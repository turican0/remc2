/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Watcom C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __noreturn sub_10000(); // weak
signed __int16 sub_10010();
unsigned int __cdecl sub_10080(int a1, int a2);
signed int __cdecl sub_10100(int a1);
signed int __cdecl sub_10130(int a1, _DWORD *a2, _DWORD *a3);
unsigned __int8 sub_101C0();
int __cdecl sub_102D0(int a1, __int16 *a2, char a3);
signed int __cdecl sub_104A0(int a1);
int (*__cdecl sub_104D0(signed __int16 *a1))();
int (*__cdecl sub_10590(char a1))();
bool __cdecl sub_10630(_WORD *a1, signed __int16 *a2, _WORD *a3, signed __int16 *a4);
bool __cdecl sub_106C0(int a1, int a2);
bool __cdecl sub_106F0(_WORD *a1, int a2, _WORD *a3, int a4);
bool __cdecl sub_10750(int a1, int a2);
int __cdecl sub_10780(int a1);
int __cdecl sub_108B0(int a1);
int __cdecl sub_10A50(int a1);
signed int __cdecl sub_10B70(unsigned __int16 *a1, char a2, char a3);
int __cdecl sub_10C40(__int16 *a1);
int __cdecl sub_10C60(__int16 *a1);
int __cdecl sub_10C80(int a1, unsigned __int8 a2, unsigned __int16 a3);
int __cdecl sub_112D0(int a1, unsigned __int16 a2);
char __cdecl sub_11400(int a1, char a2, unsigned __int16 a3);
int __cdecl sub_116A0(int a1, char a2, unsigned __int16 a3);
int __cdecl sub_11900(int a1, int a2, unsigned __int8 a3, unsigned __int16 a4);
unsigned int __cdecl sub_11960(_WORD *a1);
char __cdecl sub_11A10(_WORD *a1);
char __cdecl sub_11C80(unsigned __int16 a1);
_BOOL1 __cdecl sub_11CB0(__int16 *a1);
_BOOL1 __cdecl sub_11E20(int a1, __int16 *a2);
_BOOL1 __cdecl sub_11E70(int a1, __int16 *a2);
signed int __cdecl sub_11EE0(int a1);
__int16 __cdecl sub_12100(int a1, int a2, char a3);
int __cdecl sub_122A0(int a1);
char *__cdecl sub_122C0(__int16 a1);
int __cdecl sub_12330(int a1, __int16 a2);
char __cdecl sub_12410(int a1, char a2);
int __cdecl sub_12470(int a1, char a2);
char __cdecl sub_12500(int a1);
char *sub_12780();
char *sub_12870();
signed int __cdecl sub_12910(unsigned int a1);
signed int __cdecl sub_12A70(unsigned int a1);
signed int __cdecl sub_12E70(int a1);
signed int __cdecl sub_12FF0(int a1);
// int __cdecl _nmemneed(_DWORD); weak
signed int __cdecl sub_13100(int a1);
signed int __cdecl sub_131F0(_WORD *a1);
signed int __cdecl sub_13270(int a1);
signed int __cdecl sub_133B0(int a1);
// int __cdecl _nmemneed_0(_DWORD); weak
signed int __cdecl sub_135C0(int a1);
signed int __cdecl sub_13710(int a1);
signed int __cdecl sub_13830(int a1);
signed int __cdecl sub_13850(int a1);
int __cdecl sub_13870(int a1);
int __fastcall nullsub_1(_DWORD); // weak
signed int __cdecl sub_13890(int a1);
signed int __cdecl sub_13B00(int a1);
signed int __cdecl sub_13C50(int a1);
unsigned int __cdecl sub_13CE0(int a1);
signed int __cdecl sub_13DC0(int a1);
signed int __cdecl sub_13E40(int a1);
signed int __cdecl sub_14030(int a1);
signed int __cdecl sub_14250(int a1);
signed int __cdecl sub_14530(int a1);
signed int __cdecl sub_14630(int a1);
unsigned int __cdecl sub_146C0(int a1, unsigned __int8 a2);
signed int __cdecl sub_146F0(int a1);
unsigned int __cdecl sub_148E0(int a1);
unsigned int __cdecl sub_14B10(int a1, unsigned __int8 a2);
unsigned int __cdecl sub_14BD0(int a1, int a2);
__int16 __cdecl sub_14C40(int a1);
bool __cdecl sub_14C60(int a1, int a2);
signed int __cdecl sub_14C90(int a1, int a2, signed int a3, signed int a4);
signed int __cdecl sub_14E10(int a1, unsigned __int8 a2);
unsigned int __cdecl sub_15170(int a1, unsigned __int8 a2);
signed int __cdecl sub_155E0(int a1);
bool __cdecl sub_156F0(int a1, unsigned __int8 a2);
bool __cdecl sub_15730(int a1, unsigned __int8 a2);
unsigned int __cdecl sub_15760(int a1, unsigned __int8 a2);
char __cdecl sub_15790(int a1);
char __cdecl sub_15910(_DWORD *a1);
void sub_159E0();
// unsigned int __usercall sub_15CB0@<eax>(unsigned int a1@<edi>, int a2);
int __cdecl sub_15D20(int a1);
// char __usercall sub_15D40@<al>(__int16 a1@<di>, int a2, int a3);
_BOOL1 __cdecl sub_15E60(int a1);
char sub_15EE0();
signed int __cdecl sub_15F20(int a1, signed __int16 a2, signed int a3);
signed int __cdecl sub_15FC0(_WORD *a1);
signed int __cdecl sub_161A0(int a1);
_BOOL1 __cdecl sub_164B0(int a1);
signed int __cdecl sub_16580(int a1);
// int __usercall sub_16730@<eax>(int a1@<edx>, int a2, char a3);
char __cdecl sub_169C0(int a1);
// int __usercall sub_16CA0@<eax>(int a1@<edx>, _BYTE *a2, __int16 a3, char a4);
int __cdecl sub_16E70(unsigned __int8 *a1, unsigned __int8 *a2);
unsigned int __cdecl sub_16FC0(int a1, int a2);
__int16 __cdecl sub_17060(__int16 a1, __int16 a2);
char sub_17190();
// char __usercall sub_17A00@<al>(_BYTE *a1@<ebx>, signed int a2@<edi>, __int16 a3@<si>);
int sub_18AA0();
char sub_18B30();
int sub_18BB0();
char __cdecl sub_18DA0(int a1, char a2, char a3);
char __cdecl sub_18F80(int a1);
char __cdecl sub_191B0(__int16 a1, char a2);
int __cdecl sub_19760(char *a1, unsigned __int8 a2, __int16 a3);
int sub_197F0();
__int64 sub_19A50();
char sub_19A70();
__int64 sub_19AB0();
void __cdecl sub_19CA0(unsigned __int8 a1);
// int __usercall sub_19D60@<eax>(signed int a1@<ebx>, int a2@<esi>);
char sub_19E00();
int sub_1A030();
// void __usercall sub_1A070(signed int a1@<edi>, __int16 a2@<si>);
int sub_1A280();
int sub_1A4A0();
int __cdecl sub_1A5B0(int a1, int *a2, int *a3);
int sub_1A7A0();
int sub_1A8A0();
char __cdecl sub_1A970(char a1, int a2, int a3);
int __cdecl sub_1B280(int a1);
int sub_1B5F0();
void __cdecl sub_1B6B0(int a1);
int __cdecl sub_1B7A0(signed __int16 *a1);
int __cdecl sub_1B830(_WORD *a1);
signed int __cdecl sub_1B8C0(int a1);
signed int __cdecl sub_1BD90(int a1, char a2);
void __cdecl sub_1BF90(int a1, char a2);
signed int __cdecl sub_1C310(int a1, char a2, unsigned __int16 (__cdecl *a3)(int, int));
char __cdecl sub_1C560(int a1, unsigned __int16 a2);
int __cdecl sub_1C890(int a1, char a2);
void __cdecl sub_1C930(int a1);
int __cdecl sub_1C980(int a1, char a2);
signed int __cdecl sub_1CC20(_WORD *a1, unsigned int a2);
signed int __cdecl sub_1CCE0(_WORD *a1, unsigned int a2);
signed int __cdecl sub_1CDA0(_WORD *a1, unsigned int a2);
signed int __cdecl sub_1CE80(int a1, int a2);
signed int __cdecl sub_1CED0(int a1, int a2);
signed int __cdecl sub_1CF20(int a1, int a2);
signed int __cdecl sub_1D0E0(_WORD *a1, unsigned int a2);
signed int __cdecl sub_1D1A0(_WORD *a1, unsigned int a2);
signed int __cdecl sub_1D260(int a1, unsigned int a2);
signed int __cdecl sub_1D460(_WORD *a1, int a2);
void __cdecl sub_1D5D0(int a1, __int16 a2);
void __cdecl sub_1D700(int a1, __int16 a2);
void __cdecl sub_1D7C0(int a1, __int16 a2);
char __cdecl sub_1D880(int a1, __int16 a2);
char __cdecl sub_1D8A0(int a1, __int16 a2);
void __cdecl sub_1D8C0(int a1, __int16 a2);
int __cdecl sub_1DBF0(int a1, unsigned __int16 a2);
char __cdecl sub_1DDA0(int a1, __int16 a2);
char __cdecl sub_1E000(int a1, __int16 a2);
char __cdecl sub_1E020(int a1, __int16 a2);
int __cdecl sub_1E040(int a1, char a2);
char __cdecl sub_1E1C0(int a1, __int16 a2);
char __cdecl sub_1E320(int a1);
int __cdecl sub_1E3E0(int a1);
int __cdecl sub_1E4D0(int a1);
void __cdecl sub_1E580(int a1, __int16 a2);
void __cdecl sub_1E700(int a1, char a2);
void __cdecl sub_1E9C0(int a1, __int16 a2);
int __cdecl sub_1ED30(int a1, int a2);
signed int __cdecl sub_1EEE0(int a1);
signed int __cdecl sub_1EF20(int a1);
// int __usercall sub_1EF40@<eax>(int a1@<esi>, _WORD *a2);
// int __usercall sub_1EF70@<eax>(int a1@<esi>, _WORD *a2);
// int __usercall sub_1EFD0@<eax>(int a1@<esi>, _WORD *a2);
int __cdecl sub_1F000(int a1);
void __cdecl sub_1F020(int a1);
int __cdecl sub_1F040(_WORD *a1);
// void __usercall sub_1F0C0(int a1@<esi>, int a2);
// int __usercall sub_1F300@<eax>(int a1@<esi>, int a2);
void __cdecl sub_1F340(int a1);
void __cdecl sub_1F3C0(int a1);
void __cdecl sub_1F440(int a1);
void __cdecl sub_1F470(int a1);
int __cdecl sub_1F4F0(int a1);
void __cdecl sub_1F510(int a1);
void __cdecl sub_1F530(int a1);
__int16 __cdecl sub_1F5B0(int a1);
signed int __cdecl sub_1F630(int a1);
void __cdecl sub_1F660(int a1);
void __cdecl sub_1F6D0(int a1);
char __cdecl sub_1F800(int a1);
int __cdecl sub_1F830(int a1);
void __cdecl sub_1F850(int a1);
void __cdecl sub_1F8A0(int a1);
signed int __cdecl sub_1F950(int a1);
void __cdecl sub_1F970(int a1);
void __cdecl sub_1F990(int a1);
char __cdecl sub_1F9E0(int a1);
int __cdecl sub_1FA00(int a1);
void __cdecl sub_1FA20(int a1);
void __cdecl sub_1FA50(int a1);
char __cdecl sub_1FA70(int a1);
char __cdecl sub_1FAA0(int a1);
unsigned int __cdecl sub_1FF40(int a1);
char __cdecl sub_1FFE0(int a1);
int __cdecl sub_20010(int a1);
void __cdecl sub_20040(int a1);
char __cdecl sub_20060(int a1);
_WORD *__cdecl sub_200F0(int a1);
void __cdecl sub_20140(int a1);
int __cdecl sub_20370(int a1);
void __cdecl sub_203D0(int a1);
void __cdecl sub_20940(int a1);
void __cdecl sub_20C50(int a1);
char __cdecl sub_20E50(int a1);
int __cdecl sub_20E80(int a1);
void __cdecl sub_20EA0(int a1);
char __cdecl sub_20EC0(int a1);
int __cdecl sub_20F20(int a1);
int __cdecl sub_20F60(int a1);
int __cdecl sub_20F80(int a1);
void __cdecl sub_20FC0(int a1);
__int16 __cdecl sub_21030(int a1);
char __cdecl sub_21490(int a1);
void __cdecl sub_21850(int a1);
void __cdecl sub_21AB0(int a1);
char __cdecl sub_21F60(int a1);
char __cdecl sub_22190(int a1);
char __cdecl sub_221F0(int a1, __int16 a2);
__int16 __cdecl sub_22270(int a1);
__int16 __cdecl sub_222B0(int a1);
unsigned int sub_223E0();
char __cdecl sub_22490(unsigned __int16 *a1);
int __cdecl sub_22530(int a1);
int __cdecl sub_22540(int a1);
int __cdecl sub_22550(int a1);
int __cdecl sub_22560(int a1);
void __cdecl sub_22580(int a1);
int __cdecl sub_225A0(int a1);
int __cdecl sub_225B0(int a1);
_BOOL1 __cdecl sub_22640(_WORD *a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4);
_WORD *__cdecl sub_226D0(unsigned __int16 a1, _WORD *a2, _WORD *a3);
char __cdecl sub_22760(int a1);
char __cdecl sub_22C80(int a1);
char __cdecl sub_22E60(int a1);
char __cdecl sub_23020(int a1);
int __cdecl sub_231E0(int a1);
void __cdecl sub_23200(int a1);
__int16 __cdecl sub_23260(int a1);
char __cdecl sub_232A0(int a1);
char sub_232C0();
char __cdecl sub_23320(int a1);
char __cdecl sub_23340(int a1);
char __cdecl sub_23640(int a1);
char __cdecl sub_23660(int a1);
int __cdecl sub_23680(int a1);
void __cdecl sub_236F0(int a1);
__int16 __cdecl sub_23710(int a1);
__int16 __cdecl sub_23750(int a1);
char __cdecl sub_23790(int a1);
char __cdecl sub_237B0(int a1);
char __cdecl sub_23AC0(int a1);
char __cdecl sub_23AE0(int a1);
int __cdecl sub_23B00(int a1);
void __cdecl sub_23B30(int a1);
__int16 __cdecl sub_23B90(int a1);
__int16 __cdecl sub_23BD0(int a1);
signed int __cdecl sub_23C20(int a1);
void __cdecl sub_23C40(int a1);
void __cdecl sub_23E60(int a1);
char __cdecl sub_240A0(int a1);
int __cdecl sub_240C0(int a1);
void __cdecl sub_240E0(int a1);
int __cdecl sub_24100(_WORD *a1);
int __cdecl sub_24150(_WORD *a1);
signed int __cdecl sub_24190(int a1);
void __cdecl sub_24400(int a1);
signed int __cdecl sub_24420(int a1);
void __cdecl sub_24440(int a1);
__int16 __cdecl sub_24510(int a1);
char __cdecl sub_247D0(int a1);
int __cdecl sub_247F0(int a1);
void __cdecl sub_24810(int a1);
void __cdecl sub_24840(int a1);
unsigned int __cdecl sub_24860(int a1);
void __cdecl sub_248C0(int a1);
__int16 __cdecl sub_24930(int a1);
char __cdecl sub_24D40(int a1);
int __cdecl sub_24DA0(int a1);
void __cdecl sub_24DC0(int a1);
void __cdecl sub_24DF0(int a1);
int __cdecl sub_24E20(int a1);
int __cdecl sub_25050(int a1);
__int16 __cdecl sub_250B0(int a1);
// int __usercall sub_25280@<eax>(int a1@<eax>, int a2);
int __cdecl sub_252A0(int a1);
void __cdecl sub_252C0(int a1);
unsigned int __cdecl sub_252E0(int a1);
// int __usercall sub_253B0@<eax>(int result@<eax>, int a2, unsigned __int8 a3, unsigned __int8 a4);
int __cdecl sub_254E0(int a1, int a2, unsigned __int8 a3);
int __cdecl sub_25550(int a1);
signed int __cdecl sub_25590(int a1);
void __cdecl sub_255C0(int a1);
void __cdecl sub_25610(int a1);
char __cdecl sub_25CD0(int a1);
int __cdecl sub_25D00(int a1);
void __cdecl sub_25D20(int a1);
void __cdecl sub_25D50(int a1);
unsigned int __cdecl sub_25D80(int a1);
void __cdecl sub_25DE0(int a1);
void __cdecl sub_25E40(int a1);
char __cdecl sub_25F70(int a1);
int __cdecl sub_25FD0(int a1);
void __cdecl sub_25FF0(int a1);
void __cdecl sub_26020(int a1);
int __cdecl sub_26050(int a1);
char __cdecl sub_26070(int a1);
// unsigned int __usercall sub_26220@<eax>(unsigned int a1@<esi>, int a2);
int __cdecl sub_263C0(int a1);
int __cdecl sub_263E0(int a1);
void __cdecl sub_26400(int a1);
int __cdecl sub_26470(_BYTE *a1);
// int __usercall sub_26500@<eax>(int result@<eax>, int a2);
int __cdecl sub_265A0(int a1);
signed int __cdecl sub_26830(int a1);
int __cdecl sub_268F0(int a1, unsigned __int8 a2);
char __cdecl sub_26930(int a1);
void __cdecl sub_26960(int a1);
int __cdecl sub_26990(int a1);
void __cdecl sub_26AA0(int a1);
void __cdecl sub_26BD0(int a1);
int __cdecl sub_26CA0(int a1);
int __cdecl sub_26CC0(int a1);
int __cdecl sub_26D20(int a1);
int __cdecl sub_26F10(int a1);
__int16 __cdecl sub_26FF0(int a1);
int __cdecl sub_27120(int a1);
signed int __cdecl sub_271D0(int a1);
char __cdecl sub_272C0(int a1);
int __cdecl sub_273C0(__int16 a1, char a2, __int16 a3, __int16 a4);
int __cdecl sub_27430(int a1);
int __cdecl sub_27470(int a1, __int16 a2);
int __cdecl sub_274C0(int a1, int a2, _WORD *a3, __int16 a4);
// int __usercall sub_27590@<eax>(signed int a1@<ebx>, int a2);
// int __usercall sub_27610@<eax>(signed int a1@<ebx>, int a2);
signed int __cdecl sub_276E0(signed int a1);
void __cdecl sub_27720(int a1, signed __int16 a2);
void __cdecl sub_27880(int a1);
int __cdecl sub_278F0(int a1, __int16 a2, __int16 a3);
void __cdecl sub_27930(int a1);
char __cdecl sub_27950(int a1);
char __cdecl sub_27B20(int a1);
char __cdecl sub_27C10(int a1);
char __cdecl sub_27E00(int a1);
int __cdecl sub_27FA0(int a1);
void __cdecl sub_27FC0(int a1);
int __cdecl sub_27FE0(int a1, char a2, char a3, int a4);
unsigned int __cdecl sub_28000(int a1);
char __cdecl sub_28060(int a1);
char __cdecl sub_28110(int a1);
unsigned int __cdecl sub_282D0(int a1);
char __cdecl sub_28390(_WORD *a1, int a2);
int __cdecl sub_28420(int a1);
void __cdecl sub_28470(int a1);
int __cdecl sub_28490(int a1);
int __cdecl sub_28500(int a1);
int __cdecl sub_28570(int a1);
signed int __cdecl sub_285D0(int a1);
int __cdecl sub_285F0(int a1);
void __cdecl sub_28610(int a1);
int __cdecl sub_28630(int a1);
int __cdecl sub_28660(int a1);
void __cdecl sub_28690(int a1);
int __cdecl sub_287B0(int a1);
__int16 __cdecl sub_28860(int a1);
int __cdecl sub_28C30(int a1);
signed int __cdecl sub_28C60(int a1);
int __cdecl sub_28CC0(int a1);
int __cdecl sub_28CE0(int a1);
void __cdecl sub_28EC0(int a1);
void __cdecl sub_28F50(int a1);
int __cdecl sub_28F90(int a1);
int __cdecl sub_28FC0(int a1);
int __cdecl sub_28FF0(int a1);
int __cdecl sub_29300(int a1);
int __cdecl sub_29330(int a1);
void __cdecl sub_29350(int a1);
int __cdecl sub_29380(int a1);
int __cdecl sub_293B0(int a1);
int __cdecl sub_293D0(int a1);
__int16 __cdecl sub_29400(int a1);
__int16 __cdecl sub_29670(int a1);
__int16 __cdecl sub_29710(int a1);
__int16 __cdecl sub_29890(int a1);
int __cdecl sub_298B0(int a1);
int __cdecl sub_298D0(unsigned int a1);
__int16 __cdecl sub_29930(int a1);
__int16 __cdecl sub_29A90(int a1);
// char __usercall sub_2A340@<al>(int a1@<eax>, int a2@<edx>, int a3@<edi>, int a4@<esi>, int a5, int a6);
signed int __cdecl sub_2A5B0(int a1, int a2, __int16 a3);
int __cdecl sub_2A660(int a1, int a2);
signed int __cdecl sub_2A6B0(int a1);
unsigned int __cdecl sub_2A6F0(int a1);
int __cdecl sub_2A7B0(int a1);
void __cdecl sub_2A7F0(int a1, int a2, char a3);
signed int __cdecl sub_2A940(signed int a1, int a2);
signed int __cdecl sub_2A9F0(int a1, int a2);
// unsigned __int16 __usercall sub_2AA90@<ax>(int a1@<ebx>, int a2, int a3);
_WORD *__cdecl sub_2AC50(int a1);
unsigned __int16 __cdecl sub_2AD40(signed int a1);
int __cdecl sub_2AE30(int a1);
int __cdecl sub_2AE80(unsigned int a1);
char __cdecl sub_2AED0(int a1, int a2);
char __cdecl sub_2AF10(int a1, char a2);
signed int __cdecl sub_2B1D0(int a1);
void __cdecl sub_2B200(int a1);
char __cdecl sub_2B260(int a1);
int __cdecl sub_2B750(int a1);
int __cdecl sub_2B760(int a1);
void __cdecl sub_2B780(int a1);
void __cdecl sub_2B7B0(int a1);
char __cdecl sub_2B7E0(int a1);
int __cdecl sub_2B840(int a1);
char __cdecl sub_2B860(int a1, unsigned __int8 a2);
signed int __cdecl sub_2B9A0(int a1);
unsigned __int8 __cdecl sub_2BA50(int a1, unsigned __int8 a2);
// int _wcpp_1_unwind_leave__62(void); weak
int __cdecl sub_2BB40(__int16 a1, __int16 a2, int a3);
int __cdecl sub_2BBB0(__int16 a1, __int16 a2, int a3);
int __cdecl sub_2BC10(_BYTE *a1, __int16 a2, __int16 a3, unsigned __int8 a4);
int __cdecl sub_2BC80(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5);
int __cdecl sub_2BD10(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5);
int sub_2BE30();
int __cdecl sub_2CA60(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
int __cdecl sub_2CA90(__int16 a1);
__int16 __cdecl sub_2CB30(_DWORD *a1, __int16 a2, int a3, __int16 a4);
int __cdecl sub_2CE30(int a1, int a2);
int __cdecl sub_2D190(__int16 a1, __int16 a2, int a3, __int16 a4, int a5, unsigned __int8 a6);
int sub_2D1D0();
int __cdecl sub_2D710(int a1);
char __cdecl sub_2DE80(__int16 a1, __int16 a2, int a3);
char __cdecl sub_2DFD0(__int16 a1, __int16 a2, int a3, unsigned __int8 a4);
void __cdecl sub_2E260(__int16 a1, __int16 a2, unsigned int a3, char a4);
int __cdecl sub_2E790(__int16 a1, int a2, int a3, int a4, unsigned __int8 a5);
int __cdecl sub_2E850(__int16 a1, int a2, int a3, int a4, unsigned __int8 a5);
int sub_2EB40();
int sub_2EB60();
int __cdecl sub_2EBB0(_BYTE *a1);
int sub_2EC30();
int sub_2EC60();
char __cdecl sub_2EC90(char a1);
__int16 sub_2ECC0();
int sub_2F6B0();
char sub_2FD90();
int *__cdecl sub_2FFE0(int *a1, int *a2, _DWORD *a3, _DWORD *a4);
int sub_30050();
// int __usercall sub_303D0@<eax>(signed int a1@<edi>);
int sub_30630();
char sub_30870();
int __cdecl sub_30A60(__int16 a1, __int16 a2);
_DWORD *__cdecl sub_30BE0(_DWORD *a1, _DWORD *a2);
void __cdecl sub_30D50(int a1);
int __cdecl sub_30F60(int a1);
int __cdecl sub_31100(int a1);
int __cdecl sub_31120(int a1);
char __cdecl sub_311E0(int a1);
char __cdecl sub_31760(int a1);
int __cdecl sub_31870(int a1);
int __cdecl sub_31890(int a1);
void __cdecl sub_318B0(int a1);
int __cdecl sub_31920(int a1);
char __cdecl sub_31940(int a1);
int __cdecl sub_31E90(signed __int16 *a1);
unsigned int __cdecl sub_31F00(signed __int16 *a1, __int16 a2, __int16 a3);
void __cdecl sub_31FB0(int a1);
int __cdecl sub_320E0(int a1);
int __cdecl sub_32120(int a1);
int __cdecl sub_32160(int a1);
int __cdecl sub_322A0(int a1);
char __cdecl sub_323E0(int a1);
char __cdecl sub_32400(int a1);
char __cdecl sub_32420(int a1);
int __cdecl sub_32530(int a1);
__int16 __cdecl sub_32600(int a1);
int __cdecl sub_32880(int a1);
void __cdecl sub_32A70(int a1);
void __cdecl sub_32CF0(int a1);
int __cdecl sub_32F40(int a1);
void __cdecl sub_33110(unsigned int a1);
_WORD *__cdecl sub_331A0(int a1);
void __cdecl sub_33340(_WORD *a1);
void __cdecl sub_33710(int a1);
char __cdecl sub_33810(int a1, int a2);
unsigned int __cdecl sub_338D0(unsigned int a1);
char __cdecl sub_339B0(int a1);
int __cdecl sub_33AD0(int a1);
__int16 __cdecl sub_33B20(int a1);
int __cdecl sub_33C00(int a1);
int __cdecl sub_33C70(int a1);
int __cdecl sub_33D40(int a1);
void __cdecl sub_33D80(int a1);
void __cdecl sub_33E20(int a1);
int __cdecl sub_33E80(int a1);
_BOOL1 __cdecl sub_33F70(unsigned __int16 a1);
int __cdecl sub_34000(int a1);
int __cdecl sub_34110(_WORD *a1);
int __cdecl sub_34210(_WORD *a1);
int __cdecl sub_34330(int a1);
int __cdecl sub_34350(int a1);
int __cdecl sub_34390(int a1);
int __cdecl sub_343C0(int a1);
int __cdecl sub_343F0(_WORD *a1);
int __cdecl sub_34480(int a1);
_WORD *__cdecl sub_344A0(int a1);
int __cdecl sub_34520(int a1);
int __cdecl sub_34540(int a1);
int __cdecl sub_34910(int a1);
int __cdecl sub_34B00(char a1, char a2, __int16 a3, __int16 a4);
char __cdecl sub_34C40(int a1);
// void __usercall sub_34EE0(signed int a1@<edi>, int a2@<esi>, int a3);
int __cdecl sub_352A0(int a1);
_WORD *__cdecl sub_352C0(int a1);
void __cdecl sub_35390(int a1);
unsigned int __cdecl sub_35530(int a1);
int __cdecl sub_35600(int a1);
void __cdecl sub_35640(int a1);
int __cdecl sub_357C0(int a1);
void __cdecl sub_35940(int a1);
int sub_365F8(); // weak
char __cdecl sub_36680(int a1);
void __cdecl sub_36770(_WORD *a1);
char __cdecl sub_36850(int a1);
// char __usercall sub_36920@<al>(signed __int16 a1@<bx>, int a2);
// signed int __usercall sub_369F0@<eax>(signed int a1@<ebx>, __int16 a2);
// signed int __usercall sub_36A50@<eax>(signed int a1@<ebx>, char a2);
int __cdecl sub_36AE0(__int16 *a1);
void __cdecl sub_36BA0(int a1, char a2);
int __cdecl sub_36D50(int a1, int a2);
int __cdecl sub_36F30(int a1, int a2);
char __cdecl sub_36FC0(int a1);
void __cdecl sub_37240(int a1);
char __cdecl sub_37740(int a1);
void __cdecl sub_377A0(int a1);
__int16 __cdecl sub_377F0(int a1);
__int16 __cdecl sub_37BC0(int a1);
int __cdecl sub_38270(int a1);
int __cdecl sub_38330(int a1);
int __cdecl sub_385C0(int a1);
int __cdecl sub_389F0(int a1);
signed int __cdecl sub_38B00(int a1);
int __cdecl sub_38B90(int a1);
unsigned int __cdecl sub_38D80(int a1);
int __cdecl sub_38E20(int a1);
int __cdecl sub_38E40(int a1);
int __cdecl sub_38E70(int a1);
int __cdecl sub_38F70(_WORD *a1);
char __cdecl sub_39040(int a1);
int __cdecl sub_396A0(int a1);
unsigned __int8 __cdecl sub_396D0(int a1);
int __cdecl sub_39B60(int a1);
char __cdecl sub_39E40(int a1);
char __cdecl sub_39FA0(int a1, int a2);
void __cdecl sub_3A090(unsigned __int16 *a1);
void __cdecl sub_3A200(int a1, int a2);
void __cdecl sub_3A2D0(int a1);
void __cdecl sub_3A5B0(int a1);
int __cdecl sub_3A630(int a1);
int __cdecl sub_3A650(int a1);
char __cdecl sub_3A7F0(_BYTE *a1);
char __cdecl sub_3A8B0(int a1);
int __cdecl sub_3AF00(int a1);
int *__cdecl sub_3B4D0(int a1);
_DWORD *__cdecl sub_3B560(__int16 a1);
// char __usercall sub_3C080@<al>(int a1@<ebx>, int a2@<esi>, __int16 a3, __int16 a4, __int16 a5, signed int a6, int a7, __int16 a8, int a9);
// unsigned __int16 __usercall sub_3E360@<ax>(int a1@<esi>, int a2);
// unsigned __int16 __usercall sub_3FD60@<ax>(int a1@<edi>, int a2);
__int16 __cdecl sub_40950(__int16 a1);
int __cdecl sub_40BF0(int a1, int a2, int a3, int a4);
int __cdecl sub_40C50(int a1);
int __fastcall sub_40D10(int a1);
void sub_40F80();
char __cdecl sub_411A0(int a1, int a2, int a3, __int16 a4, signed int a5, int a6, __int16 a7, int a8);
__int16 sub_417A0();
__int16 sub_417D0();
char __cdecl sub_41A90(unsigned __int8 *a1);
char sub_41AF0();
char sub_41B60();
__int64 sub_41BC0();
__int16 __cdecl sub_41BD3(unsigned int a1);
// int __usercall sub_43830@<eax>(unsigned int a1@<esi>, int a2);
// unsigned int __usercall sub_43970@<eax>(unsigned int a1@<esi>);
// unsigned int __usercall sub_439A0@<eax>(unsigned int a1@<esi>, unsigned __int16 a2);
__int16 sub_43B40();
__int16 sub_43BB0();
void __cdecl sub_43C60(unsigned __int8 a1, char a2, int a3, int a4);
unsigned __int16 sub_43D50();
unsigned __int16 sub_43EE0();
unsigned __int16 sub_43FC0();
unsigned __int16 __cdecl sub_440D0(unsigned __int16 a1);
unsigned __int16 sub_44320();
__int16 sub_44580();
int sub_44D00();
int sub_44DB0();
unsigned __int16 __cdecl sub_44E40(int a1, unsigned __int8 a2);
// unsigned __int16 __usercall sub_44EE0@<ax>(int a1@<ebx>, int a2);
unsigned __int8 __cdecl sub_45060(unsigned __int8 a1, unsigned __int8 a2);
char __cdecl sub_45210(unsigned __int8 a1, unsigned __int8 a2);
unsigned __int16 __cdecl sub_454F0(unsigned __int8 a1, unsigned __int8 a2);
unsigned __int16 __cdecl sub_45600(unsigned __int8 a1);
unsigned __int16 sub_45AA0();
// char __usercall sub_45BE0@<al>(char a1@<dl>, char a2@<cl>, unsigned __int16 a3);
// char __usercall sub_45DC0@<al>(char a1@<dl>, char a2@<cl>, unsigned __int16 a3, unsigned __int8 a4);
unsigned __int16 __cdecl sub_46180(unsigned __int16 a1, char a2);
char __cdecl sub_462A0(unsigned __int16 a1, __int16 a2);
char __cdecl sub_46570(unsigned __int16 a1, __int16 a2);
int sub_46820();
// int __usercall sub_46830@<eax>(signed __int16 *a1@<ebx>, signed int a2@<edi>, unsigned __int16 a3@<si>);
void sub_46B40();
char __fastcall sub_46DD0(int a1, int a2, int a3);
void sub_46F50();
char *sub_46F80();
void sub_47130();
char *sub_47160();
// int __usercall sub_47320@<eax>(signed int a1@<edi>);
int sub_473B0();
int sub_473E0();
// void __usercall sub_47560(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebx>, signed int a4@<edi>, __int16 a5@<si>);
int __fastcall sub_47650(int a1, int a2);
char __fastcall sub_47760(int a1, int a2, int a3);
int __cdecl sub_47FC0(char a1);
unsigned __int8 __fastcall sub_480A0(int a1, int a2, int a3);
unsigned __int8 sub_48120();
int sub_48350();
int __cdecl sub_48370(__int16 a1, __int16 a2, __int16 a3);
int __cdecl sub_483A0(__int16 a1, int a2, char a3, char a4);
int __cdecl sub_48400(int a1, int a2, int a3, int a4);
int __cdecl sub_48690(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
int __cdecl sub_487D0(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4, char a5);
int __cdecl sub_48880(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4);
int sub_48930(); // weak
int __cdecl sub_48990(char a1, char a2, char a3, char a4);
// __int16 __usercall sub_48A20@<ax>(int a1@<edi>, char a2, char a3, int a4, int a5, unsigned __int8 a6);
__int16 __cdecl sub_48B50(unsigned __int8 a1, char a2, int a3, int a4);
__int16 __cdecl sub_48B90(int a1);
__int16 __cdecl sub_48D20(int a1, unsigned __int16 a2);
__int16 __cdecl sub_48DF0(char a1, char a2, char a3, char a4);
signed int __cdecl sub_48E60(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4);
signed int __cdecl sub_48E90(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4);
signed int __cdecl sub_48EC0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4);
signed int __cdecl sub_48EF0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4);
signed int __cdecl sub_48F20(char a1, char a2, __int16 a3, unsigned __int16 a4, int a5);
signed int __cdecl sub_48FD0(char a1, char a2, __int16 a3, unsigned __int16 a4, int a5);
void __cdecl sub_49090(int a1, _WORD *a2);
int __cdecl sub_49270(int a1);
int __cdecl sub_49290(int a1, char a2);
void __cdecl sub_49540(int a1, int a2);
int __cdecl sub_49830(int a1);
int sub_498A0();
int __cdecl sub_49A20(int a1);
__int16 __cdecl sub_49A30(int a1, unsigned __int16 a2);
int __cdecl sub_49C70(int a1);
char __cdecl sub_49C90(int a1, __int16 a2);
int __cdecl sub_49CD0(_WORD *a1, __int16 a2);
int __cdecl sub_49D50(int a1, __int16 a2);
int __cdecl sub_49DA0(_WORD *a1, __int16 a2);
int __cdecl sub_49E10(_WORD *a1, __int16 a2);
_WORD *__cdecl sub_49EA0(_WORD *a1, __int16 a2, __int16 a3);
unsigned int __cdecl sub_49EC0(_WORD *a1, __int16 a2);
signed int sub_49F30();
int sub_49F90();
int sub_4A050();
int __cdecl sub_4A190(int a1, int a2, int a3);
int __cdecl sub_4A1E0(int a1, char a2);
int __cdecl sub_4A310(unsigned __int16 *a1);
int sub_4A810();
int __cdecl sub_4A820(int a1);
int __cdecl sub_4A840(int a1);
int __cdecl sub_4A860(int a1);
int __cdecl sub_4A880(int a1);
int __cdecl sub_4A8A0(int a1);
int __cdecl sub_4A8C0(int a1);
int __cdecl sub_4A8E0(int a1);
int __cdecl sub_4A900(int a1);
_WORD *__cdecl sub_4A920(int a1);
_WORD *__cdecl sub_4A9C0(int a1);
int __cdecl sub_4AA40(int a1);
int __cdecl sub_4ABA0(int a1);
int __cdecl sub_4AC40(int a1);
_WORD *__cdecl sub_4AD70(int a1);
_WORD *__cdecl sub_4ADF0(int a1);
_WORD *__cdecl sub_4AE80(int a1);
_WORD *__cdecl sub_4AF00(int a1);
_WORD *__cdecl sub_4AF70(int a1);
int __cdecl sub_4AFE0(int a1);
int __cdecl sub_4B0F0(int a1);
int __cdecl sub_4B120(int a1);
int __cdecl sub_4B150(int a1, char a2, char a3, __int16 a4);
_DWORD *__cdecl sub_4B240(int a1);
int __cdecl sub_4B490(int a1);
int __cdecl sub_4B590(int a1);
int __cdecl sub_4B6F0(int a1);
int __cdecl sub_4BA10(int a1);
int __cdecl sub_4BBB0(int a1);
int __cdecl sub_4BD00(int a1);
int __cdecl sub_4BDF0(int a1);
_WORD *__cdecl sub_4BF40(int a1);
int __cdecl sub_4C0B0(int a1);
int __cdecl sub_4C1E0(int a1);
int __cdecl sub_4C310(int a1);
int __cdecl sub_4C460(int a1);
int __cdecl sub_4C590(int a1);
int __cdecl sub_4C6B0(int a1);
int __cdecl sub_4C7F0(int a1);
int __cdecl sub_4C8F0(int a1);
int __cdecl sub_4CA00(int a1);
signed int __cdecl sub_4CB60(int a1);
int __cdecl sub_4CBF0(int a1);
int __cdecl sub_4CCF0(int a1);
int __cdecl sub_4CE00(int a1);
int __cdecl sub_4CF00(int a1);
// unsigned int __usercall sub_4D000@<eax>(unsigned int a1@<esi>, int a2);
int __cdecl sub_4D1D0(int a1);
int __cdecl sub_4D2E0(int a1);
int __cdecl sub_4D380(int a1);
int __cdecl sub_4D3B0(int a1);
int __cdecl sub_4D470(int a1);
int __cdecl sub_4D500(int a1);
int __cdecl sub_4D590(int a1);
int __cdecl sub_4D620(int a1);
int __cdecl sub_4D6B0(int a1);
int __cdecl sub_4D740(int a1);
int __cdecl sub_4D7D0(int a1);
int __cdecl sub_4D860(int a1);
int __cdecl sub_4D900(int a1);
int __cdecl sub_4D990(int a1);
int __cdecl sub_4DA20(int a1);
_WORD *__cdecl sub_4DAB0(int a1);
_WORD *__cdecl sub_4DBC0(int a1);
_WORD *__cdecl sub_4DC40(int a1);
_WORD *__cdecl sub_4DCC0(int a1);
_WORD *__cdecl sub_4DD50(int a1);
int __cdecl sub_4DDD0(int a1);
int __cdecl sub_4DEA0(int a1);
int __cdecl sub_4DF30(int a1);
int __cdecl sub_4DFC0(int a1);
int __cdecl sub_4E050(int a1);
int __cdecl sub_4E0F0(int a1);
int __cdecl sub_4E180(int a1);
int __cdecl sub_4E210(int a1);
int __cdecl sub_4E2A0(int a1);
_WORD *__cdecl sub_4E320(int a1);
_WORD *__cdecl sub_4E3B0(int a1);
int __cdecl sub_4E430(int a1);
int __cdecl sub_4E490(int a1);
int __cdecl sub_4E500(int a1);
int __cdecl sub_4E570(int a1);
int __cdecl sub_4E5F0(__int16 *a1);
int __cdecl sub_4E6A0(__int16 *a1);
int __cdecl sub_4E760(int a1);
_WORD *__cdecl sub_4E7D0(int a1);
int __cdecl sub_4E840(int a1);
int __cdecl sub_4E8C0(int a1);
int __cdecl sub_4E950(int a1);
int __cdecl sub_4E9E0(int a1);
int __cdecl sub_4EA20(int a1);
int __cdecl sub_4EA60(int a1);
int __cdecl sub_4EAA0(int a1, char a2, char a3, __int16 a4, int a5);
int __cdecl sub_4EB50(int a1);
int __cdecl sub_4EC10(int a1);
int __cdecl sub_4ECD0(int a1);
int __cdecl sub_4ED70(int a1);
int __cdecl sub_4EDC0(__int16 *a1);
int __cdecl sub_4EED0(int a1);
int __cdecl sub_4EF30(int a1);
int __cdecl sub_4EF90(int a1);
_WORD *__cdecl sub_4F040(int a1);
unsigned __int16 __cdecl sub_4F1C0(_WORD *a1);
_WORD *__cdecl sub_4F2A0(int a1);
__int16 __cdecl sub_4F440(int a1);
int __cdecl sub_4F5F0(int a1);
_WORD *__cdecl sub_4F6A0(int a1);
_WORD *__cdecl sub_4F720(int a1);
int __cdecl sub_4F7A0(int a1);
int __cdecl sub_4F800(int a1);
int __cdecl sub_4F860(int a1);
int __cdecl sub_4F8B0(int a1);
int __cdecl sub_4F900(int a1);
int __cdecl sub_4F950(int a1);
int __cdecl sub_4F9A0(int a1);
int __cdecl sub_4FA00(int a1);
int __cdecl sub_4FA60(int a1);
int __cdecl sub_4FAC0(int a1);
int __cdecl sub_4FB20(int a1);
int __cdecl sub_4FB80(int a1);
int __cdecl sub_4FBE0(int a1);
int __cdecl sub_4FC30(int a1);
int __cdecl sub_4FCA0(int a1);
int __cdecl sub_4FCD0(int a1);
int __cdecl sub_4FD00(int a1);
int __cdecl sub_4FD70(int a1);
int __cdecl sub_4FDE0(int a1);
_WORD *__cdecl sub_4FE40(int a1);
int sub_4FF20();
_WORD *__cdecl sub_4FF30(int a1);
int __cdecl sub_4FFB0(int a1);
_WORD *__cdecl sub_50020(int a1);
int __cdecl sub_50080(int a1);
int __cdecl sub_500A0(int a1);
int __cdecl sub_500C0(int a1, __int16 a2);
int __cdecl sub_50130(int a1);
_WORD *__cdecl sub_501D0(int a1);
_WORD *__cdecl sub_50250(int a1);
_WORD *__cdecl sub_502B0(int a1);
int __cdecl sub_50320(int a1);
int __cdecl sub_50370(int a1);
_WORD *__cdecl sub_503D0(int a1);
_WORD *__cdecl sub_50430(int a1);
int __cdecl sub_504B0(int a1);
int __cdecl sub_50500(int a1);
int __cdecl sub_505A0(int a1);
int __cdecl sub_505E0(int a1);
int __cdecl sub_50640(int a1);
int __cdecl sub_506E0(int a1);
int __cdecl sub_50780(int a1);
int __cdecl sub_507C0(int a1);
_BYTE *sub_50800();
_WORD *__cdecl sub_50840(int a1);
int __cdecl sub_508E0(int a1);
int __cdecl sub_50960(int a1);
int __cdecl sub_50A20(int a1);
int __cdecl sub_50A90(int a1, char a2, char a3);
int __cdecl sub_50AE0(int a1);
int __cdecl sub_50B00(int a1);
int __cdecl sub_50B20(int a1);
int __cdecl sub_50B40(int a1);
int __cdecl sub_50B60(int a1);
int __cdecl sub_50B80(int a1);
int __cdecl sub_50C10(int a1);
int __cdecl sub_50C30(int a1);
int __cdecl sub_50C50(int a1);
int __cdecl sub_50C70(int a1);
int __cdecl sub_50C90(int a1);
int __cdecl sub_50CB0(int a1);
int __cdecl sub_50CD0(int a1);
int __cdecl sub_50CF0(int a1);
int __cdecl sub_50D10(int a1);
int __cdecl sub_50D30(int a1);
int __cdecl sub_50D50(int a1);
int __cdecl sub_50D70(int a1);
int __cdecl sub_50D90(int a1);
int __cdecl sub_50DB0(int a1);
int __cdecl sub_50DD0(int a1);
int __cdecl sub_50DF0(int a1);
int __cdecl sub_50E10(int a1);
int __cdecl sub_50E30(int a1);
int __cdecl sub_50E50(int a1);
int __cdecl sub_50E70(int a1);
int __cdecl sub_50E90(int a1);
int __cdecl sub_50EB0(int a1);
int __cdecl sub_50ED0(int a1);
int __cdecl sub_50EF0(int a1);
int __cdecl sub_50F10(int a1);
int __cdecl sub_50F30(int a1);
int __cdecl sub_50F50(int a1);
int __cdecl sub_50F70(int a1);
int __cdecl sub_50F90(int a1);
int __cdecl sub_50FB0(int a1);
int __cdecl sub_50FD0(int a1);
int __cdecl sub_50FF0(int a1);
int __cdecl sub_51120(int a1, char a2, char a3);
int __cdecl sub_511A0(int a1);
int __cdecl sub_511C0(int a1);
int __cdecl sub_511E0(int a1);
int __cdecl sub_51200(int a1);
int __cdecl sub_51220(int a1);
int __cdecl sub_51240(int a1);
int __cdecl sub_51260(int a1);
int __cdecl sub_51280(int a1);
int __cdecl sub_512A0(int a1);
int __cdecl sub_512C0(int a1);
int __cdecl sub_512E0(int a1);
int __cdecl sub_51300(int a1);
int __cdecl sub_51320(int a1);
int __cdecl sub_51340(int a1);
int __cdecl sub_51360(int a1);
int __cdecl sub_51380(int a1);
int __cdecl sub_513A0(int a1);
int __cdecl sub_513C0(int a1);
int __cdecl sub_513E0(int a1);
int __cdecl sub_51400(int a1);
int __cdecl sub_51420(int a1);
int __cdecl sub_51440(int a1);
int __cdecl sub_51460(int a1);
int __cdecl sub_51480(int a1);
int __cdecl sub_514A0(int a1);
int __cdecl sub_514C0(int a1);
int __cdecl sub_514E0(int a1, char a2, char a3, __int16 a4);
_WORD *__cdecl sub_51530(int a1);
int __cdecl sub_51570(int a1);
int __cdecl sub_515C0(int a1);
_WORD *__cdecl sub_51610(int a1);
int __cdecl sub_51660(int a1);
int __cdecl sub_516C0(int a1);
int __cdecl sub_51730(int a1);
_BYTE *__cdecl sub_51790(int a1);
_WORD *__cdecl sub_51800(int a1);
_BYTE *__cdecl sub_51A00(int a1);
// int __usercall sub_51BB0@<eax>(int a1@<edi>);
char __cdecl sub_52D70(unsigned __int16 a1, char *a2);
char __cdecl sub_52E90(int a1, signed int a2, char a3);
char sub_53120();
int sub_53160();
char __cdecl sub_533B0(__int16 a1, void *a2);
int __cdecl sub_53590(int a1);
char __cdecl sub_53770(__int16 a1);
char __cdecl sub_53950(__int16 a1);
char sub_539A0();
void __cdecl sub_53A40(char *a1);
int sub_53C70();
int sub_53CA0();
int sub_53CC0();
int __cdecl sub_53CF0(int a1);
char __cdecl sub_53D10(unsigned __int8 a1, int a2, char *a3);
int __cdecl sub_53E60(int a1, char *a2);
int __cdecl sub_53EF0(int a1, int a2);
bool __cdecl sub_53F60(int a1);
char __cdecl sub_53F80(int a1, int a2, int a3);
char sub_54200();
int sub_54600();
__int16 __cdecl sub_54630(__int16 a1);
int __cdecl sub_54660(unsigned __int8 a1, int a2);
char __cdecl sub_54800(unsigned __int8 a1);
__int16 __cdecl sub_548B0(__int16 *a1);
_WORD *__cdecl sub_548F0(_WORD *a1);
int sub_54960();
signed int __cdecl sub_549A0(int a1, int a2);
int __cdecl sub_54A50(unsigned __int16 a1, int a2);
char __cdecl sub_54D30(__int16 a1);
char __cdecl sub_54F00(__int16 a1);
char __cdecl sub_55080(unsigned __int8 a1, int a2);
int __cdecl sub_55100(char a1);
char __cdecl sub_55250(unsigned __int8 a1);
_BOOL1 __cdecl sub_55320(unsigned __int8 a1);
char __cdecl sub_55450(unsigned __int8 a1, int a2);
char __cdecl sub_555D0(unsigned __int8 a1, int a2);
char __cdecl sub_55750(unsigned __int8 a1, int a2);
_BOOL1 __cdecl sub_558E0(unsigned __int8 a1);
char __cdecl sub_55A10(unsigned __int8 a1);
int __cdecl sub_55AB0(int a1, int a2);
char __cdecl sub_55C00(__int16 a1);
// unsigned int __usercall sub_55C60@<eax>(int a1@<edi>, int a2@<esi>, int a3);
unsigned int __cdecl sub_55EB0(__int16 a1);
int __cdecl main(int argc, const char **argv, const char **envp);
char sub_560D0();
int __cdecl sub_56210(unsigned __int16 a1, int a2);
int sub_56730();
int sub_567C0();
// char __usercall sub_56A30@<al>(unsigned int a1@<esi>);
int __cdecl sub_56C00(int a1);
// char __usercall sub_56D60@<al>(unsigned int a1@<esi>, char a2);
_BOOL1 __cdecl sub_56EE0(unsigned __int16 a1);
char __cdecl sub_56F10(__int16 a1, __int16 a2, __int16 a3, char a4);
char __cdecl sub_570F0(__int16 a1, __int16 a2, signed __int16 a3, char a4, char a5, char a6);
char __cdecl sub_572C0(signed __int16 *a1, __int16 a2, __int16 a3, __int16 a4, char a5);
unsigned __int8 __cdecl sub_57390(unsigned __int16 a1, unsigned __int16 a2);
char __cdecl sub_57450(unsigned __int8 a1);
_WORD *sub_574A0();
int sub_57570();
char sub_575C0();
char sub_57640();
unsigned int sub_57680();
char sub_57730();
char __cdecl sub_57B20(int a1, int a2);
signed int __cdecl sub_57CF0(int a1, int a2);
signed int __cdecl sub_57D40(int a1, int a2);
int __cdecl sub_57D70(int a1, int a2);
__int16 __cdecl sub_57E50(int a1);
int __cdecl sub_57F10(int a1);
int __cdecl sub_57F20(int a1);
_WORD *__cdecl sub_57FA0(_WORD *a1, unsigned __int16 a2, __int16 a3, __int16 a4);
_WORD *__cdecl sub_58030(int a1, _WORD *a2);
signed int __cdecl sub_580E0(int a1, signed int a2, int a3, int a4, __int16 a5);
__int16 __cdecl sub_581E0(_WORD *a1, _WORD *a2);
__int16 __cdecl sub_58210(_WORD *a1, _WORD *a2);
int __cdecl sub_582B0(__int16 a1, __int16 a2);
int __cdecl sub_582F0(int a1, __int16 a2);
int __cdecl sub_58350(unsigned __int16 a1, __int16 a2, int a3, unsigned __int16 a4);
int __cdecl sub_583B0(_WORD *a1, _WORD *a2);
unsigned int __cdecl sub_583F0(_WORD *a1, _WORD *a2);
int __cdecl sub_58440(_WORD *a1, _WORD *a2);
unsigned int __cdecl sub_58490(_WORD *a1, _WORD *a2);
int __cdecl sub_584D0(_WORD *a1, _WORD *a2);
signed int __cdecl sub_585A0(int a1);
void sub_585D0();
char sub_58630();
int __cdecl sub_58940(int a1);
int __cdecl sub_58DA0(int a1, int a2);
int sub_58F00();
char __cdecl sub_595C0(__int16 a1);
char __cdecl sub_59610(int *a1, __int16 a2);
char __cdecl sub_596C0(_WORD *a1, __int16 a2);
int __cdecl sub_59760(int a1, int a2);
void sub_59820();
int sub_59A50();
int sub_59AF0();
int sub_59B50();
_DWORD *sub_59BF0();
int __cdecl sub_59C40(int a1);
int __cdecl sub_59C60(int a1);
int __cdecl sub_59C80(int a1);
char __cdecl sub_59DC0(_WORD *a1);
void __cdecl sub_59F60(int a1);
unsigned int __cdecl sub_5B070(int a1);
void __cdecl sub_5B100(int a1);
int sub_5B7A0();
// int __fastcall _wcpp_1_unwind_leave__93(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int sub_5B840();
int __cdecl sub_5B870(_BYTE *a1, int a2, int a3);
char sub_5B8D0();
char sub_5BC20();
int sub_5BCC0();
int __cdecl sub_5BDC0(__int16 a1, __int16 a2);
char __cdecl sub_5BE80(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
char sub_5BF10();
signed int sub_5BF50();
signed int sub_5C060();
int sub_5C0A0();
signed int sub_5C1B0();
void sub_5C330();
signed int __cdecl sub_5C380(__int16 a1);
signed int __cdecl sub_5C3D0(int a1, char *a2);
int sub_5C430();
void sub_5C450();
int sub_5C490();
int sub_5C530();
__int16 __cdecl sub_5C800(int a1, char a2);
__int16 __cdecl sub_5C830(int a1, char a2, __int16 a3);
signed int __cdecl sub_5C870(int a1);
signed int __cdecl sub_5C8D0(int a1);
int __cdecl sub_5C950(int a1, int a2);
_WORD *__cdecl sub_5CF40(int a1, char a2);
int __cdecl sub_5D0A0(int a1);
// int __cdecl _wcpp_1_unwind_leave__98(_DWORD); weak
void __cdecl sub_5D530(int a1);
signed int __cdecl sub_5DD50(int a1);
void __cdecl sub_5DE30(int a1);
// int __cdecl _wcpp_1_unwind_leave__99(_DWORD); weak
void __cdecl sub_5E010(unsigned int a1);
int __cdecl sub_5E310(int a1);
int __cdecl sub_5E660(int a1);
__int16 __cdecl sub_5E6C0(int a1);
char __cdecl sub_5E7C0(int a1);
signed int __cdecl sub_5E8C0(int a1);
unsigned int __cdecl sub_5EF70(unsigned int a1);
signed int __cdecl sub_5EFA0(unsigned int a1);
char __cdecl sub_5F380(int a1);
char __cdecl sub_5F660(int a1, unsigned int a2, int a3);
unsigned __int8 __cdecl sub_5F7B0(int a1, int a2, int a3);
unsigned __int8 __cdecl sub_5F7E0(int a1, int a2);
unsigned int __cdecl sub_5F810(int a1, int a2, int a3);
char __cdecl sub_5F890(int a1, __int16 a2);
void __cdecl sub_5F8F0(int a1);
void __cdecl sub_5FA70(int a1);
unsigned int __cdecl sub_5FBD0(__int16 *a1);
int __cdecl sub_5FC40(int a1);
int __cdecl sub_5FCA0(int a1);
// int __cdecl _wcpp_1_unwind_leave__100(_DWORD, _DWORD); weak
int __cdecl sub_5FD00(int a1);
int __cdecl sub_5FF50(int a1);
_WORD *__cdecl sub_60400(__int16 a1, _WORD *a2, _WORD *a3);
char __cdecl sub_60480(int a1);
char __cdecl sub_605E0(int a1);
int __cdecl sub_60780(_DWORD *a1, int a2, int a3, int a4);
unsigned int __cdecl sub_60810(int a1);
signed int __cdecl sub_609E0(int a1);
signed int __cdecl sub_60AB0(int a1);
signed int __cdecl sub_60D50(__int16 *a1, int a2);
signed int __cdecl sub_60EA0(int a1);
char sub_60F00();
__int16 __cdecl sub_61000(int a1);
unsigned int __cdecl sub_61050(unsigned int a1);
__int16 __cdecl sub_613D0(int a1);
char __cdecl sub_61620(int a1, int a2);
signed int __cdecl sub_616D0(signed int a1);
signed int __cdecl sub_61790(signed int a1);
signed int __cdecl sub_61810(int a1, int a2);
char *__cdecl sub_61880(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8);
char *__cdecl sub_61A00(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8);
char *__cdecl sub_627F0(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8);
char __cdecl sub_63570(int a1, int a2);
int __cdecl sub_63600(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10);
int __cdecl sub_63670(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10);
int __cdecl sub_63C90(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10);
char __cdecl sub_644F0(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8);
char __cdecl sub_64CE0(int a1);
int (*__cdecl sub_64E20(int a1))();
int (*__cdecl sub_64F60(int a1))();
int (*__cdecl sub_64FF0(_WORD *a1))();
int __cdecl sub_65040(int a1);
int __cdecl sub_65080(int a1);
int __cdecl sub_65110(int a1);
int (*__cdecl sub_651B0(int a1))();
int (*__cdecl sub_65240(int a1))();
void __cdecl sub_65280(int a1);
void __cdecl sub_652A0(int a1);
void __cdecl sub_652C0(int a1);
int __cdecl sub_654B0(signed __int16 *a1, int a2);
int __cdecl sub_65580(int a1);
int __cdecl sub_655A0(int a1);
int __cdecl sub_655C0(_WORD *a1, int a2);
int __cdecl sub_65610(int a1, int a2);
__int16 __cdecl sub_656D0(int a1, int a2);
char __cdecl sub_65780(int a1, unsigned int a2, unsigned int a3);
int __cdecl sub_65820(int a1);
int __cdecl sub_65B30(int a1);
int __cdecl sub_65B50(int a1);
int __cdecl sub_65C20(int a1);
__int16 __cdecl sub_65F60(int a1);
int __cdecl sub_66160(int a1);
int __cdecl sub_66180(int a1);
int __cdecl sub_66250(int a1);
int __cdecl sub_66280(int a1);
int __cdecl sub_662A0(int a1);
char __cdecl sub_662C0(int a1);
char __cdecl sub_662E0(int a1);
__int16 __cdecl sub_66610(int a1);
__int16 __cdecl sub_66750(unsigned int a1);
char __cdecl sub_66B30(int a1);
char __cdecl sub_66D00(int a1);
int __cdecl sub_66FB0(int a1);
char __cdecl sub_66FD0(int a1);
char __cdecl sub_672E0(int a1);
int __cdecl sub_67410(int a1);
int __cdecl sub_67430(int a1);
int __cdecl sub_67450(int a1);
int __cdecl sub_67470(int a1);
__int16 __cdecl sub_674C0(int a1);
_WORD *__cdecl sub_676F0(int a1);
int __cdecl sub_67740(int a1);
int __cdecl sub_67760(int a1);
int __cdecl sub_67780(int a1);
int __cdecl sub_677A0(int a1);
int __cdecl sub_677D0(int a1);
int __cdecl sub_67800(int a1);
unsigned int __cdecl sub_67890(int a1);
int __cdecl sub_678E0(int a1);
int __cdecl sub_67910(int a1);
int __cdecl sub_67940(int a1);
// int __usercall sub_67960@<eax>(unsigned int a1@<esi>, int a2);
signed int __cdecl sub_67CB0(int a1);
int __cdecl sub_68490(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
int __cdecl sub_685D0(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
int __cdecl sub_686D0(int a1, unsigned int a2);
char __cdecl sub_68740(int a1, int a2, unsigned __int16 a3, __int16 a4);
char __cdecl sub_68940(int a1);
char __cdecl sub_68AC0(int a1, int a2);
char __cdecl sub_68BD0(int a1, _BYTE *a2);
int sub_68BF0();
int __cdecl sub_68C70(int a1);
signed int __cdecl sub_68D50(int a1, _DWORD *a2);
signed int __cdecl sub_68DE0(int a1, int a2);
signed int __cdecl sub_68E50(int a1, int a2, int a3);
signed int __cdecl sub_68FF0(int a1, char a2, char a3);
signed int __cdecl sub_69250(int a1);
signed int __cdecl sub_692A0(int a1);
char __cdecl sub_692C0(int a1);
void __cdecl sub_69300(int a1, int a2);
int __cdecl sub_693F0(int a1);
signed int __cdecl sub_69600(int a1);
signed int __cdecl sub_69620(int a1);
void __cdecl sub_69640(int a1);
void __cdecl sub_69900(int a1, int a2);
signed int __cdecl sub_69A70(int a1);
signed int __cdecl sub_69A90(int a1);
int __cdecl sub_69AB0(int a1);
signed int __cdecl sub_69D70(int a1);
signed int __cdecl sub_69D90(int a1);
void __cdecl sub_69DB0(int a1);
signed int __cdecl sub_69FF0(int a1);
signed int __cdecl sub_6A010(int a1);
char __cdecl sub_6A030(int a1);
signed int __cdecl sub_6A2C0(int a1);
signed int __cdecl sub_6A2E0(int a1);
void __cdecl sub_6A300(int a1);
signed int __cdecl sub_6A440(int a1);
signed int __cdecl sub_6A460(int a1);
char __cdecl sub_6A480(int a1);
signed int __cdecl sub_6A580(int a1);
signed int __cdecl sub_6A5A0(int a1);
int __cdecl sub_6A5C0(int a1);
signed int __cdecl sub_6A9C0(int a1);
signed int __cdecl sub_6A9E0(int a1);
__int16 __cdecl sub_6AA00(int a1);
signed int __cdecl sub_6AAC0(int a1);
signed int __cdecl sub_6AAE0(int a1);
int __cdecl sub_6AB00(int a1);
signed int __cdecl sub_6AD00(int a1);
signed int __cdecl sub_6AD20(int a1);
void __cdecl sub_6AD60(int a1);
signed int __cdecl sub_6B180(int a1);
signed int __cdecl sub_6B1A0(int a1);
void __cdecl sub_6B1C0(int a1);
signed int __cdecl sub_6B2D0(int a1);
signed int __cdecl sub_6B2F0(int a1);
__int16 __cdecl sub_6B310(_WORD *a1);
signed int __cdecl sub_6B3A0(int a1);
signed int __cdecl sub_6B3C0(int a1);
int __cdecl sub_6B3E0(int a1);
signed int __cdecl sub_6B5D0(int a1);
signed int __cdecl sub_6B5F0(int a1);
__int16 __cdecl sub_6B610(int a1);
signed int __cdecl sub_6B830(int a1);
signed int __cdecl sub_6B850(int a1);
int __cdecl sub_6B870(int a1);
signed int __cdecl sub_6BA70(int a1);
signed int __cdecl sub_6BA90(int a1);
int __cdecl sub_6BAB0(int a1);
signed int __cdecl sub_6BCB0(int a1);
signed int __cdecl sub_6BCD0(int a1);
int __cdecl sub_6BCF0(int a1);
signed int __cdecl sub_6BEF0(int a1);
signed int __cdecl sub_6BF10(int a1);
int __cdecl sub_6BF30(int a1);
signed int __cdecl sub_6C130(int a1);
signed int __cdecl sub_6C150(int a1);
__int16 __cdecl sub_6C170(int a1);
signed int __cdecl sub_6C3A0(int a1);
signed int __cdecl sub_6C3C0(int a1);
int __cdecl sub_6C3E0(int a1);
signed int __cdecl sub_6C5E0(int a1);
signed int __cdecl sub_6C600(int a1);
int __cdecl sub_6C620(int a1);
signed int __cdecl sub_6C830(int a1);
signed int __cdecl sub_6C850(int a1);
__int16 __cdecl sub_6C870(int a1);
signed int __cdecl sub_6CA80(int a1);
signed int __cdecl sub_6CAA0(int a1);
int __cdecl sub_6CAC0(int a1);
signed int __cdecl sub_6CCE0(int a1);
signed int __cdecl sub_6CD00(int a1);
int __cdecl sub_6CD20(int a1);
signed int __cdecl sub_6CF60(int a1);
signed int __cdecl sub_6CF80(int a1);
int __cdecl sub_6CFA0(int a1);
signed int __cdecl sub_6D1C0(int a1);
signed int __cdecl sub_6D1E0(int a1);
__int16 __cdecl sub_6D200(int a1);
int __cdecl sub_6D420(__int16 a1, __int16 a2);
char __cdecl sub_6D4C0(int a1);
int __cdecl sub_6D4F0(int a1, __int16 a2);
// int __fastcall _wcpp_1_unwind_leave__120(_DWORD, _DWORD, _DWORD); weak
char __cdecl sub_6D5E0(int a1, char a2);
int __cdecl sub_6D710(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3);
char __cdecl sub_6D830(int a1, char a2);
char __cdecl sub_6D880(int a1);
void __cdecl sub_6D8B0(unsigned __int16 a1, unsigned __int16 a2, __int16 a3);
int __cdecl sub_6D9C0(int a1, unsigned __int8 *a2, __int16 a3, char a4, char a5);
void __cdecl sub_6DAD0(int a1, unsigned __int8 *a2, __int16 a3);
int __cdecl sub_6DB50(char a1, char a2);
void sub_6DBD0();
void __cdecl sub_6DC40(unsigned __int8 a1);
int __cdecl sub_6DCA0(int a1, int a2, unsigned __int16 a3, __int16 *a4, __int16 a5, char a6);
signed int __cdecl sub_6E020(unsigned __int16 a1);
int __cdecl sub_6E090(int a1, int a2);
int sub_6E0D0();
void sub_6E150();
void __cdecl sub_6E450(__int16 a1, __int16 a2, __int16 a3);
bool __cdecl sub_6EA90(int a1, int a2);
void __cdecl sub_6EAB0(int a1, __int16 a2, __int16 a3);
unsigned int __cdecl sub_6EB90(unsigned int **a1);
unsigned int __cdecl sub_6EBF0(unsigned int **a1);
int sub_6EDB0();
int __cdecl sub_6EDE0(signed __int16 a1, signed __int16 a2);
__int16 __cdecl sub_6EF10(__int16 a1, signed __int16 a2, __int16 a3, signed __int16 a4);
unsigned int __cdecl sub_6F030(int a1);
unsigned int __cdecl sub_6F070(int a1);
unsigned int __cdecl sub_6F0B0(int a1);
unsigned int __cdecl sub_6F100(int a1);
unsigned int __cdecl sub_6F150(int a1);
int __cdecl sub_6F1C0(int a1);
_BYTE *__cdecl sub_6F2B0(int a1);
unsigned int __cdecl sub_6F300(int a1, unsigned int a2);
unsigned int __cdecl sub_6F420(int a1);
unsigned int __cdecl sub_6F440(int a1);
unsigned int __cdecl sub_6F460(int a1);
unsigned int __cdecl sub_6F480(int a1);
unsigned int __cdecl sub_6F4A0(int a1);
unsigned int __cdecl sub_6F4C0(int a1);
unsigned int __cdecl sub_6F4E0(int a1);
unsigned int __cdecl sub_6F500(int a1);
unsigned int __cdecl sub_6F520(int a1);
unsigned int __cdecl sub_6F540(int a1);
unsigned int __cdecl sub_6F560(int a1);
unsigned int __cdecl sub_6F580(int a1);
unsigned int __cdecl sub_6F5A0(int a1);
unsigned int __cdecl sub_6F5C0(int a1);
unsigned int __cdecl sub_6F5E0(int a1);
unsigned int __cdecl sub_6F600(int a1);
unsigned int __cdecl sub_6F620(int a1);
unsigned int __cdecl sub_6F640(int a1);
unsigned int __cdecl sub_6F660(int a1);
unsigned int __cdecl sub_6F680(int a1);
unsigned int __cdecl sub_6F6A0(int a1);
unsigned int __cdecl sub_6F6C0(int a1);
unsigned int __cdecl sub_6F6E0(int a1);
unsigned int __cdecl sub_6F700(int a1);
unsigned int __cdecl sub_6F720(int a1);
unsigned int __cdecl sub_6F740(int a1);
unsigned int __cdecl sub_6F760(int a1);
unsigned int __cdecl sub_6F780(int a1);
unsigned int __cdecl sub_6F7A0(int a1);
unsigned int __cdecl sub_6F7C0(int a1);
_BYTE *__cdecl sub_6F7E0(int a1);
unsigned int __cdecl sub_6F850(int a1, int a2);
int __cdecl sub_6F8E0(int a1, int a2);
int __cdecl sub_6F940(_BYTE *a1, int a2, int a3, unsigned __int8 a4);
__int16 sub_6FC10();
__int16 sub_6FC30();
int __cdecl sub_6FC50(__int16 a1);
unsigned int __cdecl sub_6FC80(char *a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5);
int sub_6FD30(); // weak
int sub_6FDA0();
void sub_6FE20();
// int __fastcall _wcpp_1_unwind_leave__130(_DWORD); weak
int __cdecl sub_6FE90(unsigned __int8 *a1, unsigned int a2);
int sub_6FEC0();
int sub_70890();
int sub_70910();
unsigned int sub_70940();
char sub_70A60();
int sub_70BF0();
int __cdecl sub_70C60(unsigned __int16 a1, char *a2);
char __cdecl sub_70D20(unsigned __int16 a1);
char __cdecl sub_70E10(unsigned __int16 a1);
int __cdecl sub_70EF0(unsigned __int16 a1);
int __cdecl sub_70F50(unsigned __int16 a1);
unsigned int __cdecl sub_71090(unsigned int a1);
__int16 sub_712F0();
int sub_713A0();
int sub_71410();
bool __cdecl sub_71520(unsigned __int16 a1);
int sub_715B0();
int sub_716A0();
signed __int16 *__cdecl sub_716C0(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3);
int __cdecl sub_71730(unsigned __int16 a1);
char sub_71780();
char sub_71890();
__int16 sub_718F0();
int sub_71930();
char sub_71990();
unsigned __int8 __cdecl sub_71A70(unsigned __int8 a1);
__int16 __cdecl sub_71AB0(__int16 a1, char a2);
int __cdecl sub_71B40(int a1, unsigned __int16 a2, int a3);
signed int __cdecl sub_71CD0(int a1);
int __cdecl sub_71E60(int a1);
int __cdecl sub_71E70(int a1, unsigned int a2, __int16 a3);
__int16 __cdecl sub_71F20(int a1, int a2);
void __cdecl sub_720C0(int *a1);
int __cdecl sub_72120(unsigned __int16 a1);
int __cdecl sub_721C0(unsigned __int16 *a1, int *a2, __int16 a3);
int __cdecl sub_72350(int a1);
unsigned __int16 __cdecl sub_723B0(int a1, char a2);
_DWORD *__cdecl sub_72410(_DWORD *a1);
int __cdecl sub_724F0(int a1, __int16 a2);
void __cdecl sub_72550(int *a1);
__int16 __cdecl __spoils<> sub_72633(__int16 a1, __int16 a2);
unsigned int __cdecl sub_7277A(unsigned int a1);
void __cdecl sub_727F0(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
// void __usercall __spoils<ecx> sub_72883(int a1@<eax>, void *a2, unsigned __int16 a3, char a4);
// void __usercall __spoils<ecx> sub_728A9(int a1@<eax>, void *a2, unsigned __int16 a3, char a4);
int __cdecl sub_72C40(__int16 a1, __int16 a2, int a3, unsigned __int8 a4);
int __cdecl sub_72CB0(unsigned __int8 *a1, int a2);
void sub_72D04();
// int __usercall sub_72DDE@<eax>(signed __int16 *a1@<ebx>, int a2);
int __fastcall sub_72E70(int a1, int a2, signed __int16 *a3);
signed int __fastcall sub_72FBB(int a1, int a2, signed __int16 *a3);
signed int sub_7302E();
// int __usercall sub_7308F@<eax>(signed __int16 *a1@<ebx>, int a2, __int16 a3);
int __cdecl sub_73669(__int16 a1);
int __cdecl sub_7373D(__int16 a1);
__int16 __cdecl sub_739AD(__int16 a1);
__int16 __cdecl sub_73AA1(__int16 a1);
__int16 __cdecl sub_73D11(__int16 a1);
unsigned __int16 __cdecl sub_74006(unsigned __int16 a1, int a2, unsigned int a3);
unsigned __int16 __cdecl sub_7404E(unsigned __int16 a1, int a2, unsigned int a3);
__int16 sub_74374();
unsigned __int16 __cdecl sub_7438A(int a1, unsigned int a2);
__int16 sub_7449C();
int sub_74515();
int sub_74536();
int sub_74556();
// signed int __usercall sub_74767@<eax>(signed __int16 *a1@<ebx>, _BYTE *a2, int a3);
int __cdecl sub_74809(__int16 a1);
signed int __cdecl sub_748F7(__int16 a1);
signed int sub_74A11();
int __cdecl sub_74A86(_BYTE *a1, int a2);
int __cdecl sub_74B19(_BYTE *a1);
signed int __cdecl sub_74B75(__int16 a1);
int __cdecl sub_74C9D(unsigned int a1, int a2);
int __cdecl sub_74D41(unsigned int a1, int a2, unsigned int a3);
signed int __cdecl sub_74DD4(unsigned int a1, int a2, unsigned __int16 a3);
int __cdecl sub_74E6D(unsigned int a1, int a2, int a3);
int __cdecl sub_74EF1(unsigned int a1, int a2, unsigned int a3);
__int16 sub_74F76();
signed int __cdecl sub_74FE1(__int16 a1);
int __cdecl sub_75044(unsigned int a1);
int **__cdecl sub_75110(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5);
int **__cdecl sub_75160(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5);
int **__cdecl sub_751B0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5);
void __cdecl sub_75200(__int16 a1);
int sub_752C0(); // weak
int sub_753D0();
int sub_75420();
int sub_75440();
int __cdecl sub_754C0(int a1, _DWORD *a2, int a3);
int __cdecl sub_75540(int a1, int a2);
int __cdecl sub_755B0(int a1, _DWORD *a2, int a3);
signed int sub_75650();
int sub_75900();
signed int sub_75910();
int sub_759B0();
unsigned __int8 __cdecl sub_75A10(int a1, unsigned __int8 *a2);
int sub_75AB0();
int __cdecl sub_75AE0(int a1);
int __cdecl sub_75B50(__int16 a1);
int __cdecl sub_75B80(int a1, _WORD *a2, _WORD *a3);
void sub_75C50();
void sub_75CB0();
unsigned int __cdecl sub_75D70(void *a1, unsigned int a2);
int sub_75DB0();
void __fastcall sub_75E70(__int16 a1);
int __cdecl sub_76160(__int16 a1, __int16 a2, int a3);
unsigned int sub_76260();
__int16 sub_76300();
int sub_76430();
int sub_76540();
void __cdecl sub_765FC(__int16 a1, __int16 a2);
int __cdecl sub_76619(int a1, int a2);
__int16 sub_766A4();
__int16 sub_76752();
int sub_7677C();
__int16 sub_7678D();
int sub_76840();
signed int __fastcall sub_76930(int a1, int a2, signed __int16 *a3);
int sub_76A40();
void sub_76CF0();
// int __fastcall _wcpp_1_unwind_leave__131(_DWORD); weak
char __cdecl sub_76D10(char a1);
int sub_76F40(); // weak
int __fastcall sub_76FA0(int a1, int a2, signed __int16 *a3);
char __cdecl sub_77350(int a1);
char __fastcall sub_77680(int a1, int a2, signed __int16 *a3);
char __cdecl sub_77980(int a1);
char __cdecl sub_779E0(int a1);
char __cdecl sub_780F0(int a1);
char __cdecl sub_78730(_WORD *a1);
// char __usercall sub_78E00@<al>(int a1@<eax>, int a2@<ebx>, signed __int16 *a3);
char __cdecl sub_79160(int a1);
char sub_79610();
signed int __cdecl sub_79E10(char *a1, char a2);
char sub_7A060();
void __cdecl sub_7A110(char a1, char a2);
signed int __cdecl sub_7AA70(int a1, char *a2, int a3, int a4);
// int (__cdecl **__usercall sub_7AB00@<eax>(__int16 a1@<ax>, int a2@<edx>, signed __int16 *a3@<ebx>, unsigned __int8 a4))(int);
int sub_7AC00();
int __cdecl sub_7ADE0(char a1);
bool __cdecl sub_7B200(_WORD *a1, __int16 a2, __int16 a3);
char __fastcall sub_7B250(int a1, int a2, __int16 a3);
void sub_7B5A0();
void sub_7B5D0();
int __cdecl sub_7B660(int a1, int a2, __int16 a3, _WORD *a4, _BYTE *a5, char a6);
int (__cdecl **sub_7BEC0())(int);
int __cdecl sub_7BF20(signed __int16 *a1);
_WORD *__cdecl sub_7C020(_WORD *a1);
signed int __fastcall sub_7C050(__int16 a1, __int16 a2);
int __cdecl sub_7C120(__int16 a1, __int16 a2, int a3);
int __cdecl sub_7C140(int a1, __int16 a2, int a3, __int16 a4, unsigned __int8 a5);
char __cdecl sub_7C200(unsigned __int8 a1);
int __fastcall sub_7C230(int a1, int a2, signed __int16 *a3);
signed int sub_7C390();
void sub_7C710();
int __cdecl sub_7C720(unsigned __int8 a1, _BYTE *a2);
int __cdecl sub_7C7C0(int a1, int a2);
char __cdecl sub_7C800(signed __int16 a1);
char __cdecl sub_7C9D0(signed __int16 a1);
int sub_7CB10();
char sub_7CBF0();
char sub_7CC40();
int sub_7CCA0();
int sub_7CCF0();
int sub_7CD30();
int sub_7CDA0();
int __cdecl sub_7CDC0(unsigned __int8 a1, unsigned __int8 a2);
signed int sub_7CE50();
int sub_7D1F0();
signed int __cdecl sub_7D230(char a1, unsigned __int8 a2, unsigned __int8 a3);
int sub_7D310();
unsigned int sub_7D380();
// int __usercall sub_7D400@<eax>(int a1@<eax>, __int16 a2, __int16 a3, char a4);
int __cdecl sub_7DA70(__int16 a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6);
int sub_7DD70();
// char __usercall sub_7DE80@<al>(int a1@<ebx>, int a2);
signed int sub_7E0E0();
int sub_7E1F0();
// signed int __usercall sub_7E320@<eax>(__int16 a1@<dx>, int a2@<edi>);
// signed int __usercall sub_7E5A0@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3, __int16 a4, int a5, __int16 a6, __int16 a7);
signed int __cdecl sub_7E620(int a1);
signed int __cdecl sub_7E640(int a1);
char __cdecl sub_7E800(_WORD *a1);
char __cdecl sub_7E820(int a1);
int __cdecl sub_7E840(signed __int16 *a1, __int16 a2, __int16 a3);
int __cdecl sub_7E8D0(_WORD *a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7);
signed int __cdecl sub_7E9D0(_WORD *a1, _WORD *a2, _WORD *a3);
int __cdecl sub_7EAE0(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, char *a5, _WORD *a6);
// int __usercall sub_7F6A0@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3, __int16 a4, char *a5, _BYTE *a6, unsigned __int8 a7);
int __cdecl sub_7F7D0(unsigned int *a1, _DWORD *a2, unsigned int a3, int a4);
int __cdecl sub_7F960(unsigned int *a1, unsigned int a2, unsigned int a3, int a4);
unsigned int __cdecl sub_7FAE0(char *a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5);
int __cdecl sub_7FB90(_BYTE *a1, int a2, __int16 a3, unsigned __int8 a4);
// int __usercall sub_7FCB0@<eax>(int a1@<ebx>, _BYTE *a2, int a3, int a4, int a5, char a6, unsigned __int8 a7, __int16 a8);
void __cdecl sub_80C30(__int16 a1, __int16 a2, __int16 a3);
// signed int __usercall sub_80D40@<eax>(__int16 a1@<si>, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
// int __usercall sub_81260@<eax>(int a1@<eax>, int a2@<edx>, int a3, __int16 a4, __int16 a5);
int __cdecl sub_812D0(__int16 a1, __int16 a2);
int __cdecl sub_81360(int a1, int a2, int a3, int a4, __int16 a5);
signed int __fastcall sub_81760(int a1);
// unsigned int __usercall sub_81CA0@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3, __int16 a4, int a5);
signed int sub_81DB0();
// signed __int16 __usercall sub_81EE0@<ax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, signed __int16 a4@<di>, __int16 a5, __int16 a6);
_WORD *__cdecl sub_824B0(__int16 a1);
_WORD *__cdecl sub_824E0(__int16 a1);
// int __usercall sub_82510@<eax>(__int16 a1@<dx>, int *a2);
__int16 sub_82670();
int __cdecl sub_82AB0(unsigned __int8 a1);
void __cdecl sub_82C20(__int16 a1);
signed int __cdecl sub_83250(char a1);
void sub_833C0();
int sub_83850();
int sub_83B50();
char __cdecl sub_83CC0(char a1);
int __cdecl sub_83CD0(int a1);
int __cdecl sub_83D70(int a1);
char __cdecl sub_83E00(int a1, int a2);
void __cdecl sub_83E80(int a1);
int __cdecl sub_84000(int a1);
int sub_84050();
// void __usercall sub_840B8(char a1@<cf>, _BOOL1 a2@<zf>, char a3@<sf>, char a4@<of>);
// __int16 __usercall sub_840D3@<ax>(char _CF@<cf>, _BOOL1 _ZF@<zf>, char _SF@<sf>, char _OF@<of>);
// void __usercall __spoils<st0> sub_841CE(__int16 a1@<fpstat>);
__int16 __cdecl sub_84250(int a1);
signed int __cdecl sub_84300(unsigned __int8 a1);
void sub_844A0();
char __cdecl sub_844F0(int a1, unsigned __int8 a2);
int sub_84790();
char __cdecl sub_847D0(int a1, char a2, char a3, char a4);
int __cdecl sub_84880(_BYTE *a1);
char sub_848A0();
int sub_84B80();
int __cdecl sub_84EA0(unsigned __int16 a1, int a2, char a3, __int16 a4);
int __cdecl sub_84FB0(signed __int16 *a1, signed __int16 *a2);
int __cdecl sub_85060(int a1);
void sub_85070();
int *sub_85350();
int __cdecl sub_85450(unsigned int a1);
__int16 __cdecl sub_856D0(int a1, int a2, __int16 a3, int a4);
unsigned int *__cdecl sub_85AF0(int a1);
int __cdecl sub_85B20(_BYTE *a1, _WORD *a2, unsigned __int16 a3);
int __cdecl sub_85BF5(_BYTE *a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_85C42(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6);
void __cdecl sub_85C8B(int a1, char *a2, int a3, int a4, int a5, int a6);
// void __usercall __spoils<ecx> sub_85CC3(unsigned int a1@<eax>, int a2@<ebx>, unsigned __int16 *a3);
signed __int16 sub_85E40();
__int16 __cdecl sub_85EB0(__int16 a1);
__int16 __cdecl sub_85F00(__int16 a1);
int __cdecl sub_85F60(int a1);
bool sub_85FD0();
int sub_86010();
__int16 __cdecl sub_86180(unsigned __int16 a1);
__int16 __cdecl sub_86270(unsigned __int16 a1);
__int16 __cdecl sub_86370(unsigned __int16 a1, char a2);
__int16 __cdecl sub_86460(unsigned __int16 a1);
int sub_86550();
char __cdecl sub_86780(unsigned __int16 a1, int a2, int a3);
char __cdecl sub_86860(unsigned __int16 a1);
char __cdecl sub_86930(unsigned __int16 a1);
_BOOL1 sub_86A00();
char sub_86BD0();
int __fastcall sub_86EA0(int a1, int a2, int a3);
void __cdecl sub_86EB0(unsigned __int8 a1, unsigned __int8 a2, char a3);
void __cdecl sub_86F20(char a1);
void __cdecl sub_86F70(unsigned __int8 a1, __int16 a2, __int16 a3);
void __cdecl sub_86FF0(unsigned __int8 a1, __int16 a2, __int16 a3);
char sub_87090();
char sub_871E0();
int sub_871F0();
int sub_872A0();
void sub_87580();
char sub_87610();
int sub_87860();
int sub_87970();
int sub_87A30();
int sub_87B30();
void **sub_87B70();
// int __fastcall _wcpp_1_unwind_leave__132(_DWORD); weak
void **sub_87BE0();
int sub_87C10();
int sub_87CF0();
int sub_88450();
void __cdecl sub_884D0(int a1, __int16 a2, int a3, char a4, char a5);
void **sub_88580();
char __cdecl sub_885E0(int a1, int a2, int a3, unsigned __int16 a4);
void __cdecl sub_88740(int a1, int a2, int a3);
int __cdecl sub_889F0(int a1);
int sub_88B20();
int sub_88B60();
char sub_88BA0();
int sub_88D00();
char sub_88D40();
char sub_89360();
int __cdecl sub_89420(_WORD *a1, const char *a2);
int __cdecl sub_89520(signed __int16 *a1);
int __cdecl sub_895D0(int a1, const char *a2);
int __cdecl sub_89690(signed __int16 *a1);
int __cdecl sub_89830(_WORD *a1);
_WORD *__cdecl sub_898A0(_WORD *a1);
int __cdecl sub_89920(_WORD *a1, __int16 a2, int a3);
int __cdecl sub_89980(signed __int16 *a1);
__int16 __cdecl sub_89A30(_WORD *a1);
int __cdecl sub_89AC0(_BYTE *a1, int a2);
signed int __cdecl sub_89B60(unsigned __int8 a1);
int sub_89D10();
int sub_8B5A0();
signed int __cdecl sub_8B600(int a1);
int sub_8B770();
signed int __cdecl sub_8B790(_DWORD *a1);
char __cdecl sub_8B880(int *a1, char a2, signed int a3, int a4);
// char __usercall sub_8B980@<al>(int a1@<eax>, int a2@<edx>, _DWORD **a3, int a4);
// char __usercall sub_8BA10@<al>(int a1@<eax>, int a2@<edx>, int *a3, char *a4, int a5);
int __cdecl sub_8BB10(int a1);
int __cdecl sub_8BB40(int a1, char a2);
signed int __cdecl sub_8BBE0(int a1);
void __cdecl sub_8C0E0(unsigned __int8 (__fastcall *a1)(signed int));
char __cdecl sub_8C140(unsigned __int16 a1, int a2);
// _DWORD __cdecl dos_getdrive(_DWORD); weak
// _DWORD __cdecl dos_setdrive(_DWORD, _DWORD); weak
// _DWORD __cdecl dos_getdiskfree(_DWORD, _DWORD); weak
int sub_8C21F();
// _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD); weak
// int rand(void); weak
// _DWORD __cdecl printf(_DWORD);
void sub_8C2CD();
void sub_8C2DE();
int sub_8C329();
int sub_8C635();
int sub_8C839();
int sub_8CA16();
int sub_8CACD();
void sub_8CB1F();
void sub_8CB3A();
int __cdecl sub_8CD27(int a1);
signed int sub_8CEDF();
int sub_8D12F();
void __fastcall sub_8D290(int a1, int a2, int a3);
void sub_8D800();
int sub_8D8F0();
void __fastcall sub_8D970(int a1, int a2, int a3);
void sub_8E020();
int sub_8E0D0(); // weak
void __cdecl sub_8E160(__int16 a1, unsigned __int8 a2);
// _DWORD sprintf(_DWORD, const char *, ...); weak
_DWORD *__cdecl sub_8E410(_DWORD *a1);
int __cdecl sub_8E470(int a1);
__int16 sub_8E673();
__int16 sub_8E736();
int sub_8E799();
int sub_8E7B7();
int sub_8E7D5();
void sub_8E7FC();
__int16 sub_8E871();
int sub_8E948();
char sub_8E9EF();
void __fastcall sub_8EA7B(int a1, unsigned __int16 a2);
signed int __cdecl sub_8EAD0(int a1);
unsigned int sub_8EC90();
char __cdecl sub_8ED00(int a1, unsigned __int8 a2);
int __cdecl sub_8F023(int a1, int a2, unsigned int a3);
int __cdecl sub_8F0AB(int a1, int a2, int a3);
int **__cdecl sub_8F100(int *a1, __int16 a2, int a3, int a4, unsigned __int16 a5, char a6, unsigned __int8 a7);
void __cdecl sub_8F420(int a1, __int16 a2);
int sub_8F4B0(); // weak
void __cdecl sub_8F710(int a1, __int16 a2, signed int a3, unsigned __int8 a4, char a5);
char *sub_8F850();
int __cdecl sub_8F8B0(__int16 a1, __int16 a2, int a3);
int __cdecl sub_8F8E8(__int16 a1, __int16 a2, int a3);
// void __usercall sub_8F920(__int16 a1@<dx>, signed int a2@<ecx>, int a3@<ebx>, char *a4@<esi>, unsigned __int8 a5, char a6);
// void __usercall sub_8F935(__int16 a1@<dx>, signed int a2@<ecx>, int a3@<ebx>, char *a4@<esi>, unsigned __int8 a5, char a6);
void __cdecl sub_90164(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, unsigned __int16 a5);
void __cdecl sub_901E4(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, unsigned __int16 a5);
int __cdecl sub_9025C(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6);
int __cdecl sub_90374(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6);
void sub_90478();
char __cdecl sub_904C0(float a1);
unsigned __int8 __cdecl sub_90530(int a1, int a2, float a3);
int __cdecl sub_905EC(char a1);
signed int __cdecl sub_90668(int a1);
int sub_906B4();
int sub_90810();
__int16 __cdecl sub_90B27(char *a1, unsigned __int8 a2, char a3);
void sub_90D27();
int __cdecl sub_90D3F(int a1);
int __cdecl sub_90D6E(unsigned __int8 *a1);
int __cdecl sub_90E07(unsigned __int8 *a1);
int __cdecl sub_90EA0(int a1, char a2);
int sub_90EE0();
int sub_90F20();
int sub_90F60();
__int16 __fastcall sub_90FD0(int a1, int a2, int a3);
__int16 sub_91010();
int sub_91420();
bool sub_915A0();
signed int sub_916F0();
signed int sub_919C0();
int __cdecl sub_91A80(int a1, int a2);
void sub_91BD0();
void sub_91BF0();
// int __usercall sub_91C10@<eax>(__int16 a1@<dx>, int a2@<ecx>, int a3@<ebx>, int a4);
signed int __cdecl sub_91D50(int a1, int a2);
signed int __cdecl sub_91E90(int a1);
unsigned int sub_91F20();
void __cdecl sub_91F50(unsigned int a1);
int __cdecl sub_91F70(int a1, int a2, _WORD *a3, _WORD *a4);
unsigned __int8 __cdecl sub_920D0(int a1);
int sub_92160();
int __cdecl sub_92190(int a1, int a2);
unsigned int __cdecl sub_92600(int a1);
signed __int32 __cdecl sub_92740(int a1, signed __int32 a2);
void __cdecl sub_92890(int a1, int a2);
void __cdecl sub_92930(int a1, unsigned int a2);
void __cdecl sub_92BA0(int a1);
void __cdecl sub_92CB0(int a1);
void __cdecl sub_92DC0(int a1);
void sub_92E50();
void *__cdecl sub_92ED0(int a1);
// _DWORD *__usercall sub_93010@<eax>(int a1@<ebx>, int a2, int a3);
int __cdecl sub_93160(unsigned int a1);
// int __usercall sub_931F0@<eax>(int a1@<ebx>, int **a2);
// int *__usercall sub_93330@<eax>(int a1@<ebx>, int a2, const void *a3);
int __cdecl sub_93480(unsigned int *a1);
_DWORD *__cdecl sub_93510(int a1);
int __cdecl sub_937A0(int a1);
int __cdecl sub_93830(_DWORD *a1);
signed int __cdecl sub_938C0(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl sub_93A10(_DWORD *a1, int a2, int a3);
int __cdecl sub_93AB0(_DWORD *a1, int a2, int a3);
int __cdecl sub_93B50(int *a1);
int __cdecl sub_93D00(int a1);
int __cdecl sub_93D90(int a1, int a2);
int __cdecl sub_93E30(_DWORD *a1, int a2);
int __cdecl sub_93ED0(_DWORD *a1, int a2);
int __cdecl sub_93F70(int a1, int a2);
int __cdecl sub_94010(int a1);
int __cdecl sub_94650(_DWORD *a1, int a2);
int __cdecl sub_95140(int a1, int a2);
int __cdecl sub_953E0(int a1, int a2, int a3);
int __cdecl sub_95480(int a1, int a2);
// int __usercall sub_95710@<eax>(int a1@<ebx>, int **a2);
// int *__usercall sub_95850@<eax>(int a1@<ebx>, int a2, const void *a3);
int __cdecl sub_959A0(unsigned int *a1);
_DWORD *__cdecl sub_95A30(int a1);
int __cdecl sub_95C00(int *a1, int a2, int a3);
int *__cdecl sub_95D50(int *a1);
int __cdecl sub_95DE0(int *a1);
void __cdecl sub_95E70(_DWORD *a1);
int __cdecl sub_95F00(int a1);
void __cdecl sub_96030(_DWORD *a1, int a2, int a3);
int __cdecl sub_96170(int a1);
_DWORD *__cdecl sub_96670(_DWORD *a1, _DWORD *a2);
signed int __cdecl sub_969A0(_DWORD *a1);
int __cdecl sub_96AE0(int a1);
int __cdecl sub_97330(_DWORD *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__cdecl sub_97480(_DWORD *a1, int a2);
int __cdecl sub_97670(int a1, int a2);
int __cdecl sub_97A60(int a1, int a2);
int __cdecl sub_97BB0(int a1, int a2);
int __cdecl sub_97F90(_DWORD *a1);
int __cdecl sub_980D0(_DWORD *a1, int a2);
int __cdecl sub_98170(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl sub_98360(_DWORD *a1, int a2, int a3, unsigned int a4, int a5);
bool sub_986A0();
void sub_986E0();
unsigned int __cdecl sub_98709(unsigned int a1, unsigned int a2, unsigned int a3);
unsigned int *__cdecl sub_9874D(unsigned int *a1, unsigned int a2, unsigned int a3);
int __fastcall j___clock(_DWORD, _DWORD, _DWORD); // weak
void __cdecl sub_98790(unsigned __int16 a1, unsigned __int8 a2);
// _DWORD __cdecl toupper(_DWORD); weak
int __cdecl sub_98817(int a1, int a2);
int __cdecl sub_98882(int a1);
int __cdecl sub_988A7(int a1, int a2, int a3);
// _DWORD __cdecl filelength(_DWORD); weak
int __cdecl sub_9891E(int a1, int a2, char a3);
int __cdecl sub_9894C(int a1, char *a2);
// char __usercall sub_98AE0@<al>(int *a1@<esi>);
// __int16 __usercall sub_98AE9@<ax>(__int16 *a1@<edx>, int a2@<esi>);
// __int16 __usercall sub_98B2C@<ax>(unsigned __int8 a1@<al>, int a2@<esi>);
// char __usercall sub_98BAF@<al>(int a1@<esi>);
signed int __cdecl sub_98C48(int a1, int a2, int a3);
int __cdecl sub_98CAA(int a1, int a2, int a3);
// _DWORD __cdecl access(_DWORD, _DWORD); weak
// _DWORD __cdecl mkdir(_DWORD); weak
// _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD); weak
// int _sigfpe_handler(); weak
// _DWORD __cdecl signal(_DWORD, _DWORD); weak
// _DWORD __cdecl stricmp(_DWORD, _DWORD); weak
// _DWORD __cdecl unknown_libname_1(_DWORD); weak
int __cdecl sub_98FF5(char *a1);
// void __cdecl __noreturn exit(int status); idb
void __cdecl sub_99080(char a1);
int __cdecl sub_9937E(__int16 a1);
int __cdecl sub_994BA(__int16 a1);
signed int __cdecl sub_9951B(__int16 a1);
int sub_995B0();
// _DWORD __cdecl strncmp(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl fgetc(_DWORD); weak
int sub_99830(); // weak
void __cdecl sub_99970(char a1, unsigned __int8 a2);
unsigned int __cdecl sub_99A77(unsigned int a1, unsigned int a2, unsigned int a3);
unsigned int *__cdecl sub_99AEB(unsigned int *a1, unsigned int a2, unsigned int a3);
// _DWORD __cdecl strnicmp(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl dos_getvect(_DWORD); weak
// _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD); weak
void sub_99C10();
void sub_99C90();
// _DWORD __cdecl strcpy(_DWORD, _DWORD); weak
// _DWORD __cdecl strlen(_DWORD); weak
// _DWORD __cdecl strcat(_DWORD, _DWORD); weak
// _DWORD __cdecl memcpy(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl segread(_DWORD); weak
// _DWORD __cdecl int386x(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl getenv(_DWORD); weak
signed int __cdecl sub_99E8E(unsigned __int8 *a1, unsigned __int8 **a2, signed int a3, int a4);
signed int __cdecl sub_99FF0(unsigned __int8 *a1, unsigned __int8 **a2, signed int a3);
int __cdecl sub_99FF5(unsigned __int8 a1);
// _DWORD __cdecl strcmp(_DWORD, _DWORD); weak
unsigned __int8 sub_9A0FC();
signed int __fastcall sub_9A10A(signed int result);
_DWORD __cdecl j___delay(_DWORD); // weak
void __cdecl sub_9A128(const void *a1, void *a2, unsigned __int16 a3);
void __cdecl sub_9A144(const void *a1, void *a2, unsigned __int16 a3);
// _DWORD __cdecl unknown_libname_2(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl unknown_libname_3(_DWORD); weak
// int __cdecl unknown_libname_4(_DWORD); weak
// _DWORD __cdecl strupr(_DWORD); weak
int __cdecl sub_9A230(int a1);
_DWORD *__cdecl sub_9A2F5(int a1);
signed int __cdecl sub_9A32D(int a1);
// _DWORD __cdecl gets(_DWORD); weak
// _DWORD __cdecl tell(_DWORD); weak
// _DWORD __cdecl malloc(_DWORD); weak
// _DWORD __cdecl expand(_DWORD, _DWORD); weak
// _DWORD __cdecl qsort(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_9AD16(unsigned __int16 a1);
int __cdecl sub_9AD9C(int a1);
int __cdecl sub_9ADB4(int a1);
int __fastcall j_j___clock(_DWORD, _DWORD, _DWORD); // weak
// bool __usercall sub_9AE04@<eax>(int eax0@<eax>, int edx0@<edx>, int a3@<ebx>, int a1, int a2);
// char __usercall sub_9AE90@<al>(int eax0@<eax>, int edx0@<edx>, int ebx0@<ebx>, int *a1, _BYTE *a2, int a3, int a4);
void __cdecl sub_9AEEC(_DWORD **a1, char *a2);
// char __usercall sub_9AFC4@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, int *a4, int a5);
char __cdecl sub_9B038(int *a1, char *a2, int a3);
int __cdecl sub_9B234(int *a1);
signed int __cdecl sub_9B260(_DWORD **a1);
char __cdecl sub_9B274(int *a1, int a2);
char *__cdecl sub_9B498(char a1);
// double __fastcall _CHP(_DWORD); weak
// _DWORD __cdecl calloc(_DWORD, _DWORD); weak
bool __cdecl sub_9B540(unsigned int a1, unsigned int a2);
bool __cdecl sub_9B5B4(unsigned int a1, unsigned int a2);
void sub_9B628();
int __cdecl sub_9B63C(int a1);
_WORD *__cdecl sub_9B688(int a1);
int __cdecl sub_9B7E8(int a1);
// void __usercall __noreturn sub_9BA00(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
// void __usercall __noreturn sub_9BA2C(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
// void __usercall __noreturn sub_9BA58(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
// void __usercall __noreturn sub_9BA84(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
void sub_9BAB0();
int __cdecl sub_9BAC4(int a1, signed int a2);
int __cdecl sub_9BBFC(int a1);
signed int __cdecl sub_9BC68(_WORD *a1, int a2, unsigned int a3);
signed int __cdecl sub_9BD28(int a1);
int __cdecl sub_9BE18(int a1, int a2, char a3, unsigned int a4, unsigned int a5);
int __cdecl sub_9C58C(int a1);
signed int __cdecl sub_9C810(_DWORD *a1, char a2);
signed int __cdecl sub_9C938(_DWORD *a1);
bool __cdecl sub_9C9D0(int a1);
void __cdecl sub_9CBBC(_DWORD *a1);
int __cdecl sub_9CCB4(int a1, int a2);
int __cdecl sub_9CCF8(int a1, int a2);
int __cdecl sub_9CD9C(int a1, int a2);
// _DWORD __cdecl strtod(_DWORD, _DWORD); weak
// _DWORD __cdecl _set_errno(_DWORD); weak
__int16 __fastcall sub_9D31C(__int16 result);
int __cdecl sub_9D380(int a1, int a2, char a3, int a4, int a5);
int (__cdecl *__cdecl sub_9D3F0(int (__cdecl *a1)(int)))(int);
int (__cdecl *__cdecl sub_9D420(int (__cdecl *a1)(int)))(int);
unsigned int __cdecl sub_9D450(int a1);
int __cdecl sub_9D490(unsigned int a1, int a2);
signed int __cdecl sub_9D4D0(int a1, unsigned int *a2, _DWORD *a3, _DWORD *a4);
void __cdecl sub_9D560(int a1);
bool __cdecl sub_9D590(unsigned int a1, unsigned int a2);
bool __cdecl sub_9D650(unsigned int a1, unsigned int a2);
bool __cdecl sub_9D710(unsigned int a1, int a2);
bool __cdecl sub_9D740(unsigned int a1, int a2);
int __cdecl sub_9D770(int a1, char a2);
signed int __cdecl sub_9DE20(int a1);
int __cdecl sub_9DEA0(int a1, int a2);
// _DWORD __cdecl sscanf(_DWORD, _DWORD, char); weak
bool sub_9E1B0();
int sub_9E250(); // weak
int __cdecl sub_9E2B0(int a1, int a2, _DWORD *a3);
int __cdecl sub_9E3A0(char *a1, int a2);
int __cdecl sub_9E6E0(int a1, int a2);
// _DWORD *__usercall sub_9E720@<eax>(int a1@<ebx>, int a2, int a3);
int __cdecl sub_9EA60(unsigned int a1);
void *__cdecl sub_9EB60(int a1);
void sub_9EC30();
signed int sub_9ED70();
bool sub_9EDD0();
int sub_9EE70(); // weak
int sub_9F040();
signed __int64 __cdecl sub_9F110(int a1);
int __cdecl sub_9F170(int a1, unsigned __int16 a2);
int __cdecl sub_9F1D0(int a1);
int __cdecl sub_9F220(int a1);
int __cdecl sub_9F280(int *a1);
signed int __cdecl sub_9F2E0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
__int64 __cdecl sub_9F3D0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
signed int __cdecl sub_9F4F0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
signed int __cdecl sub_9F5E0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
int __cdecl sub_9F6D0(int *a1, __int16 a2);
void __cdecl sub_9F740(int a1);
void sub_9FA80();
// _DWORD __cdecl open(_DWORD, _DWORD);
// _DWORD __cdecl sopen(_DWORD, _DWORD, char);
// _DWORD __cdecl close(_DWORD); weak
// _DWORD __cdecl read(_DWORD, _DWORD, _DWORD); weak
// double __usercall IF_DPOW@<st0>(double@<st0>, double@<st1>); weak
int __cdecl sub_A0B24(int a1);
int __cdecl sub_A0BB0(int *a1, int a2);
// _DWORD __cdecl abs(_DWORD); weak
int __cdecl sub_A0D2C(unsigned __int8 *a1);
int __cdecl sub_A0D50(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
// _DWORD __cdecl chdir(_DWORD); weak
// _DWORD __cdecl getcwd(_DWORD, _DWORD); weak
// _DWORD __cdecl free(_DWORD); weak
// _DWORD __cdecl outp(_DWORD, char); weak
// _DWORD __cdecl inp(_DWORD); weak
void sub_A0EEC();
void sub_A0EF9();
// int __usercall sub_A0F06@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
char __cdecl sub_A102C(int a1);
char __cdecl sub_A105C(unsigned int a1);
void sub_A108F();
void sub_A10F4();
signed int sub_A11E2();
int __fastcall sub_A121D(int a1, __int16 a2, int a3, int a4);
signed int sub_A1249();
signed int __cdecl sub_A12C5(int a1, int a2, __int16 a3);
signed int __cdecl sub_A14DB(int a1);
unsigned int sub_A1520();
void __cdecl sub_A1524(unsigned int a1);
int __cdecl sub_A158B(int a1, __int16 a2, _WORD *a3, _WORD *a4);
unsigned __int8 __cdecl sub_A1665(int a1);
int sub_A16A2();
unsigned int __cdecl sub_A16AE(int a1);
signed __int32 __cdecl sub_A16F5(int a1, signed __int32 a2);
void __cdecl sub_A171D(int a1);
void sub_A1744();
void __cdecl sub_A1768(int a1);
void sub_A1798();
void __cdecl sub_A17BC(int a1);
void sub_A17EC();
void __cdecl sub_A1810(int a1, int a2);
void __cdecl sub_A1840(int a1, unsigned int a2);
void __cdecl sub_A1870(int a1, unsigned int a2);
int sub_A18B2();
bool sub_A18BE();
// _DWORD fprintf(_DWORD, const char *, ...); weak
// _DWORD __cdecl fopen(_DWORD, _DWORD); weak
// _DWORD __cdecl fclose(_DWORD); weak
bool sub_A1F90();
int __cdecl sub_A2070(int a1);
int *__cdecl sub_A20D0(int *a1);
int __cdecl sub_A2110(_DWORD *a1);
int sub_A2450(); // weak
int __cdecl sub_A2650(int a1);
int __cdecl sub_A2C80(int *a1, const void *a2);
int sub_A2DE0(); // weak
int *__cdecl sub_A2EA0(int a1, const void *a2);
// int *__usercall sub_A3600@<eax>(int a1@<ebx>, int a2, const void *a3);
// int *__usercall sub_A36B0@<eax>(int a1@<ebx>, int a2, int a3, const void *a4);
// int __usercall sub_A3720@<eax>(int a1@<ebx>, int **a2);
int __cdecl sub_A37A0(unsigned int *a1);
int __cdecl sub_A37C0(int a1);
_DWORD *__cdecl sub_A3820(int a1);
int __cdecl sub_A38C0(int a1);
int __cdecl sub_A38E0(_DWORD *a1);
int __cdecl sub_A3A00(int a1);
_DWORD *__cdecl sub_A3A30(_DWORD *a1, int a2, int a3);
int __cdecl sub_A3A70(_DWORD *a1, int a2, int a3);
int __cdecl sub_A3AC0(int a1);
int __cdecl sub_A3AF0(int a1, int a2);
int __cdecl sub_A3B10(int a1);
int __cdecl sub_A3B40(_DWORD *a1, int a2);
int __cdecl sub_A3B80(int a1);
int __cdecl sub_A3BB0(_DWORD *a1, int a2);
int __cdecl sub_A3BF0(int a1);
int __cdecl sub_A3C30(int a1, int a2);
signed int __cdecl sub_A3C60(int a1);
int __cdecl sub_A3C90(int a1, int a2);
int __cdecl sub_A3CB0(int *a1);
int __cdecl sub_A3D30(int a1);
int __cdecl sub_A3D60(int *a1);
int __cdecl sub_A3DA0(int a1);
int __cdecl sub_A3E10(int a1, int a2);
int __cdecl sub_A3E60(int a1, int a2);
int __cdecl sub_A3EB0(int a1, int a2);
int __cdecl sub_A3F00(int a1, int a2, int a3);
int __cdecl sub_A3F30(int a1, int a2);
int __cdecl sub_A3F70(_DWORD *a1, int a2);
int __cdecl sub_A3FE0(int a1);
char __cdecl sub_A4000(_DWORD *a1, int a2, unsigned int a3);
int __cdecl sub_A4100(int *a1, int a2, int a3, int a4);
signed int __cdecl sub_A41B0(_DWORD *a1);
bool sub_A4260();
bool sub_A4330();
int __cdecl sub_A4370(_DWORD *a1);
int __cdecl sub_A4390(int a1);
void __cdecl sub_A43E0(int a1);
int sub_A47A0(); // weak
_DWORD *__cdecl sub_A47C0(int a1, _DWORD *a2);
int sub_A4920(); // weak
_DWORD *__cdecl sub_A4970(int a1, int a2, int a3);
signed int __cdecl sub_A4B20(_DWORD *a1, int a2, int a3);
int __cdecl sub_A4C60(int a1, int a2);
bool sub_A4CB0();
bool sub_A4CF0();
signed int __cdecl sub_A4E10(char a1);
int __cdecl sub_A4EB0(int a1);
int __cdecl sub_A4F10(int a1, char a2, char a3, char a4);
int __cdecl sub_A4FD0(int a1, int a2, unsigned int a3);
int __cdecl sub_A5040(_DWORD *a1);
unsigned int __cdecl sub_A50A0(int a1);
unsigned int __cdecl sub_A50F0(int a1, int a2);
int __cdecl sub_A5210(int a1, char a2, unsigned int a3);
_DWORD *__cdecl sub_A5530(int a1, char a2, unsigned int a3, unsigned __int8 a4);
_DWORD *__cdecl sub_A5850(int a1, char a2, unsigned int a3, signed int a4, int a5);
char __cdecl sub_A5E50(int *a1);
int __cdecl sub_A5F30(int *a1, int a2);
_DWORD *__cdecl sub_A5FD0(int a1, int a2);
_DWORD *__cdecl sub_A6370(_DWORD *a1);
_DWORD *__cdecl sub_A6490(_DWORD *a1);
signed int __cdecl sub_A64C0(int a1);
int sub_A6530(); // weak
int __cdecl sub_A6E00(int *a1, const void *a2);
int sub_A6F30(); // weak
int *__cdecl sub_A6FB0(int a1, const void *a2);
// int *__usercall sub_A77D0@<eax>(int a1@<ebx>, int a2, const void *a3);
// int *__usercall sub_A7880@<eax>(int a1@<ebx>, int a2, int a3, const void *a4);
// int __usercall sub_A78F0@<eax>(int a1@<ebx>, int **a2);
int __cdecl sub_A7970(unsigned int *a1);
signed int __cdecl sub_A7990(_DWORD *a1);
int __cdecl sub_A7AA0(int a1);
_DWORD *__cdecl sub_A7B30(int a1);
int *__cdecl sub_A7BF0(int *a1);
int __cdecl sub_A7C20(int *a1, int a2, int a3);
int *__cdecl sub_A8010(int *a1);
int __cdecl sub_A8050(int *a1);
void __cdecl sub_A8180(_DWORD *a1);
int __cdecl sub_A8250(int a1);
int __cdecl sub_A82A0(int a1, int a2);
void __cdecl sub_A82C0(_DWORD *a1, int a2, int a3);
void __cdecl sub_A8360(_DWORD *a1, int a2, int a3);
int __cdecl sub_A8410(int a1);
signed int __cdecl sub_A8440(int a1);
int __cdecl sub_A8470(int a1);
int __cdecl sub_A84A0(int a1);
_DWORD *__cdecl sub_A84D0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_A8550(int a1);
int __cdecl sub_A8570(int *a1, __int16 a2, __int16 a3);
signed int __cdecl sub_A85B0(int *a1, int a2, int a3);
int __cdecl sub_A8690(int *a1, __int16 a2, __int16 a3);
int __cdecl sub_A86D0(int *a1, __int16 a2, __int16 a3);
int __cdecl sub_A8710(int a1);
int __cdecl sub_A8770(int a1, char a2, unsigned int a3);
int __cdecl sub_A87C0(int a1, int a2);
int __cdecl sub_A8830(_DWORD *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__cdecl sub_A8900(_DWORD *a1, int a2);
int __cdecl sub_A89E0(int a1, int a2);
int __cdecl sub_A8A20(int a1, int a2);
int __cdecl sub_A8A60(int a1, int a2);
int __cdecl sub_A8AA0(int a1, int a2);
int __cdecl sub_A8AE0(int a1, int a2);
int __cdecl sub_A8B20(int a1, int a2);
int __cdecl sub_A8B60(int a1, int a2, int a3);
int __cdecl sub_A8B90(int a1, int a2);
int __cdecl sub_A8BD0(int a1, int a2);
int __cdecl sub_A8BF0(_DWORD *a1);
int __cdecl sub_A8EA0(_DWORD *a1, int a2);
int __cdecl sub_A9080(_DWORD *a1, int a2, int a3);
int __cdecl sub_A9100(int a1, int a2);
_DWORD *__cdecl sub_A9140(_DWORD *a1, int a2, int a3, unsigned int a4, int a5);
int __cdecl sub_A9230(int a1, int a2);
bool sub_A9280();
bool sub_A9590();
_DWORD *__cdecl sub_A95D0(int a1, char a2, unsigned int a3, unsigned __int8 a4);
_DWORD *__cdecl sub_A98D0(_DWORD *a1, int a2, int a3);
int __cdecl sub_A9950(int a1, int a2);
int __cdecl sub_A9A30(int a1, int a2);
int sub_A9C00(); // weak
int sub_A9C50(); // weak
_DWORD *__cdecl sub_AA310(int a1, int a2, int a3, signed int a4);
int __cdecl sub_AA590(int *a1);
bool sub_AA620();
// _DWORD __cdecl creat(_DWORD, _DWORD); weak
// _DWORD __cdecl setmode(_DWORD, _DWORD); weak
// _DWORD __cdecl lseek(_DWORD, _DWORD, char); weak
// _DWORD __cdecl write(_DWORD, _DWORD, _DWORD); weak
int __fastcall sub_AB610(int a1, _DWORD *a2);
// _DWORD __cdecl tolower(_DWORD); weak
signed int __cdecl sub_AB9E1(int a1);
int sub_AC24B();
signed int __cdecl sub_AC250(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, _DWORD *a7, signed int *a8);
void sub_AC449();
void sub_AC44B();
__int16 sub_AC70E();
void sub_AC7D9();
signed __int16 __fastcall sub_AC7F6(int a1, int a2, int a3);
signed __int16 sub_AC843();
signed __int16 sub_AC8DD();
signed __int16 sub_AC918();
void *sub_AC9C3();
void *sub_AC9C9();
// _DWORD __cdecl fputc(_DWORD, _DWORD); weak
signed int __cdecl sub_ACB61(int a1, unsigned __int8 *a2, int *a3);
unsigned __int8 *__cdecl sub_ACD79(unsigned __int8 *a1, int a2);
int __cdecl sub_ACE56(int a1);
// int __usercall sub_ACE8D@<eax>(_WORD *a1@<esi>, int a2, int *a3);
// void __usercall sub_ACF1A(_BYTE *a1@<esi>, int a2, int *a3);
int *__cdecl sub_AD033(int a1, int *a2, int a3);
_BYTE *__cdecl sub_AD09E(_BYTE *a1, int a2);
// void __usercall sub_AD0E2(_BYTE *a1@<esi>, int a2, int *a3, _BYTE **a4);
void __cdecl sub_AD1E8(int a1, int *a2);
void __cdecl sub_AD52B(int a1, int *a2, signed int a3, int a4);
int __cdecl sub_AD754(signed int a1);
int __cdecl sub_AD783(int a1);
// _DWORD __cdecl fgets(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl memmove(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl strncpy(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl dos_read(_DWORD, char, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_ADC52(_BYTE *a1);
int sub_AEAF5();
// int __usercall sub_AEF40@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AEF51@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AEF5D@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AEF7C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// char __usercall sub_AEF90@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// char __usercall sub_AEFAF@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AEFC3@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AEFE0@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AEFF2@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF00F@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF021@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF035@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// __int16 __usercall sub_AF044@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// __int16 __usercall sub_AF05A@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF06B@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF08C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF0A2@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF0C3@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF0D9@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF0FE@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF118@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF13D@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF157@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF17A@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF192@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF1B5@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF1CD@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF1F4@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF210@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF237@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF253@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, signed int *a3@<esi>);
// signed int __usercall sub_AF280@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_AF2A8@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// signed int __usercall sub_AF301@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// char __usercall sub_AF34F@<al>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// char __usercall sub_AF3A8@<al>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_AF3F6@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, signed int *a4@<esi>);
// signed int __usercall sub_AF44D@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, signed int *a4@<esi>);
// int __usercall sub_AF499@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, signed int *a4@<esi>);
// signed int __usercall sub_AF4F0@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, signed int *a4@<esi>);
// int __usercall sub_AF53C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// signed int __usercall sub_AF56C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// __int16 __usercall sub_AF597@<ax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// __int16 __usercall sub_AF5C9@<ax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_AF5F6@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// signed int __usercall sub_AF651@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_AF6A1@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// signed int __usercall sub_AF6FC@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_AF74C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// __int16 __usercall sub_AF7AB@<ax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_AF7FF@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// __int16 __usercall sub_AF85E@<ax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_AF8B2@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>);
// signed int __usercall sub_AF90F@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>);
// int __usercall sub_AF961@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>);
// signed int __usercall sub_AF9BE@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>);
// int __usercall sub_AFA10@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>);
// __int16 __usercall sub_AFA71@<ax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>);
// int __usercall sub_AFAC7@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>);
// __int16 __usercall sub_AFB28@<ax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>);
// int __usercall sub_AFB7E@<eax>(int result@<eax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>);
// int __usercall sub_AFB9F@<eax>(int result@<eax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>);
// int __usercall sub_AFBC3@<eax>(int result@<eax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// int __usercall sub_AFBF5@<eax>(int result@<eax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_AFC27@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>);
// __int16 __usercall sub_AFC4B@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>);
// __int16 __usercall sub_AFC72@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>);
// __int16 __usercall sub_AFCA6@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>);
// __int16 __usercall sub_AFCDA@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>);
// __int16 __usercall sub_AFCF6@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>);
// __int16 __usercall sub_AFD15@<ax>(__int16 result@<ax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_AFD3C@<ax>(__int16 result@<ax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_AFD63@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>);
// __int16 __usercall sub_AFD82@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>);
// __int16 __usercall sub_AFDA4@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>);
// __int16 __usercall sub_AFDCD@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>);
// int __usercall sub_AFDF6@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// int __usercall sub_AFE22@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// int __usercall sub_AFE51@<eax>(int result@<eax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// int __usercall sub_AFE91@<eax>(int result@<eax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// __int16 __usercall sub_AFED1@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>);
// __int16 __usercall sub_AFF03@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>);
// __int16 __usercall sub_AFF38@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>);
// __int16 __usercall sub_AFF7A@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>);
// __int16 __usercall sub_AFFBC@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_AFFE3@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_B000D@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// __int16 __usercall sub_B0042@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// __int16 __usercall sub_B0077@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B00A4@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B00D4@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B010B@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// char __usercall sub_B0142@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// char __usercall sub_B015E@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// char __usercall sub_B0184@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// char __usercall sub_B01AE@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// char __usercall sub_B01D9@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// char __usercall sub_B0203@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// int __usercall sub_B022E@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>);
// int __usercall sub_B0258@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>);
// int __usercall sub_B0292@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>);
// int __usercall sub_B02D5@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>);
// int __usercall sub_B0319@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>);
// int __usercall sub_B035C@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>);
// __int16 __usercall sub_B03A0@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B03C5@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B03FA@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B0432@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B046B@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B04A3@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// char __usercall sub_B04DC@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// char __usercall sub_B0503@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// char __usercall sub_B0534@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, _BYTE *a6@<esi>);
// char __usercall sub_B056C@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, _BYTE *a6@<esi>);
// char __usercall sub_B05A5@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, _BYTE *a6@<esi>);
// char __usercall sub_B05DD@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, _BYTE *a6@<esi>);
// int __usercall sub_B0616@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>);
// int __usercall sub_B064E@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>);
// int __usercall sub_B0696@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>);
// int __usercall sub_B06E7@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>);
// int __usercall sub_B0739@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>);
// int __usercall sub_B078A@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>);
// __int16 __usercall sub_B07DC@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>);
// __int16 __usercall sub_B080F@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>);
// __int16 __usercall sub_B0852@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>);
// __int16 __usercall sub_B0898@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>);
// __int16 __usercall sub_B08DF@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>);
// __int16 __usercall sub_B0925@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>);
int __cdecl sub_B096C(int *a1);
int __cdecl sub_B0B87(_DWORD *a1, int a2);
int __cdecl sub_B0C1A(int a1);
bool sub_B0C46();
char *sub_B0CC8();
void sub_B0CD2();
void sub_B0D52();
void sub_B0D80();
signed int __cdecl sub_B1138(signed int *a1, signed int a2);
int __cdecl sub_B11E8(_DWORD *a1, int a2);
int __cdecl sub_B12A4(int a1);
int __cdecl sub_B1304(int a1, int a2);
int __cdecl sub_B1414(int a1);
int __cdecl sub_B148C(int a1);
int __cdecl sub_B14F8(int *a1, int a2);
// char __usercall sub_B1C58@<al>(__int16 a1@<bx>, int a2, __int16 a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, __int16 a16);
// char __usercall sub_B1D8C@<al>(int a1@<ebp>, int a2@<edi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
int sub_B1DC8(); // weak
// char __usercall sub_B1E11@<al>(int a1@<ebp>, int a2@<edi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_B1E68@<eax>(int result@<eax>, int a2@<ecx>, _BYTE *a3@<ebp>);
// void __usercall sub_B1EB6(int a1@<ebp>);
// void __usercall sub_B1EBC(int a1@<ebp>);
// void __usercall sub_B1EC2(int a1@<ebp>);
// void __usercall sub_B1EC8(int a1@<ebp>);
// void __usercall sub_B1ECE(int a1@<ebp>);
// void __usercall sub_B1ED6(int *a1@<esi>);
// void __usercall sub_B1EDC(int a1@<ebp>);
// void __usercall sub_B1EE2(int a1@<ebp>);
// void __usercall sub_B1EE8(int a1@<ebp>, char *a2@<esi>);
// void __usercall sub_B1EF0(int a1@<ebp>, char *a2@<esi>);
// void __usercall sub_B1EF8(int a1@<ebp>, char *a2@<esi>);
// void __usercall sub_B1F00(int a1@<ebp>, char *a2@<esi>);
// void __usercall sub_B1F08(int a1@<ebp>, char *a2@<esi>);
// void __usercall sub_B1F12(int a1@<ebp>, char *a2@<esi>);
// void __usercall sub_B1F1C(int a1@<ebp>, char *a2@<esi>);
// void __usercall sub_B1F24(int a1@<ebp>, char *a2@<esi>);
// void __usercall sub_B1F2C(int a1@<ebp>, _DWORD *a2@<esi>);
// void __usercall sub_B1F35(int a1@<ebp>, _DWORD *a2@<esi>);
// void __usercall sub_B1F3E(int a1@<ebp>, _DWORD *a2@<esi>);
// void __usercall sub_B1F47(int a1@<ebp>, _DWORD *a2@<esi>);
// void __usercall sub_B1F50(int a1@<ebp>, _DWORD *a2@<esi>);
// void __usercall sub_B1F5B(int a1@<ebp>, _DWORD *a2@<esi>);
// void __usercall sub_B1F66(int a1@<ebp>, _DWORD *a2@<esi>);
// void __usercall sub_B1F6F(int a1@<ebp>, _DWORD *a2@<esi>);
// int __usercall sub_B1F78@<eax>(unsigned __int8 a1@<ah>, unsigned int a2@<ebx>, int a3@<ebp>, _BYTE *a4@<esi>);
// int __usercall sub_B1FB5@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_B1FD4@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>);
// char __usercall sub_B1FF3@<al>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>, __int16 bx0@<bx>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B200F@<al>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>, int _4, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_B202B@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_B204A@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_B2069@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_B2088@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>);
// char __usercall sub_B20A7@<al>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B20E1@<al>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>, __int16 bx0@<bx>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B20F2@<al>(int a1@<ebp>, int a2@<edi>, int *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char __usercall sub_B2103@<al>(void *a1@<ebp>, const void *a2@<esi>, __int16 bx0@<bx>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char __usercall sub_B2121@<al>(int a1@<ebp>, __int16 *a2@<esi>, __int16 bx0@<bx>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char __usercall sub_B2161@<al>(const void *a1@<ebp>, void *a2@<esi>, __int16 di0@<di>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char __usercall sub_B2175@<al>(_WORD *a1@<ebp>, _WORD *a2@<esi>, __int16 bx0@<bx>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_B2183@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// int __usercall sub_B21A2@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// char __usercall sub_B21C1@<al>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>, __int16 bx0@<bx>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B21DD@<al>(int a1@<ebp>, int a2@<edi>, int *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_B21F9@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// int __usercall sub_B2218@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// int __usercall sub_B2237@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// int __usercall sub_B2256@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// char __usercall sub_B2275@<al>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B22AF@<al>(_WORD *a1@<ebp>, int a2@<edi>, _DWORD *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B22EB@<al>(int a1@<ebp>, int a2@<edi>, _DWORD *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_B230F@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>);
// int __usercall sub_B2332@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>);
// char __usercall sub_B2355@<al>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B2375@<al>(int a1@<ebp>, int a2@<edi>, __int64 *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_B2395@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>);
// int __usercall sub_B23B8@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>);
// int __usercall sub_B23DB@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>);
// int __usercall sub_B23FE@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>);
// char __usercall sub_B2421@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B2468@<al>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B24A6@<al>(_BYTE *a1@<ebp>, int a2@<edi>, int *a3@<esi>, __int16 bx0@<bx>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B24BB@<al>(int a1@<ebp>, int a2@<edi>, int esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char __usercall sub_B24D9@<al>(int a1@<ebp>, int a2@<edi>, int *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char __usercall sub_B24EE@<al>(_DWORD *a1@<ebp>, _DWORD *a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// void __usercall sub_B2535(char *a1@<ebp>, int a2@<edi>, _DWORD *a3@<esi>);
// char __usercall sub_B2560@<al>(int a1@<ebp>, _WORD *a2@<esi>, __int16 bx0@<bx>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_B256E@<eax>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>);
// int __usercall sub_B258F@<eax>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>);
// char __usercall sub_B25B0@<al>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>, __int16 bx0@<bx>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B25CE@<al>(int a1@<ebp>, int a2@<edi>, signed __int16 *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_B25EC@<eax>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>);
// int __usercall sub_B260D@<eax>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>);
// int __usercall sub_B262E@<eax>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>);
// int __usercall sub_B264F@<eax>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>);
// char __usercall sub_B2670@<al>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B26AC@<al>(_WORD *a1@<ebp>, int a2@<edi>, _WORD *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B26F4@<al>(int a1@<ebp>, int a2@<edi>, _WORD *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char __usercall sub_B2729@<al>(int a1@<ebp>, int a2@<edi>, unsigned int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B2768@<al>(int a1@<ebp>, int a2@<edi>, int *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
void sub_B2791();
// int __usercall sub_B27BE@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B27D3@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// char __usercall sub_B27E8@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, __int16 bx0@<bx>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B27FA@<al>(int a1@<ebp>, int a2@<edi>, int esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_B280C@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B2821@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B2836@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B284B@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// char __usercall sub_B2860@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B28A8@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B2912@<al>(int a1@<ebp>, int a2@<edi>, __int16 bx0@<bx>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char __usercall sub_B2951@<al>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B2B6C@<al>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4@<ebp>, int a5@<edi>, int a6@<esi>, int a7, __int16 a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, __int16 a21);
void __fastcall sub_B2D8E(int a1, int a2, int a3);
void __fastcall sub_B2E17(int a1, int a2, int a3);
// int __usercall sub_B2E71@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B2E86@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B2E9B@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B2EB0@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B2EC5@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B2EDA@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// char __usercall sub_B2EEF@<al>(int a1@<ebp>, int a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char __usercall sub_B2F0E@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B2F3A@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, __int16 bx0@<bx>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char __usercall sub_B2F4C@<al>(int a1@<ebp>, int a2@<edi>, int esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char __usercall sub_B2F5E@<al>(int a1@<ebp>, int a2@<edi>, int esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_B2F8A@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B2FD5@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
void __fastcall sub_B3020(int a1, int a2, int a3);
// int __usercall sub_B30A9@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B30F4@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B313F@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B318A@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
void sub_B31D5();
void __fastcall sub_B336E(int a1, int a2);
// int __usercall sub_B337C@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>);
// int __userpurge sub_B33A6@<eax>(int a1@<eax>, int a2@<esi>, int a3, int a4, __int16 a5);
// int __usercall sub_B33D6@<eax>(unsigned __int64 a1@<edx:eax>, int a2@<ecx>, int a3@<ebx>, int a4@<esi>);
int __fastcall sub_B3542(int a1, int a2);
// int __usercall sub_B35DB@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebp>, int a4@<esi>);
// int __usercall sub_B3605@<eax>(unsigned __int64 a1@<edx:eax>, int a2@<ecx>, unsigned int a3@<ebx>, _BYTE *a4@<ebp>, int a5@<esi>);
// int __usercall sub_B37B0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>);
// int __usercall sub_B37DA@<eax>(unsigned __int64 a1@<edx:eax>, unsigned int a2@<ecx>, unsigned int a3@<ebx>, int a4@<esi>);
void sub_B392B();
int __fastcall sub_B3930(int *a1);
int __fastcall sub_B399A(int a1, int a2);
int __fastcall sub_B39AB(unsigned int a1, int a2);
// int __usercall sub_B39E0@<eax>(__int64 a1@<edx:eax>, int a2@<ebx>, _BYTE *a3@<ebp>);
int __fastcall sub_B3A60(int a1);
// int __usercall sub_B3ADF@<eax>(__int64 *a1@<eax>, _BYTE *a2@<ebp>);
signed int __fastcall sub_B3BA6(signed int result, int a2);
unsigned int __fastcall sub_B3C6B(unsigned int result, signed __int16 a2);
// __int16 __usercall sub_B3DF8@<ax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _BYTE *a4@<ebp>, int a5@<esi>);
// __int16 __usercall __spoils<ecx> sub_B3EAE@<ax>(int a1@<eax>, _BYTE *a2@<ebp>, int a3@<esi>);
// int __usercall sub_B4011@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>);
// int __usercall sub_B4077@<eax>(__int64 a1@<edx:eax>, unsigned int a2@<ecx>, unsigned int a3@<ebx>, __int16 a4@<di>, __int16 a5@<si>);
// int __usercall sub_B41E0@<eax>(int a1@<eax>, _BYTE *a2@<ebp>, int a3@<esi>);
// int __usercall sub_B41F9@<eax>(int a1@<eax>, _BYTE *a2@<ebp>, int a3@<esi>);
// int __usercall sub_B423C@<eax>(int a1@<eax>, _BYTE *a2@<ebp>);
// int __usercall sub_B44D4@<eax>(int a1@<eax>, int a2@<esi>);
int __fastcall sub_B46CB(int a1);
int __fastcall sub_B46D5(int a1);
int __fastcall sub_B46E2(int a1);
int sub_B46F0(); // weak
int __fastcall sub_B4718(int a1, int a2, int a3, int a4);
int __fastcall sub_B48EC(unsigned __int64 a1);
// void __usercall sub_B49D8(int a1@<ecx>, int a2@<esi>);
// int __usercall sub_B4A2A@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<esi>);
// int __fastcall _hook387(_DWORD, _DWORD, _DWORD); weak
// int _FDFS(void); weak
// _DWORD __cdecl fputs(_DWORD, _DWORD); weak
// _DWORD __cdecl strerror(_DWORD); weak
void __spoils<edx,ecx> sub_B4F46();
void __spoils<edx,ecx> sub_B4FA3();
void sub_B5000();
void __noreturn sub_B5015();
void __noreturn sub_B5022();
// void __usercall sub_B5128(__int16 a1@<bx>, int a2@<ebp>, double *a3@<edi>, double a4@<st0>);
// void __usercall sub_B51B3(__int16 a1@<bx>, int a2@<ebp>, double *a3@<edi>, __int16 a4@<fpstat>, double a5@<st0>);
// double __usercall sub_B5205@<st0>(char a1@<bh>, int a2@<ebp>, __int16 a3@<fpstat>, double a4@<st0>);
// __int64 __usercall sub_B522B@<edx:eax>(int a1@<edx>, __int16 a2@<bx>, int _ESI@<esi>);
// double __usercall sub_B5250@<st0>(char a1@<bl>, double *a2@<edi>, double result@<st0>);
// int _Phar_hook_init(void); weak
// int _Phar_hook_fini(void); weak
// int _DOS4G_hook_init(void); weak
// int _DOS4G_hook_fini(void); weak
// int __cdecl _Ergo_hook_init(_DWORD, _DWORD); weak
// int __cdecl _Ergo_hook_fini(_DWORD); weak
// int _Intel_hook_init(void); weak
// int _Intel_hook_fini(void); weak
int sub_B5C5B();
int __cdecl sub_B5C60(__int16 a1, __int16 a2);
int __cdecl sub_B5D68(__int16 a1, __int16 a2);
void __cdecl __spoils<ecx> sub_B5E70(__int16 a1, unsigned __int16 a2, __int16 a3);
// __int16 __usercall sub_B5EFA@<ax>(__int16 a1@<cx>, int a2@<ebx>, int a3@<ebp>, __int16 a4@<si>);
// __int16 __usercall sub_B5F8F@<ax>(__int16 a1@<cx>, int a2@<ebx>, int a3@<ebp>, __int16 a4@<si>);
void __cdecl __spoils<ecx> sub_B6253(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void __cdecl __spoils<> sub_BCD45(int a1, int a2, int a3, int a4, int a5);
void __cdecl __spoils<ecx> sub_BD1B6(int a1);
void __cdecl __spoils<ecx> sub_BD2CB(int a1);
// int __usercall sub_BD320@<eax>(int result@<eax>, _BYTE *a2@<edx>, _BYTE *a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<esi>);
void sub_BD3DD();
void __cdecl sub_BD524(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
void __cdecl __spoils<ecx> sub_BD542(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, char a5);
// int __fastcall gettextposition(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl settextposition(_DWORD, _DWORD); weak
// _DWORD __cdecl outtext(_DWORD); weak
int sub_BF123();
int __far sub_C0000(); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_10001; // weak
void *off_1B190 = &loc_1B2E6; // weak
_UNKNOWN loc_20000; // weak
_UNKNOWN loc_2FED1; // weak
_UNKNOWN loc_2FED5; // weak
_UNKNOWN loc_3030E; // weak
_UNKNOWN loc_30325; // weak
_UNKNOWN loc_36479; // weak
_UNKNOWN loc_364D1; // weak
_UNKNOWN loc_3653D; // weak
_UNKNOWN loc_36541; // weak
_UNKNOWN loc_36543; // weak
_UNKNOWN loc_36546; // weak
_UNKNOWN loc_3654B; // weak
_UNKNOWN loc_3654E; // weak
_UNKNOWN loc_36550; // weak
char byte_3659C[] = { 'f' }; // weak
char byte_3659D[] = { '\x89' }; // weak
char byte_3659F[] = { ',' }; // weak
_UNKNOWN loc_365F2; // weak
_UNKNOWN loc_36CAA; // weak
_UNKNOWN loc_36DE9; // weak
_UNKNOWN loc_36DEC; // weak
_UNKNOWN loc_36DFC; // weak
_UNKNOWN loc_36E03; // weak
_UNKNOWN loc_36E09; // weak
_UNKNOWN loc_36F44; // weak
_UNKNOWN loc_3A013; // weak
_UNKNOWN loc_40000; // weak
_UNKNOWN loc_42471; // weak
_UNKNOWN loc_4AFFE; // weak
char algn_4BB85[11] = { '\x8D', '\x80', '\0', '\0', '\0', '\0', '\x8D', 'R', '\0', '\x8B', '' }; // weak
_UNKNOWN loc_4D54A; // weak
void *off_55C38 = &loc_55CB2; // weak
_UNKNOWN loc_568AA; // weak
void *off_5B0E4 = &loc_5B1BA; // weak
int (*off_5FA4C[7])() =
{
  &sub_5FA96,
  &sub_5FBB1,
  &sub_5FB09,
  &sub_5FB22,
  &sub_5FB3A,
  &sub_5FB8C,
  &sub_5FBB1
}; // weak
_UNKNOWN loc_5FBBE; // weak
void *off_607E8 = &loc_608FD; // weak
_UNKNOWN loc_64000; // weak
_UNKNOWN loc_712C2; // weak
__int16 word_727B0[] = { 1 }; // weak
void *off_75628 = &loc_75779; // weak
_UNKNOWN loc_783BD; // weak
void *off_790E4 = &loc_79404; // weak
void *off_79118 = &loc_79463; // weak
_UNKNOWN loc_7FFFF; // weak
_UNKNOWN loc_87D80; // weak
void *off_88D1C = &loc_88FD9; // weak
_UNKNOWN loc_917D0; // weak
void *off_91856 = (void *)0x152E9; // weak
_UNKNOWN loc_91C54; // weak
// extern _UNKNOWN _GETDS; weak
_UNKNOWN loc_9AEE8; // weak
void *off_9B844 = &loc_9B94B; // weak
// extern _UNKNOWN loc_A0000; weak
int dword_A1270 = 1397753374; // weak
__int16 word_A1277 = 39321; // weak
__int16 word_A1286 = 39321; // weak
int dword_A128C = 2576980377; // weak
__int16 word_A12A2 = 39321; // weak
__int16 word_A12AC = 39321; // weak
__int16 word_A12B3 = 39321; // weak
void *off_A4400 = &loc_A4459; // weak
int dword_A9390[] = { 8 }; // weak
_UNKNOWN loc_ACF14; // weak
int (*off_AEB40[2])() = { &sub_AEF40, &sub_AEF51 }; // weak
int (*off_AED40[2])() = { &sub_AFB7E, &sub_AFB9F }; // weak
_UNKNOWN loc_AFFFE; // weak
int dword_B184C[2] = { 0, 0 }; // weak
void *off_B1854 = &loc_A0000; // weak
int dword_B1858[2] = { 70, 0 }; // weak
int dword_B1860[41] =
{
  20,
  67584,
  1966080,
  268435466,
  2,
  1310760,
  202752,
  3276800,
  536870942,
  4,
  2621500,
  337920,
  4587520,
  805306418,
  6,
  3932160,
  473088,
  4294705152,
  1,
  196610,
  327667,
  524288,
  4291756044,
  16,
  3145760,
  4259647,
  8388608,
  4244570304,
  256,
  50332160,
  67171327,
  134217728,
  3489598464,
  4096,
  805314560,
  1073758207,
  2147483648,
  1073856512,
  33572096,
  50414144,
  3683074881
}; // weak
int (*off_B1904[57])() =
{
  &sub_B1EB6,
  &sub_B1EBC,
  &sub_B1EC2,
  &sub_B1EC8,
  &sub_B1F78,
  &sub_B1ED6,
  &sub_B1EDC,
  &sub_B1EE2,
  &sub_B1EE8,
  &sub_B1EF0,
  &sub_B1EF8,
  &sub_B1F00,
  &sub_B1F78,
  &sub_B1F12,
  &sub_B1F1C,
  &sub_B1F24,
  &sub_B1F2C,
  &sub_B1F35,
  &sub_B1F3E,
  &sub_B1F47,
  &sub_B1F78,
  &sub_B1F5B,
  &sub_B1F66,
  &sub_B1F6F,
  &sub_B1EB6,
  &sub_B1EBC,
  &sub_B1EC2,
  &sub_B1EC8,
  &sub_B1ECE,
  &sub_B1ED6,
  &sub_B1EDC,
  &sub_B1EE2,
  &sub_B1EE8,
  &sub_B1EF0,
  &sub_B1EF8,
  &sub_B1F00,
  &sub_B1F08,
  &sub_B1F12,
  &sub_B1F1C,
  &sub_B1F24,
  &sub_B1F2C,
  &sub_B1F35,
  &sub_B1F3E,
  &sub_B1F47,
  &sub_B1F50,
  &sub_B1F5B,
  &sub_B1F66,
  &sub_B1F6F,
  &sub_B1FB5,
  &sub_B20A7,
  &sub_B2183,
  &sub_B2275,
  &sub_B230F,
  &sub_B2468,
  &sub_B256E,
  &sub_B2670,
  &sub_B1FD4
}; // weak
int (*off_B1964[33])() =
{
  &sub_B1EB6,
  &sub_B1EBC,
  &sub_B1EC2,
  &sub_B1EC8,
  &sub_B1ECE,
  &sub_B1ED6,
  &sub_B1EDC,
  &sub_B1EE2,
  &sub_B1EE8,
  &sub_B1EF0,
  &sub_B1EF8,
  &sub_B1F00,
  &sub_B1F08,
  &sub_B1F12,
  &sub_B1F1C,
  &sub_B1F24,
  &sub_B1F2C,
  &sub_B1F35,
  &sub_B1F3E,
  &sub_B1F47,
  &sub_B1F50,
  &sub_B1F5B,
  &sub_B1F66,
  &sub_B1F6F,
  &sub_B1FB5,
  &sub_B20A7,
  &sub_B2183,
  &sub_B2275,
  &sub_B230F,
  &sub_B2468,
  &sub_B256E,
  &sub_B2670,
  &sub_B1FD4
}; // weak
_UNKNOWN loc_B27B9; // weak
void *off_B2947 = &unk_17A6E8; // weak
_UNKNOWN loc_B2C44; // weak
int (__cdecl *off_B2D96)(__int16, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16) = &sub_B278C; // weak
int (__cdecl *off_B2E1F[2])(__int16, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16) = { &sub_B278C, &sub_B278C }; // weak
_UNKNOWN loc_B2E4B; // weak
int (__cdecl *off_B3028)(__int16, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16) = &sub_B278C; // weak
_UNKNOWN loc_B335E; // weak
_UNKNOWN loc_B3383; // weak
_UNKNOWN loc_B3933; // weak
_UNKNOWN loc_B39B3; // weak
int dword_B3BEB[] = { 2147483647 }; // weak
__int16 word_B3D9E = 6222; // weak
__int16 word_B419A = 18153; // weak
int dword_B41B8 = 0; // weak
__int16 word_B440E[] = { 21337 }; // weak
int dword_B4468[19] =
{
  2646669455,
  3611270969,
  3909435346,
  2772829156,
  3218786763,
  3334782378,
  2406926207,
  3818340322,
  2109457658,
  3219756018,
  218157069,
  3490513104,
  3054190575,
  1622543200,
  3220551179,
  2863311530,
  2863311530,
  16378,
  0
}; // weak
__int16 word_B44C2[] = { 0 }; // weak
int dword_B8845[] = { 0 }; // weak
_UNKNOWN loc_BD550; // weak
char byte_C0134[3788] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char aDataSearchDat[16] = "data/search.dat"; // weak
char aNoHelpData[13] = "No Help Data"; // weak
char aOk[4] = "@OK"; // weak
char aSS[7] = "%s:%s."; // weak
char aSS_0[8] = "%s. %s."; // weak
char aSS_1[6] = "%s %s"; // weak
char aYS[5] = "y_%s"; // weak
char aSS_2[8] = "[%s] %s"; // weak
char aD[3] = "%d"; // weak
char a03d[5] = "%03d"; // weak
char aOk_0[6] = " * OK"; // weak
char aNS[5] = "n%s?"; // weak
char aSound[6] = "sound"; // weak
char aNetherw[9] = "/netherw"; // weak
char aSS_3[6] = "%s/%s"; // weak
char aErrorNotEnough[37] = "ERROR: NOT ENOUGH MEMORY FOR SOUNDS\n"; // weak
char aDataMwebd00Tab[18] = "data/mwebd0-0.tab"; // weak
char aDataHwebd00Tab[18] = "data/hwebd0-0.tab"; // weak
char aDataMwebn00Tab[18] = "data/mwebn0-0.tab"; // weak
char aDataHwebn00Tab[18] = "data/hwebn0-0.tab"; // weak
char aDataMwebc00Tab[18] = "data/mwebc0-0.tab"; // weak
char aDataHwebc00Tab[18] = "data/hwebc0-0.tab"; // weak
char aDataMsprd00Dat_0[18] = "data/msprd0-0.dat"; // weak
char aS[3] = "%s"; // weak
char aDataMsprd00Tab[18] = "data/msprd0-0.tab"; // weak
char aDataHsprd00Dat_0[18] = "data/hsprd0-0.dat"; // weak
char aDataHsprd00Tab[18] = "data/hsprd0-0.tab"; // weak
char aDataMsprn00Dat[18] = "data/msprn0-0.dat"; // weak
char aDataMsprn00Tab[18] = "data/msprn0-0.tab"; // weak
char aDataHsprn00Dat[18] = "data/hsprn0-0.dat"; // weak
char aDataHsprn00Tab[18] = "data/hsprn0-0.tab"; // weak
char aDataMsprc00Dat[18] = "data/msprc0-0.dat"; // weak
char aDataMsprc00Tab[18] = "data/msprc0-0.tab"; // weak
char aDataHsprc00Dat[18] = "data/hsprc0-0.dat"; // weak
char aDataHsprc00Tab[18] = "data/hsprc0-0.tab"; // weak
char aDataPald0Dat[16] = "data/pald-0.dat"; // weak
char aDataClrd0Dat[16] = "data/clrd-0.dat"; // weak
char aDataPalf0Dat[16] = "data/palf-0.dat"; // weak
char aDataPaln0Dat[16] = "data/paln-0.dat"; // weak
char aDataClrn0Dat[16] = "data/clrn-0.dat"; // weak
char aDataPalc0Dat[16] = "data/palc-0.dat"; // weak
char aDataClrc0Dat[16] = "data/clrc-0.dat"; // weak
char aDataSmatitleDa[18] = "data/smatitle.dat"; // weak
char aDataSmatitl2Da[18] = "data/smatitl2.dat"; // weak
char aDataSmatitlePa[18] = "data/smatitle.pal"; // weak
char aDataSmatitl2Pa[18] = "data/smatitl2.pal"; // weak
char aC[3] = "%c"; // weak
char aCheatAccessAll[28] = ".. CHEAT: access all spells"; // weak
char aCheatMoreMana[20] = ".. CHEAT: more mana"; // weak
char aCheatDestroyAl[30] = ".. CHEAT: destroy all players"; // weak
char aCheatDestroyAl_0[30] = ".. CHEAT: destroy all castles"; // weak
char aCheatDestroyAl_1[31] = ".. CHEAT: destroy all balloons"; // weak
char aCheatHeal[15] = ".. CHEAT: heal"; // weak
char aCheatKillAllCr[29] = ".. CHEAT: Kill all creatures"; // weak
char aCheatMoreSpell[39] = ".. CHEAT: More Spell Experience Points"; // weak
char aCheatFreeSpell[31] = ".. CHEAT: Free Spell Usage OFF"; // weak
char aCheatFreeSpell_0[30] = ".. CHEAT: Free Spell Usage ON"; // weak
char aCheatInvincabi[27] = ".. CHEAT: Invincability ON"; // weak
char aCheatInvincabi_0[28] = ".. CHEAT: Invincability OFF"; // weak
char aClevels[8] = "clevels"; // weak
char aNetherw_0[9] = "/netherw"; // weak
char aCSSLevelsDat[20] = "%c:%s/%s/levels.dat"; // weak
char aLevelsLevelsDa[18] = "levels/levels.dat"; // weak
char aCSSLevelsTab[20] = "%c:%s/%s/levels.tab"; // weak
char aLevelsLevelsTa[18] = "levels/levels.tab"; // weak
char aErrorDecompres[32] = "ERROR decompressing levels.dat\n"; // weak
char aMovie[6] = "movie"; // weak
char aSGam05dDat[15] = "%s/gam%05d.dat"; // weak
char aSMap05dDat[15] = "%s/map%05d.dat"; // weak
char aDataBldgprmDat[17] = "data/bldgprm.dat"; // weak
char aSMvi05dDat[15] = "%s/mvi%05d.dat"; // weak
char aCS[6] = "%c:%s"; // weak
char aVe[4] = "ve/"; // weak
char aErrorDecompres_0[24] = "ERROR decompressing %s\n"; // weak
char aSSTab[10] = "%s/%s.tab"; // weak
char aSSDat[10] = "%s/%s.dat"; // weak
char aDC[5] = "%d%c"; // weak
char aCheckingSetupV[26] = "Checking Setup Version .."; // weak
char aVersionDat[12] = "version.dat"; // weak
char aCdata[6] = "cdata"; // weak
char aCSSS[12] = "%c:%s/%s/%s"; // weak
char asc_D0650[2] = "\n"; // weak
char aTmaps00[9] = "tmaps0-0"; // weak
char aCSSSDat[16] = "%c:%s/%s/%s.dat"; // weak
char aDataSDat[12] = "data/%s.dat"; // weak
char aCreatingSetupD[32] = "Creating Setup Directories 1 .."; // weak
char aCSS[9] = "%c:%s/%s"; // weak
char aData[5] = "data"; // weak
char aTmaps10[9] = "tmaps1-0"; // weak
char aCreatingSetupD_0[32] = "Creating Setup Directories 2 .."; // weak
char aTmaps20[9] = "tmaps2-0"; // weak
char aCreatingSetupD_1[32] = "Creating Setup Directories 3 .."; // weak
char aSettingUpLevel[21] = "Setting Up Levels .."; // weak
char aLevels[7] = "levels"; // weak
char aDataBlock16Dat_0[17] = "data/block16.dat"; // weak
char aDataSkyd00Dat[17] = "data/skyd0-0.dat"; // weak
char aDataBlock32Dat_0[17] = "data/block32.dat"; // weak
char aDataTmaps00Tab[18] = "data/tmaps0-0.tab"; // weak
char aDataBl16f00Dat[18] = "data/bl16f0-0.dat"; // weak
char aDataBl16n00Dat[18] = "data/bl16n0-0.dat"; // weak
char aDataSkyn00Dat[17] = "data/skyn0-0.dat"; // weak
char aDataBl32f00Dat[18] = "data/bl32f0-0.dat"; // weak
char aDataBl32n00Dat[18] = "data/bl32n0-0.dat"; // weak
char aDataTmaps10Tab[18] = "data/tmaps1-0.tab"; // weak
char aDataBl16c00Dat[18] = "data/bl16c0-0.dat"; // weak
char aDataBl32c00Dat[18] = "data/bl32c0-0.dat"; // weak
char aDataTmaps20Tab[18] = "data/tmaps2-0.tab"; // weak
char aDataTablesdDat[17] = "data/tablesd.dat"; // weak
char aDataTablesnDat[17] = "data/tablesn.dat"; // weak
char aDataTablescDat[17] = "data/tablesc.dat"; // weak
char aSmap[5] = "SMAP"; // weak
char aSS03dDat[14] = "%s/%s%03d.dat"; // weak
char aSlev[5] = "SLEV"; // weak
char aSave[5] = "save"; // weak
char aCSSSDDat[18] = "%c:%s/%s/%s%d.dat"; // weak
char aSver[5] = "SVER"; // weak
char aDeviceNoneDriv[82] = "DEVICE\t\tNone\r\nDRIVER\t\tNone\r\nIO_ADDR\t\t-1\r\nIRQ\t\t-1\r\nDMA_8_BIT\t\t-1\r\nDMA_16_BIT\t\t-1\r\n"; // weak
char aSound_0[6] = "sound"; // weak
char aNetherw_1[9] = "/netherw"; // weak
char aCSSDigIni[17] = "%c:%s/%s/dig.ini"; // weak
char aCSSMdiIni[17] = "%c:%s/%s/mdi.ini"; // weak
char aNetwork[8] = "network"; // weak
char aLevel[6] = "level"; // weak
char aHarddrive[10] = "harddrive"; // weak
char aSkipscreens[12] = "skipscreens"; // weak
char aNocd[5] = "nocd"; // weak
char aShowversion[12] = "showversion"; // weak
char aShowversion2[13] = "showversion2"; // weak
char aDetectoff[10] = "detectoff"; // weak
char aLangcheck[10] = "langcheck"; // weak
char aMavio[6] = "MAvio"; // weak
char aExtern[7] = "extern"; // weak
char aExternalCtrlAt[22] = "External ctrl at %ul\n"; // weak
char aVfx1[5] = "VFX1"; // weak
char aScc[6] = "/%scc"; // weak
char aSpellsedit[11] = "spellsedit"; // weak
char aMusic2[7] = "music2"; // weak
char aErrorCantAlloc[31] = "ERROR: CANT ALLOC TAPE MEMORY."; // weak
char aErrorCantAlloc_0[33] = "ERROR: CANT ALLOC CARPET MEMORY."; // weak
char aDataPald0Dat_0[16] = "data/pald-0.dat"; // weak
char aDataClrd0Dat_0[16] = "data/clrd-0.dat"; // weak
char aSave_0[5] = "save"; // weak
char aNetherw_2[9] = "/netherw"; // weak
char aCdata_0[6] = "cdata"; // weak
char aClevels_0[8] = "clevels"; // weak
char aSound_1[6] = "sound"; // weak
char aLanguage[9] = "language"; // weak
char aShots[6] = "shots"; // weak
char aDataSpellsDat[16] = "data/spells.dat"; // weak
char aErrorMouseDriv[36] = "ERROR : MOUSE DRIVER NOT INSTALLED\n"; // weak
char aErrorCopyingDa[42] = "ERROR COPYING DATA FILES TO LOCAL DRIVE \n"; // weak
char aErrorCreatingS[35] = "Error creating setup directories.\n"; // weak
char aNoVesaDriverDe[25] = "NO VESA DRIVER DETECTED\n"; // weak
char aNotEnoughMemor[19] = "NOT ENOUGH MEMORY\n"; // weak
char byte_D0C18 = '\0'; // weak
char aTa[5] = "ta/\n"; // weak
char asc_D0C20[61] = "***********************************************************\n"; // weak
char aTestersWriteDo[61] = "*   TESTERS: WRITE DOWN THE ABOVE VERSION DATE AND TIME.  *\n"; // weak
char aPressReturnToC[61] = "*   Press RETURN to continue...                           *\n"; // weak
char asc_D0CE0[61] = "***********************************************************\n"; // weak
char aDataGtd2Dat[14] = "data/gtd2.dat"; // weak
char aProductName[13] = "Product name"; // weak
char aMagicCarpet2Ne[30] = "Magic Carpet 2 (Netherworlds)"; // weak
char aVersionNumber[15] = "Version number"; // weak
char aBeta[5] = "Beta"; // weak
char aVersionDate[13] = "Version date"; // weak
char aSep061995[12] = "Sep 06 1995"; // weak
char a034213[9] = "03:42:13"; // weak
char aSS_4[6] = "%s %s"; // weak
char aProgrammer[11] = "Programmer"; // weak
char aBullfrogAlanWr[23] = "Bullfrog, Alan Wright."; // weak
char aSuppliedTo[12] = "Supplied to"; // weak
char aPublic[7] = "PUBLIC"; // weak
char aLevelNumber[13] = "Level Number"; // weak
char aApD[6] = "_AP%d"; // weak
char aTransferRate[15] = "Transfer rate:"; // weak
char aHfps[5] = "hFPS"; // weak
char aSoundNumber[13] = "Sound Number"; // weak
char aGameTurn[10] = "Game turn"; // weak
char aDD[6] = "%d %d"; // weak
char aThing[6] = "Thing"; // weak
char aThingDActiveD[20] = "Thing %d, Active %d"; // weak
char aCarpetD[10] = "Carpet %d"; // weak
char aTapeD[8] = "Tape %d"; // weak
char aHeapD[8] = "Heap %d"; // weak
char aMemoryUsedFree[19] = "Memory (Used/Free)"; // weak
char aDD_0[6] = "%d/%d"; // weak
char aS77dU01d[13] = "s%7.7d,u%01d"; // weak
char aThing_0[6] = "THING"; // weak
char aLdLd[10] = "%ld / %ld"; // weak
char aClassModelStat[22] = "CLASS / MODEL / STATE"; // weak
char aLdLdLd[16] = "%ld / %ld / %ld"; // weak
char aLifeMaxLife[16] = "LIFE / MAX LIFE"; // weak
char aSpeedActualMin[33] = "SPEED ACTUAL / MINIMUM / MAXIMUM"; // weak
char aActualXYZ[17] = "ACTUAL X / Y / Z"; // weak
char aIdWhoOwnsMe[17] = "ID / WHO OWNS ME"; // weak
char aManaActualMaxi[22] = "MANA ACTUAL / MAXIMUM"; // weak
char aCopyrightC1995[46] = "Copyright (c) 1995 Bullfrog Productions Ltd.\n"; // weak
char aAllRightsReser[22] = "All rights reserved.\n"; // weak
char aS_0[5] = "%s \n"; // weak
void *off_D189C = (void *)0xA7325; // weak
char aTmaps00_0[9] = "tmaps0-0"; // weak
char aCdata_1[6] = "cdata"; // weak
char aNetherw_4[9] = "/netherw"; // weak
char aCSSSDat_0[16] = "%c:%s/%s/%s.dat"; // weak
char aDataSDat_0[12] = "data/%s.dat"; // weak
char aTmaps10_0[9] = "tmaps1-0"; // weak
char aTmaps20_0[9] = "tmaps2-0"; // weak
char aErrorDecompres_1[30] = "ERROR decompressing tmap%03d\n"; // weak
char aSD[5] = "%s%d"; // weak
char aErrorCodeListe[25] = "Error code (LISTEN) : %d"; // weak
char aErrorCodeCallD[23] = "Error code (CALL) : %d"; // weak
char asc_D1949[2] = " "; // weak
char aVipport[8] = "VIPPORT"; // weak
char aErrorUnknownFr[26] = "ERROR UNKNOWN FRAME TYPE\n"; // weak
char aColour256[11] = "COLOUR256 "; // weak
char aSs2[5] = "SS2 "; // weak
char aColour[8] = "COLOUR "; // weak
char aLc[4] = "LC "; // weak
char aBlack[7] = "BLACK "; // weak
char aBrun[6] = "BRUN "; // weak
char aCopy[6] = "COPY "; // weak
char aPstamp[8] = "PSTAMP "; // weak
char aNetherwConfigD[21] = ":/NETHERW/CONFIG.DAT"; // weak
char aCS_0[5] = "%c%s"; // weak
char aNetherwLanguag[19] = ":/NETHERW/LANGUAGE"; // weak
char aCSLDTxt[13] = "%c%s/L%d.txt"; // weak
char aLanguageLDTxt[17] = "LANGUAGE/L%d.txt"; // weak
char aDataScreensHsc[26] = "DATA/SCREENS/HSCREEN0.DAT"; // weak
char aIntroIntroDat[16] = "intro\\intro.dat"; // weak
char aIntroIntro2Dat[17] = "intro\\intro2.dat"; // weak
char aNethD[7] = "NETH%d"; // weak
char aLanguageLTxt[16] = "LANGUAGE/L*.TXT"; // weak
char aLanguageDTxt[16] = "LANGUAGE/D*.TXT"; // weak
char aLDTxt[8] = "L%d.TXT"; // weak
char aNetherw_5[9] = "/netherw"; // weak
char aCSSaveSaveDGam[22] = "%c:%s/save/save%d.gam"; // weak
char aDD_1[6] = "%d%d."; // weak
char aC_0[3] = "%c"; // weak
char asc_D1AB3[3] = "/_"; // weak
int dword_D1AE4 = 7629889; // weak
__int16 word_D1B00 = 65; // weak
__int16 word_D1B04 = 66; // weak
__int16 word_D1B08 = 69; // weak
__int16 word_D1B0C = 70; // weak
__int16 word_D1B10 = 71; // weak
__int16 word_D1B14 = 72; // weak
__int16 word_D1B18 = 74; // weak
__int16 word_D1B1C = 75; // weak
__int16 word_D1B20 = 78; // weak
__int16 word_D1B24 = 81; // weak
__int16 word_D1B28 = 84; // weak
__int16 word_D1B2C = 85; // weak
__int16 word_D1B30 = 87; // weak
__int16 word_D1B34 = 88; // weak
__int16 word_D1B38 = 89; // weak
__int16 word_D1B3C = 90; // weak
__int16 word_D1B40 = 45; // weak
__int16 word_D1B44 = 59; // weak
__int16 word_D1B48 = 35; // weak
__int16 word_D1B4C = 44; // weak
__int16 word_D1B50 = 46; // weak
__int16 word_D1B54 = 47; // weak
char aDD_2[5] = "%d%d"; // weak
char aDS[7] = "%d. %s"; // weak
char aGD[4] = "G%d"; // weak
char aCSS_0[8] = "%c%s/%s"; // weak
char aLanguageS[12] = "LANGUAGE/%s"; // weak
char aIntroCutDDat[16] = "intro\\cut%d.dat"; // weak
char aHitAccuracy[13] = "Hit Accuracy"; // weak
char aManaCollected[15] = "Mana Collected"; // weak
char a3d[6] = "%3d%%"; // weak
char a02d02d02d[15] = "%02d:%02d:%02d"; // weak
char aE[3] = "E!"; // weak
char aError1NotEnoug[41] = "ERROR 1: NOT ENOUGH MEMORY. (%ld / %ld)\n"; // weak
char aErrorAllocatio[23] = "ERROR: Allocation %s.\n"; // weak
char aPressReturnToC_0[26] = "Press return to continue\n"; // weak
char aErrorFileS[17] = "ERROR: File %s.\n"; // weak
char aSoundSoundDat[16] = "SOUND/SOUND.DAT"; // weak
char aFdmErrorFreein[23] = "fdm:error freeing %lx\n"; // weak
char aF1S[8] = "[F1] %s"; // weak
char aVfxInitialised[17] = "VFX INITIALISED\n"; // weak
char aS_1[5] = "%s.\n"; // weak
_UNKNOWN unk_D1F0C; // weak
void *off_D1F10 = (void *)0xD5221; // weak
char aM1PB[9] = "!M1,P,B\r"; // weak
char aCouldNotSendIn[32] = "Could not send Info to Tracker\n"; // weak
float flt_D1F40 =  0.000061035156; // weak
char aNoMemoryForSer[28] = "No memory for serial data.\n"; // weak
char aNoSerial[11] = "NO SERIAL\n"; // weak
char aNoMemory[11] = "NO MEMORY\n"; // weak
void *off_D1F78 = &unk_D5621; // weak
double dbl_D1F7C =  1.003; // weak
char aCouldNotLoadAn[37] = "\nCould not load any digital samples\n"; // weak
char aMdsound[8] = "MDSOUND"; // weak
char aSXDDD[15] = "%s %x %d %d %d"; // weak
char aS_2[3] = "%s"; // weak
char aDigIni[8] = "DIG.INI"; // weak
char aNone[5] = "None"; // weak
char aCouldNotLoadAn_0[37] = "\nCould not load any digital samples\n"; // weak
char aCouldNotLoadAn_1[37] = "\nCould not load any digital samples\n"; // weak
char aSbawe32Mdi[12] = "SBAWE32.MDI"; // weak
char aSbpro2Mdi[11] = "SBPRO2.MDI"; // weak
char aSbpro1Mdi[11] = "SBPRO1.MDI"; // weak
char aMpu401Mdi[11] = "MPU401.MDI"; // weak
char aMt32mpuMdi[12] = "MT32MPU.MDI"; // weak
char aSndscapeMdi[13] = "SNDSCAPE.MDI"; // weak
char aAdlibgMdi[11] = "ADLIBG.MDI"; // weak
char aPasMdi[8] = "PAS.MDI"; // weak
char aPasplusMdi[12] = "PASPLUS.MDI"; // weak
char aSblasterMdi[13] = "SBLASTER.MDI"; // weak
char aOpl3Mdi[9] = "OPL3.MDI"; // weak
char aAdlibMdi[10] = "ADLIB.MDI"; // weak
char aD_2[4] = "d \\"; // weak
char aCSsoundSample[18] = "%c:%sSOUND/SAMPLE"; // weak
char aCSSoundSample[19] = "%c:%s/SOUND/SAMPLE"; // weak
char aMdmusic[8] = "MDMUSIC"; // weak
char aSXDDD_0[15] = "%s %x %d %d %d"; // weak
char aMS[4] = "M%s"; // weak
char aMdiIni[8] = "MDI.INI"; // weak
char aNone_0[5] = "None"; // weak
char aT32f[5] = "T32f"; // weak
char aEsfmMdi[9] = "ESFM.MDI"; // weak
char aApew[5] = "APEw"; // weak
char aDig[4] = "DIg"; // weak
char aOpr[4] = "opr"; // weak
char aErrorDriverNot[29] = "\nError driver not supported\n"; // weak
char aErrorOpeningMu[28] = "\nError opening music files\n"; // weak
char aSoundMusicDat[16] = "SOUND/MUSIC.DAT"; // weak
char aNullWav[9] = "null.wav"; // weak
double dbl_D220C =  0.01; // weak
double dbl_D2218 =  63.0; // weak
double dbl_D2220 =  0.5; // weak
_UNKNOWN unk_D2228; // weak
char aSb16Dig[9] = "SB16.DIG"; // weak
char aSbawe32Mdi_0[12] = "SBAWE32.MDI"; // weak
char aMpu401Mdi_0[11] = "MPU401.MDI"; // weak
char a02u02u02u02u[27] = "[%.02u:%.02u:%.02u.%.02u] "; // weak
_UNKNOWN unk_D226C; // weak
_UNKNOWN unk_D2270; // weak
char aAilShutdown[16] = "AIL_shutdown()\n"; // weak
char aAilSetPreferen[27] = "AIL_set_preference(%d,%d)\n"; // weak
char aResultD[13] = "Result = %d\n"; // weak
char aAilGetRealVect[25] = "AIL_get_real_vect(0x%X)\n"; // weak
char aResult0xX[15] = "Result = 0x%X\n"; // weak
char aAilSetRealVect[30] = "AIL_set_real_vect(0x%X,0x%X)\n"; // weak
char aAilRestoreUse1[27] = "AIL_restore_USE16_ISR(%d)\n"; // weak
char aAilCallDriver0[38] = "AIL_call_driver(0x%X,0x%X,0x%X,0x%X)\n"; // weak
char aAilDelayD[15] = "AIL_delay(%d)\n"; // weak
char aAilApiReadIni0[27] = "AIL_API_read_INI(0x%X,%s)\n"; // weak
char aDriverS[13] = "Driver = %s\n"; // weak
char aDeviceS[13] = "Device = %s\n"; // weak
char aIoX[13] = "IO     = %X\n"; // weak
char aIrqD[13] = "IRQ    = %d\n"; // weak
char aDma8D[13] = "DMA_8  = %d\n"; // weak
char aDma16D[13] = "DMA_16 = %d\n"; // weak
char aResultU[13] = "Result = %u\n"; // weak
char aAilRegisterTim[26] = "AIL_register_timer(0x%X)\n"; // weak
char aAilSetTimerUse[27] = "AIL_set_timer_user(%u,%u)\n"; // weak
char aAilSetTimerPer[29] = "AIL_set_timer_period(%u,%u)\n"; // weak
char aAilSetTimerFre[32] = "AIL_set_timer_frequency(%u,%u)\n"; // weak
char aAilStartTimerU[21] = "AIL_start_timer(%u)\n"; // weak
char aAilStopTimerU[20] = "AIL_stop_timer(%u)\n"; // weak
char aAilReleaseTime[30] = "AIL_release_timer_handle(%u)\n"; // weak
char aAilReleaseAllT[26] = "AIL_release_all_timers()\n"; // weak
char aAilGetIoEnviro[30] = "AIL_get_IO_environment(0x%X)\n"; // weak
char aAilInstallDriv[29] = "AIL_install_driver(0x%X,%u)\n"; // weak
char aAilUninstallDr[28] = "AIL_uninstall_driver(0x%X)\n"; // weak
char aAilInstallDigI[27] = "AIL_install_DIG_INI(0x%X)\n"; // weak
char aAilInstallDigD[38] = "AIL_install_DIG_driver_file(%s,0x%X)\n"; // weak
char aAilUninstallDi[32] = "AIL_uninstall_DIG_driver(0x%X)\n"; // weak
char aAilAllocateSam[34] = "AIL_allocate_sample_handle(0x%X)\n"; // weak
char aAilReleaseSamp[33] = "AIL_release_sample_handle(0x%X)\n"; // weak
char aAilInitSample0[23] = "AIL_init_sample(0x%X)\n"; // weak
char aAilSetSampleFi[35] = "AIL_set_sample_file(0x%X,0x%X,%d)\n"; // weak
char aAilSetSampleAd[38] = "AIL_set_sample_address(0x%X,0x%X,%u)\n"; // weak
char aAilSetSampleTy[33] = "AIL_set_sample_type(0x%X,%d,%u)\n"; // weak
char aAilStartSample[24] = "AIL_start_sample(0x%X)\n"; // weak
char aAilEndSample0x[22] = "AIL_end_sample(0x%X)\n"; // weak
char aAilSetSamplePl[39] = "AIL_set_sample_playback_rate(0x%X,%d)\n"; // weak
char aAilSetSampleVo[32] = "AIL_set_sample_volume(0x%X,%d)\n"; // weak
char aAilSetSamplePa[29] = "AIL_set_sample_pan(0x%X,%d)\n"; // weak
char aAilSetSampleLo[36] = "AIL_set_sample_loop_count(0x%X,%d)\n"; // weak
char aAilSampleStatu[25] = "AIL_sample_status(0x%X)\n"; // weak
char aAilSetDigitalM[40] = "AIL_set_digital_master_volume(0x%X,%d)\n"; // weak
char aAilRegisterEos[38] = "AIL_register_EOS_callback(0x%X,0x%X)\n"; // weak
char aAilSetSampleUs[38] = "AIL_set_sample_user_data(0x%X,%u,%d)\n"; // weak
char aAilSampleUserD[31] = "AIL_sample_user_data(0x%X,%u)\n"; // weak
char aAilInstallMdiI[27] = "AIL_install_MDI_INI(0x%X)\n"; // weak
char aAilInstallMdiD[38] = "AIL_install_MDI_driver_file(%s,0x%X)\n"; // weak
char aAilUninstallMd[32] = "AIL_uninstall_MDI_driver(0x%X)\n"; // weak
char aAilAllocateSeq[36] = "AIL_allocate_sequence_handle(0x%X)\n"; // weak
char aAilInitSequenc[33] = "AIL_init_sequence(0x%X,0x%X,%d)\n"; // weak
char aAilStartSequen[26] = "AIL_start_sequence(0x%X)\n"; // weak
char aAilStopSequenc[25] = "AIL_stop_sequence(0x%X)\n"; // weak
char aAilResumeSeque[27] = "AIL_resume_sequence(0x%X)\n"; // weak
char aAilEndSequence[24] = "AIL_end_sequence(0x%X)\n"; // weak
char aAilSetSequence_0[37] = "AIL_set_sequence_volume(0x%X,%d,%d)\n"; // weak
char aAilSequenceSta[27] = "AIL_sequence_status(0x%X)\n"; // weak
char aAilSetXmidiMas[38] = "AIL_set_XMIDI_master_volume(0x%X,%d)\n"; // weak
char aAilMdiDriverTy[27] = "AIL_MDI_driver_type(0x%X)\n"; // weak
char aAilSetGtlFilen[33] = "AIL_set_GTL_filename_prefix(%s)\n"; // weak
char aAilSequencePos[39] = "AIL_sequence_position(0x%X,0x%X,0x%X)\n"; // weak
char aResultDD[16] = "Result = %d:%d\n"; // weak
char aAilBranchIndex[27] = "AIL_branch_index(0x%X,%u)\n"; // weak
char aAilRegisterTri[42] = "AIL_register_trigger_callback(0x%X,0x%X)\n"; // weak
char aAilRegisterEve[40] = "AIL_register_event_callback(0x%X,0x%X)\n"; // weak
char aAilRegisterTim_0[41] = "AIL_register_timbre_callback(0x%X,0x%X)\n"; // weak
char aAilLockChannel[24] = "AIL_lock_channel(0x%X)\n"; // weak
char aAilReleaseChan[30] = "AIL_release_channel(0x%X,%d)\n"; // weak
char aAilMapSequence[38] = "AIL_map_sequence_channel(0x%X,%d,%d)\n"; // weak
char aAilSendChannel[58] = "AIL_send_channel_voice_message(0x%X,0x%X,0x%X,0x%X,0x%X)\n"; // weak
char aVesa[5] = "VESA"; // weak
char aWritingS[12] = "Writing %s\n"; // weak
char aResponseC[14] = "Response: %c\n"; // weak
char aTrackerInitial[23] = "Tracker initialized ok"; // weak
char aNoSerialPort[15] = "No serial port"; // weak
char aTrackerNotPres[20] = "Tracker not present"; // weak
char aTrackerIsNotRe[26] = "Tracker is not responding"; // weak
char aTrackerDataIsI[24] = "Tracker data is invalid"; // weak
char aTrackerHeaderD[31] = "Tracker header data is invalid"; // weak
char aAVerifiedWrite[42] = "A verified write to tracker memory failed"; // weak
char aInvalidParamet[18] = "Invalid parameter"; // weak
char aTrackerCommand[34] = "Tracker command returned an error"; // weak
char aAMemoryAllocat[27] = "A memory allocation failed"; // weak
char aTrackerVersion[34] = "Tracker version string is invalid"; // weak
char aUndefined[10] = "Undefined"; // weak
char aLx[3] = "LX"; // weak
char byte_D3450[] = { '0' }; // weak
char aRt[4] = ",rt"; // weak
char aDriver[7] = "DRIVER"; // weak
char aDevice[7] = "DEVICE"; // weak
char aIoAddr[8] = "IO_ADDR"; // weak
char aIrq[4] = "IRQ"; // weak
char aDma8Bit[10] = "DMA_8_bit"; // weak
char aDma16Bit[11] = "DMA_16_bit"; // weak
char aCorruptedIniFi[21] = "Corrupted .INI file\n"; // weak
char aInsufficientLo[25] = "Insufficient low memory\n"; // weak
char aAil3dig[8] = "AIL3DIG"; // weak
char aAil3mdi[8] = "AIL3MDI"; // weak
char aInvalidDriverT[21] = "Invalid driver type\n"; // weak
char aOutOfDriverHan[23] = "Out of driver handles\n"; // weak
char aOutOfTimerHand[22] = "Out of timer handles\n"; // weak
char aSbawe32Mdi_1[12] = "SBAWE32.MDI"; // weak
char aW[2] = "w"; // weak
char aSoundSSbk[14] = "sound//%s.sbk"; // weak
char aCouldNotAlloca[38] = "Could not allocate memory for driver\n"; // weak
char aDigDriverRequi[22] = ".DIG driver required\n"; // weak
char aDigitalSoundHa[34] = "Digital sound hardware not found\n"; // weak
char aCouldNotAlloca_0[32] = "Could not allocate DMA buffers\n"; // weak
char aCouldNotAlloca_1[33] = "Could not allocate build buffer\n"; // weak
char aCouldNotAlloca_2[38] = "Could not allocate SAMPLE structures\n"; // weak
char aOutOfTimerHand_0[22] = "Out of timer handles\n"; // weak
char aDigIni_0[8] = "DIG.INI"; // weak
char aUnableToOpenFi[29] = "Unable to open file DIG.INI\n"; // weak
char aOutOfSampleHan[23] = "Out of sample handles\n"; // weak
char aFmt[5] = "fmt "; // weak
char aData_0[5] = "data"; // weak
char aCreative[9] = "Creative"; // weak
char aWave[5] = "WAVE"; // weak
char aUnrecognizedDi[38] = "Unrecognized digital audio file type\n"; // weak
char aUnrecognizedDi_0[38] = "Unrecognized digital audio file type\n"; // weak
char aForm[5] = "FORM"; // weak
char aCat[5] = "CAT "; // weak
char aXmid[5] = "XMID"; // weak
char aCouldNotAlloca_3[38] = "Could not allocate memory for driver\n"; // weak
char aMdiDriverRequi[22] = ".MDI driver required\n"; // weak
char aXmidiSoundHard[32] = "XMIDI sound hardware not found\n"; // weak
char aCouldNotInitia[41] = "Could not initialize instrument manager\n"; // weak
char aCouldNotAlloca_4[40] = "Could not allocate SEQUENCE structures\n"; // weak
char aOutOfTimerHand_1[22] = "Out of timer handles\n"; // weak
char aMdiIni_0[8] = "MDI.INI"; // weak
char aUnableToOpenFi_0[29] = "Unable to open file MDI.INI\n"; // weak
char aTandy3VoiceMus[20] = "Tandy 3-voice music"; // weak
char aIbmInternalSpe[27] = "IBM internal speaker music"; // weak
char aMAd[5] = "m.AD"; // weak
char aOpl[5] = ".OPL"; // weak
char aOutOfSequenceH[25] = "Out of sequence handles\n"; // weak
char aInvalidXmidiSe[24] = "Invalid XMIDI sequence\n"; // weak
char aTimb[5] = "TIMB"; // weak
char aRbrn[5] = "RBRN"; // weak
char aEvnt[5] = "EVNT"; // weak
char aDriverCouldNot[51] = "Driver could not install timbre bank %u, patch %u\n"; // weak
char aDriverCouldNot_0[51] = "Driver could not install timbre bank %u, patch %u\n"; // weak
char aInsufficientMe_0[42] = "Insufficient memory for HWAVE descriptor\n"; // weak
char asc_D3A8C[3] = ": "; // weak
char IsTable[256] =
{
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\n',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  'X',
  'X',
  'X',
  'X',
  'X',
  'X',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\x98',
  '\x98',
  '\x98',
  '\x98',
  '\x98',
  '\x98',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\f',
  '\f',
  '\f',
  '\f',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_D3EA0[6] = { '\x01', '\x02', '\x04', '\b', '\x10', ' ' }; // idb
char byte_D3F48 = '\0'; // weak
__int16 word_D3F4C[26] =
{
  2,
  10,
  40,
  32,
  300,
  1,
  1,
  1,
  1,
  4,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  400,
  600,
  600,
  400,
  400,
  0,
  0,
  0
}; // idb
_UNKNOWN unk_D3F80; // weak
_UNKNOWN unk_D3F89; // weak
_UNKNOWN unk_D3F91; // weak
char byte_D3F96[14] =
{
  '\0',
  '\xFF',
  '\0',
  '\xFF',
  '\x01',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_D3FA4[] = { '\0' }; // weak
char byte_D3FB2[14] =
{
  '\0',
  '\x01',
  '\0',
  '\0',
  '\xFF',
  '\x01',
  '\xFF',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_D3FC0[] = { '\0' }; // weak
__int16 word_D3FCE[13] = { 0, 1536, 0, 1536, 512, 1536, 0, 0, 1024, 1024, 1536, 1024, 512 }; // idb
__int16 word_D3FE8[14] = { 1024, 512, 1024, 1024, 1536, 512, 1536, 1024, 0, 512, 512, 1024, 0, 0 }; // idb
__int16 word_D4004 = 0; // weak
char byte_D400C[64] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  '\x02',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\x03',
  '\x02',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\x04',
  '\x03',
  '\x03',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\x05',
  '\x04',
  '\x03',
  '\x02',
  '\x01',
  '\0',
  '\0',
  '\a',
  '\x06',
  '\x05',
  '\x04',
  '\x03',
  '\x02',
  '\x01',
  '\0'
}; // idb
void *off_D404C = &unk_140186; // weak
int dword_D40BC[] = { 0 }; // weak
int dword_D40C0[] = { 0 }; // weak
int dword_D4188 = 0; // weak
int dword_D418C = 0; // weak
int dword_D4190 = 0; // weak
int dword_D4198 = 0; // weak
char byte_D419C = '\xFF'; // weak
char byte_D419D = '\x01'; // weak
char byte_D419E = '\0'; // weak
int dword_D41A0 = 0; // weak
int dword_D41A4 = 0; // weak
char *off_D41A8 = &byte_14B4E0; // weak
char byte_D41AD = '\0'; // weak
char byte_D41B4 = '\0'; // weak
char byte_D41B5 = ' '; // weak
char byte_D41B6 = '\x01'; // weak
char byte_D41B7 = ','; // weak
int dword_D41BC = 0; // weak
char byte_D41C0 = '\0'; // weak
char byte_D41C1 = '\0'; // weak
char byte_D41C4 = 'c'; // weak
char byte_D41C6 = '('; // weak
int dword_D41C8 = 0; // weak
char byte_D41CE = '\0'; // weak
int dword_D41D0 = 0; // weak
__int16 word_D41D4 = 1; // weak
char byte_D41D8[] = { '\0' }; // weak
char byte_D427C[164] =
{
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_D4320 = '\0'; // weak
int dword_D4324 = 0; // weak
_UNKNOWN unk_D4328; // weak
_UNKNOWN unk_D4350; // weak
char byte_D4750[] = { '\0' }; // weak
char byte_D4756[] = { '\x01' }; // weak
char byte_D475C[16] =
{
  '\0',
  '\x01',
  '\x01',
  '\x02',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x04',
  '\x03',
  '\x03',
  '\x02',
  '\x02',
  '\x01',
  '\x01',
  '\0'
}; // idb
char byte_D476C[16] =
{
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0'
}; // idb
char byte_D477C[16] =
{
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\f',
  '\f',
  '\f'
}; // idb
char byte_D478C = '\0'; // weak
int dword_D4790 = 20; // weak
int dword_D4794 = 0; // weak
int dword_D4798 = 0; // weak
char byte_D47D8 = '\0'; // weak
char byte_D47D9 = '\0'; // weak
int dword_D47DC = 1; // weak
_UNKNOWN unk_D47E0; // weak
_UNKNOWN unk_D4A30; // weak
_UNKNOWN unk_D4A40; // weak
_UNKNOWN unk_D4A70; // weak
_UNKNOWN unk_D4A80; // weak
_UNKNOWN unk_D4AB0; // weak
char byte_D4B50 = '\0'; // weak
char byte_D4B51 = '\0'; // weak
char byte_D4B78 = '\0'; // weak
char byte_D4B79 = '\0'; // weak
char byte_D4B7A = '\0'; // weak
__int16 word_D4B7C = 254; // weak
__int16 word_D4B7E = 0; // weak
char byte_D4B80 = '\0'; // weak
int dword_D4B84 = 16; // weak
int dword_D4B88 = 4294967216; // weak
int dword_D4B8C = 80; // weak
int dword_D4B90 = 4294967292; // weak
__int16 word_D4BA4 = 16; // weak
int dword_D4BA8 = 4294967216; // weak
int dword_D4BAC = 80; // weak
__int16 word_D4BB0 = 65532; // weak
int dword_D4C52 = 0; // weak
int dword_D4C56 = 0; // weak
int (__cdecl *off_D697E)(int) = &sub_4E320; // weak
int (__cdecl *off_D781E)(int) = &sub_511A0; // weak
int (__cdecl *off_D7B7A)(int) = &sub_51530; // weak
_UNKNOWN unk_D7BD6; // weak
_UNKNOWN unk_D83AC; // weak
void *off_D83CE = &unk_160001; // weak
_UNKNOWN unk_D83F0; // weak
void *off_D8412 = &unk_110003; // weak
void *off_D8434 = &loc_B0004; // weak
void *off_D8456 = (void *)0x50005; // weak
_UNKNOWN unk_D8478; // weak
_UNKNOWN unk_D849A; // weak
__int16 word_D84A6 = 256; // weak
_UNKNOWN unk_D84BC; // weak
_UNKNOWN unk_D84DE; // weak
_UNKNOWN unk_D8544; // weak
_UNKNOWN unk_D8588; // weak
_UNKNOWN unk_D85AA; // weak
void *off_D85CC = &unk_160010; // weak
void *off_D8676 = &unk_160015; // weak
void *off_D86DC = &unk_160018; // weak
_UNKNOWN unk_D86FE; // weak
_UNKNOWN unk_D8720; // weak
void *off_D8742 = &unk_16001B; // weak
_UNKNOWN unk_D8764; // weak
_UNKNOWN unk_D8786; // weak
_UNKNOWN unk_D87A8; // weak
_UNKNOWN unk_D87CA; // weak
_UNKNOWN unk_D87EC; // weak
_UNKNOWN unk_D880E; // weak
_UNKNOWN unk_D8830; // weak
_UNKNOWN unk_D8852; // weak
_UNKNOWN unk_D8874; // weak
_UNKNOWN unk_D8896; // weak
void *off_D88B8 = &unk_160026; // weak
_UNKNOWN unk_D88DA; // weak
_UNKNOWN unk_D88FC; // weak
void *off_D891E = &unk_160029; // weak
void *off_D8940 = &unk_16002A; // weak
_UNKNOWN unk_D8962; // weak
void *off_D8984 = &unk_16002C; // weak
_UNKNOWN unk_D89A6; // weak
void *off_D89C8 = &loc_5002E; // weak
void *off_D89EA = &unk_11002F; // weak
char byte_D8A2E[38] =
{
  '\x01',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\0'
}; // idb
char aSearchd[9] = "*SearchD"; // weak
char aDataBuild00Dat[18] = "data/build0-0.dat"; // weak
char aDataBlock16Dat[17] = "data/block16.dat"; // weak
char aDataBlock32Dat[17] = "data/block32.dat"; // weak
char aWscreen[9] = "*WScreen"; // weak
char aDataMsprd00Dat[18] = "data/msprd0-0.dat"; // weak
char aDataMsprd00Tab_0[18] = "data/msprd0-0.tab"; // weak
char aDataHsprd00Dat[18] = "data/hsprd0-0.dat"; // weak
char aDataHsprd00Tab_0[18] = "data/hsprd0-0.tab"; // weak
int *off_D918C = &dword_EB394; // weak
int *off_D91BC[2] = { &dword_EA3DC, &dword_EA3E0 }; // weak
void *off_D91D4 = &unk_E9B2C; // weak
int *off_D91EC = &dword_EA3BC; // weak
char *off_D9204[2] = { "1. Jahwl", "2. Kopahk" }; // weak
char *off_D9208 = "2. Kopahk"; // weak
char *off_D93A0 = "Zanzamar"; // weak
__int16 word_D93C0[] = { 2 }; // weak
char byte_D93C2[] = { '\x03' }; // weak
char byte_D93C3[] = { '\0' }; // weak
char byte_D94F0[] = { '\xAA' }; // weak
char byte_D94F1[] = { '\0' }; // weak
char byte_D94F2[] = { 'c' }; // weak
char byte_D94F3[12] = { '\r', '\0', '3', '\0', '\x11', ';', '\0', '3', '\0', '\x88', ';', '\0' }; // idb
char byte_D94FF[29] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\0',
  '\x03',
  '\0'
}; // idb
__int16 word_D951C[] = { 8 }; // weak
__int16 word_D9522[] = { 0 }; // weak
__int16 word_D9524[] = { 250 }; // weak
char byte_D9528[] = { '\0' }; // weak
__int16 word_D99F2 = 0; // weak
__int16 word_D99F4 = 180; // weak
int dword_D9F50[] = { 16777356 }; // weak
__int16 word_DA076 = 1500; // weak
__int16 word_DA506 = 311; // weak
int dword_DA750[] = { 27918336 }; // weak
__int16 word_DA7CA = 1200; // weak
char byte_DA818[] = { '\x03' }; // weak
char byte_DA819[] = { '\0' }; // weak
int dword_DA81E = 100; // weak
int dword_DA822 = 0; // weak
__int16 word_DA82E[] = { 186 }; // weak
int dword_DA85A[60] =
{
  5000,
  750,
  983228,
  196610,
  10,
  100,
  0,
  0,
  0,
  196797,
  983040,
  16384000,
  0,
  19660800,
  3276800,
  12451840,
  65577,
  20,
  1000,
  1000,
  900,
  150,
  3342527,
  196610,
  0,
  1000,
  0,
  0,
  0,
  6619328,
  0,
  81920000,
  0,
  1638400,
  262144,
  12648448,
  65637,
  1,
  2000,
  0,
  125,
  6,
  6619330,
  67305474,
  2,
  1000,
  0,
  0,
  0,
  19726531,
  196608,
  163840000,
  0,
  9175040,
  983040,
  12845056,
  451,
  4,
  5000,
  0
}; // idb
__int16 word_DA96E = 198; // weak
char byte_DA972[] = { '\x13' }; // weak
_UNKNOWN unk_DAB3A; // weak
_BYTE byte_DAC2A[26] =
{
  208,
  7,
  0,
  0,
  244,
  1,
  0,
  0,
  16,
  39,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  5,
  0,
  0,
  0
}; // idb
_UNKNOWN unk_DAC44; // weak
_UNKNOWN unk_DAC7A; // weak
__int16 word_DAE1E = 244; // weak
char byte_DAE22 = '\x13'; // weak
_UNKNOWN unk_DAF4A; // weak
int dword_DAF50[58] =
{
  1310720000,
  0,
  0,
  16842752,
  47,
  5000,
  12000,
  20000,
  120,
  30,
  4391170,
  655360001,
  1572864000,
  3932160000,
  15728640,
  3932160,
  16973824,
  131159,
  39976963,
  655360000,
  1310720000,
  0,
  0,
  17039360,
  1048619,
  1100,
  18000,
  36000,
  90,
  30,
  2162949,
  177602586,
  1966080000,
  1603272704,
  18350081,
  4587520,
  17170432,
  2097185,
  6553603,
  720896000,
  1245184000,
  0,
  0,
  17235968,
  31,
  130,
  13000,
  38000,
  200,
  40,
  2687240,
  25559041,
  1703936000,
  3670016000,
  26214400,
  7864320,
  17367040,
  131123
}; // idb
char byte_DB038[] = { '\0' }; // weak
char byte_DB039[16] =
{
  '\0',
  '\x01',
  '\0',
  '\x04',
  '\x01',
  '\x04',
  '\x01',
  '\x04',
  '\x05',
  '\x04',
  '\x05',
  '\b',
  '\t',
  '\b',
  '\t',
  '\0'
}; // idb
_UNKNOWN unk_DB04A; // weak
void *off_DB06C = (void *)0xD1130; // weak
char byte_DB080[] = { '\x02' }; // weak
__int16 word_DB082[] = { 0 }; // weak
__int16 word_DB084[] = { 750 }; // weak
int dword_DB350[103] =
{
  29492775,
  19662900,
  29493675,
  24579000,
  0,
  0,
  0,
  0,
  19664250,
  20,
  39322125,
  300,
  0,
  0,
  0,
  0,
  0,
  0,
  63897600,
  1376481,
  54067200,
  34407300,
  34407900,
  0,
  0,
  0,
  0,
  0,
  0,
  29493300,
  22,
  58983225,
  93389250,
  122880375,
  525,
  0,
  0,
  0,
  0,
  162201600,
  1507703,
  73728000,
  14746800,
  34407900,
  0,
  0,
  0,
  0,
  0,
  0,
  29493300,
  24,
  68813775,
  93389100,
  122880375,
  162202125,
  186777900,
  211353900,
  245760450,
  375,
  275251200,
  1638700,
  54067200,
  24576900,
  34407750,
  19662750,
  19663125,
  19663500,
  0,
  0,
  0,
  24579075,
  26,
  1200,
  83558400,
  675,
  0,
  0,
  0,
  0,
  0,
  132710400,
  1771047,
  24576000,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  375,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
char byte_DB4EE[25] =
{
  '0',
  '6',
  '<',
  'B',
  'E',
  'H',
  'M',
  'O',
  'V',
  '\\',
  'a',
  'f',
  'i',
  'n',
  's',
  'v',
  '|',
  '~',
  '\x83',
  '\x85',
  '\x88',
  '\x8C',
  '\x8F',
  '\x97',
  '\x9C'
}; // idb
char byte_DB507[10] = { '5', ';', 'A', 'D', 'G', 'L', 'N', 'U', '[', '`' }; // idb
char byte_DB511 = 'e'; // weak
char byte_DB520[6] = { '0', '3', '?', '=', '\x92', 'q' }; // idb
char byte_DB526 = 'N'; // weak
int dword_DB538[8] = { 256, 512, 1024, 2048, 4096, 9192, 18384, 36768 }; // idb
char *off_DB558[3] = { "Designed By", "Bullfrog Productions Ltd", "!" }; // weak
char byte_DB734 = '\0'; // weak
char byte_DB738 = '\0'; // weak
int dword_DB73C = 4294967295; // weak
int dword_DB740 = 4294967295; // weak
int dword_DB744 = 4294967295; // weak
int dword_DB748 = 4294967295; // weak
char byte_DB74C = '\x01'; // weak
int dword_DB750[256] =
{
  0,
  201,
  402,
  603,
  804,
  1005,
  1206,
  1407,
  1608,
  1809,
  2010,
  2211,
  2412,
  2613,
  2814,
  3015,
  3216,
  3417,
  3617,
  3818,
  4019,
  4219,
  4420,
  4621,
  4821,
  5022,
  5222,
  5422,
  5623,
  5823,
  6023,
  6224,
  6424,
  6624,
  6824,
  7024,
  7224,
  7423,
  7623,
  7823,
  8022,
  8222,
  8421,
  8621,
  8820,
  9019,
  9218,
  9417,
  9616,
  9815,
  10014,
  10212,
  10411,
  10609,
  10808,
  11006,
  11204,
  11402,
  11600,
  11798,
  11996,
  12193,
  12391,
  12588,
  12785,
  12983,
  13180,
  13376,
  13573,
  13770,
  13966,
  14163,
  14359,
  14555,
  14751,
  14947,
  15143,
  15338,
  15534,
  15729,
  15924,
  16119,
  16314,
  16508,
  16703,
  16897,
  17091,
  17285,
  17479,
  17673,
  17867,
  18060,
  18253,
  18446,
  18639,
  18832,
  19024,
  19216,
  19409,
  19600,
  19792,
  19984,
  20175,
  20366,
  20557,
  20748,
  20939,
  21129,
  21320,
  21510,
  21699,
  21889,
  22078,
  22268,
  22457,
  22645,
  22834,
  23022,
  23210,
  23398,
  23586,
  23774,
  23961,
  24148,
  24335,
  24521,
  24708,
  24894,
  25080,
  25265,
  25451,
  25636,
  25821,
  26005,
  26190,
  26374,
  26558,
  26742,
  26925,
  27108,
  27291,
  27474,
  27656,
  27838,
  28020,
  28202,
  28383,
  28564,
  28745,
  28926,
  29106,
  29286,
  29466,
  29645,
  29824,
  30003,
  30182,
  30360,
  30538,
  30716,
  30893,
  31071,
  31248,
  31424,
  31600,
  31776,
  31952,
  32127,
  32303,
  32477,
  32652,
  32826,
  33000,
  33173,
  33347,
  33520,
  33692,
  33865,
  34037,
  34208,
  34380,
  34551,
  34721,
  34892,
  35062,
  35231,
  35401,
  35570,
  35738,
  35907,
  36075,
  36243,
  36410,
  36577,
  36744,
  36910,
  37076,
  37241,
  37407,
  37572,
  37736,
  37900,
  38064,
  38228,
  38391,
  38554,
  38716,
  38878,
  39040,
  39201,
  39362,
  39523,
  39683,
  39843,
  40002,
  40161,
  40320,
  40478,
  40636,
  40794,
  40951,
  41108,
  41264,
  41420,
  41576,
  41731,
  41886,
  42040,
  42194,
  42348,
  42501,
  42654,
  42806,
  42958,
  43110,
  43261,
  43412,
  43562,
  43713,
  43862,
  44011,
  44160,
  44308,
  44456,
  44604,
  44751,
  44898,
  45044,
  45190,
  45335,
  45480,
  45625,
  45769,
  45912,
  46056,
  46199
}; // idb
int dword_DBB50[256] =
{
  46341,
  46483,
  46624,
  46765,
  46906,
  47046,
  47186,
  47325,
  47464,
  47603,
  47741,
  47878,
  48015,
  48152,
  48288,
  48424,
  48559,
  48694,
  48828,
  48962,
  49095,
  49228,
  49361,
  49493,
  49624,
  49756,
  49886,
  50016,
  50146,
  50275,
  50404,
  50532,
  50660,
  50787,
  50914,
  51041,
  51166,
  51292,
  51417,
  51541,
  51665,
  51789,
  51911,
  52034,
  52156,
  52277,
  52398,
  52519,
  52639,
  52759,
  52878,
  52996,
  53114,
  53232,
  53349,
  53465,
  53581,
  53697,
  53812,
  53926,
  54040,
  54154,
  54267,
  54379,
  54491,
  54603,
  54714,
  54824,
  54934,
  55043,
  55152,
  55260,
  55368,
  55476,
  55582,
  55689,
  55794,
  55900,
  56004,
  56108,
  56212,
  56315,
  56418,
  56520,
  56621,
  56722,
  56823,
  56923,
  57022,
  57121,
  57219,
  57317,
  57414,
  57511,
  57607,
  57703,
  57798,
  57892,
  57986,
  58079,
  58172,
  58265,
  58356,
  58448,
  58538,
  58628,
  58718,
  58807,
  58896,
  58983,
  59071,
  59158,
  59244,
  59330,
  59415,
  59499,
  59583,
  59667,
  59750,
  59832,
  59914,
  59995,
  60075,
  60156,
  60235,
  60314,
  60392,
  60470,
  60547,
  60624,
  60700,
  60776,
  60851,
  60925,
  60999,
  61072,
  61145,
  61217,
  61288,
  61359,
  61429,
  61499,
  61568,
  61637,
  61705,
  61772,
  61839,
  61906,
  61971,
  62036,
  62101,
  62165,
  62228,
  62291,
  62353,
  62415,
  62476,
  62536,
  62596,
  62655,
  62714,
  62772,
  62830,
  62886,
  62943,
  62998,
  63054,
  63108,
  63162,
  63215,
  63268,
  63320,
  63372,
  63423,
  63473,
  63523,
  63572,
  63621,
  63668,
  63716,
  63763,
  63809,
  63854,
  63899,
  63944,
  63987,
  64031,
  64073,
  64115,
  64156,
  64197,
  64237,
  64277,
  64316,
  64354,
  64392,
  64429,
  64465,
  64501,
  64536,
  64571,
  64605,
  64639,
  64672,
  64704,
  64735,
  64766,
  64797,
  64827,
  64856,
  64884,
  64912,
  64940,
  64967,
  64993,
  65018,
  65043,
  65067,
  65091,
  65114,
  65137,
  65159,
  65180,
  65200,
  65220,
  65240,
  65259,
  65277,
  65294,
  65311,
  65328,
  65343,
  65358,
  65373,
  65387,
  65400,
  65413,
  65425,
  65436,
  65447,
  65457,
  65467,
  65476,
  65484,
  65492,
  65499,
  65505,
  65511,
  65516,
  65521,
  65525,
  65528,
  65531,
  65533,
  65535,
  65536
}; // idb
void (__noreturn *off_DBF50[2])() = { &sub_10000, &sub_10000 }; // weak
int dword_DDF50[] = { 0 }; // weak
int dword_DDF54 = 32; // weak
__int16 word_DE350[] = { 0 }; // weak
int dword_DE554 = 0; // weak
int dword_DE558 = 0; // weak
int dword_DE55C = 0; // weak
int dword_DE560 = 0; // weak
int dword_DE564 = 0; // weak
int dword_DE568 = 0; // weak
_UNKNOWN unk_DE56C; // weak
char byte_E126C = 'p'; // weak
char byte_E126D = '\0'; // weak
char byte_E1274 = '\0'; // weak
char byte_E1275 = '\0'; // weak
__int16 word_E1276 = 65535; // weak
__int16 word_E1278 = 0; // weak
__int16 word_E127A = 8; // weak
int dword_E127E = 0; // weak
int dword_E1282 = 0; // weak
int dword_E1286[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // idb
__int16 word_E12A6 = 0; // weak
__int16 word_E12A8 = 0; // weak
int dword_E12AA = 0; // weak
int dword_E12AE[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // idb
char byte_E12CE[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
char aTester[7] = "TESTER"; // weak
char byte_E12EC = '\0'; // weak
char byte_E12ED = '\0'; // weak
int dword_E12F4 = 0; // weak
__int16 word_E12FC = 1; // weak
__int16 word_E12FE = 0; // weak
int dword_E1300 = 0; // weak
int dword_E1304 = 0; // weak
int dword_E1308 = 0; // weak
__int16 word_E130C = 0; // weak
__int16 word_E130E = 0; // weak
__int16 word_E1310 = 0; // weak
__int16 word_E1312 = 0; // weak
__int16 word_E1316 = 0; // weak
__int16 word_E131A = 0; // weak
char byte_E131C[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
char byte_E1324 = '2'; // weak
void *off_E16E0 = &unk_E1328; // weak
char byte_E1711[] = { '6' }; // weak
char byte_E1712[] = { '6' }; // weak
char byte_E1713[25] =
{
  '6',
  '\0',
  '&',
  '\0',
  '-',
  '\0',
  '\0',
  '#',
  '\0',
  '!',
  '?',
  '\x0F',
  '(',
  '\x16',
  '\x0F',
  '\0',
  '\0',
  '\0',
  '\x17',
  '?',
  '\x1F',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_E172C[] = { '\"' }; // weak
char byte_E172D[] = { '\"' }; // weak
char byte_E172E[] = { '\"' }; // weak
_UNKNOWN unk_E1748; // weak
_UNKNOWN unk_E1784; // weak
_UNKNOWN unk_E17CC; // weak
_UNKNOWN unk_E192C; // weak
_UNKNOWN unk_E1960; // weak
__int16 word_E1964[] = { 116 }; // weak
__int16 word_E1966[] = { 478 }; // weak
__int16 word_E196C[] = { 420 }; // weak
__int16 word_E196E[] = { 820 }; // weak
__int16 word_E1970 = 33; // weak
char byte_E1972[484] =
{
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'p',
  '\x01',
  '',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\x9A',
  '\x02',
  '%',
  '\x03',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '@',
  '\x02',
  '',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  'q',
  '\x03',
  '',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '%',
  '\x02',
  'r',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '',
  '\x01',
  '\x8C',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  'b',
  '\x02',
  '\x9A',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\xFB',
  '\x02',
  '\x8C',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '',
  '\x02',
  '.',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\x84',
  '\x02',
  '*',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\x18',
  '\x02',
  '\x1C',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  '2',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '6',
  '\x03',
  '',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '~',
  '\x02',
  '\xBE',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '',
  '\x03',
  '\x9C',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '~',
  '\x02',
  '\\',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\"',
  '\x04',
  '\f',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\x01',
  '\\',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\x85',
  '\x03',
  '0',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\x01',
  '\\',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '1',
  '\x03',
  '',
  '\0',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\x01',
  '\\',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\xAC',
  '\x02',
  '\x06',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'z',
  '\0',
  '`',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\x12',
  '\x02',
  '<',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'z',
  '\0',
  '`',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\xAB',
  '\x01',
  '',
  '\0',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'z',
  '\0',
  '`',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  'B',
  '\x01',
  '\xFE',
  '\0',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '2',
  '\x01',
  '',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  's',
  '\x02',
  '\xA0',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  'D',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\xB4',
  '\0',
  '\x16',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '(',
  '\x01',
  'D',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  'a',
  '\x02',
  '',
  '\0',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\x01',
  '\0',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  'F',
  '\x03',
  '`',
  '\0',
  '!',
  '\0'
}; // idb
__int16 word_E1B66 = 679; // weak
__int16 word_E1B68 = 126; // weak
char byte_E1B82 = '\x02'; // weak
char byte_E1B9C[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
char byte_E1BA4[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
_WORD off_E1BAC[22] =
{
  29520,
  7,
  0,
  0,
  0,
  206,
  67,
  80,
  80,
  410,
  13115,
  262,
  0,
  78,
  78,
  0,
  0,
  80,
  0,
  0,
  0,
  3
}; // idb
_WORD off_E1D64[22] =
{
  52464,
  7,
  0,
  0,
  0,
  284,
  2,
  30,
  10,
  0,
  1035,
  256,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3
}; // idb
void *off_E1E98 = (void *)0x5BC1E; // weak
signed __int16 word_E1F70[10] = { 430, 78, 0, 0, 80, 0, 413, 0, 0, 0 }; // idb
_WORD word_E1F84[66] =
{
  0,
  0,
  0,
  0,
  0,
  291,
  205,
  60,
  60,
  0,
  8996,
  257,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  0,
  0,
  0,
  0,
  0,
  288,
  99,
  60,
  60,
  0,
  19788,
  258,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
_WORD word_E2008[66] =
{
  0,
  0,
  0,
  0,
  0,
  273,
  10,
  60,
  60,
  0,
  27904,
  257,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  0,
  0,
  0,
  0,
  0,
  283,
  381,
  60,
  60,
  0,
  27648,
  258,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
int dword_E208C = 0; // weak
__int16 word_E2094 = 40; // weak
char byte_E2096 = '('; // weak
char byte_E2097 = '1'; // weak
_WORD word_E20A4[414] =
{
  0,
  0,
  0,
  0,
  1,
  37,
  2,
  37,
  3,
  0,
  0,
  384,
  0,
  543,
  960,
  140,
  145,
  140,
  140,
  145,
  50,
  1,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  256,
  9472,
  512,
  9472,
  768,
  0,
  0,
  35584,
  2561,
  9728,
  51714,
  35843,
  37120,
  35840,
  35840,
  37120,
  12800,
  256,
  768,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  37,
  2,
  37,
  3,
  0,
  0,
  400,
  6,
  555,
  980,
  140,
  145,
  140,
  140,
  145,
  50,
  1,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  256,
  9984,
  512,
  9984,
  768,
  0,
  0,
  256,
  48640,
  64512,
  13316,
  52737,
  54016,
  52736,
  52736,
  54016,
  10240,
  256,
  768,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  37,
  2,
  37,
  3,
  0,
  0,
  459,
  0,
  1278,
  960,
  146,
  151,
  146,
  146,
  151,
  20,
  1,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  256,
  2304,
  512,
  768,
  768,
  0,
  0,
  21248,
  2,
  14848,
  31746,
  5378,
  7169,
  5377,
  23809,
  26368,
  0,
  512,
  768,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  9,
  2,
  3,
  3,
  0,
  0,
  610,
  114,
  610,
  114,
  297,
  304,
  297,
  297,
  304,
  0,
  3,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  256,
  2304,
  512,
  768,
  768,
  0,
  0,
  25856,
  1,
  7936,
  36865,
  27394,
  29184,
  27392,
  23808,
  26368,
  3840,
  256,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  9,
  2,
  3,
  3,
  0,
  0,
  939,
  0,
  879,
  614,
  107,
  114,
  107,
  93,
  103,
  15,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  768,
  2304,
  512,
  768,
  768,
  0,
  0,
  44800,
  1,
  26880,
  1,
  27394,
  29184,
  27392,
  23808,
  26368,
  2816,
  256,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  4,
  9,
  2,
  3,
  3,
  0,
  0,
  455,
  0,
  395,
  114,
  107,
  114,
  107,
  93,
  103,
  18,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
_BYTE off_E23E0[44] =
{
  32,
  230,
  7,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  69,
  2,
  171,
  1,
  40,
  0,
  70,
  0,
  0,
  0,
  247,
  246,
  11,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  0
}; // idb
_UNKNOWN unk_E24BC; // weak
__int16 word_E24BE[18] = { 40, 49, 196, 38, 0, 283, 106, 2, 454, 298, 300, 397, 298, 0, 321, 236, 8, 0 }; // idb
_UNKNOWN unk_E24F2; // weak
_UNKNOWN unk_E2516; // weak
__int16 word_E2518[] = { 303 }; // weak
char byte_E2527[72] =
{
  '\v',
  '\x95',
  '\x01',
  '^',
  '\x01',
  'A',
  '\0',
  '\x11',
  '\x02',
  'R',
  '\0',
  '\0',
  '\0',
  'T',
  '\x02',
  '\x1C',
  '\0',
  '\b',
  '\b',
  '\x96',
  '\x01',
  '~',
  '\0',
  'A',
  '\0',
  '{',
  '\0',
  'R',
  '\0',
  '\0',
  '\0',
  '7',
  '\0',
  '\x1C',
  '\0',
  '\b',
  '\t',
  '',
  '\x01',
  '\x7F',
  '\0',
  'h',
  '\x01',
  '{',
  '\0',
  'v',
  '\x01',
  '\0',
  '\0',
  '4',
  '\0',
  '\xB0',
  '\x01',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_E2570; // weak
__int16 word_E2572[45] =
{
  4,
  184,
  66,
  182,
  0,
  126,
  130,
  0,
  459,
  5,
  360,
  77,
  360,
  0,
  149,
  304,
  0,
  458,
  444,
  362,
  551,
  362,
  0,
  454,
  290,
  0,
  456,
  444,
  168,
  552,
  168,
  0,
  488,
  116,
  0,
  460,
  419,
  13,
  471,
  25,
  0,
  328,
  24,
  8,
  0
}; // idb
_UNKNOWN unk_E25DC; // weak
__int16 word_E25DE[] = { 2 }; // weak
char byte_E25ED[] = { '\x06' }; // weak
_UNKNOWN unk_E2690; // weak
_UNKNOWN unk_E26C8; // weak
_UNKNOWN unk_E28A8; // weak
__int16 word_E28B6 = 1; // weak
_WORD word_E2970[51] =
{
  0,
  0,
  4,
  30,
  287,
  656,
  3,
  270,
  0,
  0,
  1792,
  7936,
  28416,
  26115,
  770,
  3584,
  1,
  0,
  0,
  11,
  32,
  854,
  400,
  3,
  270,
  0,
  0,
  4352,
  8448,
  35584,
  29185,
  768,
  3584,
  1,
  0,
  0,
  19,
  34,
  365,
  504,
  3,
  270,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_E29D6 = 0; // weak
__int16 word_E29D8 = 0; // weak
__int16 word_E29DA = 0; // weak
__int16 word_E29DC = 0; // weak
char byte_E29DE = '\x01'; // weak
char byte_E29DF = '\0'; // weak
char byte_E29E0 = '\0'; // weak
char byte_E29E1 = '\x01'; // weak
char byte_E29E8 = '\x01'; // weak
char byte_E29EC = '\0'; // weak
char byte_E29ED = '\0'; // weak
char byte_E29EE = '\0'; // weak
char byte_E29EF = '\0'; // weak
char byte_E29F0 = '\0'; // weak
char byte_E29F1 = '\0'; // weak
__int16 word_E29F4 = 0; // weak
int dword_E29F6 = 0; // weak
int dword_E29FA = 0; // weak
int dword_E29FE = 0; // weak
int dword_E2A02 = 0; // weak
char byte_E2A06 = '\0'; // weak
_UNKNOWN unk_E2A08; // weak
__int16 word_E2A14 = 0; // weak
int dword_E2A18 = 0; // weak
int dword_E2A1C = 0; // weak
char byte_E2A20 = '\0'; // weak
__int16 word_E2A24 = 0; // weak
char byte_E2A28 = '\0'; // weak
int dword_E2A6C = 0; // weak
int dword_E2A70 = 0; // weak
__int16 word_E2A74[] = { 0 }; // weak
char byte_E2A76[] = { '\0' }; // weak
__int16 word_E2A78[] = { 0 }; // weak
__int16 word_E2A7A[] = { 0 }; // weak
__int16 word_E2A7C[] = { 0 }; // weak
__int16 word_E2A7E[] = { 0 }; // weak
int dword_E2A80 = 0; // weak
int dword_E2A84 = 0; // weak
int dword_E2A88 = 0; // weak
char byte_E2A90[] = { '\0' }; // weak
char byte_E2A91[] = { '\0' }; // weak
void *off_E2A92 = (void *)0x40001; // weak
__int16 word_E2AB8 = 0; // weak
__int16 word_E2ABA = 0; // weak
char byte_E2ACD = '\0'; // weak
char byte_E2AD0 = '\x04'; // weak
char byte_E2AEE = '$'; // weak
char byte_E2B0C = ' '; // weak
char byte_E2B2A = '\x04'; // weak
char byte_E2B48 = '\x04'; // weak
char byte_E2B66 = '\x04'; // weak
char byte_E2B84 = '\x04'; // weak
char byte_E2BA2 = '$'; // weak
__int16 word_E2BA8 = 320; // weak
__int16 word_E2BAA = 80; // weak
char byte_E2BC0 = '$'; // weak
__int16 word_E2BC6 = 320; // weak
__int16 word_E2BC8 = 80; // weak
char byte_E2BDE = '$'; // weak
__int16 word_E2BE4 = 320; // weak
__int16 word_E2BE6 = 80; // weak
char byte_E2BFC = '\x04'; // weak
char byte_E2C1A = '\x04'; // weak
char byte_E2C38 = '\x04'; // weak
char byte_E2C56 = '\x04'; // weak
char byte_E2C71 = '\0'; // weak
char byte_E2C74 = '$'; // weak
int dword_E2C86 = 0; // weak
__int16 word_E2E96 = 0; // weak
__int16 word_E2E98 = 0; // weak
char byte_E2EEA = ' '; // weak
char byte_E2F08 = ' '; // weak
char byte_E2F26 = ' '; // weak
__int16 word_E2F2C = 540; // weak
__int16 word_E2F2E = 40; // weak
char byte_E2F44 = ' '; // weak
__int16 word_E2F4A = 0; // weak
__int16 word_E2F4C = 0; // weak
char byte_E2F5F = '\0'; // weak
char byte_E2F62 = ' '; // weak
__int16 word_E2F68 = 560; // weak
__int16 word_E2F6A = 16; // weak
char byte_E32E6 = '\x04'; // weak
char byte_E3304 = '\x04'; // weak
char byte_E3322 = '\x04'; // weak
char byte_E3340 = '\x04'; // weak
char byte_E335E = '\x04'; // weak
char byte_E337C = '\x04'; // weak
char byte_E339A = '\x04'; // weak
char byte_E33B8 = '\x04'; // weak
char byte_E33D6 = '\x04'; // weak
char byte_E340F = '\0'; // weak
char byte_E3430 = '\x80'; // weak
__int16 word_E3490 = 360; // weak
__int16 word_E3492 = 114; // weak
__int16 word_E34AE = 360; // weak
__int16 word_E34B0 = 146; // weak
__int16 word_E34CC = 310; // weak
__int16 word_E34CE = 176; // weak
__int16 word_E34EA = 360; // weak
__int16 word_E34EC = 176; // weak
__int16 word_E3508 = 360; // weak
__int16 word_E350A = 210; // weak
_UNKNOWN unk_E3522; // weak
__int16 word_E359E = 0; // weak
__int16 word_E35A0 = 0; // weak
__int16 word_E35BC = 0; // weak
__int16 word_E35BE = 0; // weak
int dword_E36C4 = 0; // weak
int dword_E36C8 = 1; // weak
__int16 word_E36CC = 0; // weak
__int16 word_E36CE = 0; // weak
char byte_E36D0 = '\0'; // weak
char byte_E36D1 = '\0'; // weak
__int16 word_E36D4 = 0; // weak
char byte_E36DC[] = { '\0' }; // weak
int dword_E3758 = 0; // weak
__int16 word_E375C = 320; // weak
__int16 word_E375E = 200; // weak
int dword_E3760 = 13107520; // weak
char byte_E3766 = '\0'; // weak
int dword_E3768 = 0; // weak
int dword_E3794 = 10; // weak
char byte_E3798 = '\x01'; // weak
char byte_E3799 = '\x01'; // weak
char byte_E379A = '\0'; // weak
char byte_E379B = '\x01'; // weak
char byte_E379C = '\x01'; // weak
int dword_E37A0 = 0; // weak
int dword_E37A4 = 0; // weak
int dword_E37A8 = 0; // weak
char byte_E37AC = '\0'; // weak
char byte_E37AD = '\xFF'; // weak
char byte_E37AE = '\0'; // weak
int dword_E37B0 = 127; // weak
__int16 word_E37B4 = 1644; // weak
__int16 word_E37B6 = 0; // weak
char byte_E37B8 = '\0'; // weak
int dword_E37BC = 0; // weak
int dword_E37F8 = 127; // weak
char byte_E37FC = '\x01'; // weak
char byte_E37FD = '\x01'; // weak
char byte_E37FE = '\0'; // weak
__int16 word_E3800 = 0; // weak
__int16 word_E3802 = 0; // weak
__int16 word_E3804 = 0; // weak
int dword_E3808 = 0; // weak
int dword_E380C = 0; // weak
int dword_E3810 = 0; // weak
char byte_E3814 = '\0'; // weak
char byte_E3815 = '\0'; // weak
char byte_E3816 = '\0'; // weak
char byte_E3817 = '\x01'; // weak
char byte_E3818 = '\0'; // weak
char byte_E3819 = '\0'; // weak
char byte_E381A = '\xFF'; // weak
__int16 word_E381C = 0; // weak
__int16 word_E381E = 0; // weak
__int16 word_E3820 = 0; // weak
__int16 word_E3822 = 0; // weak
int dword_E3824 = 0; // weak
__int16 word_E3828 = 0; // weak
__int16 word_E3834 = 0; // weak
int dword_E383C = 0; // weak
int dword_E3840 = 0; // weak
int dword_E3844 = 5; // weak
_UNKNOWN unk_E3848; // weak
__int16 word_E387A = 0; // weak
int dword_E387C = 0; // weak
int dword_E3880 = 0; // weak
int dword_E3884 = 0; // weak
int dword_E3888 = 0; // weak
char byte_E388D = '\0'; // weak
int dword_E3890 = 0; // weak
_UNKNOWN unk_E3894; // weak
__int16 word_E3908 = 0; // weak
char byte_E390C = '\0'; // weak
char aSound_2[6] = "SOUND"; // weak
char byte_E39A0 = '\0'; // weak
__int16 word_E39A4 = 0; // weak
__int16 word_E39A6 = 0; // weak
__int16 word_E39A8 = 0; // weak
__int16 word_E39AA = 0; // weak
__int16 word_E39AC = 0; // weak
__int16 word_E39AE = 0; // weak
__int16 word_E39B0 = 0; // weak
__int16 word_E39B2 = 0; // weak
__int16 word_E39B4 = 0; // weak
__int16 word_E39B6 = 0; // weak
char byte_E39B8 = '\0'; // weak
int dword_E39BC = 0; // weak
_UNKNOWN unk_E39C0; // weak
_UNKNOWN unk_E3A40; // weak
_UNKNOWN unk_E3AC0; // weak
int dword_E3B40 = 0; // weak
int dword_E3B44 = 0; // weak
__int16 word_E3B4A = 0; // weak
__int16 word_E3B4C = 0; // weak
__int16 word_E3B4E = 0; // weak
char byte_E3B50 = '\0'; // weak
char byte_E3B51 = '\0'; // weak
int (*off_E3B90)() = &_null_int23_exit; // weak
int dword_E3B94 = 0; // weak
__int16 word_E3B98 = 32; // weak
__int16 word_E3B9A = 0; // weak
__int16 word_E3BA4 = 0; // weak
__int16 word_E3BA6 = 0; // weak
__int16 word_E3BA8 = 0; // weak
__int16 word_E3BAA = 0; // weak
int dword_E3BAC = 0; // weak
int dword_E3BB0 = 0; // weak
int dword_E3BB8 = 1; // weak
_UNKNOWN unk_E3BE0; // weak
int dword_E3DE8 = 0; // weak
int dword_E3DF8 = 1024; // weak
int dword_E3DFC[] = { 0 }; // weak
void (__noreturn *off_E3E10)() = &sub_9BA00; // weak
__int16 seg_E3E14[] = { 1 }; // weak
char byte_E3E28 = '\0'; // weak
int dword_E3E2C = 0; // weak
int (__cdecl *off_E3E30)(_DWORD) = &malloc; // weak
int (__cdecl *off_E3E34)(int) = &free; // weak
int dword_E3E38 = 0; // weak
int dword_E3E3C = 0; // weak
int dword_E3E40 = 0; // weak
char byte_E3E44 = '\0'; // weak
char byte_E3E45 = '\x01'; // weak
char aBullfrog[9] = "Bullfrog"; // weak
char byte_E3E54[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_E3E5C[] = { 0 }; // weak
int dword_E3E9C[] = { 0 }; // weak
int dword_E3ED8 = 0; // weak
int dword_E3EDC[] = { 0 }; // weak
int dword_E3F1C[] = { 0 }; // weak
int dword_E3F5C[] = { 0 }; // weak
int dword_E3F98 = 0; // weak
int dword_E3F9C[] = { 0 }; // weak
int dword_E3FDC = 0; // weak
__int16 word_E3FE0 = 0; // weak
int dword_E3FE2 = 0; // weak
int dword_E3FE6 = 0; // weak
int dword_E3FEA = 0; // weak
int dword_E3FEE = 0; // weak
int dword_E3FF2 = 0; // weak
__int16 word_E3FF6 = 0; // weak
int dword_E3FF8 = 0; // weak
int dword_E3FFC = 0; // weak
int dword_E4000 = 0; // weak
_UNKNOWN unk_E4004; // weak
__int16 word_E4A04 = 0; // weak
int dword_E4A08 = 0; // weak
char byte_E4A0C[128] =
{
  '\0',
  '\x02',
  '\x04',
  '\x06',
  '\b',
  '\n',
  '\f',
  '\x0E',
  '\x10',
  '\x12',
  '\x14',
  '\x16',
  '\x18',
  '\x1A',
  '\x1C',
  '\x1E',
  ' ',
  '\"',
  '$',
  '&',
  '(',
  '*',
  ',',
  '.',
  '0',
  '2',
  '4',
  '6',
  '8',
  ':',
  '<',
  '>',
  '@',
  'B',
  'D',
  'F',
  'H',
  'J',
  'L',
  'N',
  'P',
  'R',
  'T',
  'V',
  'X',
  'Z',
  '\\',
  '^',
  '`',
  'b',
  'd',
  'f',
  'h',
  'j',
  'l',
  'n',
  'p',
  'r',
  't',
  'v',
  'x',
  'z',
  '|',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80'
}; // idb
int dword_E4A8C = 0; // weak
int dword_E4A90 = 0; // weak
int dword_E4A94 = 0; // weak
char aSample[7] = "SAMPLE"; // weak
int dword_E4B18 = 0; // weak
int dword_E4B1C = 0; // weak
char aTimb_0[5] = "TIMB"; // weak
char byte_E4B2A = '\xFF'; // weak
char byte_E4B2B = '\xFF'; // weak
int dword_E4B2C = 0; // weak
int dword_E4C90 = 0; // weak
int dword_E4C94 = 0; // weak
int dword_E4CA4 = 0; // weak
char byte_E4CB2 = '\0'; // weak
char byte_E4CB4 = '\0'; // weak
int (__fastcall *off_E4CBD)(_DWORD) = &nullsub_3; // weak
int dword_E4CCC = 0; // weak
int dword_E4CD0 = 0; // weak
int dword_E4D10 = 0; // weak
__int16 word_E4D14 = 0; // weak
__int16 word_E4D16 = 0; // weak
char byte_E4D18 = '\0'; // weak
int (__cdecl *off_E4D20)(_DWORD, _DWORD) = &_no_support_loaded; // weak
int dword_E4E1C = 0; // weak
int dword_E4E20 = 0; // weak
int dword_E4E24 = 0; // weak
int dword_E4E28 = 0; // weak
int dword_E4E2C = 0; // weak
__int64 qword_E4E30 = 0i64; // weak
int dword_E4E38 = 0; // weak
__int16 word_E4E3C = 0; // weak
_UNKNOWN unk_E52EE; // weak
int dword_E731C = 16; // weak
int dword_E7320[] = { 0 }; // weak
int dword_E7324[255] =
{
  1647088,
  3294115,
  4941018,
  6587735,
  8234204,
  9880363,
  11526150,
  13171503,
  14816360,
  16460659,
  18104339,
  19747337,
  21389591,
  23031040,
  24671622,
  26311275,
  27949938,
  29587548,
  31224044,
  32859365,
  34493448,
  36126233,
  37757658,
  39387661,
  41016182,
  42643158,
  44268528,
  45892232,
  47514208,
  49134395,
  50752733,
  52369159,
  53983614,
  55596036,
  57206365,
  58814541,
  60420502,
  62024188,
  63625539,
  65224495,
  66820995,
  68414979,
  70006387,
  71595160,
  73181237,
  74764559,
  76345066,
  77922699,
  79497398,
  81069104,
  82637758,
  84203301,
  85765673,
  87324816,
  88880672,
  90433181,
  91982285,
  93527927,
  95070047,
  96608588,
  98143491,
  99674700,
  101202156,
  102725801,
  104245579,
  105761432,
  107273304,
  108781136,
  110284873,
  111784458,
  113279835,
  114770946,
  116257736,
  117740150,
  119218130,
  120691622,
  122160570,
  123624918,
  125084613,
  126539598,
  127989818,
  129435220,
  130875749,
  132311350,
  133741970,
  135167555,
  136588051,
  138003404,
  139413562,
  140818470,
  142218077,
  143612330,
  145001175,
  146384561,
  147762436,
  149134748,
  150501445,
  151862476,
  153217789,
  154567334,
  155911059,
  157248914,
  158580849,
  159906814,
  161226758,
  162540632,
  163848386,
  165149972,
  166445340,
  167734441,
  169017227,
  170293650,
  171563661,
  172827213,
  174084258,
  175334749,
  176578639,
  177815881,
  179046428,
  180270234,
  181487253,
  182697439,
  183900746,
  185097130,
  186286545,
  187468946,
  188644290,
  189812531,
  190973625,
  192127530,
  193274201,
  194413595,
  195545670,
  196670383,
  197787691,
  198897553,
  199999926,
  201094769,
  202182041,
  203261701,
  204333709,
  205398023,
  206454605,
  207503413,
  208544409,
  209577553,
  210602807,
  211620132,
  212629490,
  213630842,
  214624151,
  215609379,
  216586490,
  217555447,
  218516213,
  219468752,
  220413028,
  221349005,
  222276649,
  223195924,
  224106796,
  225009231,
  225903194,
  226788652,
  227665571,
  228533919,
  229393663,
  230244770,
  231087209,
  231920947,
  232745954,
  233562198,
  234369648,
  235168275,
  235958047,
  236738936,
  237510912,
  238273946,
  239028009,
  239773072,
  240509108,
  241236089,
  241953988,
  242662778,
  243362431,
  244052922,
  244734224,
  245406312,
  246069161,
  246722745,
  247367041,
  248002023,
  248627668,
  249243953,
  249850853,
  250448347,
  251036411,
  251615025,
  252184165,
  252743810,
  253293940,
  253834533,
  254365570,
  254887030,
  255398893,
  255901141,
  256393755,
  256876715,
  257350004,
  257813604,
  258267497,
  258711667,
  259146097,
  259570769,
  259985670,
  260390781,
  260786089,
  261171579,
  261547236,
  261913046,
  262268994,
  262615069,
  262951256,
  263277543,
  263593918,
  263900369,
  264196884,
  264483453,
  264760063,
  265026706,
  265283370,
  265530047,
  265766727,
  265993400,
  266210059,
  266416696,
  266613302,
  266799870,
  266976394,
  267142865,
  267299279,
  267445630,
  267581911,
  267708118,
  267824246,
  267930290,
  268026247,
  268112113,
  268187885,
  268253559,
  268309134,
  268354608,
  268389978,
  268415243,
  268430402
}; // idb
int dword_E7720 = 268435456; // weak
int dword_E7724[] = { 0 }; // weak
void *off_E7728[255] =
{
  &unk_FFFFA,
  (void *)0x1FFFD5,
  (void *)0x2FFF70,
  (void *)0x3FFEAA,
  (void *)0x4FFD65,
  (void *)0x5FFB80,
  (void *)0x6FF8DB,
  (void *)0x7FF556,
  (void *)0x8FF0D2,
  (void *)0x9FEB2F,
  (void *)0xAFE44D,
  (void *)0xBFDC0C,
  (void *)0xCFD24C,
  (void *)0xDFC6EF,
  (void *)0xEFB9D4,
  (void *)0xFFAADD,
  (void *)0x10F99EA,
  (void *)0x11F86DB,
  (void *)0x12F7193,
  (void *)0x13F59F0,
  (void *)0x14F3FD6,
  (void *)0x15F2324,
  (void *)0x16F03BD,
  (void *)0x17EE182,
  (void *)0x18EBC54,
  (void *)0x19E9415,
  (void *)0x1AE68A7,
  (void *)0x1BE39EB,
  (void *)0x1CE07C5,
  (void *)0x1DDD217,
  (void *)0x1ED98C2,
  (void *)0x1FD5BA9,
  (void *)0x20D1AB0,
  (void *)0x21CD5B9,
  (void *)0x22C8CA8,
  (void *)0x23C3F5F,
  (void *)0x24BEDC2,
  (void *)0x25B97B6,
  (void *)0x26B3D1D,
  (void *)0x27ADDDD,
  (void *)0x28A79D8,
  (void *)0x29A10F5,
  (void *)0x2A9A317,
  (void *)0x2B93023,
  (void *)0x2C8B7FF,
  (void *)0x2D83A91,
  (void *)0x2E7B7BD,
  (void *)0x2F72F69,
  (void *)0x306A17C,
  (void *)0x3160DDC,
  (void *)0x325746F,
  (void *)0x334D51D,
  (void *)0x3442FCC,
  (void *)0x3538463,
  (void *)0x362D2CA,
  (void *)0x3721AEA,
  (void *)0x3815CA9,
  (void *)0x39097F1,
  (void *)0x39FCCA9,
  (void *)0x3AEFABB,
  (void *)0x3BE2210,
  (void *)0x3CD4291,
  (void *)0x3DC5C28,
  (void *)0x3EB6EBF,
  (void *)0x3FA7A3F,
  (void *)0x4097E94,
  (void *)0x4187BA8,
  (void *)0x4277165,
  (void *)0x4365FB9,
  (void *)0x445468D,
  (void *)0x45425CE,
  (void *)0x462FD68,
  (void *)0x471CD48,
  (void *)0x4809559,
  (void *)0x48F558A,
  (void *)0x49E0DC8,
  (void *)0x4ACBDFF,
  (void *)0x4BB661E,
  (void *)0x4CA0613,
  (void *)0x4D89DCD,
  (void *)0x4E72D3A,
  (void *)0x4F5B44A,
  (void *)0x50432EB,
  (void *)0x512A90D,
  (void *)0x52116A1,
  (void *)0x52F7B96,
  (void *)0x53DD7DC,
  (void *)0x54C2B66,
  (void *)0x55A7623,
  (void *)0x568B805,
  (void *)0x576F0FE,
  (void *)0x5852100,
  (void *)0x59347FD,
  (void *)0x5A165E7,
  (void *)0x5AF7AB2,
  (void *)0x5BD8650,
  (void *)0x5CB88B5,
  (void *)0x5D981D4,
  (void *)0x5E771A2,
  (void *)0x5F55812,
  (void *)0x603351A,
  (void *)0x61108AE,
  (void *)0x61ED2C3,
  (void *)0x62C934E,
  (void *)0x63A4A45,
  (void *)0x647F79F,
  (void *)0x6559B50,
  (void *)0x6633551,
  (void *)0x670C597,
  (void *)0x67E4C19,
  (void *)0x68BC8CF,
  (void *)0x6993BB0,
  (void *)0x6A6A4B5,
  (void *)0x6B403D5,
  (void *)0x6C15908,
  (void *)0x6CEA447,
  (void *)0x6DBE58B,
  (void *)0x6E91CCD,
  (void *)0x6F64A07,
  (void *)0x7036D32,
  (void *)0x7108647,
  (void *)0x71D9542,
  (void *)0x72A9A1C,
  (void *)0x73794D0,
  (void *)0x7448559,
  (void *)0x7516BB2,
  (void *)0x75E47D6,
  (void *)0x76B19C1,
  (void *)0x777E16E,
  (void *)0x7849EDA,
  (void *)0x7915201,
  (void *)0x79DFADF,
  (void *)0x7AA9971,
  (void *)0x7B72DB5,
  (void *)0x7C3B7A6,
  (void *)0x7D03742,
  (void *)0x7DCAC88,
  (void *)0x7E91774,
  (void *)0x7F57805,
  (void *)0x801CE39,
  (void *)0x80E1A0F,
  (void *)0x81A5B84,
  (void *)0x8269298,
  (void *)0x832BF4A,
  (void *)0x83EE199,
  (void *)0x84AF984,
  (void *)0x857070B,
  (void *)0x8630A2D,
  (void *)0x86F02EB,
  (void *)0x87AF145,
  (void *)0x886D53B,
  (void *)0x892AECD,
  (void *)0x89E7DFD,
  (void *)0x8AA42CB,
  (void *)0x8B5FD37,
  (void *)0x8C1AD44,
  (void *)0x8CD52F2,
  (void *)0x8D8EE43,
  (void *)0x8E47F39,
  (void *)0x8F005D5,
  (void *)0x8FB821A,
  (void *)0x906F409,
  (void *)0x9125BA6,
  (void *)0x91DB8F1,
  (void *)0x9290BEE,
  (void *)0x93454A0,
  (void *)0x93F9309,
  (void *)0x94AC72C,
  (void *)0x955F10D,
  (void *)0x96110AF,
  (void *)0x96C2614,
  (void *)0x9773142,
  (void *)0x982323A,
  (void *)0x98D2902,
  (void *)0x998159C,
  (void *)0x9A2F80E,
  (void *)0x9ADD05B,
  (void *)0x9B89E86,
  (void *)0x9C36296,
  (void *)0x9CE1C8E,
  (void *)0x9D8CC72,
  (void *)0x9E37248,
  (void *)0x9EE0E15,
  (void *)0x9F89FDC,
  (void *)0xA0327A3,
  (void *)0xA0DA570,
  (void *)0xA181947,
  (void *)0xA22832D,
  (void *)0xA2CE329,
  (void *)0xA37393F,
  (void *)0xA418575,
  (void *)0xA4BC7D1,
  (void *)0xA560058,
  (void *)0xA602F11,
  (void *)0xA6A5401,
  (void *)0xA746F2D,
  (void *)0xA7E809D,
  (void *)0xA888856,
  (void *)0xA92865F,
  (void *)0xA9C7ABD,
  (void *)0xAA66578,
  (void *)0xAB04694,
  (void *)0xABA1E1A,
  (void *)0xAC3EC0F,
  (void *)0xACDB07A,
  (void *)0xAD76B62,
  (void *)0xAE11CCE,
  (void *)0xAEAC4C3,
  (void *)0xAF4634A,
  (void *)0xAFDF868,
  (void *)0xB078425,
  (void *)0xB110688,
  (void *)0xB1A7F98,
  (void *)0xB23EF5C,
  (void *)0xB2D55DB,
  (void *)0xB36B31C,
  (void *)0xB400727,
  (void *)0xB495202,
  (void *)0xB5293B6,
  (void *)0xB5BCC49,
  (void *)0xB64FBC2,
  (void *)0xB6E222A,
  (void *)0xB773F88,
  (void *)0xB8053E2,
  (void *)0xB895F42,
  (void *)0xB9261AD,
  (void *)0xB9B5B2D,
  (void *)0xBA44BC7,
  (void *)0xBAD3385,
  (void *)0xBB6126E,
  (void *)0xBBEE889,
  (void *)0xBC7B5DE,
  (void *)0xBD07A75,
  (void *)0xBD93656,
  (void *)0xBE1E988,
  (void *)0xBEA9414,
  (void *)0xBF33600,
  (void *)0xBFBCF56,
  (void *)0xC04601C,
  (void *)0xC0CE85B,
  (void *)0xC15681B,
  (void *)0xC1DDF62,
  (void *)0xC264E3B,
  (void *)0xC2EB4AB,
  (void *)0xC3712BC,
  (void *)0xC3F6875,
  (void *)0xC47B5DE,
  (void *)0xC4FFAFF,
  (void *)0xC5837E0,
  (void *)0xC606C8A,
  (void *)0xC689903,
  (void *)0xC70BD54,
  (void *)0xC78D986,
  (void *)0xC80ED9F,
  (void *)0xC88F9A8
}; // idb
int dword_E7B24 = 210828714; // weak
__int16 word_E7C58 = 0; // weak
_UNKNOWN unk_E7C64; // weak
double dbl_E7C6E =  1.797693134862316e308; // weak
float flt_E7C76 =  3.4028235e38; // weak
int dword_E7EE0[] = { 0 }; // weak
int dword_E7EE4[] = { 0 }; // weak
int dword_E7EE8[] = { 0 }; // weak
int dword_E7EEC[] = { 0 }; // weak
int dword_E7EF0[] = { 0 }; // weak
int dword_E7EF4[594] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  
}; // idb
int dword_E8840; // weak
char byte_E88E0[]; // weak
char byte_E88E1[]; // weak
char byte_E88E2[]; // weak
char byte_E88E3; // weak
char byte_E88E4; // weak
char byte_E88E5; // weak
char byte_E88E6; // weak
char byte_E88E7; // weak
char byte_E88E8; // weak
char byte_E88E9; // weak
char byte_E88EA; // weak
char byte_E88EB; // weak
char byte_E88EC; // weak
char byte_E88ED; // weak
char byte_E88EE; // weak
char byte_E88EF; // weak
char byte_E88F0; // weak
char byte_E88F1; // weak
char byte_E88F2; // weak
char byte_E88F3; // weak
char byte_E88F4; // weak
char byte_E88F5; // weak
char byte_E88F6; // weak
char byte_E88F7; // weak
char byte_E8900[]; // weak
char byte_E890F; // weak
char byte_E8988; // weak
char byte_E89F0; // weak
char byte_E89FF; // weak
char byte_E9188; // weak
char byte_E9800; // weak
char byte_E980F; // weak
char byte_E98F0; // weak
char byte_E98FF; // weak
int dword_E9980; // weak
__int16 word_E9984[134]; // idb
int dword_E9B20[]; // weak
int dword_E9B90; // weak
int dword_E9BA8; // weak
int dword_E9C08; // weak
int dword_E9C14; // weak
int dword_E9C18; // weak
int dword_E9C1C; // weak
int dword_E9C20; // weak
int dword_E9C24; // weak
int dword_E9C28; // weak
int dword_E9C2C; // weak
int dword_E9C30; // weak
int dword_E9C38; // weak
int dword_E9C3C; // weak
int dword_E9C4C[2]; // idb
int dword_E9C54; // weak
int dword_E9C84; // weak
int dword_E9CA8[136]; // idb
int dword_E9EC8; // weak
int dword_E9ECC[123]; // idb
int dword_EA0B8; // weak
int dword_EA1D0; // weak
int dword_EA224; // weak
int dword_EA230; // weak
int dword_EA234; // weak
int dword_EA238; // weak
int dword_EA240; // weak
int dword_EA244; // weak
int dword_EA248; // weak
int dword_EA24C; // weak
int dword_EA250; // weak
int dword_EA254; // weak
int dword_EA26C; // weak
int dword_EA270; // weak
int dword_EA274; // weak
int dword_EA2C4; // weak
int dword_EA2E8; // weak
int dword_EA2EC; // weak
int dword_EA2F0; // weak
int dword_EA300; // weak
int dword_EA304; // weak
int dword_EA308; // weak
int dword_EA3B4; // weak
int dword_EA3B8; // weak
int dword_EA3BC; // weak
int dword_EA3C0; // weak
int dword_EA3C4; // weak
int dword_EA3C8; // weak
int dword_EA3CC; // weak
int dword_EA3D0; // weak
int dword_EA3D4; // weak
int dword_EA3D8; // weak
int dword_EA3DC; // weak
int dword_EA3E0[]; // weak
int dword_EA3E4[]; // weak
int dword_EA3E8; // weak
int dword_EB384; // weak
int dword_EB394; // weak
__int16 word_EB398; // weak
__int16 word_EB39A; // weak
__int16 word_EB39C; // weak
char byte_EB39E; // weak
char byte_EB39F; // weak
char byte_EB3A0; // weak
char byte_EB3A1; // weak
char byte_EB3A2; // weak
char byte_EB3A3; // weak
char byte_EB3A4; // weak
char byte_EB3A5; // weak
char byte_EB3A6; // weak
char byte_EB3A7; // weak
char byte_EB3A8; // weak
char byte_EB3B6; // weak
_UNKNOWN unk_F0000; // weak
int dword_F01E4; // weak
int (__cdecl *dword_F01E8)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_F01EC)(_DWORD, _DWORD, _DWORD); // weak
__int16 word_F01F4; // weak
char byte_F01FE[]; // weak
char byte_F01FF[]; // weak
char byte_F0200[31]; // idb
char byte_F021F; // weak
char byte_F0220[256]; // idb
char byte_F0320[256]; // idb
char byte_F0420[256]; // idb
char byte_F0520[256]; // idb
char byte_F0620[256]; // idb
char byte_F0720[256]; // idb
char byte_F0820[256]; // idb
char byte_F0920[256]; // idb
_UNKNOWN unk_F0A20; // weak
_UNKNOWN unk_F0E20; // weak
int dword_F2C20; // weak
int dword_F2C24; // weak
int dword_F2C28; // weak
int dword_F2C2C; // weak
int dword_F2C30; // weak
int dword_F2C34; // weak
int dword_F2C38; // weak
int dword_F2C3C; // weak
int dword_F2C40; // weak
int dword_F2C44; // weak
int dword_F2C48; // weak
int dword_F2C4C; // weak
int dword_F2C50; // weak
int dword_F2C54; // weak
int dword_F2C58; // weak
int dword_F2C5C; // weak
int dword_F2C60; // weak
int dword_F2C64; // weak
int dword_F2C68; // weak
int dword_F2C6C; // weak
int dword_F2C70; // weak
int dword_F2C74; // weak
int dword_F2C78; // weak
int dword_F2C7C; // weak
int dword_F2C80; // weak
int dword_F2C84; // weak
int dword_F2C88; // weak
int dword_F2C8C; // weak
int dword_F2C90; // weak
int dword_F2C94; // weak
int dword_F2C98; // weak
int dword_F2C9C; // weak
int dword_F2CA0; // weak
int dword_F2CA4; // weak
int dword_F2CA8; // weak
int dword_F2CAC; // weak
int dword_F2CB0; // weak
int dword_F2CB4; // weak
int dword_F2CB8; // weak
int dword_F2CBC; // weak
__int16 word_F2CC0; // weak
__int16 word_F2CC2; // weak
__int16 word_F2CC4; // weak
char byte_F2CC6; // weak
char byte_F2CC7; // weak
char byte_F2CD0[]; // weak
char byte_F2CD1[4815]; // idb
char byte_F3FA0[]; // weak
char byte_F3FA1[]; // weak
char byte_F3FA2[670]; // idb
_UNKNOWN unk_F4240; // weak
int dword_F42A0; // weak
int dword_F42A4; // weak
__int16 word_F42A8; // weak
__int16 word_F42AE; // weak
_UNKNOWN unk_F42B0; // weak
int dword_F4720; // weak
int dword_F4940; // weak
__int16 word_F4960[]; // weak
__int16 word_F4962[830]; // idb
__int16 word_F4FE0[]; // weak
__int16 word_F4FE2[]; // weak
__int16 word_F4FE4[]; // weak
__int16 word_F4FE6[]; // weak
__int16 word_F4FE8[]; // weak
__int16 word_F4FEA[418]; // idb
int dword_F5330; // weak
__int16 word_F5334; // weak
char byte_F5340[504]; // idb
char byte_F5538[504]; // idb
int dword_F5730[504]; // idb
int dword_F5F10[504]; // idb
int dword_F66F0[504]; // idb
int dword_F6ED0; // weak
char byte_F6EE0[16384]; // idb
char byte_FAEE0[16672]; // idb
_UNKNOWN unk_FF000; // weak
_UNKNOWN unk_100000; // weak
_UNKNOWN unk_100001; // weak
char byte_10AEE0[768]; // idb
char byte_10B1E0[511]; // idb
char byte_10B3DF[]; // weak
char byte_10B3E0[255]; // idb
char byte_10B4DF[]; // weak
char byte_10B4E0[19235]; // idb
char byte_11B4E0[65536]; // idb
char byte_12B4E0[]; // weak
_UNKNOWN unk_12C000; // weak
_UNKNOWN unk_13A9CA; // weak
_UNKNOWN unk_13ACCA; // weak
_UNKNOWN unk_13B194; // weak
_UNKNOWN unk_13B3B8; // weak
char byte_13B4E0[6464]; // idb
_UNKNOWN unk_13CE20; // weak
_UNKNOWN unk_141E85; // weak
_UNKNOWN unk_145210; // weak
char byte_14B4E0[65536]; // idb
__int16 word_15B4E0[9616]; // idb
_UNKNOWN unk_163EFC; // weak
_UNKNOWN unk_1641FC; // weak
_UNKNOWN unk_1646BA; // weak
_UNKNOWN unk_164907; // weak
_UNKNOWN unk_164DAE; // weak
_UNKNOWN unk_164FCD; // weak
_UNKNOWN unk_165329; // weak
_UNKNOWN unk_16554D; // weak
_UNKNOWN unk_178B5F; // weak
_UNKNOWN unk_178E5F; // weak
__int16 word_17B4E0; // weak
_UNKNOWN unk_17C118; // weak
int dword_17D430; // weak
__int16 word_17D434; // weak
char byte_17D440[]; // weak
char byte_17D441[255]; // idb
_UNKNOWN unk_17D540; // weak
int dword_17D640; // weak
int dword_17D644; // weak
int dword_17D648; // weak
char byte_17D650[6]; // weak
char byte_17D674[6]; // weak
int dword_17D698; // weak
int dword_17D6A0; // weak
int dword_17D6A4; // weak
int dword_17D6A8; // weak
int dword_17D6AC; // weak
int dword_17D6B0; // weak
int dword_17D6C4; // weak
int dword_17D6C8; // weak
__int16 word_17D6CC; // weak
__int16 word_17D6CE; // weak
__int16 word_17D6D0; // weak
_UNKNOWN unk_17D6D4; // weak
int dword_17D6E4; // weak
int dword_17D6E8; // weak
int dword_17D6EC; // weak
int dword_17D6F0; // weak
__int16 word_17D6F6; // weak
__int16 word_17D706; // weak
__int16 word_17D708; // weak
__int16 word_17D70A; // weak
__int16 word_17D70C; // weak
__int16 word_17D70E; // weak
char byte_17D710; // weak
int dword_17D720; // weak
__int16 word_17D724; // weak
_UNKNOWN word_17D726; // weak
int dword_17D730; // weak
char byte_17D738[256]; // idb
_UNKNOWN unk_17D838; // weak
int dword_17DB38; // weak
int (__fastcall *dword_17DB3C)(_DWORD); // weak
_UNKNOWN unk_17DB40; // weak
__int16 word_17DB46; // weak
__int16 word_17DB48; // weak
__int16 word_17DB4A; // weak
int dword_17DB50; // weak
int dword_17DB54; // weak
__int16 word_17DB58; // weak
__int16 word_17DB5A; // weak
__int16 word_17DB5C; // weak
__int16 word_17DB60; // weak
int dword_17DB70; // weak
__int16 word_17DB74; // weak
_UNKNOWN unk_17DB76; // weak
_UNKNOWN unk_17DB78; // weak
_UNKNOWN unk_17DB7E; // weak
_UNKNOWN unk_17DB80; // weak
__int16 word_17DB82; // weak
__int16 word_17DB84; // weak
__int16 word_17DB86; // weak
__int16 word_17DB88; // weak
__int16 word_17DB8A; // weak
__int16 word_17DB8C; // weak
char byte_17DB8E; // weak
char byte_17DB8F; // weak
_UNKNOWN unk_17DB90; // weak
_UNKNOWN unk_17DBA8; // weak
char byte_17DBB6; // weak
int dword_17DBB8; // weak
int dword_17DBBC; // weak
__int16 word_17DBC4; // weak
char byte_17DBC6; // weak
int dword_17DBC8[]; // weak
int dword_17DBCC[]; // weak
int dword_17DBD0[]; // weak
int dword_17DBD4[]; // weak
int dword_17DBD8[121]; // idb
int dword_17DDBC[]; // weak
int dword_17DDC0[]; // weak
int dword_17DDC4[]; // weak
int dword_17DDC8[]; // weak
int dword_17DDCC[21]; // idb
int dword_17DE22; // weak
__int16 word_17DE26; // weak
int dword_17DE28; // weak
int dword_17DE2C; // weak
__int16 word_17DE30; // weak
__int16 word_17DE32; // weak
char byte_17DE34; // weak
int dword_17DE38; // weak
int dword_17DE3C; // weak
int dword_17DE40; // weak
int dword_17DE44; // weak
int dword_17DE48; // weak
int dword_17DE4C; // weak
int dword_17DE50; // weak
int dword_17DE54; // weak
int dword_17DE58; // weak
int dword_17DE5C; // weak
int dword_17DE60; // weak
int dword_17DE64; // weak
char byte_17DE68[]; // weak
char byte_17DE69[]; // weak
char byte_17DE71[]; // weak
char byte_17DE72[78]; // idb
int dword_17DEC0; // weak
int dword_17DEC4; // weak
int dword_17DEC8; // weak
int dword_17DECC; // weak
int dword_17DED0; // weak
int dword_17DED4; // weak
int dword_17DED8; // weak
int dword_17DEDC; // weak
int dword_17DEE0; // weak
int dword_17DEE4; // weak
__int16 word_17DEEC; // weak
__int16 word_17DEEE; // weak
__int16 word_17DEF0; // weak
__int16 word_17DEF2; // weak
__int16 word_17DEF4; // weak
__int16 word_17DEF6; // weak
__int16 word_17DEF8; // weak
__int16 word_17DEFA; // weak
__int16 word_17DEFC; // weak
__int16 word_17DEFE; // weak
__int16 word_17DF00; // weak
__int16 word_17DF02; // weak
__int16 word_17DF04; // weak
__int16 word_17DF06; // weak
__int16 word_17DF08; // weak
__int16 word_17DF0A; // weak
__int16 word_17DF0C; // weak
__int16 word_17DF0E; // weak
char byte_17DF10; // weak
char byte_17DF11; // weak
char byte_17DF13; // weak
_BYTE byte_17DF14[40]; // idb
char byte_17DF3C[]; // weak
char byte_17DF3D[]; // weak
char byte_17DF3E[302]; // idb
__int16 word_17E06C; // weak
__int16 word_17E06E; // weak
__int16 word_17E070; // weak
__int16 word_17E072; // weak
__int16 word_17E074; // weak
__int16 word_17E076; // weak
_UNKNOWN unk_17E078; // weak
__int16 word_17E07C; // weak
__int16 word_17E07E; // weak
__int16 word_17E080; // weak
char byte_17E082; // weak
char byte_17E083; // weak
_UNKNOWN unk_17E084; // weak
char byte_17E09C; // weak
char byte_17E09D; // weak
int dword_17E0A0[]; // weak
int dword_17E0A4[]; // weak
int dword_17E0A8[766]; // idb
int dword_17ECA0; // weak
int dword_17ECA4; // weak
int dword_17ECA8; // weak
int dword_17ECAC; // weak
char byte_17ECB0[]; // weak
char byte_17ECB1[4590]; // idb
int dword_17FEA0; // weak
int dword_17FEA4; // weak
int dword_17FEA8; // weak
int dword_17FEAC; // weak
int dword_17FEB0; // weak
int dword_17FEC0; // weak
int dword_17FEC4; // weak
int dword_17FEC8; // weak
int dword_17FECC; // weak
int dword_17FF0C; // weak
int dword_17FF10; // weak
int dword_17FF14; // weak
__int16 word_17FF18; // weak
int dword_17FF20; // weak
int dword_17FF24; // weak
_UNKNOWN unk_17FF28; // weak
int dword_17FF38; // weak
int dword_17FF40; // weak
int dword_17FF44; // weak
__int16 word_17FF4A; // weak
__int16 word_17FF56; // weak
__int16 word_17FF58; // weak
__int16 word_17FF5A; // weak
int dword_180078; // weak
int dword_180084[]; // weak
int dword_180088[]; // weak
int dword_180214[101]; // idb
_UNKNOWN unk_1803A8; // weak
__int16 word_1803AB; // weak
_UNKNOWN unk_1803C0; // weak
__int16 word_1803C3; // weak
__int16 word_1803E8; // weak
__int16 word_1803EA; // weak
__int16 word_1803EC; // weak
char byte_1803EE[100]; // idb
_UNKNOWN unk_180452; // weak
__int16 word_180455; // weak
_UNKNOWN unk_180460; // weak
__int16 word_180463; // weak
_UNKNOWN unk_180470; // weak
char byte_180471; // weak
char byte_180472; // weak
int dword_180473; // weak
_UNKNOWN unk_180484; // weak
int dword_180486; // weak
char byte_18048A; // weak
_UNKNOWN unk_18048B; // weak
_UNKNOWN unk_180498; // weak
char byte_18049E; // weak
char byte_1804A1; // weak
_UNKNOWN unk_1804B0; // weak
__int16 word_1804BE; // weak
__int16 word_1804C0; // weak
__int16 word_1804C2; // weak
__int16 word_1804C4; // weak
__int16 word_1804C6; // weak
__int16 word_1804C8; // weak
__int16 word_1804CA; // weak
signed __int16 word_1804E3[6]; // idb
__int16 word_1804EF; // weak
__int16 word_1804F7; // weak
__int16 word_1804F9; // weak
__int16 word_1804FB; // weak
__int16 word_1804FD; // weak
__int16 word_1804FF; // weak
__int16 word_180501; // weak
__int16 word_180507; // weak
__int16 word_180509; // weak
__int16 word_18050B; // weak
__int16 word_18050D; // weak
char byte_180513; // weak
char byte_180514; // weak
int dword_180516; // weak
int dword_18051A; // weak
int dword_18051E; // weak
int dword_180522; // weak
int dword_180526; // weak
int dword_18052A; // weak
int dword_180532; // weak
__int16 word_180536; // weak
__int16 word_180538; // weak
int dword_18053A; // weak
__int16 word_18053E[4]; // idb
__int16 word_180546; // weak
__int16 word_180548; // weak
__int16 word_18054A; // weak
__int16 word_18054C; // weak
__int16 word_18054E; // weak
char byte_180550; // weak
char byte_180551; // weak
char byte_180552; // weak
char byte_180553; // weak
char byte_180554; // weak
char byte_180555; // weak
char byte_180556; // weak
char byte_180557; // weak
char byte_180558; // weak
char byte_180559; // weak
char byte_18055A; // weak
_UNKNOWN unk_180560; // weak
char byte_180584; // weak
char byte_180586; // weak
char byte_180587; // weak
char byte_180588; // weak
char byte_180589; // weak
_UNKNOWN unk_18058C; // weak
int dword_180590; // weak
int dword_180594; // weak
int dword_180598; // weak
int dword_18059C; // weak
int dword_1805A0; // weak
int dword_1805A4; // weak
int dword_1805A8; // weak
int dword_1805AC; // weak
int dword_1805B0; // weak
int dword_1805B4; // weak
int dword_1805B8; // weak
int dword_1805BC; // weak
__int16 word_1805C0; // weak
__int16 word_1805C2; // weak
__int16 word_1805C4; // weak
__int16 word_1805C6; // weak
__int16 word_1805C8; // weak
_UNKNOWN unk_1805CE; // weak
int dword_180624; // weak
int dword_180628; // weak
int dword_18062C; // weak
int dword_180630; // weak
int dword_180634; // weak
int dword_180638; // weak
int dword_18063C; // weak
int dword_180640; // weak
int dword_180644; // weak
int dword_180648; // weak
int dword_18064C; // weak
int dword_180650; // weak
int dword_180654; // weak
int dword_180658; // weak
int dword_18065C; // weak
__int16 word_180660; // weak
__int16 word_180662; // weak
char byte_180664[24]; // idb
char byte_18067C; // weak
char byte_18068E; // weak
char byte_180693; // weak
char byte_180696; // weak
char byte_18069A; // weak
char byte_18069C; // weak
char byte_1806E4; // weak
char byte_1806E5; // weak
_UNKNOWN unk_1806E6; // weak
int dword_1806E8; // weak
_UNKNOWN unk_1806EC; // weak
__int16 word_1806EE; // weak
int dword_1806F0; // weak
int dword_1806F4; // weak
int dword_1806F8; // weak
int dword_1806FC; // weak
int dword_180700; // weak
int dword_180704; // weak
int dword_180708; // weak
int dword_18070C; // weak
int dword_180714; // weak
int dword_180718; // weak
int dword_180720; // weak
__int16 word_18072C; // weak
__int16 word_18072E; // weak
int dword_180730; // weak
int dword_180734; // weak
__int16 word_180738; // weak
int dword_18073A; // weak
__int16 word_180744; // weak
__int16 word_180746; // weak
__int16 word_18074A; // weak
__int16 word_18074C; // weak
_UNKNOWN unk_180750; // weak
_UNKNOWN unk_180A30; // weak
_UNKNOWN unk_180AB0; // weak
__int16 word_180B30; // weak
int dword_180B48; // weak
int dword_180B4C; // weak
__int16 word_180B50; // weak
_UNKNOWN unk_180B60; // weak
_UNKNOWN unk_180BE0; // weak
int dword_180C78; // weak
int dword_180C7C; // weak
int dword_180C80; // weak
char byte_180C84; // weak
char byte_180C90[]; // weak
int dword_180CA0[]; // weak
_UNKNOWN unk_180CA4; // weak
char byte_1810A3[]; // weak
__int16 word_1811E4[]; // weak
char byte_181504[64]; // idb
unsigned __int8 byte_181544[768]; // idb
_UNKNOWN unk_181844; // weak
_UNKNOWN unk_181B42; // weak
__int16 word_181B44; // weak
_UNKNOWN unk_181B50; // weak
int dword_181BE0; // weak
int dword_181BE4; // weak
int dword_181BF0; // weak
int dword_181BF4; // weak
int dword_181BF8; // weak
int dword_181BFC; // weak
int dword_181C00; // weak
int dword_181C04; // weak
int dword_181C08; // weak
int dword_181C0C; // weak
int dword_181C10; // weak
int dword_181C40; // weak
__int16 word_181C44; // weak
int dword_181C50[16]; // idb
char byte_181C90; // weak
_UNKNOWN unk_181D90; // weak
int dword_181DA8; // weak
int dword_181DAC[]; // weak
int dword_181DB0; // weak
int dword_181DB4; // weak
int dword_181DB8; // weak
int dword_181DBC; // weak
int dword_181DC0; // weak
int dword_181DC4; // weak
int dword_181DC8; // weak
int dword_181DCC; // weak
int dword_181DD0; // weak
int dword_181DD8; // weak
int dword_181DDC; // weak
int dword_181DE0; // weak
int dword_181DE4; // weak
int dword_181DE8; // weak
int dword_181DEC; // weak
int dword_181DF0; // weak
int dword_181DF4; // weak
_UNKNOWN unk_181DF8; // weak
int dword_181E10; // weak
int dword_181E20; // weak
int dword_181E26; // weak
__int16 word_181E2A; // weak
int dword_181E2C; // weak
__int16 word_181E30; // weak
_UNKNOWN unk_181E80; // weak
int dword_181E8C; // weak
int dword_181E90; // weak
int dword_181E94; // weak
int dword_181E98; // weak
int dword_181E9C; // weak
int dword_181EA0; // weak
int dword_181EB0; // weak
int dword_181EB4; // weak
int dword_181EB8; // weak
int dword_181EBC; // weak
int dword_181EC0; // weak
int dword_181EC4; // weak
int dword_181EC8; // weak
int dword_181ECC; // weak
int dword_181ED0; // weak
int dword_181ED4; // weak
int dword_181ED8; // weak
int dword_181EDC; // weak
_UNKNOWN unk_181EE0; // weak
signed int dword_182188[6]; // idb
signed int dword_1821A0[6]; // idb
signed int dword_1821B8[6]; // idb
signed int dword_1821D0[6]; // idb
signed int dword_1821E8[6]; // idb
_UNKNOWN unk_182200; // weak
_UNKNOWN unk_182204; // weak


//----- (00010010) --------------------------------------------------------
signed __int16 sub_10010()
{
  __int16 v0; // bx
  __int16 v2; // [esp+0h] [ebp-Ch]
  __int16 v3; // [esp+2h] [ebp-Ah]
  int v4; // [esp+4h] [ebp-8h]
  int v5; // [esp+8h] [ebp-4h]

  v0 = 0;
  if ( byte_D3F48 )
    return 1;
  dos_getdrive(&v5);
  if ( !dos_getdiskfree(v5, &v2) && v2 == -1 && !v3 && v4 == 134217729 )
  {
    v0 = v4;
    byte_D3F48 = 1;
  }
  return v0;
}
// 8C1B2: using guessed type _DWORD __cdecl dos_getdrive(_DWORD);
// 8C1E8: using guessed type _DWORD __cdecl dos_getdiskfree(_DWORD, _DWORD);
// D3F48: using guessed type char byte_D3F48;

//----- (00010080) --------------------------------------------------------
unsigned int __cdecl sub_10080(int a1, int a2)
{
  unsigned int i; // edx
  int v3; // eax
  int v4; // ecx
  int *v5; // ebx

  for ( i = 1; i < 0x64 && dword_E7EE8[6 * i] != -1; ++i )
    ;
  v3 = 3 * i;
  dword_E7EE0[2 * v3] = a1;
  dword_E7EE8[2 * v3] = a1;
  dword_E7EEC[2 * v3] = 0;
  v4 = dword_E7EE8[6 * i];
  dword_E7EE4[2 * v3] = a2;
  v5 = (int *)((char *)&dword_E9980 + 6 * v4);
  dword_E7EF0[2 * v3] = (int)v5;
  dword_E7EF4[2 * v3] = *v5;
  return i;
}
// E7EE0: using guessed type int dword_E7EE0[];
// E7EE4: using guessed type int dword_E7EE4[];
// E7EE8: using guessed type int dword_E7EE8[];
// E7EEC: using guessed type int dword_E7EEC[];
// E7EF0: using guessed type int dword_E7EF0[];
// E9980: using guessed type int dword_E9980;

//----- (00010100) --------------------------------------------------------
signed int __cdecl sub_10100(int a1)
{
  dword_E7EE8[6 * a1] = -1;
  return 1;
}
// E7EE8: using guessed type int dword_E7EE8[];

//----- (00010130) --------------------------------------------------------
signed int __cdecl sub_10130(int a1, _DWORD *a2, _DWORD *a3)
{
  int *v3; // eax
  char *v4; // edx
  int v5; // ecx
  int v6; // ebx
  int v7; // esi
  int v8; // edi
  int v9; // ebx
  signed int result; // eax

  v3 = &dword_E7EE0[6 * a1];
  v4 = (char *)v3[5];
  v5 = v3[4];
  *a2 = *v4;
  *a3 = v4[1];
  v6 = v3[3] + 1;
  v3[5] += 4;
  v3[3] = v6;
  if ( *(unsigned __int16 *)(v5 + 4) > v6
    || (v7 = v3[4], v3[3] = 0, v8 = v3[2], v3[4] = v7 + 6, ++v8, v9 = v3[1], v3[2] = v8, v8 <= v9) )
  {
    result = 1;
  }
  else
  {
    result = 2;
  }
  return result;
}
// E7EE0: using guessed type int dword_E7EE0[];

//----- (000101C0) --------------------------------------------------------
unsigned __int8 sub_101C0()
{
  int v0; // esi
  unsigned int v1; // edx
  int v2; // eax
  _BYTE *v3; // edx
  unsigned __int8 result; // al
  int v5; // ebx
  __int16 i; // cx
  char v7; // ah
  char v8; // [esp+4h] [ebp-Ch]
  char v9; // [esp+8h] [ebp-8h]
  __int16 v10; // [esp+Ch] [ebp-4h]

  v0 = dword_180628;
  sub_53E60((int)aDataSearchDat, (char *)dword_180628);
  v1 = 1;
  while ( v1 < 0x64 )
  {
    v2 = 3 * v1++;
    dword_E7EE8[2 * v2] = -1;
  }
  v3 = (_BYTE *)dword_E9C30;
  result = 0;
  do
  {
    v5 = 3 * result;
    *(int *)((char *)&dword_E9980 + 2 * v5) = (int)v3;
    v10 = 0;
    word_E9984[v5] = 0;
    while ( v10 < 32 )
    {
      for ( i = 0; i < 32; ++i )
      {
        v7 = *(_BYTE *)(v0 + i + 32 * v10);
        if ( result == v7 )
        {
          if ( !v7 && v3 == (_BYTE *)dword_E9C30 )
          {
            v8 = i;
            v9 = v10;
          }
          *v3 = i - v8;
          v3[1] = v10 - v9;
          v3[2] = result;
          v3 += 4;
          ++word_E9984[3 * result];
        }
      }
      ++v10;
    }
    ++result;
  }
  while ( result < 0x20u );
  return result;
}
// E7EE8: using guessed type int dword_E7EE8[];
// E9980: using guessed type int dword_E9980;
// E9C30: using guessed type int dword_E9C30;
// 180628: using guessed type int dword_180628;

//----- (000102D0) --------------------------------------------------------
int __cdecl sub_102D0(int a1, __int16 *a2, char a3)
{
  int v3; // esi
  int result; // eax
  int v5; // esi
  __int16 v6; // ax
  int v7; // edi
  int v8; // esi
  int (*v9)(); // eax
  unsigned __int16 v10; // ax
  __int16 v11; // ax
  __int16 v12; // si
  __int16 v13; // ax
  signed int v14; // ebx
  signed int v15; // ebx
  int v16; // [esp+0h] [ebp-Ch]
  __int16 v17; // [esp+4h] [ebp-8h]
  int v18; // [esp+8h] [ebp-4h]

  if ( a3 & 2 )
  {
    v3 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 12);
    if ( a2[2] < v3 + (signed __int16)sub_10C40(a2) )
      return 1;
    v5 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 10);
    if ( a2[2] > (signed __int16)sub_10C40(a2) + v5 )
      return 1;
  }
  if ( a3 & 1 )
  {
    v16 = *(_DWORD *)a2;
    v17 = a2[2];
    v6 = *(_WORD *)(a1 + 84);
    if ( v6 <= *(_WORD *)(a1 + 86) )
      v6 = *(_WORD *)(a1 + 86);
    v7 = v6;
    v8 = 0;
    while ( v8 <= v7 )
    {
      v18 = ~*(_DWORD *)(*(_DWORD *)(a1 + 160) + 20);
      v9 = sub_104D0((signed __int16 *)&v16);
      result = v18 & (unsigned int)v9;
      if ( result )
        return result;
      if ( byte_D41B6 )
      {
        LOBYTE(v10) = BYTE1(v16);
        HIBYTE(v10) = HIBYTE(v16);
        if ( byte_13B4E0[v10] & 8 )
          return 1;
        if ( sub_11E70(a1, (__int16 *)&v16) )
          return 1;
      }
      v8 += 256;
      sub_57FA0(&v16, *(_WORD *)(a1 + 28), 0, 256);
    }
  }
  if ( a3 & 4 )
  {
    v11 = sub_58210((_WORD *)(a1 + 76), a2);
    v12 = v11;
    v13 = sub_582F0(0, v11);
    if ( v13 < 0 )
    {
      if ( v13 == -1 )
      {
        v15 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 16);
        if ( (unsigned __int16)sub_582B0(0, v12) > v15 )
          return 1;
      }
    }
    else if ( v13 > 0 && v13 == 1 )
    {
      v14 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 18);
      if ( (unsigned __int16)sub_582B0(0, v12) > v14 )
        return 1;
    }
  }
  return 0;
}
// D41B6: using guessed type char byte_D41B6;

//----- (000104A0) --------------------------------------------------------
signed int __cdecl sub_104A0(int a1)
{
  unsigned __int16 v1; // ax

  LOBYTE(v1) = *(_BYTE *)(a1 + 1);
  HIBYTE(v1) = *(_BYTE *)(a1 + 3);
  return 1 << (byte_13B4E0[v1] & 0xF);
}

//----- (000104D0) --------------------------------------------------------
int (*__cdecl sub_104D0(signed __int16 *a1))()
{
  int v1; // eax

  v1 = *a1 >> 8;
  BYTE1(v1) = (unsigned __int16)a1[1] >> 8;
  return sub_10590(byte_10B4E0[(unsigned __int16)v1]);
}

//----- (00010590) --------------------------------------------------------
int (*__cdecl sub_10590(char a1))()
{
  int (*result)(); // eax

  result = 0;
  switch ( a1 )
  {
    case 0:
      result = (int (*)())1;
      break;
    case 1:
      result = (int (*)())2;
      break;
    case 2:
      result = (int (*)())4;
      break;
    case 3:
      result = (int (*)())8;
      break;
    case 4:
      result = (int (*)())16;
      break;
    case 5:
      result = (int (*)())32;
      break;
    case 8:
      result = (int (*)())256;
      break;
    case 9:
      result = (int (*)())512;
      break;
    case 10:
      result = (int (*)())&unk_100000;
      break;
    case 11:
      result = (int (*)())0x200000;
      break;
    case 12:
      result = (int (*)())0x400000;
      break;
    case 13:
    case 14:
      return result;
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
      result = (int (*)())1024;
      break;
    case 21:
    case 22:
    case 24:
      result = (int (*)())&loc_20000;
      break;
    case 23:
      result = (int (*)())&loc_40000;
      break;
    case 25:
    case 27:
      result = (int (*)())((char *)&loc_7FFFF + 1);
      break;
    case 26:
      result = sub_10000;
      break;
    default:
      result = (int (*)())0x800000;
      break;
  }
  return result;
}
// 10000: using guessed type int sub_10000();

//----- (00010630) --------------------------------------------------------
bool __cdecl sub_10630(_WORD *a1, signed __int16 *a2, _WORD *a3, signed __int16 *a4)
{
  return abs((signed __int16)(*a3 - *a1)) < a2[1] + a4[1]
      && abs((signed __int16)(a3[1] - a1[1])) < a2[2] + a4[2]
      && abs((signed __int16)a1[2] + *a2 - ((signed __int16)a3[2] + *a4)) < a2[3] + a4[3];
}

//----- (000106C0) --------------------------------------------------------
bool __cdecl sub_106C0(int a1, int a2)
{
  return sub_10630((_WORD *)(a1 + 76), (signed __int16 *)(a1 + 82), (_WORD *)(a2 + 76), (signed __int16 *)(a2 + 82));
}

//----- (000106F0) --------------------------------------------------------
bool __cdecl sub_106F0(_WORD *a1, int a2, _WORD *a3, int a4)
{
  return abs((signed __int16)(*a3 - *a1)) < *(signed __int16 *)(a2 + 2) + *(signed __int16 *)(a4 + 2)
      && abs((signed __int16)(a3[1] - a1[1])) < *(signed __int16 *)(a2 + 4) + *(signed __int16 *)(a4 + 4);
}

//----- (00010750) --------------------------------------------------------
bool __cdecl sub_10750(int a1, int a2)
{
  return sub_106F0((_WORD *)(a1 + 76), a1 + 82, (_WORD *)(a2 + 76), a2 + 82);
}

//----- (00010780) --------------------------------------------------------
int __cdecl sub_10780(int a1)
{
  int v1; // edx
  int v2; // edi
  int i; // eax
  int v5; // ebx
  int v6; // [esp+0h] [ebp-10h]
  int v7; // [esp+4h] [ebp-Ch]
  int v8; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  v8 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
  v1 = *(signed __int16 *)(a1 + 84) + 255;
  v9 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
  v2 = sub_10080(0, (v1 - (__CFSHL__(v1 >> 31, 8) + (v1 >> 31 << 8))) >> 8);
  if ( v2 )
  {
    while ( sub_10130(v2, &v7, &v6) == 1 )
    {
      for ( i = word_15B4E0[((unsigned __int8)(v9 + v6) << 8) + (unsigned __int8)(v7 + v8)];
            ;
            i = *(unsigned __int16 *)(v5 + 22) )
      {
        v5 = dword_EA3E4[i];
        if ( v5 == dword_EA3E4[0] )
          break;
        if ( *(_BYTE *)(v5 + 12) & 8
          && (*(char *)(a1 + 65) == -1
           || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v5 + 63) && *(char *)(a1 + 66) == -1
           || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v5 + 63) && *(_BYTE *)(a1 + 66) == *(_BYTE *)(v5 + 64))
          && *(_WORD *)(a1 + 26) != *(_WORD *)(v5 + 26)
          && sub_106C0(a1, v5) )
        {
          sub_10100(v2);
          return v5;
        }
      }
    }
    sub_10100(v2);
  }
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000108B0) --------------------------------------------------------
int __cdecl sub_108B0(int a1)
{
  int v1; // edx
  int v2; // edi
  int i; // eax
  unsigned __int8 v4; // al
  unsigned __int8 v5; // al
  __int16 v6; // ax
  int v8; // ebx
  int v9; // [esp+0h] [ebp-14h]
  int v10; // [esp+4h] [ebp-10h]
  int v11; // [esp+8h] [ebp-Ch]
  int v12; // [esp+Ch] [ebp-8h]
  char v13; // [esp+10h] [ebp-4h]

  v11 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
  v1 = *(signed __int16 *)(a1 + 84) + 255;
  v12 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
  v2 = sub_10080(0, (v1 - (__CFSHL__(v1 >> 31, 8) + (v1 >> 31 << 8))) >> 8);
  if ( v2 )
  {
LABEL_29:
    if ( sub_10130(v2, &v10, &v9) != 1 )
    {
      sub_10100(v2);
      return 0;
    }
    for ( i = word_15B4E0[((unsigned __int8)(v12 + v9) << 8) + (unsigned __int8)(v10 + v11)];
          ;
          i = *(unsigned __int16 *)(v8 + 22) )
    {
      v8 = dword_EA3E4[i];
      if ( v8 == dword_EA3E4[0] )
        goto LABEL_29;
      if ( *(_BYTE *)(v8 + 12) & 8 )
        break;
LABEL_27:
      ;
    }
    v4 = *(_BYTE *)(v8 + 63);
    v13 = 0;
    if ( v4 >= 5u )
    {
      if ( v4 <= 5u )
      {
        if ( *(_BYTE *)(v8 + 64) != 22 )
          goto LABEL_22;
      }
      else
      {
        if ( v4 != 10 )
          goto LABEL_22;
        v5 = *(_BYTE *)(v8 + 64);
        if ( v5 < 0x2Du )
        {
          if ( v5 < 0x27u || v5 > 0x28u )
            goto LABEL_22;
        }
        else
        {
          if ( v5 > 0x2Du )
          {
            if ( v5 == 57 && *(unsigned __int16 *)(v8 + 40) != *(signed __int16 *)(a1 + 26) && sub_106C0(a1, v8) )
            {
              sub_10100(v2);
              return v8;
            }
            goto LABEL_22;
          }
          if ( byte_D93C2[4 * *(char *)(v8 + 70)] & 8 )
            goto LABEL_22;
        }
      }
      v13 = 1;
    }
LABEL_22:
    if ( v13 )
    {
      v6 = *(_WORD *)(a1 + 26);
      if ( v6 != *(_WORD *)(v8 + 26) && v6 != *(unsigned __int16 *)(v8 + 148) && sub_106C0(a1, v8) )
      {
        sub_10100(v2);
        return v8;
      }
    }
    goto LABEL_27;
  }
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00010A50) --------------------------------------------------------
int __cdecl sub_10A50(int a1)
{
  int v1; // edx
  int v2; // edi
  int i; // eax
  int v5; // ebx
  int v6; // [esp+0h] [ebp-10h]
  int v7; // [esp+4h] [ebp-Ch]
  int v8; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  v8 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
  v1 = *(signed __int16 *)(a1 + 84) + 255;
  v9 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
  v2 = sub_10080(0, (v1 - (__CFSHL__(v1 >> 31, 8) + (v1 >> 31 << 8))) >> 8);
  if ( v2 )
  {
    while ( sub_10130(v2, &v7, &v6) == 1 )
    {
      for ( i = word_15B4E0[((unsigned __int8)(v9 + v6) << 8) + (unsigned __int8)(v7 + v8)];
            ;
            i = *(unsigned __int16 *)(v5 + 22) )
      {
        v5 = dword_EA3E4[i];
        if ( v5 == dword_EA3E4[0] )
          break;
        if ( (*(char *)(a1 + 65) == -1
           || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v5 + 63) && *(char *)(a1 + 66) == -1
           || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v5 + 63) && *(_BYTE *)(a1 + 66) == *(_BYTE *)(v5 + 64))
          && *(_WORD *)(a1 + 26) != *(_WORD *)(v5 + 26)
          && sub_106C0(a1, v5) )
        {
          sub_10100(v2);
          return v5;
        }
      }
    }
    sub_10100(v2);
  }
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00010B70) --------------------------------------------------------
signed int __cdecl sub_10B70(unsigned __int16 *a1, char a2, char a3)
{
  __int16 v3; // si
  __int16 i; // di
  unsigned int j; // ebx
  int v8; // [esp+0h] [ebp-8h]
  int v9; // [esp+4h] [ebp-4h]

  v9 = (*a1 - 128) >> 8;
  v3 = 0;
  v8 = (a1[1] - 128) >> 8;
  while ( v3 < 2 )
  {
    for ( i = 0; i < 2; ++i )
    {
      for ( j = dword_EA3E4[word_15B4E0[((unsigned __int8)(v8 + v3) << 8) + (unsigned __int8)(v9 + i)]];
            j > dword_EA3E4[0];
            j = dword_EA3E4[*(unsigned __int16 *)(j + 22)] )
      {
        if ( *(_BYTE *)(j + 63) == a2 && a3 == *(_BYTE *)(j + 64) && sub_583F0(a1, (_WORD *)(j + 76)) <= 0x80 )
          return 1;
      }
    }
    ++v3;
  }
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00010C40) --------------------------------------------------------
int __cdecl sub_10C40(__int16 *a1)
{
  return sub_B5C60(*a1, a1[1]);
}

//----- (00010C60) --------------------------------------------------------
int __cdecl sub_10C60(__int16 *a1)
{
  return sub_B5D68(*a1, a1[1]);
}

//----- (00010C80) --------------------------------------------------------
int __cdecl sub_10C80(int a1, unsigned __int8 a2, unsigned __int16 a3)
{
  int v3; // edi
  unsigned int ii; // esi
  unsigned int jj; // esi
  int v6; // ecx
  int ll; // eax
  int v8; // esi
  int result; // eax
  int n; // esi
  int v11; // eax
  int k; // esi
  int v13; // eax
  int v14; // [esp+0h] [ebp-5Ch]
  int v15; // [esp+4h] [ebp-58h]
  int v16; // [esp+8h] [ebp-54h]
  int v17; // [esp+Ch] [ebp-50h]
  int v18; // [esp+10h] [ebp-4Ch]
  int v19; // [esp+1Ch] [ebp-40h]
  int v20; // [esp+20h] [ebp-3Ch]
  int v21; // [esp+24h] [ebp-38h]
  int v22; // [esp+28h] [ebp-34h]
  int m; // [esp+2Ch] [ebp-30h]
  int v24; // [esp+30h] [ebp-2Ch]
  int j; // [esp+34h] [ebp-28h]
  int l; // [esp+38h] [ebp-24h]
  int v27; // [esp+3Ch] [ebp-20h]
  int v28; // [esp+40h] [ebp-1Ch]
  int i; // [esp+44h] [ebp-18h]
  int kk; // [esp+48h] [ebp-14h]
  int v31; // [esp+4Ch] [ebp-10h]
  signed int v32; // [esp+54h] [ebp-8h]

  v3 = 0;
  v32 = 1 << a2;
  if ( a2 )
  {
    if ( a2 < 3u || a2 > 4u )
    {
      v17 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
      v14 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
      v27 = (*(signed __int16 *)(a1 + 84)
           + 255
           - (__CFSHL__((*(signed __int16 *)(a1 + 84) + 255) >> 31, 8)
            + ((*(signed __int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
      for ( i = -v27; i <= v27; ++i )
      {
        for ( j = -v27; j <= v27; ++j )
        {
          for ( k = dword_EA3E4[word_15B4E0[(unsigned __int8)(j + v17) + ((unsigned __int8)(i + v14) << 8)]];
                k != dword_EA3E4[0];
                k = dword_EA3E4[*(unsigned __int16 *)(k + 22)] )
          {
            if ( *(_WORD *)(a1 + 26) != *(_WORD *)(k + 26)
              && *(_BYTE *)(k + 63)
              && *(_BYTE *)(k + 12) & 8
              && (unsigned __int8)v32 & *(_BYTE *)(k + 56)
              && (*(char *)(a1 + 65) == -1
               || *(_BYTE *)(a1 + 65) == *(_BYTE *)(k + 63) && *(char *)(a1 + 66) == -1
               || *(_BYTE *)(a1 + 65) == *(_BYTE *)(k + 63) && *(_BYTE *)(a1 + 66) == *(_BYTE *)(k + 64))
              && sub_106C0(a1, k) )
            {
              v13 = k + 6 * a2;
              if ( *(_WORD *)(v13 + 98) )
                *(_DWORD *)(v13 + 94) += a3;
              else
                *(_DWORD *)(v13 + 94) = a3;
              ++v3;
              *(_WORD *)(k + 6 * a2 + 98) = *(_WORD *)(a1 + 26);
            }
          }
        }
      }
      return v3;
    }
    v18 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
    v15 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
    v28 = (*(signed __int16 *)(a1 + 84)
         + 255
         - (__CFSHL__((*(signed __int16 *)(a1 + 84) + 255) >> 31, 8)
          + ((*(signed __int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
    for ( l = -v28; l <= v28; ++l )
    {
      for ( m = -v28; m <= v28; ++m )
      {
        for ( n = dword_EA3E4[word_15B4E0[((unsigned __int8)(l + v15) << 8) + (unsigned __int8)(m + v18)]];
              n != dword_EA3E4[0];
              n = dword_EA3E4[*(unsigned __int16 *)(n + 22)] )
        {
          if ( *(_WORD *)(a1 + 26) != *(_WORD *)(n + 26) && *(_BYTE *)(n + 63) == 3 && sub_106C0(a1, n) )
          {
            v11 = n + 6 * a2;
            if ( !*(_WORD *)(v11 + 98) )
            {
              *(_DWORD *)(v11 + 94) = a3;
              ++v3;
              *(_WORD *)(v11 + 98) = *(_WORD *)(a1 + 26);
            }
          }
        }
      }
    }
    result = v3;
  }
  else
  {
    for ( ii = *(_DWORD *)(dword_D41A4 + 38519); ii > dword_EA3E4[0]; ii = *(_DWORD *)ii )
    {
      if ( *(_BYTE *)(ii + 64) == 2 && *(_WORD *)(ii + 26) != *(_WORD *)(a1 + 26) && sub_106C0(a1, ii) )
      {
        if ( *(_WORD *)(ii + 98) )
          *(_DWORD *)(ii + 94) += a3;
        else
          *(_DWORD *)(ii + 94) = a3;
        ++v3;
        *(_WORD *)(ii + 98) = *(_WORD *)(a1 + 26);
      }
    }
    for ( jj = *(_DWORD *)(dword_D41A4 + 38527); jj > dword_EA3E4[0]; jj = *(_DWORD *)jj )
    {
      if ( sub_10750(a1, jj) )
      {
        v6 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(jj + 70) + 4);
        v21 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(jj + 70) + 5);
        if ( word_180660 == 1 )
        {
          v6 >>= 1;
          v21 >>= 1;
        }
        v22 = (*(signed __int16 *)(a1 + 76) >> 8) - (v6 >> 1);
        v20 = (*(signed __int16 *)(a1 + 78) >> 8) - (v21 >> 1);
        if ( (v20 + v22) % 2 )
          ++v22;
        if ( *(_BYTE *)(*(_DWORD *)(dword_EA3BC + 6 * *(char *)(jj + 70))
                      + 2
                      * ((*(signed __int16 *)(a1 + 76) >> 8) - v22 + ((*(signed __int16 *)(a1 + 78) >> 8) - v20) * v6)) != -1 )
        {
          if ( *(_WORD *)(jj + 98) )
            *(_DWORD *)(jj + 94) += a3;
          else
            *(_DWORD *)(jj + 94) = a3;
          ++v3;
          *(_WORD *)(jj + 98) = *(_WORD *)(a1 + 26);
        }
      }
    }
    v19 = (*(unsigned __int16 *)(a1 + 76)
         + 128
         - (__CFSHL__((*(unsigned __int16 *)(a1 + 76) + 128) >> 31, 8)
          + ((*(unsigned __int16 *)(a1 + 76) + 128) >> 31 << 8))) >> 8;
    v16 = (*(unsigned __int16 *)(a1 + 78)
         + 128
         - (__CFSHL__((*(unsigned __int16 *)(a1 + 78) + 128) >> 31, 8)
          + ((*(unsigned __int16 *)(a1 + 78) + 128) >> 31 << 8))) >> 8;
    v24 = (*(signed __int16 *)(a1 + 84)
         + 255
         - (__CFSHL__((*(signed __int16 *)(a1 + 84) + 255) >> 31, 8)
          + ((*(signed __int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
    v31 = -v24;
    if ( -v24 > v24 )
      return v3;
    do
    {
      for ( kk = -v24; kk <= v24; ++kk )
      {
        for ( ll = word_15B4E0[((unsigned __int8)(v16 + v31) << 8) + (unsigned __int8)(kk + v19)];
              ;
              ll = *(unsigned __int16 *)(v8 + 22) )
        {
          v8 = dword_EA3E4[ll];
          if ( v8 == dword_EA3E4[0] )
            break;
          if ( *(_WORD *)(a1 + 26) != *(_WORD *)(v8 + 26)
            && (*(_BYTE *)(v8 + 63) != 3 || *(_BYTE *)(v8 + 64) != 2)
            && (unsigned __int8)v32 & *(_BYTE *)(v8 + 56)
            && *(_BYTE *)(v8 + 12) & 8
            && (*(_BYTE *)(v8 + 63) != 10 || *(_BYTE *)(v8 + 64) != 45)
            && sub_106C0(a1, v8)
            && (*(char *)(a1 + 65) == -1
             || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v8 + 63) && *(char *)(a1 + 66) == -1
             || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v8 + 63) && *(_BYTE *)(a1 + 66) == *(_BYTE *)(v8 + 64)) )
          {
            if ( *(_WORD *)(v8 + 98) )
              *(_DWORD *)(v8 + 94) += a3;
            else
              *(_DWORD *)(v8 + 94) = a3;
            ++v3;
            *(_WORD *)(v8 + 98) = *(_WORD *)(a1 + 26);
          }
        }
      }
      ++v31;
    }
    while ( v31 <= v24 );
    result = v3;
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// EA3BC: using guessed type int dword_EA3BC;
// EA3E4: using guessed type int dword_EA3E4[];
// 180660: using guessed type __int16 word_180660;

//----- (000112D0) --------------------------------------------------------
int __cdecl sub_112D0(int a1, unsigned __int16 a2)
{
  int v2; // eax
  int v3; // edi
  int result; // eax
  int v5; // ebx
  int v6; // [esp+0h] [ebp-10h]
  int v7; // [esp+4h] [ebp-Ch]
  int i; // [esp+8h] [ebp-8h]
  int j; // [esp+Ch] [ebp-4h]

  v6 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
  v7 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
  v2 = (*(signed __int16 *)(a1 + 84)
      + 255
      - (__CFSHL__((*(signed __int16 *)(a1 + 84) + 255) >> 31, 8)
       + ((*(signed __int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
  v3 = v2;
  result = -v2;
  for ( i = result; v3 >= i; ++i )
  {
    result = -v3;
    for ( j = -v3; v3 >= j; ++j )
    {
      for ( result = word_15B4E0[((unsigned __int8)(v7 + i) << 8) + (unsigned __int8)(j + v6)];
            ;
            result = *(unsigned __int16 *)(v5 + 22) )
      {
        v5 = dword_EA3E4[result];
        if ( v5 == dword_EA3E4[0] )
          break;
        if ( *(_WORD *)(a1 + 26) != *(_WORD *)(v5 + 26)
          && *(_BYTE *)(v5 + 63)
          && *(_BYTE *)(v5 + 12) & 8
          && *(_BYTE *)(v5 + 56) & 2
          && (*(char *)(a1 + 65) == -1
           || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v5 + 63) && *(char *)(a1 + 66) == -1
           || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v5 + 63) && *(_BYTE *)(a1 + 66) == *(_BYTE *)(v5 + 64))
          && sub_106C0(a1, v5) )
        {
          *(_WORD *)(v5 + 104) = *(_WORD *)(a1 + 26);
          *(_DWORD *)(v5 + 100) = a2;
        }
      }
    }
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00011400) --------------------------------------------------------
char __cdecl sub_11400(int a1, char a2, unsigned __int16 a3)
{
  signed int v3; // eax
  _BOOL1 v4; // zf
  unsigned int i; // ebx
  int v6; // eax
  int v7; // edi
  int l; // ebx
  int v9; // ebx
  int v11; // [esp+0h] [ebp-18h]
  int v12; // [esp+4h] [ebp-14h]
  signed int j; // [esp+8h] [ebp-10h]
  int k; // [esp+Ch] [ebp-Ch]

  v3 = 1 << a2;
  if ( !a2 )
  {
    v4 = (*(_BYTE *)(a1 + 14) & 1) == 0;
    for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(_BYTE *)(i + 64) == 2 && *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) && sub_106C0(a1, i) )
      {
        if ( *(_WORD *)(i + 98) )
          *(_DWORD *)(i + 94) += a3;
        else
          *(_DWORD *)(i + 94) = a3;
        *(_WORD *)(i + 98) = *(_WORD *)(a1 + 26);
      }
    }
    v11 = (*(unsigned __int16 *)(a1 + 76)
         + 128
         - (__CFSHL__((*(unsigned __int16 *)(a1 + 76) + 128) >> 31, 8)
          + ((*(unsigned __int16 *)(a1 + 76) + 128) >> 31 << 8))) >> 8;
    v12 = (*(unsigned __int16 *)(a1 + 78)
         + 128
         - (__CFSHL__((*(unsigned __int16 *)(a1 + 78) + 128) >> 31, 8)
          + ((*(unsigned __int16 *)(a1 + 78) + 128) >> 31 << 8))) >> 8;
    v6 = (*(signed __int16 *)(a1 + 84)
        + 255
        - (__CFSHL__((*(signed __int16 *)(a1 + 84) + 255) >> 31, 8)
         + ((*(signed __int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
    v7 = v6;
    v3 = -v6;
    for ( j = v3; v7 >= j; ++j )
    {
      v3 = -v7;
      for ( k = -v7; v7 >= k; ++k )
      {
        v3 = ((unsigned __int8)(v12 + j) << 8) + (unsigned __int8)(k + v11);
        for ( l = word_15B4E0[v3]; ; l = *(unsigned __int16 *)(v9 + 22) )
        {
          v9 = dword_EA3E4[l];
          if ( v9 == dword_EA3E4[0] )
            break;
          LOWORD(v3) = *(_WORD *)(a1 + 26);
          if ( (_WORD)v3 != *(_WORD *)(v9 + 26) )
          {
            v3 = sub_106C0(a1, v9);
            if ( v3 )
            {
              LOBYTE(v3) = 1 << a2;
              if ( (unsigned __int16)(1 << a2) & *(unsigned __int8 *)(v9 + 56) )
              {
                if ( *(_BYTE *)(v9 + 12) & 8 && (*(_BYTE *)(v9 + 63) != 3 || *(_BYTE *)(v9 + 64) != 2) )
                {
                  if ( *(char *)(a1 + 65) == -1
                    || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v9 + 63) && *(char *)(a1 + 66) == -1
                    || (LOBYTE(v3) = *(_BYTE *)(a1 + 65), (_BYTE)v3 == *(_BYTE *)(v9 + 63))
                    && (LOBYTE(v3) = *(_BYTE *)(a1 + 66), (_BYTE)v3 == *(_BYTE *)(v9 + 64)) )
                  {
                    if ( *(_BYTE *)(v9 + 63) != 2 || *(_BYTE *)(v9 + 64) )
                    {
                      if ( *(_WORD *)(v9 + 98) )
                        *(_DWORD *)(v9 + 94) += a3;
                      else
                        *(_DWORD *)(v9 + 94) = a3;
                    }
                    else if ( *(_WORD *)(v9 + 98) )
                    {
                      *(_DWORD *)(v9 + 94) += a3 / 10;
                    }
                    else
                    {
                      *(_DWORD *)(v9 + 94) = a3 / 10;
                    }
                    LOBYTE(v3) = 0;
                    *(_WORD *)(v9 + 98) = *(_WORD *)(a1 + 26);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v3;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000116A0) --------------------------------------------------------
int __cdecl sub_116A0(int a1, char a2, unsigned __int16 a3)
{
  int v3; // edi
  unsigned int i; // ebx
  int l; // ebx
  int v7; // [esp+0h] [ebp-1Ch]
  int v8; // [esp+4h] [ebp-18h]
  int k; // [esp+8h] [ebp-14h]
  int v10; // [esp+Ch] [ebp-10h]
  int j; // [esp+10h] [ebp-Ch]

  v3 = 0;
  if ( !a2 )
  {
    for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(_BYTE *)(i + 64) == 2 && sub_106C0(a1, i) )
      {
        *(_WORD *)(i + 48) = 30;
        if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) )
        {
          if ( *(_WORD *)(i + 98) )
            *(_DWORD *)(i + 94) += a3;
          else
            *(_DWORD *)(i + 94) = a3;
          ++v3;
          *(_WORD *)(i + 98) = *(_WORD *)(a1 + 26);
        }
      }
    }
    v7 = (*(unsigned __int16 *)(a1 + 76)
        + 128
        - (__CFSHL__((*(unsigned __int16 *)(a1 + 76) + 128) >> 31, 8)
         + ((*(unsigned __int16 *)(a1 + 76) + 128) >> 31 << 8))) >> 8;
    v8 = (*(unsigned __int16 *)(a1 + 78)
        + 128
        - (__CFSHL__((*(unsigned __int16 *)(a1 + 78) + 128) >> 31, 8)
         + ((*(unsigned __int16 *)(a1 + 78) + 128) >> 31 << 8))) >> 8;
    v10 = (*(signed __int16 *)(a1 + 84)
         + 255
         - (__CFSHL__((*(signed __int16 *)(a1 + 84) + 255) >> 31, 8)
          + ((*(signed __int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
    for ( j = -v10; j <= v10; ++j )
    {
      for ( k = -v10; k <= v10; ++k )
      {
        for ( l = dword_EA3E4[word_15B4E0[((unsigned __int8)(v8 + j) << 8) + (unsigned __int8)(k + v7)]];
              l != dword_EA3E4[0];
              l = dword_EA3E4[*(unsigned __int16 *)(l + 22)] )
        {
          if ( *(_WORD *)(a1 + 26) != *(_WORD *)(l + 26)
            && sub_106C0(a1, l)
            && (unsigned __int16)(1 << a2) & *(unsigned __int8 *)(l + 56)
            && *(_BYTE *)(l + 12) & 8
            && (*(_BYTE *)(l + 63) != 3 || *(_BYTE *)(l + 64) != 2)
            && (*(char *)(a1 + 65) == -1
             || *(_BYTE *)(a1 + 65) == *(_BYTE *)(l + 63) && *(char *)(a1 + 66) == -1
             || *(_BYTE *)(a1 + 65) == *(_BYTE *)(l + 63) && *(_BYTE *)(a1 + 66) == *(_BYTE *)(l + 64)) )
          {
            if ( *(_WORD *)(l + 98) )
              *(_DWORD *)(l + 94) += a3;
            else
              *(_DWORD *)(l + 94) = a3;
            ++v3;
            *(_WORD *)(l + 98) = *(_WORD *)(a1 + 26);
          }
        }
      }
    }
  }
  return v3;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00011900) --------------------------------------------------------
int __cdecl sub_11900(int a1, int a2, unsigned __int8 a3, unsigned __int16 a4)
{
  int v4; // eax
  int result; // eax

  v4 = a2 + 6 * a3;
  if ( *(_WORD *)(v4 + 98) )
    *(_DWORD *)(v4 + 94) = a4;
  else
    *(_DWORD *)(v4 + 94) += a4;
  result = 3 * a3;
  *(_WORD *)(a2 + 6 * a3 + 98) = *(_WORD *)(a1 + 26);
  return result;
}

//----- (00011960) --------------------------------------------------------
unsigned int __cdecl sub_11960(_WORD *a1)
{
  __int16 v1; // di
  unsigned int v2; // ebx
  __int16 v4; // [esp+0h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]

  sub_49EC0(a1, a1[8] + 1);
  v6 = (signed __int16)a1[42];
  v1 = a1[38];
  v5 = (signed __int16)a1[43];
  v2 = *(_DWORD *)(dword_D41A4 + 38527);
  v4 = a1[39];
  while ( v2 > dword_EA3E4[0] )
  {
    if ( abs((signed __int16)(*(_WORD *)(v2 + 76) - v1)) <= *(signed __int16 *)(v2 + 84) + v6
      && abs((signed __int16)(*(_WORD *)(v2 + 78) - v4)) <= *(signed __int16 *)(v2 + 86) + v5 )
    {
      *(_DWORD *)(v2 + 8) = -1;
      *(_BYTE *)(v2 + 61) = 0;
    }
    v2 = *(_DWORD *)v2;
  }
  return sub_49EC0(a1, a1[8]);
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00011A10) --------------------------------------------------------
char __cdecl sub_11A10(_WORD *a1)
{
  unsigned int i; // ebx
  unsigned __int16 v3; // bx
  __int16 v4; // di
  __int16 v5; // di
  unsigned __int16 v6; // bx
  __int16 v7; // di
  unsigned __int16 v8; // bx
  int v9; // eax
  __int16 v10; // di
  unsigned __int16 v11; // bx
  __int16 v12; // [esp+0h] [ebp-24h]
  int v13; // [esp+4h] [ebp-20h]
  __int16 l; // [esp+8h] [ebp-1Ch]
  __int16 j; // [esp+Ch] [ebp-18h]
  __int16 k; // [esp+10h] [ebp-14h]
  int v17; // [esp+14h] [ebp-10h]
  __int16 v18; // [esp+14h] [ebp-10h]
  __int16 v19; // [esp+18h] [ebp-Ch]
  unsigned __int16 v20; // [esp+1Ch] [ebp-8h]
  __int16 v21; // [esp+20h] [ebp-4h]
  __int16 v22; // [esp+20h] [ebp-4h]

  v18 = a1[42] >> 8;
  v21 = a1[43] >> 8;
  sub_49EC0(a1, a1[8] + 1);
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(_BYTE *)(i + 64) == 2 && (_WORD *)i != a1 && sub_106C0(i, (int)a1) )
    {
      sub_49EC0(a1, a1[8]);
      return 0;
    }
  }
  v19 = a1[42] >> 8;
  v12 = a1[43] >> 8;
  LOBYTE(v20) = ((unsigned __int16)(a1[38] + 128) >> 8) - v19;
  HIBYTE(v20) = ((unsigned __int16)(a1[39] + 128) >> 8) - v12;
  LOWORD(v17) = v19 - v18;
  v3 = v20;
  v22 = v12 - v21;
  v4 = v22;
  while ( v4 )
  {
    for ( j = 2 * v19; j; --j )
    {
      if ( !sub_11C80(v3) )
      {
        sub_49EC0(a1, a1[8]);
        return 0;
      }
      LOBYTE(v3) = v3 + 1;
    }
    --v4;
    v3 = __PAIR__(HIBYTE(v3), (unsigned __int8)v20) + 256;
  }
  LOBYTE(v6) = v20;
  v5 = v22;
  HIBYTE(v6) = 2 * v12 + HIBYTE(v20) - v22;
  while ( v5 )
  {
    for ( k = 2 * v19; k; --k )
    {
      if ( !sub_11C80(v6) )
      {
        sub_49EC0(a1, a1[8]);
        return 0;
      }
      LOBYTE(v6) = v6 + 1;
    }
    --v5;
    v6 = __PAIR__(HIBYTE(v6), (unsigned __int8)v20) + 256;
  }
  LOBYTE(v8) = v20;
  v7 = v22;
  HIBYTE(v8) = v22 + HIBYTE(v20);
  while ( v7 )
  {
    v9 = v17;
    while ( 1 )
    {
      v13 = v9;
      if ( !(_WORD)v9 )
        break;
      if ( !sub_11C80(v8) )
      {
        sub_49EC0(a1, a1[8]);
        return 0;
      }
      v9 = v13 - 1;
      LOBYTE(v8) = v8 + 1;
    }
    --v7;
    v8 = __PAIR__(HIBYTE(v8), (unsigned __int8)v20) + 256;
  }
  LOBYTE(v11) = v19 + v20 - v17;
  v10 = v22;
  HIBYTE(v11) = v22 + HIBYTE(v20);
  while ( v10 )
  {
    for ( l = v17; l; --l )
    {
      if ( !sub_11C80(v11) )
      {
        sub_49EC0(a1, a1[8]);
        return 0;
      }
      LOBYTE(v11) = v11 + 1;
    }
    --v10;
    v11 = __PAIR__(HIBYTE(v11), (unsigned __int8)v20) + 256;
  }
  sub_49EC0(a1, a1[8]);
  return 1;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00011C80) --------------------------------------------------------
char __cdecl sub_11C80(unsigned __int16 a1)
{
  char result; // al
  char v2; // ah

  result = 1;
  v2 = byte_13B4E0[a1];
  if ( v2 < 0 || byte_D41B6 && v2 & 8 )
    result = 0;
  return result;
}
// D41B6: using guessed type char byte_D41B6;

//----- (00011CB0) --------------------------------------------------------
_BOOL1 __cdecl sub_11CB0(__int16 *a1)
{
  __int16 v1; // cx
  unsigned int v2; // ebx
  unsigned int i; // ebx
  signed __int16 v4; // di
  unsigned __int16 v5; // bx
  signed __int16 j; // si
  __int16 v8; // [esp+8h] [ebp-10h]
  unsigned __int16 v9; // [esp+Ch] [ebp-Ch]
  char v10; // [esp+14h] [ebp-4h]

  v1 = a1[1];
  v10 = 0;
  v2 = *(_DWORD *)(dword_D41A4 + 38519);
  v8 = *a1;
  while ( !v10 && v2 > dword_EA3E4[0] )
  {
    if ( *(_BYTE *)(v2 + 64) == 2
      && abs((signed __int16)(*(_WORD *)(v2 + 76) - v8)) <= *(signed __int16 *)(v2 + 84) + 2560
      && abs((signed __int16)(*(_WORD *)(v2 + 78) - v1)) <= *(signed __int16 *)(v2 + 86) + 2560 )
    {
      v10 = 1;
    }
    v2 = *(_DWORD *)v2;
  }
  if ( !v10 )
  {
    for ( i = *(_DWORD *)(dword_D41A4 + 38527); !v10 && i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( abs((signed __int16)(*(_WORD *)(i + 76) - v8)) <= *(signed __int16 *)(i + 84) + 2560
        && abs((signed __int16)(*(_WORD *)(i + 78) - v1)) <= *(signed __int16 *)(i + 86) + 2560 )
      {
        v10 = 1;
      }
    }
  }
  if ( !v10 )
  {
    LOBYTE(v9) = ((unsigned __int16)*a1 >> 8) - 8;
    HIBYTE(v9) = ((unsigned __int16)a1[1] >> 8) - 8;
    v4 = 8;
    v5 = v9;
    while ( v4 && !v10 )
    {
      for ( j = 8; j && !v10; --j )
      {
        if ( !sub_11C80(v5) )
          v10 = 1;
        LOBYTE(v5) = v5 + 1;
      }
      --v4;
      v5 = __PAIR__(HIBYTE(v5), (unsigned __int8)v9) + 256;
    }
  }
  return v10 == 0;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00011E20) --------------------------------------------------------
_BOOL1 __cdecl sub_11E20(int a1, __int16 *a2)
{
  int v2; // ebx
  int v3; // ebx

  v2 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 12);
  v3 = (signed __int16)sub_10C40(a2) + v2 + *(signed __int16 *)(a1 + 88);
  return v3 > (signed __int16)sub_10C60(a2) - 384;
}

//----- (00011E70) --------------------------------------------------------
_BOOL1 __cdecl sub_11E70(int a1, __int16 *a2)
{
  int v2; // ebx
  int v3; // ebx

  v2 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 12);
  v3 = *(signed __int16 *)(a1 + 88) + (signed __int16)sub_10C40(a2) + v2;
  return v3 > (signed __int16)sub_10C60(a2);
}

//----- (00011EE0) --------------------------------------------------------
signed int __cdecl sub_11EE0(int a1)
{
  char *v1; // ST00_4
  signed __int16 v2; // ax
  int v3; // esi
  signed int result; // eax
  int v5; // edx
  int v6; // edi
  char v7; // ST14_1
  int v8; // edx
  int v9; // edx
  int v10; // edx
  int v11; // edx
  int v12; // edx
  int v13; // ecx
  __int16 v14; // di
  int v15; // edx
  int v16; // edx
  int v17; // ecx

  v1 = (char *)&loc_365F2 + dword_D41A0 + 2;
  *((_BYTE *)&loc_36DFC + dword_D41A0 + 4) = 0;
  memset(v1, 0, 88);
  v2 = 10;
  v3 = dword_D41A0;
  while ( v2 > 0 && !(*(_BYTE *)(a1 + 8 * v2 + 26028) & 0xF) )
    --v2;
  *((_BYTE *)&loc_36DFC + dword_D41A0 + 4) = v2;
  for ( result = 1; (signed __int16)result <= *((unsigned __int8 *)&loc_36DFC + v3 + 4); ++result )
  {
    v5 = 8 * (signed __int16)result;
    v6 = a1 + v5;
    v7 = *(_BYTE *)(a1 + v5 + 26028) & 0xF;
    v8 = v3 + v5;
    *((_BYTE *)&loc_365F2 + v8 + 2) = v7;
    if ( v7 )
    {
      if ( *(_BYTE *)(v6 + 26028) < 0 )
        *(_BYTE *)(v8 + 222709) |= 1u;
      v9 = 8 * (signed __int16)result;
      if ( *(_BYTE *)(v9 + a1 + 26028) & 0x40 )
        *(_BYTE *)(v3 + v9 + 222709) |= 2u;
      v10 = 8 * (signed __int16)result;
      if ( *(_BYTE *)(v10 + a1 + 26028) & 0x10 )
        *(_BYTE *)(v3 + v10 + 222709) |= 0x20u;
      v11 = 8 * (signed __int16)result;
      if ( *(_BYTE *)(v11 + a1 + 26028) & 0x20 )
        *(_BYTE *)(v3 + v11 + 222709) |= 0x40u;
      switch ( *((_BYTE *)&loc_365F2 + 8 * (signed __int16)result + v3 + 2) )
      {
        case 1:
        case 2:
          v12 = 8 * (signed __int16)result;
          v13 = a1 + v12;
          v14 = *(_WORD *)(a1 + v12 + 26032);
          v15 = v3 + v12;
          *(_WORD *)((char *)sub_365F8 + v15) = v14 << 8;
          *(_WORD *)((char *)sub_365F8 + v15 + 2) = *(_WORD *)(v13 + 26034) << 8;
          break;
        case 3:
        case 4:
        case 5:
        case 8:
        case 9:
          v16 = 8 * (signed __int16)result;
          v17 = v3 + v16;
          LOBYTE(v16) = *(_BYTE *)(v3 + v16 + 222709);
          *(_DWORD *)((char *)sub_365F8 + v17) = 0;
          if ( v16 & 2 )
            *(_WORD *)((char *)sub_365F8 + v17) = *(_WORD *)((char *)&loc_3030E
                                                           + 20 * *(unsigned __int16 *)((char *)&loc_36479 + v17 + 5)
                                                           + v3
                                                           + 5);
          break;
        case 6:
        case 7:
          *(_DWORD *)((char *)sub_365F8 + 8 * (signed __int16)result + v3) = *(_DWORD *)(a1
                                                                                       + 8 * (signed __int16)result
                                                                                       + 26032);
          break;
        default:
          break;
      }
      *(_BYTE *)(v3 + 8 * (signed __int16)result + 222710) = *(_BYTE *)(8 * (signed __int16)result + a1 + 26029);
    }
  }
  dword_D41A0 = v3;
  return result;
}
// 365F8: using guessed type int sub_365F8();
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;

//----- (00012100) --------------------------------------------------------
__int16 __cdecl sub_12100(int a1, int a2, char a3)
{
  signed __int16 v3; // bx
  unsigned __int8 v4; // cl
  char *v5; // esi
  signed __int16 v6; // bx
  char *v7; // edx
  signed __int16 v8; // bx
  char *i; // ecx
  __int16 result; // ax

  v3 = 1;
  v4 = 0;
  v5 = (char *)sub_365F8 + dword_D41A0 + 4;
  while ( v3 <= *((unsigned __int8 *)&loc_36DFC + dword_D41A0 + 4) && !v4 )
  {
    if ( *v5
      && !(v5[1] & 1)
      && (a1 - ((signed int)&loc_3030E + dword_D41A0 + 3)) / 20 == *(unsigned __int16 *)((char *)&loc_36479
                                                                                       + 8 * v3
                                                                                       + dword_D41A0
                                                                                       + 3) )
    {
      v4 = v3;
    }
    ++v3;
    v5 += 8;
  }
  if ( !v4 )
  {
    v6 = 1;
    v7 = (char *)sub_365F8 + dword_D41A0 + 4;
    while ( v6 <= *((unsigned __int8 *)&loc_36DFC + dword_D41A0 + 4) && !v4 )
    {
      if ( *v7
        && v7[1] & 1
        && *(_WORD *)((char *)&loc_3030E
                    + 20 * *(unsigned __int16 *)((char *)&loc_36479 + 8 * v6 + dword_D41A0 + 3)
                    + dword_D41A0
                    + 5) == *(_WORD *)(a1 + 2) )
      {
        v4 = v6;
      }
      ++v6;
      v7 += 8;
    }
  }
  if ( v4 )
  {
    if ( a3 )
      *(_WORD *)(a2 + 74) = v4;
    else
      sub_12330(a2, v4);
  }
  v8 = 1;
  for ( i = (char *)sub_365F8 + dword_D41A0 + 4; ; i += 8 )
  {
    result = *((unsigned __int8 *)&loc_36DFC + dword_D41A0 + 4);
    if ( v8 > (unsigned __int8)result )
      break;
    if ( *i )
    {
      switch ( *i )
      {
        case 3:
        case 4:
        case 5:
        case 8:
        case 9:
          if ( !(i[1] & 2)
            && *(unsigned __int16 *)((char *)&loc_36479 + 8 * v8 + dword_D41A0 + 5) == (a1
                                                                                      - ((signed int)&loc_3030E
                                                                                       + dword_D41A0
                                                                                       + 3))
                                                                                     / 20 )
          {
            *((_DWORD *)i + 1) = a2;
            i[1] &= 0xFBu;
          }
          break;
        default:
          break;
      }
    }
    ++v8;
  }
  return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;

//----- (000122A0) --------------------------------------------------------
int __cdecl sub_122A0(int a1)
{
  __int16 v1; // bx
  int result; // eax

  v1 = *(_WORD *)(a1 + 74);
  if ( v1 )
    result = sub_12330(a1, v1);
  return result;
}

//----- (000122C0) --------------------------------------------------------
char *__cdecl sub_122C0(__int16 a1)
{
  signed __int16 v1; // dx
  char *result; // eax

  v1 = 1;
  result = (char *)sub_365F8 + dword_D41A0 + 4;
  while ( v1 <= *((unsigned __int8 *)&loc_36DFC + dword_D41A0 + 4) )
  {
    if ( *result == 7 && a1 == *((_WORD *)result + 2) )
      result[1] |= 0x18u;
    ++v1;
    result += 8;
  }
  return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;

//----- (00012330) --------------------------------------------------------
int __cdecl sub_12330(int a1, __int16 a2)
{
  int result; // eax
  char v3; // dl
  int v4; // ecx
  int v5; // ebx
  char v6; // dh
  unsigned __int8 v7; // dh
  char v8; // cl
  _BOOL1 v9; // zf
  int v10; // edx
  char v11; // bl

  result = a1;
  v3 = 1;
  if ( !a2 )
  {
LABEL_12:
    v3 = 0;
    goto LABEL_13;
  }
  v4 = 8 * a2;
  v5 = v4 + dword_D41A0;
  v6 = *(_BYTE *)(v4 + dword_D41A0 + 222711);
  LOBYTE(v4) = v6;
  *(_BYTE *)(v5 + 222711) = v6 + 1;
  v7 = *(_BYTE *)(v5 + 222709) & 0x60;
  v8 = v4 & 3;
  if ( v7 < 0x40u )
  {
    if ( v7 != 32 || v8 != 3 )
      goto LABEL_13;
    goto LABEL_12;
  }
  if ( v7 <= 0x40u )
  {
    v9 = (v8 & 1) == 0;
    goto LABEL_11;
  }
  if ( v7 == 96 )
  {
    v9 = (v8 & 3) == 0;
LABEL_11:
    if ( v9 )
      goto LABEL_13;
    goto LABEL_12;
  }
LABEL_13:
  if ( !v3 )
    return sub_12470(a1, 8 * *(_BYTE *)(a1 + 64) + 1);
  *(_BYTE *)(a1 + 69) = 8 * *(_BYTE *)(a1 + 64) + 7;
  *(_BYTE *)(a1 + 72) = a2;
  v10 = 8 * a2 + dword_D41A0;
  *(_WORD *)(a1 + 74) = 0;
  v11 = *((_BYTE *)&loc_365F2 + v10 + 2);
  *(_BYTE *)(a1 + 73) = v11;
  if ( v11 == 6 )
    *(_WORD *)(a1 + 74) = *(_WORD *)((char *)sub_365F8 + v10);
  return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;

//----- (00012410) --------------------------------------------------------
char __cdecl sub_12410(int a1, char a2)
{
  int v2; // edx
  char v3; // bh

  v2 = 8 * *(unsigned __int8 *)(a1 + 72);
  v3 = 0;
  if ( *(_BYTE *)(v2 + dword_D41A0 + 222710) )
    sub_12330(a1, *(unsigned __int8 *)(v2 + dword_D41A0 + 222710));
  else
    v3 = 1;
  if ( v3 )
    sub_12470(a1, a2);
  return 0;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00012470) --------------------------------------------------------
int __cdecl sub_12470(int a1, char a2)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 73) = 0;
  *(_BYTE *)(a1 + 72) = 0;
  *(_WORD *)(a1 + 74) = 0;
  *(_BYTE *)(a1 + 69) = a2;
  return result;
}

//----- (00012500) --------------------------------------------------------
char __cdecl sub_12500(int a1)
{
  int v1; // eax
  signed __int16 v2; // di
  __int16 v3; // si
  char *v4; // ecx
  __int16 v5; // si
  char v6; // dl
  __int16 v7; // dx
  int v8; // esi
  __int16 v9; // cx
  signed __int16 v11; // [esp+0h] [ebp-4h]

  LOBYTE(v1) = *(_BYTE *)(a1 + 69) & 7;
  v2 = 0;
  v3 = (unsigned __int8)v1;
  v11 = 1;
  if ( (unsigned __int8)v1 < 4u || (unsigned __int8)v1 > 5u )
  {
    LOBYTE(v1) = *(_BYTE *)(a1 + 73) - 1;
    switch ( *(_BYTE *)(a1 + 73) )
    {
      case 0xA:
        v11 = 0;
        if ( v3 != 2 && v3 != 6 )
          LOBYTE(v1) = sub_12330(a1, *(unsigned __int8 *)(a1 + 72));
        break;
      case 0xD:
      case 0xE:
      case 0x10:
      case 0x11:
        v11 = 0;
        if ( v3 != 2 && v3 != 6 )
        {
          LOBYTE(v1) = 8 * *(_BYTE *)(a1 + 64) + 7;
          *(_BYTE *)(a1 + 69) = v1;
        }
        break;
      case 0xF:
        LOBYTE(v1) = 0;
        v11 = 0;
        if ( v3 )
          LOBYTE(v1) = sub_12330(a1, *(unsigned __int8 *)(a1 + 72));
        break;
      default:
        break;
    }
    if ( v11 )
    {
      v4 = (char *)&loc_365F2 + 8 * *(unsigned __int8 *)(a1 + 72) + dword_D41A0 + 2;
      LOBYTE(v1) = *v4 - 1;
      switch ( *v4 )
      {
        case 1:
          v1 = abs(*((signed __int16 *)v4 + 2) - *(signed __int16 *)(a1 + 76));
          if ( v1 <= 2048 )
          {
            v1 = abs(*((signed __int16 *)v4 + 3) - *(signed __int16 *)(a1 + 78));
            if ( v1 <= 2048 )
              goto LABEL_44;
          }
          goto LABEL_45;
        case 3:
          LOBYTE(v1) = v4[1];
          if ( v1 & 4 )
          {
            *(_WORD *)(a1 + 74) = 0;
            if ( v3 != 2 && v3 != 6 )
              goto LABEL_44;
          }
          else if ( v1 & 2 )
          {
            v9 = *(_WORD *)(a1 + 74);
            if ( v9 )
            {
              v1 = dword_EA3E4[v9];
              if ( *(_DWORD *)(v1 + 8) < 0 || *(_BYTE *)(v1 + 13) & 4 )
                *(_WORD *)(a1 + 74) = 0;
            }
          }
          goto LABEL_45;
        case 4:
        case 5:
        case 8:
        case 9:
          v6 = v4[1];
          if ( v6 & 4 )
          {
            v2 = 1;
          }
          else
          {
            if ( !(v6 & 2) )
            {
              LOBYTE(v1) = *v4;
              if ( *v4 == 9 )
              {
                v8 = *((_DWORD *)v4 + 1);
                if ( v8 )
                {
                  v1 = abs(*(signed __int16 *)(v8 + 76) - *(signed __int16 *)(a1 + 76));
                  if ( v1 <= 3072 )
                  {
                    v1 = abs(*(signed __int16 *)(*((_DWORD *)v4 + 1) + 78) - *(signed __int16 *)(a1 + 78));
                    if ( v1 <= 3072 )
                      goto LABEL_44;
                  }
                }
              }
              goto LABEL_45;
            }
            LOBYTE(v1) = *v4;
            if ( (unsigned __int8)*v4 < 4u
              || (unsigned __int8)v1 > 5u
              || (v7 = *(_WORD *)(a1 + 74)) == 0
              || (v1 = dword_EA3E4[v7], *(_DWORD *)(v1 + 8) >= 0) && !(*(_BYTE *)(v1 + 13) & 4) )
            {
LABEL_45:
              if ( v2 )
                LOBYTE(v1) = sub_12410(a1, 8 * *(_BYTE *)(a1 + 64) + 1);
              return v1;
            }
          }
          *(_WORD *)(a1 + 74) = 0;
          goto LABEL_45;
        case 6:
          v5 = *(_WORD *)(a1 + 74) - 1;
          *(_WORD *)(a1 + 74) = v5;
          if ( !v5 )
            goto LABEL_44;
          goto LABEL_45;
        case 7:
          if ( v4[1] & 0x18 )
          {
            LOBYTE(v1) = (unsigned int)sub_12870();
LABEL_44:
            v2 = 1;
          }
          goto LABEL_45;
        default:
          goto LABEL_45;
      }
    }
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00012780) --------------------------------------------------------
char *sub_12780()
{
  signed __int16 v0; // bx
  char *result; // eax
  signed __int16 v2; // dx
  char v3; // cl
  int v4; // ecx
  char v5; // dh

  v0 = 1;
  result = (char *)sub_365F8 + dword_D41A0 + 4;
  while ( v0 <= *((unsigned __int8 *)&loc_36DFC + dword_D41A0 + 4) )
  {
    if ( !*result )
      goto LABEL_18;
    v2 = 0;
    switch ( *result )
    {
      case 3:
      case 4:
      case 5:
      case 8:
      case 9:
        v3 = result[1];
        if ( v3 & 4 )
          goto LABEL_11;
        if ( v3 & 2 )
        {
          if ( *(_DWORD *)(dword_D41A4 + 4 * *((unsigned __int16 *)result + 2) + 38403) )
            goto LABEL_12;
LABEL_11:
          v2 = 1;
          goto LABEL_12;
        }
        v4 = *((_DWORD *)result + 1);
        if ( v4 && (*(_DWORD *)(v4 + 8) < 0 || *(_BYTE *)(v4 + 13) & 4) )
          goto LABEL_11;
LABEL_12:
        if ( v2 )
          result[1] |= 4u;
LABEL_18:
        ++v0;
        result += 8;
        break;
      case 7:
        v5 = result[1];
        if ( v5 & 0x18 )
        {
          if ( v5 & 0x10 )
            result[1] = v5 & 0xEF;
          else
            result[1] = v5 & 0xF7;
        }
        goto LABEL_18;
      default:
        goto LABEL_18;
    }
  }
  return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00012870) --------------------------------------------------------
char *sub_12870()
{
  signed __int16 v0; // dx
  char *result; // eax
  char v2; // bh

  v0 = 1;
  result = (char *)sub_365F8 + dword_D41A0 + 4;
  while ( v0 <= *((unsigned __int8 *)&loc_36DFC + dword_D41A0 + 4) )
  {
    if ( *result )
    {
      switch ( *result )
      {
        case 3:
        case 4:
        case 5:
        case 8:
        case 9:
          v2 = result[1];
          if ( v2 & 4 )
          {
            if ( v2 & 2 )
              result[1] = v2 & 0xFB;
          }
          break;
        default:
          break;
      }
    }
    ++v0;
    result += 8;
  }
  return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;

//----- (00012910) --------------------------------------------------------
signed int __cdecl sub_12910(unsigned int a1)
{
  signed int result; // eax

  sub_12A70(a1);
  switch ( *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) )
  {
    case 0:
      sub_12E70(a1);
      result = sub_12E70(a1);
      break;
    case 1:
      sub_12FF0(a1);
      result = sub_12E70(a1);
      break;
    case 2:
      _nmemneed(a1);
      result = sub_12E70(a1);
      break;
    case 3:
      sub_13100(a1);
      result = sub_12E70(a1);
      break;
    case 4:
      sub_131F0((_WORD *)a1);
      result = sub_12E70(a1);
      break;
    case 5:
      _nmemneed_0(a1);
      result = sub_12E70(a1);
      break;
    case 6:
      sub_135C0(a1);
      result = sub_12E70(a1);
      break;
    case 7:
      sub_13710(a1);
      result = sub_12E70(a1);
      break;
    case 8:
      sub_13830(a1);
      result = sub_12E70(a1);
      break;
    case 9:
      sub_13870(a1);
      result = sub_12E70(a1);
      break;
    case 0xB:
      sub_133B0(a1);
      result = sub_12E70(a1);
      break;
    case 0xC:
      sub_13270(a1);
      result = sub_12E70(a1);
      break;
    case 0xD:
      sub_13850(a1);
      result = sub_12E70(a1);
      break;
    case 0xE:
      sub_161A0(a1);
      goto LABEL_16;
    default:
LABEL_16:
      result = sub_12E70(a1);
      break;
  }
  return result;
}
// 130F0: using guessed type int __cdecl _nmemneed(_DWORD);
// 135B0: using guessed type int __cdecl _nmemneed_0(_DWORD);

//----- (00012A70) --------------------------------------------------------
signed int __cdecl sub_12A70(unsigned int a1)
{
  int v1; // edx
  signed int v2; // edi
  __int16 v3; // cx
  __int16 v4; // dx
  int v5; // esi
  __int16 v6; // ax
  __int16 i; // dx
  int v8; // ecx
  int v9; // eax
  int v10; // esi
  unsigned __int16 v11; // cx
  int v12; // eax
  int v13; // eax
  int v14; // esi
  int v15; // eax
  unsigned __int16 v16; // dx
  int v18; // edx
  unsigned __int8 v19; // ah
  int v20; // ecx
  int v21; // edx
  int v22; // edx
  int v23; // ecx
  int v24; // ecx
  int v25; // edx
  int v26; // esi
  signed __int16 j; // si
  int v28; // edx
  int v29; // eax
  int v30; // eax
  int v32; // [esp+0h] [ebp-4h]

  sub_15EE0();
  v1 = *(_DWORD *)(a1 + 164);
  v2 = 0;
  v3 = *(_WORD *)(v1 + 418);
  if ( v3 < 0 )
    *(_WORD *)(v1 + 418) = v3 + 1;
  v4 = 0;
  do
  {
    v5 = 2 * v4 + *(_DWORD *)(a1 + 164);
    v6 = *(_WORD *)(v5 + 871);
    if ( v6 > 0 )
      *(_WORD *)(v5 + 871) = v6 - 1;
    ++v4;
  }
  while ( v4 < 26 );
  for ( i = 0; i < 8; ++i )
  {
    v8 = 8 * i;
    v9 = *(_DWORD *)(a1 + 164);
    v32 = v8;
    v10 = v8 + v9;
    v11 = *(_WORD *)(v8 + v9 + 516);
    if ( v11 < 0x601Fu )
    {
      *(_WORD *)(v10 + 516) = *(_WORD *)(v9 + 578) + 1 + v11;
      v12 = v32 + *(_DWORD *)(a1 + 164);
      if ( *(_WORD *)(v12 + 516) > 0x601Fu )
        *(_WORD *)(v12 + 516) = 24607;
    }
    v13 = *(_DWORD *)(a1 + 164);
    v14 = v13 + 8 * i;
    if ( *(_WORD *)(v14 + 516) > 0x601Fu )
    {
      if ( !*(_WORD *)(v14 + 518) )
        *(_WORD *)(v14 + 516) -= 256 - *(_WORD *)(v13 + 578);
      v15 = *(_DWORD *)(a1 + 164) + 8 * i;
      if ( *(_WORD *)(v15 + 516) < 0x601Fu )
        *(_WORD *)(v15 + 516) = 24607;
    }
  }
  _wcpp_1_unwind_leave__99(a1);
  v16 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 58);
  if ( v16 && sub_106C0(a1, dword_EA3E4[v16]) )
    v2 = 1;
  if ( (_WORD)v2 )
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 345) = 2;
  if ( *(_WORD *)(*(_DWORD *)(a1 + 164) + 345) )
  {
    memset(a1 + 94, 0, 36);
    --*(_WORD *)(*(_DWORD *)(a1 + 164) + 345);
  }
  else if ( sub_5EFA0(a1) == 2 )
  {
    *(_BYTE *)(a1 + 69) = 2;
    return 0;
  }
  sub_146F0(a1);
  v18 = *(_DWORD *)(a1 + 164);
  v19 = *(_BYTE *)(v18 + 340);
  if ( v19 < 0xC8u )
    *(_BYTE *)(v18 + 340) = v19 + 1;
  *(_DWORD *)(a1 + 144) += *(_DWORD *)(a1 + 136);
  v20 = *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 355) + *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v20;
  if ( v20 < -1 )
    *(_DWORD *)(a1 + 8) = -1;
  v21 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(a1 + 8) > v21 )
    *(_DWORD *)(a1 + 8) = v21;
  v22 = *(_DWORD *)(a1 + 164);
  v23 = *(_DWORD *)(v22 + 365);
  if ( v23 )
    *(_DWORD *)(v22 + 365) = v23 - 1;
  if ( (_WORD)v2 || *(_BYTE *)(a1 + 13) & 0x10 )
  {
    *(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 140) / 200;
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 355) = *(_DWORD *)(a1 + 4) / 200;
    if ( *(_DWORD *)(a1 + 136) < 1000 )
      *(_DWORD *)(a1 + 136) = 1000;
    *(_BYTE *)(a1 + 13) &= 0xEFu;
  }
  else
  {
    *(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 140) / 2000;
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 355) = *(_DWORD *)(a1 + 4) / 500;
    if ( *(_DWORD *)(a1 + 136) < 100 )
      *(_DWORD *)(a1 + 136) = 100;
  }
  if ( *(_DWORD *)(a1 + 144) < 0 )
    *(_DWORD *)(a1 + 144) = 0;
  v24 = *(_DWORD *)(a1 + 140);
  if ( *(_DWORD *)(a1 + 144) > v24 )
    *(_DWORD *)(a1 + 144) = v24;
  v25 = *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 582);
  if ( !(*(unsigned __int8 *)(a1 + 62) % (64 - ((v25 - (__CFSHL__(v25 >> 31, 2) + 4 * (v25 >> 31))) >> 2))) )
  {
    v26 = sub_15CB0(v2, a1);
    if ( v26 )
    {
      sub_15D20(a1);
      sub_15D40(v2, a1, v26);
    }
    if ( *(_DWORD *)(a1 + 8) < *(_DWORD *)(a1 + 4) )
    {
      for ( j = *(char *)(*(_DWORD *)(a1 + 164) + 1058); j >= 0; --j )
      {
        if ( (unsigned __int16)sub_15F20(a1, j, 5) == 5 )
        {
          sub_14E10(a1, 5u);
          break;
        }
      }
    }
  }
  v28 = (signed __int16)sub_10C40((__int16 *)(a1 + 76));
  v29 = *(_DWORD *)(a1 + 160);
  if ( *(signed __int16 *)(a1 + 80) > v28 + *(signed __int16 *)(v29 + 10) )
    *(_WORD *)(a1 + 80) = *(_WORD *)(v29 + 10) + v28;
  v30 = *(_DWORD *)(a1 + 160);
  if ( *(signed __int16 *)(a1 + 80) < v28 + *(signed __int16 *)(v30 + 12) )
    *(_WORD *)(a1 + 80) = *(_WORD *)(v30 + 12) + v28;
  return 1;
}
// 5E000: using guessed type int __cdecl _wcpp_1_unwind_leave__99(_DWORD);
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00012E70) --------------------------------------------------------
signed int __cdecl sub_12E70(int a1)
{
  int v2; // edx

  if ( sub_13B00(a1) )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 3;
  }
  else
  {
    if ( sub_13DC0(a1) )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 11;
      return 1;
    }
    v2 = *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 582);
    if ( !(*(unsigned __int8 *)(a1 + 62) % (64 - ((v2 - (__CFSHL__(v2 >> 31, 2) + 4 * (v2 >> 31))) >> 2))) )
    {
      if ( sub_13C50(a1) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 1;
        return 1;
      }
      if ( sub_13E40(a1) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 7;
        return 1;
      }
      if ( sub_14030(a1) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 8;
        return 1;
      }
      if ( sub_14250(a1) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 9;
        return 1;
      }
      if ( (unsigned __int16)sub_15FC0((_WORD *)a1) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 14;
        return 1;
      }
      if ( sub_13CE0(a1) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 6;
        return 1;
      }
      if ( sub_14530(a1) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 13;
        return 1;
      }
      sub_14630(a1);
    }
  }
  return 1;
}

//----- (00012FF0) --------------------------------------------------------
signed int __cdecl sub_12FF0(int a1)
{
  int v1; // esi
  signed __int16 i; // di
  int v3; // eax

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  if ( !sub_14C60(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]) )
    goto LABEL_14;
  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
  if ( sub_14C90(a1, v1, 512, 2048) )
  {
    for ( i = *(char *)(*(_DWORD *)(a1 + 164) + 1055); i >= 0 && (unsigned __int16)sub_15F20(a1, i, 2) != 2; --i )
      ;
    if ( !sub_14E10(a1, 2u) )
    {
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
      v3 = *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v1 + 80) + 512);
      if ( *(signed __int16 *)(a1 + 80) != *(signed __int16 *)(v1 + 80) + 512 )
      {
        if ( v3 <= 0 )
          LOWORD(v3) = -1;
        else
          LOWORD(v3) = 1;
      }
      *(_WORD *)(a1 + 80) += *(_WORD *)(*(_DWORD *)(a1 + 160) + 14) * v3;
      goto LABEL_13;
    }
LABEL_14:
    sub_16580(a1);
    return 0;
  }
LABEL_13:
  sub_16580(a1);
  return 1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013100) --------------------------------------------------------
signed int __cdecl sub_13100(int a1)
{
  signed __int16 i; // si
  int v2; // eax
  signed int v3; // ebx

  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a1 + 154));
  if ( !sub_14C90(a1, 0, 2048, 4096) )
    goto LABEL_16;
  for ( i = *(char *)(*(_DWORD *)(a1 + 164) + 1055); i >= 0 && (unsigned __int16)sub_15F20(a1, i, 2) != 2; --i )
    ;
  if ( sub_14E10(a1, 2u) )
  {
LABEL_16:
    sub_16580(a1);
    v3 = 0;
  }
  else
  {
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
    v2 = *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(a1 + 158) + 512);
    if ( *(signed __int16 *)(a1 + 80) != *(signed __int16 *)(a1 + 158) + 512 )
    {
      if ( *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(a1 + 158) + 512) <= 0 )
        LOWORD(v2) = -1;
      else
        LOWORD(v2) = 1;
    }
    v3 = 1;
    *(_WORD *)(a1 + 80) += v2 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
    sub_16580(a1);
  }
  return v3;
}

//----- (000131F0) --------------------------------------------------------
signed int __cdecl sub_131F0(_WORD *a1)
{
  int v1; // esi
  signed int v2; // ebx

  v1 = dword_EA3E4[(unsigned __int16)a1[75]];
  if ( !sub_14C60((int)a1, dword_EA3E4[(unsigned __int16)a1[75]])
    || (a1[16] = sub_581E0(a1 + 38, (_WORD *)(v1 + 76)), sub_14C90((int)a1, v1, 256, 2048)) )
  {
    sub_16580((int)a1);
    v2 = 0;
  }
  else
  {
    sub_16580((int)a1);
    v2 = 1;
  }
  return v2;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013270) --------------------------------------------------------
signed int __cdecl sub_13270(int a1)
{
  int v1; // edi
  signed __int16 v2; // si
  int v3; // edx
  unsigned __int16 v4; // cx
  signed __int16 v5; // di
  signed __int16 i; // si
  signed int v7; // ebx
  signed int result; // eax
  unsigned int v9; // eax

  v1 = *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 580);
  v2 = 0;
  if ( rand() % 255 < v1 )
  {
    v3 = *(_DWORD *)(a1 + 164);
    v4 = *(_WORD *)(v3 + 58);
    v5 = *(char *)(v3 + 1075);
    if ( v4 && sub_106C0(a1, dword_EA3E4[v4]) )
      v2 = 1;
    if ( !v2 )
    {
      for ( i = v5; i >= 0; --i )
      {
        if ( (unsigned __int16)sub_15F20(a1, v5, 22) == 22 )
        {
          sub_14E10(a1, 0x16u);
          sub_16580(a1);
          v7 = 1;
          goto LABEL_19;
        }
      }
    }
  }
  if ( sub_15170(a1, 3u) )
  {
    if ( !sub_156F0(a1, 3u) )
      sub_14E10(a1, 3u);
    sub_16580(a1);
    result = 1;
  }
  else
  {
    sub_16580(a1);
    v9 = sub_146C0(a1, 3u);
    if ( v9 && *(_WORD *)(v9 + 46) > 0 )
    {
      result = 1;
    }
    else
    {
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = *(_WORD *)(a1 + 132);
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
      v7 = 0;
LABEL_19:
      result = v7;
    }
  }
  return result;
}
// 8C278: using guessed type int rand(void);
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000133B0) --------------------------------------------------------
signed int __cdecl sub_133B0(int a1)
{
  int v1; // eax
  unsigned int v2; // esi
  signed __int16 k; // di
  signed __int16 l; // di
  signed __int16 i; // si
  signed __int16 j; // si
  unsigned int v9; // eax

  v1 = *(_DWORD *)(a1 + 164);
  v2 = dword_EA3E4[*(unsigned __int16 *)(v1 + 58)];
  if ( v2 <= dword_EA3E4[0] )
  {
    for ( i = *(char *)(v1 + 1064); i >= 0; --i )
    {
      if ( (unsigned __int16)sub_15F20(a1, i, 11) == 11 )
      {
        sub_14E10(a1, 0xBu);
        break;
      }
    }
    for ( j = *(char *)(*(_DWORD *)(a1 + 164) + 1056); j >= 0; --j )
    {
      if ( (unsigned __int16)sub_15F20(a1, j, 3) == 3 )
      {
        sub_14E10(a1, 3u);
        sub_16580(a1);
        return 1;
      }
    }
    v9 = sub_146C0(a1, 3u);
    if ( v9 && *(_WORD *)(v9 + 46) > 0 )
    {
      sub_16580(a1);
      return 1;
    }
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = *(_WORD *)(a1 + 132);
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
  }
  else
  {
    if ( (unsigned int)sub_584D0((_WORD *)(a1 + 76), (_WORD *)(v2 + 76)) > 0x6400000 )
    {
      for ( k = *(char *)(*(_DWORD *)(a1 + 164) + 1054); k >= 0; --k )
      {
        if ( (unsigned __int16)sub_15F20(a1, k, 1) == 1 && sub_14E10(a1, 1u) )
          goto LABEL_6;
      }
    }
    for ( l = *(char *)(*(_DWORD *)(a1 + 164) + 1064); l >= 0; --l )
    {
      if ( (unsigned __int16)sub_15F20(a1, l, 11) == 11 )
      {
        sub_14E10(a1, 0xBu);
        break;
      }
    }
    if ( sub_14C60(a1, v2) )
    {
      *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v2 + 76));
      if ( sub_14C90(a1, v2, 256, 2048) )
      {
        sub_16580(a1);
        return 0;
      }
LABEL_6:
      sub_16580(a1);
      return 1;
    }
  }
  sub_16580(a1);
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000135C0) --------------------------------------------------------
signed int __cdecl sub_135C0(int a1)
{
  _WORD *v1; // esi
  signed __int16 i; // di
  __int16 v3; // ax
  int v4; // esi
  __int16 v7; // [esp+0h] [ebp-4h]

  v1 = (_WORD *)dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  if ( !sub_14C60(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]) )
  {
LABEL_17:
    sub_16580(a1);
    return 0;
  }
  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), v1 + 38);
  if ( sub_14C90(a1, (int)v1, 1024, 3072) )
  {
    for ( i = *(char *)(*(_DWORD *)(a1 + 164) + 1054); i >= 0; --i )
    {
      v7 = sub_15F20(a1, i, 1);
      if ( v7 == 1 )
        break;
    }
    if ( v7 == 1 && sub_14E10(a1, 1u) )
    {
      v3 = sub_581E0((_WORD *)(a1 + 76), v1 + 38);
      if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v3) < 0x1Cu )
        v1[74] = *(_WORD *)(a1 + 26);
      goto LABEL_17;
    }
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
    v4 = *(signed __int16 *)(a1 + 80) - ((signed __int16)v1[40] + 512);
    if ( v4 )
    {
      if ( v4 <= 0 )
        LOWORD(v4) = -1;
      else
        LOWORD(v4) = 1;
    }
    *(_WORD *)(a1 + 80) += v4 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
  }
  sub_16580(a1);
  return 1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013710) --------------------------------------------------------
signed int __cdecl sub_13710(int a1)
{
  int v1; // esi
  int v2; // edx
  signed __int8 v3; // al
  int v4; // edx

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  if ( !sub_14C60(a1, v1) )
    goto LABEL_12;
  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
  if ( sub_14C90(a1, v1, 2048, 3584) )
  {
    v2 = *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 582);
    if ( !(*(unsigned __int8 *)(a1 + 62) % (64 - ((v2 - (__CFSHL__(v2 >> 31, 2) + 4 * (v2 >> 31))) >> 2))) )
    {
      v3 = sub_15910((_DWORD *)a1);
      if ( v3 == -1 || !sub_14E10(a1, v3) )
      {
        *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
        v4 = *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v1 + 80) + 512);
        if ( *(signed __int16 *)(a1 + 80) != *(signed __int16 *)(v1 + 80) + 512 )
        {
          if ( v4 <= 0 )
            LOWORD(v4) = -1;
          else
            LOWORD(v4) = 1;
        }
        *(_WORD *)(a1 + 80) += v4 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
        goto LABEL_11;
      }
LABEL_12:
      sub_16580(a1);
      return 0;
    }
  }
LABEL_11:
  sub_16580(a1);
  return 1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013830) --------------------------------------------------------
signed int __cdecl sub_13830(int a1)
{
  return sub_13890(a1);
}

//----- (00013850) --------------------------------------------------------
signed int __cdecl sub_13850(int a1)
{
  return sub_13890(a1);
}

//----- (00013870) --------------------------------------------------------
int __cdecl sub_13870(int a1)
{
  signed int v1; // eax

  v1 = sub_13890(a1);
  return nullsub_1(v1);
}
// 13880: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00013890) --------------------------------------------------------
signed int __cdecl sub_13890(int a1)
{
  int v1; // esi
  signed __int8 v2; // al
  unsigned __int8 v3; // di
  char v4; // ah
  char v5; // dh
  int v6; // eax
  char v7; // ch
  int v8; // eax
  char v9; // cl
  int v10; // eax
  char v11; // dh
  int v12; // eax

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  if ( sub_14C60(a1, v1) )
  {
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
    if ( sub_14C90(a1, v1, 3328, 4608) && *(_WORD *)(*(_DWORD *)(a1 + 164) + 418) >= 0 )
    {
      v2 = sub_15790(a1);
      if ( v2 != -1 )
      {
        v3 = v2;
        if ( sub_15170(a1, v2) )
        {
          if ( sub_14E10(a1, v3) )
          {
            v4 = *(_BYTE *)(v1 + 64);
            if ( !v4 || v4 == 1 )
              *(_WORD *)(*(_DWORD *)(a1 + 164) + 8 * *(signed __int16 *)(*(_DWORD *)(v1 + 164) + 56) + 518) = 0;
            goto LABEL_36;
          }
        }
      }
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
      v5 = *(_BYTE *)(v1 + 64);
      if ( !v5 || v5 == 1 )
      {
        v6 = *(_DWORD *)(a1 + 164);
        v7 = *(_BYTE *)(v6 + 1117);
        if ( v7 < 3 || v7 >= 5 )
        {
          v8 = *(_DWORD *)(a1 + 164);
          v9 = *(_BYTE *)(v8 + 1117);
          if ( v9 < 5 || v9 >= 20 )
          {
            v10 = *(_DWORD *)(a1 + 164);
            v11 = *(_BYTE *)(v10 + 1117);
            if ( v11 < 20 )
            {
              if ( v11 )
              {
                if ( *(_BYTE *)(v10 + 1116) == 1 )
                  *(_WORD *)(a1 + 32) -= 512;
                else
                  *(_BYTE *)(a1 + 33) += 2;
                *(_BYTE *)(a1 + 33) &= 7u;
                *(_WORD *)(a1 + 130) = 3
                                     * *(signed __int16 *)(a1 + 132)
                                     * *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 582)
                                     / 255;
                *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
              }
              else
              {
                *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
                if ( (signed int)(*(unsigned __int16 *)(a1 + 20) % 0xFFu) >= 127 )
                {
                  *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1116) = 2;
                  *(_BYTE *)(a1 + 29) += 2;
                }
                else
                {
                  *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1116) = 1;
                  *(_WORD *)(a1 + 28) -= 512;
                }
                *(_BYTE *)(a1 + 29) &= 7u;
              }
              ++*(_BYTE *)(*(_DWORD *)(a1 + 164) + 1117);
            }
            else
            {
              *(_BYTE *)(v10 + 1117) = 0;
            }
          }
          else
          {
            *(_BYTE *)(v8 + 1117) = v9 + 1;
          }
        }
        else
        {
          *(_BYTE *)(v6 + 1117) = v7 + 1;
        }
      }
      v12 = *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v1 + 80) + 512);
      if ( *(signed __int16 *)(a1 + 80) != *(signed __int16 *)(v1 + 80) + 512 )
      {
        if ( *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v1 + 80) + 512) <= 0 )
          LOWORD(v12) = -1;
        else
          LOWORD(v12) = 1;
      }
      *(_WORD *)(a1 + 80) += v12 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
    }
    sub_16580(a1);
    return 1;
  }
LABEL_36:
  sub_16580(a1);
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013B00) --------------------------------------------------------
signed int __cdecl sub_13B00(int a1)
{
  _WORD *v1; // esi
  __int16 v2; // bx
  unsigned int v3; // eax
  int v4; // edi
  int v5; // esi
  unsigned int v7; // eax
  int v8; // edi
  int v9; // esi
  int v11; // [esp+4h] [ebp-Ch]
  __int16 i; // [esp+8h] [ebp-8h]
  int v13; // [esp+Ch] [ebp-4h]

  v1 = (_WORD *)dword_EA3E4[0];
  if ( !*(_WORD *)(*(_DWORD *)(a1 + 164) + 58) && sub_146C0(a1, 2u) && sub_15730(a1, 2u) )
  {
    v1[13] = *(_WORD *)(a1 + 26);
    v13 = (*(signed __int16 *)(a1 + 76)
         - (__CFSHL__(*(signed __int16 *)(a1 + 76) >> 31, 14)
          + (*(signed __int16 *)(a1 + 76) >> 31 << 14))) >> 14;
    v2 = 0;
    v11 = (*(signed __int16 *)(a1 + 78)
         - (__CFSHL__(*(signed __int16 *)(a1 + 78) >> 31, 14)
          + (*(signed __int16 *)(a1 + 78) >> 31 << 14))) >> 14;
    while ( v2 < 4 )
    {
      for ( i = 0; i < 4; ++i )
      {
        v1[38] = (((_BYTE)v13 + (_BYTE)i) & 3) << 14;
        v1[39] = (((_BYTE)v2 + (_BYTE)v11) & 3) << 14;
        v3 = sub_14B10((int)v1, 2u);
        if ( !v3 || (unsigned int)sub_583B0((_WORD *)(v3 + 76), v1 + 38) > 0x3000 )
        {
          v4 = a1 + 154;
          v5 = (int)(v1 + 38);
          *(_DWORD *)v4 = *(_DWORD *)v5;
          *(_WORD *)(v4 + 4) = *(_WORD *)(v5 + 4);
          return 1;
        }
        v7 = sub_14B10((int)v1, 2u);
        if ( !v7 || (unsigned int)sub_583B0((_WORD *)(v7 + 76), v1 + 38) > 0x3000 )
        {
          v8 = a1 + 154;
          v9 = (int)(v1 + 38);
          *(_DWORD *)v8 = *(_DWORD *)v9;
          *(_WORD *)(v8 + 4) = *(_WORD *)(v9 + 4);
          return 1;
        }
      }
      ++v2;
    }
  }
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013C50) --------------------------------------------------------
signed int __cdecl sub_13C50(int a1)
{
  unsigned int v1; // ebx

  v1 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)];
  if ( v1 <= dword_EA3E4[0] || *(_BYTE *)(v1 + 69) != 4 || *(_WORD *)(v1 + 48) || !sub_155E0(a1) )
    return 0;
  *(_WORD *)(a1 + 150) = (signed int)(v1 - (dword_D41A0 + 28302)) / 168;
  *(_WORD *)(a1 + 152) = sub_14C40(v1);
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013CE0) --------------------------------------------------------
unsigned int __cdecl sub_13CE0(int a1)
{
  unsigned int result; // eax
  unsigned int v2; // eax
  int v3; // eax
  int v4; // eax

  result = sub_146C0(a1, 1u);
  if ( result )
  {
    v2 = sub_146C0(a1, 2u);
    if ( v2 )
    {
      if ( *(_DWORD *)(a1 + 140) <= *(_DWORD *)(v2 + 140) )
      {
        v3 = sub_148E0(a1);
        if ( v3 )
        {
          *(_WORD *)(a1 + 150) = (v3 - (dword_D41A0 + 28302)) / 168;
          *(_WORD *)(a1 + 152) = sub_14C40(v3);
          return 1;
        }
      }
    }
    else
    {
      v4 = sub_148E0(a1);
      if ( v4 )
      {
        *(_WORD *)(a1 + 150) = (v4 - (dword_D41A0 + 28302)) / 168;
        *(_WORD *)(a1 + 152) = sub_14C40(v4);
        return 1;
      }
    }
    result = 0;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00013DC0) --------------------------------------------------------
signed int __cdecl sub_13DC0(int a1)
{
  unsigned int v1; // ecx
  int v2; // ST00_4

  if ( *(_DWORD *)(a1 + 4) / 2 <= *(_DWORD *)(a1 + 8) )
    return 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)];
  if ( v1 <= dword_EA3E4[0] )
    return 0;
  v2 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)];
  *(_WORD *)(a1 + 150) = (signed int)(v1 - (dword_D41A0 + 28302)) / 168;
  *(_WORD *)(a1 + 152) = sub_14C40(v2);
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013E40) --------------------------------------------------------
signed int __cdecl sub_13E40(int a1)
{
  int v1; // edi
  unsigned int i; // ebx
  int v3; // ecx
  unsigned int v4; // eax
  int v5; // ebx
  signed int v6; // ebx
  unsigned int v8; // [esp+8h] [ebp-8h]

  v8 = -1;
  if ( !sub_164B0(a1) || !*(_WORD *)(*(_DWORD *)(a1 + 164) + 58) && sub_146C0(a1, 2u) )
    return 0;
  v1 = 0;
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) && *(_BYTE *)(i + 64) == 2 )
    {
      if ( (v3 = dword_EA3E4[*(signed __int16 *)(i + 26)],
            50000 - *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 578) * (*(_DWORD *)(v3 + 140) / 10) / 255 < *(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 8 * *(signed __int16 *)(*(_DWORD *)(v3 + 164) + 56) + 516))
        && (unsigned int)sub_584D0((_WORD *)(v3 + 76), (_WORD *)(i + 76)) > 0x3840000
        && !sub_106C0(dword_EA3E4[*(signed __int16 *)(i + 26)], i)
        || *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)] + 144) > 640
                                                                                             * (255
                                                                                              - *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 578))
                                                                                             + *(_DWORD *)(i + 144) )
      {
        v4 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
        if ( v4 < v8 )
        {
          v1 = i;
          v8 = v4;
        }
      }
    }
  }
  if ( !v1 )
    return 0;
  v5 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
  if ( sub_584D0((_WORD *)(v1 + 76), (_WORD *)(a1 + 76)) >= (unsigned int)(v5 * v5) )
    return 0;
  v6 = 1;
  *(_WORD *)(a1 + 150) = (v1 - (dword_D41A0 + 28302)) / 168;
  *(_WORD *)(a1 + 152) = sub_14C40(v1);
  return v6;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00014030) --------------------------------------------------------
signed int __cdecl sub_14030(int a1)
{
  int v1; // edi
  unsigned int i; // ebx
  char v3; // ah
  int v4; // ecx
  int v5; // eax
  unsigned int v7; // eax
  int v8; // ebx
  unsigned int v9; // [esp+0h] [ebp-14h]

  v9 = -1;
  if ( !sub_15E60(a1) || !*(_WORD *)(*(_DWORD *)(a1 + 164) + 58) && sub_146C0(a1, 2u) )
    return 0;
  v1 = 0;
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) )
    {
      v3 = *(_BYTE *)(i + 64);
      if ( (!v3 || v3 == 1) && !sub_15760(i, 0xBu) )
      {
        v4 = *(_DWORD *)(i + 164);
        v5 = *(_DWORD *)(a1 + 164) + 8 * *(signed __int16 *)(v4 + 56);
        if ( *(_WORD *)(v5 + 518) == 1 )
        {
          *(_WORD *)(a1 + 150) = (signed int)(i - (dword_D41A0 + 28302)) / 168;
          *(_WORD *)(a1 + 152) = sub_14C40(i);
          return 1;
        }
        if ( 50000 - *(_DWORD *)(i + 140) / 10 * *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 578) / 255 <= *(unsigned __int16 *)(v5 + 516)
          || !*(_WORD *)(v4 + 58)
          && sub_146C0(i, 2u)
          && *(_DWORD *)(i + 144) + 32 * (255 - *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 578)) < *(_DWORD *)(a1 + 144) )
        {
          v7 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
          if ( v7 < v9 )
          {
            v1 = i;
            v9 = v7;
          }
        }
      }
    }
  }
  if ( !v1 )
    return 0;
  v8 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28) + 10;
  if ( sub_584D0((_WORD *)(v1 + 76), (_WORD *)(a1 + 76)) >= (unsigned int)(v8 * v8) )
    return 0;
  *(_WORD *)(a1 + 150) = (v1 - (dword_D41A0 + 28302)) / 168;
  *(_WORD *)(a1 + 152) = sub_14C40(v1);
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00014250) --------------------------------------------------------
signed int __cdecl sub_14250(int a1)
{
  int v1; // esi
  unsigned int i; // ebx
  int v3; // edx
  unsigned int v4; // eax
  int v5; // ebx
  int v7; // [esp+Ch] [ebp-Ch]
  int v8; // [esp+10h] [ebp-8h]
  unsigned int v9; // [esp+14h] [ebp-4h]

  v9 = -1;
  if ( !sub_15E60(a1) )
    return 0;
  v1 = 0;
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) && *(_BYTE *)(i + 64) == 3 )
    {
      v3 = dword_EA3E4[*(signed __int16 *)(i + 26)];
      v8 = *(_DWORD *)(v3 + 164);
      v7 = *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 578);
      if ( 50000 - *(_DWORD *)(v3 + 140) / 10 * v7 / 255 < *(unsigned __int16 *)(*(_DWORD *)(a1 + 164)
                                                                               + 8 * *(signed __int16 *)(v8 + 56)
                                                                               + 516)
        && 10 * (275 - v7) < *(_DWORD *)(i + 144)
        && !sub_106C0(i, dword_EA3E4[*(unsigned __int16 *)(v8 + 58)]) )
      {
        v4 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
        if ( v4 < v9 )
        {
          v1 = i;
          v9 = v4;
        }
      }
    }
  }
  if ( !v1 )
    return 0;
  v5 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
  if ( sub_584D0((_WORD *)(v1 + 76), (_WORD *)(a1 + 76)) >= (unsigned int)(v5 * v5) )
    return 0;
  *(_WORD *)(a1 + 150) = (v1 - (dword_D41A0 + 28302)) / 168;
  *(_WORD *)(a1 + 152) = sub_14C40(v1);
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00014530) --------------------------------------------------------
signed int __cdecl sub_14530(int a1)
{
  int v1; // esi
  signed int i; // edi
  unsigned int j; // ebx
  unsigned int v4; // eax
  unsigned int v6; // [esp+0h] [ebp-8h]
  int v7; // [esp+4h] [ebp-4h]

  v1 = 0;
  v6 = -1;
  if ( !sub_15E60(a1) )
    return 0;
  v7 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)];
  if ( v7 == dword_EA3E4[0] )
    v7 = a1;
  for ( i = 0; i < 29; ++i )
  {
    for ( j = *(_DWORD *)(dword_D41A4 + 4 * i + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
    {
      if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26) && *(_DWORD *)(j + 144) > 0 )
      {
        v4 = sub_584D0((_WORD *)(v7 + 76), (_WORD *)(j + 76));
        if ( v4 < v6 )
        {
          v1 = j;
          v6 = v4;
        }
      }
    }
  }
  if ( !v1 )
    return 0;
  *(_WORD *)(a1 + 150) = (v1 - (dword_D41A0 + 28302)) / 168;
  *(_WORD *)(a1 + 152) = sub_14C40(v1);
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00014630) --------------------------------------------------------
signed int __cdecl sub_14630(int a1)
{
  unsigned int v1; // ecx

  if ( *(_DWORD *)(a1 + 8) >= *(_DWORD *)(a1 + 4)
    || (v1 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)], v1 <= dword_EA3E4[0]) )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 12;
  }
  else
  {
    *(_WORD *)(a1 + 150) = (signed int)(v1 - (dword_D41A0 + 28302)) / 168;
    *(_WORD *)(a1 + 152) = sub_14C40(v1);
    *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 11;
  }
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000146C0) --------------------------------------------------------
unsigned int __cdecl sub_146C0(int a1, unsigned __int8 a2)
{
  unsigned int result; // eax

  result = dword_EA3E4[*(signed __int16 *)(*(_DWORD *)(a1 + 164) + 2 * a2 + 819)];
  if ( result <= dword_EA3E4[0] )
    result = 0;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000146F0) --------------------------------------------------------
signed int __cdecl sub_146F0(int a1)
{
  char v1; // ah
  signed __int16 *v2; // edx
  __int16 v3; // ST10_2
  int v4; // ST0C_4
  int v5; // ST08_4
  __int16 v6; // ax
  unsigned __int16 v7; // ax
  int v8; // edx
  __int16 v9; // cx
  _WORD *v10; // eax
  signed __int16 v11; // dx
  signed __int16 v12; // ax
  __int16 v13; // ax
  unsigned __int16 v14; // si
  __int64 v15; // rax
  int v16; // eax
  int v17; // edx
  __int16 v18; // si
  __int16 v19; // si
  unsigned int v20; // eax
  unsigned __int16 v21; // si
  unsigned __int16 v22; // dx

  v1 = *(_BYTE *)(a1 + 13);
  if ( v1 & 8 )
  {
    *(_BYTE *)(a1 + 13) = v1 & 0xF7;
  }
  else
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v2 = *(signed __int16 **)(a1 + 160);
    v3 = v2[7];
    v4 = v2[5];
    v5 = v2[6];
    v6 = sub_10C40(&word_EB398);
    sub_580E0((int)&word_EB398, v6, v5, v4, v3);
    sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
    v7 = *(_WORD *)(a1 + 28);
    HIBYTE(v7) += 2;
    sub_57FA0(&word_EB398, v7, 0, *(_WORD *)(*(_DWORD *)(a1 + 164) + 16));
    v8 = *(_DWORD *)(a1 + 164);
    v9 = *(_WORD *)(v8 + 16);
    v10 = (_WORD *)(v8 + 16);
    if ( v9 )
    {
      if ( v9 <= 0 )
        v11 = -1;
      else
        v11 = 1;
    }
    else
    {
      v11 = 0;
    }
    *v10 -= 4 * v11;
    sub_57CF0(a1, (int)&word_EB398);
    v12 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) - *(_WORD *)(a1 + 130);
    if ( *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 12) != *(signed __int16 *)(a1 + 130) )
    {
      if ( *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 12) - *(signed __int16 *)(a1 + 130) <= 0 )
        v12 = -1;
      else
        v12 = 1;
    }
    *(_WORD *)(a1 + 130) += 16 * v12;
    v13 = *(_WORD *)(a1 + 32);
    HIBYTE(v13) &= 7u;
    v14 = sub_582B0(*(_WORD *)(a1 + 28), v13);
    v15 = 255 - *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 582);
    v16 = v14
        / (signed int)(unsigned __int16)(((signed int)(v15 - (__CFSHL__(HIDWORD(v15), 4) + 16 * HIDWORD(v15))) >> 4) + 8);
    v17 = *(_DWORD *)(a1 + 160);
    v18 = v16;
    if ( (signed __int16)v16 <= *(_WORD *)(v17 + 2) )
    {
      if ( (signed __int16)v16 < *(_WORD *)(v17 + 4) )
        v18 = *(_WORD *)(v17 + 4);
    }
    else
    {
      v18 = *(_WORD *)(v17 + 2);
    }
    v19 = sub_582F0(*(unsigned __int16 *)(a1 + 28), *(_WORD *)(a1 + 32)) * v18;
    v20 = *(unsigned __int16 *)(a1 + 28);
    v21 = (v20 + v19) & 0x7FF;
    v22 = *(_WORD *)(a1 + 32);
    *(_WORD *)(a1 + 28) = v21;
    if ( (unsigned __int16)v20 < (unsigned int)v22 && v21 > v22
      || (v22 = *(_WORD *)(a1 + 32), v20 > v22) && v22 > *(_WORD *)(a1 + 28) )
    {
      *(_WORD *)(a1 + 28) = v22;
    }
  }
  return 1;
}
// EB398: using guessed type __int16 word_EB398;

//----- (000148E0) --------------------------------------------------------
unsigned int __cdecl sub_148E0(int a1)
{
  unsigned int v1; // edi
  unsigned int v2; // ebx
  int v3; // ST08_4
  int v4; // eax
  int v5; // edx
  char v6; // cl
  unsigned int v7; // eax
  unsigned int v8; // eax
  unsigned int i; // ebx
  unsigned int v10; // eax
  unsigned int v12; // [esp+8h] [ebp-14h]
  _WORD *v13; // [esp+Ch] [ebp-10h]
  int v14; // [esp+10h] [ebp-Ch]
  unsigned int v15; // [esp+14h] [ebp-8h]
  unsigned int v16; // [esp+18h] [ebp-4h]

  v1 = -1;
  v16 = 0;
  v2 = *(_DWORD *)(dword_D41A4 + 38523);
  v15 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)];
  while ( v2 > dword_EA3E4[0] )
  {
    if ( a1 == dword_EA3E4[*(unsigned __int16 *)(v2 + 148)] )
      goto LABEL_22;
    if ( *(_BYTE *)(v2 + 64) == 57 )
    {
      v3 = *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 580);
      if ( rand() % 255 < v3 )
        break;
    }
    v4 = *(unsigned __int16 *)(v2 + 148);
    v5 = dword_EA3E4[(unsigned __int16)v4];
    v13 = (_WORD *)(v2 + 76);
    v6 = *(_BYTE *)(v5 + 63);
    if ( v6 == 3 )
    {
      if ( v4 == *(signed __int16 *)(a1 + 26) )
        goto LABEL_22;
      if ( 50000 - *(_DWORD *)(v5 + 140) / 10 * *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 578) / 255 >= *(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 8 * *(signed __int16 *)(*(_DWORD *)(v5 + 164) + 56) + 516) )
      {
        v12 = sub_16FC0(v2, a1);
        if ( !v12 )
          goto LABEL_22;
        v8 = v15 <= dword_EA3E4[0] ? sub_14B10(v2, 2u) : sub_14BD0(v2, v15);
        v14 = v8;
        if ( *(_WORD *)(a1 + 26) != *(_WORD *)(v12 + 26)
          && (unsigned int)sub_584D0((_WORD *)(v2 + 76), (_WORD *)(v12 + 76)) <= 0x1900000 )
        {
          goto LABEL_22;
        }
        if ( v14 && sub_106C0(v2, v14) )
          goto LABEL_22;
        v7 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(v2 + 76));
      }
      else
      {
        v7 = sub_584D0((_WORD *)(v15 + 76), v13);
      }
    }
    else
    {
      if ( v6 == 3 )
        goto LABEL_22;
      v7 = sub_584D0((_WORD *)(a1 + 76), v13);
    }
    if ( v7 < v1 )
    {
      v16 = v2;
      v1 = v7;
    }
LABEL_22:
    v2 = *(_DWORD *)v2;
  }
  if ( !v16 )
  {
    for ( i = *(_DWORD *)(dword_D41A4 + 38491); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(_BYTE *)(i + 64) != 57 && *(unsigned __int16 *)(i + 148) != *(signed __int16 *)(a1 + 26) )
      {
        v10 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
        if ( v10 < v1 )
        {
          v16 = i;
          v1 = v10;
        }
      }
    }
  }
  return v16;
}
// 8C278: using guessed type int rand(void);
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00014B10) --------------------------------------------------------
unsigned int __cdecl sub_14B10(int a1, unsigned __int8 a2)
{
  unsigned int v2; // edi
  unsigned int v3; // esi
  unsigned int i; // ebx
  unsigned int v5; // eax
  unsigned int j; // ebx
  unsigned int v7; // eax

  v2 = -1;
  v3 = 0;
  if ( a2 < 2u )
  {
    if ( a2 )
      return v3;
  }
  else if ( a2 > 3u )
  {
    if ( a2 == -1 )
    {
      for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
      {
        if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) )
        {
          v5 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
          if ( v5 < v2 )
          {
            v3 = i;
            v2 = v5;
          }
        }
      }
    }
    return v3;
  }
  for ( j = *(_DWORD *)(dword_D41A4 + 38519); j > dword_EA3E4[0]; j = *(_DWORD *)j )
  {
    if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26) && *(char *)(j + 64) == a2 )
    {
      v7 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(j + 76));
      if ( v7 < v2 )
      {
        v3 = j;
        v2 = v7;
      }
    }
  }
  return v3;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00014BD0) --------------------------------------------------------
unsigned int __cdecl sub_14BD0(int a1, int a2)
{
  unsigned int v2; // edi
  unsigned int v3; // esi
  unsigned int v4; // ebx
  __int16 v6; // ax
  unsigned int v7; // eax

  v2 = -1;
  v3 = 0;
  v4 = *(_DWORD *)(dword_D41A4 + 38519);
  if ( v4 <= dword_EA3E4[0] )
    return 0;
  do
  {
    v6 = *(_WORD *)(v4 + 26);
    if ( v6 != *(_WORD *)(a1 + 26) && v6 != *(_WORD *)(a2 + 26) && *(_BYTE *)(v4 + 64) == 2 )
    {
      v7 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(v4 + 76));
      if ( v7 < v2 )
      {
        v3 = v4;
        v2 = v7;
      }
    }
    v4 = *(_DWORD *)v4;
  }
  while ( v4 > dword_EA3E4[0] );
  return v3;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00014C40) --------------------------------------------------------
__int16 __cdecl sub_14C40(int a1)
{
  return *(_WORD *)(a1 + 26) + *(char *)(a1 + 64) + (*(char *)(a1 + 63) << 7);
}

//----- (00014C60) --------------------------------------------------------
bool __cdecl sub_14C60(int a1, int a2)
{
  return sub_14C40(a2) == *(_WORD *)(a1 + 152);
}

//----- (00014C90) --------------------------------------------------------
signed int __cdecl sub_14C90(int a1, int a2, signed int a3, signed int a4)
{
  signed int v4; // eax
  signed int v6; // eax

  *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 0;
  if ( !a2 )
  {
    v4 = sub_58490((_WORD *)(a1 + 76), (_WORD *)(a1 + 154));
    if ( v4 > a3 )
    {
      if ( v4 > a4 && sub_15170(a1, 3u) )
      {
        if ( !sub_156F0(a1, 3u) )
          sub_14E10(a1, 3u);
      }
      else
      {
        *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = *(_WORD *)(a1 + 132);
        *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
      }
      return 0;
    }
LABEL_16:
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
    return 1;
  }
  v6 = sub_58490((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
  if ( v6 <= a3 )
    goto LABEL_16;
  if ( v6 > a4 && sub_15170(a1, 3u) )
  {
    if ( !sub_156F0(a1, 3u) )
      sub_14E10(a1, 3u);
  }
  else
  {
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = *(_WORD *)(a1 + 132);
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
  }
  return 0;
}

//----- (00014E10) --------------------------------------------------------
signed int __cdecl sub_14E10(int a1, unsigned __int8 a2)
{
  unsigned int v2; // eax
  signed int result; // eax
  int v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // edi
  int v7; // esi
  unsigned int v8; // esi
  unsigned int v9; // eax

  if ( !sub_15170(a1, a2) )
    return 0;
  *(_BYTE *)(a1 + 13) &= 0xFEu;
  if ( a2 > 0x16u )
    return 0;
  switch ( a2 )
  {
    case 0u:
    case 1u:
    case 7u:
    case 0x16u:
      v6 = sub_146C0(a1, a2);
      if ( !v6
        || *(_WORD *)(*(_DWORD *)(a1 + 164) + 418) < 0
        || (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32)) >= 0xAAu )
      {
        return 0;
      }
      *(_WORD *)(a1 + 30) = sub_58210((_WORD *)(a1 + 76), (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 76));
      ++*(_WORD *)(*(_DWORD *)(a1 + 164) + 418);
      v7 = *(_DWORD *)(a1 + 164);
      if ( *(_WORD *)(v7 + 418) >= 8 )
        *(_WORD *)(v7 + 418) = ((*(signed __int16 *)(v7 + 582)
                               - 255
                               - (__CFSHL__((*(signed __int16 *)(v7 + 582) - 255) >> 31, 3)
                                + 8 * ((*(signed __int16 *)(v7 + 582) - 255) >> 31))) >> 3)
                             - 1;
      if ( sub_5F660(a1, v6, 0) != 1 )
        return 0;
      *(_WORD *)(2 * a2 + *(_DWORD *)(a1 + 164) + 871) = word_D3F4C[a2];
      return 1;
    case 2u:
      v2 = sub_146C0(a1, a2);
      if ( !v2 )
        return 0;
      if ( *(_WORD *)(*(_DWORD *)(a1 + 164) + 58) )
      {
        if ( sub_5F660(a1, v2, 0) != 1 )
          return 0;
        *(_WORD *)(*(_DWORD *)(a1 + 164) + 2 * a2 + 871) = word_D3F4C[a2];
        result = 1;
      }
      else
      {
        v4 = sub_4A190(a1 + 154, 3, 2);
        if ( v4 )
        {
          *(_WORD *)(v4 + 26) = *(_WORD *)(a1 + 26);
          *(_WORD *)(*(_DWORD *)(a1 + 164) + 58) = (v4 - (dword_D41A0 + 28302)) / 168;
        }
        result = 1;
      }
      break;
    case 3u:
      v5 = sub_146C0(a1, a2);
      if ( !v5 || sub_5F660(a1, v5, 0) != 1 )
        return 0;
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 2 * a2 + 871) = word_D3F4C[a2];
      return 1;
    case 4u:
    case 9u:
    case 0xDu:
    case 0xEu:
    case 0x12u:
    case 0x13u:
    case 0x15u:
      v8 = sub_146C0(a1, a2);
      if ( !v8 )
        return 0;
      if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32)) >= 0xE3u )
        return 0;
      *(_WORD *)(a1 + 30) = sub_58210((_WORD *)(a1 + 76), (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 76));
      if ( sub_5F660(a1, v8, 0) != 1 )
        return 0;
      *(_WORD *)(2 * a2 + *(_DWORD *)(a1 + 164) + 871) = word_D3F4C[a2];
      return 1;
    case 5u:
    case 6u:
    case 8u:
    case 0xAu:
    case 0xBu:
    case 0xCu:
    case 0x10u:
    case 0x11u:
    case 0x14u:
      v9 = sub_146C0(a1, a2);
      if ( !v9 || sub_5F660(a1, v9, 0) != 1 )
        return 0;
      *(_WORD *)(2 * a2 + *(_DWORD *)(a1 + 164) + 871) = word_D3F4C[a2];
      return 1;
    case 0xFu:
      return 0;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00015170) --------------------------------------------------------
unsigned int __cdecl sub_15170(int a1, unsigned __int8 a2)
{
  unsigned int v2; // eax
  unsigned int v3; // esi
  int v4; // eax
  int v5; // edx
  unsigned int v7; // eax
  unsigned int v8; // esi
  int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // esi
  int v12; // eax
  int v13; // eax
  int v14; // edi
  unsigned int v15; // eax
  unsigned int v16; // esi
  int v17; // eax
  int v18; // eax
  int v19; // edx
  __int64 v20; // rax
  unsigned int v21; // eax
  unsigned int v22; // esi
  int v23; // eax
  int v24; // eax
  int v25; // edi
  unsigned int v26; // eax
  unsigned int v27; // esi
  int v28; // eax
  int v29; // edx

  if ( a2 > 0x16u )
  {
LABEL_43:
    if ( a2 < 0x1Au )
    {
      v26 = sub_146C0(a1, a2);
      v27 = v26;
      if ( v26 )
      {
        v28 = 80 * a2 + 26 * *(char *)(v26 + 70);
        if ( *(_DWORD *)(a1 + 140) >= *(int *)((char *)&dword_DA822 + v28) )
        {
          v29 = *(_DWORD *)(a1 + 144);
          if ( v29 >= *(int *)((char *)&dword_DA81E + v28)
            && !*(_WORD *)(*(_DWORD *)(a1 + 164) + 2 * a2 + 871)
            && v29 >= *(_DWORD *)(v27 + 140) )
          {
            return v27;
          }
        }
      }
    }
  }
  else
  {
    switch ( a2 )
    {
      case 0u:
      case 7u:
      case 0xDu:
      case 0xEu:
      case 0x16u:
        v21 = sub_146C0(a1, a2);
        v22 = v21;
        if ( !v21 )
          return 0;
        v23 = 80 * a2 + 26 * *(char *)(v21 + 70);
        if ( *(_DWORD *)(a1 + 140) < *(int *)((char *)&dword_DA822 + v23) )
          return 0;
        if ( *(_DWORD *)(a1 + 144) < *(int *)((char *)&dword_DA81E + v23) )
          return 0;
        v24 = *(_DWORD *)(a1 + 164);
        if ( *(_WORD *)(v24 + 2 * a2 + 871) )
          return 0;
        if ( *(_DWORD *)(a1 + 144) < *(_DWORD *)(v22 + 140) )
          return 0;
        v25 = ((((255
                - *(signed __int16 *)(v24 + 580)
                - (__CFSHL__((255 - *(signed __int16 *)(v24 + 580)) >> 31, 2)
                 + 4 * ((255 - *(signed __int16 *)(v24 + 580)) >> 31))) >> 2)
              + 20) << 11)
            / 360;
        if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32)) >= v25 )
          return 0;
        return v22;
      case 1u:
      case 9u:
      case 0x10u:
      case 0x12u:
      case 0x13u:
      case 0x15u:
        v10 = sub_146C0(a1, a2);
        v11 = v10;
        if ( !v10 )
          return 0;
        v12 = 26 * *(char *)(v10 + 70) + 80 * a2;
        if ( *(_DWORD *)(a1 + 140) < *(int *)((char *)&dword_DA822 + v12) )
          return 0;
        if ( *(_DWORD *)(a1 + 144) < *(int *)((char *)&dword_DA81E + v12) )
          return 0;
        if ( *(_WORD *)(v11 + 46) )
          return 0;
        v13 = *(_DWORD *)(a1 + 164);
        if ( *(_WORD *)(v13 + 2 * a2 + 871) )
          return 0;
        if ( *(_DWORD *)(a1 + 144) < *(_DWORD *)(v11 + 140) )
          return 0;
        v14 = ((((255
                - *(signed __int16 *)(v13 + 580)
                - (__CFSHL__((255 - *(signed __int16 *)(v13 + 580)) >> 31, 2)
                 + 4 * ((255 - *(signed __int16 *)(v13 + 580)) >> 31))) >> 2)
              + 20) << 11)
            / 360;
        if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32)) >= v14 )
          return 0;
        return v11;
      case 2u:
        v15 = sub_146C0(a1, a2);
        v16 = v15;
        if ( !v15 )
          return 0;
        v17 = 80 * a2 + 26 * *(char *)(v15 + 70);
        if ( *(_DWORD *)(a1 + 140) < *(int *)((char *)&dword_DA822 + v17)
          || *(_DWORD *)(a1 + 144) < *(int *)((char *)&dword_DA81E + v17) )
        {
          return 0;
        }
        v18 = *(_DWORD *)(a1 + 164);
        v19 = v18 + 2 * a2;
        if ( *(_WORD *)(v18 + 58) )
        {
          if ( !*(_WORD *)(v16 + 46) && !*(_WORD *)(v19 + 871) )
          {
            if ( sub_11A10((_WORD *)dword_EA3E4[*(unsigned __int16 *)(v18 + 58)]) )
            {
              if ( *(_DWORD *)(a1 + 144) >= *(_DWORD *)(v16 + 140) )
              {
                v20 = 255 - *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 580);
                if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32)) < ((((signed int)(v20 - (__CFSHL__(HIDWORD(v20), 2) + 4 * HIDWORD(v20))) >> 2)
                                                                                             + 20) << 11)
                                                                                           / 360 )
                  return v16;
              }
            }
          }
        }
        else if ( !*(_WORD *)(v19 + 871) && *(_DWORD *)(a1 + 144) >= *(_DWORD *)(v16 + 140) )
        {
          return v16;
        }
        break;
      case 3u:
        v2 = sub_146C0(a1, a2);
        v3 = v2;
        if ( !v2 )
          return 0;
        v4 = 80 * a2 + 26 * *(char *)(v2 + 70);
        if ( *(_DWORD *)(a1 + 140) < *(int *)((char *)&dword_DA822 + v4) )
          return 0;
        v5 = *(_DWORD *)(a1 + 144);
        if ( v5 < *(int *)((char *)&dword_DA81E + v4) || v5 < *(_DWORD *)(v3 + 140) )
          return 0;
        return v3;
      case 4u:
      case 6u:
      case 8u:
      case 0xBu:
        v7 = sub_146C0(a1, a2);
        v8 = v7;
        if ( !v7 )
          return 0;
        v9 = 26 * *(char *)(v7 + 70) + 80 * a2;
        if ( *(_DWORD *)(a1 + 140) < *(int *)((char *)&dword_DA822 + v9)
          || *(_DWORD *)(a1 + 144) < *(int *)((char *)&dword_DA81E + v9)
          || *(_WORD *)(v8 + 46)
          || *(_WORD *)(*(_DWORD *)(a1 + 164) + 2 * a2 + 871)
          || *(_DWORD *)(a1 + 144) < *(_DWORD *)(v8 + 140) )
        {
          return 0;
        }
        return v8;
      case 5u:
      case 0xAu:
      case 0xCu:
      case 0xFu:
      case 0x11u:
      case 0x14u:
        goto LABEL_43;
    }
  }
  return 0;
}
// DA81E: using guessed type int dword_DA81E;
// DA822: using guessed type int dword_DA822;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000155E0) --------------------------------------------------------
signed int __cdecl sub_155E0(int a1)
{
  unsigned int v1; // ebx
  int v2; // eax
  __int64 v4; // rax

  v1 = sub_146C0(a1, 2u);
  if ( v1 )
  {
    v2 = *(_DWORD *)(a1 + 164);
    if ( *(_WORD *)(v2 + 58) )
    {
      if ( !*(_WORD *)(v1 + 46) && !*(_WORD *)(v2 + 875) )
      {
        if ( sub_11A10((_WORD *)dword_EA3E4[*(unsigned __int16 *)(v2 + 58)]) )
        {
          if ( *(_DWORD *)(a1 + 140) >= *(_DWORD *)(v1 + 140) )
          {
            v4 = 255 - *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 580);
            if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32)) < ((((signed int)(v4 - (__CFSHL__(HIDWORD(v4), 2) + 4 * HIDWORD(v4))) >> 2)
                                                                                         + 20) << 11)
                                                                                       / 360 )
              return 1;
          }
        }
      }
    }
    else if ( !*(_WORD *)(v2 + 875) && *(_DWORD *)(a1 + 140) >= *(_DWORD *)(v1 + 140) )
    {
      return 1;
    }
  }
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000156F0) --------------------------------------------------------
bool __cdecl sub_156F0(int a1, unsigned __int8 a2)
{
  unsigned int v2; // eax
  bool result; // eax

  result = 0;
  if ( a2 < 0x1Au )
  {
    v2 = sub_146C0(a1, a2);
    if ( v2 )
    {
      if ( *(_WORD *)(v2 + 46) > 0 )
        result = 1;
    }
  }
  return result;
}

//----- (00015730) --------------------------------------------------------
bool __cdecl sub_15730(int a1, unsigned __int8 a2)
{
  return *(_DWORD *)(a1 + 140) >= *(_DWORD *)(sub_146C0(a1, a2) + 140);
}

//----- (00015760) --------------------------------------------------------
unsigned int __cdecl sub_15760(int a1, unsigned __int8 a2)
{
  unsigned int result; // eax

  result = sub_146C0(a1, a2);
  if ( !result || *(_WORD *)(result + 46) <= 0 )
    result = 0;
  return result;
}

//----- (00015790) --------------------------------------------------------
char __cdecl sub_15790(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // eax
  int v4; // ecx
  int v5; // edi
  int i; // edi
  char *j; // esi
  int k; // edi
  char v10; // dl
  int v11; // edi
  int v12; // [esp+0h] [ebp-4h]

  v12 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v1 = (*(_DWORD *)(a1 + 140) - (__CFSHL__(*(_DWORD *)(a1 + 140) >> 31, 2) + 4 * (*(_DWORD *)(a1 + 140) >> 31))) >> 2;
  if ( v1 <= *(_DWORD *)(a1 + 144) )
  {
    v2 = *(_DWORD *)(a1 + 164);
    if ( *(_WORD *)(v2 + 420) )
    {
      v3 = v1 + 6000;
      v4 = *(_DWORD *)(a1 + 140);
      if ( v3 >= v4 )
        v3 = v4 / 2;
      if ( v3 <= *(_DWORD *)(a1 + 144) )
        *(_WORD *)(v2 + 420) = 0;
    }
  }
  else
  {
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 420) = 1;
  }
  if ( !*(_WORD *)(*(_DWORD *)(a1 + 164) + 420) )
  {
    if ( sub_15760(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)], 8u) )
    {
      v5 = *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 580);
      if ( rand() % 255 < v5 )
      {
        for ( i = *(char *)(*(_DWORD *)(a1 + 164) + 1060); i >= 0; --i )
        {
          if ( (signed __int16)sub_15F20(a1, i, 7) == 7 )
            return 7;
        }
      }
    }
    for ( j = (char *)&unk_D3F80; ; ++j )
    {
      v11 = *j;
      if ( v11 == -1 )
        break;
      for ( k = *(char *)(v11 + *(_DWORD *)(a1 + 164) + 1053); k >= 0; --k )
      {
        if ( (signed __int16)sub_15F20(a1, k, *j) == *j )
        {
          if ( *j == 19 )
          {
            v10 = *(_BYTE *)(v12 + 64);
            if ( !v10 || v10 == 1 )
              return *j;
          }
          if ( *j != 19 )
            return *j;
        }
      }
    }
  }
  return -1;
}
// 8C278: using guessed type int rand(void);
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00015910) --------------------------------------------------------
char __cdecl sub_15910(_DWORD *a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // eax
  int v4; // ecx
  unsigned __int8 *i; // esi
  signed __int16 j; // di
  __int16 v7; // ax
  int v8; // eax

  v1 = (a1[35] - (__CFSHL__(a1[35] >> 31, 2) + 4 * (a1[35] >> 31))) >> 2;
  if ( v1 <= a1[36] )
  {
    v2 = a1[41];
    if ( *(_WORD *)(v2 + 420) )
    {
      v3 = v1 + 6000;
      v4 = a1[35];
      if ( v3 >= v4 )
        v3 = v4 / 2;
      if ( v3 <= a1[36] )
        *(_WORD *)(v2 + 420) = 0;
    }
  }
  else
  {
    *(_WORD *)(a1[41] + 420) = 1;
  }
  if ( !*(_WORD *)(a1[41] + 420) )
  {
    for ( i = (unsigned __int8 *)&unk_D3F89; ; ++i )
    {
      v8 = *i;
      if ( v8 == -1 )
        break;
      for ( j = *(char *)(a1[41] + v8 + 1053); j >= 0; --j )
      {
        v7 = sub_15F20((int)a1, j, *i);
        if ( v7 == *i )
          return v7;
      }
    }
  }
  LOBYTE(v7) = -1;
  return v7;
}

//----- (000159E0) --------------------------------------------------------
void sub_159E0()
{
  unsigned int v0; // edi
  unsigned int v1; // esi
  unsigned int v2; // ecx
  unsigned __int8 v3; // al
  int v4; // ebx
  unsigned __int8 v5; // al
  int v6; // ebx
  unsigned __int8 v7; // al
  int v8; // edx
  int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // [esp+4h] [ebp-8h]

  v0 = *(_DWORD *)(dword_D41A4 + 38531);
  if ( v0 > dword_EA3E4[0] )
  {
    while ( 1 )
    {
      if ( *(_BYTE *)(v0 + 13) & 0x20 )
        goto LABEL_48;
      v1 = dword_EA3E4[*(signed __int16 *)(v0 + 26)];
      if ( v1 <= dword_EA3E4[0] )
        goto LABEL_48;
      if ( *(_BYTE *)(v1 + 63) != 3 )
        goto LABEL_48;
      v2 = dword_EA3E4[*(unsigned __int16 *)(v0 + 150)];
      if ( v2 <= dword_EA3E4[0] )
        goto LABEL_48;
      *(_BYTE *)(v0 + 13) |= 0x20u;
      v3 = *(_BYTE *)(v2 + 63);
      if ( v3 < 3u )
        goto LABEL_48;
      if ( v3 <= 3u )
        break;
      if ( v3 != 10 )
        goto LABEL_48;
      if ( *(_BYTE *)(v0 + 64) != 1 )
        goto LABEL_48;
      if ( *(_BYTE *)(v2 + 64) != 39 )
        goto LABEL_48;
      v10 = dword_EA3E4[*(unsigned __int16 *)(v2 + 148)];
      v11 = v10;
      if ( v10 <= dword_EA3E4[0] || *(_BYTE *)(v10 + 63) != 3 )
        goto LABEL_48;
      v6 = ((*(_DWORD *)(v2 + 144) - (__CFSHL__(*(_DWORD *)(v2 + 144) >> 31, 2) + 4 * (*(_DWORD *)(v2 + 144) >> 31))) >> 2)
         + *(unsigned __int16 *)(8 * *(signed __int16 *)(*(_DWORD *)(v1 + 164) + 56) + *(_DWORD *)(v10 + 164) + 516);
      if ( v6 < 0 )
        v6 = 0;
      if ( v6 > 0xFFFF )
        LOWORD(v6) = -1;
      v9 = *(signed __int16 *)(*(_DWORD *)(v1 + 164) + 56);
      v8 = *(_DWORD *)(v11 + 164);
LABEL_47:
      *(_WORD *)(v8 + 8 * v9 + 516) = v6;
LABEL_48:
      v0 = *(_DWORD *)v0;
      if ( v0 <= dword_EA3E4[0] )
        return;
    }
    if ( *(_BYTE *)(v2 + 64) == 2 )
    {
      v4 = *(unsigned __int16 *)(*(_DWORD *)(dword_EA3E4[*(signed __int16 *)(v2 + 26)] + 164)
                               + 8 * *(signed __int16 *)(*(_DWORD *)(v1 + 164) + 56)
                               + 516);
      v5 = *(_BYTE *)(v0 + 64);
      if ( v5 < 0xAu )
      {
        if ( v5 >= 3u && v5 <= 4u )
          goto LABEL_17;
LABEL_18:
        v4 += 1000;
      }
      else if ( v5 > 0xAu )
      {
        if ( v5 != 11 )
          goto LABEL_18;
LABEL_17:
        v4 += 5000;
      }
      if ( v4 < 0 )
        v4 = 0;
      if ( v4 > 0xFFFF )
        v4 = 0xFFFF;
      *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(signed __int16 *)(v2 + 26)] + 164)
               + 8 * *(signed __int16 *)(*(_DWORD *)(v1 + 164) + 56)
               + 516) = v4;
      if ( v4 > 50000 - *(_DWORD *)(v1 + 140) / 10 * *(signed __int16 *)(*(_DWORD *)(v2 + 164) + 578) / 255 )
        *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(signed __int16 *)(v2 + 26)] + 164)
                 + 8 * *(signed __int16 *)(*(_DWORD *)(v1 + 164) + 56)
                 + 518) = 1;
      goto LABEL_48;
    }
    v6 = *(unsigned __int16 *)(*(_DWORD *)(dword_EA3E4[*(signed __int16 *)(v2 + 26)] + 164)
                             + 8 * *(signed __int16 *)(*(_DWORD *)(v1 + 164) + 56)
                             + 516);
    v7 = *(_BYTE *)(v0 + 64);
    if ( v7 < 0xAu )
    {
      if ( v7 < 3u || v7 > 4u )
        goto LABEL_32;
    }
    else
    {
      if ( v7 <= 0xAu )
      {
LABEL_33:
        if ( v6 < 0 )
          v6 = 0;
        if ( v6 > 0xFFFF )
          LOWORD(v6) = -1;
        v8 = *(_DWORD *)(dword_EA3E4[*(signed __int16 *)(v2 + 26)] + 164);
        v9 = *(signed __int16 *)(*(_DWORD *)(v1 + 164) + 56);
        goto LABEL_47;
      }
      if ( v7 != 11 )
      {
LABEL_32:
        v6 += 500;
        goto LABEL_33;
      }
    }
    v6 += 3000;
    goto LABEL_33;
  }
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00015CB0) --------------------------------------------------------
unsigned int __usercall sub_15CB0@<eax>(unsigned int a1@<edi>, int a2)
{
  unsigned int v2; // esi
  unsigned int i; // ebx
  unsigned int v4; // eax
  unsigned int result; // eax

  v2 = -1;
  for ( i = *(_DWORD *)(dword_D41A4 + 38531); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(unsigned __int16 *)(i + 150) == *(signed __int16 *)(a2 + 26) )
    {
      v4 = sub_584D0((_WORD *)(a2 + 76), (_WORD *)(i + 76));
      if ( v4 < v2 )
      {
        v2 = v4;
        a1 = i;
      }
    }
  }
  if ( v2 >= 0x1900000 )
    result = 0;
  else
    result = a1;
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00015D20) --------------------------------------------------------
int __cdecl sub_15D20(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 164);
  if ( !*(_BYTE *)(result + 1118) )
    *(_WORD *)(result + 16) = 80;
  return result;
}

//----- (00015D40) --------------------------------------------------------
char __usercall sub_15D40@<al>(__int16 a1@<di>, int a2, int a3)
{
  unsigned int v3; // eax
  signed __int16 i; // si
  signed __int16 v5; // si
  signed __int16 v6; // si

  v3 = sub_584D0((_WORD *)(a2 + 76), (_WORD *)(a3 + 76));
  if ( v3 >= (unsigned int)&unk_100000 )
    return v3;
  LOBYTE(v3) = *(_BYTE *)(a3 + 64);
  if ( (unsigned __int8)v3 < 3u )
  {
    if ( (_BYTE)v3 )
      return v3;
  }
  else if ( (unsigned __int8)v3 > 3u )
  {
    if ( (_BYTE)v3 == 4 )
    {
      v3 = *(_DWORD *)(a2 + 164);
      v6 = *(char *)(v3 + 1059);
      if ( v6 >= 0 )
      {
        while ( 1 )
        {
          LOWORD(v3) = sub_15F20(a2, v6, 6);
          if ( (_WORD)v3 == 6 )
            break;
          if ( --v6 < 0 )
            return v3;
        }
        LOBYTE(v3) = sub_14E10(a2, 6u);
      }
    }
    return v3;
  }
  v3 = *(_DWORD *)(a2 + 164);
  for ( i = *(char *)(v3 + 1061); i >= 0; --i )
  {
    LOWORD(v3) = sub_15F20(a2, i, 8);
    a1 = v3;
    if ( (_WORD)v3 == 8 )
    {
      LOBYTE(v3) = sub_14E10(a2, 8u);
      break;
    }
  }
  if ( a1 != 8 )
  {
    v3 = *(_DWORD *)(a2 + 164);
    v5 = *(char *)(v3 + 1059);
    if ( v5 >= 0 )
    {
      while ( 1 )
      {
        LOWORD(v3) = sub_15F20(a2, v5, 6);
        if ( (_WORD)v3 == 6 )
          break;
        if ( --v5 < 0 )
          return v3;
      }
      LOBYTE(v3) = sub_14E10(a2, 6u);
    }
  }
  return v3;
}

//----- (00015E60) --------------------------------------------------------
_BOOL1 __cdecl sub_15E60(int a1)
{
  return sub_146C0(a1, 0)
      || sub_146C0(a1, 7u)
      || sub_146C0(a1, 0x12u)
      || sub_146C0(a1, 0x10u)
      || sub_146C0(a1, 0x14u)
      || sub_146C0(a1, 0x15u)
      || sub_146C0(a1, 9u);
}

//----- (00015EE0) --------------------------------------------------------
char sub_15EE0()
{
  unsigned int v0; // eax

  v0 = *(_DWORD *)(dword_D41A4 + 38519);
  if ( v0 <= dword_EA3E4[0] )
    return 1;
  do
  {
    if ( !*(_BYTE *)(v0 + 64) )
      dword_E8840 = v0;
    v0 = *(_DWORD *)v0;
  }
  while ( v0 > dword_EA3E4[0] );
  return 1;
}
// D41A4: using guessed type int dword_D41A4;
// E8840: using guessed type int dword_E8840;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00015F20) --------------------------------------------------------
signed int __cdecl sub_15F20(int a1, signed __int16 a2, signed int a3)
{
  int v3; // ebx
  int v4; // eax
  int v5; // ebx
  signed int result; // eax

  v3 = 80 * (signed __int16)a3;
  if ( (unsigned __int8)byte_DA818[v3] <= a2 )
    return 0;
  v4 = sub_146C0(a1, a3);
  if ( !v4 )
    return 0;
  sub_6D5E0(v4, a2);
  if ( !sub_15170(a1, a3) )
    return 0;
  v5 = 26 * a2 + v3;
  if ( *(_DWORD *)(a1 + 140) < *(int *)((char *)&dword_DA822 + v5)
    || *(_DWORD *)(a1 + 144) < *(int *)((char *)&dword_DA81E + v5) )
  {
    result = -1;
  }
  else
  {
    result = a3;
  }
  return result;
}
// DA81E: using guessed type int dword_DA81E;
// DA822: using guessed type int dword_DA822;

//----- (00015FC0) --------------------------------------------------------
signed int __cdecl sub_15FC0(_WORD *a1)
{
  unsigned __int8 v1; // bl
  int v2; // esi
  unsigned int i; // esi
  char v5; // ah
  unsigned int v6; // eax
  unsigned int k; // esi
  unsigned int v8; // eax
  int v9; // eax
  unsigned int v11; // [esp+0h] [ebp-18h]
  int v12; // [esp+4h] [ebp-14h]
  unsigned int v13; // [esp+8h] [ebp-10h]
  unsigned int v14; // [esp+Ch] [ebp-Ch]
  char *j; // [esp+10h] [ebp-8h]
  int v16; // [esp+14h] [ebp-4h]

  v11 = 0;
  v16 = 0;
  v13 = -1;
  v14 = -1;
  v1 = 0;
  v2 = dword_EA3E4[(unsigned __int16)a1[75]];
  if ( !sub_156F0((int)a1, 4u) || !sub_14C60((int)a1, v2) )
  {
    v12 = sub_146C0((int)a1, 4u);
    if ( !v12 )
      return 0;
    for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(_WORD *)(i + 26) != a1[13] )
      {
        v5 = *(_BYTE *)(i + 64);
        if ( !v5 || v5 == 1 )
        {
          v6 = sub_583F0(a1 + 38, (_WORD *)(i + 76));
          if ( v6 < v14 )
          {
            v11 = i;
            v14 = v6;
          }
        }
      }
    }
    if ( v14 > 0x1400 )
      v11 = 0;
    if ( !v11 )
      return 0;
    for ( j = (char *)&unk_D3F91; ; ++j )
    {
      v9 = *j;
      if ( v9 == -1 )
        break;
      for ( k = *(_DWORD *)(dword_D41A4 + 4 * v9 + 38403); k > dword_EA3E4[0]; k = *(_DWORD *)k )
      {
        if ( *(_WORD *)(k + 26) != a1[13] )
        {
          v8 = sub_583F0((_WORD *)(v11 + 76), (_WORD *)(k + 76));
          if ( v8 < v13 )
          {
            v16 = k;
            v13 = v8;
            v1 = *j;
          }
        }
      }
    }
    if ( !v16 || v13 >= 0x1400 || !v1 )
      return 0;
    if ( v1 < 0x10u )
    {
      if ( v1 == 2 )
      {
LABEL_35:
        sub_6D5E0(v12, 0);
        goto LABEL_38;
      }
    }
    else
    {
      if ( v1 <= 0x10u )
      {
        sub_6D5E0(v12, 2);
        goto LABEL_38;
      }
      if ( v1 >= 0x13u )
      {
        if ( v1 > 0x13u )
        {
          if ( v1 == 25 )
            sub_6D5E0(v12, 1);
          goto LABEL_38;
        }
        goto LABEL_35;
      }
    }
LABEL_38:
    a1[75] = (v16 - (dword_D41A0 + 28302)) / 168;
    a1[76] = sub_14C40(v16);
    return 1;
  }
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000161A0) --------------------------------------------------------
signed int __cdecl sub_161A0(int a1)
{
  int v1; // esi
  int v2; // eax
  int v3; // eax
  unsigned int v4; // eax
  int v5; // edi
  int v6; // edi
  unsigned int i; // esi
  char v8; // cl
  unsigned int v9; // eax
  signed __int8 v10; // al
  signed int result; // eax
  int v12; // eax
  __int16 v13; // ax
  unsigned int v14; // [esp+4h] [ebp-8h]
  unsigned int v15; // [esp+8h] [ebp-4h]

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v15 = -1;
  if ( sub_14C60(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]) )
  {
    sub_14E10(a1, 4u);
    sub_584D0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
    v2 = *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v1 + 80) + 512);
    if ( *(signed __int16 *)(a1 + 80) != *(signed __int16 *)(v1 + 80) + 512 )
    {
      if ( v2 <= 0 )
        LOWORD(v2) = -1;
      else
        LOWORD(v2) = 1;
    }
    *(_WORD *)(a1 + 80) += v2 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
    v3 = *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v1 + 80) + 512);
    if ( *(signed __int16 *)(a1 + 80) != *(signed __int16 *)(v1 + 80) + 512 )
    {
      if ( *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v1 + 80) + 512) <= 0 )
        LOWORD(v3) = -1;
      else
        LOWORD(v3) = 1;
    }
    *(_WORD *)(a1 + 80) += v3 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
    v4 = sub_146C0(a1, 4u);
    v14 = v4;
    if ( v4 && !*(_BYTE *)(v4 + 70) )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v5 = 2 * ((signed int)(*(unsigned __int16 *)(a1 + 20) % 0x9Du) / 79);
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      *(_WORD *)(a1 + 32) += (v5 - 1) * (*(_WORD *)(a1 + 20) % 0x55u);
      *(_BYTE *)(a1 + 33) &= 7u;
    }
    v6 = 0;
    for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) )
      {
        v8 = *(_BYTE *)(i + 64);
        if ( !v8 || v8 == 1 )
        {
          v9 = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
          if ( v9 < v15 )
          {
            v6 = i;
            v15 = v9;
          }
        }
      }
    }
    if ( v6 && v15 < 0x1400 && v15 > 0xA00 )
    {
      *(_WORD *)(a1 + 150) = (v6 - (dword_D41A0 + 28302)) / 168;
      *(_WORD *)(a1 + 152) = sub_14C40(v6);
      v10 = sub_15790(a1);
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
      if ( v10 != -1 && sub_14E10(a1, v10) )
      {
        sub_16580(a1);
        return 1;
      }
    }
    else
    {
      *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v6 + 76));
      v12 = *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v6 + 80) + 512);
      if ( *(signed __int16 *)(a1 + 80) != *(signed __int16 *)(v6 + 80) + 512 )
      {
        if ( *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v6 + 80) + 512) <= 0 )
          LOWORD(v12) = -1;
        else
          LOWORD(v12) = 1;
      }
      *(_WORD *)(a1 + 80) += v12 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
    }
    if ( v14 )
    {
      if ( *(_BYTE *)(v14 + 70) )
        v13 = *(_WORD *)(a1 + 132);
      else
        v13 = 3 * *(_WORD *)(a1 + 132);
      *(_WORD *)(a1 + 130) = v13;
    }
    sub_16580(a1);
    result = 1;
  }
  else
  {
    sub_16580(a1);
    result = 0;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000164B0) --------------------------------------------------------
_BOOL1 __cdecl sub_164B0(int a1)
{
  return sub_146C0(a1, 0x11u)
      || sub_146C0(a1, 0x10u)
      || sub_146C0(a1, 0x12u)
      || sub_146C0(a1, 7u)
      || sub_146C0(a1, 9u)
      || sub_146C0(a1, 0x14u)
      || sub_146C0(a1, 0x13u)
      || sub_146C0(a1, 0x15u)
      || sub_146C0(a1, 0);
}

//----- (00016580) --------------------------------------------------------
signed int __cdecl sub_16580(int a1)
{
  __int16 v1; // di
  __int16 v2; // dx
  signed int v3; // esi
  signed __int16 v4; // ax
  signed int result; // eax
  int v6; // eax
  int v7; // eax
  unsigned __int8 v8; // [esp+0h] [ebp-4h]

  LOBYTE(v2) = 0;
  v8 = 0;
  v1 = *(_WORD *)(a1 + 28);
  HIBYTE(v2) = *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1118);
  v3 = 0;
  if ( SHIBYTE(v2) <= 2 || SHIBYTE(v2) >= 8 )
  {
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1118) <= 7 )
      v4 = (unsigned __int8)sub_169C0(a1);
    else
      v4 = 0;
  }
  else
  {
    v4 = 3;
  }
  switch ( v4 )
  {
    case 0:
      *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1118) = 0;
      return 0;
    case 1:
      v8 = sub_16730(v2, a1, 0);
      if ( v8 )
        *(_WORD *)(a1 + 28) = word_D3FCE[v8];
      goto LABEL_11;
    case 2:
      v8 = sub_16730(v2, a1, 1);
      if ( v8 )
        *(_WORD *)(a1 + 28) = word_D3FE8[v8];
      goto LABEL_11;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      result = 0;
      ++*(_BYTE *)(*(_DWORD *)(a1 + 164) + 1118);
      break;
    default:
LABEL_11:
      if ( v8 )
      {
        v6 = *(_DWORD *)(a1 + 164);
        v3 = 1;
        if ( *(char *)(v6 + 1119) != v8 )
          *(_BYTE *)(v6 + 1119) = v8;
        if ( v1 != *(_WORD *)(a1 + 28) )
        {
          v7 = *(_DWORD *)(a1 + 164);
          *(_WORD *)(a1 + 130) = 0;
          *(_WORD *)(v7 + 12) = 0;
          *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
        }
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 28);
      }
      result = v3;
      break;
  }
  return result;
}

//----- (00016730) --------------------------------------------------------
int __usercall sub_16730@<eax>(int a1@<edx>, int a2, char a3)
{
  int v3; // eax
  int v4; // eax
  int result; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // [esp+0h] [ebp-8h]
  int v14; // [esp+4h] [ebp-4h]

  v14 = *(signed __int16 *)(a2 + 78) >> 8;
  v3 = *(signed __int16 *)(a2 + 76) >> 8;
  BYTE1(v3) = v14 - 1;
  LOWORD(a1) = 0;
  if ( byte_10B4E0[(unsigned __int16)v3] == 8 )
  {
    LOBYTE(a1) = 1;
  }
  else
  {
    BYTE1(v3) = v14 + 1;
    if ( byte_10B4E0[(unsigned __int16)v3] == 8 )
      LOBYTE(a1) = 4;
  }
  BYTE1(v3) = *(_WORD *)(a2 + 78) >> 8;
  if ( a3 )
    LOBYTE(v3) = v3 + 1;
  else
    LOBYTE(v3) = v3 - 1;
  if ( byte_10B4E0[(unsigned __int16)v3] == 8 )
  {
    if ( a3 )
    {
      LOBYTE(a1) = a1 | 2;
      goto LABEL_18;
    }
LABEL_17:
    LOBYTE(a1) = a1 | 8;
    goto LABEL_18;
  }
  v13 = *(signed __int16 *)(a2 + 76) >> 8;
  if ( a3 )
    LOBYTE(v3) = v13 - 1;
  else
    LOBYTE(v3) = v13 + 1;
  if ( byte_10B4E0[(unsigned __int16)v3] == 8 )
  {
    if ( !a3 )
    {
      LOBYTE(a1) = a1 | 2;
      goto LABEL_18;
    }
    goto LABEL_17;
  }
LABEL_18:
  if ( (_BYTE)a1 )
    return a1;
  if ( a3 )
  {
    switch ( *(_BYTE *)(*(_DWORD *)(a2 + 164) + 1119) )
    {
      case 1:
      case 9:
        v9 = *(signed __int16 *)(a2 + 76) >> 8;
        BYTE1(v9) = (*(_WORD *)(a2 + 78) >> 8) - 1;
        LOBYTE(v9) = v9 - 1;
        if ( byte_10B4E0[(unsigned __int16)v9] != 8 )
          return a1;
        LOWORD(a1) = 1544;
        return a1;
      case 2:
      case 3:
        v10 = *(signed __int16 *)(a2 + 76) >> 8;
        BYTE1(v10) = (*(_WORD *)(a2 + 78) >> 8) - 1;
        LOBYTE(v10) = v10 + 1;
        if ( byte_10B4E0[(unsigned __int16)v10] != 8 )
          return a1;
        LOWORD(a1) = 3073;
        return a1;
      case 4:
      case 6:
        v11 = *(signed __int16 *)(a2 + 76) >> 8;
        BYTE1(v11) = (*(_WORD *)(a2 + 78) >> 8) + 1;
        LOBYTE(v11) = v11 + 1;
        if ( byte_10B4E0[(unsigned __int16)v11] != 8 )
          return a1;
        LOWORD(a1) = 2306;
        return a1;
      case 8:
      case 0xC:
        v12 = *(signed __int16 *)(a2 + 76) >> 8;
        BYTE1(v12) = (*(_WORD *)(a2 + 78) >> 8) + 1;
        LOBYTE(v12) = v12 - 1;
        if ( byte_10B4E0[(unsigned __int16)v12] == 8 )
          LOWORD(a1) = 772;
        return a1;
      default:
        return a1;
    }
    return a1;
  }
  switch ( *(_BYTE *)(*(_DWORD *)(a2 + 164) + 1119) )
  {
    case 1:
    case 3:
      v4 = *(signed __int16 *)(a2 + 76) >> 8;
      BYTE1(v4) = (*(_WORD *)(a2 + 78) >> 8) - 1;
      LOBYTE(v4) = v4 + 1;
      if ( byte_10B4E0[(unsigned __int16)v4] != 8 )
        return a1;
      LOWORD(a1) = 770;
      result = a1;
      break;
    case 2:
    case 6:
      v6 = *(signed __int16 *)(a2 + 76) >> 8;
      BYTE1(v6) = (*(_WORD *)(a2 + 78) >> 8) + 1;
      LOBYTE(v6) = v6 + 1;
      if ( byte_10B4E0[(unsigned __int16)v6] != 8 )
        return a1;
      LOWORD(a1) = 1540;
      result = a1;
      break;
    case 4:
      v7 = *(signed __int16 *)(a2 + 76) >> 8;
      BYTE1(v7) = (*(_WORD *)(a2 + 78) >> 8) + 1;
      LOBYTE(v7) = v7 - 1;
      if ( byte_10B4E0[(unsigned __int16)v7] != 8 )
        return a1;
      LOWORD(a1) = 3080;
      result = a1;
      break;
    case 8:
    case 9:
      v8 = *(signed __int16 *)(a2 + 76) >> 8;
      BYTE1(v8) = (*(_WORD *)(a2 + 78) >> 8) - 1;
      LOBYTE(v8) = v8 - 1;
      if ( byte_10B4E0[(unsigned __int16)v8] != 8 )
        return a1;
      LOWORD(a1) = 2305;
      result = a1;
      break;
    default:
      return a1;
  }
  return result;
}

//----- (000169C0) --------------------------------------------------------
char __cdecl sub_169C0(int a1)
{
  int v1; // eax
  __int16 v2; // dx
  __int16 v3; // dx
  char result; // al
  unsigned __int16 v5; // si
  unsigned __int16 v6; // si
  int v7; // eax
  char v8; // dl
  unsigned __int8 v9; // [esp+0h] [ebp-1Ch]
  unsigned __int8 v10; // [esp+1h] [ebp-1Bh]
  int v11; // [esp+4h] [ebp-18h]
  int v12; // [esp+8h] [ebp-14h]
  __int16 v13; // [esp+Ch] [ebp-10h]
  __int16 v14; // [esp+10h] [ebp-Ch]
  __int16 v15; // [esp+14h] [ebp-8h]
  __int16 v16; // [esp+18h] [ebp-4h]

  LOBYTE(v12) = *(_WORD *)(a1 + 76) >> 8;
  BYTE1(v12) = *(_WORD *)(a1 + 78) >> 8;
  LOWORD(v11) = v12;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v13 = 0;
  v16 = 0;
  v9 = *(_WORD *)(v1 + 76) >> 8;
  v10 = *(_WORD *)(v1 + 78) >> 8;
  LOBYTE(v2) = 0;
  HIBYTE(v2) = *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1118);
  switch ( HIBYTE(v2) )
  {
    case 0:
      v15 = sub_16730(v2, a1, 0);
      v14 = sub_16730(v3, a1, 1);
      if ( !(_BYTE)v14 && !(_BYTE)v15 )
        return 0;
      if ( (_BYTE)v15 )
      {
        v5 = 0;
        while ( v5 < 0x28u )
        {
          LOBYTE(v12) = byte_D3F96[(unsigned __int8)v15] + v12;
          BYTE1(v12) += byte_D3FA4[(unsigned __int8)v15];
          v16 = v12;
          ++v5;
          v15 = sub_16CA0((unsigned __int8)v15, &v12, (unsigned __int8)v15, 0);
        }
      }
      if ( (_BYTE)v14 )
      {
        v6 = 0;
        while ( v6 < 0x28u )
        {
          LOBYTE(v11) = byte_D3FB2[(unsigned __int8)v14] + v11;
          BYTE1(v11) += byte_D3FC0[(unsigned __int8)v14];
          v13 = v11;
          ++v6;
          v14 = sub_16CA0((unsigned __int8)v14, &v11, (unsigned __int8)v14, 1);
        }
      }
      if ( (_BYTE)v15 && (_BYTE)v14 )
      {
        if ( abs(v10 - HIBYTE(v16)) * abs(v9 - (unsigned __int8)v16) > abs(v9 - (unsigned __int8)v13)
                                                                     * abs(v10 - HIBYTE(v13)) )
        {
          v7 = *(_DWORD *)(a1 + 164);
          v8 = 2;
        }
        else
        {
          v7 = *(_DWORD *)(a1 + 164);
          v8 = 1;
        }
        goto LABEL_21;
      }
      if ( !(_BYTE)v15 )
      {
        v7 = *(_DWORD *)(a1 + 164);
        v8 = 2;
LABEL_21:
        *(_BYTE *)(v7 + 1118) = v8;
        return v8;
      }
      LOBYTE(v2) = 1;
      *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1118) = 1;
      return v2;
    case 1:
      v15 = sub_16730(v2, a1, 0);
      if ( !HIBYTE(v15) || (unsigned __int16)sub_16E70((unsigned __int8 *)&v12, &v9) )
      {
        result = 1;
      }
      else
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1118) = 3;
        result = 3;
      }
      break;
    case 2:
      v14 = sub_16730(v2, a1, 1);
      if ( !HIBYTE(v14) || (unsigned __int16)sub_16E70((unsigned __int8 *)&v12, &v9) )
      {
        result = 2;
      }
      else
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1118) = 3;
        result = 3;
      }
      break;
    default:
      return v2;
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00016CA0) --------------------------------------------------------
int __usercall sub_16CA0@<eax>(int a1@<edx>, _BYTE *a2, __int16 a3, char a4)
{
  unsigned __int16 v4; // ax
  char v5; // al
  int v6; // eax
  char v7; // al
  int v8; // eax
  char v9; // al
  char v10; // ah
  unsigned __int16 v11; // ax
  int result; // eax
  unsigned __int16 v13; // ax
  unsigned __int16 v14; // ax
  unsigned __int16 v15; // ax
  char v16; // al
  char v17; // ah
  unsigned __int16 v18; // ax
  unsigned __int16 v19; // ax
  unsigned __int16 v20; // ax
  unsigned __int16 v21; // ax

  LOBYTE(v4) = *a2;
  HIBYTE(v4) = a2[1] - 1;
  LOWORD(a1) = 0;
  if ( byte_10B4E0[v4] == 8 )
  {
    LOBYTE(a1) = 1;
  }
  else
  {
    HIBYTE(v4) = a2[1] + 1;
    if ( byte_10B4E0[v4] == 8 )
      LOBYTE(a1) = 4;
  }
  v5 = *a2;
  if ( a4 )
    LOBYTE(v6) = v5 + 1;
  else
    LOBYTE(v6) = v5 - 1;
  BYTE1(v6) = a2[1];
  if ( byte_10B4E0[(unsigned __int16)v6] == 8 )
  {
    if ( !a4 )
    {
      LOBYTE(a1) = a1 | 8;
      goto LABEL_18;
    }
    goto LABEL_16;
  }
  v7 = *a2;
  if ( a4 )
    LOBYTE(v8) = v7 - 1;
  else
    LOBYTE(v8) = v7 + 1;
  BYTE1(v8) = a2[1];
  if ( byte_10B4E0[(unsigned __int16)v8] == 8 )
  {
    if ( !a4 )
    {
LABEL_16:
      LOBYTE(a1) = a1 | 2;
      goto LABEL_18;
    }
    LOBYTE(a1) = a1 | 8;
  }
LABEL_18:
  if ( (_BYTE)a1 )
    return a1;
  if ( a4 )
  {
    v16 = *a2;
    v17 = a2[1];
    switch ( a3 )
    {
      case 1:
      case 9:
        HIBYTE(v18) = v17 - 1;
        LOBYTE(v18) = v16 - 1;
        if ( byte_10B4E0[v18] != 8 )
          return a1;
        LOWORD(a1) = 1544;
        return a1;
      case 2:
      case 3:
        HIBYTE(v19) = v17 - 1;
        LOBYTE(v19) = v16 + 1;
        if ( byte_10B4E0[v19] != 8 )
          return a1;
        LOWORD(a1) = 3073;
        return a1;
      case 4:
      case 6:
        HIBYTE(v20) = v17 + 1;
        LOBYTE(v20) = v16 + 1;
        if ( byte_10B4E0[v20] != 8 )
          return a1;
        LOWORD(a1) = 2306;
        return a1;
      case 8:
      case 12:
        HIBYTE(v21) = v17 + 1;
        LOBYTE(v21) = v16 - 1;
        if ( byte_10B4E0[v21] == 8 )
          LOWORD(a1) = 772;
        return a1;
      default:
        return a1;
    }
    return a1;
  }
  v9 = *a2;
  v10 = a2[1];
  switch ( a3 )
  {
    case 1:
    case 3:
      HIBYTE(v11) = v10 - 1;
      LOBYTE(v11) = v9 + 1;
      if ( byte_10B4E0[v11] != 8 )
        return a1;
      LOWORD(a1) = 770;
      result = a1;
      break;
    case 2:
    case 6:
      HIBYTE(v13) = v10 + 1;
      LOBYTE(v13) = v9 + 1;
      if ( byte_10B4E0[v13] != 8 )
        return a1;
      LOWORD(a1) = 1540;
      result = a1;
      break;
    case 4:
      HIBYTE(v14) = v10 + 1;
      LOBYTE(v14) = v9 - 1;
      if ( byte_10B4E0[v14] != 8 )
        return a1;
      LOWORD(a1) = 3080;
      result = a1;
      break;
    case 8:
    case 9:
      HIBYTE(v15) = v10 - 1;
      LOBYTE(v15) = v9 - 1;
      if ( byte_10B4E0[v15] != 8 )
        return a1;
      LOWORD(a1) = 2305;
      result = a1;
      break;
    default:
      return a1;
  }
  return result;
}

//----- (00016E70) --------------------------------------------------------
int __cdecl sub_16E70(unsigned __int8 *a1, unsigned __int8 *a2)
{
  __int16 v2; // cx
  __int16 v3; // si
  int v4; // ebx
  signed __int16 v5; // ax
  signed __int16 v6; // ax
  __int16 v7; // ax
  __int16 v8; // dx
  int j; // ecx
  unsigned __int16 v10; // ST00_2
  int i; // ecx
  unsigned __int16 v12; // ST00_2
  int result; // eax
  int v14; // ecx
  signed __int16 v15; // [esp+4h] [ebp-10h]
  int v16; // [esp+8h] [ebp-Ch]
  int v17; // [esp+Ch] [ebp-8h]
  signed __int16 v18; // [esp+10h] [ebp-4h]

  v2 = *a2 - *a1;
  v3 = a2[1] - a1[1];
  v17 = 2 * abs(v2);
  v4 = 0;
  v16 = 2 * abs(v3);
  if ( v2 >= 0 )
  {
    LOBYTE(v5) = *a2 != *a1;
    HIBYTE(v5) = 0;
    v15 = v5;
  }
  else
  {
    v15 = -1;
  }
  if ( v3 >= 0 )
  {
    LOBYTE(v6) = a2[1] != a1[1];
    HIBYTE(v6) = 0;
    v18 = v6;
  }
  else
  {
    v18 = -1;
  }
  v7 = *a1;
  v8 = a1[1];
  if ( (signed __int16)v17 <= (signed __int16)v16 )
  {
    for ( i = (signed __int16)v17 - ((signed __int16)v16 >> 1); ; i += v17 )
    {
      LOBYTE(v12) = v7;
      HIBYTE(v12) = v8;
      if ( byte_10B4E0[v12] == 8 )
        return v4 + 1;
      if ( v8 == a2[1] )
        break;
      if ( (i & 0x8000u) == 0 )
      {
        LOBYTE(v7) = v15 + v7;
        i -= v16;
      }
      ++v4;
      v8 += v18;
    }
    result = 0;
  }
  else
  {
    for ( j = (signed __int16)v16 - ((signed __int16)v17 >> 1); ; j += v16 )
    {
      LOBYTE(v10) = v7;
      HIBYTE(v10) = v8;
      if ( byte_10B4E0[v10] == 8 )
      {
        v14 = v4 + 1;
        goto LABEL_24;
      }
      if ( v7 == *a2 )
        break;
      if ( (j & 0x8000u) == 0 )
      {
        LOBYTE(v8) = v18 + v8;
        j -= v17;
      }
      ++v4;
      v7 += v15;
    }
    v14 = 0;
LABEL_24:
    result = v14;
  }
  return result;
}

//----- (00016FC0) --------------------------------------------------------
unsigned int __cdecl sub_16FC0(int a1, int a2)
{
  unsigned int v2; // edi
  unsigned int v3; // esi
  unsigned int v4; // ebx
  __int16 v6; // ax
  char v7; // ah
  unsigned int v8; // eax

  v2 = -1;
  v3 = 0;
  v4 = *(_DWORD *)(dword_D41A4 + 38519);
  if ( v4 <= dword_EA3E4[0] )
    return 0;
  do
  {
    v6 = *(_WORD *)(v4 + 26);
    if ( v6 != *(_WORD *)(a1 + 26) && v6 != *(_WORD *)(a2 + 26) )
    {
      v7 = *(_BYTE *)(v4 + 64);
      if ( !v7 || v7 == 1 )
      {
        v8 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(v4 + 76));
        if ( v8 < v2 )
        {
          v3 = v4;
          v2 = v8;
        }
      }
    }
    v4 = *(_DWORD *)v4;
  }
  while ( v4 > dword_EA3E4[0] );
  return v3;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00017060) --------------------------------------------------------
__int16 __cdecl sub_17060(__int16 a1, __int16 a2)
{
  __int16 result; // ax
  int v3; // ebx
  int v4; // ecx
  int v5; // eax
  int v6; // edx

  result = dword_D41A4;
  if ( !*(_BYTE *)(dword_D41A4 + 178) )
  {
    if ( word_180660 == 1 )
    {
      v3 = ((a1 << 7) - 40960) / 320;
      v4 = (25600 - (a2 << 7)) / 200;
    }
    else
    {
      v3 = ((a1 << 7) - 40960) / 320;
      v4 = ((a2 << 7) - 30720) / -240;
    }
    if ( v3 < -127 )
      v3 = -127;
    if ( v3 > 127 )
      LOBYTE(v3) = 127;
    if ( v4 < -127 )
      v4 = -127;
    if ( v4 > 127 )
      LOBYTE(v4) = 127;
    v5 = dword_D41A0;
    *(_BYTE *)(dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12) + 28225) = v3;
    *(_BYTE *)(v5 + 10 * *(signed __int16 *)(v5 + 12) + 28226) = v4;
    *(_WORD *)(v5 + 10 * *(signed __int16 *)(v5 + 12) + 28228) = dword_180590;
    v6 = v5 + 10 * *(signed __int16 *)(v5 + 12);
    result = dword_180594;
    *(_WORD *)(v6 + 28230) = dword_180594;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 180590: using guessed type int dword_180590;
// 180594: using guessed type int dword_180594;
// 180660: using guessed type __int16 word_180660;

//----- (00017190) --------------------------------------------------------
char sub_17190()
{
  int v0; // eax
  int v1; // ecx
  int v2; // edx
  int v3; // edx
  char v4; // dl
  char v5; // cl
  int v6; // edx
  _BOOL1 v7; // dl
  int v8; // eax

  if ( !(*(_BYTE *)(dword_D41A4 + 22) & 4) || (v0 = sub_473E0()) == 0 )
  {
    v1 = *(signed __int16 *)(dword_D41A0 + 12);
    LOBYTE(v0) = 5 * v1;
    if ( !*(_BYTE *)(dword_D41A0 + 10 * v1 + 28222) )
    {
      v2 = 2124 * v1 + dword_D41A0;
      if ( !(*(_BYTE *)(v2 + 11232) & 0x20) )
      {
        v3 = dword_EA3E4[*(unsigned __int16 *)(v2 + 11240)];
        if ( byte_18069C )
        {
          LOBYTE(v0) = byte_1806E4;
          if ( (unsigned __int8)byte_1806E4 >= 0x3Cu )
          {
            if ( (unsigned __int8)byte_1806E4 <= 0x3Cu )
            {
              LOBYTE(v0) = sub_191B0(30, 2);
              byte_1806E4 = 0;
            }
            else if ( (unsigned __int8)byte_1806E4 < 0x40u )
            {
              if ( (unsigned __int8)byte_1806E4 < 0x3Eu )
              {
                LOBYTE(v0) = sub_191B0(30, 3);
                byte_1806E4 = 0;
              }
              else
              {
                if ( (unsigned __int8)byte_1806E4 <= 0x3Eu )
                  LOBYTE(v0) = sub_191B0(30, 4);
                else
                  LOBYTE(v0) = sub_191B0(30, 5);
                byte_1806E4 = 0;
              }
            }
            else if ( (unsigned __int8)byte_1806E4 <= 0x40u )
            {
              LOBYTE(v0) = sub_191B0(30, 6);
              byte_1806E4 = 0;
            }
            else if ( (unsigned __int8)byte_1806E4 < 0x42u )
            {
              LOBYTE(v0) = sub_191B0(30, 7);
              byte_1806E4 = 0;
            }
            else if ( (unsigned __int8)byte_1806E4 <= 0x42u )
            {
              LOBYTE(v0) = sub_191B0(30, 8);
              byte_1806E4 = 0;
            }
            else if ( (unsigned __int8)byte_1806E4 <= 0x43u )
            {
              LOBYTE(v0) = sub_191B0(30, 9);
              byte_1806E4 = 0;
            }
            else if ( byte_1806E4 == 68 )
            {
              LOBYTE(v0) = sub_191B0(30, 10);
              byte_1806E4 = 0;
            }
            goto LABEL_161;
          }
          if ( (unsigned __int8)byte_1806E4 >= 0x2Cu )
          {
            if ( (unsigned __int8)byte_1806E4 <= 0x2Cu )
            {
              LOBYTE(v0) = dword_D41A4;
              if ( *(_BYTE *)(dword_D41A4 + 23) < 0 )
              {
                v5 = *(_BYTE *)(dword_D41A4 + 25);
                if ( v5 & 0x20 )
                  *(_BYTE *)(dword_D41A4 + 25) = v5 & 0xDF;
                else
                  *(_BYTE *)(dword_D41A4 + 25) = v5 | 0x20;
              }
              byte_1806E4 = 0;
              goto LABEL_161;
            }
            if ( (unsigned __int8)byte_1806E4 < 0x31u )
            {
              if ( byte_1806E4 == 47 )
              {
                LOBYTE(v0) = dword_D41A4;
                if ( *(_BYTE *)(dword_D41A4 + 23) < 0 )
                  LOBYTE(v0) = sub_191B0(4, 8);
                byte_1806E4 = 0;
              }
              goto LABEL_161;
            }
            if ( (unsigned __int8)byte_1806E4 > 0x31u )
            {
              if ( byte_1806E4 == 59 )
              {
                LOBYTE(v0) = sub_191B0(30, 1);
                byte_1806E4 = 0;
              }
              goto LABEL_161;
            }
            goto LABEL_61;
          }
          if ( (unsigned __int8)byte_1806E4 < 0x20u )
          {
            if ( byte_1806E4 == 20 )
            {
              LOBYTE(v0) = dword_D41A4;
              if ( *(_BYTE *)(dword_D41A4 + 23) < 0 )
              {
                if ( byte_18069A )
                  LOBYTE(v0) = sub_70940();
                else
                  LOBYTE(v0) = sub_191B0(4, 64);
              }
              byte_1806E4 = 0;
            }
            goto LABEL_161;
          }
          if ( (unsigned __int8)byte_1806E4 <= 0x20u )
          {
            LOBYTE(v0) = dword_D41A4;
            if ( *(_BYTE *)(dword_D41A4 + 23) < 0 )
            {
              sub_5BF10();
              LOBYTE(v0) = dword_D41A4;
              v4 = *(_BYTE *)(dword_D41A4 + 24);
              byte_18069C = 0;
              if ( v4 & 0x10 )
                *(_BYTE *)(dword_D41A4 + 24) = v4 & 0xEF;
              else
                *(_BYTE *)(dword_D41A4 + 24) = v4 | 0x10;
            }
            byte_1806E4 = 0;
            goto LABEL_161;
          }
          if ( byte_1806E4 == 35 )
          {
            v0 = dword_D41A0;
            *(_BYTE *)(v0 + 8595) ^= 1u;
LABEL_61:
            byte_1806E4 = 0;
          }
LABEL_161:
          if ( byte_18067C )
          {
            LOBYTE(v0) = dword_D41A0;
            *((_BYTE *)&loc_36E03 + dword_D41A0 + 1) = 2;
          }
          return v0;
        }
        if ( byte_18068E || byte_18069A )
        {
          LOBYTE(v0) = byte_1806E4;
          if ( (unsigned __int8)byte_1806E4 < 0x2Eu )
          {
            if ( (unsigned __int8)byte_1806E4 < 0x20u )
            {
              if ( (unsigned __int8)byte_1806E4 < 0x12u )
              {
                if ( byte_1806E4 == 16 )
                {
                  LOBYTE(v0) = sub_191B0(2, 0);
                  byte_1806E4 = 0;
                }
              }
              else if ( (unsigned __int8)byte_1806E4 <= 0x12u )
              {
                LOBYTE(v0) = dword_D41A4;
                if ( *(_BYTE *)(dword_D41A4 + 23) < 0 )
                  LOBYTE(v0) = sub_191B0(26, 0);
                byte_1806E4 = 0;
              }
              else if ( byte_1806E4 == 19 )
              {
                LOBYTE(v0) = dword_D41A4;
                if ( *(_BYTE *)(dword_D41A4 + 23) < 0 && !(*(_BYTE *)(dword_D41A4 + 22) & 0x10) )
                {
                  v6 = dword_D41A0;
                  *(_BYTE *)(v6 + 2124 * *(signed __int16 *)(dword_D41A0 + 12) + 11232) |= 0xCu;
                  LOBYTE(v0) = dword_D41A0;
                  *(_WORD *)(2124 * *(signed __int16 *)(v6 + 12) + dword_D41A0 + 12286) = 0;
                }
                byte_1806E4 = 0;
              }
              goto LABEL_161;
            }
            if ( (unsigned __int8)byte_1806E4 <= 0x20u )
            {
              LOBYTE(v0) = dword_D41A4;
              if ( *(_BYTE *)(dword_D41A4 + 23) < 0 )
              {
                v0 = 5 * (unsigned __int8)byte_3659D[11 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0];
                *((_BYTE *)&loc_3654B + 2 * v0 + dword_D41A0 + 2) |= 2u;
              }
            }
            else
            {
              if ( (unsigned __int8)byte_1806E4 < 0x22u )
              {
                LOBYTE(v0) = dword_D41A4;
                if ( *(_BYTE *)(dword_D41A4 + 23) < 0 )
                {
                  v0 = 2124 * *(signed __int16 *)(dword_D41A0 + 12);
                  *(_BYTE *)(dword_D41A0 + v0 + 11232) |= 4u;
                }
                byte_1806E4 = 0;
                goto LABEL_161;
              }
              if ( (unsigned __int8)byte_1806E4 > 0x22u )
              {
                if ( (unsigned __int8)byte_1806E4 >= 0x25u )
                {
                  if ( (unsigned __int8)byte_1806E4 <= 0x25u )
                  {
                    if ( !(*(_WORD *)(dword_D41A4 + 22) & 0x8010) )
                      *(_DWORD *)(v3 + 8) = -1;
                    LOBYTE(v0) = 0;
                    byte_1806E4 = 0;
                  }
                  else if ( byte_1806E4 == 38 )
                  {
                    v0 = *(_DWORD *)(v3 + 164);
                    if ( *(_WORD *)(v0 + 58) )
                      LOBYTE(v0) = sub_191B0(42, 0);
                    byte_1806E4 = 0;
                  }
                }
                goto LABEL_161;
              }
            }
          }
          else
          {
            if ( (unsigned __int8)byte_1806E4 <= 0x2Eu )
            {
              LOBYTE(v0) = dword_D41A4;
              if ( *(_BYTE *)(dword_D41A4 + 23) < 0 )
              {
                byte_3659C[11 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0] = 1;
                LOBYTE(v0) = sub_191B0(27, 0);
              }
              byte_1806E4 = 0;
              goto LABEL_161;
            }
            if ( (unsigned __int8)byte_1806E4 >= 0x3Eu )
            {
              if ( (unsigned __int8)byte_1806E4 <= 0x3Eu )
              {
                LOBYTE(v0) = sub_1A970(12, 0, 0);
                byte_1806E4 = 0;
              }
              else if ( (unsigned __int8)byte_1806E4 < 0x40u )
              {
                LOBYTE(v0) = sub_1A970(13, 0, 0);
                byte_1806E4 = 0;
              }
              else if ( (unsigned __int8)byte_1806E4 <= 0x40u )
              {
                LOBYTE(v0) = sub_1A970(14, 0, 0);
                byte_1806E4 = 0;
              }
              else if ( (unsigned __int8)byte_1806E4 <= 0x41u )
              {
                LOBYTE(v0) = sub_1A970(15, 0, 0);
                byte_1806E4 = 0;
              }
              else if ( byte_1806E4 == 68 )
              {
                v7 = *(_BYTE *)(dword_D41A4 + 205) == 0;
                v8 = dword_D41A4;
                *(_BYTE *)(dword_D41A4 + 205) = v7;
                *(_BYTE *)(v8 + 206) = v7;
                if ( v7 && *(_BYTE *)(v8 + 24) & 1 )
                  sub_8CD27(dword_EB394);
                LOBYTE(v0) = dword_D41A4;
                if ( !*(_BYTE *)(dword_D41A4 + 206) && *(_BYTE *)(dword_D41A4 + 24) & 1 )
                  LOBYTE(v0) = sub_8CD27(dword_EB394 + 6 * (unsigned __int8)byte_D419E);
                byte_1806E4 = 0;
              }
              goto LABEL_161;
            }
            if ( (unsigned __int8)byte_1806E4 >= 0x3Cu )
            {
              if ( (unsigned __int8)byte_1806E4 <= 0x3Cu )
              {
                LOBYTE(v0) = sub_1A970(10, 0, 0);
              }
              else
              {
                sub_1A970(11, 0, 0);
                LOBYTE(v0) = 0;
              }
              byte_1806E4 = 0;
              goto LABEL_161;
            }
            if ( byte_1806E4 != 59 )
              goto LABEL_161;
            LOBYTE(v0) = sub_1A970(9, 0, 0);
          }
        }
        else
        {
          if ( !(*(_BYTE *)(dword_D41A4 + 22) & 0x10) && byte_1806E4 == 25 )
          {
            sub_18BB0();
            byte_1806E4 = 0;
          }
          if ( byte_1806E4 == 19 )
          {
            sub_1A970(16, 0, 0);
            byte_1806E4 = 0;
          }
          if ( byte_1806E4 == 57 )
          {
            sub_191B0(15, 0);
            byte_1806E4 = 0;
          }
          LOBYTE(v0) = byte_1806E4;
          if ( (unsigned __int8)byte_1806E4 >= 0x3Eu )
          {
            if ( (unsigned __int8)byte_1806E4 <= 0x3Eu )
            {
              LOBYTE(v0) = sub_1A970(4, 0, 0);
              byte_1806E4 = 0;
            }
            else if ( (unsigned __int8)byte_1806E4 < 0x40u )
            {
              sub_1A970(2, 0, 0);
              LOBYTE(v0) = 0;
              byte_1806E4 = 0;
            }
            else if ( (unsigned __int8)byte_1806E4 <= 0x40u )
            {
              LOBYTE(v0) = sub_1A970(3, 0, 0);
              byte_1806E4 = 0;
            }
            else if ( (unsigned __int8)byte_1806E4 <= 0x41u )
            {
              LOBYTE(v0) = sub_1A970(6, 0, 0);
              byte_1806E4 = 0;
            }
            else if ( byte_1806E4 == 66 )
            {
              LOBYTE(v0) = sub_1A970(17, 0, 0);
              byte_1806E4 = 0;
            }
            goto LABEL_161;
          }
          if ( (unsigned __int8)byte_1806E4 < 0x3Bu )
          {
            if ( byte_1806E4 != 31 )
              goto LABEL_161;
            LOBYTE(v0) = dword_D41A4;
            if ( !(*(_BYTE *)(dword_D41A4 + 24) & 1)
              && word_180660 & 1
              && (word_1805C2 == 1 || word_1805C2 == 8 || word_1805C2 == 12) )
            {
              LOBYTE(v0) = sub_1A970(18, 0, 0);
            }
          }
          else
          {
            if ( (unsigned __int8)byte_1806E4 <= 0x3Bu )
            {
              LOBYTE(v0) = sub_1A970(1, 0, 0);
              byte_1806E4 = 0;
              goto LABEL_161;
            }
            if ( (unsigned __int8)byte_1806E4 <= 0x3Cu )
            {
              LOBYTE(v0) = sub_1A970(5, 0, 0);
              byte_1806E4 = 0;
              goto LABEL_161;
            }
            LOBYTE(v0) = sub_1A970(7, 0, 0);
          }
        }
        byte_1806E4 = 0;
        goto LABEL_161;
      }
    }
  }
  return v0;
}
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB394: using guessed type int dword_EB394;
// 1805C2: using guessed type __int16 word_1805C2;
// 180660: using guessed type __int16 word_180660;
// 18067C: using guessed type char byte_18067C;
// 18068E: using guessed type char byte_18068E;
// 18069A: using guessed type char byte_18069A;
// 18069C: using guessed type char byte_18069C;
// 1806E4: using guessed type char byte_1806E4;

//----- (00017A00) --------------------------------------------------------
char __usercall sub_17A00@<al>(_BYTE *a1@<ebx>, signed int a2@<edi>, __int16 a3@<si>)
{
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // ebx
  char v9; // ch
  char v10; // dl
  char v11; // dh
  int v12; // edi
  int v13; // eax
  int v14; // edx
  int v15; // ebx
  unsigned __int8 v16; // al
  char v17; // al
  int v18; // esi
  char v19; // al
  int v20; // eax
  char v21; // dl
  int v22; // ecx
  char v23; // al
  int v24; // ebx
  unsigned __int8 v25; // al
  char v26; // cl
  char v27; // al
  signed int v28; // eax
  int v29; // eax
  int v30; // ecx
  char v32; // [esp-4h] [ebp-Ch]
  char v33; // [esp+0h] [ebp-8h]
  char v34; // [esp+4h] [ebp-4h]

  if ( (unsigned __int8)byte_1806E4 >= 0x80u )
    byte_1806E4 = 0;
  v3 = 2124 * *(signed __int16 *)(dword_D41A0 + 12);
  v4 = v3 + dword_D41A0;
  if ( !(*(_BYTE *)(v3 + dword_D41A0 + 11232) & 0x20) )
  {
    switch ( *(_BYTE *)(v4 + 12221) )
    {
      case 0:
      case 4:
        if ( *(_BYTE *)(dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12) + 28222) )
          goto LABEL_292;
        if ( *(_BYTE *)(dword_D41A4 + 24) & 1 )
          sub_197F0();
        sub_17190();
        v5 = dword_D41A0;
        v6 = *(signed __int16 *)(dword_D41A0 + 12);
        v7 = 5 * v6;
        v8 = dword_EA3E4[*(unsigned __int16 *)(2124 * v6 + dword_D41A0 + 11240)];
        LOBYTE(v6) = dword_18059C;
        *(_BYTE *)(dword_D41A0 + 2 * v7 + 28227) = 0;
        if ( v6 & 0x10 )
        {
          if ( *(_DWORD *)(v8 + 8) >= 0 )
            sub_191B0(20, 5);
        }
        else if ( byte_18069C || byte_180664[(unsigned __int8)byte_EB3A7] )
        {
          if ( (unsigned __int8)byte_1806E4 < 0x1Fu )
          {
            if ( (unsigned __int8)byte_1806E4 >= 0x13u )
            {
              if ( (unsigned __int8)byte_1806E4 <= 0x13u )
              {
                byte_1806E4 = 0;
              }
              else if ( byte_1806E4 == 25 )
              {
                byte_1806E4 = 0;
              }
            }
          }
          else if ( (unsigned __int8)byte_1806E4 <= 0x1Fu )
          {
            byte_1806E4 = 0;
          }
          else if ( (unsigned __int8)byte_1806E4 >= 0x21u && (unsigned __int8)byte_1806E4 <= 0x21u )
          {
            sub_191B0(4, 32);
            byte_1806E4 = 0;
          }
          if ( dword_18059C & 1 )
          {
            sub_18DA0(v8, 1, 1);
            LOBYTE(dword_18059C) = dword_18059C & 0xFE;
          }
          else if ( dword_18059C & 2 )
          {
            sub_18DA0(v8, 2, 1);
            LOBYTE(dword_18059C) = dword_18059C & 0xFD;
          }
        }
        else if ( byte_18068E || byte_180664[(unsigned __int8)byte_EB3A6] )
        {
          if ( dword_18059C & 1 )
          {
            sub_18DA0(v8, 1, 0);
            LOBYTE(dword_18059C) = dword_18059C & 0xFE;
          }
          else if ( dword_18059C & 2 )
          {
            sub_18DA0(v8, 2, 0);
            LOBYTE(dword_18059C) = dword_18059C & 0xFD;
          }
        }
        else
        {
          if ( byte_1806E4 == 26 )
          {
            if ( !*(_BYTE *)(v5 + 8592) )
            {
              v9 = *(_BYTE *)(v5 + 8589);
              if ( v9 < 40 )
              {
                *(_BYTE *)(v5 + 8589) = v9 + 1;
                sub_2CA90((char)(v9 + 1));
              }
            }
            byte_1806E4 = 0;
          }
          if ( byte_1806E4 == 27 )
          {
            if ( !*(_BYTE *)(dword_D41A0 + 8592) )
            {
              v10 = *(_BYTE *)(dword_D41A0 + 8589);
              if ( v10 > 17 )
              {
                *(_BYTE *)(dword_D41A0 + 8589) = v10 - 1;
                sub_2CA90((char)(v10 - 1));
              }
            }
            byte_1806E4 = 0;
          }
          switch ( byte_1806E4 )
          {
            case 23:
              if ( !(*(_BYTE *)(dword_D41A4 + 25) & 2) )
              {
                v11 = *(_BYTE *)(v8 + 69);
                if ( v11 != 2 && v11 != 3 )
                  sub_191B0(16, 0);
              }
              byte_1806E4 = 0;
              goto LABEL_296;
            case 1:
              sub_18B30();
              byte_1806E4 = 0;
              LOBYTE(v3) = sub_1A7A0();
              goto LABEL_306;
            case 57:
              sub_191B0(15, 0);
              byte_1806E4 = 0;
              break;
          }
          if ( dword_18059C & 1 && dword_18059C & 2 )
          {
            if ( *(_DWORD *)(v8 + 8) >= 0 )
              sub_191B0(20, 6);
            LOBYTE(dword_18059C) = dword_18059C & 0xFC;
          }
          if ( byte_1806E4 == byte_EB3A2 )
          {
            if ( *(_DWORD *)(v8 + 8) >= 0 )
              sub_191B0(20, 6);
            byte_1806E4 = 0;
          }
          if ( (unsigned __int8)byte_1806E4 >= 2u )
          {
            if ( (unsigned __int8)byte_1806E4 <= 9u )
            {
              sub_191B0(43, byte_1806E4 - 2);
              byte_1806E4 = 0;
            }
            else if ( byte_1806E4 == 32 )
            {
              sub_19A70();
              byte_1806E4 = 0;
            }
          }
          if ( !byte_180693 || *(_BYTE *)(dword_D41A4 + 38543) )
          {
            if ( byte_180696 && !*(_BYTE *)(dword_D41A4 + 38543) )
              sub_19CA0(2u);
          }
          else
          {
            sub_19CA0(1u);
          }
          sub_18F80(v8);
        }
        if ( byte_1806E4 && byte_E36DC[(unsigned __int8)byte_1806E4] == 8 )
        {
          sub_191B0(39, 1);
          byte_1806E4 = 0;
        }
        sub_1A8A0();
        sub_17060(dword_1805B0, dword_1805B4);
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_306;
      case 1:
        sub_17190();
        if ( (!(dword_18059C & 1) || !(dword_18059C & 2)) && byte_1806E4 != 28 )
          goto LABEL_296;
        byte_1806E4 = 0;
        LOBYTE(dword_18059C) = dword_18059C & 0xFC;
        sub_191B0(20, 0);
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_306;
      case 3:
        if ( !byte_1806E4 || (unsigned __int8)byte_1806E4 >= 0x80u )
          goto LABEL_216;
        if ( (unsigned __int8)byte_1806E4 < 0x1Cu )
        {
          if ( byte_1806E4 == 1 )
          {
            sub_191B0(18, 0);
            goto LABEL_215;
          }
          goto LABEL_206;
        }
        if ( (unsigned __int8)byte_1806E4 <= 0x1Cu )
        {
          sub_191B0(19, 0);
          goto LABEL_215;
        }
        if ( (unsigned __int8)byte_1806E4 < 0x3Bu )
          goto LABEL_206;
        if ( (unsigned __int8)byte_1806E4 <= 0x42u )
        {
          if ( byte_18068E || byte_18069A )
          {
            sub_191B0(35, byte_1806E4 - 59);
          }
          else if ( byte_1806E4 == 59 )
          {
            sub_18AA0();
          }
          byte_1806E4 = 0;
        }
        else
        {
          if ( byte_1806E4 != 67 )
          {
LABEL_206:
            v27 = byte_E36DC[(unsigned __int8)byte_1806E4];
            if ( (unsigned __int8)v27 >= 0x41u && (unsigned __int8)v27 <= 0x5Au
              || (unsigned __int8)v27 >= 0x61u && (unsigned __int8)v27 <= 0x7Au
              || (unsigned __int8)v27 >= 0x30u && (unsigned __int8)v27 <= 0x39u
              || v27 == 8
              || v27 == 32 )
            {
              sub_191B0(17, byte_E36DC[(unsigned __int8)byte_1806E4]);
            }
            goto LABEL_215;
          }
          v25 = *(_BYTE *)(v4 + 12223) + 1;
          *(_BYTE *)(v4 + 12223) = v25;
          v26 = v25;
          if ( (signed int)v25 >= 4 )
            v26 = 0;
          sub_191B0(36, v26);
        }
LABEL_215:
        byte_1806E4 = 0;
LABEL_216:
        if ( word_180660 & 1 )
          v28 = 400;
        else
          v28 = 480;
        v29 = v28 - 72;
        if ( dword_1805B0 < 4 || dword_1805B0 >= 66 || v29 + 28 > dword_1805B4 || v29 + 66 <= dword_1805B4 )
        {
          if ( dword_1805B0 < 384 || dword_1805B0 >= 654 || v29 + 26 > dword_1805B4 || v29 + 48 <= dword_1805B4 )
          {
            if ( dword_1805B0 < 82 || dword_1805B0 >= 378 || v29 + 32 > dword_1805B4 || v29 + 60 <= dword_1805B4 )
            {
              if ( dword_1805B0 < 384 || dword_1805B0 >= 440 || v29 + 4 > dword_1805B4 || v29 + 22 <= dword_1805B4 )
              {
                if ( dword_1805B0 < 474 || dword_1805B0 >= 530 || v29 + 4 > dword_1805B4 || v29 + 22 <= dword_1805B4 )
                {
                  if ( dword_1805B0 >= 564
                    && dword_1805B0 < 620
                    && v29 + 4 <= dword_1805B4
                    && v29 + 22 > dword_1805B4
                    && dword_18059C & 1 )
                  {
                    sub_191B0(18, 0);
                  }
                }
                else if ( dword_18059C & 1 )
                {
                  sub_191B0(44, 0);
                }
              }
              else if ( dword_18059C & 1 )
              {
                sub_191B0(19, 0);
              }
              goto LABEL_292;
            }
            if ( dword_1805B0 < 82 || dword_1805B0 >= 150 || v29 + 32 > dword_1805B4 || v29 + 60 <= dword_1805B4 )
            {
              if ( dword_1805B0 >= 152 && dword_1805B0 < 220 && v29 + 32 <= dword_1805B4 && v29 + 60 > dword_1805B4 )
              {
                if ( *(_BYTE *)(dword_D41A4 + 10) )
                  byte_180559 = 99;
                if ( dword_18059C & 1 )
                  sub_191B0(36, 1);
                goto LABEL_292;
              }
              if ( dword_1805B0 >= 222 && dword_1805B0 < 290 && v29 + 32 <= dword_1805B4 && v29 + 60 > dword_1805B4 )
              {
                if ( *(_BYTE *)(dword_D41A4 + 10) )
                  byte_180559 = 100;
                if ( dword_18059C & 1 )
                  sub_191B0(36, 2);
                goto LABEL_292;
              }
              if ( dword_1805B0 < 310 || dword_1805B0 >= 378 || v29 + 32 > dword_1805B4 || v29 + 60 <= dword_1805B4 )
                goto LABEL_292;
              if ( *(_BYTE *)(dword_D41A4 + 10) )
                byte_180559 = 101;
              if ( !(dword_18059C & 1) )
                goto LABEL_292;
              v32 = 3;
            }
            else
            {
              if ( *(_BYTE *)(dword_D41A4 + 10) )
                byte_180559 = 98;
              if ( !(dword_18059C & 1) )
                goto LABEL_292;
              v32 = 0;
            }
            sub_191B0(36, v32);
            goto LABEL_292;
          }
          if ( *(_BYTE *)(dword_D41A4 + 10) )
            byte_180559 = 102;
          if ( dword_18059C & 1 )
          {
            v30 = (dword_1805B0 - 384) / 34;
            if ( v30 >= *(signed __int16 *)(dword_D41A0 + 12) )
              LOBYTE(v30) = v30 + 1;
            sub_191B0(37, v30);
          }
        }
        else
        {
          if ( *(_BYTE *)(dword_D41A4 + 10) )
            byte_180559 = 97;
          if ( dword_18059C & 1 )
            sub_191B0(
              35,
              4 * ((dword_1805B4 - (v29 + 28)) / 20)
            + ((dword_1805B0 - 4 - (__CFSHL__((dword_1805B0 - 4) >> 31, 4) + 16 * ((dword_1805B0 - 4) >> 31))) >> 4));
        }
LABEL_292:
        LOBYTE(dword_18059C) = dword_18059C & 0xFC;
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_306;
      case 5:
      case 8:
        v33 = 0;
        v34 = 0;
        v12 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
        LOBYTE(v13) = sub_17190();
        if ( *(_DWORD *)(v12 + 8) < 0 )
        {
          v33 = 1;
        }
        else
        {
          v15 = *(_DWORD *)(v12 + 164);
          _wcpp_1_unwind_leave__120(v13, v14, v15);
          v16 = *(_BYTE *)(v15 + 1111);
          a1 = (_BYTE *)(v15 + 611);
          if ( v16 )
          {
            if ( v16 <= 2u )
            {
              if ( (v16 != 1 || dword_18059C & 4) && (a1[500] != 2 || dword_18059C & 8) )
              {
                v23 = sub_6D4F0((int)a1, dword_1805B0);
                a1[502] = v23;
                sub_191B0(41, v23);
              }
              else
              {
                if ( a1[500] == 1 )
                  *(_BYTE *)(dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12) + 28222) = 31;
                else
                  *(_BYTE *)(dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12) + 28222) = 32;
                v22 = dword_D41A0;
                *(_BYTE *)(dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12) + 28223) = a1[501];
                *(_BYTE *)(v22 + 10 * *(signed __int16 *)(v22 + 12) + 28224) = a1[502];
                a1[500] = 0;
                sub_6D200(v22 + 11230 + 2124 * *(signed __int16 *)(v22 + 12));
              }
            }
          }
          else
          {
            v34 = 1;
            v17 = sub_6D420(dword_1805B0, dword_1805B4);
            a1[501] = v17;
            v18 = (unsigned __int8)byte_D94FF[v17];
            v19 = 1;
            if ( !*(_WORD *)&a1[2 * v18 + 208] || !byte_D41B6 && v18 == 25 )
              v19 = 0;
            if ( !v19 )
              goto LABEL_122;
            sub_6D4C0((int)a1);
            if ( !(dword_18059C & 1) && !(dword_18059C & 2) )
              goto LABEL_122;
            if ( byte_18068E || byte_180664[(unsigned __int8)byte_EB3A5] )
            {
              sub_191B0(38, v18);
              v20 = dword_D41A0;
              *(_BYTE *)(dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12) + 28224) = 0;
              v21 = a1[v18 + 338];
              if ( v21 )
              {
                if ( dword_18059C & 1 )
                {
                  if ( v21 != 1 )
                    *(_BYTE *)(v20 + 10 * *(signed __int16 *)(v20 + 12) + 28224) = 1;
                  goto LABEL_122;
                }
                if ( v21 == 2 )
                  goto LABEL_122;
              }
              else if ( dword_18059C & 1 )
              {
                *(_BYTE *)(v20 + 10 * *(signed __int16 *)(v20 + 12) + 28224) = 1;
                goto LABEL_122;
              }
              *(_BYTE *)(v20 + 10 * *(signed __int16 *)(v20 + 12) + 28224) = 2;
              goto LABEL_122;
            }
            if ( dword_18059C & 1 && dword_18059C & 2 )
            {
              sub_191B0(6, 64);
              *(_BYTE *)(10 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 28223) = a1[501];
            }
            else
            {
              a1[500] = ((dword_18059C & 1) == 0) + 1;
              sub_6D200(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230);
              sub_191B0(40, a1[501]);
              *(_BYTE *)(10 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 28224) = a1[500];
            }
          }
        }
LABEL_122:
        if ( !(dword_18059C & 0x10) && !(dword_18059C & 4) && !(dword_18059C & 8) )
          v33 = 1;
        if ( v33 )
        {
          if ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) == 5 )
            sub_191B0(20, 0);
          else
            sub_191B0(20, 6);
        }
        else
        {
          if ( *(_DWORD *)(v12 + 8) >= 0 )
          {
            if ( word_1805C0 & 1 )
              sub_191B0(6, 1);
            if ( word_1805C0 & 2 )
              sub_191B0(6, 2);
            if ( word_1805C0 & 4 )
              sub_191B0(6, 4);
            if ( word_1805C0 & 8 )
              sub_191B0(6, 8);
          }
          if ( *(_BYTE *)(dword_D41A4 + 22) & 2
            && v34
            && !*(_BYTE *)(dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12) + 28222) )
          {
            sub_191B0(40, a1[501]);
            *(_BYTE *)(dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12) + 28224) = 0;
          }
        }
        sub_17060(*(_WORD *)(*(_DWORD *)(v12 + 164) + 20), *(_WORD *)(*(_DWORD *)(v12 + 164) + 22));
        byte_1806E4 = 0;
        LOBYTE(dword_18059C) = dword_18059C & 0xFC;
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_306;
      case 6:
      case 7:
        v24 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
        if ( *(_BYTE *)(dword_D41A4 + 24) & 1 )
          sub_197F0();
        sub_17190();
        if ( dword_18059C & 1 && dword_18059C & 2 || byte_1806E4 == byte_EB3A2 || *(_DWORD *)(v24 + 8) < 0 )
        {
          sub_191B0(20, 0);
        }
        else if ( byte_1806E4 == 1 )
        {
          sub_18B30();
          byte_1806E4 = 0;
        }
        else
        {
          if ( dword_18059C & 0x10 )
          {
            sub_191B0(20, 8);
          }
          else if ( byte_18069C || byte_180664[(unsigned __int8)byte_EB3A7] || byte_180664[(unsigned __int8)byte_EB3A4] )
          {
            if ( dword_18059C & 1 )
            {
              sub_18DA0(v24, 1, 1);
              LOBYTE(dword_18059C) = dword_18059C & 0xFE;
            }
            else if ( dword_18059C & 2 )
            {
              sub_18DA0(v24, 2, 1);
              LOBYTE(dword_18059C) = dword_18059C & 0xFD;
            }
            else if ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) != 7 )
            {
              sub_191B0(20, 7);
            }
          }
          else if ( byte_18068E || byte_180664[(unsigned __int8)byte_EB3A6] )
          {
            if ( dword_18059C & 1 )
            {
              sub_18DA0(v24, 1, 0);
              LOBYTE(dword_18059C) = dword_18059C & 0xFE;
            }
            else if ( dword_18059C & 2 )
            {
              sub_18DA0(v24, 2, 0);
              LOBYTE(dword_18059C) = dword_18059C & 0xFD;
            }
          }
          else if ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) != 6 )
          {
            sub_191B0(20, 6);
          }
          sub_18F80(v24);
        }
        if ( byte_1806E4 == 32 )
        {
          sub_19A70();
          byte_1806E4 = 0;
        }
        if ( !byte_180693 || *(_BYTE *)(dword_D41A4 + 38543) )
        {
          if ( byte_180696 && !*(_BYTE *)(dword_D41A4 + 38543) )
            sub_19CA0(2u);
        }
        else
        {
          sub_19CA0(1u);
        }
        if ( byte_1806E4 && byte_E36DC[(unsigned __int8)byte_1806E4] == 8 )
        {
          sub_191B0(39, 1);
          byte_1806E4 = 0;
        }
        sub_1A8A0();
        sub_17060(dword_1805B0, dword_1805B4);
        byte_1806E4 = 0;
        LOBYTE(dword_18059C) = dword_18059C & 0xFC;
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_306;
      case 9:
      case 0xB:
        sub_19AB0();
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_306;
      case 0xA:
      case 0xC:
        sub_1A070(a2, a3);
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_306;
      case 0xD:
      case 0xE:
        sub_19E00();
        goto LABEL_296;
      default:
LABEL_296:
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_306;
    }
  }
  if ( byte_1806E4 )
  {
    LOBYTE(v3) = byte_1806E4;
    if ( (unsigned __int8)byte_1806E4 >= 1u )
    {
      if ( (unsigned __int8)byte_1806E4 <= 1u )
      {
        LOBYTE(v3) = sub_18B30();
      }
      else if ( byte_1806E4 == 25 )
      {
        LOBYTE(v3) = dword_D41A4;
        if ( !(*(_BYTE *)(dword_D41A4 + 22) & 0x10) )
          LOBYTE(v3) = sub_18BB0();
      }
    }
    byte_1806E4 = 0;
  }
LABEL_306:
  if ( !(dword_18059C & 1) )
    word_180746 = 0;
  if ( !(dword_18059C & 2) )
    word_180744 = 0;
  return v3;
}
// 6D5D0: using guessed type int __fastcall _wcpp_1_unwind_leave__120(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB3A2: using guessed type char byte_EB3A2;
// EB3A4: using guessed type char byte_EB3A4;
// EB3A5: using guessed type char byte_EB3A5;
// EB3A6: using guessed type char byte_EB3A6;
// EB3A7: using guessed type char byte_EB3A7;
// 180559: using guessed type char byte_180559;
// 18059C: using guessed type int dword_18059C;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C0: using guessed type __int16 word_1805C0;
// 180660: using guessed type __int16 word_180660;
// 18068E: using guessed type char byte_18068E;
// 180693: using guessed type char byte_180693;
// 180696: using guessed type char byte_180696;
// 18069A: using guessed type char byte_18069A;
// 18069C: using guessed type char byte_18069C;
// 1806E4: using guessed type char byte_1806E4;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;

//----- (00018AA0) --------------------------------------------------------
int sub_18AA0()
{
  int result; // eax
  char v1; // bl
  char v2; // bh

  result = dword_D41A4;
  v1 = 1;
  if ( *(_BYTE *)(dword_D41A4 + 10) )
  {
    *(_BYTE *)(dword_D41A4 + 10) = 0;
  }
  else
  {
    sub_87090();
    if ( byte_180552 )
    {
      result = dword_D41A4;
      *(_BYTE *)(dword_D41A4 + 10) = 1;
    }
    else
    {
      v1 = 0;
      result = sub_19760(aNoHelpData, 3u, 50);
    }
  }
  if ( v1 )
  {
    byte_18055A = -1;
    v2 = *(_BYTE *)(dword_D41A4 + 10);
    *(_BYTE *)(dword_D41A4 + 38402) = 1;
    result = sub_19760((char *)dword_E9C4C[(v2 == 0) + 400], 3u, 50);
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// 180552: using guessed type char byte_180552;
// 18055A: using guessed type char byte_18055A;

//----- (00018B30) --------------------------------------------------------
char sub_18B30()
{
  int v0; // eax
  unsigned __int8 v1; // dh

  v0 = 2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0;
  if ( !(*(_BYTE *)(v0 + 11232) & 0x20) )
  {
    v1 = *(_BYTE *)(v0 + 12221);
    if ( v1 != 13 && v1 != 14 )
    {
      if ( v1 < 6u || v1 > 8u && (v1 < 0xBu || v1 > 0xCu) )
        sub_191B0(20, 13);
      else
        sub_191B0(20, 14);
      LOBYTE(v0) = dword_D41A4;
      *(_BYTE *)(dword_D41A4 + 38546) = 1;
    }
    else
    {
      sub_191B0(29, 0);
      LOBYTE(v0) = sub_191B0(27, 0);
    }
  }
  return v0;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00018BB0) --------------------------------------------------------
int sub_18BB0()
{
  int v0; // eax
  char v1; // dl
  char v2; // cl
  int v3; // eax
  int v4; // edx
  int result; // eax

  v0 = dword_D41A4;
  v1 = *(_BYTE *)(dword_D41A4 + 24) ^ 1;
  *(_BYTE *)(dword_D41A4 + 24) = v1;
  if ( v1 & 1 )
  {
    if ( *((_BYTE *)&loc_36E09 + dword_D41A0 + 2) & 2 )
    {
      *(_BYTE *)(v0 + 24) &= 0xFEu;
    }
    else
    {
      *((_BYTE *)&loc_36E03 + dword_D41A0 + 1) = 0;
      v2 = *(_BYTE *)(v0 + 206);
      byte_18055A = -1;
      if ( !v2 && (word_1805C2 == 7 || word_1805C2 == 1 || word_1805C2 == 2) )
        sub_8CD27(dword_EB394 + 6 * (unsigned __int8)byte_D419E);
      sub_41AF0();
      if ( !*(_BYTE *)(dword_D41A4 + 206) )
        sub_8CD27(dword_EB394 + 6 * (unsigned __int8)byte_D419E);
      sub_52E90(
        2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230,
        *(unsigned __int8 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221),
        1);
      if ( byte_E3799 )
        sub_8D8F0();
      if ( byte_E37FD )
        sub_8E020();
      if ( *(_BYTE *)(dword_D41A4 + 225) )
        *(_BYTE *)(dword_D41A4 + 225) = 2;
    }
  }
  else
  {
    sub_41B60();
    v3 = dword_D41A4;
    v4 = dword_EB394;
    *(_BYTE *)(dword_D41A4 + 205) = 0;
    *(_BYTE *)(v3 + 206) = 0;
    sub_8CD27(v4);
    sub_52E90(
      2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230,
      *(unsigned __int8 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221),
      1);
    if ( byte_E37FD )
      sub_8E160(*(_WORD *)(dword_D41A0 + 565), 0x7Fu);
    sub_86930(word_1803EC);
    if ( *(_BYTE *)(dword_D41A4 + 225) )
      *(_BYTE *)(dword_D41A4 + 225) = 1;
  }
  LOBYTE(result) = sub_55C00(*(_WORD *)(dword_D41A4 + 43));
  *(_BYTE *)(dword_D41A4 + 208) = result;
  return result;
}
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E3799: using guessed type char byte_E3799;
// E37FD: using guessed type char byte_E37FD;
// EB394: using guessed type int dword_EB394;
// 1803EC: using guessed type __int16 word_1803EC;
// 18055A: using guessed type char byte_18055A;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (00018DA0) --------------------------------------------------------
char __cdecl sub_18DA0(int a1, char a2, char a3)
{
  int v3; // edx
  signed int v4; // esi
  signed int v5; // eax
  int v6; // eax
  int v7; // ebx
  int v8; // edi
  int v9; // edx
  signed int v10; // ebx
  signed int v11; // esi
  signed int v12; // eax
  int v13; // ebx
  int v14; // edi
  int v15; // edx
  signed int v16; // ebx

  v3 = *(_DWORD *)(a1 + 164) + 611;
  if ( a2 == 2 )
  {
    v4 = 0;
    if ( a3 )
      v5 = -1;
    else
      v5 = 1;
    v6 = *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 1107) + v5;
    while ( 1 )
    {
      if ( a3 || v6 < 26 )
      {
        if ( a3 == 1 && v6 < 0 )
          v6 = 25;
      }
      else
      {
        v6 = 0;
      }
      v7 = (unsigned __int8)byte_D94FF[v6];
      if ( *(_WORD *)(v3 + 2 * v7 + 208) )
      {
        v8 = v3 + v7;
        if ( *(_BYTE *)(v3 + v7 + 338) == 2 )
          break;
      }
      if ( a3 )
        v10 = -1;
      else
        v10 = 1;
      ++v4;
      v6 += v10;
      if ( v4 >= 26 )
        return v6;
    }
    *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1115) = v6;
    v9 = dword_D41A0;
    *(_BYTE *)(dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12) + 28222) = 32;
    *(_BYTE *)(v9 + 10 * *(signed __int16 *)(v9 + 12) + 28223) = v7;
    LOBYTE(v6) = *(_BYTE *)(v8 + 468);
    *(_BYTE *)(10 * *(signed __int16 *)(v9 + 12) + v9 + 28224) = v6;
  }
  else
  {
    v11 = 0;
    if ( a3 )
      v12 = -1;
    else
      v12 = 1;
    v6 = *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 1105) + v12;
    while ( 1 )
    {
      if ( a3 || v6 < 26 )
      {
        if ( a3 == 1 && v6 < 0 )
          v6 = 25;
      }
      else
      {
        v6 = 0;
      }
      v13 = (unsigned __int8)byte_D94FF[v6];
      if ( *(_WORD *)(v3 + 2 * v13 + 208) )
      {
        v14 = v3 + v13;
        if ( *(_BYTE *)(v3 + v13 + 338) == 1 )
          break;
      }
      if ( a3 )
        v16 = -1;
      else
        v16 = 1;
      ++v11;
      v6 += v16;
      if ( v11 >= 26 )
        return v6;
    }
    *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1114) = v6;
    v15 = dword_D41A0;
    *(_BYTE *)(dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12) + 28222) = 31;
    *(_BYTE *)(v15 + 10 * *(signed __int16 *)(v15 + 12) + 28223) = v13;
    LOBYTE(v6) = *(_BYTE *)(v14 + 468);
    *(_BYTE *)(10 * *(signed __int16 *)(v15 + 12) + v15 + 28224) = v6;
  }
  return v6;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00018F80) --------------------------------------------------------
char __cdecl sub_18F80(int a1)
{
  int v1; // eax
  int v2; // edx
  int v3; // eax
  int v4; // eax
  int v5; // edx

  if ( word_1805C0 & 1 )
    sub_191B0(6, 1);
  if ( word_1805C0 & 2 )
    sub_191B0(6, 2);
  if ( word_1805C0 & 4 )
    sub_191B0(6, 4);
  if ( word_1805C0 & 8 )
    sub_191B0(6, 8);
  v1 = *(_DWORD *)(a1 + 164);
  v2 = *(signed __int16 *)(v1 + 1105);
  if ( v2 == -1 )
  {
    LOBYTE(dword_18059C) = dword_18059C & 0xFE;
  }
  else
  {
    v3 = dword_EA3E4[*(signed __int16 *)(v1 + 2 * v2 + 819)];
    if ( *(_BYTE *)(v3 + 59) == 1 )
    {
      if ( dword_18059C & 1 )
      {
        sub_191B0(6, 16);
        LOBYTE(dword_18059C) = dword_18059C & 0xFE;
      }
    }
    else if ( dword_18059C & 1 || dword_18059C & 4 && *(_WORD *)(v3 + 46) > 0 )
    {
      sub_191B0(6, 16);
      LOBYTE(dword_18059C) = dword_18059C & 0xFE;
    }
  }
  v4 = *(_DWORD *)(a1 + 164);
  v5 = *(signed __int16 *)(v4 + 1107);
  if ( v5 == -1 )
  {
    LOBYTE(dword_18059C) = dword_18059C & 0xFD;
  }
  else
  {
    v4 = dword_EA3E4[*(signed __int16 *)(v4 + 2 * v5 + 819)];
    if ( *(_BYTE *)(v4 + 59) == 1 )
    {
      if ( dword_18059C & 2 )
      {
        LOBYTE(v4) = sub_191B0(6, 32);
        LOBYTE(dword_18059C) = dword_18059C & 0xFD;
      }
    }
    else if ( dword_18059C & 2 || dword_18059C & 8 && *(_WORD *)(v4 + 46) > 0 )
    {
      LOBYTE(v4) = sub_191B0(6, 32);
      LOBYTE(dword_18059C) = dword_18059C & 0xFD;
    }
  }
  return v4;
}
// EA3E4: using guessed type int dword_EA3E4[];
// 18059C: using guessed type int dword_18059C;
// 1805C0: using guessed type __int16 word_1805C0;

//----- (000191B0) --------------------------------------------------------
char __cdecl sub_191B0(__int16 a1, char a2)
{
  int v2; // edx
  char result; // al
  int v4; // esi
  int v5; // ecx
  int v6; // ebx
  int v7; // ecx
  int v8; // ebx
  int v9; // esi
  int v10; // ebx
  int v11; // ebx
  int v12; // esi
  int v13; // ecx
  int v14; // esi
  int v15; // esi
  _BYTE *v16; // ebx
  int v17; // ebx
  int v18; // ebx

  v2 = dword_D41A0;
  result = a1;
  switch ( a1 )
  {
    case 0:
    case 1:
    case 2:
    case 26:
      goto LABEL_23;
    case 3:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      goto LABEL_40;
    case 4:
      v4 = dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12);
      if ( *(char *)(v4 + 28222) != a1 && *(_BYTE *)(v4 + 28222) )
        goto LABEL_40;
      v5 = dword_D41A0;
      *(_BYTE *)(dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12) + 28222) = a1;
      result = a2;
      *(_BYTE *)(v5 + 10 * *(signed __int16 *)(v2 + 12) + 28223) |= a2;
      dword_D41A0 = v2;
      return result;
    case 5:
    case 6:
      v6 = dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12);
      if ( *(char *)(v6 + 28222) != a1 && *(_BYTE *)(v6 + 28222) )
        goto LABEL_40;
      v7 = dword_D41A0;
      *(_BYTE *)(dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12) + 28222) = a1;
      result = a2;
      *(_BYTE *)(v7 + 10 * *(signed __int16 *)(v2 + 12) + 28227) |= a2;
      dword_D41A0 = v2;
      return result;
    case 12:
    case 13:
    case 14:
    case 16:
    case 18:
    case 19:
    case 29:
    case 42:
    case 44:
      v15 = dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12);
      if ( *(char *)(v15 + 28222) != a1 && *(_BYTE *)(v15 + 28222) )
        goto LABEL_40;
LABEL_23:
      *(_BYTE *)(dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12) + 28222) = a1;
      dword_D41A0 = v2;
      return result;
    case 15:
      v8 = dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12);
      if ( *(char *)(v8 + 28222) != a1 && *(_BYTE *)(v8 + 28222) )
        goto LABEL_40;
      v9 = *(signed __int16 *)(dword_D41A0 + 12);
      v10 = dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 2124 * v9 + 11240)];
      if ( *(_DWORD *)(v10 + 8) >= 0 || *(_BYTE *)(v10 + 69) != 3 )
        goto LABEL_40;
      *(_BYTE *)(dword_D41A0 + 10 * v9 + 28222) = a1;
      dword_D41A0 = v2;
      return result;
    case 27:
      v11 = dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12);
      if ( *(char *)(v11 + 28222) != a1 && *(_BYTE *)(v11 + 28222) )
        goto LABEL_40;
      v12 = *(signed __int16 *)(dword_D41A0 + 12);
      if ( !(*(_BYTE *)(dword_D41A0 + 2124 * v12 + 11232) & 2) )
        goto LABEL_40;
      *(_BYTE *)(dword_D41A0 + 10 * v12 + 28222) = a1;
      dword_D41A0 = v2;
      return result;
    case 28:
      v13 = dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12);
      if ( *(char *)(v13 + 28222) != a1 && *(_BYTE *)(v13 + 28222) )
        goto LABEL_40;
      v14 = *(signed __int16 *)(dword_D41A0 + 12);
      if ( !(*(_BYTE *)(dword_D41A0 + 2124 * v14 + 11232) & 4) )
        goto LABEL_40;
      *(_BYTE *)(dword_D41A0 + 10 * v14 + 28222) = a1;
      dword_D41A0 = v2;
      return result;
    case 30:
      if ( *(_BYTE *)(dword_D41A4 + 23) < 0
        || (v16 = (_BYTE *)(dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12)), v16[12157] == 99)
        && v16[12158] == 104
        && v16[12159] == 114
        && v16[12160] == 111
        && v16[12161] == 110
        && v16[12162] == 105
        && v16[12163] == 99
        && v16[12164] == 108
        && v16[12165] == 101 )
      {
        v17 = dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12);
        if ( *(char *)(v17 + 28222) == a1 || !*(_BYTE *)(v17 + 28222) )
          goto LABEL_39;
      }
      goto LABEL_40;
    case 39:
      goto LABEL_39;
    default:
      v18 = dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12);
      if ( *(char *)(v18 + 28222) == a1 || !*(_BYTE *)(v18 + 28222) )
      {
LABEL_39:
        *(_BYTE *)(dword_D41A0 + 10 * *(signed __int16 *)(dword_D41A0 + 12) + 28222) = a1;
        result = a2;
        *(_BYTE *)(v2 + 10 * *(signed __int16 *)(v2 + 12) + 28223) = a2;
      }
LABEL_40:
      dword_D41A0 = v2;
      return result;
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00019760) --------------------------------------------------------
int __cdecl sub_19760(char *a1, unsigned __int8 a2, __int16 a3)
{
  char *v3; // esi
  char *v4; // edi
  char v5; // al
  char v6; // al
  int result; // eax

  v3 = a1;
  v4 = (char *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230 + 28);
  do
  {
    v5 = *v3;
    *v4 = *v3;
    if ( !v5 )
      break;
    v6 = v3[1];
    v3 += 2;
    v4[1] = v6;
    v4 += 2;
  }
  while ( v6 );
  result = dword_D41A0;
  *(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11307) = a3;
  *(_WORD *)(2124 * *(signed __int16 *)(result + 12) + result + 11309) = a2;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (000197F0) --------------------------------------------------------
int sub_197F0()
{
  int result; // eax
  char v1; // bl
  signed int v2; // ebx
  signed int v3; // edx
  unsigned __int8 v4; // al
  unsigned __int8 v5; // al
  int v6; // [esp+0h] [ebp-10h]
  int v7; // [esp+4h] [ebp-Ch]
  int v8; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  result = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 24) & 1 )
  {
    v1 = *(_BYTE *)(dword_D41A4 + 225);
    byte_18055A = -1;
    if ( !v1 && !*(_BYTE *)(dword_D41A4 + 38543) )
    {
      if ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) == 7 )
      {
        sub_8CD27(dword_EB394);
      }
      else if ( word_1805C2 == 7 || word_1805C2 == 1 || word_1805C2 == 2 )
      {
        sub_8CD27(dword_EB394 + 6 * (unsigned __int8)byte_D419E);
      }
      if ( !*(_BYTE *)(dword_D41A4 + 206) )
      {
        sub_2FFE0(&v8, &v9, &v6, &v7);
        if ( dword_1805B0 >= v8 && v8 + v6 > dword_1805B0 )
        {
          v2 = -1;
          v3 = 0;
          while ( v3 < 4 && v2 < 0 )
          {
            if ( v9 <= dword_1805B4 && v9 + v7 > dword_1805B4 )
              v2 = v3;
            ++v3;
            v9 += v7;
          }
          if ( v2 >= 0 )
          {
            if ( v2 != 2 || v8 + v6 / 2 > dword_1805B0 )
            {
              if ( v2 > 2 )
                ++v2;
            }
            else
            {
              v2 = 3;
            }
            byte_18055A = v2;
            if ( dword_18059C & 1 || dword_18059C & 2 )
            {
              switch ( v2 )
              {
                case 0:
                  v4 = *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221);
                  if ( v4 < 6u || v4 > 8u )
                    sub_191B0(20, 13);
                  else
                    sub_191B0(20, 14);
                  *(_BYTE *)(dword_D41A4 + 38546) = 3;
                  return sub_19A50();
                case 1:
                  if ( !*(_BYTE *)(dword_D41A4 + 208) )
                    break;
                  v5 = *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221);
                  if ( v5 < 6u || v5 > 8u )
                    sub_191B0(20, 13);
                  else
                    sub_191B0(20, 14);
                  *(_BYTE *)(dword_D41A4 + 38546) = 2;
                  return sub_19A50();
                case 2:
                  sub_19CA0(1u);
                  return sub_19A50();
                case 3:
                  sub_19CA0(2u);
                  return sub_19A50();
                case 4:
                  sub_19A70();
                  break;
                default:
                  break;
              }
            }
          }
        }
      }
      result = sub_19A50();
    }
  }
  return result;
}
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EB394: using guessed type int dword_EB394;
// 18055A: using guessed type char byte_18055A;
// 18059C: using guessed type int dword_18059C;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (00019A50) --------------------------------------------------------
__int64 sub_19A50()
{
  __int64 result; // rax

  BYTE1(result) = dword_18059C;
  if ( dword_18059C & 1 || dword_18059C & 2 )
    LOBYTE(dword_18059C) = dword_18059C & 0xFC;
  return result;
}
// 18059C: using guessed type int dword_18059C;

//----- (00019A70) --------------------------------------------------------
char sub_19A70()
{
  unsigned __int8 v0; // al
  char result; // al

  v0 = *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221);
  if ( v0 < 6u || v0 > 8u )
    result = sub_191B0(20, 9);
  else
    result = sub_191B0(20, 11);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00019AB0) --------------------------------------------------------
__int64 sub_19AB0()
{
  int v0; // eax
  signed int v1; // ebx
  int v2; // edx
  signed int v3; // eax

  if ( word_1805C2 == 7 || word_1805C2 == 1 || word_1805C2 == 2 )
    sub_8CD27(dword_EB394 + 6 * (unsigned __int8)byte_D419E);
  if ( byte_1806E4 == 1 )
  {
    sub_18B30();
    byte_1806E4 = 0;
    return sub_19A50();
  }
  if ( !(dword_18059C & 1) && !(dword_18059C & 2) && byte_1806E4 != 28 && byte_1806E4 != 32 )
    return sub_19A50();
  v0 = (640 - *(signed __int16 *)(dword_D41A4 + 186)) / 2 + (*(signed __int16 *)(dword_D41A4 + 186) - 82) / 2;
  if ( v0 <= dword_1805B0 && v0 + 82 > dword_1805B0 && dword_1805B4 >= 377 && dword_1805B4 < 395
    || byte_1806E4 == 28
    || byte_1806E4 == 32 )
  {
    *(_BYTE *)(dword_D41A4 + 225) = 0;
    if ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) == 9 )
      sub_191B0(20, 0);
    else
      sub_191B0(20, 6);
    sub_8CD27(dword_EB394);
    byte_1806E4 = 0;
    return sub_19A50();
  }
  v1 = 0;
  v2 = (640 - *(signed __int16 *)(dword_D41A4 + 186)) / 2;
  v3 = 67;
  do
  {
    if ( v2 <= dword_1805B0
      && v2 + *(signed __int16 *)(dword_D41A4 + 186) > dword_1805B0
      && v3 <= dword_1805B4
      && v3 + 18 > dword_1805B4 )
    {
      sub_1A970(v1 + 1, (dword_18059C & 1) == 0, 1);
      sub_1A280();
      return sub_19A50();
    }
    ++v1;
    v3 += 18;
  }
  while ( v1 < 17 );
  return sub_19A50();
}
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EB394: using guessed type int dword_EB394;
// 18059C: using guessed type int dword_18059C;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;
// 1806E4: using guessed type char byte_1806E4;

//----- (00019CA0) --------------------------------------------------------
void __cdecl sub_19CA0(unsigned __int8 a1)
{
  __int16 v1; // ST00_2
  int v2; // edx
  int v3; // eax
  unsigned __int8 v4; // al

  if ( a1 >= 1u )
  {
    if ( a1 <= 1u )
    {
      if ( byte_E3798 )
      {
        *(_BYTE *)(dword_D41A4 + 38543) = a1;
        byte_E3799 = 1;
      }
    }
    else if ( a1 == 2 && byte_E37FC )
    {
      *(_BYTE *)(dword_D41A4 + 38543) = 2;
      v1 = *(_WORD *)(dword_D41A0 + 565);
      byte_E37FD = 1;
      sub_8E160(v1, 0x7Fu);
    }
  }
  v2 = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 38543) )
  {
    v3 = dword_D41A0;
    *((_BYTE *)&loc_36E03 + dword_D41A0 + 1) = 0;
    *(_BYTE *)(v2 + 38402) = 1;
    v4 = *(_BYTE *)(2124 * *(signed __int16 *)(v3 + 12) + v3 + 12221);
    if ( v4 < 6u || v4 > 8u )
      sub_191B0(20, 10);
    else
      sub_191B0(20, 12);
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;

//----- (00019D60) --------------------------------------------------------
int __usercall sub_19D60@<eax>(signed int a1@<ebx>, int a2@<esi>)
{
  unsigned __int8 v2; // dl
  int v4; // [esp+0h] [ebp-10h]
  int v5; // [esp+4h] [ebp-Ch]
  int v6; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  v2 = *(_BYTE *)(dword_D41A4 + 38543);
  if ( v2 >= 1u )
  {
    if ( v2 <= 1u )
    {
      a1 = 127;
      a2 = *(signed __int16 *)(dword_D41A4 + 6);
    }
    else if ( v2 == 2 )
    {
      a1 = 127;
      a2 = *(signed __int16 *)(dword_D41A4 + 8);
    }
  }
  sub_2FFE0(&v7, &v6, &v5, &v4);
  return sub_5BDC0((unsigned int)(a2 * (v5 - 12) / a1) + 5 + v7, 9 * v4 / 2 + v6);
}
// D41A4: using guessed type int dword_D41A4;

//----- (00019E00) --------------------------------------------------------
char sub_19E00()
{
  char v0; // bl
  char v1; // bh
  int v2; // eax
  unsigned __int8 v3; // dl
  char v5; // [esp+0h] [ebp-Ah]
  int v6; // [esp+80h] [ebp+76h]
  int v7; // [esp+84h] [ebp+7Ah]
  char v8; // [esp+88h] [ebp+7Eh]

  v0 = 0;
  v8 = 0;
  v1 = 0;
  LOBYTE(v2) = (unsigned int)sub_30BE0(&v7, &v6);
  if ( byte_1806E4 )
  {
    LOBYTE(v2) = byte_1806E4;
    if ( (unsigned __int8)byte_1806E4 >= 1u )
    {
      if ( (unsigned __int8)byte_1806E4 <= 1u )
      {
        v8 = 1;
      }
      else if ( byte_1806E4 == 28 )
      {
        v0 = 1;
      }
    }
    byte_1806E4 = 0;
  }
  else if ( dword_18059C & 1 || dword_18059C & 2 )
  {
    if ( v7 > dword_1805B0 || v7 + 50 <= dword_1805B0 || v6 > dword_1805B4 || v6 + 32 <= dword_1805B4 )
    {
      if ( v7 + 50 <= dword_1805B0 && v7 + 100 > dword_1805B0 && v6 <= dword_1805B4 && v6 + 32 > dword_1805B4 )
        v8 = 1;
    }
    else
    {
      v0 = 1;
    }
    LOBYTE(v2) = sub_19A50();
  }
  if ( !v0 )
    goto LABEL_37;
  LOBYTE(v2) = dword_D41A4;
  v3 = *(_BYTE *)(dword_D41A4 + 38546);
  if ( v3 >= 2u )
  {
    if ( v3 > 2u )
    {
      if ( v3 == 3 )
      {
        if ( sub_55080(0, *(unsigned __int16 *)(dword_D41A4 + 43)) )
          sprintf(&v5, aSS, dword_EA2EC, &aOk[1]);
        else
          sprintf(&v5, aSS, dword_EA2EC, dword_EA300);
        sub_52D70(0, &v5);
        LOBYTE(v2) = sub_55C00(*(_WORD *)(dword_D41A4 + 43));
        v1 = 1;
        *(_BYTE *)(dword_D41A4 + 208) = v2;
      }
      goto LABEL_38;
    }
    if ( *(_BYTE *)(dword_D41A4 + 208) )
    {
      if ( sub_555D0(0, *(unsigned __int16 *)(dword_D41A4 + 43)) )
        sprintf(&v5, aSS, dword_EA2E8, &aOk[1]);
      else
        sprintf(&v5, aSS, dword_EA2E8, dword_EA300);
      LOBYTE(v2) = sub_52D70(0, &v5);
    }
LABEL_37:
    v1 = 1;
    goto LABEL_38;
  }
  if ( v3 == 1 )
    LOBYTE(v2) = sub_18B30();
LABEL_38:
  if ( v0 || v8 )
  {
    v2 = dword_D41A4;
    *(_BYTE *)(dword_D41A4 + 38546) = 0;
    if ( v1 )
      LOBYTE(v2) = sub_191B0(20, *(_BYTE *)(v2 + 38544));
  }
  return v2;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;
// EA2E8: using guessed type int dword_EA2E8;
// EA2EC: using guessed type int dword_EA2EC;
// EA300: using guessed type int dword_EA300;
// 18059C: using guessed type int dword_18059C;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1806E4: using guessed type char byte_1806E4;

//----- (0001A030) --------------------------------------------------------
int sub_1A030()
{
  int v1; // [esp+0h] [ebp-8h]
  int v2; // [esp+4h] [ebp-4h]

  sub_30BE0(&v2, &v1);
  return sub_5BDC0(v2 + 87, v1 + 24);
}

//----- (0001A070) --------------------------------------------------------
void __usercall sub_1A070(signed int a1@<edi>, __int16 a2@<si>)
{
  unsigned __int8 v2; // al
  int v3; // eax
  int v4; // edx
  int v5; // esi
  int v6; // ebx
  int v7; // eax
  int v8; // ett
  int v9; // ebx
  unsigned __int8 v10; // dl
  int v11; // eax
  int v12; // [esp+0h] [ebp-10h]
  int v13; // [esp+4h] [ebp-Ch]
  int v14; // [esp+8h] [ebp-8h]
  int v15; // [esp+Ch] [ebp-4h]

  if ( word_1805C2 == 7 || word_1805C2 == 1 || word_1805C2 == 2 )
    sub_8CD27(6 * (unsigned __int8)byte_D419E + dword_EB394);
  sub_2FFE0(&v15, &v14, &v13, &v12);
  v2 = *(_BYTE *)(dword_D41A4 + 38543);
  if ( v2 >= 1u )
  {
    if ( v2 <= 1u )
    {
      v3 = v13;
      v4 = v13;
    }
    else
    {
      if ( v2 != 2 )
        goto LABEL_12;
      v4 = 3 * v13;
      v3 = 3 * v13;
    }
    a1 = 127;
    a2 = (v3 - (__CFSHL__(v4 >> 31, 2) + 4 * (v4 >> 31))) >> 2;
  }
LABEL_12:
  if ( dword_18059C & 1 || dword_18059C & 2 || dword_18059C & 4 || dword_18059C & 8 || byte_180693 || byte_180696 )
  {
    v5 = v13 - 12;
    v6 = dword_1805B0 - (v15 + 4);
    if ( v6 < 0 )
      v6 = 0;
    if ( v6 > v5 )
      v6 = v13 - 12;
    v8 = a1 * v6;
    v7 = a1 * v6 / v5;
    v9 = a1 * v6 / v5;
    if ( v8 / v5 < 0 )
      v9 ^= v7;
    if ( v9 > 127 )
      v9 = 127;
    v10 = *(_BYTE *)(dword_D41A4 + 38543);
    if ( v10 >= 1u )
    {
      if ( v10 <= 1u )
      {
        sub_6E450(
          *(_WORD *)(dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12) + 11240),
          *(_WORD *)(dword_D41A0 + 12),
          8);
        sub_6E150();
        if ( *(signed __int16 *)(dword_D41A4 + 6) != v9 )
        {
          *(_WORD *)(dword_D41A4 + 6) = v9;
          sub_8E470((signed __int16)v9);
        }
      }
      else if ( v10 == 2 && *(signed __int16 *)(dword_D41A4 + 8) != v9 )
      {
        *(_WORD *)(dword_D41A4 + 8) = v9;
        sub_8E410((_DWORD *)(signed __int16)v9);
      }
    }
    sub_19A50();
  }
  else
  {
    v11 = dword_D41A4;
    *(_BYTE *)(dword_D41A4 + 38543) = byte_180693;
    sub_191B0(20, *(_BYTE *)(v11 + 38544));
    sub_8CD27(dword_EB394);
    sub_5BDC0(v15 + a2, v14 + 5 * v12 / 2);
    if ( *(_BYTE *)(dword_D41A4 + 24) & 1 )
    {
      sub_8D8F0();
      sub_8E020();
    }
  }
}
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EB394: using guessed type int dword_EB394;
// 18059C: using guessed type int dword_18059C;
// 1805B0: using guessed type int dword_1805B0;
// 1805C2: using guessed type __int16 word_1805C2;
// 180693: using guessed type char byte_180693;
// 180696: using guessed type char byte_180696;

//----- (0001A280) --------------------------------------------------------
int sub_1A280()
{
  int v0; // edx
  _BYTE *v1; // ebx
  char v2; // cl
  char v3; // ch
  char v4; // cl
  char v5; // ch
  int result; // eax

  v0 = dword_D41A4;
  v1 = (_BYTE *)dword_D41A0;
  *(_DWORD *)(dword_D41A4 + 192) = 0;
  v2 = *(_BYTE *)(v0 + 192) | 1;
  *(_BYTE *)(v0 + 192) = v2;
  if ( byte_E3798 )
    *(_BYTE *)(v0 + 192) = v2 | 2;
  if ( byte_E37FC )
    *(_BYTE *)(v0 + 192) |= 4u;
  if ( byte_E2A28 )
    *(_BYTE *)(v0 + 192) |= 8u;
  *(_BYTE *)(v0 + 192) |= 0xF0u;
  if ( v1[8618] )
    *(_BYTE *)(v0 + 193) |= 1u;
  if ( v1[8619] )
    *(_BYTE *)(v0 + 193) |= 4u;
  if ( v1[8620] )
    *(_BYTE *)(v0 + 193) |= 2u;
  if ( v1[8630] )
    *(_BYTE *)(v0 + 193) |= 8u;
  v3 = *(_BYTE *)(v0 + 193) | 0x10;
  *(_BYTE *)(v0 + 193) = v3;
  if ( v1[8632] )
    *(_BYTE *)(v0 + 193) = v3 | 0x20;
  if ( v1[8633] )
    *(_BYTE *)(v0 + 193) |= 0x40u;
  if ( v1[8628] )
    *(_BYTE *)(v0 + 193) |= 0x80u;
  *(_BYTE *)(v0 + 194) |= 1u;
  v4 = *(_BYTE *)(v0 + 10);
  *(_DWORD *)(v0 + 188) = 0;
  if ( v4 )
    *(_BYTE *)(v0 + 188) |= 1u;
  if ( byte_E3799 )
    *(_BYTE *)(v0 + 188) |= 2u;
  if ( byte_E37FD )
    *(_BYTE *)(v0 + 188) |= 4u;
  if ( *(_BYTE *)(v0 + 24) & 0x40 )
    *(_BYTE *)(v0 + 188) |= 8u;
  if ( v1[(_DWORD)&loc_36DE9 + 1] )
    *(_BYTE *)(v0 + 188) |= 0x10u;
  v5 = *(_BYTE *)(v0 + 188) | 0x20;
  *(_BYTE *)(v0 + 188) = v5;
  if ( *(_BYTE *)(v0 + 178) )
    *(_BYTE *)(v0 + 188) = v5 | 0x40;
  *(_BYTE *)(v0 + 188) |= 0x80u;
  if ( v1[8586] )
    *(_BYTE *)(v0 + 189) |= 1u;
  if ( v1[8587] )
    *(_BYTE *)(v0 + 189) |= 4u;
  if ( v1[8588] )
    *(_BYTE *)(v0 + 189) |= 2u;
  if ( v1[8598] )
    *(_BYTE *)(v0 + 189) |= 8u;
  if ( v1[8590] )
    *(_BYTE *)(v0 + 189) |= 0x10u;
  if ( v1[8600] )
    *(_BYTE *)(v0 + 189) |= 0x20u;
  if ( v1[8601] )
    *(_BYTE *)(v0 + 189) |= 0x40u;
  if ( v1[8596] )
    *(_BYTE *)(v0 + 189) |= 0x80u;
  result = v0;
  if ( !*(_BYTE *)(v0 + 207) )
    *(_BYTE *)(v0 + 190) |= 1u;
  dword_D41A0 = (int)v1;
  dword_D41A4 = v0;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E2A28: using guessed type char byte_E2A28;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;

//----- (0001A4A0) --------------------------------------------------------
int sub_1A4A0()
{
  int v0; // ebx
  signed int i; // esi
  unsigned int v2; // kr04_4
  unsigned int v3; // kr08_4
  int v5; // [esp+0h] [ebp-8h]
  int v6; // [esp+4h] [ebp-4h]

  v0 = 0;
  for ( i = 0; i < 17; ++i )
  {
    sub_1A5B0(i + 1, &v6, &v5);
    v2 = strlen((const char *)dword_E9C4C[v6]) + 1;
    if ( (signed int)(8 * (v2 - 1)) > v0 )
      v0 = 8 * (v2 - 1);
    v3 = strlen((const char *)dword_E9C4C[v5]) + 1;
    if ( (signed int)(8 * (v3 - 1)) > v0 )
      v0 = 8 * (v3 - 1);
  }
  return 6 * ((v0 - 11) / 6 + 1) + 16;
}

//----- (0001A5B0) --------------------------------------------------------
int __cdecl sub_1A5B0(int a1, int *a2, int *a3)
{
  int result; // eax

  result = (int)a2;
  switch ( a1 )
  {
    case 1:
      *a2 = 400;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
      goto LABEL_23;
    case 2:
      *a2 = 390;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
      goto LABEL_23;
    case 3:
      *a2 = 392;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
      goto LABEL_23;
    case 4:
      *a2 = 469;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
      goto LABEL_23;
    case 5:
      *a2 = 398;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
      goto LABEL_23;
    case 6:
      *a2 = 7;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
      goto LABEL_23;
    case 7:
      *a2 = 382;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
      goto LABEL_23;
    case 8:
      *a2 = 13;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
      goto LABEL_23;
    case 9:
      *a2 = 359;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
      goto LABEL_23;
    case 10:
      *a2 = 363;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
      goto LABEL_23;
    case 11:
      *a2 = 357;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
      goto LABEL_23;
    case 12:
      *a2 = 395;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
      goto LABEL_23;
    case 13:
      *a2 = 365;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
      goto LABEL_23;
    case 14:
      *a2 = 441;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
      goto LABEL_23;
    case 15:
      *a2 = 442;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
      goto LABEL_23;
    case 16:
      *a2 = 468;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          break;
      }
LABEL_23:
      result = *a2 + 1;
      *a3 = result;
      return result;
    case 17:
      *a2 = 402;
      break;
    default:
      break;
  }
  switch ( a1 )
  {
    case 6:
    case 16:
LABEL_20:
      result = *a2;
      *a3 = *a2;
      break;
    case 7:
LABEL_21:
      *a3 = 381;
      break;
    case 14:
LABEL_22:
      result = *a2 - 1;
      *a3 = result;
      break;
    default:
      goto LABEL_23;
  }
  return result;
}

//----- (0001A7A0) --------------------------------------------------------
int sub_1A7A0()
{
  int result; // eax
  int v1; // ebx
  char v2; // cl
  int v3; // edx
  __int16 v4; // dx
  int v5; // eax

  result = dword_D41A0;
  if ( *((_BYTE *)&loc_36DE9 + dword_D41A0 + 1) )
  {
    v1 = *(signed __int16 *)(dword_D41A0 + 12);
    v2 = *(_BYTE *)(dword_D41A0 + 2124 * v1 + 12221);
    if ( v2 != 5 && v2 != 8 && v2 != 3 && !*(_BYTE *)(dword_D41A4 + 225) )
    {
      if ( *(signed __int16 *)((char *)&loc_36DEC + dword_D41A0) != dword_1805B8
        || *(signed __int16 *)((char *)&loc_36DEC + dword_D41A0 + 2) != dword_1805BC
        || (v3 = dword_D41A0 + 10 * v1, *(_BYTE *)(v3 + 28222))
        || *(_BYTE *)(v3 + 28227) )
      {
        v5 = dword_D41A0;
      }
      else
      {
        v4 = *(_WORD *)((char *)&loc_36DEC + dword_D41A0 + 4) + 1;
        *(_WORD *)((char *)&loc_36DEC + dword_D41A0 + 4) = v4;
        if ( v4 <= 48 )
        {
LABEL_14:
          result = dword_D41A0;
          *(_WORD *)((char *)&loc_36DEC + dword_D41A0) = dword_1805B8;
          *(_WORD *)((char *)&loc_36DEC + result + 2) = dword_1805BC;
          return result;
        }
        sub_191B0(39, 0);
        v5 = dword_D41A0;
      }
      *(_WORD *)((char *)&loc_36DEC + v5 + 4) = 0;
      goto LABEL_14;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 1805B8: using guessed type int dword_1805B8;
// 1805BC: using guessed type int dword_1805BC;

//----- (0001A8A0) --------------------------------------------------------
int sub_1A8A0()
{
  char v0; // dh
  int result; // eax
  char v2; // bh
  char v3; // cl

  if ( word_1805C0 & 4 )
  {
    if ( word_1805C0 & 8 )
    {
      v0 = *(_BYTE *)(dword_D41A4 + 183);
      if ( !(v0 & 1) && !(v0 & 2) )
        sub_191B0(6, 128);
    }
  }
  result = dword_D41A4;
  v2 = *(_BYTE *)(dword_D41A4 + 183) & 0xFC;
  v3 = word_1805C0;
  *(_BYTE *)(dword_D41A4 + 183) = v2;
  if ( v3 & 4 )
    *(_BYTE *)(result + 183) = v2 | 1;
  if ( word_1805C0 & 8 )
  {
    result = dword_D41A4;
    *(_BYTE *)(result + 183) |= 2u;
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// 1805C0: using guessed type __int16 word_1805C0;

//----- (0001A970) --------------------------------------------------------
char __cdecl sub_1A970(char a1, int a2, int a3)
{
  int v3; // edx
  char v4; // cl
  char result; // al
  char v6; // cl
  _BOOL1 v7; // zf
  int v8; // eax
  char v9; // cl
  char v10; // bl
  char v11; // ch
  _BOOL1 v12; // al
  unsigned int v13; // ebx
  unsigned __int8 v14; // al
  __int16 v15; // ST04_2
  char v16; // dl
  unsigned __int8 v17; // bl
  char v18; // bl
  char v19; // cl
  char v20; // bl
  int v21; // ebx
  char v22; // cl
  int v23; // ebx
  char v24; // cl
  _BOOL1 v25; // dl
  int v26; // ebx
  char v27; // ch
  char v28; // cl

  v3 = a2;
  switch ( a1 )
  {
    case 1:
      sub_18AA0();
      return 0;
    case 2:
      if ( !byte_E3798 )
        return 0;
      sub_19760((char *)dword_E9C4C[(byte_E3799 != 0) + 390], 3u, 50);
      sub_8D8F0();
      sub_86860(word_1803EC);
      byte_E3799 ^= 1u;
      return 0;
    case 3:
      if ( !byte_E37FC )
        return 0;
      if ( byte_E37FD )
      {
        sub_8E020();
        sub_19760((char *)dword_EA270, 3u, 50);
        byte_E37FD = 0;
      }
      else
      {
        v15 = *(_WORD *)(dword_D41A0 + 565);
        byte_E37FD = 1;
        sub_8E160(v15, 0x7Fu);
        sub_19760((char *)dword_EA26C, 3u, 50);
      }
      return 0;
    case 4:
      if ( !byte_E2A28 )
        return 0;
      v16 = *(_BYTE *)(dword_D41A4 + 24);
      if ( v16 & 0x40 )
        *(_BYTE *)(dword_D41A4 + 24) = v16 & 0xBF;
      else
        *(_BYTE *)(dword_D41A4 + 24) = v16 | 0x40;
      sub_19760((char *)dword_E9C4C[((*(_BYTE *)(dword_D41A4 + 24) & 0x40) == 0) + 469], 3u, 50);
      return 0;
    case 5:
      if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
      {
        *((_BYTE *)&loc_36DE9 + dword_D41A0 + 1) = 0;
      }
      else
      {
        v12 = *((_BYTE *)&loc_36DE9 + dword_D41A0 + 1) == 0;
        *((_BYTE *)&loc_36DE9 + dword_D41A0 + 1) = v12;
        sub_19760((char *)dword_E9C4C[(v12 == 0) + 398], 3u, 50);
      }
      return 0;
    case 6:
      if ( *(_BYTE *)(dword_D41A4 + 51) < 3u || *(_BYTE *)(dword_D41A4 + 180) )
        return 0;
      *(_BYTE *)(dword_D41A4 + 38402) = 1;
      v17 = *((_BYTE *)&loc_2FED1 + dword_D41A0 + 3);
      if ( v17 < 1u )
      {
        if ( !v17 )
        {
          if ( a2 )
          {
            v3 = dword_D41A4;
            v19 = *(_BYTE *)(dword_D41A4 + 11) - 1;
            *(_BYTE *)(dword_D41A4 + 11) = v19;
            if ( v19 >= 0 )
              goto LABEL_86;
            if ( !a3 )
            {
              *(_BYTE *)(v3 + 11) = 4;
              goto LABEL_86;
            }
          }
          else
          {
            v3 = dword_D41A4;
            v18 = *(_BYTE *)(dword_D41A4 + 11) + 1;
            *(_BYTE *)(dword_D41A4 + 11) = v18;
            if ( v18 <= 4 )
              goto LABEL_86;
            if ( a3 )
            {
              *(_BYTE *)(v3 + 11) = 4;
              goto LABEL_86;
            }
          }
          *(_BYTE *)(v3 + 11) = 0;
        }
LABEL_86:
        sub_47650(a3, v3);
        return 0;
      }
      if ( v17 > 1u )
      {
        if ( v17 != 2 )
          goto LABEL_86;
        if ( a2 )
        {
          v23 = dword_D41A4;
          v24 = *(_BYTE *)(dword_D41A4 + 13) - 1;
          *(_BYTE *)(dword_D41A4 + 13) = v24;
          if ( v24 < 0 )
          {
            if ( !a3 )
            {
              *(_BYTE *)(v23 + 13) = 4;
              sub_47650(0, a2);
              return 0;
            }
            goto LABEL_85;
          }
        }
        else
        {
          v23 = dword_D41A4;
          v3 = (unsigned __int8)(*(_BYTE *)(dword_D41A4 + 13) + 1);
          *(_BYTE *)(dword_D41A4 + 13) = v3;
          if ( (char)v3 > 4 )
          {
            if ( a3 )
            {
              *(_BYTE *)(v23 + 13) = 4;
              sub_47650(a3, v3);
              return 0;
            }
LABEL_85:
            *(_BYTE *)(v23 + 13) = 0;
            goto LABEL_86;
          }
        }
        goto LABEL_86;
      }
      if ( a2 )
      {
        v21 = dword_D41A4;
        v22 = *(_BYTE *)(dword_D41A4 + 12) - 1;
        *(_BYTE *)(dword_D41A4 + 12) = v22;
        if ( v22 >= 0 )
          goto LABEL_86;
        if ( a3 )
        {
          *(_BYTE *)(v21 + 12) = 0;
          sub_47650(a3, a2);
        }
        else
        {
          *(_BYTE *)(v21 + 12) = 4;
          sub_47650(0, a2);
        }
        result = 0;
      }
      else
      {
        v3 = dword_D41A4;
        v20 = *(_BYTE *)(dword_D41A4 + 12) + 1;
        *(_BYTE *)(dword_D41A4 + 12) = v20;
        if ( v20 <= 4 )
          goto LABEL_86;
        if ( a3 )
        {
          *(_BYTE *)(v3 + 12) = 4;
          sub_47650(a3, v3);
        }
        else
        {
          *(_BYTE *)(v3 + 12) = 0;
          sub_47650(0, v3);
        }
        result = 0;
      }
      return result;
    case 7:
      if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
        return 0;
      v13 = dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12) + 11240)];
      if ( v13 <= dword_EA3E4[0] || *(_DWORD *)(v13 + 8) < 0 )
        return 0;
      if ( *(_BYTE *)(dword_D41A4 + 178) )
        *(_BYTE *)(dword_D41A4 + 178) = 0;
      else
        *(_BYTE *)(dword_D41A4 + 178) = (a2 != 0) + 1;
      v14 = *(_BYTE *)(dword_D41A4 + 178);
      if ( v14 < 1u )
      {
        if ( v14 )
          return 0;
        sub_19760((char *)dword_EA240, 3u, 50);
        result = 0;
      }
      else
      {
        if ( v14 <= 1u )
        {
          sub_19760((char *)dword_EA244, 3u, 50);
        }
        else
        {
          if ( v14 != 2 )
            return 0;
          sub_19760((char *)dword_EA248, 3u, 50);
        }
        *(_WORD *)(*(_DWORD *)(v13 + 164) + 341) = 0;
        *(_WORD *)(*(_DWORD *)(v13 + 164) + 343) = 0;
        result = 0;
      }
      return result;
    case 8:
      v26 = dword_D41A0;
      if ( *(_BYTE *)(dword_D41A0 + 8592) )
        return 0;
      if ( a2 )
      {
        v27 = *(_BYTE *)(dword_D41A0 + 8589) + 1;
        *(_BYTE *)(dword_D41A0 + 8589) = v27;
        if ( v27 <= 40 )
          goto LABEL_97;
        if ( !a3 )
        {
          *(_BYTE *)(v26 + 8589) = 16;
          goto LABEL_97;
        }
      }
      else
      {
        v28 = *(_BYTE *)(dword_D41A0 + 8589) - 1;
        *(_BYTE *)(dword_D41A0 + 8589) = v28;
        if ( v28 >= 16 )
          goto LABEL_97;
        if ( a3 )
        {
          *(_BYTE *)(v26 + 8589) = 16;
          goto LABEL_97;
        }
      }
      *(_BYTE *)(v26 + 8589) = 40;
LABEL_97:
      sub_2CA90(*(char *)(dword_D41A0 + 8589));
      return 0;
    case 9:
      if ( !*(_BYTE *)(dword_D41A0 + 8618) )
        return 0;
      v4 = *(_BYTE *)(dword_D41A0 + 8586) ^ 1;
      *(_BYTE *)(dword_D41A0 + 8586) = v4;
      sub_19760((char *)dword_E9C4C[(v4 == 0) + 359], 3u, 50);
      return 0;
    case 10:
      if ( !*(_BYTE *)(dword_D41A0 + 8620) || !off_D41A8 )
        return 0;
      *(_BYTE *)(dword_D41A0 + 8588) ^= 1u;
      sub_19760((char *)dword_E9C4C[(*(_BYTE *)(dword_D41A0 + 8588) == 0) + 363], 3u, 50);
      return 0;
    case 11:
      if ( !*(_BYTE *)(dword_D41A0 + 8619) )
        return 0;
      v6 = *(_BYTE *)(dword_D41A0 + 8587) ^ 1;
      *(_BYTE *)(dword_D41A0 + 8587) = v6;
      sub_19760((char *)dword_E9C4C[(v6 == 0) + 357], 3u, 50);
      return 0;
    case 12:
      if ( !*(_BYTE *)(dword_D41A0 + 8630) )
        return 0;
      v7 = *(_BYTE *)(dword_D41A0 + 8598) == 1;
      *(_BYTE *)(dword_D41A0 + 8598) ^= 1u;
      sub_19760((char *)dword_E9C4C[(unsigned __int8)v7 + 395], 3u, 50);
      return 0;
    case 13:
      v8 = dword_D41A0;
      v9 = *(_BYTE *)(dword_D41A0 + 8591) ^ 1;
      *(_BYTE *)(dword_D41A0 + 8590) ^= 1u;
      *(_BYTE *)(v8 + 8591) = v9;
      sub_19760((char *)dword_E9C4C[(*(_BYTE *)(v8 + 8590) == 0) + 365], 3u, 50);
      if ( *(_BYTE *)(dword_D41A0 + 8590) )
        return 0;
      sub_87C10();
      return 0;
    case 14:
      if ( !*(_BYTE *)(dword_D41A0 + 8632) )
        return 0;
      v10 = *(_BYTE *)(dword_D41A0 + 8600) ^ 1;
      *(_BYTE *)(dword_D41A0 + 8600) = v10;
      sub_19760((char *)dword_E9C4C[(v10 != 0) + 440], 3u, 50);
      return 0;
    case 15:
      if ( !*(_BYTE *)(dword_D41A0 + 8633) )
        return 0;
      v11 = *(_BYTE *)(dword_D41A0 + 8601) ^ 1;
      *(_BYTE *)(dword_D41A0 + 8601) = v11;
      sub_19760((char *)dword_E9C4C[(v11 == 0) + 442], 3u, 50);
      return 0;
    case 16:
      if ( !*(_BYTE *)(dword_D41A0 + 8628) || *(_BYTE *)(dword_D41A0 + 8592) )
        return 0;
      sub_41BC0();
      sub_46B40();
      return 0;
    case 17:
      v25 = *(_BYTE *)(dword_D41A4 + 207) == 0;
      *(_BYTE *)(dword_D41A4 + 207) = v25;
      sub_19760((char *)dword_E9C4C[(v25 != 0) + 402], 3u, 50);
      return 0;
    case 18:
      v7 = *(_BYTE *)(dword_D41A0 + 8592) == 1;
      *(_BYTE *)(dword_D41A0 + 8592) ^= 1u;
      if ( v7 )
      {
        sub_417A0();
        return 0;
      }
      sub_417D0();
      return 0;
    default:
      return 0;
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41A8: using guessed type char *off_D41A8;
// E2A28: using guessed type char byte_E2A28;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// EA240: using guessed type int dword_EA240;
// EA244: using guessed type int dword_EA244;
// EA248: using guessed type int dword_EA248;
// EA26C: using guessed type int dword_EA26C;
// EA270: using guessed type int dword_EA270;
// EA3E4: using guessed type int dword_EA3E4[];
// 1803EC: using guessed type __int16 word_1803EC;

//----- (0001B280) --------------------------------------------------------
int __cdecl sub_1B280(int a1)
{
  int result; // eax
  int v2; // edx
  unsigned __int8 v3; // dl

  while ( 1 )
  {
    result = 7 * word_D4004;
    v2 = a1 + result;
    if ( word_17DB60 != *(_WORD *)(a1 + result) )
      break;
    result = *(signed __int16 *)(v2 + 3);
    if ( result == -1 )
      break;
    v3 = *(_BYTE *)(v2 + 2) - 65;
    if ( v3 <= 0x39u )
      JUMPOUT(__CS__, *(&off_1B190 + v3));
    ++word_D4004;
  }
  return result;
}
// 1B190: using guessed type void *off_1B190;
// D4004: using guessed type __int16 word_D4004;
// D41C0: using guessed type char byte_D41C0;
// E3798: using guessed type char byte_E3798;
// E3844: using guessed type int dword_E3844;
// E387C: using guessed type int dword_E387C;
// 17DB60: using guessed type __int16 word_17DB60;

//----- (0001B5F0) --------------------------------------------------------
int sub_1B5F0()
{
  unsigned __int16 v0; // ax
  unsigned int j; // edx
  __int16 v2; // bx
  unsigned int i; // edx
  __int16 v4; // bx

  v0 = 0;
  do
  {
    if ( v0 < 0xAu )
      goto LABEL_16;
    if ( v0 <= 0xAu )
      goto LABEL_12;
    if ( v0 != 27 )
    {
LABEL_16:
      for ( i = *(_DWORD *)(dword_D41A4 + 4 * (signed __int16)v0 + 38403); i > dword_EA3E4[0]; i = *(_DWORD *)i )
      {
        v4 = *(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240);
        *(_DWORD *)(i + 8) = -1;
        *(_WORD *)(i + 36) = v4;
      }
    }
    else
    {
      for ( j = *(_DWORD *)(dword_D41A4 + 38511); j > dword_EA3E4[0]; j = *(_DWORD *)j )
      {
        v2 = *(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240);
        *(_BYTE *)(j + 69) = -35;
        *(_WORD *)(j + 36) = v2;
      }
    }
LABEL_12:
    ++v0;
  }
  while ( (signed __int16)v0 < 29 );
  return 0;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001B6B0) --------------------------------------------------------
void __cdecl sub_1B6B0(int a1)
{
  int v1; // esi
  int v2; // esi
  int v3; // esi
  int v4; // edi
  __int16 v5; // ax

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 50)];
  if ( *(_BYTE *)(v1 + 63) != 5 )
    sub_57F10(a1);
  if ( *(_BYTE *)(a1 + 57) )
  {
    *(_WORD *)(a1 + 28) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
    *(_WORD *)(a1 + 30) = sub_58210((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
    v2 = v1 + 76;
    *(_DWORD *)&word_EB398 = *(_DWORD *)v2;
    *(&word_EB398 + 2) = *(_WORD *)(v2 + 4);
    sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), -*(_WORD *)(a1 + 54));
    sub_57CF0(a1, (int)&word_EB398);
    if ( *(_WORD *)(a1 + 98) )
    {
      v3 = *(_DWORD *)(a1 + 94);
      v4 = *(_DWORD *)(a1 + 8);
      v5 = *(_WORD *)(a1 + 98);
      *(_WORD *)(a1 + 98) = 0;
      *(_WORD *)(a1 + 38) = v5;
      *(_DWORD *)(a1 + 8) = v4 - v3;
    }
    else
    {
      *(_WORD *)(a1 + 38) = 0;
    }
  }
  else if ( !(*(_BYTE *)(a1 + 62) & 3) )
  {
    sub_57CF0(a1, v1 + 76);
    *(_WORD *)(a1 + 28) = *(_WORD *)(v1 + 28);
  }
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (0001B7A0) --------------------------------------------------------
int __cdecl sub_1B7A0(signed __int16 *a1)
{
  int v1; // eax
  unsigned __int16 v2; // dx
  unsigned __int16 v3; // bx
  unsigned __int8 v4; // cl
  unsigned __int16 v5; // bx
  int v6; // esi
  int v7; // ebx
  int v8; // ecx
  int v9; // ebx

  v1 = *a1 >> 8;
  BYTE1(v1) = (unsigned __int16)a1[1] >> 8;
  v2 = v1;
  LOBYTE(v1) = v1 + 1;
  v3 = v1;
  ++BYTE1(v1);
  v4 = byte_11B4E0[v3];
  v5 = v1;
  LOBYTE(v2) = byte_11B4E0[v2];
  LOBYTE(v1) = v1 - 1;
  HIBYTE(v2) = byte_11B4E0[v5];
  v6 = (unsigned __int8)byte_11B4E0[(unsigned __int16)v1];
  v7 = (unsigned __int8)v2 + v4 - v6;
  v8 = abs((unsigned __int8)v2 + v6 - v4 - HIBYTE(v2));
  v9 = abs(v7 - HIBYTE(v2));
  if ( v8 > v9 )
    v9 = v8;
  return v9;
}

//----- (0001B830) --------------------------------------------------------
int __cdecl sub_1B830(_WORD *a1)
{
  unsigned __int16 v1; // ax
  unsigned __int16 v2; // dx
  unsigned __int16 v3; // bx
  unsigned __int8 v4; // cl
  unsigned __int16 v5; // bx
  int v6; // esi
  int v7; // ebx
  int v8; // ecx
  int v9; // ebx

  LOBYTE(v1) = (*a1 >> 8) - 1;
  HIBYTE(v1) = (a1[1] >> 8) - 1;
  v2 = v1;
  LOBYTE(v1) = v1 + 2;
  v3 = v1;
  HIBYTE(v1) += 2;
  v4 = byte_11B4E0[v3];
  v5 = v1;
  LOBYTE(v2) = byte_11B4E0[v2];
  LOBYTE(v1) = v1 - 2;
  HIBYTE(v2) = byte_11B4E0[v5];
  v6 = (unsigned __int8)byte_11B4E0[v1];
  v7 = (unsigned __int8)v2 + v4 - v6;
  v8 = abs((unsigned __int8)v2 + v6 - v4 - HIBYTE(v2));
  v9 = abs(v7 - HIBYTE(v2));
  if ( v8 > v9 )
    v9 = v8;
  return v9;
}

//----- (0001B8C0) --------------------------------------------------------
signed int __cdecl sub_1B8C0(int a1)
{
  char v1; // ah
  char v2; // dl
  signed int result; // eax
  signed __int16 *v4; // eax
  __int16 v5; // ST10_2
  int v6; // ST0C_4
  int v7; // ST08_4
  __int16 v8; // ax
  __int16 v9; // ax
  int v10; // esi
  __int16 v11; // ax
  char v12; // ch
  __int16 v13; // ax
  signed __int16 *v14; // eax
  __int16 v15; // ST10_2
  int v16; // ST0C_4
  int v17; // ST08_4
  __int16 v18; // ax
  int v19; // esi
  __int16 v20; // ax
  __int16 v21; // ax
  signed __int16 *v22; // eax
  __int16 v23; // ST10_2
  int v24; // ST0C_4
  int v25; // ST08_4
  __int16 v26; // ax
  int v27; // esi
  __int16 v28; // ax
  signed __int16 *v29; // eax
  __int16 v30; // ST10_2
  int v31; // ST0C_4
  int v32; // ST08_4
  __int16 v33; // ax
  int v34; // esi
  __int16 v35; // ax
  int v36; // ebx
  __int16 v37; // [esp+0h] [ebp-4h]

  v1 = *(_BYTE *)(a1 + 13);
  if ( v1 & 8 )
  {
    v2 = v1 & 0xF7;
    result = 4;
    *(_BYTE *)(a1 + 13) = v2;
  }
  else if ( *(_BYTE *)(a1 + 64) == 27 )
  {
    result = (unsigned __int8)sub_2AF10(a1, 1);
  }
  else
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v4 = *(signed __int16 **)(a1 + 160);
    v5 = v4[7];
    v6 = v4[5];
    v7 = v4[6];
    v8 = sub_10C40(&word_EB398);
    sub_580E0((int)&word_EB398, v8, v7, v6, v5);
    sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
    if ( *(signed __int16 *)(a1 + 76) >> 8 != word_EB398 >> 8 || *(signed __int16 *)(a1 + 78) >> 8 != word_EB39A >> 8 )
    {
      if ( sub_102D0(a1, &word_EB398, 1)
        || (v10 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 16), sub_1B7A0(&word_EB398) >= v10) )
      {
        *(_BYTE *)(a1 + 14) |= 4u;
        v13 = *(_WORD *)(a1 + 28);
        v37 = v13;
        v13 += 341;
        HIBYTE(v13) &= 7u;
        *(_WORD *)(a1 + 28) = v13;
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        v14 = *(signed __int16 **)(a1 + 160);
        v15 = v14[7];
        v16 = v14[5];
        v17 = v14[6];
        v18 = sub_10C40(&word_EB398);
        sub_580E0((int)&word_EB398, v18, v17, v16, v15);
        sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
        if ( sub_102D0(a1, &word_EB398, 1)
          || (v19 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 16), sub_1B7A0(&word_EB398) >= v19) )
        {
          LOBYTE(v21) = v37 - 85;
          HIBYTE(v21) = ((unsigned __int16)(v37 - 341) >> 8) & 7;
          *(_WORD *)(a1 + 28) = v21;
          *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
          *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
          v22 = *(signed __int16 **)(a1 + 160);
          v23 = v22[7];
          v24 = v22[5];
          v25 = v22[6];
          v26 = sub_10C40(&word_EB398);
          sub_580E0((int)&word_EB398, v26, v25, v24, v23);
          sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
          if ( sub_102D0(a1, &word_EB398, 1)
            || (v27 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 16), sub_1B7A0(&word_EB398) >= v27) )
          {
            *(_WORD *)(a1 + 28) = __PAIR__(HIBYTE(v37) + 4, (unsigned __int8)v37) & 0x7FF;
            *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
            *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
            v29 = *(signed __int16 **)(a1 + 160);
            v30 = v29[7];
            v31 = v29[5];
            v32 = v29[6];
            v33 = sub_10C40(&word_EB398);
            sub_580E0((int)&word_EB398, v33, v32, v31, v30);
            sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
            if ( sub_102D0(a1, &word_EB398, 1)
              || (v34 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 16), sub_1B7A0(&word_EB398) >= v34) )
            {
              if ( *(_BYTE *)(*(_DWORD *)(a1 + 160) + 32) & 1 || sub_104D0((signed __int16 *)(a1 + 76)) == (int (*)())1 )
                *(_DWORD *)(a1 + 8) = -1;
              if ( *(_DWORD *)(a1 + 8) == -1 )
              {
                v36 = *(_DWORD *)((char *)&loc_364D1 + dword_D41A0 + 1);
                if ( v36 )
                  *(_DWORD *)((char *)&loc_364D1 + dword_D41A0 + 1) = v36 - 1;
              }
              result = 4;
            }
            else
            {
              sub_57CF0(a1, (int)&word_EB398);
              v35 = *(_WORD *)(a1 + 28)
                  + sub_58350(
                      *(_WORD *)(a1 + 28),
                      *(_WORD *)(a1 + 32),
                      *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 4),
                      *(_WORD *)(*(_DWORD *)(a1 + 160) + 2));
              HIBYTE(v35) &= 7u;
              *(_WORD *)(a1 + 28) = v35;
              result = 3;
            }
          }
          else
          {
            sub_57CF0(a1, (int)&word_EB398);
            v28 = *(_WORD *)(a1 + 28)
                + sub_58350(
                    *(_WORD *)(a1 + 28),
                    *(_WORD *)(a1 + 32),
                    *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 4),
                    *(_WORD *)(*(_DWORD *)(a1 + 160) + 2));
            HIBYTE(v28) &= 7u;
            *(_WORD *)(a1 + 28) = v28;
            result = 3;
          }
        }
        else
        {
          sub_57CF0(a1, (int)&word_EB398);
          v20 = *(_WORD *)(a1 + 28)
              + sub_58350(
                  *(_WORD *)(a1 + 28),
                  *(_WORD *)(a1 + 32),
                  *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 4),
                  *(_WORD *)(*(_DWORD *)(a1 + 160) + 2));
          HIBYTE(v20) &= 7u;
          *(_WORD *)(a1 + 28) = v20;
          result = 3;
        }
      }
      else
      {
        sub_57CF0(a1, (int)&word_EB398);
        v11 = *(_WORD *)(a1 + 28)
            + sub_58350(
                *(_WORD *)(a1 + 28),
                *(_WORD *)(a1 + 32),
                *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 4),
                *(_WORD *)(*(_DWORD *)(a1 + 160) + 2));
        HIBYTE(v11) &= 7u;
        v12 = *(_BYTE *)(a1 + 14) & 0xFB;
        *(_WORD *)(a1 + 28) = v11;
        result = 2;
        *(_BYTE *)(a1 + 14) = v12;
      }
    }
    else
    {
      sub_57CF0(a1, (int)&word_EB398);
      v9 = *(_WORD *)(a1 + 28)
         + sub_58350(
             *(_WORD *)(a1 + 28),
             *(_WORD *)(a1 + 32),
             *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 4),
             *(_WORD *)(*(_DWORD *)(a1 + 160) + 2));
      HIBYTE(v9) &= 7u;
      *(_BYTE *)(a1 + 14) &= 0xFBu;
      *(_WORD *)(a1 + 28) = v9;
      result = 1;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;

//----- (0001BD90) --------------------------------------------------------
signed int __cdecl sub_1BD90(int a1, char a2)
{
  unsigned int v2; // esi
  __int16 v3; // ax
  int i; // eax
  int v5; // edx
  int v6; // eax
  char v7; // al
  int v8; // esi
  unsigned int j; // esi
  int v10; // eax
  unsigned int v11; // edi
  signed int v12; // ST08_4
  __int16 v13; // ax
  unsigned int v15; // [esp+4h] [ebp-Ch]
  unsigned int v16; // [esp+8h] [ebp-8h]
  unsigned int v17; // [esp+Ch] [ebp-4h]

  v2 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v3 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v2 = 1;
    *(_WORD *)(a1 + 38) = v3;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        v2 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v2 >= 1 )
  {
    if ( v2 <= 1 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 160) + 32) & 8 )
        v7 = a2 + 6;
      else
        v7 = a2 + 2;
    }
    else
    {
      if ( v2 != 2 )
        return sub_1EEE0(a1);
      v7 = a2 + 4;
    }
    goto LABEL_35;
  }
  if ( !v2 )
  {
    v8 = *(_DWORD *)(a1 + 160);
    if ( !(*(_BYTE *)(v8 + 32) & 4) && !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v8 + 26)) )
    {
      v16 = -1;
      v15 = *(signed __int16 *)(v8 + 28) * *(signed __int16 *)(v8 + 28);
      v17 = 0;
      for ( j = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
      {
        if ( !*(_WORD *)(j + 50) && j != a1 )
        {
          v10 = (signed __int16)(*(_WORD *)(j + 76) - *(_WORD *)(a1 + 76));
          v11 = (signed __int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78))
              * (signed __int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78))
              + v10 * v10;
          if ( v11 <= v15 )
          {
            v12 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 30);
            v13 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(j + 76));
            if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v13) < v12 && v11 < v16 )
            {
              v17 = j;
              v16 = v11;
            }
          }
        }
      }
      if ( v17 )
      {
        *(_WORD *)(a1 + 50) = (signed int)(v17 - (dword_D41A0 + 28302)) / 168;
        v7 = a2 + 3;
LABEL_35:
        *(_BYTE *)(a1 + 69) = v7;
        return sub_1EEE0(a1);
      }
    }
  }
  return sub_1EEE0(a1);
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001BF90) --------------------------------------------------------
void __cdecl sub_1BF90(int a1, char a2)
{
  unsigned int v2; // esi
  __int16 v3; // ax
  int i; // eax
  int v5; // edx
  int v6; // eax
  char v7; // al
  char v8; // al
  unsigned __int16 v9; // ax
  char v10; // cl
  int v11; // eax
  unsigned int v12; // esi
  int v13; // eax
  unsigned int v14; // edi
  signed int v15; // ST0C_4
  __int16 v16; // ax
  int v17; // eax
  unsigned int j; // esi
  int v19; // eax
  unsigned int v20; // edi
  signed int v21; // ST0C_4
  __int16 v22; // ax
  unsigned int v23; // [esp+0h] [ebp-1Ch]
  unsigned int v24; // [esp+8h] [ebp-14h]
  unsigned int v25; // [esp+Ch] [ebp-10h]
  unsigned int v26; // [esp+10h] [ebp-Ch]
  unsigned int v27; // [esp+14h] [ebp-8h]
  unsigned int v28; // [esp+18h] [ebp-4h]

  v2 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v3 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v2 = 1;
    *(_WORD *)(a1 + 38) = v3;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        v2 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v2 < 1 )
  {
    if ( !v2 )
    {
      sub_1B8C0(a1);
      if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v9 = *(_WORD *)(a1 + 20);
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        *(_WORD *)(a1 + 32) += ((*(_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v9 % 0x9Du) / 79) - 1);
        v10 = *(_BYTE *)(a1 + 57);
        *(_BYTE *)(a1 + 33) &= 7u;
        if ( v10 )
        {
          v11 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
          v23 = -1;
          v24 = 0;
          v12 = *(_DWORD *)(dword_D41A4 + 38519);
          v27 = v11 * v11;
          while ( v12 > dword_EA3E4[0] )
          {
            v13 = (signed __int16)(*(_WORD *)(v12 + 76) - *(_WORD *)(a1 + 76));
            v14 = (signed __int16)(*(_WORD *)(v12 + 78) - *(_WORD *)(a1 + 78))
                * (signed __int16)(*(_WORD *)(v12 + 78) - *(_WORD *)(a1 + 78))
                + v13 * v13;
            if ( v14 <= v27 && !(*(_BYTE *)(v12 + 12) & 0x20) )
            {
              v15 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 30);
              v16 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v12 + 76));
              if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v16) < v15 && v14 < v23 )
              {
                v24 = v12;
                v23 = v14;
              }
            }
            v12 = *(_DWORD *)v12;
          }
          if ( v24 )
          {
            *(_WORD *)(a1 + 150) = (signed int)(v24 - (dword_D41A0 + 28302)) / 168;
            if ( *(_BYTE *)(*(_DWORD *)(a1 + 160) + 32) & 8 )
              *(_BYTE *)(a1 + 69) = a2 + 6;
            else
              *(_BYTE *)(a1 + 69) = a2 + 2;
          }
          else
          {
            v17 = *(_DWORD *)(a1 + 160);
            if ( !(*(_BYTE *)(v17 + 32) & 4) )
            {
              v28 = -1;
              v26 = *(signed __int16 *)(v17 + 28) * *(signed __int16 *)(v17 + 28);
              v25 = 0;
              for ( j = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
              {
                if ( !*(_WORD *)(j + 50) && j != a1 )
                {
                  v19 = (signed __int16)(*(_WORD *)(j + 76) - *(_WORD *)(a1 + 76));
                  v20 = (signed __int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78))
                      * (signed __int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78))
                      + v19 * v19;
                  if ( v20 <= v26 )
                  {
                    v21 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 30);
                    v22 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(j + 76));
                    if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v22) < v21 && v20 < v28 )
                    {
                      v25 = j;
                      v28 = v20;
                    }
                  }
                }
              }
              if ( v25 )
              {
                *(_WORD *)(a1 + 50) = (signed int)(v25 - (dword_D41A0 + 28302)) / 168;
                v7 = a2 + 3;
                goto LABEL_49;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    if ( v2 > 1 )
    {
      if ( v2 != 2 )
        return;
      v7 = a2 + 4;
LABEL_49:
      *(_BYTE *)(a1 + 69) = v7;
      return;
    }
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 160) + 32) & 8 )
      v8 = a2 + 6;
    else
      v8 = a2 + 2;
    *(_BYTE *)(a1 + 69) = v8;
    sub_1EEE0(a1);
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001C310) --------------------------------------------------------
signed int __cdecl sub_1C310(int a1, char a2, unsigned __int16 (__cdecl *a3)(int, int))
{
  signed int v3; // edi
  unsigned int v4; // eax
  __int16 v5; // ax
  int i; // edx
  int v7; // edx
  int v8; // ecx
  int v10; // eax
  int v11; // esi
  __int16 v12; // ax
  int v13; // edx
  unsigned int j; // ecx
  int v15; // ecx
  unsigned int v16; // ST0C_4

  v3 = 0;
  v4 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    v5 = *(_WORD *)(a1 + 98);
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    *(_WORD *)(a1 + 38) = v5;
    *(_WORD *)(a1 + 98) = 0;
    v4 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v8 + 52) )
    {
      v8 = dword_EA3E4[i];
      if ( v8 == dword_EA3E4[0] )
        break;
      v7 = *(_DWORD *)(v8 + 8);
      if ( v7 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v7;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v8 + 38);
        v4 = 1;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v4 = 2;
  }
  if ( v4 < 1 )
  {
    if ( !v4 )
    {
      sub_1B8C0(a1);
      v10 = sub_1ED30(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
      v11 = v10;
      if ( v10 == dword_EA3E4[0] || *(_DWORD *)(v10 + 8) < 0 || *(_BYTE *)(v10 + 13) & 4 )
      {
        *(_BYTE *)(a1 + 69) = a2 + 1;
        return 0;
      }
      if ( !(*(_BYTE *)(a1 + 62) & 3) )
      {
        v12 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v10 + 76));
        v13 = dword_D41A4;
        *(_WORD *)(a1 + 32) = v12;
        for ( j = *(_DWORD *)(v13 + 4 * *(char *)(a1 + 64) + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
        {
          if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26)
            && abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
            && abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78)) < (signed int)*(signed __int16 *)(a1 + 84) )
          {
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
            break;
          }
        }
      }
      v15 = *(_DWORD *)(a1 + 160);
      if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v15 + 26)) )
      {
        v16 = *(signed __int16 *)(v15 + 28);
        if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v11 + 76)) >= v16 )
        {
          *(_BYTE *)(a1 + 69) = a2 + 1;
          return 0;
        }
        if ( a3(a1, v11) )
          v3 = 1;
      }
    }
  }
  else
  {
    if ( v4 <= 1 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      sub_1EEE0(a1);
      return 0;
    }
    if ( v4 == 2 )
      *(_BYTE *)(a1 + 69) = a2 + 4;
  }
  return v3;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001C560) --------------------------------------------------------
char __cdecl sub_1C560(int a1, unsigned __int16 a2)
{
  char v2; // al
  int v3; // eax
  int v4; // esi
  signed __int16 v5; // cx
  int i; // eax
  int v7; // edx
  int v8; // eax
  char v9; // al
  int v10; // eax
  char v11; // al
  int v12; // eax
  char v13; // al
  unsigned int v14; // ecx
  _BOOL1 v16; // [esp+4h] [ebp-4h]

  if ( !*(_WORD *)(a1 + 50) )
  {
    v2 = a2;
LABEL_57:
    LOBYTE(v3) = v2 + 1;
LABEL_58:
    *(_BYTE *)(a1 + 69) = v3;
    return v3;
  }
  LOWORD(v3) = *(_WORD *)(a1 + 50);
  v4 = dword_EA3E4[(unsigned __int16)v3];
  v16 = *(_DWORD *)(v4 + 8) >= 0
     && !(*(_BYTE *)(v4 + 13) & 4)
     && (LOBYTE(v3) = *(_BYTE *)(v4 + 63), (_BYTE)v3 == *(_BYTE *)(a1 + 63))
     && (LOBYTE(v3) = *(_BYTE *)(v4 + 64), (_BYTE)v3 == *(_BYTE *)(a1 + 64));
  v5 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    LOWORD(v3) = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v5 = 1;
    *(_WORD *)(a1 + 38) = v3;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v3 + 52) )
    {
      v3 = dword_EA3E4[i];
      if ( v3 == dword_EA3E4[0] )
        break;
      v7 = *(_DWORD *)(v3 + 8);
      if ( v7 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v7;
        LOWORD(v3) = *(_WORD *)(v3 + 38);
        v5 = 1;
        *(_WORD *)(a1 + 38) = v3;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    LOWORD(v3) = *(_WORD *)(a1 + 38);
    v5 = 2;
    *(_WORD *)(a1 + 36) = v3;
  }
  if ( (unsigned __int16)v5 < 1u )
  {
    if ( v5 )
      return v3;
    sub_1B8C0(a1);
    if ( !v16 )
    {
      v2 = a2;
      *(_WORD *)(a1 + 50) = 0;
      goto LABEL_57;
    }
    LOWORD(v3) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(_WORD *)(*(_DWORD *)(a1 + 160) + 26);
    if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
    {
      switch ( *(unsigned __int8 *)(v4 + 69) - a2 )
      {
        case 0:
        case 1:
          goto LABEL_45;
        case 2:
          *(_WORD *)(a1 + 150) = *(_WORD *)(v4 + 150);
          *(_WORD *)(a1 + 50) = 0;
          LOBYTE(v3) = a2 + 2;
          *(_BYTE *)(a1 + 69) = a2 + 2;
          return v3;
        case 3:
          *(_WORD *)(a1 + 50) = *(_WORD *)(v4 + 50);
LABEL_45:
          *(_WORD *)(a1 + 32) = sub_581E0(
                                  (_WORD *)(a1 + 76),
                                  (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 50)] + 76));
          v14 = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403);
          break;
        case 6:
          *(_WORD *)(a1 + 150) = *(_WORD *)(v4 + 150);
          *(_WORD *)(a1 + 50) = 0;
          LOBYTE(v3) = a2 + 6;
          *(_BYTE *)(a1 + 69) = a2 + 6;
          return v3;
        default:
          *(_WORD *)(a1 + 50) = 0;
          LOBYTE(v3) = a2 + 1;
          *(_BYTE *)(a1 + 69) = a2 + 1;
          return v3;
      }
      while ( v14 > dword_EA3E4[0] )
      {
        if ( *(_WORD *)(v14 + 26) != *(_WORD *)(a1 + 26)
          && abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(v14 + 76)) < 256
          && abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(v14 + 78)) < 256 )
        {
          *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(v14 + 76), (_WORD *)(a1 + 76));
          break;
        }
        v14 = *(_DWORD *)v14;
      }
      LOWORD(v3) = *(_WORD *)(v4 + 134) + *(_WORD *)(v4 + 130);
      *(_WORD *)(a1 + 130) = v3;
    }
  }
  else
  {
    if ( (unsigned __int16)v5 > 1u )
    {
      if ( v5 != 2 )
        return v3;
      if ( v16 )
      {
        *(_WORD *)(v4 + 150) = *(_WORD *)(a1 + 38);
        v8 = *(_DWORD *)(v4 + 160);
        *(_WORD *)(v4 + 50) = 0;
        if ( *(_BYTE *)(v8 + 32) & 8 )
          v9 = a2 + 6;
        else
          v9 = a2 + 2;
        *(_BYTE *)(v4 + 69) = v9;
      }
      *(_WORD *)(a1 + 50) = 0;
      LOBYTE(v3) = a2 + 4;
      goto LABEL_58;
    }
    if ( v16 )
    {
      *(_WORD *)(v4 + 150) = *(_WORD *)(a1 + 38);
      v10 = *(_DWORD *)(v4 + 160);
      *(_WORD *)(v4 + 50) = 0;
      if ( *(_BYTE *)(v10 + 32) & 8 )
        v11 = a2 + 6;
      else
        v11 = a2 + 2;
      *(_BYTE *)(v4 + 69) = v11;
    }
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
    v12 = *(_DWORD *)(a1 + 160);
    *(_WORD *)(a1 + 50) = 0;
    if ( *(_BYTE *)(v12 + 32) & 8 )
      v13 = a2 + 6;
    else
      v13 = a2 + 2;
    *(_BYTE *)(a1 + 69) = v13;
    LOBYTE(v3) = sub_1EEE0(a1);
  }
  return v3;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001C890) --------------------------------------------------------
int __cdecl sub_1C890(int a1, char a2)
{
  int result; // eax
  int i; // edx
  __int16 v4; // bx
  int v5; // edx
  int v6; // edx
  unsigned int v7; // edx
  char v8; // bl

  result = a1;
  for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
  {
    v5 = dword_EA3E4[i];
    if ( v5 == dword_EA3E4[0] )
      break;
    *(_BYTE *)(v5 + 69) = a2 + 5;
    v4 = *(_WORD *)(v5 + 36);
    if ( v4 )
      *(_WORD *)(a1 + 36) = v4;
  }
  HIWORD(v6) = HIWORD(dword_EA3E4[0]) ^ HIWORD(v5);
  LOWORD(v6) = *(_WORD *)(a1 + 36);
  v7 = dword_EA3E4[v6];
  if ( v7 > dword_EA3E4[0]
    && *(_BYTE *)(v7 + 63) == 3
    && !*(_BYTE *)(v7 + 64)
    && *(_WORD *)(a1 + 26) != *(_WORD *)(v7 + 26) )
  {
    v8 = *(_BYTE *)(a1 + 64);
    if ( v8 != 12 && v8 != 13 && v8 != 14 && v8 != 15 && v8 != 9 )
      ++*(_DWORD *)(*(_DWORD *)(v7 + 164) + 373);
  }
  *(_BYTE *)(a1 + 69) = a2 + 5;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001C930) --------------------------------------------------------
void __cdecl sub_1C930(int a1)
{
  int v1; // eax

  if ( !(*(_BYTE *)(a1 + 62) & 7) )
  {
    sub_36BA0(a1, 0);
    if ( !(*(_BYTE *)(a1 + 14) & 0x10) )
    {
      v1 = sub_4A190(a1 + 76, 10, 1);
      if ( v1 )
        *(_WORD *)(v1 + 26) = *(_WORD *)(a1 + 26);
    }
    sub_57F10(a1);
  }
}

//----- (0001C980) --------------------------------------------------------
int __cdecl sub_1C980(int a1, char a2)
{
  unsigned int v2; // ecx
  __int16 v3; // ax
  int i; // eax
  int v5; // edx
  int v6; // eax
  char v7; // al
  unsigned int v9; // eax
  unsigned int v10; // esi
  __int16 v11; // ax
  int v12; // edx
  int v13; // eax
  unsigned int j; // ecx
  int v15; // ecx
  unsigned int v16; // ST08_4

  v2 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    v3 = *(_WORD *)(a1 + 98);
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    *(_WORD *)(a1 + 38) = v3;
    v2 = 1;
    *(_WORD *)(a1 + 98) = 0;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        v2 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v2 < 1 )
  {
    if ( v2 )
      return 0;
    sub_1B8C0(a1);
    v9 = sub_1ED30(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
    v10 = v9;
    if ( v9 > dword_EA3E4[0] && *(_DWORD *)(v9 + 8) >= 0 && !(*(_BYTE *)(v9 + 13) & 4) )
    {
      if ( !(*(_BYTE *)(a1 + 62) & 3) )
      {
        v11 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v9 + 76));
        HIBYTE(v11) += 4;
        *(_WORD *)(a1 + 32) = v11;
        v12 = 4 * *(char *)(a1 + 64);
        v13 = dword_D41A4;
        *(_BYTE *)(a1 + 33) &= 7u;
        for ( j = *(_DWORD *)(v12 + v13 + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
        {
          if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26)
            && abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
            && abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78)) < (signed int)*(signed __int16 *)(a1 + 84) )
          {
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
            break;
          }
        }
      }
      v15 = *(_DWORD *)(a1 + 160);
      if ( *(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v15 + 26) )
        return 0;
      v16 = *(signed __int16 *)(v15 + 28);
      if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v10 + 76)) < v16 )
        return 0;
    }
    v7 = a2 + 1;
    goto LABEL_34;
  }
  if ( v2 <= 1 )
  {
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
    sub_1EEE0(a1);
    return 0;
  }
  if ( v2 == 2 )
  {
    v7 = a2 + 4;
LABEL_34:
    *(_BYTE *)(a1 + 69) = v7;
  }
  return 0;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001CC20) --------------------------------------------------------
signed int __cdecl sub_1CC20(_WORD *a1, unsigned int a2)
{
  _WORD *v2; // esi
  signed int v3; // edi
  int v4; // eax
  int v5; // ebx
  char v6; // al

  v2 = a1 + 38;
  v3 = 0;
  v4 = sub_4A190((int)(a1 + 38), 9, 0);
  v5 = v4;
  if ( v4 )
  {
    *(_BYTE *)(v4 + 67) = 10;
    *(_BYTE *)(v4 + 68) = 0;
    *(_WORD *)(v4 + 26) = a1[13];
    *(_WORD *)(v4 + 28) = sub_581E0(v2, (_WORD *)(a2 + 76));
    *(_WORD *)(v5 + 30) = sub_58210(v2, (_WORD *)(a2 + 76));
    *(_WORD *)(v5 + 80) += a1[44];
    *(_WORD *)(v5 + 150) = a1[75];
    *(_DWORD *)(v5 + 160) = &unk_D8478;
    *(_BYTE *)(v5 + 66) = *(_BYTE *)(a2 + 64);
    v6 = *(_BYTE *)(a2 + 63);
    *(_WORD *)(v5 + 42) = 500;
    v3 = 1;
    *(_BYTE *)(v5 + 65) = v6;
    sub_5EF70(a2);
  }
  return v3;
}

//----- (0001CCE0) --------------------------------------------------------
signed int __cdecl sub_1CCE0(_WORD *a1, unsigned int a2)
{
  _WORD *v2; // edi
  signed int v3; // esi
  int v4; // ebx
  char v5; // al

  v2 = a1 + 38;
  v3 = 0;
  v4 = sub_4A190((int)(a1 + 38), 9, 13);
  if ( v4 )
  {
    *(_WORD *)(v4 + 26) = a1[13];
    *(_WORD *)(v4 + 28) = sub_581E0(v2, (_WORD *)(a2 + 76));
    *(_WORD *)(v4 + 30) = sub_58210(v2, (_WORD *)(a2 + 76));
    *(_WORD *)(v4 + 80) += a1[44] / 2;
    *(_WORD *)(v4 + 150) = a1[75];
    *(_BYTE *)(v4 + 66) = *(_BYTE *)(a2 + 64);
    v5 = *(_BYTE *)(a2 + 63);
    *(_WORD *)(v4 + 42) = 250;
    *(_BYTE *)(v4 + 65) = v5;
    sub_49E10((_WORD *)v4, 195);
    v3 = 1;
    sub_5EF70(a2);
  }
  return v3;
}

//----- (0001CDA0) --------------------------------------------------------
signed int __cdecl sub_1CDA0(_WORD *a1, unsigned int a2)
{
  signed int v2; // edi
  int v3; // ebx
  _WORD *v5; // [esp+4h] [ebp-4h]

  v2 = 0;
  v5 = a1 + 38;
  v3 = sub_4A190((int)(a1 + 38), 9, 13);
  if ( v3 )
  {
    *(_WORD *)(v3 + 26) = a1[13];
    *(_WORD *)(v3 + 28) = sub_581E0(v5, (_WORD *)(a2 + 76));
    *(_WORD *)(v3 + 30) = sub_58210(v5, (_WORD *)(a2 + 76));
    *(_WORD *)(v3 + 80) += a1[44];
    *(_WORD *)(v3 + 150) = a1[75];
    *(_BYTE *)(v3 + 66) = *(_BYTE *)(a2 + 64);
    *(_BYTE *)(v3 + 65) = *(_BYTE *)(a2 + 63);
    if ( a1[74] )
      *(_WORD *)(v3 + 42) = 600;
    else
      *(_WORD *)(v3 + 42) = 400;
    sub_49E10((_WORD *)v3, 203);
    v2 = 1;
    sub_5EF70(a2);
  }
  return v2;
}

//----- (0001CE80) --------------------------------------------------------
signed int __cdecl sub_1CE80(int a1, int a2)
{
  signed int v2; // ebx

  v2 = 0;
  if ( (signed int)sub_583F0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76)) < 1024 )
  {
    v2 = 1;
    sub_11900(a1, a2, 0, *(_WORD *)(a1 + 42));
  }
  return v2;
}

//----- (0001CED0) --------------------------------------------------------
signed int __cdecl sub_1CED0(int a1, int a2)
{
  signed int v2; // ebx

  v2 = 0;
  if ( (signed int)sub_583F0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76)) < 768 )
  {
    v2 = 1;
    sub_11900(a1, a2, 0, *(_WORD *)(a1 + 42));
  }
  return v2;
}

//----- (0001CF20) --------------------------------------------------------
signed int __cdecl sub_1CF20(int a1, int a2)
{
  signed int v2; // ebx

  v2 = 0;
  if ( (signed int)sub_583F0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76)) < 1536 )
  {
    v2 = 1;
    sub_11900(a1, a2, 0, *(_WORD *)(a1 + 42));
  }
  return v2;
}

//----- (0001D0E0) --------------------------------------------------------
signed int __cdecl sub_1D0E0(_WORD *a1, unsigned int a2)
{
  _WORD *v2; // esi
  signed int v3; // edi
  int v4; // eax
  int v5; // ebx
  char v6; // al

  v2 = a1 + 38;
  v3 = 0;
  v4 = sub_4A190((int)(a1 + 38), 9, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_BYTE *)(v4 + 67) = 10;
    *(_BYTE *)(v4 + 68) = 65;
    *(_WORD *)(v4 + 26) = a1[13];
    *(_WORD *)(v4 + 28) = sub_581E0(v2, (_WORD *)(a2 + 76));
    *(_WORD *)(v5 + 30) = sub_58210(v2, (_WORD *)(a2 + 76));
    *(_WORD *)(v5 + 80) += a1[44];
    *(_WORD *)(v5 + 150) = a1[75];
    *(_DWORD *)(v5 + 160) = &unk_D8478;
    *(_BYTE *)(v5 + 66) = *(_BYTE *)(a2 + 64);
    v6 = *(_BYTE *)(a2 + 63);
    *(_WORD *)(v5 + 42) = 780;
    v3 = 1;
    *(_BYTE *)(v5 + 65) = v6;
    sub_5EF70(a2);
  }
  return v3;
}

//----- (0001D1A0) --------------------------------------------------------
signed int __cdecl sub_1D1A0(_WORD *a1, unsigned int a2)
{
  _WORD *v2; // esi
  signed int v3; // edi
  int v4; // eax
  int v5; // ebx
  __int16 v6; // ax
  __int16 v7; // dx

  v2 = a1 + 38;
  v3 = 0;
  v4 = sub_4A190((int)(a1 + 38), 9, 21);
  v5 = v4;
  if ( v4 )
  {
    *(_BYTE *)(v4 + 67) = 10;
    *(_BYTE *)(v4 + 68) = 66;
    *(_WORD *)(v4 + 26) = a1[13];
    *(_WORD *)(v4 + 28) = sub_581E0(v2, (_WORD *)(a2 + 76));
    v6 = sub_58210(v2, (_WORD *)(a2 + 76));
    v7 = *(_WORD *)(v5 + 80);
    *(_WORD *)(v5 + 30) = v6;
    *(_WORD *)(v5 + 80) = v7 + 128;
    *(_WORD *)(v5 + 150) = a1[75];
    *(_DWORD *)(v5 + 160) = &unk_D8478;
    *(_BYTE *)(v5 + 66) = *(_BYTE *)(a2 + 64);
    LOBYTE(v6) = *(_BYTE *)(a2 + 63);
    *(_WORD *)(v5 + 42) = 780;
    v3 = 1;
    *(_BYTE *)(v5 + 65) = v6;
    sub_5EF70(a2);
  }
  return v3;
}

//----- (0001D260) --------------------------------------------------------
signed int __cdecl sub_1D260(int a1, unsigned int a2)
{
  int v2; // eax
  int v3; // ebx
  char v4; // al
  signed int v6; // [esp+0h] [ebp-4h]

  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  v6 = 0;
  word_EB39C += *(_WORD *)(a1 + 88);
  v2 = sub_4A190((int)&word_EB398, 9, 9);
  v3 = v2;
  if ( v2 )
  {
    *(_BYTE *)(v2 + 67) = 10;
    *(_BYTE *)(v2 + 68) = 23;
    *(_WORD *)(v2 + 26) = *(_WORD *)(a1 + 26);
    *(_WORD *)(v2 + 28) = sub_581E0(&word_EB398, (_WORD *)(a2 + 76));
    *(_WORD *)(v3 + 30) = sub_58210(&word_EB398, (_WORD *)(a2 + 76));
    *(_WORD *)(v3 + 150) = *(_WORD *)(a1 + 150);
    *(_DWORD *)(v3 + 160) = &off_D8456;
    *(_BYTE *)(v3 + 66) = *(_BYTE *)(a2 + 64);
    v4 = *(_BYTE *)(a2 + 63);
    *(_WORD *)(v3 + 42) = 4000;
    *(_BYTE *)(v3 + 65) = v4;
    sub_5EF70(a2);
    v6 = 1;
  }
  return v6;
}
// D8456: using guessed type void *off_D8456;
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0001D460) --------------------------------------------------------
signed int __cdecl sub_1D460(_WORD *a1, int a2)
{
  unsigned __int16 v2; // si
  signed __int16 v3; // di
  int v4; // eax
  _WORD *v5; // ebx
  __int16 v6; // ax
  __int16 v7; // cx
  _WORD *v9; // [esp+4h] [ebp-8h]
  signed int v10; // [esp+8h] [ebp-4h]

  v2 = 0;
  v10 = 0;
  do
  {
    switch ( v2 )
    {
      case 0u:
        v3 = -226;
        break;
      case 1u:
        v3 = -113;
        break;
      case 2u:
        v3 = 0;
        break;
      case 3u:
        v3 = 113;
        break;
      default:
        v3 = 226;
        break;
    }
    v9 = a1 + 38;
    v4 = sub_4A190((int)(a1 + 38), 9, 0);
    v5 = (_WORD *)v4;
    if ( v4 )
    {
      *(_BYTE *)(v4 + 67) = 10;
      *(_BYTE *)(v4 + 68) = 0;
      *(_DWORD *)(v4 + 160) = &unk_D83F0;
      *(_BYTE *)(v4 + 66) = *(_BYTE *)(a2 + 64);
      *(_BYTE *)(v4 + 65) = *(_BYTE *)(a2 + 63);
      *(_WORD *)(v4 + 42) = 800;
      *(_WORD *)(v4 + 26) = a1[13];
      *(_WORD *)(v4 + 28) = v3 + sub_581E0(v9, (_WORD *)(a2 + 76));
      v6 = sub_58210(v9, (_WORD *)(a2 + 76));
      v7 = v5[40];
      v5[15] = v6;
      v5[40] = v7 + 200;
      v10 = 1;
      v5[75] = a1[75];
    }
    ++v2;
  }
  while ( v2 < 5u );
  return v10;
}

//----- (0001D5D0) --------------------------------------------------------
void __cdecl sub_1D5D0(int a1, __int16 a2)
{
  switch ( *(_BYTE *)(a1 + 73) )
  {
    case 1:
      sub_1DDA0(a1, a2);
      break;
    case 2:
      sub_1DBF0(a1, a2);
      break;
    case 3:
      sub_1D7C0(a1, a2);
      break;
    case 4:
      sub_1D700(a1, a2);
      break;
    case 5:
      sub_1D8C0(a1, a2);
      break;
    case 6:
      sub_1E000(a1, a2);
      break;
    case 7:
      sub_1E020(a1, a2);
      break;
    case 8:
      sub_1D880(a1, a2);
      break;
    case 9:
      sub_1D8A0(a1, a2);
      break;
    case 0xA:
      sub_1E040(a1, a2);
      break;
    case 0xC:
      sub_1E4D0(a1);
      break;
    case 0xD:
    case 0x10:
      sub_1E580(a1, a2);
      break;
    case 0xE:
      sub_1E9C0(a1, a2);
      break;
    case 0x11:
      sub_1E320(a1);
      break;
    default:
      return;
  }
}

//----- (0001D700) --------------------------------------------------------
void __cdecl sub_1D700(int a1, __int16 a2)
{
  char *v2; // esi
  unsigned int v3; // esi
  unsigned __int16 v4; // dx
  unsigned int v5; // edi

  sub_1D8C0(a1, a2);
  if ( !(*(_BYTE *)(a1 + 62) & 7) )
  {
    v2 = (char *)&loc_365F2 + 8 * *(unsigned __int8 *)(a1 + 72) + dword_D41A0 + 2;
    if ( v2[1] & 2 )
      v3 = dword_EA3E4[*(signed __int16 *)(a1 + 74)];
    else
      v3 = *((_DWORD *)v2 + 1);
    if ( v3 )
    {
      if ( v3 > dword_EA3E4[0] )
      {
        v4 = *(_WORD *)(v3 + 150);
        if ( v4 )
        {
          v5 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
          if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(dword_EA3E4[v4] + 76)) <= v5 )
          {
            *(_WORD *)(a1 + 150) = *(_WORD *)(v3 + 150);
            *(_BYTE *)(a1 + 73) = 10;
            sub_1E040(a1, a2);
          }
        }
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001D7C0) --------------------------------------------------------
void __cdecl sub_1D7C0(int a1, __int16 a2)
{
  char *v2; // esi
  unsigned int v3; // esi
  unsigned int v4; // edi

  sub_1D8C0(a1, a2);
  if ( !(*(_BYTE *)(a1 + 62) & 7) )
  {
    v2 = (char *)&loc_365F2 + 8 * *(unsigned __int8 *)(a1 + 72) + dword_D41A0 + 2;
    if ( v2[1] & 2 )
      v3 = dword_EA3E4[*(signed __int16 *)(a1 + 74)];
    else
      v3 = *((_DWORD *)v2 + 1);
    if ( v3 && v3 > dword_EA3E4[0] )
    {
      v4 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
      if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76)) <= v4 )
      {
        *(_WORD *)(a1 + 150) = (signed int)(v3 - (dword_D41A0 + 28302)) / 168;
        *(_BYTE *)(a1 + 73) = 10;
        sub_1E040(a1, a2);
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001D880) --------------------------------------------------------
char __cdecl sub_1D880(int a1, __int16 a2)
{
  return sub_1E1C0(a1, a2);
}

//----- (0001D8A0) --------------------------------------------------------
char __cdecl sub_1D8A0(int a1, __int16 a2)
{
  return sub_1E1C0(a1, a2);
}

//----- (0001D8C0) --------------------------------------------------------
void __cdecl sub_1D8C0(int a1, __int16 a2)
{
  unsigned int v2; // ecx
  __int16 v3; // ax
  int i; // eax
  int v5; // eax
  int v6; // esi
  int v7; // eax
  char v8; // al
  char v9; // cl
  char v10; // al
  int v11; // esi
  _WORD *v12; // esi
  __int16 v13; // ax
  char v14; // dl
  unsigned __int16 v15; // ax
  unsigned int j; // ecx

  v2 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v3 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v2 = 1;
    *(_WORD *)(a1 + 38) = v3;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) && *(_BYTE *)(a1 + 64) != 27 )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        v2 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v2 < 1 )
  {
    if ( !v2 )
    {
      sub_1B8C0(a1);
      if ( !(*(_BYTE *)(a1 + 62) & 7) )
      {
        v11 = dword_D41A0 + 8 * *(unsigned __int8 *)(a1 + 72);
        if ( *(_BYTE *)(v11 + 222709) & 2 )
        {
          if ( !*(_WORD *)(a1 + 74) )
            *(_WORD *)(a1 + 74) = sub_1E3E0(a1);
          v12 = (_WORD *)dword_EA3E4[*(signed __int16 *)(a1 + 74)];
        }
        else
        {
          v12 = *(_WORD **)((char *)sub_365F8 + v11);
        }
        if ( v12 && (unsigned int)v12 > dword_EA3E4[0] )
        {
          if ( !(*(_BYTE *)(a1 + 14) & 4) )
          {
            v13 = sub_581E0((_WORD *)(a1 + 76), v12 + 38);
            v14 = *(_BYTE *)(a1 + 62);
            *(_WORD *)(a1 + 32) = v13;
            if ( !(v14 & 0x3F) )
            {
              *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
              v15 = *(_WORD *)(a1 + 20);
              *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
              *(_WORD *)(a1 + 32) += (2 * ((signed int)(v15 % 0x9Du) / 79) - 1) * ((*(_WORD *)(a1 + 20) & 0xFF) + 85);
              *(_BYTE *)(a1 + 33) &= 7u;
            }
          }
          for ( j = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
          {
            if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26)
              && abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
              && abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78)) < (signed int)*(signed __int16 *)(a1 + 84) )
            {
              *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
              break;
            }
          }
          if ( abs(*(signed __int16 *)(a1 + 76) - (signed __int16)v12[38]) < *(signed __int16 *)(a1 + 84)
                                                                           + (signed __int16)v12[42]
            && abs(*(signed __int16 *)(a1 + 78) - (signed __int16)v12[39]) < *(signed __int16 *)(a1 + 84)
                                                                           + (signed __int16)v12[42] )
          {
            *(_WORD *)(a1 + 32) = sub_581E0(v12 + 38, (_WORD *)(a1 + 76));
          }
        }
        else if ( !(*(_BYTE *)(a1 + 62) & 0xF) && !(*(_BYTE *)(a1 + 14) & 4) )
        {
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          *(_WORD *)(a1 + 32) += *(_WORD *)(a1 + 20) % 0x71u + 142;
          *(_BYTE *)(a1 + 33) &= 7u;
        }
      }
    }
  }
  else if ( v2 <= 1 )
  {
    v7 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
    if ( *(_BYTE *)(v7 + 63) != *(_BYTE *)(a1 + 63) || (v8 = *(_BYTE *)(v7 + 64), v9 = *(_BYTE *)(a1 + 64), v8 != v9) )
      v10 = 1;
    else
      v10 = v9 ^ v8;
    if ( v10 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      *(_BYTE *)(a1 + 73) = 10;
      sub_1E040(a1, a2);
    }
    sub_1EEE0(a1);
  }
  else if ( v2 == 2 )
  {
    *(_BYTE *)(a1 + 69) = a2 + 4;
  }
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001DBF0) --------------------------------------------------------
int __cdecl sub_1DBF0(int a1, unsigned __int16 a2)
{
  char *v2; // esi
  int result; // eax
  int v4; // esi
  unsigned int v5; // edi
  unsigned int v6; // esi
  int v7; // ecx
  __int16 v8; // dx
  int v9; // ST08_4
  __int16 v10; // ax
  unsigned int v11; // [esp+4h] [ebp-Ch]
  unsigned int v12; // [esp+8h] [ebp-8h]
  unsigned int v13; // [esp+Ch] [ebp-4h]

  v2 = (char *)&loc_365F2 + 8 * *(unsigned __int8 *)(a1 + 72) + dword_D41A0 + 2;
  if ( abs(*((signed __int16 *)v2 + 2) - *(signed __int16 *)(a1 + 76)) > 3072
    || abs(*((signed __int16 *)v2 + 3) - *(signed __int16 *)(a1 + 78)) > 3072 )
  {
    sub_1DDA0(a1, a2);
  }
  else
  {
    sub_1E1C0(a1, a2);
  }
  result = a2 + 7;
  if ( *(unsigned __int8 *)(a1 + 69) == result && *(_BYTE *)(a1 + 73) == 2 )
  {
    if ( *(_BYTE *)(a1 + 57) )
    {
      v4 = *(_DWORD *)(a1 + 160);
      result = *(unsigned __int8 *)(a1 + 62) / *(signed __int16 *)(v4 + 26);
      if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v4 + 26)) )
      {
        result = *(signed __int16 *)(v4 + 28) * *(signed __int16 *)(v4 + 28);
        v5 = 0;
        v12 = -1;
        v6 = *(_DWORD *)(dword_D41A4 + 38519);
        v11 = result;
        while ( v6 > dword_EA3E4[0] )
        {
          v7 = (signed __int16)(*(_WORD *)(v6 + 76) - *(_WORD *)(a1 + 76));
          v8 = *(_WORD *)(v6 + 78) - *(_WORD *)(a1 + 78);
          v13 = v8 * v8 + v7 * v7;
          result = v13;
          if ( v13 <= v11 && !(*(_BYTE *)(v6 + 12) & 0x20) )
          {
            v9 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 30);
            v10 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v6 + 76));
            result = (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v10);
            if ( result < v9 )
            {
              result = v13;
              if ( v13 < v12 )
              {
                v5 = v6;
                v12 = v13;
              }
            }
          }
          v6 = *(_DWORD *)v6;
        }
        if ( v5 )
        {
          *(_WORD *)(a1 + 150) = (signed int)(v5 - (dword_D41A0 + 28302)) / 168;
          *(_BYTE *)(a1 + 73) = 10;
          result = sub_1E040(a1, a2);
        }
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001DDA0) --------------------------------------------------------
char __cdecl sub_1DDA0(int a1, __int16 a2)
{
  signed int v2; // eax
  __int16 v3; // ax
  int i; // edx
  int v5; // edx
  int v6; // ecx
  int v7; // eax
  char v8; // al
  char v9; // cl
  char v10; // al
  unsigned __int16 v11; // ax
  unsigned int j; // ecx
  __int16 v14; // [esp+0h] [ebp-Ch]
  __int16 v15; // [esp+2h] [ebp-Ah]
  char v16; // [esp+8h] [ebp-4h]

  v2 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v3 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v3;
    v2 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) && *(_BYTE *)(a1 + 64) != 27 )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        v2 = 1;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v2 = 2;
  }
  if ( (unsigned int)v2 < 1 )
  {
    if ( !v2 )
    {
      LOBYTE(v2) = sub_1B8C0(a1);
      if ( !(*(_BYTE *)(a1 + 62) & 7) )
      {
        v14 = *(_WORD *)((char *)sub_365F8 + 8 * *(unsigned __int8 *)(a1 + 72) + dword_D41A0);
        v15 = *(_WORD *)(dword_D41A0 + 8 * *(unsigned __int8 *)(a1 + 72) + 222714);
        if ( !(*(_BYTE *)(a1 + 14) & 4) )
        {
          *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), &v14);
          if ( !(*(_BYTE *)(a1 + 62) & 0x3F) )
          {
            *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
            v11 = *(_WORD *)(a1 + 20);
            *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
            *(_WORD *)(a1 + 32) += ((*(_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v11 % 0x9Du) / 79) - 1);
            *(_BYTE *)(a1 + 33) &= 7u;
          }
        }
        v2 = *(char *)(a1 + 64);
        v16 = 0;
        for ( j = *(_DWORD *)(dword_D41A4 + 4 * v2 + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
        {
          LOWORD(v2) = *(_WORD *)(j + 26);
          if ( (_WORD)v2 != *(_WORD *)(a1 + 26) )
          {
            v2 = abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76));
            if ( v2 < *(signed __int16 *)(a1 + 84) )
            {
              v2 = abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78));
              if ( v2 < *(signed __int16 *)(a1 + 84) )
              {
                LOWORD(v2) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
                *(_WORD *)(a1 + 32) = v2;
                v16 = 1;
                return v2;
              }
            }
          }
        }
      }
    }
  }
  else if ( (unsigned int)v2 <= 1 )
  {
    v7 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
    if ( *(_BYTE *)(v7 + 63) != *(_BYTE *)(a1 + 63) || (v8 = *(_BYTE *)(v7 + 64), v9 = *(_BYTE *)(a1 + 64), v8 != v9) )
      v10 = 1;
    else
      v10 = v9 ^ v8;
    if ( v10 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      *(_BYTE *)(a1 + 73) = 10;
      sub_1E040(a1, a2);
    }
    LOBYTE(v2) = sub_1EEE0(a1);
  }
  else if ( v2 == 2 )
  {
    LOBYTE(v2) = a2 + 4;
    *(_BYTE *)(a1 + 69) = a2 + 4;
  }
  return v2;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001E000) --------------------------------------------------------
char __cdecl sub_1E000(int a1, __int16 a2)
{
  return sub_1E1C0(a1, a2);
}

//----- (0001E020) --------------------------------------------------------
char __cdecl sub_1E020(int a1, __int16 a2)
{
  return sub_1E1C0(a1, a2);
}

//----- (0001E040) --------------------------------------------------------
int __cdecl sub_1E040(int a1, char a2)
{
  int result; // eax
  char v3; // bl

  result = *(_DWORD *)(a1 + 160);
  if ( *(_BYTE *)(result + 32) & 8 )
    v3 = a2 + 6;
  else
    v3 = a2 + 2;
  *(_BYTE *)(a1 + 69) = v3;
  return result;
}

//----- (0001E1C0) --------------------------------------------------------
char __cdecl sub_1E1C0(int a1, __int16 a2)
{
  unsigned int v2; // eax
  __int16 v3; // ax
  int i; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // eax
  char v8; // al
  char v9; // cl
  char v10; // al

  v2 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v3 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v3;
    v2 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) && *(_BYTE *)(a1 + 64) != 27 )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        v2 = 1;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v2 = 2;
  }
  if ( v2 < 1 )
  {
    if ( !v2 )
    {
      v2 = *(_DWORD *)(a1 + 160);
      if ( !(*(_BYTE *)(v2 + 32) & 2) )
      {
        sub_1B8C0(a1);
        LOBYTE(v2) = *(_BYTE *)(a1 + 62);
        if ( !(v2 & 0xF) && !(*(_BYTE *)(a1 + 14) & 4) )
        {
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          v2 = *(unsigned __int16 *)(a1 + 20) % 0x71u + 142 + *(unsigned __int16 *)(a1 + 32);
          *(_WORD *)(a1 + 32) = v2;
          *(_BYTE *)(a1 + 33) &= 7u;
        }
      }
    }
  }
  else if ( v2 <= 1 )
  {
    v7 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
    if ( *(_BYTE *)(v7 + 63) != *(_BYTE *)(a1 + 63) || (v8 = *(_BYTE *)(v7 + 64), v9 = *(_BYTE *)(a1 + 64), v8 != v9) )
      v10 = 1;
    else
      v10 = v9 ^ v8;
    if ( v10 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      *(_BYTE *)(a1 + 73) = 10;
      sub_1E040(a1, a2);
    }
    LOBYTE(v2) = sub_1EEE0(a1);
  }
  else if ( v2 == 2 )
  {
    LOBYTE(v2) = a2 + 4;
    *(_BYTE *)(a1 + 69) = a2 + 4;
  }
  return v2;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001E320) --------------------------------------------------------
char __cdecl sub_1E320(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // dx

  sub_1B8C0(a1);
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    LOBYTE(v1) = sub_57F10(a1);
    return v1;
  }
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  if ( v1 <= dword_EA3E4[0] || *(_DWORD *)(v1 + 8) < 0 || *(_BYTE *)(v1 + 13) & 4 )
    goto LABEL_14;
  LOWORD(v1) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
  v2 = *(_WORD *)(a1 + 130);
  *(_WORD *)(a1 + 32) = v1;
  v2 -= 8;
  *(_WORD *)(a1 + 130) = v2;
  if ( v2 <= 16 )
  {
    LOBYTE(v1) = *(_BYTE *)(a1 + 64);
    if ( (unsigned __int8)v1 < 0x13u )
    {
      if ( !(_BYTE)v1 )
        *(_WORD *)(a1 + 130) = 30;
    }
    else if ( (unsigned __int8)v1 <= 0x13u )
    {
      *(_WORD *)(a1 + 130) = 76;
    }
    else if ( (_BYTE)v1 == 21 )
    {
      *(_WORD *)(a1 + 130) = 96;
    }
LABEL_14:
    *(_BYTE *)(a1 + 73) = 16;
  }
  return v1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001E3E0) --------------------------------------------------------
int __cdecl sub_1E3E0(int a1)
{
  unsigned int v1; // edi
  int v2; // ebx
  int v3; // edx
  unsigned int i; // eax
  unsigned int j; // esi
  unsigned int v6; // eax
  unsigned int v8; // [esp+0h] [ebp-4h]

  v8 = -1;
  v1 = 0;
  v2 = 0;
  if ( *(_BYTE *)(dword_D41A0 + 8 * *(unsigned __int8 *)(a1 + 72) + 222709) & 1 )
  {
    HIWORD(v3) = HIWORD(dword_D41A4);
    for ( i = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); i > dword_EA3E4[0] && !(_WORD)v2; i = *(_DWORD *)i )
    {
      if ( *(_BYTE *)(i + 72) == *(_BYTE *)(a1 + 72) )
      {
        LOWORD(v3) = *(_WORD *)(i + 74);
        if ( (_WORD)v3 )
          v2 = v3;
      }
    }
  }
  if ( !(_WORD)v2 )
  {
    for ( j = *(_DWORD *)(dword_D41A4
                        + 4 * *(unsigned __int16 *)((char *)sub_365F8 + 8 * *(unsigned __int8 *)(a1 + 72) + dword_D41A0)
                        + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
    {
      v6 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(j + 76));
      if ( v6 < v8 )
      {
        v8 = v6;
        v1 = j;
      }
    }
    if ( v1 )
      v2 = (signed int)(v1 - (dword_D41A0 + 28302)) / 168;
  }
  return v2;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001E4D0) --------------------------------------------------------
int __cdecl sub_1E4D0(int a1)
{
  unsigned int v1; // ebx
  unsigned __int8 v2; // al
  int v3; // edx
  int result; // eax

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
  if ( v1 <= dword_EA3E4[0] || *(_DWORD *)(v1 + 8) < 0 )
    return sub_57F10(a1);
  word_EB398 = *(_WORD *)(v1 + 76);
  v2 = *(_BYTE *)(a1 + 64);
  word_EB39A = *(_WORD *)(v1 + 78);
  v3 = *(signed __int16 *)(v1 + 80);
  if ( v2 >= 0x10u )
  {
    if ( v2 <= 0x10u )
    {
      v3 -= 896;
    }
    else if ( v2 > 0x13u && v2 == 25 )
    {
      v3 -= 512;
    }
  }
  if ( v3 <= 0 )
    LOWORD(v3) = 0;
  word_EB39C = v3;
  result = sub_57CF0(a1, (int)&word_EB398);
  *(_WORD *)(a1 + 32) = *(_WORD *)(v1 + 32);
  *(_WORD *)(a1 + 28) = *(_WORD *)(v1 + 28);
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0001E580) --------------------------------------------------------
void __cdecl sub_1E580(int a1, __int16 a2)
{
  unsigned int v2; // eax
  unsigned int v3; // esi
  unsigned int v4; // edi
  __int16 v5; // si
  char v6; // [esp+0h] [ebp-4h]

  v6 = 0;
  v2 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
  if ( v2 <= dword_EA3E4[0] || *(_DWORD *)(v2 + 8) < 0 || *(_BYTE *)(v2 + 13) & 4 )
  {
    *(_WORD *)(a1 + 46) = 0;
  }
  else if ( *(_BYTE *)(a1 + 73) == 13 )
  {
    --*(_WORD *)(a1 + 46);
  }
  if ( *(_WORD *)(a1 + 46) <= 0 )
  {
    v6 = 1;
  }
  else
  {
    v3 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v3 > dword_EA3E4[0] && (*(_DWORD *)(v3 + 8) <= 0 || *(_BYTE *)(v3 + 13) & 4) )
    {
      *(_WORD *)(a1 + 150) = 0;
      v3 = dword_EA3E4[0];
    }
    if ( v3 <= dword_EA3E4[0] && !(*(_BYTE *)(a1 + 62) & 7) )
    {
      v3 = sub_16FC0(v2, v2);
      *(_WORD *)(a1 + 150) = (signed int)(v3 - (dword_D41A0 + 28302)) / 168;
    }
    if ( v3 <= dword_EA3E4[0] )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 40);
      sub_1E700(a1, a2);
      v5 = *(_WORD *)(a1 + 46);
      *(_WORD *)(a1 + 150) = 0;
      *(_WORD *)(a1 + 46) = v5 - 4;
    }
    else
    {
      sub_1E700(a1, a2);
      if ( !(*(_BYTE *)(a1 + 62) & 7) )
      {
        v4 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
        if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76)) < v4 )
          *(_BYTE *)(a1 + 69) = a2 + 2;
      }
    }
  }
  if ( v6 )
  {
    if ( *(_BYTE *)(a1 + 73) == 13 )
      sub_4A190(a1 + 76, 10, 73);
    sub_4A190(a1 + 76, 10, 0);
    sub_57F10(a1);
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001E700) --------------------------------------------------------
void __cdecl sub_1E700(int a1, char a2)
{
  unsigned int v2; // eax
  __int16 v3; // ax
  int i; // edx
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  char v8; // al
  char v9; // al
  unsigned int v10; // eax
  __int16 v11; // ax
  char v12; // ch
  unsigned __int16 v13; // ax
  unsigned int j; // ecx

  v2 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v3 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v3;
    v2 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) && *(_BYTE *)(a1 + 64) != 27 )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        v2 = 1;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v2 = 2;
  }
  if ( v2 < 1 )
  {
    if ( !v2 )
    {
      sub_1B8C0(a1);
      if ( !(*(_BYTE *)(a1 + 62) & 7) )
      {
        v10 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
        if ( v10 > dword_EA3E4[0] )
        {
          if ( !(*(_BYTE *)(a1 + 14) & 4) )
          {
            v11 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v10 + 76));
            v12 = *(_BYTE *)(a1 + 62);
            *(_WORD *)(a1 + 32) = v11;
            if ( !(v12 & 0x3F) )
            {
              *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
              v13 = *(_WORD *)(a1 + 20);
              *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
              *(_WORD *)(a1 + 32) += ((*(_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v13 % 0x9Du) / 79) - 1);
              *(_BYTE *)(a1 + 33) &= 7u;
            }
          }
          for ( j = *(_DWORD *)(4 * *(char *)(a1 + 64) + dword_D41A4 + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
          {
            if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26)
              && abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
              && abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78)) < (signed int)*(signed __int16 *)(a1 + 84) )
            {
              *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
              return;
            }
          }
        }
      }
    }
  }
  else if ( v2 <= 1 )
  {
    sub_1B8C0(a1);
    v7 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
    v8 = 1;
    if ( *(_BYTE *)(v7 + 63) == *(_BYTE *)(a1 + 63) && *(_BYTE *)(v7 + 64) == *(_BYTE *)(a1 + 64) )
      v8 = 0;
    if ( *(_WORD *)(a1 + 40) == *(_WORD *)(a1 + 38) )
      v8 = 0;
    if ( v8 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 160) + 32) & 8 )
        v9 = a2 + 6;
      else
        v9 = a2 + 2;
      *(_BYTE *)(a1 + 69) = v9;
      sub_6D8B0(*(_WORD *)(a1 + 40), 0x13u, 1);
    }
  }
  else if ( v2 == 2 )
  {
    *(_WORD *)(a1 + 46) = 1;
  }
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001E9C0) --------------------------------------------------------
void __cdecl sub_1E9C0(int a1, __int16 a2)
{
  __int16 v2; // cx
  unsigned int v3; // esi
  char v4; // al
  int i; // eax
  char v6; // dl
  int v7; // eax
  unsigned __int16 v8; // di
  unsigned __int16 v9; // ax
  unsigned int v10; // esi
  unsigned int v11; // edi
  int v12; // esi
  int v13; // edx
  int j; // eax
  int v15; // eax
  signed __int16 v16; // [esp+0h] [ebp-4h]

  v2 = *(_WORD *)(a1 + 46) - 1;
  v16 = 0;
  *(_WORD *)(a1 + 46) = v2;
  if ( v2 <= 0 )
    goto LABEL_66;
  v3 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
  v4 = 0;
  if ( v2 <= *(signed __int16 *)(a1 + 48) - 16 && *(_WORD *)(a1 + 46) >= 16 )
  {
    if ( (*(_BYTE *)(a1 + 62) & 0x1C) == 16 )
      v4 = *(_BYTE *)(a1 + 62) & 3;
  }
  else
  {
    v4 = *(_BYTE *)(a1 + 62) & 1 ? 0 : 2;
  }
  switch ( v4 )
  {
    case 0:
      *(_BYTE *)(a1 + 15) &= 0xF9u;
      break;
    case 1:
    case 3:
      *(_BYTE *)(a1 + 15) = (*(_BYTE *)(a1 + 15) | 2) & 0xFB;
      break;
    case 2:
      *(_BYTE *)(a1 + 15) = *(_BYTE *)(a1 + 15) & 0xF9 | 4;
      break;
    default:
      break;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v7 + 52) )
    {
      v7 = dword_EA3E4[i];
      if ( v7 == dword_EA3E4[0] )
        break;
      v6 = 0;
      if ( *(signed __int16 *)(a1 + 46) <= *(signed __int16 *)(a1 + 48) - 16 && *(_WORD *)(a1 + 46) >= 16 )
      {
        if ( (*(_BYTE *)(a1 + 62) & 0x1C) == 16 )
          v6 = *(_BYTE *)(a1 + 62) & 3;
      }
      else if ( *(_BYTE *)(a1 + 62) & 1 )
      {
        v6 = 0;
      }
      else
      {
        v6 = 2;
      }
      switch ( v6 )
      {
        case 0:
          *(_BYTE *)(v7 + 15) &= 0xF9u;
          break;
        case 1:
        case 3:
          *(_BYTE *)(v7 + 15) = (*(_BYTE *)(v7 + 15) | 2) & 0xFB;
          break;
        case 2:
          *(_BYTE *)(v7 + 15) = *(_BYTE *)(v7 + 15) & 0xF9 | 4;
          break;
        default:
          continue;
      }
    }
  }
  if ( v3 <= dword_EA3E4[0] || *(_DWORD *)(v3 + 8) <= 0 )
  {
LABEL_66:
    v16 = 1;
  }
  else
  {
    v8 = *(_WORD *)(a1 + 150);
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 40);
    sub_1E700(a1, a2);
    v9 = *(_WORD *)(v3 + 150);
    if ( !v9 && *(_WORD *)(v3 + 38) )
      v9 = *(_WORD *)(v3 + 38);
    if ( v9 && v8 != v9 )
      v8 = v9;
    *(_WORD *)(a1 + 150) = v8;
    if ( v8 )
    {
      v10 = dword_EA3E4[v8];
      if ( v10 > dword_EA3E4[0]
        && (*(_WORD *)(v10 + 40) == *(_WORD *)(a1 + 40) && *(_BYTE *)(v10 + 73) == 14
         || *(_DWORD *)(v10 + 8) <= 0
         || *(_BYTE *)(v10 + 13) & 4) )
      {
        *(_WORD *)(a1 + 150) = 0;
        v10 = dword_EA3E4[0];
      }
      if ( v10 > dword_EA3E4[0] )
      {
        v11 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
        if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v10 + 76)) < v11 )
        {
          *(_WORD *)(a1 + 150) = (signed int)(v10 - (dword_D41A0 + 28302)) / 168;
          *(_BYTE *)(a1 + 69) = a2 + 2;
          sub_6D8B0(*(_WORD *)(a1 + 40), 0x18u, 1);
        }
      }
    }
  }
  if ( v16 )
  {
    *(_BYTE *)(a1 + 73) = 10;
    *(_WORD *)(a1 + 150) = 0;
    *(_WORD *)(a1 + 40) = 0;
    v12 = *(signed __int16 *)(a1 + 46);
    v13 = *(signed __int16 *)(a1 + 48) - 16;
    *(_BYTE *)(a1 + 72) = *(_BYTE *)(a1 + 74);
    if ( v12 <= v13 )
      *(_WORD *)(a1 + 46);
    switch ( 0 )
    {
      case 0:
        *(_BYTE *)(a1 + 15) &= 0xF9u;
        break;
      case 1:
      case 3:
        *(_BYTE *)(a1 + 15) = (*(_BYTE *)(a1 + 15) | 2) & 0xFB;
        break;
      case 2:
        *(_BYTE *)(a1 + 15) = *(_BYTE *)(a1 + 15) & 0xF9 | 4;
        break;
      default:
        break;
    }
    if ( *(_WORD *)(a1 + 52) )
    {
      for ( j = *(unsigned __int16 *)(a1 + 52); ; j = *(unsigned __int16 *)(v15 + 52) )
      {
        v15 = dword_EA3E4[j];
        if ( v15 == dword_EA3E4[0] )
          break;
        if ( *(signed __int16 *)(a1 + 46) <= *(signed __int16 *)(a1 + 48) - 16 )
          *(_WORD *)(a1 + 46);
        switch ( 0 )
        {
          case 0:
            *(_BYTE *)(v15 + 15) &= 0xF9u;
            break;
          case 1:
          case 3:
            *(_BYTE *)(v15 + 15) = (*(_BYTE *)(v15 + 15) | 2) & 0xFB;
            break;
          case 2:
            *(_BYTE *)(v15 + 15) = *(_BYTE *)(v15 + 15) & 0xF9 | 4;
            break;
          default:
            continue;
        }
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001ED30) --------------------------------------------------------
int __cdecl sub_1ED30(int a1, int a2)
{
  int v2; // ebx
  char v3; // dl
  int i; // edx
  char v5; // cl
  char v6; // cl
  int v7; // edx
  __int16 v8; // dx
  unsigned int v9; // eax
  unsigned __int16 v10; // ax

  v2 = a2;
  if ( *(_BYTE *)(a1 + 73) == 14 )
  {
    v3 = 0;
    if ( *(signed __int16 *)(a1 + 48) - 16 >= *(signed __int16 *)(a1 + 46) && *(_WORD *)(a1 + 46) >= 16 )
    {
      if ( (*(_BYTE *)(a1 + 62) & 0x1C) == 16 )
        v3 = *(_BYTE *)(a1 + 62) & 3;
    }
    else if ( *(_BYTE *)(a1 + 62) & 1 )
    {
      v3 = 0;
    }
    else
    {
      v3 = 2;
    }
    switch ( v3 )
    {
      case 0:
        *(_BYTE *)(a1 + 15) &= 0xF9u;
        break;
      case 1:
      case 3:
        *(_BYTE *)(a1 + 15) = (*(_BYTE *)(a1 + 15) | 2) & 0xFB;
        break;
      case 2:
        *(_BYTE *)(a1 + 15) = *(_BYTE *)(a1 + 15) & 0xF9 | 4;
        break;
      default:
        break;
    }
    if ( *(_WORD *)(a1 + 52) )
    {
      for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v7 + 52) )
      {
        v7 = dword_EA3E4[i];
        if ( v7 == dword_EA3E4[0] )
          break;
        v5 = 0;
        if ( *(signed __int16 *)(a1 + 46) <= *(signed __int16 *)(a1 + 48) - 16 && *(_WORD *)(a1 + 46) >= 16 )
        {
          if ( (*(_BYTE *)(a1 + 62) & 0x1C) == 16 )
            v5 = *(_BYTE *)(a1 + 62) & 3;
        }
        else if ( *(_BYTE *)(a1 + 62) & 1 )
        {
          v5 = 0;
        }
        else
        {
          v5 = 2;
        }
        switch ( v5 )
        {
          case 0:
            *(_BYTE *)(v7 + 15) &= 0xF9u;
            break;
          case 1:
          case 3:
            v6 = (*(_BYTE *)(v7 + 15) | 2) & 0xFB;
            goto LABEL_26;
          case 2:
            v6 = *(_BYTE *)(v7 + 15) & 0xF9 | 4;
LABEL_26:
            *(_BYTE *)(v7 + 15) = v6;
            break;
          default:
            continue;
        }
      }
    }
    v8 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v8;
    if ( v8 <= 0 )
      return dword_EA3E4[0];
    v9 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v9 > dword_EA3E4[0] )
    {
      if ( a2 == v9 )
        return dword_EA3E4[0];
      if ( *(_WORD *)(v9 + 150) )
      {
        v10 = *(_WORD *)(v9 + 150);
      }
      else
      {
        if ( !*(_WORD *)(v9 + 38) )
          return v2;
        v10 = *(_WORD *)(v9 + 38);
      }
      if ( dword_EA3E4[v10] != a2 )
        return dword_EA3E4[0];
    }
  }
  return v2;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001EEE0) --------------------------------------------------------
signed int __cdecl sub_1EEE0(int a1)
{
  signed __int16 *v1; // eax
  __int16 v2; // ST10_2
  int v3; // ST0C_4
  int v4; // ST08_4
  __int16 v5; // ax

  v1 = *(signed __int16 **)(a1 + 160);
  v2 = v1[7];
  v3 = v1[5];
  v4 = v1[6];
  v5 = sub_10C40((__int16 *)(a1 + 76));
  return sub_580E0(a1 + 76, v5, v4, v3, v2);
}

//----- (0001EF20) --------------------------------------------------------
signed int __cdecl sub_1EF20(int a1)
{
  return sub_1BD90(a1, 0);
}

//----- (0001EF40) --------------------------------------------------------
int __usercall sub_1EF40@<eax>(int a1@<esi>, _WORD *a2)
{
  sub_1BF90((int)a2, 0);
  sub_1F0C0(a1, (int)a2);
  return sub_1F040(a2);
}

//----- (0001EF70) --------------------------------------------------------
int __usercall sub_1EF70@<eax>(int a1@<esi>, _WORD *a2)
{
  if ( (unsigned __int16)sub_1C310((int)a2, 0, (unsigned __int16 (__cdecl *)(int, int))sub_1CC20) )
    sub_6E450((signed int)((char *)a2 - dword_D41A0 - 28302) / 168, -1, 8);
  sub_1F0C0(a1, (int)a2);
  return sub_1F040(a2);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001EFD0) --------------------------------------------------------
int __usercall sub_1EFD0@<eax>(int a1@<esi>, _WORD *a2)
{
  sub_1C560((int)a2, 0);
  sub_1F0C0(a1, (int)a2);
  return sub_1F040(a2);
}

//----- (0001F000) --------------------------------------------------------
int __cdecl sub_1F000(int a1)
{
  return sub_1C890(a1, 0);
}

//----- (0001F020) --------------------------------------------------------
void __cdecl sub_1F020(int a1)
{
  sub_1C930(a1);
}

//----- (0001F040) --------------------------------------------------------
int __cdecl sub_1F040(_WORD *a1)
{
  __int16 v1; // ax
  int result; // eax

  a1[40] += a1[8];
  v1 = sub_10C40(a1 + 38);
  *((_DWORD *)a1 + 4) -= 5;
  result = v1 + 256;
  if ( (signed __int16)a1[40] >= result )
  {
    if ( byte_D41B6 )
    {
      result = sub_10C60(a1 + 38);
      if ( (signed __int16)a1[40] > (signed __int16)result - 256 )
        *((_DWORD *)a1 + 4) = -150;
    }
  }
  else
  {
    *((_DWORD *)a1 + 4) = 150;
  }
  return result;
}
// D41B6: using guessed type char byte_D41B6;

//----- (0001F0C0) --------------------------------------------------------
void __usercall sub_1F0C0(int a1@<esi>, int a2)
{
  char v2; // ah
  int v3; // edi
  int i; // eax
  int v5; // eax
  char v6; // cl
  unsigned int v7; // esi
  __int16 v8; // ax
  int v9; // [esp+0h] [ebp-14h]
  int v10; // [esp+4h] [ebp-10h]
  int v11; // [esp+8h] [ebp-Ch]
  int v12; // [esp+Ch] [ebp-8h]
  char v13; // [esp+10h] [ebp-4h]

  v2 = *(_BYTE *)(a2 + 61);
  if ( v2 )
  {
    *(_BYTE *)(a2 + 61) = v2 - 1;
    if ( *(_BYTE *)(a2 + 70) )
    {
      if ( *(_WORD *)(a2 + 44) )
      {
        v7 = dword_EA3E4[*(unsigned __int16 *)(a2 + 36)];
        if ( v7 <= dword_EA3E4[0] || *(_DWORD *)(v7 + 8) < 0 || *(_BYTE *)(v7 + 13) & 4 )
        {
          *(_BYTE *)(a2 + 70) = 0;
          *(_WORD *)(a2 + 36) = 0;
        }
        else
        {
          if ( *(_BYTE *)(a2 + 36) & 1 )
            v8 = *(_WORD *)(v7 + 28) + 512;
          else
            v8 = *(_WORD *)(v7 + 28) - 512;
          *(_DWORD *)&word_EB398 = *(_DWORD *)(a2 + 76);
          *(&word_EB398 + 2) = *(_WORD *)(a2 + 80);
          sub_57FA0(&word_EB398, v8 & 0x7FF, 0, 48 * *(_WORD *)(a2 + 44));
          sub_57CF0(a2, (int)&word_EB398);
          --*(_WORD *)(a2 + 44);
        }
      }
      else
      {
        *(_BYTE *)(a2 + 70) = 0;
        *(_WORD *)(a2 + 36) = 0;
      }
    }
    else
    {
      v11 = (*(unsigned __int16 *)(a2 + 76) + 128) >> 8;
      v12 = (*(unsigned __int16 *)(a2 + 78) + 128) >> 8;
      v3 = sub_10080(0, 4);
      if ( v3 )
      {
        v13 = 0;
LABEL_11:
        while ( !v13 && sub_10130(v3, &v10, &v9) == 1 )
        {
          for ( i = word_15B4E0[((unsigned __int8)(v9 + v12) << 8) + (unsigned __int8)(v10 + v11)];
                ;
                i = *(unsigned __int16 *)(a1 + 22) )
          {
            a1 = dword_EA3E4[i];
            if ( a1 == dword_EA3E4[0] )
              break;
            if ( *(_BYTE *)(a1 + 63) == 9 && *(unsigned __int16 *)(a1 + 150) == *(signed __int16 *)(a2 + 26) )
            {
              v13 = 1;
              goto LABEL_11;
            }
          }
        }
        sub_10100(v3);
        if ( v13 )
        {
          v5 = (a1 - (dword_D41A0 + 28302)) / 168;
          v6 = *(_BYTE *)(a2 + 70);
          *(_WORD *)(a2 + 44) = 5;
          *(_BYTE *)(a2 + 70) = v6 + 1;
          *(_WORD *)(a2 + 36) = v5;
        }
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (0001F300) --------------------------------------------------------
int __usercall sub_1F300@<eax>(int a1@<esi>, int a2)
{
  int result; // eax

  sub_1D5D0(a2, 0);
  result = (unsigned __int8)(*(_BYTE *)(a2 + 73) - 1);
  switch ( *(_BYTE *)(a2 + 73) )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xD:
    case 0xE:
    case 0x10:
      sub_1F0C0(a1, a2);
      goto LABEL_3;
    case 0x11:
LABEL_3:
      result = sub_1F040((_WORD *)a2);
      break;
    default:
      return result;
  }
  return result;
}

//----- (0001F340) --------------------------------------------------------
void __cdecl sub_1F340(int a1)
{
  sub_1BD90(a1, 8);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  if ( !(*(unsigned __int16 *)(a1 + 20) % 0x4Du) )
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 46);
  if ( *(_BYTE *)(a1 + 69) == 14 )
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001F3C0) --------------------------------------------------------
void __cdecl sub_1F3C0(int a1)
{
  sub_1BF90(a1, 8);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  if ( !(*(unsigned __int16 *)(a1 + 20) % 0x4Du) )
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 46);
  if ( *(_BYTE *)(a1 + 69) == 14 )
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001F440) --------------------------------------------------------
void __cdecl sub_1F440(int a1)
{
  *(_BYTE *)(a1 + 69) = 14;
  *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
  sub_1F530(a1);
}

//----- (0001F470) --------------------------------------------------------
void __cdecl sub_1F470(int a1)
{
  sub_1C560(a1, 8u);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  if ( !(*(unsigned __int16 *)(a1 + 20) % 0x4Du) )
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 46);
  if ( *(_BYTE *)(a1 + 69) == 14 )
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001F4F0) --------------------------------------------------------
int __cdecl sub_1F4F0(int a1)
{
  return sub_1C890(a1, 8);
}

//----- (0001F510) --------------------------------------------------------
void __cdecl sub_1F510(int a1)
{
  sub_1C930(a1);
}

//----- (0001F530) --------------------------------------------------------
void __cdecl sub_1F530(int a1)
{
  sub_1C980(a1, 8);
  if ( *(_BYTE *)(a1 + 69) != 14 )
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 134);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  if ( !(*(unsigned __int16 *)(a1 + 20) % 0x2Bu) )
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 46);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001F5B0) --------------------------------------------------------
__int16 __cdecl sub_1F5B0(int a1)
{
  __int16 result; // ax

  sub_1D5D0(a1, 8);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  if ( !(*(unsigned __int16 *)(a1 + 20) % 0x4Du) )
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 46);
  if ( *(_BYTE *)(a1 + 69) == 14 )
    result = *(_WORD *)(a1 + 132);
  else
    result = *(_WORD *)(a1 + 134);
  *(_WORD *)(a1 + 130) = result;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001F630) --------------------------------------------------------
signed int __cdecl sub_1F630(int a1)
{
  signed int result; // eax

  result = sub_1BD90(a1, 16);
  BYTE1(result) = *(_BYTE *)(a1 + 69);
  if ( BYTE1(result) == 18 )
    *(_DWORD *)(a1 + 16) = 1;
  return result;
}

//----- (0001F660) --------------------------------------------------------
void __cdecl sub_1F660(int a1)
{
  sub_1BF90(a1, 16);
  if ( *(_BYTE *)(a1 + 69) == 18 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, (*(_WORD *)(a1 + 20) & 1) + 12);
    *(_DWORD *)(a1 + 16) = 1;
  }
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001F6D0) --------------------------------------------------------
void __cdecl sub_1F6D0(int a1)
{
  int v1; // edx
  int v2; // eax
  unsigned __int16 v3; // dx
  int v4; // eax

  v1 = *(_DWORD *)(a1 + 16);
  if ( v1 )
  {
    v2 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v1 - 1;
    if ( v2 == 1 )
      *(_WORD *)(a1 + 130) = 5 * *(signed __int16 *)(a1 + 132) >> 1;
  }
  v3 = *(_WORD *)(a1 + 150);
  if ( v3 )
  {
    v4 = *(signed __int16 *)(a1 + 80)
       - (*(signed __int16 *)(dword_EA3E4[v3] + 82)
        + *(signed __int16 *)(dword_EA3E4[v3] + 80));
    if ( *(signed __int16 *)(a1 + 80) != *(signed __int16 *)(dword_EA3E4[v3] + 82)
                                       + *(signed __int16 *)(dword_EA3E4[v3] + 80) )
    {
      if ( v4 <= 0 )
        LOWORD(v4) = -1;
      else
        LOWORD(v4) = 1;
    }
    *(_WORD *)(a1 + 80) += v4 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
    if ( (unsigned __int16)sub_1C310(a1, 16, (unsigned __int16 (__cdecl *)(int, int))sub_1CE80) )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, (*(_WORD *)(a1 + 20) & 1) + 12);
      *(_WORD *)(a1 + 130) = -*(_WORD *)(a1 + 134);
      *(_DWORD *)(a1 + 16) = 3 * *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26);
    }
  }
  else
  {
    *(_BYTE *)(a1 + 69) = 17;
  }
  if ( *(_BYTE *)(a1 + 69) != 18 )
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001F800) --------------------------------------------------------
char __cdecl sub_1F800(int a1)
{
  char result; // al

  result = sub_1C560(a1, 0x10u);
  if ( *(_BYTE *)(a1 + 69) == 18 )
    *(_DWORD *)(a1 + 16) = 1;
  return result;
}

//----- (0001F830) --------------------------------------------------------
int __cdecl sub_1F830(int a1)
{
  return sub_1C890(a1, 16);
}

//----- (0001F850) --------------------------------------------------------
void __cdecl sub_1F850(int a1)
{
  sub_1C930(a1);
}

//----- (0001F8A0) --------------------------------------------------------
void __cdecl sub_1F8A0(int a1)
{
  int v1; // esi

  sub_1D5D0(a1, 16);
  if ( !(*(_BYTE *)(a1 + 62) & 7) && (unsigned __int8)(*(_BYTE *)(a1 + 73) - 1) <= 8u )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v1 = 2 * ((signed int)(*(unsigned __int16 *)(a1 + 20) % 0x9Du) / 79);
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    *(_WORD *)(a1 + 32) += *(_WORD *)(a1 + 20) % 0x55u * (v1 - 1);
    *(_BYTE *)(a1 + 33) &= 7u;
  }
  if ( *(_BYTE *)(a1 + 69) == 18 )
    *(_DWORD *)(a1 + 16) = 1;
}

//----- (0001F950) --------------------------------------------------------
signed int __cdecl sub_1F950(int a1)
{
  return sub_1BD90(a1, 24);
}

//----- (0001F970) --------------------------------------------------------
void __cdecl sub_1F970(int a1)
{
  sub_1BF90(a1, 24);
}

//----- (0001F990) --------------------------------------------------------
void __cdecl sub_1F990(int a1)
{
  if ( (unsigned __int16)sub_1C310(a1, 24, (unsigned __int16 (__cdecl *)(int, int))sub_1CC20) )
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 8);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001F9E0) --------------------------------------------------------
char __cdecl sub_1F9E0(int a1)
{
  return sub_1C560(a1, 0x18u);
}

//----- (0001FA00) --------------------------------------------------------
int __cdecl sub_1FA00(int a1)
{
  return sub_1C890(a1, 24);
}

//----- (0001FA20) --------------------------------------------------------
void __cdecl sub_1FA20(int a1)
{
  sub_1C930(a1);
}

//----- (0001FA50) --------------------------------------------------------
void __cdecl sub_1FA50(int a1)
{
  sub_1D5D0(a1, 24);
}

//----- (0001FA70) --------------------------------------------------------
char __cdecl sub_1FA70(int a1)
{
  char result; // al

  result = sub_1BD90(a1, 32);
  if ( *(_BYTE *)(a1 + 69) == 34 )
    result = sub_20060(a1);
  return result;
}

//----- (0001FAA0) --------------------------------------------------------
char __cdecl sub_1FAA0(int a1)
{
  __int16 v1; // cx
  unsigned int j; // eax
  __int16 v3; // ax
  int i; // edx
  int v5; // edi
  int v6; // edx
  unsigned __int16 v7; // ax
  int v8; // edi
  int v9; // ecx
  unsigned int v10; // esi
  unsigned int v11; // edi
  int v12; // eax
  signed int v13; // ST14_4
  __int16 v14; // ax
  unsigned int v15; // esi
  char v16; // dh
  int v17; // eax
  unsigned int v18; // esi
  unsigned int v19; // edi
  int v20; // edx
  unsigned int v21; // edx
  int v22; // eax
  unsigned int v23; // edi
  unsigned int k; // esi
  int v25; // eax
  signed int v26; // ST14_4
  __int16 v27; // ax
  int v28; // esi
  unsigned int v30; // [esp+0h] [ebp-28h]
  unsigned int v31; // [esp+4h] [ebp-24h]
  unsigned int v32; // [esp+8h] [ebp-20h]
  unsigned int v33; // [esp+14h] [ebp-14h]
  unsigned int v34; // [esp+18h] [ebp-10h]
  unsigned int v35; // [esp+1Ch] [ebp-Ch]
  unsigned int v36; // [esp+20h] [ebp-8h]

  v1 = *(_WORD *)(a1 + 98);
  j = 0;
  *(_DWORD *)(a1 + 16) = 0;
  if ( v1 )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v3 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v3;
    j = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        j = 1;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    j = 2;
  }
  if ( j >= 1 )
  {
    if ( j <= 1 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      *(_BYTE *)(a1 + 69) = 34;
      LOBYTE(j) = sub_1EEE0(a1);
    }
    else if ( j == 2 )
    {
      LOBYTE(j) = 36;
      *(_BYTE *)(a1 + 69) = 36;
    }
    goto LABEL_68;
  }
  if ( !j )
  {
    sub_1B8C0(a1);
    LOWORD(j) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(_WORD *)(*(_DWORD *)(a1 + 160) + 26);
    if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
    {
      if ( *(_WORD *)(a1 + 150) )
      {
        LOWORD(j) = *(_WORD *)(a1 + 150);
        v28 = dword_EA3E4[(unsigned __int16)j];
        if ( *(_BYTE *)(v28 + 63) != 10 || *(_BYTE *)(v28 + 64) != 45 )
        {
          *(_WORD *)(a1 + 150) = 0;
        }
        else if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v28 + 76)) > 0x1000 )
        {
          LOWORD(j) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v28 + 76));
          *(_WORD *)(a1 + 32) = j;
        }
        else
        {
          *(_DWORD *)(a1 + 16) = 1;
          LOBYTE(j) = 36;
          *(_BYTE *)(a1 + 69) = 36;
          ++*(_DWORD *)(v28 + 16);
        }
        goto LABEL_68;
      }
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v7 = *(_WORD *)(a1 + 20);
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      *(_WORD *)(a1 + 32) += ((*(_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v7 % 0x9Du) / 79) - 1);
      v8 = *(_DWORD *)(a1 + 160);
      *(_BYTE *)(a1 + 33) &= 7u;
      v9 = 4 * *(signed __int16 *)(v8 + 26);
      j = *(unsigned __int8 *)(a1 + 62) / v9;
      if ( !(*(unsigned __int8 *)(a1 + 62) % v9) )
      {
        j = *(signed __int16 *)(v8 + 28) * *(signed __int16 *)(v8 + 28);
        v32 = -1;
        v10 = *(_DWORD *)(dword_D41A4 + 38519);
        v11 = 0;
        v31 = j;
        while ( v10 > dword_EA3E4[0] )
        {
          v12 = (signed __int16)(*(_WORD *)(v10 + 76) - *(_WORD *)(a1 + 76));
          j = (signed __int16)(*(_WORD *)(v10 + 78) - *(_WORD *)(a1 + 78))
            * (signed __int16)(*(_WORD *)(v10 + 78) - *(_WORD *)(a1 + 78))
            + v12 * v12;
          v35 = j;
          if ( j <= v31 && !(*(_BYTE *)(v10 + 12) & 0x20) )
          {
            v13 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 30);
            v14 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v10 + 76));
            j = (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v14);
            if ( (signed int)j < v13 )
            {
              LOBYTE(j) = v35;
              if ( v35 < v32 )
              {
                v11 = v10;
                v32 = v35;
              }
            }
          }
          v10 = *(_DWORD *)v10;
        }
        v15 = v11;
        if ( v11 )
        {
          if ( v11 <= dword_EA3E4[0]
            || (v16 = *(_BYTE *)(v11 + 64)) != 0 && v16 != 1
            || (j = *(_DWORD *)(v11 + 164), !*(_WORD *)(j + 584)) )
          {
            v15 = 0;
          }
        }
        if ( !v15 )
        {
          v17 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
          v33 = v17 * v17;
          v18 = -1;
          v19 = 0;
          for ( j = *(_DWORD *)(dword_D41A4 + 38439); j > dword_EA3E4[0]; j = *(_DWORD *)j )
          {
            v20 = (signed __int16)(*(_WORD *)(j + 76) - *(_WORD *)(a1 + 76));
            v21 = v20 * v20
                + (signed __int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78))
                * (signed __int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78));
            if ( v21 <= v33 && v21 < v18 )
            {
              v19 = j;
              v18 = v21;
            }
          }
          v15 = v19;
        }
        if ( v15 )
        {
          if ( *(_BYTE *)(v15 + 63) == 10 && *(_BYTE *)(v15 + 64) == 45 )
            goto LABEL_68;
          *(_WORD *)(a1 + 150) = (signed int)(v15 - (dword_D41A0 + 28302)) / 168;
          LOBYTE(j) = 34;
LABEL_60:
          *(_BYTE *)(a1 + 69) = j;
          goto LABEL_68;
        }
        v22 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
        v23 = 0;
        v30 = v22 * v22;
        j = *(char *)(a1 + 64);
        v34 = -1;
        for ( k = *(_DWORD *)(dword_D41A4 + 4 * j + 38403); k > dword_EA3E4[0]; k = *(_DWORD *)k )
        {
          if ( !*(_WORD *)(k + 50) && k != a1 )
          {
            v25 = (signed __int16)(*(_WORD *)(k + 76) - *(_WORD *)(a1 + 76));
            j = (signed __int16)(*(_WORD *)(k + 78) - *(_WORD *)(a1 + 78))
              * (signed __int16)(*(_WORD *)(k + 78) - *(_WORD *)(a1 + 78))
              + v25 * v25;
            v36 = j;
            if ( j <= v30 )
            {
              v26 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 30);
              v27 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(k + 76));
              j = (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v27);
              if ( (signed int)j < v26 )
              {
                LOBYTE(j) = v36;
                if ( v36 < v34 )
                {
                  v23 = k;
                  v34 = v36;
                }
              }
            }
          }
        }
        if ( v23 )
        {
          *(_WORD *)(a1 + 50) = (signed int)(v23 - (dword_D41A0 + 28302)) / 168;
          LOBYTE(j) = 35;
          goto LABEL_60;
        }
      }
    }
  }
LABEL_68:
  if ( *(_BYTE *)(a1 + 69) == 34 )
    LOBYTE(j) = sub_20060(a1);
  return j;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001FF40) --------------------------------------------------------
unsigned int __cdecl sub_1FF40(int a1)
{
  unsigned int result; // eax
  char v2; // cl

  sub_1C310(a1, 32, (unsigned __int16 (__cdecl *)(int, int))sub_1CCE0);
  if ( *(_BYTE *)(a1 + 69) != 34 )
    return (unsigned int)sub_200F0(a1);
  result = *(unsigned __int8 *)(a1 + 62) / *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26);
  if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
  {
    result = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( result > dword_EA3E4[0] )
    {
      v2 = *(_BYTE *)(result + 64);
      if ( !v2 || v2 == 1 )
      {
        result = *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 164);
        *(_WORD *)(result + 584) = 200;
      }
    }
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001FFE0) --------------------------------------------------------
char __cdecl sub_1FFE0(int a1)
{
  char result; // al

  result = sub_1C560(a1, 0x20u);
  if ( *(_BYTE *)(a1 + 69) == 34 )
    result = sub_20060(a1);
  return result;
}

//----- (00020010) --------------------------------------------------------
int __cdecl sub_20010(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 16) )
    result = sub_57F10(a1);
  else
    result = sub_1C890(a1, 32);
  return result;
}

//----- (00020040) --------------------------------------------------------
void __cdecl sub_20040(int a1)
{
  sub_1C930(a1);
}

//----- (00020060) --------------------------------------------------------
char __cdecl sub_20060(int a1)
{
  signed int v1; // edx
  char result; // al

  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  v1 = *(unsigned __int16 *)(a1 + 20) % 0x14u;
  *(_WORD *)(a1 + 130) = 0;
  if ( v1 <= 10 )
    sub_49CD0((_WORD *)a1, 206);
  else
    sub_49CD0((_WORD *)a1, 1);
  sub_49EA0((_WORD *)a1, 128, 256);
  *(_BYTE *)(a1 + 65) = *(_BYTE *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 63);
  result = *(_BYTE *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 64);
  *(_BYTE *)(a1 + 66) = result;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000200F0) --------------------------------------------------------
_WORD *__cdecl sub_200F0(int a1)
{
  _WORD *result; // eax

  *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
  sub_49CD0((_WORD *)a1, 0);
  result = sub_49EA0((_WORD *)a1, 128, 256);
  *(_BYTE *)(a1 + 65) = 3;
  *(_BYTE *)(a1 + 66) = -1;
  return result;
}

//----- (00020140) --------------------------------------------------------
void __cdecl sub_20140(int a1)
{
  *(_DWORD *)(a1 + 16) = 0;
  sub_1D5D0(a1, 32);
  if ( *(_BYTE *)(a1 + 69) == 34 )
    sub_20060(a1);
}

//----- (00020370) --------------------------------------------------------
int __cdecl sub_20370(int a1)
{
  int result; // eax
  int v2; // edx

  result = *(_DWORD *)(a1 + 16);
  v2 = result - 1;
  *(_DWORD *)(a1 + 16) = result - 1;
  if ( result )
  {
    if ( v2 < 16 )
    {
      result = v2 / 2;
      if ( !(v2 % 2) )
        result = sub_585A0(a1);
    }
  }
  else
  {
    sub_20F20(a1);
    *(_BYTE *)(a1 + 69) = 73;
    *(_DWORD *)(a1 + 16) = 400;
    *(_BYTE *)(a1 + 70) = 0;
    result = sub_122A0(a1);
  }
  return result;
}

//----- (000203D0) --------------------------------------------------------
void __cdecl sub_203D0(int a1)
{
  int v1; // edx
  char v2; // al
  unsigned int v3; // esi
  __int16 v4; // ax
  int i; // eax
  int v6; // edx
  int v7; // eax
  unsigned int v8; // edx
  int v9; // edi
  unsigned int j; // esi
  int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // ST18_4
  unsigned __int16 v14; // ax
  int v15; // eax
  int v16; // edi
  unsigned int v17; // esi
  int v18; // eax
  int v19; // edx
  int v20; // eax
  signed int v21; // ST18_4
  __int16 v22; // ax
  int v23; // edx
  int v24; // esi
  unsigned int v25; // edx
  unsigned int v26; // edi
  int v27; // esi
  unsigned int k; // eax
  int v29; // edx
  unsigned int v30; // edx
  unsigned int v31; // edi
  unsigned int l; // eax
  int v33; // edx
  unsigned int v34; // edx
  unsigned int v35; // edi
  unsigned int m; // eax
  int v37; // edx
  unsigned int v38; // edx
  int v39; // eax
  unsigned int v40; // [esp+0h] [ebp-24h]
  int v41; // [esp+4h] [ebp-20h]
  unsigned int v42; // [esp+8h] [ebp-1Ch]
  unsigned int v43; // [esp+10h] [ebp-14h]
  unsigned int v44; // [esp+14h] [ebp-10h]
  unsigned int v45; // [esp+18h] [ebp-Ch]
  unsigned int v46; // [esp+1Ch] [ebp-8h]

  v1 = *(_DWORD *)(a1 + 16);
  if ( v1 > 0 )
  {
    *(_DWORD *)(a1 + 16) = v1 - 1;
    if ( v1 == 1 )
      sub_20F60(a1);
  }
  v2 = *(_BYTE *)(a1 + 70);
  if ( v2 )
  {
    if ( v2 == 1 )
      sub_20940(a1);
    goto LABEL_85;
  }
  if ( *(_BYTE *)(a1 + 57) )
    *(_DWORD *)(a1 + 16) = 400;
  v3 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v4 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v3 = 1;
    *(_WORD *)(a1 + 38) = v4;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v7 + 52) )
    {
      v7 = dword_EA3E4[i];
      if ( v7 == dword_EA3E4[0] )
        break;
      v6 = *(_DWORD *)(v7 + 8);
      if ( v6 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v6;
        v3 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v7 + 38);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    v3 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v3 >= 1 )
  {
    if ( v3 <= 1 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      *(_BYTE *)(a1 + 69) = 74;
    }
    else if ( v3 == 2 )
    {
      *(_BYTE *)(a1 + 69) = 76;
    }
    goto LABEL_85;
  }
  if ( !v3 )
  {
    sub_1B8C0(a1);
    if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
    {
      v8 = -1;
      v9 = 0;
      for ( j = *(_DWORD *)(dword_D41A4 + 38519); j > dword_EA3E4[0]; j = *(_DWORD *)j )
      {
        if ( *(_BYTE *)(j + 64) == 2 && *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26) )
        {
          v11 = (signed __int16)(*(_WORD *)(j + 76) - *(_WORD *)(a1 + 76));
          v12 = v11 * v11
              + (signed __int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78))
              * (signed __int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78));
          if ( v12 < v8 )
          {
            v9 = j;
            v8 = v12;
          }
        }
      }
      v41 = v9;
      if ( v9 )
      {
        *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v9 + 76));
        v13 = *(signed __int16 *)(v9 + 84) + *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
        if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v9 + 76)) > v13 )
        {
          v41 = 0;
        }
        else
        {
          *(_WORD *)(a1 + 150) = (v9 - (dword_D41A0 + 28302)) / 168;
          *(_BYTE *)(a1 + 69) = 74;
        }
      }
      else
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v14 = *(_WORD *)(a1 + 20);
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        *(_WORD *)(a1 + 32) += ((*(_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v14 % 0x9Du) / 79) - 1);
        *(_BYTE *)(a1 + 33) &= 7u;
      }
      if ( !v41 )
      {
        if ( *(_BYTE *)(a1 + 57) )
        {
          v15 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
          v16 = 0;
          v44 = -1;
          v17 = *(_DWORD *)(dword_D41A4 + 38519);
          v42 = v15 * v15;
          while ( v17 > dword_EA3E4[0] )
          {
            if ( *(_WORD *)(v17 + 26) != *(_WORD *)(a1 + 26) )
            {
              v18 = (signed __int16)(*(_WORD *)(v17 + 76) - *(_WORD *)(a1 + 76));
              v19 = v18 * v18;
              v20 = (signed __int16)(*(_WORD *)(v17 + 78) - *(_WORD *)(a1 + 78));
              v43 = v20 * v20 + v19;
              if ( v43 <= v42 && !(*(_BYTE *)(v17 + 12) & 0x20) )
              {
                v21 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 30);
                v22 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v17 + 76));
                if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v22) < v21 && v43 < v44 )
                {
                  v16 = v17;
                  v44 = v43;
                }
              }
            }
            v17 = *(_DWORD *)v17;
          }
          v41 = v16;
          if ( v16 )
          {
            *(_WORD *)(a1 + 150) = (v16 - (dword_D41A0 + 28302)) / 168;
            *(_BYTE *)(a1 + 69) = 74;
          }
        }
        v23 = v41;
        if ( !v41 )
        {
          LOBYTE(v23) = *(_BYTE *)(a1 + 62);
          v24 = *(_DWORD *)(a1 + 160);
          v25 = v23 / *(signed __int16 *)(v24 + 26) % 3;
          if ( v25 < 1 )
          {
            if ( v25 )
            {
LABEL_79:
              if ( v41 )
              {
                if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v41 + 76)) <= 0x600 )
                {
                  *(_DWORD *)&word_EB398 = *(_DWORD *)(v41 + 76);
                  *(&word_EB398 + 2) = *(_WORD *)(v41 + 80);
                  sub_57F10(v41);
                  v39 = sub_4A190((int)&word_EB398, 5, 9);
                  if ( v39 )
                  {
                    if ( *(_BYTE *)(dword_EA3E4[*(signed __int16 *)(a1 + 26)] + 63) == 3 )
                      *(_WORD *)(v39 + 26) = *(_WORD *)(a1 + 26);
                  }
                }
              }
              goto LABEL_85;
            }
            v45 = *(signed __int16 *)(v24 + 28) * *(signed __int16 *)(v24 + 28);
            v26 = -1;
            v27 = 0;
            for ( k = *(_DWORD *)(dword_D41A4 + 38419); k > dword_EA3E4[0]; k = *(_DWORD *)k )
            {
              v29 = (signed __int16)(*(_WORD *)(k + 76) - *(_WORD *)(a1 + 76));
              v30 = v29 * v29
                  + (signed __int16)(*(_WORD *)(k + 78) - *(_WORD *)(a1 + 78))
                  * (signed __int16)(*(_WORD *)(k + 78) - *(_WORD *)(a1 + 78));
              if ( v30 <= v45 && v30 < v26 )
              {
                v27 = k;
                v26 = v30;
              }
            }
          }
          else if ( v25 <= 1 )
          {
            v46 = *(signed __int16 *)(v24 + 28) * *(signed __int16 *)(v24 + 28);
            v31 = -1;
            v27 = 0;
            for ( l = *(_DWORD *)(dword_D41A4 + 38451); l > dword_EA3E4[0]; l = *(_DWORD *)l )
            {
              v33 = (signed __int16)(*(_WORD *)(l + 76) - *(_WORD *)(a1 + 76));
              v34 = v33 * v33
                  + (signed __int16)(*(_WORD *)(l + 78) - *(_WORD *)(a1 + 78))
                  * (signed __int16)(*(_WORD *)(l + 78) - *(_WORD *)(a1 + 78));
              if ( v34 <= v46 && v34 < v31 )
              {
                v27 = l;
                v31 = v34;
              }
            }
          }
          else
          {
            if ( v25 != 2 )
              goto LABEL_79;
            v40 = *(signed __int16 *)(v24 + 28) * *(signed __int16 *)(v24 + 28);
            v35 = -1;
            v27 = 0;
            for ( m = *(_DWORD *)(dword_D41A4 + 38455); m > dword_EA3E4[0]; m = *(_DWORD *)m )
            {
              v37 = (signed __int16)(*(_WORD *)(m + 76) - *(_WORD *)(a1 + 76));
              v38 = v37 * v37
                  + (signed __int16)(*(_WORD *)(m + 78) - *(_WORD *)(a1 + 78))
                  * (signed __int16)(*(_WORD *)(m + 78) - *(_WORD *)(a1 + 78));
              if ( v38 <= v40 && v38 < v35 )
              {
                v27 = m;
                v35 = v38;
              }
            }
          }
          v41 = v27;
          goto LABEL_79;
        }
      }
    }
  }
LABEL_85:
  if ( *(_BYTE *)(a1 + 69) == 74 )
    sub_20EC0(a1);
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00020940) --------------------------------------------------------
void __cdecl sub_20940(int a1)
{
  signed int v1; // ecx
  __int16 v2; // ax
  int i; // eax
  int v4; // edx
  int v5; // eax
  __int16 v6; // ax
  int v7; // edx
  int v8; // esi
  unsigned int v9; // edx
  unsigned int v10; // edi
  unsigned int j; // ecx
  int v12; // eax
  unsigned int v13; // eax
  unsigned int v14; // edi
  unsigned int k; // ecx
  int v16; // eax
  unsigned int v17; // eax
  unsigned int v18; // edi
  unsigned int l; // ecx
  int v20; // eax
  unsigned int v21; // eax
  int v22; // eax
  int v23; // eax
  _WORD *v24; // [esp+10h] [ebp-4h]

  v1 = 0;
  v24 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v1 = 1;
    *(_WORD *)(a1 + 38) = v2;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        v1 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( (unsigned int)v1 >= 1 )
  {
    if ( (unsigned int)v1 <= 1 )
    {
      v6 = *(_WORD *)(a1 + 38);
      *(_BYTE *)(a1 + 69) = 74;
      *(_WORD *)(a1 + 150) = v6;
    }
    else if ( v1 == 2 )
    {
      *(_BYTE *)(a1 + 69) = 76;
    }
    return;
  }
  if ( v1 )
    return;
  v7 = *(_DWORD *)(a1 + 16);
  if ( v7 < 0 )
  {
    *(_DWORD *)(a1 + 16) = v7 + 1;
    if ( v7 == -1 )
      sub_20F80(a1);
    return;
  }
  if ( *(_BYTE *)(a1 + 57) )
  {
    *(_DWORD *)(a1 + 16) = -50;
    return;
  }
  LOBYTE(v1) = *(_BYTE *)(a1 + 62);
  v8 = *(_DWORD *)(a1 + 160);
  if ( !(v1 % *(signed __int16 *)(v8 + 26)) )
  {
    v9 = v1 / *(signed __int16 *)(v8 + 26) % 3;
    if ( v9 < 1 )
    {
      if ( v9 )
      {
LABEL_50:
        if ( v24 )
        {
          v22 = (signed __int16)(v24[38] - *(_WORD *)(a1 + 76));
          if ( sub_7277A(
                 (signed __int16)(v24[39] - *(_WORD *)(a1 + 78)) * (signed __int16)(v24[39] - *(_WORD *)(a1 + 78))
               + v22 * v22
               + (signed __int16)(v24[40] - *(_WORD *)(a1 + 80)) * (signed __int16)(v24[40] - *(_WORD *)(a1 + 80))) <= 0x600 )
          {
            *(_DWORD *)&word_EB398 = *((_DWORD *)v24 + 19);
            *(&word_EB398 + 2) = v24[40];
            sub_57F10((int)v24);
            v23 = sub_4A190((int)&word_EB398, 5, 9);
            if ( v23 )
              *(_WORD *)(v23 + 26) = *(_WORD *)(a1 + 26);
          }
        }
        return;
      }
      v10 = -1;
      for ( j = *(_DWORD *)(dword_D41A4 + 38419); j > dword_EA3E4[0]; j = *(_DWORD *)j )
      {
        v12 = (signed __int16)(*(_WORD *)(j + 76) - *(_WORD *)(a1 + 76));
        v13 = v12 * v12
            + (signed __int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78))
            * (signed __int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78));
        if ( v13 <= *(signed __int16 *)(v8 + 28) * *(signed __int16 *)(v8 + 28) && v13 < v10 )
        {
          v9 = j;
          v10 = v13;
        }
      }
    }
    else if ( v9 <= 1 )
    {
      v14 = -1;
      v9 = 0;
      for ( k = *(_DWORD *)(dword_D41A4 + 38451); k > dword_EA3E4[0]; k = *(_DWORD *)k )
      {
        v16 = (signed __int16)(*(_WORD *)(k + 76) - *(_WORD *)(a1 + 76));
        v17 = v16 * v16
            + (signed __int16)(*(_WORD *)(k + 78) - *(_WORD *)(a1 + 78))
            * (signed __int16)(*(_WORD *)(k + 78) - *(_WORD *)(a1 + 78));
        if ( v17 <= *(signed __int16 *)(v8 + 28) * *(signed __int16 *)(v8 + 28) && v17 < v14 )
        {
          v9 = k;
          v14 = v17;
        }
      }
    }
    else
    {
      if ( v9 != 2 )
        goto LABEL_50;
      v18 = -1;
      v9 = 0;
      for ( l = *(_DWORD *)(dword_D41A4 + 38455); l > dword_EA3E4[0]; l = *(_DWORD *)l )
      {
        v20 = (signed __int16)(*(_WORD *)(l + 76) - *(_WORD *)(a1 + 76));
        v21 = v20 * v20
            + (signed __int16)(*(_WORD *)(l + 78) - *(_WORD *)(a1 + 78))
            * (signed __int16)(*(_WORD *)(l + 78) - *(_WORD *)(a1 + 78));
        if ( v21 <= *(signed __int16 *)(v8 + 28) * *(signed __int16 *)(v8 + 28) && v21 < v18 )
        {
          v9 = l;
          v18 = v21;
        }
      }
    }
    v24 = (_WORD *)v9;
    goto LABEL_50;
  }
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00020C50) --------------------------------------------------------
void __cdecl sub_20C50(int a1)
{
  unsigned int v1; // esi
  __int16 v2; // ax
  int i; // eax
  int v4; // eax
  int v5; // ecx
  unsigned int v6; // eax
  unsigned int v7; // esi
  int v8; // edi
  unsigned int v9; // edi

  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v1 = 1;
    *(_WORD *)(a1 + 38) = v2;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        v1 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v1 >= 1 )
  {
    if ( v1 <= 1 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
    }
    else if ( v1 == 2 )
    {
      *(_BYTE *)(a1 + 69) = 76;
    }
    goto LABEL_32;
  }
  if ( v1 )
    goto LABEL_32;
  sub_1B8C0(a1);
  v6 = sub_1ED30(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
  v7 = v6;
  if ( v6 <= dword_EA3E4[0] || *(_DWORD *)(v6 + 8) < 0 || *(_BYTE *)(v6 + 13) & 4 )
  {
LABEL_31:
    *(_BYTE *)(a1 + 69) = 73;
    goto LABEL_32;
  }
  if ( !(*(unsigned __int8 *)(a1 + 62) % 10) )
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v6 + 76));
  v8 = *(_DWORD *)(a1 + 160);
  if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v8 + 26)) )
  {
    v9 = *(signed __int16 *)(v8 + 28);
    if ( *(_BYTE *)(v7 + 63) == 3 && *(_BYTE *)(v7 + 64) == 2 )
      v9 += *(signed __int16 *)(v7 + 84);
    if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v7 + 76)) < v9 )
    {
      sub_1CDA0((_WORD *)a1, v7);
      goto LABEL_32;
    }
    goto LABEL_31;
  }
LABEL_32:
  if ( *(_BYTE *)(a1 + 69) != 74 )
    sub_20F20(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00020E50) --------------------------------------------------------
char __cdecl sub_20E50(int a1)
{
  char result; // al

  result = sub_1C560(a1, 0x48u);
  if ( *(_BYTE *)(a1 + 69) == 74 )
    result = sub_20EC0(a1);
  return result;
}

//----- (00020E80) --------------------------------------------------------
int __cdecl sub_20E80(int a1)
{
  return sub_1C890(a1, 72);
}

//----- (00020EA0) --------------------------------------------------------
void __cdecl sub_20EA0(int a1)
{
  sub_1C930(a1);
}

//----- (00020EC0) --------------------------------------------------------
char __cdecl sub_20EC0(int a1)
{
  int v1; // esi
  char result; // al

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  if ( *(_WORD *)(a1 + 26) == *(_WORD *)(v1 + 26) )
  {
    *(_BYTE *)(a1 + 69) = 73;
  }
  else
  {
    *(_WORD *)(a1 + 130) = 0;
    sub_49CD0((_WORD *)a1, 202);
    *(_BYTE *)(a1 + 65) = *(_BYTE *)(v1 + 63);
    result = *(_BYTE *)(v1 + 64);
    *(_BYTE *)(a1 + 66) = result;
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00020F20) --------------------------------------------------------
int __cdecl sub_20F20(int a1)
{
  int result; // eax

  *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
  result = sub_49CD0((_WORD *)a1, 201);
  *(_BYTE *)(a1 + 65) = 3;
  *(_BYTE *)(a1 + 66) = -1;
  *(_DWORD *)(a1 + 16) = 50;
  *(_BYTE *)(a1 + 70) = 0;
  return result;
}

//----- (00020F60) --------------------------------------------------------
int __cdecl sub_20F60(int a1)
{
  int result; // eax

  result = sub_49CD0((_WORD *)a1, 201);
  *(_BYTE *)(a1 + 70) = 1;
  return result;
}

//----- (00020F80) --------------------------------------------------------
int __cdecl sub_20F80(int a1)
{
  *(_BYTE *)(a1 + 70) = 0;
  *(_DWORD *)(a1 + 16) = 400;
  return sub_49CD0((_WORD *)a1, 201);
}

//----- (00020FC0) --------------------------------------------------------
void __cdecl sub_20FC0(int a1)
{
  sub_1D5D0(a1, 72);
  if ( *(_BYTE *)(a1 + 69) == 74 )
    sub_20EC0(a1);
}

//----- (00021030) --------------------------------------------------------
__int16 __cdecl sub_21030(int a1)
{
  int v1; // esi
  unsigned __int8 v2; // al
  int v3; // eax
  char v4; // dh
  int v5; // edx
  int v6; // ecx
  int v7; // edi
  int v8; // eax
  int v9; // edi
  int v10; // edx
  int v11; // esi
  int v12; // eax
  int v13; // eax
  __int16 v14; // dx
  int v15; // ecx
  int v16; // edi
  char v17; // ah
  unsigned int i; // eax
  char v19; // dl
  int v20; // ecx
  int v21; // eax
  __int16 v22; // dx
  char v24; // [esp+0h] [ebp-4h]

  v24 = 0;
  sub_223E0();
  v1 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  if ( sub_21F60(a1) )
    *(_BYTE *)(a1 + 42) |= 1u;
  v2 = *(_BYTE *)(a1 + 70);
  if ( v2 > 1u && (v2 < 0xCu || v2 > 0xFu) && *(_DWORD *)(a1 + 8) >= 10 )
    sub_22190(a1);
  switch ( *(_BYTE *)(a1 + 70) )
  {
    case 0:
      v3 = dword_D41A0;
      *(_WORD *)((char *)&loc_36546 + dword_D41A0 + 2) = 1;
      *(_BYTE *)(a1 + 70) = 1;
      *(_WORD *)(a1 + 42) = 8;
      *(_DWORD *)(a1 + 16) = 15;
      LOWORD(v3) = *(_WORD *)(2124 * *(signed __int16 *)(v3 + 12) + v3 + 11240);
      *(_WORD *)(a1 + 44) = 22;
      *(_WORD *)(a1 + 150) = v3;
      word_DA7CA = 60;
      sub_22490((unsigned __int16 *)a1);
      goto LABEL_10;
    case 1:
LABEL_10:
      if ( sub_21490(a1) )
      {
        v4 = *(_BYTE *)(a1 + 42);
        *(_BYTE *)(a1 + 70) = 4;
        *(_BYTE *)(a1 + 42) = v4 | 0x80;
      }
      goto LABEL_48;
    case 2:
      v5 = 26 * *(_DWORD *)(a1 + 8);
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v6 = *(_DWORD *)(a1 + 4);
      v7 = *(_WORD *)(a1 + 20) & 7;
      *(_BYTE *)(a1 + 70) = 3;
      v8 = v5 / v6 - v7;
      *(_DWORD *)(a1 + 16) = v8;
      if ( v8 < 3 )
        *(_DWORD *)(a1 + 16) = 3;
      if ( *(_DWORD *)(a1 + 16) > 26 )
        *(_DWORD *)(a1 + 16) = 26;
      *(_BYTE *)(a1 + 68) = 0;
      *(_WORD *)(a1 + 44) = 22;
      sub_221F0(a1, 341);
      goto LABEL_17;
    case 3:
LABEL_17:
      if ( *(_DWORD *)(a1 + 8) < 10 )
      {
        *(_BYTE *)(a1 + 70) = 12;
        goto LABEL_48;
      }
      if ( *(_BYTE *)(a1 + 42) & 1 )
        goto LABEL_26;
      --*(_DWORD *)(a1 + 16);
      if ( (signed int)sub_58490((_WORD *)(v1 + 76), (_WORD *)(a1 + 76)) < 0x2000 && *(_DWORD *)(a1 + 16) <= 0 )
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        if ( (signed int)(*(unsigned __int16 *)(a1 + 20) % 0xCu) < 9 )
        {
          *(_BYTE *)(a1 + 70) = 4;
          goto LABEL_48;
        }
LABEL_26:
        *(_BYTE *)(a1 + 70) = 6;
      }
LABEL_48:
      if ( v24 && !(*(_BYTE *)(a1 + 62) & 3) )
        sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 63);
      return sub_22270(a1);
    case 4:
      *(_BYTE *)(a1 + 70) = 5;
      *(_DWORD *)(a1 + 16) = 6;
      *(_BYTE *)(a1 + 68) = 2;
      *(_WORD *)(a1 + 44) = 113;
      goto LABEL_25;
    case 5:
LABEL_25:
      v9 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v9;
      if ( v9 <= 0 )
        goto LABEL_26;
      goto LABEL_48;
    case 6:
      *(_BYTE *)(a1 + 70) = 7;
      *(_DWORD *)(a1 + 16) = 16;
      *(_BYTE *)(a1 + 68) = 0;
      *(_WORD *)(a1 + 44) = 113;
      sub_221F0(a1, 343);
      goto LABEL_28;
    case 7:
LABEL_28:
      v10 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v10;
      if ( v10 <= 0 )
        *(_BYTE *)(a1 + 70) = 8;
      goto LABEL_48;
    case 8:
      *(_BYTE *)(a1 + 70) = 9;
      *(_DWORD *)(a1 + 16) = 0;
      *(_BYTE *)(a1 + 68) = 3;
      *(_WORD *)(a1 + 44) = 22;
      sub_221F0(a1, 342);
      sub_21850(a1);
      goto LABEL_31;
    case 9:
LABEL_31:
      sub_21AB0(a1);
      v11 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v11;
      if ( v11 <= 0 )
        *(_BYTE *)(a1 + 70) = 10;
      goto LABEL_48;
    case 0xA:
      *(_BYTE *)(a1 + 70) = 11;
      *(_DWORD *)(a1 + 16) = 16;
      *(_WORD *)(a1 + 44) = 22;
      sub_221F0(a1, 344);
      goto LABEL_34;
    case 0xB:
LABEL_34:
      v12 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v12;
      if ( v12 <= 0 )
        *(_BYTE *)(a1 + 70) = 2;
      goto LABEL_48;
    case 0xC:
      *(_BYTE *)(a1 + 70) = 13;
      *(_DWORD *)(a1 + 16) = 32;
      v13 = sub_4A190(a1 + 76, 10, 17);
      if ( v13 )
      {
        v14 = *(_WORD *)(v1 + 26);
        *(_WORD *)(v13 + 80) = 0;
        *(_DWORD *)(v13 + 4) = 70;
        *(_WORD *)(v13 + 26) = v14;
        *(_DWORD *)(v13 + 8) = *(_DWORD *)(v13 + 4);
      }
      goto LABEL_38;
    case 0xD:
LABEL_38:
      v24 = 1;
      v15 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v15;
      if ( v15 <= 0 )
      {
        *(_BYTE *)(a1 + 70) = 14;
        *(_DWORD *)(a1 + 16) = 32;
        sub_221F0(a1, 345);
      }
      goto LABEL_48;
    case 0xE:
      v24 = 1;
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
      v16 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v16;
      if ( v16 <= 0 )
      {
        *(_BYTE *)(a1 + 70) = 15;
        *(_DWORD *)(a1 + 16) = 60;
        v17 = *(_BYTE *)(a1 + 12);
        *(_DWORD *)(a1 + 8) = -1;
        *(_BYTE *)(a1 + 12) = v17 | 1;
        sub_1B5F0();
        for ( i = *(_DWORD *)(dword_D41A4 + 38523); i > dword_EA3E4[0]; i = *(_DWORD *)i )
        {
          v19 = *(_BYTE *)(i + 13);
          *(_DWORD *)(i + 4) = 140;
          *(_BYTE *)(i + 13) = v19 | 0x20;
          *(_DWORD *)(i + 8) = *(_DWORD *)(i + 4);
        }
      }
      goto LABEL_48;
    case 0xF:
      sub_1B5F0();
      v20 = *(_DWORD *)(a1 + 16) - 1;
      v24 = 1;
      *(_DWORD *)(a1 + 16) = v20;
      if ( v20 <= 0 )
      {
        v21 = sub_4A190(a1 + 76, 10, 9);
        if ( v21 )
        {
          v22 = *(_WORD *)(v1 + 26);
          *(_DWORD *)(v21 + 8) = 32;
          *(_DWORD *)(v21 + 4) = 11;
          *(_WORD *)(v21 + 26) = v22;
          *((_BYTE *)&loc_36E03 + dword_D41A0) = 1;
        }
        *(_WORD *)((char *)&loc_36546 + dword_D41A0 + 2) = 0;
        sub_57F10(a1);
      }
      goto LABEL_48;
    default:
      goto LABEL_48;
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// DA7CA: using guessed type __int16 word_DA7CA;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00021490) --------------------------------------------------------
char __cdecl sub_21490(int a1)
{
  char v1; // cl
  int v2; // edx
  int v3; // esi
  int v4; // esi
  unsigned __int16 v5; // ax
  char v6; // ah
  unsigned int v7; // esi
  char v8; // dh
  char v9; // al
  char v10; // dl
  char v11; // cl
  int v12; // edx
  char v13; // ah
  unsigned int i; // esi
  int v15; // eax
  int v16; // eax
  int v18; // [esp+0h] [ebp-30h]
  __int16 v19; // [esp+4h] [ebp-2Ch]
  int v20; // [esp+8h] [ebp-28h]
  int v21; // [esp+Ch] [ebp-24h]
  int v22; // [esp+10h] [ebp-20h]
  int v23; // [esp+14h] [ebp-1Ch]
  int v24; // [esp+18h] [ebp-18h]
  int v25; // [esp+1Ch] [ebp-14h]
  char v26; // [esp+20h] [ebp-10h]
  char v27; // [esp+24h] [ebp-Ch]
  char v28; // [esp+28h] [ebp-8h]
  unsigned __int8 v29; // [esp+2Ch] [ebp-4h]

  v1 = *(_BYTE *)(a1 + 42);
  v27 = 1;
  v29 = 0;
  v26 = 0;
  if ( v1 & 8 )
  {
    v25 = (*(signed __int16 *)(a1 + 76) + 128) >> 8;
    v2 = *(_DWORD *)(a1 + 16);
    v22 = (*(signed __int16 *)(a1 + 78) + 128) >> 8;
    if ( v2 < 0 )
    {
      v28 = 1;
      v4 = sub_10080(0, 7);
      if ( v4 )
      {
        while ( sub_10130(v4, &v21, &v20) == 1 && v28 )
        {
          LOBYTE(v5) = v21 + v25;
          HIBYTE(v5) = v20 + v22;
          if ( byte_10B4E0[v5] )
            v28 = 0;
        }
        sub_10100(v4);
      }
      if ( v28 )
      {
        v6 = *(_BYTE *)(a1 + 42) | 4;
        *(_DWORD *)(a1 + 16) = 70;
        *(_BYTE *)(a1 + 42) = v6 & 0xF7;
      }
      else
      {
        *(_DWORD *)(a1 + 16) = 15;
      }
    }
    else
    {
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
      v3 = sub_10080(0, 15 - *(_DWORD *)(a1 + 16));
      if ( v3 )
      {
        while ( sub_10130(v3, &v21, &v20) == 1 )
          sub_56F10(v21 + v25, v20 + v22, -1, 0);
        sub_10100(v3);
      }
      --*(_DWORD *)(a1 + 16);
    }
  }
  else if ( v1 & 4 )
  {
    sub_1B5F0();
    v7 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v7 - 1;
    if ( v7 < 0x11 )
    {
      if ( v7 )
      {
        if ( v7 == 1 )
          v29 = 3;
      }
      else
      {
        *(_BYTE *)(a1 + 42) = (*(_BYTE *)(a1 + 42) | 0x10) & 0xFB;
        v8 = *(_BYTE *)(a1 + 12);
        *(_DWORD *)(a1 + 16) = 1;
        *(_BYTE *)(a1 + 12) = v8 & 0xFE;
      }
    }
    else if ( v7 <= 0x11 )
    {
      v29 = 2;
    }
    else if ( v7 >= 0x23 )
    {
      if ( v7 <= 0x23 )
      {
        v29 = 1;
      }
      else if ( v7 == 70 )
      {
        *((_BYTE *)&loc_36DFC + dword_D41A0 + 4) = 0;
      }
    }
  }
  else if ( v1 & 0x10 )
  {
    if ( *(_DWORD *)(a1 + 16) == 1 )
    {
      v11 = *(_BYTE *)(a1 + 42);
      *(_DWORD *)(a1 + 16) = 0;
      *(_BYTE *)(a1 + 42) = v11 & 0xBF;
    }
    else if ( v1 & 0x40 )
    {
      if ( sub_58490(
             (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12)
                                                       + dword_D41A0
                                                       + 11240)]
                     + 76),
             (_WORD *)(a1 + 76)) >= 0xA00 )
      {
        *(_BYTE *)(a1 + 42) &= 0xBFu;
      }
      else
      {
        v9 = *(_BYTE *)(a1 + 42);
        v10 = *(_BYTE *)(a1 + 14);
        *(_DWORD *)(a1 + 16) = 30;
        v9 |= 0x20u;
        *(_BYTE *)(a1 + 42) = v9;
        *(_BYTE *)(a1 + 14) = v10 & 0x7F;
        *(_BYTE *)(a1 + 42) = v9 & 0xEF;
      }
    }
  }
  else if ( v1 & 0x20 )
  {
    if ( *(_DWORD *)(a1 + 16) >= 600 )
      v27 = 0;
    v12 = *(_DWORD *)(a1 + 16) + 30;
    *(_DWORD *)(a1 + 16) = v12;
    if ( v12 >= 1200 )
    {
      v13 = *(_BYTE *)(a1 + 42);
      *(_DWORD *)(a1 + 16) = 1200;
      *(_BYTE *)(a1 + 42) = v13 & 0xDF;
    }
    word_DA7CA = *(_WORD *)(a1 + 16);
  }
  else
  {
    v26 = 1;
  }
  if ( v29 )
  {
    for ( i = *(_DWORD *)(dword_D41A4 + 38523); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( v29 < 2u )
      {
        if ( v29 == 1 )
        {
          *(_BYTE *)(i + 15) |= 1u;
          *(_BYTE *)(i + 14) &= 0x7Fu;
        }
      }
      else if ( v29 <= 2u )
      {
        *(_BYTE *)(i + 14) |= 0x80u;
        *(_BYTE *)(i + 15) &= 0xFEu;
      }
      else if ( v29 == 3 )
      {
        sub_57F10(i);
      }
    }
  }
  if ( v27 )
  {
    *(_WORD *)(a1 + 40) += 96;
    *(_BYTE *)(a1 + 41) &= 7u;
    v24 = 0;
    v15 = *(unsigned __int16 *)(a1 + 40);
    while ( 1 )
    {
      v23 = v15;
      if ( v24 >= 4 )
        break;
      v18 = *(_DWORD *)(a1 + 76);
      v19 = *(_WORD *)(a1 + 80);
      sub_57FA0(&v18, v23, 0, 192);
      v16 = sub_4A190((int)&v18, 10, 14);
      if ( v16 )
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        *(_DWORD *)(v16 + 8) = (*(_WORD *)(a1 + 20) & 7) + 8;
      }
      v15 = ((_WORD)v23 + 512) & 0x7FF;
      ++v24;
    }
  }
  return v26;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// DA7CA: using guessed type __int16 word_DA7CA;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00021850) --------------------------------------------------------
void __cdecl sub_21850(int a1)
{
  signed int v1; // ecx
  char v2; // ah
  signed int v3; // esi
  signed int v4; // edx
  char v5; // al
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  signed int v10; // edx

  v1 = 0;
  v2 = *(_BYTE *)(a1 + 42) & 0xFD;
  v3 = 0;
  *(_BYTE *)(a1 + 42) = v2;
  if ( v2 & 1 )
  {
    *(_BYTE *)(a1 + 42) = v2 & 0xFE;
    if ( *(_BYTE *)(a1 + 57) )
    {
      v3 = 1;
      *(_BYTE *)(a1 + 42) = v2 & 0xFE | 2;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 42) = v2 | 2;
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v4 = *(unsigned __int16 *)(a1 + 20) % 0x46u;
    v5 = *(_BYTE *)(a1 + 42);
    *(_WORD *)(a1 + 20) += *(_WORD *)(dword_D41A4 + 30);
    if ( v5 < 0 )
    {
      v4 = 0;
      *(_BYTE *)(a1 + 42) = v5 & 0x7F;
    }
    if ( v4 < 40 )
    {
      if ( v4 >= 3 && v4 <= 6 )
      {
        v3 = 1;
        goto LABEL_22;
      }
    }
    else if ( v4 > 48 )
    {
      if ( v4 > 58 )
      {
        if ( v4 > 68 )
        {
          *(_DWORD *)(a1 + 16) = 8;
          *(_WORD *)(a1 + 36) = 3;
          v9 = dword_D41A0;
          *(_WORD *)(a1 + 74) = 682;
          if ( *(_WORD *)((char *)&loc_3653D + v9 + 3) < 12 )
          {
            *(_BYTE *)(a1 + 67) = 4;
            goto LABEL_22;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 16) = 8;
          *(_WORD *)(a1 + 36) = 3;
          v8 = dword_D41A0;
          *(_WORD *)(a1 + 74) = 682;
          if ( *(_WORD *)((char *)&loc_36541 + v8 + 1) < 6 )
          {
            *(_BYTE *)(a1 + 67) = 5;
            goto LABEL_22;
          }
        }
      }
      else
      {
        *(_DWORD *)(a1 + 16) = 8;
        *(_WORD *)(a1 + 36) = 3;
        v7 = dword_D41A0;
        *(_WORD *)(a1 + 74) = 682;
        if ( *(_WORD *)((char *)&loc_3653D + v7 + 1) < 4 )
        {
          *(_BYTE *)(a1 + 67) = 3;
          goto LABEL_22;
        }
      }
    }
    else
    {
      *(_DWORD *)(a1 + 16) = 8;
      *(_WORD *)(a1 + 36) = 8;
      v6 = dword_D41A0;
      *(_WORD *)(a1 + 74) = 256;
      if ( *(_WORD *)((char *)&loc_36543 + v6 + 1) < 28 )
      {
        *(_BYTE *)(a1 + 67) = 6;
        goto LABEL_22;
      }
    }
    v1 = 1;
  }
LABEL_22:
  if ( v1 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v10 = *(unsigned __int16 *)(a1 + 20) % 0x1Du;
    *(_WORD *)(a1 + 20) += *(_WORD *)(dword_D41A4 + 30);
    if ( v10 > 7 )
    {
      if ( v10 > 17 )
      {
        if ( v10 > 25 )
        {
          if ( v10 > 27 )
          {
            v3 = 1;
          }
          else
          {
            *(_BYTE *)(a1 + 67) = 8;
            *(_WORD *)(a1 + 36) = 1;
            *(_DWORD *)(a1 + 16) = 5;
          }
        }
        else
        {
          *(_BYTE *)(a1 + 67) = 9;
          *(_WORD *)(a1 + 36) = 1;
          *(_DWORD *)(a1 + 16) = 5;
        }
      }
      else
      {
        *(_BYTE *)(a1 + 67) = 2;
        *(_WORD *)(a1 + 36) = 8;
        *(_DWORD *)(a1 + 16) = 8;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 67) = 1;
      *(_WORD *)(a1 + 36) = 10;
      *(_DWORD *)(a1 + 16) = 10;
    }
  }
  if ( v3 )
  {
    *(_BYTE *)(a1 + 67) = 7;
    *(_WORD *)(a1 + 36) = 24;
    *(_DWORD *)(a1 + 16) = 32;
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00021AB0) --------------------------------------------------------
void __cdecl sub_21AB0(int a1)
{
  int v1; // edx
  unsigned int v2; // eax
  __int16 v3; // dx
  __int16 v4; // ax
  _WORD *v5; // eax
  _WORD *v6; // eax
  _WORD *v7; // eax
  _WORD *v8; // eax
  __int16 v9; // ax
  _DWORD *v10; // eax
  int v11; // eax
  int v12; // esi
  int v13; // edx
  char v14; // cl
  int v15; // eax
  __int16 v16; // si
  _WORD *v17; // ST0C_4
  unsigned __int16 v18; // ax
  int v19; // edi
  int v20; // esi
  __int16 v21; // ax
  _WORD *v22; // esi
  _WORD *v23; // ST0C_4
  __int16 v24; // ax
  __int16 v25; // ax
  _WORD *v26; // edx
  unsigned int v27; // ST0C_4
  int v28; // [esp+0h] [ebp-20h]
  __int16 v29; // [esp+4h] [ebp-1Ch]
  int v30; // [esp+8h] [ebp-18h]
  unsigned int v31; // [esp+Ch] [ebp-14h]
  int v32; // [esp+10h] [ebp-10h]
  _WORD *v33; // [esp+14h] [ebp-Ch]
  int v34; // [esp+18h] [ebp-8h]
  _DWORD *v35; // [esp+1Ch] [ebp-4h]

  v33 = 0;
  v35 = 0;
  v1 = 2124 * *(signed __int16 *)(dword_D41A0 + 12);
  v34 = -1;
  v2 = dword_EA3E4[*(unsigned __int16 *)(v1 + dword_D41A0 + 11240)];
  v31 = v2;
  if ( v2 > dword_EA3E4[0] && *(_DWORD *)(v2 + 8) >= 0 && !(*(_BYTE *)(v2 + 13) & 4) )
  {
    v3 = *(_WORD *)(a1 + 36);
    if ( v3 )
    {
      *(_WORD *)(a1 + 36) = v3 - 1;
      v28 = *(_DWORD *)(a1 + 76);
      v29 = *(_WORD *)(a1 + 80);
      sub_57FA0(&v28, *(_WORD *)(a1 + 28), 0, 640);
      v4 = *(_WORD *)(a1 + 80);
      HIBYTE(v4) += 3;
      v29 = v4;
      switch ( *(_BYTE *)(a1 + 67) )
      {
        case 1:
          v5 = (_WORD *)sub_4A190((int)&v28, 9, 0);
          v33 = v5;
          if ( v5 )
          {
            *((_BYTE *)v5 + 67) = 10;
            *((_BYTE *)v5 + 68) = 0;
            *((_DWORD *)v5 + 40) = &off_D8412;
            v5[21] = 800;
            v34 = 15;
          }
          break;
        case 2:
          v6 = (_WORD *)sub_4A190((int)&v28, 9, 9);
          v33 = v6;
          if ( v6 )
          {
            *((_BYTE *)v6 + 67) = 10;
            *((_BYTE *)v6 + 68) = 23;
            *((_DWORD *)v6 + 40) = &off_D8412;
            v6[21] = 800;
            v34 = 23;
          }
          break;
        case 3:
        case 4:
        case 5:
        case 6:
          v32 = (*(_WORD *)(a1 + 74) * *(_WORD *)(a1 + 36) + *(_WORD *)(a1 + 28)) & 0x7FF;
          sub_57FA0(&v28, v32, 0, 1792);
          v9 = *(_WORD *)(a1 + 80);
          HIBYTE(v9) += 3;
          v29 = v9;
          switch ( *(_BYTE *)(a1 + 67) )
          {
            case 3:
              v10 = sub_4B240((int)&v28);
              goto LABEL_19;
            case 4:
              v10 = (_DWORD *)sub_4C8F0((int)&v28);
              goto LABEL_19;
            case 5:
              v10 = (_DWORD *)sub_4CE00((int)&v28);
              goto LABEL_19;
            case 6:
              v10 = (_DWORD *)sub_4C6B0((int)&v28);
LABEL_19:
              v35 = v10;
              break;
            default:
              break;
          }
          if ( v35 )
          {
            ++*(_DWORD *)((char *)&loc_364D1 + dword_D41A0 + 1);
            switch ( *(_BYTE *)(a1 + 67) )
            {
              case 3:
                v30 = 7;
                v34 = 8;
                break;
              case 4:
                v30 = 175;
                v34 = 42;
                break;
              case 5:
                v30 = 207;
                v34 = 37;
                break;
              case 6:
                v30 = 159;
                v34 = 44;
                break;
              default:
                break;
            }
            v11 = dword_D41A0;
            v12 = (int)v35;
            *((_WORD *)v35 + 75) = *(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240);
            *(_WORD *)(v12 + 26) = *(_WORD *)(a1 + 26);
            v13 = (int)v35;
            *((_BYTE *)v35 + 73) = 17;
            *(_WORD *)(v13 + 46) = 250;
            *(_WORD *)(v13 + 130) = 320;
            *(_WORD *)(v13 + 40) = (a1 - (v11 + 28302)) / 168;
            LOWORD(v11) = v32;
            *(_WORD *)(v13 + 28) = v32;
            *(_WORD *)(v13 + 32) = v11;
            *(_BYTE *)(v13 + 69) = v30;
          }
          break;
        case 7:
          if ( *(_BYTE *)(a1 + 42) & 2 )
          {
            sub_5C800(v31, 6);
            *(_WORD *)((char *)&loc_36546 + dword_D41A0) = 1024;
            v14 = *(_BYTE *)(a1 + 42);
            v34 = 19;
            *(_BYTE *)(a1 + 42) = v14 & 0xFD;
          }
          v15 = dword_D41A0;
          v16 = *(_WORD *)((char *)&loc_36546 + dword_D41A0) - 80;
          *(_WORD *)((char *)&loc_36546 + dword_D41A0) = v16;
          if ( v16 < 10 )
            *(_WORD *)((char *)&loc_36546 + v15) = 10;
          if ( *(_WORD *)((char *)&loc_36546 + dword_D41A0) > 1024 )
            *(_WORD *)((char *)&loc_36546 + dword_D41A0) = 1024;
          v17 = (_WORD *)(v31 + 76);
          *(_DWORD *)&word_EB398 = *(_DWORD *)(v31 + 76);
          *(&word_EB398 + 2) = *(_WORD *)(v31 + 80);
          v18 = sub_581E0((_WORD *)(a1 + 76), v17);
          v32 = v18;
          sub_57FA0(&word_EB398, v18, 0, *(_WORD *)((char *)&loc_36546 + dword_D41A0));
          v19 = v31;
          if ( (unsigned __int16)sub_5D0A0(v31) )
          {
            v20 = *(signed __int16 *)(*(_DWORD *)(v19 + 160) + 12);
            v21 = sub_10C40(&word_EB398);
            if ( word_EB39C < v21 + v20 )
              word_EB39C = *(_WORD *)(*(_DWORD *)(v19 + 160) + 12) + v21;
            sub_57CF0(v31, (int)&word_EB398);
          }
          break;
        case 8:
          v8 = (_WORD *)sub_4A190((int)&v28, 9, 26);
          v33 = v8;
          if ( v8 )
          {
            *((_BYTE *)v8 + 67) = 10;
            *((_BYTE *)v8 + 68) = 22;
            v8[21] = 20;
            *((_BYTE *)v8 + 70) = 3;
            v34 = 15;
          }
          break;
        case 9:
          v7 = (_WORD *)sub_4A190((int)&v28, 9, 3);
          v33 = v7;
          if ( v7 )
          {
            *((_BYTE *)v7 + 67) = 10;
            *((_BYTE *)v7 + 68) = 17;
            v7[21] = 6000;
            *((_BYTE *)v7 + 70) = 10;
            v34 = 15;
          }
          break;
        default:
          break;
      }
      if ( v33 )
      {
        v22 = (_WORD *)(v31 + 76);
        v23 = (_WORD *)(v31 + 76);
        v33[13] = *(_WORD *)(a1 + 26);
        v24 = sub_581E0((_WORD *)(a1 + 76), v23);
        v33[14] = v24;
        v25 = sub_58210((_WORD *)(a1 + 76), v22);
        v26 = v33;
        v33[15] = v25;
        *((_BYTE *)v26 + 66) = *(_BYTE *)(v31 + 64);
        v27 = v31;
        *((_BYTE *)v26 + 65) = *(_BYTE *)(v31 + 63);
        sub_5EF70(v27);
      }
    }
    if ( v34 >= 0 )
      sub_6E450(*(_WORD *)(a1 + 26), -1, v34);
  }
}
// D41A0: using guessed type int dword_D41A0;
// D8412: using guessed type void *off_D8412;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00021F60) --------------------------------------------------------
char __cdecl sub_21F60(int a1)
{
  unsigned int i; // ebx
  unsigned __int8 v2; // al
  bool v3; // eax
  unsigned __int16 v4; // si
  int v5; // eax
  int v6; // eax
  __int16 v7; // di
  int v9; // [esp+0h] [ebp-28h]
  __int16 v10; // [esp+4h] [ebp-24h]
  char v11; // [esp+8h] [ebp-20h]
  __int16 v12; // [esp+Ah] [ebp-1Eh]
  __int16 v13; // [esp+Ch] [ebp-1Ch]
  int v14; // [esp+10h] [ebp-18h]
  __int16 v15; // [esp+14h] [ebp-14h]
  int v16; // [esp+18h] [ebp-10h]
  _BOOL1 v17; // [esp+1Ch] [ebp-Ch]
  char v18; // [esp+20h] [ebp-8h]
  char v19; // [esp+24h] [ebp-4h]

  v19 = 0;
  v16 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v17 = *(_BYTE *)(a1 + 63) != 5 || *(_BYTE *)(a1 + 64) != 10;
  for ( i = *(_DWORD *)(dword_D41A4 + 38531); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    v2 = *(_BYTE *)(i + 64);
    v18 = 0;
    if ( v2 < 0xAu )
    {
      if ( v2 < 2u || v2 > 2u && (v2 < 4u || v2 > 5u) )
        goto LABEL_31;
      goto LABEL_19;
    }
    if ( v2 > 0xAu )
    {
      if ( v2 < 0x19u )
      {
        if ( v2 < 0x16u || v2 > 0x17u )
          goto LABEL_31;
      }
      else if ( v2 > 0x19u && v2 != 30 )
      {
        goto LABEL_31;
      }
LABEL_19:
      if ( !v17 )
      {
        if ( sub_58490((_WORD *)(a1 + 76), (_WORD *)(i + 76)) <= 0xC00 )
        {
          v19 = 1;
          v18 = 1;
        }
        goto LABEL_31;
      }
      v12 = 5120;
      v13 = 5120;
      v3 = sub_106F0((_WORD *)(a1 + 76), a1 + 82, (_WORD *)(i + 76), (int)&v11);
      goto LABEL_29;
    }
    v12 = 5120;
    v13 = 5120;
    HIWORD(v9) = 5120;
    v10 = 5120;
    v14 = *(_DWORD *)(i + 76);
    v15 = *(_WORD *)(i + 80);
    v4 = *(_WORD *)(*(_DWORD *)(v16 + 164) + 58);
    if ( v4 )
    {
      v5 = dword_EA3E4[v4];
      v14 = *(_DWORD *)(v5 + 76);
      v15 = *(_WORD *)(v5 + 80);
      v9 = *(_DWORD *)(v5 + 82);
      *(_DWORD *)&v10 = *(_DWORD *)(v5 + 86);
    }
    if ( v17 )
    {
      v3 = sub_106F0((_WORD *)(a1 + 76), a1 + 82, &v14, (int)&v9);
LABEL_29:
      if ( v3 )
        v18 = 1;
      goto LABEL_31;
    }
    if ( sub_106F0((_WORD *)(a1 + 76), (int)&v11, &v14, (int)&v9) )
    {
      v19 = 1;
      v18 = 1;
    }
LABEL_31:
    if ( v18 )
    {
      if ( *(_BYTE *)(i + 64) == 10 )
        *(_WORD *)(dword_EA3E4[*(signed __int16 *)(*(_DWORD *)(v16 + 164) + 823)] + 46) = 0;
      v6 = sub_4A190(i + 76, 10, 0);
      if ( v6 )
        *(_WORD *)(v6 + 26) = *(_WORD *)(a1 + 26);
      sub_57F10(i);
    }
  }
  v7 = *(_WORD *)(*(_DWORD *)(v16 + 164) + 835);
  if ( v7 && *(_WORD *)(dword_EA3E4[v7] + 46) > 0 )
    v19 = 1;
  return v19;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00022190) --------------------------------------------------------
char __cdecl sub_22190(int a1)
{
  char v1; // dl
  signed int v2; // edx
  __int16 v3; // dx

  v1 = 0;
  if ( *(_BYTE *)(a1 + 57) )
  {
    if ( *(_WORD *)(a1 + 98) )
    {
      v2 = *(_DWORD *)(a1 + 94);
      if ( v2 < 1 )
        v2 = 1;
      if ( v2 > 300 )
        v2 = 300;
      *(_DWORD *)(a1 + 8) -= v2;
      v3 = *(_WORD *)(a1 + 98);
      *(_WORD *)(a1 + 98) = 0;
      *(_WORD *)(a1 + 38) = v3;
      v1 = 1;
    }
    else
    {
      *(_WORD *)(a1 + 38) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 10 )
  {
    v1 = 2;
    *(_DWORD *)(a1 + 8) = 8;
  }
  return v1;
}

//----- (000221F0) --------------------------------------------------------
char __cdecl sub_221F0(int a1, __int16 a2)
{
  int v2; // eax
  unsigned __int16 v3; // bx

  LOBYTE(v2) = sub_49C90(a1, a2);
  if ( (unsigned __int16)a2 >= 0x157u && (unsigned __int16)a2 <= 0x159u )
  {
    v3 = word_D951C[7 * a2];
    LOBYTE(v2) = sub_71AB0(v3, 1);
    if ( dword_F66F0[v3] )
    {
      v2 = *(unsigned __int16 *)(sub_724F0(dword_E9C08, v3) + 16);
      *(_DWORD *)(a1 + 16) = v2;
    }
  }
  return v2;
}
// D951C: using guessed type __int16 word_D951C[];
// E9C08: using guessed type int dword_E9C08;

//----- (00022270) --------------------------------------------------------
__int16 __cdecl sub_22270(int a1)
{
  __int16 result; // ax
  signed int v2; // edx

  result = sub_10C40((__int16 *)(a1 + 76));
  v2 = *(_DWORD *)(a1 + 8);
  *(_WORD *)(a1 + 80) = result;
  if ( v2 >= 10 )
    result = sub_222B0(a1);
  return result;
}

//----- (000222B0) --------------------------------------------------------
__int16 __cdecl sub_222B0(int a1)
{
  int v1; // eax
  unsigned int v2; // edx
  signed int v3; // esi
  signed __int16 v4; // dx
  __int16 v5; // ax
  char v6; // ch

  v1 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v2 = (((*(unsigned __int16 *)(a1 + 28) - *(unsigned __int16 *)(v1 + 28)) >> 3) & 0xF0) >> 4;
  v3 = 0;
  if ( v2 <= 2 )
  {
    LOWORD(v1) = *(_WORD *)(v1 + 28) + 384;
    *(_WORD *)(a1 + 28) = v1;
  }
  else if ( v2 >= 0xD && v2 <= 0xF )
  {
    LOWORD(v1) = *(_WORD *)(v1 + 28);
    BYTE1(v1) += 6;
    *(_WORD *)(a1 + 28) = v1;
  }
  else
  {
    switch ( *(_BYTE *)(a1 + 68) )
    {
      case 0:
        v3 = 1;
        LOWORD(v1) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
        goto LABEL_15;
      case 1:
        goto LABEL_13;
      case 2:
        if ( *(_BYTE *)(dword_D41A4 + 26) & 1 )
          v4 = 512;
        else
          v4 = -512;
        v5 = *(_WORD *)(v1 + 28);
        HIBYTE(v5) += 4;
        LOWORD(v1) = v4 + v5;
        *(_WORD *)(a1 + 32) = v1;
        v6 = *(_BYTE *)(a1 + 33);
        *(_BYTE *)(a1 + 68) = 1;
        *(_BYTE *)(a1 + 33) = v6 & 7;
LABEL_13:
        v3 = 1;
        break;
      case 3:
        LOWORD(v1) = *(_WORD *)(a1 + 28);
LABEL_15:
        *(_WORD *)(a1 + 32) = v1;
        break;
      default:
        break;
    }
    if ( v3 )
    {
      LOWORD(v1) = sub_58350(
                     *(_WORD *)(a1 + 28),
                     *(_WORD *)(a1 + 32),
                     *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 4),
                     *(_WORD *)(a1 + 44));
      *(_WORD *)(a1 + 28) += v1;
    }
  }
  *(_BYTE *)(a1 + 29) &= 7u;
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000223E0) --------------------------------------------------------
unsigned int sub_223E0()
{
  int v0; // edx
  int v1; // ecx
  _DWORD *i; // eax
  _DWORD *j; // eax
  _DWORD *k; // eax
  unsigned int result; // eax

  v0 = dword_D41A0;
  v1 = dword_D41A4;
  *(_WORD *)((char *)&loc_3653D + dword_D41A0 + 1) = 0;
  for ( i = *(_DWORD **)(v1 + 38403); (unsigned int)i > dword_EA3E4[0]; i = (_DWORD *)*i )
    ++*(_WORD *)((char *)&loc_3653D + v0 + 1);
  *(_WORD *)((char *)&loc_3653D + v0 + 3) = 0;
  for ( j = *(_DWORD **)(v1 + 38403); (unsigned int)j > dword_EA3E4[0]; j = (_DWORD *)*j )
    ++*(_WORD *)((char *)&loc_3653D + v0 + 3);
  *(_WORD *)((char *)&loc_36543 + v0 + 1) = 0;
  for ( k = *(_DWORD **)(v1 + 38403); (unsigned int)k > dword_EA3E4[0]; k = (_DWORD *)*k )
    ++*(_WORD *)((char *)&loc_36543 + v0 + 1);
  *(_WORD *)((char *)&loc_36541 + v0 + 1) = 0;
  for ( result = *(_DWORD *)(v1 + 38503); result > dword_EA3E4[0]; result = *(_DWORD *)result )
  {
    if ( *(_BYTE *)(result + 69) != -56 )
      ++*(_WORD *)((char *)&loc_36541 + v0 + 1);
  }
  dword_D41A4 = v1;
  dword_D41A0 = v0;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00022490) --------------------------------------------------------
char __cdecl sub_22490(unsigned __int16 *a1)
{
  unsigned __int16 v1; // ax
  signed int v2; // esi
  unsigned __int16 v3; // bx
  signed int v4; // edi
  unsigned __int16 v6; // [esp+8h] [ebp-4h]

  LOBYTE(v1) = ((unsigned __int16)(a1[38] + 128) >> 8) - 19;
  HIBYTE(v1) = ((unsigned __int16)(a1[39] + 128) >> 8) - 19;
  v2 = 0;
  v6 = v1;
  do
  {
    v3 = v6;
    v4 = 0;
    while ( v4 < 38 )
    {
      ++v4;
      LOBYTE(v1) = sub_57390(v3, a1[13]);
      LOBYTE(v3) = v3 + 1;
    }
    ++v2;
    ++HIBYTE(v6);
  }
  while ( v2 < 38 );
  return v1;
}

//----- (00022530) --------------------------------------------------------
int __cdecl sub_22530(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = 80;
  return result;
}

//----- (00022540) --------------------------------------------------------
int __cdecl sub_22540(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = 80;
  return result;
}

//----- (00022550) --------------------------------------------------------
int __cdecl sub_22550(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = 80;
  return result;
}

//----- (00022560) --------------------------------------------------------
int __cdecl sub_22560(int a1)
{
  return sub_1C890(a1, 80);
}

//----- (00022580) --------------------------------------------------------
void __cdecl sub_22580(int a1)
{
  sub_1C930(a1);
}

//----- (000225A0) --------------------------------------------------------
int __cdecl sub_225A0(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = 80;
  return result;
}

//----- (000225B0) --------------------------------------------------------
int __cdecl sub_225B0(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = 80;
  return result;
}

//----- (00022640) --------------------------------------------------------
_BOOL1 __cdecl sub_22640(_WORD *a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4)
{
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // bh

  v4 = (*a1 >> 8) - ((signed int)a2 >> 1);
  v5 = (a1[1] >> 8) - ((signed int)a3 >> 1);
  if ( (v4 + v5) % 2 )
    ++v4;
  return (signed __int16)sub_48990(v4, v5, a3, a2) < (signed int)a4;
}

//----- (000226D0) --------------------------------------------------------
_WORD *__cdecl sub_226D0(unsigned __int16 a1, _WORD *a2, _WORD *a3)
{
  unsigned __int16 v3; // cx
  unsigned __int16 v4; // bx
  _WORD *result; // eax

  v3 = *(unsigned __int8 *)(dword_EA3BC + 6 * a1 + 5);
  v4 = *(unsigned __int8 *)(dword_EA3BC + 6 * a1 + 4);
  if ( word_180660 == 1 )
  {
    v3 >>= 1;
    v4 >>= 1;
  }
  *a3 = (v3 << 8) / 2 + 768;
  result = a2;
  *a2 = (v4 << 8) / 2 + 768;
  return result;
}
// EA3BC: using guessed type int dword_EA3BC;
// 180660: using guessed type __int16 word_180660;

//----- (00022760) --------------------------------------------------------
char __cdecl sub_22760(int a1)
{
  int v1; // eax
  signed int v2; // eax
  int v3; // eax
  __int16 v4; // ax
  __int16 v5; // dx
  __int16 v6; // ax
  __int16 v7; // di
  int v8; // eax
  char v9; // cl
  unsigned int i; // esi
  unsigned int j; // esi
  unsigned int k; // esi
  unsigned int l; // esi
  int v14; // esi
  char v15; // al
  int v17; // [esp+0h] [ebp-1Ch]
  unsigned __int16 v18; // [esp+8h] [ebp-14h]
  unsigned __int16 v19; // [esp+Ch] [ebp-10h]
  __int16 v20; // [esp+10h] [ebp-Ch]
  int v21; // [esp+14h] [ebp-8h]
  unsigned __int8 v22; // [esp+18h] [ebp-4h]

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v20 = 96;
  v17 = v1;
  if ( !*(_BYTE *)(v1 + 63) || *(_BYTE *)(v1 + 64) != 45 )
  {
    *(_DWORD *)(a1 + 16) = 5;
LABEL_51:
    v15 = v20;
    *(_WORD *)(a1 + 150) = 0;
    LOBYTE(v8) = v15 + 1;
    *(_BYTE *)(a1 + 69) = v8;
    return v8;
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(v1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(v1 + 80);
  v2 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = v2 + 1;
  if ( v2 >= 4 )
  {
    *(_DWORD *)(a1 + 16) = 1;
    goto LABEL_51;
  }
  v22 = sub_232C0();
  sub_226D0(v22, &v19, &v18);
  v3 = *(_DWORD *)(a1 + 16) - 1;
  switch ( *(_DWORD *)(a1 + 16) )
  {
    case 1:
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v4 = 9377 * *(_WORD *)(a1 + 20);
      word_EB398 += (*(_WORD *)(a1 + 20) % 3u << 8) + *(_WORD *)(v17 + 84) + v19 + 256;
      *(_WORD *)(a1 + 20) = v4 + 9439;
      v3 = (*(unsigned __int16 *)(a1 + 20) % 3u << 8) - 1280;
      v5 = v3 + word_EB39A;
      goto LABEL_10;
    case 2:
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      word_EB398 -= (*(_WORD *)(a1 + 20) % 3u << 8) + *(_WORD *)(v17 + 84) + v19 + 256;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v3 = (*(unsigned __int16 *)(a1 + 20) % 3u << 8) - 1280;
      v5 = v3 + word_EB39A;
      goto LABEL_10;
    case 3:
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v6 = 9377 * *(_WORD *)(a1 + 20);
      word_EB398 += (*(_WORD *)(a1 + 20) % 3u << 8) - 1280;
      *(_WORD *)(a1 + 20) = v6 + 9439;
      v3 = (*(unsigned __int16 *)(a1 + 20) % 3u << 8) + *(signed __int16 *)(v17 + 86) + v18 + 256;
      v5 = v3 + word_EB39A;
      goto LABEL_10;
    case 4:
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      word_EB398 += (*(_WORD *)(a1 + 20) % 3u << 8) - 1280;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v3 = *(signed __int16 *)(v17 + 86) + v18;
      v5 = word_EB39A - (v3 + (*(_WORD *)(a1 + 20) % 3u << 8) + 256);
LABEL_10:
      word_EB39A = v5;
      break;
    default:
      break;
  }
  LOWORD(v3) = word_EB398;
  v7 = word_EB39A;
  v21 = v3;
  if ( sub_104D0(&word_EB398) == (int (*)())1 )
  {
    *(_DWORD *)(a1 + 16) = 2;
    goto LABEL_51;
  }
  LOBYTE(v8) = sub_22640(
                 &word_EB398,
                 (signed int)v19 >> 8,
                 (signed int)v18 >> 8,
                 (((signed int)v19 >> 7) + ((signed int)v18 >> 7) > 4) + 15);
  if ( (_BYTE)v8 )
  {
    v9 = 0;
    for ( i = *(_DWORD *)(dword_D41A4 + 38527); !v9 && i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      v8 = abs((signed __int16)(*(_WORD *)(i + 76) - v21));
      if ( v8 <= *(signed __int16 *)(i + 84) + v19 )
      {
        v8 = abs((signed __int16)(*(_WORD *)(i + 78) - v7));
        if ( v8 <= v18 + (signed int)*(signed __int16 *)(i + 86) )
          v9 = 1;
      }
    }
    if ( !v9 )
    {
      for ( j = *(_DWORD *)(dword_D41A4 + 38519); !v9 && j > dword_EA3E4[0]; j = *(_DWORD *)j )
      {
        if ( *(_BYTE *)(j + 64) == 2 )
        {
          v8 = abs((signed __int16)(*(_WORD *)(j + 76) - v21));
          if ( v8 <= *(signed __int16 *)(j + 84) + v19 )
          {
            v8 = abs((signed __int16)(*(_WORD *)(j + 78) - v7));
            if ( v8 <= v18 + (signed int)*(signed __int16 *)(j + 86) )
              v9 = 1;
          }
        }
      }
    }
    if ( !v9 )
    {
      for ( k = *(_DWORD *)(dword_D41A4 + 38535); !v9 && k > dword_EA3E4[0]; k = *(_DWORD *)k )
      {
        if ( *(_BYTE *)(k + 64) == 67 )
        {
          v8 = abs((signed __int16)(*(_WORD *)(k + 76) - v21));
          if ( v8 <= *(signed __int16 *)(k + 84) + v19 )
          {
            v8 = abs((signed __int16)(*(_WORD *)(k + 78) - v7));
            if ( v8 <= v18 + (signed int)*(signed __int16 *)(k + 86) )
              v9 = 1;
          }
        }
      }
    }
    if ( !v9 )
    {
      for ( l = *(_DWORD *)(dword_D41A4 + 38451); !v9 && l > dword_EA3E4[0]; l = *(_DWORD *)l )
      {
        if ( *(_BYTE *)(l + 61) )
          v9 = 1;
      }
    }
    if ( !v9 )
    {
      v8 = sub_4A190((int)&word_EB398, 10, 45);
      v14 = v8;
      if ( v8 )
      {
        sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
        LOBYTE(v8) = sub_49A30(v14, v22);
        *(_BYTE *)(v14 + 69) = 51;
      }
      *(_WORD *)(a1 + 150) = 0;
      *(_BYTE *)(a1 + 61) = 1;
      *(_BYTE *)(a1 + 69) = 105;
    }
  }
  return v8;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;

//----- (00022C80) --------------------------------------------------------
char __cdecl sub_22C80(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // ax
  int i; // edx
  int v4; // ecx
  int v5; // edx
  unsigned int v6; // edx
  unsigned __int16 v7; // ax

  *(_BYTE *)(a1 + 61) = 0;
  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    v1 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        v1 = 1;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v1 = 2;
  }
  if ( v1 >= 1 )
  {
    if ( v1 <= 1 )
    {
      v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( v6 > dword_EA3E4[0] && (!*(_BYTE *)(v6 + 64) || *(_BYTE *)(v6 + 64) == 1) )
        *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      LOBYTE(v1) = 102;
    }
    else
    {
      if ( v1 != 2 )
        goto LABEL_28;
      LOBYTE(v1) = 100;
    }
LABEL_27:
    *(_BYTE *)(a1 + 69) = v1;
    goto LABEL_28;
  }
  if ( !v1 )
  {
    sub_1B8C0(a1);
    LOWORD(v1) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(_WORD *)(*(_DWORD *)(a1 + 160) + 26);
    if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v7 = *(_WORD *)(a1 + 20);
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      *(_WORD *)(a1 + 32) += ((*(_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v7 % 0x9Du) / 79) - 1);
      v1 = *(_DWORD *)(a1 + 16);
      *(_BYTE *)(a1 + 33) &= 7u;
      *(_DWORD *)(a1 + 16) = v1 - 1;
      if ( !v1 )
      {
        LOBYTE(v1) = 99;
        *(_DWORD *)(a1 + 16) = 1;
        goto LABEL_27;
      }
    }
  }
LABEL_28:
  if ( *(_BYTE *)(a1 + 69) == 102 )
  {
    LOWORD(v1) = *(_WORD *)(a1 + 132);
    *(_WORD *)(a1 + 130) = v1;
  }
  return v1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00022E60) --------------------------------------------------------
char __cdecl sub_22E60(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // ax
  int i; // edx
  int v4; // esi
  int v5; // edx
  unsigned int v6; // edx
  int v7; // edx
  int v8; // eax
  _WORD *v9; // esi

  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    v1 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        v1 = 1;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v1 = 2;
  }
  if ( v1 >= 1 )
  {
    if ( v1 <= 1 )
    {
      v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( v6 > dword_EA3E4[0] && (!*(_BYTE *)(v6 + 64) || *(_BYTE *)(v6 + 64) == 1) )
        *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      LOBYTE(v1) = 102;
    }
    else
    {
      if ( v1 != 2 )
        goto LABEL_31;
      LOBYTE(v1) = 100;
    }
LABEL_30:
    *(_BYTE *)(a1 + 69) = v1;
    goto LABEL_31;
  }
  if ( !v1 )
  {
    sub_1B8C0(a1);
    v1 = *(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26) / 2;
    if ( !v1 )
    {
      v7 = *(_DWORD *)(a1 + 16);
      v8 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
      *(_DWORD *)(a1 + 16) = v7 - 1;
      if ( !v7 || !*(_BYTE *)(v8 + 63) )
      {
        *(_DWORD *)(a1 + 16) = 5;
        *(_BYTE *)(a1 + 69) = 97;
      }
      v9 = (_WORD *)(v8 + 76);
      *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v8 + 76));
      v1 = sub_583F0((_WORD *)(a1 + 76), v9);
      if ( v1 < 0xA00 )
      {
        LOBYTE(v1) = 96;
        *(_DWORD *)(a1 + 16) = 0;
        goto LABEL_30;
      }
    }
  }
LABEL_31:
  if ( *(_BYTE *)(a1 + 69) == 102 )
  {
    LOWORD(v1) = *(_WORD *)(a1 + 132);
    *(_WORD *)(a1 + 130) = v1;
  }
  return v1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00023020) --------------------------------------------------------
char __cdecl sub_23020(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // ax
  int i; // edx
  int v4; // esi
  int v5; // edx
  unsigned int v6; // edx
  unsigned int v7; // edi
  unsigned int j; // esi
  unsigned int v9; // eax
  unsigned int v11; // [esp+0h] [ebp-8h]

  v1 = 0;
  v11 = -1;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    v1 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        v1 = 1;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v1 = 2;
  }
  if ( v1 >= 1 )
  {
    if ( v1 <= 1 )
    {
      v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( v6 > dword_EA3E4[0] && (!*(_BYTE *)(v6 + 64) || *(_BYTE *)(v6 + 64) == 1) )
        *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      LOBYTE(v1) = 102;
    }
    else
    {
      if ( v1 != 2 )
        goto LABEL_34;
      LOBYTE(v1) = 100;
    }
LABEL_33:
    *(_BYTE *)(a1 + 69) = v1;
    goto LABEL_34;
  }
  if ( !v1 )
  {
    v7 = 0;
    for ( j = *(_DWORD *)(dword_D41A4 + 38527); j > dword_EA3E4[0]; j = *(_DWORD *)j )
    {
      v9 = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(j + 76));
      if ( v9 && v9 < v11 )
      {
        v7 = j;
        v11 = v9;
      }
    }
    if ( v7 )
    {
      *(_WORD *)(a1 + 150) = (signed int)(v7 - (dword_D41A0 + 28302)) / 168;
      *(_DWORD *)(a1 + 16) = 10;
      LOBYTE(v1) = 98;
    }
    else
    {
      *(_DWORD *)(a1 + 16) = 5;
      LOBYTE(v1) = 97;
    }
    goto LABEL_33;
  }
LABEL_34:
  if ( *(_BYTE *)(a1 + 69) == 102 )
  {
    LOWORD(v1) = *(_WORD *)(a1 + 132);
    *(_WORD *)(a1 + 130) = v1;
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000231E0) --------------------------------------------------------
int __cdecl sub_231E0(int a1)
{
  return sub_1C890(a1, 96);
}

//----- (00023200) --------------------------------------------------------
void __cdecl sub_23200(int a1)
{
  unsigned int v1; // edx

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 36)];
  if ( v1 > dword_EA3E4[0] && (!*(_BYTE *)(v1 + 64) || *(_BYTE *)(v1 + 64) == 1) )
    *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 36)] + 164) + 584) = 200;
  sub_1C930(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00023260) --------------------------------------------------------
__int16 __cdecl sub_23260(int a1)
{
  __int16 result; // ax

  LOBYTE(result) = sub_1C980(a1, 96);
  HIBYTE(result) = *(_BYTE *)(a1 + 69);
  if ( HIBYTE(result) != 102 )
  {
    *(_DWORD *)(a1 + 16) = 5;
    *(_WORD *)(a1 + 150) = 0;
    result = *(_WORD *)(a1 + 134);
    *(_BYTE *)(a1 + 69) = 97;
    *(_WORD *)(a1 + 130) = result;
  }
  return result;
}

//----- (000232A0) --------------------------------------------------------
char __cdecl sub_232A0(int a1)
{
  *(_DWORD *)(a1 + 16) = 5;
  *(_BYTE *)(a1 + 69) = 97;
  return sub_22C80(a1);
}

//----- (000232C0) --------------------------------------------------------
char sub_232C0()
{
  int v0; // eax
  unsigned __int8 v1; // bl
  unsigned int v2; // eax

  v0 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
  v1 = 0;
  v2 = *(_DWORD *)(v0 + 8) % 0x3Cu + 17;
  while ( !(byte_D93C2[4 * (unsigned __int8)v2] & 2) && v1 < 0x4Du )
  {
    LOBYTE(v2) = v2 + 1;
    ++v1;
    if ( (unsigned __int8)v2 >= 0x4Cu )
      LOBYTE(v2) = 17;
  }
  if ( v1 >= 0x4Du )
    LOBYTE(v2) = 17;
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00023320) --------------------------------------------------------
char __cdecl sub_23320(int a1)
{
  *(_BYTE *)(a1 + 69) = 105;
  return sub_23340(a1);
}

//----- (00023340) --------------------------------------------------------
char __cdecl sub_23340(int a1)
{
  unsigned int j; // eax
  __int16 v2; // ax
  int i; // edx
  int v4; // edx
  int v5; // esi
  unsigned int v6; // edx
  unsigned __int16 v7; // ax
  unsigned int v8; // edi
  unsigned int v9; // esi
  int v10; // edx
  unsigned int v11; // edx
  int v12; // esi

  j = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    j = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        j = 1;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    j = 2;
  }
  if ( j >= 1 )
  {
    if ( j <= 1 )
    {
      v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( v6 > dword_EA3E4[0] && (!*(_BYTE *)(v6 + 64) || *(_BYTE *)(v6 + 64) == 1) )
        *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      LOBYTE(j) = 110;
      *(_BYTE *)(a1 + 69) = 110;
    }
    else if ( j == 2 )
    {
      LOBYTE(j) = 108;
      *(_BYTE *)(a1 + 69) = 108;
    }
    goto LABEL_43;
  }
  if ( j )
    goto LABEL_43;
  sub_1B8C0(a1);
  LOWORD(j) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(_WORD *)(*(_DWORD *)(a1 + 160) + 26);
  if ( *(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26) )
    goto LABEL_43;
  if ( *(_WORD *)(a1 + 150) )
  {
    v12 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( *(_BYTE *)(v12 + 63) == 10 && *(_BYTE *)(v12 + 64) == 45 )
    {
      if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v12 + 76)) > 0x800 )
      {
        LOWORD(j) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v12 + 76));
        *(_WORD *)(a1 + 32) = j;
        goto LABEL_43;
      }
      if ( (signed int)*(signed __int16 *)(v12 + 132) > *(_DWORD *)(v12 + 16) )
      {
        *(_DWORD *)(a1 + 16) = 1;
        LOBYTE(j) = 108;
        *(_BYTE *)(a1 + 69) = 108;
        ++*(_DWORD *)(v12 + 16);
        goto LABEL_43;
      }
    }
    *(_WORD *)(a1 + 150) = 0;
    LOWORD(j) = *(_WORD *)(a1 + 134);
    goto LABEL_42;
  }
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  v7 = *(_WORD *)(a1 + 20);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  *(_WORD *)(a1 + 32) += (2 * ((signed int)(v7 % 0x9Du) / 79) - 1) * ((*(_WORD *)(a1 + 20) & 0xFF) + 85);
  *(_BYTE *)(a1 + 33) &= 7u;
  LOWORD(j) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(_WORD *)(*(_DWORD *)(a1 + 160) + 26);
  if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
  {
    v8 = -1;
    v9 = 0;
    for ( j = *(_DWORD *)(dword_D41A4 + 38527); j > dword_EA3E4[0]; j = *(_DWORD *)j )
    {
      if ( byte_D93C2[4 * *(char *)(j + 70)] & 1 )
      {
        v10 = (signed __int16)(*(_WORD *)(j + 76) - *(_WORD *)(a1 + 76));
        v11 = v10 * v10
            + (signed __int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78))
            * (signed __int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78));
        if ( v11 < v8 )
        {
          v9 = j;
          v8 = v11;
        }
      }
    }
    if ( v9 )
    {
      *(_WORD *)(a1 + 150) = (signed int)(v9 - (dword_D41A0 + 28302)) / 168;
      LOWORD(j) = *(_WORD *)(a1 + 134) + 12;
LABEL_42:
      *(_WORD *)(a1 + 130) = j;
      goto LABEL_43;
    }
  }
LABEL_43:
  if ( *(_BYTE *)(a1 + 69) == 110 )
  {
    LOWORD(j) = *(_WORD *)(a1 + 132);
    *(_WORD *)(a1 + 130) = j;
  }
  return j;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00023640) --------------------------------------------------------
char __cdecl sub_23640(int a1)
{
  *(_BYTE *)(a1 + 69) = 105;
  return sub_23340(a1);
}

//----- (00023660) --------------------------------------------------------
char __cdecl sub_23660(int a1)
{
  *(_BYTE *)(a1 + 69) = 105;
  return sub_23340(a1);
}

//----- (00023680) --------------------------------------------------------
int __cdecl sub_23680(int a1)
{
  unsigned int v2; // ebx

  if ( *(_DWORD *)(a1 + 16) )
    return sub_57F10(a1);
  v2 = dword_EA3E4[*(unsigned __int16 *)(a1 + 36)];
  if ( v2 > dword_EA3E4[0] && (!*(_BYTE *)(v2 + 64) || *(_BYTE *)(v2 + 64) == 1) )
    *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 36)] + 164) + 584) = 200;
  return sub_1C890(a1, 104);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000236F0) --------------------------------------------------------
void __cdecl sub_236F0(int a1)
{
  sub_1C930(a1);
}

//----- (00023710) --------------------------------------------------------
__int16 __cdecl sub_23710(int a1)
{
  __int16 result; // ax

  LOBYTE(result) = sub_1C980(a1, 104);
  HIBYTE(result) = *(_BYTE *)(a1 + 69);
  if ( HIBYTE(result) != 110 )
  {
    result = *(_WORD *)(a1 + 134);
    *(_WORD *)(a1 + 150) = 0;
    *(_WORD *)(a1 + 130) = result;
  }
  return result;
}

//----- (00023750) --------------------------------------------------------
__int16 __cdecl sub_23750(int a1)
{
  __int16 result; // ax

  sub_1D5D0(a1, 104);
  if ( *(_BYTE *)(a1 + 69) == 110 )
    result = *(_WORD *)(a1 + 132);
  else
    result = *(_WORD *)(a1 + 134);
  *(_WORD *)(a1 + 130) = result;
  return result;
}

//----- (00023790) --------------------------------------------------------
char __cdecl sub_23790(int a1)
{
  *(_BYTE *)(a1 + 69) = 113;
  return sub_237B0(a1);
}

//----- (000237B0) --------------------------------------------------------
char __cdecl sub_237B0(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // ax
  int i; // edx
  int v4; // edx
  int v5; // esi
  unsigned int v6; // edx
  unsigned __int16 v7; // di
  unsigned __int16 v8; // ax
  unsigned int v9; // edi
  unsigned int v10; // esi
  int v11; // edx
  unsigned int v12; // edx
  int v13; // esi

  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    v1 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        v1 = 1;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v1 = 2;
  }
  if ( v1 >= 1 )
  {
    if ( v1 <= 1 )
    {
      v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( v6 > dword_EA3E4[0] && (!*(_BYTE *)(v6 + 64) || *(_BYTE *)(v6 + 64) == 1) )
        *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      LOBYTE(v1) = 118;
      *(_BYTE *)(a1 + 69) = 118;
    }
    else if ( v1 == 2 )
    {
      LOBYTE(v1) = 116;
      *(_BYTE *)(a1 + 69) = 116;
    }
    goto LABEL_44;
  }
  if ( v1 )
    goto LABEL_44;
  sub_1B8C0(a1);
  LOWORD(v1) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(_WORD *)(*(_DWORD *)(a1 + 160) + 26);
  if ( *(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26) )
    goto LABEL_44;
  v7 = *(_WORD *)(a1 + 150);
  if ( v7 )
  {
    v13 = dword_EA3E4[v7];
    if ( *(_BYTE *)(v13 + 63) == 10 && *(_BYTE *)(v13 + 64) == 45 )
    {
      if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v13 + 76)) > 0x800 )
      {
        LOWORD(v1) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v13 + 76));
        *(_WORD *)(a1 + 32) = v1;
        goto LABEL_44;
      }
      if ( (signed int)*(signed __int16 *)(v13 + 132) > *(_DWORD *)(v13 + 16) )
      {
        *(_DWORD *)(a1 + 16) = 1;
        LOBYTE(v1) = 116;
        *(_BYTE *)(a1 + 69) = 116;
        ++*(_DWORD *)(v13 + 16);
        goto LABEL_44;
      }
    }
    *(_WORD *)(a1 + 150) = 0;
    LOWORD(v1) = *(_WORD *)(a1 + 134);
    goto LABEL_43;
  }
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  v8 = *(_WORD *)(a1 + 20);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  *(_WORD *)(a1 + 32) += ((*(_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v8 % 0x9Du) / 79) - 1);
  *(_BYTE *)(a1 + 33) &= 7u;
  LOWORD(v1) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(_WORD *)(*(_DWORD *)(a1 + 160) + 26);
  if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
  {
    v9 = -1;
    v1 = *(_DWORD *)(dword_D41A4 + 38527);
    v10 = 0;
    while ( v1 > dword_EA3E4[0] )
    {
      if ( byte_D93C2[4 * *(char *)(v1 + 70)] & 1 )
      {
        v11 = (signed __int16)(*(_WORD *)(v1 + 76) - *(_WORD *)(a1 + 76));
        v12 = v11 * v11
            + (signed __int16)(*(_WORD *)(v1 + 78) - *(_WORD *)(a1 + 78))
            * (signed __int16)(*(_WORD *)(v1 + 78) - *(_WORD *)(a1 + 78));
        if ( v12 < v9 && v12 > 0xE100000 )
        {
          v10 = v1;
          v9 = v12;
        }
      }
      v1 = *(_DWORD *)v1;
    }
    if ( v10 )
    {
      *(_WORD *)(a1 + 150) = (signed int)(v10 - (dword_D41A0 + 28302)) / 168;
      LOWORD(v1) = *(_WORD *)(a1 + 134) + 12;
LABEL_43:
      *(_WORD *)(a1 + 130) = v1;
      goto LABEL_44;
    }
  }
LABEL_44:
  if ( *(_BYTE *)(a1 + 69) == 118 )
  {
    LOWORD(v1) = *(_WORD *)(a1 + 132);
    *(_WORD *)(a1 + 130) = v1;
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00023AC0) --------------------------------------------------------
char __cdecl sub_23AC0(int a1)
{
  *(_BYTE *)(a1 + 69) = 113;
  return sub_237B0(a1);
}

//----- (00023AE0) --------------------------------------------------------
char __cdecl sub_23AE0(int a1)
{
  *(_BYTE *)(a1 + 69) = 113;
  return sub_237B0(a1);
}

//----- (00023B00) --------------------------------------------------------
int __cdecl sub_23B00(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 16) )
    result = sub_57F10(a1);
  else
    result = sub_1C890(a1, 112);
  return result;
}

//----- (00023B30) --------------------------------------------------------
void __cdecl sub_23B30(int a1)
{
  unsigned int v1; // edx

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 36)];
  if ( v1 > dword_EA3E4[0] && (!*(_BYTE *)(v1 + 64) || *(_BYTE *)(v1 + 64) == 1) )
    *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 36)] + 164) + 584) = 200;
  sub_1C930(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00023B90) --------------------------------------------------------
__int16 __cdecl sub_23B90(int a1)
{
  __int16 result; // ax

  LOBYTE(result) = sub_1C980(a1, 112);
  HIBYTE(result) = *(_BYTE *)(a1 + 69);
  if ( HIBYTE(result) != 118 )
  {
    result = *(_WORD *)(a1 + 134);
    *(_WORD *)(a1 + 150) = 0;
    *(_WORD *)(a1 + 130) = result;
  }
  return result;
}

//----- (00023BD0) --------------------------------------------------------
__int16 __cdecl sub_23BD0(int a1)
{
  __int16 result; // ax

  sub_1D5D0(a1, 112);
  if ( *(_BYTE *)(a1 + 69) == 118 )
    result = *(_WORD *)(a1 + 132);
  else
    result = *(_WORD *)(a1 + 134);
  *(_WORD *)(a1 + 130) = result;
  return result;
}

//----- (00023C20) --------------------------------------------------------
signed int __cdecl sub_23C20(int a1)
{
  return sub_1BD90(a1, 120);
}

//----- (00023C40) --------------------------------------------------------
void __cdecl sub_23C40(int a1)
{
  unsigned int v1; // esi
  __int16 v2; // ax
  int i; // eax
  int v4; // edx
  int v5; // eax
  int v6; // eax
  __int16 v7; // ax
  int v8; // esi
  int v9; // eax
  unsigned int v10; // esi
  int v11; // eax
  unsigned int v12; // edi
  signed int v13; // ST0C_4
  __int16 v14; // ax
  int v15; // eax
  unsigned int v16; // [esp+0h] [ebp-10h]
  unsigned int v17; // [esp+8h] [ebp-8h]
  unsigned int v18; // [esp+Ch] [ebp-4h]

  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v1 = 1;
    *(_WORD *)(a1 + 38) = v2;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        v1 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v1 < 1 )
  {
    if ( !v1 )
    {
      sub_24190(a1);
      v8 = *(_DWORD *)(a1 + 160);
      if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v8 + 26)) )
      {
        if ( *(_BYTE *)(a1 + 57) )
        {
          v9 = *(signed __int16 *)(v8 + 28) * *(signed __int16 *)(v8 + 28);
          v16 = -1;
          v18 = 0;
          v10 = *(_DWORD *)(dword_D41A4 + 38519);
          v17 = v9;
          while ( v10 > dword_EA3E4[0] )
          {
            if ( *(_WORD *)(v10 + 26) != *(_WORD *)(a1 + 26) )
            {
              v11 = (signed __int16)(*(_WORD *)(v10 + 76) - *(_WORD *)(a1 + 76));
              v12 = (signed __int16)(*(_WORD *)(v10 + 78) - *(_WORD *)(a1 + 78))
                  * (signed __int16)(*(_WORD *)(v10 + 78) - *(_WORD *)(a1 + 78))
                  + v11 * v11;
              if ( v12 <= v17 && !(*(_BYTE *)(v10 + 12) & 0x20) )
              {
                v13 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 30);
                v14 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v10 + 76));
                if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v14) < v13 && v12 < v16 )
                {
                  v18 = v10;
                  v16 = v12;
                }
              }
            }
            v10 = *(_DWORD *)v10;
          }
          if ( v18 )
          {
            v15 = v18 - (dword_D41A0 + 28302);
            *(_BYTE *)(a1 + 69) = 122;
            *(_WORD *)(a1 + 150) = v15 / 168;
          }
        }
      }
    }
  }
  else if ( v1 <= 1 )
  {
    v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
    if ( *(_BYTE *)(v6 + 63) == 3 && *(_WORD *)(v6 + 26) != *(_WORD *)(a1 + 26) )
    {
      v7 = *(_WORD *)(a1 + 38);
      *(_BYTE *)(a1 + 69) = 122;
      *(_WORD *)(a1 + 150) = v7;
    }
    sub_1EEE0(a1);
  }
  else if ( v1 == 2 )
  {
    *(_BYTE *)(a1 + 69) = 124;
  }
  if ( *(_BYTE *)(a1 + 69) == 122 )
    sub_24100((_WORD *)a1);
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00023E60) --------------------------------------------------------
void __cdecl sub_23E60(int a1)
{
  unsigned int v1; // esi
  __int16 v2; // ax
  int i; // eax
  int v4; // edx
  int v5; // eax
  unsigned int v6; // edi
  int v7; // esi
  unsigned int v8; // esi
  int v9; // eax
  int v10; // esi
  _WORD *v11; // [esp+4h] [ebp-8h]
  _WORD *v12; // [esp+8h] [ebp-4h]

  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v1 = 1;
    *(_WORD *)(a1 + 38) = v2;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        v1 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v1 <= 1 )
  {
    v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( !(*(_BYTE *)(a1 + 62) & 3) )
      *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v6 + 76));
    if ( *(_DWORD *)(v6 + 8) < 0 || *(_BYTE *)(v6 + 13) & 4 )
    {
      *(_BYTE *)(a1 + 69) = 121;
      goto LABEL_26;
    }
    v7 = *(_DWORD *)(a1 + 160);
    if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v7 + 26)) )
    {
      v11 = (_WORD *)(v6 + 76);
      v8 = *(signed __int16 *)(v7 + 28);
      v12 = (_WORD *)(a1 + 76);
      if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v6 + 76)) >= v8 )
      {
        *(_BYTE *)(a1 + 69) = 121;
        goto LABEL_26;
      }
      v9 = sub_4A190((int)v12, 9, 13);
      v10 = v9;
      if ( v9 )
      {
        *(_WORD *)(v9 + 26) = *(_WORD *)(a1 + 26);
        *(_WORD *)(v9 + 28) = sub_581E0(v12, v11);
        *(_WORD *)(v10 + 30) = sub_58210(v12, v11);
        *(_WORD *)(v10 + 80) += *(_WORD *)(a1 + 88) / 2;
        *(_WORD *)(v10 + 150) = *(_WORD *)(a1 + 150);
        *(_BYTE *)(v10 + 66) = *(_BYTE *)(a1 + 66);
        *(_BYTE *)(v10 + 65) = *(_BYTE *)(a1 + 65);
        sub_5EF70(v6);
      }
    }
    sub_1EEE0(a1);
  }
  else if ( v1 == 2 )
  {
    *(_BYTE *)(a1 + 69) = 124;
  }
LABEL_26:
  if ( *(_BYTE *)(a1 + 69) != 122 )
    sub_24150((_WORD *)a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000240A0) --------------------------------------------------------
char __cdecl sub_240A0(int a1)
{
  return sub_1C560(a1, 0x78u);
}

//----- (000240C0) --------------------------------------------------------
int __cdecl sub_240C0(int a1)
{
  return sub_1C890(a1, 120);
}

//----- (000240E0) --------------------------------------------------------
void __cdecl sub_240E0(int a1)
{
  sub_1C930(a1);
}

//----- (00024100) --------------------------------------------------------
int __cdecl sub_24100(_WORD *a1)
{
  signed int v1; // edx
  int result; // eax

  a1[10] = 9377 * a1[10] + 9439;
  v1 = (unsigned __int16)a1[10] % 0x14u;
  a1[65] = 0;
  if ( v1 <= 10 )
    result = sub_49CD0(a1, 206);
  else
    result = sub_49CD0(a1, 1);
  return result;
}

//----- (00024150) --------------------------------------------------------
int __cdecl sub_24150(_WORD *a1)
{
  a1[65] = a1[66];
  return sub_49CD0(a1, 0);
}

//----- (00024190) --------------------------------------------------------
signed int __cdecl sub_24190(int a1)
{
  int v1; // esi
  signed int result; // eax
  unsigned __int16 v3; // ST04_2
  unsigned __int16 v4; // dx
  unsigned int v5; // esi
  int v6; // eax
  unsigned int i; // ecx
  int v8; // [esp+0h] [ebp-18h]
  int v9; // [esp+4h] [ebp-14h]
  int v10; // [esp+8h] [ebp-10h]
  int v11; // [esp+Ch] [ebp-Ch]
  int v12; // [esp+10h] [ebp-8h]
  char v13; // [esp+14h] [ebp-4h]

  v10 = 0;
  v8 = *(_DWORD *)"X\x1BX\x1B\n";
  v9 = *(_DWORD *)"\n";
  v12 = 1;
  if ( !(*(unsigned __int8 *)(a1 + 62) % 8) )
  {
    v1 = ~*(_DWORD *)(*(_DWORD *)(a1 + 160) + 20);
    result = (signed int)sub_104D0((signed __int16 *)(a1 + 76));
    if ( result & v1 )
    {
      *(_BYTE *)(a1 + 69) = 124;
      return result;
    }
    LOWORD(result) = *(_WORD *)(a1 + 28);
    while ( 1 )
    {
      v11 = result;
      if ( (unsigned __int16)v10 >= 4u )
        break;
      v3 = v11;
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      sub_57FA0(&word_EB398, v3, 0, 256);
      v4 = v10;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v5 = *(unsigned __int16 *)(a1 + 20) % (unsigned int)*((unsigned __int16 *)&v8 + v4);
      v6 = (v5 + 2) * (sub_102D0(a1, &word_EB398, 1) == 0);
      if ( (unsigned __int16)v6 > (unsigned __int16)v12 )
      {
        v12 = v6;
        *(_WORD *)(a1 + 28) = v11;
      }
      result = v11;
      BYTE1(result) = (BYTE1(result) + 2) & 7;
      ++v10;
    }
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  if ( !(*(unsigned __int8 *)(a1 + 62) % 16) )
  {
    switch ( ((*(unsigned __int16 *)(a1 + 28) - 256) >> 9) & 3 )
    {
      case 0:
      case 2:
        word_EB39A = (word_EB39A >> 8 << 8) + 128;
        break;
      case 1:
      case 3:
        word_EB398 = (word_EB398 >> 8 << 8) + 128;
        break;
      default:
        break;
    }
  }
  v13 = 0;
  for ( i = *(_DWORD *)(4 * *(char *)(a1 + 64) + dword_D41A4 + 38403); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26)
      && abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(i + 76)) < 256
      && abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(i + 78)) < 256 )
    {
      *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(i + 76), (_WORD *)(a1 + 76));
      v13 = 1;
      break;
    }
  }
  if ( *(_WORD *)(a1 + 32) == *(_WORD *)(a1 + 28)
    || (*(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439,
        (signed int)(*(unsigned __int16 *)(a1 + 20) % 0x14u) <= 10) )
  {
    sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
    sub_57CF0(a1, (int)&word_EB398);
  }
  return sub_1EEE0(a1);
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;

//----- (00024400) --------------------------------------------------------
void __cdecl sub_24400(int a1)
{
  sub_1D5D0(a1, 120);
}

//----- (00024420) --------------------------------------------------------
signed int __cdecl sub_24420(int a1)
{
  return sub_1BD90(a1, 128);
}

//----- (00024440) --------------------------------------------------------
void __cdecl sub_24440(int a1)
{
  int v1; // ecx
  int v2; // edx
  unsigned int v3; // esi
  unsigned int i; // eax
  int v5; // ecx
  unsigned int v6; // ecx
  int v7; // eax
  unsigned int v8; // [esp+4h] [ebp-4h]

  sub_1BF90(a1, 128);
  if ( *(_BYTE *)(a1 + 69) == -127 )
  {
    v1 = *(_DWORD *)(a1 + 160);
    v2 = *(unsigned __int8 *)(a1 + 62) % (*(signed __int16 *)(v1 + 26) + 1);
    if ( !v2 )
    {
      v8 = *(signed __int16 *)(v1 + 28) * *(signed __int16 *)(v1 + 28);
      v3 = -1;
      for ( i = *(_DWORD *)(dword_D41A4 + 38527); i > dword_EA3E4[0]; i = *(_DWORD *)i )
      {
        v5 = (signed __int16)(*(_WORD *)(i + 76) - *(_WORD *)(a1 + 76));
        v6 = v5 * v5
           + (signed __int16)(*(_WORD *)(i + 78) - *(_WORD *)(a1 + 78))
           * (signed __int16)(*(_WORD *)(i + 78) - *(_WORD *)(a1 + 78));
        if ( v6 <= v8 && v6 < v3 )
        {
          v2 = i;
          v3 = v6;
        }
      }
      if ( v2 )
      {
        v7 = (v2 - (dword_D41A0 + 28302)) / 168;
        *(_BYTE *)(a1 + 69) = -126;
        *(_WORD *)(a1 + 150) = v7;
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00024510) --------------------------------------------------------
__int16 __cdecl sub_24510(int a1)
{
  int v1; // eax
  unsigned int i; // eax
  unsigned int v3; // esi
  int v4; // edi
  unsigned int v5; // edi
  int v6; // eax
  int v7; // eax
  int v8; // esi
  __int16 v9; // ax
  int v10; // eax
  __int16 v11; // ax
  unsigned int v13; // [esp+4h] [ebp-8h]
  _WORD *v14; // [esp+8h] [ebp-4h]

  v1 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
  i = v1 * v1;
  v3 = 0;
  v13 = i;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    LOWORD(i) = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v3 = 1;
    *(_WORD *)(a1 + 38) = i;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v4 + 52) )
    {
      v4 = dword_EA3E4[i];
      if ( v4 == dword_EA3E4[0] )
        break;
      i = *(_DWORD *)(v4 + 8);
      if ( (signed int)i < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = i;
        LOWORD(i) = *(_WORD *)(v4 + 38);
        v3 = 1;
        *(_WORD *)(a1 + 38) = i;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    LOWORD(i) = *(_WORD *)(a1 + 38);
    v3 = 2;
    *(_WORD *)(a1 + 36) = i;
  }
  if ( v3 < 1 )
  {
    if ( !v3 )
    {
      sub_1B8C0(a1);
      i = sub_1ED30(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
      v5 = i;
      if ( i > dword_EA3E4[0] )
      {
        if ( !(*(_BYTE *)(a1 + 62) & 7) )
        {
          if ( *(_BYTE *)(i + 63) == 3 || (i = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(i + 76)), i >= 0x200) )
          {
            LOWORD(i) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v5 + 76));
            *(_WORD *)(a1 + 32) = i;
          }
        }
        if ( *(_DWORD *)(v5 + 8) < 0 || *(_BYTE *)(v5 + 13) & 4 )
        {
          *(_BYTE *)(a1 + 69) = -127;
        }
        else
        {
          v6 = *(_DWORD *)(a1 + 16);
          if ( v6 )
          {
            *(_DWORD *)(a1 + 16) = v6 - 1;
            v14 = (_WORD *)(a1 + 76);
            v7 = sub_4A190(a1 + 76, 9, 0);
            v8 = v7;
            if ( v7 )
            {
              *(_BYTE *)(v7 + 67) = 10;
              *(_BYTE *)(v7 + 68) = 0;
              *(_DWORD *)(v7 + 160) = &unk_D83F0;
              *(_BYTE *)(v7 + 66) = *(_BYTE *)(v5 + 64);
              *(_BYTE *)(v7 + 65) = *(_BYTE *)(v5 + 63);
              *(_WORD *)(v7 + 26) = *(_WORD *)(a1 + 26);
              *(_WORD *)(v7 + 28) = sub_581E0(v14, (_WORD *)(v5 + 76));
              *(_WORD *)(v8 + 30) = sub_58210(v14, (_WORD *)(v5 + 76));
              *(_WORD *)(v8 + 80) += 6 * *(_WORD *)(a1 + 88);
              v9 = *(_WORD *)(a1 + 150);
              *(_WORD *)(v8 + 42) = 1600;
              *(_DWORD *)(v8 + 144) = 50000;
              *(_WORD *)(v8 + 150) = v9;
            }
          }
          LOWORD(i) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(_WORD *)(*(_DWORD *)(a1 + 160) + 26);
          if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
          {
            v10 = (signed __int16)(*(_WORD *)(v5 + 76) - *(_WORD *)(a1 + 76));
            i = v10 * v10
              + (signed __int16)(*(_WORD *)(v5 + 78) - *(_WORD *)(a1 + 78))
              * (signed __int16)(*(_WORD *)(v5 + 78) - *(_WORD *)(a1 + 78));
            if ( i < v13 )
            {
              if ( !(*(unsigned __int8 *)(a1 + 62) % (2 * *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26))) )
                sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 39);
              v11 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v5 + 76));
              LOWORD(i) = sub_582B0(*(_WORD *)(a1 + 28), v11);
              if ( (unsigned __int16)i < 0xE3u )
              {
                *(_DWORD *)(a1 + 16) = 15;
                LOWORD(i) = sub_5EF70(v5);
              }
            }
            else
            {
              *(_BYTE *)(a1 + 69) = -127;
            }
          }
        }
      }
    }
  }
  else if ( v3 <= 1 )
  {
    LOWORD(i) = *(_WORD *)(a1 + 38);
    *(_WORD *)(a1 + 150) = i;
  }
  else if ( v3 == 2 )
  {
    *(_BYTE *)(a1 + 69) = -124;
  }
  return i;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000247D0) --------------------------------------------------------
char __cdecl sub_247D0(int a1)
{
  return sub_1C560(a1, 0x80u);
}

//----- (000247F0) --------------------------------------------------------
int __cdecl sub_247F0(int a1)
{
  return sub_1C890(a1, 128);
}

//----- (00024810) --------------------------------------------------------
void __cdecl sub_24810(int a1)
{
  sub_1C930(a1);
}

//----- (00024840) --------------------------------------------------------
void __cdecl sub_24840(int a1)
{
  sub_1D5D0(a1, 128);
}

//----- (00024860) --------------------------------------------------------
unsigned int __cdecl sub_24860(int a1)
{
  unsigned int result; // eax
  char v2; // dh

  result = sub_1BD90(a1, 136);
  BYTE1(result) = *(_BYTE *)(a1 + 69);
  if ( BYTE1(result) == -118 )
  {
    result = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( result <= dword_EA3E4[0] || *(_BYTE *)(result + 63) != 3 || (v2 = *(_BYTE *)(result + 64)) != 0 && v2 != 1 )
      *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 70) = 0;
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000248C0) --------------------------------------------------------
void __cdecl sub_248C0(int a1)
{
  unsigned int v1; // eax
  char v2; // dh

  sub_1BF90(a1, 136);
  if ( *(_BYTE *)(a1 + 69) == -118 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v1 <= dword_EA3E4[0] || *(_BYTE *)(v1 + 63) != 3 || (v2 = *(_BYTE *)(v1 + 64)) != 0 && v2 != 1 )
      *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 70) = 0;
  }
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00024930) --------------------------------------------------------
__int16 __cdecl sub_24930(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // ax
  int i; // ecx
  int v4; // edx
  unsigned int v5; // eax
  char v6; // al
  unsigned int j; // ecx
  signed int v8; // esi
  signed int v9; // eax
  __int16 v10; // ax
  int v11; // esi
  signed int v13; // [esp+0h] [ebp-10h]
  signed int v14; // [esp+4h] [ebp-Ch]
  unsigned int v15; // [esp+8h] [ebp-8h]

  sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 58);
  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    v1 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = dword_EA3E4[*(unsigned __int16 *)(a1 + 52)];
          i != dword_EA3E4[0];
          i = dword_EA3E4[*(unsigned __int16 *)(i + 52)] )
    {
      v4 = *(_DWORD *)(i + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(i + 38);
        v1 = 1;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v1 = 2;
  }
  if ( v1 < 1 )
  {
    if ( v1 )
      return v1;
  }
  else
  {
    if ( v1 > 1 )
    {
      if ( v1 == 2 )
        *(_BYTE *)(a1 + 69) = -116;
      return v1;
    }
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
  }
  v13 = sub_1B8C0(a1);
  v5 = sub_1ED30(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
  v15 = v5;
  if ( v5 <= dword_EA3E4[0] || *(_DWORD *)(v5 + 8) < 0 || *(_BYTE *)(v5 + 13) & 4 )
  {
    *(_DWORD *)(a1 + 160) = &unk_D8720;
    *(_WORD *)(a1 + 150) = 0;
    LOWORD(v1) = *(_WORD *)(a1 + 132);
    *(_BYTE *)(a1 + 69) = -119;
    *(_WORD *)(a1 + 130) = v1;
  }
  else
  {
    if ( !(*(_BYTE *)(a1 + 62) & 3) )
    {
      v6 = *(_BYTE *)(a1 + 70);
      if ( !v6 || v6 == 4 )
      {
        *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v15 + 76));
        for ( j = *(_DWORD *)(4 * *(char *)(a1 + 64) + dword_D41A4 + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
        {
          if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26)
            && abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
            && abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78)) < (signed int)*(signed __int16 *)(a1 + 84) )
          {
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
            break;
          }
        }
      }
    }
    LOWORD(v1) = *(unsigned __int8 *)(a1 + 70);
    switch ( (_BYTE)v1 )
    {
      case 0:
        LOWORD(v1) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(_WORD *)(*(_DWORD *)(a1 + 160) + 26);
        if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
        {
          v1 = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v15 + 76));
          if ( v1 >= *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28) )
          {
            *(_BYTE *)(a1 + 69) = -119;
          }
          else if ( v1 >= 0x700 )
          {
            LOWORD(v1) = sub_1D0E0((_WORD *)a1, v15);
          }
          else
          {
            *(_BYTE *)(a1 + 70) = 1;
          }
        }
        return v1;
      case 1:
        LOWORD(v1) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v15 + 76));
        *(_WORD *)(a1 + 32) = v1;
        *(_WORD *)(a1 + 28) = v1;
        LOWORD(v1) = 3 * *(_WORD *)(a1 + 132);
        *(_DWORD *)(a1 + 160) = &unk_D8764;
        *(_DWORD *)(a1 + 16) = 0;
        *(_BYTE *)(a1 + 70) = 2;
        *(_WORD *)(a1 + 130) = v1;
        return v1;
      case 2:
      case 3:
        if ( v13 != 3 )
          *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        v8 = *(_DWORD *)(a1 + 16);
        if ( v8 <= 4 )
        {
          v9 = 192 >> *(_BYTE *)(a1 + 16);
        }
        else
        {
          if ( 4 - (v8 - 4) <= 0 )
          {
            v14 = -192;
            goto LABEL_49;
          }
          v9 = -(192 >> (4 - (v8 - 4)));
        }
        v14 = v9;
LABEL_49:
        ++*(_DWORD *)(a1 + 16);
        v10 = *(_WORD *)(a1 + 130);
        if ( v10 > *(_WORD *)(a1 + 134) )
          *(_WORD *)(a1 + 130) = v10 - 8;
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        v11 = v14 + word_EB39C;
        LOWORD(v1) = sub_10C40(&word_EB398);
        if ( v11 <= (signed __int16)v1 )
        {
          *(_BYTE *)(a1 + 70) = 4;
          *(_DWORD *)(a1 + 16) = 18;
        }
        else
        {
          LOBYTE(v1) = v14;
          BYTE1(v1) = *(_BYTE *)(a1 + 70);
          *(_WORD *)(a1 + 80) += v14;
          if ( BYTE1(v1) != 3 )
          {
            LOWORD(v1) = sub_1CED0(a1, v15);
            if ( (_WORD)v1 )
              *(_BYTE *)(a1 + 70) = 3;
          }
        }
        break;
      case 4:
        v1 = *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 16) = v1 - 1;
        if ( v1 )
        {
          if ( v1 == 18 )
          {
            LOWORD(v1) = *(_WORD *)(a1 + 134);
            *(_DWORD *)(a1 + 160) = &unk_D8720;
            *(_WORD *)(a1 + 130) = v1;
          }
        }
        else
        {
          *(_BYTE *)(a1 + 70) = 0;
          LOWORD(v1) = *(_WORD *)(a1 + 132);
          *(_WORD *)(a1 + 130) = v1;
        }
        return v1;
      default:
        return v1;
    }
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00024D40) --------------------------------------------------------
char __cdecl sub_24D40(int a1)
{
  unsigned int v1; // eax
  char v2; // dh

  LOBYTE(v1) = sub_1C560(a1, 0x88u);
  if ( *(_BYTE *)(a1 + 69) == -118 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v1 <= dword_EA3E4[0] || *(_BYTE *)(v1 + 63) != 3 || (v2 = *(_BYTE *)(v1 + 64)) != 0 && v2 != 1 )
      *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 70) = 0;
  }
  return v1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00024DA0) --------------------------------------------------------
int __cdecl sub_24DA0(int a1)
{
  return sub_1C890(a1, 136);
}

//----- (00024DC0) --------------------------------------------------------
void __cdecl sub_24DC0(int a1)
{
  sub_1C930(a1);
}

//----- (00024DF0) --------------------------------------------------------
void __cdecl sub_24DF0(int a1)
{
  sub_1D5D0(a1, 136);
  if ( *(_BYTE *)(a1 + 69) == -118 )
    *(_BYTE *)(a1 + 70) = 0;
}

//----- (00024E20) --------------------------------------------------------
int __cdecl sub_24E20(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // eax
  unsigned int v4; // edi
  unsigned int v5; // esi
  int v6; // eax
  int v7; // ST10_4
  __int16 v8; // ax
  int v9; // eax
  int v10; // esi
  int v11; // eax
  unsigned int v12; // [esp+0h] [ebp-10h]
  unsigned int v13; // [esp+8h] [ebp-8h]
  unsigned int v14; // [esp+Ch] [ebp-4h]

  result = sub_252E0(a1);
  if ( result )
  {
    if ( result == 1 )
      result = sub_253B0(1, a1, 2u, 0);
  }
  else
  {
    result = *(unsigned __int8 *)(a1 + 70);
    if ( (_BYTE)result )
    {
      if ( (_BYTE)result == 1 && *(_WORD *)(a1 + 150) )
      {
        v10 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
        v11 = sub_58490((_WORD *)(a1 + 76), (_WORD *)(v10 + 76));
        if ( v11 < *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28) )
        {
          sub_254E0(a1, v10, 4u);
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          result = *(unsigned __int16 *)(a1 + 20) / 0x31u;
          if ( !(*(unsigned __int16 *)(a1 + 20) % 0x31u) )
            result = sub_253B0(result, a1, 2u, 0);
        }
        else
        {
          *(_WORD *)(a1 + 150) = 0;
          result = sub_253B0(v11, a1, 0, 0);
        }
      }
    }
    else
    {
      v2 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v2;
      if ( v2 )
      {
        if ( *(_BYTE *)(a1 + 57) )
        {
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          result = *(_WORD *)(a1 + 20) & 1;
          if ( !result )
          {
            v3 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
            result = v3 * v3;
            v13 = -1;
            v4 = 0;
            v5 = *(_DWORD *)(dword_D41A4 + 38519);
            v12 = result;
            while ( v5 > dword_EA3E4[0] )
            {
              v6 = (signed __int16)(*(_WORD *)(v5 + 76) - *(_WORD *)(a1 + 76));
              result = (signed __int16)(*(_WORD *)(v5 + 78) - *(_WORD *)(a1 + 78))
                     * (signed __int16)(*(_WORD *)(v5 + 78) - *(_WORD *)(a1 + 78))
                     + v6 * v6;
              v14 = result;
              if ( result <= v12 && !(*(_BYTE *)(v5 + 12) & 0x20) )
              {
                v7 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 30);
                v8 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v5 + 76));
                result = (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v8);
                if ( result < v7 )
                {
                  result = v14;
                  if ( v14 < v13 )
                  {
                    v4 = v5;
                    v13 = v14;
                  }
                }
              }
              v5 = *(_DWORD *)v5;
            }
            if ( v4 && *(_BYTE *)(v4 + 63) == 3 )
            {
              v9 = (signed int)(v4 - (dword_D41A0 + 28302)) / 168;
              *(_WORD *)(a1 + 150) = v9;
              result = sub_253B0(v9, a1, 0, 1u);
            }
          }
        }
      }
      else
      {
        result = sub_253B0(result, a1, 1u, 0);
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00025050) --------------------------------------------------------
int __cdecl sub_25050(int a1)
{
  int result; // eax
  int v2; // edx

  result = sub_252E0(a1);
  if ( result )
  {
    if ( result == 1 )
      result = sub_253B0(1, a1, 0, 1u);
  }
  else
  {
    *(_WORD *)(a1 + 150) = 0;
    result = sub_1B8C0(a1);
    v2 = *(_DWORD *)(a1 + 16) - 1;
    *(_DWORD *)(a1 + 16) = v2;
    if ( v2 <= 0 )
      result = sub_253B0(result, a1, 0, 0);
  }
  return result;
}

//----- (000250B0) --------------------------------------------------------
__int16 __cdecl sub_250B0(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // edx
  int v4; // esi
  int v5; // eax
  int v6; // esi
  int v7; // ecx

  v1 = sub_252E0(a1);
  v2 = v1;
  if ( (unsigned int)v1 <= 1 )
  {
    v1 = *(unsigned __int8 *)(a1 + 70);
    switch ( (_BYTE)v1 )
    {
      case 0:
        v1 = sub_254E0(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)], 4u);
        if ( v2 == 1 )
        {
          v3 = *(_DWORD *)(a1 + 16) - 47;
          *(_DWORD *)(a1 + 16) = v3;
          if ( v3 < 0 )
            LOWORD(v1) = sub_253B0(v1, a1, 2u, 1u);
        }
        else
        {
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          v1 = *(unsigned __int16 *)(a1 + 20) / 0x29u;
          if ( *(unsigned __int16 *)(a1 + 20) % 0x29u )
          {
            v4 = *(_DWORD *)(a1 + 16) - 1;
            *(_DWORD *)(a1 + 16) = v4;
            if ( v4 < 0 )
              LOWORD(v1) = sub_253B0(v1, a1, 2u, 2u);
          }
          else
          {
            LOWORD(v1) = sub_253B0(v1, a1, 2u, 1u);
          }
        }
        return v1;
      case 1:
        v5 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v5;
        if ( v5 <= 0 )
          goto LABEL_17;
        LOWORD(v1) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(_WORD *)(*(_DWORD *)(a1 + 160) + 26);
        if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
        {
          v5 = sub_1ED30(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
          v6 = v5;
          if ( (unsigned int)v5 <= dword_EA3E4[0] || *(_DWORD *)(v5 + 8) < 0 || *(_BYTE *)(v5 + 13) & 4 )
          {
LABEL_17:
            LOWORD(v1) = sub_253B0(v5, a1, 2u, 2u);
          }
          else
          {
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v5 + 76));
            *(_WORD *)(a1 + 28) += sub_58350(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32), 5, 0x400u);
            *(_BYTE *)(a1 + 29) &= 7u;
            LOWORD(v1) = sub_1D460((_WORD *)a1, v6);
          }
        }
        break;
      case 2:
        v1 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v1;
        if ( v1 <= 0 )
          LOWORD(v1) = sub_253B0(v1, a1, 2u, 3u);
        break;
      case 3:
        v7 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v7;
        if ( v7 < 0 )
        {
          LOWORD(v1) = sub_253B0(v1, a1, 1u, 0);
        }
        else if ( v7 >= 8 )
        {
          *(_WORD *)(a1 + 28) += 170;
          *(_BYTE *)(a1 + 29) &= 7u;
          LOWORD(v1) = *(_WORD *)(a1 + 28);
          *(_WORD *)(a1 + 32) = v1;
        }
        break;
      default:
        return v1;
    }
  }
  return v1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00025280) --------------------------------------------------------
int __usercall sub_25280@<eax>(int a1@<eax>, int a2)
{
  return sub_253B0(a1, a2, 0, 0);
}

//----- (000252A0) --------------------------------------------------------
int __cdecl sub_252A0(int a1)
{
  return sub_1C890(a1, 144);
}

//----- (000252C0) --------------------------------------------------------
void __cdecl sub_252C0(int a1)
{
  sub_1C930(a1);
}

//----- (000252E0) --------------------------------------------------------
unsigned int __cdecl sub_252E0(int a1)
{
  __int16 v1; // ax
  __int16 v2; // dx
  unsigned int result; // eax
  __int16 v4; // ax
  int i; // edx
  int v6; // ecx
  int v7; // edx

  v1 = sub_10C40((__int16 *)(a1 + 76));
  v2 = *(_WORD *)(a1 + 98);
  *(_WORD *)(a1 + 80) = v1;
  result = 0;
  if ( v2 )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v4 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v4;
    result = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v7 + 52) )
    {
      v7 = dword_EA3E4[i];
      if ( v7 == dword_EA3E4[0] )
        break;
      v6 = *(_DWORD *)(v7 + 8);
      if ( v6 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v6;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v7 + 38);
        result = 1;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    result = 2;
  }
  if ( result >= 1 )
  {
    if ( result <= 1 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
    }
    else if ( result == 2 )
    {
      *(_BYTE *)(a1 + 69) = -108;
    }
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000253B0) --------------------------------------------------------
int __usercall sub_253B0@<eax>(int result@<eax>, int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  signed int v4; // esi
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rt2

  if ( a3 < 1u )
  {
    if ( !a3 )
    {
      if ( a4 )
      {
        if ( a4 != 1 )
          goto LABEL_19;
        HIDWORD(v5) = 0;
        *(_WORD *)(a2 + 20) = 9377 * *(_WORD *)(a2 + 20) + 9439;
        WORD1(v5) = 0;
        v4 = 60;
      }
      else
      {
        v4 = 400;
        *(_WORD *)(a2 + 20) = 9377 * *(_WORD *)(a2 + 20) + 9439;
        v5 = 0i64;
      }
      LOWORD(v5) = *(_WORD *)(a2 + 20);
      v6 = v5 % (unsigned int)v4;
      result = v5 / (unsigned int)v4;
      *(_DWORD *)(a2 + 16) = v4 + v6;
    }
LABEL_19:
    *(_BYTE *)(a2 + 70) = a4;
    *(_BYTE *)(a2 + 69) = a3 - 112;
    return result;
  }
  if ( a3 <= 1u )
  {
    *(_WORD *)(a2 + 20) = 9377 * *(_WORD *)(a2 + 20) + 9439;
    result = *(unsigned __int16 *)(a2 + 20) / 0x190u;
    *(_DWORD *)(a2 + 16) = *(unsigned __int16 *)(a2 + 20) % 0x190u + 400;
    *(_BYTE *)(a2 + 70) = a4;
    *(_BYTE *)(a2 + 69) = a3 - 112;
    return result;
  }
  if ( a3 != 2 || a4 > 3u )
    goto LABEL_19;
  result = a4;
  switch ( a4 )
  {
    case 0u:
      *(_WORD *)(a2 + 20) = 9377 * *(_WORD *)(a2 + 20) + 9439;
      result = *(unsigned __int16 *)(a2 + 20) / 0xC8u;
      *(_DWORD *)(a2 + 16) = *(unsigned __int16 *)(a2 + 20) % 0xC8u + 200;
      *(_BYTE *)(a2 + 70) = a4;
      *(_BYTE *)(a2 + 69) = -110;
      break;
    case 1u:
      *(_DWORD *)(a2 + 16) = 10;
      *(_BYTE *)(a2 + 70) = a4;
      *(_BYTE *)(a2 + 69) = -110;
      break;
    case 2u:
      *(_DWORD *)(a2 + 16) = 12;
      *(_BYTE *)(a2 + 70) = a4;
      *(_BYTE *)(a2 + 69) = -110;
      break;
    case 3u:
      *(_DWORD *)(a2 + 16) = 14;
      goto LABEL_19;
  }
  return result;
}

//----- (000254E0) --------------------------------------------------------
int __cdecl sub_254E0(int a1, int a2, unsigned __int8 a3)
{
  int v3; // ebx
  int result; // eax

  v3 = a1;
  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
  result = sub_58350(*(_WORD *)(v3 + 28), *(_WORD *)(v3 + 32), 5, (a3 << 11) / 360);
  *(_WORD *)(v3 + 28) += result;
  BYTE1(result) = *(_BYTE *)(a1 + 29) & 7;
  *(_BYTE *)(a1 + 29) = BYTE1(result);
  return result;
}

//----- (00025550) --------------------------------------------------------
int __cdecl sub_25550(int a1)
{
  int result; // eax

  sub_1D5D0(a1, 144);
  result = sub_10C40((__int16 *)(a1 + 76));
  *(_WORD *)(a1 + 80) = result;
  BYTE1(result) = *(_BYTE *)(a1 + 69);
  if ( BYTE1(result) == -110 )
    result = sub_253B0(result, a1, 2u, 0);
  return result;
}

//----- (00025590) --------------------------------------------------------
signed int __cdecl sub_25590(int a1)
{
  signed int result; // eax

  result = sub_1BD90(a1, 152);
  BYTE1(result) = *(_BYTE *)(a1 + 69);
  if ( BYTE1(result) == -102 )
    *(_BYTE *)(a1 + 70) = 0;
  return result;
}

//----- (000255C0) --------------------------------------------------------
void __cdecl sub_255C0(int a1)
{
  sub_1BF90(a1, 152);
  if ( *(_BYTE *)(a1 + 69) == -102 )
    *(_BYTE *)(a1 + 70) = 0;
}

//----- (00025610) --------------------------------------------------------
void __cdecl sub_25610(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // ax
  int i; // edx
  int v4; // edx
  int v5; // ecx
  __int16 v6; // ax
  unsigned int v7; // eax
  __int16 v8; // ax
  __int16 v9; // ax
  char v10; // dh
  unsigned int j; // ecx
  __int16 v12; // cx
  int v13; // eax
  int v14; // edx
  unsigned int v15; // ecx
  unsigned int v16; // edx
  signed __int16 v17; // dx
  __int16 v18; // dx
  __int16 v19; // ST0C_2
  __int16 v20; // ax
  int v21; // edi
  unsigned int v22; // ecx
  int v23; // ecx
  char v24; // dh
  int v25; // ecx
  unsigned int v26; // esi
  __int16 v27; // ax
  __int16 v28; // ax
  int v29; // edx
  unsigned int v30; // ecx
  int v31; // ecx
  unsigned int v32; // esi
  __int16 v33; // ax
  unsigned __int16 *v34; // [esp+0h] [ebp-14h]

  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    v1 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        v1 = 1;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v1 = 2;
  }
  if ( v1 < 1 )
  {
    if ( !v1 )
    {
      sub_1B8C0(a1);
      v7 = sub_1ED30(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
      v34 = (unsigned __int16 *)v7;
      if ( v7 <= dword_EA3E4[0] || *(_DWORD *)(v7 + 8) < 0 || *(_BYTE *)(v7 + 13) & 4 )
      {
LABEL_92:
        v33 = *(_WORD *)(a1 + 132);
        *(_BYTE *)(a1 + 69) = -103;
        *(_WORD *)(a1 + 130) = v33;
      }
      else
      {
        switch ( *(_BYTE *)(a1 + 70) )
        {
          case 0:
            v8 = *(_WORD *)(a1 + 132);
            *(_BYTE *)(a1 + 70) = 1;
            *(_WORD *)(a1 + 130) = v8;
            goto LABEL_25;
          case 1:
LABEL_25:
            *(_DWORD *)&word_EB398 = *((_DWORD *)v34 + 19);
            *(&word_EB398 + 2) = v34[40];
            *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
            sub_57FA0(
              &word_EB398,
              (v34[14] - 256 + (signed int)(*(unsigned __int16 *)(a1 + 20) % 0x5Au << 11) / 360) & 0x7FF,
              0,
              2048);
            if ( sub_583F0((_WORD *)(a1 + 76), &word_EB398) <= 0x500 )
            {
              *(_BYTE *)(a1 + 70) = 2;
            }
            else
            {
              v9 = sub_581E0((_WORD *)(a1 + 76), &word_EB398);
              v10 = *(_BYTE *)(a1 + 62);
              *(_WORD *)(a1 + 32) = v9;
              if ( v10 & 3 )
                return;
              for ( j = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
              {
                if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26)
                  && abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
                  && abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78)) < (signed int)*(signed __int16 *)(a1 + 84) )
                {
                  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
                  return;
                }
              }
            }
            return;
          case 2:
            v12 = *(_WORD *)(a1 + 20);
            *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 134);
            *(_WORD *)(a1 + 20) = 9377 * v12 + 9439;
            v13 = *(signed __int16 *)(v7 + 80);
            v14 = *(_WORD *)(a1 + 20) & 0x3FF;
            *(_BYTE *)(a1 + 70) = 3;
            *(_DWORD *)(a1 + 16) = v14 + v13;
            goto LABEL_37;
          case 3:
LABEL_37:
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), v34 + 38);
            if ( *(_BYTE *)(a1 + 62) & 3 )
              return;
            v15 = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403);
            while ( 2 )
            {
              if ( v15 > dword_EA3E4[0] )
              {
                if ( *(_WORD *)(v15 + 26) == *(_WORD *)(a1 + 26)
                  || abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(v15 + 76)) >= (signed int)*(signed __int16 *)(a1 + 84)
                  || abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(v15 + 78)) >= (signed int)*(signed __int16 *)(a1 + 84) )
                {
                  v15 = *(_DWORD *)v15;
                  continue;
                }
                *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(v15 + 76), (_WORD *)(a1 + 76));
              }
              break;
            }
            *(_DWORD *)&word_EB398 = *((_DWORD *)v34 + 19);
            *(&word_EB398 + 2) = v34[40];
            sub_57FA0(&word_EB398, v34[14], 0, 2048);
            if ( sub_583F0((_WORD *)(a1 + 76), &word_EB398) > 0x500 )
            {
LABEL_57:
              *(_BYTE *)(a1 + 70) = 0;
            }
            else
            {
              *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
              v16 = *(unsigned __int16 *)(a1 + 20) % 0x11Fu;
              if ( !(v16 & 0x3F) )
                *(_BYTE *)(a1 + 70) = 6;
              if ( !(v16 & 0x1F) )
                *(_BYTE *)(a1 + 70) = 7;
              if ( !v16 )
                *(_BYTE *)(a1 + 70) = 4;
              if ( !(v16 & 3) )
              {
                if ( (signed int)*(signed __int16 *)(a1 + 80) <= *(_DWORD *)(a1 + 16) )
                  v17 = 64;
                else
                  v17 = -64;
                *(_WORD *)(a1 + 80) += v17;
              }
            }
            return;
          case 4:
            v27 = *(_WORD *)(a1 + 132);
            *(_BYTE *)(a1 + 70) = 5;
            *(_WORD *)(a1 + 130) = v27;
            goto LABEL_81;
          case 5:
LABEL_81:
            if ( *(_BYTE *)(a1 + 62) & 3 )
              goto LABEL_89;
            v28 = sub_581E0((_WORD *)(a1 + 76), v34 + 38);
            v29 = dword_D41A4;
            *(_WORD *)(a1 + 32) = v28;
            v30 = *(_DWORD *)(v29 + 4 * *(char *)(a1 + 64) + 38403);
            while ( 2 )
            {
              if ( v30 > dword_EA3E4[0] )
              {
                if ( *(_WORD *)(v30 + 26) == *(_WORD *)(a1 + 26)
                  || abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(v30 + 76)) >= (signed int)*(signed __int16 *)(a1 + 84)
                  || abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(v30 + 78)) >= (signed int)*(signed __int16 *)(a1 + 84) )
                {
                  v30 = *(_DWORD *)v30;
                  continue;
                }
                *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(v30 + 76), (_WORD *)(a1 + 76));
              }
              break;
            }
LABEL_89:
            v31 = *(_DWORD *)(a1 + 160);
            if ( *(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v31 + 26) )
              return;
            v32 = *(signed __int16 *)(v31 + 28);
            if ( sub_583F0((_WORD *)(a1 + 76), v34 + 38) >= v32 )
              goto LABEL_79;
            sub_1CC20((_WORD *)a1, (unsigned int)v34);
            return;
          case 6:
            goto LABEL_92;
          case 7:
            v18 = *(_WORD *)(a1 + 20);
            *(_WORD *)(a1 + 130) = 3 * *(_WORD *)(a1 + 132);
            *(_WORD *)(a1 + 20) = 9377 * v18 + 9439;
            v19 = (*(_WORD *)(a1 + 20) & 1) + 43;
            v20 = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_DWORD *)(a1 + 16) = 24;
            *(_BYTE *)(a1 + 70) = 8;
            sub_6E450(v20, -1, v19);
            goto LABEL_59;
          case 8:
          case 9:
LABEL_59:
            v21 = *(_DWORD *)(a1 + 16) - 1;
            *(_DWORD *)(a1 + 16) = v21;
            if ( !v21 )
              goto LABEL_57;
            if ( *(_BYTE *)(a1 + 62) & 3 )
              goto LABEL_70;
            if ( v21 > 16 )
              *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), v34 + 38);
            v22 = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403);
            break;
          default:
            return;
        }
        while ( v22 > dword_EA3E4[0] )
        {
          if ( *(_WORD *)(v22 + 26) != *(_WORD *)(a1 + 26)
            && abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(v22 + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
            && abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(v22 + 78)) < (signed int)*(signed __int16 *)(a1 + 84) )
          {
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(v22 + 76), (_WORD *)(a1 + 76));
            break;
          }
          v22 = *(_DWORD *)v22;
        }
LABEL_70:
        v23 = (signed __int16)v34[40] - *(signed __int16 *)(a1 + 80);
        if ( abs(v23) > 64 )
        {
          if ( v23 <= 0 )
            LOWORD(v23) = -64;
          else
            LOWORD(v23) = 64;
        }
        v24 = *(_BYTE *)(a1 + 70);
        *(_WORD *)(a1 + 80) += v23;
        if ( v24 == 8 && (unsigned __int16)sub_1CED0(a1, (int)v34) )
          *(_BYTE *)(a1 + 70) = 9;
        v25 = *(_DWORD *)(a1 + 160);
        if ( !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v25 + 26)) )
        {
          v26 = *(signed __int16 *)(v25 + 28);
          if ( sub_583F0((_WORD *)(a1 + 76), v34 + 38) >= v26 )
LABEL_79:
            *(_BYTE *)(a1 + 70) = 6;
        }
      }
    }
  }
  else if ( v1 <= 1 )
  {
    v6 = *(_WORD *)(a1 + 38);
    *(_BYTE *)(a1 + 70) = 7;
    *(_WORD *)(a1 + 150) = v6;
  }
  else if ( v1 == 2 )
  {
    *(_BYTE *)(a1 + 69) = -100;
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00025CD0) --------------------------------------------------------
char __cdecl sub_25CD0(int a1)
{
  char result; // al

  result = sub_1C560(a1, 0x98u);
  if ( *(_BYTE *)(a1 + 69) == -102 )
    *(_BYTE *)(a1 + 70) = 0;
  return result;
}

//----- (00025D00) --------------------------------------------------------
int __cdecl sub_25D00(int a1)
{
  return sub_1C890(a1, 152);
}

//----- (00025D20) --------------------------------------------------------
void __cdecl sub_25D20(int a1)
{
  sub_1C930(a1);
}

//----- (00025D50) --------------------------------------------------------
void __cdecl sub_25D50(int a1)
{
  sub_1D5D0(a1, 152);
  if ( *(_BYTE *)(a1 + 69) == -102 )
    *(_BYTE *)(a1 + 70) = 0;
}

//----- (00025D80) --------------------------------------------------------
unsigned int __cdecl sub_25D80(int a1)
{
  unsigned int result; // eax
  char v2; // dh

  result = sub_1BD90(a1, 160);
  BYTE1(result) = *(_BYTE *)(a1 + 69);
  if ( BYTE1(result) == -94 )
  {
    result = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( result <= dword_EA3E4[0] || *(_BYTE *)(result + 63) != 3 || (v2 = *(_BYTE *)(result + 64)) != 0 && v2 != 1 )
      *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 70) = 0;
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00025DE0) --------------------------------------------------------
void __cdecl sub_25DE0(int a1)
{
  unsigned int v1; // eax
  char v2; // dh

  sub_1BF90(a1, 160);
  if ( *(_BYTE *)(a1 + 69) == -94 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v1 <= dword_EA3E4[0] || *(_BYTE *)(v1 + 63) != 3 || (v2 = *(_BYTE *)(v1 + 64)) != 0 && v2 != 1 )
      *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 70) = 0;
  }
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00025E40) --------------------------------------------------------
void __cdecl sub_25E40(int a1)
{
  unsigned int v1; // esi
  unsigned __int8 v2; // al
  char v3; // al
  _BOOL1 v4; // zf
  __int16 v5; // dx
  int v6; // ecx
  __int16 v7; // ax
  char v8; // [esp+0h] [ebp-4h]

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v8 = 0;
  if ( v1 <= dword_EA3E4[0] )
  {
    *(_BYTE *)(a1 + 69) = -95;
    goto LABEL_21;
  }
  sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 32);
  v2 = *(_BYTE *)(a1 + 70);
  if ( v2 < 1u )
  {
    if ( !v2 )
    {
      v3 = sub_1C310(a1, 160, (unsigned __int16 (__cdecl *)(int, int))sub_1D1A0);
      if ( *(_BYTE *)(v1 + 63) != 3 || *(_BYTE *)(v1 + 64) )
        v4 = v3 == 0;
      else
        v4 = *(_BYTE *)(*(_DWORD *)(v1 + 164) + 334) == 0;
      if ( !v4 )
        *(_BYTE *)(a1 + 70) = 1;
    }
  }
  else
  {
    if ( v2 <= 1u )
    {
      *(_BYTE *)(a1 + 70) = 2;
      v5 = *(_WORD *)(a1 + 132);
      *(_DWORD *)(a1 + 16) = 32;
      *(_WORD *)(a1 + 130) = 2 * v5;
    }
    else if ( v2 != 2 )
    {
      goto LABEL_21;
    }
    if ( (unsigned __int16)sub_1C310(a1, 160, (unsigned __int16 (__cdecl *)(int, int))sub_1CE80) )
      v8 = 1;
    v6 = *(_DWORD *)(a1 + 16) - 1;
    *(_DWORD *)(a1 + 16) = v6;
    if ( !v6 )
      v8 = 1;
    if ( v8 )
    {
      v7 = *(_WORD *)(a1 + 132);
      *(_BYTE *)(a1 + 70) = 0;
      *(_WORD *)(a1 + 130) = v7;
    }
  }
LABEL_21:
  if ( *(_BYTE *)(a1 + 69) != -94 )
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00025F70) --------------------------------------------------------
char __cdecl sub_25F70(int a1)
{
  unsigned int v1; // eax
  char v2; // dh

  LOBYTE(v1) = sub_1C560(a1, 0xA0u);
  if ( *(_BYTE *)(a1 + 69) == -94 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v1 <= dword_EA3E4[0] || *(_BYTE *)(v1 + 63) != 3 || (v2 = *(_BYTE *)(v1 + 64)) != 0 && v2 != 1 )
      *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 70) = 0;
  }
  return v1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00025FD0) --------------------------------------------------------
int __cdecl sub_25FD0(int a1)
{
  return sub_1C890(a1, 160);
}

//----- (00025FF0) --------------------------------------------------------
void __cdecl sub_25FF0(int a1)
{
  sub_1C930(a1);
}

//----- (00026020) --------------------------------------------------------
void __cdecl sub_26020(int a1)
{
  sub_1D5D0(a1, 160);
  if ( *(_BYTE *)(a1 + 69) == -94 )
    *(_BYTE *)(a1 + 70) = 0;
}

//----- (00026050) --------------------------------------------------------
int __cdecl sub_26050(int a1)
{
  return sub_268F0(a1, 1u);
}

//----- (00026070) --------------------------------------------------------
char __cdecl sub_26070(int a1)
{
  signed int v1; // eax
  unsigned __int16 v2; // ax
  int v3; // eax
  unsigned int v4; // edi
  unsigned int v5; // esi
  int v6; // eax
  int v7; // edx
  int v8; // eax
  signed int v9; // ST08_4
  __int16 v10; // ax
  unsigned int v12; // [esp+4h] [ebp-Ch]
  unsigned int v13; // [esp+8h] [ebp-8h]
  unsigned int v14; // [esp+Ch] [ebp-4h]

  v1 = sub_26830(a1);
  if ( (unsigned int)v1 <= 1 )
  {
    sub_1B8C0(a1);
    sub_265A0(a1);
    LOBYTE(v1) = sub_26930(a1);
    if ( (_BYTE)v1 )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v2 = *(_WORD *)(a1 + 20);
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      *(_WORD *)(a1 + 28) += ((*(_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v2 % 0x9Du) / 79) - 1);
      *(_BYTE *)(a1 + 29) &= 7u;
      LOWORD(v1) = *(_WORD *)(a1 + 28);
      *(_WORD *)(a1 + 32) = v1;
    }
    if ( !(*(_BYTE *)(a1 + 62) & 0x3F) && *(_BYTE *)(a1 + 57) )
    {
      v3 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
      v1 = v3 * v3;
      v4 = 0;
      v13 = -1;
      v5 = *(_DWORD *)(dword_D41A4 + 38519);
      v12 = v1;
      while ( v5 > dword_EA3E4[0] )
      {
        v6 = (signed __int16)(*(_WORD *)(v5 + 76) - *(_WORD *)(a1 + 76));
        v7 = v6 * v6;
        v8 = (signed __int16)(*(_WORD *)(v5 + 78) - *(_WORD *)(a1 + 78));
        v1 = v8 * v8;
        v14 = v1 + v7;
        if ( v1 + v7 <= v12 && !(*(_BYTE *)(v5 + 12) & 0x20) )
        {
          v9 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 30);
          v10 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v5 + 76));
          v1 = (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v10);
          if ( v1 < v9 )
          {
            LOBYTE(v1) = v14;
            if ( v14 < v13 )
            {
              v4 = v5;
              v13 = v14;
            }
          }
        }
        v5 = *(_DWORD *)v5;
      }
      if ( v4 )
      {
        *(_WORD *)(a1 + 150) = (signed int)(v4 - (dword_D41A0 + 28302)) / 168;
        LOBYTE(v1) = sub_268F0(a1, 2u);
      }
    }
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00026220) --------------------------------------------------------
unsigned int __usercall sub_26220@<eax>(unsigned int a1@<esi>, int a2)
{
  unsigned int result; // eax
  unsigned __int16 v3; // dx
  unsigned int v4; // eax
  unsigned int i; // ecx
  unsigned int v6; // edi
  char v7; // [esp+8h] [ebp-8h]
  char v8; // [esp+Ch] [ebp-4h]

  v7 = 1;
  v8 = 0;
  result = sub_26830(a2);
  if ( result <= 1 )
  {
    v3 = *(_WORD *)(a2 + 150);
    if ( v3 )
    {
      v4 = sub_1ED30(a2, dword_EA3E4[v3]);
      a1 = v4;
      if ( v4 <= dword_EA3E4[0] || *(_DWORD *)(v4 + 8) < 0 || *(_BYTE *)(v4 + 13) & 4 )
        v7 = 0;
    }
    else
    {
      v7 = 0;
    }
    if ( !v7 )
      goto LABEL_26;
    if ( sub_26930(a2) )
    {
      *(_WORD *)(a2 + 32) = sub_581E0((_WORD *)(a2 + 76), (_WORD *)(a1 + 76));
      if ( !(*(_BYTE *)(a2 + 62) & 3) )
      {
        for ( i = *(_DWORD *)(4 * *(char *)(a2 + 64) + dword_D41A4 + 38403); i > dword_EA3E4[0]; i = *(_DWORD *)i )
        {
          if ( *(_WORD *)(i + 26) != *(_WORD *)(a2 + 26)
            && abs(*(signed __int16 *)(a2 + 76) - *(signed __int16 *)(i + 76)) < (signed int)*(signed __int16 *)(a2 + 84)
            && abs(*(signed __int16 *)(a2 + 78) - *(signed __int16 *)(i + 78)) < (signed int)*(signed __int16 *)(a2 + 84) )
          {
            *(_WORD *)(a2 + 32) = sub_581E0((_WORD *)(i + 76), (_WORD *)(a2 + 76));
            break;
          }
        }
      }
    }
    if ( *(_BYTE *)(a2 + 62) & 0x1F )
      goto LABEL_22;
    v6 = *(signed __int16 *)(*(_DWORD *)(a2 + 160) + 28);
    if ( sub_583F0((_WORD *)(a2 + 76), (_WORD *)(a1 + 76)) < v6 )
      sub_1CC20((_WORD *)a2, a1);
    else
LABEL_26:
      v8 = 1;
LABEL_22:
    sub_1B8C0(a2);
    result = sub_265A0(a2);
    if ( v8 )
      result = sub_268F0(a2, 1u);
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000263C0) --------------------------------------------------------
int __cdecl sub_263C0(int a1)
{
  return sub_268F0(a1, 1u);
}

//----- (000263E0) --------------------------------------------------------
int __cdecl sub_263E0(int a1)
{
  return sub_1C890(a1, 168);
}

//----- (00026400) --------------------------------------------------------
void __cdecl sub_26400(int a1)
{
  sub_1C930(a1);
}

//----- (00026470) --------------------------------------------------------
int __cdecl sub_26470(_BYTE *a1)
{
  int result; // eax

  sub_1D5D0((int)a1, 168);
  result = (unsigned __int8)(a1[73] - 1);
  switch ( a1[73] )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 0xA:
      result = sub_265A0((int)a1);
      break;
    case 0xD:
    case 0xE:
    case 0x10:
      a1[67] = 0;
      result = sub_265A0((int)a1);
      break;
    default:
      break;
  }
  BYTE1(result) = a1[69];
  if ( BYTE1(result) != -81 )
    result = sub_268F0((int)a1, BYTE1(result) + 88);
  return result;
}

//----- (00026500) --------------------------------------------------------
int __usercall sub_26500@<eax>(int result@<eax>, int a2)
{
  switch ( *(_BYTE *)(a2 + 70) )
  {
    case 0:
      result = 311;
      break;
    case 1:
    case 2:
    case 3:
    case 9:
      result = 308;
      break;
    case 4:
      result = 309;
      break;
    case 5:
      result = 310;
      break;
    case 6:
      result = 305;
      break;
    case 7:
      result = 306;
      break;
    case 8:
      result = 307;
      break;
    case 0xA:
      result = 312;
      break;
    default:
      break;
  }
  if ( *(signed __int16 *)(a2 + 90) != result )
    result = sub_49CD0((_WORD *)a2, result);
  return result;
}

//----- (000265A0) --------------------------------------------------------
int __cdecl sub_265A0(int a1)
{
  char v1; // dh
  __int16 v2; // dx
  int v3; // esi
  unsigned int v4; // esi
  unsigned int v5; // edx
  signed int v6; // esi
  __int16 v7; // cx
  int v8; // edi
  int v9; // eax
  int v10; // eax
  int result; // eax
  char v12; // [esp+0h] [ebp-8h]
  char v13; // [esp+4h] [ebp-4h]

  v12 = 0;
  v13 = 1;
  switch ( *(_BYTE *)(a1 + 70) )
  {
    case 0:
    case 1:
      v1 = *(_BYTE *)(a1 + 68);
      if ( v1 )
        *(_BYTE *)(a1 + 68) = v1 - 1;
      else
        *(_BYTE *)(a1 + 70) = 2;
      v12 = 1;
      v13 = 0;
      break;
    case 2:
      v12 = 1;
      *(_BYTE *)(a1 + 70) = 3;
      v13 = 0;
      break;
    case 3:
      *(_BYTE *)(a1 + 70) = 4;
      break;
    case 4:
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v2 = *(_WORD *)(a1 + 20) % 0x64u;
      *(_BYTE *)(a1 + 70) = 5;
      *(_WORD *)(a1 + 44) = v2 + 140;
      break;
    case 5:
      if ( *(_WORD *)(a1 + 44) < 0 )
        *(_BYTE *)(a1 + 70) = 6;
      break;
    case 6:
      v3 = *(signed __int16 *)(a1 + 80);
      if ( v3 - (signed __int16)sub_10C40((__int16 *)(a1 + 76)) < 230 )
        *(_BYTE *)(a1 + 70) = 7;
      break;
    case 7:
      *(_BYTE *)(a1 + 70) = 8;
      v13 = 0;
      break;
    case 8:
      v12 = 1;
      *(_BYTE *)(a1 + 70) = 9;
      v13 = 0;
      break;
    case 9:
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      if ( !(*(unsigned __int16 *)(a1 + 20) % 0xBu) )
        sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 42);
      if ( *(_BYTE *)(a1 + 67) )
      {
        v4 = *(char *)(a1 + 67);
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v5 = *(unsigned __int16 *)(a1 + 20) % v4;
        *(_BYTE *)(a1 + 68) = v5;
        *(_BYTE *)(a1 + 70) = (v5 & 1) == 0;
      }
      else
      {
        *(_BYTE *)(a1 + 68) = 1;
        *(_BYTE *)(a1 + 70) = 0;
      }
      v12 = 1;
      v13 = 0;
      break;
    case 0xA:
      v12 = 1;
      break;
    default:
      break;
  }
  v6 = (signed __int16)sub_10C40((__int16 *)(a1 + 76));
  if ( v12 )
  {
    *(_WORD *)(a1 + 80) -= 42;
  }
  else
  {
    v7 = *(_WORD *)(a1 + 44) - 42;
    *(_WORD *)(a1 + 80) += *(_WORD *)(a1 + 44);
    *(_WORD *)(a1 + 44) = v7;
  }
  if ( *(signed __int16 *)(a1 + 80) < v6 )
    *(_WORD *)(a1 + 80) = v6;
  if ( byte_D41B6 )
  {
    v8 = *(signed __int16 *)(a1 + 88);
    v9 = (signed __int16)sub_10C60((__int16 *)(a1 + 76)) - v8;
    if ( *(signed __int16 *)(a1 + 80) > v9 )
    {
      *(_WORD *)(a1 + 44) = 0;
      *(_WORD *)(a1 + 80) = v9;
    }
  }
  if ( sub_104D0((signed __int16 *)(a1 + 76)) == (int (*)())1 )
  {
    if ( *(_BYTE *)(a1 + 70) == 10 )
    {
      if ( *(signed __int16 *)(a1 + 80) > v6 )
        *(_BYTE *)(a1 + 70) = 0;
    }
    else if ( *(signed __int16 *)(a1 + 80) == v6 )
    {
      *(_BYTE *)(a1 + 70) = 10;
      sub_4A190((int)&word_EB398, 10, 5);
    }
    if ( *(_BYTE *)(a1 + 69) == -86 )
      v10 = 66;
    else
      v10 = 40;
  }
  else
  {
    if ( *(_BYTE *)(a1 + 70) == 10 )
      *(_BYTE *)(a1 + 70) = 0;
    if ( *(_BYTE *)(a1 + 69) == -86 )
      v10 = 96;
    else
      v10 = 60;
  }
  *(_WORD *)(a1 + 130) = v10;
  result = sub_26500(v10, a1);
  if ( !v13 )
    *(_BYTE *)(a1 + 13) |= 8u;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// EB398: using guessed type __int16 word_EB398;

//----- (00026830) --------------------------------------------------------
signed int __cdecl sub_26830(int a1)
{
  __int16 v1; // dx
  unsigned int v2; // ebx
  int i; // edx
  int v4; // ecx
  int v5; // edx

  v1 = *(_WORD *)(a1 + 98);
  v2 = 0;
  if ( v1 )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v1 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v2 = 1;
  }
  *(_WORD *)(a1 + 38) = v1;
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        v2 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v2 >= 1 )
  {
    if ( v2 <= 1 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      sub_268F0(a1, 2u);
    }
    else if ( v2 == 2 )
    {
      *(_BYTE *)(a1 + 69) = -84;
      return 2;
    }
  }
  return v2;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000268F0) --------------------------------------------------------
int __cdecl sub_268F0(int a1, unsigned __int8 a2)
{
  int result; // eax

  result = a1;
  if ( a2 >= 1u )
  {
    if ( a2 <= 1u )
    {
      *(_BYTE *)(a1 + 67) = 64;
      *(_WORD *)(a1 + 150) = 0;
    }
    else if ( a2 == 2 )
    {
      *(_BYTE *)(a1 + 67) = 0;
    }
  }
  *(_BYTE *)(a1 + 69) = a2 - 88;
  return result;
}

//----- (00026930) --------------------------------------------------------
char __cdecl sub_26930(int a1)
{
  char result; // al
  unsigned __int8 v2; // ah

  result = 0;
  v2 = *(_BYTE *)(a1 + 70);
  if ( v2 >= 9u && (v2 <= 9u || v2 == 10 && !(*(_BYTE *)(a1 + 62) & 7)) )
    result = 1;
  return result;
}

//----- (00026960) --------------------------------------------------------
void __cdecl sub_26960(int a1)
{
  sub_26FF0(a1);
  sub_272C0(a1);
  sub_26F10(a1);
  sub_27880(a1);
}

//----- (00026990) --------------------------------------------------------
int __cdecl sub_26990(int a1)
{
  __int16 v1; // si
  signed __int16 v2; // di
  int result; // eax
  int v4; // edx
  __int16 v5; // ax
  int v6; // [esp+0h] [ebp-1Ch]
  __int16 v7; // [esp+4h] [ebp-18h]
  int v8; // [esp+8h] [ebp-14h]
  __int16 v9; // [esp+10h] [ebp-Ch]
  char v10; // [esp+18h] [ebp-4h]

  v10 = 1;
  sub_26FF0(a1);
  sub_272C0(a1);
  v8 = *(_DWORD *)(a1 + 16) >> 8;
  v1 = *(_WORD *)(a1 + 16) & 0xFF;
  v2 = 0;
  result = sub_369F0(a1, *(_WORD *)(a1 + 148));
  v9 = result;
  while ( v2 < (signed __int16)((v1 != 0) + 1) )
  {
    if ( v2 )
      v4 = -v1;
    else
      LOWORD(v4) = v1;
    v7 = v4 + v8;
    result = abs((signed __int16)(v4 + v8));
    if ( result <= *(char *)(a1 + 70) / 2 )
    {
      result = sub_27470(a1, v7);
      v6 = result;
      if ( result )
      {
        v5 = sub_278F0(v9, *(char *)(a1 + 70), v7);
        result = sub_49D50(v6, v5);
        v10 = 0;
      }
    }
    ++v2;
  }
  if ( v10 )
  {
    if ( *(_WORD *)(a1 + 148) )
      *(_BYTE *)(a1 + 69) = -78;
    else
      *(_BYTE *)(a1 + 69) = -80;
  }
  else
  {
    result = (signed __int16)(v1 + 1);
    *(_DWORD *)(a1 + 16) = result | ((signed __int16)v8 << 8);
  }
  return result;
}

//----- (00026AA0) --------------------------------------------------------
void __cdecl sub_26AA0(int a1)
{
  unsigned __int16 v1; // dx
  int v2; // eax
  unsigned __int16 v3; // si
  int v4; // esi
  __int16 v5; // ax
  char v6; // ch
  char v7; // [esp+4h] [ebp-4h]

  v7 = 0;
  sub_26FF0(a1);
  sub_272C0(a1);
  sub_26F10(a1);
  sub_27880(a1);
  if ( !(*(_BYTE *)(a1 + 62) & 0x1F) )
  {
    v1 = *(_WORD *)(a1 + 148);
    if ( !v1 )
      goto LABEL_17;
    if ( *(_WORD *)(a1 + 130) > *(_WORD *)(a1 + 134) )
      goto LABEL_13;
    v2 = dword_EA3E4[v1];
    if ( *(_BYTE *)(v2 + 63) != 3 )
      goto LABEL_17;
    if ( *(_DWORD *)(v2 + 8) < 0 )
      goto LABEL_17;
    if ( *(_BYTE *)(v2 + 13) & 4 )
      goto LABEL_17;
    v3 = *(_WORD *)(*(_DWORD *)(v2 + 164) + 58);
    if ( !v3 )
      goto LABEL_17;
    v4 = dword_EA3E4[v3];
    v5 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v4 + 76));
    v6 = *(_BYTE *)(a1 + 62);
    *(_WORD *)(a1 + 32) = v5;
    if ( v6 & 3 || sub_58490((_WORD *)(a1 + 76), (_WORD *)(v4 + 76)) > 0x100 )
      goto LABEL_13;
    if ( *(_DWORD *)(a1 + 144) + *(_DWORD *)(v4 + 144) < *(_DWORD *)(v4 + 140) )
    {
      *(_DWORD *)(a1 + 16) = 128;
      *(_BYTE *)(a1 + 69) = -77;
    }
    else
    {
LABEL_17:
      v7 = 1;
    }
LABEL_13:
    if ( v7 )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_WORD *)(a1 + 148) = 0;
      *(_BYTE *)(a1 + 69) = -79;
    }
  }
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00026BD0) --------------------------------------------------------
void __cdecl sub_26BD0(int a1)
{
  int v1; // edx
  char v2; // dl
  int v3; // eax
  unsigned __int16 v4; // dx
  int v5; // eax
  int v6; // edi
  int v7; // edx

  sub_272C0(a1);
  v1 = *(_DWORD *)(a1 + 16);
  if ( v1 )
  {
    *(_DWORD *)(a1 + 16) = v1 - 1;
  }
  else if ( !(*(_BYTE *)(a1 + 62) & 1) )
  {
    v2 = *(_BYTE *)(a1 + 70);
    if ( v2 > 1 )
    {
      sub_27720(a1, v2 - 2);
    }
    else
    {
      v3 = dword_EA3E4[*(unsigned __int16 *)(a1 + 148)];
      if ( *(_BYTE *)(v3 + 63) == 3 && *(_DWORD *)(v3 + 8) >= 0 && !(*(_BYTE *)(v3 + 13) & 4) )
      {
        v4 = *(_WORD *)(*(_DWORD *)(v3 + 164) + 58);
        if ( v4 )
        {
          v5 = dword_EA3E4[v4];
          v6 = *(_DWORD *)(v5 + 140);
          v7 = *(_DWORD *)(a1 + 144) + *(_DWORD *)(v5 + 144);
          if ( v7 >= v6 )
            *(_DWORD *)(v5 + 144) = v6;
          else
            *(_DWORD *)(v5 + 144) = v7;
        }
      }
      sub_57F10(a1);
    }
  }
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00026CA0) --------------------------------------------------------
int __cdecl sub_26CA0(int a1)
{
  sub_271D0(a1);
  return sub_26D20(a1);
}

//----- (00026CC0) --------------------------------------------------------
int __cdecl sub_26CC0(int a1)
{
  int i; // ebx
  int v2; // ebx

  for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v2 + 52) )
  {
    v2 = dword_EA3E4[i];
    if ( v2 == dword_EA3E4[0] )
      break;
    sub_36BA0(v2, 0);
    sub_57F10(v2);
  }
  sub_36BA0(a1, 0);
  return sub_57F10(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00026D20) --------------------------------------------------------
int __cdecl sub_26D20(int a1)
{
  int v1; // ebx
  unsigned __int8 v2; // al
  __int16 v3; // ax
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  __int16 v8; // cx
  __int16 v9; // ax
  __int16 v10; // ax
  int i; // eax
  int v12; // eax

  if ( *(_BYTE *)(a1 + 57) )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    v2 = *(_BYTE *)(v1 + 69);
    if ( v2 >= 0xB0u && (v2 <= 0xB0u || v2 == -78) )
    {
      if ( *(_WORD *)(a1 + 98) )
      {
        *(_WORD *)(v1 + 130) = ((*(signed __int16 *)(v1 + 132) - *(signed __int16 *)(v1 + 134)) >> 2)
                             + *(_WORD *)(v1 + 134);
        v3 = sub_581E0((_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 98)] + 76), (_WORD *)(a1 + 76));
        *(_WORD *)(v1 + 28) = v3;
        *(_WORD *)(v1 + 32) = v3;
        v4 = 56 * abs(*(char *)(a1 + 70)) / (*(char *)(v1 + 70) >> 1);
        if ( ((*(_WORD *)(v1 + 28) - *(_WORD *)(a1 + 44)) & 0x7FF) >= 1024 )
          v4 = -v4;
        v5 = v4 + *(signed __int16 *)(v1 + 44);
        if ( abs(v5) < 11 )
        {
          if ( v5 <= 0 )
            v5 = -11;
          else
            v5 = 11;
        }
        if ( abs(v5) > 227 )
        {
          if ( v5 <= 0 )
            LOWORD(v5) = -227;
          else
            LOWORD(v5) = 227;
        }
        v6 = *(unsigned __int16 *)(v1 + 52);
        *(_WORD *)(v1 + 44) = v5;
        while ( 1 )
        {
          v7 = dword_EA3E4[v6];
          if ( v7 == dword_EA3E4[0] )
            break;
          *(_WORD *)(v7 + 98) = 0;
          v6 = *(unsigned __int16 *)(v7 + 52);
        }
      }
      v8 = *(_WORD *)(a1 + 104);
      if ( v8 )
      {
        if ( v8 != *(_WORD *)(v1 + 148) )
        {
          if ( *(_DWORD *)(a1 + 100) )
          {
            *(_BYTE *)(v1 + 69) = -79;
            *(_DWORD *)(v1 + 16) = *(char *)(a1 + 70) << 8;
            v10 = *(_WORD *)(a1 + 104);
            *(_WORD *)(v1 + 148) = v10;
            sub_6E450(v10, -1, 4);
            *(_BYTE *)(a1 + 14) |= 0x20u;
          }
          else if ( !(*(_BYTE *)(a1 + 14) & 0x20) )
          {
            *(_BYTE *)(v1 + 69) = -79;
            *(_DWORD *)(v1 + 16) = *(char *)(a1 + 70) << 8;
            v9 = *(_WORD *)(a1 + 104);
            *(_WORD *)(v1 + 148) = v9;
            sub_6E450(v9, -1, 4);
          }
        }
        for ( i = *(unsigned __int16 *)(v1 + 52); ; i = *(unsigned __int16 *)(v12 + 52) )
        {
          v12 = dword_EA3E4[i];
          if ( v12 == dword_EA3E4[0] )
            break;
          *(_WORD *)(v12 + 104) = 0;
        }
      }
    }
  }
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00026F10) --------------------------------------------------------
int __cdecl sub_26F10(int a1)
{
  int v1; // eax
  signed __int16 v2; // cx
  __int16 v3; // si
  __int16 v4; // ax
  __int16 v5; // di
  __int16 v6; // ax

  if ( *(_BYTE *)(a1 + 57) )
  {
    if ( *(_WORD *)(a1 + 98) )
    {
      v1 = (*(_DWORD *)(a1 + 94) >> 2) + *(signed __int16 *)(a1 + 130);
      v2 = *(_WORD *)(a1 + 134);
      *(_WORD *)(a1 + 130) = v1;
      if ( (signed __int16)v1 < v2 )
        *(_WORD *)(a1 + 130) = v2;
      v3 = *(_WORD *)(a1 + 132);
      if ( *(_WORD *)(a1 + 130) > v3 )
        *(_WORD *)(a1 + 130) = v3;
      v4 = sub_581E0((_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 98)] + 76), (_WORD *)(a1 + 76));
      *(_WORD *)(a1 + 98) = 0;
      *(_WORD *)(a1 + 28) = v4;
      *(_WORD *)(a1 + 32) = v4;
    }
    v5 = *(_WORD *)(a1 + 104);
    if ( v5 )
    {
      if ( v5 != *(_WORD *)(a1 + 148) )
      {
        v6 = *(_WORD *)(a1 + 104);
        *(_WORD *)(a1 + 148) = v6;
        *(_BYTE *)(a1 + 69) = -79;
        *(_DWORD *)(a1 + 16) = 0;
        sub_6E450(v6, -1, 4);
      }
      *(_WORD *)(a1 + 104) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
    *(_BYTE *)(a1 + 69) = -75;
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00026FF0) --------------------------------------------------------
__int16 __cdecl sub_26FF0(int a1)
{
  __int16 v1; // ax
  __int16 v2; // si
  __int16 v3; // di
  int v4; // eax
  int v5; // eax
  int v6; // esi
  __int16 v7; // si
  int v9; // [esp+0h] [ebp-10h]
  __int16 v10; // [esp+4h] [ebp-Ch]
  _WORD *v11; // [esp+8h] [ebp-8h]
  int v12; // [esp+Ch] [ebp-4h]

  v1 = *(_WORD *)(a1 + 130);
  if ( v1 > *(_WORD *)(a1 + 134) )
    *(_WORD *)(a1 + 130) = v1 - 2;
  v2 = *(_WORD *)(a1 + 88);
  v3 = *(_WORD *)(a1 + 84);
  sub_49EA0((_WORD *)a1, *(char *)(a1 + 70) << 8, *(_WORD *)(a1 + 88));
  sub_1B8C0(a1);
  if ( !(*(_BYTE *)(a1 + 62) & 0xF) )
    sub_27120(a1);
  v11 = (_WORD *)a1;
  v12 = 0;
  sub_49EA0((_WORD *)a1, v3, v2);
  while ( v11 != (_WORD *)dword_EA3E4[0] )
  {
    v4 = sub_10C40(v11 + 38);
    if ( (signed __int16)v4 > (signed __int16)v12 )
    {
      v12 = v4;
      v9 = *((_DWORD *)v11 + 19);
      v10 = v11[40];
    }
    v11 = (_WORD *)dword_EA3E4[(unsigned __int16)v11[26]];
  }
  v12 += 384;
  LOWORD(v5) = *(_WORD *)(a1 + 80);
  if ( (signed __int16)v5 >= (signed __int16)v12 )
  {
    v7 = *(_WORD *)(a1 + 36);
    if ( v7 )
    {
      LOWORD(v5) = v7 - 1;
      *(_WORD *)(a1 + 36) = v7 - 1;
    }
    else
    {
      *(_WORD *)(a1 + 80) = v5 - 2;
    }
  }
  else
  {
    v6 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 16);
    v5 = sub_1B7A0((signed __int16 *)&v9);
    if ( v5 > v6 )
      ++*(_BYTE *)(a1 + 81);
    else
      *(_WORD *)(a1 + 80) += 64;
    *(_WORD *)(a1 + 36) = 64;
  }
  return v5;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00027120) --------------------------------------------------------
int __cdecl sub_27120(int a1)
{
  int v1; // edi
  int v2; // esi
  unsigned int v3; // ecx
  __int16 v5; // ax

  v1 = 2 * *(signed __int16 *)(a1 + 88) + 32;
  v2 = 2 * *(signed __int16 *)(a1 + 84);
  v3 = *(_DWORD *)(4 * *(char *)(a1 + 64) + dword_D41A4 + 38403);
  if ( v3 <= dword_EA3E4[0] )
    return 0;
  do
  {
    if ( *(_WORD *)(v3 + 26) != *(_WORD *)(a1 + 26)
      && abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(v3 + 76)) < v2
      && abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(v3 + 78)) < v2
      && abs(*(signed __int16 *)(a1 + 80) - *(signed __int16 *)(v3 + 80)) < v1 )
    {
      v5 = *(_WORD *)(a1 + 80);
      if ( v5 >= *(_WORD *)(v3 + 80) )
        *(_WORD *)(a1 + 80) = v5 + 64;
    }
    v3 = *(_DWORD *)v3;
  }
  while ( v3 > dword_EA3E4[0] );
  return 0;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000271D0) --------------------------------------------------------
signed int __cdecl sub_271D0(int a1)
{
  signed int result; // eax
  int v2; // eax
  __int16 v3; // si
  unsigned __int16 v4; // ax
  int v5; // ebx
  unsigned __int16 v6; // cx

  result = a1;
  if ( *(_WORD *)(a1 + 150) )
  {
    v2 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    v3 = *(_WORD *)(v2 + 42);
    v4 = (v3 + sub_273C0(*(unsigned __int8 *)(v2 + 92), *(_WORD *)(v2 + 54), *(char *)(a1 + 70), *(char *)(v2 + 70))) & 0x7FF;
    *(_WORD *)(a1 + 44) = v4;
    v5 = dword_EA3E4[*(unsigned __int16 *)(a1 + 50)];
    if ( v5 )
    {
      v6 = *(_WORD *)(v5 + 50);
      if ( v6 )
        v5 = dword_EA3E4[v6];
    }
    *(_DWORD *)&word_EB398 = *(_DWORD *)(v5 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(v5 + 80);
    sub_57FA0(&word_EB398, v4, 0, *(_WORD *)(a1 + 84) + *(_WORD *)(v5 + 84));
    word_EB39C = *(_WORD *)(v5 + 84) - *(_WORD *)(a1 + 84) + *(_WORD *)(v5 + 80);
    result = sub_57CF0(a1, (int)&word_EB398);
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (000272C0) --------------------------------------------------------
char __cdecl sub_272C0(int a1)
{
  signed __int16 v1; // ax
  unsigned __int8 v2; // dl
  unsigned __int8 v3; // ch
  char v4; // ah
  char v5; // dl
  int v6; // eax
  int v7; // edx
  signed __int16 v9; // [esp+0h] [ebp-4h]

  if ( *(_BYTE *)(a1 + 70) >= 11 )
  {
    v1 = sub_27430(*(unsigned __int8 *)(a1 + 92));
    v2 = *(_BYTE *)(a1 + 92);
    v9 = v1;
    if ( v2 && v2 < 0x10u )
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 48);
    if ( *(_BYTE *)(a1 + 54) & 1 )
    {
      v3 = v9 + *(_BYTE *)(a1 + 92);
      *(_BYTE *)(a1 + 92) = v3;
      if ( v3 > 0x64u )
      {
        v4 = *(_BYTE *)(a1 + 54);
        *(_BYTE *)(a1 + 92) = 100;
        *(_BYTE *)(a1 + 54) = v4 & 0xFE;
      }
    }
    else if ( *(unsigned __int8 *)(a1 + 92) > v9 )
    {
      *(_BYTE *)(a1 + 92) -= v9;
    }
    else
    {
      v5 = *(_BYTE *)(a1 + 54) | 1;
      *(_BYTE *)(a1 + 54) = v5;
      *(_BYTE *)(a1 + 92) = 0;
      *(_BYTE *)(a1 + 54) = v5 ^ 2;
    }
  }
  *(_WORD *)(a1 + 42) += *(_WORD *)(a1 + 44);
  LOBYTE(v6) = *(_BYTE *)(a1 + 62);
  *(_BYTE *)(a1 + 43) &= 7u;
  if ( !(v6 & 3) )
  {
    v6 = abs(*(signed __int16 *)(a1 + 44)) - 5;
    if ( (signed __int16)v6 < 11 )
      LOWORD(v6) = 11;
    if ( *(_WORD *)(a1 + 44) <= 0 )
      v7 = -(signed __int16)v6;
    else
      LOWORD(v7) = v6;
    *(_WORD *)(a1 + 44) = v7;
  }
  return v6;
}
// D41A0: using guessed type int dword_D41A0;

//----- (000273C0) --------------------------------------------------------
int __cdecl sub_273C0(__int16 a1, char a2, __int16 a3, __int16 a4)
{
  __int16 v4; // ax
  int result; // eax
  __int16 v6; // ax

  v4 = abs(a3);
  result = ((15 - a4) * v4 + v4 * a1) & 0x7FF;
  if ( a3 >= 0 )
  {
    if ( a2 & 2 )
      return result;
    v6 = 2048 - result;
  }
  else if ( a2 & 2 )
  {
    v6 = 1024 - result;
  }
  else
  {
    v6 = result + 1024;
  }
  return v6 & 0x7FF;
}

//----- (00027430) --------------------------------------------------------
int __cdecl sub_27430(int a1)
{
  int v1; // eax

  HIWORD(v1) = HIWORD(a1);
  if ( (signed __int16)a1 >= 96 )
    return 2;
  if ( (signed __int16)a1 >= 87 )
    return 3;
  if ( (signed __int16)a1 >= 60 )
    return 4;
  LOBYTE(v1) = (signed __int16)a1 < 30;
  BYTE1(v1) = 0;
  return v1 + 5;
}

//----- (00027470) --------------------------------------------------------
int __cdecl sub_27470(int a1, __int16 a2)
{
  int result; // eax

  result = a1;
  if ( a2 )
  {
    while ( 1 )
    {
      result = dword_EA3E4[*(unsigned __int16 *)(result + 52)];
      if ( result == dword_EA3E4[0] )
        break;
      if ( *(char *)(result + 70) == a2 )
        return result;
    }
    result = 0;
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000274C0) --------------------------------------------------------
int __cdecl sub_274C0(int a1, int a2, _WORD *a3, __int16 a4)
{
  int v4; // edx
  int v5; // eax

  qmemcpy((void *)a2, a3, 0xA8u);
  v4 = a2 - (dword_D41A0 + 28302);
  *(_WORD *)(a2 + 50) = (signed int)((char *)a3 - dword_D41A0 - 28302) / 168;
  a3[26] = v4 / 168;
  *(_WORD *)(a2 + 52) = 0;
  *(_BYTE *)(a2 + 62) = abs((_BYTE)a4) & 1;
  *(_BYTE *)(a2 + 12) &= 0xFBu;
  *(_BYTE *)(a2 + 70) = a4;
  v5 = (a1 - (dword_D41A0 + 28302)) / 168;
  *(_BYTE *)(a2 + 69) = -76;
  *(_WORD *)(a2 + 44) = 0;
  *(_WORD *)(a2 + 148) = 0;
  *(_DWORD *)(a2 + 144) = 0;
  *(_WORD *)(a2 + 150) = v5;
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57D70(a2, (int)&word_EB398);
  return sub_49A20(a2);
}
// D41A0: using guessed type int dword_D41A0;
// EB398: using guessed type __int16 word_EB398;

//----- (00027590) --------------------------------------------------------
int __usercall sub_27590@<eax>(signed int a1@<ebx>, int a2)
{
  __int16 v2; // ax
  __int16 v3; // di
  __int16 v4; // ax
  int result; // eax
  __int16 v6; // ax
  int v7; // ebx

  v2 = sub_369F0(a1, *(_WORD *)(a2 + 148));
  v3 = v2;
  v4 = sub_278F0(v2, *(char *)(a2 + 70), 0);
  sub_49D50(a2, v4);
  for ( result = *(unsigned __int16 *)(a2 + 52); ; result = *(unsigned __int16 *)(v7 + 52) )
  {
    v7 = dword_EA3E4[result];
    if ( v7 == dword_EA3E4[0] )
      break;
    v6 = sub_278F0(v3, *(char *)(a2 + 70), *(char *)(v7 + 70));
    sub_49D50(v7, v6);
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00027610) --------------------------------------------------------
int __usercall sub_27610@<eax>(signed int a1@<ebx>, int a2)
{
  __int16 v2; // di
  __int64 v3; // rtt
  int result; // eax
  __int64 v5; // rtt
  int v6; // ebx

  v2 = sub_369F0(a1, *(_WORD *)(a2 + 148));
  v3 = 550 * (unsigned __int16)word_D9524[7 * (signed __int16)sub_278F0(v2, *(char *)(a2 + 70), 0)];
  sub_49EA0((_WORD *)a2, v3 / 1000, v3 / 1000);
  for ( result = *(unsigned __int16 *)(a2 + 52); ; result = *(unsigned __int16 *)(v6 + 52) )
  {
    v6 = dword_EA3E4[result];
    if ( v6 == dword_EA3E4[0] )
      break;
    v5 = 550 * (unsigned __int16)word_D9524[7 * (signed __int16)sub_278F0(v2, *(char *)(a2 + 70), *(char *)(v6 + 70))];
    sub_49EA0((_WORD *)v6, v5 / 1000, v5 / 1000);
  }
  return result;
}
// D9524: using guessed type __int16 word_D9524[];
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000276E0) --------------------------------------------------------
signed int __cdecl sub_276E0(signed int a1)
{
  signed int result; // eax
  int i; // ebx
  int v3; // ebx

  result = a1;
  for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v3 + 52) )
  {
    v3 = dword_EA3E4[i];
    if ( v3 == dword_EA3E4[0] )
      break;
    result = sub_271D0(v3);
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00027720) --------------------------------------------------------
void __cdecl sub_27720(int a1, signed __int16 a2)
{
  signed int i; // ebx
  signed __int16 v3; // di
  _WORD *v4; // edi
  __int16 v5; // ST0C_2
  int v6; // ebx
  int v7; // eax
  int v8; // ST10_4
  int v9; // [esp+4h] [ebp-Ch]
  int v10; // [esp+8h] [ebp-8h]
  char v11; // [esp+Ch] [ebp-4h]

  LOBYTE(a2) = a2 | 1;
  v11 = 0;
  if ( a2 >= 1 && a2 <= 15 && *(char *)(a1 + 70) != a2 )
  {
    for ( i = a1; ; i = dword_EA3E4[*(unsigned __int16 *)(i + 52)] )
    {
      v3 = *(_WORD *)(i + 52);
      if ( !v3 )
        break;
    }
    if ( *(char *)(a1 + 70) >= a2 )
    {
      v10 = (*(char *)(a1 + 70) - a2) / 2;
      while ( v3 < (signed __int16)v10 )
      {
        v6 = dword_EA3E4[*(unsigned __int16 *)(i + 50)];
        v7 = v6;
        i = dword_EA3E4[*(unsigned __int16 *)(v6 + 50)];
        *(_WORD *)(i + 52) = 0;
        v8 = dword_EA3E4[*(unsigned __int16 *)(v7 + 52)];
        sub_57F10(v7);
        ++v3;
        sub_57F10(v8);
      }
    }
    else
    {
      v4 = (_WORD *)sub_4A050();
      if ( v4 )
      {
        v9 = sub_4A050();
        if ( v9 )
        {
          sub_274C0(a1, (int)v4, (_WORD *)i, abs(*(char *)(i + 70)) + 1);
          v5 = -(abs(*(char *)(i + 70)) + 1);
          i = v9;
          sub_274C0(a1, v9, v4, v5);
        }
        else
        {
          sub_57F10((int)v4);
          v11 = 1;
        }
      }
      else
      {
        v11 = 1;
      }
    }
    if ( !v11 )
    {
      *(_BYTE *)(a1 + 70) = a2;
      sub_27590(i, a1);
      sub_27610(i, a1);
    }
  }
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00027880) --------------------------------------------------------
void __cdecl sub_27880(int a1)
{
  __int16 v1; // dx
  char v2; // ah
  signed int v3; // edx

  v1 = *(_WORD *)(a1 + 150);
  if ( v1 )
  {
    *(_WORD *)(a1 + 150) = v1 - 1;
  }
  else
  {
    v2 = *(_BYTE *)(a1 + 70);
    *(_WORD *)(a1 + 150) = 1024;
    if ( v2 <= 13 )
      sub_27720(a1, v2 + 2);
    v3 = *(_DWORD *)(a1 + 144);
    if ( v3 < 50000 )
      *(_DWORD *)(a1 + 144) = v3 + 1000;
  }
}

//----- (000278F0) --------------------------------------------------------
int __cdecl sub_278F0(int a1, __int16 a2, __int16 a3)
{
  int v3; // eax

  v3 = (signed __int16)abs(a3);
  LOWORD(v3) = (unsigned __int8)byte_D400C[8 * (signed __int16)(a2 >> 1) + (signed __int16)v3];
  return a1 + v3;
}

//----- (00027930) --------------------------------------------------------
void __cdecl sub_27930(int a1)
{
  sub_1D5D0(a1, 176);
}

//----- (00027950) --------------------------------------------------------
char __cdecl sub_27950(int a1)
{
  unsigned int i; // ecx
  int v2; // ecx
  signed __int16 v3; // cx
  unsigned __int8 v4; // cl
  int v5; // eax
  unsigned int v6; // eax
  int v7; // eax
  __int16 v8; // ax
  _WORD *v9; // edi
  char v11; // [esp-Ch] [ebp-10h]
  char v12; // [esp-8h] [ebp-Ch]
  int v13; // [esp-4h] [ebp-8h]

  sub_1B8C0(a1);
  for ( i = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26)
      && abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(i + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
      && abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(i + 78)) < (signed int)*(signed __int16 *)(a1 + 84) )
    {
      *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(i + 76), (_WORD *)(a1 + 76));
      break;
    }
  }
  v2 = *(signed __int16 *)(a1 + 80) - *(signed __int16 *)(a1 + 44);
  if ( abs(v2) >= 256 )
  {
    if ( v2 <= 0 )
      v3 = 32;
    else
      v3 = -32;
    *(_WORD *)(a1 + 80) += v3;
  }
  v4 = *(_BYTE *)(a1 + 70);
  if ( v4 < 1u )
  {
    if ( v4 )
      return sub_28110(a1);
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 134);
    v5 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v5 - 1;
    if ( v5 )
      return sub_28110(a1);
LABEL_27:
    v13 = v5;
    v12 = 1;
    v11 = -72;
    goto LABEL_28;
  }
  if ( v4 <= 1u )
  {
    v6 = sub_28000(a1);
    if ( v6 )
    {
      v7 = v6 - (dword_D41A0 + 28302);
      *(_WORD *)(a1 + 44) = 0x2000;
      *(_WORD *)(a1 + 150) = v7 / 168;
      sub_27FE0(a1, 184, 2, 0);
    }
    else
    {
      v8 = sub_10C40((__int16 *)(a1 + 76));
      HIBYTE(v8) += 7;
      *(_WORD *)(a1 + 44) = v8;
      sub_27FE0(a1, 184, 0, 80);
    }
    return sub_28110(a1);
  }
  if ( v4 != 2 )
    return sub_28110(a1);
  v5 = sub_28420(a1);
  if ( !v5 )
    goto LABEL_27;
  if ( !(*(_BYTE *)(a1 + 62) & 3) )
  {
    v9 = (_WORD *)(v5 + 76);
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v5 + 76));
    if ( (signed int)sub_58490((_WORD *)(a1 + 76), v9) < 768 )
    {
      v13 = 500;
      v12 = 0;
      v11 = -71;
LABEL_28:
      sub_27FE0(a1, v11, v12, v13);
      return sub_28110(a1);
    }
  }
  return sub_28110(a1);
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00027B20) --------------------------------------------------------
char __cdecl sub_27B20(int a1)
{
  char v1; // al
  int v2; // edx
  int v3; // esi
  __int16 v5; // dx
  char v6; // [esp+0h] [ebp-4h]

  v6 = 0;
  v1 = *(_BYTE *)(a1 + 70);
  if ( v1 )
  {
    if ( v1 == 1 )
    {
      v5 = *(_WORD *)(a1 + 80);
      if ( v5 >= 0x2000 )
      {
        sub_27FE0(a1, 184, 0, 80);
        return sub_28110(a1);
      }
      *(_WORD *)(a1 + 80) = v5 + 32;
    }
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 16);
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
    *(_DWORD *)(a1 + 16) = --v2;
    if ( v2 && (v3 = sub_28420(a1)) != 0 && !sub_28060(a1) )
    {
      if ( sub_28390((_WORD *)a1, v3) )
        sub_27FE0(a1, 187, 0, 0);
    }
    else
    {
      v6 = 1;
    }
    if ( v6 )
    {
      sub_27FE0(a1, 185, 1, 0);
      return sub_28110(a1);
    }
  }
  return sub_28110(a1);
}

//----- (00027C10) --------------------------------------------------------
char __cdecl sub_27C10(int a1)
{
  unsigned __int8 v1; // al
  int v2; // eax
  int v3; // eax
  int v4; // esi
  int v5; // edi
  int v6; // edx
  unsigned int v7; // eax
  char v9; // [esp+0h] [ebp-8h]
  char v10; // [esp+4h] [ebp-4h]

  v10 = 0;
  v9 = 0;
  sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 59);
  v1 = *(_BYTE *)(a1 + 70);
  if ( v1 < 1u )
  {
    if ( v1 )
      goto LABEL_24;
    v2 = sub_28420(a1);
    if ( !v2 || *(_BYTE *)(v2 + 12) & 0x40 )
    {
      v9 = 1;
    }
    else
    {
      *(_WORD *)(a1 + 44) = 18;
      sub_27FE0(a1, 187, 1, 64);
    }
  }
  else if ( v1 > 1u )
  {
    if ( v1 == 3 )
    {
      *(_WORD *)(a1 + 150) = 0;
      v7 = sub_28000(a1);
      if ( v7
        && (*(_WORD *)(a1 + 150) = (signed int)(v7 - (dword_D41A0 + 28302)) / 168,
            (signed int)sub_58490((_WORD *)(a1 + 76), (_WORD *)(v7 + 76)) <= 3584) )
      {
        sub_27FE0(a1, 185, 0, 500);
      }
      else
      {
        v10 = 1;
      }
    }
    goto LABEL_24;
  }
  if ( *(_WORD *)(a1 + 150) )
  {
    v3 = sub_28420(a1);
    v4 = v3;
    v5 = v3;
    if ( v3 && (v6 = *(_DWORD *)(a1 + 16) - 1, (*(_DWORD *)(a1 + 16) = v6) != 0) )
    {
      *(_BYTE *)(v3 + 12) |= 0x40u;
      *(_WORD *)(v3 + 150) = (a1 - (dword_D41A0 + 28302)) / 168;
      *(_WORD *)(a1 + 44) += 10;
      if ( sub_106C0(a1, v3) || *(_WORD *)(v4 + 80) > *(_WORD *)(a1 + 80) )
      {
        *(_DWORD *)(a1 + 144) += *(_DWORD *)(v5 + 144);
        sub_57F10(v5);
        v9 = 1;
      }
    }
    else
    {
      v9 = 1;
    }
  }
  else
  {
    v10 = 1;
  }
  if ( v9 )
    sub_27FE0(a1, 187, 3, 0);
LABEL_24:
  if ( v10 )
    sub_27FE0(a1, 185, 1, 0);
  return sub_28110(a1);
}
// D41A0: using guessed type int dword_D41A0;

//----- (00027E00) --------------------------------------------------------
char __cdecl sub_27E00(int a1)
{
  _WORD *v1; // ebx
  unsigned int v2; // eax
  unsigned int v3; // esi
  unsigned int i; // ecx
  int v5; // eax
  unsigned int v6; // edi
  char result; // al
  char v8; // [esp+4h] [ebp-8h]

  v1 = (_WORD *)a1;
  v8 = 0;
  sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 59);
  v1[65] = v1[66];
  sub_1B8C0(a1);
  v2 = sub_1ED30((int)v1, dword_EA3E4[(unsigned __int16)v1[75]]);
  v3 = v2;
  if ( v2 <= dword_EA3E4[0] || *(_DWORD *)(v2 + 8) < 0 || *(_BYTE *)(v2 + 13) & 4 )
  {
LABEL_15:
    v8 = 1;
    goto LABEL_16;
  }
  if ( !(*(_BYTE *)(a1 + 62) & 3) )
  {
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v2 + 76));
    for ( i = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26)
        && abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(i + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
        && abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(i + 78)) < (signed int)*(signed __int16 *)(a1 + 84) )
      {
        *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(i + 76), (_WORD *)(a1 + 76));
        break;
      }
    }
  }
  v5 = *(_DWORD *)(a1 + 160);
  if ( !(*(signed __int16 *)(v5 + 26) & *(unsigned __int8 *)(a1 + 62)) )
  {
    v6 = *(signed __int16 *)(v5 + 28);
    if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76)) < v6 )
    {
      sub_1D260(a1, v3);
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_16:
  result = sub_28110(a1);
  if ( v8 )
  {
    *(_WORD *)(a1 + 150) = 0;
    result = sub_27FE0(a1, 187, 3, 0);
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00027FA0) --------------------------------------------------------
int __cdecl sub_27FA0(int a1)
{
  return sub_1C890(a1, 184);
}

//----- (00027FC0) --------------------------------------------------------
void __cdecl sub_27FC0(int a1)
{
  sub_1C930(a1);
}

//----- (00027FE0) --------------------------------------------------------
int __cdecl sub_27FE0(int a1, char a2, char a3, int a4)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = a2;
  *(_BYTE *)(a1 + 70) = a3;
  *(_DWORD *)(a1 + 16) = a4;
  return result;
}

//----- (00028000) --------------------------------------------------------
unsigned int __cdecl sub_28000(int a1)
{
  unsigned int v1; // edi
  unsigned int v2; // esi
  unsigned int v3; // ebx
  unsigned int v5; // eax

  v1 = -1;
  v2 = 0;
  v3 = *(_DWORD *)(dword_D41A4 + 38523);
  if ( v3 <= dword_EA3E4[0] )
    return 0;
  do
  {
    if ( *(_BYTE *)(v3 + 64) == 39 )
    {
      v5 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76));
      if ( v5 < v1 )
      {
        v2 = v3;
        v1 = v5;
      }
    }
    v3 = *(_DWORD *)v3;
  }
  while ( v3 > dword_EA3E4[0] );
  return v2;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00028060) --------------------------------------------------------
char __cdecl sub_28060(int a1)
{
  int v1; // esi
  unsigned int i; // ecx
  __int16 v3; // ax
  char v5; // [esp+4h] [ebp-4h]

  v5 = 0;
  v1 = 2 * *(signed __int16 *)(a1 + 84);
  for ( i = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26)
      && abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(i + 76)) < v1
      && abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(i + 78)) < v1
      && abs(*(signed __int16 *)(a1 + 80) - *(signed __int16 *)(i + 80)) < 2 * *(signed __int16 *)(a1 + 88) )
    {
      v3 = *(_WORD *)(a1 + 80);
      if ( v3 >= *(_WORD *)(i + 80) )
      {
        v5 = 1;
        *(_WORD *)(a1 + 80) = v3 + 16;
        return v5;
      }
    }
  }
  return v5;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00028110) --------------------------------------------------------
char __cdecl sub_28110(int a1)
{
  signed int v1; // esi
  __int16 v2; // ax
  unsigned __int16 v3; // ax
  int v4; // eax
  int v5; // ecx
  char v6; // al
  unsigned int v7; // eax
  unsigned int v8; // edi
  unsigned int v9; // esi
  int v10; // eax
  char v11; // dh

  v1 = 0;
  if ( *(_BYTE *)(a1 + 57) )
  {
    if ( *(_WORD *)(a1 + 98) )
    {
      v2 = *(_WORD *)(a1 + 98);
      *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
      *(_WORD *)(a1 + 38) = v2;
      v3 = *(_WORD *)(a1 + 38);
      *(_WORD *)(a1 + 98) = 0;
      if ( *(_BYTE *)(dword_EA3E4[v3] + 63) == 3 )
      {
        v1 = 1;
        v4 = sub_28420(a1);
        v5 = v4;
        if ( v4 && *(_BYTE *)(v4 + 12) & 0x40 && *(unsigned __int16 *)(v4 + 150) == (a1 - (dword_D41A0 + 28302)) / 168 )
        {
          v6 = *(_BYTE *)(v4 + 12);
          *(_WORD *)(v5 + 150) = 0;
          *(_BYTE *)(v5 + 12) = v6 & 0xBF;
        }
        *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
        sub_27FE0(a1, 186, 0, 0);
      }
    }
    else
    {
      *(_WORD *)(a1 + 38) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    sub_27FE0(a1, 188, 0, 0);
  }
  if ( !v1 && !(*(_BYTE *)(a1 + 62) & 0x1F) )
  {
    v7 = sub_282D0(a1);
    v8 = v7;
    if ( v7 )
    {
      v9 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
      if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v7 + 76)) < v9 )
      {
        v10 = sub_28420(a1);
        if ( v10
          && *(_BYTE *)(v10 + 12) & 0x40
          && *(unsigned __int16 *)(v10 + 150) == (a1 - (dword_D41A0 + 28302)) / 168 )
        {
          v11 = *(_BYTE *)(v10 + 12);
          *(_WORD *)(v10 + 150) = 0;
          *(_BYTE *)(v10 + 12) = v11 & 0xBF;
        }
        *(_WORD *)(a1 + 150) = (signed int)(v8 - (dword_D41A0 + 28302)) / 168;
        sub_27FE0(a1, 186, 0, 0);
      }
    }
  }
  return 0;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000282D0) --------------------------------------------------------
unsigned int __cdecl sub_282D0(int a1)
{
  unsigned int v1; // esi
  unsigned int v2; // edi
  unsigned int i; // ebx
  unsigned __int8 v4; // al
  int v5; // eax
  int v6; // eax
  int v7; // eax
  unsigned int v8; // eax

  v1 = -1;
  v2 = 0;
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    v4 = *(_BYTE *)(i + 64);
    if ( v4 <= 1u )
    {
      v5 = *(_DWORD *)(i + 164);
    }
    else
    {
      if ( v4 != 3 )
        continue;
      if ( *(_DWORD *)(i + 144) <= 0 )
        continue;
      v6 = dword_EA3E4[*(signed __int16 *)(i + 26)];
      if ( !v6 )
        continue;
      v5 = *(_DWORD *)(v6 + 164);
    }
    v7 = dword_EA3E4[*(unsigned __int16 *)(v5 + 58)];
    if ( v7 )
    {
      if ( !sub_10750(i, v7) )
      {
        v8 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
        if ( v8 < v1 )
        {
          v1 = v8;
          v2 = i;
        }
      }
    }
  }
  return v2;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00028390) --------------------------------------------------------
char __cdecl sub_28390(_WORD *a1, int a2)
{
  char v3; // [esp+0h] [ebp-4h]

  v3 = 1;
  if ( (signed int)sub_58490(a1 + 38, (_WORD *)(a2 + 76)) > 128 )
  {
    v3 = 0;
    a1[16] = sub_581E0(a1 + 38, (_WORD *)(a2 + 76));
    sub_1B8C0((int)a1);
  }
  if ( abs((signed __int16)a1[40] - (*(signed __int16 *)(a2 + 80) + 640)) > 64 )
  {
    v3 = 0;
    if ( (signed __int16)a1[40] - (*(signed __int16 *)(a2 + 80) + 640) <= 0 )
      a1[40] += 32;
    else
      a1[40] -= 32;
  }
  return v3;
}

//----- (00028420) --------------------------------------------------------
int __cdecl sub_28420(int a1)
{
  int result; // eax

  result = 0;
  if ( *(_WORD *)(a1 + 150) )
  {
    LOWORD(result) = *(_WORD *)(a1 + 150);
    result = dword_EA3E4[result];
    if ( result )
    {
      if ( *(_DWORD *)(result + 8) < 0
        || *(_BYTE *)(result + 13) & 4
        || *(_BYTE *)(result + 63) != 10
        || *(_BYTE *)(result + 64) != 39 )
      {
        result = 0;
      }
    }
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00028470) --------------------------------------------------------
void __cdecl sub_28470(int a1)
{
  sub_1D5D0(a1, 184);
}

//----- (00028490) --------------------------------------------------------
int __cdecl sub_28490(int a1)
{
  sub_1BD90(a1, 192);
  if ( *(_BYTE *)(a1 + 69) == -64 )
  {
    if ( !(*(_BYTE *)(a1 + 62) & 7) )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      if ( !(*(unsigned __int16 *)(a1 + 20) % 3u) )
        *(_BYTE *)(a1 + 69) = -63;
    }
    if ( *(_BYTE *)(a1 + 69) == -64 )
      sub_28690(a1);
  }
  else
  {
    *(_BYTE *)(a1 + 69) = -58;
  }
  return sub_287B0(a1);
}

//----- (00028500) --------------------------------------------------------
int __cdecl sub_28500(int a1)
{
  sub_1BF90(a1, 192);
  if ( *(_BYTE *)(a1 + 69) == -63 )
  {
    if ( !(*(_BYTE *)(a1 + 62) & 7) )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      if ( !(*(unsigned __int16 *)(a1 + 20) % 3u) )
        *(_BYTE *)(a1 + 69) = -64;
    }
    if ( *(_BYTE *)(a1 + 69) == -63 )
      sub_28690(a1);
  }
  else
  {
    *(_BYTE *)(a1 + 69) = -58;
  }
  return sub_287B0(a1);
}

//----- (00028570) --------------------------------------------------------
int __cdecl sub_28570(int a1)
{
  sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 7);
  if ( (unsigned __int16)sub_1C310(a1, 192, (unsigned __int16 (__cdecl *)(int, int))sub_1CF20) )
    *(_BYTE *)(a1 + 69) = -58;
  return sub_287B0(a1);
}
// D41A0: using guessed type int dword_D41A0;

//----- (000285D0) --------------------------------------------------------
signed int __cdecl sub_285D0(int a1)
{
  *(_BYTE *)(a1 + 69) = -63;
  return sub_1BD90(a1, 192);
}

//----- (000285F0) --------------------------------------------------------
int __cdecl sub_285F0(int a1)
{
  return sub_1C890(a1, 192);
}

//----- (00028610) --------------------------------------------------------
void __cdecl sub_28610(int a1)
{
  sub_1C930(a1);
}

//----- (00028630) --------------------------------------------------------
int __cdecl sub_28630(int a1)
{
  sub_1C980(a1, 192);
  sub_28690(a1);
  return sub_287B0(a1);
}

//----- (00028660) --------------------------------------------------------
int __cdecl sub_28660(int a1)
{
  sub_1D5D0(a1, 192);
  return sub_287B0(a1);
}

//----- (00028690) --------------------------------------------------------
void __cdecl sub_28690(int a1)
{
  int v1; // eax
  unsigned int v2; // esi
  int v3; // eax
  unsigned int v4; // edi
  signed int v5; // ST0C_4
  __int16 v6; // ax
  unsigned int v7; // eax
  int v8; // eax
  unsigned int v9; // [esp+0h] [ebp-10h]
  int v10; // [esp+8h] [ebp-8h]
  unsigned int v11; // [esp+Ch] [ebp-4h]

  if ( *(_BYTE *)(a1 + 57) && !(*(_BYTE *)(a1 + 62) & 0xF) )
  {
    v1 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
    v11 = -1;
    v10 = 0;
    v2 = *(_DWORD *)(dword_D41A4 + 38519);
    v9 = v1 * v1;
    while ( v2 > dword_EA3E4[0] )
    {
      v3 = (signed __int16)(*(_WORD *)(v2 + 76) - *(_WORD *)(a1 + 76));
      v4 = (signed __int16)(*(_WORD *)(v2 + 78) - *(_WORD *)(a1 + 78))
         * (signed __int16)(*(_WORD *)(v2 + 78) - *(_WORD *)(a1 + 78))
         + v3 * v3;
      if ( v4 <= v9 && !(*(_BYTE *)(v2 + 12) & 0x20) )
      {
        v5 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 30);
        v6 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v2 + 76));
        if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v6) < v5 && v4 < v11 )
        {
          v10 = v2;
          v11 = v4;
        }
      }
      v2 = *(_DWORD *)v2;
    }
    if ( v10 )
    {
      v7 = sub_1ED30(a1, v10);
      if ( v7 > dword_EA3E4[0] && *(_DWORD *)(v7 + 8) >= 0 && !(*(_BYTE *)(v7 + 13) & 4) )
      {
        v8 = v7 - (dword_D41A0 + 28302);
        *(_BYTE *)(a1 + 69) = -62;
        *(_WORD *)(a1 + 150) = v8 / 168;
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000287B0) --------------------------------------------------------
int __cdecl sub_287B0(int a1)
{
  int result; // eax
  unsigned __int8 v2; // dl
  signed int v3; // edx
  __int16 v4; // dx

  result = a1;
  v2 = *(_BYTE *)(a1 + 69);
  if ( v2 < 0xC2u )
  {
    if ( v2 == -64 )
    {
      v3 = 336;
      *(_WORD *)(a1 + 130) = 0;
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  if ( v2 <= 0xC2u )
  {
    v4 = *(_WORD *)(a1 + 132);
  }
  else
  {
    if ( v2 != -58 )
    {
LABEL_9:
      v4 = *(_WORD *)(a1 + 134);
      goto LABEL_10;
    }
    v4 = 2 * *(_WORD *)(a1 + 134);
  }
LABEL_10:
  *(_WORD *)(a1 + 130) = v4;
  v3 = 335;
LABEL_11:
  if ( v3 != *(signed __int16 *)(a1 + 90) )
  {
    *(_WORD *)(a1 + 90) = v3;
    *(_BYTE *)(a1 + 92) = 0;
    *(_BYTE *)(a1 + 93) = byte_D8A2E[(unsigned __int8)byte_D9528[14 * v3]];
  }
  return result;
}

//----- (00028860) --------------------------------------------------------
__int16 __cdecl sub_28860(int a1)
{
  char v1; // dh
  int (*v2)(); // eax
  __int16 v3; // ax
  int i; // edx
  int v5; // ecx
  int v6; // edx
  __int16 v7; // si
  int v8; // eax
  int v9; // ecx
  int v10; // ecx
  __int16 v11; // ax
  char v12; // cl
  int v13; // eax
  char v14; // dh
  __int16 v15; // ax
  unsigned int v16; // edx
  int v17; // eax
  unsigned __int16 v18; // di
  int v19; // esi
  unsigned __int16 v20; // dx
  int v21; // esi
  int v22; // ecx
  __int64 v23; // rtt
  char v24; // ch
  char v26; // [esp+0h] [ebp-4h]

  v26 = 0;
  v1 = *(_BYTE *)(a1 + 70);
  v2 = 0;
  if ( v1 != 1 && v1 != 2 )
  {
    if ( *(_WORD *)(a1 + 98) )
    {
      *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
      v3 = *(_WORD *)(a1 + 98);
      *(_WORD *)(a1 + 98) = 0;
      *(_WORD *)(a1 + 38) = v3;
      v2 = (int (*)())1;
    }
    else
    {
      *(_WORD *)(a1 + 38) = 0;
    }
    if ( *(_WORD *)(a1 + 52) )
    {
      for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
      {
        v6 = dword_EA3E4[i];
        if ( v6 == dword_EA3E4[0] )
          break;
        v5 = *(_DWORD *)(v6 + 8);
        if ( v5 < *(_DWORD *)(a1 + 8) )
        {
          *(_DWORD *)(a1 + 8) = v5;
          *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
          v2 = (int (*)())1;
          break;
        }
      }
    }
    if ( *(_DWORD *)(a1 + 8) < 0 )
    {
      *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
      v2 = (int (*)())2;
    }
  }
  v7 = *(_WORD *)(a1 + 42) - 1;
  *(_WORD *)(a1 + 42) = v7;
  if ( !v7 )
    v2 = (int (*)())2;
  if ( v2 == (int (*)())2 )
  {
    *(_BYTE *)(a1 + 69) = -52;
  }
  else
  {
    switch ( *(_BYTE *)(a1 + 70) )
    {
      case 1:
        *(_DWORD *)(a1 + 16) = 52;
        *(_BYTE *)(a1 + 70) = 2;
        goto LABEL_20;
      case 2:
LABEL_20:
        v8 = *(_DWORD *)(a1 + 4);
        v9 = *(_DWORD *)(a1 + 16);
        *(_WORD *)(a1 + 98) = 0;
        v10 = v9 - 1;
        *(_DWORD *)(a1 + 8) = v8;
        *(_DWORD *)(a1 + 16) = v10;
        if ( v10 < 0 )
          goto LABEL_21;
        if ( v10 > 13 )
        {
          v11 = *(_WORD *)(a1 + 32);
          HIBYTE(v11) = (HIBYTE(v11) + 1) & 7;
          *(_WORD *)(a1 + 32) = v11;
        }
        break;
      case 3:
        v12 = 0;
        if ( !*(_WORD *)(a1 + 36)
          || (v13 = dword_EA3E4[*(unsigned __int16 *)(a1 + 36)], *(_BYTE *)(v13 + 63) != 3)
          || (v14 = *(_BYTE *)(v13 + 64)) != 0 && v14 != 1 )
        {
          v12 = 1;
        }
        else if ( *(_WORD *)(*(_DWORD *)(v13 + 164) + 58) )
        {
          v15 = *(_WORD *)(a1 + 36);
          *(_BYTE *)(a1 + 70) = 5;
          *(_WORD *)(a1 + 150) = v15;
        }
        else
        {
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          v16 = *(unsigned __int16 *)(a1 + 20) % 0x64u;
          *(_BYTE *)(a1 + 70) = 4;
          *(_DWORD *)(a1 + 16) = v16 + 100;
        }
        if ( v12 )
        {
          *(_BYTE *)(a1 + 70) = 8;
          *(_DWORD *)(a1 + 16) = 100;
        }
        break;
      case 4:
        v17 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v17;
        if ( v17 < 0 )
          goto LABEL_35;
        break;
      case 5:
        v18 = *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 164) + 58);
        if ( v18 )
        {
          if ( !(*(_BYTE *)(a1 + 62) & 7) )
          {
            v19 = dword_EA3E4[v18];
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v19 + 76));
            if ( sub_10750(a1, v19) )
              *(_BYTE *)(a1 + 70) = 6;
          }
        }
        else
        {
LABEL_35:
          *(_BYTE *)(a1 + 70) = 3;
        }
        break;
      case 6:
        *(_BYTE *)(a1 + 70) = 7;
        v26 = 1;
        goto LABEL_41;
      case 7:
LABEL_41:
        v20 = *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 164) + 58);
        if ( v20 )
        {
          v21 = dword_EA3E4[v20];
          if ( sub_10750(a1, dword_EA3E4[v20]) )
          {
            sub_11900(a1, v21, 0, 0x3Cu);
          }
          else
          {
            *(_BYTE *)(a1 + 70) = 5;
            v26 = 1;
          }
        }
        else
        {
LABEL_21:
          *(_BYTE *)(a1 + 70) = 3;
          v26 = 1;
        }
        break;
      case 8:
        v22 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v22;
        if ( v22 < 0 )
          *(_BYTE *)(a1 + 69) = -52;
        break;
      default:
        break;
    }
    if ( !(*(_BYTE *)(a1 + 62) & 7) )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v23 = *(unsigned __int16 *)(a1 + 20) % 0x9Du;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      *(_WORD *)(a1 + 32) += (2 * (unsigned __int64)(v23 / 79) - 1) * (*(_WORD *)(a1 + 20) % 0x17Du);
      *(_BYTE *)(a1 + 33) &= 7u;
    }
    sub_1B8C0(a1);
    v2 = sub_104D0((signed __int16 *)(a1 + 76));
    if ( v2 == (int (*)())1 )
    {
      if ( *(_WORD *)(a1 + 90) == 314 )
      {
        LOWORD(v2) = sub_10C40((__int16 *)(a1 + 76));
        if ( (signed __int16)v2 < *(_WORD *)(a1 + 80) )
          LOWORD(v2) = sub_49CD0((_WORD *)a1, 313);
      }
      else
      {
        LOWORD(v2) = sub_49CD0((_WORD *)a1, 314);
        *(_WORD *)(a1 + 132) = 35;
        v26 = 1;
      }
    }
    else if ( *(_WORD *)(a1 + 90) != 313 )
    {
      LOWORD(v2) = sub_49CD0((_WORD *)a1, 313);
      *(_WORD *)(a1 + 132) = 60;
      v26 = 1;
    }
    if ( v26 )
    {
      LOWORD(v2) = *(_WORD *)(a1 + 132);
      v24 = *(_BYTE *)(a1 + 70);
      *(_WORD *)(a1 + 130) = (_WORD)v2;
      if ( v24 == 2 )
        *(_WORD *)(a1 + 130) = (_WORD)v2 + 50;
    }
  }
  return (signed __int16)v2;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00028C30) --------------------------------------------------------
int __cdecl sub_28C30(int a1)
{
  int result; // eax

  sub_1BF90(a1, 200);
  if ( *(_DWORD *)(a1 + 8) < 0 )
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (00028C60) --------------------------------------------------------
signed int __cdecl sub_28C60(int a1)
{
  signed int result; // eax

  sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 37);
  result = sub_1C310(a1, 200, (unsigned __int16 (__cdecl *)(int, int))sub_1CC20);
  if ( *(_DWORD *)(a1 + 8) < 0 )
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00028CC0) --------------------------------------------------------
int __cdecl sub_28CC0(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  v2 = *(_DWORD *)(a1 + 8);
  *(_BYTE *)(a1 + 69) = -55;
  if ( v2 < 0 )
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (00028CE0) --------------------------------------------------------
int __cdecl sub_28CE0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax
  __int16 v5; // ax
  int v6; // edx
  int v7; // eax
  int result; // eax
  int v9; // [esp+0h] [ebp-10h]
  signed int i; // [esp+4h] [ebp-Ch]
  int v11; // [esp+8h] [ebp-8h]
  int v12; // [esp+Ch] [ebp-4h]

  if ( *(_BYTE *)(a1 + 70) )
    return sub_1C890(a1, 200);
  if ( sub_4A810() <= 1 )
  {
    sub_36BA0(a1, 0);
  }
  else
  {
    v12 = *(_DWORD *)(a1 + 144);
    v9 = v12 / 3;
    for ( i = 0; i < 3; ++i )
    {
      v1 = sub_4A050();
      v2 = v1;
      v11 = v1;
      if ( v1 )
      {
        *(_BYTE *)(v1 + 69) = -56;
        *(_BYTE *)(v1 + 63) = 5;
        *(_BYTE *)(v1 + 64) = 25;
        *(_DWORD *)(v1 + 76) = *(_DWORD *)(a1 + 76);
        *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 80);
        *(_BYTE *)(v1 + 70) = 3;
        *(_WORD *)(v1 + 132) = 35;
        *(_WORD *)(v1 + 134) = 60;
        *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132) + 50;
        v3 = *(_WORD *)(v1 + 20);
        *(_DWORD *)(v1 + 144) = v9;
        *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
        v4 = *(_WORD *)(v1 + 20);
        *(_DWORD *)(v2 + 4) = 80;
        *(_WORD *)(v2 + 42) = 15000;
        v5 = (v4 & 0x7FF) - 1;
        *(_WORD *)(v2 + 32) = v5;
        *(_WORD *)(v2 + 28) = v5;
        *(_BYTE *)(v2 + 56) = 1;
        v6 = *(char *)(a1 + 64) + dword_D41A0;
        LOBYTE(v5) = (*(_BYTE *)(v6 + 16))++;
        *(_BYTE *)(v2 + 62) = v5;
        *(_DWORD *)(v2 + 160) = &unk_D8874;
        *(_BYTE *)(v2 + 57) = 64;
        v12 -= v9;
        *(_BYTE *)(v2 + 65) = 3;
        sub_57D70(v2, a1 + 76);
        sub_49A20(v2);
        sub_49CD0((_WORD *)v2, 314);
        sub_49EA0((_WORD *)v2, 32, 32);
        *(_BYTE *)(v2 + 70) = 1;
        *(_WORD *)(v2 + 36) = *(_WORD *)(a1 + 38);
      }
    }
    if ( v11 )
      *(_DWORD *)(v11 + 144) += v12;
  }
  v7 = sub_4A190(a1 + 76, 10, 1);
  if ( v7 )
    *(_WORD *)(v7 + 26) = *(_WORD *)(a1 + 26);
  *(_BYTE *)(a1 + 69) = -51;
  result = dword_D41A0;
  *(_DWORD *)((char *)&loc_364D1 + result + 1) += 3;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00028EC0) --------------------------------------------------------
void __cdecl sub_28EC0(int a1)
{
  int v1; // edx
  int v2; // edx

  if ( *(_BYTE *)(a1 + 70) )
  {
    v2 = 2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0;
    if ( *(_WORD *)(a1 + 36) == *(_WORD *)(v2 + 11240) )
      ++*(_DWORD *)(v2 + 12601);
    sub_1C930(a1);
  }
  else
  {
    v1 = 2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0;
    if ( *(_WORD *)(a1 + 36) == *(_WORD *)(v1 + 11240) )
      ++*(_DWORD *)(v1 + 12601);
    *(_DWORD *)(a1 + 8) = -1;
    sub_57F10(a1);
  }
}
// D41A0: using guessed type int dword_D41A0;

//----- (00028F50) --------------------------------------------------------
void __cdecl sub_28F50(int a1)
{
  if ( *(_BYTE *)(a1 + 70) )
  {
    sub_12470(a1, 200);
    *(_BYTE *)(a1 + 70) = 3;
  }
  else
  {
    sub_1D5D0(a1, 200);
  }
}

//----- (00028F90) --------------------------------------------------------
int __cdecl sub_28F90(int a1)
{
  sub_1BD90(a1, 208);
  return sub_293B0(a1);
}

//----- (00028FC0) --------------------------------------------------------
int __cdecl sub_28FC0(int a1)
{
  sub_1BF90(a1, 208);
  return sub_293B0(a1);
}

//----- (00028FF0) --------------------------------------------------------
int __cdecl sub_28FF0(int a1)
{
  unsigned int v1; // esi
  __int16 v2; // ax
  int i; // ecx
  int v4; // eax
  int v5; // ecx
  unsigned int v6; // esi
  char v7; // dh
  unsigned int j; // ecx
  int v9; // edx
  signed int v10; // eax
  int v11; // eax
  unsigned int v12; // edx
  int v14; // edx
  int v15; // eax
  __int16 v16; // dx
  int v17; // edx
  int v18; // eax
  __int16 v19; // cx

  if ( !(*(_BYTE *)(a1 + 62) & 0x1F) )
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 62);
  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v1 = 1;
    *(_WORD *)(a1 + 38) = v2;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        v1 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v1 < 1 )
  {
    if ( v1 )
      return sub_293D0(a1);
  }
  else
  {
    if ( v1 > 1 )
    {
      if ( v1 == 2 )
        *(_BYTE *)(a1 + 69) = -44;
      return sub_293D0(a1);
    }
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
  }
  sub_1B8C0(a1);
  v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  if ( v6 > dword_EA3E4[0] && *(_BYTE *)(v6 + 63) == 3 )
  {
    v7 = *(_BYTE *)(v6 + 64);
    if ( (!v7 || v7 == 1) && *(_DWORD *)(v6 + 8) >= 0 && !(*(_BYTE *)(v6 + 13) & 4) )
    {
      if ( !(*(_BYTE *)(a1 + 62) & 3) )
      {
        *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v6 + 76));
        for ( j = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
        {
          if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26)
            && abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
            && abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78)) < (signed int)*(signed __int16 *)(a1 + 84) )
          {
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
            break;
          }
        }
      }
      v9 = *(_DWORD *)(v6 + 144) - (*(_DWORD *)(v6 + 136) + 14);
      *(_DWORD *)(v6 + 144) = v9;
      if ( v9 < 0 )
        *(_DWORD *)(v6 + 144) = 0;
      if ( *(_BYTE *)(a1 + 62) & 3 )
        return sub_293D0(a1);
      v10 = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v6 + 76));
      if ( v10 <= *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28) )
      {
        if ( v10 >= 2048 )
          return sub_293D0(a1);
        if ( *(_BYTE *)(v6 + 64) )
          return sub_293D0(a1);
        v11 = dword_D41A0;
        *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
        v12 = *(_DWORD *)(v11 + 8) % 0x3Fu;
        if ( v12 < 4 )
          return sub_293D0(a1);
        if ( v12 <= 4 )
        {
          v17 = *(_DWORD *)(v6 + 164);
          v18 = *(signed __int16 *)(v17 + 1107);
          if ( v18 == -1 )
            return sub_293D0(a1);
          v19 = *(_WORD *)(v17 + 2 * v18 + 819);
          if ( !v19 )
            return sub_293D0(a1);
          sub_69300(dword_EA3E4[v19], a1);
        }
        else
        {
          if ( v12 != 5 )
            return sub_293D0(a1);
          v14 = *(_DWORD *)(v6 + 164);
          v15 = *(signed __int16 *)(v14 + 1105);
          if ( v15 == -1 )
            return sub_293D0(a1);
          v16 = *(_WORD *)(v14 + 2 * v15 + 819);
          if ( !v16 )
            return sub_293D0(a1);
          sub_69300(dword_EA3E4[v16], a1);
        }
        return sub_293D0(a1);
      }
    }
  }
  *(_BYTE *)(a1 + 69) = -47;
  return sub_293D0(a1);
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00029300) --------------------------------------------------------
int __cdecl sub_29300(int a1)
{
  sub_1C560(a1, 0xD0u);
  return sub_293B0(a1);
}

//----- (00029330) --------------------------------------------------------
int __cdecl sub_29330(int a1)
{
  return sub_1C890(a1, 208);
}

//----- (00029350) --------------------------------------------------------
void __cdecl sub_29350(int a1)
{
  sub_1C930(a1);
}

//----- (00029380) --------------------------------------------------------
int __cdecl sub_29380(int a1)
{
  sub_1D5D0(a1, 208);
  return sub_293B0(a1);
}

//----- (000293B0) --------------------------------------------------------
int __cdecl sub_293B0(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_BYTE *)(a1 + 69) == -46 )
  {
    *(_BYTE *)(a1 + 14) &= 0x7Fu;
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
  }
  return result;
}

//----- (000293D0) --------------------------------------------------------
int __cdecl sub_293D0(int a1)
{
  int result; // eax
  char v2; // dh

  result = a1;
  if ( *(_BYTE *)(a1 + 69) != -46 )
  {
    v2 = *(_BYTE *)(a1 + 14);
    *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 14) = v2 | 0x80;
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 134);
  }
  return result;
}

//----- (00029400) --------------------------------------------------------
__int16 __cdecl sub_29400(int a1)
{
  unsigned int v1; // eax
  unsigned int i; // eax
  int v3; // ecx
  __int16 v4; // ax
  signed int v5; // esi
  unsigned int v7; // [esp+0h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 16);
  v7 = 0;
  *(_DWORD *)(a1 + 16) = v1 + 1;
  if ( v1 < 9 )
  {
    if ( v1 < 3 )
    {
      if ( !v1 )
      {
        sub_2AED0(a1, 337);
        *(_DWORD *)(a1 + 8) = &unk_F4240;
        *(_WORD *)(a1 + 150) = 0;
      }
      goto LABEL_26;
    }
    if ( v1 <= 3 )
    {
LABEL_15:
      v7 = 1;
      i = a1;
      goto LABEL_35;
    }
    if ( v1 != 6 )
    {
LABEL_26:
      if ( !v7 )
        goto LABEL_36;
      i = a1;
      goto LABEL_35;
    }
  }
  else
  {
    if ( v1 <= 9 )
    {
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v3 = (*(_WORD *)(a1 + 20) & 7) + 8;
      v4 = 9377 * *(_WORD *)(a1 + 20) + 9439;
      *(_WORD *)(a1 + 20) = v4;
      v5 = 0;
      word_EB398 += (_WORD)v3 << 8;
      word_EB39A += ((v4 & 7) + 8) << 8;
      while ( v5 < 128 )
      {
        word_EB39C = sub_10C40(&word_EB398);
        if ( !sub_102D0(a1, &word_EB398, 1) && !sub_102D0(a1, &word_EB398, 4) && sub_1B830(&word_EB398) < 32 )
          break;
        ++v5;
        sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, 768);
      }
      sub_57CF0(a1, (int)&word_EB398);
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 22);
      goto LABEL_36;
    }
    if ( v1 >= 0xF )
    {
      if ( v1 > 0xF )
      {
        if ( v1 == 18 )
        {
          *(_BYTE *)(a1 + 69) = -38;
          v7 = 3;
          sub_2AED0(a1, 337);
          *(_WORD *)(a1 + 150) = 0;
          *(_BYTE *)(a1 + 70) = 1;
        }
        goto LABEL_26;
      }
      goto LABEL_15;
    }
    if ( v1 != 12 )
      goto LABEL_26;
  }
  v7 = 2;
LABEL_35:
  for ( i = a1; i > dword_EA3E4[0]; i = dword_EA3E4[*(unsigned __int16 *)(i + 52)] )
  {
    *(_WORD *)(i + 14) &= 0xFE7Fu;
    if ( v7 >= 1 )
    {
      if ( v7 <= 1 )
      {
        *(_BYTE *)(i + 15) |= 1u;
      }
      else if ( v7 == 2 )
      {
        *(_BYTE *)(i + 14) |= 0x80u;
      }
    }
  }
LABEL_36:
  *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
  return sub_29A90(a1);
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00029670) --------------------------------------------------------
__int16 __cdecl sub_29670(int a1)
{
  signed int v1; // eax
  __int16 v2; // ax
  char v3; // al

  v1 = sub_2A6B0(a1);
  if ( v1 )
  {
    if ( v1 != 1 )
      return sub_29A90(a1);
    *(_BYTE *)(a1 + 69) = -38;
    v2 = *(_WORD *)(a1 + 38);
    *(_DWORD *)(a1 + 8) = &unk_F4240;
    *(_WORD *)(a1 + 150) = v2;
  }
  v3 = sub_2AF10(a1, 1);
  if ( (unsigned __int8)v3 >= 3u )
  {
    if ( (unsigned __int8)v3 <= 3u )
      return sub_29A90(a1);
    if ( v3 == 4 )
    {
      *(_BYTE *)(a1 + 69) = -40;
      *(_DWORD *)(a1 + 16) = 0;
      return sub_29A90(a1);
    }
  }
  if ( !(*(_BYTE *)(a1 + 62) & 0x3F) )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    *(_WORD *)(a1 + 32) = (*(_WORD *)(a1 + 20) % 0x1C7u + *(_WORD *)(a1 + 32) - 227) & 0x7FF;
  }
  return sub_29A90(a1);
}

//----- (00029710) --------------------------------------------------------
__int16 __cdecl sub_29710(int a1)
{
  signed int v1; // eax
  char v2; // al
  unsigned int v3; // esi
  signed int v4; // edi
  __int16 v5; // ax
  unsigned int v6; // edi
  char v8; // [esp+0h] [ebp-4h]

  v8 = 0;
  v1 = sub_2A6B0(a1);
  if ( v1 )
  {
    if ( v1 != 1 )
      goto LABEL_19;
    *(_DWORD *)(a1 + 8) = &unk_F4240;
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
  }
  v2 = sub_2AF10(a1, *(_BYTE *)(a1 + 70) == 0);
  if ( v2 == 4 )
  {
    *(_BYTE *)(a1 + 69) = -40;
    *(_DWORD *)(a1 + 16) = 0;
  }
  else
  {
    v3 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v3 <= dword_EA3E4[0] || *(_DWORD *)(v3 + 8) < 0 || *(_BYTE *)(v3 + 13) & 4 )
      goto LABEL_24;
    if ( !(*(_BYTE *)(a1 + 62) & 3) && v2 != 3 && !*(_BYTE *)(a1 + 70) )
      *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76));
    if ( !(*(_BYTE *)(a1 + 62) & 0x1F) )
    {
      v4 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 30);
      v5 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76));
      if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v5) <= v4 )
      {
        *(_BYTE *)(a1 + 70) = 1;
        sub_2AED0(a1, 337);
      }
      else
      {
        *(_BYTE *)(a1 + 70) = 0;
        sub_2AED0(a1, 315);
      }
      v6 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
      if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76)) >= v6 )
LABEL_24:
        v8 = 1;
    }
  }
LABEL_19:
  if ( v8 )
  {
    *(_BYTE *)(a1 + 69) = -39;
    sub_2AED0(a1, 315);
    *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 70) = 0;
  }
  return sub_29A90(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00029890) --------------------------------------------------------
__int16 __cdecl sub_29890(int a1)
{
  *(_BYTE *)(a1 + 69) = -39;
  return sub_29670(a1);
}

//----- (000298B0) --------------------------------------------------------
int __cdecl sub_298B0(int a1)
{
  *(_DWORD *)(a1 + 8) = -1;
  return sub_1C890(a1, 216);
}

//----- (000298D0) --------------------------------------------------------
int __cdecl sub_298D0(unsigned int a1)
{
  int v1; // eax

  *(_DWORD *)(a1 + 8) = -1;
  sub_36BA0(a1, 1);
  if ( !(*(_BYTE *)(a1 + 14) & 0x10) )
  {
    v1 = sub_4A190(a1 + 76, 10, 1);
    if ( v1 )
      *(_WORD *)(v1 + 26) = *(_WORD *)(a1 + 26);
  }
  return sub_2AE80(a1);
}

//----- (00029930) --------------------------------------------------------
__int16 __cdecl sub_29930(int a1)
{
  unsigned __int8 v1; // al
  char v2; // ah
  int v3; // eax
  unsigned int v4; // eax

  sub_1D5D0(a1, 216);
  v1 = *(_BYTE *)(a1 + 73);
  if ( v1 < 2u || v1 > 2u && (v1 < 6u || v1 > 9u) )
    sub_2AED0(a1, 315);
  else
    sub_2AED0(a1, 337);
  v2 = *(_BYTE *)(a1 + 69);
  *(_DWORD *)(a1 + 8) = &unk_F4240;
  if ( v2 == -38 )
  {
    v3 = *(unsigned __int16 *)(a1 + 52);
    *(_BYTE *)(a1 + 73) = 10;
    while ( 1 )
    {
      v4 = dword_EA3E4[v3];
      if ( v4 <= dword_EA3E4[0] )
        break;
      if ( *(_BYTE *)(v4 + 69) == -23 && *(_BYTE *)(v4 + 70) == 1 )
      {
        *(_BYTE *)(v4 + 70) = 2;
        *(_WORD *)(v4 + 150) = *(_WORD *)(a1 + 150);
      }
      v3 = *(unsigned __int16 *)(v4 + 52);
    }
  }
  else if ( v2 == -40 )
  {
    *(_BYTE *)(a1 + 73) = 15;
  }
  return sub_29A90(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00029A90) --------------------------------------------------------
__int16 __cdecl sub_29A90(int a1)
{
  int v1; // edx
  int v2; // eax
  unsigned int i; // ebx
  _WORD *v4; // esi
  unsigned __int8 v5; // al
  int v6; // eax
  __int16 v7; // di
  unsigned __int16 v8; // ax
  __int16 v9; // ax
  unsigned int v10; // eax
  int v11; // eax
  int v12; // ecx
  int v13; // eax
  int v14; // eax
  int v15; // ecx
  int v16; // edi
  int v17; // eax
  signed int v18; // ecx
  int v19; // edx
  int j; // eax
  int v21; // eax
  char v22; // dh
  signed int v23; // eax
  signed int v24; // eax
  int v25; // eax
  char v26; // cl
  __int16 v27; // ax
  __int16 v28; // ax
  int v29; // ecx
  int k; // eax
  int v31; // ecx
  unsigned int v32; // edx
  int v34; // [esp+0h] [ebp-10h]
  unsigned int v35; // [esp+4h] [ebp-Ch]
  char v36; // [esp+8h] [ebp-8h]
  char v37; // [esp+Ch] [ebp-4h]

  HIWORD(v1) = HIWORD(a1);
  LOWORD(v2) = *(_WORD *)(a1 + 52);
  for ( i = dword_EA3E4[(unsigned __int16)v2]; i > dword_EA3E4[0]; i = dword_EA3E4[*(unsigned __int16 *)(i + 52)] )
  {
    if ( *(_BYTE *)(i + 69) == -23 )
    {
      LOBYTE(v1) = 0;
      v37 = 0;
      BYTE1(v1) = *(_BYTE *)(i + 62) + 1;
      v4 = (_WORD *)((char *)&off_D404C + 22 * *(unsigned __int8 *)(i + 59));
      v5 = *(_BYTE *)(i + 70);
      *(_BYTE *)(i + 62) = BYTE1(v1);
      if ( v5 <= 5u )
      {
        *(_WORD *)(i + 20) = 9377 * *(_WORD *)(i + 20) + 9439;
        *(_BYTE *)(i + 67) = *(_WORD *)(i + 20) % 0x14u;
        sub_2A5B0(a1, i, 672);
        sub_2A660(a1, i);
        if ( *(_BYTE *)(i + 70) == 1 )
        {
          *(_WORD *)(i + 20) = 9377 * *(_WORD *)(i + 20) + 9439;
          v6 = *(_WORD *)(i + 20) & 7;
          v7 = *(_WORD *)(i + 38);
          v34 = *(_WORD *)(i + 20) & 7;
          if ( v7 )
          {
            if ( v6 < 4 )
            {
              *(_WORD *)(i + 38) = 0;
              *(_BYTE *)(i + 70) = 2;
              v8 = *(_WORD *)(i + 54);
              *(_WORD *)(i + 150) = v7;
              v8 += 22;
              *(_WORD *)(i + 54) = v8;
              if ( v8 > 0x44u )
                *(_WORD *)(i + 54) = 68;
            }
          }
          else if ( v6 < 4 && *(_WORD *)(a1 + 150) && !(*(_BYTE *)(i + 62) & 7) )
          {
            v9 = *(_WORD *)(a1 + 150);
            *(_BYTE *)(i + 70) = 2;
            *(_WORD *)(i + 150) = v9;
          }
        }
      }
      switch ( *(_BYTE *)(i + 70) )
      {
        case 0:
          *(_WORD *)(i + 150) = 0;
          *(_BYTE *)(i + 70) = 1;
          *(_WORD *)(i + 44) = 0;
          *(_WORD *)(i + 54) = 0;
          *(_WORD *)(i + 132) = 16;
          goto LABEL_15;
        case 1:
LABEL_15:
          if ( *(_BYTE *)(a1 + 57) )
          {
            if ( !(*(_BYTE *)(i + 62) & 7) )
            {
              v1 = v34;
              if ( v34 )
              {
                if ( v34 > 4 )
                  *(_BYTE *)(i + 70) = 4;
              }
              else
              {
                v10 = sub_2A6F0(i);
                v35 = v10;
                if ( v10 )
                {
                  v11 = v10 - (dword_D41A0 + 28302);
                  v1 = v11 % 168;
                  *(_BYTE *)(i + 70) = 2;
                  *(_WORD *)(i + 150) = v11 / 168;
                }
              }
            }
            if ( !(*(_BYTE *)(i + 62) & 7) && !(v34 & 1) )
            {
              v12 = *(_DWORD *)(i + 160);
              *(_WORD *)(i + 20) = 9377 * *(_WORD *)(i + 20) + 9439;
              v4 = (_WORD *)(*(unsigned __int16 *)(a1 + 28) + (signed __int16)v4[6] - *(signed __int16 *)(v12 + 30));
              v1 = (int)v4 + *(unsigned __int16 *)(i + 20) % (unsigned int)*(signed __int16 *)(v12 + 30);
              *(_WORD *)(i + 28) = v1;
            }
          }
          break;
        case 2:
          *(_BYTE *)(i + 70) = 3;
          *(_BYTE *)(i + 68) = 0;
          *(_WORD *)(i + 44) = 2;
          *(_WORD *)(i + 132) = 16;
          goto LABEL_26;
        case 3:
LABEL_26:
          v13 = sub_2A7B0(i);
          v35 = v13;
          if ( v13 )
          {
            LOBYTE(v1) = *(_BYTE *)(i + 68);
            if ( (unsigned __int8)v1 < 1u )
            {
              if ( !(_BYTE)v1 && !*(_WORD *)(i + 130) )
              {
                v4 = (_WORD *)(v13 + 76);
                *(_BYTE *)(i + 68) = 1;
                *(_WORD *)(i + 44) = 1;
                *(_WORD *)(i + 132) = 16;
                *(_WORD *)(i + 28) = sub_581E0((_WORD *)(i + 76), (_WORD *)(v13 + 76));
                *(_WORD *)(i + 30) = sub_58210((_WORD *)(i + 76), v4);
                v1 = a1;
                *(_WORD *)(i + 32) = *(_WORD *)(i + 28) - *(_WORD *)(a1 + 28);
                *(_WORD *)(i + 34) = *(_WORD *)(i + 30) - *(_WORD *)(a1 + 30);
              }
            }
            else if ( (unsigned __int8)v1 <= 1u )
            {
              if ( *(_WORD *)(i + 130) == 192 )
              {
                *(_WORD *)(i + 44) = 3;
                *(_BYTE *)(i + 68) = 3;
                *(_DWORD *)(i + 16) = 4;
                v37 = 1;
              }
            }
            else if ( (_BYTE)v1 == 3 )
            {
              v37 = 2;
              v14 = *(_DWORD *)(i + 16) - 1;
              *(_DWORD *)(i + 16) = v14;
              if ( !v14 )
              {
                *(_BYTE *)(i + 70) = 0;
                *(_DWORD *)(i + 16) = 1;
              }
            }
          }
          else
          {
            *(_BYTE *)(i + 70) = 0;
          }
          break;
        case 4:
          *(_BYTE *)(i + 70) = 5;
          *(_BYTE *)(i + 68) = 0;
          *(_WORD *)(i + 44) = 2;
          *(_WORD *)(i + 132) = 16;
          goto LABEL_40;
        case 5:
LABEL_40:
          switch ( *(_BYTE *)(i + 68) )
          {
            case 0:
              if ( !*(_WORD *)(i + 130) )
              {
                *(_BYTE *)(i + 68) = 1;
                *(_WORD *)(i + 44) = 1;
                *(_WORD *)(i + 132) = -16;
                *(_WORD *)(i + 32) = v4[6];
                *(_WORD *)(i + 34) = v4[7];
                LOWORD(v1) = *(_WORD *)(i + 32);
                *(_WORD *)(i + 28) = v1 + *(_WORD *)(a1 + 28);
                *(_WORD *)(i + 30) = *(_WORD *)(i + 34) + *(_WORD *)(a1 + 30);
              }
              break;
            case 1:
              if ( *(signed __int16 *)(i + 130) == -192 )
              {
                *(_BYTE *)(i + 68) = 2;
                *(_DWORD *)(i + 16) = 2;
              }
              break;
            case 2:
              v15 = *(_DWORD *)(i + 16) - 1;
              *(_DWORD *)(i + 16) = v15;
              if ( !v15 )
              {
                *(_WORD *)(i + 44) = 4;
                *(_BYTE *)(i + 68) = 6;
                *(_DWORD *)(i + 16) = 1;
              }
              break;
            case 5:
              v1 = *(_DWORD *)(i + 16) - 1;
              *(_DWORD *)(i + 16) = v1;
              if ( v1 <= 4 )
              {
                *(_BYTE *)(i + 70) = 0;
                *(_DWORD *)(i + 16) = 4;
              }
              break;
            case 6:
              sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 17);
              v16 = *(_DWORD *)(i + 16) + 1;
              *(_DWORD *)(i + 16) = v16;
              if ( v16 >= 4 )
                *(_BYTE *)(i + 68) = 5;
              break;
            default:
              goto LABEL_94;
          }
          break;
        case 6:
          *(_DWORD *)(i + 16) = 0;
          *(_WORD *)(i + 44) = 2;
          *(_BYTE *)(i + 70) = 7;
          *(_BYTE *)(i + 68) = 0;
          *(_WORD *)(i + 132) = 80;
          goto LABEL_52;
        case 7:
LABEL_52:
          v36 = 0;
          sub_2A5B0(a1, i, 672);
          v17 = *(unsigned __int8 *)(i + 68);
          switch ( (_BYTE)v17 )
          {
            case 0:
              if ( !*(_WORD *)(i + 130) )
              {
                *(_BYTE *)(i + 68) = 1;
                *(_WORD *)(i + 44) = 1;
                *(_WORD *)(i + 32) = v4[6];
                LOWORD(v17) = v4[7];
                *(_WORD *)(i + 34) = v17;
              }
              break;
            case 1:
              LOWORD(v17) = *(_WORD *)(i + 130);
              v36 = 1;
              if ( (_WORD)v17 == 192 )
              {
                *(_BYTE *)(i + 68) = 7;
                *(_WORD *)(i + 44) = 5;
                *(_DWORD *)(i + 16) = 8;
              }
              break;
            case 7:
              v36 = 1;
              v17 = *(_DWORD *)(i + 16) - 1;
              *(_DWORD *)(i + 16) = v17;
              if ( !v17 )
              {
                *(_BYTE *)(i + 68) = 8;
                *(_WORD *)(i + 44) = 6;
                *(_WORD *)(i + 34) = 0;
                *(_BYTE *)(i + 67) = 0;
                *(_WORD *)(i + 54) = 0;
                *(_WORD *)(i + 132) = 12;
                *(_DWORD *)(i + 16) = 0;
              }
              break;
            case 8:
              v18 = *(_DWORD *)(i + 16);
              if ( v18 > 10 )
              {
                *(_BYTE *)(i + 70) = 8;
              }
              else
              {
                if ( v18 )
                {
                  v19 = dword_EA3E4[*(unsigned __int16 *)(i + 52)];
                  for ( j = 0; ; ++j )
                  {
                    v35 = v19;
                    if ( j >= 9 - *(_DWORD *)(i + 16) )
                      break;
                    v19 = dword_EA3E4[*(unsigned __int16 *)(v19 + 52)];
                  }
                }
                else
                {
                  v35 = i;
                }
                if ( v35 > dword_EA3E4[0] )
                  *(_BYTE *)(v35 + 12) = (*(_BYTE *)(v35 + 12) | 1) & 0xF7;
                v21 = *(_DWORD *)(i + 16) + 1;
                v22 = *(_BYTE *)(i + 67) + 1;
                *(_DWORD *)(i + 16) = v21;
                LOWORD(v21) = v22;
                v17 = 28 * v21;
                *(_BYTE *)(i + 67) = v22;
                *(_WORD *)(i + 54) += v17;
              }
              break;
            default:
              break;
          }
          if ( v36 )
          {
            if ( *(_BYTE *)(i + 62) & 1 )
              v23 = -204;
            else
              v23 = 204;
            v17 = *(unsigned __int16 *)(a1 + 28) + (signed __int16)v4[6] + v23;
            *(_WORD *)(i + 28) = v17;
          }
          sub_2A340(v17, a1, a1, (int)v4, a1, i);
          sub_2A940(a1, i);
          break;
        case 8:
          *(_BYTE *)(i + 70) = 9;
          *(_DWORD *)(i + 16) = 100;
          --*(_BYTE *)(a1 + 59);
          goto LABEL_83;
        case 9:
LABEL_83:
          v25 = *(_DWORD *)(i + 16) - 1;
          *(_DWORD *)(i + 16) = v25;
          if ( !v25 )
            *(_BYTE *)(i + 70) = 10;
          break;
        case 0xA:
          ++*(_BYTE *)(a1 + 59);
          *(_BYTE *)(i + 70) = 11;
          *(_WORD *)(i + 44) = 5;
          v26 = *(_BYTE *)(i + 12);
          *(_DWORD *)(i + 16) = 7;
          v26 &= 0xF6u;
          v27 = *(_WORD *)(i + 52);
          *(_BYTE *)(i + 12) = v26;
          *(_WORD *)(i + 150) = v27;
          *(_BYTE *)(i + 12) = v26 | 8;
          *(_WORD *)(i + 32) = v4[6];
          v28 = v4[7];
          *(_WORD *)(i + 130) = 156;
          *(_WORD *)(i + 34) = v28;
          goto LABEL_86;
        case 0xB:
LABEL_86:
          v29 = *(_DWORD *)(i + 16) - 1;
          *(_DWORD *)(i + 16) = v29;
          if ( v29 <= 0 )
          {
            *(_BYTE *)(i + 70) = 12;
            *(_DWORD *)(i + 16) = 0;
          }
          break;
        case 0xC:
          if ( *(_DWORD *)(i + 16) < 9 )
          {
            v1 = *(unsigned __int16 *)(i + 52);
            for ( k = 0; ; ++k )
            {
              v4 = (_WORD *)dword_EA3E4[v1];
              if ( k >= *(_DWORD *)(i + 16) )
                break;
              v1 = (unsigned __int16)v4[26];
            }
            *((_BYTE *)v4 + 12) &= 0xFEu;
            v31 = *(_DWORD *)(i + 16) + 1;
            *(_WORD *)(i + 150) = v4[26];
            *(_DWORD *)(i + 16) = v31;
            if ( v31 >= 9 )
            {
              *(_WORD *)(i + 20) = 9377 * *(_WORD *)(i + 20) + 9439;
              v32 = *(unsigned __int16 *)(i + 20) % 0x398u;
              *(_WORD *)(i + 98) = 0;
              *(_BYTE *)(i + 70) = 0;
              v1 = v32 + 920;
              *(_DWORD *)(i + 8) = v1;
            }
          }
          break;
        case 0xD:
          *(_BYTE *)(i + 70) = 14;
          *(_BYTE *)(i + 67) = 10;
          *(_DWORD *)(i + 16) = 10;
          goto LABEL_77;
        case 0xE:
LABEL_77:
          v4 = (_WORD *)(*(_DWORD *)(i + 16) - 1);
          *(_DWORD *)(i + 16) = v4;
          if ( !v4 )
            *(_BYTE *)(i + 70) = 15;
          break;
        case 0xF:
          v35 = i;
          *(_BYTE *)(i + 70) = 8;
          v24 = 0;
          do
          {
            *(_BYTE *)(v35 + 12) = (*(_BYTE *)(v35 + 12) | 1) & 0xF7;
            v1 = dword_EA3E4[*(unsigned __int16 *)(v35 + 52)];
            ++v24;
            v35 = dword_EA3E4[*(unsigned __int16 *)(v35 + 52)];
          }
          while ( v24 < 10 );
          break;
        default:
          break;
      }
LABEL_94:
      v2 = *(unsigned __int8 *)(i + 70);
      switch ( (_BYTE)v2 )
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          sub_2A340(v2, v1, a1, (int)v4, a1, i);
          sub_2A940(a1, i);
          sub_2AA90(i, a1, i);
          if ( v37 )
          {
            sub_2A7F0(i, v35, v37 == 1);
            sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 17);
          }
          goto LABEL_99;
        case 6:
        case 7:
          LOWORD(v2) = sub_2AA90(i, a1, i);
          break;
        case 0xB:
        case 0xC:
          sub_2A5B0(a1, i, 672);
          sub_2A940(a1, i);
          sub_2AA90(i, a1, i);
          v35 = dword_EA3E4[*(unsigned __int16 *)(i + 150)];
          *(_DWORD *)&word_EB398 = *(_DWORD *)(v35 + 76);
          *(&word_EB398 + 2) = *(_WORD *)(v35 + 80);
          sub_57CF0(i, (int)&word_EB398);
LABEL_99:
          LOWORD(v2) = sub_2A9F0(a1, i);
          break;
        default:
          continue;
      }
    }
  }
  return v2;
}
// D404C: using guessed type void *off_D404C;
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (0002A340) --------------------------------------------------------
char __usercall sub_2A340@<al>(int a1@<eax>, int a2@<edx>, int a3@<edi>, int a4@<esi>, int a5, int a6)
{
  int v6; // eax
  int v7; // eax
  __int16 v8; // cx
  int v9; // edi
  __int16 v10; // dx
  __int16 v11; // di
  __int16 v12; // cx
  __int16 v13; // cx

  LOWORD(v6) = *(_WORD *)(a6 + 44);
  switch ( (_WORD)v6 )
  {
    case 0:
      LOWORD(a1) = *(_WORD *)(a6 + 134);
      LOWORD(a2) = *(_WORD *)(a6 + 54);
      v7 = a2 + a1 + 73;
      v8 = v7 + *(_WORD *)(a6 + 32);
      LOWORD(v7) = *(_WORD *)(a6 + 134);
      LOWORD(a4) = *(_WORD *)(a6 + 54);
      LOWORD(a3) = *(_WORD *)(a6 + 34);
      *(_WORD *)(a6 + 32) = v8;
      v9 = a4 + v7 + 62 + a3;
      LOWORD(v7) = *(_WORD *)(a6 + 130);
      *(_WORD *)(a6 + 34) = v9;
      if ( (_WORD)v7 != 192 )
      {
        v10 = *(_WORD *)(a6 + 132) + *(_WORD *)(a6 + 130);
        *(_WORD *)(a6 + 130) = v10;
        if ( abs(v10) > 192 )
        {
          if ( *(_WORD *)(a6 + 132) <= 0 )
            *(_WORD *)(a6 + 130) = -192;
          else
            *(_WORD *)(a6 + 130) = 192;
          *(_WORD *)(a6 + 132) = -*(_WORD *)(a6 + 132);
        }
      }
      if ( !(*(_BYTE *)(a6 + 62) & 1) )
      {
        v11 = *(_WORD *)(a6 + 54);
        if ( v11 )
          *(_WORD *)(a6 + 54) = v11 - 1;
      }
      LOBYTE(v6) = *(_BYTE *)(a6 + 67);
      if ( (_BYTE)v6 )
      {
        if ( (_BYTE)v6 == 3 && *(_WORD *)(a6 + 130) == 192 )
        {
          *(_WORD *)(a6 + 132) = -16;
          LOWORD(v6) = *(_WORD *)(a6 + 132);
          *(_WORD *)(a6 + 130) += v6;
        }
      }
      else
      {
        *(_WORD *)(a6 + 20) = 9377 * *(_WORD *)(a6 + 20) + 9439;
        LOWORD(v6) = *(_WORD *)(a6 + 20) / 0x1Cu;
        *(_WORD *)(a6 + 134) = *(_WORD *)(a6 + 20) % 0x1Cu;
      }
      break;
    case 1:
      v6 = abs(*(signed __int16 *)(a6 + 130));
      if ( v6 < 192 )
      {
        LOWORD(v6) = *(_WORD *)(a6 + 132);
        *(_WORD *)(a6 + 130) += v6;
      }
      if ( *(_WORD *)(a6 + 132) <= 0 )
      {
        v6 = *(signed __int16 *)(a6 + 130);
        if ( v6 < -192 )
LABEL_23:
          *(_WORD *)(a6 + 130) = -192;
      }
      else if ( *(_WORD *)(a6 + 130) > 192 )
      {
LABEL_21:
        *(_WORD *)(a6 + 130) = 192;
      }
      break;
    case 2:
      v6 = abs(*(signed __int16 *)(a6 + 130));
      if ( v6 < *(signed __int16 *)(a6 + 132) )
      {
        *(_WORD *)(a6 + 130) = 0;
      }
      else
      {
        v12 = *(_WORD *)(a6 + 130);
        if ( v12 <= 0 )
        {
          LOWORD(v6) = *(_WORD *)(a6 + 132);
          *(_WORD *)(a6 + 130) = v6 + v12;
        }
        else
        {
          LOWORD(v6) = *(_WORD *)(a6 + 132);
          *(_WORD *)(a6 + 130) = v12 - v6;
        }
      }
      break;
    case 3:
    case 4:
      v6 = *(_DWORD *)(a6 + 16) - 1;
      switch ( *(_DWORD *)(a6 + 16) )
      {
        case 1:
          goto LABEL_23;
        case 2:
          *(_WORD *)(a6 + 130) = -130;
          return v6;
        case 3:
          *(_WORD *)(a6 + 130) = -23;
          return v6;
        case 4:
          goto LABEL_21;
        default:
          return v6;
      }
    case 6:
      v13 = *(_WORD *)(a6 + 80) - *(_WORD *)(a6 + 54);
      *(_WORD *)(a6 + 130) -= *(_WORD *)(a6 + 132);
      *(_WORD *)(a6 + 80) = v13;
      LOWORD(v6) = sub_10C40((__int16 *)(a6 + 76));
      if ( *(signed __int16 *)(a6 + 80) < (signed __int16)v6 )
        *(_WORD *)(a6 + 80) = v6;
      break;
    default:
      return v6;
  }
  return v6;
}

//----- (0002A5B0) --------------------------------------------------------
signed int __cdecl sub_2A5B0(int a1, int a2, __int16 a3)
{
  __int16 *v3; // ebx
  __int16 v4; // si
  __int16 v5; // ax

  v3 = (__int16 *)((char *)&off_D404C + 22 * *(unsigned __int8 *)(a2 + 59));
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57FA0(&word_EB398, v3[1] + *(_WORD *)(a1 + 28), 0, *v3);
  v4 = v3[7];
  v5 = *(_WORD *)(a1 + 30);
  word_EB39C += v3[2];
  sub_57FA0(&word_EB398, v3[6] + *(_WORD *)(a1 + 28), v4 + v5, a3);
  return sub_57CF0(a2, (int)&word_EB398);
}
// D404C: using guessed type void *off_D404C;
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0002A660) --------------------------------------------------------
int __cdecl sub_2A660(int a1, int a2)
{
  int result; // eax
  __int16 v3; // dx
  signed int v4; // edx
  __int16 v5; // dx
  int v6; // ecx

  result = a2;
  v3 = *(_WORD *)(a2 + 98);
  if ( v3 )
  {
    *(_WORD *)(a1 + 98) = v3;
    v4 = *(_DWORD *)(a2 + 94);
    *(_DWORD *)(a1 + 94) = v4;
    if ( v4 > 76 )
      v4 = 76;
    *(_DWORD *)(a2 + 8) -= v4;
    v5 = *(_WORD *)(a2 + 98);
    *(_WORD *)(a2 + 98) = 0;
    v6 = *(_DWORD *)(a2 + 8);
    *(_WORD *)(a2 + 38) = v5;
    if ( v6 < 0 )
      *(_BYTE *)(a2 + 70) = 6;
  }
  return result;
}

//----- (0002A6B0) --------------------------------------------------------
signed int __cdecl sub_2A6B0(int a1)
{
  __int16 v1; // bx
  signed int v2; // edx
  char v3; // dl

  v1 = *(_WORD *)(a1 + 98);
  v2 = 0;
  if ( v1 )
  {
    v3 = *(_BYTE *)(a1 + 59);
    *(_WORD *)(a1 + 38) = v1;
    if ( v3 )
    {
      v2 = 1;
    }
    else
    {
      *(_BYTE *)(a1 + 69) = -36;
      v2 = 2;
      *(_WORD *)(a1 + 36) = v1;
    }
    *(_WORD *)(a1 + 98) = 0;
  }
  return v2;
}

//----- (0002A6F0) --------------------------------------------------------
unsigned int __cdecl sub_2A6F0(int a1)
{
  int v1; // esi
  unsigned int v2; // edi
  unsigned int v3; // ebx
  int v4; // esi
  signed int v5; // ST08_4
  __int16 v6; // ax
  int v8; // [esp+4h] [ebp-10h]
  signed int v9; // [esp+10h] [ebp-4h]

  v1 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
  v2 = 0;
  v9 = 0x10000000;
  v3 = *(_DWORD *)(dword_D41A4 + 38519);
  v8 = v1 * v1;
  while ( v3 > dword_EA3E4[0] )
  {
    v4 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76));
    if ( v4 < v8 )
    {
      v5 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 30);
      v6 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76));
      if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v6) < v5 && v4 < v9 )
      {
        v2 = v3;
        v9 = v4;
      }
    }
    v3 = *(_DWORD *)v3;
  }
  return v2;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002A7B0) --------------------------------------------------------
int __cdecl sub_2A7B0(int a1)
{
  unsigned __int16 v1; // bx
  int result; // eax
  int v3; // edx

  v1 = *(_WORD *)(a1 + 150);
  result = 0;
  if ( v1 )
  {
    v3 = dword_EA3E4[v1];
    if ( *(_DWORD *)(v3 + 8) >= 0 && !(*(_BYTE *)(v3 + 13) & 4) )
      result = dword_EA3E4[v1];
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002A7F0) --------------------------------------------------------
void __cdecl sub_2A7F0(int a1, int a2, char a3)
{
  int v3; // esi
  signed int v4; // edx
  unsigned int v5; // eax
  int v6; // eax
  __int16 v7; // [esp-4h] [ebp-8h]

  v3 = 0;
  if ( a3 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v4 = *(unsigned __int16 *)(a1 + 20) % 0xCu;
    *(_WORD *)(a1 + 20) += *(_WORD *)(dword_D41A4 + 30);
    *(_DWORD *)(a1 + 136) = (v4 > 7) + 1;
  }
  v5 = *(_DWORD *)(a1 + 136);
  if ( v5 >= 1 )
  {
    if ( v5 <= 1 )
    {
      if ( !a3 )
        goto LABEL_13;
      v6 = sub_4A190(a1 + 76, 9, 0);
      v3 = v6;
      if ( !v6 )
        goto LABEL_13;
      *(_BYTE *)(v6 + 67) = 10;
      *(_BYTE *)(v6 + 68) = 0;
      v7 = 15;
    }
    else
    {
      if ( v5 != 2 )
        goto LABEL_13;
      v6 = sub_4A190(a1 + 76, 9, 9);
      v3 = v6;
      if ( !v6 )
        goto LABEL_13;
      *(_BYTE *)(v6 + 67) = 10;
      *(_BYTE *)(v6 + 68) = 23;
      v7 = 23;
    }
    *(_WORD *)(v6 + 42) = 850;
    sub_6E450(*(_WORD *)(a1 + 26), -1, v7);
  }
LABEL_13:
  if ( v3 )
  {
    *(_WORD *)(v3 + 26) = *(_WORD *)(a1 + 26);
    *(_WORD *)(v3 + 28) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
    *(_WORD *)(v3 + 30) = sub_58210((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
    *(_WORD *)(v3 + 80) += *(_WORD *)(a1 + 88) / 2;
    *(_WORD *)(v3 + 150) = *(_WORD *)(a1 + 150);
    *(_DWORD *)(v3 + 160) = &off_D89EA;
    *(_BYTE *)(v3 + 66) = *(_BYTE *)(a2 + 64);
    *(_BYTE *)(v3 + 65) = *(_BYTE *)(a2 + 63);
  }
}
// D41A4: using guessed type int dword_D41A4;
// D89EA: using guessed type void *off_D89EA;

//----- (0002A940) --------------------------------------------------------
signed int __cdecl sub_2A940(signed int a1, int a2)
{
  signed int result; // eax
  char *v3; // edx

  result = a1;
  if ( dword_E9BA8 )
  {
    v3 = (char *)&off_D404C + 22 * *(unsigned __int8 *)(a2 + 59);
    *(_WORD *)(a2 + 32) = *((_WORD *)v3 + 6);
    LOWORD(v3) = *((_WORD *)v3 + 7);
    *(_WORD *)(a2 + 130) = 192;
    *(_BYTE *)(a2 + 70) = 0;
    *(_WORD *)(a2 + 34) = (_WORD)v3;
    *(_BYTE *)(a1 + 13) |= 8u;
  }
  else
  {
    *(_BYTE *)(a1 + 13) &= 0xF7u;
  }
  if ( *(_WORD *)(a2 + 130) )
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a2 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a2 + 80);
    sub_57FA0(
      &word_EB398,
      *(_WORD *)(a2 + 32) + *(_WORD *)(a1 + 28),
      *(_WORD *)(a2 + 34) + *(_WORD *)(a1 + 30),
      *(_WORD *)(a2 + 130));
    result = sub_57CF0(a2, (int)&word_EB398);
  }
  return result;
}
// D404C: using guessed type void *off_D404C;
// E9BA8: using guessed type int dword_E9BA8;
// EB398: using guessed type __int16 word_EB398;

//----- (0002A9F0) --------------------------------------------------------
signed int __cdecl sub_2A9F0(int a1, int a2)
{
  int v2; // eax
  _WORD *v3; // eax
  __int16 v4; // di
  __int16 v5; // ST0C_2
  __int16 v6; // dx

  v2 = 22 * *(unsigned __int8 *)(a2 + 59);
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a2 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a2 + 80);
  v3 = (_WORD *)((char *)&off_D404C + v2);
  v4 = v3[7];
  v5 = v3[3];
  v6 = *(_WORD *)(a1 + 30);
  word_EB39C += v3[5];
  sub_57FA0(&word_EB398, v3[6] + *(_WORD *)(a1 + 28), v4 + v6, v5);
  return sub_57CF0(a2, (int)&word_EB398);
}
// D404C: using guessed type void *off_D404C;
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0002AA90) --------------------------------------------------------
unsigned __int16 __usercall sub_2AA90@<ax>(int a1@<ebx>, int a2, int a3)
{
  __int16 *v3; // ecx
  __int16 v4; // ax
  int v5; // eax
  signed int v6; // esi
  _WORD *v7; // edi
  int v8; // eax
  int v9; // ebx
  __int16 v10; // ax
  unsigned __int16 result; // ax
  int v12; // [esp+0h] [ebp-20h]
  int v13; // [esp+4h] [ebp-1Ch]
  int v14; // [esp+8h] [ebp-18h]
  __int16 v15; // [esp+Ch] [ebp-14h]
  __int16 *v16; // [esp+10h] [ebp-10h]
  int v17; // [esp+14h] [ebp-Ch]
  int v18; // [esp+18h] [ebp-8h]
  int v19; // [esp+1Ch] [ebp-4h]

  v3 = (__int16 *)((char *)&off_D404C + 22 * *(unsigned __int8 *)(a3 + 59));
  v12 = *(_DWORD *)(a2 + 76);
  LOWORD(v13) = *(_WORD *)(a2 + 80);
  v4 = *v3;
  v16 = v3;
  sub_57FA0(&v12, v3[1] + *(_WORD *)(a2 + 28), 0, v4);
  LOWORD(v13) = v16[2] + v13;
  v14 = *(_DWORD *)(a3 + 76);
  v15 = *(_WORD *)(a3 + 80);
  v5 = (signed int)(sub_583F0(&v12, &v14) - 468) / 24;
  v18 = 16 - v5;
  if ( 16 - v5 <= 15 )
  {
    if ( 16 - v5 < 0 )
      v18 = 0;
  }
  else
  {
    v18 = 15;
  }
  LOWORD(v19) = sub_581E0(&v12, &v14);
  v19 = (unsigned __int16)v19;
  LOWORD(v17) = sub_58210(&v12, &v14);
  v17 = (unsigned __int16)v17;
  v6 = 0;
  v7 = (_WORD *)dword_EA3E4[*(unsigned __int16 *)(a3 + 52)];
  do
  {
    v8 = 3 * v18;
    switch ( v6 )
    {
      case 0:
        LOWORD(a1) = 0;
        break;
      case 1:
      case 8:
        v9 = dword_D40BC[v8];
        goto LABEL_12;
      case 2:
      case 7:
        v9 = dword_D40C0[v8];
LABEL_12:
        a1 = -v9;
        break;
      case 3:
      case 6:
        a1 = dword_D40C0[v8];
        break;
      case 4:
      case 5:
        a1 = dword_D40BC[v8];
        break;
      default:
        break;
    }
    if ( v6 )
      sub_57FA0(&v12, v19, a1 + v17, 96);
    sub_57CF0((int)v7, (int)&v12);
    if ( *(_BYTE *)(a3 + 70) == 7 && *(_BYTE *)(a3 + 68) == 8 )
    {
      v10 = sub_10C40(v7 + 38);
      if ( (signed __int16)v7[40] <= v10 )
        v7[40] = v10;
    }
    result = v7[26];
    ++v6;
    v7 = (_WORD *)dword_EA3E4[result];
  }
  while ( v6 < 9 );
  return result;
}
// D404C: using guessed type void *off_D404C;
// D40BC: using guessed type int dword_D40BC[];
// D40C0: using guessed type int dword_D40C0[];
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002AC50) --------------------------------------------------------
_WORD *__cdecl sub_2AC50(int a1)
{
  int v1; // ebx
  int v2; // ecx
  int v3; // edx
  int v4; // ecx
  char v5; // ah

  v1 = a1;
  *(_WORD *)(a1 + 32) = 0;
  *(_WORD *)(v1 + 28) = *(_WORD *)(v1 + 32);
  v2 = dword_D41A0;
  *(_WORD *)(v1 + 30) = *(_WORD *)(v1 + 32);
  *(_WORD *)(a1 + 132) = 64;
  *(_WORD *)(a1 + 134) = 0;
  *(_WORD *)(a1 + 130) = 30;
  *(_BYTE *)(a1 + 59) = 5;
  *(_DWORD *)(a1 + 8) = &unk_F4240;
  *(_DWORD *)(a1 + 4) = 36000;
  *(_DWORD *)(a1 + 144) = 20000;
  *(_DWORD *)(v1 + 16) = (v1 - (v2 + 28302)) / 168 % 100;
  v3 = *(char *)(a1 + 64);
  *(_WORD *)(a1 + 34) = 0;
  v4 = v3 + v2;
  *(_BYTE *)(a1 + 56) = 1;
  LOBYTE(v3) = (*(_BYTE *)(v4 + 16))++;
  *(_DWORD *)(a1 + 160) = &off_D88B8;
  *(_BYTE *)(a1 + 62) = v3;
  v5 = *(_BYTE *)(a1 + 15) | 0x80;
  LOBYTE(v3) = *(_BYTE *)(*(_DWORD *)(a1 + 160) + 26);
  *(_BYTE *)(a1 + 65) = 3;
  *(_BYTE *)(a1 + 15) = v5;
  *(_BYTE *)(a1 + 57) = v3 + 1;
  sub_49CD0((_WORD *)a1, 315);
  return sub_49EA0((_WORD *)a1, 1024, 1536);
}
// D41A0: using guessed type int dword_D41A0;
// D88B8: using guessed type void *off_D88B8;

//----- (0002AD40) --------------------------------------------------------
unsigned __int16 __cdecl sub_2AD40(signed int a1)
{
  unsigned __int16 result; // ax
  signed int v2; // esi
  unsigned int i; // ebx
  __int16 v4; // cx
  int v5; // eax

  result = *(_WORD *)(a1 + 52);
  v2 = 1;
  for ( i = dword_EA3E4[result]; i > dword_EA3E4[0]; i = dword_EA3E4[*(unsigned __int16 *)(i + 52)] )
  {
    if ( *(_BYTE *)(i + 69) == -23 )
    {
      sub_49CD0((_WORD *)i, 316);
      *(_BYTE *)(i + 15) |= 0xA0u;
      *(_WORD *)(i + 20) = 9377 * *(_WORD *)(i + 20) + 9439;
      v4 = *(_WORD *)(i + 20);
      *(_WORD *)(i + 32) = *(_WORD *)(i + 20) & 0x7FF;
      *(_WORD *)(i + 20) = 9377 * v4 + 9439;
      *(_WORD *)(i + 34) = *(_WORD *)(i + 20) & 0x7FF;
      *(_WORD *)(i + 132) = 16;
      *(_WORD *)(i + 130) = 16;
      *(_DWORD *)(i + 160) = &off_D8984;
      *(_BYTE *)(i + 56) = 1;
      v5 = 460 * v2 + 920;
      *(_DWORD *)(i + 8) = v5;
      *(_DWORD *)(i + 4) = v5;
      result = sub_2A940(a1, i);
    }
    ++v2;
  }
  return result;
}
// D8984: using guessed type void *off_D8984;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002AE30) --------------------------------------------------------
int __cdecl sub_2AE30(int a1)
{
  int result; // eax
  int i; // ebx
  unsigned int v3; // ebx

  result = a1;
  for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v3 + 52) )
  {
    v3 = dword_EA3E4[i];
    if ( v3 <= dword_EA3E4[0] )
      break;
    if ( *(_BYTE *)(v3 + 69) == -22 )
    {
      result = sub_49CD0((_WORD *)v3, 317);
      *(_BYTE *)(v3 + 15) |= 0xA0u;
    }
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002AE80) --------------------------------------------------------
int __cdecl sub_2AE80(unsigned int a1)
{
  int i; // ebx
  unsigned int v2; // ebx
  int result; // eax

  if ( a1 && a1 > dword_EA3E4[0] )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v2 + 52) )
    {
      v2 = dword_EA3E4[i];
      if ( v2 <= dword_EA3E4[0] )
        break;
      sub_57F10(v2);
    }
    result = sub_57F10(a1);
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002AED0) --------------------------------------------------------
char __cdecl sub_2AED0(int a1, int a2)
{
  int v2; // eax

  v2 = *(signed __int16 *)(a1 + 90);
  if ( a2 != v2 )
  {
    *(_WORD *)(a1 + 90) = a2;
    *(_BYTE *)(a1 + 92) = 0;
    LOBYTE(v2) = byte_D8A2E[(unsigned __int8)byte_D9528[14 * a2]];
    *(_BYTE *)(a1 + 93) = v2;
  }
  return v2;
}

//----- (0002AF10) --------------------------------------------------------
char __cdecl sub_2AF10(int a1, char a2)
{
  char v2; // dh
  char v3; // al
  signed int v4; // eax
  __int16 v5; // ax
  signed int v7; // [esp+0h] [ebp-1Ch]
  unsigned __int16 v8; // [esp+4h] [ebp-18h]
  int v9; // [esp+8h] [ebp-14h]
  char v10; // [esp+Ch] [ebp-10h]
  char v11; // [esp+10h] [ebp-Ch]
  char v12; // [esp+14h] [ebp-8h]
  char v13; // [esp+18h] [ebp-4h]

  v2 = *(_BYTE *)(a1 + 14);
  v10 = 0;
  v12 = 0;
  if ( v2 & 0x10 )
    *(_BYTE *)(a1 + 14) = v2 & 0xEF;
  else
    *(_BYTE *)(a1 + 12) &= 0xFEu;
  v3 = *(_BYTE *)(a1 + 13);
  if ( v3 & 8 )
  {
    *(_BYTE *)(a1 + 13) = v3 & 0xF7;
    v13 = 4;
  }
  else
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    if ( a2 )
      sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
    word_EB39C = sub_10C40(&word_EB398);
    if ( a2
      && *(signed __int16 *)(a1 + 76) >> 8 == word_EB398 >> 8
      && *(signed __int16 *)(a1 + 78) >> 8 == word_EB39A >> 8 )
    {
      v10 = 1;
      v12 = 1;
      v13 = 1;
      *(_BYTE *)(a1 + 14) &= 0xFBu;
    }
    else if ( sub_102D0(a1, &word_EB398, 1) || sub_102D0(a1, &word_EB398, 4) || sub_1B830(&word_EB398) >= 32 )
    {
      if ( *(_WORD *)(a1 + 28) == *(_WORD *)(a1 + 32) )
      {
        *(_BYTE *)(a1 + 14) |= 4u;
        v7 = 91;
        v9 = 1;
        v11 = BYTE1(v7);
        while ( v7 <= 1024 )
        {
          *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
          *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
          v8 = (*(_WORD *)(a1 + 28) + v9 * v7) & 0x7FF;
          sub_57FA0(&word_EB398, v8, 0, *(_WORD *)(a1 + 130));
          word_EB39C = sub_10C40(&word_EB398);
          if ( !sub_102D0(a1, &word_EB398, 1) && !sub_102D0(a1, &word_EB398, 4) && sub_1B830(&word_EB398) < 32 )
          {
            v11 = 1;
            break;
          }
          v9 = -v9;
          if ( v9 == 1 )
            v4 = 91;
          else
            v4 = 0;
          v7 += v4;
        }
        if ( v11 )
        {
          *(_WORD *)(a1 + 32) = v8;
          v12 = 1;
          v13 = 3;
        }
        else
        {
          v13 = 4;
        }
      }
      else
      {
        *(_BYTE *)(a1 + 14) |= 4u;
        v12 = 1;
        v13 = 3;
      }
    }
    else
    {
      v10 = 1;
      v12 = 1;
      v13 = 2;
      *(_BYTE *)(a1 + 14) &= 0xFBu;
    }
    if ( a2 && v10 )
      sub_57CF0(a1, (int)&word_EB398);
    if ( v12 )
    {
      v5 = *(_WORD *)(a1 + 28)
         + sub_58350(
             *(_WORD *)(a1 + 28),
             *(_WORD *)(a1 + 32),
             *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 4),
             *(_WORD *)(*(_DWORD *)(a1 + 160) + 2));
      HIBYTE(v5) &= 7u;
      *(_WORD *)(a1 + 28) = v5;
    }
    *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
  }
  if ( v13 == 4 )
  {
    *(_BYTE *)(a1 + 69) = -40;
    *(_DWORD *)(a1 + 16) = 0;
  }
  return v13;
}
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0002B1D0) --------------------------------------------------------
signed int __cdecl sub_2B1D0(int a1)
{
  signed int result; // eax

  result = sub_1BD90(a1, 224);
  BYTE1(result) = *(_BYTE *)(a1 + 69);
  if ( BYTE1(result) == -30 )
    result = sub_2B840(a1);
  return result;
}

//----- (0002B200) --------------------------------------------------------
void __cdecl sub_2B200(int a1)
{
  sub_1BF90(a1, 224);
  if ( *(_BYTE *)(a1 + 69) == -30 )
    sub_2B840(a1);
}

//----- (0002B260) --------------------------------------------------------
char __cdecl sub_2B260(int a1)
{
  signed int v1; // eax
  __int16 v2; // dx
  unsigned __int16 *v3; // edx
  int v4; // edi
  unsigned int v5; // ecx
  int v6; // edx
  __int16 v7; // ax
  char v8; // dl
  unsigned __int16 v9; // di
  char v10; // al
  unsigned __int16 *v11; // edx
  int v12; // esi
  char v13; // al
  unsigned int v14; // ecx
  char v15; // cl
  signed __int16 v16; // ax
  char v17; // al
  unsigned __int16 v18; // cx
  unsigned __int16 *v19; // edx
  unsigned int v20; // esi
  int v21; // esi
  int v23; // [esp+0h] [ebp-1Ch]
  unsigned __int16 v24; // [esp+4h] [ebp-18h]
  unsigned __int16 *v25; // [esp+8h] [ebp-14h]
  char v26; // [esp+Ch] [ebp-10h]
  char v27; // [esp+10h] [ebp-Ch]
  char v28; // [esp+14h] [ebp-8h]
  char v29; // [esp+18h] [ebp-4h]

  v1 = sub_2B9A0(a1);
  if ( (unsigned int)v1 <= 1 )
  {
    LOBYTE(v1) = *(_BYTE *)(a1 + 70);
    switch ( (_BYTE)v1 )
    {
      case 0:
        sub_2B860(a1, 3u);
        LOBYTE(v1) = sub_2BA50(a1, 1u);
        return v1;
      case 1:
        sub_4A190(a1 + 76, 10, 5);
        LOBYTE(v1) = sub_2BA50(a1, 2u);
        return v1;
      case 2:
        LOBYTE(v1) = 0;
        v2 = *(_WORD *)(a1 + 150);
        v29 = 0;
        if ( v2 )
        {
          v3 = (unsigned __int16 *)dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
          v25 = v3;
          if ( (unsigned int)v3 > dword_EA3E4[0] && *((_DWORD *)v3 + 2) >= 0 && !(*((_BYTE *)v3 + 13) & 4) )
            LOBYTE(v1) = 1;
        }
        if ( !(_BYTE)v1 || (v4 = *(_DWORD *)(a1 + 16) - 1, *(_DWORD *)(a1 + 16) = v4, v4 <= 0) )
        {
          v29 = 1;
          goto LABEL_31;
        }
        v23 = *((_DWORD *)v25 + 19);
        v24 = v25[40];
        sub_57FA0(&v23, v25[14], 0, 768);
        if ( !(*(_BYTE *)(a1 + 62) & 3) )
          *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), &v23);
        if ( *(_BYTE *)(a1 + 62) & 3 )
          goto LABEL_22;
        v28 = 0;
        v5 = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403);
        while ( 2 )
        {
          if ( v5 > dword_EA3E4[0] )
          {
            if ( *(_WORD *)(v5 + 26) == *(_WORD *)(a1 + 26)
              || abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(v5 + 76)) >= (signed int)*(signed __int16 *)(a1 + 84)
              || abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(v5 + 78)) >= (signed int)*(signed __int16 *)(a1 + 84) )
            {
              v5 = *(_DWORD *)v5;
              continue;
            }
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(v5 + 76), (_WORD *)(a1 + 76));
            v28 = 1;
          }
          break;
        }
LABEL_22:
        v1 = sub_1B8C0(a1);
        if ( v1 == 3 )
        {
          LOBYTE(v1) = sub_2BA50(a1, 7u);
        }
        else if ( !(*(_BYTE *)(a1 + 62) & 3) && *(_DWORD *)(a1 + 16) < 14 )
        {
          v1 = sub_584D0((_WORD *)(a1 + 76), &v23);
          if ( v1 < 2768896 )
          {
            LOBYTE(v1) = sub_2B7E0(a1);
            if ( !(_BYTE)v1 )
              LOBYTE(v1) = sub_2BA50(a1, 3u);
          }
        }
LABEL_31:
        if ( v29 )
        {
          LOBYTE(v1) = sub_2B7E0(a1);
          if ( !(_BYTE)v1 )
            LOBYTE(v1) = sub_2BA50(a1, 3u);
        }
        return v1;
      case 3:
        sub_2BA50(a1, 4u);
        sub_2B860(a1, 2u);
        v6 = dword_D41A0 + 28302;
        *(_WORD *)(a1 + 48) = *(_WORD *)(a1 + 28);
        sub_6E450((a1 - v6) / 168, -1, 38);
        goto LABEL_35;
      case 4:
      case 5:
LABEL_35:
        if ( *(_DWORD *)(a1 + 16) <= 0 )
        {
          LOBYTE(v1) = sub_2BA50(a1, 6u);
          return v1;
        }
        v7 = *(_WORD *)(a1 + 48);
        *(_WORD *)(a1 + 28) = v7;
        v8 = *(_BYTE *)(a1 + 70);
        *(_WORD *)(a1 + 32) = v7;
        if ( v8 == 4 )
        {
          v9 = *(_WORD *)(a1 + 150);
          v10 = 0;
          if ( v9 )
          {
            v11 = (unsigned __int16 *)dword_EA3E4[v9];
            v25 = v11;
            if ( (unsigned int)v11 > dword_EA3E4[0] && *((_DWORD *)v11 + 2) >= 0 && !(*((_BYTE *)v11 + 13) & 4) )
              v10 = 1;
          }
          if ( v10 )
          {
            if ( !(*(_BYTE *)(a1 + 62) & 7) && sub_584D0((_WORD *)(a1 + 76), v25 + 38) > 802816 )
              *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), v25 + 38);
            v12 = *(_DWORD *)(a1 + 16);
            if ( *(signed __int16 *)(a1 + 44) - 3 > v12 && v12 > 3 && (unsigned __int16)sub_1CED0(a1, (int)v25) )
              *(_BYTE *)(a1 + 70) = 5;
          }
        }
        v13 = *(_BYTE *)(a1 + 62);
        --*(_DWORD *)(a1 + 16);
        if ( v13 & 3 )
          goto LABEL_58;
        v27 = 0;
        v14 = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403);
        break;
      case 6:
        sub_2B860(a1, 3u);
        sub_4A190(a1 + 76, 10, 5);
        v17 = 0;
        v18 = *(_WORD *)(a1 + 150);
        v26 = 0;
        if ( v18 )
        {
          v19 = (unsigned __int16 *)dword_EA3E4[v18];
          v25 = v19;
          if ( (unsigned int)v19 > dword_EA3E4[0] && *((_DWORD *)v19 + 2) >= 0 && !(*((_BYTE *)v19 + 13) & 4) )
            v17 = 1;
        }
        if ( v17 )
        {
          v20 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 28);
          if ( sub_583F0((_WORD *)(a1 + 76), v25 + 38) < v20 )
            v26 = 1;
        }
        if ( v26 )
          LOBYTE(v1) = sub_2BA50(a1, 2u);
        else
          LOBYTE(v1) = sub_2BA50(a1, 7u);
        return v1;
      case 7:
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 20) & 0x7FF;
        sub_2BA50(a1, 8u);
        goto LABEL_76;
      case 8:
LABEL_76:
        LOBYTE(v1) = sub_1B8C0(a1);
        v21 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v21;
        if ( v21 <= 0 )
          LOBYTE(v1) = sub_2BA50(a1, 9u);
        return v1;
      case 9:
        LOBYTE(v1) = sub_2B860(a1, 1u);
        *(_BYTE *)(a1 + 69) = -31;
        *(_WORD *)(a1 + 150) = 0;
        return v1;
      default:
        return v1;
    }
    while ( v14 > dword_EA3E4[0] )
    {
      if ( *(_WORD *)(v14 + 26) != *(_WORD *)(a1 + 26)
        && abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(v14 + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
        && abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(v14 + 78)) < (signed int)*(signed __int16 *)(a1 + 84) )
      {
        *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(v14 + 76), (_WORD *)(a1 + 76));
        v27 = 1;
        break;
      }
      v14 = *(_DWORD *)v14;
    }
LABEL_58:
    sub_1B8C0(a1);
    v15 = *(_BYTE *)(a1 + 16);
    *(_WORD *)(a1 + 48) = *(_WORD *)(a1 + 28);
    if ( v15 & 4 )
      v16 = 56;
    else
      v16 = -56;
    LOWORD(v1) = *(_WORD *)(a1 + 28) + v16;
    *(_WORD *)(a1 + 28) = v1;
    *(_BYTE *)(a1 + 29) &= 7u;
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002B750) --------------------------------------------------------
int __cdecl sub_2B750(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = -31;
  return result;
}

//----- (0002B760) --------------------------------------------------------
int __cdecl sub_2B760(int a1)
{
  return sub_1C890(a1, 224);
}

//----- (0002B780) --------------------------------------------------------
void __cdecl sub_2B780(int a1)
{
  sub_1C930(a1);
}

//----- (0002B7B0) --------------------------------------------------------
void __cdecl sub_2B7B0(int a1)
{
  sub_1D5D0(a1, 224);
  if ( *(_BYTE *)(a1 + 69) == -30 )
    sub_2B840(a1);
}

//----- (0002B7E0) --------------------------------------------------------
char __cdecl sub_2B7E0(int a1)
{
  unsigned int v1; // eax
  char v3; // bl

  v1 = *(_DWORD *)(dword_D41A4 + 38515);
  if ( v1 <= dword_EA3E4[0] )
    return 0;
  do
  {
    if ( v1 != a1 && *(_BYTE *)(v1 + 69) == -30 )
    {
      v3 = *(_BYTE *)(v1 + 70);
      if ( v3 == 3 || v3 == 4 || v3 == 5 )
        return 1;
    }
    v1 = *(_DWORD *)v1;
  }
  while ( v1 > dword_EA3E4[0] );
  return 0;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002B840) --------------------------------------------------------
int __cdecl sub_2B840(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = -30;
  *(_BYTE *)(a1 + 70) = 0;
  return result;
}

//----- (0002B860) --------------------------------------------------------
char __cdecl sub_2B860(int a1, unsigned __int8 a2)
{
  __int16 v2; // ax
  char v3; // ah
  char v4; // dh
  unsigned __int16 v5; // si
  char v6; // ch

  LOBYTE(v2) = a2;
  if ( a2 < 2u )
  {
    if ( a2 == 1 )
    {
      v3 = *(_BYTE *)(a1 + 12) & 0xF6;
      *(_DWORD *)(a1 + 160) = &unk_D8830;
      *(_BYTE *)(a1 + 12) = v3 | 8;
      sub_49CD0((_WORD *)a1, 292);
      sub_49EA0((_WORD *)a1, 85, 42);
      v2 = *(_WORD *)(a1 + 134);
      *(_WORD *)(a1 + 130) = v2;
    }
  }
  else if ( a2 <= 2u )
  {
    *(_DWORD *)(a1 + 160) = &unk_D8830;
    *(_WORD *)(a1 + 44) = 0;
    v4 = *(_BYTE *)(a1 + 12) & 0xF6;
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
    *(_BYTE *)(a1 + 12) = v4;
    v5 = word_DA506;
    *(_BYTE *)(a1 + 12) = v4 | 8;
    sub_49CD0((_WORD *)a1, 291);
    sub_49EA0((_WORD *)a1, 384, 768);
    LOBYTE(v2) = sub_71AB0(v5, 0);
    if ( dword_F66F0[v5] )
    {
      *(_DWORD *)(a1 + 16) = *(unsigned __int16 *)(sub_724F0(dword_E9C08, v5) + 16);
      v2 = *(_WORD *)(a1 + 16);
      *(_WORD *)(a1 + 44) = v2;
    }
  }
  else if ( a2 == 3 )
  {
    *(_BYTE *)(a1 + 57) = 0;
    *(_DWORD *)(a1 + 160) = &unk_D8852;
    v6 = *(_BYTE *)(a1 + 12) | 1;
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132) - 28;
    LOBYTE(v2) = v6 & 0xF7;
    *(_BYTE *)(a1 + 12) = v6 & 0xF7;
  }
  return v2;
}
// DA506: using guessed type __int16 word_DA506;
// E9C08: using guessed type int dword_E9C08;

//----- (0002B9A0) --------------------------------------------------------
signed int __cdecl sub_2B9A0(int a1)
{
  unsigned int v1; // edx
  __int16 v2; // dx
  int i; // ebx
  int v4; // ecx
  int v5; // ebx

  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    v1 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        v1 = 1;
        break;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v1 = 2;
  }
  if ( v1 >= 1 )
  {
    if ( v1 <= 1 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
    }
    else if ( v1 == 2 )
    {
      *(_BYTE *)(a1 + 69) = -28;
      return 2;
    }
  }
  return v1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002BA50) --------------------------------------------------------
unsigned __int8 __cdecl sub_2BA50(int a1, unsigned __int8 a2)
{
  unsigned __int8 result; // al

  result = a2;
  *(_BYTE *)(a1 + 70) = a2;
  if ( a2 < 2u )
    goto LABEL_10;
  if ( a2 <= 2u )
  {
    *(_DWORD *)(a1 + 16) = 32;
    return result;
  }
  if ( a2 == 8 )
    *(_DWORD *)(a1 + 16) = 16;
  else
LABEL_10:
    *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (0002BB40) --------------------------------------------------------
int __cdecl sub_2BB40(__int16 a1, __int16 a2, int a3)
{
  int (__cdecl *v3)(__int16, __int16, int); // eax
  int result; // eax
  int v5; // edi
  int (__cdecl *v6)(__int16, __int16, int); // [esp+0h] [ebp-4h]

  if ( word_180660 & 1 )
    v3 = sub_8F8B0;
  else
    v3 = sub_8F8E8;
  v6 = v3;
  v3(a1, a2, a3);
  result = dword_D41A0;
  if ( *(_BYTE *)(dword_D41A0 + 8592) == 1 )
  {
    v5 = dword_180628;
    dword_180628 = dword_E9C3C;
    result = v6(a1, a2, a3);
    dword_180628 = v5;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E9C3C: using guessed type int dword_E9C3C;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0002BBB0) --------------------------------------------------------
int __cdecl sub_2BBB0(__int16 a1, __int16 a2, int a3)
{
  int result; // eax
  int v4; // edi

  dword_F01EC(a1, a2, a3);
  result = dword_D41A0;
  if ( *(_BYTE *)(dword_D41A0 + 8592) == 1 )
  {
    v4 = dword_180628;
    dword_180628 = dword_E9C3C;
    result = dword_F01EC(a1, a2, a3);
    dword_180628 = v4;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E9C3C: using guessed type int dword_E9C3C;
// F01EC: using guessed type int (__cdecl *dword_F01EC)(_DWORD, _DWORD, _DWORD);
// 180628: using guessed type int dword_180628;

//----- (0002BC10) --------------------------------------------------------
int __cdecl sub_2BC10(_BYTE *a1, __int16 a2, __int16 a3, unsigned __int8 a4)
{
  int result; // eax
  int v5; // ST10_4

  sub_6F940(a1, a2, a3, a4);
  result = dword_D41A0;
  if ( *(_BYTE *)(dword_D41A0 + 8592) == 1 )
  {
    v5 = dword_180628;
    dword_180628 = dword_E9C3C;
    sub_6F940(a1, a2, a3, a4);
    result = v5;
    dword_180628 = v5;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E9C3C: using guessed type int dword_E9C3C;
// 180628: using guessed type int dword_180628;

//----- (0002BC80) --------------------------------------------------------
int __cdecl sub_2BC80(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5)
{
  void *v5; // ebx
  int result; // eax
  int v7; // ST14_4

  if ( word_180660 & 1 )
    v5 = sub_90164;
  else
    v5 = sub_901E4;
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v5)(a1, a2, a3, a4, a5);
  result = dword_D41A0;
  if ( *(_BYTE *)(dword_D41A0 + 8592) == 1 )
  {
    v7 = dword_180628;
    dword_180628 = dword_E9C3C;
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v5)(a1, a2, a3, a4, a5);
    result = v7;
    dword_180628 = v7;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E9C3C: using guessed type int dword_E9C3C;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0002BD10) --------------------------------------------------------
int __cdecl sub_2BD10(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5)
{
  void *v5; // ebx
  int result; // eax
  int v7; // ST14_4

  if ( word_180660 & 1 )
    v5 = sub_BD524;
  else
    v5 = sub_BD542;
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v5)(a1, a2, a3, a4, a5);
  result = dword_D41A0;
  if ( *(_BYTE *)(dword_D41A0 + 8592) == 1 )
  {
    v7 = dword_180628;
    dword_180628 = dword_E9C3C;
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v5)(a1, a2, a3, a4, a5);
    result = v7;
    dword_180628 = v7;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E9C3C: using guessed type int dword_E9C3C;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0002BE30) --------------------------------------------------------
int sub_2BE30()
{
  char v0; // dl
  int (__cdecl *v1)(__int16, __int16, int); // eax
  char v2; // bh
  int v3; // esi
  char v4; // dl
  int v5; // ebx
  signed int v6; // edi
  __int16 v7; // bx
  int v8; // ebx
  int v9; // edx
  int v10; // eax
  int v11; // edi
  int v12; // ebx
  unsigned __int8 v13; // al
  signed int v14; // edi
  int v15; // edx
  int v16; // eax
  int v17; // esi
  int v18; // esi
  int v19; // edx
  int v20; // eax
  int v21; // esi
  unsigned __int16 v22; // dx
  int v23; // eax
  int v24; // esi
  int v25; // esi
  int v26; // ecx
  int v27; // eax
  signed int v28; // esi
  int v29; // ebx
  __int16 v30; // di
  signed int v31; // esi
  int v33; // eax
  unsigned __int16 v34; // cx
  int v35; // [esp+8h] [ebp-18h]
  signed __int16 v36; // [esp+Ch] [ebp-14h]
  signed __int16 v37; // [esp+10h] [ebp-10h]
  signed __int16 v38; // [esp+14h] [ebp-Ch]
  signed __int16 v39; // [esp+18h] [ebp-8h]
  __int16 v40; // [esp+1Ch] [ebp-4h]

  v0 = *(_BYTE *)(dword_D41A4 + 22);
  dword_D41C8 = 0;
  if ( *(_BYTE *)(dword_D41A0 + 8600) )
  {
    if ( word_180660 & 1 )
      v1 = sub_8F8B0;
    else
      v1 = sub_8F8E8;
    dword_F01E8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))v1;
  }
  else
  {
    dword_F01E8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))sub_2DE80;
  }
  dword_F01EC = dword_F01E8;
  v2 = *(_BYTE *)(dword_D41A4 + 10);
  dword_F01E8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))sub_2BBB0;
  if ( v2 )
    sub_88580();
  switch ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) )
  {
    case 0:
    case 3:
    case 5:
    case 9:
    case 0xA:
    case 0xD:
      v3 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
      if ( byte_D41C4 || *(char *)(dword_D41A0 + 8589) != (unsigned __int8)byte_D41C6 )
      {
        v4 = *(_BYTE *)(dword_D41A0 + 8589);
        byte_D41C4 = 0;
        byte_D41C6 = v4;
        if ( v4 < 40 )
        {
          if ( word_180660 & 1 )
            sub_72883((unsigned __int8)byte_EB3A8, (void *)dword_180628, 0xC8u, byte_EB3A8);
          else
            sub_728A9(dword_180628, (void *)dword_180628, 0x1E0u, byte_EB3A8);
        }
      }
      if ( *(_BYTE *)(dword_D41A0 + 8589) < 40 )
      {
        if ( word_180660 & 1 )
          sub_72883((unsigned __int8)byte_EB3A8, (void *)dword_180628, 0xC8u, byte_EB3A8);
        else
          sub_728A9((unsigned __int8)byte_EB3A8, (void *)dword_180628, 0x1E0u, byte_EB3A8);
      }
      sub_40C50(*(char *)(dword_D41A0 + 8589));
      v5 = dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12);
      v6 = *(unsigned __int16 *)(v5 + 11244);
      sub_411A0(
        dword_180628,
        *(signed __int16 *)(v5 + 14 * (unsigned __int16)v6 + 11709),
        *(signed __int16 *)(v5 + 14 * (unsigned __int16)v6 + 11711),
        *(_WORD *)(v5 + 14 * (unsigned __int16)v6 + 11715),
        *(signed __int16 *)(v5 + 14 * (unsigned __int16)v6 + 11713) + 128,
        *(signed __int16 *)(v5 + 14 * (unsigned __int16)v6 + 11717),
        *(_WORD *)(v5 + 14 * (unsigned __int16)v6 + 11719),
        *(signed __int16 *)(v5 + 14 * (unsigned __int16)v6 + 11721));
      if ( *(_DWORD *)(v3 + 8) < 0 )
      {
        v13 = *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221);
        if ( v13 < 0xAu )
        {
          if ( v13 == 9 )
          {
            sub_30050();
            break;
          }
        }
        else if ( v13 <= 0xAu )
        {
          sub_303D0(v6);
        }
        else if ( v13 == 13 )
        {
          sub_30A60(6, 6);
          break;
        }
        sub_2FD90();
      }
      else
      {
        if ( dword_D4188 && *(_BYTE *)(*(_DWORD *)(v3 + 164) + 334) )
        {
          if ( word_180660 & 1 )
          {
            v39 = 2;
            v37 = 4;
          }
          else
          {
            v39 = 4;
            v37 = 6;
          }
          v6 = 1;
          v38 = 0;
          v40 = 0;
          v7 = *(unsigned __int8 *)(dword_D418C + 11);
          while ( v38 < v39 )
          {
            v36 = 0;
            v35 = 0;
            while ( v36 < v37 )
            {
              v8 = 6 * v6;
              sub_2BB40(v35, v40, 6 * v6 + dword_D418C);
              ++v36;
              ++v6;
              v35 += *(unsigned __int8 *)(v8 + dword_D418C + 4);
              v7 = *(unsigned __int8 *)(dword_D418C + 11);
            }
            ++v38;
            v40 += v7;
          }
        }
        if ( *(_BYTE *)(dword_D41A0 + 8590) )
        {
          v9 = dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12);
          v10 = v9 + 14 * *(unsigned __int16 *)(v9 + 11244);
          sub_63600(
            0,
            0,
            *(signed __int16 *)(v10 + 11709),
            *(signed __int16 *)(v10 + 11711),
            128,
            128,
            *(_WORD *)(v10 + 11715),
            256,
            dword_180648 - 2 * (dword_180648 / 5u),
            0);
          v11 = 2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0;
          sub_61880(
            0,
            0,
            *(_WORD *)(v11 + 14 * *(unsigned __int16 *)(v11 + 11244) + 11709),
            *(_WORD *)(v11 + 14 * *(unsigned __int16 *)(v11 + 11244) + 11711),
            128,
            128,
            *(_WORD *)(v11 + 14 * *(unsigned __int16 *)(v11 + 11244) + 11715),
            256);
          v12 = dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12);
          v6 = 256;
          sub_644F0(
            0,
            0,
            *(_WORD *)(v12 + 14 * *(unsigned __int16 *)(v12 + 11244) + 11709),
            *(_WORD *)(v12 + 14 * *(unsigned __int16 *)(v12 + 11244) + 11711),
            128,
            128,
            *(_WORD *)(v12 + 14 * *(unsigned __int16 *)(v12 + 11244) + 11715),
            256);
        }
        sub_6FC50(byte_D419D);
        if ( *(_BYTE *)(dword_D41A0 + 8591) )
        {
          sub_2E260(
            510,
            2,
            dword_EA3E4[*(signed __int16 *)(*(_DWORD *)(v3 + 164)
                                          + 2 * *(signed __int16 *)(*(_DWORD *)(v3 + 164) + 1105)
                                          + 819)],
            0);
          sub_2E260(
            574,
            2,
            dword_EA3E4[*(signed __int16 *)(*(_DWORD *)(v3 + 164)
                                          + 2 * *(signed __int16 *)(*(_DWORD *)(v3 + 164) + 1107)
                                          + 819)],
            0);
          sub_2D710(v3);
        }
        switch ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) )
        {
          case 3:
            sub_2F6B0();
            goto LABEL_41;
          case 9:
            sub_30050();
            break;
          case 0xA:
            sub_303D0(v6);
            goto LABEL_41;
          case 0xD:
            sub_30A60(132, 50);
            break;
          default:
LABEL_41:
            sub_2FD90();
            break;
        }
        sub_2CE30(132, 50);
        if ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) == 5 )
          sub_2ECC0();
      }
      break;
    case 6:
    case 7:
    case 8:
    case 0xB:
    case 0xC:
    case 0xE:
      v14 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
      if ( word_180660 & 1 )
        sub_72883((unsigned __int8)byte_EB3A8, (void *)dword_180628, 0xC8u, byte_EB3A8);
      else
        sub_728A9((unsigned __int8)byte_EB3A8, (void *)dword_180628, 0x1E0u, byte_EB3A8);
      if ( word_180660 == 1 )
      {
        v15 = dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12);
        v16 = v15 + 14 * *(unsigned __int16 *)(v15 + 11244);
        sub_63600(
          0,
          0,
          *(signed __int16 *)(v16 + 11709),
          *(signed __int16 *)(v16 + 11711),
          382,
          400,
          *(_WORD *)(v16 + 11715),
          204,
          dword_180648 - 192,
          1);
        v17 = dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12);
        sub_61880(
          0,
          0,
          *(_WORD *)(v17 + 14 * *(unsigned __int16 *)(v17 + 11244) + 11709),
          *(_WORD *)(v17 + 14 * *(unsigned __int16 *)(v17 + 11244) + 11711),
          382,
          400,
          *(_WORD *)(v17 + 14 * *(unsigned __int16 *)(v17 + 11244) + 11715),
          204);
      }
      else
      {
        v18 = dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12);
        sub_63600(
          0,
          0,
          *(signed __int16 *)(v18 + 14 * *(unsigned __int16 *)(v18 + 11244) + 11709),
          *(signed __int16 *)(v18 + 14 * *(unsigned __int16 *)(v18 + 11244) + 11711),
          382,
          400,
          *(_WORD *)(v18 + 14 * *(unsigned __int16 *)(v18 + 11244) + 11715),
          204,
          dword_180648 - 192,
          1);
        v19 = dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12);
        v20 = v19 + 14 * *(unsigned __int16 *)(v19 + 11244);
        sub_61880(0, 0, *(_WORD *)(v20 + 11709), *(_WORD *)(v20 + 11711), 382, 400, *(_WORD *)(v20 + 11715), 204);
      }
      sub_40BF0(384, 0, 256, 400);
      v21 = dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12);
      v22 = *(_WORD *)(v21 + 11244);
      sub_411A0(
        dword_180628,
        *(signed __int16 *)(v21 + 14 * v22 + 11709),
        *(signed __int16 *)(v21 + 14 * v22 + 11711),
        *(_WORD *)(v21 + 14 * v22 + 11715),
        *(signed __int16 *)(v21 + 14 * v22 + 11713) + 128,
        *(signed __int16 *)(v21 + 14 * v22 + 11717),
        *(_WORD *)(v21 + 14 * v22 + 11719),
        *(signed __int16 *)(v21 + 14 * v22 + 11721));
      if ( word_180660 & 1 )
        sub_9025C(384, 0, 384, 400, (unsigned __int8)byte_E8900[0], 0);
      else
        sub_90374(384, 0, 384, 400, (unsigned __int8)byte_E8900[0], 0);
      if ( word_180660 & 1 )
        sub_9025C(382, 0, 382, 400, (unsigned __int8)byte_E8900[0], 0);
      else
        sub_90374(382, 0, 382, 400, (unsigned __int8)byte_E8900[0], 0);
      sub_40C50(*(char *)(dword_D41A0 + 8589));
      if ( word_180660 == 1 )
      {
        v23 = dword_D41A0;
        v24 = 2124 * *(signed __int16 *)(dword_D41A0 + 12);
      }
      else
      {
        v24 = dword_D41A0;
        v23 = 2124 * *(signed __int16 *)(dword_D41A0 + 12);
      }
      v25 = v23 + v24;
      sub_644F0(
        0,
        0,
        *(_WORD *)(v25 + 14 * *(unsigned __int16 *)(v25 + 11244) + 11709),
        *(_WORD *)(v25 + 14 * *(unsigned __int16 *)(v25 + 11244) + 11711),
        382,
        400,
        *(_WORD *)(v25 + 14 * *(unsigned __int16 *)(v25 + 11244) + 11715),
        204);
      switch ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) )
      {
        case 7:
          sub_2D1D0();
          break;
        case 8:
          sub_2FD90();
          sub_2ECC0();
          break;
        case 0xB:
          sub_30050();
          break;
        case 0xC:
          sub_303D0(v14);
          goto LABEL_73;
        case 0xE:
          sub_30A60(6, 6);
          break;
        default:
LABEL_73:
          sub_2FD90();
          break;
      }
      sub_2CE30(6, 6);
      if ( *(_BYTE *)(dword_D41A4 + 38400) )
        sub_2E260(
          510,
          2,
          dword_EA3E4[*(signed __int16 *)(*(_DWORD *)(v14 + 164)
                                        + 2 * *(signed __int16 *)(*(_DWORD *)(v14 + 164) + 1105)
                                        + 819)],
          0);
      if ( *(_BYTE *)(dword_D41A4 + 38401) )
        sub_2E260(
          574,
          2,
          dword_EA3E4[*(signed __int16 *)(*(_DWORD *)(v14 + 164)
                                        + 2 * *(signed __int16 *)(*(_DWORD *)(v14 + 164) + 1107)
                                        + 819)],
          0);
      break;
    default:
      break;
  }
  if ( *((_BYTE *)&loc_36E03 + dword_D41A0 + 1) )
    sub_30630();
  sub_6FC50(byte_D419D);
  if ( !(*(_BYTE *)(dword_D41A4 + 22) & 4) )
    return _wcpp_1_unwind_leave__62();
  if ( *(_BYTE *)(dword_D41A4 + 204) == 3 )
  {
    v26 = *(_DWORD *)(dword_D41A4 + 210);
    if ( v26 <= 0 )
      *(_BYTE *)(dword_D41A4 + 204) = 2;
    else
      *(_DWORD *)(dword_D41A4 + 210) = v26 - 1;
  }
  v27 = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 204) == 2 )
  {
    *(_BYTE *)(dword_D41A4 + 204) = 1;
    *(_WORD *)(v27 + 214) = 0;
    *(_DWORD *)(v27 + 210) = 50;
  }
  if ( *(_BYTE *)(dword_D41A4 + 204) != 1 )
    return _wcpp_1_unwind_leave__62();
  if ( *(_DWORD *)(dword_D41A4 + 210) <= 0 )
  {
    while ( 1 )
    {
      v33 = dword_D41A4;
      if ( *off_DB558[*(unsigned __int16 *)(dword_D41A4 + 214)] == 33 )
        break;
      ++*(_WORD *)(dword_D41A4 + 214);
    }
    v34 = *(_WORD *)(dword_D41A4 + 214) + 1;
    *(_WORD *)(dword_D41A4 + 214) = v34;
    if ( *off_DB558[v34] == 35 )
    {
      *(_BYTE *)(v33 + 204) = 3;
      *(_DWORD *)(v33 + 210) = 200;
      return _wcpp_1_unwind_leave__62();
    }
    *(_DWORD *)(v33 + 210) = 50;
    return _wcpp_1_unwind_leave__62();
  }
  v28 = 380;
  v29 = 0;
  while ( *off_DB558[v29 + *(unsigned __int16 *)(dword_D41A4 + 214)] != 33 )
  {
    ++v29;
    v28 -= sub_6FC30();
  }
  v30 = 0;
  v31 = 8;
  while ( v29 > 0 )
  {
    if ( v30 )
      sub_2BC10(off_DB558[v30 + *(unsigned __int16 *)(dword_D41A4 + 214)], 8, v31, byte_E8900[0]);
    else
      sub_2BC10(off_DB558[*(unsigned __int16 *)(dword_D41A4 + 214)], 8, v31, byte_E98FF);
    --v29;
    ++v30;
    v31 += sub_6FC30();
  }
  --*(_DWORD *)(dword_D41A4 + 210);
  return _wcpp_1_unwind_leave__62();
}
// 2BB30: using guessed type int _wcpp_1_unwind_leave__62(void);
// D4188: using guessed type int dword_D4188;
// D418C: using guessed type int dword_D418C;
// D419D: using guessed type char byte_D419D;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41C4: using guessed type char byte_D41C4;
// D41C6: using guessed type char byte_D41C6;
// D41C8: using guessed type int dword_D41C8;
// DB558: using guessed type char *off_DB558[3];
// E98FF: using guessed type char byte_E98FF;
// EA3E4: using guessed type int dword_EA3E4[];
// EB3A8: using guessed type char byte_EB3A8;
// F01E8: using guessed type int (__cdecl *dword_F01E8)(_DWORD, _DWORD, _DWORD);
// F01EC: using guessed type int (__cdecl *dword_F01EC)(_DWORD, _DWORD, _DWORD);
// 180628: using guessed type int dword_180628;
// 180648: using guessed type int dword_180648;
// 180660: using guessed type __int16 word_180660;

//----- (0002CA60) --------------------------------------------------------
int __cdecl sub_2CA60(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  int result; // eax

  dword_EA3D0 = a1;
  dword_EA3CC = a2;
  dword_EA3C4 = a3;
  result = a4;
  dword_EA3C0 = a4;
  return result;
}
// EA3C0: using guessed type int dword_EA3C0;
// EA3C4: using guessed type int dword_EA3C4;
// EA3CC: using guessed type int dword_EA3CC;
// EA3D0: using guessed type int dword_EA3D0;

//----- (0002CA90) --------------------------------------------------------
int __cdecl sub_2CA90(__int16 a1)
{
  int v1; // eax
  int result; // eax
  int v3; // esi
  int v4; // ecx

  v1 = 40 - a1;
  dword_EA3D0 = 8 * v1;
  dword_EA3C4 = 16 * a1;
  if ( word_180660 & 1 )
  {
    result = 5 * v1 / 2;
    v3 = 10 * a1;
    v4 = 2 * result;
  }
  else
  {
    result = 12 * v1 / 2;
    v3 = 12 * a1;
    v4 = result;
  }
  dword_EA3C0 = v3;
  dword_EA3CC = v4;
  return result;
}
// EA3C0: using guessed type int dword_EA3C0;
// EA3C4: using guessed type int dword_EA3C4;
// EA3CC: using guessed type int dword_EA3CC;
// EA3D0: using guessed type int dword_EA3D0;
// 180660: using guessed type __int16 word_180660;

//----- (0002CB30) --------------------------------------------------------
__int16 __cdecl sub_2CB30(_DWORD *a1, __int16 a2, int a3, __int16 a4)
{
  char *v4; // edi
  char *v5; // esi
  char v6; // al
  char v7; // al
  int v8; // esi
  int v9; // eax
  __int16 v10; // bx
  __int16 v11; // bx
  int v12; // edi
  int v13; // esi
  unsigned __int8 v14; // ST10_1
  unsigned __int8 v15; // ST10_1
  unsigned __int8 v16; // ST10_1
  unsigned __int8 v17; // ST10_1
  unsigned __int8 v18; // ST10_1
  unsigned __int8 v19; // ST10_1
  char *v21; // [esp-4h] [ebp-5Ch]
  unsigned __int8 v22; // [esp-4h] [ebp-5Ch]
  unsigned __int8 v23; // [esp-4h] [ebp-5Ch]
  char v24[32]; // [esp+0h] [ebp-58h]
  int v25; // [esp+20h] [ebp-38h]
  int v26; // [esp+24h] [ebp-34h]
  int v27; // [esp+28h] [ebp-30h]
  int v28; // [esp+2Ch] [ebp-2Ch]
  int v29; // [esp+30h] [ebp-28h]
  int v30; // [esp+34h] [ebp-24h]
  int v31; // [esp+38h] [ebp-20h]
  int v32; // [esp+3Ch] [ebp-1Ch]
  unsigned __int8 v33; // [esp+40h] [ebp-18h]
  char v34; // [esp+44h] [ebp-14h]
  char v35; // [esp+48h] [ebp-10h]
  char v36; // [esp+4Ch] [ebp-Ch]
  char v37; // [esp+50h] [ebp-8h]
  unsigned __int8 v38; // [esp+54h] [ebp-4h]
  int v39; // [esp+74h] [ebp+1Ch]

  v31 = dword_EA3C4 + dword_EA3D0 - 4;
  v29 = dword_EA3C0 + dword_EA3CC - 22;
  v25 = *(signed __int16 *)(a1[41] + 56);
  v4 = v24;
  v5 = (char *)(2124 * v25 + dword_D41A0 + 11230 + 927);
  v21 = v24;
  do
  {
    v6 = *v5;
    *v4 = *v5;
    if ( !v6 )
      break;
    v7 = v5[1];
    v5 += 2;
    v4[1] = v7;
    v4 += 2;
  }
  while ( v7 );
  v36 = byte_E88E0[3 * sub_61790(v25)];
  v35 = byte_E8900[0];
  v34 = byte_E88E0[3 * sub_61790(v25)];
  v8 = 5 * *((unsigned __int8 *)&loc_2FED1 + dword_D41A0 + 3);
  v33 = byte_D94F2[v8];
  v38 = byte_D94F3[v8];
  v37 = byte_D94F0[v8];
  v9 = a4 >> 1;
  v10 = v9 + a2;
  if ( word_180660 & 1 )
  {
    v10 *= 2;
    a3 *= 2;
  }
  LOWORD(v9) = dword_EA3CC;
  v11 = dword_EA3D0 + v10;
  v12 = v9 + a3 - 20;
  v39 = v9 + a3 - 20;
  if ( v11 >= dword_EA3D0 )
  {
    LOWORD(v9) = v12;
    if ( (signed __int16)v12 >= dword_EA3CC && v11 < v31 && (signed __int16)v12 < v29 )
    {
      v9 = strlen(v24);
      v13 = 8 * v9 + 4;
      if ( v11 + v13 > v31 )
      {
        v13 = v31 - v11;
        v9 = (v31 - v11 - 4 - (__CFSHL__((v31 - v11 - 4) >> 31, 3) + 8 * ((v31 - v11 - 4) >> 31))) >> 3;
      }
      if ( v9 > 0 )
      {
        v24[v9] = 0;
        v32 = v13 + 2;
        v26 = (signed __int16)(v13 + 2);
        v30 = v11;
        sub_2BC80(v11, v39, v13 + 2, 18, v22);
        v27 = v33;
        sub_2BC80(v30, v39, v26, 2, v14);
        v28 = v38;
        sub_2BC80(v30, v39 + 16, v26, 2, v15);
        sub_2BC80(v30, v39, 2, 16, v16);
        sub_2BC80(v11 + v32 - 2, v39, 2, 18, v17);
        sub_2BC10(v24, v11 + 4, v39, v18);
        sub_2BC80(v11 + 2, v39 + 14, v13 - 2, 2, v19);
        LOWORD(v9) = (_WORD)a1;
        if ( a1[1] )
        {
          v9 = a1[2] * (v13 - 2) / a1[1];
          if ( v30 + 2 + v9 > v31 - 2 )
            v9 = v31 - 2 - (v30 + 2);
          if ( v9 > 0 )
            LOWORD(v9) = sub_2BC80(v11 + 2, v39 + 14, v9, 2, v23);
        }
      }
    }
  }
  return v9;
}
// D41A0: using guessed type int dword_D41A0;
// EA3C0: using guessed type int dword_EA3C0;
// EA3C4: using guessed type int dword_EA3C4;
// EA3CC: using guessed type int dword_EA3CC;
// EA3D0: using guessed type int dword_EA3D0;
// 180660: using guessed type __int16 word_180660;
// 2CB30: using guessed type char var_58[32];

//----- (0002CE30) --------------------------------------------------------
int __cdecl sub_2CE30(int a1, int a2)
{
  int v2; // esi
  int result; // eax
  unsigned int v4; // edi
  unsigned __int8 v5; // bl
  int v6; // eax
  int v7; // ebx
  unsigned __int16 v8; // ax
  __int16 v9; // ax
  int v10; // eax
  __int16 v11; // ax
  int v12; // eax
  __int16 v13; // ax
  __int64 v14; // rax
  unsigned __int8 v15; // al
  int v16; // eax
  __int16 v17; // ax
  __int64 v18; // rax
  int v19; // eax
  char v20; // [esp+0h] [ebp-Eh]
  int v21; // [esp+80h] [ebp+72h]
  int v22; // [esp+84h] [ebp+76h]

  v2 = a2;
  sub_6FC50(byte_D419D);
  result = dword_D41A4;
  LOWORD(v4) = a1;
  v5 = byte_E9800;
  if ( !*(_BYTE *)(dword_D41A4 + 205) && !*(_BYTE *)(dword_D41A4 + 38546) )
  {
    if ( *(_BYTE *)(dword_D41A4 + 24) & 1 )
    {
      sub_2BC10((_BYTE *)dword_EA2F0, a1, a2, byte_E89F0);
      v4 = 8 * (strlen((const char *)dword_EA2F0) + 2) + a1;
    }
    if ( !(*(_BYTE *)(dword_D41A4 + 22) & 0x20) && byte_3659C[11 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0] )
    {
      sprintf(&v20, aSS_0, dword_EA234, dword_EA238);
      sub_2BC10(&v20, v4, a2, v5);
      LOWORD(v4) = a1;
      LOWORD(v6) = sub_6FC30();
      v2 = v6 + a2;
    }
    v22 = 0;
    v7 = dword_D41A0 + 11230;
    while ( 1 )
    {
      result = dword_D41A0;
      if ( (unsigned __int16)v22 >= *(_WORD *)(dword_D41A0 + 14) )
        break;
      v8 = *(_WORD *)(v7 + 79) - 1;
      if ( v8 <= 4u )
      {
        v21 = v7 + 28;
        switch ( v8 )
        {
          case 0u:
            v9 = *(_WORD *)(v7 + 77);
            *(_WORD *)(v7 + 77) = v9 - 1;
            if ( v9 <= 0 )
              goto LABEL_24;
            sprintf(&v20, aSS_1, v7 + 927, v7 + 28);
            sub_2BC10(&v20, v4, v2, byte_E9800);
            LOWORD(v4) = a1;
            LOWORD(v10) = sub_6FC30();
            v2 += v10;
            break;
          case 1u:
            v13 = *(_WORD *)(v7 + 77);
            *(_WORD *)(v7 + 77) = v13 - 1;
            if ( v13 <= 0 )
              goto LABEL_24;
            sprintf(&v20, aSS_2, v7 + 927, v21);
            if ( *(_WORD *)(v7 + 77) <= 100 )
            {
              v15 = byte_E9800;
            }
            else
            {
              v14 = 4080 * *(unsigned __int8 *)(dword_D41A4 + 123);
              v15 = byte_E8900[256 * ((signed int)(v14 - (__CFSHL__(HIDWORD(v14), 8) + (HIDWORD(v14) << 8))) >> 8)];
            }
            sub_2BC10(&v20, v4, v2, v15);
            LOWORD(v16) = sub_6FC30();
            LOWORD(v4) = a1;
            v2 += v16;
            break;
          case 2u:
          case 4u:
            v11 = *(_WORD *)(v7 + 77);
            *(_WORD *)(v7 + 77) = v11 - 1;
            if ( v11 <= 0 )
              goto LABEL_24;
            if ( *(_WORD *)(v7 + 79) == 3 || (unsigned __int16)v22 == *(signed __int16 *)(dword_D41A0 + 12) )
            {
              sprintf(&v20, &aYS[2], v7 + 28);
              sub_2BC10(&v20, v4, v2, byte_E9800);
              LOWORD(v4) = a1;
              LOWORD(v12) = sub_6FC30();
              v2 += v12;
            }
            break;
          case 3u:
            v17 = *(_WORD *)(v7 + 77);
            *(_WORD *)(v7 + 77) = v17 - 1;
            if ( v17 <= 0 )
            {
LABEL_24:
              *(_WORD *)(v7 + 79) = 0;
            }
            else
            {
              sprintf(&v20, aSS_2, v7 + 927, v21);
              v18 = 4080 * *(unsigned __int8 *)(dword_D41A4 + 123);
              sub_2BC10(
                &v20,
                v4,
                v2,
                byte_E8900[16 * ((signed int)(v18 - (__CFSHL__(HIDWORD(v18), 8) + (HIDWORD(v18) << 8))) >> 8)]);
              LOWORD(v4) = a1;
              LOWORD(v19) = sub_6FC30();
              v2 += v19;
            }
            break;
        }
      }
      v7 += 2124;
      ++v22;
    }
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D419D: using guessed type char byte_D419D;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E89F0: using guessed type char byte_E89F0;
// E9800: using guessed type char byte_E9800;
// EA234: using guessed type int dword_EA234;
// EA238: using guessed type int dword_EA238;
// EA2F0: using guessed type int dword_EA2F0;

//----- (0002D190) --------------------------------------------------------
int __cdecl sub_2D190(__int16 a1, __int16 a2, int a3, __int16 a4, int a5, unsigned __int8 a6)
{
  int result; // eax

  result = a5;
  if ( a5 >= a3 )
    result = a3;
  if ( result >= 2 )
    result = sub_2BC80(a1, a2, result, a4, a6);
  return result;
}

//----- (0002D1D0) --------------------------------------------------------
int sub_2D1D0()
{
  signed int v0; // esi
  int v1; // eax
  int v2; // edx
  int v3; // ebx
  signed int v4; // edx
  int v5; // ebx
  char v6; // cl
  int v7; // edi
  unsigned __int8 v8; // si
  unsigned __int8 v9; // ST10_1
  int v10; // esi
  int v11; // eax
  int v12; // edi
  int v13; // eax
  int v14; // esi
  signed int v15; // eax
  unsigned __int16 v16; // cx
  signed int j; // esi
  int v18; // eax
  int v19; // eax
  int result; // eax
  char v21; // [esp+0h] [ebp-124h]
  int v22; // [esp+100h] [ebp-24h]
  int v23; // [esp+104h] [ebp-20h]
  int i; // [esp+108h] [ebp-1Ch]
  int v25; // [esp+10Ch] [ebp-18h]
  int v26; // [esp+110h] [ebp-14h]
  int v27; // [esp+114h] [ebp-10h]
  int v28; // [esp+118h] [ebp-Ch]
  unsigned __int8 v29; // [esp+11Ch] [ebp-8h]
  unsigned __int8 v30; // [esp+120h] [ebp-4h]

  v0 = 0;
  sub_6FC50(byte_D419D);
  v1 = 0;
  v2 = dword_D41A0 + 11230;
  while ( v0 < *(unsigned __int16 *)(dword_D41A0 + 14) )
  {
    if ( *(_BYTE *)(v2 + 6) )
      ++v1;
    ++v0;
    v2 += 2124;
  }
  v3 = v1 * *(unsigned __int8 *)(dword_EA3DC + 515);
  v28 = (640 - (v1 * *(unsigned __int8 *)(dword_EA3DC + 520) + *(unsigned __int8 *)(dword_EA3DC + 514))) / 2;
  if ( word_180660 == 1 )
    v4 = 400;
  else
    v4 = 480;
  v5 = (v4 - v3) / 2;
  v25 = 0;
  for ( i = dword_D41A0 + 11230; ; i += 2124 )
  {
    result = *(unsigned __int16 *)(dword_D41A0 + 14);
    if ( result <= v25 )
      break;
    v6 = *(_BYTE *)(i + 6);
    v23 = dword_EA3E4[*(unsigned __int16 *)(i + 10)];
    if ( v6 == 1 )
    {
      v29 = byte_E88E1[3 * sub_61790(v25)];
      v30 = byte_E88E0[3 * sub_61790(v25)];
      v7 = v28;
      sub_2BB40(v28, v5, dword_EA3DC + 510);
      sub_2BC80(
        v7 + 4,
        v5 + 4,
        *(unsigned __int8 *)(dword_EA3DC + 514) - 8,
        *(unsigned __int8 *)(dword_EA3DC + 515) - 8,
        v30);
      v8 = v29;
      v22 = (signed __int16)(v7 + 8);
      sub_2BC10((_BYTE *)(i + 927), v7 + 8, v5 + 6, v29);
      sprintf(&v21, aD, *(_DWORD *)(v23 + 140));
      v9 = v8;
      v10 = v25;
      sub_2BC10(&v21, v22, v5 + 20, v9);
      if ( !v10 && *(_BYTE *)(dword_D41A4 + 10) )
      {
        word_180546 = v7 + 20;
        word_180548 = v5 + 30;
      }
      HIWORD(v11) = HIWORD(dword_EA3DC);
      LOWORD(v11) = *(unsigned __int8 *)(dword_EA3DC + 514);
      v12 = v11 + v7;
      if ( *(_BYTE *)(dword_D41A4 + 10) && *(_WORD *)(dword_D41A0 + 14) > 1u && !byte_180558 )
      {
        dword_180532 = 9377 * dword_180532 + 9439;
        v13 = *(_DWORD *)(dword_D41A4 + 26) & 0xFF;
        byte_180558 = dword_180532 % (unsigned int)*(unsigned __int16 *)(dword_D41A0 + 14) + 1;
        v14 = v13 + dword_180532;
        v15 = 1;
        dword_180532 = v14;
        while ( v15 < 8 && !*(_BYTE *)(dword_D41A0 + 2124 * v15 + 11236) )
        {
          v16 = *(_WORD *)(dword_D41A0 + 14);
          if ( (unsigned __int8)++byte_180558 >= (signed int)v16 )
            byte_180558 = 1;
          ++v15;
        }
        if ( !*(_BYTE *)(dword_D41A0 + 2124 * (unsigned __int8)byte_180558 + 11236) )
          byte_180558 = 0;
      }
      for ( j = 0; j < 8; ++j )
      {
        if ( *(_BYTE *)(dword_D41A0 + 2124 * j + 11236) == 1 )
        {
          v27 = v12 + 4;
          v26 = v5 + 4;
          if ( j == v25 )
          {
            sub_2BB40(v12, v5, dword_EA3DC + 516);
            sub_2BC80(
              v27,
              v26,
              *(unsigned __int8 *)(dword_EA3DC + 520) - 8,
              *(unsigned __int8 *)(dword_EA3DC + 521) - 8,
              byte_E8900[0]);
          }
          else
          {
            v29 = byte_E88E1[3 * sub_61790(j)];
            v30 = byte_E88E0[3 * sub_61790(j)];
            sub_2BB40(v12, v5, dword_EA3DC + 516);
            sub_2BC80(
              v27,
              v26,
              *(unsigned __int8 *)(dword_EA3DC + 520) - 8,
              *(unsigned __int8 *)(dword_EA3DC + 521) - 8,
              v30);
            sprintf(&v21, a03d, *(signed __int16 *)(*(_DWORD *)(v23 + 164) + 2 * j + 38));
            sub_2BC10(&v21, v12 + 8, v5 + 10, v29);
            if ( *(_BYTE *)(dword_D41A4 + 10) && byte_180558 && !v25 && j == (unsigned __int8)byte_180558 )
            {
              word_18054A = v12 + 20;
              word_18054C = v5 + 20;
            }
          }
          HIWORD(v18) = HIWORD(dword_EA3DC);
          LOWORD(v18) = *(unsigned __int8 *)(dword_EA3DC + 520);
          v12 += v18;
        }
      }
      HIWORD(v19) = HIWORD(dword_EA3DC);
      LOWORD(v19) = *(unsigned __int8 *)(dword_EA3DC + 515);
      v5 += v19;
    }
    ++v25;
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D419D: using guessed type char byte_D419D;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// 180532: using guessed type int dword_180532;
// 180546: using guessed type __int16 word_180546;
// 180548: using guessed type __int16 word_180548;
// 18054A: using guessed type __int16 word_18054A;
// 18054C: using guessed type __int16 word_18054C;
// 180558: using guessed type char byte_180558;
// 180660: using guessed type __int16 word_180660;

//----- (0002D710) --------------------------------------------------------
int __cdecl sub_2D710(int a1)
{
  __int16 v1; // bx
  unsigned int v2; // ecx
  int v3; // ecx
  int v4; // edx
  int v5; // eax
  __int64 v6; // rtt
  __int16 v8; // bx
  unsigned int v9; // eax
  __int16 v12; // bx
  __int16 v14; // bx
  unsigned __int8 v16; // [esp-4h] [ebp-4Ch]
  int v17; // [esp+0h] [ebp-48h]
  int v18; // [esp+8h] [ebp-40h]
  unsigned int v19; // [esp+Ch] [ebp-3Ch]
  int v20; // [esp+10h] [ebp-38h]
  __int16 v21; // [esp+1Ch] [ebp-2Ch]
  __int16 v22; // [esp+24h] [ebp-24h]
  _DWORD *v23; // [esp+28h] [ebp-20h]
  signed __int16 v24; // [esp+2Ch] [ebp-1Ch]
  signed __int16 v25; // [esp+30h] [ebp-18h]
  unsigned __int8 v26; // [esp+34h] [ebp-14h]
  unsigned __int8 v27; // [esp+3Ch] [ebp-Ch]
  unsigned __int8 v28; // [esp+40h] [ebp-8h]

  v28 = byte_E88E0[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(a1 + 164) + 56))];
  v27 = byte_E88E1[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(a1 + 164) + 56))];
  v26 = byte_E88E0[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(a1 + 164) + 56))
                 + *(unsigned __int8 *)(dword_D41A4 + 123)];
  dword_F01E8(2, 2, dword_EA3DC + 240);
  v1 = *(unsigned __int8 *)(dword_EA3DC + 244) + 2;
  v18 = *(_DWORD *)(dword_D41A4 + 246);
  v20 = *(_DWORD *)(a1 + 164);
  v2 = dword_EA3E4[*(unsigned __int16 *)(v20 + 58)];
  v23 = (_DWORD *)v2;
  if ( v2 > dword_EA3E4[0] && *(_DWORD *)(v2 + 16) )
  {
    if ( *(_BYTE *)(v20 + 405) > 0 && *(_BYTE *)(dword_D41A4 + 122) )
    {
      dword_F01E8(v1, 2, dword_EA3DC + 330);
      --*(_BYTE *)(*(_DWORD *)(a1 + 164) + 405);
    }
    else
    {
      dword_F01E8(v1, 2, dword_EA3DC + 246);
    }
    sub_2BB40(v1 + 2, 2, 6 * (v23[4] + 43) + dword_EA3DC);
    sub_2BB40(v1 + 38, 2, dword_EA3DC + 252);
    v22 = v1 + 58;
    sub_2D190(v1 + 58, 10, 64, 10, (v23[2] << 6) / v23[1], 0x7Bu);
    v17 = (v23[36] + *(_DWORD *)(*(_DWORD *)(a1 + 164) + 316)) << 6;
    if ( v23[36] + *(_DWORD *)(*(_DWORD *)(a1 + 164) + 316) == v23[35] )
    {
      if ( *(_BYTE *)(dword_D41A4 + 123) == 1 )
      {
        v3 = v18;
        v4 = v23[35] << 6;
        v16 = v27;
        v5 = v23[35] << 6;
      }
      else
      {
        v16 = v28;
        v5 = (v23[36] + *(_DWORD *)(*(_DWORD *)(a1 + 164) + 316)) << 6;
        v4 = (v23[36] + *(_DWORD *)(*(_DWORD *)(a1 + 164) + 316)) << 6;
        v3 = v18;
      }
    }
    else
    {
      sub_2D190(v22, 28, 64, 10, (v23[35] << 6) / v18, v27);
      v16 = v28;
      v5 = v17;
      v4 = v17;
      v3 = v18;
    }
    LODWORD(v6) = v5;
    HIDWORD(v6) = v4 >> 31;
    sub_2D190(v22, 28, 64, 10, v6 / v3, v16);
    if ( !(*(_BYTE *)(dword_D41A4 + 22) & 0x10) && *(_WORD *)((char *)&loc_2FED5 + dword_D41A0) )
    {
      sub_2BC80(v22 + (*(unsigned __int16 *)((char *)&loc_2FED5 + dword_D41A0) << 6) / 100, 26, 2, 2, v26);
      sub_2BC80(v22 + (*(unsigned __int16 *)((char *)&loc_2FED5 + dword_D41A0) << 6) / 100, 38, 2, 2, v26);
    }
  }
  else
  {
    dword_F01E8(v1, 2, dword_EA3DC + 324);
  }
  v8 = *(unsigned __int8 *)(dword_EA3DC + 250) + v1;
  if ( dword_EA3E4[0] >= (unsigned int)v23 )
  {
    dword_F01E8(v8, 2, dword_EA3DC + 324);
  }
  else
  {
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 164) + 407) > 0 && *(_BYTE *)(dword_D41A4 + 122) )
    {
      dword_F01E8(v8, 2, dword_EA3DC + 330);
      --*(_BYTE *)(*(_DWORD *)(a1 + 164) + 407);
    }
    else
    {
      dword_F01E8(v8, 2, dword_EA3DC + 246);
    }
    switch ( v23[4] )
    {
      case 1:
      case 2:
      case 3:
        v25 = 1;
        break;
      case 4:
      case 5:
        v25 = 2;
        break;
      case 6:
      case 7:
        v25 = 3;
        break;
      default:
        v25 = 0;
        break;
    }
    sub_2BB40(v8 + 2, 2, 6 * (v25 + 50) + dword_EA3DC);
    v24 = 0;
    sub_2BB40(v8 + 38, 2, dword_EA3DC + 252);
    if ( v25 > 0 )
    {
      do
      {
        v21 = v8 + 58;
        v9 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 2 * v24 + 60)];
        v19 = v9;
        if ( v9 > dword_EA3E4[0] )
        {
          if ( *(_DWORD *)(v9 + 8) >= 0 )
            sub_2D190(v21, 2 * v24 + 12, 64, 2, (*(_DWORD *)(v9 + 8) << 6) / *(_DWORD *)(v9 + 4), 0x7Bu);
          sub_2D190(v21, 2 * v24 + 30, 64, 2, (*(_DWORD *)(v19 + 144) << 6) / *(_DWORD *)(v19 + 140), v28);
        }
        ++v24;
      }
      while ( v24 < v25 );
    }
  }
  v12 = *(unsigned __int8 *)(dword_EA3DC + 250) + v8;
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 164) + 406) > 0 && *(_BYTE *)(dword_D41A4 + 122) )
  {
    dword_F01E8(v12, 2, dword_EA3DC + 330);
    --*(_BYTE *)(*(_DWORD *)(a1 + 164) + 406);
  }
  else
  {
    dword_F01E8(v12, 2, dword_EA3DC + 246);
  }
  if ( (*(_BYTE *)(a1 + 12) & 0x20 || *(_WORD *)(*(_DWORD *)(a1 + 164) + 345)) && *(_BYTE *)(dword_D41A4 + 123) )
  {
    sub_2DE80(v12 + 2, 2, dword_EA3DC + 258);
    sub_2DE80(v12 + 38, 2, dword_EA3DC + 252);
  }
  else
  {
    sub_2BB40(v12 + 2, 2, dword_EA3DC + 258);
    sub_2BB40(v12 + 38, 2, dword_EA3DC + 252);
  }
  v14 = v12 + 58;
  sub_2D190(v14, 10, 64, 10, (*(_DWORD *)(a1 + 8) << 6) / *(_DWORD *)(a1 + 4), 0x7Bu);
  sub_2D190(v14, 28, 64, 10, (*(_DWORD *)(a1 + 140) << 6) / v18, v27);
  return sub_2D190(v14, 28, 64, 10, (*(_DWORD *)(a1 + 144) << 6) / v18, v28);
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// F01E8: using guessed type int (__cdecl *dword_F01E8)(_DWORD, _DWORD, _DWORD);

//----- (0002DE80) --------------------------------------------------------
char __cdecl sub_2DE80(__int16 a1, __int16 a2, int a3)
{
  __int16 v3; // bx
  int v4; // eax
  _BYTE *v5; // edi
  _BYTE *v6; // edx
  _BYTE *v7; // esi
  int v8; // ecx
  __int16 v9; // bx
  _BYTE *v10; // edi
  _BYTE *v11; // edx
  _BYTE *v12; // esi
  int v13; // ecx
  int v15; // [esp+0h] [ebp-Ch]
  int v16; // [esp+0h] [ebp-Ch]
  int v17; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h]

  if ( word_180660 == 1 )
  {
    v3 = *(unsigned __int8 *)(a3 + 5) / 2;
    v4 = a2 / 2 * dword_18062C + a1 / 2;
    v5 = (_BYTE *)(v4 + dword_180628);
    v6 = *(_BYTE **)a3;
    for ( i = v4 + dword_180628; v3; v6 += v15 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          LOBYTE(v4) = *v6++;
          if ( (_BYTE)v4 )
            break;
          --v3;
          i += dword_18062C;
          v5 = (_BYTE *)i;
          if ( !v3 )
            return v4;
        }
        if ( (v4 & 0x80u) == 0 )
          break;
        v5 -= (char)v4;
        if ( !v3 )
          return v4;
      }
      v4 = (char)v4;
      v7 = v6;
      v8 = v4;
      v15 = (char)v4;
      HIWORD(v4) = 0;
      do
      {
        LOBYTE(v4) = *v7++;
        BYTE1(v4) = *v5;
        LOBYTE(v4) = byte_FAEE0[v4];
        *v5++ = v4;
        --v8;
      }
      while ( v8 );
    }
  }
  else
  {
    v4 = a1 + dword_18062C * a2;
    v9 = *(unsigned __int8 *)(a3 + 5);
    v10 = (_BYTE *)(v4 + dword_180628);
    v11 = *(_BYTE **)a3;
    v17 = v4 + dword_180628;
    if ( *(_BYTE *)(a3 + 5) )
    {
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            LOBYTE(v4) = *v11++;
            if ( (_BYTE)v4 )
              break;
            --v9;
            v17 += dword_18062C;
            v10 = (_BYTE *)v17;
            if ( !v9 )
              return v4;
          }
          if ( (v4 & 0x80u) == 0 )
            break;
          v10 -= (char)v4;
          if ( !v9 )
            return v4;
        }
        v4 = (char)v4;
        v12 = v11;
        v13 = v4;
        v16 = (char)v4;
        HIWORD(v4) = 0;
        do
        {
          LOBYTE(v4) = *v12++;
          BYTE1(v4) = *v10;
          LOBYTE(v4) = byte_FAEE0[v4];
          *v10++ = v4;
          --v13;
        }
        while ( v13 );
        v11 += v16;
      }
      while ( v9 );
    }
  }
  return v4;
}
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (0002DFD0) --------------------------------------------------------
char __cdecl sub_2DFD0(__int16 a1, __int16 a2, int a3, unsigned __int8 a4)
{
  int v4; // eax
  _BYTE *v5; // edi
  _BYTE *v6; // edx
  int v7; // ebx
  int v8; // ecx
  _BYTE *v9; // edi
  _BYTE *v10; // edx
  int v11; // ebx
  int v12; // ecx
  int v14; // [esp+0h] [ebp-14h]
  int v15; // [esp+0h] [ebp-14h]
  int i; // [esp+4h] [ebp-10h]
  int v17; // [esp+8h] [ebp-Ch]
  __int16 v18; // [esp+Ch] [ebp-8h]
  __int16 v19; // [esp+10h] [ebp-4h]

  if ( word_180660 == 1 )
  {
    v19 = *(unsigned __int8 *)(a3 + 5) / 2;
    v4 = a2 / 2 * dword_18062C + a1 / 2;
    v5 = (_BYTE *)(v4 + dword_180628);
    v6 = *(_BYTE **)a3;
    for ( i = v4 + dword_180628; v19; v6 += v14 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          LOBYTE(v4) = *v6++;
          if ( (_BYTE)v4 )
            break;
          LOBYTE(v4) = dword_18062C;
          i += dword_18062C;
          v5 = (_BYTE *)i;
          if ( !--v19 )
            return v4;
        }
        if ( (v4 & 0x80u) == 0 )
          break;
        v5 -= (char)v4;
        if ( !v19 )
          return v4;
      }
      v7 = a4;
      v8 = (char)v4;
      v14 = (char)v4;
      do
      {
        BYTE1(v7) = *v5;
        LOBYTE(v4) = byte_FAEE0[v7];
        *v5++ = v4;
        --v8;
      }
      while ( v8 );
    }
  }
  else
  {
    v18 = *(unsigned __int8 *)(a3 + 5);
    LOBYTE(v4) = dword_180628;
    v9 = (_BYTE *)(dword_180628 + a1 + dword_18062C * a2);
    v10 = *(_BYTE **)a3;
    v17 = dword_180628 + a1 + dword_18062C * a2;
    if ( *(_BYTE *)(a3 + 5) )
    {
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            LOBYTE(v4) = *v10++;
            if ( (_BYTE)v4 )
              break;
            LOBYTE(v4) = dword_18062C;
            v9 = (_BYTE *)(dword_18062C + v17);
            v17 += dword_18062C;
            if ( !--v18 )
              return v4;
          }
          if ( (v4 & 0x80u) == 0 )
            break;
          v9 -= (char)v4;
          if ( !v18 )
            return v4;
        }
        v11 = a4;
        v12 = (char)v4;
        v15 = (char)v4;
        do
        {
          BYTE1(v11) = *v9;
          LOBYTE(v4) = byte_FAEE0[v11];
          *v9++ = v4;
          --v12;
        }
        while ( v12 );
        v10 += v15;
      }
      while ( v18 );
    }
  }
  return v4;
}
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (0002E260) --------------------------------------------------------
void __cdecl sub_2E260(__int16 a1, __int16 a2, unsigned int a3, char a4)
{
  unsigned int v4; // eax
  signed int v5; // eax
  __int16 v6; // t1
  __int16 v7; // cx
  int v8; // eax
  int v9; // eax
  int v10; // edi
  unsigned __int16 v11; // di
  unsigned __int8 v12; // al
  signed int i; // [esp+0h] [ebp-14h]
  signed int j; // [esp+4h] [ebp-10h]
  unsigned int v15; // [esp+8h] [ebp-Ch]
  unsigned __int8 v16; // [esp+Ch] [ebp-8h]
  unsigned __int8 v17; // [esp+10h] [ebp-4h]

  if ( a3 > dword_EA3E4[0] )
  {
    sub_6FC50(byte_D419D);
    v4 = dword_EA3E4[*(unsigned __int16 *)(a3 + 40)];
    v15 = v4;
    if ( v4 > dword_EA3E4[0] )
    {
      v17 = byte_E88E0[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(v4 + 164) + 56))];
      v5 = sub_61790(*(signed __int16 *)(*(_DWORD *)(v15 + 164) + 56));
      v6 = *(_WORD *)(a3 + 46);
      v16 = byte_E88E1[3 * v5];
      if ( !(byte_DA819[80 * *(char *)(a3 + 64)] & 4)
        || (v7 = *(_WORD *)(a3 + 46), v7 <= 0)
        || v7 >= 32
        || !*(_BYTE *)(dword_D41A4 + 122) )
      {
        if ( a4 )
        {
          if ( *(_WORD *)(a3 + 46) )
            v8 = dword_EA3DC + 12;
          else
            v8 = dword_EA3DC + 6;
          sub_2BB40(a1, a2, v8);
        }
        else
        {
          if ( *(_WORD *)(a3 + 46) )
            v9 = dword_EA3DC + 12;
          else
            v9 = dword_EA3DC + 6;
          dword_F01E8(a1, a2, v9);
        }
        sub_2BB40(a1, a2, 6 * (*(char *)(a3 + 64) + 123) + dword_EA3DC);
        sub_2BC10(
          *(&off_DB06C + *(char *)(a3 + 70)),
          *(unsigned __int8 *)(dword_EA3DC + 10) + a1 - 8 * strlen((const char *)*(&off_DB06C + *(char *)(a3 + 70))) - 2,
          a2,
          byte_E8900[0]);
        if ( *(_DWORD *)(a3 + 140) )
        {
          sub_2BC80(
            a1 + 4,
            a2 + 36,
            56 * (*(_DWORD *)(v15 + 144) % *(_DWORD *)(a3 + 140)) / *(_DWORD *)(a3 + 140),
            4,
            v16);
          v10 = *(_DWORD *)(v15 + 144) / *(_DWORD *)(a3 + 140);
          for ( i = 0; i < 27 && v10; ++i )
          {
            for ( j = 0; j < 2 && v10; ++j )
            {
              sub_2BC80(a1 + 2 * (i + 2), a2 + 2 * (j + 18), 2, 2, v17);
              --v10;
            }
          }
        }
        if ( *(_DWORD *)(a3 + 136) )
        {
          v11 = *(_WORD *)(*(_DWORD *)(v15 + 164) + 58);
          if ( !v11 || *(_DWORD *)(a3 + 136) > *(_DWORD *)(dword_EA3E4[v11] + 144) )
          {
            if ( *((_BYTE *)&loc_2FED1 + dword_D41A0 + 3) )
              v12 = 16;
            else
              v12 = 48;
            sub_2E850(a1, a2, *(unsigned __int8 *)(dword_EA3DC + 10), *(unsigned __int8 *)(dword_EA3DC + 11), v12);
          }
        }
      }
    }
  }
}
// D419D: using guessed type char byte_D419D;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// DB06C: using guessed type void *off_DB06C;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// F01E8: using guessed type int (__cdecl *dword_F01E8)(_DWORD, _DWORD, _DWORD);

//----- (0002E790) --------------------------------------------------------
int __cdecl sub_2E790(__int16 a1, int a2, int a3, int a4, unsigned __int8 a5)
{
  __int16 v5; // bx
  int v6; // ecx
  int v7; // eax
  int result; // eax
  __int16 v9; // si
  int v10; // [esp+Ch] [ebp-4h]

  v5 = a1;
  v6 = a2;
  if ( word_180660 == 1 )
  {
    v5 = a1 / 2;
    HIWORD(v7) = HIWORD(a2);
    LOWORD(v7) = (signed __int16)a2 / 2;
    v6 = v7;
    HIWORD(v7) = HIWORD(a3);
    LOWORD(v7) = (signed __int16)a3 / 2;
    a3 = v7;
    HIWORD(v7) = HIWORD(a4);
    LOWORD(v7) = (signed __int16)a4 / 2;
    a4 = v7;
  }
  for ( result = v6; (signed __int16)result < (signed __int16)v6 + (signed __int16)a4; ++result )
  {
    v9 = v5;
    while ( 1 )
    {
      v10 = v9;
      if ( (signed __int16)a3 + v5 <= v9 )
        break;
      ++v9;
      *(_BYTE *)(dword_180628 + dword_18062C * (signed __int16)result + v10) = byte_FAEE0[256 * a5
                                                                                        + *(unsigned __int8 *)(dword_180628 + dword_18062C * (signed __int16)result + v10)];
    }
  }
  return result;
}
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (0002E850) --------------------------------------------------------
int __cdecl sub_2E850(__int16 a1, int a2, int a3, int a4, unsigned __int8 a5)
{
  __int16 v5; // bx
  int v6; // ecx
  int v7; // eax
  int result; // eax
  __int16 v9; // si
  int v10; // [esp+Ch] [ebp-4h]

  v5 = a1;
  v6 = a2;
  if ( word_180660 == 1 )
  {
    v5 = a1 / 2;
    HIWORD(v7) = HIWORD(a2);
    LOWORD(v7) = (signed __int16)a2 / 2;
    v6 = v7;
    HIWORD(v7) = HIWORD(a3);
    LOWORD(v7) = (signed __int16)a3 / 2;
    a3 = v7;
    HIWORD(v7) = HIWORD(a4);
    LOWORD(v7) = (signed __int16)a4 / 2;
    a4 = v7;
  }
  for ( result = v6; (signed __int16)result < (signed __int16)v6 + (signed __int16)a4; ++result )
  {
    v9 = v5;
    while ( 1 )
    {
      v10 = v9;
      if ( (signed __int16)a3 + v5 <= v9 )
        break;
      ++v9;
      *(_BYTE *)(dword_180628 + dword_18062C * (signed __int16)result + v10) = byte_F6EE0[256 * a5
                                                                                        + *(unsigned __int8 *)(dword_180628 + dword_18062C * (signed __int16)result + v10)];
    }
  }
  return result;
}
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (0002EB40) --------------------------------------------------------
int sub_2EB40()
{
  int result; // eax

  BYTE1(result) = 0;
  byte_D41CE = 0;
  byte_D41C1 = 0;
  dword_D41D0 = 0;
  return result;
}
// D41C1: using guessed type char byte_D41C1;
// D41CE: using guessed type char byte_D41CE;
// D41D0: using guessed type int dword_D41D0;

//----- (0002EB60) --------------------------------------------------------
int sub_2EB60()
{
  int result; // eax

  if ( !byte_D41CE )
  {
    byte_D41CE = 1;
    byte_D41C1 = 1;
    dword_F01E4 = dword_180628 + 64320;
    word_F01F4 = 12800;
    result = sub_2EC30();
    dword_D41D0 = 0;
  }
  return result;
}
// D41C1: using guessed type char byte_D41C1;
// D41CE: using guessed type char byte_D41CE;
// D41D0: using guessed type int dword_D41D0;
// F01E4: using guessed type int dword_F01E4;
// F01F4: using guessed type __int16 word_F01F4;
// 180628: using guessed type int dword_180628;

//----- (0002EBB0) --------------------------------------------------------
int __cdecl sub_2EBB0(_BYTE *a1)
{
  int result; // eax

  if ( byte_D41CE )
  {
    dword_D41D0 = (int)a1;
    word_E36D4 = 64;
    dword_180628 += 9920;
    result = sub_7FCB0(64, a1, 0, 630, 340, 5, byte_EB3B6, 0);
    word_E36D4 = 0;
    dword_180628 -= 9920;
  }
  return result;
}
// D41CE: using guessed type char byte_D41CE;
// D41D0: using guessed type int dword_D41D0;
// E36D4: using guessed type __int16 word_E36D4;
// EB3B6: using guessed type char byte_EB3B6;
// 180628: using guessed type int dword_180628;

//----- (0002EC30) --------------------------------------------------------
int sub_2EC30()
{
  int result; // eax

  if ( byte_D41CE )
    result = memset(dword_F01E4, 0, (unsigned __int16)word_F01F4);
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41CE: using guessed type char byte_D41CE;
// F01E4: using guessed type int dword_F01E4;
// F01F4: using guessed type __int16 word_F01F4;

//----- (0002EC60) --------------------------------------------------------
int sub_2EC60()
{
  int result; // eax

  if ( byte_D41CE )
  {
    result = sub_2EC30();
    byte_D41C1 = 0;
    byte_D41CE = 0;
    dword_D41D0 = 0;
  }
  return result;
}
// D41C1: using guessed type char byte_D41C1;
// D41CE: using guessed type char byte_D41CE;
// D41D0: using guessed type int dword_D41D0;

//----- (0002EC90) --------------------------------------------------------
char __cdecl sub_2EC90(char a1)
{
  char result; // al

  if ( byte_D41CE )
  {
    result = a1;
    byte_EB3B6 = a1;
    if ( dword_D41D0 )
      result = sub_2EBB0((_BYTE *)dword_D41D0);
  }
  return result;
}
// D41CE: using guessed type char byte_D41CE;
// D41D0: using guessed type int dword_D41D0;
// EB3B6: using guessed type char byte_EB3B6;

//----- (0002ECC0) --------------------------------------------------------
__int16 sub_2ECC0()
{
  char v0; // t0
  int v1; // eax
  int v2; // eax
  char v3; // dh
  signed int v4; // eax
  __int16 v5; // si
  __int16 v6; // di
  __int16 v7; // bx
  char v8; // dl
  unsigned int v9; // edx
  __int16 v10; // ax
  __int16 v11; // ax
  unsigned __int16 v12; // dx
  int v13; // eax
  unsigned __int8 v14; // al
  int v15; // eax
  int v16; // eax
  unsigned __int8 v17; // dl
  __int16 v18; // cx
  int v19; // esi
  int v20; // ebx
  char *v21; // edi
  int v22; // eax
  unsigned __int16 v23; // cx
  signed __int16 v24; // ax
  __int16 v25; // cx
  int v26; // eax
  int v27; // eax
  int v28; // ecx
  int v29; // edx
  int v30; // ecx
  int v31; // eax
  int v32; // edi
  __int16 result; // ax
  int v34; // [esp+4h] [ebp-6Ch]
  int v35; // [esp+Ch] [ebp-64h]
  int v36; // [esp+10h] [ebp-60h]
  unsigned int v37; // [esp+14h] [ebp-5Ch]
  signed int i; // [esp+18h] [ebp-58h]
  char *v39; // [esp+24h] [ebp-4Ch]
  signed int v40; // [esp+28h] [ebp-48h]
  __int16 v41; // [esp+2Ch] [ebp-44h]
  __int16 v42; // [esp+34h] [ebp-3Ch]
  int v43; // [esp+38h] [ebp-38h]
  __int16 v44; // [esp+38h] [ebp-38h]
  __int16 v45; // [esp+3Ch] [ebp-34h]
  unsigned __int8 v46; // [esp+40h] [ebp-30h]
  signed __int16 v47; // [esp+40h] [ebp-30h]
  int v48; // [esp+44h] [ebp-2Ch]
  __int16 v49; // [esp+48h] [ebp-28h]
  __int16 v50; // [esp+4Ch] [ebp-24h]
  int v51; // [esp+50h] [ebp-20h]
  __int16 v52; // [esp+54h] [ebp-1Ch]
  __int16 v53; // [esp+58h] [ebp-18h]
  __int16 v54; // [esp+5Ch] [ebp-14h]
  char v55; // [esp+60h] [ebp-10h]
  unsigned __int8 v56; // [esp+64h] [ebp-Ch]
  unsigned __int8 v57; // [esp+68h] [ebp-8h]
  char v58; // [esp+6Ch] [ebp-4h]

  v0 = *((_BYTE *)&loc_2FED1 + dword_D41A0 + 3);
  v1 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v37 = v1;
  v2 = *(_DWORD *)(v1 + 164);
  v36 = v2 + 611;
  v57 = byte_E88E0[3 * sub_61790(*(signed __int16 *)(v2 + 56))];
  v56 = byte_E88E1[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(v37 + 164) + 56))];
  v3 = word_180660;
  *(_BYTE *)(dword_D41A4 + 50) = -1;
  if ( v3 & 1 )
    v4 = 400;
  else
    v4 = 480;
  v41 = *(unsigned __int8 *)(dword_EA3DC + 532);
  v48 = *(unsigned __int8 *)(dword_EA3DC + 539);
  v51 = v4 - 2 * v48;
  v42 = *(unsigned __int8 *)(dword_EA3DC + 538);
  v49 = 0;
  v54 = 0;
  v45 = v42 - *(unsigned __int8 *)(dword_EA3DC + 898);
  v5 = v4 - 2 * v48;
  while ( v49 < 2 )
  {
    if ( !v49 )
      dword_F01E8(0, v5, dword_EA3DC + 528);
    v6 = v41;
    v7 = 0;
    while ( v7 < 13 )
    {
      v44 = (unsigned __int8)byte_D94FF[v54];
      v8 = 1;
      if ( !byte_DA818[80 * (unsigned __int8)byte_D94FF[v54]] || !byte_D41B6 && v44 == 25 )
        v8 = 0;
      if ( !v8 )
      {
        dword_F01E8(v6, v5, dword_EA3DC + 534);
        goto LABEL_54;
      }
      v9 = dword_EA3E4[*(signed __int16 *)(*(_DWORD *)(v37 + 164) + 2 * (unsigned __int8)byte_D94FF[v54] + 819)];
      if ( v9 > dword_EA3E4[0] )
      {
        if ( v54 == *(char *)(v36 + 501) )
        {
          *(_BYTE *)(dword_D41A4 + 50) = v54;
          v10 = *(char *)(v36 + 502);
        }
        else
        {
          v10 = *(char *)((unsigned __int8)byte_D94FF[v54] + v36 + 468);
        }
        v46 = v10;
        v39 = &byte_DA818[80 * v44 + 2 + 26 * v10];
        if ( byte_DA819[80 * *(char *)(v9 + 64)] & 4 )
        {
          v11 = *(_WORD *)(v9 + 46);
          if ( v11 > 0 && v11 < 32 && *(_BYTE *)(dword_D41A4 + 122) )
            goto LABEL_43;
        }
        v55 = 0;
        if ( !*((_DWORD *)v39 + 2)
          || (v12 = *(_WORD *)(*(_DWORD *)(v37 + 164) + 58)) != 0
          && *((_DWORD *)v39 + 2) <= *(_DWORD *)(dword_EA3E4[v12] + 144) )
        {
          v55 = 1;
        }
        if ( v55 )
        {
          if ( *(char *)(dword_D41A4 + 50) == v54 )
          {
            v35 = sub_6D710(v37, v44, v46);
            if ( v35 > 0 )
            {
              sub_2BB40(v6, v5, dword_EA3DC + 522);
              sub_2BC80(v6 + 6, v5 + 28, 36 * (*(_DWORD *)(v37 + 144) % v35) / v35, 4, v56);
              v34 = *(_DWORD *)(v37 + 144) / v35;
              for ( i = 0; i < 36 && v34 > 0; i += 2 )
              {
                v40 = 0;
                while ( v40 < 4 && v34 > 0 )
                {
                  sub_2BC80(i + v6 + 6, v40 + v5 + 28, 2, 2, v57);
                  v40 += 2;
                  --v34;
                }
              }
            }
LABEL_40:
            if ( v55 )
              sub_2BB40(v6, v5, dword_EA3DC + 6 * (v44 + 97));
            else
              sub_2DE80(v6, v5, 6 * (v44 + 97) + dword_EA3DC);
LABEL_43:
            v14 = *(_BYTE *)(v36 + v44 + 338);
            if ( v14 >= 1u )
            {
              if ( v14 <= 1u )
              {
                sub_2DE80(v6, v5, dword_EA3DC + 894);
              }
              else if ( v14 == 2 )
              {
                sub_2DE80(v6 + v45, v5, dword_EA3DC + 900);
              }
            }
            goto LABEL_54;
          }
          v13 = dword_EA3DC + 534;
        }
        else
        {
          v13 = dword_EA3DC + 546;
        }
        dword_F01E8(v6, v5, v13);
        goto LABEL_40;
      }
      dword_F01E8(v6, v5, dword_EA3DC + 534);
      v15 = v44 + *(_DWORD *)(v37 + 164);
      if ( *(_BYTE *)(v15 + 1001) || *(_BYTE *)(v15 + 1027) )
        sub_2DFD0(v6, v5, dword_EA3DC + 6 * (v44 + 97), 0xA6u);
LABEL_54:
      ++v7;
      v6 += v42;
      ++v54;
    }
    if ( !v49 )
      dword_F01E8(v6, v5, dword_EA3DC + 528);
    v5 += *(unsigned __int8 *)(dword_EA3DC + 539);
    ++v49;
  }
  sub_2BB40(v41 + v42 * (*(char *)(v36 + 501) % 13), *(char *)(v36 + 501) / 13 * v48 + v51, dword_EA3DC + 540);
  v16 = *(char *)(dword_D41A4 + 50);
  if ( v16 != -1 )
  {
    v17 = byte_D94FF[v16];
    LOWORD(v43) = v17;
    v47 = *(char *)(v36 + v17 + 442);
    v18 = 3 * *(unsigned __int8 *)(dword_EA3DC + 982);
    v50 = v51 - *(unsigned __int8 *)(dword_EA3DC + 983);
    v19 = v42 / 2 + v42 * (*(char *)(v36 + 501) % 13) + v41 - v18 / 2;
    if ( (signed __int16)v19 <= 640 - v18 )
    {
      if ( (v19 & 0x8000u) != 0 )
        LOWORD(v19) = 0;
    }
    else
    {
      LOWORD(v19) = 640 - v18;
    }
    v20 = 0;
    v52 = *(unsigned __int8 *)(dword_EA3DC + 982);
    while ( 2 )
    {
      if ( (signed __int16)v20 >= 3 )
        break;
      v21 = &byte_DA818[80 * (signed __int16)v43 + 2 + 26 * (signed __int16)v20];
      LOBYTE(v22) = 0;
      v58 = 0;
      if ( !*((_DWORD *)v21 + 2)
        || (v23 = *(_WORD *)(*(_DWORD *)(v37 + 164) + 58)) != 0
        && *((_DWORD *)v21 + 2) <= *(_DWORD *)(dword_EA3E4[v23] + 144) )
      {
        v58 = 1;
        v22 = *(_DWORD *)(v37 + 144) / sub_6D710(v37, v43, v20);
      }
      if ( (signed __int16)v20 > v47 )
      {
        sub_2BB40(v19, v50, dword_EA3DC + 978);
      }
      else
      {
        if ( v58 && (_BYTE)v22 )
          v24 = 161;
        else
          v24 = 162;
        sub_2BB40(v19, v50, dword_EA3DC + 6 * v24);
        sub_2BB40(v19 + 6, v50 + 10, dword_EA3DC + 6 * (signed __int16)(v20 + 165));
        v53 = v19 + 18;
        v25 = v50 + 6;
        v26 = v20 + 3 * v43 + 179;
        if ( v58 )
          sub_2BB40(v53, v25, dword_EA3DC + 6 * (signed __int16)v26);
        else
          sub_2DE80(v53, v25, 6 * (signed __int16)v26 + dword_EA3DC);
      }
      if ( (_WORD)v20 == *(char *)(v36 + 502) )
        sub_2BB40(v19, v50, dword_EA3DC + 984);
      if ( (signed __int16)v20 <= v47 && (signed __int16)v20 < 2 )
      {
        if ( (_WORD)v20 == v47 )
        {
          if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
          {
            v27 = (signed __int16)v43;
            v28 = *(_DWORD *)(v21 + 42);
            v29 = *((_DWORD *)v21 + 4);
          }
          else
          {
            v27 = (signed __int16)v43;
            v28 = *(_DWORD *)(v21 + 38);
            v29 = *((_DWORD *)v21 + 3);
          }
          v30 = v28 - v29;
          v31 = *(_DWORD *)(4 * v27 + v36) + *(_DWORD *)(4 * v27 + v36 + 104) - v29;
          if ( v30 > 0 )
          {
            v32 = 54 * v31 / v30;
            goto LABEL_92;
          }
LABEL_91:
          LOWORD(v32) = 0;
        }
        else
        {
          if ( (signed __int16)v20 >= v47 )
            goto LABEL_91;
          LOWORD(v32) = 54;
        }
LABEL_92:
        if ( (v32 & 0x8000u) != 0 )
          LOWORD(v32) = 0;
        if ( (signed __int16)v32 > 54 )
          LOWORD(v32) = 54;
        sub_2BC80(v19 + 6, v50 + 28, 54, 2, byte_E8900[0]);
        if ( (_WORD)v32 )
          sub_2BC80(v19 + 6, v50 + 28, v32, 2, byte_E9800);
      }
      ++v20;
      LOWORD(v19) = v52 + v19;
      continue;
    }
  }
  result = word_1805C2;
  if ( word_1805C2 == 8
    || word_1805C2 == 12
    || word_1805C2 == 13
    || word_1805C2 == 4
    || word_1805C2 == 6
    || word_1805C2 == 11
    || word_1805C2 == 5 )
  {
    result = sub_2BB40(dword_1805B0, dword_1805B4, dword_EB394 + 6 * (unsigned __int8)byte_D419E);
  }
  return result;
}
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// E9800: using guessed type char byte_E9800;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// EB394: using guessed type int dword_EB394;
// F01E8: using guessed type int (__cdecl *dword_F01E8)(_DWORD, _DWORD, _DWORD);
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;
// 180660: using guessed type __int16 word_180660;

//----- (0002F6B0) --------------------------------------------------------
int sub_2F6B0()
{
  signed int v0; // eax
  int v1; // eax
  unsigned __int8 v2; // dl
  char v3; // dh
  __int16 v4; // bx
  unsigned __int8 v5; // di
  unsigned __int8 v6; // al
  __int16 v7; // si
  int v8; // ebx
  __int16 v9; // di
  unsigned int v10; // ebx
  __int16 v11; // si
  unsigned __int8 v12; // al
  __int16 v13; // ST04_2
  __int16 v14; // ST00_2
  __int16 v15; // si
  __int16 v16; // bx
  __int16 v17; // si
  __int16 v18; // bx
  int v19; // eax
  int v20; // ebx
  __int16 v21; // si
  int v22; // eax
  signed int v23; // eax
  int v24; // ebx
  int v25; // esi
  char v26; // al
  int v27; // eax
  __int16 v28; // si
  __int16 v29; // bx
  __int16 v30; // si
  unsigned __int8 v31; // di
  int result; // eax
  char v33; // [esp+0h] [ebp-Eh]
  int v34; // [esp+48h] [ebp+3Ah]
  int v35; // [esp+4Ch] [ebp+3Eh]
  int v36; // [esp+50h] [ebp+42h]
  int v37; // [esp+54h] [ebp+46h]
  int v38; // [esp+58h] [ebp+4Ah]
  int v39; // [esp+5Ch] [ebp+4Eh]
  int v40; // [esp+60h] [ebp+52h]
  _BYTE *v41; // [esp+64h] [ebp+56h]
  unsigned __int8 v42; // [esp+68h] [ebp+5Ah]
  unsigned __int8 v43; // [esp+6Ch] [ebp+5Eh]
  unsigned __int8 v44; // [esp+70h] [ebp+62h]
  unsigned __int8 v45; // [esp+74h] [ebp+66h]
  unsigned __int8 v46; // [esp+78h] [ebp+6Ah]
  unsigned __int8 v47; // [esp+7Ch] [ebp+6Eh]
  unsigned __int8 v48; // [esp+80h] [ebp+72h]
  unsigned __int8 v49; // [esp+84h] [ebp+76h]
  _BOOL1 v50; // [esp+88h] [ebp+7Ah]
  char v51; // [esp+8Ch] [ebp+7Eh]

  v41 = (_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230);
  if ( word_180660 & 1 )
    v0 = 400;
  else
    v0 = 480;
  v40 = v0 - 72;
  v36 = 0;
  v1 = 5 * *((unsigned __int8 *)&loc_2FED1 + dword_D41A0 + 3);
  v2 = byte_D94F0[v1];
  v47 = byte_D94F1[v1];
  v3 = byte_D94F2[v1];
  v48 = byte_D94F3[v1];
  v42 = byte_E98FF;
  v44 = byte_E8900[0];
  v49 = v3;
  v45 = byte_E89F0;
  v43 = byte_E9800;
  v4 = v40;
  v51 = -1;
  sub_2BC80(0, v40, 640, 72, v2);
  v34 = v49;
  sub_2BC80(0, v4, 640, 2, v49);
  v5 = v48;
  sub_2BC80(0, v40 + 70, 640, 2, v48);
  sub_2BC80(0, v4, 2, 70, v34);
  sub_2BC80(v36 + 638, v4, 2, 72, v5);
  if ( (signed __int16)dword_E3760 < 4
    || (signed __int16)dword_E3760 >= 66
    || SHIWORD(dword_E3760) < v40 + 28
    || SHIWORD(dword_E3760) >= v40 + 66 )
  {
    v6 = v41[992];
  }
  else
  {
    v6 = 4 * ((SHIWORD(dword_E3760) - (v40 + 28)) / 20)
       + (((signed __int16)dword_E3760
         - 4
         - (__CFSHL__(((signed __int16)dword_E3760 - 4) >> 31, 4)
          + 16 * (((signed __int16)dword_E3760 - 4) >> 31))) >> 4);
  }
  v46 = v6;
  v7 = v40 + 4;
  v8 = v36 + 4;
  v9 = v36 + 4;
  v34 = (signed __int16)(v40 + 4);
  sub_2BC80(v36 + 4, v40 + 4, 372, 20, v47);
  v35 = v48;
  sub_2BC80(v9, v34, 372, 2, v48);
  v38 = v49;
  sub_2BC80(v9, v7 + 18, 372, 2, v49);
  sub_2BC80(v9, v34, 2, 18, v35);
  sub_2BC80(v8 + 370, v34, 2, 20, v38);
  sprintf(&v33, &aYS[2], &v41[48 * v46 + 81]);
  v7 += 2;
  v8 += 6;
  sub_2BC10(&v33, v8, v7, v42);
  v10 = 8 * strlen(&v33) + v8;
  v11 = v7 + 2;
  if ( *(_BYTE *)(dword_D41A4 + 26) & 8 )
    v12 = v43;
  else
    v12 = v47;
  v13 = v11;
  v39 = 0;
  v14 = v10;
  v15 = v40;
  v16 = v36;
  sub_2BC80(v14, v13, 6, 12, v12);
  v17 = v15 + 28;
  v18 = v16 + 4;
  while ( v39 < 8 )
  {
    if ( (unsigned __int8)v41[992] == v39 )
      v19 = dword_EA3DC + 930;
    else
      v19 = dword_EA3DC + 948;
    sub_2BB40(v18, v17, v19);
    sprintf(&v33, aD, v39 + 1);
    sub_2BC10(&v33, v18 + 4, v17 + 2, v44);
    if ( ++v39 == 4 )
    {
      v18 = 4;
      v17 += 20;
    }
    else
    {
      v18 += 16;
    }
  }
  v39 = 0;
  v20 = v36 + 82;
  v21 = v40 + 32;
  while ( v39 < 4 )
  {
    if ( (unsigned __int8)v41[993] == v39 )
      v22 = dword_EA3DC + 936;
    else
      v22 = dword_EA3DC + 954;
    sub_2BB40(v20, v21, v22);
    switch ( v39 )
    {
      case 0:
        v37 = 154;
        break;
      case 1:
        v37 = 153;
        break;
      case 2:
        v37 = 152;
        break;
      case 3:
        v37 = 151;
        break;
      default:
        break;
    }
    sub_2BB40(v20 + 2, v21 + 2, 6 * v37 + dword_EA3DC);
    if ( ++v39 == 3 )
      v23 = 20;
    else
      v23 = 2;
    v20 += v23 + 68;
  }
  v50 = v41[993] != 3;
  v39 = 0;
  v24 = v36 + 384;
  v25 = v40 + 26;
  while ( v39 < 8 )
  {
    if ( *(signed __int16 *)(dword_D41A0 + 12) == v39 )
      ++v39;
    v26 = 1;
    if ( !v50 && (1 << v39) & (unsigned __int8)v41[995] )
      v26 = 0;
    if ( v26 )
      v27 = dword_EA3DC + 960;
    else
      v27 = dword_EA3DC + 942;
    sub_2BB40(v24, v25, v27);
    sub_2BB40(v24 + 2, v25 + 2, 6 * (v39 + 74) + dword_EA3DC);
    if ( (signed __int16)dword_E3760 >= v24
      && (signed __int16)dword_E3760 < v24 + 32
      && SHIWORD(dword_E3760) >= v25
      && SHIWORD(dword_E3760) < v25 + 22 )
    {
      v51 = v39;
    }
    v24 += 34;
    ++v39;
  }
  v28 = v40 + 4;
  v29 = v36 + 384;
  sub_2BB40(v36 + 384, v40 + 4, dword_EA3DC + 1554);
  sub_2BB40(v36 + 474, v28, dword_EA3DC + 1566);
  sub_2BB40(v36 + 564, v28, dword_EA3DC + 1560);
  v30 = v40 + 50;
  sub_2BC80(v29, v40 + 50, 236, 18, v47);
  v31 = v48;
  sub_2BC80(v29, v30, 236, 2, v48);
  v38 = v49;
  sub_2BC80(v29, v40 + 66, 236, 2, v49);
  sub_2BC80(v29, v30, 2, 16, v31);
  sub_2BC80(v36 + 618, v30, 2, 18, v38);
  result = v51;
  if ( v51 != -1 )
    result = sub_2BC10((_BYTE *)(2124 * v51 + dword_D41A0 + 11230 + 927), v36 + 390, v40 + 52, v45);
  if ( word_1805C2 == 8
    || word_1805C2 == 12
    || word_1805C2 == 13
    || word_1805C2 == 4
    || word_1805C2 == 6
    || word_1805C2 == 11
    || word_1805C2 == 5 )
  {
    result = sub_2BB40(dword_1805B0, dword_1805B4, dword_EB394 + 6 * (unsigned __int8)byte_D419E);
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E3760: using guessed type int dword_E3760;
// E89F0: using guessed type char byte_E89F0;
// E9800: using guessed type char byte_E9800;
// E98FF: using guessed type char byte_E98FF;
// EA3DC: using guessed type int dword_EA3DC;
// EB394: using guessed type int dword_EB394;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;
// 180660: using guessed type __int16 word_180660;

//----- (0002FD90) --------------------------------------------------------
char sub_2FD90()
{
  char result; // al
  signed int v1; // ebx
  signed int v2; // ebx
  signed int v3; // ebx
  int v4; // [esp+0h] [ebp-14h]
  int v5; // [esp+4h] [ebp-10h]
  int v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-8h]
  unsigned __int8 v8; // [esp+10h] [ebp-4h]

  v8 = byte_E8900[0];
  result = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 24) & 1 )
  {
    if ( !*(_BYTE *)(dword_D41A4 + 206) )
    {
      sub_2FFE0(&v6, &v7, &v5, &v4);
      sub_2BB40(v6, v7, dword_EA3DC + 1044);
      v7 += v4;
      sub_2BB40(v6, v7, dword_EA3DC + 1050);
      if ( !*(_BYTE *)(dword_D41A4 + 208) )
      {
        v1 = 0;
        while ( v1 < 2 )
        {
          ++v1;
          sub_2E790(v6, (signed __int16)v7, (signed __int16)(v5 - 2), (signed __int16)v4, v8);
        }
      }
      v7 += v4;
      sub_2BB40(v6, v7, dword_EA3DC + 1056);
      if ( !byte_E3798 )
      {
        v2 = 0;
        while ( v2 < 2 )
        {
          ++v2;
          sub_2E790(
            v6,
            (signed __int16)v7,
            *(unsigned __int8 *)(dword_EA3DC + 1060),
            *(unsigned __int8 *)(dword_EA3DC + 1061),
            v8);
        }
      }
      sub_2BB40(v6 + *(unsigned __int8 *)(dword_EA3DC + 1060), v7, dword_EA3DC + 1062);
      if ( !byte_E37FC )
      {
        v3 = 0;
        while ( v3 < 2 )
        {
          ++v3;
          sub_2E790(
            v6 + *(unsigned __int8 *)(dword_EA3DC + 1060),
            (signed __int16)v7,
            *(unsigned __int8 *)(dword_EA3DC + 1066),
            *(unsigned __int8 *)(dword_EA3DC + 1067),
            v8);
        }
      }
      v7 += v4;
      sub_2BB40(v6, v7, dword_EA3DC + 1068);
    }
    if ( word_1805C2 == 8
      || word_1805C2 == 12
      || word_1805C2 == 13
      || word_1805C2 == 4
      || word_1805C2 == 6
      || word_1805C2 == 11
      || word_1805C2 == 5 )
    {
      sub_2BB40(dword_1805B0, dword_1805B4, dword_EB394 + 6 * (unsigned __int8)byte_D419E);
    }
    result = dword_D41A4;
    if ( *(_BYTE *)(dword_D41A4 + 25) & 0x10 )
      result = sub_30870();
  }
  return result;
}
// D419E: using guessed type char byte_D419E;
// D41A4: using guessed type int dword_D41A4;
// E3798: using guessed type char byte_E3798;
// E37FC: using guessed type char byte_E37FC;
// EA3DC: using guessed type int dword_EA3DC;
// EB394: using guessed type int dword_EB394;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (0002FFE0) --------------------------------------------------------
int *__cdecl sub_2FFE0(int *a1, int *a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // eax
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int *result; // eax

  v4 = dword_EA3DC;
  *a3 = *(unsigned __int8 *)(dword_EA3DC + 1048) + 2;
  v5 = *(unsigned __int8 *)(v4 + 1049);
  *a4 = v5;
  v6 = (400 - 4 * v5) / 2 - 60;
  v7 = (640 - *a3) / 2;
  LOBYTE(v7) = v7 & 0xFE;
  *a1 = v7;
  result = a2;
  LOBYTE(v6) = v6 & 0xFE;
  *a2 = v6;
  return result;
}
// EA3DC: using guessed type int dword_EA3DC;

//----- (00030050) --------------------------------------------------------
int sub_30050()
{
  signed int v0; // esi
  int v1; // edx
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  int v5; // ecx
  int v6; // edi
  unsigned __int8 v7; // dl
  int v8; // ebx
  int v9; // esi
  int v10; // edi
  int v11; // eax
  unsigned __int8 v12; // dl
  int result; // eax
  int v14; // [esp+0h] [ebp-20h]
  int v15; // [esp+4h] [ebp-1Ch]
  int v16; // [esp+8h] [ebp-18h]
  int v17; // [esp+Ch] [ebp-14h]
  char *v18; // [esp+10h] [ebp-10h]
  int v19; // [esp+14h] [ebp-Ch]
  int v20; // [esp+18h] [ebp-8h]
  int v21; // [esp+1Ch] [ebp-4h]

  v0 = 67;
  v1 = 0;
  v2 = (640 - *(signed __int16 *)(dword_D41A4 + 186)) / 2;
  while ( 1 )
  {
    v21 = v1;
    if ( v1 >= 17 )
      break;
    sub_1A5B0(v21 + 1, &v15, &v14);
    v19 = 1 << v21;
    if ( (1 << v21) & *(_DWORD *)(dword_D41A4 + 192) && (1 << v21) & *(_DWORD *)(dword_D41A4 + 188) )
      v3 = v15;
    else
      v3 = v14;
    v18 = (char *)dword_E9C4C[v3];
    v4 = *(signed __int16 *)(dword_D41A4 + 186);
    v16 = v2 + *(unsigned __int8 *)(dword_EA3DC + 1012);
    v5 = v2 + v4 - *(unsigned __int8 *)(dword_EA3DC + 1024);
    v17 = *(unsigned __int8 *)(dword_EA3DC + 1018);
    v20 = v5;
    sub_2BB40(v2, v0, dword_EA3DC + 1008);
    v6 = v16;
    sub_2BB40(v20, v0, dword_EA3DC + 1020);
    while ( v6 < v20 )
    {
      sub_2BB40(v6, v0, dword_EA3DC + 1014);
      v6 += v17;
    }
    if ( v19 & *(_DWORD *)(dword_D41A4 + 192) )
    {
      if ( v2 > dword_1805B0
        || v2 + *(signed __int16 *)(dword_D41A4 + 186) <= dword_1805B0
        || v0 > dword_1805B4
        || v0 + 18 <= dword_1805B4 )
      {
        v7 = byte_E98FF;
      }
      else
      {
        v7 = byte_E9800;
      }
    }
    else
    {
      v7 = byte_E9188;
    }
    sub_2BC10(v18, v2 + ((*(signed __int16 *)(dword_D41A4 + 186) - 8 * strlen(v18)) >> 1), v0 + 2, v7);
    v0 += 18;
    v1 = v21 + 1;
  }
  v8 = (*(signed __int16 *)(dword_D41A4 + 186) - 82) / 2 + (640 - *(signed __int16 *)(dword_D41A4 + 186)) / 2;
  v16 = v8 + *(unsigned __int8 *)(dword_EA3DC + 1012);
  v9 = *(unsigned __int8 *)(dword_EA3DC + 1018);
  v20 = v8 + 82 - *(unsigned __int8 *)(dword_EA3DC + 1024);
  sub_2BB40(v8, 377, dword_EA3DC + 1008);
  v10 = v16;
  sub_2BB40(v20, 377, dword_EA3DC + 1020);
  while ( v10 < v20 )
  {
    sub_2BB40(v10, 377, dword_EA3DC + 1014);
    v10 += v9;
  }
  v11 = (640 - *(signed __int16 *)(dword_D41A4 + 186)) / 2 + (*(signed __int16 *)(dword_D41A4 + 186) - 82) / 2;
  if ( v11 > dword_1805B0 || v11 + 82 <= dword_1805B0 || dword_1805B4 < 377 || dword_1805B4 >= 395 )
    v12 = byte_E98FF;
  else
    v12 = byte_E9800;
  result = sub_2BC10(
             &aOk_0[3],
             (640 - *(signed __int16 *)(dword_D41A4 + 186)) / 2 + (*(signed __int16 *)(dword_D41A4 + 186) - 82) / 2 + 33,
             379,
             v12);
  if ( word_1805C2 == 8
    || word_1805C2 == 12
    || word_1805C2 == 13
    || word_1805C2 == 4
    || word_1805C2 == 6
    || word_1805C2 == 11
    || word_1805C2 == 5 )
  {
    result = sub_2BB40(dword_1805B0, dword_1805B4, 6 * (unsigned __int8)byte_D419E + dword_EB394);
  }
  return result;
}
// D419E: using guessed type char byte_D419E;
// D41A4: using guessed type int dword_D41A4;
// E9188: using guessed type char byte_E9188;
// E9800: using guessed type char byte_E9800;
// E98FF: using guessed type char byte_E98FF;
// EA3DC: using guessed type int dword_EA3DC;
// EB394: using guessed type int dword_EB394;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (000303D0) --------------------------------------------------------
int __usercall sub_303D0@<eax>(signed int a1@<edi>)
{
  int v1; // edx
  unsigned __int8 v2; // bh
  unsigned __int8 v3; // bl
  unsigned __int8 v4; // al
  int v5; // eax
  unsigned __int8 v6; // si
  int v7; // ebx
  int v9; // [esp+0h] [ebp-1Ch]
  int v10; // [esp+4h] [ebp-18h]
  int v11; // [esp+8h] [ebp-14h]
  int v12; // [esp+Ch] [ebp-10h]
  int v13; // [esp+10h] [ebp-Ch]
  int v14; // [esp+14h] [ebp-8h]
  unsigned __int8 v15; // [esp+18h] [ebp-4h]

  v1 = *(unsigned __int8 *)(dword_D41A0 + 196308);
  v2 = byte_D94F0[5 * v1];
  v3 = byte_D94F2[5 * v1];
  v15 = byte_D94F3[5 * v1];
  sub_2FFE0(&v12, &v11, &v10, &v9);
  v4 = *(_BYTE *)(dword_D41A4 + 38543);
  if ( v4 >= 1u )
  {
    if ( v4 <= 1u )
    {
      v5 = *(signed __int16 *)(dword_D41A4 + 6);
    }
    else
    {
      if ( v4 != 2 )
        goto LABEL_8;
      v5 = *(signed __int16 *)(dword_D41A4 + 8);
    }
    a1 = 127;
    v14 = v5;
  }
LABEL_8:
  v10 -= 2;
  v13 = v2;
  v11 += 4 * v9;
  sub_2BC80(v12, v11, v10, 24, v2);
  sub_2BC80(v12, v11, v10, 2, v3);
  v6 = v15;
  sub_2BC80(v12, v11 + 22, v10, 2, v15);
  sub_2BC80(v12, v11, 2, 22, v3);
  sub_2BC80(v10 + v12 - 2, v11, 2, 24, v6);
  sub_2BC80(v12 + 4, v11 + 4, v10 - 8, 16, v13);
  sub_2BC80(v12 + 4, v11 + 4, v10 - 8, 2, v6);
  sub_2BC80(v12 + 4, v11 + 18, v10 - 8, 2, v3);
  sub_2BC80(v12 + 4, v11 + 4, 2, 14, v6);
  sub_2BC80(v12 + 4 + v10 - 8 - 2, v11 + 4, 2, 16, v3);
  v7 = v14 * (v10 - 12) / a1;
  v11 += 6;
  v12 += 6;
  sub_2BC80(v12, v11, v10 - 12, 12, byte_E8900[0]);
  return sub_2BC80(v12, v11, v7, 12, byte_E89F0);
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E89F0: using guessed type char byte_E89F0;

//----- (00030630) --------------------------------------------------------
int sub_30630()
{
  char v0; // dl
  int result; // eax
  unsigned __int16 v2; // cx
  int v3; // edx
  int v4; // edx
  const char *v5; // ebx
  __int16 v6; // [esp+0h] [ebp-34h]
  __int16 v7; // [esp+2h] [ebp-32h]
  __int16 v8; // [esp+Ch] [ebp-28h]
  __int16 v9; // [esp+Eh] [ebp-26h]
  __int16 v10; // [esp+10h] [ebp-24h]
  __int16 v11; // [esp+12h] [ebp-22h]
  __int16 v12; // [esp+14h] [ebp-20h]
  __int16 v13; // [esp+16h] [ebp-1Eh]
  __int16 v14; // [esp+18h] [ebp-1Ch]
  __int16 v15; // [esp+1Ah] [ebp-1Ah]
  __int16 v16; // [esp+24h] [ebp-10h]
  __int16 v17; // [esp+26h] [ebp-Eh]
  __int16 v18; // [esp+28h] [ebp-Ch]
  __int16 v19; // [esp+2Ah] [ebp-Ah]
  char v20; // [esp+30h] [ebp-4h]
  unsigned __int8 v21; // [esp+31h] [ebp-3h]

  v0 = *(_BYTE *)(dword_D41A4 + 22);
  result = 0;
  if ( !(v0 & 0x10) && !(v0 & 0x20) )
  {
    if ( *(_BYTE *)(dword_D41A4 + 23) & 2 )
    {
      v4 = 11 * *(signed __int16 *)(dword_D41A0 + 12);
      if ( byte_3659C[v4 + dword_D41A0] )
        result = (unsigned __int8)byte_DB526;
      else
        result = (unsigned __int8)byte_DB520[(unsigned __int8)byte_3659D[v4 + dword_D41A0]];
    }
    else if ( *((_BYTE *)&loc_36E09 + dword_D41A0 + 2) & 1 )
    {
      result = (*(_BYTE *)(dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12) + 12226) != 0) + 284;
    }
    else
    {
      v2 = *(_WORD *)(dword_D41A4 + 43);
      if ( v2 >= 0x1Eu && v2 <= 0x22u )
      {
        if ( byte_3659C[11 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0] )
          result = (unsigned __int8)byte_DB511;
        else
          result = (unsigned __int8)byte_DB4EE[0] + 3;
      }
      else if ( *(_BYTE *)(dword_D41A4 + 38545) & 0x20
             && !byte_3659D[11 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0] )
      {
        *((_BYTE *)&loc_36E03 + dword_D41A0 + 1) = 0;
      }
      else
      {
        v3 = 11 * *(signed __int16 *)(dword_D41A0 + 12);
        if ( byte_3659C[v3 + dword_D41A0] )
          result = (unsigned __int8)byte_DB507[*(unsigned __int16 *)(dword_D41A4 + 43)];
        else
          result = (unsigned __int8)byte_3659D[v3 + dword_D41A0]
                 + (unsigned __int8)byte_DB4EE[*(unsigned __int16 *)(dword_D41A4 + 43)];
      }
    }
    if ( result )
    {
      v5 = (const char *)dword_E9C4C[result];
      v10 = 8;
      v9 = 400;
      v12 = 40;
      v13 = 600;
      v11 = 14;
      v15 = 260;
      v20 = byte_E9800;
      v14 = 80;
      v21 = byte_E8900[0];
      v6 = 320;
      v7 = 300;
      v8 = 320;
      sub_89420(&v6, v5);
      sub_89520(&v6);
      sub_89980(&v6);
      sub_2E790(v16, v17, v18, v19, v21);
      sub_895D0((int)&v6, v5);
      result = sub_89690(&v6);
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// DB511: using guessed type char byte_DB511;
// DB526: using guessed type char byte_DB526;
// E9800: using guessed type char byte_E9800;

//----- (00030870) --------------------------------------------------------
char sub_30870()
{
  const char *v0; // ebx
  __int16 v1; // ax
  char v3; // [esp+0h] [ebp-32h]
  __int16 v4; // [esp+80h] [ebp+4Eh]
  __int16 v5; // [esp+82h] [ebp+50h]
  __int16 v6; // [esp+8Ch] [ebp+5Ah]
  __int16 v7; // [esp+8Eh] [ebp+5Ch]
  __int16 v8; // [esp+90h] [ebp+5Eh]
  __int16 v9; // [esp+92h] [ebp+60h]
  __int16 v10; // [esp+94h] [ebp+62h]
  __int16 v11; // [esp+96h] [ebp+64h]
  __int16 v12; // [esp+98h] [ebp+66h]
  __int16 v13; // [esp+9Ah] [ebp+68h]
  char v14; // [esp+B0h] [ebp+7Eh]
  char v15; // [esp+B1h] [ebp+7Fh]

  sub_2BC80(4, 286, 632, 190, 0);
  sprintf(&v3, aD, word_D41D4);
  sub_2BC10(&v3, 10, 300, byte_E98FF);
  v7 = 400;
  v10 = 4;
  v8 = 8;
  v9 = 14;
  v11 = 636;
  v0 = (const char *)dword_E9C4C[word_D41D4];
  v6 = 600;
  v4 = 320;
  v14 = byte_E9800;
  v15 = byte_E8900[0];
  v12 = 310;
  v13 = 630;
  v5 = 310;
  sub_89420(&v4, v0);
  sub_89520(&v4);
  sub_89980(&v4);
  LOBYTE(v1) = sub_895D0((int)&v4, v0);
  switch ( byte_1806E4 )
  {
    case 72:
      if ( ++word_D41D4 < 1 )
        word_D41D4 = 1;
      if ( word_D41D4 > 470 )
        word_D41D4 = 470;
      byte_1806E4 = 0;
      break;
    case 80:
      v1 = word_D41D4 - 1;
      word_D41D4 = v1;
      if ( v1 < 1 )
        word_D41D4 = 1;
      if ( word_D41D4 > 470 )
        word_D41D4 = 470;
      byte_1806E4 = 0;
      break;
    case 75:
      word_D41D4 = 1;
      byte_1806E4 = 0;
      break;
    case 77:
      word_D41D4 = 470;
      LOBYTE(v1) = 0;
      byte_1806E4 = 0;
      break;
  }
  return v1;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41D4: using guessed type __int16 word_D41D4;
// E9800: using guessed type char byte_E9800;
// E98FF: using guessed type char byte_E98FF;
// 1806E4: using guessed type char byte_1806E4;

//----- (00030A60) --------------------------------------------------------
int __cdecl sub_30A60(__int16 a1, __int16 a2)
{
  int result; // eax
  unsigned __int8 v3; // dl
  __int64 v4; // rax
  char v5; // [esp+0h] [ebp-Eh]
  int v6; // [esp+80h] [ebp+72h]
  int v7; // [esp+84h] [ebp+76h]

  v7 = a1;
  v6 = a2;
  result = dword_D41A4;
  v3 = *(_BYTE *)(dword_D41A4 + 38546);
  if ( v3 )
  {
    if ( v3 < 2u )
    {
      if ( v3 == 1 )
        sprintf(&v5, &aNS[1], dword_E9C54);
    }
    else if ( v3 <= 2u )
    {
      sprintf(&v5, &aNS[1], dword_EA2E8);
    }
    else if ( v3 == 3 )
    {
      sprintf(&v5, &aNS[1], dword_EA2EC);
    }
    v4 = 4080 * *(unsigned __int8 *)(dword_D41A4 + 125);
    sub_2BC10(&v5, v7, v6, byte_E8900[256 * ((signed int)(v4 - (__CFSHL__(HIDWORD(v4), 8) + (HIDWORD(v4) << 8))) >> 8)]);
    sub_30BE0(&v7, &v6);
    sub_2BB40(v7, v6, dword_EA3DC + 1542);
    result = sub_2BB40(v7 + 50, v6, dword_EA3DC + 1548);
    if ( word_1805C2 == 8
      || word_1805C2 == 12
      || word_1805C2 == 13
      || word_1805C2 == 4
      || word_1805C2 == 6
      || word_1805C2 == 11
      || word_1805C2 == 5 )
    {
      result = sub_2BB40(dword_1805B0, dword_1805B4, 6 * (unsigned __int8)byte_D419E + dword_EB394);
    }
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D419E: using guessed type char byte_D419E;
// D41A4: using guessed type int dword_D41A4;
// E9C54: using guessed type int dword_E9C54;
// EA2E8: using guessed type int dword_EA2E8;
// EA2EC: using guessed type int dword_EA2EC;
// EA3DC: using guessed type int dword_EA3DC;
// EB394: using guessed type int dword_EB394;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (00030BE0) --------------------------------------------------------
_DWORD *__cdecl sub_30BE0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  *a1 = 270;
  result = a2;
  *a2 = 104;
  return result;
}

//----- (00030D50) --------------------------------------------------------
void __cdecl sub_30D50(int a1)
{
  int v1; // eax
  char v2; // dl
  signed int v3; // esi
  char v4; // cl
  char v5; // ch
  __int16 v6; // ax
  int v7; // eax
  int v8; // edi
  int v9; // esi
  unsigned __int16 v10; // [esp+0h] [ebp-4h]

  if ( *(_BYTE *)(a1 + 16) & 3 )
  {
    --*(_DWORD *)(a1 + 16);
  }
  else
  {
    v1 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v1 - 1;
    if ( v1 >= 0 )
    {
      *(_BYTE *)(a1 + 12) &= 0xFEu;
      v3 = (signed __int16)sub_10C40((__int16 *)(a1 + 76));
      if ( !(*(_BYTE *)(a1 + 12) & 2) )
      {
        LOBYTE(v10) = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
        v4 = *(_BYTE *)(a1 + 14);
        HIBYTE(v10) = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
        if ( !(v4 & 1) )
          sub_10C80(a1, 0, *(_WORD *)(a1 + 42));
        v5 = byte_10B4E0[v10];
        if ( v5 )
        {
          switch ( v5 )
          {
            case 26:
              sub_45DC0(v2, v4, v10, 0x14u);
              break;
            case 10:
              sub_45DC0(v2, v4, v10, 0x15u);
              break;
            case 11:
              sub_45DC0(v2, v4, v10, 0x16u);
              break;
            default:
              if ( ((unsigned __int8)v5 < 6u || (unsigned __int8)v5 > 0x22u)
                && (byte_13B4E0[v10] & 7) != 1
                && *(signed __int16 *)(a1 + 80) - v3 <= 128
                && !(sub_104A0(a1 + 76) & 1) )
              {
                *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
                sub_572C0((signed __int16 *)a1, 0, 0, -(*(unsigned __int16 *)(a1 + 20) % 7u), 1);
              }
              break;
          }
        }
        v6 = 9377 * *(_WORD *)(a1 + 20);
        *(_BYTE *)(a1 + 12) |= 2u;
        *(_WORD *)(a1 + 20) = v6 + 9439;
        v7 = dword_D41A0 + 28302;
        *(_WORD *)(a1 + 44) = *(_WORD *)(a1 + 20) % 0x41u - 32;
        sub_6E450((a1 - v7) / 168, -1, 3);
      }
      sub_580E0(a1 + 76, v3, 0, 0, *(_WORD *)(a1 + 44));
      if ( byte_D41B6 )
      {
        v8 = *(signed __int16 *)(a1 + 88);
        v9 = (signed __int16)sub_10C60((__int16 *)(a1 + 76)) - v8;
        if ( *(signed __int16 *)(a1 + 80) > v9 )
          *(_WORD *)(a1 + 80) = v9;
      }
      sub_585A0(a1);
    }
    else
    {
      sub_57F10(a1);
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;

//----- (00030F60) --------------------------------------------------------
int __cdecl sub_30F60(int a1)
{
  int v1; // eax
  int result; // eax
  int v3; // eax
  int v4; // esi
  int v5; // eax
  unsigned int v6; // edx
  __int16 v7; // [esp+0h] [ebp-10h]
  __int16 v8; // [esp+2h] [ebp-Eh]
  __int16 v9; // [esp+4h] [ebp-Ch]
  int v10; // [esp+8h] [ebp-8h]
  int v11; // [esp+Ch] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  if ( !(*(_BYTE *)(a1 + 12) & 2) )
  {
    v3 = dword_D41A0 + 28302;
    *(_BYTE *)(a1 + 12) |= 2u;
    sub_6E450((a1 - v3) / 168, -1, 3);
  }
  result = sub_10080(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 16));
  v4 = result;
  if ( result )
  {
    while ( sub_10130(v4, &v11, &v10) == 1 )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      if ( 2 * ((signed int)(*(unsigned __int16 *)(a1 + 20) % 0x9Du) / 79) - 1 > 0 )
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v7 = *(_WORD *)(a1 + 76) - 96 + 192 * v11 + *(_WORD *)(a1 + 20) % 0x81u - 64;
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v8 = *(_WORD *)(a1 + 78) - 96 + 192 * v10 + *(_WORD *)(a1 + 20) % 0x81u - 64;
        v9 = *(_WORD *)(a1 + 80);
        v5 = sub_4A190((int)&v7, 10, 0);
        if ( v5 )
        {
          *(_WORD *)(v5 + 26) = *(_WORD *)(a1 + 26);
          *(_WORD *)(v5 + 28) = *(_WORD *)(a1 + 28);
          v6 = (unsigned int)sub_10000 & *(_DWORD *)(a1 + 12);
          LOBYTE(v6) = v6 | 0x80;
          *(_DWORD *)(v5 + 12) |= v6;
        }
      }
    }
    result = sub_10100(v4);
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;

//----- (00031100) --------------------------------------------------------
int __cdecl sub_31100(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = result - 1;
  if ( result < 0 )
    result = sub_57F10(a1);
  return result;
}

//----- (00031120) --------------------------------------------------------
int __cdecl sub_31120(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // eax
  char v4; // [esp+0h] [ebp-4h]

  v4 = 0;
  result = sub_10C40((__int16 *)(a1 + 76));
  if ( (_WORD)result != *(_WORD *)(a1 + 80) )
    goto LABEL_12;
  if ( *(_DWORD *)(a1 + 4) - 5 == *(_DWORD *)(a1 + 8) )
  {
    sub_4A190(a1 + 76, 10, 87);
    v2 = dword_D41A0;
    v3 = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
    *(_DWORD *)(dword_D41A0 + 8) = v3;
    if ( !(v3 & 1) )
      sub_6E450((a1 - (v2 + 28302)) / 168, -1, *(_WORD *)(a1 + 90) - 282);
  }
  result = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = result - 1;
  if ( result < 0 )
LABEL_12:
    v4 = 1;
  else
    result = sub_585A0(a1);
  if ( v4 )
    result = sub_57F10(a1);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (000311E0) --------------------------------------------------------
char __cdecl sub_311E0(int a1)
{
  unsigned int v1; // eax
  int v2; // eax
  unsigned __int8 v3; // dl
  __int16 v4; // di
  __int16 v5; // si
  __int16 v6; // ax
  signed int v7; // edi
  char v8; // al
  char v9; // al
  signed int v10; // eax
  int v11; // eax
  int v12; // esi
  int v13; // eax
  unsigned int j; // esi
  signed int v15; // eax
  signed int v16; // ecx
  signed int v17; // eax
  signed int v18; // edx
  int v19; // ecx
  int v20; // edx
  int v21; // eax
  unsigned __int8 v22; // dh
  char v23; // cl
  int v24; // eax
  unsigned __int16 v25; // dx
  __int16 v26; // si
  __int16 v28; // [esp+0h] [ebp-50h]
  __int16 v29; // [esp+2h] [ebp-4Eh]
  int v30; // [esp+8h] [ebp-48h]
  unsigned int v31; // [esp+Ch] [ebp-44h]
  int v32; // [esp+10h] [ebp-40h]
  int v33; // [esp+14h] [ebp-3Ch]
  int v34; // [esp+18h] [ebp-38h]
  int v35; // [esp+1Ch] [ebp-34h]
  int v36; // [esp+20h] [ebp-30h]
  int k; // [esp+24h] [ebp-2Ch]
  int v38; // [esp+28h] [ebp-28h]
  int v39; // [esp+2Ch] [ebp-24h]
  int v40; // [esp+30h] [ebp-20h]
  int v41; // [esp+34h] [ebp-1Ch]
  int v42; // [esp+38h] [ebp-18h]
  int v43; // [esp+3Ch] [ebp-14h]
  int v44; // [esp+40h] [ebp-10h]
  int v45; // [esp+44h] [ebp-Ch]
  int v46; // [esp+48h] [ebp-8h]
  unsigned __int16 i; // [esp+4Ch] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 4);
  if ( v1 < 1 )
    goto LABEL_78;
  if ( v1 <= 1 )
  {
    v39 = 5;
    goto LABEL_8;
  }
  if ( v1 == 2 )
    v39 = 7;
  else
LABEL_78:
    v39 = 3;
LABEL_8:
  v36 = v39 + 12;
  LOBYTE(v2) = *(_BYTE *)(a1 + 70);
  if ( (unsigned __int8)v2 < 2u )
  {
    if ( (_BYTE)v2 )
      return v2;
    v3 = ((unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8) - v36;
    BYTE1(v46) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - v36;
    v4 = BYTE1(v46);
    v5 = v3;
    LOBYTE(v46) = v3;
    *(_WORD *)(a1 + 80) = sub_48EF0(v3, BYTE1(v46), 2 * v36, 2 * v36);
    v6 = sub_48E60(v5, v4, 2 * v36, 2 * v36);
    *(_DWORD *)(a1 + 8) = 40;
    *(_WORD *)(a1 + 44) = 227;
    *(_WORD *)(a1 + 54) = 0;
    *(_BYTE *)(a1 + 70) = 2;
    *(_WORD *)(a1 + 158) = v6;
  }
  else if ( (unsigned __int8)v2 > 2u )
  {
    if ( (_BYTE)v2 == 3 )
      LOBYTE(v2) = sub_57F10(a1);
    return v2;
  }
  v32 = *(signed __int16 *)(a1 + 80);
  v42 = *(signed __int16 *)(a1 + 158);
  v33 = 0;
  v44 = v32 - v42;
  v35 = 0;
  v7 = *(signed __int16 *)(a1 + 44);
  LOBYTE(v2) = v39;
  v44 = ((v32 - v42) >> 1) + v32 - v42;
  v38 = v39;
  while ( v33 < 6 )
  {
    v43 = v35 - 1024;
    if ( v35 - 1024 < 0 )
      v43 = 0;
    if ( v36 << 8 < v43 )
      v43 = v36 << 8;
    v35 = v38 << 8;
    LOBYTE(v2) = 2 * v38;
    v41 = 2 * v38;
    if ( v7 > 0 && v7 <= 512 )
    {
      v8 = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - v38;
      LOBYTE(v46) = ((unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8) - v38;
      BYTE1(v46) = v8;
      v34 = 0;
      for ( i = v46; ; ++HIBYTE(i) )
      {
        LOBYTE(v2) = v34;
        if ( v34 >= v41 )
          break;
        v40 = 0;
        v9 = v46;
        while ( 1 )
        {
          LOBYTE(i) = v9;
          if ( v40 >= v41 )
            break;
          v28 = (unsigned __int8)i << 8;
          v29 = HIBYTE(i) << 8;
          v10 = sub_58490((_WORD *)(a1 + 76), &v28);
          if ( v10 < v35 && v10 >= v43 )
          {
            v11 = (v44 * ((_DWORD)((_DWORD)sub_10000 + (signed int)off_DBF50[(v10 << 10) / v35]) >> 1) >> 16)
                * ((char *)sub_10000 - (char *)off_DBF50[v7]);
            v12 = v11 >> 16;
            v45 = (v11 >> 18) + v42;
            if ( (unsigned __int8)byte_11B4E0[i] < v45 )
              sub_570F0((unsigned __int8)i, HIBYTE(i), v45, 0, 1, 1);
            v13 = (unsigned __int8)byte_14B4E0[i];
            v45 = v32 - v12;
            if ( v32 - v12 < 0 )
              v45 = 0;
            if ( v13 > v45 )
              byte_14B4E0[i] = v45;
            for ( j = *(_DWORD *)(dword_D41A4 + 38519); j > dword_EA3E4[0]; j = *(_DWORD *)j )
            {
              if ( !*(_BYTE *)(j + 64) )
              {
                v15 = abs(v28 - *(signed __int16 *)(j + 76));
                v16 = v15;
                if ( v15 >= 0x8000 )
                  v16 = abs(v15 - (_DWORD)sub_10000);
                v17 = abs(v29 - *(signed __int16 *)(j + 78));
                v18 = v17;
                if ( v17 >= 0x8000 )
                  v18 = abs(v17 - (_DWORD)sub_10000);
                v19 = v16 * v16;
                v20 = v18 * v18;
                if ( v19 + v20 <= (signed int)&loc_64000 )
                {
                  v31 = sub_7277A((unsigned int)((char *)&loc_64000 - v19 - v20)) >> 5;
                  v30 = *(signed __int16 *)(j + 80) >> 5;
                  v45 = v30 - v31;
                  if ( (signed int)(v30 - v31) < 0 )
                    v45 = 0;
                  if ( v45 > 254 )
                    v45 = 254;
                  if ( (unsigned __int8)byte_11B4E0[i] > v45 )
                    sub_570F0((unsigned __int8)i, HIBYTE(i), v45, 0, 0, 1);
                  v45 = v31 + v30;
                  if ( (signed int)(v31 + v30) < 0 )
                    v45 = 0;
                  if ( v45 > 254 )
                    v45 = 254;
                  if ( (unsigned __int8)byte_14B4E0[i] < v45 )
                    byte_14B4E0[i] = v45;
                }
              }
            }
          }
          v21 = i;
          v22 = byte_11B4E0[i];
          if ( (unsigned __int8)byte_14B4E0[i] > v22 )
          {
            byte_13B4E0[i] &= 0xF7u;
          }
          else
          {
            v23 = byte_13B4E0[i] | 8;
            byte_14B4E0[i] = v22;
            byte_13B4E0[v21] = v23;
          }
          v9 = i + 1;
          ++v40;
        }
        ++v34;
      }
    }
    v7 -= 68;
    ++v33;
    v38 += 2;
  }
  if ( !*(_WORD *)(a1 + 54) && *(_WORD *)(a1 + 44) > 455 )
  {
    *(_WORD *)(a1 + 54) = 1;
    for ( k = 0; k < 2048; k += 28 )
    {
      v24 = (v39 << 8) - 768;
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      if ( v24 < 256 )
        v24 = 256;
      if ( v24 > 0x2000 )
        LOWORD(v24) = 0x2000;
      sub_57FA0(&word_EB398, k, 0, v24);
      v2 = sub_4A190((int)&word_EB398, 10, 13);
      if ( v2 )
      {
        *(_WORD *)(v2 + 28) = k;
        v25 = i;
        *(_WORD *)(v2 + 134) = 512;
        word_EB39C = 32 * (unsigned __int8)byte_11B4E0[v25];
        LOBYTE(v2) = sub_57CF0(v2, (int)&word_EB398);
      }
    }
  }
  v26 = *(_WORD *)(a1 + 44) + 22;
  *(_DWORD *)(a1 + 8) += 4;
  *(_WORD *)(a1 + 44) = v26;
  if ( v26 > 1024 )
    *(_BYTE *)(a1 + 70) = 3;
  return v2;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A4: using guessed type int dword_D41A4;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00031760) --------------------------------------------------------
char __cdecl sub_31760(int a1)
{
  int v1; // eax
  int v2; // esi
  __int16 v3; // cx
  char v4; // ah
  int v5; // eax
  __int16 v6; // dx
  __int16 v7; // di
  int (*v8)(); // eax

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    goto LABEL_17;
  sub_5C870(a1);
  if ( *(_DWORD *)(a1 + 8) < 12 )
  {
    if ( *(_DWORD *)(a1 + 16) > 0 )
    {
      v3 = *(_WORD *)(a1 + 90);
      --*(_DWORD *)(a1 + 16);
      v4 = *(_BYTE *)(a1 + 12);
      *(_WORD *)(a1 + 90) = v3 - 1;
      if ( v4 >= 0 )
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        if ( !(*(unsigned __int16 *)(a1 + 20) % 7u) )
        {
          v5 = sub_4A190(a1 + 76, 10, 14);
          if ( v5 )
          {
            v6 = *(_WORD *)(a1 + 26);
            *(_DWORD *)(v5 + 16) = 100;
            v7 = *(_WORD *)(v5 + 90);
            *(_DWORD *)(v5 + 8) = 15;
            *(_WORD *)(v5 + 26) = v6;
            *(_WORD *)(v5 + 90) = v7 + 2;
          }
        }
      }
    }
  }
  else if ( *(_DWORD *)(a1 + 16) <= 6 )
  {
    v2 = *(_DWORD *)(a1 + 16) + 1;
    ++*(_WORD *)(a1 + 90);
    *(_DWORD *)(a1 + 16) = v2;
  }
  *(_WORD *)(a1 + 80) = *(_WORD *)(a1 + 44) + sub_10C40((__int16 *)(a1 + 76));
  v8 = sub_104D0((signed __int16 *)(a1 + 76));
  if ( v8 == (int (*)())1 )
LABEL_17:
    LOBYTE(v8) = sub_57F10(a1);
  if ( !(*(_BYTE *)(a1 + 14) & 1) )
    LOBYTE(v8) = sub_11400(a1, 0, *(_WORD *)(a1 + 42));
  return (char)v8;
}

//----- (00031870) --------------------------------------------------------
int __cdecl sub_31870(int a1)
{
  return sub_57F10(a1);
}

//----- (00031890) --------------------------------------------------------
int __cdecl sub_31890(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = result - 1;
  if ( result < 0 )
    result = sub_57F10(a1);
  return result;
}

//----- (000318B0) --------------------------------------------------------
void __cdecl sub_318B0(int a1)
{
  int v1; // edx
  int v2; // eax

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 >= 0 )
  {
    sub_585A0(a1);
    if ( !(*(_BYTE *)(a1 + 12) & 2) )
    {
      v2 = dword_D41A0 + 28302;
      *(_BYTE *)(a1 + 12) |= 2u;
      sub_6E450((a1 - v2) / 168, -1, 27);
    }
  }
  else
  {
    sub_57F10(a1);
  }
}
// D41A0: using guessed type int dword_D41A0;

//----- (00031920) --------------------------------------------------------
int __cdecl sub_31920(int a1)
{
  return sub_57F10(a1);
}

//----- (00031940) --------------------------------------------------------
char __cdecl sub_31940(int a1)
{
  int v1; // eax
  unsigned int v2; // ebx
  __int16 v3; // ST0C_2
  __int16 v4; // ST08_2
  int v5; // esi
  signed int v6; // edi
  int v7; // esi
  int v8; // eax
  unsigned __int16 v9; // bx
  int v10; // edx
  signed int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // edx
  int v15; // eax
  unsigned __int16 v16; // bx
  signed int v17; // edx
  signed int v18; // eax
  unsigned __int16 v19; // si
  int v20; // eax
  int v21; // esi
  int v22; // esi
  unsigned __int16 v23; // bx
  int v24; // eax
  signed int v25; // eax
  unsigned __int16 v26; // bx
  int v27; // edx
  signed int v28; // edx
  unsigned __int16 v29; // si
  __int16 v31; // [esp+0h] [ebp-3Ch]
  __int16 v32; // [esp+2h] [ebp-3Ah]
  int v33; // [esp+8h] [ebp-34h]
  int v34; // [esp+Ch] [ebp-30h]
  int v35; // [esp+10h] [ebp-2Ch]
  int v36; // [esp+14h] [ebp-28h]
  int v37; // [esp+18h] [ebp-24h]
  int v38; // [esp+1Ch] [ebp-20h]
  int v39; // [esp+20h] [ebp-1Ch]
  int v40; // [esp+24h] [ebp-18h]
  int v41; // [esp+28h] [ebp-14h]
  int v42; // [esp+2Ch] [ebp-10h]
  int v43; // [esp+30h] [ebp-Ch]
  int v44; // [esp+34h] [ebp-8h]
  int v45; // [esp+38h] [ebp-4h]

  LOBYTE(v45) = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
  BYTE1(v45) = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
  LOBYTE(v1) = *(_BYTE *)(a1 + 70);
  v39 = 0;
  if ( (unsigned __int8)v1 < 1u )
  {
    if ( (_BYTE)v1 )
      return v1;
    v2 = *(_DWORD *)(a1 + 4);
    LOBYTE(v2) = v2 | 1;
    sub_49EA0((_WORD *)a1, (_WORD)v2 << 8, 0x4000);
    LOBYTE(v44) = v45 - v2;
    BYTE1(v44) = BYTE1(v45) - v2;
    v3 = (unsigned __int8)(BYTE1(v45) - v2);
    v4 = (unsigned __int8)(v45 - v2);
    LOWORD(v2) = 2 * v2;
    *(_WORD *)(a1 + 80) = sub_48E60(v4, v3, v2, v2);
    *(_WORD *)(a1 + 44) = v2 + 100;
    if ( *(signed __int16 *)(a1 + 80) + *(signed __int16 *)(a1 + 44) > 255 )
      *(_WORD *)(a1 + 44) = 255 - *(_WORD *)(a1 + 80);
    *(_BYTE *)(a1 + 70) = 1;
  }
  else if ( (unsigned __int8)v1 > 1u )
  {
    if ( (_BYTE)v1 == 2 )
    {
      v43 = *(signed __int16 *)(a1 + 80) + *(signed __int16 *)(a1 + 44) - 24;
      v20 = *(signed __int16 *)(a1 + 84);
      v21 = v20;
      v20 >>= 8;
      LOBYTE(v44) = v45 - v20;
      BYTE1(v44) = BYTE1(v45) - v20;
      v22 = v21 >> 7;
      HIBYTE(v23) = BYTE1(v45) - v20;
      v24 = 0;
      if ( v22 > 0 )
      {
        do
        {
          LOBYTE(v23) = v44;
          v27 = 0;
          while ( v27 < v22 )
          {
            if ( (unsigned __int8)byte_11B4E0[v23] > v43 )
              byte_11B4E0[v23] = v43;
            ++v27;
            LOBYTE(v23) = v23 + 1;
          }
          ++v24;
          ++HIBYTE(v23);
        }
        while ( v24 < v22 );
        v25 = 0;
        HIBYTE(v26) = BYTE1(v45) - 1;
      }
      else
      {
        v25 = 0;
        HIBYTE(v26) = BYTE1(v45) - 1;
      }
      while ( v25 < 2 )
      {
        v28 = 0;
        LOBYTE(v26) = v45 - 1;
        while ( v28 < 2 )
        {
          byte_11B4E0[v26] = v43 - 16;
          if ( *(_BYTE *)(dword_D41A0 + 196308) )
            v36 = 1;
          else
            v36 = 63;
          v29 = v26;
          ++v28;
          LOBYTE(v26) = v26 + 1;
          byte_12B4E0[v29] = v36;
        }
        ++v25;
        ++HIBYTE(v26);
      }
      LOBYTE(v1) = sub_57F10(a1);
    }
    return v1;
  }
  LOBYTE(v1) = a1;
  v5 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v5;
  if ( v5 <= 0 )
  {
    *(_BYTE *)(a1 + 70) = 2;
  }
  else
  {
    v6 = *(signed __int16 *)(a1 + 84);
    v7 = v6 >> 7;
    LOBYTE(v44) = v45 - BYTE1(v6);
    v34 = v6 - ((((v6 >> 8) - 7) >> 1 << 8) + 512);
    BYTE1(v44) = BYTE1(v45) - BYTE1(v6);
    v8 = 0;
    for ( HIBYTE(v9) = BYTE1(v45) - BYTE1(v6); ; ++HIBYTE(v9) )
    {
      v41 = v8;
      if ( v7 <= v8 )
        break;
      v10 = 0;
      for ( LOBYTE(v9) = v44; ; LOBYTE(v9) = v9 + 1 )
      {
        v40 = v10;
        if ( v7 <= v10 )
          break;
        v31 = (unsigned __int8)v9 << 8;
        v32 = HIBYTE(v9) << 8;
        v11 = sub_58490((_WORD *)(a1 + 76), &v31);
        v33 = v11;
        if ( v11 < v6 )
        {
          v12 = (*(signed __int16 *)(a1 + 44)
               * ((_DWORD)((_DWORD)sub_10000 + (signed int)off_DBF50[(v11 << 10) / v6]) >> 1) >> 16)
              + *(signed __int16 *)(a1 + 80);
          v43 = v12;
          v42 = (unsigned __int8)byte_11B4E0[v9];
          v13 = v12;
          v14 = v42;
          if ( v13 > v42 )
            v14 = (v13 - v42) / *(_DWORD *)(a1 + 8) + v42;
          v43 = v14;
          sub_570F0((unsigned __int8)v9, HIBYTE(v9), v14, 0, v33 <= v34, 1);
          if ( byte_D41B6 )
          {
            v43 += 64;
            if ( v43 > 254 )
              v43 = 254;
            v37 = v9;
            v38 = (unsigned __int8)byte_14B4E0[v9];
            if ( v43 > v38 )
            {
              v15 = (v38 - v43) / *(_DWORD *)(a1 + 8);
              v43 = v38 - v15;
              byte_14B4E0[v37] = v38 - v15;
            }
          }
        }
        if ( byte_D41B6 )
        {
          if ( (unsigned __int8)byte_14B4E0[v9] > (unsigned __int8)byte_11B4E0[v9] )
            byte_13B4E0[v9] &= 0xF7u;
          else
            byte_13B4E0[v9] |= 8u;
        }
        v10 = v40 + 1;
      }
      v8 = v41 + 1;
    }
    if ( !*((_BYTE *)&loc_36E03 + dword_D41A0) )
      v39 = (signed __int16)sub_116A0(a1, 0, *(_WORD *)(a1 + 42));
    if ( v39 )
      sub_6D8B0(*(_WORD *)(a1 + 26), 0x12u, v39);
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
    if ( *((_BYTE *)&loc_36E03 + dword_D41A0) && !(*(_BYTE *)(a1 + 62) & 3) )
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 63);
    LOBYTE(v1) = a1;
    if ( *(_DWORD *)(a1 + 8) == 3 )
    {
      HIBYTE(v16) = BYTE1(v45) - 1;
      v17 = 0;
      v43 = *(signed __int16 *)(a1 + 80) + *(signed __int16 *)(a1 + 44) - 24;
      while ( v17 < 2 )
      {
        v18 = 0;
        LOBYTE(v16) = v45 - 1;
        while ( v18 < 2 )
        {
          byte_11B4E0[v16] = v43 - 16;
          if ( *(_BYTE *)(dword_D41A0 + 196308) )
            v35 = 1;
          else
            v35 = 63;
          v19 = v16;
          ++v18;
          LOBYTE(v16) = v16 + 1;
          byte_12B4E0[v19] = v35;
        }
        ++v17;
        ++HIBYTE(v16);
      }
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      word_EB39C = sub_10C40(&word_EB398);
      v1 = *((_BYTE *)&loc_36E03 + dword_D41A0) ? sub_4A190((int)&word_EB398, 10, 91) : sub_4A190(
                                                                                          (int)&word_EB398,
                                                                                          10,
                                                                                          18);
      if ( v1 )
        *(_WORD *)(v1 + 26) = *(_WORD *)(a1 + 26);
    }
  }
  return v1;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00031E90) --------------------------------------------------------
int __cdecl sub_31E90(signed __int16 *a1)
{
  if ( !(sub_104A0((int)(a1 + 38)) & 1) )
  {
    a1[10] = 9377 * a1[10] + 9439;
    sub_572C0(
      a1,
      0,
      (a1[42] - (__CFSHL__(a1[42] >> 31, 8) + (a1[42] >> 31 << 8))) >> 8,
      -((unsigned __int16)a1[10] % 7u),
      1);
  }
  return sub_57F10((int)a1);
}

//----- (00031F00) --------------------------------------------------------
unsigned int __cdecl sub_31F00(signed __int16 *a1, __int16 a2, __int16 a3)
{
  int v3; // ebx
  int v4; // esi
  int v5; // edi
  unsigned int result; // eax
  int v7; // ebx
  int v8; // [esp+0h] [ebp-Ch]
  int v9; // [esp+4h] [ebp-8h]
  int v10; // [esp+8h] [ebp-4h]

  LOWORD(v3) = a3;
  v4 = (a1[38] + 128) >> 8;
  v5 = (a1[39] + 128) >> 8;
  if ( a3 > (a1[42] - (__CFSHL__(a1[42] >> 31, 8) + (a1[42] >> 31 << 8))) >> 8 )
    v3 = (a1[42] - (__CFSHL__(a1[42] >> 31, 8) + (a1[42] >> 31 << 8))) >> 8;
  v10 = -3;
  result = sub_10080(a2, (signed __int16)v3);
  v7 = result;
  if ( result )
  {
    while ( sub_10130(v7, &v9, &v8) == 1 )
      sub_56F10(v4 + v9, v5 + v8, v10, 0);
    result = sub_10100(v7);
  }
  return result;
}

//----- (00031FB0) --------------------------------------------------------
void __cdecl sub_31FB0(int a1)
{
  int v1; // edx
  unsigned __int16 v2; // ax
  __int16 v3; // ax
  unsigned __int16 v4; // dx
  int v5; // eax
  __int16 v6; // si

  if ( !(*(unsigned __int8 *)(a1 + 62) % 3) )
    ++*(_DWORD *)(a1 + 16);
  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 || sub_104A0(a1 + 76) & 1 )
  {
    sub_57F10(a1);
  }
  else
  {
    if ( *(_BYTE *)(a1 + 12) & 2 )
      v2 = *(unsigned __int16 *)(a1 + 42) / 25;
    else
      v2 = *(_WORD *)(a1 + 42);
    v3 = sub_116A0(a1, 0, v2);
    if ( v3 )
    {
      v4 = *(_WORD *)(a1 + 38);
      if ( v4 >= 0xBu )
      {
        if ( v4 <= 0xBu )
        {
          sub_6D8B0(*(_WORD *)(a1 + 26), 0x10u, v3);
        }
        else if ( v4 == 15 )
        {
          sub_6D8B0(*(_WORD *)(a1 + 26), 0x11u, v3);
        }
      }
    }
    v5 = (*(signed __int16 *)(a1 + 84)
        - (__CFSHL__(*(signed __int16 *)(a1 + 84) >> 31, 8)
         + (*(signed __int16 *)(a1 + 84) >> 31 << 8))) >> 8;
    v6 = *(_WORD *)(a1 + 16);
    if ( v6 > v5 - 1 )
    {
      v6 = v5 - 1;
      if ( !(*(_BYTE *)(a1 + 12) & 2) )
        sub_31F00((signed __int16 *)a1, v5, v5);
    }
    *(_BYTE *)(a1 + 12) |= 2u;
    sub_31F00((signed __int16 *)a1, 0, v6);
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
  }
}
// D41A0: using guessed type int dword_D41A0;

//----- (000320E0) --------------------------------------------------------
int __cdecl sub_320E0(int a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 8);
  ++*(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  sub_585A0(a1);
  return sub_112D0(a1, 0);
}

//----- (00032120) --------------------------------------------------------
int __cdecl sub_32120(int a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 8);
  ++*(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  sub_585A0(a1);
  return sub_112D0(a1, 1u);
}

//----- (00032160) --------------------------------------------------------
int __cdecl sub_32160(int a1)
{
  int v1; // eax
  __int16 v3; // dx
  __int16 v4; // ax
  int v5; // edx
  __int16 v6; // ax
  __int16 v7; // si
  __int16 v8; // ax

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  v3 = *(_WORD *)(a1 + 130) - 4;
  *(_WORD *)(a1 + 130) = v3;
  if ( v3 < 64 )
    *(_WORD *)(a1 + 130) = 64;
  if ( *(_WORD *)(a1 + 130) > 128 )
    *(_WORD *)(a1 + 130) = 128;
  word_EB39C += *(_WORD *)(a1 + 130);
  v4 = sub_10C40((__int16 *)(a1 + 76));
  if ( word_EB39C < v4 )
    word_EB39C = v4;
  v5 = *(_DWORD *)(a1 + 16) + 1;
  *(_DWORD *)(a1 + 16) = v5;
  if ( v5 < 16 )
  {
    sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 134));
    v6 = *(_WORD *)(a1 + 134) - 52;
    *(_WORD *)(a1 + 134) = v6;
    if ( v6 < 30 )
      *(_WORD *)(a1 + 134) = 30;
    if ( *(_WORD *)(a1 + 134) > 1024 )
      *(_WORD *)(a1 + 134) = 1024;
    if ( !(*(_BYTE *)(a1 + 16) & 1) )
    {
      v7 = *(_WORD *)(a1 + 90);
      if ( v7 < 74 )
        *(_WORD *)(a1 + 90) = v7 + 1;
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 6 )
  {
    v8 = *(_WORD *)(a1 + 90);
    if ( v8 > 67 )
      *(_WORD *)(a1 + 90) = v8 - 1;
  }
  return sub_57CF0(a1, (int)&word_EB398);
}
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (000322A0) --------------------------------------------------------
int __cdecl sub_322A0(int a1)
{
  int v1; // eax
  __int16 v3; // dx
  __int16 v4; // ax
  int v5; // edx
  __int16 v6; // ax
  __int16 v7; // si
  __int16 v8; // ax

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  v3 = *(_WORD *)(a1 + 130) - 4;
  *(_WORD *)(a1 + 130) = v3;
  if ( v3 < 64 )
    *(_WORD *)(a1 + 130) = 64;
  if ( *(_WORD *)(a1 + 130) > 128 )
    *(_WORD *)(a1 + 130) = 128;
  word_EB39C += *(_WORD *)(a1 + 130);
  v4 = sub_10C40((__int16 *)(a1 + 76));
  if ( word_EB39C < v4 )
    word_EB39C = v4;
  v5 = *(_DWORD *)(a1 + 16) + 1;
  *(_DWORD *)(a1 + 16) = v5;
  if ( v5 < 16 )
  {
    sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 134));
    v6 = *(_WORD *)(a1 + 134) - 52;
    *(_WORD *)(a1 + 134) = v6;
    if ( v6 < 30 )
      *(_WORD *)(a1 + 134) = 30;
    if ( *(_WORD *)(a1 + 134) > 1024 )
      *(_WORD *)(a1 + 134) = 1024;
    if ( !(*(_BYTE *)(a1 + 16) & 1) )
    {
      v7 = *(_WORD *)(a1 + 90);
      if ( v7 < 16 )
        *(_WORD *)(a1 + 90) = v7 + 1;
    }
  }
  if ( *(_DWORD *)(a1 + 8) < 6 )
  {
    v8 = *(_WORD *)(a1 + 90);
    if ( v8 > 9 )
      *(_WORD *)(a1 + 90) = v8 - 1;
  }
  return sub_57CF0(a1, (int)&word_EB398);
}
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (000323E0) --------------------------------------------------------
char __cdecl sub_323E0(int a1)
{
  return sub_32420(a1);
}

//----- (00032400) --------------------------------------------------------
char __cdecl sub_32400(int a1)
{
  return sub_32420(a1);
}

//----- (00032420) --------------------------------------------------------
char __cdecl sub_32420(int a1)
{
  int v1; // ecx
  int v2; // eax
  int v3; // eax
  __int16 v4; // dx
  __int16 v5; // ax
  __int16 v6; // dx
  __int16 v7; // ax
  int v9; // [esp+0h] [ebp-8h]
  __int16 v10; // [esp+4h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 - 1;
  if ( v2 < 0 )
  {
    LOBYTE(v3) = sub_57F10(a1);
    return v3;
  }
  v9 = *(_DWORD *)(a1 + 76);
  v10 = *(_WORD *)(a1 + 80);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  LOWORD(v9) = *(_WORD *)(a1 + 20) % 0xA0u + v9;
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  v10 += *(_WORD *)(a1 + 20) % 0xA0u;
  LOBYTE(v3) = *(_BYTE *)(a1 + 64);
  if ( (unsigned __int8)v3 >= 0x3Bu )
  {
    if ( (unsigned __int8)v3 <= 0x3Bu )
    {
      v3 = sub_4E9E0((int)&v9);
    }
    else
    {
      if ( (_BYTE)v3 != 60 )
        goto LABEL_10;
      v3 = sub_4EA20((int)&v9);
    }
    v1 = v3;
  }
LABEL_10:
  if ( v1 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v4 = *(_WORD *)(a1 + 20) % 0x4Du;
    v5 = *(_WORD *)(a1 + 130);
    *(_DWORD *)(v1 + 8) = 32;
    v6 = v5 + v4;
    v7 = *(_WORD *)(v1 + 130);
    *(_DWORD *)(v1 + 4) = 32;
    LOWORD(v3) = v6 + v7;
    *(_WORD *)(v1 + 130) = v3;
  }
  return v3;
}

//----- (00032530) --------------------------------------------------------
int __cdecl sub_32530(int a1)
{
  int v1; // ecx
  int v2; // eax
  int result; // eax
  __int16 v4; // dx

  if ( sub_104A0(a1 + 76) & 1 )
  {
    ++*(_DWORD *)(a1 + 16);
  }
  else
  {
    v1 = *(_DWORD *)(a1 + 16);
    if ( v1 > 0 )
      *(_DWORD *)(a1 + 16) = v1 - 1;
  }
  v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 - 1;
  if ( v2 < 0 || *(_DWORD *)(a1 + 16) > 8 )
    return sub_57F10(a1);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  *(_WORD *)(a1 + 28) = (*(_WORD *)(a1 + 20) % 0x5Bu + *(_WORD *)(a1 + 28) - 45) & 0x7FF;
  sub_57FA0((_WORD *)(a1 + 76), *(_WORD *)(a1 + 28), 0, 256);
  result = sub_4A190(a1 + 76, 10, 11);
  if ( result )
  {
    *(_DWORD *)(result + 84) = *(_DWORD *)(a1 + 84);
    *(_WORD *)(result + 88) = *(_WORD *)(a1 + 88);
    *(_DWORD *)(result + 8) = 10;
    v4 = *(_WORD *)(a1 + 26);
    *(_WORD *)(result + 38) = 15;
    *(_WORD *)(result + 26) = v4;
  }
  return result;
}

//----- (00032600) --------------------------------------------------------
__int16 __cdecl sub_32600(int a1)
{
  int v1; // eax
  int v2; // eax
  char v3; // ah
  __int16 v4; // di
  __int16 v5; // ax
  __int16 v6; // ax
  __int16 v7; // si
  int v8; // edx
  int v9; // eax
  int v10; // eax
  __int16 v11; // cx
  int v12; // eax
  int v13; // edx

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 >= 0 )
  {
    v3 = *(_BYTE *)(a1 + 12);
    if ( !(v3 & 2) )
      *(_BYTE *)(a1 + 12) = v3 | 2;
    if ( *(signed __int16 *)(a1 + 154) < -80 )
      *(_WORD *)(a1 + 154) = -80;
    if ( *(_WORD *)(a1 + 154) > 80 )
      *(_WORD *)(a1 + 154) = 80;
    if ( *(signed __int16 *)(a1 + 156) < -80 )
      *(_WORD *)(a1 + 156) = -80;
    if ( *(_WORD *)(a1 + 156) > 80 )
      *(_WORD *)(a1 + 156) = 80;
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v4 = *(_WORD *)(a1 + 156);
    word_EB398 = *(_WORD *)(a1 + 154) + *(_WORD *)(a1 + 76);
    word_EB39A = v4 + *(_WORD *)(a1 + 78);
    v5 = *(_WORD *)(a1 + 44);
    word_EB39C += v5;
    *(_WORD *)(a1 + 44) = v5 - 28;
    if ( (signed __int16)(v5 - 28) < -384 )
      *(_WORD *)(a1 + 44) = -384;
    if ( *(_WORD *)(a1 + 44) > 256 )
      *(_WORD *)(a1 + 44) = 256;
    v6 = sub_10C40(&word_EB398);
    v7 = v6;
    if ( v6 > word_EB39C )
    {
      v8 = *(signed __int16 *)(a1 + 44);
      word_EB39C = v6;
      *(_WORD *)(a1 + 44) = -((v8 - (__CFSHL__(v8 >> 31, 2) + 4 * (v8 >> 31))) >> 2);
      if ( sub_104D0((signed __int16 *)(a1 + 76)) == (int (*)())1 )
      {
        v9 = sub_4A190((int)&word_EB398, 10, 5);
        if ( v9 )
        {
          *(_WORD *)(v9 + 26) = *(_WORD *)(a1 + 26);
          sub_57F10(a1);
        }
      }
      else
      {
        if ( !sub_10B70((unsigned __int16 *)&word_EB398, 10, 6) )
        {
          v10 = sub_4A190((int)&word_EB398, 10, 6);
          if ( v10 )
          {
            v11 = *(_WORD *)(v10 + 42);
            *(_WORD *)(v10 + 26) = *(_WORD *)(a1 + 26);
            *(_DWORD *)(v10 + 8) = 30;
            *(_WORD *)(v10 + 42) = 3 * v11;
            *(_DWORD *)(a1 + 16) = 0;
          }
        }
        if ( *(_WORD *)(a1 + 44) <= 28 )
          *(_WORD *)(a1 + 44) = 0;
      }
    }
    ++*(_DWORD *)(a1 + 16);
    sub_57CF0(a1, (int)&word_EB398);
    LOWORD(v2) = word_EB39C;
    if ( v7 == word_EB39C )
    {
      sub_58030(a1 + 76, &word_EB398);
      *(_WORD *)(a1 + 154) += word_EB398;
      v12 = (250 * *(signed __int16 *)(a1 + 154)
           - (__CFSHL__(250 * *(signed __int16 *)(a1 + 154) >> 31, 8)
            + (250 * *(signed __int16 *)(a1 + 154) >> 31 << 8))) >> 8;
      *(_WORD *)(a1 + 156) += word_EB39A;
      v13 = *(signed __int16 *)(a1 + 156);
      *(_WORD *)(a1 + 154) = v12;
      v2 = (250 * v13 - (__CFSHL__(250 * v13 >> 31, 8) + (250 * v13 >> 31 << 8))) >> 8;
      *(_WORD *)(a1 + 156) = v2;
    }
  }
  else
  {
    LOWORD(v2) = sub_57F10(a1);
  }
  return v2;
}
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00032880) --------------------------------------------------------
int __cdecl sub_32880(int a1)
{
  int v1; // edx
  int result; // eax
  int v3; // edx
  __int16 v4; // ax
  int v5; // edi
  int v6; // eax
  int v7; // esi
  int v8; // ecx
  __int16 v9; // [esp+0h] [ebp-10h]
  __int16 v10; // [esp+2h] [ebp-Eh]
  __int16 v11; // [esp+4h] [ebp-Ch]
  int v12; // [esp+8h] [ebp-8h]
  int v13; // [esp+Ch] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  if ( !(*(_BYTE *)(a1 + 12) & 2) )
  {
    v3 = a1 - (dword_D41A0 + 28302);
    *(_DWORD *)(a1 + 12) |= (unsigned int)&loc_10001 + 1;
    sub_6E450(v3 / 168, -1, 30);
  }
  sub_49EA0(
    (_WORD *)a1,
    (768 * *(_DWORD *)(a1 + 16)
   - (__CFSHL__(768 * *(_DWORD *)(a1 + 16) >> 31, 2)
    + 4 * (768 * *(_DWORD *)(a1 + 16) >> 31))) >> 2,
    512);
  v4 = sub_10C80(a1, 0, (signed int)*(unsigned __int16 *)(a1 + 42) / *(_DWORD *)(a1 + 4));
  if ( v4 )
    sub_6D8B0(*(_WORD *)(a1 + 26), 9u, v4);
  v5 = sub_10080(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 16));
  if ( v5 )
  {
    while ( sub_10130(v5, &v12, &v13) == 1 )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v9 = *(_WORD *)(a1 + 76) - 96 + 160 * v12 + *(_WORD *)(a1 + 20) % 0x81u - 64;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v10 = *(_WORD *)(a1 + 20) % 0x81u + 160 * v13 + *(_WORD *)(a1 + 78) - 96 - 64;
      v11 = *(_WORD *)(a1 + 80);
      v6 = sub_4A190((int)&v9, 10, 0);
      v7 = v6;
      if ( v6 )
      {
        v8 = *(_DWORD *)(v6 + 12);
        *(_WORD *)(v6 + 26) = *(_WORD *)(a1 + 26);
        *(_WORD *)(v6 + 28) = *(_WORD *)(a1 + 28);
        *(_DWORD *)(v6 + 12) = (unsigned int)sub_10080 | v8;
        sub_49EA0((_WORD *)v6, 512, 512);
        *(_DWORD *)(v7 + 16) = 0;
      }
    }
    sub_10100(v5);
  }
  result = (*(_DWORD *)(a1 + 16) + 2) / 11;
  *(_DWORD *)(a1 + 16) = (*(_DWORD *)(a1 + 16) + 2) % 11;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00032A70) --------------------------------------------------------
void __cdecl sub_32A70(int a1)
{
  __int16 v1; // si
  __int16 v2; // ax
  __int16 v3; // si
  __int16 v4; // ax
  unsigned int v5; // eax
  int v6; // eax
  int v7; // esi
  int v8; // eax
  __int16 v9; // dx
  int v10; // esi
  __int16 v11; // ax
  int v12; // [esp+0h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 16) > 2500 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    if ( !(*(unsigned __int16 *)(a1 + 20) % 0x64u) && !*(_WORD *)(dword_D41A0 + 49) )
    {
      v1 = *(_WORD *)(a1 + 80);
      v2 = sub_10C40((__int16 *)(a1 + 76));
      *(_WORD *)(a1 + 80) = v2;
      if ( v1 != v2 )
      {
        sub_57F10(a1);
        return;
      }
      *(_DWORD *)(a1 + 16) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 16) < 128
    && *(_BYTE *)(a1 + 16) & 0xF
    && (*(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439, !(*(unsigned __int16 *)(a1 + 20) % 5u))
    || !*(_DWORD *)(a1 + 16) )
  {
    v3 = *(_WORD *)(a1 + 80);
    v4 = sub_10C40((__int16 *)(a1 + 76));
    *(_WORD *)(a1 + 80) = v4;
    if ( v3 != v4 )
    {
      sub_57F10(a1);
      *(_WORD *)(dword_D41A0 + 49) = 0;
      return;
    }
    if ( !*(_DWORD *)(a1 + 16) )
    {
      v5 = dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 49)];
      if ( v5 > dword_EA3E4[0] )
        *(_DWORD *)(v5 + 16) = 250;
      *(_WORD *)(dword_D41A0 + 49) = (a1 - (dword_D41A0 + 28302)) / 168;
      v6 = sub_4A190(a1 + 76, 10, 19);
      v7 = v6;
      if ( v6 )
      {
        *(_WORD *)(v6 + 26) = *(_WORD *)(a1 + 26);
        if ( (unsigned int)dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 51)] > dword_EA3E4[0] )
          sub_57F10(dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 51)]);
        *(_WORD *)(dword_D41A0 + 51) = (v7 - (dword_D41A0 + 28302)) / 168;
      }
    }
    v8 = sub_4A190(a1 + 76, 10, 16);
    if ( v8 )
    {
      *(_WORD *)(v8 + 26) = *(_WORD *)(a1 + 26);
      v9 = 9377 * *(_WORD *)(a1 + 20) + 9439;
      *(_WORD *)(a1 + 20) = v9;
      *(_WORD *)(v8 + 20) = v9;
    }
    v10 = *(_DWORD *)(a1 + 16);
    *(_BYTE *)(a1 + 29) += 5;
    if ( !v10 )
    {
      v12 = sub_4A190(a1 + 76, 9, 0);
      if ( v12 )
      {
        *(_WORD *)(v12 + 26) = *(_WORD *)(a1 + 26);
        v11 = *(_WORD *)(a1 + 28);
        *(_WORD *)(v12 + 30) = -386;
        *(_BYTE *)(v12 + 67) = 10;
        *(_BYTE *)(v12 + 68) = 17;
        HIBYTE(v11) &= 7u;
        *(_DWORD *)(v12 + 8) = 1;
        *(_WORD *)(v12 + 28) = v11;
        *(_DWORD *)(v12 + 154) = *(_DWORD *)(a1 + 76);
        *(_WORD *)(v12 + 158) = *(_WORD *)(a1 + 80);
        sub_57FA0((_WORD *)(v12 + 154), *(_WORD *)(v12 + 28), 0, 1536);
        *(_WORD *)(v12 + 158) = sub_10C40((__int16 *)(v12 + 154));
      }
    }
    if ( *(_DWORD *)(a1 + 16) >= 127 )
    {
      sub_57F10(a1);
      *(_WORD *)(dword_D41A0 + 49) = 0;
    }
  }
  ++*(_DWORD *)(a1 + 16);
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00032CF0) --------------------------------------------------------
void __cdecl sub_32CF0(int a1)
{
  int v1; // eax
  int v2; // ecx
  signed int v3; // ebx
  char v4; // ah
  __int16 v5; // dx
  __int16 v6; // ax
  unsigned int v7; // ecx
  signed int v8; // esi
  __int16 v9; // ax
  __int16 v10; // ax
  __int16 v11; // cx
  char *v12; // esi
  signed int v13; // ebx
  int v14; // ST0C_4
  unsigned __int16 v15; // ST08_2
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 3; ++i )
  {
    v1 = sub_4A190(a1 + 76, 10, 39);
    v2 = v1;
    v3 = v1;
    if ( v1 )
    {
      v4 = *(_BYTE *)(v1 + 13) | 0x20;
      *(_DWORD *)(v2 + 4) = 140;
      *(_BYTE *)(v2 + 13) = v4;
      *(_DWORD *)(v2 + 8) = *(_DWORD *)(v2 + 4);
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v5 = *(_WORD *)(a1 + 20) % 0x300u;
      *(_WORD *)(v2 + 130) = v5;
      if ( v5 < 64 )
        *(_WORD *)(v2 + 130) = 64;
      if ( *(_WORD *)(v3 + 130) > 768 )
        *(_WORD *)(v3 + 130) = 768;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v6 = *(_WORD *)(a1 + 20) & 0x7F;
      *(_WORD *)(v3 + 148) = 0;
      *(_WORD *)(v3 + 44) = v6 + 128;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v7 = *(unsigned __int16 *)(a1 + 20) % 9u - 1;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v8 = 0;
      *(_DWORD *)(v3 + 144) = *(unsigned __int16 *)(a1 + 20) % 0xA00u + 1;
      while ( v8 < 7 && *(_DWORD *)(v3 + 144) > dword_DB538[v8] )
        ++v8;
      v9 = sub_36A50(v3, v7);
      sub_49CD0((_WORD *)v3, v8 + v9);
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v10 = *(_WORD *)(a1 + 20) & 0x7FF;
      *(_WORD *)(v3 + 30) = 0;
      *(_WORD *)(v3 + 28) = v10;
      *(_WORD *)(v3 + 32) = *(_WORD *)(v3 + 28);
      *(_DWORD *)(v3 + 154) = *(_DWORD *)(a1 + 76);
      *(_WORD *)(v3 + 158) = *(_WORD *)(a1 + 80);
      sub_57FA0((_WORD *)(v3 + 154), *(_WORD *)(v3 + 28), 0, *(_WORD *)(v3 + 130));
      v11 = *(_WORD *)(v3 + 156) - *(_WORD *)(v3 + 78);
      *(_WORD *)(v3 + 154) -= *(_WORD *)(v3 + 76);
      *(_WORD *)(v3 + 156) = v11;
      *(_WORD *)(v3 + 80) = sub_10C40((__int16 *)(v3 + 76)) + 96;
    }
  }
  if ( !(*(_BYTE *)(a1 + 62) & 1) )
  {
    v12 = byte_DA818;
    v13 = 0;
    while ( v13 < 26 )
    {
      v14 = (*(_DWORD *)(v12 + 66) - (__CFSHL__(*(_DWORD *)(v12 + 66) >> 31, 9) + (*(_DWORD *)(v12 + 66) >> 31 << 9))) >> 9;
      v15 = v13++;
      v12 += 80;
      sub_6D8B0(*(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240), v15, v14);
    }
  }
}
// D41A0: using guessed type int dword_D41A0;

//----- (00032F40) --------------------------------------------------------
int __cdecl sub_32F40(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // eax
  __int16 v5; // [esp+0h] [ebp-14h]
  __int16 v6; // [esp+2h] [ebp-12h]
  __int16 v7; // [esp+4h] [ebp-10h]
  int v8; // [esp+8h] [ebp-Ch]
  int v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+10h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 >= 0 )
  {
    *(_DWORD *)(a1 + 16) = 0;
    v2 = sub_10080(0, *(_DWORD *)(a1 + 16));
    if ( v2 )
    {
      while ( sub_10130(v2, &v9, &v8) == 1 )
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        if ( 2 * ((signed int)(*(unsigned __int16 *)(a1 + 20) % 0x9Du) / 79) - 1 > 0 )
        {
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          v5 = *(_WORD *)(a1 + 20) % 0x81u + *(_WORD *)(a1 + 76) - 96 + 192 * v9 - 64;
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          v6 = *(_WORD *)(a1 + 78) - 96 + 192 * v8 + *(_WORD *)(a1 + 20) % 0x81u - 64;
          v7 = *(_WORD *)(a1 + 80);
          if ( *(_BYTE *)(a1 + 8) & 1 )
          {
            LOWORD(v10) = (*(_DWORD *)(a1 + 8) / 2 & 1) << 8;
            while ( (unsigned __int16)v10 < 0x800u )
            {
              v3 = sub_4A190((int)&v5, 10, 14);
              if ( v3 )
              {
                *(_WORD *)(v3 + 26) = *(_WORD *)(a1 + 26);
                *(_WORD *)(v3 + 28) = v10;
              }
              BYTE1(v10) += 2;
            }
          }
        }
      }
      sub_10100(v2);
    }
    *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
  }
  else
  {
    sub_57F10(a1);
    *(_WORD *)(dword_D41A0 + 51) = 0;
  }
  return sub_10C80(a1, 0, *(_WORD *)(a1 + 42));
}
// D41A0: using guessed type int dword_D41A0;

//----- (00033110) --------------------------------------------------------
void __cdecl sub_33110(unsigned int a1)
{
  int v1; // edx

  v1 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v1;
  if ( v1 < 0 )
  {
    sub_6EAB0((signed __int16)((signed int)(a1 - (dword_D41A0 + 28302)) / 168), -1, 49);
    sub_338D0(a1);
  }
  else
  {
    sub_331A0(a1);
    sub_33340((_WORD *)a1);
    sub_33710(a1);
    sub_6E450((signed int)(a1 - (dword_D41A0 + 28302)) / 168, -1, 49);
  }
}
// D41A0: using guessed type int dword_D41A0;

//----- (000331A0) --------------------------------------------------------
_WORD *__cdecl sub_331A0(int a1)
{
  __int16 v1; // ax
  __int16 v2; // ax
  _WORD *result; // eax
  _WORD *v4; // edi
  signed int v5; // eax
  int v6; // edi
  _WORD *v7; // [esp+0h] [ebp-4h]

  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  *(_WORD *)(a1 + 48) = word_EB39C;
  if ( !(*(_BYTE *)(a1 + 62) & 0xF) )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    if ( !(*(_WORD *)(a1 + 20) & 1) )
      *(_WORD *)(a1 + 46) = -*(_WORD *)(a1 + 46);
  }
  v1 = *(_WORD *)(a1 + 32) + 11 * *(_WORD *)(a1 + 46);
  HIBYTE(v1) &= 7u;
  *(_WORD *)(a1 + 32) = v1;
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 32), 0, 32);
  *(_DWORD *)(a1 + 154) = *(_DWORD *)&word_EB398;
  *(_WORD *)(a1 + 158) = *(&word_EB398 + 2);
  v2 = *(_WORD *)(a1 + 28) + 341;
  HIBYTE(v2) &= 7u;
  *(_WORD *)(a1 + 28) = v2;
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, 120);
  word_EB39C = sub_10C40(&word_EB398);
  sub_57CF0(a1, (int)&word_EB398);
  v7 = (_WORD *)dword_EA3E4[*(unsigned __int16 *)(a1 + 52)];
  result = (_WORD *)a1;
  while ( (unsigned int)v7 > dword_EA3E4[0] )
  {
    *(_DWORD *)&word_EB398 = *((_DWORD *)v7 + 19);
    *(&word_EB398 + 2) = v7[40];
    v4 = result + 38;
    v7[14] = sub_581E0(v7 + 38, result + 38);
    v5 = sub_58490(v4, v7 + 38);
    v6 = 72 - 4 * (12 - (signed __int16)v7[22]);
    if ( v5 > v6 )
      sub_57FA0(&word_EB398, v7[14], 0, v5 - v6);
    word_EB39C = v7[27] + *(_WORD *)(a1 + 80);
    sub_57CF0((int)v7, (int)&word_EB398);
    result = v7;
    v7 = (_WORD *)dword_EA3E4[(unsigned __int16)v7[26]];
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00033340) --------------------------------------------------------
void __cdecl sub_33340(_WORD *a1)
{
  int i; // ebx
  char v2; // dl
  signed int v3; // eax
  signed int v4; // eax
  int v5; // eax
  __int16 v6; // dx
  int v7; // eax
  __int16 v8; // cx
  int v9; // edi
  __int16 v10; // si
  __int16 v11; // ax
  __int16 v12; // cx
  unsigned int v13; // esi
  __int16 v14; // dx
  __int16 v15; // ax
  __int16 v16; // ax
  char v17; // ch
  int v18; // edx
  int v19; // edi
  int v20; // esi
  int v21; // eax
  __int16 v22; // ST10_2
  int v23; // ST0C_4
  int v24; // ST08_4
  __int16 v25; // ax
  unsigned __int16 v26; // ST10_2
  int v27; // esi
  int v28; // [esp+0h] [ebp-34h]
  int v29; // [esp+4h] [ebp-30h]
  int v30; // [esp+8h] [ebp-2Ch]
  int v31; // [esp+Ch] [ebp-28h]
  int v32; // [esp+10h] [ebp-24h]
  int v33; // [esp+14h] [ebp-20h]
  int v34; // [esp+18h] [ebp-1Ch]
  int v35; // [esp+1Ch] [ebp-18h]
  int v36; // [esp+20h] [ebp-14h]
  int v37; // [esp+24h] [ebp-10h]
  int v38; // [esp+28h] [ebp-Ch]
  char v39; // [esp+2Ch] [ebp-8h]
  _BOOL1 v40; // [esp+30h] [ebp-4h]

  v31 = 0;
  v32 = ((unsigned __int16)a1[38] + 128) >> 8;
  v36 = ((unsigned __int16)a1[39] + 128) >> 8;
  v35 = sub_10080(0, 12);
  if ( v35 )
  {
    while ( 1 )
    {
      v27 = v35;
      if ( sub_10130(v35, &v29, &v28) != 1 )
        break;
      for ( i = dword_EA3E4[word_15B4E0[(unsigned __int8)(v29 + v32) + ((unsigned __int8)(v28 + v36) << 8)]];
            i != dword_EA3E4[0];
            i = dword_EA3E4[*(unsigned __int16 *)(i + 22)] )
      {
        if ( sub_33810((int)a1, i) )
        {
          v2 = *(_BYTE *)(i + 63);
          v39 = 0;
          v37 = 0;
          v30 = 0;
          v40 = v2 == 3 && !*(_BYTE *)(i + 64);
          if ( v40 )
            v3 = 56;
          else
            v3 = 204;
          v38 = v3;
          if ( v40 )
            v4 = 384;
          else
            v4 = 768;
          v34 = v4;
          v5 = sub_584D0(a1 + 77, (_WORD *)(i + 76));
          v33 = v5;
          if ( v5 >= 3211264 )
          {
            *(_DWORD *)&word_EB398 = *(_DWORD *)(i + 76);
            *(&word_EB398 + 2) = *(_WORD *)(i + 80);
            if ( *(_BYTE *)(i + 15) & 0x10 )
            {
              v17 = *(_BYTE *)(i + 13) | 8;
              v39 = 1;
              v18 = *(_DWORD *)(i + 160);
              *(_BYTE *)(i + 13) = v17;
              v37 = *(signed __int16 *)(v18 + 14);
              LOWORD(v18) = v38 + *(_WORD *)(i + 28);
              BYTE1(v18) &= 7u;
              v30 = 64;
              *(_WORD *)(i + 28) = v18;
              if ( v5 >= 5308416 )
                *(_BYTE *)(i + 15) &= 0xEFu;
            }
          }
          else
          {
            v6 = sub_581E0(a1 + 77, (_WORD *)(i + 76));
            if ( *(_BYTE *)(i + 15) & 0x10 )
            {
              *(_BYTE *)(i + 13) |= 8u;
              v30 = 128;
              *(_DWORD *)&word_EB398 = *(_DWORD *)(i + 76);
              *(&word_EB398 + 2) = *(_WORD *)(i + 80);
              v15 = *(_WORD *)(i + 28);
              v39 = 1;
              v16 = v38 + v15;
              HIBYTE(v16) &= 7u;
              word_EB39C += 114;
              *(_WORD *)(i + 28) = v16;
            }
            else
            {
              if ( v40 )
              {
                v7 = *(_DWORD *)(i + 164);
                v8 = *(_WORD *)(v7 + 341);
                if ( v8 < 256 )
                  *(_WORD *)(v7 + 341) = v8 + 28;
                *(_WORD *)(i + 130) = 80;
              }
              if ( v33 >= (signed int)&loc_40000 )
              {
                v14 = v6 + 591;
                HIBYTE(v14) &= 7u;
                *(_DWORD *)&word_EB398 = *(_DWORD *)(i + 76);
                *(&word_EB398 + 2) = *(_WORD *)(i + 80);
                *(_WORD *)(i + 48) = v14;
                *(_WORD *)(i + 28) = v14;
                v30 = 96;
              }
              else
              {
                *(_BYTE *)(i + 13) |= 8u;
                *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 77);
                *(&word_EB398 + 2) = a1[79];
                v9 = *(signed __int16 *)(i + 80) - (signed __int16)a1[24] + 57;
                v10 = sub_10C40(&word_EB398);
                word_EB39C = v9 + v10;
                if ( (signed __int16)(v9 + v10) < v10 )
                  word_EB39C = v10;
                v11 = v38 + *(_WORD *)(i + 28);
                HIBYTE(v11) &= 7u;
                v12 = *(_WORD *)(i + 20);
                *(_WORD *)(i + 28) = v11;
                v13 = v34;
                *(_WORD *)(i + 20) = 9377 * v12 + 9439;
                if ( v9 >= (signed int)(v13 + *(unsigned __int16 *)(i + 20) % v13) )
                {
                  *(_BYTE *)(i + 15) |= 0x10u;
                  *(_WORD *)(i + 48) = *(_WORD *)(i + 28);
                }
              }
            }
          }
          sub_57FA0(&word_EB398, *(_WORD *)(i + 48), 0, v30);
          if ( byte_D41B6 )
          {
            v19 = *(signed __int16 *)(i + 88);
            v20 = (signed __int16)sub_10C60(&word_EB398) - v19;
            if ( word_EB39C > v20 )
              word_EB39C = v20;
          }
          v21 = *(_DWORD *)(i + 160);
          v22 = v37;
          v23 = *(signed __int16 *)(v21 + 10);
          v24 = *(signed __int16 *)(v21 + 12);
          v25 = sub_10C40(&word_EB398);
          sub_580E0((int)&word_EB398, v25, v24, v23, v22);
          sub_57CF0(i, (int)&word_EB398);
          if ( v39 )
          {
            v26 = a1[21];
            ++v31;
            sub_11900((int)a1, i, 0, v26);
          }
        }
      }
    }
    sub_10100(v27);
    if ( v31 )
      sub_6D8B0(a1[13], 0x15u, v31);
  }
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00033710) --------------------------------------------------------
void __cdecl sub_33710(int a1)
{
  int v1; // edi
  _DWORD *i; // ebx
  unsigned int j; // ebx
  __int16 v4; // ax

  v1 = 0;
  if ( !(*(_BYTE *)(a1 + 62) & 7) )
  {
    for ( i = *(_DWORD **)(dword_D41A4 + 38527); (unsigned int)i > dword_EA3E4[0]; i = (_DWORD *)*i )
    {
      if ( sub_10750(a1, (int)i) )
        sub_11900(a1, (int)i, 0, *(_WORD *)(a1 + 42));
    }
    for ( j = *(_DWORD *)(dword_D41A4 + 38519); j > dword_EA3E4[0]; j = *(_DWORD *)j )
    {
      if ( *(_BYTE *)(j + 64) == 2 && sub_10750(a1, j) )
      {
        v4 = (a1 - (dword_D41A0 + 28302)) / 168;
        *(_WORD *)(j + 48) = 30;
        *(_WORD *)(j + 38) = v4;
        *(_DWORD *)(j + 94) += *(unsigned __int16 *)(a1 + 42);
        v1 += 2;
        *(_WORD *)(j + 98) = *(_WORD *)(a1 + 26);
      }
    }
    if ( v1 )
      sub_6D8B0(*(_WORD *)(a1 + 26), 0x15u, v1);
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00033810) --------------------------------------------------------
char __cdecl sub_33810(int a1, int a2)
{
  char result; // al
  unsigned __int8 v3; // ah
  char v4; // bl
  unsigned __int8 v5; // ah
  unsigned __int8 v6; // ah
  unsigned __int8 v7; // ah

  result = 1;
  v3 = *(_BYTE *)(a2 + 63) - 2;
  if ( v3 > 8u )
    return 0;
  switch ( v3 )
  {
    case 0u:
      v7 = *(_BYTE *)(a2 + 64);
      if ( v7 < 7u || v7 > 8u )
        return 0;
      return result;
    case 1u:
      if ( *(_WORD *)(a2 + 26) == *(_WORD *)(a1 + 26) )
        return 0;
      if ( *(_BYTE *)(a2 + 64) == 2 )
        result = 0;
      return result;
    case 2u:
    case 4u:
    case 5u:
    case 6u:
    case 7u:
      return 0;
    case 3u:
      v4 = *(_BYTE *)(a2 + 69);
      if ( v4 == -24 || v4 == -76 )
        return 0;
      v5 = *(_BYTE *)(a2 + 64);
      if ( v5 < 0xFu )
      {
        if ( v5 == 10 )
          result = 0;
      }
      else if ( v5 <= 0xFu || v5 >= 0x12u && (v5 <= 0x12u || v5 >= 0x1Bu && v5 <= 0x1Cu) )
      {
        return 0;
      }
      return result;
    case 8u:
      v6 = *(_BYTE *)(a2 + 64);
      if ( v6 < 0x27u )
      {
        if ( v6 < 0xDu )
          return 0;
        if ( v6 > 0xEu )
          result = 0;
      }
      else if ( v6 > 0x27u && v6 != 57 )
      {
        result = 0;
      }
      break;
  }
  return result;
}

//----- (000338D0) --------------------------------------------------------
unsigned int __cdecl sub_338D0(unsigned int a1)
{
  int v1; // edi
  int v2; // esi
  unsigned int result; // eax
  int v4; // edi
  int v5; // ebx
  int i; // eax
  int v7; // eax
  unsigned int j; // ebx
  int v9; // [esp+0h] [ebp-8h]
  int v10; // [esp+4h] [ebp-4h]

  v1 = *(unsigned __int16 *)(a1 + 78) + 128;
  v2 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
  result = sub_10080(0, 12);
  v4 = v1 >> 8;
  v5 = result;
  if ( result )
  {
    while ( sub_10130(v5, &v10, &v9) == 1 )
    {
      for ( i = word_15B4E0[((unsigned __int8)(v4 + v9) << 8) + (unsigned __int8)(v2 + v10)];
            ;
            i = *(unsigned __int16 *)(v7 + 22) )
      {
        v7 = dword_EA3E4[i];
        if ( v7 == dword_EA3E4[0] )
          break;
        *(_DWORD *)(v7 + 12) &= 0xEFFFF7FF;
      }
    }
    result = sub_10100(v5);
  }
  for ( j = a1; j > dword_EA3E4[0]; j = dword_EA3E4[*(unsigned __int16 *)(j + 52)] )
    result = sub_57F10(j);
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000339B0) --------------------------------------------------------
char __cdecl sub_339B0(int a1)
{
  __int16 v1; // ax
  unsigned __int16 v2; // dx
  int v3; // eax
  __int16 v4; // cx
  int v5; // edx
  char v6; // ah
  __int16 v7; // di

  LOBYTE(v1) = *(_BYTE *)(a1 + 70);
  if ( (unsigned __int8)v1 < 1u )
  {
    if ( (_BYTE)v1 )
      return v1;
    v2 = *(_WORD *)(a1 + 150);
    if ( v2 )
    {
      v3 = dword_EA3E4[v2];
      *(_WORD *)(a1 + 134) = *(_WORD *)(v3 + 84) >> 1;
      v4 = *(_WORD *)(a1 + 134);
      *(_WORD *)(a1 + 132) = 6 * *(signed __int16 *)(v3 + 84) >> 2;
      if ( v4 < 128 )
        *(_WORD *)(a1 + 134) = 128;
      if ( *(_WORD *)(a1 + 132) > 640 )
        *(_WORD *)(a1 + 132) = 640;
    }
    *(_BYTE *)(a1 + 70) = 1;
  }
  else if ( (unsigned __int8)v1 > 1u )
  {
    if ( (_BYTE)v1 == 2 )
    {
      v6 = *(_BYTE *)(a1 + 61);
      if ( v6 < 0 )
        *(_BYTE *)(a1 + 61) = -v6;
      sub_33B20(a1);
      v1 = *(char *)(a1 + 61);
      v7 = *(_WORD *)(a1 + 44) - v1;
      *(_WORD *)(a1 + 44) = v7;
      if ( v7 < 0 )
      {
        sub_4A190(a1 + 76, 10, 0);
        LOBYTE(v1) = sub_33D40(a1);
      }
    }
    return v1;
  }
  sub_33C70(a1);
  sub_33AD0(a1);
  sub_33B20(a1);
  LOBYTE(v1) = sub_33C00(a1);
  v5 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v5;
  if ( v5 < 1 )
    *(_BYTE *)(a1 + 70) = 2;
  return v1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00033AD0) --------------------------------------------------------
int __cdecl sub_33AD0(int a1)
{
  int result; // eax
  __int16 v2; // bx
  __int16 v3; // cx
  char v4; // dl
  __int16 v5; // si
  char v6; // dh

  result = a1;
  v2 = *(char *)(a1 + 61) + *(_WORD *)(a1 + 44);
  v3 = *(_WORD *)(a1 + 132);
  *(_WORD *)(a1 + 44) = v2;
  if ( v2 <= v3 )
  {
    v5 = *(_WORD *)(a1 + 134);
    if ( v2 < v5 )
    {
      v6 = *(_BYTE *)(a1 + 61);
      *(_WORD *)(a1 + 44) = v5;
      *(_BYTE *)(a1 + 61) = -v6;
    }
  }
  else
  {
    v4 = *(_BYTE *)(a1 + 61);
    *(_WORD *)(a1 + 44) = v3;
    *(_BYTE *)(a1 + 61) = -v4;
  }
  return result;
}

//----- (00033B20) --------------------------------------------------------
__int16 __cdecl sub_33B20(int a1)
{
  __int16 v1; // ax
  __int16 v2; // ax
  int i; // eax
  __int16 v4; // ax
  __int16 v5; // ax
  __int16 v6; // ax
  __int16 v7; // ST08_2
  unsigned __int16 v8; // ax
  _WORD *v9; // ebx

  v1 = *(_WORD *)(a1 + 28) + 22;
  HIBYTE(v1) &= 7u;
  *(_WORD *)(a1 + 28) = v1;
  v2 = *(_WORD *)(a1 + 30) + 16;
  HIBYTE(v2) &= 7u;
  *(_WORD *)(a1 + 30) = v2;
  for ( i = *(unsigned __int16 *)(a1 + 52); ; i = (unsigned __int16)v9[26] )
  {
    v9 = (_WORD *)dword_EA3E4[i];
    if ( (unsigned int)v9 <= dword_EA3E4[0] )
      break;
    v4 = v9[16] + v9[14];
    HIBYTE(v4) &= 7u;
    v9[14] = v4;
    v5 = v9[17] + v9[15];
    HIBYTE(v5) &= 7u;
    v9[15] = v5;
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v6 = v9[15] + *(_WORD *)(a1 + 30);
    HIBYTE(v6) &= 7u;
    v7 = v6;
    v8 = v9[14] + *(_WORD *)(a1 + 28);
    HIBYTE(v8) &= 7u;
    sub_57FA0(&word_EB398, v8, v7, *(_WORD *)(a1 + 44));
    sub_57CF0((int)v9, (int)&word_EB398);
  }
  return i;
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00033C00) --------------------------------------------------------
int __cdecl sub_33C00(int a1)
{
  int result; // eax
  unsigned int v2; // ebx

  for ( result = *(unsigned __int16 *)(a1 + 52); ; result = *(unsigned __int16 *)(v2 + 52) )
  {
    v2 = dword_EA3E4[result];
    if ( v2 <= dword_EA3E4[0] )
      break;
    if ( !*(_BYTE *)(v2 + 68) )
    {
      if ( (unsigned __int16)sub_10C80(v2, 0, *(_WORD *)(a1 + 42)) )
        sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 3);
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00033C70) --------------------------------------------------------
int __cdecl sub_33C70(int a1)
{
  unsigned __int16 v1; // dx
  int v2; // eax
  int v3; // esi
  int v4; // edi
  int result; // eax
  int v6; // esi
  int v7; // edi
  int v8; // esi
  char v9; // [esp+4h] [ebp-4h]

  v1 = *(_WORD *)(a1 + 150);
  v9 = 0;
  if ( v1 )
  {
    v2 = dword_EA3E4[v1];
    *(_DWORD *)&word_EB398 = *(_DWORD *)(v2 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(v2 + 80);
    v3 = v2;
    word_EB39C += *(_WORD *)(v2 + 82);
    sub_57CF0(a1, (int)&word_EB398);
    if ( *(_DWORD *)(v3 + 8) < 0 || *(_BYTE *)(v3 + 13) & 4 )
      v9 = 1;
  }
  v4 = *(signed __int16 *)(a1 + 44);
  result = sub_10C40((__int16 *)(a1 + 76));
  v6 = v4 + (signed __int16)result;
  if ( *(signed __int16 *)(a1 + 80) < v6 )
    *(_WORD *)(a1 + 80) = v6;
  if ( byte_D41B6 )
  {
    v7 = *(signed __int16 *)(a1 + 44);
    result = sub_10C60((__int16 *)(a1 + 76));
    v8 = (signed __int16)result - v7;
    if ( *(signed __int16 *)(a1 + 80) > v8 )
      *(_WORD *)(a1 + 80) = v8;
  }
  if ( v9 )
    *(_BYTE *)(a1 + 70) = 2;
  return result;
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00033D40) --------------------------------------------------------
int __cdecl sub_33D40(int a1)
{
  int i; // ebx
  unsigned int v2; // ebx

  for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v2 + 52) )
  {
    v2 = dword_EA3E4[i];
    if ( v2 <= dword_EA3E4[0] )
      break;
    sub_57F10(v2);
  }
  return sub_57F10(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00033D80) --------------------------------------------------------
void __cdecl sub_33D80(int a1)
{
  int v1; // eax
  __int16 v2; // ax
  char v3; // dl

  v1 = *(_DWORD *)(a1 + 8);
  ++*(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 >= 0 )
  {
    if ( !(*(_BYTE *)(a1 + 12) & 2) )
    {
      v2 = sub_10C80(a1, 0, *(_WORD *)(a1 + 42));
      if ( v2 )
        sub_6D8B0(*(_WORD *)(a1 + 26), 7u, v2);
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 24);
      v3 = *(_BYTE *)(a1 + 12);
      *(_DWORD *)(a1 + 8) = 1;
      *(_BYTE *)(a1 + 12) = v3 | 2;
    }
  }
  else
  {
    sub_57F10(a1);
  }
}
// D41A0: using guessed type int dword_D41A0;

//----- (00033E20) --------------------------------------------------------
void __cdecl sub_33E20(int a1)
{
  int v1; // ecx
  unsigned __int16 v2; // ST08_2

  v1 = *(_DWORD *)(a1 + 8) - 1;
  ++*(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 8) = v1;
  if ( v1 >= 0 )
  {
    if ( !(*(_BYTE *)(a1 + 12) & 2) )
    {
      v2 = *(char *)(a1 + 70);
      *(_BYTE *)(a1 + 12) |= 2u;
      if ( (unsigned __int16)sub_10C80(a1, 3u, v2) )
        *(_DWORD *)(a1 + 8) = 0;
    }
  }
  else
  {
    sub_57F10(a1);
  }
}

//----- (00033E80) --------------------------------------------------------
int __cdecl sub_33E80(int a1)
{
  int v1; // eax
  int result; // eax

  v1 = *(_DWORD *)(a1 + 8);
  ++*(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  sub_585A0(a1);
  result = sub_10C80(a1, 4u, *(char *)(a1 + 70));
  if ( (_WORD)result )
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (00033F70) --------------------------------------------------------
_BOOL1 __cdecl sub_33F70(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  signed int v2; // edx
  unsigned __int16 v3; // ax
  _BOOL1 result; // al

  HIBYTE(v1) = HIBYTE(a1);
  LOBYTE(v1) = a1 - 1;
  result = 1;
  if ( byte_10B4E0[v1] == 8 )
  {
    v2 = (unsigned __int16)((unsigned __int8)byte_11B4E0[a1] + 30);
    if ( (unsigned __int8)byte_11B4E0[v1] <= (signed int)(unsigned __int16)v2 )
    {
      LOBYTE(v1) = v1 + 2;
      if ( (unsigned __int8)byte_11B4E0[v1] <= v2 )
      {
        LOBYTE(v3) = v1 - 1;
        HIBYTE(v3) = HIBYTE(a1) + 1;
        if ( (unsigned __int8)byte_11B4E0[v3] <= v2 )
        {
          HIBYTE(v3) = HIBYTE(a1) - 1;
          if ( (unsigned __int8)byte_11B4E0[v3] <= v2 )
            result = 0;
        }
      }
    }
  }
  return result;
}

//----- (00034000) --------------------------------------------------------
int __cdecl sub_34000(int a1)
{
  unsigned __int16 v1; // bx
  unsigned __int16 v3; // [esp+0h] [ebp-Ch]
  __int16 i; // [esp+4h] [ebp-8h]
  __int16 v5; // [esp+8h] [ebp-4h]

  LOBYTE(v3) = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
  HIBYTE(v3) = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
  if ( v3 % 2 )
    LOBYTE(v3) = v3 + 1;
  LOBYTE(v3) = v3 - *(_BYTE *)(a1 + 8) + 1;
  v5 = *(_WORD *)(a1 + 8) + *(_WORD *)(a1 + 16);
  while ( v5 )
  {
    HIBYTE(v1) = HIBYTE(v3);
    LOBYTE(v1) = v3 - 1;
    byte_13B4E0[v1] |= 0x80u;
    LOBYTE(v1) = v3;
    for ( i = *(_WORD *)(a1 + 8); i; --i )
    {
      if ( byte_10B4E0[v1] != 8 || sub_33F70(v1) )
        byte_11B4E0[v1] += 48;
      sub_46180(v1++, 8);
    }
    byte_13B4E0[v1] |= 0x80u;
    --v5;
    ++HIBYTE(v3);
  }
  return sub_57F10(a1);
}

//----- (00034110) --------------------------------------------------------
int __cdecl sub_34110(_WORD *a1)
{
  unsigned __int16 v1; // bx
  char v3; // [esp+0h] [ebp-Ch]
  char v4; // [esp+1h] [ebp-Bh]
  __int16 i; // [esp+4h] [ebp-8h]
  __int16 v6; // [esp+8h] [ebp-4h]

  v3 = (unsigned __int16)(a1[38] + 128) >> 8;
  v4 = ((unsigned __int16)(a1[39] + 128) >> 8) + 2;
  v6 = a1[4] + a1[8];
  while ( v6 )
  {
    HIBYTE(v1) = v4;
    LOBYTE(v1) = v3 - 1;
    byte_13B4E0[v1] |= 0x80u;
    LOBYTE(v1) = v3;
    for ( i = a1[4]; i; --i )
    {
      if ( byte_10B4E0[v1] != 8 || sub_33F70(v1) )
        byte_11B4E0[v1] += 48;
      sub_46180(v1++, 8);
    }
    byte_13B4E0[v1] |= 0x80u;
    --v6;
    --v4;
  }
  return sub_57F10((int)a1);
}

//----- (00034210) --------------------------------------------------------
int __cdecl sub_34210(_WORD *a1)
{
  int v1; // edx
  int v2; // ebx
  unsigned __int16 v3; // di
  char v4; // cl
  unsigned __int16 v5; // bx
  int v6; // ebx
  __int16 v7; // dx
  unsigned __int16 v8; // di
  char v9; // cl
  int v11; // [esp+0h] [ebp-Ch]
  int v12; // [esp+4h] [ebp-8h]
  __int16 i; // [esp+8h] [ebp-4h]

  LOBYTE(v12) = (unsigned __int16)(a1[38] + 128) >> 8;
  BYTE1(v12) = (unsigned __int16)(a1[39] + 128) >> 8;
  v1 = ((unsigned __int8)v12 + BYTE1(v12)) % 2;
  if ( v1 )
    LOBYTE(v12) = v12 + 1;
  v2 = v12;
  LOWORD(v1) = a1[8];
  --BYTE1(v2);
  while ( (_WORD)v1 )
  {
    v3 = v2;
    --v1;
    v4 = byte_13B4E0[(unsigned __int16)v2++] | 0x80;
    byte_13B4E0[v3] = v4;
  }
  for ( i = a1[4]; i; --i )
  {
    LOWORD(v1) = a1[8];
    v5 = v12;
    while ( 1 )
    {
      v11 = v1;
      if ( !(_WORD)v1 )
        break;
      if ( byte_10B4E0[v5] != 8 || sub_33F70(v5) )
        byte_11B4E0[v5] += 48;
      sub_46180(v5++, 8);
      v1 = v11 - 1;
    }
    ++BYTE1(v12);
  }
  v6 = v12;
  v7 = a1[8];
  while ( v7 )
  {
    v8 = v6;
    --v7;
    v9 = byte_13B4E0[(unsigned __int16)v6++] | 0x80;
    byte_13B4E0[v8] = v9;
  }
  return sub_57F10((int)a1);
}

//----- (00034330) --------------------------------------------------------
int __cdecl sub_34330(int a1)
{
  return sub_57F10(a1);
}

//----- (00034350) --------------------------------------------------------
int __cdecl sub_34350(int a1)
{
  return sub_57F10(a1);
}

//----- (00034390) --------------------------------------------------------
int __cdecl sub_34390(int a1)
{
  unsigned int v1; // eax

  v1 = sub_5B070(a1);
  if ( v1 )
    *(_DWORD *)(v1 + 8) = 2;
  return sub_57F10(a1);
}

//----- (000343C0) --------------------------------------------------------
int __cdecl sub_343C0(int a1)
{
  unsigned int v1; // eax

  v1 = sub_5B070(a1);
  if ( v1 )
    *(_DWORD *)(v1 + 8) = 1;
  return sub_57F10(a1);
}

//----- (000343F0) --------------------------------------------------------
int __cdecl sub_343F0(_WORD *a1)
{
  unsigned __int16 v1; // bx
  __int16 v2; // di
  __int16 v4; // [esp+0h] [ebp-8h]
  __int16 v5; // [esp+4h] [ebp-4h]

  LOBYTE(v1) = (unsigned __int16)(a1[38] + 128) >> 8;
  HIBYTE(v1) = (unsigned __int16)(a1[39] + 128) >> 8;
  v5 = a1[14];
  v2 = a1[8];
  v4 = a1[15];
  while ( v2 )
  {
    byte_13B4E0[v1] = byte_13B4E0[v1] & 0xF0 | 1;
    --v2;
    sub_462A0(v1, v1);
    LOBYTE(v1) = v5 + v1;
    HIBYTE(v1) += v4;
  }
  return sub_57F10((int)a1);
}

//----- (00034480) --------------------------------------------------------
int __cdecl sub_34480(int a1)
{
  return sub_57F10(a1);
}

//----- (000344A0) --------------------------------------------------------
_WORD *__cdecl sub_344A0(int a1)
{
  int v1; // eax
  int v3; // eax

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 || sub_104A0(a1 + 76) & 1 )
    return (_WORD *)sub_57F10(a1);
  v3 = sub_4A190(a1 + 76, 10, 11);
  if ( v3 )
  {
    *(_WORD *)(v3 + 88) = *(_WORD *)(a1 + 88);
    *(_WORD *)(v3 + 26) = *(_WORD *)(a1 + 26);
    *(_DWORD *)(v3 + 8) = *(char *)(a1 + 70);
  }
  return sub_57FA0((_WORD *)(a1 + 76), *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
}

//----- (00034520) --------------------------------------------------------
int __cdecl sub_34520(int a1)
{
  return sub_57F10(a1);
}

//----- (00034540) --------------------------------------------------------
int __cdecl sub_34540(int a1)
{
  int v1; // ebx
  int v2; // eax
  int v3; // edx
  int v4; // esi
  int v5; // edi
  signed int v6; // eax
  signed int v7; // ebx
  signed int v8; // ebx
  signed int v9; // eax
  int v10; // ebx
  int v11; // eax
  unsigned int v12; // ST14_4
  int v13; // ebx
  unsigned int v14; // eax
  int v15; // ebx
  int v16; // ebx
  int v17; // ebx
  unsigned __int8 v18; // ah
  char v19; // dl
  signed int i; // eax
  int v21; // ebx
  int v23; // [esp+0h] [ebp-4Ch]
  __int16 v24; // [esp+4h] [ebp-48h]
  int v25; // [esp+8h] [ebp-44h]
  __int16 v26; // [esp+Ch] [ebp-40h]
  int v27; // [esp+10h] [ebp-3Ch]
  int v28; // [esp+14h] [ebp-38h]
  int v29; // [esp+18h] [ebp-34h]
  int v30; // [esp+1Ch] [ebp-30h]
  unsigned int v31; // [esp+20h] [ebp-2Ch]
  int v32; // [esp+24h] [ebp-28h]
  int v33; // [esp+28h] [ebp-24h]
  int v34; // [esp+2Ch] [ebp-20h]
  int v35; // [esp+30h] [ebp-1Ch]
  int v36; // [esp+34h] [ebp-18h]
  int v37; // [esp+38h] [ebp-14h]
  int v38; // [esp+3Ch] [ebp-10h]
  unsigned __int16 v39; // [esp+40h] [ebp-Ch]
  unsigned __int8 v40; // [esp+44h] [ebp-8h]
  unsigned __int8 v41; // [esp+48h] [ebp-4h]

  v28 = (*(char *)(a1 + 70) >> 4 << 8) + 512;
  v27 = ((*(_BYTE *)(a1 + 70) & 0xF) << 8) + 512;
  v29 = sub_58490((_WORD *)(a1 + 76), (_WORD *)(a1 + 154)) / 0x55;
  v34 = (unsigned __int16)sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a1 + 154));
  v33 = 0;
  v25 = *(_DWORD *)(a1 + 76);
  v26 = *(_WORD *)(a1 + 80);
  while ( v33 < 32 )
  {
    LOBYTE(v39) = BYTE1(v25);
    HIBYTE(v39) = HIBYTE(v25);
    v1 = ((unsigned __int8)byte_11B4E0[v39] + (unsigned __int8)byte_14B4E0[v39]) / 2;
    if ( v1 < 0 )
      v1 = 0;
    if ( v1 > 254 )
      LOBYTE(v1) = -2;
    byte_F0200[v33++] = v1;
    sub_57FA0(&v25, v34, 0, 85);
  }
  v30 = 0;
  v23 = *(_DWORD *)(a1 + 76);
  v24 = *(_WORD *)(a1 + 80);
  while ( v30 < v29 )
  {
    v2 = v28 + v30 * ((v27 - v28) / v29);
    v36 = v2 * v2;
    v3 = 2 * v2 + 128;
    v40 = (unsigned __int16)(v23 + 128) >> 8;
    v35 = (unsigned __int8)byte_F0200[0];
    v4 = v3 >> 8;
    v3 >>= 9;
    v41 = (unsigned __int16)(HIWORD(v23) + 128) >> 8;
    LOBYTE(v37) = v40 - v3;
    BYTE1(v37) = v41 - v3;
    v5 = 0;
    LOWORD(v38) = v37;
    while ( v5 < v4 )
    {
      v32 = 0;
      v39 = v38;
      while ( v4 > v32 )
      {
        v6 = abs((unsigned __int8)v39 - v40);
        v7 = v6;
        if ( v6 >= 128 )
          v7 = abs(v6 - 256);
        v8 = v7 << 8;
        v9 = abs(HIBYTE(v39) - v41);
        if ( v9 >= 128 )
          v9 = abs(v9 - 256);
        v10 = v8 * v8;
        v11 = (v9 << 8) * (v9 << 8);
        if ( v10 + v11 <= v36 )
        {
          v12 = v36 - v10 - v11;
          v13 = v35;
          v14 = sub_7277A(v12) >> 5;
          v15 = v13 - v14;
          v31 = v14;
          if ( v15 < 0 )
            v15 = 0;
          if ( v15 > 254 )
            v15 = 254;
          if ( (unsigned __int8)byte_11B4E0[v39] > v15 )
            sub_570F0((unsigned __int8)v39, HIBYTE(v39), v15, 0, 0, 1);
          v16 = v31 + v35;
          if ( (signed int)(v31 + v35) < 0 )
            v16 = 0;
          if ( v16 > 254 )
            v16 = 254;
          if ( (unsigned __int8)byte_14B4E0[v39] < v16 )
            byte_14B4E0[v39] = v16;
        }
        v17 = v39;
        v18 = byte_11B4E0[v39];
        if ( (unsigned __int8)byte_14B4E0[v39] > v18 )
        {
          byte_13B4E0[v39] &= 0xF7u;
        }
        else
        {
          v19 = byte_13B4E0[v39] | 8;
          byte_14B4E0[v39] = v18 - 1;
          byte_13B4E0[v17] = v19;
        }
        ++v32;
        LOBYTE(v39) = v39 + 1;
      }
      ++v5;
      ++BYTE1(v38);
    }
    sub_34B00(v37 - 1, BYTE1(v37) - 1, v4 + 1, v4 + 1);
    sub_57FA0(&v23, v34, 0, 85);
    for ( i = 1; i < 32; byte_F01FE[i] = byte_F01FF[i] )
      ++i;
    LOBYTE(v39) = BYTE1(v25);
    HIBYTE(v39) = HIBYTE(v25);
    v21 = ((unsigned __int8)byte_11B4E0[v39] + (unsigned __int8)byte_14B4E0[v39]) / 2;
    if ( v21 < 0 )
      v21 = 0;
    if ( v21 > 254 )
      LOBYTE(v21) = -2;
    byte_F021F = v21;
    ++v30;
    sub_57FA0(&v25, v34, 0, 85);
  }
  return sub_57F10(a1);
}
// F021F: using guessed type char byte_F021F;

//----- (00034910) --------------------------------------------------------
int __cdecl sub_34910(int a1)
{
  int v1; // ebx
  int v2; // esi
  int v3; // ecx
  int v4; // edi
  int v5; // ebx
  int v6; // eax
  int v7; // eax
  unsigned __int8 v8; // dh
  char v9; // cl
  signed int v11; // [esp+8h] [ebp-1Ch]
  signed int v12; // [esp+Ch] [ebp-18h]
  int v13; // [esp+10h] [ebp-14h]
  int v14; // [esp+14h] [ebp-10h]
  int v15; // [esp+18h] [ebp-Ch]
  unsigned __int16 v16; // [esp+1Ch] [ebp-8h]
  unsigned __int16 v17; // [esp+20h] [ebp-4h]

  v13 = 3 * *(char *)(a1 + 70);
  v1 = *(char *)(a1 + 67);
  v2 = 2 * v1;
  v5 = (*(signed __int16 *)(a1 + 76) >> 8) - v1;
  v3 = *(char *)(a1 + 68);
  v4 = 2 * v3;
  BYTE1(v5) = (*(_WORD *)(a1 + 78) >> 8) - v3;
  v11 = sub_48E60((unsigned __int8)v5, BYTE1(v5), v2, 2 * v3);
  v16 = v5;
  v12 = sub_48E90((unsigned __int8)v5, BYTE1(v5), v2, v4);
  v14 = 0;
  while ( v4 > v14 )
  {
    v15 = 0;
    v17 = v16;
    while ( v2 > v15 )
    {
      v6 = v11 - v13;
      if ( v11 - v13 < 0 )
        v6 = 0;
      if ( v6 > 254 )
        v6 = 254;
      if ( (unsigned __int8)byte_11B4E0[v17] > v6 )
        sub_570F0((unsigned __int8)v17, HIBYTE(v16), v6, 0, 0, 0);
      v7 = v13 + v12;
      if ( v13 + v12 < 0 )
        v7 = 0;
      if ( v7 > 254 )
        v7 = 254;
      if ( v7 > (unsigned __int8)byte_14B4E0[v17] )
        byte_14B4E0[v17] = v7;
      v8 = byte_11B4E0[v17];
      if ( (unsigned __int8)byte_14B4E0[v17] > v8 )
      {
        byte_13B4E0[v17] &= 0xF7u;
      }
      else
      {
        v9 = byte_13B4E0[v17] | 8;
        byte_14B4E0[v17] = v8 - 1;
        byte_13B4E0[v17] = v9;
      }
      ++v15;
      LOBYTE(v17) = v17 + 1;
    }
    ++v14;
    ++HIBYTE(v16);
  }
  sub_34B00(v5 - 1, BYTE1(v5) - 1, v2 + 1, v4 + 1);
  sub_43C60(v5, SBYTE1(v5), (unsigned __int16)v2, (unsigned __int16)v4);
  return sub_57F10(a1);
}

//----- (00034B00) --------------------------------------------------------
int __cdecl sub_34B00(char a1, char a2, __int16 a3, __int16 a4)
{
  unsigned __int16 v4; // bx
  char v5; // dl
  int v6; // eax
  char v7; // ch
  int result; // eax
  unsigned __int16 v9; // bx
  char v10; // dl
  int v11; // eax
  char v12; // ch
  signed int v13; // [esp+0h] [ebp-Ch]
  signed int i; // [esp+4h] [ebp-8h]

  for ( i = 0; a3 > i; ++i )
  {
    HIBYTE(v4) = a2;
    LOBYTE(v4) = i + a1;
    v5 = byte_13B4E0[v4];
    if ( v5 & 8 )
    {
      byte_13B4E0[v4] = v5 & 0xF8 | 1;
      byte_10B4E0[v4] = 1;
      sub_462A0(v4, v4);
    }
    HIWORD(v6) = 0;
    HIBYTE(v4) = a4 + a2;
    LOWORD(v6) = v4;
    v7 = byte_13B4E0[v4];
    if ( v7 & 8 )
    {
      byte_13B4E0[v6] = v7 & 0xF8 | 1;
      sub_462A0(v4, v4);
    }
  }
  v13 = 0;
  for ( result = a4; a4 > v13; result = a4 )
  {
    LOBYTE(v9) = a1;
    HIBYTE(v9) = v13 + a2;
    v10 = byte_13B4E0[v9];
    if ( v10 & 8 )
    {
      byte_13B4E0[v9] = v10 & 0xF8 | 1;
      byte_10B4E0[v9] = 1;
      sub_462A0(v9, v9);
    }
    HIWORD(v11) = 0;
    LOBYTE(v9) = a3 + v9;
    LOWORD(v11) = v9;
    v12 = byte_13B4E0[v9];
    if ( v12 & 8 )
    {
      byte_13B4E0[v11] = v12 & 0xF8 | 1;
      sub_462A0(v9, v9);
    }
    ++v13;
  }
  return result;
}

//----- (00034C40) --------------------------------------------------------
char __cdecl sub_34C40(int a1)
{
  int v1; // edx
  int v2; // eax
  int v3; // esi
  unsigned __int8 v4; // cl
  unsigned __int8 v5; // dl
  __int16 v6; // di
  signed int v7; // edi
  signed int v8; // eax
  int v9; // ecx
  int v10; // ecx
  __int16 v12; // [esp+0h] [ebp-40h]
  __int16 v13; // [esp+2h] [ebp-3Eh]
  int v14; // [esp+8h] [ebp-38h]
  int v15; // [esp+Ch] [ebp-34h]
  int v16; // [esp+10h] [ebp-30h]
  int v17; // [esp+14h] [ebp-2Ch]
  int v18; // [esp+18h] [ebp-28h]
  int v19; // [esp+1Ch] [ebp-24h]
  int v20; // [esp+20h] [ebp-20h]
  int v21; // [esp+24h] [ebp-1Ch]
  int v22; // [esp+28h] [ebp-18h]
  int v23; // [esp+2Ch] [ebp-14h]
  int v24; // [esp+30h] [ebp-10h]
  int v25; // [esp+34h] [ebp-Ch]
  unsigned __int16 i; // [esp+38h] [ebp-8h]
  int v27; // [esp+3Ch] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v1;
  if ( v1 <= 0 )
  {
    LOBYTE(v2) = sub_57F10(a1);
  }
  else
  {
    v2 = *(signed __int16 *)(a1 + 154);
    v3 = 2 * v2;
    v4 = ((unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8) - v2;
    BYTE1(v27) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - v2;
    v5 = *(_BYTE *)(a1 + 70);
    LOBYTE(v27) = v4;
    if ( v5 < 1u )
    {
      if ( !v5 )
      {
        v6 = v4;
        v21 = BYTE1(v27);
        *(_WORD *)(a1 + 80) = sub_48E60(v4, BYTE1(v27), v3, v3);
        LOWORD(v2) = sub_48EF0(v6, v21, v3, v3);
        *(_WORD *)(a1 + 158) = v2;
        LOBYTE(v2) = ((signed __int16)v2 - *(signed __int16 *)(a1 + 80) <= 0) + 1;
        *(_BYTE *)(a1 + 70) = v2;
      }
    }
    else if ( v5 <= 1u )
    {
      v7 = v2 << 8;
      v23 = *(signed __int16 *)(a1 + 80);
      v2 = *(signed __int16 *)(a1 + 158);
      v24 = v2;
      v17 = 192 * v7 >> 8;
      v14 = v2 - v23;
      LOBYTE(v2) = v27;
      v20 = 0;
      for ( i = v27; v3 > v20; ++HIBYTE(i) )
      {
        v19 = 0;
        LOBYTE(v2) = v27;
        LOBYTE(i) = v27;
        while ( v3 > v19 )
        {
          v12 = (unsigned __int8)i << 8;
          v13 = HIBYTE(i) << 8;
          v16 = 0;
          v8 = sub_58490((_WORD *)(a1 + 76), &v12);
          v15 = v8;
          if ( v8 < v7 )
          {
            v22 = (unsigned __int8)byte_11B4E0[i];
            v25 = (unsigned __int8)byte_14B4E0[i];
            v18 = v14 * ((_DWORD)((_DWORD)sub_10000 + (signed int)off_DBF50[(v8 << 10) / v7]) >> 1) >> 16;
            v9 = v18 + v23;
            if ( v18 + v23 > 254 )
              v9 = 254;
            if ( v9 > v22 )
              sub_570F0(
                (unsigned __int8)i,
                HIBYTE(i),
                (unsigned int)((v9 - v22) / *(_DWORD *)(a1 + 8)) + v22,
                0,
                v15 <= v17,
                1);
            v10 = v16 + v24 - v18;
            if ( v10 < 0 )
              v10 = 0;
            if ( v10 < v25 )
              byte_14B4E0[i] = v25 - (unsigned int)((v25 - v10) / *(_DWORD *)(a1 + 8));
            if ( (unsigned __int8)byte_14B4E0[i] > (unsigned __int8)byte_11B4E0[i] )
              byte_13B4E0[i] &= 0xF7u;
            else
              byte_13B4E0[i] |= 8u;
          }
          LOBYTE(v2) = v19++ + 1;
          LOBYTE(i) = i + 1;
        }
        ++v20;
      }
    }
    else if ( v5 == 2 )
    {
      *(_DWORD *)(a1 + 8) = 0;
    }
  }
  return v2;
}
// 10000: using guessed type void __noreturn sub_10000();
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();

//----- (00034EE0) --------------------------------------------------------
void __usercall sub_34EE0(signed int a1@<edi>, int a2@<esi>, int a3)
{
  int v3; // edx
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  unsigned __int8 v7; // dl
  unsigned __int8 v8; // al
  __int16 v9; // dx
  unsigned int v10; // esi
  char v11; // ah
  __int16 v12; // di
  int v13; // edi
  int v14; // esi
  signed int v15; // eax
  int v16; // ecx
  unsigned __int8 v17; // al
  int v18; // ecx
  int v19; // ecx
  int v20; // eax
  int v21; // eax
  int v22; // ecx
  int v23; // ecx
  int v24; // eax
  int v25; // ecx
  unsigned __int8 v26; // dl
  char v27; // dh
  __int16 v28; // [esp+0h] [ebp-34h]
  __int16 v29; // [esp+2h] [ebp-32h]
  int v30; // [esp+8h] [ebp-2Ch]
  int v31; // [esp+Ch] [ebp-28h]
  int v32; // [esp+10h] [ebp-24h]
  int v33; // [esp+14h] [ebp-20h]
  int v34; // [esp+18h] [ebp-1Ch]
  int v35; // [esp+1Ch] [ebp-18h]
  int v36; // [esp+20h] [ebp-14h]
  int v37; // [esp+24h] [ebp-10h]
  int v38; // [esp+28h] [ebp-Ch]
  unsigned int v39; // [esp+2Ch] [ebp-8h]
  unsigned __int16 i; // [esp+30h] [ebp-4h]

  v3 = *(_DWORD *)(a3 + 8) - 1;
  *(_DWORD *)(a3 + 8) = v3;
  if ( v3 <= 0 )
  {
    sub_57F10(a3);
  }
  else
  {
    v4 = *(signed __int16 *)(a3 + 154);
    v5 = *(signed __int16 *)(a3 + 78);
    v38 = 2 * v4;
    v6 = (*(signed __int16 *)(a3 + 76) + 128) >> 8;
    v36 = (v5 + 128) >> 8;
    LOBYTE(v39) = v6 - v4;
    BYTE1(v39) = v36 - v4;
    v7 = *(_BYTE *)(a3 + 70);
    if ( v7 < 1u )
    {
      if ( !v7 )
      {
        v8 = *(_BYTE *)(a3 + 64);
        if ( v8 >= 0x54u )
        {
          if ( v8 <= 0x54u )
          {
            v37 = BYTE1(v39);
            v36 = (unsigned __int8)v39;
            a1 = sub_48EF0((unsigned __int8)v39, BYTE1(v39), v38, v38);
            a2 = a1 - sub_48E90((unsigned __int8)v39, BYTE1(v39), v38, v38) - 1;
          }
          else if ( v8 == 85 )
          {
            v36 = BYTE1(v39);
            v37 = (unsigned __int8)v39;
            a1 = sub_48E60((unsigned __int8)v39, BYTE1(v39), v38, v38);
            a2 = sub_48EC0((unsigned __int8)v39, BYTE1(v39), v38, v38) - a1 - 1;
          }
        }
        if ( a2 <= 0 )
        {
          *(_BYTE *)(a3 + 70) = 2;
        }
        else
        {
          v9 = *(_WORD *)(a3 + 80);
          if ( v9 )
          {
            v10 = (51 * v9 * a2 - (__CFSHL__(51 * v9 * a2 >> 31, 8) + (51 * v9 * a2 >> 31 << 8))) >> 8;
          }
          else
          {
            *(_WORD *)(a3 + 20) = 9377 * *(_WORD *)(a3 + 20) + 9439;
            v10 = *(unsigned __int16 *)(a3 + 20) % (unsigned int)a2;
          }
          v11 = *(_BYTE *)(a3 + 64);
          *(_WORD *)(a3 + 158) = a1;
          if ( v11 == 84 )
            v12 = a1 - v10;
          else
            v12 = v10 + a1;
          *(_WORD *)(a3 + 80) = v12;
          *(_BYTE *)(a3 + 70) = 1;
        }
      }
    }
    else if ( v7 <= 1u )
    {
      v35 = v4 << 8;
      v13 = *(signed __int16 *)(a3 + 158);
      v14 = abs(*(signed __int16 *)(a3 + 80) - v13);
      v34 = 0;
      v30 = 49152 * v4 >> 8;
      for ( i = v39; v34 < v38; ++HIBYTE(i) )
      {
        v33 = 0;
        LOBYTE(i) = v39;
        while ( v33 < v38 )
        {
          v28 = (unsigned __int8)i << 8;
          v29 = HIBYTE(i) << 8;
          v15 = sub_58490((_WORD *)(a3 + 76), &v28);
          v31 = v15;
          if ( v15 < v35 )
          {
            v16 = v14 * ((_DWORD)((_DWORD)sub_10000 + (signed int)off_DBF50[(v15 << 10) / v35]) >> 1);
            v17 = *(_BYTE *)(a3 + 64);
            v18 = v16 >> 16;
            if ( v17 >= 0x54u )
            {
              if ( v17 <= 0x54u )
              {
                v19 = v13 - v18;
                if ( v19 < 0 )
                  v19 = 0;
                v32 = i;
                v20 = (unsigned __int8)byte_14B4E0[i];
                v37 = v20;
                v21 = (v20 - v19) / *(_DWORD *)(a3 + 8);
                if ( v37 - v21 < v37 )
                  byte_14B4E0[v32] = v37 - v21;
              }
              else if ( v17 == 85 )
              {
                v22 = v13 + v18;
                if ( v22 > 254 )
                  v22 = 254;
                v23 = v22 - (unsigned __int8)byte_11B4E0[i];
                v37 = (unsigned __int8)byte_11B4E0[i];
                v24 = v23 / *(_DWORD *)(a3 + 8);
                if ( v24 + v37 > v37 )
                  sub_570F0((unsigned __int8)i, HIBYTE(i), v24 + v37, 0, v31 <= v30, 1);
              }
            }
            v25 = i;
            v26 = byte_11B4E0[i];
            if ( (unsigned __int8)byte_14B4E0[i] > v26 )
            {
              byte_13B4E0[i] &= 0xF7u;
            }
            else
            {
              v27 = byte_13B4E0[i] | 8;
              byte_14B4E0[i] = v26 - 1;
              byte_13B4E0[v25] = v27;
            }
          }
          ++v33;
          LOBYTE(i) = i + 1;
        }
        ++v34;
      }
    }
    else if ( v7 == 2 )
    {
      if ( *(_BYTE *)(a3 + 64) == 84 )
        sub_43C60(v39, SBYTE1(v39), (unsigned __int16)v38, (unsigned __int16)v38);
      *(_DWORD *)(a3 + 8) = 0;
    }
  }
}
// 10000: using guessed type void __noreturn sub_10000();
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();

//----- (000352A0) --------------------------------------------------------
int __cdecl sub_352A0(int a1)
{
  return sub_57F10(a1);
}

//----- (000352C0) --------------------------------------------------------
_WORD *__cdecl sub_352C0(int a1)
{
  int v1; // edx

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 || sub_104A0(a1 + 76) & 1 )
    return (_WORD *)sub_57F10(a1);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  if ( !sub_572C0((signed __int16 *)a1, 0, 1024, *(_WORD *)(a1 + 20) % 0xFu + 10, 0) )
  {
    sub_10C80(a1, 0, *(_WORD *)(a1 + 42));
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
  }
  return sub_57FA0((_WORD *)(a1 + 76), *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
}
// D41A0: using guessed type int dword_D41A0;

//----- (00035390) --------------------------------------------------------
void __cdecl sub_35390(int a1)
{
  int v1; // eax
  int v2; // edx
  int v3; // edi
  int v4; // esi
  __int16 v5; // ax
  int v6; // ST0C_4
  __int16 v7; // ax
  int v8; // edx
  __int16 *v9; // [esp+8h] [ebp-8h]
  unsigned __int16 i; // [esp+Ch] [ebp-4h]

  if ( !(*(_BYTE *)(a1 + 12) & 2) )
  {
    v1 = dword_D41A0 + 28302;
    *(_BYTE *)(a1 + 12) |= 2u;
    sub_6E450((a1 - v1) / 168, -1, 21);
  }
  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 <= 0 || (*(_DWORD *)(a1 + 8) = v2 - 1, v2 != 1) )
  {
    v3 = dword_D41A0 + 11230;
    for ( i = 0; ; ++i )
    {
      v9 = (__int16 *)(a1 + 76);
      if ( *(_WORD *)(dword_D41A0 + 14) <= i )
        break;
      v4 = dword_EA3E4[*(unsigned __int16 *)(v3 + 10)];
      if ( sub_106C0(a1, dword_EA3E4[*(unsigned __int16 *)(v3 + 10)]) )
      {
        v5 = sub_581E0((_WORD *)(v4 + 76), v9);
        if ( (unsigned __int16)sub_582B0(*(_WORD *)(v4 + 28), v5) < 0xAAu )
        {
          v6 = *(_DWORD *)(a1 + 160);
          v7 = sub_10C40((__int16 *)(a1 + 154));
          v8 = dword_D41A0;
          *(_WORD *)(a1 + 158) = *(_WORD *)(v6 + 12) + v7;
          sub_6E450((a1 - (v8 + 28302)) / 168, -1, 22);
          sub_57CF0(v4, a1 + 154);
          sub_5C800(v4, 6);
        }
      }
      v3 += 2124;
    }
    *(_WORD *)(a1 + 80) = sub_10C40(v9);
  }
  else
  {
    sub_57F10(a1);
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 20);
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00035530) --------------------------------------------------------
unsigned int __cdecl sub_35530(int a1)
{
  unsigned int result; // eax
  __int16 v2; // ax
  __int16 v3; // ax

  result = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
  if ( result > dword_EA3E4[0] )
  {
    if ( *(_DWORD *)(result + 8) == 1 )
    {
      result = sub_57F10(a1);
    }
    else
    {
      *(_DWORD *)&word_EB398 = *(_DWORD *)(result + 76);
      *(&word_EB398 + 2) = *(_WORD *)(result + 80);
      sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
      v2 = *(_WORD *)(a1 + 28) + 45;
      HIBYTE(v2) &= 7u;
      *(_WORD *)(a1 + 28) = v2;
      v3 = sub_10C40(&word_EB398);
      ++HIBYTE(v3);
      word_EB39C = v3;
      result = sub_57CF0(a1, (int)&word_EB398);
    }
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00035600) --------------------------------------------------------
int __cdecl sub_35600(int a1)
{
  int result; // eax
  int v2; // edx
  char v3; // dl

  result = a1;
  ++*(_DWORD *)(result + 16);
  v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 - 1;
  if ( v2 < 0 )
    return sub_57F10(a1);
  v3 = *(_BYTE *)(a1 + 12);
  if ( !(v3 & 2) )
    *(_BYTE *)(a1 + 12) = v3 | 2;
  return result;
}

//----- (00035640) --------------------------------------------------------
void __cdecl sub_35640(int a1)
{
  signed __int16 v1; // si
  __int16 v2; // dx
  int v3; // eax
  __int16 v4; // ax
  __int16 v5; // ax
  int v6; // ST08_4
  int v7; // ST04_4
  int v8; // eax
  int v9; // ecx
  __int16 v10; // ax
  signed int v11; // [esp+0h] [ebp-4h]

  v1 = 0;
  v2 = sub_10C40((__int16 *)(a1 + 76));
  if ( *(signed __int16 *)(a1 + 80) < v2 + 1024 )
  {
    v1 = 1;
    *(_WORD *)(a1 + 80) += 64;
  }
  if ( *(signed __int16 *)(a1 + 80) > v2 + 1024 )
  {
    HIBYTE(v2) += 4;
    v1 = 1;
    *(_WORD *)(a1 + 80) = v2;
  }
  if ( !v1 )
  {
    v3 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v3 - 1;
    if ( v3 >= 0 )
    {
      v4 = 9377 * *(_WORD *)(a1 + 20);
      *(_WORD *)(a1 + 30) = 56;
      *(_WORD *)(a1 + 20) = v4 + 9439;
      v11 = 0;
      *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 20) & 0x7FF;
      do
      {
        v5 = *(_WORD *)(a1 + 28);
        HIBYTE(v5) = (HIBYTE(v5) + 4) & 7;
        *(_WORD *)(a1 + 28) = v5;
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        v6 = *(char *)(a1 + 68);
        v7 = *(char *)(a1 + 67);
        word_EB39C += *(_WORD *)(a1 + 82);
        v8 = sub_4A190(a1 + 76, v7, v6);
        v9 = v8;
        if ( v8 )
        {
          *(_WORD *)(v8 + 26) = *(_WORD *)(a1 + 26);
          *(_DWORD *)(v8 + 8) /= 3;
          *(_WORD *)(v8 + 28) = *(_WORD *)(a1 + 28);
          *(_WORD *)(v8 + 30) = *(_WORD *)(a1 + 30);
          v10 = *(_WORD *)(a1 + 42);
          *(_BYTE *)(v9 + 67) = 10;
          *(_BYTE *)(v9 + 68) = 23;
          *(_WORD *)(v9 + 42) = v10;
          if ( !v11 )
            sub_6E450((v9 - (dword_D41A0 + 28302)) / 168, -1, 23);
        }
        ++v11;
      }
      while ( v11 < 2 );
    }
    else
    {
      sub_57F10(a1);
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (000357C0) --------------------------------------------------------
int __cdecl sub_357C0(int a1)
{
  signed __int16 v1; // bx
  unsigned __int16 v2; // cx
  unsigned int i; // eax
  int v4; // eax
  int v5; // ecx
  int v7; // [esp+0h] [ebp-10h]
  unsigned __int16 v8; // [esp+4h] [ebp-Ch]
  __int16 v9; // [esp+8h] [ebp-8h]
  int v10; // [esp+Ch] [ebp-4h]

  *(_WORD *)(a1 + 42) = 10000;
  if ( *(_WORD *)(a1 + 42) )
  {
    v1 = sub_4A810();
    if ( v1 < 0 )
      v1 = 0;
    if ( v1 > 8 )
      v1 = 8;
    v2 = 0;
    for ( i = *(_DWORD *)(dword_D41A4 + 38439); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(unsigned __int16 *)(i + 148) == *(signed __int16 *)(a1 + 26) )
        ++v2;
    }
    if ( v1 < 0 )
      v1 = 0;
    if ( v1 > 64 - v2 )
      v1 = 64 - v2;
    if ( v1 > 0 )
    {
      HIWORD(v4) = HIWORD(a1);
      LOWORD(v4) = *(_WORD *)(a1 + 42);
      v7 = v4;
      v10 = (signed __int16)v4 / v1;
      v9 = 2048 / v1;
      v8 = 0;
      while ( v1 > 0 )
      {
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        sub_57FA0(&word_EB398, v8, 0, 512);
        v5 = sub_4A190((int)&word_EB398, 5, 9);
        if ( v5 )
        {
          *(_DWORD *)(v5 + 144) = (signed __int16)v7 % (signed __int16)v10;
          *(_WORD *)(v5 + 148) = *(_WORD *)(a1 + 26);
          *(_WORD *)(v5 + 26) = *(_WORD *)(a1 + 26);
          *(_WORD *)(v5 + 32) = __PAIR__(HIBYTE(v8) + 4, (unsigned __int8)v8) & 0x7FF;
          *(_WORD *)(v5 + 28) = __PAIR__(HIBYTE(v8) + 4, (unsigned __int8)v8) & 0x7FF;
          v7 -= v10;
        }
        --v1;
        v8 += v9;
      }
    }
  }
  return sub_57F10(a1);
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00035940) --------------------------------------------------------
void __cdecl sub_35940(int a1)
{
  char v1; // dh
  __int16 v2; // dx
  __int16 v3; // ax
  __int16 v4; // ax
  unsigned __int16 v5; // si
  __int16 v6; // ST0C_2
  unsigned __int16 v7; // ST04_2
  int v8; // eax
  char v9; // dl
  unsigned __int16 v10; // ax
  signed int v11; // eax
  _WORD *v12; // eax
  __int16 v13; // si
  __int16 v14; // ax
  __int16 v15; // cx
  __int16 v16; // ax
  __int16 v17; // t0
  signed int v18; // eax
  __int16 v19; // ax
  __int16 v20; // dx
  __int16 v21; // cx
  __int16 v22; // si
  int v23; // eax
  __int16 v24; // cx
  int v25; // eax
  int v26; // eax
  int v27; // edx
  unsigned int v28; // eax
  char v29; // cl
  int v30; // [esp+0h] [ebp-1Ch]
  unsigned __int16 v31; // [esp+4h] [ebp-18h]
  signed int v32; // [esp+8h] [ebp-14h]
  signed __int16 v33; // [esp+Ch] [ebp-10h]
  char v34; // [esp+10h] [ebp-Ch]
  char v35; // [esp+14h] [ebp-8h]
  char v36; // [esp+18h] [ebp-4h]

  v1 = *(_BYTE *)(a1 + 13);
  v35 = 0;
  v36 = 0;
  if ( v1 & 8 )
  {
    *(_BYTE *)(a1 + 13) = v1 & 0xF7;
  }
  else
  {
    v2 = *(_WORD *)(a1 + 104);
    if ( v2 )
    {
      if ( v2 != *(_WORD *)(a1 + 148) )
      {
        v36 = 1;
        if ( *(_DWORD *)(a1 + 100) )
        {
          v4 = *(_WORD *)(a1 + 104);
          *(_WORD *)(a1 + 148) = v4;
          sub_6E450(v4, -1, 4);
          *(_DWORD *)(a1 + 12) &= 0xFFDFFFBF;
          *(_BYTE *)(a1 + 14) |= 0x20u;
        }
        else if ( !(*(_BYTE *)(a1 + 14) & 0x20) )
        {
          v3 = *(_WORD *)(a1 + 104);
          *(_WORD *)(a1 + 148) = v3;
          sub_6E450(v3, -1, 4);
          *(_BYTE *)(a1 + 12) &= 0xBFu;
        }
      }
      *(_WORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
    }
    v5 = *(_WORD *)(a1 + 122);
    if ( v5 )
    {
      v35 = 1;
      *(_WORD *)(a1 + 28) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(dword_EA3E4[v5] + 76));
      v6 = *(_WORD *)(a1 + 118);
      v7 = *(_WORD *)(a1 + 28);
      word_EB398 = 0;
      word_EB39A = 0;
      word_EB39C = 0;
      sub_57FA0(&word_EB398, v7, 0, v6);
      *(_WORD *)(a1 + 154) = word_EB398;
      *(_WORD *)(a1 + 156) = word_EB39A;
      *(_WORD *)(a1 + 122) = 0;
    }
    if ( *(_BYTE *)(a1 + 12) & 0x40 )
    {
      v8 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
      v9 = 1;
      if ( *(_BYTE *)(v8 + 63) != 3 || 3 != *(_BYTE *)(v8 + 64) )
      {
        if ( *(_BYTE *)(v8 + 63) == 5 && *(_BYTE *)(v8 + 64) == 23 )
        {
          v9 = 0;
          v33 = *(_WORD *)(v8 + 44);
        }
      }
      else
      {
        v9 = 0;
        v33 = 32;
      }
      if ( v9 )
      {
        *(_BYTE *)(a1 + 12) &= 0xBFu;
      }
      else
      {
        v10 = *(_WORD *)(a1 + 150);
        *(_WORD *)(a1 + 44) = 128;
        *(_WORD *)(a1 + 28) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(dword_EA3E4[v10] + 76));
        v11 = sub_58490((_WORD *)(a1 + 76), (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 76));
        if ( v11 <= 1024 )
        {
          if ( v11 >= 16 )
          {
            *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
            *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
            sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, 16);
          }
          else
          {
            *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
            *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
            v12 = (_WORD *)dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
            word_EB398 = v12[38];
            v13 = v12[40];
            word_EB39A = v12[39];
            if ( word_EB39C >= v13 )
            {
              if ( word_EB39C > v13 + 512 )
                word_EB39C -= v33;
            }
            else
            {
              word_EB39C += v33;
            }
          }
          v14 = sub_10C40(&word_EB398);
          if ( v14 > word_EB39C )
            word_EB39C = v14;
          sub_57CF0(a1, (int)&word_EB398);
        }
        else
        {
          *(_BYTE *)(a1 + 12) &= 0xBFu;
        }
      }
    }
    else if ( *(_BYTE *)(a1 + 57) || v35 )
    {
      if ( *(signed __int16 *)(a1 + 154) < -64 )
        *(_WORD *)(a1 + 154) = -64;
      if ( *(_WORD *)(a1 + 154) > 64 )
        *(_WORD *)(a1 + 154) = 64;
      if ( *(signed __int16 *)(a1 + 156) < -64 )
        *(_WORD *)(a1 + 156) = -64;
      if ( *(_WORD *)(a1 + 156) > 64 )
        *(_WORD *)(a1 + 156) = 64;
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      v15 = *(_WORD *)(a1 + 156);
      word_EB398 = *(_WORD *)(a1 + 154) + *(_WORD *)(a1 + 76);
      word_EB39A = v15 + *(_WORD *)(a1 + 78);
      v16 = *(_WORD *)(a1 + 44);
      word_EB39C += v16;
      *(_WORD *)(a1 + 44) = v16 - 16;
      if ( (signed __int16)(v16 - 16) < -128 )
        *(_WORD *)(a1 + 44) = -128;
      if ( byte_D41B6 && sub_11E70(a1, &word_EB398) )
      {
        if ( v35 )
        {
          *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
          *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        }
        else
        {
          v17 = *(_WORD *)(a1 + 130);
          *(_WORD *)(a1 + 130) = 256;
          v32 = 170;
          v34 = 0;
          v30 = 1;
          while ( v32 <= 1024 )
          {
            *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
            *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
            v31 = (v30 * v32 + *(_WORD *)(a1 + 28) + 512) & 0x7FF;
            sub_57FA0(&word_EB398, v31, 0, *(_WORD *)(a1 + 130));
            word_EB39C = sub_10C40(&word_EB398);
            if ( !sub_11E70(a1, &word_EB398) )
            {
              v34 = 1;
              break;
            }
            v30 = -v30;
            if ( v30 == 1 )
              v18 = 170;
            else
              v18 = 0;
            v32 += v18;
          }
          if ( v34 )
          {
            *(_WORD *)(a1 + 32) = v31;
            *(_WORD *)(a1 + 28) = v31;
          }
          else
          {
            *(_WORD *)(a1 + 154) = 64;
            v19 = *(_WORD *)(a1 + 76);
            v20 = *(_WORD *)(a1 + 154);
            *(_WORD *)(a1 + 156) = 64;
            v21 = *(_WORD *)(a1 + 156);
            word_EB398 = v20 + v19;
            word_EB39A = v21 + *(_WORD *)(a1 + 78);
          }
        }
        *(_WORD *)(a1 + 44) = -128;
      }
      v22 = sub_10C40(&word_EB398);
      if ( v22 > word_EB39C )
      {
        v23 = -((*(signed __int16 *)(a1 + 44)
               - (__CFSHL__(*(signed __int16 *)(a1 + 44) >> 31, 2)
                + 4 * (*(signed __int16 *)(a1 + 44) >> 31))) >> 2);
        *(_WORD *)(a1 + 44) = v23;
        if ( (signed __int16)v23 <= 16 )
          *(_WORD *)(a1 + 44) = 0;
        word_EB39C = v22;
      }
      if ( byte_D41B6 )
      {
        v24 = sub_10C60(&word_EB398) - *(_WORD *)(a1 + 88);
        if ( v24 < word_EB39C )
        {
          *(_WORD *)(a1 + 44) = -abs(*(signed __int16 *)(a1 + 44));
          word_EB39C = v24;
        }
      }
      sub_57CF0(a1, (int)&word_EB398);
      if ( v22 == word_EB39C )
      {
        v25 = sub_10A50(a1);
        if ( v25 && !(*(_BYTE *)(a1 + 13) & 0x20) )
          sub_36D50(a1, v25);
        sub_58030(a1 + 76, &word_EB398);
        *(_WORD *)(a1 + 154) += word_EB398;
        v26 = (250 * *(signed __int16 *)(a1 + 154)
             - (__CFSHL__(250 * *(signed __int16 *)(a1 + 154) >> 31, 8)
              + (250 * *(signed __int16 *)(a1 + 154) >> 31 << 8))) >> 8;
        *(_WORD *)(a1 + 156) += word_EB39A;
        v27 = *(signed __int16 *)(a1 + 156);
        *(_WORD *)(a1 + 154) = v26;
        *(_WORD *)(a1 + 156) = (250 * v27 - (__CFSHL__(250 * v27 >> 31, 8) + (250 * v27 >> 31 << 8))) >> 8;
      }
      if ( !(*(_BYTE *)(a1 + 13) & 0x20) || v36 )
        sub_36920(a1, a1);
    }
    if ( *(_BYTE *)(a1 + 13) & 0x20 )
    {
      v28 = *(_DWORD *)(a1 + 8) - 1;
      *(_DWORD *)(a1 + 8) = v28;
      if ( v28 < 6 )
      {
        if ( !v28 )
          sub_57F10(a1);
      }
      else if ( v28 <= 6 )
      {
        v29 = *(_BYTE *)(a1 + 15) & 0xFE;
        *(_BYTE *)(a1 + 14) |= 0x80u;
        *(_BYTE *)(a1 + 15) = v29;
      }
      else if ( v28 == 12 )
      {
        *(_BYTE *)(a1 + 15) |= 1u;
      }
    }
  }
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00036680) --------------------------------------------------------
char __cdecl sub_36680(int a1)
{
  unsigned __int8 v1; // al
  signed int v2; // eax
  int v3; // eax
  char v5; // [esp+0h] [ebp-4h]

  v5 = 0;
  if ( *(_WORD *)(a1 + 40) == *(_WORD *)(a1 + 104) )
  {
    *(_WORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  else
  {
    v1 = *(_BYTE *)(a1 + 70);
    if ( v1 < 1u )
    {
      if ( !v1 )
      {
        sub_36770((_WORD *)a1);
        sub_6D8B0(*(_WORD *)(a1 + 40), 0x16u, 1);
        v5 = 1;
      }
    }
    else if ( v1 <= 1u )
    {
      v2 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 16) = v2 + 1;
      if ( v2 >= 8 )
      {
        sub_6D8B0(*(_WORD *)(a1 + 40), 0x16u, 1);
        return 1;
      }
      if ( !(*(_BYTE *)(a1 + 16) & 1) )
        sub_36770((_WORD *)a1);
    }
    else if ( v1 <= 3u )
    {
      v3 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 16) = v3 + 1;
      if ( !v3 )
      {
        sub_36850(a1);
        return 0;
      }
      if ( v3 + 1 > 2 )
      {
        sub_6D8B0(*(_WORD *)(a1 + 40), 0x16u, 1);
        return 1;
      }
    }
  }
  return v5;
}

//----- (00036770) --------------------------------------------------------
void __cdecl sub_36770(_WORD *a1)
{
  _WORD *v1; // ebx
  int v2; // ST08_4
  int v3; // eax

  v1 = (_WORD *)sub_4A190((int)(a1 + 38), 9, 0);
  if ( v1 )
  {
    v2 = dword_EA3E4[(unsigned __int16)a1[52]];
    v1[75] = a1[52];
    sub_655C0(v1, v2);
    v1[14] = v1[16];
    v1[15] = v1[17];
    v1[40] += a1[44];
    v1[21] = a1[21];
    sub_6E450((signed int)((char *)v1 - dword_D41A0 - 28302) / 168, -1, 9);
    if ( sub_104D0(v1 + 38) == (int (*)())1 )
    {
      v3 = sub_4A190((int)(a1 + 38), 10, 5);
      if ( v3 )
        sub_6E450((v3 - (dword_D41A0 + 28302)) / 168, -1, 27);
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00036850) --------------------------------------------------------
char __cdecl sub_36850(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // esi

  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  v1 = sub_4A190((int)&word_EB398, 9, 9);
  v2 = v1;
  if ( v1 )
  {
    v3 = dword_EA3E4[*(unsigned __int16 *)(a1 + 104)];
    *(_BYTE *)(v1 + 67) = 10;
    *(_BYTE *)(v1 + 68) = 23;
    *(_WORD *)(v1 + 26) = *(_WORD *)(a1 + 26);
    *(_WORD *)(v1 + 150) = *(_WORD *)(a1 + 104);
    sub_655C0((_WORD *)v1, v3);
    LOWORD(v1) = *(_WORD *)(v2 + 32);
    *(_DWORD *)(v2 + 160) = &off_D8456;
    *(_WORD *)(v2 + 28) = v1;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 34);
    *(_BYTE *)(v2 + 66) = *(_BYTE *)(v3 + 64);
    LOBYTE(v1) = *(_BYTE *)(v3 + 63);
    *(_BYTE *)(v2 + 65) = v1;
    *(_WORD *)(v2 + 80) += *(_WORD *)(a1 + 88);
    *(_WORD *)(v2 + 42) = *(_WORD *)(a1 + 42);
  }
  return v1;
}
// D8456: using guessed type void *off_D8456;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00036920) --------------------------------------------------------
char __usercall sub_36920@<al>(signed __int16 a1@<bx>, int a2)
{
  __int16 i; // si
  __int16 v3; // ax

  for ( i = 0; i < 7 && *(_DWORD *)(a2 + 144) > dword_DB538[i]; ++i )
    ;
  v3 = sub_369F0(a1, *(_WORD *)(a2 + 148));
  if ( v3 + i != *(signed __int16 *)(a2 + 90) )
  {
    LOBYTE(v3) = sub_49C90(a2, i + v3);
    switch ( i )
    {
      case 0:
        a1 = 13;
        break;
      case 1:
        a1 = 28;
        break;
      case 2:
        a1 = 42;
        break;
      case 3:
        a1 = 56;
        break;
      case 4:
        a1 = 70;
        break;
      case 5:
        a1 = 84;
        break;
      case 6:
        a1 = 98;
        break;
      case 7:
        a1 = 112;
        break;
      default:
        break;
    }
    *(_WORD *)(a2 + 84) = a1;
    *(_WORD *)(a2 + 86) = a1;
    *(_WORD *)(a2 + 88) = a1;
    *(_WORD *)(a2 + 82) = a1;
  }
  return v3;
}

//----- (000369F0) --------------------------------------------------------
signed int __usercall sub_369F0@<eax>(signed int a1@<ebx>, __int16 a2)
{
  unsigned int v2; // eax
  signed int result; // eax

  v2 = dword_EA3E4[a2];
  if ( v2 <= dword_EA3E4[0] || *(_BYTE *)(v2 + 63) != 3 )
    result = 52;
  else
    result = sub_36A50(a1, *(_BYTE *)(*(_DWORD *)(v2 + 164) + 56));
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00036A50) --------------------------------------------------------
signed int __usercall sub_36A50@<eax>(signed int a1@<ebx>, char a2)
{
  char v2; // al
  signed int result; // eax

  v2 = a2;
  if ( a2 >= 0 )
    v2 = sub_616D0(a2);
  switch ( v2 + 1 )
  {
    case 0:
      result = 52;
      break;
    case 1:
      result = 105;
      break;
    case 2:
      result = 113;
      break;
    case 3:
      result = 121;
      break;
    case 4:
      result = 129;
      break;
    case 5:
      result = 137;
      break;
    case 6:
      result = 145;
      break;
    case 7:
      result = 153;
      break;
    case 8:
      a1 = 161;
      goto LABEL_13;
    default:
LABEL_13:
      result = a1;
      break;
  }
  return result;
}

//----- (00036AE0) --------------------------------------------------------
int __cdecl sub_36AE0(__int16 *a1)
{
  int result; // eax
  unsigned __int16 v2; // dx
  int v3; // edi
  unsigned int i; // ecx

  result = sub_10C40(a1 + 38);
  v2 = a1[52];
  a1[40] = result;
  if ( v2 )
  {
    v3 = dword_EA3E4[v2];
    if ( *(_BYTE *)(v3 + 63) == 3 && !a1[74] )
    {
      for ( i = dword_EA3E8; i < dword_EB384; i += 168 )
      {
        if ( (signed int)((char *)a1 - dword_D41A0 - 28302) / 168 == *(unsigned __int16 *)(i + 148) )
          *(_WORD *)(i + 148) = (v3 - (dword_D41A0 + 28302)) / 168;
      }
    }
    a1[52] = 0;
    result = sub_57F10((int)a1);
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EA3E8: using guessed type int dword_EA3E8;
// EB384: using guessed type int dword_EB384;

//----- (00036BA0) --------------------------------------------------------
void __cdecl sub_36BA0(int a1, char a2)
{
  int v2; // edx
  int v3; // edi
  int v4; // eax
  _WORD *v5; // ebx
  int v6; // edx
  __int16 v7; // cx
  __int16 v8; // dx
  unsigned __int16 v9; // ax
  int v10; // ST14_4
  __int16 v11; // ax
  int v12; // [esp+0h] [ebp-Ch]
  int v13; // [esp+8h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 144);
  if ( v2 > 0 )
  {
    if ( a2 )
    {
      v3 = v2 / 1000;
      if ( v2 / 1000 < 1 )
        v3 = 1;
      if ( v3 > 16 )
        v3 = 16;
      v13 = *(_DWORD *)(a1 + 144) / v3;
    }
    else
    {
      v3 = 1;
      v13 = *(_DWORD *)(a1 + 144);
    }
    v12 = 0;
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    while ( v3 > v12 )
    {
      v4 = sub_4A190(a1 + 76, 10, 39);
      v5 = (_WORD *)v4;
      if ( v4 )
      {
        if ( v3 - 1 == v12 )
          v6 = *(_DWORD *)(a1 + 144) - (v3 - 1) * v13;
        else
          v6 = v13;
        *(_DWORD *)(v4 + 144) = v6;
        v7 = *(_WORD *)(v4 + 20);
        *(_WORD *)(v4 + 148) = *(_WORD *)(a1 + 148);
        *(_WORD *)(v4 + 20) = 9377 * v7 + 9439;
        v8 = *(_WORD *)(v4 + 20);
        *(_WORD *)(v4 + 28) = (*(_WORD *)(v4 + 20) % 0x71u + *(_WORD *)(a1 + 28) - 56) & 0x7FF;
        *(_WORD *)(v4 + 20) = 9377 * v8 + 9439;
        v9 = *(_WORD *)(v4 + 20);
        v5[77] = 0;
        v5[78] = 0;
        v5[65] = v9 % 0x30u + 16;
        v10 = *(signed __int16 *)(a1 + 80);
        v11 = sub_10C40((__int16 *)(a1 + 76));
        v5[22] = (1024 - (v10 - v11) - (__CFSHL__((1024 - (v10 - v11)) >> 31, 3) + 8 * ((1024 - (v10 - v11)) >> 31))) >> 3;
        sub_57FA0(v5 + 77, v5[14], 0, v5[65]);
      }
      ++v12;
    }
    *(_WORD *)(a1 + 148) = 0;
  }
}

//----- (00036D50) --------------------------------------------------------
int __cdecl sub_36D50(int a1, int a2)
{
  int v3; // edx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // edi
  int v8; // edx
  int v9; // eax
  int v10; // eax
  __int64 v11; // rtt

  if ( *(_WORD *)(a1 + 148) || *(_WORD *)(a2 + 148) )
  {
    if ( !*(_WORD *)(a1 + 148) )
    {
      *(_DWORD *)(a1 + 144) += *(_DWORD *)(a2 + 144);
      *(_WORD *)(a1 + 148) = *(_WORD *)(a2 + 148);
      if ( *(_BYTE *)(a2 + 14) & 0x20 )
      {
        *(_BYTE *)(a1 + 14) |= 0x20u;
        return sub_57F20(a2);
      }
      return sub_57F20(a2);
    }
    if ( !*(_WORD *)(a2 + 148) )
    {
      *(_DWORD *)(a1 + 144) += *(_DWORD *)(a2 + 144);
      return sub_57F20(a2);
    }
    v3 = dword_EA3E4[*(unsigned __int16 *)(a1 + 148)];
    v4 = dword_EA3E4[*(unsigned __int16 *)(a2 + 148)];
    if ( *(_BYTE *)(v3 + 63) == 10 && *(_BYTE *)(v4 + 63) == 10 )
    {
      *(_DWORD *)(a1 + 144) += *(_DWORD *)(a2 + 144);
      return sub_57F20(a2);
    }
    if ( *(_BYTE *)(v3 + 63) == 10 )
    {
      v5 = v4 - (dword_D41A0 + 28302);
      *(_DWORD *)(a1 + 144) += *(_DWORD *)(a2 + 144);
      v6 = v5 / 168;
LABEL_22:
      *(_WORD *)(a1 + 148) = v6;
      return sub_57F20(a2);
    }
    if ( *(_BYTE *)(v4 + 63) == 10 )
    {
      v7 = *(_DWORD *)(a2 + 144) + *(_DWORD *)(a1 + 144);
      v8 = v3 - (dword_D41A0 + 28302);
      v9 = v8;
    }
    else
    {
      if ( v3 == v4 )
      {
        *(_DWORD *)(a1 + 144) += *(_DWORD *)(a2 + 144);
        return sub_57F20(a2);
      }
      if ( *(_DWORD *)(v3 + 140) > *(_DWORD *)(v4 + 140) )
      {
        v10 = dword_D41A0 + 28302;
        *(_DWORD *)(a1 + 144) += *(_DWORD *)(a2 + 144);
        v6 = (v3 - v10) / 168;
        goto LABEL_22;
      }
      v7 = *(_DWORD *)(a2 + 144) + *(_DWORD *)(a1 + 144);
      v9 = v4 - (dword_D41A0 + 28302);
      v8 = v9;
    }
    LODWORD(v11) = v9;
    HIDWORD(v11) = v8 >> 31;
    v6 = v11 / 168;
    *(_DWORD *)(a1 + 144) = v7;
    goto LABEL_22;
  }
  *(_DWORD *)(a1 + 144) += *(_DWORD *)(a2 + 144);
  return sub_57F20(a2);
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00036F30) --------------------------------------------------------
int __cdecl sub_36F30(int a1, int a2)
{
  __int16 v2; // bx

  LOBYTE(v2) = 0;
  if ( *(_BYTE *)(a1 + 70) >= *(_BYTE *)(a2 + 70) )
  {
    if ( *(_WORD *)(a2 + 40) != *(_WORD *)(a1 + 40) )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v2 = *(_WORD *)(a1 + 20) & 1;
    }
  }
  else
  {
    LOBYTE(v2) = 1;
  }
  if ( (_BYTE)v2 )
  {
    *(_WORD *)(a1 + 40) = *(_WORD *)(a2 + 40);
    *(_WORD *)(a1 + 148) = *(_WORD *)(a2 + 148);
    *(_BYTE *)(a1 + 70) = *(_BYTE *)(a2 + 70);
    *(_WORD *)(a1 + 42) = *(_WORD *)(a2 + 42);
  }
  *(_DWORD *)(a1 + 144) += *(_DWORD *)(a2 + 144);
  return sub_57F20(a2);
}

//----- (00036FC0) --------------------------------------------------------
char __cdecl sub_36FC0(int a1)
{
  unsigned __int8 v1; // bl
  int v2; // eax
  unsigned int v3; // esi
  unsigned int v4; // edi
  char result; // al
  unsigned __int16 v6; // bx
  unsigned __int8 v7; // cl
  char v8; // dl
  __int16 v9; // dx
  int v10; // eax
  int v11; // eax
  unsigned __int8 v12; // cl
  char v13; // ch
  char v14; // cl
  unsigned __int16 v15; // bx
  unsigned __int8 *v16; // [esp+0h] [ebp-2Ch]
  unsigned __int8 *v17; // [esp+4h] [ebp-28h]
  unsigned int v18; // [esp+8h] [ebp-24h]
  unsigned int v19; // [esp+Ch] [ebp-20h]
  unsigned int v20; // [esp+10h] [ebp-1Ch]
  unsigned int v21; // [esp+14h] [ebp-18h]
  unsigned __int8 *v22; // [esp+18h] [ebp-14h]
  unsigned __int16 v23; // [esp+1Ch] [ebp-10h]
  unsigned __int16 v24; // [esp+1Ch] [ebp-10h]
  __int16 v25; // [esp+20h] [ebp-Ch]
  char v26; // [esp+24h] [ebp-8h]
  unsigned __int16 v27; // [esp+24h] [ebp-8h]
  char v28; // [esp+25h] [ebp-7h]
  char v29; // [esp+28h] [ebp-4h]

  v29 = 0;
  v26 = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
  v28 = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
  v1 = *(_BYTE *)(a1 + 70);
  v25 = *(_WORD *)(a1 + 80) >> 5;
  v2 = 6 * v1;
  v3 = *(unsigned __int8 *)(v2 + dword_EA3BC + 5);
  v17 = *(unsigned __int8 **)(v2 + dword_EA3BC);
  v4 = *(unsigned __int8 *)(v2 + dword_EA3BC + 4);
  result = sub_37740(a1);
  if ( !result )
  {
    if ( word_180660 == 1 )
    {
      v3 >>= 1;
      v4 >>= 1;
    }
    if ( byte_D41B6 && !(byte_D93C2[4 * v1] & 4) )
      v29 = 1;
    LOBYTE(v27) = v26 - (v4 >> 1);
    HIBYTE(v27) = v28 - (v3 >> 1);
    v23 = v27;
    v20 = 0;
    v22 = v17;
    while ( v3 > v20 )
    {
      v6 = v23;
      v18 = 0;
      while ( v4 > v18 )
      {
        sub_57390(v6, *(_WORD *)(a1 + 26));
        v7 = v22[1];
        if ( v7 != -1 )
        {
          byte_11B4E0[v6] = v7 + v25;
          v8 = byte_13B4E0[v6];
          if ( !(v8 & 7) )
          {
            byte_13B4E0[v6] = v8 & 0xF8 | 1;
            sub_462A0(v6, v6);
          }
        }
        if ( v29 )
        {
          v9 = (unsigned __int8)byte_11B4E0[v6];
          if ( v9 >= v25 )
            v10 = (unsigned __int8)v9;
          else
            v10 = v25;
          v11 = v10 + 80;
          if ( v11 > 255 )
            v11 = 255;
          if ( v11 > (unsigned __int8)byte_14B4E0[v6] )
            byte_14B4E0[v6] = v11;
          v12 = byte_11B4E0[v6];
          if ( (unsigned __int8)byte_14B4E0[v6] > v12 )
          {
            byte_13B4E0[v6] &= 0xF7u;
          }
          else
          {
            v13 = byte_13B4E0[v6] | 8;
            byte_14B4E0[v6] = v12 - 1;
            byte_13B4E0[v6] = v13;
          }
        }
        LOBYTE(v6) = v6 + 1;
        ++v18;
        v22 += 2;
      }
      ++v20;
      ++HIBYTE(v23);
    }
    v24 = v27;
    result = (char)v17;
    v19 = 0;
    v16 = v17;
    if ( v3 )
    {
      do
      {
        v14 = 0;
        v15 = v24;
        v21 = 0;
        while ( v4 > v21 )
        {
          if ( *v16 != -1 )
            sub_45DC0((char)v16, v14, v15, *v16);
          LOBYTE(v15) = v15 + 1;
          ++v21;
          v16 += 2;
        }
        result = v19++ + 1;
        ++HIBYTE(v24);
      }
      while ( v3 > v19 );
    }
  }
  return result;
}
// D41B6: using guessed type char byte_D41B6;
// EA3BC: using guessed type int dword_EA3BC;
// 180660: using guessed type __int16 word_180660;

//----- (00037240) --------------------------------------------------------
void __cdecl sub_37240(int a1)
{
  unsigned __int8 v1; // cl
  int v2; // esi
  unsigned int v3; // edi
  unsigned int v4; // esi
  int v5; // ecx
  char v6; // dh
  signed __int16 v7; // dx
  int v8; // eax
  int v9; // eax
  int v10; // edx
  unsigned __int8 v11; // ch
  char v12; // cl
  _BYTE *v13; // ebx
  unsigned int v14; // edx
  unsigned __int8 *v15; // ebx
  char v16; // dl
  unsigned __int8 v17; // al
  __int16 v18; // ax
  unsigned int v19; // esi
  int v20; // edi
  unsigned int v21; // [esp+0h] [ebp-58h]
  unsigned int v22; // [esp+4h] [ebp-54h]
  unsigned int v23; // [esp+8h] [ebp-50h]
  unsigned int v24; // [esp+Ch] [ebp-4Ch]
  unsigned int v25; // [esp+18h] [ebp-40h]
  _BYTE *v26; // [esp+1Ch] [ebp-3Ch]
  _BYTE *v27; // [esp+20h] [ebp-38h]
  unsigned int v28; // [esp+24h] [ebp-34h]
  unsigned int v29; // [esp+28h] [ebp-30h]
  unsigned int v30; // [esp+2Ch] [ebp-2Ch]
  unsigned int v31; // [esp+30h] [ebp-28h]
  unsigned int v32; // [esp+34h] [ebp-24h]
  unsigned int v33; // [esp+38h] [ebp-20h]
  _BYTE *v34; // [esp+40h] [ebp-18h]
  int v35; // [esp+44h] [ebp-14h]
  char v36; // [esp+48h] [ebp-10h]
  unsigned __int16 v37; // [esp+48h] [ebp-10h]
  __int16 v38; // [esp+48h] [ebp-10h]
  char v39; // [esp+49h] [ebp-Fh]
  unsigned __int16 v40; // [esp+4Ch] [ebp-Ch]
  unsigned __int16 v41; // [esp+4Ch] [ebp-Ch]
  unsigned __int16 v42; // [esp+4Ch] [ebp-Ch]
  unsigned __int16 v43; // [esp+4Ch] [ebp-Ch]
  __int16 v44; // [esp+4Ch] [ebp-Ch]
  unsigned __int16 v45; // [esp+50h] [ebp-8h]
  unsigned __int16 v46; // [esp+50h] [ebp-8h]
  unsigned __int16 v47; // [esp+50h] [ebp-8h]
  unsigned __int16 v48; // [esp+50h] [ebp-8h]
  __int16 v49; // [esp+50h] [ebp-8h]
  char v50; // [esp+54h] [ebp-4h]

  v50 = 0;
  if ( *(_DWORD *)(a1 + 4) == *(_DWORD *)(a1 + 8) )
    sub_49EC0((_WORD *)a1, *(char *)(a1 + 70));
  if ( !sub_37740(a1) )
  {
    v36 = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
    v1 = *(_BYTE *)(a1 + 70);
    v39 = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
    v35 = *(signed __int16 *)(a1 + 80) >> 5;
    v2 = 6 * v1 + dword_EA3BC;
    v3 = *(unsigned __int8 *)(v2 + 5);
    v26 = *(_BYTE **)v2;
    v4 = *(unsigned __int8 *)(v2 + 4);
    if ( word_180660 == 1 )
    {
      v3 >>= 1;
      v4 >>= 1;
    }
    if ( byte_D41B6 && !(byte_D93C2[4 * v1] & 4) )
      v50 = 1;
    v22 = v3 >> 1;
    v5 = *(_DWORD *)(a1 + 8) - 1;
    *(_DWORD *)(a1 + 8) = v5;
    v25 = v4 >> 1;
    if ( v5 <= 0 )
    {
      LOBYTE(v38) = v36 - v25;
      HIBYTE(v38) = v39 - v22;
      v23 = 0;
      v44 = v38;
      v27 = v26;
      while ( v3 > v23 )
      {
        v21 = 0;
        v49 = v44;
        while ( v4 > v21 )
        {
          if ( *v27 != -1 )
            sub_462A0(v49, v49);
          ++v21;
          v27 += 2;
          LOBYTE(v49) = v49 + 1;
        }
        ++v23;
        ++HIBYTE(v44);
      }
      v17 = *(_BYTE *)(a1 + 69);
      if ( v17 >= 0x30u )
      {
        if ( v17 <= 0x30u )
        {
          *(_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 40)] + 46) = 2;
          sub_377A0(a1);
          sub_57F10(a1);
        }
        else if ( v17 == 51 )
        {
          *(_DWORD *)(a1 + 8) = 1000 * *(unsigned __int16 *)(a1 + 42);
          v18 = *(_WORD *)(a1 + 148);
          *(_BYTE *)(a1 + 69) = 52;
          if ( v18 )
            *(_BYTE *)(a1 + 12) &= 0xFEu;
          else
            *(_BYTE *)(a1 + 12) |= 1u;
          *(_WORD *)(a1 + 158) = *(_WORD *)(a1 + 80);
          v19 = v4 >> 1;
          *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
          v20 = (v3 >> 1) & 0xFFFF;
          sub_48A20(v20, v38, SHIBYTE(v38), v20, (unsigned __int16)v19, 2u);
          sub_48A20(v20, v38, SHIBYTE(v38), v20, (unsigned __int16)v19, 5u);
          sub_377A0(a1);
        }
      }
    }
    else
    {
      LOBYTE(v37) = v36 - v25;
      HIBYTE(v37) = v39 - v22;
      if ( *(_DWORD *)(a1 + 4) - 1 == *(_DWORD *)(a1 + 8) )
      {
        v29 = 0;
        v40 = v37;
        while ( v3 > v29 )
        {
          v30 = 0;
          v45 = v40;
          while ( v4 > v30 )
          {
            sub_57390(v45, *(_WORD *)(a1 + 26));
            ++v30;
            LOBYTE(v45) = v45 + 1;
          }
          ++v29;
          ++HIBYTE(v40);
        }
      }
      v41 = v37;
      v28 = 0;
      v34 = v26;
      while ( v3 > v28 )
      {
        v33 = 0;
        v46 = v41;
        while ( v4 > v33 )
        {
          if ( v34[1] != -1 )
          {
            v6 = byte_13B4E0[v46];
            byte_11B4E0[v46] += ((unsigned __int8)v34[1] + (signed __int16)v35 - (unsigned __int8)byte_11B4E0[v46])
                              / *(_DWORD *)(a1 + 8);
            if ( !(v6 & 7) )
            {
              byte_13B4E0[v46] = v6 & 0xF0 | 1;
              sub_462A0(v46, v46);
            }
          }
          if ( v50 )
          {
            v7 = (unsigned __int8)byte_11B4E0[v46];
            if ( v7 >= (signed __int16)v35 )
              v8 = (unsigned __int8)v7;
            else
              v8 = (signed __int16)v35;
            v9 = v8 + 80;
            if ( v9 > 255 )
              v9 = 255;
            v10 = (unsigned __int8)byte_14B4E0[v46];
            if ( v9 > v10 )
              byte_14B4E0[v46] = v10 + (unsigned int)((v9 - v10) / *(_DWORD *)(a1 + 8));
            v11 = byte_11B4E0[v46];
            if ( (unsigned __int8)byte_14B4E0[v46] > v11 )
            {
              byte_13B4E0[v46] &= 0xF7u;
            }
            else
            {
              byte_14B4E0[v46] = v11 - 1;
              byte_13B4E0[v46] |= 8u;
            }
          }
          ++v33;
          v34 += 2;
          LOBYTE(v46) = v46 + 1;
        }
        ++v28;
        ++HIBYTE(v41);
      }
      v12 = 5;
      if ( !(*(_DWORD *)(a1 + 8) % 5) || *(_DWORD *)(a1 + 8) == 1 )
      {
        v13 = v26;
        v14 = 0;
        v42 = v37;
        while ( v14 < v3 )
        {
          v12 = 0;
          v32 = 0;
          v47 = v42;
          while ( v4 > v32 )
          {
            if ( *v13 != -1 )
            {
              v12 = byte_13B4E0[v47] & 0xF0 | 1;
              byte_13B4E0[v47] = v12;
              byte_10B4E0[v47] = 1;
            }
            v13 += 2;
            ++v32;
            LOBYTE(v47) = v47 + 1;
          }
          ++v14;
          ++HIBYTE(v42);
        }
        v31 = 0;
        v15 = v26;
        v43 = v37;
        if ( v3 )
        {
          do
          {
            v16 = 0;
            v24 = 0;
            v48 = v43;
            while ( v4 > v24 )
            {
              if ( *v15 != -1 )
                sub_45DC0(v16, v12, v48, *v15);
              v15 += 2;
              v12 = v24 + 1;
              v16 = v48 + 1;
              ++v24;
              LOBYTE(v48) = v48 + 1;
            }
            ++v31;
            ++HIBYTE(v43);
          }
          while ( v3 > v31 );
        }
      }
    }
  }
}
// D41B6: using guessed type char byte_D41B6;
// EA3BC: using guessed type int dword_EA3BC;
// EA3E4: using guessed type int dword_EA3E4[];
// 180660: using guessed type __int16 word_180660;

//----- (00037740) --------------------------------------------------------
char __cdecl sub_37740(int a1)
{
  unsigned int v1; // ebx
  char v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  v1 = *(_DWORD *)(dword_D41A4 + 38535);
  if ( v1 <= dword_EA3E4[0] )
    return 0;
  while ( *(_BYTE *)(v1 + 63) != 10 || *(_BYTE *)(v1 + 64) != 42 || !sub_10750(a1, v1) )
  {
    v1 = *(_DWORD *)v1;
    if ( v1 <= dword_EA3E4[0] )
      return v3;
  }
  return 1;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000377A0) --------------------------------------------------------
void __cdecl sub_377A0(int a1)
{
  __int16 *i; // ebx

  for ( i = *(__int16 **)(dword_D41A4 + 38519); (unsigned int)i > dword_EA3E4[0]; i = *(__int16 **)i )
  {
    if ( sub_10750(a1, (int)i) )
      sub_5FBD0(i);
  }
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000377F0) --------------------------------------------------------
__int16 __cdecl sub_377F0(int a1)
{
  __int16 v1; // dx
  signed int v2; // eax
  unsigned int v3; // esi
  unsigned int v4; // eax
  unsigned int v5; // edi
  char v6; // cl
  __int16 v7; // ax
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  int v12; // edx
  unsigned int v13; // edx
  unsigned __int16 v14; // ax
  char v15; // cl
  unsigned __int8 v16; // ch
  unsigned int k; // ecx
  unsigned int v18; // edx
  unsigned __int8 v19; // ch
  unsigned int l; // [esp+0h] [ebp-28h]
  unsigned int i; // [esp+4h] [ebp-24h]
  int v23; // [esp+8h] [ebp-20h]
  unsigned int j; // [esp+10h] [ebp-18h]
  unsigned __int16 v25; // [esp+18h] [ebp-10h]

  LOBYTE(v1) = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
  HIBYTE(v1) = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
  if ( word_180660 == 1 )
    v2 = (signed int)*(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 4) >> 1;
  else
    v2 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 4);
  v3 = v2;
  if ( word_180660 == 1 )
    v4 = (signed int)*(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 5) >> 1;
  else
    v4 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 5);
  v5 = v4;
  if ( word_180660 == 1 )
  {
    v5 = v4 >> 1;
    v3 >>= 1;
  }
  LOBYTE(v25) = v1 - (v3 >> 1);
  v6 = *(_BYTE *)(a1 + 12);
  HIBYTE(v25) = HIBYTE(v1) - (v5 >> 1);
  if ( v6 & 2 )
  {
    if ( !*(_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 40)] + 48) && *(_DWORD *)(a1 + 16) )
    {
      v9 = *(unsigned __int16 *)(a1 + 42) - *(signed __int16 *)(a1 + 46);
      v10 = *(_DWORD *)(a1 + 16);
      HIWORD(v11) = (unsigned int)(v9 % v10) >> 16;
      v23 = v9 / v10;
      LOWORD(v11) = *(_WORD *)(a1 + 46);
      v12 = v9 / v10 + v11;
      v8 = *(_DWORD *)(a1 + 16);
      *(_WORD *)(a1 + 46) = v12;
      if ( v8 == 1 )
      {
        v13 = 0;
        v14 = v25;
        while ( v5 > v13 )
        {
          for ( i = 0; v3 > i; ++i )
          {
            v15 = byte_13B4E0[v14];
            if ( v15 < 0 )
            {
              byte_13B4E0[v14] = v15 & 0x7F;
              if ( !byte_D41B6 )
                byte_13B4E0[v14] = v15 & 0x7F | 8;
            }
            v16 = v23 + byte_11B4E0[v14];
            byte_11B4E0[v14] = v16;
            if ( byte_D41B6 )
            {
              if ( v16 < (unsigned __int8)byte_14B4E0[v14] )
              {
                byte_13B4E0[v14] &= 0xF7u;
              }
              else
              {
                byte_14B4E0[v14] = v16 - 1;
                byte_13B4E0[v14] |= 8u;
              }
            }
            LOBYTE(v14) = v14 + 1;
          }
          ++v13;
          v14 = __PAIR__(HIBYTE(v14), (unsigned __int8)v25) + 256;
        }
        LOWORD(v8) = -10;
        *(_DWORD *)(a1 + 16) = -10;
      }
      else if ( v8 == -1 )
      {
        LOWORD(v8) = v25;
        for ( j = 0; v5 > j; ++j )
        {
          for ( k = 0; k < v3; ++k )
          {
            if ( !byte_D41B6 && byte_13B4E0[(unsigned __int16)v8] & 8 )
            {
              byte_13B4E0[(unsigned __int16)v8] |= 0x80u;
              byte_13B4E0[(unsigned __int16)v8] &= 0xF7u;
            }
            LOBYTE(v8) = v8 + 1;
          }
          LOWORD(v8) = __PAIR__(BYTE1(v8), (unsigned __int8)v25) + 256;
        }
        ++*(_DWORD *)(a1 + 16);
      }
      else if ( v8 <= 0 )
      {
        *(_DWORD *)(a1 + 16) = v8 + 1;
      }
      else
      {
        v18 = 0;
        LOWORD(v8) = v25;
        while ( v5 > v18 )
        {
          for ( l = 0; v3 > l; ++l )
          {
            v19 = v23 + byte_11B4E0[(unsigned __int16)v8];
            byte_11B4E0[(unsigned __int16)v8] = v19;
            if ( byte_D41B6 )
            {
              if ( v19 < (unsigned __int8)byte_14B4E0[(unsigned __int16)v8] )
              {
                byte_13B4E0[(unsigned __int16)v8] &= 0xF7u;
              }
              else
              {
                byte_14B4E0[(unsigned __int16)v8] = v19 - 1;
                byte_13B4E0[(unsigned __int16)v8] |= 8u;
              }
            }
            LOBYTE(v8) = v8 + 1;
          }
          ++v18;
          LOWORD(v8) = __PAIR__(BYTE1(v8), (unsigned __int8)v25) + 256;
        }
        --*(_DWORD *)(a1 + 16);
      }
    }
    else
    {
      *(_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 40)] + 46) = 2;
      *(_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 40)] + 158) = 32 * *(_WORD *)(a1 + 46);
      sub_48A20(v5 >> 1, v1, SHIBYTE(v1), (unsigned __int16)(v5 >> 1), (v3 >> 1) & 0xFFFF, 3u);
      LOWORD(v8) = sub_57F10(a1);
    }
  }
  else
  {
    *(_WORD *)(a1 + 46) = *(_WORD *)(a1 + 80) >> 5;
    *(_DWORD *)(a1 + 16) = 10;
    *(_BYTE *)(a1 + 12) = v6 | 2;
    v7 = sub_48DF0(v25 - 1, HIBYTE(v25) - 1, v5 + 2, v3 + 2);
    *(_WORD *)(a1 + 42) = v7;
    if ( (unsigned __int16)v7 > 0xDCu )
      *(_WORD *)(a1 + 42) = 220;
    v8 = *(signed __int16 *)(a1 + 46);
    if ( v8 == *(unsigned __int16 *)(a1 + 42) )
      *(_DWORD *)(a1 + 16) = 0;
  }
  return v8;
}
// D41B6: using guessed type char byte_D41B6;
// EA3BC: using guessed type int dword_EA3BC;
// EA3E4: using guessed type int dword_EA3E4[];
// 180660: using guessed type __int16 word_180660;

//----- (00037BC0) --------------------------------------------------------
__int16 __cdecl sub_37BC0(int a1)
{
  int v1; // eax
  int v2; // edx
  signed int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  signed int v6; // eax
  unsigned int v7; // edx
  unsigned int v8; // edx
  unsigned __int16 v9; // ax
  unsigned __int8 *v10; // esi
  int v11; // edi
  unsigned __int8 v12; // ch
  int v13; // edx
  unsigned int v14; // edi
  int v15; // esi
  char v16; // al
  char v17; // dl
  signed __int16 v18; // dx
  int v19; // eax
  int v20; // eax
  int v21; // edx
  unsigned __int8 v22; // ch
  signed int v23; // eax
  unsigned int v24; // esi
  unsigned int v25; // eax
  unsigned __int16 v26; // ST44_2
  unsigned int v27; // edx
  unsigned int v28; // ecx
  int v30; // [esp+4h] [ebp-54h]
  unsigned int v31; // [esp+10h] [ebp-48h]
  unsigned int v32; // [esp+14h] [ebp-44h]
  int v33; // [esp+18h] [ebp-40h]
  unsigned int k; // [esp+1Ch] [ebp-3Ch]
  int v35; // [esp+20h] [ebp-38h]
  unsigned int v36; // [esp+24h] [ebp-34h]
  unsigned int v37; // [esp+28h] [ebp-30h]
  unsigned int v38; // [esp+2Ch] [ebp-2Ch]
  unsigned int v39; // [esp+30h] [ebp-28h]
  int v40; // [esp+34h] [ebp-24h]
  unsigned __int16 v41; // [esp+38h] [ebp-20h]
  unsigned __int16 v42; // [esp+3Ch] [ebp-1Ch]
  unsigned __int16 j; // [esp+3Ch] [ebp-1Ch]
  unsigned __int16 v44; // [esp+3Ch] [ebp-1Ch]
  unsigned __int16 v45; // [esp+40h] [ebp-18h]
  unsigned __int8 i; // [esp+44h] [ebp-14h]
  char v47; // [esp+48h] [ebp-10h]
  unsigned __int8 v48; // [esp+50h] [ebp-8h]
  char v49; // [esp+54h] [ebp-4h]
  char v50; // [esp+54h] [ebp-4h]

  LOBYTE(v1) = dword_E9C38;
  v30 = dword_E9C38;
  BYTE1(v1) = *(_BYTE *)(a1 + 12);
  if ( !(v1 & 0x200) )
  {
    *(_DWORD *)(a1 + 16) = 19;
    *(_BYTE *)(a1 + 12) = BYTE1(v1) | 2;
  }
  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 <= 0 )
  {
    *(_DWORD *)(a1 + 16) = v2 + 1;
    if ( v2 == -1 )
    {
      v50 = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
      if ( word_180660 == 1 )
        v23 = (signed int)*(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 4) >> 1;
      else
        v23 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 4);
      v24 = v23;
      if ( word_180660 == 1 )
        v25 = (signed int)*(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 5) >> 1;
      else
        v25 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 5);
      if ( !byte_D41B6 )
      {
        v27 = 0;
        HIBYTE(v26) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - (v25 >> 1);
        LOBYTE(v26) = v50 - (v24 >> 1);
        v44 = v26;
        while ( v27 < v25 )
        {
          v28 = 0;
          while ( v28 < v24 )
          {
            if ( byte_13B4E0[v44] & 8 )
            {
              byte_13B4E0[v44] |= 0x80u;
              byte_13B4E0[v44] &= 0xF7u;
            }
            ++v28;
            LOBYTE(v44) = v44 + 1;
          }
          LOBYTE(v44) = v50 - (v24 >> 1);
          ++v27;
          ++HIBYTE(v44);
        }
      }
      *(_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 40)] + 46) = 2;
      LOWORD(v1) = sub_57F10(a1);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 16) = v2 - 1;
    if ( v2 == 1 )
    {
      if ( *(_BYTE *)(a1 + 59) )
        *(_DWORD *)(a1 + 16) = -25;
      else
        *(_DWORD *)(a1 + 16) = -1;
    }
    else
    {
      v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
      if ( !*(_WORD *)(v1 + 48) )
      {
        v49 = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
        v47 = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
        v40 = *(signed __int16 *)(a1 + 80) >> 5;
        if ( word_180660 == 1 )
          v3 = (signed int)*(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 4) >> 1;
        else
          v3 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 4);
        v36 = v3;
        if ( word_180660 == 1 )
          v4 = (signed int)*(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 5) >> 1;
        else
          v4 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 5);
        v37 = v4;
        v48 = v4 >> 1;
        LOBYTE(v41) = v49 - (v36 >> 1);
        HIBYTE(v41) = v47 - v48;
        memset(v30, 0, 2 * v4 * v36);
        for ( i = 1; i <= (signed int)*(char *)(a1 + 70); ++i )
        {
          v5 = 6 * i;
          if ( word_180660 == 1 )
            v6 = (signed int)*(unsigned __int8 *)(dword_EA3BC + v5 + 4) >> 1;
          else
            v6 = *(unsigned __int8 *)(dword_EA3BC + v5 + 4);
          v31 = v6;
          if ( word_180660 == 1 )
            v7 = (signed int)*(unsigned __int8 *)(dword_EA3BC + 6 * i + 5) >> 1;
          else
            v7 = *(unsigned __int8 *)(dword_EA3BC + 6 * i + 5);
          v39 = v7;
          v8 = v7 >> 1;
          LOBYTE(v9) = v49 - v8;
          HIBYTE(v9) = v47 - (v31 >> 1);
          v10 = *(unsigned __int8 **)(dword_EA3BC + 6 * i);
          v45 = v9;
          v33 = (unsigned __int8)(v36 >> 1) - v8;
          v38 = 0;
          v11 = v36 * (v48 - (v31 >> 1));
          while ( v38 < v31 )
          {
            v35 = v11 + v33;
            v32 = 0;
            v42 = v45;
            while ( v32 < v39 )
            {
              if ( *(_BYTE *)(a1 + 14) & 1 )
                sub_57390(v42, *(_WORD *)(a1 + 26));
              v12 = v10[1];
              if ( v12 != -1 )
                *(_WORD *)(v30 + 2 * v35) = v12 + (_WORD)v40 - (unsigned __int8)byte_11B4E0[v42];
              v13 = *(_DWORD *)(a1 + 16) % 7;
              if ( (!v13 || *(_DWORD *)(a1 + 16) == 1) && *v10 != -1 )
                sub_45DC0(v13, 7, v42, *v10);
              v10 += 2;
              ++v32;
              LOBYTE(v42) = v42 + 1;
              ++v35;
            }
            v11 += v36;
            ++v38;
            ++HIBYTE(v45);
          }
        }
        LOWORD(v1) = v41;
        v14 = 0;
        v15 = 0;
        for ( j = v41; v14 < v37; ++HIBYTE(j) )
        {
          for ( k = 0; k < v36; ++k )
          {
            if ( *(_WORD *)(v30 + 2 * v15) )
            {
              if ( !byte_11B4E0[j] || sub_57450(byte_10B4E0[j]) )
              {
                byte_13B4E0[j] = byte_13B4E0[j] & 0xF8 | 1;
                sub_46570(j, j);
              }
              byte_11B4E0[j] += (signed int)*(signed __int16 *)(v30 + 2 * v15) / *(_DWORD *)(a1 + 16);
              if ( *(_DWORD *)(a1 + 16) == 1 )
              {
                v16 = byte_13B4E0[j];
                if ( v16 < 0 )
                {
                  v17 = byte_D41B6;
                  byte_13B4E0[j] = v16 & 0x7F;
                  if ( !v17 )
                    byte_13B4E0[j] = v16 & 0x7F | 8;
                }
              }
            }
            if ( byte_D41B6 )
            {
              v18 = (unsigned __int8)byte_11B4E0[j];
              if ( v18 >= (signed __int16)v40 )
                v19 = (unsigned __int8)v18;
              else
                v19 = (signed __int16)v40;
              v20 = v19 + 100;
              if ( v20 > 255 )
                v20 = 255;
              v21 = (unsigned __int8)byte_14B4E0[j];
              if ( v20 > v21 )
                byte_14B4E0[j] += (v20 - v21) / *(_DWORD *)(a1 + 16);
              v22 = byte_11B4E0[j];
              if ( (unsigned __int8)byte_14B4E0[j] > v22 )
              {
                byte_13B4E0[j] &= 0xF7u;
              }
              else
              {
                byte_14B4E0[j] = v22 - 1;
                byte_13B4E0[j] |= 8u;
              }
            }
            if ( !byte_D41B6 && *(_DWORD *)(a1 + 16) == 2 )
              byte_13B4E0[j] &= 0xF7u;
            LOBYTE(j) = j + 1;
            ++v15;
          }
          LOBYTE(j) = v49 - (v36 >> 1);
          LOWORD(v1) = __PAIR__(HIBYTE(j), (unsigned __int8)v41) + 256;
          ++v14;
        }
      }
    }
  }
  return v1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41B6: using guessed type char byte_D41B6;
// E9C38: using guessed type int dword_E9C38;
// EA3BC: using guessed type int dword_EA3BC;
// EA3E4: using guessed type int dword_EA3E4[];
// 180660: using guessed type __int16 word_180660;

//----- (00038270) --------------------------------------------------------
int __cdecl sub_38270(int a1)
{
  int v1; // ebx
  int result; // eax
  int v3; // eax

  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  v1 = 0;
  switch ( *(unsigned __int16 *)(a1 + 20) % 0xCu )
  {
    case 0u:
    case 1u:
      result = sub_4A190((int)&word_EB398, 5, 4);
      v1 = result;
      if ( !result )
        goto LABEL_10;
      *(_BYTE *)(result + 69) = 33;
      break;
    case 2u:
    case 3u:
      result = sub_4A190((int)&word_EB398, 5, 14);
      v1 = result;
      if ( !result )
        goto LABEL_10;
      *(_BYTE *)(result + 69) = 113;
      break;
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 8u:
      result = sub_4A190((int)&word_EB398, 5, 13);
      v1 = result;
      if ( !result )
        goto LABEL_10;
      *(_BYTE *)(result + 69) = 105;
      break;
    case 9u:
    case 0xAu:
    case 0xBu:
      v3 = sub_4A190((int)&word_EB398, 5, 12);
      v1 = v3;
      if ( v3 )
        *(_BYTE *)(v3 + 69) = 97;
      goto LABEL_10;
    default:
LABEL_10:
      result = v1;
      break;
  }
  return result;
}
// EB398: using guessed type __int16 word_EB398;

//----- (00038330) --------------------------------------------------------
int __cdecl sub_38330(int a1)
{
  unsigned int v1; // eax
  signed int v2; // edx
  int v3; // eax
  int v4; // eax
  __int16 v5; // dx
  unsigned int v6; // edx
  __int16 v7; // cx
  __int16 v8; // ax
  __int16 v9; // cx
  unsigned int v10; // ecx
  int result; // eax

  v1 = sub_38B00(a1);
  if ( v1 < 1 )
  {
    if ( v1 )
      goto LABEL_31;
  }
  else
  {
    if ( v1 > 1 )
    {
      if ( v1 == 2 )
        *(_BYTE *)(a1 + 69) = 53;
      goto LABEL_31;
    }
    v2 = *(_DWORD *)(a1 + 16);
    if ( v2 > 2 )
    {
      v3 = *(char *)(a1 + 70);
      *(_DWORD *)(a1 + 16) = v2 - 1;
      if ( byte_D93C2[4 * v3] & 1 )
      {
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        word_EB398 += *(_WORD *)(a1 + 84);
        v4 = sub_4A190((int)&word_EB398, 5, 4);
        if ( v4 )
        {
          *(_BYTE *)(v4 + 69) = 33;
          v5 = *(_WORD *)(a1 + 38);
          *(_DWORD *)(v4 + 94) = 1;
          *(_WORD *)(v4 + 98) = v5;
        }
      }
      v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( v6 > dword_EA3E4[0] && (!*(_BYTE *)(v6 + 64) || *(_BYTE *)(v6 + 64) == 1) )
        *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
    }
  }
  v7 = *(_WORD *)(a1 + 104);
  if ( v7 )
  {
    if ( v7 != *(_WORD *)(a1 + 148) )
    {
      if ( *(_DWORD *)(a1 + 100) )
      {
        *(_WORD *)(a1 + 148) = v7;
        sub_6E450(v7, -1, 4);
        *(_DWORD *)(a1 + 12) &= 0xFFDFFFFE;
        *(_BYTE *)(a1 + 14) |= 0x20u;
        sub_49CD0((_WORD *)a1, 177);
        *(_WORD *)(a1 + 90) += *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 104)] + 164) + 56);
      }
      else if ( !(*(_BYTE *)(a1 + 14) & 0x20) )
      {
        v8 = *(_WORD *)(a1 + 104);
        *(_WORD *)(a1 + 148) = v8;
        sub_6E450(v8, -1, 4);
        *(_BYTE *)(a1 + 12) &= 0xFEu;
        sub_49CD0((_WORD *)a1, 177);
        *(_WORD *)(a1 + 90) += *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 104)] + 164) + 56);
      }
    }
    *(_WORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  if ( !(*(_BYTE *)(a1 + 62) & 0x1F) )
  {
    if ( byte_D93C2[4 * *(char *)(a1 + 70)] & 1 )
    {
      v9 = *(_WORD *)(a1 + 132);
      if ( v9 > 5 && v9 == *(_DWORD *)(a1 + 16) )
      {
        v10 = *(signed __int16 *)(a1 + 132);
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        if ( (signed int)(*(unsigned __int16 *)(a1 + 20) % v10) > *(signed __int16 *)(a1 + 132)
                                                                - (*(signed __int16 *)(a1 + 132) >> 4)
                                                                - 2 )
        {
          *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
          *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
          word_EB398 += *(_WORD *)(a1 + 84);
          sub_38270(a1);
        }
      }
    }
  }
  if ( byte_D93C2[4 * *(char *)(a1 + 70)] & 1 )
    sub_5C8D0(a1);
LABEL_31:
  result = sub_10C40((__int16 *)(a1 + 76));
  *(_WORD *)(a1 + 80) = result;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (000385C0) --------------------------------------------------------
int __cdecl sub_385C0(int a1)
{
  unsigned __int8 v1; // dl
  int v2; // eax
  _BYTE *v3; // edi
  int v4; // esi
  signed int v5; // edx
  int v6; // eax
  __int16 v7; // dx
  unsigned int v8; // esi
  char v9; // dh
  unsigned __int8 v10; // cl
  char v11; // ch
  int v13; // esi
  __int16 v14; // cx
  char v15; // ah
  unsigned int v16; // edi
  _BYTE *v17; // eax
  unsigned int v18; // esi
  unsigned int v19; // [esp+0h] [ebp-28h]
  int v20; // [esp+4h] [ebp-24h]
  unsigned int v21; // [esp+8h] [ebp-20h]
  _BYTE *v22; // [esp+Ch] [ebp-1Ch]
  unsigned int v23; // [esp+10h] [ebp-18h]
  unsigned int v24; // [esp+14h] [ebp-14h]
  __int16 v25; // [esp+18h] [ebp-10h]
  unsigned __int16 v26; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v27; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v28; // [esp+20h] [ebp-8h]
  unsigned __int16 v29; // [esp+20h] [ebp-8h]
  unsigned __int16 v30; // [esp+24h] [ebp-4h]

  v1 = *(_BYTE *)(a1 + 70);
  v22 = *(_BYTE **)(dword_EA3BC + 6 * v1);
  v21 = *(unsigned __int8 *)(dword_EA3BC + 6 * v1 + 5);
  v24 = *(unsigned __int8 *)(dword_EA3BC + 6 * v1 + 4);
  if ( word_180660 == 1 )
  {
    v21 >>= 1;
    v24 = (unsigned int)*(unsigned __int8 *)(dword_EA3BC + 6 * v1 + 4) >> 1;
  }
  LOBYTE(v30) = ((unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8) - (v24 >> 1);
  HIBYTE(v30) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - (v21 >> 1);
  if ( !*(_BYTE *)(a1 + 61) )
  {
    if ( *(_BYTE *)(a1 + 64) )
      LOWORD(v2) = sub_48DF0(v30, SHIBYTE(v30), v21, v24);
    else
      v2 = *(signed __int16 *)(a1 + 80) >> 5;
    v25 = v2;
    v19 = 0;
    v28 = v30;
    v3 = v22;
    v20 = 0;
    while ( v19 < v21 )
    {
      v23 = 0;
      v26 = v28;
      while ( v23 < v24 )
      {
        if ( v3[1] != -1 || -1 != *v3 )
        {
          word_EB398 = (unsigned __int8)v26 << 8;
          word_EB39A = HIBYTE(v28) << 8;
          ++v20;
          word_EB39C = 32 * v25;
          if ( !(v20 & 7) )
            word_EB39C = 32 * (v25 - 10);
          v4 = *(_DWORD *)(a1 + 16);
          if ( v4 > 0 )
          {
            *(_DWORD *)(a1 + 16) = v4 - 1;
            if ( byte_D93C2[4 * *(char *)(a1 + 70)] & 1 )
            {
              v5 = *(_DWORD *)(a1 + 16);
              if ( v5 )
              {
                if ( v5 >= 4 )
                {
                  v6 = sub_38270(a1);
                }
                else
                {
                  v6 = sub_4A190((int)&word_EB398, 5, 4);
                  if ( v6 )
                    *(_BYTE *)(v6 + 69) = 33;
                }
              }
              else
              {
                v6 = sub_4A190((int)&word_EB398, 5, 12);
                if ( v6 )
                  *(_BYTE *)(v6 + 69) = 97;
              }
              if ( v6 )
              {
                v7 = *(_WORD *)(a1 + 38);
                *(_DWORD *)(v6 + 94) = 1;
                *(_WORD *)(v6 + 98) = v7;
              }
            }
          }
          v8 = v26;
          v9 = byte_13B4E0[v26] & 0x7F;
          byte_13B4E0[(unsigned __int16)v8] = byte_13B4E0[(unsigned __int16)v8] & 0x70 | 1;
          sub_46570(v8, v8);
          v10 = v3[1];
          if ( v10 != -1 )
          {
            if ( v10 >= (unsigned __int8)byte_11B4E0[v26] )
            {
              byte_11B4E0[v26] = 0;
            }
            else
            {
              *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
              if ( (signed int)(*(unsigned __int16 *)(a1 + 20) % 0x32u) <= 20 )
              {
                byte_11B4E0[v26] -= v3[1];
              }
              else
              {
                *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
                byte_11B4E0[v26] -= v3[1] - *(_WORD *)(a1 + 20) % 0x14u;
              }
            }
          }
        }
        v3 += 2;
        ++v23;
        LOBYTE(v26) = v26 + 1;
      }
      ++v19;
      ++HIBYTE(v28);
    }
    sub_48B50(v30, SHIBYTE(v30), (unsigned __int16)v21, (unsigned __int16)v24);
    v11 = *(_BYTE *)(a1 + 65);
    if ( v11 )
      sub_4A1E0(v11, 1);
    if ( *(_BYTE *)(a1 + 70) == 68 )
    {
      *(_WORD *)(dword_D41A0 + 222538) = 0;
      return sub_57F10(a1);
    }
    return sub_57F10(a1);
  }
  v13 = sub_4A190(a1 + 76, 10, 45);
  if ( !v13 )
  {
    *(_BYTE *)(a1 + 61) = 0;
    return sub_57F10(a1);
  }
  sub_49A30(v13, *(char *)(a1 + 61));
  *(_WORD *)(v13 + 80) = *(_WORD *)(a1 + 158);
  *(_BYTE *)(v13 + 65) = *(_BYTE *)(a1 + 65);
  v14 = *(_WORD *)(a1 + 148);
  if ( v14 )
  {
    v15 = *(_BYTE *)(v13 + 12);
    *(_WORD *)(v13 + 148) = v14;
    *(_BYTE *)(v13 + 12) = v15 | 1;
    if ( *(_BYTE *)(a1 + 14) & 0x20 )
      *(_BYTE *)(v13 + 14) |= 0x20u;
    else
      *(_BYTE *)(v13 + 14) &= 0xDFu;
    sub_49CD0((_WORD *)v13, 177);
    *(_WORD *)(v13 + 90) = *(_WORD *)(a1 + 90);
  }
  sub_59760(a1, v13);
  v16 = 0;
  v29 = v30;
  v17 = v22;
  while ( v16 < v21 )
  {
    v18 = 0;
    v27 = v29;
    while ( v18 < v24 )
    {
      if ( v17[1] != -1 || -1 != *v17 )
        byte_13B4E0[v27] &= 0x7Fu;
      ++v18;
      v17 += 2;
      LOBYTE(v27) = v27 + 1;
    }
    ++v16;
    ++HIBYTE(v29);
  }
  return sub_57F10(a1);
}
// D41A0: using guessed type int dword_D41A0;
// EA3BC: using guessed type int dword_EA3BC;
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;
// 180660: using guessed type __int16 word_180660;

//----- (000389F0) --------------------------------------------------------
int __cdecl sub_389F0(int a1)
{
  int v1; // eax
  __int16 v2; // dx

  v1 = *(_DWORD *)(a1 + 8);
  ++*(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 >= 0 )
  {
    sub_585A0(a1);
    if ( !(*(_BYTE *)(a1 + 12) & 2) )
    {
      *(_BYTE *)(a1 + 12) |= 2u;
      if ( (signed __int16)sub_10C40((__int16 *)(a1 + 76)) > 58880 )
        sub_5F890(a1, 0);
      if ( sub_106C0(
             a1,
             dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(dword_EA3E4[*(signed __int16 *)(a1 + 26)] + 164) + 58)]) )
      {
        v2 = *(_WORD *)(a1 + 26);
        *(_WORD *)(dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(dword_EA3E4[*(signed __int16 *)(a1 + 26)] + 164) + 58)]
                 + 128) = v2;
        *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(dword_EA3E4[v2] + 164) + 58)] + 124) = 10;
      }
      else
      {
        sub_5F890(a1, 0);
      }
    }
  }
  return sub_57F10(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00038B00) --------------------------------------------------------
signed int __cdecl sub_38B00(int a1)
{
  signed int v1; // ebx
  int v3; // ecx
  __int16 v4; // bx

  *(_WORD *)(a1 + 38) = 0;
  v1 = 0;
  if ( *(_DWORD *)(a1 + 8) < 0 )
    return 2;
  if ( *(_WORD *)(a1 + 98) )
  {
    v3 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 94);
    *(_DWORD *)(a1 + 8) = v3;
    if ( v3 < 0 )
    {
      v4 = *(_WORD *)(a1 + 98);
      *(_WORD *)(a1 + 36) = v4;
      *(_WORD *)(a1 + 38) = v4;
      return 2;
    }
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 98);
    *(_DWORD *)(a1 + 94) = 0;
    v1 = 1;
    *(_WORD *)(a1 + 98) = 0;
  }
  return v1;
}

//----- (00038B90) --------------------------------------------------------
int __cdecl sub_38B90(int a1)
{
  int v1; // eax
  int result; // eax
  int v3; // eax
  int v4; // edi
  int v5; // eax
  int v6; // esi
  int v7; // edx
  __int16 v8; // [esp+0h] [ebp-10h]
  __int16 v9; // [esp+2h] [ebp-Eh]
  __int16 v10; // [esp+4h] [ebp-Ch]
  int v11; // [esp+8h] [ebp-8h]
  int v12; // [esp+Ch] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  if ( !(*(_BYTE *)(a1 + 12) & 2) )
  {
    v3 = dword_D41A0 + 28302;
    *(_DWORD *)(a1 + 12) |= (unsigned int)&loc_10001 + 1;
    sub_6E450((a1 - v3) / 168, -1, 30);
  }
  sub_49EA0(
    (_WORD *)a1,
    (768 * *(_DWORD *)(a1 + 16)
   - (__CFSHL__(768 * *(_DWORD *)(a1 + 16) >> 31, 2)
    + 4 * (768 * *(_DWORD *)(a1 + 16) >> 31))) >> 2,
    512);
  sub_10C80(a1, 0, (signed int)*(unsigned __int16 *)(a1 + 42) / *(_DWORD *)(a1 + 4));
  v4 = sub_10080(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 16));
  if ( v4 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    while ( sub_10130(v4, &v12, &v11) == 1 )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v8 = *(_WORD *)(a1 + 76) - 96 + 160 * v12 + *(_WORD *)(a1 + 20) % 0x81u - 64;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v9 = *(_WORD *)(a1 + 20) % 0x81u + *(_WORD *)(a1 + 78) - 96 + 160 * v11 - 64;
      v10 = *(_WORD *)(a1 + 80);
      v5 = sub_4A190((int)&v8, 10, 0);
      v6 = v5;
      if ( v5 )
      {
        *(_WORD *)(v5 + 26) = *(_WORD *)(a1 + 26);
        *(_WORD *)(v5 + 28) = *(_WORD *)(a1 + 28);
        *(_DWORD *)(v5 + 12) |= (unsigned int)sub_10080;
        sub_49EA0((_WORD *)v5, 512, 512);
        *(_DWORD *)(v6 + 16) = 0;
      }
    }
    sub_10100(v4);
  }
  v7 = *(_DWORD *)(a1 + 16) + 2;
  result = v7 / 7;
  *(_DWORD *)(a1 + 16) = v7 % 7;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00038D80) --------------------------------------------------------
unsigned int __cdecl sub_38D80(int a1)
{
  unsigned int result; // eax
  unsigned int i; // ebx
  unsigned int v3; // ecx

  result = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = result - 1;
  if ( (result & 0x80000000) != 0 )
    return sub_57F10(a1);
  for ( i = *(_DWORD *)(dword_D41A4 + 38523); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( !*(_WORD *)(i + 122) )
    {
      result = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
      if ( result < *(_DWORD *)(a1 + 16) )
      {
        v3 = sub_7277A(result);
        if ( v3 > 0x2A )
          v3 = 42;
        result = (a1 - (dword_D41A0 + 28302)) / 168;
        *(_DWORD *)(i + 118) = v3;
        *(_WORD *)(i + 122) = result;
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00038E20) --------------------------------------------------------
int __cdecl sub_38E20(int a1)
{
  return sub_57F10(a1);
}

//----- (00038E40) --------------------------------------------------------
int __cdecl sub_38E40(int a1)
{
  return sub_57F10(a1);
}

//----- (00038E70) --------------------------------------------------------
int __cdecl sub_38E70(int a1)
{
  int v1; // ebx
  int v2; // eax
  unsigned __int8 v3; // dh

  if ( *(_WORD *)(a1 + 150) )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( *(_BYTE *)(v1 + 63) == 3 && !*(_BYTE *)(v1 + 64) )
    {
      v2 = *(_DWORD *)(v1 + 164);
      v3 = *(_BYTE *)(v2 + 332);
      if ( v3 < 3u )
      {
        if ( !v3 )
        {
          *(_WORD *)(v2 + 30) = -80;
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          sub_6E450(*(_WORD *)(a1 + 150), -1, (*(_WORD *)(a1 + 20) & 3) + 54);
        }
        sub_5C830(v1, 3, 171 * (unsigned __int8)++*(_BYTE *)(*(_DWORD *)(v1 + 164) + 332) / 3 + 85);
      }
      *(_BYTE *)(*(_DWORD *)(v1 + 164) + 333) = 8;
    }
  }
  return sub_57F10(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00038F70) --------------------------------------------------------
int __cdecl sub_38F70(_WORD *a1)
{
  int v1; // esi
  int v2; // eax

  if ( a1[75] )
  {
    v1 = dword_EA3E4[(unsigned __int16)a1[75]];
    if ( *(_BYTE *)(v1 + 63) == 3 && !*(_BYTE *)(v1 + 64) )
    {
      v2 = *(_DWORD *)(v1 + 164);
      if ( !*(_BYTE *)(v2 + 334) )
      {
        *(_WORD *)(v2 + 30) = -80;
        a1[10] = 9377 * a1[10] + 9439;
        sub_6E450(a1[75], -1, (a1[10] & 3) + 54);
        sub_11900((int)a1, v1, 0, a1[21]);
      }
      *(_BYTE *)(*(_DWORD *)(v1 + 164) + 334) = 1;
      *(_BYTE *)(*(_DWORD *)(v1 + 164) + 335) = 10;
    }
  }
  return sub_57F10((int)a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00039040) --------------------------------------------------------
char __cdecl sub_39040(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  unsigned __int8 v4; // bl
  unsigned __int16 v5; // ax
  int v6; // edx
  int v7; // ecx
  unsigned __int16 v8; // bx
  signed int v9; // eax
  __int16 v10; // ax
  int v11; // ecx
  int v12; // ecx
  char v13; // dl
  int v14; // esi
  int v15; // edx
  int v16; // esi
  char v17; // al
  unsigned __int16 v18; // cx
  int v19; // eax
  int v20; // ecx
  int v21; // eax
  char v22; // dh
  unsigned __int16 v23; // dx
  __int16 v24; // ax
  signed int v25; // esi
  unsigned __int16 v26; // bx
  int v27; // ecx
  int v28; // edi
  int v29; // eax
  unsigned __int16 v30; // bx
  signed int v31; // esi
  signed int v32; // edi
  unsigned __int16 v33; // ax
  __int16 v34; // dx
  unsigned __int16 v35; // bx
  signed int v36; // eax
  signed int v37; // edx
  unsigned __int16 v38; // si
  __int16 v40; // [esp+0h] [ebp-3Ch]
  __int16 v41; // [esp+2h] [ebp-3Ah]
  int v42; // [esp+8h] [ebp-34h]
  __int16 v43; // [esp+Ch] [ebp-30h]
  int i; // [esp+10h] [ebp-2Ch]
  int v45; // [esp+14h] [ebp-28h]
  int v46; // [esp+18h] [ebp-24h]
  int v47; // [esp+1Ch] [ebp-20h]
  int v48; // [esp+20h] [ebp-1Ch]
  int v49; // [esp+24h] [ebp-18h]
  int v50; // [esp+28h] [ebp-14h]
  int v51; // [esp+2Ch] [ebp-10h]
  int v52; // [esp+30h] [ebp-Ch]
  int v53; // [esp+34h] [ebp-8h]
  char v54; // [esp+38h] [ebp-4h]

  v54 = 0;
  LOBYTE(v1) = a1;
  v2 = *(_DWORD *)(a1 + 8) - 1;
  dword_E9B90 = 0;
  *(_DWORD *)(a1 + 8) = v2;
  if ( v2 <= 0 )
  {
    *(_BYTE *)(a1 + 69) = 74;
    *(_BYTE *)(a1 + 70) = 0;
  }
  else
  {
    v3 = (*(signed __int16 *)(a1 + 76) + 128) >> 8;
    v1 = (*(signed __int16 *)(a1 + 78) + 128) >> 8;
    LOBYTE(v53) = v3 - 15;
    BYTE1(v53) = v1 - 15;
    LOBYTE(v52) = v3;
    v4 = *(_BYTE *)(a1 + 70);
    BYTE1(v52) = v1;
    if ( v4 <= 3u )
    {
      switch ( v4 )
      {
        case 0u:
          LOBYTE(v1) = sub_39E40(a1);
          if ( (_BYTE)v1 )
            *(_BYTE *)(a1 + 70) = 1;
          else
            LOBYTE(v1) = sub_57F10(a1);
          break;
        case 1u:
          v5 = sub_48DF0(v3 - 9, v1 - 9, 18, 18);
          *(_WORD *)(a1 + 80) = 0;
          *(_WORD *)(a1 + 44) = 0;
          if ( (signed int)v5 > 64 )
          {
            *(_WORD *)(a1 + 80) = v5 - 64;
            if ( (signed __int16)(v5 - 64) > 16 )
              *(_WORD *)(a1 + 44) = 32 * (v5 - 80);
          }
          *(_DWORD *)(a1 + 144) = 0;
          *(_BYTE *)(a1 + 70) = 2;
          *(_DWORD *)(a1 + 16) = 12;
          sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 64);
          goto LABEL_11;
        case 2u:
LABEL_11:
          v6 = *(_DWORD *)(a1 + 16) - 1;
          *(_DWORD *)(a1 + 16) = v6;
          if ( v6 <= 0 )
          {
            *(_BYTE *)(a1 + 70) = 3;
          }
          else
          {
            v7 = 0;
            for ( HIBYTE(v8) = BYTE1(v53); ; ++HIBYTE(v8) )
            {
              v51 = v7;
              if ( v7 >= 30 )
                break;
              LOBYTE(v8) = v53;
              for ( i = 0; i < 30; ++i )
              {
                v40 = (unsigned __int8)v8 << 8;
                v41 = HIBYTE(v8) << 8;
                v9 = sub_58490((_WORD *)(a1 + 76), &v40);
                v48 = v9;
                if ( v9 < 3840 )
                {
                  if ( v9 >= 2304 )
                  {
                    v10 = sub_581E0((_WORD *)(a1 + 76), &v40);
                    v42 = *(_DWORD *)(a1 + 76);
                    v43 = *(_WORD *)(a1 + 80);
                    sub_57FA0(&v42, v10, 0, 3840);
                    v11 = (signed __int16)sub_10C40((__int16 *)&v42) >> 5;
                    if ( *(signed __int16 *)(a1 + 44) < v11 )
                      *(_WORD *)(a1 + 44) = v11;
                    v50 = v11
                        - (((_DWORD)((_DWORD)sub_10000 + (signed int)off_DBF50[((v48 - 2304) << 10) / 1536]) >> 1)
                         * (v11 - (*(signed __int16 *)(a1 + 80) + 64)) >> 16);
                  }
                  else
                  {
                    v50 = *(signed __int16 *)(a1 + 80)
                        + 64
                        - (((char *)sub_10000 - (char *)off_DBF50[((2304 - v9) << 9) / 2304]) << 6 >> 16);
                  }
                  v12 = (v50 - (unsigned __int8)byte_11B4E0[v8]) / *(_DWORD *)(a1 + 16)
                      + (unsigned __int8)byte_11B4E0[v8];
                  if ( v12 < 1 )
                    v12 = 1;
                  if ( v12 > 255 )
                    v12 = 255;
                  v13 = byte_D41B6;
                  byte_11B4E0[v8] = v12;
                  if ( v13 )
                  {
                    v50 = v12 + 64;
                    if ( v12 + 64 > 254 )
                      v50 = 254;
                    v14 = (unsigned __int8)byte_14B4E0[v8];
                    v15 = (unsigned __int8)byte_14B4E0[v8];
                    v47 = v8;
                    v50 = v14 - (v15 - v50) / *(_DWORD *)(a1 + 16);
                    byte_14B4E0[v47] = v50;
                  }
                  v16 = *(signed __int16 *)(a1 + 80);
                  if ( v12 <= v16 + 64 && v12 >= v16 + 6 * *(_DWORD *)(a1 + 16) && sub_57450(byte_10B4E0[v8]) )
                  {
                    v17 = byte_13B4E0[v8] & 0xF8;
                    v54 = 1;
                    byte_10B4E0[v8] = 1;
                    byte_13B4E0[v8] = v17 | 1;
                  }
                }
                LOBYTE(v8) = v8 + 1;
                ++HIBYTE(v8);
                v18 = v8;
                LOBYTE(v8) = v8 - 2;
                HIBYTE(v8) -= 2;
                v19 = (unsigned __int8)byte_11B4E0[v8];
                LOBYTE(v8) = v8 + 1;
                v20 = v19 - (unsigned __int8)byte_11B4E0[v18] + 32;
                ++HIBYTE(v8);
                if ( v20 >= 28 )
                {
                  if ( v20 > 40 )
                    v20 = (v20 & 7) + 40;
                }
                else
                {
                  v20 = (v20 & 3) + 28;
                }
                if ( *(_BYTE *)(dword_D41A0 + 196308) )
                  v21 = 32 - v20 + 32;
                else
                  LOBYTE(v21) = v20;
                v22 = byte_D41B6;
                byte_12B4E0[v8] = v21;
                if ( v22 )
                {
                  if ( (unsigned __int8)byte_14B4E0[v8] > (unsigned __int8)byte_11B4E0[v8] )
                    byte_13B4E0[v8] &= 0xF7u;
                  else
                    byte_13B4E0[v8] |= 8u;
                }
                LOBYTE(v8) = v8 + 1;
              }
              v7 = v51 + 1;
            }
            if ( *(_DWORD *)(a1 + 16) == 5 )
            {
              sub_3A090((unsigned __int16 *)a1);
              v54 = 1;
            }
            if ( v54 )
            {
              LOBYTE(v23) = v52 - 15;
              LOBYTE(v24) = v52 + 15;
              HIBYTE(v23) = BYTE1(v52) - 15;
              HIBYTE(v24) = BYTE1(v52) + 15;
              sub_462A0(v23, v24);
            }
            v25 = 0;
            HIBYTE(v26) = BYTE1(v52) - 1;
            do
            {
              v46 = 0;
              LOBYTE(v26) = v52 - 1;
              while ( v46 < 2 )
              {
                v27 = (unsigned __int8)byte_11B4E0[v26]
                    - (signed int)(unsigned __int8)byte_11B4E0[v26] / *(_DWORD *)(a1 + 16);
                if ( v27 < 0 )
                  v27 = 0;
                if ( v27 > 255 )
                  LOBYTE(v27) = -1;
                byte_11B4E0[v26] = v27;
                v28 = *(_DWORD *)(a1 + 16);
                v29 = 31 / v28 + 32;
                if ( *(_BYTE *)(dword_D41A0 + 196308) )
                  v29 = -31 / v28 + 32;
                byte_12B4E0[v26] = v29;
                LOBYTE(v26) = v26 + 1;
                ++v46;
              }
              ++v25;
              ++HIBYTE(v26);
            }
            while ( v25 < 2 );
          }
          LOBYTE(v1) = a1;
          if ( *(_DWORD *)(a1 + 16) < 6 )
            LOBYTE(v1) = sub_39B60(a1);
          break;
        case 3u:
          HIBYTE(v30) = BYTE1(v53);
          v31 = 0;
          while ( v31 < 30 )
          {
            LOBYTE(v30) = v53;
            v32 = 0;
            while ( v32 < 30 )
            {
              v49 = v30;
              if ( sub_57450(byte_10B4E0[v30]) || byte_10B4E0[v49] == 8 )
              {
                byte_10B4E0[v30] = 1;
                byte_13B4E0[v30] = byte_13B4E0[v30] & 0xF8 | 1;
              }
              ++v32;
              LOBYTE(v30) = v30 + 1;
            }
            ++v31;
            ++HIBYTE(v30);
          }
          LOBYTE(v33) = v52 - 15;
          LOBYTE(v34) = v52 + 15;
          HIBYTE(v33) = BYTE1(v52) - 15;
          HIBYTE(v34) = BYTE1(v52) + 15;
          sub_46570(v33, v34);
          HIBYTE(v35) = BYTE1(v52) - 1;
          v36 = 0;
          while ( v36 < 2 )
          {
            v37 = 0;
            LOBYTE(v35) = v52 - 1;
            while ( v37 < 2 )
            {
              if ( *(_BYTE *)(dword_D41A0 + 196308) )
                v45 = 1;
              else
                v45 = 63;
              v38 = v35;
              ++v37;
              LOBYTE(v35) = v35 + 1;
              byte_12B4E0[v38] = v45;
            }
            ++v36;
            ++HIBYTE(v35);
          }
          sub_39B60(a1);
          LOBYTE(v1) = a1;
          *(_BYTE *)(a1 + 69) = 73;
          break;
      }
    }
  }
  return v1;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// E9B90: using guessed type int dword_E9B90;

//----- (000396A0) --------------------------------------------------------
int __cdecl sub_396A0(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  v2 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v2;
  if ( v2 > 0 )
    return sub_39B60(a1);
  *(_BYTE *)(a1 + 69) = 74;
  *(_BYTE *)(a1 + 70) = 0;
  return result;
}

//----- (000396D0) --------------------------------------------------------
unsigned __int8 __cdecl sub_396D0(int a1)
{
  int v1; // eax
  __int16 v2; // dx
  unsigned __int8 result; // al
  signed int v4; // edi
  __int16 v5; // dx
  unsigned __int16 v6; // bx
  unsigned __int16 v7; // dx
  __int16 v8; // ax
  int v9; // edx
  unsigned __int16 v10; // bx
  __int16 v11; // ax
  __int16 v12; // ax
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  unsigned __int16 v16; // ax
  int v17; // edx
  int v18; // eax
  int v19; // edx
  char v20; // ch
  unsigned __int16 v21; // bx
  signed int v22; // edi
  signed int v23; // esi
  char v24; // al
  unsigned __int16 v25; // dx
  unsigned int j; // ecx
  char v27; // dl
  int v28; // [esp+0h] [ebp-30h]
  __int16 v29; // [esp+4h] [ebp-2Ch]
  __int16 v30; // [esp+8h] [ebp-28h]
  __int16 v31; // [esp+Ah] [ebp-26h]
  int i; // [esp+10h] [ebp-20h]
  int k; // [esp+14h] [ebp-1Ch]
  int v34; // [esp+18h] [ebp-18h]
  int v35; // [esp+1Ch] [ebp-14h]
  int v36; // [esp+20h] [ebp-10h]
  int v37; // [esp+24h] [ebp-Ch]
  char v38; // [esp+28h] [ebp-8h]
  char v39; // [esp+2Ch] [ebp-4h]

  v1 = (*(signed __int16 *)(a1 + 78) + 128) >> 8;
  v2 = *(_WORD *)(a1 + 76) + 128;
  v38 = v1;
  BYTE1(v37) = v1 - 15;
  v39 = HIBYTE(v2);
  result = *(_BYTE *)(a1 + 70);
  LOBYTE(v37) = HIBYTE(v2) - 15;
  if ( result < 1u )
  {
    if ( result )
      return result;
    sub_39B60(a1);
    sub_3A090((unsigned __int16 *)a1);
    *(_BYTE *)(a1 + 70) = 1;
    v4 = 0;
    v5 = *(_WORD *)(a1 + 80);
    *(_DWORD *)(a1 + 16) = 16;
    *(_WORD *)(a1 + 80) = v5 + 64;
    HIBYTE(v6) = BYTE1(v37);
    while ( v4 < 30 )
    {
      LOBYTE(v6) = v37;
      for ( i = 0; i < 30; ++i )
      {
        if ( sub_57450(byte_10B4E0[v6]) )
        {
          byte_10B4E0[v6] = 1;
          byte_13B4E0[v6] = byte_13B4E0[v6] & 0xF8 | 1;
        }
        LOBYTE(v6) = v6 + 1;
      }
      ++v4;
      ++HIBYTE(v6);
    }
    LOBYTE(v7) = v39 - 15;
    LOBYTE(v8) = v39 + 15;
    HIBYTE(v7) = v38 - 15;
    HIBYTE(v8) = v38 + 15;
    sub_462A0(v7, v8);
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 64);
  }
  else if ( result > 1u )
  {
    if ( result == 2 )
    {
      HIBYTE(v21) = BYTE1(v37);
      v22 = 0;
      while ( v22 < 30 )
      {
        LOBYTE(v21) = v37;
        v23 = 0;
        while ( v23 < 30 )
        {
          v24 = sub_439A0(v23++, v21);
          v25 = v21;
          LOBYTE(v21) = v21 + 1;
          byte_11B4E0[v25] = v24;
        }
        ++v22;
        ++HIBYTE(v21);
      }
      for ( j = *(_DWORD *)(dword_D41A4 + 38519); j > dword_EA3E4[0]; j = *(_DWORD *)j )
      {
        if ( *(_BYTE *)(j + 64) == 2
          && *(_BYTE *)(j + 14) & 0x10
          && *(unsigned __int16 *)(j + 38) == (a1 - (dword_D41A0 + 28302)) / 168 )
        {
          v27 = *(_BYTE *)(j + 14);
          *(_WORD *)(j + 38) = 0;
          *(_BYTE *)(j + 14) = v27 & 0xEF;
        }
      }
      result = sub_57F10(a1);
    }
    return result;
  }
  result = a1;
  if ( !(*(_BYTE *)(a1 + 8) & 3) )
  {
    v9 = *(_DWORD *)(a1 + 16) - 1;
    *(_DWORD *)(a1 + 16) = v9;
    if ( v9 <= 0 )
    {
      *(_BYTE *)(a1 + 70) = 2;
    }
    else
    {
      HIBYTE(v10) = BYTE1(v37);
      v35 = 0;
      do
      {
        LOBYTE(v10) = v37;
        for ( k = 0; k < 30; ++k )
        {
          v30 = (unsigned __int8)v10 << 8;
          v31 = HIBYTE(v10) << 8;
          v36 = sub_58490((_WORD *)(a1 + 76), &v30);
          if ( v36 < 3840 )
          {
            v11 = sub_581E0((_WORD *)(a1 + 76), &v30);
            v28 = *(_DWORD *)(a1 + 76);
            v29 = *(_WORD *)(a1 + 80);
            sub_57FA0(&v28, v11, 0, 3840);
            v12 = sub_10C40((__int16 *)&v28);
            v13 = (v12 >> 5)
                - (((_DWORD)((_DWORD)sub_10000 + (signed int)off_DBF50[(v36 << 10) / 3840]) >> 1)
                 * ((v12 >> 5) - *(signed __int16 *)(a1 + 80)) >> 16);
            *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
            v14 = (*(_WORD *)(a1 + 20) & 3) + v13 - 2;
            v34 = (unsigned __int8)byte_11B4E0[v10];
            v34 += (v14 - v34) / *(_DWORD *)(a1 + 16);
            if ( v34 < 1 )
              v34 = 1;
            if ( v34 > 255 )
              v34 = 255;
            byte_11B4E0[v10] = v34;
            if ( *(_DWORD *)(a1 + 16) < 3 )
              byte_11B4E0[v10] = sub_439A0(v10, v10);
            if ( byte_D41B6 )
            {
              v15 = (unsigned __int8)byte_11B4E0[v10] + 64;
              if ( v15 > 254 )
                v15 = 254;
              byte_14B4E0[v10] -= ((unsigned __int8)byte_14B4E0[v10] - v15) / *(_DWORD *)(a1 + 16);
            }
          }
          LOBYTE(v10) = v10 + 1;
          ++HIBYTE(v10);
          v16 = v10;
          LOBYTE(v10) = v10 - 2;
          HIBYTE(v10) -= 2;
          v17 = (unsigned __int8)byte_11B4E0[v10];
          LOBYTE(v10) = v10 + 1;
          v18 = v17 - (unsigned __int8)byte_11B4E0[v16] + 32;
          ++HIBYTE(v10);
          if ( v18 >= 28 )
          {
            if ( v18 > 40 )
              v18 = (v18 & 7) + 40;
          }
          else
          {
            v18 = (v18 & 3) + 28;
          }
          if ( *(_BYTE *)(dword_D41A0 + 196308) )
            v19 = 32 - v18 + 32;
          else
            LOBYTE(v19) = v18;
          v20 = byte_D41B6;
          byte_12B4E0[v10] = v19;
          if ( v20 )
          {
            if ( (unsigned __int8)byte_14B4E0[v10] > (unsigned __int8)byte_11B4E0[v10] )
              byte_13B4E0[v10] &= 0xF7u;
            else
              byte_13B4E0[v10] |= 8u;
          }
          result = k + 1;
          LOBYTE(v10) = v10 + 1;
        }
        ++HIBYTE(v10);
        ++v35;
      }
      while ( v35 < 30 );
    }
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00039B60) --------------------------------------------------------
int __cdecl sub_39B60(int a1)
{
  char v1; // al
  int i; // eax
  signed int v3; // eax
  int v4; // edx
  int v5; // esi
  int v6; // esi
  __int16 v7; // ax
  int v8; // ecx
  int v9; // eax
  int v10; // ebx
  int result; // eax
  __int16 v12; // [esp+0h] [ebp-1Ch]
  __int16 v13; // [esp+2h] [ebp-1Ah]
  int v14; // [esp+8h] [ebp-14h]
  int v15; // [esp+Ch] [ebp-10h]
  unsigned __int16 v16; // [esp+10h] [ebp-Ch]
  int v17; // [esp+14h] [ebp-8h]
  int v18; // [esp+18h] [ebp-4h]

  v1 = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - 13;
  LOBYTE(v15) = ((unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8) - 13;
  BYTE1(v15) = v1;
  v17 = 0;
  v16 = v15;
  do
  {
    v18 = 0;
    LOBYTE(v16) = v15;
    while ( (signed __int16)v18 < 26 )
    {
      v12 = (unsigned __int8)v16 << 8;
      v13 = HIBYTE(v16) << 8;
      if ( (unsigned int)sub_584D0((_WORD *)(a1 + 76), &v12) < 0xA90000 )
      {
        for ( i = word_15B4E0[v16]; ; i = *(unsigned __int16 *)(v10 + 22) )
        {
          v10 = dword_EA3E4[i];
          if ( v10 == dword_EA3E4[0] )
            goto LABEL_35;
          if ( sub_39FA0(a1, dword_EA3E4[i]) )
          {
            v3 = sub_58490((_WORD *)(v10 + 76), (_WORD *)(a1 + 76));
            v4 = *(signed __int16 *)(a1 + 44);
            v5 = *(signed __int16 *)(v10 + 80) - v4;
            v14 = *(signed __int16 *)(v10 + 80) - v4;
            if ( v3 < 3328 && v5 < 4096 )
              break;
          }
LABEL_25:
          if ( *(_BYTE *)(a1 + 69) == 74 && *(_BYTE *)(v10 + 14) & 0x10 )
          {
            if ( *(_BYTE *)(v10 + 63) != 3
              || *(_BYTE *)(v10 + 64)
              || *(_WORD *)(*(_DWORD *)(v10 + 164) + 56) != *(_WORD *)(dword_D41A0 + 12) )
            {
              *(_BYTE *)(v10 + 12) &= 0xFEu;
            }
            else
            {
              *(_BYTE *)(v10 + 12) |= 1u;
            }
            *(_BYTE *)(v10 + 14) &= 0xEFu;
          }
        }
        if ( v3 <= 32 || v5 <= 96 )
        {
          sub_3A200(a1, v10);
          goto LABEL_25;
        }
        *(_DWORD *)&word_EB398 = *(_DWORD *)(v10 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(v10 + 80);
        v6 = ((3328 - v3) << 8) / 3328 << 7 >> 8;
        if ( v6 < 4 )
          v6 = 4;
        if ( v6 > 128 )
          v6 = 128;
        if ( v6 > v3 )
          LOWORD(v6) = v3;
        v7 = sub_581E0(&word_EB398, (_WORD *)(a1 + 76));
        sub_57FA0(&word_EB398, v7, 0, v6);
        v8 = (signed __int16)sub_10C40(&word_EB398);
        if ( *(_BYTE *)(v10 + 63) == 3 && !*(_BYTE *)(v10 + 64) )
        {
          v9 = (signed __int16)(word_EB39C
                              - (48
                               * ((((4096 - v14) << 8)
                                 - (__CFSHL__((4096 - v14) << 8 >> 31, 12)
                                  + ((4096 - v14) << 8 >> 31 << 12))) >> 12) >> 8));
          word_EB39C -= 48
                      * ((((4096 - v14) << 8)
                        - (__CFSHL__((4096 - v14) << 8 >> 31, 12)
                         + ((4096 - v14) << 8 >> 31 << 12))) >> 12) >> 8;
          goto LABEL_21;
        }
        if ( *(signed __int16 *)(*(_DWORD *)(v10 + 160) + 14) < -64 )
          goto LABEL_40;
        word_EB39C -= 48
                    * ((((4096 - v14) << 8) - (__CFSHL__((4096 - v14) << 8 >> 31, 12) + ((4096 - v14) << 8 >> 31 << 12))) >> 12) >> 8;
        v9 = word_EB39C;
LABEL_21:
        if ( v9 < v8 )
LABEL_40:
          word_EB39C = v8;
        sub_57CF0(v10, (int)&word_EB398);
        goto LABEL_25;
      }
LABEL_35:
      ++v18;
      LOBYTE(v16) = v16 + 1;
    }
    result = v17++ + 1;
    ++HIBYTE(v16);
  }
  while ( (signed __int16)v17 < 26 );
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00039E40) --------------------------------------------------------
char __cdecl sub_39E40(int a1)
{
  char v1; // ch
  signed int v2; // edx
  signed int v3; // esi
  unsigned __int16 v4; // ax
  signed int v5; // edi
  char v6; // bl
  signed int v7; // esi
  unsigned __int16 v8; // ax
  int v9; // edx
  int i; // edx
  unsigned __int8 v11; // ch
  char v12; // ch
  int v13; // edx
  int v15; // [esp+4h] [ebp-8h]

  v1 = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
  v2 = 0;
  v3 = 0;
  HIBYTE(v4) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - 15;
  while ( v3 < 30 )
  {
    v5 = 0;
    LOBYTE(v4) = v1 - 15;
    while ( v5 < 30 )
    {
      if ( !byte_10B4E0[v4] )
        ++v2;
      ++v5;
      LOBYTE(v4) = v4 + 1;
    }
    ++v3;
    ++HIBYTE(v4);
  }
  if ( v2 >= 225 )
    return 0;
  v6 = v1 - 27;
  v7 = 0;
  HIBYTE(v8) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - 27;
  do
  {
    v9 = 0;
    for ( LOBYTE(v8) = v6; ; LOBYTE(v8) = v8 + 1 )
    {
      v15 = v9;
      if ( v9 >= 54 )
        break;
      for ( i = word_15B4E0[v8]; ; i = *(unsigned __int16 *)(v13 + 22) )
      {
        v13 = dword_EA3E4[i];
        if ( v13 == dword_EA3E4[0] )
          break;
        if ( v13 != a1 && *(_BYTE *)(v13 + 63) == 10 )
        {
          v11 = *(_BYTE *)(v13 + 64);
          if ( v11 >= 0x2Du )
          {
            if ( v11 <= 0x2Du )
            {
              v12 = *(_BYTE *)(v13 + 69);
              if ( v12 == 48 || v12 == 51 )
                return 0;
            }
            else if ( v11 == 67 )
            {
              return 0;
            }
          }
        }
      }
      v9 = v15 + 1;
    }
    ++v7;
    ++HIBYTE(v8);
  }
  while ( v7 < 54 );
  return 1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00039FA0) --------------------------------------------------------
char __cdecl sub_39FA0(int a1, int a2)
{
  char result; // al
  unsigned __int8 v3; // ah
  char v4; // bl
  unsigned __int8 v5; // ah
  unsigned __int8 v6; // dl
  unsigned __int8 v7; // ah
  unsigned __int8 v8; // dl
  _BOOL1 v9; // zf

  result = 1;
  v3 = *(_BYTE *)(a2 + 63) - 1;
  if ( v3 <= 0xEu )
  {
    switch ( v3 )
    {
      case 0u:
      case 3u:
      case 5u:
      case 6u:
      case 7u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xEu:
        return 0;
      case 1u:
        return result;
      case 2u:
        v7 = *(_BYTE *)(a2 + 64);
        if ( v7 < 1u )
        {
          if ( v7 )
            return result;
        }
        else
        {
          if ( v7 > 1u )
          {
            if ( v7 != 2 )
              return result;
            return 0;
          }
          if ( *(_BYTE *)(a2 + 12) & 0x21 )
            return 0;
        }
        if ( *(_WORD *)(a1 + 26) == *(_WORD *)(a2 + 26) )
          result = 0;
        break;
      case 4u:
        if ( *(_BYTE *)(a2 + 12) & 0x21 )
          return 0;
        v4 = *(_BYTE *)(a2 + 69);
        if ( v4 == -24 )
          return 0;
        v5 = *(_BYTE *)(a2 + 64);
        if ( v5 < 0x16u )
          return result;
        if ( v5 <= 0x16u )
          return 0;
        if ( v5 != 27 )
          return result;
        if ( v4 == -23 )
          return 0;
        if ( v4 == -22 )
          result = 0;
        return result;
      case 8u:
        v6 = *(_BYTE *)(a2 + 64);
        if ( !v6 )
          return result;
        if ( v6 < 0xDu )
          return 0;
        if ( v6 > 0xEu )
          result = 0;
        return result;
      case 9u:
        v8 = *(_BYTE *)(a2 + 64);
        if ( v8 < 0x27u )
        {
          v9 = v8 == 6;
        }
        else
        {
          if ( v8 <= 0x28u )
            return result;
          v9 = v8 == 57;
        }
        if ( !v9 )
          result = 0;
        return result;
      case 0xDu:
        if ( *(_BYTE *)(a2 + 12) & 0x21 || *(_BYTE *)(a2 + 64) == 1 )
          return 0;
        return result;
    }
  }
  return result;
}

//----- (0003A090) --------------------------------------------------------
void __cdecl sub_3A090(unsigned __int16 *a1)
{
  unsigned int i; // ebx
  unsigned int j; // ebx
  int v3; // edi
  int v4; // eax
  int v5; // eax
  unsigned __int16 v6; // bx
  char v7; // al
  int v8; // [esp+0h] [ebp-10h]
  signed int k; // [esp+4h] [ebp-Ch]
  int v10; // [esp+8h] [ebp-8h]
  char v11; // [esp+Ch] [ebp-4h]

  v8 = 0;
  for ( i = *(_DWORD *)(dword_D41A4 + 38527); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( sub_10750((int)a1, i) )
    {
      *(_DWORD *)(i + 8) = -1;
      *(_BYTE *)(i + 61) = 0;
    }
  }
  for ( j = *(_DWORD *)(dword_D41A4 + 38519); j > dword_EA3E4[0]; j = *(_DWORD *)j )
  {
    if ( *(_BYTE *)(j + 64) == 2 && sub_10750((int)a1, j) )
    {
      v3 = dword_E9B90 + 1;
      v4 = dword_D41A0 + 28302;
      *(_BYTE *)(j + 14) |= 0x10u;
      dword_E9B90 = v3;
      *(_WORD *)(j + 48) = 30;
      *(_WORD *)(j + 38) = ((signed int)a1 - v4) / 168;
      *(_DWORD *)(j + 94) += a1[21];
      v8 += 2;
      *(_WORD *)(j + 98) = a1[13];
    }
  }
  v11 = ((unsigned __int16)(a1[38] + 128) >> 8) - 15;
  v5 = 0;
  for ( HIBYTE(v6) = ((unsigned __int16)(a1[39] + 128) >> 8) - 15; ; ++HIBYTE(v6) )
  {
    v10 = v5;
    if ( v5 >= 30 )
      break;
    LOBYTE(v6) = v11;
    for ( k = 0; k < 30; ++k )
    {
      if ( (unsigned int)sub_10590(byte_10B4E0[v6]) & 0x7F0000 )
      {
        v7 = byte_13B4E0[v6] & 0xF8 | 1;
        byte_10B4E0[v6] = 1;
        byte_13B4E0[v6] = v7;
      }
      LOBYTE(v6) = v6 + 1;
    }
    v5 = v10 + 1;
  }
  if ( v8 )
    sub_6D8B0(a1[13], 0x14u, v8);
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E9B90: using guessed type int dword_E9B90;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0003A200) --------------------------------------------------------
void __cdecl sub_3A200(int a1, int a2)
{
  _BOOL1 v2; // ah
  unsigned __int8 v3; // al
  unsigned __int8 v4; // al
  int v5; // edx
  unsigned __int16 v6; // ax
  char v7; // [esp+0h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  v3 = *(_BYTE *)(a2 + 63);
  *(_DWORD *)(a2 + 12) |= (unsigned int)&unk_100001;
  if ( v3 < 3u )
    goto LABEL_13;
  if ( v3 > 3u )
  {
    if ( v3 != 5 )
      goto LABEL_13;
    v4 = *(_BYTE *)(a2 + 64);
    if ( v4 < 0x12u )
    {
      if ( v4 != 12 )
        goto LABEL_13;
    }
    else if ( v4 > 0x12u )
    {
      if ( v4 == 27 )
        v7 = 1;
      goto LABEL_13;
    }
    v2 = 1;
    goto LABEL_13;
  }
  if ( !*(_BYTE *)(a2 + 64) )
  {
    v5 = *(_DWORD *)(a2 + 164);
    *(_WORD *)(a2 + 30) = 512;
    *(_WORD *)(v5 + 343) = 512;
  }
LABEL_13:
  if ( !v2 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v2 = *(unsigned __int16 *)(a1 + 20) % 7u == 0;
  }
  if ( v2 && !v7 )
  {
    if ( *(_BYTE *)(a2 + 56) & 1 )
    {
      *(_DWORD *)(a2 + 94) += *(_DWORD *)(a2 + 8) + 1;
      v6 = *(_WORD *)(a1 + 26);
      *(_WORD *)(a2 + 98) = v6;
      sub_6D8B0(v6, 0x14u, 1);
    }
  }
}

//----- (0003A2D0) --------------------------------------------------------
void __cdecl sub_3A2D0(int a1)
{
  unsigned __int8 v1; // al
  int v2; // ecx
  int v3; // edx
  int v4; // esi
  int v5; // edi
  int v6; // esi
  int v7; // edx
  char v8; // dl
  unsigned __int16 v9; // dx
  signed int v10; // ecx
  int v11; // eax
  int v12; // edi
  unsigned __int16 v13; // dx
  int v14; // eax
  __int16 v15; // ax
  char v16; // [esp+0h] [ebp-1Ch]
  char v17; // [esp+4h] [ebp-18h]
  int v18; // [esp+8h] [ebp-14h]
  int v19; // [esp+Ch] [ebp-10h]
  int v20; // [esp+10h] [ebp-Ch]
  char v21; // [esp+14h] [ebp-8h]
  char v22; // [esp+18h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    v1 = *(_BYTE *)(a1 + 70);
    if ( v1 )
    {
      if ( v1 > 3u )
      {
LABEL_51:
        --*(_DWORD *)(a1 + 8);
        return;
      }
    }
    else
    {
      v2 = *(_DWORD *)(a1 + 4);
      v3 = *(unsigned __int16 *)(a1 + 42);
      *(_WORD *)(a1 + 44) = *(_DWORD *)(a1 + 4) >> 3;
      *(_DWORD *)(a1 + 16) = 0;
      *(_BYTE *)(a1 + 70) = 1;
      *(_WORD *)(a1 + 42) = 4 * (unsigned int)(v3 / v2);
    }
    v4 = *(signed __int16 *)(a1 + 44);
    v5 = *(_DWORD *)(a1 + 8);
    if ( *(_DWORD *)(a1 + 4) - 3 * v4 >= v5 )
    {
      if ( *(_DWORD *)(a1 + 4) - 5 * v4 > v5 )
      {
        v6 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v6;
      }
      else
      {
        v6 = 3 * v4;
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        if ( !(*(unsigned __int16 *)(a1 + 20) % 5u) )
          *(_BYTE *)(a1 + 70) += 2;
      }
    }
    else
    {
      v6 = *(_DWORD *)(a1 + 16) + 1;
      *(_DWORD *)(a1 + 16) = v6;
    }
    if ( v6 < 0 )
      v6 = 0;
    v7 = *(signed __int16 *)(a1 + 44);
    if ( v6 > 3 * v7 )
      v6 = 3 * v7;
    if ( v6 < 0 )
      v6 = 0;
    if ( v6 > 15 )
      v6 = 15;
    v8 = *(_BYTE *)(a1 + 70);
    v20 = 0;
    if ( v8 > 1 )
    {
      v20 = 1;
      *(_BYTE *)(a1 + 70) = v8 - 1;
    }
    if ( v6 > 0 )
    {
      v21 = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
      v22 = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
      v18 = sub_10080(0, v6);
      if ( v18 )
      {
        while ( sub_10130(v18, &v17, &v16) == 1 )
        {
          LOBYTE(v9) = v17 + v21;
          HIBYTE(v9) = v16 + v22;
          if ( *(_BYTE *)(a1 + 8) & 1 )
            v10 = 1;
          else
            v10 = -1;
          v11 = v10 + (unsigned __int8)byte_11B4E0[v9];
          if ( v11 < 0 )
            v11 = 0;
          if ( v11 > 255 )
            LOBYTE(v11) = -1;
          byte_11B4E0[v9] = v11;
        }
        sub_10100(v18);
      }
      if ( v20 )
      {
        v12 = sub_10080(0, v6 >> 1);
        if ( v12 )
        {
          while ( sub_10130(v12, &v17, &v16) == 1 )
          {
            LOBYTE(v13) = v17 + v21;
            HIBYTE(v13) = v16 + v22;
            if ( *(_BYTE *)(a1 + 8) & 1 )
              v19 = 1;
            else
              v19 = -1;
            v14 = v19 + (unsigned __int8)byte_11B4E0[v13];
            if ( v14 < 0 )
              v14 = 0;
            if ( v14 > 255 )
              LOBYTE(v14) = -1;
            byte_11B4E0[v13] = v14;
          }
          sub_10100(v12);
        }
      }
      if ( !(*(_BYTE *)(a1 + 8) & 3) )
      {
        sub_49EA0((_WORD *)a1, (_WORD)v6 << 8, 2048);
        sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
        v15 = sub_10C80(a1, 0, *(_WORD *)(a1 + 42));
        if ( v15 )
          sub_6D8B0(*(_WORD *)(a1 + 26), 0xFu, v15);
      }
    }
    goto LABEL_51;
  }
  sub_57F10(a1);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0003A5B0) --------------------------------------------------------
void __cdecl sub_3A5B0(int a1)
{
  int v1; // edx
  int v2; // eax
  char v3; // dl
  __int16 v4; // dx

  v1 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v1;
  if ( v1 < 0 )
  {
    sub_57F10(a1);
  }
  else if ( !v1 )
  {
    v2 = sub_4A190(a1 + 76, 5, *(char *)(a1 + 70));
    if ( v2 )
    {
      v3 = 8 * *(_BYTE *)(v2 + 64);
      *(_BYTE *)(v2 + 73) = 13;
      *(_BYTE *)(v2 + 69) = v3 + 7;
      *(_WORD *)(v2 + 40) = *(_WORD *)(a1 + 40);
      v4 = *(_WORD *)(a1 + 26);
      *(_WORD *)(v2 + 150) = 0;
      *(_DWORD *)(v2 + 144) = 0;
      *(_DWORD *)(v2 + 140) = 0;
      *(_WORD *)(v2 + 46) = 250;
      *(_WORD *)(v2 + 26) = v4;
    }
  }
}

//----- (0003A630) --------------------------------------------------------
int __cdecl sub_3A630(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  v2 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v2;
  if ( v2 <= 0 )
    result = sub_57F10(a1);
  return result;
}

//----- (0003A650) --------------------------------------------------------
int __cdecl sub_3A650(int a1)
{
  unsigned int v1; // edi
  char v2; // al
  int k; // eax
  __int16 v4; // ax
  __int16 v5; // ax
  unsigned int v6; // ebx
  signed __int16 v8; // [esp+0h] [ebp-14h]
  char v9; // [esp+4h] [ebp-10h]
  char v10; // [esp+8h] [ebp-Ch]
  unsigned __int8 j; // [esp+Ch] [ebp-8h]
  unsigned __int8 i; // [esp+10h] [ebp-4h]

  if ( *(_WORD *)(a1 + 150) )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v1 > dword_EA3E4[0] )
    {
      v2 = *(_BYTE *)(a1 + 70);
      v10 = ((unsigned __int16)(*(_WORD *)(v1 + 76) + 128) >> 8) - v2;
      v8 = 2 * *(char *)(a1 + 70);
      v9 = ((unsigned __int16)(*(_WORD *)(v1 + 78) + 128) >> 8) - v2;
      for ( i = 0; i < v8; ++i )
      {
        for ( j = 0; j < v8; ++j )
        {
          for ( k = word_15B4E0[(unsigned __int8)(j + v10) + ((unsigned __int8)(v9 + i) << 8)];
                ;
                k = *(unsigned __int16 *)(v6 + 22) )
          {
            v6 = dword_EA3E4[k];
            if ( v6 <= dword_EA3E4[0] )
              break;
            if ( *(_BYTE *)(v6 + 63) == *(_BYTE *)(v1 + 63)
              && *(_BYTE *)(v6 + 64) == *(_BYTE *)(v1 + 64)
              && sub_3A7F0((_BYTE *)v6) )
            {
              sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 6);
              *(_BYTE *)(v6 + 73) = 14;
              v4 = *(unsigned __int8 *)(v6 + 72);
              *(_BYTE *)(v6 + 72) = 0;
              *(_WORD *)(v6 + 74) = v4;
              *(_WORD *)(v6 + 40) = *(_WORD *)(a1 + 26);
              v5 = *(_WORD *)(a1 + 42);
              *(_WORD *)(v6 + 46) = v5;
              *(_WORD *)(v6 + 48) = v5;
              if ( (*(_BYTE *)(v6 + 69) & 7) == 2 )
                *(_WORD *)(v6 + 150) = 0;
              else
                *(_BYTE *)(v6 + 69) = 8 * *(_BYTE *)(v6 + 64) + 7;
            }
          }
        }
      }
    }
  }
  return sub_57F10(a1);
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0003A7F0) --------------------------------------------------------
char __cdecl sub_3A7F0(_BYTE *a1)
{
  char result; // al
  unsigned __int8 v2; // ah
  char v3; // bh

  result = 1;
  if ( a1[63] != 5 )
    return 0;
  v2 = a1[64];
  if ( v2 < 0x16u )
  {
    if ( v2 >= 0xCu && v2 <= 0xFu )
      goto LABEL_12;
  }
  else
  {
    if ( v2 <= 0x17u )
      goto LABEL_12;
    if ( v2 >= 0x19u )
    {
      if ( v2 > 0x19u )
      {
        if ( v2 > 0x1Bu )
          goto LABEL_13;
        goto LABEL_12;
      }
      if ( a1[70] )
      {
LABEL_12:
        result = 0;
        goto LABEL_13;
      }
    }
  }
LABEL_13:
  if ( result )
  {
    v3 = a1[73];
    if ( v3 == 14 || v3 == 13 || v3 == 16 || v3 == 17 )
      result = 0;
  }
  if ( result && a1[69] == -24 )
    return 0;
  return result;
}

//----- (0003A8B0) --------------------------------------------------------
char __cdecl sub_3A8B0(int a1)
{
  __int16 v1; // cx
  int v2; // eax
  char v3; // dh
  char v4; // cl
  int v5; // esi
  char v6; // ah
  int v7; // eax
  __int16 v8; // di
  unsigned int v9; // eax
  signed __int16 v10; // dx
  int v11; // esi
  int v12; // eax
  int v13; // edx
  unsigned int v14; // edx
  int v15; // esi
  unsigned int i; // esi
  unsigned __int16 v17; // di
  int v18; // edi
  _WORD *v19; // eax
  _WORD *v20; // esi
  __int16 v21; // ax
  char v22; // ah
  __int16 v23; // ax
  char v24; // al
  char v25; // dl
  int v26; // esi
  char v27; // cl
  void (__noreturn *v29)(); // [esp+0h] [ebp-24h]
  __int16 *v30; // [esp+4h] [ebp-20h]
  unsigned int v31; // [esp+8h] [ebp-1Ch]
  _WORD *v32; // [esp+Ch] [ebp-18h]
  int v33; // [esp+10h] [ebp-14h]
  _BOOL1 v34; // [esp+14h] [ebp-10h]
  unsigned __int8 v35; // [esp+18h] [ebp-Ch]
  unsigned __int8 v36; // [esp+1Ch] [ebp-8h]
  char v37; // [esp+20h] [ebp-4h]

  v2 = dword_EA3E4[*(unsigned __int16 *)(a1 + 50)];
  v31 = 0;
  v29 = sub_10000;
  v33 = dword_EA3E4[*(unsigned __int16 *)(a1 + 50)];
  if ( *(_DWORD *)(v2 + 8) < 0 || *(_BYTE *)(v2 + 13) & 4 )
  {
LABEL_99:
    LOBYTE(v12) = sub_57F10(a1);
  }
  else
  {
    v3 = *(_BYTE *)(a1 + 68);
    if ( v3 )
    {
      switch ( abs(v3) )
      {
        case 1:
          v1 = 0;
          break;
        case 2:
          v1 = 153;
          break;
        case 3:
          v1 = 307;
          break;
        case 4:
          v1 = 445;
          break;
        case 5:
          v1 = 491;
          break;
        case 6:
          v1 = 512;
          break;
        default:
          break;
      }
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 154);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 158);
      word_EB39C = *(_WORD *)(a1 + 80);
      sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, v1);
      sub_57CF0(a1, (int)&word_EB398);
      v4 = *(_BYTE *)(a1 + 68) + 1;
      *(_BYTE *)(a1 + 68) = v4;
      if ( v4 > 0 && v4 > 6 )
        *(_BYTE *)(a1 + 68) = -5;
    }
    v5 = (signed __int16)sub_10C40((__int16 *)(a1 + 76));
    v6 = *(_BYTE *)(a1 + 70);
    if ( v6 != 9 && v6 != 7 )
    {
      v7 = *(_DWORD *)(a1 + 8) - 1;
      *(_DWORD *)(a1 + 8) = v7;
      if ( v7 <= 0 )
        *(_BYTE *)(a1 + 70) = 6;
      if ( *(_WORD *)(dword_D41A0 + 12) == *(_WORD *)(*(_DWORD *)(v33 + 164) + 56) )
      {
        v8 = *(_WORD *)(a1 + 54);
        *(_BYTE *)(a1 + 12) &= 0xFEu;
        if ( v8 != -1 )
          *(_BYTE *)(a1 + 14) |= 0x80u;
      }
      else if ( !(*(_BYTE *)(a1 + 62) & 7) )
      {
        v9 = dword_EA3E4[*(signed __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 13071)];
        if ( v9 > dword_EA3E4[0] && *(_WORD *)(v9 + 46) && *(_BYTE *)(v9 + 70) >= 2 )
          *(_BYTE *)(a1 + 12) &= 0xFEu;
        else
          *(_BYTE *)(a1 + 12) |= 1u;
      }
      if ( *(signed __int16 *)(a1 + 80) < v5 )
        *(_WORD *)(a1 + 80) = v5;
      if ( !*(_BYTE *)(a1 + 68) && abs(*(signed __int16 *)(a1 + 80) - (v5 + 1024)) > 96 )
      {
        if ( *(signed __int16 *)(a1 + 80) - (v5 + 1024) <= 0 )
          v10 = 48;
        else
          v10 = -48;
        *(_WORD *)(a1 + 80) += v10;
      }
      if ( byte_D41B6 )
      {
        v11 = *(signed __int16 *)(a1 + 88);
        v5 = (signed __int16)sub_10C60((__int16 *)(a1 + 76)) - v11;
        if ( *(signed __int16 *)(a1 + 80) > v5 )
          *(_WORD *)(a1 + 80) = v5;
      }
    }
    LOBYTE(v12) = *(_BYTE *)(a1 + 70);
    switch ( (_BYTE)v12 )
    {
      case 0:
        v12 = (int)&unk_DAF4A + 26 * *(unsigned __int16 *)(a1 + 42);
        v13 = *(_DWORD *)v12;
        *(_DWORD *)(a1 + 4) = *(_DWORD *)v12;
        *(_DWORD *)(a1 + 8) = v13;
        *(_DWORD *)(a1 + 154) = *(_DWORD *)(a1 + 76);
        *(_WORD *)(a1 + 158) = *(_WORD *)(a1 + 80);
        LOBYTE(v12) = *(_BYTE *)(v12 + 24);
        switch ( (_BYTE)v12 )
        {
          case 0:
            *(_BYTE *)(a1 + 67) = 1;
            break;
          case 1:
            *(_BYTE *)(a1 + 67) = 2;
            break;
          case 2:
            *(_BYTE *)(a1 + 67) = 4;
            break;
          case 3:
            *(_BYTE *)(a1 + 67) = 8;
            break;
          default:
            break;
        }
        *(_BYTE *)(a1 + 70) = 1;
        goto LABEL_45;
      case 1:
LABEL_45:
        if ( *(_WORD *)(a1 + 54) != -1 )
          goto LABEL_46;
        return v12;
      case 2:
        *(_BYTE *)(a1 + 12) &= 0xF7u;
        *(_WORD *)(a1 + 26) = *(_WORD *)(a1 + 50);
        if ( byte_DA818[80 * *(unsigned __int16 *)(a1 + 54) + 27 + 26 * *(unsigned __int16 *)(a1 + 52)] & 1 )
          *(_BYTE *)(a1 + 61) = 6;
        else
          *(_BYTE *)(a1 + 61) = 1;
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        LOWORD(v12) = *(_WORD *)(a1 + 20) / 0x32u;
        v14 = *(unsigned __int16 *)(a1 + 20) % 0x32u;
        *(_BYTE *)(a1 + 70) = 3;
        *(_DWORD *)(a1 + 16) = v14 + 16;
        return v12;
      case 3:
        v15 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v15;
        if ( !v15 )
          *(_BYTE *)(a1 + 70) = 4;
        return v12;
      case 4:
        if ( !(*(_BYTE *)(a1 + 62) & 0xF) )
        {
          for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
          {
            LOBYTE(v12) = *(_BYTE *)(i + 64);
            if ( (unsigned __int8)v12 <= 1u && i != v33 )
            {
              v12 = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
              if ( v12 < 3584 && v12 < (signed int)v29 )
              {
                v31 = i;
                v29 = (void (__noreturn *)())v12;
              }
            }
          }
          if ( v31 )
          {
            v12 = (signed int)(v31 - (dword_D41A0 + 28302)) / 168;
            *(_BYTE *)(a1 + 70) = 5;
            *(_WORD *)(a1 + 150) = v12;
          }
        }
        return v12;
      case 5:
        *(_DWORD *)(a1 + 12) &= 0xFF7FFFFE;
        LOBYTE(v12) = 0;
        v17 = *(_WORD *)(a1 + 150);
        v37 = 0;
        if ( !v17
          || (LOBYTE(v12) = *(_WORD *)(a1 + 150), v18 = dword_EA3E4[v17], *(_DWORD *)(v18 + 8) < 0)
          || *(_BYTE *)(v18 + 13) & 4 )
        {
          v37 = 1;
        }
        else
        {
          sub_6D8B0(*(_WORD *)(v33 + 26), 0x17u, 1);
          v30 = (__int16 *)&byte_DA818[80 * *(unsigned __int16 *)(a1 + 54) + 2 + 26 * *(unsigned __int16 *)(a1 + 52)];
          v34 = *(_WORD *)(a1 + 54) == 7
             && byte_DA818[80 * *(unsigned __int16 *)(a1 + 54) + 26 + 26 * *(unsigned __int16 *)(a1 + 52)] == 2;
          v35 = (v34 != 0) + 1;
          v36 = 0;
          for ( LOBYTE(v12) = 0; v36 < v35; LOBYTE(v12) = v36 )
          {
            v19 = (_WORD *)sub_6DCA0(v33, a1 + 76, *(_WORD *)(a1 + 54), v30, 0, 1);
            v20 = v19;
            v32 = v19;
            if ( v19 )
            {
              v19[13] = *(_WORD *)(a1 + 50);
              v19[75] = *(_WORD *)(a1 + 150);
              sub_655C0(v19, v18);
              v20[14] = v20[16];
              v20[15] = v20[17];
              v21 = v20[14];
              v20[40] += *(_WORD *)(a1 + 82);
              HIBYTE(v21) = (HIBYTE(v21) + 4) & 7;
              *(_WORD *)(a1 + 28) = v21;
              v22 = *(_BYTE *)(a1 + 68);
              if ( v22 )
              {
                *(_BYTE *)(a1 + 68) = v22 + 1;
                if ( (char)(v22 + 1) > 5 )
                  *(_BYTE *)(a1 + 68) = 5;
              }
              else
              {
                *(_BYTE *)(a1 + 68) = 1;
              }
              if ( v34 )
              {
                if ( v36 )
                  v23 = v32[14] - 113;
                else
                  v23 = v32[14] + 113;
                v32[14] = v23 & 0x7FF;
              }
              v24 = *(_BYTE *)(a1 + 61) - 1;
              *(_BYTE *)(a1 + 61) = v24;
              if ( !v24 )
                v37 = 1;
            }
            ++v36;
          }
        }
        if ( v37 )
        {
          v25 = *(_BYTE *)(a1 + 67);
          *(_WORD *)(a1 + 150) = 0;
          *(_BYTE *)(a1 + 67) = --v25;
          if ( v25 )
LABEL_46:
            *(_BYTE *)(a1 + 70) = 2;
          else
            *(_BYTE *)(a1 + 70) = 6;
        }
        return v12;
      case 6:
        v27 = *(_BYTE *)(a1 + 68);
        *(_DWORD *)(a1 + 12) &= 0xFF7FFFFE;
        if ( !v27 )
        {
          *(_BYTE *)(a1 + 70) = 7;
          *(_DWORD *)(a1 + 16) = 10;
        }
        return v12;
      case 7:
        v12 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v12;
        if ( !v12 )
        {
          *(_BYTE *)(a1 + 70) = 9;
          *(_DWORD *)(a1 + 16) = 3;
        }
        return v12;
      case 8:
        *(_BYTE *)(a1 + 70) = 9;
        v26 = *(_DWORD *)(a1 + 12);
        *(_DWORD *)(a1 + 16) = 3;
        *(_DWORD *)(a1 + 12) = v26 & 0xFF7FFFFE;
        return v12;
      case 9:
        v12 = *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 16) = v12 + 1;
        LOWORD(v12) = *(_WORD *)(a1 + 80) - 32 * v12;
        *(_WORD *)(a1 + 80) = v12;
        if ( (signed __int16)v12 >= v5 )
          return v12;
        *(_WORD *)(a1 + 80) = v5;
        if ( sub_104D0((signed __int16 *)(a1 + 76)) == (int (*)())1 )
          sub_4A190(a1 + 76, 10, 5);
        else
          sub_4A190(a1 + 76, 10, 0);
        goto LABEL_99;
      default:
        return v12;
    }
  }
  return v12;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0003AF00) --------------------------------------------------------
int __cdecl sub_3AF00(int a1)
{
  int v1; // edx
  __int16 v2; // dx
  int v3; // esi
  unsigned int v4; // edx
  int v5; // eax
  int i; // ecx
  unsigned __int8 v7; // al
  unsigned __int8 v8; // al
  _BOOL1 v9; // zf
  int v10; // eax
  int v11; // edx
  __int16 v12; // di
  signed int v13; // edx
  __int16 v14; // ax
  unsigned __int16 v15; // ax
  int v16; // edi
  int v17; // eax
  __int16 v18; // ax
  __int16 v19; // ax
  char v20; // dh
  char v21; // al
  int v22; // eax
  char v23; // dl
  __int16 v24; // ax
  char v25; // dh
  __int16 v26; // ax
  int result; // eax
  int v28; // ecx
  int v29; // ecx
  _WORD *v30; // esi
  signed int v31; // edx
  int v32; // [esp+0h] [ebp-30h]
  int v33; // [esp+4h] [ebp-2Ch]
  int v34; // [esp+8h] [ebp-28h]
  int v35; // [esp+Ch] [ebp-24h]
  int v36; // [esp+10h] [ebp-20h]
  int v37; // [esp+14h] [ebp-1Ch]
  int v38; // [esp+18h] [ebp-18h]
  char v39; // [esp+1Ch] [ebp-14h]
  unsigned __int8 v40; // [esp+20h] [ebp-10h]
  char v41; // [esp+24h] [ebp-Ch]
  unsigned __int8 v42; // [esp+28h] [ebp-8h]
  char v43; // [esp+2Ch] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 8);
  v41 = 0;
  if ( v1 < 0 )
    return sub_57F10(a1);
  v2 = *(_WORD *)(a1 + 26);
  if ( !v2 )
    return sub_57F10(a1);
  v38 = dword_EA3E4[v2];
  v3 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(v38 + 164) + 58)];
  if ( *(_WORD *)(a1 + 74) <= 1 )
    v37 = 384;
  else
    v37 = 224;
  switch ( *(_BYTE *)(a1 + 70) )
  {
    case 0:
      *(_DWORD *)(a1 + 154) = *(_DWORD *)(a1 + 76);
      *(_WORD *)(a1 + 158) = *(_WORD *)(a1 + 80);
      v3 = a1 + 82;
      *(_BYTE *)(a1 + 70) = 1;
      goto LABEL_74;
    case 1:
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v4 = *(unsigned __int16 *)(a1 + 20) % 0x30u;
      *(_BYTE *)(a1 + 70) = 2;
      *(_DWORD *)(a1 + 16) = v4 + 16;
      goto LABEL_9;
    case 2:
LABEL_9:
      v5 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v5;
      if ( !v5 )
        *(_BYTE *)(a1 + 70) = 3;
      goto LABEL_74;
    case 3:
      if ( *(_BYTE *)(a1 + 62) & 0x3F )
        goto LABEL_74;
      v36 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
      v35 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
      v3 = sub_10080(3, 12);
      if ( !v3 )
        goto LABEL_74;
      v39 = 0;
      break;
    case 4:
      *(_BYTE *)(a1 + 70) = 5;
      *(_DWORD *)(a1 + 16) = 4;
      goto LABEL_37;
    case 5:
LABEL_37:
      v11 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v11;
      if ( v11 )
      {
        *(_WORD *)(a1 + 54) += 160;
      }
      else
      {
        *(_BYTE *)(a1 + 70) = 6;
        *(_WORD *)(a1 + 54) = 0;
      }
      goto LABEL_74;
    case 6:
      v12 = *(_WORD *)(a1 + 20);
      *(_WORD *)(a1 + 158) = *(_WORD *)(a1 + 80);
      *(_WORD *)(a1 + 20) = 9377 * v12 + 9439;
      v13 = *(unsigned __int16 *)(a1 + 20) % 0x64u;
      *(_BYTE *)(a1 + 70) = 7;
      if ( v13 )
      {
        if ( v13 <= 5 )
        {
          v14 = (*(_BYTE *)(a1 + 67) == 1) + 2;
        }
        else
        {
          LOBYTE(v14) = *(_BYTE *)(a1 + 67) != 1;
          HIBYTE(v14) = 0;
        }
        *(_WORD *)(a1 + 44) = v14;
      }
      else
      {
        *(_WORD *)(a1 + 44) = 4;
      }
      v15 = *(_WORD *)(a1 + 44);
      *(_BYTE *)(a1 + 61) = 1;
      if ( v15 <= 1u )
        *(_BYTE *)(a1 + 61) = 6;
      goto LABEL_48;
    case 7:
    case 8:
LABEL_48:
      v43 = 0;
      if ( !*(_WORD *)(a1 + 150) )
        goto LABEL_104;
      v16 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
      if ( *(_DWORD *)(v16 + 8) < 0 || *(_BYTE *)(v16 + 13) & 4 )
        goto LABEL_104;
      switch ( *(_WORD *)(a1 + 44) )
      {
        case 0:
          v40 = 0;
          v42 = 1;
          break;
        case 1:
          v40 = 7;
          goto LABEL_57;
        case 2:
          v40 = 7;
          v42 = 1;
          break;
        case 3:
          v40 = 0;
          v42 = 2;
          break;
        case 4:
          v40 = 9;
LABEL_57:
          v42 = 0;
          break;
        default:
          break;
      }
      v17 = sub_6DCA0(v3, a1 + 76, v40, (__int16 *)&byte_DA818[80 * v40 + 2 + 26 * v42], 0, *(_BYTE *)(a1 + 70) == 7);
      v3 = v17;
      if ( v17 )
      {
        *(_WORD *)(v17 + 26) = *(_WORD *)(a1 + 26);
        *(_WORD *)(v17 + 150) = *(_WORD *)(a1 + 150);
        if ( *(_WORD *)(*(_DWORD *)(v38 + 164) + 56) == *(_WORD *)(dword_D41A0 + 12) && !v40 )
          sub_49C90(v17, 42);
        sub_655C0((_WORD *)v3, v16);
        *(_WORD *)(v3 + 28) = *(_WORD *)(v3 + 32);
        *(_WORD *)(v3 + 30) = *(_WORD *)(v3 + 34);
        v18 = *(_WORD *)(v3 + 28);
        *(_WORD *)(v3 + 80) += *(_WORD *)(a1 + 82);
        HIBYTE(v18) &= 7u;
        *(_WORD *)(a1 + 28) = v18;
        v19 = *(_WORD *)(v3 + 30);
        HIBYTE(v19) &= 7u;
        v20 = *(_BYTE *)(a1 + 68);
        *(_WORD *)(a1 + 30) = v19;
        if ( v20 )
        {
          *(_BYTE *)(a1 + 68) = v20 + 1;
          if ( (char)(v20 + 1) > 5 )
            *(_BYTE *)(a1 + 68) = 5;
        }
        else
        {
          *(_BYTE *)(a1 + 68) = 1;
        }
        v21 = *(_BYTE *)(a1 + 61) - 1;
        *(_BYTE *)(a1 + 61) = v21;
        if ( !v21 )
LABEL_104:
          v43 = 1;
      }
      if ( v43 )
      {
        *(_WORD *)(a1 + 150) = 0;
        *(_BYTE *)(a1 + 70) = 1;
      }
      else
      {
        *(_BYTE *)(a1 + 70) = 8;
      }
      goto LABEL_74;
    case 9:
      goto LABEL_73;
    case 0xA:
      v22 = sub_4A190(a1 + 76, 10, 1);
      if ( v22 )
        *(_WORD *)(v22 + 26) = *(_WORD *)(a1 + 26);
LABEL_73:
      v41 = 1;
      goto LABEL_74;
    default:
      goto LABEL_74;
  }
LABEL_33:
  if ( sub_10130(v3, &v33, &v32) == 1 && !v39 )
  {
    for ( i = dword_EA3E4[word_15B4E0[(unsigned __int8)(v33 + v36) + ((unsigned __int8)(v32 + v35) << 8)]];
          ;
          i = dword_EA3E4[*(unsigned __int16 *)(i + 22)] )
    {
      if ( i == dword_EA3E4[0] || v39 )
        goto LABEL_33;
      v7 = *(_BYTE *)(i + 63);
      if ( v7 >= 3u )
      {
        if ( v7 <= 3u )
        {
          v8 = *(_BYTE *)(i + 64);
          if ( v8 <= 1u || v8 == 3 )
          {
            v9 = *(_WORD *)(i + 26) == *(_WORD *)(a1 + 26);
LABEL_26:
            if ( v9 )
              goto LABEL_28;
LABEL_27:
            v39 = 1;
            goto LABEL_28;
          }
        }
        else if ( v7 == 5 && *(_BYTE *)(i + 64) != 22 && *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) )
        {
          if ( *(_BYTE *)(i + 73) == 14 )
          {
            v9 = *(unsigned __int16 *)(i + 40) == *(signed __int16 *)(a1 + 26);
            goto LABEL_26;
          }
          goto LABEL_27;
        }
      }
LABEL_28:
      if ( v39 )
      {
        v10 = (i - (dword_D41A0 + 28302)) / 168;
        *(_BYTE *)(a1 + 70) = 4;
        *(_WORD *)(a1 + 150) = v10;
      }
    }
  }
  sub_10100(v3);
LABEL_74:
  if ( v41 )
    return sub_57F20(a1);
  v23 = *(_BYTE *)(a1 + 68);
  if ( v23 )
  {
    switch ( abs(v23) )
    {
      case 1:
        v34 = 0;
        break;
      case 2:
        v34 = 115;
        break;
      case 3:
        v34 = 230;
        break;
      case 4:
        v34 = 334;
        break;
      case 5:
        v34 = 368;
        break;
      case 6:
        v34 = 384;
        break;
      default:
        break;
    }
    v24 = -(signed __int16)v34;
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 154);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 158);
    v3 = a1 + 160;
    sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), v24);
    sub_57CF0(a1, (int)&word_EB398);
    v25 = *(_BYTE *)(a1 + 68) + 1;
    *(_BYTE *)(a1 + 68) = v25;
    if ( v25 > 0 && v25 > 6 )
      *(_BYTE *)(a1 + 68) = -5;
  }
  v26 = sub_10C40((__int16 *)(a1 + 76));
  result = v37 + v26;
  v28 = *(signed __int16 *)(a1 + 80);
  if ( v28 < result )
  {
LABEL_98:
    *(_WORD *)(a1 + 80) = result;
    return result;
  }
  LOWORD(v3) = *(_WORD *)(a1 + 54);
  if ( (_WORD)v3 )
  {
    result += v3;
    goto LABEL_98;
  }
  if ( !*(_BYTE *)(a1 + 68) )
  {
    v29 = v28 - result;
    result = abs(v29);
    if ( result > 32 )
    {
      v30 = (_WORD *)(a1 + 80);
      if ( v29 <= 0 )
        v31 = 16;
      else
        v31 = -16;
      result = v31 + (signed __int16)*v30;
      *v30 = result;
    }
    if ( *(_BYTE *)(a1 + 62) & 8 )
      *(_WORD *)(a1 + 80) += 6;
    else
      *(_WORD *)(a1 + 80) -= 6;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (0003B4D0) --------------------------------------------------------
int *__cdecl sub_3B4D0(int a1)
{
  int *result; // eax
  char v2; // bl
  int v3; // edx

  result = (int *)&unk_D4350;
  v2 = 32;
  v3 = (a1 << 16) - 1;
  do
  {
    if ( *result )
      *result = v3;
    if ( result[1] )
      result[1] = v3;
    if ( result[2] )
      result[2] = v3;
    if ( result[3] )
      result[3] = v3;
    if ( result[4] )
      result[4] = v3;
    if ( result[5] )
      result[5] = v3;
    if ( result[6] )
      result[6] = v3;
    if ( result[7] )
      result[7] = v3;
    result += 8;
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (0003B560) --------------------------------------------------------
_DWORD *__cdecl sub_3B560(__int16 a1)
{
  int v1; // edx
  _DWORD *v2; // edi
  signed int *v3; // esi
  int v4; // eax
  __int16 v5; // bx
  signed int v6; // ecx
  int v7; // edx
  unsigned __int8 v8; // cf
  int v9; // eax
  int v10; // esi
  void (__noreturn *v11)(); // eax
  _DWORD *v12; // edi
  signed int *v13; // esi
  int v14; // eax
  signed int v15; // ecx
  int v16; // edx
  _DWORD *v17; // edi
  signed int *v18; // esi
  int v19; // eax
  __int16 v20; // bx
  signed int v21; // ecx
  int v22; // edx
  _DWORD *v23; // edi
  signed int *v24; // esi
  int v25; // eax
  __int16 v26; // bx
  signed int v27; // ecx
  int v28; // edx
  _DWORD *result; // eax
  int v30; // eax
  signed int *v31; // esi
  _DWORD *v32; // edi
  int v33; // eax
  signed int v34; // ecx
  int v35; // edx
  _DWORD *v36; // edi
  signed int *v37; // esi
  int v38; // eax
  __int16 v39; // bx
  signed int v40; // ecx
  int v41; // edx
  int v42; // edx
  _DWORD *v43; // edi
  signed int *v44; // esi
  int v45; // eax
  __int16 v46; // bx
  signed int v47; // ecx
  int v48; // edx
  int v49; // edx
  int v50; // esi
  int v51; // esi
  signed int *v52; // esi
  _DWORD *v53; // edi
  int v54; // eax
  signed int v55; // ecx
  int v56; // edx
  _DWORD *v57; // edi
  signed int *v58; // esi
  int v59; // eax
  __int16 v60; // bx
  signed int v61; // ecx
  int v62; // edx
  _DWORD *v63; // edi
  signed int *v64; // esi
  int v65; // eax
  __int16 v66; // bx
  signed int v67; // ecx
  int v68; // edx
  int v69; // esi
  int v70; // eax
  _DWORD *v71; // edi
  signed int *v72; // esi
  int v73; // eax
  signed int v74; // ecx
  int v75; // edx
  _DWORD *v76; // edi
  signed int *v77; // esi
  int v78; // eax
  __int16 v79; // bx
  signed int v80; // ecx
  int v81; // edx
  int v82; // edx
  int v83; // ecx
  int v84; // [esp+0h] [ebp-10h]
  int v85; // [esp+0h] [ebp-10h]
  int v86; // [esp+0h] [ebp-10h]
  int v87; // [esp+0h] [ebp-10h]
  int v88; // [esp+4h] [ebp-Ch]
  int v89; // [esp+4h] [ebp-Ch]
  int v90; // [esp+4h] [ebp-Ch]
  int v91; // [esp+4h] [ebp-Ch]
  int v92; // [esp+8h] [ebp-8h]
  int v93; // [esp+8h] [ebp-8h]
  int v94; // [esp+8h] [ebp-8h]
  int v95; // [esp+8h] [ebp-8h]
  int v96; // [esp+8h] [ebp-8h]
  int v97; // [esp+8h] [ebp-8h]
  int v98; // [esp+8h] [ebp-8h]
  int v99; // [esp+8h] [ebp-8h]
  int v100; // [esp+8h] [ebp-8h]
  __int16 v101; // [esp+Ch] [ebp-4h]
  __int16 v102; // [esp+Ch] [ebp-4h]
  __int16 v103; // [esp+Ch] [ebp-4h]
  __int16 v104; // [esp+Ch] [ebp-4h]
  __int16 v105; // [esp+Ch] [ebp-4h]
  __int16 v106; // [esp+Ch] [ebp-4h]
  __int16 v107; // [esp+Ch] [ebp-4h]
  __int16 v108; // [esp+Ch] [ebp-4h]

  v1 = a1 & 0x7FF;
  dword_F2C98 = v1 >> 8;
  switch ( v1 >> 8 )
  {
    case 0:
      dword_F2CBC = dword_DB750[v1];
      dword_F2C8C = (int)off_DBF50[v1];
      v88 = dword_DE560;
      v92 = (unsigned __int16)dword_DE564;
      dword_F2C9C = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v101 = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v2 = &unk_F0E20;
      v3 = (signed int *)(dword_E9C38 + 59360);
      v4 = 0;
      v5 = 0;
      v6 = 1;
      v7 = 0;
      do
      {
        v2[1] = v4;
        v2[2] = v7;
        v8 = __CFADD__(v101, v5);
        v5 += v101;
        if ( v8 )
        {
          v4 += v88;
          ++v7;
          *v3 = v6;
          ++v3;
        }
        v2 += 3;
        ++v4;
        ++v6;
        --v92;
      }
      while ( v92 );
      dword_F2C94 = v7;
      dword_F2CA4 = -v7;
      dword_F2CB4 = (unsigned __int16)dword_DE568;
      dword_F2CB8 = (unsigned __int16)dword_DE564;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      dword_F2C88 = 4 * (v7 - 1) + dword_E9C38 + 59360;
      v9 = dword_DE560;
      dword_F2C84 = (unsigned __int16)dword_DE568 - v7;
      goto LABEL_66;
    case 1:
      v10 = dword_DB750[v1];
      v11 = off_DBF50[v1];
      dword_F2CBC = dword_DB750[v1];
      dword_F2C8C = (int)v11;
      v84 = dword_DE560;
      v93 = (unsigned __int16)dword_DE568;
      if ( v1 == 256 )
      {
        dword_F2C9C = (int)sub_10000;
        v12 = &unk_F0E20;
        v13 = (signed int *)(dword_E9C38 + 59360);
        v14 = 0;
        v15 = 1;
        v16 = 0;
        do
        {
          v12[1] = v14;
          v12[2] = v16++;
          *v13 = v15;
          ++v13;
          v12 += 3;
          v14 += v84 + 1;
          ++v15;
          --v93;
        }
        while ( v93 );
        dword_F2C94 = (unsigned __int16)dword_DE568;
        dword_F2CA4 = -(unsigned __int16)dword_DE568;
      }
      else
      {
        dword_F2C9C = (dword_F2C8C << 8) / (v10 >> 8);
        v102 = (dword_F2C8C << 8) / (v10 >> 8);
        v17 = &unk_F0E20;
        v18 = (signed int *)(dword_E9C38 + 59360);
        v19 = 0;
        v20 = 0;
        v21 = 1;
        v22 = 0;
        do
        {
          v17[1] = v19;
          v17[2] = v22;
          v8 = __CFADD__(v102, v20);
          v20 += v102;
          if ( v8 )
          {
            ++v19;
            ++v22;
            *v18 = v21;
            ++v18;
          }
          v17 += 3;
          v19 += v84;
          ++v21;
          --v93;
        }
        while ( v93 );
        dword_F2C94 = v22;
        dword_F2CA4 = -v22;
      }
      dword_F2CB4 = (unsigned __int16)dword_DE564;
      dword_F2CB8 = (unsigned __int16)dword_DE568;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      dword_F2C88 = 4 * (-1 - dword_F2CA4) + dword_E9C38 + 59360;
      v9 = -1;
      dword_F2C84 = (unsigned __int16)dword_DE564 + dword_F2CA4;
      goto LABEL_66;
    case 2:
      dword_F2CBC = dword_DAF50[v1];
      dword_F2C8C = dword_DB750[v1];
      v85 = dword_DE560;
      v94 = (unsigned __int16)dword_DE568;
      dword_F2C9C = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v103 = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v23 = &unk_F0E20;
      v24 = (signed int *)(dword_E9C38 + 59360);
      v25 = 0;
      v26 = 0;
      v27 = 1;
      v28 = 0;
      do
      {
        v23[1] = v25;
        v23[2] = v28;
        v8 = __CFADD__(v103, v26);
        v26 += v103;
        if ( v8 )
        {
          --v25;
          ++v28;
          *v24 = v27;
          ++v24;
        }
        v23 += 3;
        v25 += v85;
        ++v27;
        --v94;
      }
      while ( v94 );
      dword_F2C94 = v28;
      dword_F2CA4 = -v28;
      dword_F2CB4 = (unsigned __int16)dword_DE564;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      dword_F2CB8 = (unsigned __int16)dword_DE568;
      dword_F2CAC = -1;
      dword_F2C84 = (unsigned __int16)dword_DE564 - v28;
      dword_F2C88 = 4 * (v28 - 1) + dword_E9C38 + 59360;
      v95 = (unsigned __int16)dword_DE568 - 1;
      result = &unk_F0E20;
      if ( v95 < 0 )
        return result;
      goto LABEL_68;
    case 3:
      v30 = dword_DB750[v1];
      dword_F2CBC = dword_DAF50[v1];
      dword_F2C8C = v30;
      v89 = dword_DE560;
      v96 = (unsigned __int16)dword_DE564;
      if ( v1 == 768 )
      {
        dword_F2C9C = (int)sub_10000;
        v31 = (signed int *)(dword_E9C38 + 59360);
        v32 = &unk_F0E20;
        v33 = 0;
        v34 = 1;
        v35 = 0;
        do
        {
          v32[1] = v33;
          v32[2] = v35++;
          *v31 = v34;
          ++v31;
          v32 += 3;
          v33 = v89 + v33 - 1;
          ++v34;
          --v96;
        }
        while ( v96 );
        dword_F2C94 = (unsigned __int16)dword_DE564;
        dword_F2CA4 = -(unsigned __int16)dword_DE564;
      }
      else
      {
        dword_F2C9C = (dword_F2C8C << 8) / (dword_F2CBC >> 8);
        v104 = (dword_F2C8C << 8) / (dword_F2CBC >> 8);
        v36 = &unk_F0E20;
        v37 = (signed int *)(dword_E9C38 + 59360);
        v38 = 0;
        v39 = 0;
        v40 = 1;
        v41 = 0;
        do
        {
          v36[1] = v38;
          v36[2] = v41;
          v8 = __CFADD__(v104, v39);
          v39 += v104;
          if ( v8 )
          {
            v38 += v89;
            ++v41;
            *v37 = v40;
            ++v37;
          }
          v36 += 3;
          --v38;
          ++v40;
          --v96;
        }
        while ( v96 );
        dword_F2C94 = v41;
        dword_F2CA4 = -v41;
      }
      dword_F2CB4 = (unsigned __int16)dword_DE568;
      dword_F2CB8 = (unsigned __int16)dword_DE564;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      v42 = 4 * (-1 - dword_F2CA4) + dword_E9C38 + 59360;
      dword_F2C84 = (unsigned __int16)dword_DE568 + dword_F2CA4;
      v9 = -dword_DE560;
      goto LABEL_65;
    case 4:
      dword_F2CBC = dword_DA750[v1];
      dword_F2C8C = dword_DAF50[v1];
      v90 = -dword_DE560;
      v97 = (unsigned __int16)dword_DE564;
      dword_F2C9C = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v105 = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v43 = &unk_F0E20;
      v44 = (signed int *)(dword_E9C38 + 59360);
      v45 = 0;
      v46 = 0;
      v47 = 1;
      v48 = 0;
      do
      {
        v43[1] = v45;
        v43[2] = v48;
        v8 = __CFADD__(v105, v46);
        v46 += v105;
        if ( v8 )
        {
          v45 += v90;
          ++v48;
          *v44 = v47;
          ++v44;
        }
        v43 += 3;
        --v45;
        ++v47;
        --v97;
      }
      while ( v97 );
      dword_F2C94 = v48;
      v49 = -v48;
      dword_F2CA4 = v49;
      v50 = (unsigned __int16)dword_DE568 + v49;
      dword_F2CB4 = (unsigned __int16)dword_DE568;
      dword_F2CB8 = (unsigned __int16)dword_DE564;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      v42 = 4 * (-1 - v49) + dword_E9C38 + 59360;
      dword_F2C84 = v50;
      v9 = -dword_DE560;
      goto LABEL_65;
    case 5:
      v51 = dword_DA750[v1];
      dword_F2C8C = dword_DAF50[v1];
      dword_F2CBC = v51;
      v86 = -dword_DE560;
      v98 = (unsigned __int16)dword_DE568;
      if ( v1 == 1280 )
      {
        dword_F2C9C = (int)sub_10000;
        v52 = (signed int *)(dword_E9C38 + 59360);
        v53 = &unk_F0E20;
        v54 = 0;
        v55 = 1;
        v56 = 0;
        do
        {
          v53[1] = v54;
          v53[2] = v56++;
          *v52 = v55;
          ++v52;
          v53 += 3;
          v54 = v86 + v54 - 1;
          ++v55;
          --v98;
        }
        while ( v98 );
        dword_F2C94 = (unsigned __int16)dword_DE568;
        dword_F2CA4 = -(unsigned __int16)dword_DE568;
      }
      else
      {
        dword_F2C9C = (dword_F2C8C << 8) / (dword_F2CBC >> 8);
        v106 = (dword_F2C8C << 8) / (dword_F2CBC >> 8);
        v57 = &unk_F0E20;
        v58 = (signed int *)(dword_E9C38 + 59360);
        v59 = 0;
        v60 = 0;
        v61 = 1;
        v62 = 0;
        do
        {
          v57[1] = v59;
          v57[2] = v62;
          v8 = __CFADD__(v106, v60);
          v60 += v106;
          if ( v8 )
          {
            --v59;
            ++v62;
            *v58 = v61;
            ++v58;
          }
          v57 += 3;
          v59 += v86;
          ++v61;
          --v98;
        }
        while ( v98 );
        dword_F2C94 = v62;
        dword_F2CA4 = -v62;
      }
      dword_F2CB4 = (unsigned __int16)dword_DE564;
      dword_F2CB8 = (unsigned __int16)dword_DE568;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      dword_F2CAC = 1;
      dword_F2C84 = (unsigned __int16)dword_DE564 + dword_F2CA4;
      dword_F2C88 = 4 * (-1 - dword_F2CA4) + dword_E9C38 + 59360;
      v95 = (unsigned __int16)dword_DE568 - 1;
      result = &unk_F0E20;
      if ( v95 < 0 )
        return result;
      goto LABEL_68;
    case 6:
      dword_F2CBC = dword_D9F50[v1];
      dword_F2C8C = dword_DA750[v1];
      v87 = -dword_DE560;
      v99 = (unsigned __int16)dword_DE568;
      dword_F2C9C = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v107 = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v63 = &unk_F0E20;
      v64 = (signed int *)(dword_E9C38 + 59360);
      v65 = 0;
      v66 = 0;
      v67 = 1;
      v68 = 0;
      do
      {
        v63[1] = v65;
        v63[2] = v68;
        v8 = __CFADD__(v107, v66);
        v66 += v107;
        if ( v8 )
        {
          ++v65;
          ++v68;
          *v64 = v67;
          ++v64;
        }
        v63 += 3;
        v65 += v87;
        ++v67;
        --v99;
      }
      while ( v99 );
      dword_F2C94 = v68;
      dword_F2CA4 = -v68;
      dword_F2C84 = (unsigned __int16)dword_DE564 - v68;
      dword_F2CB4 = (unsigned __int16)dword_DE564;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      dword_F2CB8 = (unsigned __int16)dword_DE568;
      dword_F2CAC = 1;
      dword_F2C88 = 4 * (v68 - 1) + dword_E9C38 + 59360;
      v95 = (unsigned __int16)dword_DE568 - 1;
      result = &unk_F0E20;
      if ( v95 < 0 )
        return result;
      goto LABEL_68;
    case 7:
      v69 = dword_D9F50[v1];
      v70 = dword_DA750[v1];
      dword_F2CBC = dword_D9F50[v1];
      dword_F2C8C = v70;
      v91 = -dword_DE560;
      v100 = (unsigned __int16)dword_DE564;
      if ( v1 == 1792 )
      {
        v71 = &unk_F0E20;
        v72 = (signed int *)(dword_E9C38 + 59360);
        dword_F2C9C = (int)sub_10000;
        v73 = 0;
        v74 = 1;
        v75 = 0;
        do
        {
          v71[1] = v73;
          v71[2] = v75++;
          *v72 = v74;
          ++v72;
          v71 += 3;
          v73 += v91 + 1;
          ++v74;
          --v100;
        }
        while ( v100 );
        dword_F2C94 = (unsigned __int16)dword_DE564;
        dword_F2CA4 = -(unsigned __int16)dword_DE564;
      }
      else
      {
        dword_F2C9C = (dword_F2C8C << 8) / (v69 >> 8);
        v108 = (dword_F2C8C << 8) / (v69 >> 8);
        v76 = &unk_F0E20;
        v77 = (signed int *)(dword_E9C38 + 59360);
        v78 = 0;
        v79 = 0;
        v80 = 1;
        v81 = 0;
        do
        {
          v76[1] = v78;
          v76[2] = v81;
          v8 = __CFADD__(v108, v79);
          v79 += v108;
          if ( v8 )
          {
            v78 += v91;
            ++v81;
            *v77 = v80;
            ++v77;
          }
          v76 += 3;
          ++v78;
          ++v80;
          --v100;
        }
        while ( v100 );
        dword_F2C94 = v81;
        dword_F2CA4 = -v81;
      }
      dword_F2CB4 = (unsigned __int16)dword_DE568;
      dword_F2CB8 = (unsigned __int16)dword_DE564;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      dword_F2C84 = (unsigned __int16)dword_DE568 + dword_F2CA4;
      v42 = 4 * (-1 - dword_F2CA4) + dword_E9C38 + 59360;
      v9 = dword_DE560;
LABEL_65:
      dword_F2C88 = v42;
LABEL_66:
      dword_F2CAC = v9;
      break;
    default:
      break;
  }
  v95 = dword_F2CB8 - 1;
  for ( result = &unk_F0E20; v95 >= 0; --v95 )
  {
LABEL_68:
    v82 = result[1];
    v83 = *(result - 2);
    result += 3;
    *(result - 3) = v82 - v83;
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// D9F50: using guessed type int dword_D9F50[];
// DA750: using guessed type int dword_DA750[];
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;
// E9C38: using guessed type int dword_E9C38;
// F2C84: using guessed type int dword_F2C84;
// F2C88: using guessed type int dword_F2C88;
// F2C8C: using guessed type int dword_F2C8C;
// F2C90: using guessed type int dword_F2C90;
// F2C94: using guessed type int dword_F2C94;
// F2C98: using guessed type int dword_F2C98;
// F2C9C: using guessed type int dword_F2C9C;
// F2CA4: using guessed type int dword_F2CA4;
// F2CAC: using guessed type int dword_F2CAC;
// F2CB4: using guessed type int dword_F2CB4;
// F2CB8: using guessed type int dword_F2CB8;
// F2CBC: using guessed type int dword_F2CBC;

//----- (0003C080) --------------------------------------------------------
char __usercall sub_3C080@<al>(int a1@<ebx>, int a2@<esi>, __int16 a3, __int16 a4, __int16 a5, signed int a6, int a7, __int16 a8, int a9)
{
  int v9; // eax
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // edi
  char v14; // dh
  int v15; // eax
  char v16; // dl
  char v17; // dl
  _DWORD *v18; // eax
  char v19; // dh
  int v20; // ebx
  int v21; // ecx
  char v22; // ch
  int v23; // eax
  int v24; // edx
  _DWORD *v25; // edi
  unsigned __int16 v26; // dx
  int v27; // ebx
  int v28; // eax
  __int16 v29; // si
  int v30; // edx
  __int16 v31; // cx
  int v32; // eax
  int v33; // ecx
  signed int v34; // esi
  int v35; // ebx
  unsigned __int16 v36; // dx
  int v37; // eax
  __int16 v38; // ax
  int v39; // eax
  int v40; // edi
  int v41; // edx
  unsigned __int16 v42; // bx
  int v43; // edx
  _BYTE *v44; // eax
  char v45; // bh
  signed int v46; // edx
  int v47; // eax
  int v48; // esi
  int v49; // ecx
  int v50; // ecx
  int v51; // ebx
  int v52; // ecx
  int v53; // ebx
  signed int v54; // esi
  signed int v55; // esi
  int v56; // eax
  int v57; // esi
  char v58; // ah
  int j; // ebx
  char v60; // dl
  char v61; // dh
  char v62; // ch
  char v63; // ah
  char v64; // dl
  char v65; // dh
  char v66; // ch
  char v67; // dl
  int v68; // ebx
  int v69; // eax
  int *v70; // edx
  char v71; // dl
  char v72; // dh
  char v73; // ch
  char v74; // ah
  char v75; // dl
  char v76; // dh
  char v77; // ch
  char v78; // dl
  char v79; // dh
  int v80; // ebx
  int *v81; // edx
  unsigned int v82; // edi
  unsigned int v83; // ebx
  char v84; // dl
  char v85; // cl
  char v86; // dh
  char v87; // al
  char v88; // dl
  char v89; // dh
  int v90; // eax
  int v91; // ebx
  char v92; // cl
  char v93; // dl
  int v94; // ebx
  int *v95; // edx
  char v96; // al
  char v97; // dl
  char v98; // dh
  char v99; // ah
  char v100; // dl
  char v101; // dh
  char v102; // ch
  int v103; // eax
  int v104; // ebx
  char v105; // dl
  char v106; // dh
  int v107; // ebx
  int *v108; // edx
  signed int v109; // esi
  int v110; // ebx
  unsigned __int16 v111; // dx
  __int16 v112; // ax
  int v113; // eax
  _DWORD *v114; // ecx
  signed int v115; // edx
  int v116; // eax
  int v117; // edx
  unsigned __int16 v118; // bx
  unsigned __int8 v119; // al
  int v120; // edx
  _BYTE *v121; // eax
  char v122; // bh
  signed int v123; // ebx
  int v124; // eax
  int v125; // esi
  int v126; // ecx
  int v127; // ecx
  int v128; // edx
  int v129; // ecx
  int v130; // edx
  signed int v131; // esi
  signed int v132; // esi
  int v133; // esi
  int v134; // ebx
  int v135; // eax
  char v136; // dl
  char v137; // ch
  char v138; // dl
  int v139; // eax
  int v140; // ebx
  int v141; // eax
  char v142; // ch
  int v143; // ebx
  char v144; // dl
  int v145; // eax
  int *v146; // edx
  unsigned int v147; // ebx
  char v148; // dl
  char v149; // dl
  int v150; // eax
  int v151; // ebx
  int v152; // eax
  char v153; // cl
  int v154; // eax
  int v155; // ebx
  char v156; // dl
  int v157; // eax
  int *v158; // edx
  int v159; // eax
  int v160; // esi
  int v161; // ebx
  int v162; // eax
  char v163; // dl
  char v164; // dh
  char v165; // ah
  char v166; // dl
  char v167; // dh
  int v168; // eax
  int v169; // ebx
  char v170; // ch
  int v171; // eax
  int v172; // ebx
  char v173; // dl
  char v174; // dh
  int *v175; // edx
  int *v176; // edx
  unsigned int v177; // edi
  unsigned int v178; // ebx
  char v179; // dl
  char v180; // ch
  char v181; // dh
  char v182; // ah
  char v183; // dl
  char v184; // dh
  int v185; // eax
  int v186; // ebx
  int v187; // eax
  int v188; // eax
  char v189; // ch
  int v190; // ebx
  char v191; // dl
  char v192; // dh
  int *v193; // edx
  char v194; // ch
  int *v195; // edx
  char v196; // ch
  int v197; // ecx
  signed int v198; // esi
  int v199; // ebx
  unsigned __int16 v200; // di
  __int16 v201; // ax
  int v202; // eax
  int v203; // eax
  unsigned __int16 v204; // bx
  unsigned __int8 *v205; // ecx
  int v206; // edx
  _BYTE *v207; // eax
  int v208; // eax
  signed int v209; // ebx
  int v210; // edx
  void (__noreturn *v211)(); // eax
  int v212; // ecx
  int v213; // edx
  int v214; // ecx
  int v215; // edx
  signed int v216; // esi
  int v217; // esi
  int v218; // ebx
  char v219; // dl
  char v220; // dh
  char v221; // al
  char v222; // dl
  char v223; // dh
  int v224; // eax
  int v225; // ebx
  char v226; // cl
  int v227; // ebx
  char v228; // dl
  char v229; // dh
  int *v230; // edx
  unsigned int v231; // edi
  unsigned int v232; // ebx
  char v233; // dl
  char v234; // ch
  char v235; // dh
  char v236; // ah
  char v237; // dl
  char v238; // dh
  int v239; // eax
  int v240; // ebx
  int v241; // eax
  char v242; // ch
  int v243; // ebx
  char v244; // dl
  char v245; // dh
  int *v246; // edx
  int v248; // [esp+0h] [ebp-62h]
  int v249; // [esp+4h] [ebp-5Eh]
  int v250; // [esp+8h] [ebp-5Ah]
  int v251; // [esp+Ch] [ebp-56h]
  int v252; // [esp+10h] [ebp-52h]
  int v253; // [esp+18h] [ebp-4Ah]
  int v254; // [esp+1Ch] [ebp-46h]
  int v255; // [esp+20h] [ebp-42h]
  int v256; // [esp+24h] [ebp-3Eh]
  _DWORD *v257; // [esp+28h] [ebp-3Ah]
  int v258; // [esp+30h] [ebp-32h]
  int v259; // [esp+34h] [ebp-2Eh]
  int v260; // [esp+38h] [ebp-2Ah]
  int v261; // [esp+3Ch] [ebp-26h]
  int v262; // [esp+40h] [ebp-22h]
  int v263; // [esp+48h] [ebp-1Ah]
  int v264; // [esp+4Ch] [ebp-16h]
  int v265; // [esp+50h] [ebp-12h]
  int v266; // [esp+54h] [ebp-Eh]
  int v267; // [esp+58h] [ebp-Ah]
  int v268; // [esp+60h] [ebp-2h]
  int v269; // [esp+64h] [ebp+2h]
  int v270; // [esp+68h] [ebp+6h]
  int v271; // [esp+6Ch] [ebp+Ah]
  int v272; // [esp+70h] [ebp+Eh]
  int v273; // [esp+74h] [ebp+12h]
  void (__noreturn *v274)(); // [esp+78h] [ebp+16h]
  int v275; // [esp+7Ch] [ebp+1Ah]
  int v276; // [esp+80h] [ebp+1Eh]
  _BYTE *v277; // [esp+84h] [ebp+22h]
  int v278; // [esp+88h] [ebp+26h]
  unsigned __int16 v279; // [esp+8Ch] [ebp+2Ah]
  char l; // [esp+90h] [ebp+2Eh]
  char v281; // [esp+94h] [ebp+32h]
  char v282; // [esp+98h] [ebp+36h]
  char v283; // [esp+9Ch] [ebp+3Ah]
  char k; // [esp+A0h] [ebp+3Eh]
  char v285; // [esp+A4h] [ebp+42h]
  char i; // [esp+A8h] [ebp+46h]
  char jj; // [esp+ACh] [ebp+4Ah]
  char m; // [esp+B0h] [ebp+4Eh]
  char v289; // [esp+B4h] [ebp+52h]
  char n; // [esp+B8h] [ebp+56h]
  char ii; // [esp+BCh] [ebp+5Ah]
  char kk; // [esp+C0h] [ebp+5Eh]
  char v293; // [esp+C4h] [ebp+62h]

  byte_F2CC7 = *(_BYTE *)(dword_D41A0 + 8587);
  byte_D4320 = *(_BYTE *)(dword_D41A0 + 196308) != 0;
  dword_F2C60 = (signed int)(unsigned __int16)dword_DE568 >> 1;
  word_F2CC4 = a3;
  word_F2CC0 = a5 & 0x7FF;
  word_F2CC2 = a4;
  v9 = (a5 & 0x7FF) + 256;
  dword_F2CA0 = a6;
  v10 = dword_DBB50[v9];
  dword_F2CB0 = dword_D4324 + ((signed int)(unsigned __int16)dword_DE564 >> 1);
  dword_F2C5C = v10;
  v11 = dword_DB350[v9];
  v12 = ((((a5 & 0x7FF) + 256) & 0x1FF) - 256) & 0x7FF;
  v276 = (v9 >> 9) & 3;
  v274 = off_DBF50[v12];
  dword_F2C7C = v11;
  v13 = dword_DB750[v12];
  sub_3B560(-a8 & 0x7FF);
  dword_F2C80 = 7
              * sub_7277A(
                  (unsigned __int16)dword_DE564 * (unsigned __int16)dword_DE564
                + (unsigned __int16)dword_DE568 * (unsigned __int16)dword_DE568)
              * a9 >> 11;
  v277 = (char *)&unk_D4328 + 10 * v276;
  switch ( (unsigned __int8)a4 )
  {
    case 0u:
      a2 = (unsigned __int8)a4 - 256;
      a1 = -(unsigned __int8)a3 - 4864;
      break;
    case 1u:
      a1 = -(unsigned __int8)a4 - 4864;
      a2 = -(unsigned __int8)a3;
      break;
    case 2u:
      a1 = (unsigned __int8)a3 - 4864;
      a2 = -(unsigned __int8)a4;
      break;
    case 3u:
      a1 = (unsigned __int8)a4 - 4864;
      a2 = (unsigned __int8)a3 - 256;
      break;
    default:
      break;
  }
  v14 = 40;
  v15 = dword_E9C38;
  do
  {
    v273 = a1 * v13 >> 16;
    v16 = 21;
    v272 = a1 * (signed int)v274 >> 16;
    while ( v16 )
    {
      *(_DWORD *)v15 = v272;
      *(_DWORD *)(v15 + 12) = v273;
      if ( a1 < 0 )
        *(_WORD *)(v15 + 38) = 0;
      else
        *(_WORD *)(v15 + 38) = 4;
      v15 += 1760;
      --v16;
    }
    v15 -= 36916;
    a1 += 256;
    --v14;
  }
  while ( v14 );
  v17 = 21;
  v18 = (_DWORD *)dword_E9C38;
  while ( v17 )
  {
    v271 = a2 * v13 >> 16;
    v19 = 40;
    v20 = a2 * (signed int)v274 >> 16;
    while ( v19 )
    {
      *v18 -= v271;
      v21 = v18[3];
      v18 += 11;
      --v19;
      *(v18 - 8) = v20 + v21;
    }
    a2 += 256;
    --v17;
  }
  dword_F2C74 = 26214400;
  v278 = dword_E9C38;
  dword_F2C68 = 8912896;
  v22 = *v277;
  dword_F2CA8 = a7 * (unsigned __int16)dword_DE564 >> 8;
  LOBYTE(v279) = v22 + HIBYTE(a3);
  HIBYTE(v279) = v277[1] + HIBYTE(a4);
  v23 = a8 & 0x7FF;
  v24 = dword_DB750[v23];
  v25 = (_DWORD *)14745600;
  dword_F2C64 = (int)off_DBF50[v23];
  dword_F2C78 = 23658496;
  dword_F2C54 = v24;
  LOBYTE(v24) = *(_BYTE *)(dword_D41A0 + 8588);
  dword_F2C6C = 14745600;
  if ( !(_BYTE)v24 || byte_D41B6 )
  {
    v26 = dword_DE564;
    v27 = dword_DE560 - (unsigned __int16)dword_DE564;
    v28 = (v26 - (__CFSHL__((signed int)v26 >> 31, 2) + 4 * ((signed int)v26 >> 31))) >> 2;
    v29 = dword_DE568;
    v25 = (_DWORD *)dword_DE558;
    v30 = (v26 - (__CFSHL__((signed int)v26 >> 31, 2) + 4 * ((signed int)v26 >> 31))) >> 2;
    LOBYTE(v28) = word_D4B7C;
    BYTE1(v28) = word_D4B7C;
    v31 = v28;
    v32 = v28 << 16;
    LOWORD(v32) = v31;
    do
    {
      memset32(v25, v32, v30);
      v25 = (_DWORD *)((char *)v25 + 4 * v30 + v27);
      --v29;
    }
    while ( v29 );
  }
  else
  {
    sub_40950(a8);
  }
  if ( byte_D41B6 )
  {
    for ( i = 21; ; --i )
    {
      if ( !i )
      {
        v46 = 840;
        v47 = dword_E9C38;
        while ( v46 )
        {
          v48 = ((*(_DWORD *)(v47 + 16) * dword_F2C64 - dword_F2C54 * *(_DWORD *)(v47 + 20)) >> 16) + dword_F2CB0;
          v269 = ((*(_DWORD *)(v47 + 16) * dword_F2C64 - dword_F2C54 * *(_DWORD *)(v47 + 28)) >> 16) + dword_F2CB0;
          v49 = *(_DWORD *)(v47 + 16) * dword_F2C54;
          v268 = dword_F2C60 - ((v49 + dword_F2C64 * *(_DWORD *)(v47 + 20)) >> 16);
          v50 = dword_F2C60 - ((v49 + dword_F2C64 * *(_DWORD *)(v47 + 28)) >> 16);
          *(_DWORD *)(v47 + 16) = v48;
          v51 = v50;
          v52 = v268;
          *(_DWORD *)(v47 + 28) = v51;
          *(_DWORD *)(v47 + 20) = v52;
          v53 = *(_DWORD *)(v47 + 16);
          *(_DWORD *)(v47 + 24) = v269;
          if ( v53 >= 0 )
          {
            if ( (signed int)(unsigned __int16)dword_DE564 <= *(_DWORD *)(v47 + 16) )
              *(_BYTE *)(v47 + 38) |= 0x10u;
          }
          else
          {
            *(_BYTE *)(v47 + 38) |= 8u;
          }
          v54 = *(_DWORD *)(v47 + 20);
          if ( v54 >= 0 )
          {
            if ( (unsigned __int16)dword_DE568 <= v54 )
              *(_BYTE *)(v47 + 38) |= 0x40u;
          }
          else
          {
            *(_BYTE *)(v47 + 38) |= 0x20u;
          }
          if ( *(_DWORD *)(v47 + 24) >= 0 )
          {
            if ( (signed int)(unsigned __int16)dword_DE564 <= *(_DWORD *)(v47 + 24) )
              *(_BYTE *)(v47 + 39) |= 2u;
          }
          else
          {
            *(_BYTE *)(v47 + 39) |= 1u;
          }
          v55 = *(_DWORD *)(v47 + 28);
          if ( v55 >= 0 )
          {
            if ( (unsigned __int16)dword_DE568 <= v55 )
              *(_BYTE *)(v47 + 39) |= 8u;
          }
          else
          {
            *(_BYTE *)(v47 + 39) |= 4u;
          }
          v47 += 44;
          --v46;
        }
        LOBYTE(v56) = 20;
        v57 = dword_E9C38 + 35200;
        v281 = 20;
        do
        {
          v58 = 39;
          for ( j = v57; ; j = v80 + 44 )
          {
            v293 = v58;
            if ( !v58 )
              break;
            v263 = *(_DWORD *)(j + 24);
            v264 = *(_DWORD *)(j + 28);
            v56 = *(_DWORD *)(j + 32);
            j += 44;
            v267 = v56;
            v60 = *(_BYTE *)(j - 6);
            v61 = *(_BYTE *)(j - 6);
            if ( *(_BYTE *)(j + 38) & 4 )
              break;
            v258 = *(_DWORD *)(j + 24);
            v259 = *(_DWORD *)(j + 28);
            v262 = *(_DWORD *)(j + 32);
            v62 = *(_BYTE *)(j + 38);
            v253 = *(_DWORD *)(j - 1736);
            v254 = *(_DWORD *)(j - 1732);
            v257 = *(_DWORD **)(j - 1728);
            v63 = *(_BYTE *)(j - 1722);
            v64 = v63 | v62 | v60;
            v65 = v63 & v62 & v61;
            v248 = *(_DWORD *)(j - 1780);
            v249 = *(_DWORD *)(j - 1776);
            v252 = *(_DWORD *)(j - 1772);
            v66 = *(_BYTE *)(j - 1766);
            v67 = v66 | v64;
            v68 = j - 1804 + 1760;
            if ( (v66 & v65 & 0x80u) == 0 )
            {
              if ( *(_BYTE *)(v68 + 39) & 0x10 )
              {
                byte_E126D = 7;
                byte_E126C = ((signed int)v257 + v262 + v267 + v252) >> 18;
              }
              else
              {
                byte_E126D = 5;
              }
              if ( !(v67 & 2) )
              {
                v69 = 0;
                if ( !(v69 & 0xF00) )
                {
                  LOBYTE(v69) = *(_BYTE *)(v68 + 42);
                  v70 = (int *)((char *)&unk_D4350 + 32 * v69);
                  v265 = *v70;
                  v266 = v70[1];
                  v260 = v70[2];
                  v261 = v70[3];
                  v255 = v70[4];
                  v256 = v70[5];
                  v250 = v70[6];
                  v251 = v70[7];
                  dword_DE55C = dword_DDF54;
                  byte_E126D = 5;
                  if ( *(_BYTE *)(v68 + 38) & 1 )
                  {
                    sub_B6253(&v263, &v248, &v258);
                    sub_B6253(&v248, &v253, &v258);
                  }
                  else
                  {
                    sub_B6253(&v263, &v253, &v258);
                    sub_B6253(&v263, &v248, &v253);
                  }
                }
              }
            }
            v263 = *(_DWORD *)(v68 + 16);
            v264 = *(_DWORD *)(v68 + 20);
            v56 = *(_DWORD *)(v68 + 32);
            j = v68 + 44;
            v267 = v56;
            v71 = *(_BYTE *)(j - 6);
            v72 = *(_BYTE *)(j - 6);
            if ( *(_BYTE *)(j + 38) & 4 )
              break;
            v258 = *(_DWORD *)(j + 16);
            v259 = *(_DWORD *)(j + 20);
            v262 = *(_DWORD *)(j + 32);
            v73 = *(_BYTE *)(j + 38);
            v253 = *(_DWORD *)(j - 1744);
            v254 = *(_DWORD *)(j - 1740);
            v257 = *(_DWORD **)(j - 1728);
            v74 = *(_BYTE *)(j - 1722);
            v75 = v74 | v73 | v71;
            v76 = v74 & v73 & v72;
            v248 = *(_DWORD *)(j - 1788);
            v249 = *(_DWORD *)(j - 1784);
            v56 = *(_DWORD *)(j - 1772);
            v252 = *(_DWORD *)(j - 1772);
            v77 = *(_BYTE *)(j - 1766);
            v78 = v77 | v75;
            v79 = v77 & v76;
            v80 = j - 1804 + 1760;
            if ( v79 >= 0 )
            {
              if ( *(_BYTE *)(v80 + 39) & 0x10 )
              {
                byte_E126D = 7;
                v56 = ((signed int)v257 + v262 + v267 + v252) >> 18;
                byte_E126C = v56;
              }
              else
              {
                byte_E126D = 5;
              }
              if ( !(v78 & 2) && !(v79 & 0x78) )
              {
                v81 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v80 + 42));
                v265 = *v81;
                v266 = v81[1];
                v260 = v81[2];
                v261 = v81[3];
                v255 = v81[4];
                v256 = v81[5];
                v250 = v81[6];
                v251 = v81[7];
                dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v80 + 41)];
                if ( *(_BYTE *)(v80 + 38) & 1 )
                {
                  sub_B6253(&v263, &v258, &v248);
                  v56 = (int)&v248;
                  sub_B6253(&v248, &v258, &v253);
                }
                else
                {
                  sub_B6253(&v263, &v258, &v253);
                  v56 = (int)&v263;
                  sub_B6253(&v263, &v253, &v248);
                }
              }
              if ( *(_WORD *)(v80 + 36) )
                LOBYTE(v56) = sub_3E360(v57, v80);
            }
            v58 = v293 - 1;
          }
          if ( v293 )
          {
            v82 = j - 44;
            v83 = v57 + 1672;
            do
            {
              v263 = *(_DWORD *)(v83 + 24);
              v264 = *(_DWORD *)(v83 + 28);
              v267 = *(_DWORD *)(v83 + 32);
              v84 = *(_BYTE *)(v83 + 38);
              v258 = *(_DWORD *)(v83 + 68);
              v259 = *(_DWORD *)(v83 + 72);
              v262 = *(_DWORD *)(v83 + 76);
              v85 = *(_BYTE *)(v83 + 82);
              v253 = *(_DWORD *)(v83 - 1692);
              v254 = *(_DWORD *)(v83 - 1688);
              v86 = v84;
              v257 = *(_DWORD **)(v83 - 1684);
              v87 = *(_BYTE *)(v83 - 1678);
              v88 = v87 | v85 | v84;
              v89 = v87 & v85 & v86;
              v248 = *(_DWORD *)(v83 - 1736);
              v249 = *(_DWORD *)(v83 - 1732);
              v90 = *(_DWORD *)(v83 - 1728);
              v91 = v83 + 44;
              v252 = v90;
              v92 = *(_BYTE *)(v91 - 1766);
              v93 = v92 | v88;
              v94 = v91 - 1804 + 1760;
              if ( (v92 & v89 & 0x80u) == 0 )
              {
                if ( *(_BYTE *)(v94 + 39) & 0x10 )
                {
                  byte_E126D = 7;
                  byte_E126C = ((signed int)v257 + v262 + v267 + v252) >> 18;
                }
                else
                {
                  byte_E126D = 5;
                }
                if ( !(v93 & 2) )
                {
                  v95 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v94 + 42));
                  v265 = *v95;
                  v266 = v95[1];
                  v260 = v95[2];
                  v261 = v95[3];
                  v255 = v95[4];
                  v256 = v95[5];
                  v250 = v95[6];
                  v251 = v95[7];
                  dword_DE55C = dword_DDF54;
                  v96 = *(_BYTE *)(v94 + 38);
                  byte_E126D = 5;
                  if ( v96 & 1 )
                  {
                    sub_B6253(&v263, &v248, &v258);
                    sub_B6253(&v248, &v253, &v258);
                  }
                  else
                  {
                    sub_B6253(&v263, &v253, &v258);
                    sub_B6253(&v263, &v248, &v253);
                  }
                }
              }
              v263 = *(_DWORD *)(v94 + 16);
              v264 = *(_DWORD *)(v94 + 20);
              v267 = *(_DWORD *)(v94 + 32);
              v97 = *(_BYTE *)(v94 + 38);
              v258 = *(_DWORD *)(v94 + 60);
              v259 = *(_DWORD *)(v94 + 64);
              v262 = *(_DWORD *)(v94 + 76);
              v98 = v97;
              v99 = *(_BYTE *)(v94 + 82);
              v100 = v99 | v97;
              v101 = v99 & v98;
              v253 = *(_DWORD *)(v94 - 1700);
              v254 = *(_DWORD *)(v94 - 1696);
              v257 = *(_DWORD **)(v94 - 1684);
              v102 = *(_BYTE *)(v94 - 1678);
              v248 = *(_DWORD *)(v94 - 1744);
              v103 = *(_DWORD *)(v94 - 1740);
              v104 = v94 + 44;
              v249 = v103;
              v56 = *(_DWORD *)(v104 - 1772);
              v252 = *(_DWORD *)(v104 - 1772);
              BYTE1(v56) = *(_BYTE *)(v104 - 1766);
              v105 = BYTE1(v56) | v102 | v100;
              v106 = BYTE1(v56) & v102 & v101;
              v107 = v104 - 1804 + 1760;
              if ( v106 >= 0 )
              {
                if ( *(_BYTE *)(v107 + 39) & 0x10 )
                {
                  byte_E126D = 7;
                  v56 = ((signed int)v257 + v262 + v267 + v252) >> 18;
                  byte_E126C = v56;
                }
                else
                {
                  byte_E126D = 5;
                }
                if ( !(v105 & 2) && !(v106 & 0x78) )
                {
                  v108 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v107 + 42));
                  v265 = *v108;
                  v266 = v108[1];
                  v260 = v108[2];
                  v261 = v108[3];
                  v255 = v108[4];
                  v256 = v108[5];
                  v250 = v108[6];
                  v251 = v108[7];
                  LOBYTE(v108) = *(_BYTE *)(v107 + 38);
                  dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v107 + 41)];
                  if ( (unsigned __int8)v108 & 1 )
                  {
                    sub_B6253(&v263, &v258, &v248);
                    v56 = (int)&v248;
                    sub_B6253(&v248, &v258, &v253);
                  }
                  else
                  {
                    sub_B6253(&v263, &v258, &v253);
                    v56 = (int)&v263;
                    sub_B6253(&v263, &v253, &v248);
                  }
                }
                if ( *(_WORD *)(v107 + 36) )
                  LOBYTE(v56) = sub_3E360(v57, v107);
              }
              v83 = v107 - 44;
            }
            while ( v83 >= v82 );
          }
          v57 -= 1760;
          --v281;
        }
        while ( v281 );
        return v56;
      }
      for ( k = 40; k; --k )
      {
        v33 = ((unsigned __int8)byte_12B4E0[v279] << 8) + 128;
        v34 = *(_DWORD *)(v278 + 12);
        v35 = v34 * v34 + *(_DWORD *)v278 * *(_DWORD *)v278;
        *(_WORD *)(v278 + 36) = 0;
        if ( v34 <= -256 || v35 >= dword_F2C74 )
        {
          *(_BYTE *)(v278 + 38) |= 2u;
          goto LABEL_46;
        }
        if ( v34 < 128 )
          v34 = 128;
        *(_DWORD *)(v278 + 16) = dword_F2C80 * *(_DWORD *)v278 / v34;
        v36 = v279;
        *(_DWORD *)(v278 + 4) = 32 * (unsigned __int8)byte_11B4E0[v279] - a6;
        *(_DWORD *)(v278 + 8) = ((unsigned __int8)byte_14B4E0[v36] << 15 >> 10) - a6;
        v37 = 0;
        if ( !byte_10B4E0[v36] )
        {
          v38 = 32 * *(unsigned int *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248);
          v37 = (dword_DB750[(v38 + (HIBYTE(v279) << 7)) & 0x7FF] >> 8)
              * (dword_DB750[(((unsigned __int8)v279 << 7) + v38) & 0x7FF] >> 8);
          *(_DWORD *)(v278 + 4) -= v37 >> 13;
          if ( v33 >= 14464 )
            v37 = 0;
        }
        v39 = (v33 << 8) + 8 * v37;
        if ( v35 <= dword_F2C6C )
          goto LABEL_39;
        if ( v35 < dword_F2C78 )
        {
          v39 = v39 * (signed __int64)(dword_F2C78 - v35) / dword_F2C68;
LABEL_39:
          *(_DWORD *)(v278 + 32) = v39;
          goto LABEL_40;
        }
        *(_DWORD *)(v278 + 32) = 0;
LABEL_40:
        if ( byte_13B4E0[v279] & 8 )
          *(_BYTE *)(v278 + 38) |= 0x80u;
        v40 = dword_F2C80;
        v41 = v278;
        *(_DWORD *)(v278 + 20) = dword_F2CA8 + dword_F2C80 * *(_DWORD *)(v278 + 4) / v34;
        *(_DWORD *)(v278 + 28) = dword_F2CA8 + v40 * *(_DWORD *)(v41 + 8) / v34;
        LOBYTE(v42) = v277[2] + v279;
        HIBYTE(v42) = v277[3] + HIBYTE(v279);
        v43 = v278;
        *(_BYTE *)(v278 + 41) = byte_10B4E0[v42];
        if ( *(_BYTE *)(dword_D41A0 + 8601) )
          *(_BYTE *)(v43 + 39) |= 0x10u;
        *(_BYTE *)(v278 + 43) = byte_D41D8[*(unsigned __int8 *)(v278 + 41)];
        *(_BYTE *)(v278 + 42) = v276 + (((signed int)(unsigned __int8)byte_13B4E0[v42] >> 2) & 0x1C);
        LOBYTE(v42) = v277[4] + v42;
        HIBYTE(v42) += v277[5];
        *(_WORD *)(v278 + 36) = word_15B4E0[v42];
LABEL_46:
        v44 = v277;
        *(_WORD *)(v278 + 38) |= ((_BYTE)v279 + HIBYTE(v279)) & 1;
        LOBYTE(v279) = v44[8] + v279;
        HIBYTE(v279) += v277[9];
        v278 += 44;
      }
      v45 = v277[6] + v279;
      HIBYTE(v279) += v277[7];
      LOBYTE(v279) = v45;
    }
  }
  if ( *(_BYTE *)(dword_D41A0 + 8586) )
  {
    for ( l = 21; ; --l )
    {
      if ( !l )
      {
        v123 = 840;
        v124 = dword_E9C38;
        while ( v123 )
        {
          v125 = ((dword_F2C64 * *(_DWORD *)(v124 + 16) - dword_F2C54 * *(_DWORD *)(v124 + 20)) >> 16) + dword_F2CB0;
          v269 = ((dword_F2C64 * *(_DWORD *)(v124 + 16) - dword_F2C54 * *(_DWORD *)(v124 + 28)) >> 16) + dword_F2CB0;
          v126 = *(_DWORD *)(v124 + 16) * dword_F2C54;
          v25 = (_DWORD *)(dword_F2C60 - ((v126 + dword_F2C64 * *(_DWORD *)(v124 + 20)) >> 16));
          v268 = dword_F2C60 - ((v126 + dword_F2C64 * *(_DWORD *)(v124 + 20)) >> 16);
          v127 = dword_F2C60 - ((v126 + dword_F2C64 * *(_DWORD *)(v124 + 28)) >> 16);
          *(_DWORD *)(v124 + 16) = v125;
          v128 = v127;
          v129 = v268;
          *(_DWORD *)(v124 + 28) = v128;
          *(_DWORD *)(v124 + 20) = v129;
          v130 = *(_DWORD *)(v124 + 16);
          *(_DWORD *)(v124 + 24) = v269;
          if ( v130 >= 0 )
          {
            if ( (signed int)(unsigned __int16)dword_DE564 <= *(_DWORD *)(v124 + 16) )
              *(_BYTE *)(v124 + 38) |= 0x10u;
          }
          else
          {
            *(_BYTE *)(v124 + 38) |= 8u;
          }
          v131 = *(_DWORD *)(v124 + 20);
          if ( v131 >= 0 )
          {
            if ( (unsigned __int16)dword_DE568 <= v131 )
              *(_BYTE *)(v124 + 38) |= 0x40u;
          }
          else
          {
            *(_BYTE *)(v124 + 38) |= 0x20u;
          }
          if ( *(_DWORD *)(v124 + 24) >= 0 )
          {
            if ( (signed int)(unsigned __int16)dword_DE564 <= *(_DWORD *)(v124 + 24) )
              *(_BYTE *)(v124 + 39) |= 2u;
          }
          else
          {
            *(_BYTE *)(v124 + 39) |= 1u;
          }
          v132 = *(_DWORD *)(v124 + 28);
          if ( v132 >= 0 )
          {
            if ( (unsigned __int16)dword_DE568 <= v132 )
              *(_BYTE *)(v124 + 39) |= 8u;
          }
          else
          {
            *(_BYTE *)(v124 + 39) |= 4u;
          }
          v124 += 44;
          --v123;
        }
        if ( a6 < 4096 )
        {
          v133 = dword_E9C38 + 35200;
          for ( m = 20; m; --m )
          {
            v134 = v133;
            for ( n = 39; n; --n )
            {
              v263 = *(_DWORD *)(v134 + 24);
              v264 = *(_DWORD *)(v134 + 28);
              v135 = *(_DWORD *)(v134 + 32);
              v134 += 44;
              v267 = v135;
              v136 = *(_BYTE *)(v134 - 6);
              if ( *(_BYTE *)(v134 + 38) & 4 )
                break;
              v258 = *(_DWORD *)(v134 + 24);
              v259 = *(_DWORD *)(v134 + 28);
              v262 = *(_DWORD *)(v134 + 32);
              v137 = *(_BYTE *)(v134 + 38);
              v253 = *(_DWORD *)(v134 - 1736);
              v254 = *(_DWORD *)(v134 - 1732);
              v257 = *(_DWORD **)(v134 - 1728);
              v138 = *(_BYTE *)(v134 - 1722) | v137 | v136;
              v248 = *(_DWORD *)(v134 - 1780);
              v139 = *(_DWORD *)(v134 - 1776);
              v140 = v134 - 1760;
              v249 = v139;
              v141 = *(_DWORD *)(v140 - 12);
              v140 -= 44;
              v252 = v141;
              v142 = *(_BYTE *)(v140 + 38);
              v143 = v140 + 1760;
              v144 = v142 | v138;
              if ( *(_BYTE *)(v143 + 41) )
              {
                if ( *(_BYTE *)(v143 + 39) & 0x10 )
                {
                  byte_E126D = 7;
                  v25 = v257;
                  byte_E126C = ((signed int)v257 + v262 + v267 + v252) >> 18;
                }
                else
                {
                  byte_E126D = 5;
                }
                if ( !(v144 & 2) )
                {
                  v145 = 0;
                  if ( !(v145 & 0xF00) )
                  {
                    LOBYTE(v145) = *(_BYTE *)(v143 + 42);
                    v146 = (int *)((char *)&unk_D4350 + 32 * v145);
                    v265 = *v146;
                    v266 = v146[1];
                    v260 = v146[2];
                    v261 = v146[3];
                    v255 = v146[4];
                    v256 = v146[5];
                    v250 = v146[6];
                    v251 = v146[7];
                    dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v143 + 41)];
                    LOBYTE(v146) = *(_BYTE *)(v143 + 38);
                    byte_E126D = 5;
                    if ( (unsigned __int8)v146 & 1 )
                    {
                      sub_B6253(&v263, &v248, &v258);
                      sub_B6253(&v248, &v253, &v258);
                    }
                    else
                    {
                      sub_B6253(&v263, &v253, &v258);
                      sub_B6253(&v263, &v248, &v253);
                    }
                  }
                }
              }
              if ( *(_WORD *)(v143 + 36) )
                sub_3FD60((int)v25, v143);
              v134 = v143 + 44;
            }
            if ( n )
            {
              v25 = (_DWORD *)(v134 - 44);
              v147 = v133 + 1672;
              do
              {
                v263 = *(_DWORD *)(v147 + 24);
                v264 = *(_DWORD *)(v147 + 28);
                v267 = *(_DWORD *)(v147 + 32);
                v148 = *(_BYTE *)(v147 + 38);
                v258 = *(_DWORD *)(v147 + 68);
                v259 = *(_DWORD *)(v147 + 72);
                v262 = *(_DWORD *)(v147 + 76);
                v149 = *(_BYTE *)(v147 + 82) | v148;
                v253 = *(_DWORD *)(v147 - 1692);
                v150 = *(_DWORD *)(v147 - 1688);
                v151 = v147 + 44;
                v254 = v150;
                v152 = *(_DWORD *)(v151 - 1728);
                v151 -= 1760;
                v257 = (_DWORD *)v152;
                v153 = *(_BYTE *)(v151 + 38);
                v248 = *(_DWORD *)(v151 - 20);
                v154 = *(_DWORD *)(v151 - 16);
                v151 -= 44;
                v249 = v154;
                v252 = *(_DWORD *)(v151 + 32);
                LOBYTE(v154) = *(_BYTE *)(v151 + 38);
                v155 = v151 + 1760;
                v156 = v154 | v153 | v149;
                if ( *(_BYTE *)(v155 + 41) )
                {
                  if ( *(_BYTE *)(v155 + 39) & 0x10 )
                  {
                    byte_E126D = 7;
                    byte_E126C = ((signed int)v257 + v262 + v267 + v252) >> 18;
                  }
                  else
                  {
                    byte_E126D = 5;
                  }
                  if ( !(v156 & 2) )
                  {
                    v157 = 0;
                    if ( !(v157 & 0xF00) )
                    {
                      LOBYTE(v157) = *(_BYTE *)(v155 + 42);
                      v158 = (int *)((char *)&unk_D4350 + 32 * v157);
                      v265 = *v158;
                      v266 = v158[1];
                      v260 = v158[2];
                      v261 = v158[3];
                      v255 = v158[4];
                      v256 = v158[5];
                      v250 = v158[6];
                      v251 = v158[7];
                      v159 = *(unsigned __int8 *)(v155 + 41);
                      byte_E126D = 5;
                      BYTE1(v158) = *(_BYTE *)(v155 + 38);
                      dword_DE55C = dword_DDF50[v159];
                      if ( BYTE1(v158) & 1 )
                      {
                        sub_B6253(&v263, &v248, &v258);
                        sub_B6253(&v248, &v253, &v258);
                      }
                      else
                      {
                        sub_B6253(&v263, &v253, &v258);
                        sub_B6253(&v263, &v248, &v253);
                      }
                    }
                  }
                }
                if ( *(_WORD *)(v155 + 36) )
                  sub_3FD60((int)v25, v155);
                v147 = v155 - 44;
              }
              while ( v147 >= (unsigned int)v25 );
            }
            v133 -= 1760;
          }
        }
        v160 = dword_E9C38 + 35200;
        v282 = 20;
        do
        {
          v161 = v160;
          for ( ii = 39; ii; --ii )
          {
            v263 = *(_DWORD *)(v161 + 16);
            v264 = *(_DWORD *)(v161 + 20);
            v162 = *(_DWORD *)(v161 + 32);
            v161 += 44;
            v267 = v162;
            v163 = *(_BYTE *)(v161 - 6);
            v164 = *(_BYTE *)(v161 - 6);
            if ( *(_BYTE *)(v161 + 38) & 4 )
              break;
            v258 = *(_DWORD *)(v161 + 16);
            v259 = *(_DWORD *)(v161 + 20);
            v262 = *(_DWORD *)(v161 + 32);
            v165 = *(_BYTE *)(v161 + 38);
            v166 = v165 | v163;
            v167 = v165 & v164;
            v253 = *(_DWORD *)(v161 - 1744);
            v254 = *(_DWORD *)(v161 - 1740);
            v168 = *(_DWORD *)(v161 - 1728);
            v169 = v161 - 1760;
            v257 = (_DWORD *)v168;
            v170 = *(_BYTE *)(v169 + 38);
            v248 = *(_DWORD *)(v169 - 28);
            v171 = *(_DWORD *)(v169 - 24);
            v169 -= 44;
            v249 = v171;
            v252 = *(_DWORD *)(v169 + 32);
            BYTE1(v171) = *(_BYTE *)(v169 + 38);
            v172 = v169 + 1760;
            v173 = BYTE1(v171) | v170 | v166;
            v174 = BYTE1(v171) & v170 & v167;
            if ( *(_BYTE *)(v172 + 38) >= 0 )
            {
              if ( *(_BYTE *)(v172 + 39) & 0x10 )
              {
                byte_E126D = 7;
                byte_E126C = ((signed int)v257 + v262 + v267 + v252) >> 18;
              }
              else
              {
                byte_E126D = 5;
              }
              if ( !(v173 & 2) && !(v174 & 0x78) )
              {
                v176 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v172 + 42));
                v265 = *v176;
                v266 = v176[1];
                v260 = v176[2];
                v261 = v176[3];
                v255 = v176[4];
                v256 = v176[5];
                v250 = v176[6];
                v251 = v176[7];
                dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v172 + 41)];
                if ( *(_BYTE *)(v172 + 38) & 1 )
                {
                  sub_B6253(&v263, &v258, &v248);
                  sub_B6253(&v248, &v258, &v253);
                }
                else
                {
                  sub_B6253(&v263, &v258, &v253);
                  sub_B6253(&v263, &v253, &v248);
                }
              }
            }
            else
            {
              byte_E126D = 26;
              if ( !(v173 & 2) && !(v174 & 0x78) )
              {
                v175 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v172 + 42));
                v265 = *v175;
                v266 = v175[1];
                v260 = v175[2];
                v261 = v175[3];
                v255 = v175[4];
                v256 = v175[5];
                v250 = v175[6];
                v251 = v175[7];
                dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v172 + 41)];
                if ( *(_BYTE *)(v172 + 38) & 1 )
                {
                  sub_B6253(&v263, &v258, &v248);
                  sub_B6253(&v248, &v258, &v253);
                }
                else
                {
                  sub_B6253(&v263, &v258, &v253);
                  sub_B6253(&v263, &v253, &v248);
                }
              }
            }
            if ( *(_WORD *)(v172 + 36) )
              sub_3E360(v160, v172);
            v161 = v172 + 44;
          }
          if ( ii )
          {
            v177 = v161 - 44;
            v178 = v160 + 1672;
            do
            {
              v263 = *(_DWORD *)(v178 + 16);
              v264 = *(_DWORD *)(v178 + 20);
              v267 = *(_DWORD *)(v178 + 32);
              v179 = *(_BYTE *)(v178 + 38);
              v258 = *(_DWORD *)(v178 + 60);
              v259 = *(_DWORD *)(v178 + 64);
              v262 = *(_DWORD *)(v178 + 76);
              v180 = *(_BYTE *)(v178 + 82);
              v253 = *(_DWORD *)(v178 - 1700);
              v254 = *(_DWORD *)(v178 - 1696);
              v181 = v179;
              v257 = *(_DWORD **)(v178 - 1684);
              v182 = *(_BYTE *)(v178 - 1678);
              v183 = v182 | v180 | v179;
              v184 = v182 & v180 & v181;
              v185 = *(_DWORD *)(v178 - 1744);
              v186 = v178 + 44;
              v248 = v185;
              v187 = *(_DWORD *)(v186 - 1784);
              v186 -= 1760;
              v249 = v187;
              v188 = *(_DWORD *)(v186 - 12);
              v186 -= 44;
              v252 = v188;
              v189 = *(_BYTE *)(v186 + 38);
              v190 = v186 + 1760;
              v191 = v189 | v183;
              v192 = v189 & v184;
              if ( *(_BYTE *)(v190 + 38) >= 0 )
              {
                if ( *(_BYTE *)(v190 + 39) & 0x10 )
                {
                  byte_E126D = 7;
                  byte_E126C = ((signed int)v257 + v262 + v267 + v252) >> 18;
                }
                else
                {
                  byte_E126D = 5;
                }
                if ( !(v191 & 2) && !(v192 & 0x78) )
                {
                  v195 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v190 + 42));
                  v265 = *v195;
                  v266 = v195[1];
                  v260 = v195[2];
                  v261 = v195[3];
                  v255 = v195[4];
                  v256 = v195[5];
                  v250 = v195[6];
                  v251 = v195[7];
                  v196 = *(_BYTE *)(v190 + 38);
                  dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v190 + 41)];
                  if ( v196 & 1 )
                  {
                    sub_B6253(&v263, &v258, &v248);
                    sub_B6253(&v248, &v258, &v253);
                  }
                  else
                  {
                    sub_B6253(&v263, &v258, &v253);
                    sub_B6253(&v263, &v253, &v248);
                  }
                }
              }
              else
              {
                byte_E126D = 26;
                if ( !(v191 & 2) && !(v192 & 0x78) )
                {
                  v193 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v190 + 42));
                  v265 = *v193;
                  v266 = v193[1];
                  v260 = v193[2];
                  v261 = v193[3];
                  v255 = v193[4];
                  v256 = v193[5];
                  v250 = v193[6];
                  v251 = v193[7];
                  v194 = *(_BYTE *)(v190 + 38);
                  dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v190 + 41)];
                  if ( v194 & 1 )
                  {
                    sub_B6253(&v263, &v258, &v248);
                    sub_B6253(&v248, &v258, &v253);
                  }
                  else
                  {
                    sub_B6253(&v263, &v258, &v253);
                    sub_B6253(&v263, &v253, &v248);
                  }
                }
              }
              if ( *(_WORD *)(v190 + 36) )
                sub_3E360(v160, v190);
              v178 = v190 - 44;
            }
            while ( v178 >= v177 );
          }
          LOBYTE(v56) = v282 - 1;
          v160 -= 1760;
          --v282;
        }
        while ( v282 );
        return v56;
      }
      for ( jj = 40; jj; --jj )
      {
        v275 = ((unsigned __int8)byte_12B4E0[v279] << 8) + 128;
        v109 = *(_DWORD *)(v278 + 12);
        v110 = v109 * v109 + *(_DWORD *)v278 * *(_DWORD *)v278;
        *(_WORD *)(v278 + 36) = 0;
        if ( v109 <= -256 || v110 >= dword_F2C74 )
        {
          *(_BYTE *)(v278 + 38) |= 2u;
          goto LABEL_140;
        }
        if ( v109 < 128 )
          v109 = 128;
        *(_DWORD *)(v278 + 16) = dword_F2C80 * *(_DWORD *)v278 / v109;
        v111 = v279;
        *(_DWORD *)(v278 + 4) = 32 * (unsigned __int8)byte_11B4E0[v279] - a6;
        v112 = (unsigned __int16)*(_DWORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248) << 6;
        v270 = dword_DB750[(v112 + (HIBYTE(v279) << 7)) & 0x7FF] >> 8;
        v113 = v270 * (dword_DB750[(((unsigned __int8)v279 << 7) + v112) & 0x7FF] >> 8);
        v270 = (unsigned __int8)byte_11B4E0[v111];
        v25 = (_DWORD *)v278;
        *(_DWORD *)(v278 + 8) = -(v270 * ((v113 >> 4) + 0x8000) >> 10) - a6;
        if ( !(byte_13B4E0[v111] & 8)
          || (v114 = v25, v25 = (_DWORD *)(v25[1] - (v113 >> 10)), v115 = v275, v114[1] = v25, v115 >= 14464) )
        {
          v113 = 0;
        }
        v116 = (v275 << 8) + 8 * v113;
        if ( v110 <= dword_F2C6C )
          goto LABEL_133;
        v25 = (_DWORD *)dword_F2C78;
        if ( v110 < dword_F2C78 )
        {
          v116 = v116 * (signed __int64)(dword_F2C78 - v110) / dword_F2C68;
LABEL_133:
          *(_DWORD *)(v278 + 32) = v116;
          goto LABEL_134;
        }
        *(_DWORD *)(v278 + 32) = 0;
LABEL_134:
        v117 = v278;
        *(_DWORD *)(v278 + 20) = dword_F2CA8 + dword_F2C80 * *(_DWORD *)(v278 + 4) / v109;
        *(_DWORD *)(v278 + 28) = dword_F2CA8 + dword_F2C80 * *(_DWORD *)(v117 + 8) / v109;
        LOBYTE(v118) = v277[2] + v279;
        HIBYTE(v118) = v277[3] + HIBYTE(v279);
        v119 = byte_10B4E0[v118];
        *(_BYTE *)(v278 + 41) = v119;
        if ( byte_D427C[v119] )
          *(_BYTE *)(v278 + 38) |= 0x80u;
        if ( *(_BYTE *)(dword_D41A0 + 8601) )
          *(_BYTE *)(v278 + 39) |= 0x10u;
        v120 = v278;
        *(_BYTE *)(v278 + 43) = byte_D41D8[*(unsigned __int8 *)(v278 + 41)];
        *(_BYTE *)(v120 + 42) = v276 + (((signed int)(unsigned __int8)byte_13B4E0[v118] >> 2) & 0x1C);
        LOBYTE(v118) = v277[4] + v118;
        HIBYTE(v118) += v277[5];
        *(_WORD *)(v278 + 36) = word_15B4E0[v118];
LABEL_140:
        v121 = v277;
        *(_WORD *)(v278 + 38) |= ((_BYTE)v279 + HIBYTE(v279)) & 1;
        LOBYTE(v279) = v121[8] + v279;
        HIBYTE(v279) += v277[9];
        v278 += 44;
      }
      v122 = v277[6] + v279;
      HIBYTE(v279) += v277[7];
      LOBYTE(v279) = v122;
    }
  }
  v283 = 21;
LABEL_259:
  if ( v283 )
  {
    v285 = 40;
    while ( 1 )
    {
      if ( !v285 )
      {
        LOBYTE(v279) = v277[6] + v279;
        HIBYTE(v279) += v277[7];
        --v283;
        goto LABEL_259;
      }
      v197 = ((unsigned __int8)byte_12B4E0[v279] << 8) + 128;
      v198 = *(_DWORD *)(v278 + 12);
      v199 = v198 * v198 + *(_DWORD *)v278 * *(_DWORD *)v278;
      *(_WORD *)(v278 + 36) = 0;
      if ( v198 > -256 && v199 < dword_F2C74 )
        break;
      *(_BYTE *)(v278 + 38) |= 2u;
LABEL_256:
      v206 = v278;
      v207 = v277;
      *(_WORD *)(v278 + 38) |= ((_BYTE)v279 + HIBYTE(v279)) & 1;
      LOBYTE(v279) = v207[8] + v279;
      HIBYTE(v279) += v277[9];
      --v285;
      v278 = v206 + 44;
    }
    if ( v198 < 128 )
      v198 = 128;
    v200 = v279;
    *(_DWORD *)(v278 + 16) = dword_F2C80 * *(_DWORD *)v278 / v198;
    *(_DWORD *)(v278 + 4) = 32 * (unsigned __int8)byte_11B4E0[v200] - a6;
    v201 = (unsigned __int16)*(_DWORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248) << 6;
    v270 = dword_DB750[(v201 + (HIBYTE(v279) << 7)) & 0x7FF] >> 8;
    v202 = v270 * (dword_DB750[(((unsigned __int8)v279 << 7) + v201) & 0x7FF] >> 8);
    if ( !(byte_13B4E0[v200] & 8) || (*(_DWORD *)(v278 + 4) -= v202 >> 10, v197 >= 14464) )
      v202 = 0;
    v203 = (v197 << 8) + 8 * v202;
    if ( v199 > dword_F2C6C )
    {
      if ( v199 >= dword_F2C78 )
      {
        *(_DWORD *)(v278 + 32) = 0;
LABEL_254:
        *(_DWORD *)(v278 + 20) = dword_F2CA8 + dword_F2C80 * *(_DWORD *)(v278 + 4) / v198;
        LOBYTE(v204) = v277[2] + v279;
        HIBYTE(v204) = v277[3] + HIBYTE(v279);
        v205 = (unsigned __int8 *)v278;
        *(_BYTE *)(v278 + 41) = byte_10B4E0[v204];
        v205[43] = byte_D41D8[v205[41]];
        v205[42] = v276 + (((signed int)(unsigned __int8)byte_13B4E0[v204] >> 2) & 0x1C);
        LOBYTE(v204) = v277[4] + v204;
        HIBYTE(v204) += v277[5];
        *(_WORD *)(v278 + 36) = word_15B4E0[v204];
        goto LABEL_256;
      }
      v203 = v203 * (signed __int64)(dword_F2C78 - v199) / dword_F2C68;
    }
    *(_DWORD *)(v278 + 32) = v203;
    goto LABEL_254;
  }
  v208 = a8 & 0x7FF;
  v209 = 840;
  v210 = dword_DB750[v208];
  v211 = off_DBF50[v208];
  dword_F2C54 = v210;
  dword_F2C64 = (int)v211;
  v56 = dword_E9C38;
  while ( v209 )
  {
    v212 = dword_F2C60;
    v213 = (dword_F2C54 * *(_DWORD *)(v56 + 16) + dword_F2C64 * *(_DWORD *)(v56 + 20)) >> 16;
    *(_DWORD *)(v56 + 16) = ((*(_DWORD *)(v56 + 16) * dword_F2C64 - dword_F2C54 * *(_DWORD *)(v56 + 20)) >> 16)
                          + dword_F2CB0;
    v214 = v212 - v213;
    v215 = *(_DWORD *)(v56 + 16);
    *(_DWORD *)(v56 + 20) = v214;
    if ( v215 >= 0 )
    {
      if ( (signed int)(unsigned __int16)dword_DE564 <= *(_DWORD *)(v56 + 16) )
        *(_BYTE *)(v56 + 38) |= 0x10u;
    }
    else
    {
      *(_BYTE *)(v56 + 38) |= 8u;
    }
    v216 = *(_DWORD *)(v56 + 20);
    if ( v216 >= 0 )
    {
      if ( (unsigned __int16)dword_DE568 <= v216 )
        *(_BYTE *)(v56 + 38) |= 0x40u;
    }
    else
    {
      *(_BYTE *)(v56 + 38) |= 0x20u;
    }
    v56 += 44;
    --v209;
  }
  v217 = dword_E9C38 + 35200;
  v289 = 20;
  do
  {
    v218 = v217;
    for ( kk = 39; kk; --kk )
    {
      v263 = *(_DWORD *)(v218 + 16);
      v264 = *(_DWORD *)(v218 + 20);
      v56 = *(_DWORD *)(v218 + 32);
      v218 += 44;
      v267 = v56;
      v219 = *(_BYTE *)(v218 - 6);
      v220 = *(_BYTE *)(v218 - 6);
      if ( *(_BYTE *)(v218 + 38) & 4 )
        break;
      v258 = *(_DWORD *)(v218 + 16);
      v259 = *(_DWORD *)(v218 + 20);
      v262 = *(_DWORD *)(v218 + 32);
      v221 = *(_BYTE *)(v218 + 38);
      v222 = v221 | v219;
      v223 = v221 & v220;
      v253 = *(_DWORD *)(v218 - 1744);
      v254 = *(_DWORD *)(v218 - 1740);
      v224 = *(_DWORD *)(v218 - 1728);
      v225 = v218 - 1760;
      v257 = (_DWORD *)v224;
      v226 = *(_BYTE *)(v225 + 38);
      v248 = *(_DWORD *)(v225 - 28);
      v56 = *(_DWORD *)(v225 - 24);
      v225 -= 44;
      v249 = v56;
      v252 = *(_DWORD *)(v225 + 32);
      LOBYTE(v56) = *(_BYTE *)(v225 + 38);
      v227 = v225 + 1760;
      v228 = v56 | v226 | v222;
      v229 = v56 & v226 & v223;
      if ( *(_BYTE *)(v227 + 39) & 0x10 )
      {
        byte_E126D = 7;
        v56 = ((signed int)v257 + v262 + v267 + v252) >> 18;
        byte_E126C = v56;
      }
      else
      {
        byte_E126D = 5;
      }
      if ( !(v228 & 2) && !(v229 & 0x78) )
      {
        v230 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v227 + 42));
        v265 = *v230;
        v266 = v230[1];
        v260 = v230[2];
        v261 = v230[3];
        v255 = v230[4];
        v256 = v230[5];
        v250 = v230[6];
        v251 = v230[7];
        dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v227 + 41)];
        if ( *(_BYTE *)(v227 + 38) & 1 )
        {
          sub_B6253(&v263, &v258, &v248);
          v56 = (int)&v248;
          sub_B6253(&v248, &v258, &v253);
        }
        else
        {
          sub_B6253(&v263, &v258, &v253);
          v56 = (int)&v263;
          sub_B6253(&v263, &v253, &v248);
        }
      }
      if ( *(_WORD *)(v227 + 36) )
        LOBYTE(v56) = sub_3E360(v217, v227);
      v218 = v227 + 44;
    }
    if ( kk )
    {
      v231 = v218 - 44;
      v232 = v217 + 1672;
      do
      {
        v263 = *(_DWORD *)(v232 + 16);
        v264 = *(_DWORD *)(v232 + 20);
        v267 = *(_DWORD *)(v232 + 32);
        v233 = *(_BYTE *)(v232 + 38);
        v258 = *(_DWORD *)(v232 + 60);
        v259 = *(_DWORD *)(v232 + 64);
        v262 = *(_DWORD *)(v232 + 76);
        v234 = *(_BYTE *)(v232 + 82);
        v253 = *(_DWORD *)(v232 - 1700);
        v254 = *(_DWORD *)(v232 - 1696);
        v235 = v233;
        v257 = *(_DWORD **)(v232 - 1684);
        v236 = *(_BYTE *)(v232 - 1678);
        v237 = v236 | v234 | v233;
        v238 = v236 & v234 & v235;
        v239 = *(_DWORD *)(v232 - 1744);
        v240 = v232 + 44;
        v248 = v239;
        v241 = *(_DWORD *)(v240 - 1784);
        v240 -= 1760;
        v249 = v241;
        v56 = *(_DWORD *)(v240 - 12);
        v240 -= 44;
        v252 = v56;
        v242 = *(_BYTE *)(v240 + 38);
        v243 = v240 + 1760;
        v244 = v242 | v237;
        v245 = v242 & v238;
        if ( *(_BYTE *)(v243 + 39) & 0x10 )
        {
          byte_E126D = 7;
          v56 = ((signed int)v257 + v262 + v267 + v252) >> 18;
          byte_E126C = v56;
        }
        else
        {
          byte_E126D = 5;
        }
        if ( !(v244 & 2) && !(v245 & 0x78) )
        {
          v246 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v243 + 42));
          v265 = *v246;
          v266 = v246[1];
          v260 = v246[2];
          v261 = v246[3];
          v255 = v246[4];
          v256 = v246[5];
          v250 = v246[6];
          v251 = v246[7];
          dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v243 + 41)];
          if ( *(_BYTE *)(v243 + 38) & 1 )
          {
            sub_B6253(&v263, &v258, &v248);
            v56 = (int)&v248;
            sub_B6253(&v248, &v258, &v253);
          }
          else
          {
            sub_B6253(&v263, &v258, &v253);
            v56 = (int)&v263;
            sub_B6253(&v263, &v253, &v248);
          }
        }
        if ( *(_WORD *)(v243 + 36) )
          LOBYTE(v56) = sub_3E360(v217, v243);
        v232 = v243 - 44;
      }
      while ( v232 >= v231 );
    }
    v217 -= 1760;
    --v289;
  }
  while ( v289 );
  return v56;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// D4320: using guessed type char byte_D4320;
// D4324: using guessed type int dword_D4324;
// D4B7C: using guessed type __int16 word_D4B7C;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// DDF50: using guessed type int dword_DDF50[];
// DDF54: using guessed type int dword_DDF54;
// DE558: using guessed type int dword_DE558;
// DE55C: using guessed type int dword_DE55C;
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;
// E126C: using guessed type char byte_E126C;
// E126D: using guessed type char byte_E126D;
// E9C38: using guessed type int dword_E9C38;
// F2C54: using guessed type int dword_F2C54;
// F2C5C: using guessed type int dword_F2C5C;
// F2C60: using guessed type int dword_F2C60;
// F2C64: using guessed type int dword_F2C64;
// F2C68: using guessed type int dword_F2C68;
// F2C6C: using guessed type int dword_F2C6C;
// F2C74: using guessed type int dword_F2C74;
// F2C78: using guessed type int dword_F2C78;
// F2C7C: using guessed type int dword_F2C7C;
// F2C80: using guessed type int dword_F2C80;
// F2CA0: using guessed type int dword_F2CA0;
// F2CA4: using guessed type int dword_F2CA4;
// F2CA8: using guessed type int dword_F2CA8;
// F2CB0: using guessed type int dword_F2CB0;
// F2CC0: using guessed type __int16 word_F2CC0;
// F2CC2: using guessed type __int16 word_F2CC2;
// F2CC4: using guessed type __int16 word_F2CC4;
// F2CC7: using guessed type char byte_F2CC7;

//----- (0003E360) --------------------------------------------------------
unsigned __int16 __usercall sub_3E360@<ax>(int a1@<esi>, int a2)
{
  unsigned __int16 result; // ax
  int v3; // eax
  __int16 v4; // cx
  int v5; // ecx
  int v6; // edx
  __int16 *v7; // edi
  int v8; // ecx
  int v9; // ST18_4
  char v10; // al
  int v11; // ebx
  int v12; // eax
  int v13; // ebx
  int v14; // ebx
  int v15; // eax
  int v16; // ebx
  int v17; // ebx
  int v18; // ebx
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // edx
  int v23; // eax
  int v24; // eax
  int v25; // ebx
  int v26; // edx
  unsigned __int16 v27; // ax
  int v28; // eax
  int v29; // edx
  unsigned __int16 v30; // ax
  int v31; // eax
  int v32; // ebx
  int v33; // eax
  int v34; // edx
  int v35; // eax
  int v36; // eax
  int v37; // ebx
  int v38; // edx
  int v39; // eax
  int v40; // eax
  int v41; // eax
  int v42; // eax
  int v43; // ebx
  char v44; // ch
  unsigned __int8 v45; // al
  int v46; // ecx
  int v47; // eax
  int v48; // eax
  int v49; // ecx
  signed __int16 *v50; // ebx
  int v51; // edx
  __int16 *v52; // edi
  int v53; // ecx
  int v54; // ST1C_4
  char v55; // al
  int v56; // ebx
  int v57; // eax
  int v58; // ebx
  int v59; // ebx
  int *v60; // esi
  int v61; // ebx
  int v62; // ebx
  int v63; // eax
  int v64; // edx
  unsigned __int16 v65; // ax
  int v66; // eax
  int v67; // eax
  int v68; // eax
  int v69; // edx
  int v70; // eax
  int v71; // eax
  int v72; // ebx
  int v73; // eax
  int v74; // edx
  int v75; // eax
  int v76; // eax
  int v77; // eax
  int v78; // eax
  int v79; // ebx
  int v80; // eax
  int v81; // eax
  int v82; // ebx
  int v83; // edx
  int v84; // eax
  int v85; // eax
  int v86; // eax
  int v87; // edx
  unsigned __int16 v88; // ax
  int v89; // eax
  int v90; // ebx
  __int16 v91; // cx
  unsigned __int8 v92; // al
  char v93; // cl
  int v94; // eax
  int v95; // eax
  int v96; // [esp+0h] [ebp-20h]
  int v97; // [esp+8h] [ebp-18h]
  int v98; // [esp+10h] [ebp-10h]
  int v99; // [esp+18h] [ebp-8h]
  int v100; // [esp+1Ch] [ebp-4h]

  result = *(_WORD *)(a2 + 36);
  do
  {
    v3 = dword_EA3E4[result];
    dword_F2C70 = v3;
    if ( !(*(_BYTE *)(v3 + 12) & 0x21) )
    {
      v4 = *(_WORD *)(v3 + 78);
      v96 = (signed __int16)(*(_WORD *)(v3 + 76) - word_F2CC4);
      v97 = (signed __int16)(word_F2CC2 - v4);
      if ( byte_F2CC7 )
      {
        if ( !*(_BYTE *)(a2 + 43) && !(*(_WORD *)(v3 + 14) & 0x808) )
        {
          v98 = sub_B5C60(*(_WORD *)(v3 + 76), v4) - dword_F2CA0;
          v5 = (dword_F2C5C * v96 - dword_F2C7C * v97) >> 16;
          v99 = (dword_F2C7C * v96 + dword_F2C5C * v97) >> 16;
          v6 = v99 * v99 + v5 * v5;
          if ( v99 > 64 && v6 < dword_F2C74 )
          {
            if ( v6 <= dword_F2C6C )
              dword_F2C20 = 0x2000;
            else
              dword_F2C20 = v6 < dword_F2C78 ? 32 * (dword_F2C78 - (v99 * v99 + v5 * v5)) / dword_F2C68 << 8 : 0;
            v7 = &word_D951C[7 * *(signed __int16 *)(dword_F2C70 + 90)];
            if ( !*((_BYTE *)v7 + 10) )
            {
              v8 = v5 * dword_F2C80 / v99;
              v9 = dword_F2C80 * v98 / v99 + dword_F2CA8;
              dword_F2C30 = ((v8 * dword_F2C64 - dword_F2C54 * v9) >> 16) + dword_F2CB0;
              dword_F2C2C = dword_F2C60 - ((dword_F2C54 * v8 + v9 * dword_F2C64) >> 16);
              v10 = *((_BYTE *)v7 + 12);
              byte_F2CC6 = 0;
              switch ( v10 )
              {
                case 0:
                  v11 = (unsigned __int16)*v7;
                  if ( dword_F66F0[v11] )
                  {
                    v12 = (unsigned __int16)*v7;
                    v13 = 4 * v11;
                  }
                  else
                  {
                    if ( !sub_71520(v11) )
                      goto LABEL_178;
                    v12 = (unsigned __int16)*v7;
                    v13 = 4 * v12;
                  }
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 2 * (v12 + v13) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                  a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7];
                  goto LABEL_51;
                case 1:
                  if ( !dword_F66F0[(unsigned __int16)*v7] && !sub_71520(*v7) )
                    goto LABEL_178;
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)*v7 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                  a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7];
                  goto LABEL_51;
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                  goto LABEL_29;
                case 17:
                  v25 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
                  if ( v25 < 8 )
                  {
                    if ( dword_F66F0[v25 + (unsigned __int16)*v7] )
                    {
                      v26 = dword_D41A4;
                      v27 = *(_WORD *)(dword_F6ED0 + 10 * (v25 + (unsigned __int16)*v7) + 8);
                    }
                    else
                    {
                      if ( !sub_71520(v25 + *v7) )
                        goto LABEL_178;
                      v26 = dword_D41A4;
                      v27 = *(_WORD *)(dword_F6ED0 + 10 * (v25 + (unsigned __int16)*v7) + 8);
                    }
                    dword_F5730[v27] = *(_DWORD *)(v26 + 26);
                    a1 = *(_DWORD *)dword_F66F0[v25 + (unsigned __int16)*v7];
                    goto LABEL_51;
                  }
                  if ( dword_F66F0[(unsigned __int16)*v7 + 15 - v25] )
                  {
                    v29 = dword_D41A4;
                    v30 = *(_WORD *)(dword_F6ED0 + 10 * ((unsigned __int16)*v7 + 15 - v25) + 8);
                  }
                  else
                  {
                    if ( !sub_71520(*v7 + 15 - v25) )
                      goto LABEL_178;
                    v29 = dword_D41A4;
                    v30 = *(_WORD *)(dword_F6ED0 + 10 * ((unsigned __int16)*v7 + 15 - v25) + 8);
                  }
                  dword_F5730[v30] = *(_DWORD *)(v29 + 26);
                  a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7 + 15 - v25];
                  dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                  dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                  v31 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v99;
                  dword_F2C50 = v31;
                  dword_F2C44 = v31 * dword_F2C40 / dword_F2C38;
                  v21 = -dword_F2C40;
                  goto LABEL_72;
                case 18:
                  v32 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
                  v33 = v32 + (unsigned __int16)*v7;
                  if ( dword_F66F0[v33] )
                  {
                    v35 = *(unsigned __int16 *)(dword_F6ED0 + 10 * v33 + 8);
                    v34 = dword_D41A4;
                  }
                  else
                  {
                    if ( !sub_71520(v32 + *v7) )
                      goto LABEL_178;
                    v34 = dword_D41A4;
                    v35 = *(unsigned __int16 *)(dword_F6ED0 + 10 * (v32 + (unsigned __int16)*v7) + 8);
                  }
                  dword_F5730[v35] = *(_DWORD *)(v34 + 26);
                  a1 = *(_DWORD *)dword_F66F0[v32 + (unsigned __int16)*v7];
                  dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                  dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                  v36 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v99;
                  dword_F2C50 = v36;
                  dword_F2C44 = v36 * dword_F2C40 / dword_F2C38;
                  v21 = dword_F2C40;
                  goto LABEL_72;
                case 19:
                  v18 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
                  if ( v18 >= 8 )
                  {
                    v22 = (unsigned __int8)byte_D475C[v18];
                    v23 = v22 + (unsigned __int16)*v7;
                    if ( dword_F66F0[v23] )
                    {
                      dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v23 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                    }
                    else
                    {
                      if ( !sub_71520(*v7 + (unsigned __int8)v22) )
                        goto LABEL_178;
                      dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                      + 10 * ((unsigned __int16)*v7 + (unsigned __int8)byte_D475C[v18])
                                                      + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                    }
                    a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7 + (unsigned __int8)byte_D475C[v18]];
                    dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                    dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                    v24 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v99;
                    dword_F2C50 = v24;
                    dword_F2C44 = v24 * dword_F2C40 / dword_F2C38;
                    v21 = -dword_F2C40;
                  }
                  else
                  {
                    v19 = (unsigned __int8)byte_D475C[v18] + (unsigned __int16)*v7;
                    if ( dword_F66F0[v19] )
                    {
                      dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v19 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                    }
                    else
                    {
                      if ( !sub_71520(*v7 + (unsigned __int8)byte_D475C[v18]) )
                        goto LABEL_178;
                      dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                      + 10 * ((unsigned __int16)*v7 + (unsigned __int8)byte_D475C[v18])
                                                      + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                    }
                    a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7 + (unsigned __int8)byte_D475C[v18]];
                    dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                    dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                    v20 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v99;
                    dword_F2C50 = v20;
                    dword_F2C44 = v20 * dword_F2C40 / dword_F2C38;
                    v21 = dword_F2C40;
                  }
                  goto LABEL_72;
                case 20:
                  v37 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
                  if ( v37 >= 8 )
                  {
                    v41 = (unsigned __int16)*v7 + (unsigned __int8)byte_D476C[v37];
                    if ( !dword_F66F0[v41] )
                    {
                      if ( !sub_71520(*v7 + (unsigned __int8)byte_D476C[v37]) )
                        goto LABEL_178;
                      v41 = (unsigned __int8)byte_D476C[v37] + (unsigned __int16)*v7;
                    }
                    dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v41 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                    a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7 + (unsigned __int8)byte_D476C[v37]];
                    dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                    dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                    v42 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v99;
                    dword_F2C50 = v42;
                    dword_F2C44 = v42 * dword_F2C40 / dword_F2C38;
                    v21 = -dword_F2C40;
                  }
                  else
                  {
                    v38 = (unsigned __int8)byte_D476C[v37];
                    v39 = v38 + (unsigned __int16)*v7;
                    if ( dword_F66F0[v39] )
                    {
                      dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v39 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                    }
                    else
                    {
                      if ( !sub_71520(*v7 + (unsigned __int8)v38) )
                        goto LABEL_178;
                      dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                      + 10 * ((unsigned __int16)*v7 + (unsigned __int8)byte_D476C[v37])
                                                      + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                    }
                    a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7 + (unsigned __int8)byte_D476C[v37]];
                    dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                    dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                    v40 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v99;
                    dword_F2C50 = v40;
                    dword_F2C44 = v40 * dword_F2C40 / dword_F2C38;
                    v21 = dword_F2C40;
                  }
                  goto LABEL_72;
                case 21:
                  v14 = (unsigned __int16)*v7;
                  if ( dword_F66F0[v14] )
                  {
                    v15 = (unsigned __int16)*v7;
                    v16 = 4 * v14;
                  }
                  else
                  {
                    if ( !sub_71520(v14) )
                      goto LABEL_178;
                    v15 = (unsigned __int16)*v7;
                    v16 = 4 * v15;
                  }
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 2 * (v15 + v16) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                  a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7];
                  goto LABEL_51;
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                  byte_F2CC6 = 1;
LABEL_29:
                  v17 = (unsigned __int16)*v7 + *(unsigned __int8 *)(dword_F2C70 + 92);
                  if ( dword_F66F0[v17] )
                  {
                    dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v17 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                  }
                  else
                  {
                    if ( !sub_71520(*v7 + *(unsigned __int8 *)(dword_F2C70 + 92)) )
                      goto LABEL_178;
                    dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                    + 10
                                                    * ((unsigned __int16)*v7 + *(unsigned __int8 *)(dword_F2C70 + 92))
                                                    + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                  }
                  a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7 + *(unsigned __int8 *)(dword_F2C70 + 92)];
LABEL_51:
                  dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                  dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                  v28 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v99;
                  dword_F2C50 = v28;
                  dword_F2C44 = v28 * dword_F2C40 / dword_F2C38;
                  v21 = dword_F2C40;
LABEL_72:
                  dword_F2C34 = v21;
LABEL_73:
                  v43 = dword_F2C20;
                  v44 = *(_BYTE *)a1 | 8;
                  dword_F2C28 = a1 + 6;
                  *(_BYTE *)a1 = v44;
                  if ( v43 == 0x2000 )
                    v45 = byte_D4750[*((unsigned __int8 *)v7 + 10)];
                  else
                    v45 = byte_D4756[*((unsigned __int8 *)v7 + 10)];
                  dword_F2C24 = v45;
                  v46 = dword_F2C50 >> 2;
                  dword_F2C50 >>= 2;
                  if ( dword_F2C44 > 0 && v46 > 0 )
                  {
                    v47 = dword_F2C20 >> 2;
                    if ( byte_D4320 )
                      dword_F2C20 = 0x2000 - v47;
                    else
                      dword_F2C20 = v47 + 0x2000;
                    dword_F2C24 = 8;
                    sub_41BD3(0);
                  }
                  break;
                default:
                  goto LABEL_73;
              }
            }
          }
        }
      }
      if ( *(_BYTE *)(dword_F2C70 + 15) >= 0 )
        v48 = *(signed __int16 *)(dword_F2C70 + 80);
      else
        v48 = *(signed __int16 *)(dword_F2C70 + 80) - 160;
      v100 = (dword_F2C7C * v96 + dword_F2C5C * v97) >> 16;
      v49 = (dword_F2C5C * v96 - dword_F2C7C * v97) >> 16;
      if ( *(_BYTE *)(dword_F2C70 + 15) & 0x20 )
      {
        v50 = (signed __int16 *)((char *)&off_D404C + 22 * *(unsigned __int8 *)(dword_F2C70 + 59));
        switch ( (((*(unsigned __int16 *)(dword_EA3E4[*(unsigned __int16 *)(dword_F2C70 + 50)] + 28)
                  - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4 )
        {
          case 0:
          case 15:
            v100 -= v50[8];
            break;
          case 1:
          case 14:
            v100 -= v50[9];
            break;
          case 2:
          case 13:
            v100 -= v50[10];
            break;
          case 5:
          case 10:
            v100 += v50[10];
            break;
          case 6:
          case 9:
            v100 += v50[9];
            break;
          case 7:
          case 8:
            v100 += v50[8];
            break;
          default:
            break;
        }
      }
      v51 = v100 * v100 + v49 * v49;
      if ( v100 > 64 && v51 < dword_F2C74 )
      {
        if ( v51 <= dword_F2C6C )
        {
          dword_F2C20 = 0x2000;
        }
        else if ( v51 < dword_F2C78 )
        {
          dword_F2C20 = 32 * (dword_F2C78 - (v100 * v100 + v49 * v49)) / dword_F2C68 << 8;
        }
        else
        {
          dword_F2C20 = 0;
        }
        v52 = &word_D951C[7 * *(signed __int16 *)(dword_F2C70 + 90)];
        v53 = v49 * dword_F2C80 / v100;
        v54 = dword_F2C80 * (v48 - dword_F2CA0) / v100 + dword_F2CA8;
        dword_F2C30 = ((v53 * dword_F2C64 - dword_F2C54 * v54) >> 16) + dword_F2CB0;
        dword_F2C2C = dword_F2C60 - ((dword_F2C54 * v53 + v54 * dword_F2C64) >> 16);
        v55 = *((_BYTE *)v52 + 12);
        byte_F2CC6 = 0;
        switch ( v55 )
        {
          case 0:
            v56 = (unsigned __int16)*v52;
            if ( dword_F66F0[v56] )
            {
              v57 = (unsigned __int16)*v52;
              v58 = 4 * v56;
              goto LABEL_105;
            }
            if ( sub_71520(v56) )
            {
              v57 = (unsigned __int16)*v52;
              v58 = 4 * v57;
LABEL_105:
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 2 * (v57 + v58) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v52];
              goto LABEL_141;
            }
            break;
          case 1:
            if ( dword_F66F0[(unsigned __int16)*v52] )
            {
              dword_F5730[*(unsigned __int16 *)(10 * (unsigned __int16)*v52 + dword_F6ED0 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            else
            {
              if ( !sub_71520(*v52) )
                break;
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)*v52 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v52];
            goto LABEL_141;
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
          case 15:
          case 16:
            goto LABEL_117;
          case 17:
            v72 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
            if ( *(_BYTE *)(dword_F2C70 + 15) & 0x40 )
              v72 = (unsigned __int8)byte_D477C[v72];
            if ( v72 < 8 )
            {
              v73 = v72 + (unsigned __int16)*v52;
              if ( dword_F66F0[v73] )
              {
                v74 = dword_D41A4;
                v75 = *(unsigned __int16 *)(dword_F6ED0 + 10 * v73 + 8);
              }
              else
              {
                if ( !sub_71520(v72 + *v52) )
                  break;
                v74 = dword_D41A4;
                v75 = *(unsigned __int16 *)(dword_F6ED0 + 10 * (v72 + (unsigned __int16)*v52) + 8);
              }
              dword_F5730[v75] = *(_DWORD *)(v74 + 26);
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v52 + v72];
              goto LABEL_141;
            }
            v77 = (unsigned __int16)*v52 + 15 - v72;
            if ( dword_F66F0[v77] )
            {
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v77 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            else
            {
              if ( !sub_71520(*v52 + 15 - v72) )
                break;
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * ((unsigned __int16)*v52 + 15 - v72) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v52 + 15 - v72];
            dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
            dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
            v78 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v52[4]) / v100;
            dword_F2C50 = v78;
            dword_F2C44 = v78 * dword_F2C40 / dword_F2C38;
            v67 = -dword_F2C40;
            goto LABEL_163;
          case 18:
            v79 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
            v80 = v79 + (unsigned __int16)*v52;
            if ( dword_F66F0[v80] )
            {
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v80 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            else
            {
              if ( !sub_71520(v79 + *v52) )
                break;
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (v79 + (unsigned __int16)*v52) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            a1 = *(_DWORD *)dword_F66F0[v79 + (unsigned __int16)*v52];
            dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
            dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
            v81 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v52[4]) / v100;
            dword_F2C50 = v81;
            dword_F2C44 = v81 * dword_F2C40 / dword_F2C38;
            v67 = dword_F2C40;
            goto LABEL_163;
          case 19:
            v62 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
            if ( v62 >= 8 )
            {
              v68 = (unsigned __int16)*v52 + (unsigned __int8)byte_D475C[v62];
              if ( dword_F66F0[v68] )
              {
                v70 = *(unsigned __int16 *)(dword_F6ED0 + 10 * v68 + 8);
                v69 = dword_D41A4;
              }
              else
              {
                if ( !sub_71520(*v52 + (unsigned __int8)byte_D475C[v62]) )
                  break;
                v69 = dword_D41A4;
                v70 = *(unsigned __int16 *)(dword_F6ED0
                                          + 10 * ((unsigned __int16)*v52 + (unsigned __int8)byte_D475C[v62])
                                          + 8);
              }
              dword_F5730[v70] = *(_DWORD *)(v69 + 26);
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v52 + (unsigned __int8)byte_D475C[v62]];
              dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
              dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
              v71 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v52[4]) / v100;
              dword_F2C50 = v71;
              dword_F2C44 = v71 * dword_F2C40 / dword_F2C38;
              v67 = -dword_F2C40;
            }
            else
            {
              v63 = (unsigned __int16)*v52 + (unsigned __int8)byte_D475C[v62];
              if ( dword_F66F0[v63] )
              {
                v64 = dword_D41A4;
                v65 = *(_WORD *)(dword_F6ED0 + 10 * v63 + 8);
              }
              else
              {
                if ( !sub_71520(*v52 + (unsigned __int8)byte_D475C[v62]) )
                  break;
                v64 = dword_D41A4;
                v65 = *(_WORD *)(dword_F6ED0 + 10 * ((unsigned __int8)byte_D475C[v62] + (unsigned __int16)*v52) + 8);
              }
              dword_F5730[v65] = *(_DWORD *)(v64 + 26);
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v52 + (unsigned __int8)byte_D475C[v62]];
              dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
              dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
              v66 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v52[4]) / v100;
              dword_F2C50 = v66;
              dword_F2C44 = v66 * dword_F2C40 / dword_F2C38;
              v67 = dword_F2C40;
            }
            goto LABEL_163;
          case 20:
            v82 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
            if ( v82 >= 8 )
            {
              v86 = (unsigned __int8)byte_D476C[v82] + (unsigned __int16)*v52;
              if ( dword_F66F0[v86] )
              {
                v87 = dword_D41A4;
                v88 = *(_WORD *)(dword_F6ED0 + 10 * v86 + 8);
              }
              else
              {
                if ( !sub_71520(*v52 + (unsigned __int8)byte_D476C[v82]) )
                  break;
                v87 = dword_D41A4;
                v88 = *(_WORD *)(dword_F6ED0 + 10 * ((unsigned __int16)*v52 + (unsigned __int8)byte_D476C[v82]) + 8);
              }
              dword_F5730[v88] = *(_DWORD *)(v87 + 26);
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v52 + (unsigned __int8)byte_D476C[v82]];
              dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
              dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
              v89 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v52[4]) / v100;
              dword_F2C50 = v89;
              dword_F2C44 = v89 * dword_F2C40 / dword_F2C38;
              v67 = -dword_F2C40;
            }
            else
            {
              v83 = (unsigned __int8)byte_D476C[v82];
              v84 = v83 + (unsigned __int16)*v52;
              if ( dword_F66F0[v84] )
              {
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v84 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              else
              {
                if ( !sub_71520(*v52 + (unsigned __int8)v83) )
                  break;
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                + 10 * ((unsigned __int16)*v52 + (unsigned __int8)byte_D476C[v82])
                                                + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v52 + (unsigned __int8)byte_D476C[v82]];
              dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
              dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
              v85 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v52[4]) / v100;
              dword_F2C50 = v85;
              dword_F2C44 = v85 * dword_F2C40 / dword_F2C38;
              v67 = dword_F2C40;
            }
            goto LABEL_163;
          case 21:
            v59 = (unsigned __int16)*v52;
            if ( dword_F66F0[v59] )
            {
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v59 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            else
            {
              if ( !sub_71520(v59) )
                break;
              dword_F5730[*(unsigned __int16 *)(10 * (unsigned __int16)*v52 + dword_F6ED0 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            v60 = (int *)dword_F66F0[(unsigned __int16)*v52];
            byte_F2CC6 = 1;
            a1 = *v60;
            goto LABEL_141;
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
          case 28:
          case 29:
          case 30:
          case 31:
          case 32:
          case 33:
          case 34:
          case 35:
          case 36:
            byte_F2CC6 = 1;
LABEL_117:
            v61 = (unsigned __int16)*v52 + *(unsigned __int8 *)(dword_F2C70 + 92);
            if ( dword_F66F0[v61] )
            {
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v61 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            else
            {
              if ( !sub_71520(*v52 + *(unsigned __int8 *)(dword_F2C70 + 92)) )
                break;
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                              + 10 * ((unsigned __int16)*v52 + *(unsigned __int8 *)(dword_F2C70 + 92))
                                              + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v52 + *(unsigned __int8 *)(dword_F2C70 + 92)];
LABEL_141:
            dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
            dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
            v76 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v52[4]) / v100;
            dword_F2C50 = v76;
            dword_F2C44 = v76 * dword_F2C40 / dword_F2C38;
            v67 = dword_F2C40;
LABEL_163:
            dword_F2C34 = v67;
LABEL_164:
            v90 = dword_F2C70;
            *(_BYTE *)a1 |= 8u;
            v91 = *(_WORD *)(v90 + 14);
            dword_F2C28 = a1 + 6;
            if ( v91 & 0x380 )
            {
              v93 = *(_BYTE *)(v90 + 15);
              if ( v93 & 2 )
              {
                v94 = (unsigned __int8)byte_E88E2[3
                                                * *(signed __int16 *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(v90 + 40)]
                                                                                + 164)
                                                                    + 56)];
                dword_F2C24 = 4;
                dword_F2C3C = v94;
              }
              else if ( v93 & 4 )
              {
                v95 = (unsigned __int8)byte_E88E2[3
                                                * *(signed __int16 *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(v90 + 40)]
                                                                                + 164)
                                                                    + 56)];
                dword_F2C24 = 5;
                dword_F2C3C = v95;
              }
              else if ( *(_BYTE *)(v90 + 14) >= 0 )
              {
                if ( v93 & 1 )
                  dword_F2C24 = 3;
              }
              else
              {
                dword_F2C24 = 2;
              }
            }
            else
            {
              if ( dword_F2C20 == 0x2000 )
                v92 = byte_D4750[*((unsigned __int8 *)v52 + 10)];
              else
                v92 = byte_D4756[*((unsigned __int8 *)v52 + 10)];
              dword_F2C24 = v92;
            }
            ++dword_F2C44;
            ++dword_F2C50;
            sub_41BD3(1u);
            break;
          default:
            goto LABEL_164;
        }
      }
    }
LABEL_178:
    result = *(_WORD *)(dword_F2C70 + 22);
  }
  while ( result );
  return result;
}
// D404C: using guessed type void *off_D404C;
// D41A4: using guessed type int dword_D41A4;
// D4320: using guessed type char byte_D4320;
// D951C: using guessed type __int16 word_D951C[];
// EA3E4: using guessed type int dword_EA3E4[];
// F2C20: using guessed type int dword_F2C20;
// F2C24: using guessed type int dword_F2C24;
// F2C28: using guessed type int dword_F2C28;
// F2C2C: using guessed type int dword_F2C2C;
// F2C30: using guessed type int dword_F2C30;
// F2C34: using guessed type int dword_F2C34;
// F2C38: using guessed type int dword_F2C38;
// F2C3C: using guessed type int dword_F2C3C;
// F2C40: using guessed type int dword_F2C40;
// F2C44: using guessed type int dword_F2C44;
// F2C50: using guessed type int dword_F2C50;
// F2C54: using guessed type int dword_F2C54;
// F2C5C: using guessed type int dword_F2C5C;
// F2C60: using guessed type int dword_F2C60;
// F2C64: using guessed type int dword_F2C64;
// F2C68: using guessed type int dword_F2C68;
// F2C6C: using guessed type int dword_F2C6C;
// F2C70: using guessed type int dword_F2C70;
// F2C74: using guessed type int dword_F2C74;
// F2C78: using guessed type int dword_F2C78;
// F2C7C: using guessed type int dword_F2C7C;
// F2C80: using guessed type int dword_F2C80;
// F2CA0: using guessed type int dword_F2CA0;
// F2CA4: using guessed type int dword_F2CA4;
// F2CA8: using guessed type int dword_F2CA8;
// F2CB0: using guessed type int dword_F2CB0;
// F2CC0: using guessed type __int16 word_F2CC0;
// F2CC2: using guessed type __int16 word_F2CC2;
// F2CC4: using guessed type __int16 word_F2CC4;
// F2CC6: using guessed type char byte_F2CC6;
// F2CC7: using guessed type char byte_F2CC7;
// F6ED0: using guessed type int dword_F6ED0;

//----- (0003FD60) --------------------------------------------------------
unsigned __int16 __usercall sub_3FD60@<ax>(int a1@<edi>, int a2)
{
  unsigned __int16 result; // ax
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // ecx
  int v7; // esi
  int v8; // edx
  __int16 *v9; // esi
  int v10; // ecx
  int v11; // ST0C_4
  char v12; // al
  int v13; // ebx
  int v14; // eax
  int v15; // ebx
  int v16; // ebx
  int *v17; // edi
  int v18; // eax
  int v19; // ebx
  int v20; // edx
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // ebx
  int v27; // eax
  int v28; // eax
  int v29; // ebx
  int v30; // eax
  int v31; // eax
  int v32; // ebx
  int v33; // eax
  int v34; // eax
  int v35; // eax
  int v36; // eax
  char v37; // cl
  int v38; // eax
  unsigned __int8 v39; // al
  int v40; // [esp+0h] [ebp-Ch]
  int v41; // [esp+4h] [ebp-8h]
  int v42; // [esp+8h] [ebp-4h]

  result = *(_WORD *)(a2 + 36);
  do
  {
    if ( result < 0x3E8u )
    {
      v3 = dword_EA3E4[result];
      v41 = v3;
      if ( !(*(_BYTE *)(v3 + 12) & 0x21) )
      {
        v4 = (signed __int16)(*(_WORD *)(v3 + 76) - word_F2CC4);
        v5 = (signed __int16)(word_F2CC2 - *(_WORD *)(v3 + 78));
        v42 = -*(signed __int16 *)(v41 + 80) - dword_F2CA0;
        v6 = (v4 * dword_F2C5C - v5 * dword_F2C7C) >> 16;
        v40 = (dword_F2C7C * v4 + dword_F2C5C * v5) >> 16;
        v7 = (dword_F2C7C * v4 + dword_F2C5C * v5) >> 16;
        v8 = v40 * v40 + v6 * v6;
        if ( v7 > 64 && v8 < dword_F2C74 )
        {
          if ( v8 <= dword_F2C6C )
          {
            dword_F2C20 = 0x2000;
          }
          else if ( v8 < dword_F2C78 )
          {
            dword_F2C20 = 32 * (dword_F2C78 - (v40 * v40 + v6 * v6)) / dword_F2C68 << 8;
          }
          else
          {
            dword_F2C20 = 0;
          }
          v9 = &word_D951C[7 * *(signed __int16 *)(v41 + 90)];
          v10 = v6 * dword_F2C80 / v40;
          v11 = dword_F2C80 * v42 / v40 + dword_F2CA8;
          dword_F2C30 = ((v10 * dword_F2C64 - dword_F2C54 * v11) >> 16) + dword_F2CB0;
          dword_F2C2C = dword_F2C60 - ((dword_F2C54 * v10 + v11 * dword_F2C64) >> 16);
          v12 = *((_BYTE *)v9 + 12);
          byte_F2CC6 = 0;
          switch ( v12 )
          {
            case 0:
              v13 = (unsigned __int16)*v9;
              if ( dword_F66F0[v13] )
              {
                v14 = (unsigned __int16)*v9;
                v15 = 4 * v13;
                goto LABEL_16;
              }
              if ( sub_71520(v13) )
              {
                v14 = (unsigned __int16)*v9;
                v15 = 4 * v14;
LABEL_16:
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 2 * (v14 + v15) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v9];
                goto LABEL_47;
              }
              break;
            case 1:
              if ( !dword_F66F0[(unsigned __int16)*v9] && !sub_71520(*v9) )
                break;
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)*v9 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v9];
              goto LABEL_47;
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
              goto LABEL_26;
            case 17:
              v26 = (((*(unsigned __int16 *)(v41 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
              if ( v26 < 8 )
              {
                if ( dword_F66F0[v26 + (unsigned __int16)*v9] )
                {
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (v26 + (unsigned __int16)*v9) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                else
                {
                  if ( !sub_71520(v26 + *v9) )
                    break;
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (v26 + (unsigned __int16)*v9) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                a1 = *(_DWORD *)dword_F66F0[v26 + (unsigned __int16)*v9];
                goto LABEL_47;
              }
              if ( dword_F66F0[(unsigned __int16)*v9 + 15 - v26] )
              {
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * ((unsigned __int16)*v9 + 15 - v26) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              else
              {
                if ( !sub_71520(*v9 + 15 - v26) )
                  break;
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * ((unsigned __int16)*v9 + 15 - v26) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v9 + 15 - v26];
              dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
              dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
              v28 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v9[4]) / v40;
              dword_F2C50 = v28;
              dword_F2C44 = v28 * dword_F2C40 / dword_F2C38;
              v23 = -dword_F2C40;
              goto LABEL_69;
            case 18:
              v29 = (((*(unsigned __int16 *)(v41 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
              v30 = v29 + (unsigned __int16)*v9;
              if ( dword_F66F0[v30] )
              {
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v30 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              else
              {
                if ( !sub_71520(v29 + *v9) )
                  break;
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (v29 + (unsigned __int16)*v9) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v9 + v29];
              dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
              dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
              v31 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v9[4]) / v40;
              dword_F2C50 = v31;
              dword_F2C44 = v31 * dword_F2C40 / dword_F2C38;
              v23 = dword_F2C40;
              goto LABEL_69;
            case 19:
              v19 = (((*(unsigned __int16 *)(v41 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
              if ( v19 >= 8 )
              {
                v24 = (unsigned __int16)*v9 + (unsigned __int8)byte_D475C[v19];
                if ( !dword_F66F0[v24] )
                {
                  if ( !sub_71520(*v9 + (unsigned __int8)byte_D475C[v19]) )
                    break;
                  v24 = (unsigned __int16)*v9 + (unsigned __int8)byte_D475C[v19];
                }
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v24 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v9 + (unsigned __int8)byte_D475C[v19]];
                dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                v25 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v9[4]) / v40;
                dword_F2C50 = v25;
                dword_F2C44 = v25 * dword_F2C40 / dword_F2C38;
                v23 = -dword_F2C40;
              }
              else
              {
                v20 = (unsigned __int8)byte_D475C[v19];
                v21 = v20 + (unsigned __int16)*v9;
                if ( dword_F66F0[v21] )
                {
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v21 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                else
                {
                  if ( !sub_71520(*v9 + (unsigned __int8)v20) )
                    break;
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                  + 10 * ((unsigned __int16)*v9 + (unsigned __int8)byte_D475C[v19])
                                                  + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v9 + (unsigned __int8)byte_D475C[v19]];
                dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                v22 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v9[4]) / v40;
                dword_F2C50 = v22;
                dword_F2C44 = v22 * dword_F2C40 / dword_F2C38;
                v23 = dword_F2C40;
              }
              goto LABEL_69;
            case 20:
              v32 = (((*(unsigned __int16 *)(v41 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
              if ( v32 >= 8 )
              {
                v35 = (unsigned __int16)*v9 + (unsigned __int8)byte_D476C[v32];
                if ( dword_F66F0[v35] )
                {
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v35 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                else
                {
                  if ( !sub_71520(*v9 + (unsigned __int8)byte_D476C[v32]) )
                    break;
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                  + 10 * ((unsigned __int16)*v9 + (unsigned __int8)byte_D476C[v32])
                                                  + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                a1 = *(_DWORD *)dword_F66F0[(unsigned __int8)byte_D476C[v32] + (unsigned __int16)*v9];
                dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                v36 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v9[4]) / v40;
                dword_F2C50 = v36;
                dword_F2C44 = v36 * dword_F2C40 / dword_F2C38;
                v23 = -dword_F2C40;
              }
              else
              {
                v33 = (unsigned __int16)*v9 + (unsigned __int8)byte_D476C[v32];
                if ( dword_F66F0[v33] )
                {
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v33 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                else
                {
                  if ( !sub_71520(*v9 + (unsigned __int8)byte_D476C[v32]) )
                    break;
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                  + 10 * ((unsigned __int16)*v9 + (unsigned __int8)byte_D476C[v32])
                                                  + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v9 + (unsigned __int8)byte_D476C[v32]];
                dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                v34 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v9[4]) / v40;
                dword_F2C50 = v34;
                dword_F2C44 = v34 * dword_F2C40 / dword_F2C38;
                v23 = dword_F2C40;
              }
              goto LABEL_69;
            case 21:
              v16 = (unsigned __int16)*v9;
              if ( dword_F66F0[v16] )
              {
                dword_F5730[*(unsigned __int16 *)(10 * v16 + dword_F6ED0 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              else
              {
                if ( !sub_71520(v16) )
                  break;
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)*v9 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              v17 = (int *)dword_F66F0[(unsigned __int16)*v9];
              byte_F2CC6 = 1;
              a1 = *v17;
              goto LABEL_47;
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
              byte_F2CC6 = 1;
LABEL_26:
              v18 = *(unsigned __int8 *)(v41 + 92) + (unsigned __int16)*v9;
              if ( dword_F66F0[v18] )
              {
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v18 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              else
              {
                if ( !sub_71520(*v9 + *(unsigned __int8 *)(v41 + 92)) )
                  break;
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                + 10 * ((unsigned __int16)*v9 + *(unsigned __int8 *)(v41 + 92))
                                                + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v9 + *(unsigned __int8 *)(v41 + 92)];
LABEL_47:
              dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
              dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
              v27 = (signed __int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v9[4]) / v40;
              dword_F2C50 = v27;
              dword_F2C44 = v27 * dword_F2C40 / dword_F2C38;
              v23 = dword_F2C40;
LABEL_69:
              dword_F2C34 = v23;
LABEL_70:
              v37 = *(_BYTE *)a1 | 8;
              dword_F2C28 = a1 + 6;
              v38 = dword_F2C20;
              *(_BYTE *)a1 = v37;
              if ( v38 == 0x2000 )
                v39 = byte_D4750[*((unsigned __int8 *)v9 + 10)];
              else
                v39 = byte_D4756[*((unsigned __int8 *)v9 + 10)];
              dword_F2C24 = v39;
              ++dword_F2C44;
              ++dword_F2C50;
              sub_41BD3(2u);
              break;
            default:
              goto LABEL_70;
          }
        }
      }
    }
    result = *(_WORD *)(v41 + 22);
  }
  while ( result );
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// D951C: using guessed type __int16 word_D951C[];
// EA3E4: using guessed type int dword_EA3E4[];
// F2C20: using guessed type int dword_F2C20;
// F2C24: using guessed type int dword_F2C24;
// F2C28: using guessed type int dword_F2C28;
// F2C2C: using guessed type int dword_F2C2C;
// F2C30: using guessed type int dword_F2C30;
// F2C34: using guessed type int dword_F2C34;
// F2C38: using guessed type int dword_F2C38;
// F2C3C: using guessed type int dword_F2C3C;
// F2C40: using guessed type int dword_F2C40;
// F2C44: using guessed type int dword_F2C44;
// F2C50: using guessed type int dword_F2C50;
// F2C54: using guessed type int dword_F2C54;
// F2C5C: using guessed type int dword_F2C5C;
// F2C60: using guessed type int dword_F2C60;
// F2C64: using guessed type int dword_F2C64;
// F2C68: using guessed type int dword_F2C68;
// F2C6C: using guessed type int dword_F2C6C;
// F2C74: using guessed type int dword_F2C74;
// F2C78: using guessed type int dword_F2C78;
// F2C7C: using guessed type int dword_F2C7C;
// F2C80: using guessed type int dword_F2C80;
// F2CA0: using guessed type int dword_F2CA0;
// F2CA4: using guessed type int dword_F2CA4;
// F2CA8: using guessed type int dword_F2CA8;
// F2CB0: using guessed type int dword_F2CB0;
// F2CC0: using guessed type __int16 word_F2CC0;
// F2CC2: using guessed type __int16 word_F2CC2;
// F2CC4: using guessed type __int16 word_F2CC4;
// F2CC6: using guessed type char byte_F2CC6;
// F6ED0: using guessed type int dword_F6ED0;

//----- (00040950) --------------------------------------------------------
__int16 __cdecl sub_40950(__int16 a1)
{
  int v1; // ebx
  int v2; // edx
  int v3; // esi
  int v4; // ebx
  char *v5; // edx
  int v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // ecx
  int v10; // edx
  __int16 result; // ax
  int v12; // eax
  char *v13; // esi
  int *v14; // edi
  char *v15; // edx
  int v16; // ecx
  int v17; // ebx
  int v18; // eax
  char v19; // [esp+0h] [ebp-52Ch]
  int v20; // [esp+500h] [ebp-2Ch]
  int v21; // [esp+504h] [ebp-28h]
  int *v22; // [esp+508h] [ebp-24h]
  int v23; // [esp+50Ch] [ebp-20h]
  int v24; // [esp+510h] [ebp-1Ch]
  int v25; // [esp+514h] [ebp-18h]
  int v26; // [esp+518h] [ebp-14h]
  int v27; // [esp+51Ch] [ebp-10h]
  char v28; // [esp+520h] [ebp-Ch]
  char v29; // [esp+524h] [ebp-8h]
  unsigned __int8 v30; // [esp+528h] [ebp-4h]

  v1 = a1 & 0x7FF;
  v2 = (_DWORD)off_DBF50[v1] << 8;
  v26 = (dword_DB750[v1] << 8) / (unsigned __int16)dword_DE564;
  v3 = 0;
  v25 = v2 / (unsigned __int16)dword_DE564;
  v4 = 0;
  v29 = 0;
  v5 = &v19;
  v30 = 0;
  v6 = (unsigned __int16)dword_DE564;
  while ( v6 )
  {
    v28 = BYTE2(v3);
    *v5 = BYTE2(v3) - v29;
    v21 = BYTE2(v4);
    v20 = BYTE2(v4) - v30;
    v5 += 2;
    --v6;
    *(v5 - 1) = BYTE2(v4) - v30;
    v29 = v28;
    v30 = BYTE2(v4);
    v4 += v26;
    v3 += v25;
  }
  v7 = (-(dword_F2C54 * dword_F2CA8) >> 16) + dword_F2CB0;
  v8 = dword_F2C60 - (dword_F2C64 * dword_F2CA8 >> 16);
  v9 = v7 * v25 - v8 * v26;
  v10 = v25 * v8 + v26 * v7;
  v23 = ((unsigned __int16)word_F2CC0 << 15) - v9;
  v22 = (int *)dword_DE558;
  result = dword_DE568;
  v27 = -v10;
  v24 = (unsigned __int16)dword_DE568;
  if ( (_WORD)dword_DE568 )
  {
    do
    {
      v12 = ((unsigned __int16)dword_DE564
           - (__CFSHL__((signed int)(unsigned __int16)dword_DE564 >> 31, 2)
            + 4 * ((signed int)(unsigned __int16)dword_DE564 >> 31))) >> 2;
      v13 = &v19;
      v20 = v27 >> 16;
      v14 = v22;
      v21 = v23 >> 16;
      v15 = off_D41A8;
      BYTE1(v17) = BYTE2(v27);
      v16 = ((unsigned __int16)dword_DE564
           - (__CFSHL__((signed int)(unsigned __int16)dword_DE564 >> 31, 2)
            + 4 * ((signed int)(unsigned __int16)dword_DE564 >> 31))) >> 2;
      LOBYTE(v17) = BYTE2(v23);
      v17 = (unsigned __int16)v17;
      do
      {
        LOBYTE(v12) = v15[v17];
        LOBYTE(v17) = *v13 + v17;
        BYTE1(v17) += v13[1];
        BYTE1(v12) = v15[v17];
        LOBYTE(v17) = v13[2] + v17;
        BYTE1(v17) += v13[3];
        v18 = v12 << 16;
        LOBYTE(v18) = v15[v17];
        LOBYTE(v17) = v13[4] + v17;
        BYTE1(v17) += v13[5];
        BYTE1(v18) = v15[v17];
        LOBYTE(v17) = v13[6] + v17;
        BYTE1(v17) += v13[7];
        v12 = __ROL4__(v18, 16);
        *v14 = v12;
        ++v14;
        v13 += 8;
        --v16;
      }
      while ( v16 );
      v22 = (int *)((char *)v22 + dword_DE560);
      result = v25;
      --v24;
      v23 -= v26;
      v27 += v25;
    }
    while ( v24 );
  }
  return result;
}
// D41A8: using guessed type char *off_D41A8;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// DE558: using guessed type int dword_DE558;
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;
// F2C54: using guessed type int dword_F2C54;
// F2C60: using guessed type int dword_F2C60;
// F2C64: using guessed type int dword_F2C64;
// F2CA8: using guessed type int dword_F2CA8;
// F2CB0: using guessed type int dword_F2CB0;
// F2CC0: using guessed type __int16 word_F2CC0;

//----- (00040BF0) --------------------------------------------------------
int __cdecl sub_40BF0(int a1, int a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // eax
  int v6; // ecx
  int v7; // edx
  int result; // eax

  v4 = a1;
  v5 = a2;
  LOWORD(v6) = a3;
  LOWORD(v7) = a4;
  if ( word_180660 & 1 )
  {
    v4 = a1 >> 1;
    v5 = a2 >> 1;
    v6 = a3 >> 1;
    v7 = a4 >> 1;
  }
  dword_F2C58 = v4 + dword_18062C * v5;
  result = dword_F2C58 + dword_180628;
  sub_BCD45(dword_F2C58 + dword_180628, 0, dword_18062C, (unsigned __int16)v6, (unsigned __int16)v7);
  return result;
}
// F2C58: using guessed type int dword_F2C58;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (00040C50) --------------------------------------------------------
int __cdecl sub_40C50(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // eax
  unsigned __int16 v4; // bx
  int v5; // ST10_4
  int result; // eax

  v1 = 40 - a1;
  if ( word_180660 & 1 )
  {
    v2 = dword_18062C * (5 * v1 / 2) + 4 * v1;
    v3 = (unsigned __int16)(5 * a1);
    v4 = 8 * a1;
  }
  else
  {
    v2 = dword_18062C * (12 * v1 / 2) + 8 * v1;
    v3 = (unsigned __int16)(12 * a1);
    v4 = 16 * a1;
  }
  v5 = v3;
  result = v2 + dword_180628;
  dword_F2C58 = v2;
  sub_BCD45(v2 + dword_180628, 0, dword_18062C, v4, v5);
  return result;
}
// F2C58: using guessed type int dword_F2C58;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (00040D10) --------------------------------------------------------
int __fastcall sub_40D10(int a1)
{
  int v1; // ebx
  signed int v2; // ecx
  _BYTE *v3; // esi
  int *v4; // edi
  signed int v5; // ecx
  _BYTE *v6; // esi
  int *v7; // edi
  signed int v8; // ecx
  int *v9; // edi
  _BYTE *v10; // esi
  signed int v11; // ecx
  int *v12; // edi
  _BYTE *v13; // esi
  signed int v14; // ecx
  int *v15; // edi
  _BYTE *v16; // esi
  signed int v17; // ecx
  int *v18; // edi
  _BYTE *v19; // esi
  signed int v20; // ecx
  int *v21; // edi
  _BYTE *v22; // esi
  signed int v23; // ecx
  int *v24; // edi
  _BYTE *v25; // esi
  int result; // eax
  signed int v27; // [esp+4h] [ebp-10h]
  int v28; // [esp+8h] [ebp-Ch]
  int v29; // [esp+Ch] [ebp-8h]
  int *v30; // [esp+10h] [ebp-4h]

  __outword(0x3CEu, 0xFF08u);
  HIWORD(v1) = 0;
  v30 = (int *)&loc_A0000;
  v28 = dword_180628;
  v27 = 200;
  v29 = dword_E9C3C;
  while ( v27 )
  {
    v2 = 10;
    v3 = (_BYTE *)v28;
    v4 = v30;
    __outword(0x3C4u, 0x102u);
    do
    {
      LOBYTE(a1) = v3[8];
      LOBYTE(v1) = v3[24];
      BYTE1(a1) = v3[12];
      BYTE1(v1) = v3[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v3;
      LOBYTE(v1) = v3[16];
      BYTE1(a1) = v3[4];
      BYTE1(v1) = v3[20];
      *v4 = a1;
      v4[1] = v1;
      v3 += 32;
      v4 += 2;
      --v2;
    }
    while ( v2 );
    v5 = 10;
    v6 = (_BYTE *)v29;
    v7 = v30 + 20;
    do
    {
      LOBYTE(a1) = v6[8];
      LOBYTE(v1) = v6[24];
      BYTE1(a1) = v6[12];
      BYTE1(v1) = v6[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v6;
      LOBYTE(v1) = v6[16];
      BYTE1(a1) = v6[4];
      BYTE1(v1) = v6[20];
      *v7 = a1;
      v7[1] = v1;
      v6 += 32;
      v7 += 2;
      --v5;
    }
    while ( v5 );
    v8 = 10;
    v9 = v30;
    v10 = (_BYTE *)(v28 + 1);
    __outword(0x3C4u, 0x202u);
    do
    {
      LOBYTE(a1) = v10[8];
      LOBYTE(v1) = v10[24];
      BYTE1(a1) = v10[12];
      BYTE1(v1) = v10[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v10;
      LOBYTE(v1) = v10[16];
      BYTE1(a1) = v10[4];
      BYTE1(v1) = v10[20];
      *v9 = a1;
      v9[1] = v1;
      v10 += 32;
      v9 += 2;
      --v8;
    }
    while ( v8 );
    v11 = 10;
    v12 = v30 + 20;
    v13 = (_BYTE *)(v29 + 1);
    do
    {
      LOBYTE(a1) = v13[8];
      LOBYTE(v1) = v13[24];
      BYTE1(a1) = v13[12];
      BYTE1(v1) = v13[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v13;
      LOBYTE(v1) = v13[16];
      BYTE1(a1) = v13[4];
      BYTE1(v1) = v13[20];
      *v12 = a1;
      v12[1] = v1;
      v13 += 32;
      v12 += 2;
      --v11;
    }
    while ( v11 );
    v14 = 10;
    v15 = v30;
    v16 = (_BYTE *)(v28 + 2);
    __outword(0x3C4u, 0x402u);
    do
    {
      LOBYTE(a1) = v16[8];
      LOBYTE(v1) = v16[24];
      BYTE1(a1) = v16[12];
      BYTE1(v1) = v16[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v16;
      LOBYTE(v1) = v16[16];
      BYTE1(a1) = v16[4];
      BYTE1(v1) = v16[20];
      *v15 = a1;
      v15[1] = v1;
      v16 += 32;
      v15 += 2;
      --v14;
    }
    while ( v14 );
    v17 = 10;
    v18 = v30 + 20;
    v19 = (_BYTE *)(v29 + 2);
    do
    {
      LOBYTE(a1) = v19[8];
      LOBYTE(v1) = v19[24];
      BYTE1(a1) = v19[12];
      BYTE1(v1) = v19[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v19;
      LOBYTE(v1) = v19[16];
      BYTE1(a1) = v19[4];
      BYTE1(v1) = v19[20];
      *v18 = a1;
      v18[1] = v1;
      v19 += 32;
      v18 += 2;
      --v17;
    }
    while ( v17 );
    v20 = 10;
    v21 = v30;
    v22 = (_BYTE *)(v28 + 3);
    __outword(0x3C4u, 0x802u);
    do
    {
      LOBYTE(a1) = v22[8];
      LOBYTE(v1) = v22[24];
      BYTE1(a1) = v22[12];
      BYTE1(v1) = v22[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v22;
      LOBYTE(v1) = v22[16];
      BYTE1(a1) = v22[4];
      BYTE1(v1) = v22[20];
      *v21 = a1;
      v21[1] = v1;
      v22 += 32;
      v21 += 2;
      --v20;
    }
    while ( v20 );
    v23 = 10;
    v24 = v30 + 20;
    v25 = (_BYTE *)(v29 + 3);
    do
    {
      LOBYTE(a1) = v25[8];
      LOBYTE(v1) = v25[24];
      BYTE1(a1) = v25[12];
      BYTE1(v1) = v25[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v25;
      LOBYTE(v1) = v25[16];
      BYTE1(a1) = v25[4];
      BYTE1(v1) = v25[20];
      *v24 = a1;
      v24[1] = v1;
      v25 += 32;
      v24 += 2;
      --v23;
    }
    while ( v23 );
    a1 = v27 - 1;
    v28 += 320;
    v29 += 320;
    v30 += 40;
    --v27;
  }
  result = 0;
  memset((void *)dword_180628, 0, 0xFA00u);
  return result;
}
// E9C3C: using guessed type int dword_E9C3C;
// 180628: using guessed type int dword_180628;

//----- (00040F80) --------------------------------------------------------
void sub_40F80()
{
  int v0; // eax
  signed int v1; // ecx
  _BYTE *v2; // esi
  _BYTE *v3; // edi
  int v4; // edx
  int v5; // ebx
  int v6; // eax
  signed int v7; // ecx
  _BYTE *v8; // esi
  _BYTE *v9; // edi
  int v10; // edx
  int v11; // ebx
  char v12; // bl
  signed int v13; // [esp+0h] [ebp-10h]
  int i; // [esp+4h] [ebp-Ch]
  int v15; // [esp+8h] [ebp-8h]
  int v16; // [esp+8h] [ebp-8h]
  int v17; // [esp+Ch] [ebp-4h]
  int v18; // [esp+Ch] [ebp-4h]

  if ( *(_BYTE *)(dword_D41A0 + 8592) == 2 && !byte_D478C )
  {
    v13 = (signed int)(unsigned __int16)dword_DE564 >> 2;
    v15 = dword_E9C3C;
    v17 = dword_DE558;
    v0 = (unsigned __int16)dword_DE568 / 2;
    for ( i = (unsigned __int16)dword_DE568 / 2; i; --i )
    {
      v1 = v13;
      v2 = (_BYTE *)v15;
      v3 = (_BYTE *)v17;
      v4 = 0;
      v5 = 0;
      do
      {
        LOBYTE(v5) = v2[2];
        LOBYTE(v4) = v3[2];
        LOBYTE(v0) = byte_F0520[v4] + byte_F0620[v5];
        LOBYTE(v5) = v2[3];
        LOBYTE(v4) = v3[3];
        BYTE1(v0) = byte_F0920[v4] + byte_F0220[v5];
        v0 <<= 16;
        LOBYTE(v5) = *v2;
        LOBYTE(v4) = *v3;
        LOBYTE(v0) = byte_F0520[v4] + byte_F0620[v5];
        LOBYTE(v5) = v2[1];
        LOBYTE(v4) = v3[1];
        BYTE1(v0) = byte_F0920[v4] + byte_F0220[v5];
        *(_DWORD *)v3 = v0;
        v3 += 4;
        v2 += 4;
        --v1;
      }
      while ( v1 );
      HIWORD(v6) = HIWORD(dword_DE560);
      v7 = v13;
      v16 = dword_DE560 + v15;
      v18 = dword_DE560 + v17;
      v8 = (_BYTE *)v16;
      v9 = (_BYTE *)v18;
      v10 = 0;
      v11 = 0;
      do
      {
        LOBYTE(v11) = v8[2];
        LOBYTE(v10) = v9[2];
        LOBYTE(v6) = byte_F0820[v10] + byte_F0320[v11];
        LOBYTE(v11) = v8[3];
        LOBYTE(v10) = v9[3];
        BYTE1(v6) = byte_F0720[v10] + byte_F0420[v11];
        v6 <<= 16;
        LOBYTE(v11) = *v8;
        LOBYTE(v10) = *v9;
        LOBYTE(v6) = byte_F0820[v10] + byte_F0320[v11];
        LOBYTE(v11) = v8[1];
        LOBYTE(v10) = v9[1];
        BYTE1(v6) = byte_F0720[v10] + byte_F0420[v11];
        *(_DWORD *)v9 = v6;
        v9 += 4;
        v8 += 4;
        --v7;
      }
      while ( v7 );
      HIWORD(v0) = HIWORD(dword_DE560);
      v15 = dword_DE560 + v16;
      v17 = dword_DE560 + v18;
    }
  }
  v12 = *(_BYTE *)(dword_D41A0 + 8592);
  if ( v12 == 1 )
  {
    sub_40D10(dword_D41A0);
  }
  else if ( word_180660 & 1 )
  {
    if ( byte_D478C )
    {
      sub_BD2CB((int)&unk_F0A20);
    }
    else if ( word_180660 & 1 )
    {
      sub_90478();
    }
    else
    {
      sub_75200(480);
    }
  }
  else if ( *(_BYTE *)(dword_D41A0 + 8595) && v12 )
  {
    sub_BD3DD();
  }
  else if ( byte_D478C )
  {
    sub_BD1B6((int)&unk_F0A20);
  }
  else if ( word_180660 & 1 )
  {
    sub_90478();
  }
  else
  {
    sub_75200(480);
  }
}
// D41A0: using guessed type int dword_D41A0;
// D478C: using guessed type char byte_D478C;
// DE558: using guessed type int dword_DE558;
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;
// E9C3C: using guessed type int dword_E9C3C;
// 180660: using guessed type __int16 word_180660;

//----- (000411A0) --------------------------------------------------------
char __cdecl sub_411A0(int a1, int a2, int a3, __int16 a4, signed int a5, int a6, __int16 a7, int a8)
{
  unsigned __int16 v8; // ax
  int v9; // ecx
  int v10; // ebx
  int v11; // edx
  int v12; // ecx
  int v13; // ebx
  int v14; // edx
  int v15; // ecx
  int v16; // ebx
  int v17; // edx
  int v18; // ecx
  int v19; // ebx
  int v20; // edx
  int v21; // esi
  int v22; // edx
  int v23; // ebx
  void (__noreturn *v24)(); // edx
  int v25; // ebx
  int v26; // edi
  char result; // al
  int v28; // ebx
  void (__noreturn *v29)(); // edx
  int v30; // ebx
  int v31; // edi
  int v32; // ST2C_4
  int v33; // edx
  __int64 v34; // rax
  _BYTE *v35; // edi
  int v36; // eax
  _BYTE *v37; // esi
  signed int v38; // ecx
  unsigned __int16 v39; // bx
  unsigned __int16 v40; // dx
  unsigned __int16 v41; // bx
  unsigned __int16 v42; // dx
  _BYTE *v43; // edi
  int v44; // esi
  int v45; // ecx
  int v46; // eax
  int v47; // ebx
  int v48; // edx
  int v49; // [esp+0h] [ebp-1Ch]
  int v50; // [esp+4h] [ebp-18h]
  signed int v51; // [esp+8h] [ebp-14h]
  char v52; // [esp+Ch] [ebp-10h]
  int v53; // [esp+14h] [ebp-8h]
  int i; // [esp+18h] [ebp-4h]
  int v55; // [esp+34h] [ebp+18h]
  int v56; // [esp+38h] [ebp+1Ch]

  LOBYTE(v8) = BYTE1(a2);
  HIBYTE(v8) = BYTE1(a3);
  if ( (signed int)(unsigned __int8)a2 < 128 )
    LOBYTE(v8) = BYTE1(a2) - 1;
  if ( (signed int)(unsigned __int8)a3 < 128 )
    HIBYTE(v8) = BYTE1(a3) - 1;
  v9 = (unsigned __int8)byte_11B4E0[v8];
  LOBYTE(v8) = v8 + 2;
  v10 = v9;
  v11 = v9;
  v12 = (unsigned __int8)byte_11B4E0[v8];
  HIBYTE(v8) += 2;
  v13 = v10 - v12;
  v14 = v12 + v11;
  v15 = (unsigned __int8)byte_11B4E0[v8];
  LOBYTE(v8) = v8 - 2;
  v16 = v13 - v15;
  v17 = v14 - v15;
  v18 = (unsigned __int8)byte_11B4E0[v8];
  v19 = 2 * (v18 + v16);
  v20 = 2 * (v17 - v18);
  if ( v19 <= 100 )
  {
    if ( v19 < -100 )
      v19 = -100;
  }
  else
  {
    v19 = 100;
  }
  if ( v20 <= 100 )
  {
    if ( v20 < -100 )
      v20 = -100;
  }
  else
  {
    v20 = 100;
  }
  v21 = a4 & 0x7FF;
  dword_D4794 += (v19 - dword_D4794) >> 3;
  dword_D4798 += (v20 - dword_D4798) >> 3;
  v55 = dword_D4794 + a2;
  v56 = dword_D4798 + a3;
  if ( *(_BYTE *)(dword_D41A0 + 8595) && *(_BYTE *)(dword_D41A0 + 8592) && dword_18062C == 640 )
  {
    sub_BCD45(
      dword_180628,
      0,
      2 * dword_18062C,
      (unsigned __int16)(dword_18062C / 2 - 8),
      (unsigned __int16)(dword_180624 / 2 - 40));
    v22 = dword_DB750[v21];
    dword_D4790 = 20;
    v23 = 5 * v22;
    v24 = off_DBF50[v21];
    dword_D4324 = -5;
    v25 = 4 * v23 >> 16;
    v26 = 20 * (signed int)v24 >> 16;
    sub_3C080(v25, v21, v55 - v26, v56 - v25, v21, a5, a6, a7, a8);
    sub_BCD45(dword_180628 + dword_18062C / 2, 0, 0, 0, 0);
    dword_D4324 = 5;
    sub_3C080(v56 + v25, v21, v55 + v26, v56 + v25, v21, a5, a6, a7, a8);
    result = dword_18062C;
    dword_D4324 = 0;
    sub_BCD45(dword_180628, 0, dword_18062C, (unsigned __int16)dword_18062C, (unsigned __int16)dword_180624);
  }
  else if ( *(_BYTE *)(dword_D41A0 + 8592) != 1 || *(_BYTE *)(dword_D41A0 + 8595) )
  {
    v52 = *(_BYTE *)(dword_D41A0 + 8593);
    if ( word_180660 == 1 )
    {
      v33 = dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12);
      if ( !*(_BYTE *)(v33 + 12221) )
      {
        if ( *(_BYTE *)(dword_D41A4 + 34) )
        {
          if ( dword_E9C3C )
          {
            if ( *(_BYTE *)(dword_D41A0 + 8589) == 40 )
            {
              v34 = *(signed __int16 *)(dword_EA3E4[*(unsigned __int16 *)(v33 + 11240)] + 130);
              if ( (signed int)((HIDWORD(v34) ^ v34) - HIDWORD(v34)) > 80 )
                *(_BYTE *)(dword_D41A0 + 8593) = 1;
            }
          }
        }
      }
    }
    if ( *(_BYTE *)(dword_D41A0 + 8625) && *(_BYTE *)(dword_D41A0 + 8593) && dword_E9C3C )
    {
      v35 = (_BYTE *)dword_DE558;
      sub_BCD45(dword_E9C3C, 0, 0, 0, 0);
      sub_3C080(v55, v21, v55, v56, v21, a5, a6, a7, a8);
      sub_BCD45((int)v35, 0, 0, 0, 0);
      v51 = (signed int)(unsigned __int16)dword_DE564 >> 2;
      v49 = dword_DE560 - (unsigned __int16)dword_DE564;
      v50 = (unsigned __int16)dword_DE568;
      HIWORD(v36) = HIWORD(dword_D41A0);
      if ( *(_BYTE *)(dword_D41A0 + 8593) != 1 )
      {
        v37 = (_BYTE *)dword_E9C3C;
        goto LABEL_33;
      }
      v37 = (_BYTE *)dword_E9C3C;
      v38 = (signed int)(unsigned __int16)dword_DE564 >> 2;
      LOBYTE(v39) = *(_BYTE *)(dword_E9C3C + 2);
      HIBYTE(v39) = v35[2];
      LOBYTE(v40) = *(_BYTE *)(dword_E9C3C + 3);
      LOBYTE(v36) = byte_FAEE0[v39];
      HIBYTE(v40) = v35[3];
      BYTE1(v36) = byte_FAEE0[v40];
      v36 <<= 16;
      LOBYTE(v39) = *(_BYTE *)dword_E9C3C;
      HIBYTE(v39) = *v35;
      LOBYTE(v40) = *(_BYTE *)(dword_E9C3C + 1);
      LOBYTE(v36) = byte_FAEE0[v39];
      HIBYTE(v40) = v35[1];
      for ( BYTE1(v36) = byte_FAEE0[v40]; ; BYTE1(v36) = byte_FAEE0[v42] )
      {
        *(_DWORD *)v35 = v36;
        v35 += 4;
        v37 += 4;
        if ( !--v38 )
        {
          HIWORD(v36) = HIWORD(v49);
          v37 += v49;
          v35 += v49;
          if ( !--v50 )
            goto LABEL_44;
LABEL_33:
          v38 = v51;
        }
        HIBYTE(v41) = v37[2];
        LOBYTE(v41) = v35[2];
        HIBYTE(v42) = v37[3];
        LOBYTE(v36) = byte_FAEE0[v41];
        LOBYTE(v42) = v35[3];
        BYTE1(v36) = byte_FAEE0[v42];
        v36 <<= 16;
        HIBYTE(v41) = *v37;
        LOBYTE(v41) = *v35;
        HIBYTE(v42) = v37[1];
        LOBYTE(v36) = byte_FAEE0[v41];
        LOBYTE(v42) = v35[1];
      }
    }
    sub_3C080(v56, v21, v55, v56, v21, a5, a6, a7, a8);
    if ( *(_BYTE *)(dword_D41A0 + 8594) )
    {
      v53 = dword_DE558;
      for ( i = (unsigned __int16)dword_DE568 - 1; i; --i )
      {
        v43 = (_BYTE *)v53;
        v44 = dword_DE560;
        v45 = (unsigned __int16)dword_DE564 - 1;
        HIWORD(v46) = 0;
        HIWORD(v47) = 0;
        HIWORD(v48) = 0;
        do
        {
          LOBYTE(v46) = *v43;
          LOBYTE(v47) = v43[1];
          BYTE1(v46) = v43[v44];
          LOBYTE(v48) = byte_FAEE0[v46];
          BYTE1(v47) = v43[v44 + 1];
          BYTE1(v48) = byte_FAEE0[v47];
          *v43++ = byte_FAEE0[v48];
          --v45;
        }
        while ( v45 );
        v53 += dword_DE560;
      }
    }
LABEL_44:
    result = dword_D41A0;
    *(_BYTE *)(dword_D41A0 + 8593) = v52;
  }
  else
  {
    v28 = 5 * dword_DB750[v21];
    v29 = off_DBF50[v21];
    dword_D4790 = 20;
    dword_D4324 = dword_DE560 / 0x28u;
    v30 = 4 * v28 >> 16;
    v31 = 20 * (signed int)v29 >> 16;
    sub_3C080(v30, v21, v31 + v55, v30 + v56, v21, a5, a6, a7, a8);
    v32 = dword_DE558;
    sub_BCD45(dword_E9C3C, 0, 0, 0, 0);
    dword_D4324 = -(dword_DE560 / 0x28u);
    result = sub_3C080(v30, v21, v55 - v31, v56 - v30, v21, a5, a6, a7, a8);
    sub_BCD45(v32, 0, 0, 0, 0);
    dword_D4324 = 0;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D4324: using guessed type int dword_D4324;
// D4790: using guessed type int dword_D4790;
// D4794: using guessed type int dword_D4794;
// D4798: using guessed type int dword_D4798;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// DE558: using guessed type int dword_DE558;
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;
// E9C3C: using guessed type int dword_E9C3C;
// EA3E4: using guessed type int dword_EA3E4[];
// 180624: using guessed type int dword_180624;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (000417A0) --------------------------------------------------------
__int16 sub_417A0()
{
  sub_90810();
  sub_41A90((unsigned __int8 *)dword_EA3D8);
  return sub_6EF10(0, 640, 0, 400);
}
// EA3D8: using guessed type int dword_EA3D8;

//----- (000417D0) --------------------------------------------------------
__int16 sub_417D0()
{
  sub_906B4();
  sub_41A90((unsigned __int8 *)dword_EA3D8);
  return sub_6EF10(0, 640, 0, 800);
}
// EA3D8: using guessed type int dword_EA3D8;

//----- (00041A90) --------------------------------------------------------
char __cdecl sub_41A90(unsigned __int8 *a1)
{
  char result; // al
  unsigned __int8 *v2; // ebx
  unsigned __int16 v3; // cx
  unsigned __int8 v4; // al
  unsigned __int8 *v5; // ebx
  unsigned __int8 v6; // al

  result = -1;
  v2 = a1;
  __outbyte(0x3C6u, 0xFFu);
  v3 = 0;
  while ( v3 < 0x100u )
  {
    __outbyte(0x3C8u, v3);
    v4 = *v2;
    v5 = v2 + 1;
    __outbyte(0x3C9u, v4);
    v6 = *v5++;
    __outbyte(0x3C9u, v6);
    ++v3;
    result = *v5;
    v2 = v5 + 1;
    __outbyte(0x3C9u, result);
  }
  if ( byte_E12EC )
    result = sub_75A10(2, a1);
  return result;
}
// E12EC: using guessed type char byte_E12EC;

//----- (00041AF0) --------------------------------------------------------
char sub_41AF0()
{
  char result; // al
  unsigned __int8 *v1; // ST00_4

  if ( !byte_D47D9 )
  {
    result = dword_D41A0;
    if ( *(_BYTE *)(dword_D41A0 + 8592) )
    {
      if ( *(_BYTE *)(dword_D41A0 + 8595) && dword_DE560 == 640 )
        sub_75C50();
      byte_D47D8 = *(_BYTE *)(dword_D41A0 + 8592);
      sub_417A0();
      v1 = (unsigned __int8 *)dword_EA3D8;
      *(_BYTE *)(dword_D41A0 + 8592) = 0;
      result = sub_41A90(v1);
    }
  }
  ++byte_D47D9;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D47D8: using guessed type char byte_D47D8;
// D47D9: using guessed type char byte_D47D9;
// DE560: using guessed type int dword_DE560;
// EA3D8: using guessed type int dword_EA3D8;

//----- (00041B60) --------------------------------------------------------
char sub_41B60()
{
  char v0; // dl
  char result; // al

  if ( byte_D47D9 == 1 )
  {
    v0 = byte_D47D8;
    *(_BYTE *)(dword_D41A0 + 8592) = byte_D47D8;
    result = v0;
    if ( (unsigned __int8)v0 >= 1u && (unsigned __int8)v0 <= 1u )
      result = sub_417D0();
    byte_D47D8 = 0;
  }
  if ( byte_D47D9 )
    --byte_D47D9;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D47D8: using guessed type char byte_D47D8;
// D47D9: using guessed type char byte_D47D9;

//----- (00041BC0) --------------------------------------------------------
__int64 sub_41BC0()
{
  __int64 result; // rax

  BYTE1(result) = 0;
  byte_D47D9 = 0;
  byte_D47D8 = 0;
  return result;
}
// D47D8: using guessed type char byte_D47D8;
// D47D9: using guessed type char byte_D47D9;

//----- (00041BD3) --------------------------------------------------------
__int16 __cdecl sub_41BD3(unsigned int a1)
{
  int v1; // eax
  char *v2; // ebx
  _DWORD *v3; // esi
  _BYTE *v4; // edi
  int v5; // ecx
  char v6; // cf
  int v7; // ecx
  int v8; // ecx
  char v9; // al
  char v10; // al
  char v11; // al
  char v12; // al
  int v13; // eax
  _BYTE *v14; // ebx
  _DWORD *v15; // esi
  _BYTE *v16; // edi
  int v17; // ecx
  _BYTE *v18; // ebx
  _DWORD *v19; // esi
  _BYTE *v20; // edi
  int v21; // eax
  int v22; // ecx
  _BYTE *v23; // ebx
  _DWORD *v24; // esi
  _BYTE *v25; // edi
  int v26; // eax
  int v27; // ecx
  _BYTE *v28; // ebx
  _DWORD *v29; // esi
  _BYTE *v30; // edi
  int v31; // eax
  int v32; // ecx
  int v33; // eax
  _BYTE *v34; // ebx
  _DWORD *v35; // esi
  _BYTE *v36; // edi
  int v37; // ecx
  int v38; // edx
  _BYTE *v39; // ebx
  _DWORD *v40; // esi
  _BYTE *v41; // edi
  int v42; // eax
  int v43; // ecx
  int v44; // edx
  _BYTE *v45; // ebx
  _DWORD *v46; // esi
  _BYTE *v47; // edi
  int v48; // eax
  int v49; // ecx
  int v50; // ST4C_4
  char *v51; // ebx
  _BYTE *v52; // edx
  _DWORD *v53; // esi
  char *v54; // edi
  int v55; // ecx
  int v56; // ecx
  int v57; // ecx
  char v58; // al
  char v59; // al
  char v60; // al
  char v61; // al
  _BYTE *v62; // ebx
  int v63; // eax
  _BYTE *v64; // edx
  _DWORD *v65; // esi
  _DWORD *v66; // edi
  int v67; // ecx
  _BYTE *v68; // ebx
  _BYTE *v69; // edx
  _DWORD *v70; // esi
  _DWORD *v71; // edi
  int v72; // eax
  int v73; // ecx
  _BYTE *v74; // ebx
  _BYTE *v75; // edx
  _DWORD *v76; // esi
  _DWORD *v77; // edi
  int v78; // eax
  int v79; // ecx
  _BYTE *v80; // ebx
  _BYTE *v81; // edx
  _DWORD *v82; // esi
  _DWORD *v83; // edi
  int v84; // eax
  int v85; // ecx
  _BYTE *v86; // ebx
  int v87; // eax
  _BYTE *v88; // edx
  _DWORD *v89; // esi
  _DWORD *v90; // edi
  int v91; // ecx
  int v92; // ecx
  _BYTE *v93; // ebx
  _BYTE *v94; // edx
  int v95; // eax
  _DWORD *v96; // esi
  _DWORD *v97; // edi
  int v98; // ecx
  _BYTE *v99; // ebx
  _BYTE *v100; // edx
  int v101; // eax
  _DWORD *v102; // esi
  _DWORD *v103; // edi
  char *v104; // ebx
  int v105; // eax
  _BYTE *v106; // edx
  _DWORD *v107; // esi
  _DWORD *v108; // edi
  int v109; // ecx
  char v110; // al
  char v111; // al
  int v112; // eax
  int v113; // edx
  int v114; // edx
  signed int v116; // [esp+10h] [ebp-54h]
  _DWORD *v117; // [esp+14h] [ebp-50h]
  _DWORD *v118; // [esp+14h] [ebp-50h]
  _DWORD *v119; // [esp+14h] [ebp-50h]
  _DWORD *v120; // [esp+14h] [ebp-50h]
  int v121; // [esp+1Ch] [ebp-48h]
  int v122; // [esp+20h] [ebp-44h]
  int v123; // [esp+20h] [ebp-44h]
  int v124; // [esp+24h] [ebp-40h]
  int v125; // [esp+24h] [ebp-40h]
  int i; // [esp+24h] [ebp-40h]
  int j; // [esp+24h] [ebp-40h]
  int k; // [esp+24h] [ebp-40h]
  int v129; // [esp+24h] [ebp-40h]
  int v130; // [esp+24h] [ebp-40h]
  int l; // [esp+28h] [ebp-3Ch]
  int v132; // [esp+28h] [ebp-3Ch]
  int v133; // [esp+28h] [ebp-3Ch]
  int v134; // [esp+34h] [ebp-30h]
  int v135; // [esp+34h] [ebp-30h]
  int v136; // [esp+38h] [ebp-2Ch]
  int v137; // [esp+38h] [ebp-2Ch]
  int v138; // [esp+3Ch] [ebp-28h]
  int v139; // [esp+3Ch] [ebp-28h]
  int v140; // [esp+3Ch] [ebp-28h]
  int v141; // [esp+3Ch] [ebp-28h]
  int v142; // [esp+3Ch] [ebp-28h]
  int v143; // [esp+3Ch] [ebp-28h]
  int v144; // [esp+3Ch] [ebp-28h]
  int v145; // [esp+3Ch] [ebp-28h]
  int v146; // [esp+3Ch] [ebp-28h]
  int v147; // [esp+3Ch] [ebp-28h]
  int v148; // [esp+3Ch] [ebp-28h]
  int v149; // [esp+3Ch] [ebp-28h]
  int v150; // [esp+3Ch] [ebp-28h]
  int v151; // [esp+3Ch] [ebp-28h]
  int v152; // [esp+3Ch] [ebp-28h]
  _DWORD *v153; // [esp+40h] [ebp-24h]
  _DWORD *v154; // [esp+40h] [ebp-24h]
  int v155; // [esp+40h] [ebp-24h]
  int v156; // [esp+44h] [ebp-20h]
  int v157; // [esp+48h] [ebp-1Ch]
  int v158; // [esp+48h] [ebp-1Ch]
  int v159; // [esp+4Ch] [ebp-18h]
  int v160; // [esp+50h] [ebp-14h]
  int v161; // [esp+50h] [ebp-14h]
  int *v162; // [esp+54h] [ebp-10h]
  _DWORD *v163; // [esp+54h] [ebp-10h]
  _DWORD *v164; // [esp+54h] [ebp-10h]
  _DWORD *v165; // [esp+54h] [ebp-10h]
  int *v166; // [esp+54h] [ebp-10h]
  _DWORD *v167; // [esp+54h] [ebp-10h]
  _DWORD *v168; // [esp+54h] [ebp-10h]
  char *v169; // [esp+58h] [ebp-Ch]
  int v170; // [esp+5Ch] [ebp-8h]
  int v171; // [esp+5Ch] [ebp-8h]
  int v172; // [esp+60h] [ebp-4h]
  int v173; // [esp+60h] [ebp-4h]
  int v174; // [esp+60h] [ebp-4h]
  int v175; // [esp+60h] [ebp-4h]

  if ( !byte_F2CC6 )
  {
    if ( a1 < 1 )
    {
      if ( a1 )
        goto LABEL_126;
    }
    else
    {
      if ( a1 <= 1 )
      {
        dword_F2C30 -= ((dword_F2C64 * dword_F2C44 >> 1) + dword_F2C54 * dword_F2C50) >> 16;
        dword_F2C2C -= (dword_F2C64 * dword_F2C50 - (dword_F2C54 * dword_F2C44 >> 1)) >> 16;
        goto LABEL_126;
      }
      if ( a1 != 2 )
      {
LABEL_126:
        LOWORD(v1) = dword_F2C98;
        if ( (unsigned int)dword_F2C98 <= 7 )
        {
          switch ( dword_F2C98 )
          {
            case 0:
              v1 = dword_F2C8C * dword_F2C44 >> 16;
              v156 = dword_F2C8C * dword_F2C44 >> 16;
              if ( v156 <= 0 )
                break;
              v1 = (dword_F2C50 << 16) / dword_F2C8C;
              v159 = (dword_F2C50 << 16) / dword_F2C8C;
              if ( v159 <= 0 )
                break;
              v135 = (dword_F2C38 << 16) / v159;
              if ( a1 == 1 )
              {
                dword_F2C48 = 0;
              }
              else
              {
                dword_F2C48 = (v159 - 1) * v135;
                v135 = -v135;
              }
              v160 = dword_F2CBC * dword_F2C50 / v159;
              v162 = (int *)(dword_E9C38 + 45920);
              v157 = dword_F2C30 << 16;
              v170 = dword_F2C2C - (dword_F2C9C * dword_F2C30 >> 16);
              if ( dword_F2C2C - (dword_F2C9C * dword_F2C30 >> 16) >= dword_F2CA4 )
                goto LABEL_136;
              v139 = dword_F2CA4 - v170;
              LOWORD(v1) = dword_F2CA4 - v170;
              v159 -= dword_F2CA4 - v170;
              if ( v159 > 0 )
              {
                dword_F2C48 += v139 * v135;
                v157 -= v139 * v160;
                v170 = dword_F2CA4;
LABEL_136:
                v123 = dword_DE560 * v170 + dword_DE558;
                goto LABEL_137;
              }
              break;
            case 1:
              v1 = dword_F2CBC * dword_F2C44 >> 16;
              v156 = dword_F2CBC * dword_F2C44 >> 16;
              if ( v156 <= 0 )
                break;
              v1 = (dword_F2C50 << 16) / dword_F2CBC;
              v159 = (dword_F2C50 << 16) / dword_F2CBC;
              if ( v159 <= 0 )
                break;
              v135 = (dword_F2C38 << 16) / v159;
              if ( a1 == 1 )
              {
                dword_F2C48 = 0;
              }
              else
              {
                dword_F2C48 = (v159 - 1) * v135;
                v135 = -v135;
              }
              v161 = dword_F2C8C * dword_F2C50 / v159;
              v166 = (int *)(dword_E9C38 + 45920);
              v158 = dword_F2C2C << 16;
              v171 = dword_F2C30 - (dword_F2C9C * dword_F2C2C >> 16);
              if ( dword_F2C30 - (dword_F2C9C * dword_F2C2C >> 16) < dword_F2CB4 )
              {
                LOWORD(v1) = dword_F2C30 - ((unsigned int)(dword_F2C9C * dword_F2C2C) >> 16);
                if ( v171 >= dword_F2CA4 )
                  goto LABEL_284;
              }
              else
              {
                v141 = v171 - dword_F2CB4;
                LOWORD(v1) = v171 - dword_F2CB4;
                v159 -= v171 - dword_F2CB4;
                if ( v159 > 0 )
                {
                  dword_F2C48 += v141 * v135;
                  v158 += v141 * v161;
                  v171 = dword_F2CB4;
LABEL_284:
                  v123 = v171 + dword_DE558;
                  goto LABEL_285;
                }
              }
              break;
            case 2:
              v1 = dword_F2C8C * dword_F2C44 >> 16;
              v156 = dword_F2C8C * dword_F2C44 >> 16;
              if ( v156 <= 0 )
                break;
              v1 = (dword_F2C50 << 16) / dword_F2C8C;
              v159 = (dword_F2C50 << 16) / dword_F2C8C;
              if ( v159 <= 0 )
                break;
              v135 = (dword_F2C38 << 16) / v159;
              if ( a1 == 1 )
              {
                dword_F2C48 = 0;
              }
              else
              {
                dword_F2C48 = (v159 - 1) * v135;
                v135 = -v135;
              }
              v160 = dword_F2CBC * dword_F2C50 / v159;
              v162 = (int *)(dword_E9C38 + 45920);
              v157 = dword_F2C2C << 16;
              v170 = dword_F2CB4 - dword_F2C30 - (dword_F2C9C * dword_F2C2C >> 16);
              if ( v170 >= dword_F2CA4 )
                goto LABEL_329;
              v147 = dword_F2CA4 - v170;
              LOWORD(v1) = dword_F2CA4 - v170;
              v159 -= dword_F2CA4 - v170;
              if ( v159 <= 0 )
                break;
              dword_F2C48 += v147 * v135;
              v157 -= v147 * v160;
              v170 = dword_F2CA4;
LABEL_329:
              v123 = dword_F2CB4 + dword_DE558 - 1 - v170;
              goto LABEL_137;
            case 3:
              v1 = dword_F2CBC * dword_F2C44 >> 16;
              v156 = dword_F2CBC * dword_F2C44 >> 16;
              if ( v156 <= 0 )
                break;
              v1 = (dword_F2C50 << 16) / dword_F2CBC;
              v159 = (dword_F2C50 << 16) / dword_F2CBC;
              if ( v159 <= 0 )
                break;
              v135 = (dword_F2C38 << 16) / v159;
              if ( a1 == 1 )
              {
                dword_F2C48 = 0;
              }
              else
              {
                dword_F2C48 = (v159 - 1) * v135;
                v135 = -v135;
              }
              v161 = dword_F2C8C * dword_F2C50 / v159;
              v166 = (int *)(dword_E9C38 + 45920);
              v158 = (dword_F2CB8 - dword_F2C30) << 16;
              v171 = dword_F2C2C - (dword_F2C9C * (dword_F2CB8 - dword_F2C30) >> 16);
              if ( dword_F2C2C - (dword_F2C9C * (dword_F2CB8 - dword_F2C30) >> 16) < dword_F2CB4 )
              {
                LOWORD(v1) = dword_F2C2C - ((unsigned int)(dword_F2C9C * (dword_F2CB8 - dword_F2C30)) >> 16);
                if ( v171 < dword_F2CA4 )
                  break;
              }
              else
              {
                v148 = v171 - dword_F2CB4;
                LOWORD(v1) = v171 - dword_F2CB4;
                v159 -= v171 - dword_F2CB4;
                if ( v159 <= 0 )
                  break;
                dword_F2C48 += v148 * v135;
                v158 += v148 * v161;
                v171 = dword_F2CB4;
              }
              v123 = dword_F2CB8 + dword_DE560 * v171 - 1 + dword_DE558;
              goto LABEL_285;
            case 4:
              v1 = dword_F2C8C * dword_F2C44 >> 16;
              v156 = dword_F2C8C * dword_F2C44 >> 16;
              if ( v156 <= 0 )
                break;
              v1 = (dword_F2C50 << 16) / dword_F2C8C;
              v159 = (dword_F2C50 << 16) / dword_F2C8C;
              if ( v159 <= 0 )
                break;
              v135 = (dword_F2C38 << 16) / v159;
              if ( a1 == 1 )
              {
                dword_F2C48 = 0;
              }
              else
              {
                dword_F2C48 = (v159 - 1) * v135;
                v135 = -v135;
              }
              v160 = dword_F2CBC * dword_F2C50 / v159;
              v162 = (int *)(dword_E9C38 + 45920);
              v157 = (dword_F2CB8 - dword_F2C30) << 16;
              v170 = dword_F2CB4 - dword_F2C2C - (dword_F2C9C * (dword_F2CB8 - dword_F2C30) >> 16);
              if ( v170 >= dword_F2CA4 )
                goto LABEL_348;
              v149 = dword_F2CA4 - v170;
              LOWORD(v1) = dword_F2CA4 - v170;
              v159 -= dword_F2CA4 - v170;
              if ( v159 <= 0 )
                break;
              dword_F2C48 += v149 * v135;
              v157 -= v149 * v160;
              v170 = dword_F2CA4;
LABEL_348:
              v123 = dword_F2CB8 + dword_DE558 + dword_DE560 * (dword_F2CB4 - v170 - 1) - 1;
              goto LABEL_137;
            case 5:
              v1 = dword_F2CBC * dword_F2C44 >> 16;
              v156 = dword_F2CBC * dword_F2C44 >> 16;
              if ( v156 <= 0 )
                break;
              v1 = (dword_F2C50 << 16) / dword_F2CBC;
              v159 = (dword_F2C50 << 16) / dword_F2CBC;
              if ( v159 <= 0 )
                break;
              v135 = (dword_F2C38 << 16) / v159;
              if ( a1 == 1 )
              {
                dword_F2C48 = 0;
              }
              else
              {
                dword_F2C48 = (v159 - 1) * v135;
                v135 = -v135;
              }
              v161 = dword_F2C8C * dword_F2C50 / v159;
              v166 = (int *)(dword_E9C38 + 45920);
              v158 = (dword_F2CB8 - dword_F2C2C) << 16;
              v113 = dword_F2C9C * (dword_F2CB8 - dword_F2C2C) >> 16;
              v171 = dword_F2CB4 - dword_F2C30 - v113;
              if ( v171 < dword_F2CB4 )
              {
                LOWORD(v1) = dword_F2CB4 - dword_F2C30 - v113;
                if ( v171 < dword_F2CA4 )
                  break;
              }
              else
              {
                v150 = v171 - dword_F2CB4;
                LOWORD(v1) = v171 - dword_F2CB4;
                v159 -= v171 - dword_F2CB4;
                if ( v159 <= 0 )
                  break;
                dword_F2C48 += v150 * v135;
                v158 += v150 * v161;
                v171 = dword_F2CB4;
              }
              v123 = (dword_F2CB8 - 1) * dword_DE560 + dword_F2CB4 + dword_DE558 - 1 - v171;
              goto LABEL_285;
            case 6:
              v1 = dword_F2C8C * dword_F2C44 >> 16;
              v156 = dword_F2C8C * dword_F2C44 >> 16;
              if ( v156 <= 0 )
                break;
              v1 = (dword_F2C50 << 16) / dword_F2C8C;
              v159 = (dword_F2C50 << 16) / dword_F2C8C;
              if ( v159 <= 0 )
                break;
              v135 = (dword_F2C38 << 16) / v159;
              if ( a1 == 1 )
              {
                dword_F2C48 = 0;
              }
              else
              {
                dword_F2C48 = (v159 - 1) * v135;
                v135 = -v135;
              }
              v160 = dword_F2CBC * dword_F2C50 / v159;
              v162 = (int *)(dword_E9C38 + 45920);
              v157 = (dword_F2CB8 - dword_F2C2C) << 16;
              v170 = dword_F2C30 - (dword_F2C9C * (dword_F2CB8 - dword_F2C2C) >> 16);
              if ( dword_F2C30 - (dword_F2C9C * (dword_F2CB8 - dword_F2C2C) >> 16) >= dword_F2CA4 )
                goto LABEL_367;
              v151 = dword_F2CA4 - v170;
              LOWORD(v1) = dword_F2CA4 - v170;
              v159 -= dword_F2CA4 - v170;
              if ( v159 <= 0 )
                break;
              dword_F2C48 += v151 * v135;
              v157 -= v151 * v160;
              v170 = dword_F2CA4;
LABEL_367:
              v123 = dword_DE558 + dword_DE560 * (dword_F2CB8 - 1) + v170;
LABEL_137:
              v140 = dword_F2CB4 - dword_F2CA4;
              if ( v170 <= 0 )
              {
                if ( v159 > v140 )
                  v159 = dword_F2CB4 - dword_F2CA4;
              }
              else if ( v170 + v159 > v140 )
              {
                LOWORD(v1) = v140 - v170;
                v159 = v140 - v170;
                if ( v140 - v170 <= 0 )
                  break;
              }
              v116 = 9999999;
              v124 = v159;
              while ( 2 )
              {
                if ( !v124 )
                  goto LABEL_154;
                v172 = v157 >> 16;
                if ( v157 >> 16 >= 0 )
                {
                  *v162 = v172;
                  v162[1] = v156;
                  v162[2] = 0;
                  v116 = 0;
LABEL_151:
                  if ( v162[1] + *v162 > dword_F2CB8 )
                    v162[1] = dword_F2CB8 - *v162;
                  v157 -= v160;
                  v162 += 3;
                  --v124;
                  continue;
                }
                break;
              }
              v173 = -v172;
              *v162 = 0;
              v162[1] = v156 - v173;
              if ( v162[1] > 0 )
              {
                v162[2] = v173;
                if ( v173 < v116 )
                  v116 = v173;
                goto LABEL_151;
              }
              v159 -= v124;
LABEL_154:
              if ( v170 + v159 > dword_F2C84 )
              {
                if ( dword_F2C84 - v170 <= 0 )
                {
                  v163 = (_DWORD *)(dword_E9C38 + 45920);
                  v117 = (_DWORD *)(4 * (dword_F2C84 - v170) + dword_F2C88);
                  v125 = v159;
                }
                else
                {
                  v163 = (_DWORD *)(12 * (dword_F2C84 - v170) + dword_E9C38 + 45920);
                  v117 = (_DWORD *)dword_F2C88;
                  v125 = v170 + v159 - dword_F2C84;
                }
                while ( v125 )
                {
                  if ( *v163 + v163[1] > *v117 )
                  {
                    if ( *v163 >= *v117 )
                    {
                      v159 -= v125;
                      break;
                    }
                    v163[1] = *v117 - *v163;
                  }
                  v163 += 3;
                  --v117;
                  --v125;
                }
              }
              if ( v170 < 0 )
              {
                v118 = (_DWORD *)(4 * (-1 - v170) + dword_E9C38 + 59360);
                v164 = (_DWORD *)(dword_E9C38 + 45920);
                while ( v170 )
                {
                  if ( *v118 > *v164 )
                  {
                    if ( v164[1] + *v164 >= *v118 )
                    {
                      v50 = *v118 - *v164;
                      *v164 = *v118;
                      v164[2] += v50;
                      v164[1] -= v50;
                    }
                    else
                    {
                      v164[1] = 0;
                    }
                  }
                  --v118;
                  v164 += 3;
                  ++v170;
                }
              }
LABEL_172:
              v137 = (dword_F2C34 << 16) / v156;
              dword_F2C4C = 0;
              if ( dword_F2C34 < 0 )
                dword_F2C4C -= v137 * (v156 - 1);
              LOWORD(v1) = v156 - v116;
              v132 = v156 - v116;
              if ( v156 - v116 > 0 )
              {
                if ( v132 > dword_F2C90 )
                  v132 = dword_F2C90;
                dword_F2C4C += v137 * v116;
                v154 = (_DWORD *)(dword_E9C38 + 36960);
                while ( v132 >= 0 )
                {
                  v154[1] = dword_F2C4C >> 16;
                  *v154 = v154[1] - *(v154 - 1);
                  dword_F2C4C += v137;
                  v154 += 2;
                  --v132;
                }
                v165 = (_DWORD *)(dword_E9C38 + 45920);
                LOWORD(v1) = v159;
                for ( i = v159; i; --i )
                {
                  v133 = v165[1];
                  if ( v133 > 0 )
                  {
                    v169 = (char *)&unk_F0E20 + 12 * *v165;
                    v155 = 8 * (v165[2] - v116) + dword_E9C38 + 36960;
                    v121 = dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28;
                    if ( (unsigned int)dword_F2C24 <= 8 )
                    {
                      switch ( dword_F2C24 )
                      {
                        case 0:
                          v51 = (char *)(*(_DWORD *)(v155 + 4) + v121);
                          v52 = (_BYTE *)(*((_DWORD *)v169 + 1) + v123);
                          v53 = (_DWORD *)(8 * (v165[2] - v116) + dword_E9C38 + 36960);
                          v54 = (char *)&unk_F0E20 + 12 * *v165;
                          v55 = v133 >> 1;
                          if ( !(v133 & 1) )
                          {
                            v6 = v55 & 1;
                            v56 = v133 >> 2;
                            if ( v6 )
                            {
                              ++v56;
                              v53 = (_DWORD *)(v155 - 8);
                              v54 = v169 - 12;
                              goto LABEL_197;
                            }
                            v53 = (_DWORD *)(v155 + 8);
                            v54 = v169 + 12;
                            goto LABEL_191;
                          }
                          v57 = v55 + 2;
                          v6 = v57 & 1;
                          v56 = v57 >> 1;
                          if ( !v6 )
                          {
                            v53 = (_DWORD *)(v155 - 16);
                            v54 = v169 - 24;
                            goto LABEL_200;
                          }
                          while ( 1 )
                          {
                            v59 = *v51;
                            v51 += v53[2];
                            if ( v59 )
                              *v52 = v59;
                            v52 += *((_DWORD *)v54 + 3);
LABEL_197:
                            v60 = *v51;
                            v51 += v53[4];
                            if ( v60 )
                              *v52 = v60;
                            v52 += *((_DWORD *)v54 + 6);
LABEL_200:
                            v61 = *v51;
                            v51 += v53[6];
                            if ( v61 )
                              *v52 = v61;
                            v52 += *((_DWORD *)v54 + 9);
                            v53 += 8;
                            v54 += 48;
                            if ( !--v56 )
                              break;
LABEL_191:
                            v58 = *v51;
                            v51 += *v53;
                            if ( v58 )
                              *v52 = v58;
                            v52 += *(_DWORD *)v54;
                          }
                          break;
                        case 1:
                          v62 = (_BYTE *)(*(_DWORD *)(v155 + 4) + v121);
                          v63 = dword_F2C20;
                          v64 = (_BYTE *)(*((_DWORD *)v169 + 1) + v123);
                          v65 = (_DWORD *)(8 * (v165[2] - v116) + dword_E9C38 + 36960);
                          v66 = (_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
                          v67 = v133 >> 1;
                          if ( !(v133 & 1) )
                          {
                            v65 = (_DWORD *)(v155 + 8);
                            v66 = v169 + 12;
                            goto LABEL_207;
                          }
                          ++v67;
                          while ( 1 )
                          {
                            LOBYTE(v63) = *v62;
                            v62 += v65[2];
                            if ( (_BYTE)v63 )
                              *v64 = byte_F6EE0[v63];
                            v64 += v66[3];
                            v65 += 4;
                            v66 += 6;
                            if ( !--v67 )
                              break;
LABEL_207:
                            LOBYTE(v63) = *v62;
                            v62 += *v65;
                            if ( (_BYTE)v63 )
                              *v64 = byte_F6EE0[v63];
                            v64 += *v66;
                          }
                          break;
                        case 2:
                          v68 = (_BYTE *)(*(_DWORD *)(v155 + 4) + v121);
                          v69 = (_BYTE *)(*((_DWORD *)v169 + 1) + v123);
                          v70 = (_DWORD *)(8 * (v165[2] - v116) + dword_E9C38 + 36960);
                          v71 = (_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
                          HIWORD(v72) = 0;
                          v73 = v133 >> 1;
                          if ( !(v133 & 1) )
                          {
                            v70 = (_DWORD *)(v155 + 8);
                            v71 = v169 + 12;
                            goto LABEL_217;
                          }
                          ++v73;
                          while ( 1 )
                          {
                            BYTE1(v72) = *v68;
                            v68 += v70[2];
                            if ( BYTE1(v72) )
                            {
                              LOBYTE(v72) = *v69;
                              *v69 = byte_FAEE0[v72];
                            }
                            v69 += v71[3];
                            v70 += 4;
                            v71 += 6;
                            if ( !--v73 )
                              break;
LABEL_217:
                            BYTE1(v72) = *v68;
                            v68 += *v70;
                            if ( BYTE1(v72) )
                            {
                              LOBYTE(v72) = *v69;
                              *v69 = byte_FAEE0[v72];
                            }
                            v69 += *v71;
                          }
                          break;
                        case 3:
                          v74 = (_BYTE *)(*(_DWORD *)(v155 + 4) + v121);
                          v75 = (_BYTE *)(*((_DWORD *)v169 + 1) + v123);
                          v76 = (_DWORD *)(8 * (v165[2] - v116) + dword_E9C38 + 36960);
                          v77 = (_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
                          HIWORD(v78) = 0;
                          v79 = v133 >> 1;
                          if ( !(v133 & 1) )
                          {
                            v76 = (_DWORD *)(v155 + 8);
                            v77 = v169 + 12;
                            goto LABEL_227;
                          }
                          ++v79;
                          while ( 1 )
                          {
                            LOBYTE(v78) = *v74;
                            v74 += v76[2];
                            if ( (_BYTE)v78 )
                            {
                              BYTE1(v78) = *v75;
                              *v75 = byte_FAEE0[v78];
                            }
                            v75 += v77[3];
                            v76 += 4;
                            v77 += 6;
                            if ( !--v79 )
                              break;
LABEL_227:
                            LOBYTE(v78) = *v74;
                            v74 += *v76;
                            if ( (_BYTE)v78 )
                            {
                              BYTE1(v78) = *v75;
                              *v75 = byte_FAEE0[v78];
                            }
                            v75 += *v77;
                          }
                          break;
                        case 4:
                          v80 = (_BYTE *)(*(_DWORD *)(v155 + 4) + v121);
                          HIWORD(v84) = HIWORD(dword_F2C3C);
                          v81 = (_BYTE *)(*((_DWORD *)v169 + 1) + v123);
                          v82 = (_DWORD *)(8 * (v165[2] - v116) + dword_E9C38 + 36960);
                          v83 = (_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
                          BYTE1(v84) = dword_F2C3C;
                          v85 = v133 >> 1;
                          if ( !(v133 & 1) )
                          {
                            v82 = (_DWORD *)(v155 + 8);
                            v83 = v169 + 12;
                            goto LABEL_237;
                          }
                          ++v85;
                          while ( 1 )
                          {
                            LOBYTE(v84) = *v80;
                            v80 += v82[2];
                            if ( (_BYTE)v84 )
                              *v81 = byte_FAEE0[v84];
                            v81 += v83[3];
                            v82 += 4;
                            v83 += 6;
                            if ( !--v85 )
                              break;
LABEL_237:
                            LOBYTE(v84) = *v80;
                            v80 += *v82;
                            if ( (_BYTE)v84 )
                              *v81 = byte_FAEE0[v84];
                            v81 += *v83;
                          }
                          break;
                        case 5:
                          v86 = (_BYTE *)(*(_DWORD *)(v155 + 4) + v121);
                          v87 = dword_F2C3C;
                          v88 = (_BYTE *)(*((_DWORD *)v169 + 1) + v123);
                          v89 = (_DWORD *)(8 * (v165[2] - v116) + dword_E9C38 + 36960);
                          v90 = (_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
                          v91 = v133 >> 1;
                          if ( !(v133 & 1) )
                          {
                            v89 = (_DWORD *)(v155 + 8);
                            v90 = v169 + 12;
                            goto LABEL_247;
                          }
                          ++v91;
                          while ( 1 )
                          {
                            BYTE1(v87) = *v86;
                            v86 += v89[2];
                            if ( BYTE1(v87) )
                              *v88 = byte_FAEE0[v87];
                            v88 += v90[3];
                            v89 += 4;
                            v90 += 6;
                            if ( !--v91 )
                              break;
LABEL_247:
                            BYTE1(v87) = *v86;
                            v86 += *v89;
                            if ( BYTE1(v87) )
                              *v88 = byte_FAEE0[v87];
                            v88 += *v90;
                          }
                          break;
                        case 6:
                          v92 = dword_F2C20;
                          v93 = (_BYTE *)(*(_DWORD *)(v155 + 4) + v121);
                          v94 = (_BYTE *)(*((_DWORD *)v169 + 1) + v123);
                          HIWORD(v95) = 0;
                          v96 = (_DWORD *)(v155 + 8);
                          v97 = v169 + 12;
                          do
                          {
                            BYTE1(v95) = *v93;
                            v93 += *v96;
                            if ( BYTE1(v95) )
                            {
                              LOBYTE(v95) = *v94;
                              LOBYTE(v92) = byte_FAEE0[v95];
                              *v94 = byte_F6EE0[v92];
                            }
                            v94 += *v97;
                            v96 += 2;
                            v97 += 3;
                            --v133;
                          }
                          while ( v133 );
                          break;
                        case 7:
                          v98 = dword_F2C20;
                          v99 = (_BYTE *)(*(_DWORD *)(v155 + 4) + v121);
                          v100 = (_BYTE *)(*((_DWORD *)v169 + 1) + v123);
                          HIWORD(v101) = 0;
                          v102 = (_DWORD *)(v155 + 8);
                          v103 = v169 + 12;
                          do
                          {
                            LOBYTE(v101) = *v99;
                            v99 += *v102;
                            if ( (_BYTE)v101 )
                            {
                              BYTE1(v101) = *v100;
                              LOBYTE(v98) = byte_FAEE0[v101];
                              *v100 = byte_F6EE0[v98];
                            }
                            v100 += *v103;
                            v102 += 2;
                            v103 += 3;
                            --v133;
                          }
                          while ( v133 );
                          break;
                        case 8:
                          v104 = (char *)(*(_DWORD *)(v155 + 4) + v121);
                          v105 = dword_F2C20;
                          v106 = (_BYTE *)(*((_DWORD *)v169 + 1) + v123);
                          v107 = (_DWORD *)(8 * (v165[2] - v116) + dword_E9C38 + 36960);
                          v108 = (_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
                          v109 = v133 >> 1;
                          if ( !(v133 & 1) )
                          {
                            v107 = (_DWORD *)(v155 + 8);
                            v108 = v169 + 12;
                            goto LABEL_267;
                          }
                          ++v109;
                          while ( 1 )
                          {
                            v111 = *v104;
                            v104 += v107[2];
                            if ( v111 )
                            {
                              LOBYTE(v105) = *v106;
                              *v106 = byte_F6EE0[v105];
                            }
                            v106 += v108[3];
                            v107 += 4;
                            v108 += 6;
                            if ( !--v109 )
                              break;
LABEL_267:
                            v110 = *v104;
                            v104 += *v107;
                            if ( v110 )
                            {
                              LOBYTE(v105) = *v106;
                              *v106 = byte_F6EE0[v105];
                            }
                            v106 += *v108;
                          }
                          break;
                      }
                    }
                  }
                  dword_F2C48 += v135;
                  v123 += dword_F2CAC;
                  v165 += 3;
                  LOWORD(v1) = i;
                }
              }
              break;
            case 7:
              v1 = dword_F2CBC * dword_F2C44 >> 16;
              v156 = dword_F2CBC * dword_F2C44 >> 16;
              if ( v156 <= 0 )
                break;
              v1 = (dword_F2C50 << 16) / dword_F2CBC;
              v159 = (dword_F2C50 << 16) / dword_F2CBC;
              if ( v159 <= 0 )
                break;
              LOWORD(v1) = dword_F2C30;
              if ( dword_F2C30 >= dword_F2CB8 )
                break;
              v135 = (dword_F2C38 << 16) / v159;
              if ( a1 == 1 )
              {
                dword_F2C48 = 0;
              }
              else
              {
                dword_F2C48 = (v159 - 1) * v135;
                v135 = -v135;
              }
              v161 = dword_F2C8C * dword_F2C50 / v159;
              v166 = (int *)(dword_E9C38 + 45920);
              v158 = dword_F2C30 << 16;
              v114 = dword_F2C9C * dword_F2C30 >> 16;
              v171 = dword_F2CB4 - dword_F2C2C - v114;
              if ( v171 < dword_F2CB4 )
              {
                LOWORD(v1) = dword_F2CB4 - dword_F2C2C - v114;
                if ( v171 < dword_F2CA4 )
                  break;
              }
              else
              {
                v152 = v171 - dword_F2CB4;
                LOWORD(v1) = v171 - dword_F2CB4;
                v159 -= v171 - dword_F2CB4;
                if ( v159 <= 0 )
                  break;
                dword_F2C48 += v152 * v135;
                v158 += v152 * v161;
                v171 = dword_F2CB4;
              }
              v123 = dword_DE560 * (dword_F2CB4 - 1 - v171) + dword_DE558;
LABEL_285:
              v142 = dword_F2CB4 - dword_F2CA4;
              if ( v171 < dword_F2CB4 )
              {
                if ( v159 > v142 )
                  v159 = dword_F2CB4 - dword_F2CA4;
              }
              else if ( v171 + v159 - dword_F2CB4 > v142 )
              {
                LOWORD(v1) = v142 - v171;
                v159 = v142 - v171 + dword_F2CB4;
                if ( v159 <= 0 )
                  break;
              }
              v116 = 9999999;
              for ( j = v159; j; --j )
              {
                v174 = v158 >> 16;
                if ( v158 >> 16 < 0 )
                {
                  v175 = -v174;
                  *v166 = 0;
                  v166[1] = v156 - v175;
                  v166[2] = v175;
                  if ( v175 < v116 )
                    v116 = v175;
                }
                else
                {
                  *v166 = v174;
                  v166[1] = v156;
                  v166[2] = 0;
                  v116 = 0;
                }
                if ( v166[1] + *v166 > dword_F2CB8 )
                  v166[1] = dword_F2CB8 - *v166;
                v158 += v161;
                v166 += 3;
              }
              v143 = v171 + dword_F2C94 - dword_F2CB4 + 1;
              if ( v143 > 0 )
              {
                v167 = (_DWORD *)(12 * v143 + dword_E9C38 + 45920);
                v119 = (_DWORD *)dword_F2C88;
                for ( k = v171 + dword_F2C94 - dword_F2CB4 + 2; k; --k )
                {
                  v167 -= 3;
                  if ( dword_E9C38 + 45920 > (unsigned int)v167 )
                    break;
                  v144 = v167[1] + *v167 - *v119;
                  if ( v144 > 0 )
                  {
                    v167[1] -= v144;
                    if ( v167[1] < 0 )
                      v167[1] = 0;
                  }
                  --v119;
                }
              }
              if ( v171 - v159 < 0 )
              {
                v129 = v159 - v171;
                v168 = (_DWORD *)(12 * v171 + dword_E9C38 + 45920);
                v120 = (_DWORD *)(dword_E9C38 + 59360);
                v145 = v171 - v159 - dword_F2CA4;
                if ( v145 < 0 )
                {
                  LOWORD(v1) = v171 - v159 - dword_F2CA4;
                  v159 = v171 - dword_F2CA4;
                  if ( v171 - dword_F2CA4 <= 0 )
                    break;
                  v129 += v145;
                }
                v112 = v129;
                v130 = v129 - 1;
                if ( v112 > 0 )
                {
                  while ( v130 )
                  {
                    v168 += 3;
                    if ( dword_E9C38 + 45920 <= (unsigned int)v168 )
                    {
                      v146 = *v120 - *v168;
                      if ( v146 > 0 )
                      {
                        *v168 = *v120;
                        v168[1] -= v146;
                        if ( v168[1] < 0 )
                          v168[1] = 0;
                        v168[2] += v146;
                      }
                    }
                    ++v120;
                    --v130;
                  }
                }
              }
              goto LABEL_172;
          }
        }
        if ( a1 == 1 )
        {
          if ( !*(_BYTE *)(dword_D41A4 + 207)
            && *(_BYTE *)(dword_F2C70 + 63) == 3
            && (!*(_BYTE *)(dword_F2C70 + 64) || *(_BYTE *)(dword_F2C70 + 64) == 1) )
          {
            sub_2CB30((_DWORD *)dword_F2C70, dword_F2C30, (signed __int16)dword_F2C2C, dword_F2C44);
          }
          if ( *(_BYTE *)(dword_D41A4 + 10) )
            sub_88740(
              dword_F2C70,
              (signed __int16)(dword_F2C30 + (dword_F2C44 >> 1)),
              (signed __int16)(dword_F2C2C + (dword_F2C50 >> 1)));
          LOWORD(v1) = dword_F2C70;
          if ( *(_BYTE *)(dword_F2C70 + 15) & 0x40 )
          {
            v1 = dword_F2C70;
            *(_BYTE *)(v1 + 42) |= 0x40u;
          }
        }
        return v1;
      }
    }
    dword_F2C30 -= dword_F2C64 * dword_F2C44 >> 17;
    dword_F2C2C -= -(dword_F2C54 * dword_F2C44) >> 17;
    goto LABEL_126;
  }
  v138 = (dword_F2C50 + dword_F2C44) >> 2;
  if ( a1 >= 1 )
  {
    if ( a1 <= 1 )
    {
      dword_F2C30 += -(dword_F2C54 * v138 >> 16) - v138;
      dword_F2C2C += -(dword_F2C64 * v138 >> 16) - v138;
    }
    else if ( a1 == 2 )
    {
      dword_F2C30 += (dword_F2C54 * v138 >> 16) - v138;
      dword_F2C2C += (dword_F2C64 * v138 >> 16) - v138;
    }
  }
  LOWORD(v1) = dword_DE564;
  if ( (unsigned __int16)dword_DE564 > dword_F2C30 )
  {
    v136 = (dword_F2C34 << 16) / dword_F2C44;
    if ( -dword_F2C30 < 0 || dword_F2C30 == 0 )
    {
      dword_F2C4C = 0;
      if ( dword_F2C44 + dword_F2C30 - (unsigned __int16)dword_DE564 > 0 )
        dword_F2C44 -= dword_F2C44 + dword_F2C30 - (unsigned __int16)dword_DE564;
    }
    else
    {
      LOWORD(v1) = -(signed __int16)dword_F2C30;
      dword_F2C44 += dword_F2C30;
      if ( dword_F2C44 <= 0 )
        return v1;
      dword_F2C4C = v136 * -dword_F2C30;
      dword_F2C30 = 0;
      if ( (unsigned __int16)dword_DE564 <= dword_F2C44 )
        dword_F2C44 = (unsigned __int16)dword_DE564;
    }
    LOWORD(v1) = dword_DE568;
    if ( (unsigned __int16)dword_DE568 > dword_F2C2C )
    {
      v134 = (dword_F2C38 << 16) / dword_F2C50;
      if ( -dword_F2C2C < 0 || dword_F2C2C == 0 )
      {
        dword_F2C48 = 0;
        if ( dword_F2C50 + dword_F2C2C - (unsigned __int16)dword_DE568 > 0 )
          dword_F2C50 -= dword_F2C50 + dword_F2C2C - (unsigned __int16)dword_DE568;
      }
      else
      {
        LOWORD(v1) = -(signed __int16)dword_F2C2C;
        dword_F2C50 += dword_F2C2C;
        if ( dword_F2C50 <= 0 )
          return v1;
        dword_F2C48 = v134 * -dword_F2C2C;
        dword_F2C2C = 0;
        if ( (unsigned __int16)dword_DE568 <= dword_F2C50 )
          dword_F2C50 = (unsigned __int16)dword_DE568;
      }
      v153 = (_DWORD *)(dword_E9C38 + 36960);
      for ( l = dword_F2C44; l; --l )
      {
        v153[1] = dword_F2C4C >> 16;
        if ( (_DWORD *)(dword_E9C38 + 36960) == v153 )
          *v153 = 22;
        else
          *v153 = v153[1] - *(v153 - 1);
        dword_F2C4C += v136;
        v153 += 2;
      }
      if ( a1 == 1 && *(_BYTE *)(dword_D41A4 + 10) )
        sub_88740(
          dword_F2C70,
          (signed __int16)(dword_F2C30 + (dword_F2C44 >> 1)),
          (signed __int16)(dword_F2C2C + (dword_F2C50 >> 1)));
      v1 = dword_F2C2C * dword_DE560 + dword_F2C30 + dword_DE558;
      v122 = dword_F2C2C * dword_DE560 + dword_F2C30 + dword_DE558;
      while ( dword_F2C50 )
      {
        if ( (unsigned int)dword_F2C24 <= 7 )
        {
          switch ( dword_F2C24 )
          {
            case 0:
              v2 = (char *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
              v3 = (_DWORD *)(dword_E9C38 + 36960);
              v4 = (_BYTE *)v122;
              v5 = dword_F2C44 >> 1;
              if ( !(dword_F2C44 & 1) )
              {
                v6 = v5 & 1;
                v7 = dword_F2C44 >> 2;
                if ( v6 )
                {
                  ++v7;
                  v3 = (_DWORD *)(dword_E9C38 + 36952);
                  v4 = (_BYTE *)(v122 - 2);
                  goto LABEL_49;
                }
                v3 = (_DWORD *)(dword_E9C38 + 36968);
                goto LABEL_45;
              }
              v8 = v5 + 2;
              v6 = v8 & 1;
              v7 = v8 >> 1;
              if ( !v6 )
              {
                v3 = (_DWORD *)(dword_E9C38 + 36944);
                v4 = (_BYTE *)(v122 - 3);
                goto LABEL_51;
              }
              v4 = (_BYTE *)(v122 - 1);
              while ( 1 )
              {
                v10 = *v2;
                v2 += v3[2];
                if ( v10 )
                  v4[1] = v10;
LABEL_49:
                v11 = *v2;
                v2 += v3[4];
                if ( v11 )
                  v4[2] = v11;
LABEL_51:
                v12 = *v2;
                v2 += v3[6];
                if ( v12 )
                  v4[3] = v12;
                v4 += 4;
                v3 += 8;
                if ( !--v7 )
                  break;
LABEL_45:
                v9 = *v2;
                v2 += *v3;
                if ( v9 )
                  *v4 = v9;
              }
              break;
            case 1:
              v13 = dword_F2C20;
              v14 = (_BYTE *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
              v15 = (_DWORD *)(dword_E9C38 + 36960);
              v16 = (_BYTE *)v122;
              v17 = dword_F2C44 >> 1;
              if ( !(dword_F2C44 & 1) )
              {
                v15 = (_DWORD *)(dword_E9C38 + 36968);
                goto LABEL_58;
              }
              ++v17;
              v16 = (_BYTE *)(v122 - 1);
              while ( 1 )
              {
                LOBYTE(v13) = *v14;
                v14 += v15[2];
                if ( (_BYTE)v13 )
                  v16[1] = byte_F6EE0[v13];
                v16 += 2;
                v15 += 4;
                if ( !--v17 )
                  break;
LABEL_58:
                LOBYTE(v13) = *v14;
                v14 += *v15;
                if ( (_BYTE)v13 )
                  *v16 = byte_F6EE0[v13];
              }
              break;
            case 2:
              v18 = (_BYTE *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
              v19 = (_DWORD *)(dword_E9C38 + 36960);
              v20 = (_BYTE *)v122;
              HIWORD(v21) = 0;
              v22 = dword_F2C44 >> 1;
              if ( !(dword_F2C44 & 1) )
              {
                v19 = (_DWORD *)(dword_E9C38 + 36968);
                goto LABEL_67;
              }
              ++v22;
              v20 = (_BYTE *)(v122 - 1);
              while ( 1 )
              {
                BYTE1(v21) = *v18;
                v18 += v19[2];
                if ( BYTE1(v21) )
                {
                  LOBYTE(v21) = v20[1];
                  v20[1] = byte_FAEE0[v21];
                }
                v20 += 2;
                v19 += 4;
                if ( !--v22 )
                  break;
LABEL_67:
                BYTE1(v21) = *v18;
                v18 += *v19;
                if ( BYTE1(v21) )
                {
                  LOBYTE(v21) = *v20;
                  *v20 = byte_FAEE0[v21];
                }
              }
              break;
            case 3:
              v23 = (_BYTE *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
              v24 = (_DWORD *)(dword_E9C38 + 36960);
              v25 = (_BYTE *)v122;
              HIWORD(v26) = 0;
              v27 = dword_F2C44 >> 1;
              if ( !(dword_F2C44 & 1) )
              {
                v24 = (_DWORD *)(dword_E9C38 + 36968);
                goto LABEL_76;
              }
              ++v27;
              v25 = (_BYTE *)(v122 - 1);
              while ( 1 )
              {
                LOBYTE(v26) = *v23;
                v23 += v24[2];
                if ( (_BYTE)v26 )
                {
                  BYTE1(v26) = v25[1];
                  v25[1] = byte_FAEE0[v26];
                }
                v25 += 2;
                v24 += 4;
                if ( !--v27 )
                  break;
LABEL_76:
                LOBYTE(v26) = *v23;
                v23 += *v24;
                if ( (_BYTE)v26 )
                {
                  BYTE1(v26) = *v25;
                  *v25 = byte_FAEE0[v26];
                }
              }
              break;
            case 4:
              HIWORD(v31) = HIWORD(dword_F2C3C);
              v28 = (_BYTE *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
              v29 = (_DWORD *)(dword_E9C38 + 36960);
              v30 = (_BYTE *)v122;
              BYTE1(v31) = dword_F2C3C;
              v32 = dword_F2C44 >> 1;
              if ( !(dword_F2C44 & 1) )
              {
                v29 = (_DWORD *)(dword_E9C38 + 36968);
                goto LABEL_85;
              }
              ++v32;
              v30 = (_BYTE *)(v122 - 1);
              while ( 1 )
              {
                LOBYTE(v31) = *v28;
                v28 += v29[2];
                if ( (_BYTE)v31 )
                  v30[1] = byte_FAEE0[v31];
                v30 += 2;
                v29 += 4;
                if ( !--v32 )
                  break;
LABEL_85:
                LOBYTE(v31) = *v28;
                v28 += *v29;
                if ( (_BYTE)v31 )
                  *v30 = byte_FAEE0[v31];
              }
              break;
            case 5:
              v33 = dword_F2C3C;
              v34 = (_BYTE *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
              v35 = (_DWORD *)(dword_E9C38 + 36960);
              v36 = (_BYTE *)v122;
              v37 = dword_F2C44 >> 1;
              if ( !(dword_F2C44 & 1) )
              {
                v35 = (_DWORD *)(dword_E9C38 + 36968);
                goto LABEL_94;
              }
              ++v37;
              v36 = (_BYTE *)(v122 - 1);
              while ( 1 )
              {
                BYTE1(v33) = *v34;
                v34 += v35[2];
                if ( BYTE1(v33) )
                  v36[1] = byte_FAEE0[v33];
                v36 += 2;
                v35 += 4;
                if ( !--v37 )
                  break;
LABEL_94:
                BYTE1(v33) = *v34;
                v34 += *v35;
                if ( BYTE1(v33) )
                  *v36 = byte_FAEE0[v33];
              }
              break;
            case 6:
              v38 = dword_F2C20;
              v39 = (_BYTE *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
              v40 = (_DWORD *)(dword_E9C38 + 36960);
              v41 = (_BYTE *)v122;
              HIWORD(v42) = 0;
              v43 = dword_F2C44 >> 1;
              if ( !(dword_F2C44 & 1) )
              {
                v40 = (_DWORD *)(dword_E9C38 + 36968);
                goto LABEL_103;
              }
              ++v43;
              v41 = (_BYTE *)(v122 - 1);
              while ( 1 )
              {
                BYTE1(v42) = *v39;
                v39 += v40[2];
                if ( BYTE1(v42) )
                {
                  LOBYTE(v42) = v41[1];
                  LOBYTE(v38) = byte_FAEE0[v42];
                  v41[1] = byte_F6EE0[v38];
                }
                v41 += 2;
                v40 += 4;
                if ( !--v43 )
                  break;
LABEL_103:
                BYTE1(v42) = *v39;
                v39 += *v40;
                if ( BYTE1(v42) )
                {
                  LOBYTE(v42) = *v41;
                  LOBYTE(v38) = byte_FAEE0[v42];
                  *v41 = byte_F6EE0[v38];
                }
              }
              break;
            case 7:
              v44 = dword_F2C20;
              v45 = (_BYTE *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
              v46 = (_DWORD *)(dword_E9C38 + 36960);
              v47 = (_BYTE *)v122;
              HIWORD(v48) = 0;
              v49 = dword_F2C44 >> 1;
              if ( !(dword_F2C44 & 1) )
              {
                v46 = (_DWORD *)(dword_E9C38 + 36968);
                goto LABEL_112;
              }
              ++v49;
              v47 = (_BYTE *)(v122 - 1);
              while ( 1 )
              {
                LOBYTE(v48) = *v45;
                v45 += v46[2];
                if ( (_BYTE)v48 )
                {
                  BYTE1(v48) = v47[1];
                  LOBYTE(v44) = byte_FAEE0[v48];
                  v47[1] = byte_F6EE0[v44];
                }
                v47 += 2;
                v46 += 4;
                if ( !--v49 )
                  break;
LABEL_112:
                LOBYTE(v48) = *v45;
                v45 += *v46;
                if ( (_BYTE)v48 )
                {
                  BYTE1(v48) = *v47;
                  LOBYTE(v44) = byte_FAEE0[v48];
                  *v47 = byte_F6EE0[v44];
                }
              }
              break;
          }
        }
        dword_F2C48 += v134;
        LOWORD(v1) = dword_DE560;
        v122 += dword_DE560;
        --dword_F2C50;
      }
    }
  }
  return v1;
}
// D41A4: using guessed type int dword_D41A4;
// DE558: using guessed type int dword_DE558;
// DE55C: using guessed type int dword_DE55C;
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;
// E9C38: using guessed type int dword_E9C38;
// F2C20: using guessed type int dword_F2C20;
// F2C24: using guessed type int dword_F2C24;
// F2C28: using guessed type int dword_F2C28;
// F2C2C: using guessed type int dword_F2C2C;
// F2C30: using guessed type int dword_F2C30;
// F2C34: using guessed type int dword_F2C34;
// F2C38: using guessed type int dword_F2C38;
// F2C3C: using guessed type int dword_F2C3C;
// F2C40: using guessed type int dword_F2C40;
// F2C44: using guessed type int dword_F2C44;
// F2C48: using guessed type int dword_F2C48;
// F2C4C: using guessed type int dword_F2C4C;
// F2C50: using guessed type int dword_F2C50;
// F2C54: using guessed type int dword_F2C54;
// F2C64: using guessed type int dword_F2C64;
// F2C70: using guessed type int dword_F2C70;
// F2C84: using guessed type int dword_F2C84;
// F2C88: using guessed type int dword_F2C88;
// F2C8C: using guessed type int dword_F2C8C;
// F2C90: using guessed type int dword_F2C90;
// F2C94: using guessed type int dword_F2C94;
// F2C98: using guessed type int dword_F2C98;
// F2C9C: using guessed type int dword_F2C9C;
// F2CA4: using guessed type int dword_F2CA4;
// F2CAC: using guessed type int dword_F2CAC;
// F2CB4: using guessed type int dword_F2CB4;
// F2CB8: using guessed type int dword_F2CB8;
// F2CBC: using guessed type int dword_F2CBC;
// F2CC6: using guessed type char byte_F2CC6;

//----- (00043830) --------------------------------------------------------
int __usercall sub_43830@<eax>(unsigned int a1@<esi>, int a2)
{
  int v2; // ebx
  int v3; // ST0C_4

  v2 = a2;
  word_17B4E0 = *(_WORD *)(a2 + 23);
  *(_DWORD *)(dword_D41A0 + 8) = *(_DWORD *)(a2 + 23);
  memset(word_15B4E0, 0, &loc_20000);
  v3 = *(unsigned __int16 *)(v2 + 35);
  sub_B5E70(word_17B4E0, *(_WORD *)(v2 + 27), *(_WORD *)(v2 + 31));
  sub_44DB0();
  memset(word_15B4E0, 0, &loc_20000);
  sub_44E40(*(_DWORD *)(v2 + 39), *(_WORD *)(v2 + 43));
  sub_45AA0();
  sub_440D0(*(_WORD *)(v2 + 51));
  sub_45060(*(_WORD *)(v2 + 55), *(_WORD *)(v2 + 59));
  sub_44320();
  sub_45210(*(_WORD *)(v2 + 55), *(_WORD *)(v2 + 59));
  sub_454F0(*(_WORD *)(v2 + 47), *(_WORD *)(v2 + 67));
  sub_45600(*(_WORD *)(v2 + 63));
  sub_43FC0();
  memset(byte_10B4E0, 0, sub_10000);
  sub_43970(a1);
  sub_43EE0();
  sub_44580();
  if ( byte_D41B6 )
    sub_43B40();
  else
    sub_43D50();
  return sub_44D00();
}
// 10000: using guessed type void __noreturn sub_10000();
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// 17B4E0: using guessed type __int16 word_17B4E0;

//----- (00043970) --------------------------------------------------------
unsigned int __usercall sub_43970@<eax>(unsigned int a1@<esi>)
{
  unsigned __int16 v1; // bx
  unsigned int result; // eax

  v1 = 0;
  do
  {
    result = sub_439A0(a1, v1);
    byte_11B4E0[v1++] = result;
  }
  while ( v1 );
  return result;
}

//----- (000439A0) --------------------------------------------------------
unsigned int __usercall sub_439A0@<eax>(unsigned int a1@<esi>, unsigned __int16 a2)
{
  unsigned __int16 v2; // ax
  unsigned __int8 v3; // dl
  unsigned __int8 v4; // dh
  unsigned __int8 v5; // ch
  unsigned __int8 v6; // cl
  int v7; // ebx
  unsigned __int8 v8; // cl
  int v9; // ebx
  unsigned __int8 v10; // cl
  int v11; // ebx
  unsigned __int8 v12; // cl
  int v13; // ebx
  unsigned __int8 v14; // cl
  int v15; // ebx
  unsigned __int8 v16; // cl
  int v17; // ebx
  unsigned __int8 v18; // cl
  int v19; // ebx
  unsigned __int8 v20; // al
  unsigned int v21; // ebx
  unsigned int v22; // ebx

  LOBYTE(v2) = a2;
  LOWORD(a1) = (unsigned __int8)byte_11B4E0[a2];
  if ( byte_13B4E0[a2] & 7 )
  {
    HIBYTE(v2) = HIBYTE(a2) - 1;
    v3 = byte_11B4E0[a2];
    v4 = v3;
    v5 = byte_11B4E0[a2];
    v6 = byte_11B4E0[v2];
    v7 = v6;
    if ( v6 > v3 )
      v3 = byte_11B4E0[v2];
    if ( v6 < v4 )
      v4 = byte_11B4E0[v2];
    LOBYTE(v2) = a2 + 1;
    v8 = byte_11B4E0[v2];
    v9 = v8 + v7;
    if ( v8 > v3 )
      v3 = byte_11B4E0[v2];
    if ( v8 < v4 )
      v4 = byte_11B4E0[v2];
    HIBYTE(v2) = HIBYTE(a2);
    v10 = byte_11B4E0[v2];
    v11 = v10 + v9;
    if ( v10 > v3 )
      v3 = byte_11B4E0[v2];
    if ( v10 < v4 )
      v4 = byte_11B4E0[v2];
    HIBYTE(v2) = HIBYTE(a2) + 1;
    v12 = byte_11B4E0[v2];
    v13 = v12 + v11;
    if ( v12 > v3 )
      v3 = byte_11B4E0[v2];
    if ( v12 < v4 )
      v4 = byte_11B4E0[v2];
    LOBYTE(v2) = a2;
    v14 = byte_11B4E0[v2];
    v15 = v14 + v13;
    if ( v14 > v3 )
      v3 = byte_11B4E0[v2];
    if ( v14 < v4 )
      v4 = byte_11B4E0[v2];
    LOBYTE(v2) = a2 - 1;
    v16 = byte_11B4E0[v2];
    v17 = v16 + v15;
    if ( v16 > v3 )
      v3 = byte_11B4E0[v2];
    if ( v16 < v4 )
      v4 = byte_11B4E0[v2];
    HIBYTE(v2) = HIBYTE(a2);
    v18 = byte_11B4E0[v2];
    v19 = v18 + v17;
    if ( v18 > v3 )
      v3 = byte_11B4E0[v2];
    if ( v18 < v4 )
      v4 = byte_11B4E0[v2];
    HIBYTE(v2) = HIBYTE(a2) - 1;
    v20 = byte_11B4E0[v2];
    v21 = v20 + v19;
    if ( v20 > v3 )
      v3 = v20;
    if ( v20 < v4 )
      v4 = v20;
    v22 = v21 >> 3;
    if ( (unsigned __int8)(v5 - v4) <= 4u )
    {
      if ( (unsigned __int8)(v3 - v5) <= 4u )
        return a1;
      if ( (unsigned __int8)(v3 - v5) <= 0xAu )
        v22 = (v5 + v22) >> 1;
    }
    else if ( (unsigned __int8)(v5 - v4) <= 0xAu )
    {
      return (v22 + v5) >> 1;
    }
    a1 = v22;
  }
  return a1;
}

//----- (00043B40) --------------------------------------------------------
__int16 sub_43B40()
{
  unsigned __int16 v0; // dx
  signed int v1; // eax
  unsigned __int8 v2; // bl
  unsigned __int8 v3; // bh
  char v4; // cl

  v0 = 0;
  do
  {
    v1 = (unsigned __int8)byte_11B4E0[v0];
    if ( v1 > (unsigned __int8)byte_D41B7 )
      LOBYTE(v1) = byte_D41B7;
    v2 = byte_D41B7 - v1;
    byte_14B4E0[v0] = byte_D41B7 - v1;
    v3 = byte_11B4E0[v0];
    if ( v2 > v3 )
    {
      byte_13B4E0[v0] &= 0xF7u;
    }
    else
    {
      v4 = byte_13B4E0[v0] | 8;
      byte_14B4E0[v0] = v3 - 1;
      byte_13B4E0[v0] = v4;
    }
    ++v0;
  }
  while ( v0 );
  return sub_43BB0();
}
// D41B7: using guessed type char byte_D41B7;

//----- (00043BB0) --------------------------------------------------------
__int16 sub_43BB0()
{
  unsigned int v0; // esi
  unsigned __int16 v1; // cx
  signed int v2; // ebx
  unsigned __int16 v3; // bx
  int v4; // eax
  unsigned __int8 v5; // dh
  char v6; // cl

  v0 = 37487429;
  v1 = 0;
  do
  {
    if ( !(byte_13B4E0[v1] & 8) )
    {
      v0 = 9377 * v0 + 9439;
      v2 = v0 % 7 - 3 + (unsigned __int8)byte_14B4E0[v1];
      if ( v2 < 0 )
        v2 = 0;
      if ( v2 > 254 )
        LOBYTE(v2) = -2;
      byte_14B4E0[v1] = v2;
    }
    ++v1;
  }
  while ( v1 );
  v3 = 0;
  do
  {
    v4 = v3;
    v5 = byte_11B4E0[v3];
    if ( (unsigned __int8)byte_14B4E0[v3] > v5 )
    {
      byte_13B4E0[v3] &= 0xF7u;
    }
    else
    {
      v6 = byte_13B4E0[v3] | 8;
      byte_14B4E0[v3] = v5 - 1;
      byte_13B4E0[v3] = v6;
    }
    ++v3;
  }
  while ( v3 );
  return v4;
}

//----- (00043C60) --------------------------------------------------------
void __cdecl sub_43C60(unsigned __int8 a1, char a2, int a3, int a4)
{
  unsigned int v4; // ecx
  int v5; // esi
  unsigned __int16 v6; // bx
  int v7; // edi
  int v8; // ecx
  unsigned __int16 v9; // bx
  int v10; // esi
  unsigned __int8 v11; // dh

  v4 = 37487429;
  LOBYTE(v6) = a1;
  v5 = a3;
  HIBYTE(v6) = a2;
  while ( (_WORD)--v5 != -1 )
  {
    v7 = a4;
    while ( (_WORD)--v7 != -1 )
    {
      if ( !(byte_13B4E0[v6] & 8) )
      {
        v4 = 9377 * v4 + 9439;
        byte_14B4E0[v6] += v4 % 7 - 3;
      }
      LOBYTE(v6) = v6 + 1;
    }
    v6 = __PAIR__(HIBYTE(v6), a1) + 256;
  }
  LOBYTE(v9) = a1;
  v8 = a3;
  HIBYTE(v9) = a2;
  while ( (_WORD)--v8 != -1 )
  {
    v10 = a4;
    while ( (_WORD)--v10 != -1 )
    {
      v11 = byte_11B4E0[v9];
      if ( (unsigned __int8)byte_14B4E0[v9] > v11 )
      {
        byte_13B4E0[v9] &= 0xF7u;
      }
      else
      {
        byte_14B4E0[v9] = v11 - 1;
        byte_13B4E0[v9] |= 8u;
      }
      LOBYTE(v9) = v9 + 1;
    }
    v9 = __PAIR__(HIBYTE(v9), a1) + 256;
  }
}

//----- (00043D50) --------------------------------------------------------
unsigned __int16 sub_43D50()
{
  unsigned __int16 result; // ax
  unsigned __int16 v1; // dx
  unsigned __int16 v2; // bx
  unsigned __int16 v3; // bx
  unsigned __int16 v4; // bx
  unsigned __int16 v5; // bx
  unsigned __int16 v6; // bx
  unsigned __int16 v7; // bx
  unsigned __int16 v8; // dx
  unsigned __int16 v9; // bx
  unsigned __int16 v10; // bx

  result = 0;
  do
  {
    byte_13B4E0[result] &= 0xF7u;
    if ( !byte_11B4E0[result] )
    {
      --HIBYTE(result);
      v1 = result;
      LOBYTE(result) = result + 1;
      v2 = result;
      ++HIBYTE(result);
      LOBYTE(v1) = (byte_11B4E0[v2] != 0) + (byte_11B4E0[v1] != 0);
      v3 = result;
      ++HIBYTE(result);
      LOBYTE(v1) = (byte_11B4E0[v3] != 0) + v1;
      v4 = result;
      LOBYTE(result) = result - 1;
      LOBYTE(v1) = (byte_11B4E0[v4] != 0) + v1;
      v5 = result;
      LOBYTE(result) = result - 1;
      LOBYTE(v1) = (byte_11B4E0[v5] != 0) + v1;
      v6 = result;
      --HIBYTE(result);
      LOBYTE(v1) = (byte_11B4E0[v6] != 0) + v1;
      v7 = result;
      --HIBYTE(result);
      LOBYTE(v1) = (byte_11B4E0[v7] != 0) + v1;
      LOBYTE(v7) = byte_11B4E0[result] != 0;
      LOBYTE(result) = result + 1;
      ++HIBYTE(result);
      if ( !((_BYTE)v7 + (_BYTE)v1) )
      {
        v8 = result;
        LOBYTE(result) = result - 1;
        v9 = result;
        --HIBYTE(result);
        LOBYTE(v8) = (byte_10B4E0[v9] != 0) + (byte_10B4E0[v8] != 0);
        v10 = result;
        LOBYTE(result) = result + 1;
        LOBYTE(v8) = (byte_10B4E0[result] != 0) + (byte_10B4E0[v10] != 0) + v8;
        ++HIBYTE(result);
        if ( !(_BYTE)v8 )
          byte_13B4E0[result] |= 8u;
      }
    }
    ++result;
  }
  while ( result );
  return result;
}

//----- (00043EE0) --------------------------------------------------------
unsigned __int16 sub_43EE0()
{
  unsigned __int16 result; // ax
  unsigned __int16 v1; // cx
  char v2; // dh
  unsigned __int8 v3; // dl
  int v4; // ecx
  char v5; // bl
  char v6; // bh
  unsigned __int8 v7; // cl
  char v8; // bh
  char v9; // bh
  unsigned __int16 v10; // cx
  unsigned __int16 v11; // cx
  unsigned __int16 v12; // cx
  unsigned __int16 v13; // cx

  result = 0;
  do
  {
    v1 = result;
    v2 = 0;
    LOBYTE(result) = result + 1;
    v3 = byte_11B4E0[v1];
    v4 = v1;
    LOWORD(v4) = result;
    v5 = 0;
    v6 = byte_13B4E0[result];
    if ( v6 )
    {
      if ( v6 == 4 )
        v2 = 1;
    }
    else
    {
      v7 = byte_11B4E0[v4];
      v5 = 1;
      if ( v7 < v3 )
        v3 = v7;
    }
    ++HIBYTE(result);
    v8 = byte_13B4E0[result];
    if ( v8 )
    {
      if ( v8 == 4 )
        ++v2;
    }
    else
    {
      ++v5;
      if ( (unsigned __int8)byte_11B4E0[result] < v3 )
        v3 = byte_11B4E0[result];
    }
    LOBYTE(result) = result - 1;
    v9 = byte_13B4E0[result];
    if ( v9 )
    {
      if ( v9 == 4 )
        ++v2;
    }
    else
    {
      ++v5;
      if ( (unsigned __int8)byte_11B4E0[result] < v3 )
        v3 = byte_11B4E0[result];
    }
    --HIBYTE(result);
    if ( v2 && v5 && !v3 )
    {
      v10 = result;
      LOBYTE(result) = result + 1;
      byte_11B4E0[v10] = 0;
      v11 = result;
      ++HIBYTE(result);
      byte_11B4E0[v11] = 0;
      v12 = result;
      LOBYTE(result) = result - 1;
      byte_11B4E0[v12] = 0;
      v13 = result;
      --HIBYTE(result);
      byte_11B4E0[v13] = 0;
    }
    ++result;
  }
  while ( result );
  return result;
}

//----- (00043FC0) --------------------------------------------------------
unsigned __int16 sub_43FC0()
{
  unsigned __int16 result; // ax
  unsigned __int16 v1; // dx
  char v2; // dh
  unsigned __int16 v3; // bx
  unsigned __int16 v4; // bx
  unsigned __int16 v5; // bx
  unsigned __int16 v6; // bx
  unsigned __int16 v7; // bx
  char v8; // bl
  unsigned __int16 v9; // ax

  result = 0;
  do
  {
    --HIBYTE(result);
    v1 = result;
    LOBYTE(result) = result + 1;
    v2 = byte_13B4E0[v1];
    LOBYTE(v1) = v2 == byte_13B4E0[result];
    ++HIBYTE(result);
    v3 = result;
    ++HIBYTE(result);
    LOBYTE(v1) = (v2 == byte_13B4E0[v3]) + v1;
    v4 = result;
    LOBYTE(result) = result - 1;
    LOBYTE(v1) = (v2 == byte_13B4E0[v4]) + v1;
    v5 = result;
    LOBYTE(result) = result - 1;
    LOBYTE(v1) = (v2 == byte_13B4E0[v5]) + v1;
    v6 = result;
    --HIBYTE(result);
    LOBYTE(v1) = (v2 == byte_13B4E0[v6]) + v1;
    v7 = result;
    --HIBYTE(result);
    v8 = (v2 == byte_13B4E0[result]) + (v2 == byte_13B4E0[v7]) + v1;
    LOBYTE(result) = result + 1;
    HIBYTE(v9) = HIBYTE(result) + 1;
    if ( v2 )
    {
      if ( v8 == 7 )
        byte_13B4E0[v9] = v2;
    }
    result = v9 + 1;
  }
  while ( result );
  return result;
}

//----- (000440D0) --------------------------------------------------------
unsigned __int16 __cdecl sub_440D0(unsigned __int16 a1)
{
  unsigned __int16 result; // ax
  unsigned __int8 v2; // dh
  unsigned __int8 v3; // dl
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // ax
  int v6; // ebx
  char v7; // bl
  char v8; // dl
  char v9; // dh

  result = 0;
  do
  {
    if ( byte_13B4E0[result] == 5 )
    {
      v2 = 0;
      v3 = -1;
      if ( byte_11B4E0[result] )
        v2 = byte_11B4E0[result];
      if ( (unsigned __int8)byte_11B4E0[result] < 0xFFu )
        v3 = byte_11B4E0[result];
      --HIBYTE(result);
      if ( v2 < (unsigned __int8)byte_11B4E0[result] )
        v2 = byte_11B4E0[result];
      if ( v3 > (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      LOBYTE(result) = result + 1;
      ++HIBYTE(result);
      if ( v2 < (unsigned __int8)byte_11B4E0[result] )
        v2 = byte_11B4E0[v4];
      if ( v3 > (unsigned __int8)byte_11B4E0[v4] )
        v3 = byte_11B4E0[v4];
      LOBYTE(v4) = v4 - 1;
      ++HIBYTE(v4);
      if ( v2 < (unsigned __int8)byte_11B4E0[v4] )
        v2 = byte_11B4E0[v5];
      if ( v3 > (unsigned __int8)byte_11B4E0[v5] )
        v3 = byte_11B4E0[v5];
      LOBYTE(result) = v5 - 1;
      --HIBYTE(result);
      if ( v2 < (unsigned __int8)byte_11B4E0[result] )
        v2 = byte_11B4E0[result];
      if ( v3 > (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      v6 = v2 - v3;
      LOBYTE(result) = result + 1;
      if ( v6 <= a1 )
      {
        if ( v6 == a1 )
          byte_13B4E0[result] = 4;
        else
          byte_13B4E0[result] = 3;
      }
    }
    ++result;
  }
  while ( result );
  do
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    if ( byte_13B4E0[result] == 3 )
      v7 = 1;
    if ( byte_13B4E0[result] == 2 )
      v8 = 1;
    if ( byte_13B4E0[result] == 5 )
      v9 = 1;
    LOBYTE(result) = result + 1;
    if ( byte_13B4E0[result] == 3 )
      ++v7;
    if ( byte_13B4E0[result] == 2 )
      ++v8;
    if ( byte_13B4E0[result] == 5 )
      ++v9;
    ++HIBYTE(result);
    if ( byte_13B4E0[result] == 3 )
      ++v7;
    if ( byte_13B4E0[result] == 2 )
      ++v8;
    if ( byte_13B4E0[result] == 5 )
      ++v9;
    LOBYTE(result) = result - 1;
    if ( byte_13B4E0[result] == 3 )
      ++v7;
    if ( byte_13B4E0[result] == 2 )
      ++v8;
    if ( byte_13B4E0[result] == 5 )
      ++v9;
    --HIBYTE(result);
    if ( !v8 && v7 && v9 )
    {
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result + 1;
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      ++HIBYTE(result);
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result - 1;
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      --HIBYTE(result);
    }
    ++result;
  }
  while ( result );
  return result;
}

//----- (00044320) --------------------------------------------------------
unsigned __int16 sub_44320()
{
  unsigned __int16 result; // ax
  char v1; // bl
  char v2; // dh
  char v3; // dl

  result = 0;
  do
  {
    v1 = 0;
    v2 = 0;
    v3 = 0;
    if ( !byte_13B4E0[result] )
      v1 = 1;
    if ( byte_13B4E0[result] == 5 )
      v3 = 1;
    if ( byte_13B4E0[result] == 3 )
      v2 = 1;
    LOBYTE(result) = result + 1;
    if ( !byte_13B4E0[result] )
      ++v1;
    if ( byte_13B4E0[result] == 5 )
      ++v3;
    if ( byte_13B4E0[result] == 3 )
      ++v2;
    ++HIBYTE(result);
    if ( !byte_13B4E0[result] )
      ++v1;
    if ( byte_13B4E0[result] == 5 )
      ++v3;
    if ( byte_13B4E0[result] == 3 )
      ++v2;
    LOBYTE(result) = result - 1;
    if ( !byte_13B4E0[result] )
      ++v1;
    if ( byte_13B4E0[result] == 5 )
      ++v3;
    if ( byte_13B4E0[result] == 3 )
      ++v2;
    --HIBYTE(result);
    if ( v2 && v3 )
    {
      if ( byte_13B4E0[result] == 5 )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result + 1;
      if ( byte_13B4E0[result] == 5 )
        byte_13B4E0[result] = 4;
      ++HIBYTE(result);
      if ( byte_13B4E0[result] == 5 )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result - 1;
      if ( byte_13B4E0[result] == 5 )
        byte_13B4E0[result] = 4;
      --HIBYTE(result);
    }
    if ( v2 && v1 )
    {
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result + 1;
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      ++HIBYTE(result);
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result - 1;
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      --HIBYTE(result);
    }
    if ( v1 && v3 )
    {
      if ( byte_13B4E0[result] )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result + 1;
      if ( byte_13B4E0[result] )
        byte_13B4E0[result] = 4;
      ++HIBYTE(result);
      if ( byte_13B4E0[result] )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result - 1;
      if ( byte_13B4E0[result] )
        byte_13B4E0[result] = 4;
      --HIBYTE(result);
    }
    ++result;
  }
  while ( result );
  return result;
}

//----- (00044580) --------------------------------------------------------
__int16 sub_44580()
{
  _BYTE *v0; // eax
  unsigned __int16 v1; // bx
  unsigned __int16 v2; // bx
  char v3; // al
  char v4; // dl
  char v5; // cl
  char v6; // ah
  int v7; // edi
  unsigned __int8 *v8; // esi
  unsigned __int8 v9; // dh
  int v10; // esi
  char v11; // dh
  char v12; // al
  char v13; // dl
  char v14; // dh
  int v15; // ST00_4
  char v16; // ah
  unsigned __int8 *v17; // esi
  char v18; // cl
  unsigned __int8 v19; // dh
  int v20; // esi
  char v21; // dh
  char v22; // al
  char v23; // ah
  char v24; // dh
  char v25; // dl
  int v26; // edi
  unsigned __int8 *v27; // esi
  char v28; // cl
  unsigned __int8 v29; // dh
  int v30; // esi
  char v31; // dh
  char v32; // al
  char v33; // dl
  char v34; // dh
  int v35; // ST00_4
  char v36; // ah
  unsigned __int8 *v37; // esi
  char v38; // cl
  unsigned __int8 v39; // dh
  int v40; // esi
  char v41; // dh
  int v42; // edi
  int v43; // esi
  char v44; // al
  unsigned __int8 *v45; // esi
  char v46; // cl
  unsigned __int8 v47; // dh
  int v48; // esi
  char v49; // dh
  char v50; // al
  char v51; // dl
  char v52; // dh
  int v53; // edi
  int v54; // esi
  char v55; // ah
  unsigned __int8 *v56; // esi
  char v57; // cl
  unsigned __int8 v58; // dh
  int v59; // esi
  char v60; // dh
  char v61; // al
  char v62; // ah
  char v63; // dh
  char v64; // dl
  int v65; // edi
  unsigned __int8 *v66; // esi
  char v67; // cl
  unsigned __int8 v68; // dh
  int v69; // esi
  _BYTE *v70; // eax
  int v71; // edx
  char *v72; // esi
  char i; // bl
  char j; // ch
  char k; // cl
  char l; // bh
  _BYTE *v77; // eax
  unsigned __int16 v78; // cx
  int v79; // eax
  char v80; // ST14_1
  unsigned __int16 v81; // ax
  char v82; // bh
  unsigned __int16 v83; // ax
  int v84; // esi
  unsigned __int8 v85; // al
  unsigned __int8 v86; // bl
  int v87; // edx
  char *v89; // [esp+8h] [ebp-10h]
  int v90; // [esp+Ch] [ebp-Ch]

  v0 = (_BYTE *)dword_180628;
  v1 = 0;
  while ( v1 < 0x961u )
  {
    ++v1;
    *v0 = 0;
    v0 += 25;
  }
  v2 = 0;
  v90 = dword_180628;
  v89 = (char *)&unk_D47E0;
  while ( v2 < 0x94u )
  {
    v3 = *v89;
    if ( *v89 >= 0 )
    {
      v4 = v89[1];
      if ( v4 >= 0 )
      {
        v5 = v89[2];
        if ( v5 >= 0 )
        {
          v6 = v89[3];
          if ( v6 >= 0 )
          {
            v7 = 49 * v4 + 7 * v5 + v6 + 343 * v3;
            v8 = (unsigned __int8 *)(v90 + 25 * v7);
            v9 = *v8;
            if ( *v8 < 0xCu )
            {
              *v8 = v9 + 1;
              v10 = (int)&v8[v9];
              *(_BYTE *)(v10 + 13) = 0;
              *(_BYTE *)(v10 + 1) = v2;
            }
            v11 = v3;
            v12 = v4;
            v13 = v11;
            v14 = v6;
            v15 = 7 * v6;
            v16 = v5;
            v17 = (unsigned __int8 *)(v90 + 25 * (49 * v13 + v5 + v15 + 343 * v12));
            v18 = v14;
            v19 = *v17;
            if ( *v17 < 0xCu )
            {
              *v17 = v19 + 1;
              v20 = (int)&v17[v19];
              *(_BYTE *)(v20 + 13) = 16;
              *(_BYTE *)(v20 + 1) = v2;
            }
            v21 = v12;
            v22 = v16;
            v23 = v21;
            v24 = v13;
            v25 = v18;
            v26 = 49 * v18 + v23 + 7 * v24 + 343 * v22;
            v27 = (unsigned __int8 *)(v90 + 25 * v26);
            v28 = v24;
            v29 = *v27;
            if ( *v27 < 0xCu )
            {
              *v27 = v29 + 1;
              v30 = (int)&v27[v29];
              *(_BYTE *)(v30 + 13) = 48;
              *(_BYTE *)(v30 + 1) = v2;
            }
            v31 = v22;
            v32 = v25;
            v33 = v31;
            v34 = v23;
            v35 = 7 * v23;
            v36 = v28;
            v37 = (unsigned __int8 *)(v90 + 25 * (49 * v33 + v28 + v35 + 343 * v32));
            v38 = v34;
            v39 = *v37;
            if ( *v37 < 0xCu )
            {
              *v37 = v39 + 1;
              v40 = (int)&v37[v39];
              *(_BYTE *)(v40 + 13) = 32;
              *(_BYTE *)(v40 + 1) = v2;
            }
            v41 = v32;
            v42 = v32;
            v43 = 8 * v32;
            v44 = v38;
            v45 = (unsigned __int8 *)(v90 + 25 * (49 * v33 + v43 - v42 + v36 + 343 * v38));
            v46 = v41;
            v47 = *v45;
            if ( *v45 < 0xCu )
            {
              *v45 = v47 + 1;
              v48 = (int)&v45[v47];
              *(_BYTE *)(v48 + 13) = 96;
              *(_BYTE *)(v48 + 1) = v2;
            }
            v49 = v44;
            v50 = v33;
            v51 = v49;
            v52 = v36;
            v53 = v36;
            v54 = 8 * v36;
            v55 = v46;
            v56 = (unsigned __int8 *)(v90 + 25 * (49 * v51 + v54 - v53 + v46 + 343 * v50));
            v57 = v52;
            v58 = *v56;
            if ( *v56 < 0xCu )
            {
              *v56 = v58 + 1;
              v59 = (int)&v56[v58];
              *(_BYTE *)(v59 + 13) = 112;
              *(_BYTE *)(v59 + 1) = v2;
            }
            v60 = v50;
            v61 = v55;
            v62 = v60;
            v63 = v51;
            v64 = v57;
            v65 = 49 * v57 + 7 * v63 + v62 + 343 * v61;
            v66 = (unsigned __int8 *)(v90 + 25 * v65);
            v67 = v63;
            v68 = *v66;
            if ( *v66 < 0xCu )
            {
              *v66 = v68 + 1;
              v69 = (int)&v66[v68];
              *(_BYTE *)(v69 + 13) = 80;
              *(_BYTE *)(v69 + 1) = v2;
            }
            v70 = (_BYTE *)(v90 + 25 * (343 * v64 + 7 * v62 + v67 + 49 * v61));
            LOBYTE(v71) = *v70;
            if ( *v70 < 0xCu )
            {
              *v70 = v71 + 1;
              v71 = (unsigned __int8)v71;
              v70[v71 + 13] = 64;
              v70[v71 + 1] = v2;
            }
          }
        }
      }
    }
    ++v2;
    v89 += 4;
  }
  v72 = byte_F2CD0;
  for ( i = 0; i < 7; ++i )
  {
    for ( j = 0; j < 7; ++j )
    {
      for ( k = 0; k < 7; ++k )
      {
        for ( l = 0; l < 7; ++l )
        {
          v77 = (_BYTE *)(v90 + 25 * (49 * j + 7 * k + l + 343 * i));
          if ( *v77 )
          {
            *v72 = v77[1];
            v72[1] = v77[13];
          }
          else
          {
            *v72 = 1;
            v72[1] = 0;
          }
          v72 += 2;
        }
      }
    }
  }
  v78 = 0;
  do
  {
    v79 = v78;
    if ( !byte_10B4E0[v78] )
    {
      LOBYTE(v78) = v78 + 1;
      v80 = byte_13B4E0[v79] & 7;
      v81 = v78;
      ++HIBYTE(v78);
      v82 = byte_13B4E0[v81];
      v83 = v78;
      LOBYTE(v78) = v78 - 1;
      v84 = 343 * v80 + 49 * (v82 & 7) + (byte_13B4E0[v78] & 7) + 7 * (byte_13B4E0[v83] & 7);
      v85 = *(_BYTE *)(v90 + 25 * v84);
      --HIBYTE(v78);
      if ( v85 )
      {
        word_17B4E0 = 9377 * word_17B4E0 + 9439;
        v86 = (unsigned __int16)word_17B4E0 % (unsigned __int16)(v85 + 1);
        if ( v86 >= v85 )
          v86 = 0;
        v87 = v86 + 25 * v84 + v90;
        LOWORD(v79) = v78;
        byte_10B4E0[v78] = *(_BYTE *)(v87 + 1);
        byte_13B4E0[v78] = (byte_13B4E0[v78] & 7) + *(_BYTE *)(v87 + 13);
      }
      else
      {
        LOWORD(v79) = v78;
        byte_10B4E0[v78] = 1;
      }
    }
    ++v78;
  }
  while ( v78 );
  return v79;
}
// 17B4E0: using guessed type __int16 word_17B4E0;
// 180628: using guessed type int dword_180628;

//----- (00044D00) --------------------------------------------------------
int sub_44D00()
{
  unsigned __int16 v0; // cx
  unsigned __int16 v1; // dx
  int result; // eax
  unsigned __int16 v3; // cx
  unsigned int v4; // et2
  char v5; // dl

  v0 = 0;
  word_17B4E0 = 0;
  do
  {
    LOBYTE(v0) = v0 + 1;
    HIWORD(result) = 0;
    ++HIBYTE(v0);
    LOWORD(result) = v0;
    LOBYTE(v0) = v0 - 2;
    HIBYTE(v0) -= 2;
    v1 = v0;
    LOBYTE(v0) = v0 + 1;
    LOBYTE(result) = byte_11B4E0[v1] - byte_11B4E0[(unsigned __int16)result] + 32;
    HIBYTE(v3) = HIBYTE(v0) + 1;
    if ( (_BYTE)result == 32 )
    {
      result = 9377 * (unsigned __int16)word_17B4E0;
      LOWORD(result) = result + 9439;
      word_17B4E0 = result;
      v4 = (unsigned __int16)result;
      BYTE1(result) = (unsigned __int16)((unsigned __int16)result / 9u) >> 8;
      LOBYTE(result) = v4 % 9 + 28;
    }
    else if ( (char)result >= 28 )
    {
      if ( (char)result > 40 )
        LOBYTE(result) = (result & 7) + 40;
    }
    else
    {
      LOBYTE(result) = (result & 3) + 28;
    }
    if ( *(_BYTE *)(dword_D41A0 + 196308) )
    {
      result = 32 - (char)result;
      v5 = result + 32;
    }
    else
    {
      v5 = result;
    }
    LOBYTE(result) = v5;
    byte_12B4E0[v3] = v5;
    v0 = v3 + 1;
  }
  while ( v0 );
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// 17B4E0: using guessed type __int16 word_17B4E0;

//----- (00044DB0) --------------------------------------------------------
int sub_44DB0()
{
  __int16 v0; // dx
  __int16 v1; // cx
  unsigned __int16 v2; // bx
  __int16 v3; // ax
  int v4; // edx
  int result; // eax

  v0 = -32000;
  v1 = 32000;
  v2 = 0;
  do
  {
    v3 = word_15B4E0[v2];
    if ( v3 > v0 )
      v0 = word_15B4E0[v2];
    if ( v3 < v1 )
      v1 = word_15B4E0[v2];
    ++v2;
  }
  while ( v2 );
  if ( v0 )
    v4 = 12845056 / v0;
  else
    v4 = 0;
  do
  {
    result = v4 * word_15B4E0[v2] >> 16;
    word_15B4E0[v2] = 0;
    if ( (result & 0x8000u) != 0 )
      result = 0;
    if ( (signed __int16)result > 196 )
      result = 196;
    byte_11B4E0[v2++] = result;
  }
  while ( v2 );
  return result;
}

//----- (00044E40) --------------------------------------------------------
unsigned __int16 __cdecl sub_44E40(int a1, unsigned __int8 a2)
{
  int v2; // edi
  unsigned __int16 v3; // si
  signed int v4; // ecx
  unsigned __int16 v5; // ax
  unsigned __int16 v6; // dx
  int v7; // eax
  int v8; // ebx
  unsigned __int16 result; // ax

  v2 = a1;
  v3 = 0;
  do
  {
    if ( byte_11B4E0[v3] )
      byte_13B4E0[v3] = 5;
    else
      byte_13B4E0[v3] = 0;
    ++v3;
  }
  while ( v3 );
LABEL_12:
  if ( v2 > 0 )
  {
    v4 = 1000;
    while ( 1 )
    {
      v8 = 0xFFFF;
      v5 = 9377 * word_17B4E0 + 9439;
      word_17B4E0 = v5;
      v6 = v5 % 0xFFFFu;
      v7 = v5;
      LOWORD(v7) = (unsigned __int16)v7 % 0xFFFFu;
      LOBYTE(v8) = byte_11B4E0[(unsigned __int16)v7];
      if ( !--v4 )
        break;
      if ( (unsigned __int8)v8 > a2 && byte_13B4E0[v7] )
      {
        --v2;
        sub_44EE0(v8, v6);
        goto LABEL_12;
      }
    }
  }
  do
  {
    result = v3;
    byte_10B4E0[v3++] = -1;
  }
  while ( v3 );
  return result;
}
// 17B4E0: using guessed type __int16 word_17B4E0;

//----- (00044EE0) --------------------------------------------------------
unsigned __int16 __usercall sub_44EE0@<ax>(int a1@<ebx>, int a2)
{
  int v2; // eax
  unsigned __int16 v3; // dx
  unsigned __int8 v4; // dh
  unsigned __int16 v5; // si
  int v6; // esi
  unsigned __int8 v7; // dl
  unsigned __int16 result; // ax

  v2 = a2;
  v3 = 0;
  do
    byte_10B4E0[v3++] = 3;
  while ( v3 );
  v4 = byte_11B4E0[(unsigned __int16)a2];
  do
  {
    v5 = v2;
    --BYTE1(v2);
    byte_10B4E0[v5] = 0;
    v6 = v5;
    LOWORD(v6) = v2;
    v7 = -1;
    if ( byte_10B4E0[(unsigned __int16)v2] && (unsigned __int8)byte_11B4E0[v6] < 0xFFu )
    {
      v7 = byte_11B4E0[v6];
      a1 = v2;
    }
    LOBYTE(v2) = v2 + 1;
    if ( byte_10B4E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_11B4E0[(unsigned __int16)v2] )
    {
      v7 = byte_11B4E0[(unsigned __int16)v2];
      a1 = v2;
    }
    ++BYTE1(v2);
    if ( byte_10B4E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_11B4E0[(unsigned __int16)v2] )
    {
      v7 = byte_11B4E0[(unsigned __int16)v2];
      a1 = v2;
    }
    ++BYTE1(v2);
    if ( byte_10B4E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_11B4E0[(unsigned __int16)v2] )
    {
      v7 = byte_11B4E0[(unsigned __int16)v2];
      a1 = v2;
    }
    LOBYTE(v2) = v2 - 1;
    if ( byte_10B4E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_11B4E0[(unsigned __int16)v2] )
    {
      v7 = byte_11B4E0[(unsigned __int16)v2];
      a1 = v2;
    }
    LOBYTE(v2) = v2 - 1;
    if ( byte_10B4E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_11B4E0[(unsigned __int16)v2] )
    {
      v7 = byte_11B4E0[(unsigned __int16)v2];
      a1 = v2;
    }
    --BYTE1(v2);
    if ( byte_10B4E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_11B4E0[(unsigned __int16)v2] )
    {
      v7 = byte_11B4E0[(unsigned __int16)v2];
      a1 = v2;
    }
    --BYTE1(v2);
    if ( byte_10B4E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_11B4E0[(unsigned __int16)v2] )
    {
      v7 = byte_11B4E0[(unsigned __int16)v2];
      a1 = v2;
    }
    if ( !byte_13B4E0[(unsigned __int16)a1] || v7 == -1 )
      break;
    if ( v7 > v4 )
      byte_11B4E0[(unsigned __int16)a1] = v4;
    v4 = byte_11B4E0[(unsigned __int16)a1];
    v2 = a1;
  }
  while ( v4 );
  result = 0;
  do
  {
    if ( !byte_10B4E0[result] )
      byte_13B4E0[result] = 0;
    ++result;
  }
  while ( result );
  return result;
}

//----- (00045060) --------------------------------------------------------
unsigned __int8 __cdecl sub_45060(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int16 v2; // dx
  unsigned __int8 result; // al
  unsigned __int8 v4; // ah
  unsigned __int16 v5; // dx

  qmemcpy(byte_10B4E0, byte_13B4E0, (unsigned int)sub_10000);
  v2 = 0;
  do
  {
    result = 0;
    v4 = -1;
    if ( byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( (unsigned __int8)byte_11B4E0[v2] < 0xFFu )
      v4 = byte_11B4E0[v2];
    --HIBYTE(v2);
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    LOBYTE(v2) = v2 + 1;
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    ++HIBYTE(v2);
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    ++HIBYTE(v2);
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    LOBYTE(v2) = v2 - 1;
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    LOBYTE(v2) = v2 - 1;
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    --HIBYTE(v2);
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    --HIBYTE(v2);
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    LOBYTE(v2) = v2 + 1;
    HIBYTE(v5) = HIBYTE(v2) + 1;
    if ( result < a1 && result - v4 <= a2 )
    {
      if ( byte_13B4E0[v5] )
        byte_13B4E0[v5] = 5;
    }
    v2 = v5 + 1;
  }
  while ( v2 );
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();

//----- (00045210) --------------------------------------------------------
char __cdecl sub_45210(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int16 v2; // dx
  int v3; // eax
  char v4; // t1
  unsigned __int8 v5; // bl
  unsigned __int8 v6; // bh
  unsigned __int16 v7; // dx
  int v8; // ecx

  qmemcpy(byte_10B4E0, byte_13B4E0, (unsigned int)sub_10000);
  v2 = 0;
  do
  {
    LOWORD(v3) = -256;
    v4 = byte_13B4E0[v2];
    v5 = 0;
    v6 = 0;
    if ( (unsigned __int8)byte_11B4E0[v2] > 0u )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( (unsigned __int8)byte_11B4E0[v2] < 0xFFu )
      BYTE1(v3) = byte_11B4E0[v2];
    --HIBYTE(v2);
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      v6 = 1;
    if ( byte_13B4E0[v2] == 2 )
      v5 = 1;
    LOBYTE(v2) = v2 + 1;
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      ++v6;
    if ( byte_13B4E0[v2] == 2 )
      ++v5;
    ++HIBYTE(v2);
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      ++v6;
    if ( byte_13B4E0[v2] == 2 )
      ++v5;
    ++HIBYTE(v2);
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      ++v6;
    if ( byte_13B4E0[v2] == 2 )
      ++v5;
    LOBYTE(v2) = v2 - 1;
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      ++v6;
    if ( byte_13B4E0[v2] == 2 )
      ++v5;
    LOBYTE(v2) = v2 - 1;
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      ++v6;
    if ( byte_13B4E0[v2] == 2 )
      ++v5;
    --HIBYTE(v2);
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      ++v6;
    if ( byte_13B4E0[v2] == 2 )
      ++v5;
    --HIBYTE(v2);
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      ++v6;
    if ( byte_13B4E0[v2] == 2 )
      ++v5;
    LOBYTE(v2) = v2 + 1;
    HIBYTE(v7) = HIBYTE(v2) + 1;
    if ( (unsigned __int8)v3 < a1 )
    {
      v8 = (unsigned __int8)v3 - BYTE1(v3);
      LOBYTE(v3) = a2;
      if ( v8 <= a2 && byte_13B4E0[v7] == 5 )
      {
        v3 = v6 + v5;
        if ( v3 == 8 )
          byte_13B4E0[v7] = 2;
      }
    }
    v2 = v7 + 1;
  }
  while ( v2 );
  return v3;
}
// 10000: using guessed type void __noreturn sub_10000();

//----- (000454F0) --------------------------------------------------------
unsigned __int16 __cdecl sub_454F0(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int16 result; // ax
  unsigned __int8 v3; // dh
  unsigned __int8 v4; // dl
  unsigned __int16 v5; // ax
  unsigned __int16 v6; // ax

  result = 0;
  do
  {
    if ( (unsigned __int8)byte_11B4E0[result] > a1 )
    {
      v3 = 0;
      v4 = -1;
      if ( byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      if ( (unsigned __int8)byte_11B4E0[result] < 0xFFu )
        v4 = byte_11B4E0[result];
      --HIBYTE(result);
      if ( v3 < (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      if ( v4 > (unsigned __int8)byte_11B4E0[result] )
        v4 = byte_11B4E0[result];
      LOBYTE(result) = result + 1;
      ++HIBYTE(result);
      if ( v3 < (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[v5];
      if ( v4 > (unsigned __int8)byte_11B4E0[v5] )
        v4 = byte_11B4E0[v5];
      ++HIBYTE(v5);
      LOBYTE(v5) = v5 - 1;
      if ( v3 < (unsigned __int8)byte_11B4E0[v5] )
        v3 = byte_11B4E0[v6];
      if ( v4 > (unsigned __int8)byte_11B4E0[v6] )
        v4 = byte_11B4E0[v6];
      LOBYTE(result) = v6 - 1;
      --HIBYTE(result);
      if ( v3 < (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      if ( v4 > (unsigned __int8)byte_11B4E0[result] )
        v4 = byte_11B4E0[result];
      LOBYTE(result) = result + 1;
      if ( byte_13B4E0[result] )
      {
        if ( v3 - v4 < a2 )
          byte_13B4E0[result] = 6;
      }
    }
    ++result;
  }
  while ( result );
  return result;
}

//----- (00045600) --------------------------------------------------------
unsigned __int16 __cdecl sub_45600(unsigned __int8 a1)
{
  unsigned __int16 result; // ax
  unsigned __int8 v2; // dh
  unsigned __int8 v3; // dl
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // ax
  unsigned __int16 v6; // ax
  __int16 v7; // bx
  char v8; // dh
  char v9; // dl
  char v10; // t0
  char v11; // t0
  char v12; // t0
  char v13; // t0
  char v14; // t0
  char v15; // t0
  char v16; // t0
  char v17; // t0
  char v18; // t0
  char v19; // t0
  char v20; // t0
  char v21; // t0
  char v22; // t0
  char v23; // t0
  char v24; // t0
  char v25; // t0
  char v26; // t0
  char v27; // t0
  char v28; // t0
  char v29; // t0
  char v30; // t0
  char v31; // t0
  char v32; // t0
  char v33; // t0

  qmemcpy(byte_10B4E0, byte_13B4E0, (unsigned int)sub_10000);
  result = 0;
  do
  {
    v2 = 0;
    v3 = -1;
    if ( byte_11B4E0[result] )
      v2 = byte_11B4E0[result];
    if ( (unsigned __int8)byte_11B4E0[result] < 0xFFu )
      v3 = byte_11B4E0[result];
    --HIBYTE(result);
    if ( v2 < (unsigned __int8)byte_11B4E0[result] )
      v2 = byte_11B4E0[result];
    if ( v3 > (unsigned __int8)byte_11B4E0[result] )
      v3 = byte_11B4E0[result];
    LOBYTE(result) = result + 1;
    ++HIBYTE(result);
    if ( v2 < (unsigned __int8)byte_11B4E0[result] )
      v2 = byte_11B4E0[v4];
    if ( v3 > (unsigned __int8)byte_11B4E0[v4] )
      v3 = byte_11B4E0[v4];
    ++HIBYTE(v4);
    LOBYTE(v4) = v4 - 1;
    if ( v2 < (unsigned __int8)byte_11B4E0[v4] )
      v2 = byte_11B4E0[v5];
    if ( v3 > (unsigned __int8)byte_11B4E0[v5] )
      v3 = byte_11B4E0[v5];
    LOBYTE(v5) = v5 - 1;
    --HIBYTE(v5);
    if ( v2 < (unsigned __int8)byte_11B4E0[v5] )
      v2 = byte_11B4E0[v6];
    if ( v3 > (unsigned __int8)byte_11B4E0[v6] )
      v3 = byte_11B4E0[v6];
    LOBYTE(v6) = v6 + 1;
    if ( byte_13B4E0[v6] && v2 - v3 >= a1 )
      byte_13B4E0[v6] = 1;
    result = v6 + 1;
  }
  while ( result );
  do
  {
    if ( byte_13B4E0[result] != 6 )
      goto LABEL_100;
    v7 = 0;
    --HIBYTE(result);
    v8 = 0;
    v9 = 0;
    if ( byte_13B4E0[result] == 3 )
      HIBYTE(v7) = 1;
    if ( byte_13B4E0[result] == 2 )
      v9 = 1;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = 1;
    v10 = byte_13B4E0[result];
    v11 = byte_13B4E0[result];
    if ( byte_13B4E0[result] == 4 )
      v8 = 1;
    v12 = byte_13B4E0[result];
    LOBYTE(result) = result + 1;
    if ( byte_13B4E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_13B4E0[result] == 2 )
      ++v9;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    v13 = byte_13B4E0[result];
    v14 = byte_13B4E0[result];
    if ( byte_13B4E0[result] == 4 )
      ++v8;
    v15 = byte_13B4E0[result];
    ++HIBYTE(result);
    if ( byte_13B4E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_13B4E0[result] == 2 )
      ++v9;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    v16 = byte_13B4E0[result];
    v17 = byte_13B4E0[result];
    if ( byte_13B4E0[result] == 4 )
      ++v8;
    v18 = byte_13B4E0[result];
    ++HIBYTE(result);
    if ( byte_13B4E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_13B4E0[result] == 2 )
      ++v9;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    v19 = byte_13B4E0[result];
    v20 = byte_13B4E0[result];
    if ( byte_13B4E0[result] == 4 )
      ++v8;
    v21 = byte_13B4E0[result];
    LOBYTE(result) = result - 1;
    if ( byte_13B4E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_13B4E0[result] == 2 )
      ++v9;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    v22 = byte_13B4E0[result];
    v23 = byte_13B4E0[result];
    if ( byte_13B4E0[result] == 4 )
      ++v8;
    v24 = byte_13B4E0[result];
    LOBYTE(result) = result - 1;
    if ( byte_13B4E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_13B4E0[result] == 2 )
      ++v9;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    v25 = byte_13B4E0[result];
    v26 = byte_13B4E0[result];
    if ( byte_13B4E0[result] == 4 )
      ++v8;
    v27 = byte_13B4E0[result];
    --HIBYTE(result);
    if ( byte_13B4E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_13B4E0[result] == 2 )
      ++v9;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    v28 = byte_13B4E0[result];
    v29 = byte_13B4E0[result];
    if ( byte_13B4E0[result] == 4 )
      ++v8;
    v30 = byte_13B4E0[result];
    --HIBYTE(result);
    if ( byte_13B4E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_13B4E0[result] == 2 )
      ++v9;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    v31 = byte_13B4E0[result];
    v32 = byte_13B4E0[result];
    if ( byte_13B4E0[result] == 4 )
      ++v8;
    v33 = byte_13B4E0[result];
    LOBYTE(result) = result + 1;
    ++HIBYTE(result);
    if ( HIBYTE(v7) )
    {
      if ( v9 || (_BYTE)v7 || v8 )
        goto LABEL_99;
    }
    else if ( v9 || (_BYTE)v7 && v8 )
    {
LABEL_99:
      byte_13B4E0[result] = 1;
      goto LABEL_100;
    }
LABEL_100:
    ++result;
  }
  while ( result );
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();

//----- (00045AA0) --------------------------------------------------------
unsigned __int16 sub_45AA0()
{
  unsigned __int16 result; // ax
  char v1; // dh
  unsigned __int16 v2; // cx
  unsigned __int8 v3; // dl
  unsigned __int8 v4; // bl
  unsigned __int16 v5; // cx
  unsigned __int16 v6; // cx
  unsigned __int16 v7; // cx
  unsigned __int16 v8; // cx
  char v9; // [esp+0h] [ebp-4h]

  do
  {
    result = 0;
    v9 = 0;
    do
    {
      v1 = 0;
      if ( !byte_13B4E0[result] )
        v1 = 1;
      v2 = result;
      LOBYTE(result) = result + 1;
      v3 = byte_11B4E0[v2];
      v4 = byte_11B4E0[v2];
      if ( !byte_13B4E0[result] )
        ++v1;
      if ( v3 > (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      if ( v4 < (unsigned __int8)byte_11B4E0[result] )
        v4 = byte_11B4E0[result];
      ++HIBYTE(result);
      if ( !byte_13B4E0[result] )
        ++v1;
      if ( v3 > (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      if ( v4 < (unsigned __int8)byte_11B4E0[result] )
        v4 = byte_11B4E0[result];
      LOBYTE(result) = result - 1;
      if ( !byte_13B4E0[result] )
        ++v1;
      if ( v3 > (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      if ( v4 < (unsigned __int8)byte_11B4E0[result] )
        v4 = byte_11B4E0[result];
      --HIBYTE(result);
      if ( v4 != v3 && v1 == 4 )
      {
        v9 = 1;
        v5 = result;
        LOBYTE(result) = result + 1;
        byte_11B4E0[v5] = v3;
        v6 = result;
        ++HIBYTE(result);
        byte_11B4E0[v6] = v3;
        v7 = result;
        LOBYTE(result) = result - 1;
        byte_11B4E0[v7] = v3;
        v8 = result;
        --HIBYTE(result);
        byte_11B4E0[v8] = v3;
      }
      ++result;
    }
    while ( result );
  }
  while ( v9 );
  return result;
}

//----- (00045BE0) --------------------------------------------------------
char __usercall sub_45BE0@<al>(char a1@<dl>, char a2@<cl>, unsigned __int16 a3)
{
  unsigned __int16 v3; // ax
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // dh
  unsigned __int8 v6; // bh
  unsigned __int8 v7; // al
  signed int v8; // edi
  char result; // al

  HIBYTE(v3) = HIBYTE(a3);
  v4 = -1;
  v5 = 0;
  if ( byte_11B4E0[a3] )
  {
    v5 = byte_11B4E0[a3];
    a1 = 0;
  }
  if ( (unsigned __int8)byte_11B4E0[a3] < 0xFFu )
    v4 = byte_11B4E0[a3];
  LOBYTE(v3) = a3 + 1;
  if ( (unsigned __int8)byte_11B4E0[v3] > v5 )
  {
    v5 = byte_11B4E0[v3];
    a1 = 1;
  }
  if ( (unsigned __int8)byte_11B4E0[v3] < v4 )
    v4 = byte_11B4E0[v3];
  HIBYTE(v3) = HIBYTE(a3) + 1;
  if ( (unsigned __int8)byte_11B4E0[v3] > v5 )
  {
    v5 = byte_11B4E0[v3];
    a1 = 2;
  }
  if ( (unsigned __int8)byte_11B4E0[v3] < v4 )
    v4 = byte_11B4E0[v3];
  LOBYTE(v3) = a3;
  if ( (unsigned __int8)byte_11B4E0[v3] > v5 )
  {
    v5 = byte_11B4E0[v3];
    a1 = 3;
  }
  if ( (unsigned __int8)byte_11B4E0[v3] < v4 )
    v4 = byte_11B4E0[v3];
  HIBYTE(v3) = HIBYTE(a3);
  v6 = 0;
  if ( a1 && byte_11B4E0[v3] )
  {
    v6 = byte_11B4E0[v3];
    a2 = 0;
  }
  LOBYTE(v3) = a3 + 1;
  if ( a1 != 1 && (unsigned __int8)byte_11B4E0[v3] > v6 )
  {
    v6 = byte_11B4E0[v3];
    a2 = 1;
  }
  HIBYTE(v3) = HIBYTE(a3) + 1;
  if ( a1 != 2 && (unsigned __int8)byte_11B4E0[v3] > v6 )
  {
    v6 = byte_11B4E0[v3];
    a2 = 2;
  }
  LOBYTE(v3) = a3;
  if ( a1 != 3 )
  {
    v7 = byte_11B4E0[v3];
    if ( v7 > v6 )
    {
      a2 = 3;
      v6 = v7;
    }
  }
  v8 = 0;
  if ( v5 - v4 <= 8 )
    v8 = 1;
  if ( v5 - v6 >= 8 )
  {
    result = a1;
LABEL_44:
    dword_D47DC = v8;
    return result;
  }
  if ( (unsigned __int8)a1 > 3u )
  {
    result = 0;
    goto LABEL_44;
  }
  switch ( a1 )
  {
    case 0:
      if ( a2 != 1 )
        goto LABEL_42;
      goto LABEL_36;
    case 1:
      if ( a2 == 2 )
        goto LABEL_38;
LABEL_36:
      result = 4;
      dword_D47DC = v8;
      return result;
    case 2:
      if ( a2 == 3 )
        goto LABEL_40;
LABEL_38:
      result = 5;
      dword_D47DC = v8;
      break;
    case 3:
      if ( a2 )
      {
LABEL_40:
        result = 6;
        dword_D47DC = v8;
      }
      else
      {
LABEL_42:
        result = 7;
        dword_D47DC = v8;
      }
      break;
  }
  return result;
}
// D47DC: using guessed type int dword_D47DC;

//----- (00045DC0) --------------------------------------------------------
char __usercall sub_45DC0@<al>(char a1@<dl>, char a2@<cl>, unsigned __int16 a3, unsigned __int8 a4)
{
  unsigned __int16 v4; // bx
  int v5; // eax
  char v6; // ch
  char *v7; // eax
  char v8; // al
  char v9; // ah
  unsigned __int8 v10; // al
  char v11; // cl
  unsigned __int8 v12; // dh
  unsigned __int8 v13; // dh
  char v14; // cl
  unsigned __int8 v15; // dh
  char v16; // cl
  unsigned __int8 v17; // dh
  char v18; // bl
  unsigned __int16 v19; // ax
  char v20; // ch
  unsigned __int16 v21; // ax
  char v22; // dl
  unsigned __int8 v24; // [esp+0h] [ebp-4h]

  HIBYTE(v4) = HIBYTE(a3);
  v24 = 8 * ((HIBYTE(a3) + a3) & 1);
  if ( a4 >= 8u )
  {
    switch ( a4 )
    {
      case 8u:
        byte_10B4E0[a3] = 8;
        break;
      case 9u:
        byte_10B4E0[a3] = 9;
        break;
      case 0xAu:
        v8 = sub_45BE0(a1, a2, a3);
        v9 = v8;
        if ( dword_D47DC )
          v9 = v8 + 8;
        v10 = v9;
        goto LABEL_28;
      case 0xBu:
        v10 = sub_45BE0(a1, a2, a3) + 16;
        if ( dword_D47DC )
          v10 += 8;
        goto LABEL_28;
      case 0xCu:
        v10 = sub_45BE0(a1, a2, a3) + 32;
        if ( dword_D47DC )
          v10 += 8;
        goto LABEL_28;
      case 0xDu:
        v10 = sub_45BE0(a1, a2, a3) + 48;
        if ( dword_D47DC )
          v10 += 8;
        goto LABEL_28;
      case 0xEu:
        v10 = sub_45BE0(a1, a2, a3) + 64;
        if ( dword_D47DC )
          v10 += 8;
LABEL_28:
        v7 = (char *)&unk_D4AB0 + 2 * v10;
        goto LABEL_29;
      case 0xFu:
        byte_10B4E0[a3] = 11;
        break;
      case 0x10u:
        v6 = byte_10B4E0[a3];
        if ( v6 == 10 || v6 == 11 || v6 == 12 )
          break;
        v7 = (char *)&unk_D4A30 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3);
        goto LABEL_29;
      case 0x11u:
        v7 = (char *)&unk_D4A70 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3);
        goto LABEL_29;
      case 0x12u:
        v7 = (char *)&unk_D4A80 + 2 * (v24 + (unsigned __int8)sub_45BE0(a1, a2, a3));
        goto LABEL_29;
      case 0x13u:
        v7 = (char *)&unk_D4A80 + 2 * ((unsigned __int8)sub_45BE0(a1, a2, a3) + v24) + 16;
        goto LABEL_29;
      case 0x14u:
        v7 = (char *)&unk_D4A40 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3);
        goto LABEL_29;
      case 0x15u:
        v7 = (char *)&unk_D4A40 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3) + 16;
        goto LABEL_29;
      case 0x16u:
        v7 = (char *)&unk_D4A40 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3) + 32;
LABEL_29:
        byte_10B4E0[a3] = *v7;
        byte_13B4E0[a3] = byte_13B4E0[a3] & 0x8F | v7[1];
        break;
      default:
        break;
    }
    v11 = byte_13B4E0[a3] | 0x80;
    byte_13B4E0[a3] = v11;
    if ( byte_D41B6 )
    {
      v12 = byte_11B4E0[a3];
      if ( (unsigned __int8)byte_14B4E0[a3] > v12 )
      {
        byte_13B4E0[a3] = v11 & 0xF7;
      }
      else
      {
        byte_13B4E0[a3] = v11 | 8;
        byte_14B4E0[a3] = v12 - 1;
      }
      LOBYTE(v4) = a3 + 1;
      v13 = byte_11B4E0[v4];
      if ( (unsigned __int8)byte_14B4E0[v4] > v13 )
      {
        byte_13B4E0[v4] &= 0xF7u;
      }
      else
      {
        v14 = byte_13B4E0[v4] | 8;
        byte_14B4E0[v4] = v13 - 1;
        byte_13B4E0[v4] = v14;
      }
      HIBYTE(v4) = HIBYTE(a3) + 1;
      v15 = byte_11B4E0[v4];
      if ( (unsigned __int8)byte_14B4E0[v4] > v15 )
      {
        byte_13B4E0[v4] &= 0xF7u;
      }
      else
      {
        v16 = byte_13B4E0[v4] | 8;
        byte_14B4E0[v4] = v15 - 1;
        byte_13B4E0[v4] = v16;
      }
      LOBYTE(v4) = a3;
      v5 = v4;
      v17 = byte_11B4E0[v4];
      if ( (unsigned __int8)byte_14B4E0[v4] <= v17 )
      {
        v18 = byte_13B4E0[v4] | 8;
        byte_14B4E0[v5] = v17 - 1;
        byte_13B4E0[v5] = v18;
        return v5;
      }
    }
    else
    {
      LOBYTE(v4) = a3 + 1;
      byte_13B4E0[a3] = v11 & 0xF7;
      v19 = v4;
      v20 = byte_13B4E0[v4] & 0xF7;
      HIBYTE(v4) = HIBYTE(a3) + 1;
      byte_13B4E0[v19] = v20;
      v21 = v4;
      v22 = byte_13B4E0[v4] & 0xF7;
      LOBYTE(v4) = a3;
      byte_13B4E0[v21] = v22;
      v5 = v21;
      LOWORD(v5) = v4;
    }
    byte_13B4E0[v5] &= 0xF7u;
    return v5;
  }
  byte_13B4E0[a3] = a4 | byte_13B4E0[a3] & 0xF0;
  LOBYTE(v5) = sub_462A0(a3, a3);
  return v5;
}
// D41B6: using guessed type char byte_D41B6;
// D47DC: using guessed type int dword_D47DC;

//----- (00046180) --------------------------------------------------------
unsigned __int16 __cdecl sub_46180(unsigned __int16 a1, char a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // bx
  unsigned __int16 v4; // bx
  unsigned __int16 v5; // bx
  unsigned __int16 result; // ax
  char v7; // bl
  char i; // bh
  unsigned __int16 v9; // si
  int v10; // edx

  HIBYTE(v2) = HIBYTE(a1);
  LOBYTE(v2) = a1 - 1;
  byte_10B4E0[a1] = a2;
  v3 = v2;
  HIBYTE(result) = HIBYTE(a1) - 1;
  byte_10B4E0[v3] = a2;
  v4 = result;
  LOBYTE(result) = a1;
  byte_10B4E0[v4] = a2;
  v5 = result;
  LOBYTE(result) = a1 - 1;
  byte_10B4E0[v5] = a2;
  v7 = 3;
  do
  {
    for ( i = 3; i; --i )
    {
      LOBYTE(result) = result + 1;
      ++HIBYTE(result);
      LOWORD(v10) = result;
      LOBYTE(result) = result - 2;
      HIBYTE(result) -= 2;
      v9 = result;
      LOBYTE(result) = result + 1;
      LOBYTE(v10) = byte_11B4E0[v9] - byte_11B4E0[(unsigned __int16)v10] + 32;
      ++HIBYTE(result);
      if ( (char)v10 >= 28 )
      {
        if ( (char)v10 > 40 )
          LOBYTE(v10) = (v10 & 7) + 40;
      }
      else
      {
        LOBYTE(v10) = (v10 & 3) + 28;
      }
      if ( *(_BYTE *)(dword_D41A0 + 196308) )
        v10 = 32 - (char)v10 + 32;
      byte_12B4E0[result] = v10;
      if ( byte_D41B6 && (unsigned __int8)byte_14B4E0[result] <= (unsigned __int8)byte_11B4E0[result] )
      {
        byte_14B4E0[result] = byte_11B4E0[result] - 1;
        byte_13B4E0[result] |= 8u;
      }
      else
      {
        byte_13B4E0[result] &= 0xF7u;
      }
      LOBYTE(result) = result + 1;
    }
    LOBYTE(result) = result - 3;
    --v7;
    ++HIBYTE(result);
  }
  while ( v7 );
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;

//----- (000462A0) --------------------------------------------------------
char __cdecl sub_462A0(unsigned __int16 a1, __int16 a2)
{
  unsigned __int16 v2; // cx
  _BOOL1 v3; // zf
  int v4; // eax
  unsigned __int16 v5; // cx
  int v6; // edx
  unsigned __int16 v7; // ax
  int v8; // edx
  int v9; // ebx
  int v10; // eax
  int v11; // edx
  char v12; // ST10_1
  unsigned __int16 v13; // cx
  char v14; // dh
  char j; // dl
  unsigned __int16 v16; // ax
  unsigned __int16 v17; // bx
  char v18; // al
  char v19; // bl
  unsigned __int8 v20; // bh
  char i; // [esp+0h] [ebp-14h]
  char v23; // [esp+4h] [ebp-10h]
  char v24; // [esp+4h] [ebp-10h]
  char v25; // [esp+8h] [ebp-Ch]
  char v26; // [esp+8h] [ebp-Ch]
  char v27; // [esp+8h] [ebp-Ch]
  char v28; // [esp+Ch] [ebp-8h]
  unsigned __int16 v29; // [esp+24h] [ebp+10h]

  LOBYTE(v4) = a2 - a1 + 1;
  v2 = a1;
  v25 = a2 - a1 + 1;
  BYTE1(v4) = HIBYTE(a2) - HIBYTE(a1) + 1;
  v3 = BYTE1(v4) == 0;
  v23 = HIBYTE(a2) - HIBYTE(a1) + 1;
  while ( !v3 )
  {
    LOBYTE(v4) = a2 - a1 + 1;
    while ( (_BYTE)v4 )
    {
      if ( byte_13B4E0[v2] >= 0 )
        byte_10B4E0[v2] = 1;
      LOBYTE(v2) = v2 - 1;
      if ( byte_13B4E0[v2] >= 0 )
        byte_10B4E0[v2] = 1;
      --HIBYTE(v2);
      if ( byte_13B4E0[v2] >= 0 )
        byte_10B4E0[v2] = 1;
      LOBYTE(v2) = v2 + 1;
      if ( byte_13B4E0[v2] >= 0 )
        byte_10B4E0[v2] = 1;
      ++HIBYTE(v2);
      LOBYTE(v4) = v4 - 1;
      LOBYTE(v2) = v2 + 1;
    }
    LOBYTE(v2) = v2 - v25;
    ++HIBYTE(v2);
    v3 = --BYTE1(v4) == 0;
  }
  LOBYTE(a1) = a1 - 1;
  --HIBYTE(a1);
  v24 = v23 + 1;
  v28 = v24;
  v5 = a1;
  v26 = v25 + 1;
  while ( v28 )
  {
    LOBYTE(v4) = v26;
    for ( i = v26; i; --i )
    {
      v4 = v5;
      if ( byte_10B4E0[v5] == 1 )
      {
        LOBYTE(v5) = v5 + 1;
        v6 = 343 * (byte_13B4E0[v4] & 7);
        v7 = v5;
        ++HIBYTE(v5);
        v8 = 49 * (byte_13B4E0[v7] & 7) + v6;
        v9 = byte_13B4E0[v5] & 7;
        LOBYTE(v5) = v5 - 1;
        v10 = byte_13B4E0[v5] & 7;
        --HIBYTE(v5);
        v11 = 2 * (v10 + 7 * v9 + v8);
        LOBYTE(v10) = byte_F2CD0[v11];
        byte_10B4E0[v5] = v10;
        if ( (unsigned __int8)v10 >= 8u )
        {
          LOBYTE(v4) = byte_F2CD1[v11] + (byte_13B4E0[v5] & 0x87);
        }
        else
        {
          v12 = byte_13B4E0[v5] & 0x87;
          word_17B4E0 = 9377 * word_17B4E0 + 9439;
          LOBYTE(v4) = v12 + 16 * ((unsigned __int16)word_17B4E0 % 7u);
        }
        byte_13B4E0[v5] = v4;
      }
      LOBYTE(v5) = v5 + 1;
    }
    LOBYTE(v5) = v5 - v26;
    ++HIBYTE(v5);
    --v28;
  }
  v27 = v26 + 1;
  v13 = v29;
  v14 = v24 + 1;
  if ( v24 != -1 )
  {
    do
    {
      for ( j = v27; j; --j )
      {
        LOBYTE(v13) = v13 + 1;
        ++HIBYTE(v13);
        v16 = v13;
        LOBYTE(v13) = v13 - 2;
        HIBYTE(v13) -= 2;
        v17 = v13;
        LOBYTE(v13) = v13 + 1;
        v18 = byte_11B4E0[v17] - byte_11B4E0[v16] + 32;
        ++HIBYTE(v13);
        if ( v18 >= 28 )
        {
          if ( v18 > 40 )
            v18 = (v18 & 7) + 40;
        }
        else
        {
          v18 = (v18 & 3) + 28;
        }
        if ( *(_BYTE *)(dword_D41A0 + 196308) )
          v19 = 32 - v18 + 32;
        else
          v19 = v18;
        v4 = v13;
        byte_12B4E0[v13] = v19;
        if ( byte_D41B6 && (v20 = byte_11B4E0[v13], (unsigned __int8)byte_14B4E0[v13] <= v20) )
        {
          byte_14B4E0[v13] = v20 - 1;
          byte_13B4E0[v13] |= 8u;
        }
        else
        {
          byte_13B4E0[v13] &= 0xF7u;
        }
        LOBYTE(v13) = v13 + 1;
      }
      LOBYTE(v13) = v13 - v27;
      --v14;
      ++HIBYTE(v13);
    }
    while ( v14 );
  }
  return v4;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// 17B4E0: using guessed type __int16 word_17B4E0;

//----- (00046570) --------------------------------------------------------
char __cdecl sub_46570(unsigned __int16 a1, __int16 a2)
{
  unsigned __int16 v2; // cx
  _BOOL1 v3; // zf
  int v4; // eax
  unsigned __int16 v5; // dx
  unsigned __int16 v6; // dx
  unsigned __int16 v7; // dx
  unsigned __int16 v8; // dx
  unsigned __int16 v9; // cx
  int v10; // edx
  unsigned __int16 v11; // ax
  int v12; // edx
  int v13; // ebx
  int v14; // eax
  int v15; // edx
  char v16; // ST0C_1
  unsigned __int16 v17; // cx
  char v18; // dh
  char j; // dl
  unsigned __int16 v20; // ax
  unsigned __int16 v21; // bx
  char v22; // al
  char v23; // bl
  unsigned __int8 v24; // bh
  char i; // [esp+0h] [ebp-14h]
  char v27; // [esp+4h] [ebp-10h]
  char v28; // [esp+4h] [ebp-10h]
  char v29; // [esp+8h] [ebp-Ch]
  char v30; // [esp+8h] [ebp-Ch]
  char v31; // [esp+8h] [ebp-Ch]
  char v32; // [esp+10h] [ebp-4h]
  unsigned __int16 v33; // [esp+24h] [ebp+10h]

  LOBYTE(v4) = a2 - a1 + 1;
  v2 = a1;
  v29 = a2 - a1 + 1;
  BYTE1(v4) = HIBYTE(a2) - HIBYTE(a1) + 1;
  v3 = BYTE1(v4) == 0;
  v27 = HIBYTE(a2) - HIBYTE(a1) + 1;
  while ( !v3 )
  {
    LOBYTE(v4) = a2 - a1 + 1;
    while ( (_BYTE)v4 )
    {
      v5 = v2;
      LOBYTE(v2) = v2 - 1;
      byte_10B4E0[v5] = 1;
      v6 = v2;
      --HIBYTE(v2);
      byte_10B4E0[v6] = 1;
      v7 = v2;
      LOBYTE(v2) = v2 + 1;
      byte_10B4E0[v7] = 1;
      v8 = v2;
      LOBYTE(v4) = v4 - 1;
      ++HIBYTE(v2);
      byte_10B4E0[v8] = 1;
      LOBYTE(v2) = v2 + 1;
    }
    LOBYTE(v2) = v2 - v29;
    ++HIBYTE(v2);
    v3 = --BYTE1(v4) == 0;
  }
  LOBYTE(a1) = a1 - 1;
  --HIBYTE(a1);
  v28 = v27 + 1;
  v32 = v28;
  v9 = a1;
  v30 = v29 + 1;
  while ( v32 )
  {
    LOBYTE(v4) = v30;
    for ( i = v30; i; --i )
    {
      v4 = v9;
      if ( byte_10B4E0[v9] == 1 )
      {
        LOBYTE(v9) = v9 + 1;
        v10 = 343 * (byte_13B4E0[v4] & 7);
        v11 = v9;
        ++HIBYTE(v9);
        v12 = 49 * (byte_13B4E0[v11] & 7) + v10;
        v13 = byte_13B4E0[v9] & 7;
        LOBYTE(v9) = v9 - 1;
        v14 = byte_13B4E0[v9] & 7;
        --HIBYTE(v9);
        v15 = 2 * (v14 + 7 * v13 + v12);
        LOBYTE(v14) = byte_F2CD0[v15];
        byte_10B4E0[v9] = v14;
        if ( (unsigned __int8)v14 >= 8u )
        {
          LOBYTE(v4) = byte_F2CD1[v15] + (byte_13B4E0[v9] & 0x87);
        }
        else
        {
          v16 = byte_13B4E0[v9] & 0x87;
          word_17B4E0 = 9377 * word_17B4E0 + 9439;
          LOBYTE(v4) = v16 + 16 * ((unsigned __int16)word_17B4E0 % 7u);
        }
        byte_13B4E0[v9] = v4;
      }
      LOBYTE(v9) = v9 + 1;
    }
    LOBYTE(v9) = v9 - v30;
    ++HIBYTE(v9);
    --v32;
  }
  v31 = v30 + 1;
  v17 = v33;
  v18 = v28 + 1;
  if ( v28 != -1 )
  {
    do
    {
      for ( j = v31; j; --j )
      {
        LOBYTE(v17) = v17 + 1;
        ++HIBYTE(v17);
        v20 = v17;
        LOBYTE(v17) = v17 - 2;
        HIBYTE(v17) -= 2;
        v21 = v17;
        LOBYTE(v17) = v17 + 1;
        v22 = byte_11B4E0[v21] - byte_11B4E0[v20] + 32;
        ++HIBYTE(v17);
        if ( v22 >= 28 )
        {
          if ( v22 > 40 )
            v22 = (v22 & 7) + 40;
        }
        else
        {
          v22 = (v22 & 3) + 28;
        }
        if ( *(_BYTE *)(dword_D41A0 + 196308) )
          v23 = 32 - v22 + 32;
        else
          v23 = v22;
        v4 = v17;
        byte_12B4E0[v17] = v23;
        if ( byte_D41B6 && (v24 = byte_11B4E0[v17], (unsigned __int8)byte_14B4E0[v17] <= v24) )
        {
          byte_14B4E0[v17] = v24 - 1;
          byte_13B4E0[v17] |= 8u;
        }
        else
        {
          byte_13B4E0[v17] &= 0xF7u;
        }
        LOBYTE(v17) = v17 + 1;
      }
      LOBYTE(v17) = v17 - v31;
      --v18;
      ++HIBYTE(v17);
    }
    while ( v18 );
  }
  return v4;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// 17B4E0: using guessed type __int16 word_17B4E0;

//----- (00046820) --------------------------------------------------------
int sub_46820()
{
  ++dword_17DB54;
  return 0;
}
// 17DB54: using guessed type int dword_17DB54;

//----- (00046830) --------------------------------------------------------
int __usercall sub_46830@<eax>(signed __int16 *a1@<ebx>, signed int a2@<edi>, unsigned __int16 a3@<si>)
{
  int result; // eax
  int v4; // eax
  int v5; // edx
  unsigned __int16 v6; // dx
  _BOOL1 v7; // al
  unsigned __int8 v8; // dl
  unsigned __int8 v9; // al
  unsigned __int8 v10; // al
  int v11; // eax
  char v12; // ch
  _WORD *v13; // eax

  *(_DWORD *)(dword_D41A4 + 30) = 0;
  *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11234) = 0;
  while ( 1 )
  {
    result = dword_D41A0;
    if ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11234) )
      return result;
    v4 = sub_48350();
    sub_76930(v4, v5, a1);
    if ( !*(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11234) )
    {
      v6 = *(_WORD *)(dword_D41A4 + 43);
      v7 = v6 > 0x18u && v6 < 0x32u;
      sub_47FC0(v7);
      sub_56A30(a3);
      sub_47160();
      while ( !*(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11234) )
      {
        if ( byte_E37FC && byte_E37FD && word_E3804 )
        {
          v8 = *(_BYTE *)(dword_D41A0 + 196308);
          if ( v8 < 1u )
          {
            if ( !v8 )
              *(_DWORD *)(dword_D41A0 + 565) = 2;
          }
          else if ( v8 <= 1u )
          {
            *(_DWORD *)(dword_D41A0 + 565) = 1;
          }
          else if ( v8 == 2 )
          {
            *(_DWORD *)(dword_D41A0 + 565) = 3;
          }
        }
        sub_6EDB0();
        sub_47320(a2);
        sub_53CC0();
        sub_8D8F0();
        sub_8E020();
        sub_86860(word_1803EC);
        sub_59BF0();
        sub_90B27(0, 0x10u, 0);
        if ( word_180660 & 1 )
        {
          v9 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
          a1 = (signed __int16 *)dword_180628;
          sub_72883(v9, (void *)dword_180628, 0xC8u, v9);
        }
        else
        {
          v10 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
          a3 = dword_180628;
          sub_728A9(v10, (void *)dword_180628, 0x1E0u, v10);
        }
        if ( word_180660 & 1 )
          sub_90478();
        else
          sub_75200(480);
        if ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) & 2
          && !(*(_BYTE *)(dword_D41A4 + 38545) & 4) )
        {
          sub_6DB50(1, 0);
        }
        sub_713A0();
        v11 = 2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0;
        v12 = *(_BYTE *)(v11 + 11232);
        if ( v12 & 4 )
        {
          sub_56D60(a3, 0);
          *(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) = 4;
        }
        else if ( v12 & 2 )
        {
          sub_5C530();
          if ( *(_BYTE *)(dword_D41A4 + 38545) & 0x20 )
            sub_6E0D0();
        }
        else
        {
          LOBYTE(a1) = v12 | 8;
          *(_BYTE *)(v11 + 11232) = v12 | 8;
        }
        BYTE1(a1) = *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232);
        if ( BYTE1(a1) & 0x10 )
        {
          a3 = *(_WORD *)(dword_D41A4 + 43);
          if ( a3 >= 0x18u )
          {
            if ( BYTE1(a1) & 2 )
              sub_5C530();
            break;
          }
          if ( BYTE1(a1) & 2 )
          {
            v13 = sub_824B0(a3);
            if ( v13 )
            {
              *(_WORD *)(dword_D41A4 + 43) = v13[3];
              sub_47FC0(1);
              sub_56A30(a3);
              sub_47160();
            }
          }
        }
        else if ( BYTE1(a1) & 0xA )
        {
          break;
        }
      }
      word_E29D8 = 4;
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E29D8: using guessed type __int16 word_E29D8;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E3804: using guessed type __int16 word_E3804;
// EA3D8: using guessed type int dword_EA3D8;
// 1803EC: using guessed type __int16 word_1803EC;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (00046B40) --------------------------------------------------------
void sub_46B40()
{
  int v0; // kr00_4
  char v1; // al
  unsigned __int8 v2; // al
  unsigned __int8 v3; // al

  v0 = dword_E3760;
  if ( byte_D41B4 )
  {
    sub_90B27(0, 0x10u, 0);
    sub_417A0();
    memset(dword_EA3D8, 0, 768);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
    if ( dword_E9C3C )
    {
      sub_83E80(dword_E9C3C);
      dword_E9C3C = 0;
    }
    sub_54600();
    sub_6EBF0((unsigned int **)&off_D918C);
    sub_6EBF0((unsigned int **)off_D91BC);
    sub_6EBF0((unsigned int **)&off_D91EC);
    sub_47130();
    if ( word_180660 == 1 )
    {
      sub_90D3F((int)aDataMsprd00Dat);
      word_180660 = 8;
    }
    else
    {
      sub_6EBF0((unsigned int **)&off_D91D4);
      sub_90D3F((int)aDataHsprd00Dat);
      word_180660 = 1;
    }
    sub_47160();
    sub_6EB90((unsigned int **)&off_D918C);
    sub_6EB90((unsigned int **)&off_D91EC);
    memset(dword_EA3D8, 0, 768);
    if ( word_180660 & 1 )
    {
      v1 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
      sub_72883(dword_180628, (void *)dword_180628, 0xC8u, v1);
    }
    else
    {
      v2 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
      sub_728A9(v2, (void *)dword_180628, 0x1E0u, v2);
    }
    memset(dword_EA3D8, 0, 768);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
    if ( word_180660 & 1 )
      sub_90D6E((unsigned __int8 *)dword_EA3D8);
    else
      sub_90E07((unsigned __int8 *)dword_EA3D8);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
    v3 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
    byte_EB3A8 = v3;
    if ( word_180660 & 1 )
      sub_72883(v3, (void *)dword_180628, 0xC8u, v3);
    else
      sub_728A9(v3, (void *)dword_180628, 0x1E0u, v3);
    sub_8CEDF();
    sub_8CD27(dword_EB394);
    *(_BYTE *)(dword_D41A4 + 51) = 2;
    if ( word_180660 == 1 )
      byte_D419D = 1;
    else
      byte_D419D = 3;
    sub_5BDC0(v0, SHIWORD(v0));
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D419D: using guessed type char byte_D419D;
// D41A4: using guessed type int dword_D41A4;
// D41B4: using guessed type char byte_D41B4;
// D918C: using guessed type int *off_D918C;
// D91BC: using guessed type int *off_D91BC[2];
// D91D4: using guessed type void *off_D91D4;
// D91EC: using guessed type int *off_D91EC;
// E3760: using guessed type int dword_E3760;
// E9C3C: using guessed type int dword_E9C3C;
// EA3D8: using guessed type int dword_EA3D8;
// EB394: using guessed type int dword_EB394;
// EB3A8: using guessed type char byte_EB3A8;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (00046DD0) --------------------------------------------------------
char __fastcall sub_46DD0(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // edx
  char v5; // bl
  char v6; // dl
  char v8; // [esp+0h] [ebp-40h]

  sub_83CC0(20);
  if ( !byte_D4B50 )
  {
    byte_D4B50 = 1;
    if ( *(_BYTE *)(dword_D41A4 + 22) & 0x40 )
    {
      sub_70910();
      byte_E37FD = 0;
      byte_E3799 = 0;
      byte_E37FC = 0;
      byte_E3798 = 0;
    }
    else
    {
      sprintf(&v8, aSS_3, aNetherw, aSound);
      sub_90EA0(*(unsigned __int8 *)(dword_D41A4 + 182) - 64, (unsigned int)&v8);
      v3 = sub_70910();
      sub_90FD0(v3, v4, a3);
      if ( !word_E2A14 )
        printf(aErrorNotEnough);
      if ( *(_BYTE *)(dword_D41A4 + 25) & 0x40 )
        sub_8EAD0(1);
    }
    if ( byte_E3798 || byte_E37FC )
    {
      dword_F42A4 = sub_92600((int)sub_46820);
      sub_92930(dword_F42A4, 0x78u);
      sub_92BA0(dword_F42A4);
      byte_D4B51 = 1;
    }
    else
    {
      sub_6FDA0();
    }
    v5 = byte_E3798;
    if ( !byte_E3798 && !byte_E37FC && byte_E2A28 )
    {
      sub_86860(word_1803EC);
      sub_86BD0();
      v6 = *(_BYTE *)(dword_D41A4 + 24) & 0xBF;
      byte_E2A28 = v5;
      *(_BYTE *)(dword_D41A4 + 24) = v6;
    }
  }
  return sub_83CC0(21);
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;
// D4B50: using guessed type char byte_D4B50;
// D4B51: using guessed type char byte_D4B51;
// E2A14: using guessed type __int16 word_E2A14;
// E2A28: using guessed type char byte_E2A28;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// F42A4: using guessed type int dword_F42A4;
// 1803EC: using guessed type __int16 word_1803EC;

//----- (00046F50) --------------------------------------------------------
void sub_46F50()
{
  if ( byte_D4B51 )
    sub_92DC0(dword_F42A4);
  else
    sub_6FE20();
  sub_986E0();
}
// D4B51: using guessed type char byte_D4B51;
// F42A4: using guessed type int dword_F42A4;

//----- (00046F80) --------------------------------------------------------
char *sub_46F80()
{
  unsigned __int8 v0; // al
  char *v1; // esi
  int v2; // esi
  char *result; // eax
  int v4; // eax
  char *v5; // ebx
  unsigned int v6; // esi
  unsigned int v7; // esi
  int v8; // [esp+0h] [ebp-2h]
  int v9; // [esp+4h] [ebp+2h]
  int v10; // [esp+8h] [ebp+6h]
  int v11; // [esp+Ch] [ebp+Ah]
  __int16 v12; // [esp+10h] [ebp+Eh]
  char v13; // [esp+40h] [ebp+3Eh]
  int v14; // [esp+80h] [ebp+7Eh]

  sub_47130();
  v0 = *(_BYTE *)(dword_D41A0 + 196308);
  if ( v0 >= 1u )
  {
    if ( v0 <= 1u )
    {
      if ( word_180660 == 1 )
      {
        strcpy(&v13, "data/mwebn0-0.dat");
        v1 = aDataMwebn00Tab;
      }
      else
      {
        strcpy(&v13, "data/hwebn0-0.dat");
        v1 = aDataHwebn00Tab;
      }
    }
    else
    {
      if ( v0 != 2 )
        goto LABEL_16;
      if ( word_180660 == 1 )
      {
        strcpy(&v13, "data/mwebc0-0.dat");
        v1 = aDataMwebc00Tab;
      }
      else
      {
        strcpy(&v13, "data/hwebc0-0.dat");
        v1 = aDataHwebc00Tab;
      }
    }
    goto LABEL_15;
  }
  if ( !v0 )
  {
    if ( word_180660 == 1 )
    {
      strcpy(&v13, "data/mwebd0-0.dat");
      v1 = aDataMwebd00Tab;
    }
    else
    {
      strcpy(&v13, "data/hwebd0-0.dat");
      v1 = aDataHwebd00Tab;
    }
LABEL_15:
    v8 = *(_DWORD *)v1;
    v2 = (int)(v1 + 4);
    v9 = *(_DWORD *)v2;
    v2 += 4;
    v10 = *(_DWORD *)v2;
    v2 += 4;
    v11 = *(_DWORD *)v2;
    v12 = *(_WORD *)(v2 + 4);
  }
LABEL_16:
  result = (char *)sub_53E60((int)&v13, (char *)dword_180628);
  if ( (signed int)result > 0 )
  {
    v4 = (int)(result + 8);
    LOBYTE(v4) = v4 & 0xF8;
    v14 = v4;
    result = (char *)sub_53E60((int)&v8, (char *)(v4 + dword_180628));
    v5 = result;
    if ( (signed int)result > 0 )
    {
      v6 = (unsigned int)&result[v14];
      result = (char *)sub_83CD0((int)&result[v14]);
      dword_D4188 = (int)result;
      if ( result )
      {
        qmemcpy(result, (const void *)dword_180628, v6);
        dword_D418C = dword_D4188 + v14;
        v7 = (unsigned int)&v5[dword_D4188 + v14];
        dword_D4190 = (int)&v5[dword_D4188 + v14];
        if ( word_180660 & 1 )
          result = (char *)sub_98709(dword_D4188 + v14, v7, dword_D4188);
        else
          result = (char *)sub_9874D((unsigned int *)(dword_D4188 + v14), v7, dword_D4188);
      }
    }
  }
  return result;
}
// D4188: using guessed type int dword_D4188;
// D418C: using guessed type int dword_D418C;
// D4190: using guessed type int dword_D4190;
// D41A0: using guessed type int dword_D41A0;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (00047130) --------------------------------------------------------
void sub_47130()
{
  if ( dword_D4188 )
  {
    sub_83E80(dword_D4188);
    dword_D4188 = 0;
    dword_D418C = 0;
    dword_D4190 = 0;
  }
}
// D4188: using guessed type int dword_D4188;
// D418C: using guessed type int dword_D418C;
// D4190: using guessed type int dword_D4190;

//----- (00047160) --------------------------------------------------------
char *sub_47160()
{
  unsigned __int8 v0; // al

  v0 = *(_BYTE *)(dword_D41A0 + 196308);
  if ( v0 < 1u )
  {
    if ( !v0 )
    {
      sprintf(aDataMsprd00Dat, aS, aDataMsprd00Dat_0);
      sprintf(aDataMsprd00Tab_0, aS, aDataMsprd00Tab);
      sprintf(aDataHsprd00Dat, aS, aDataHsprd00Dat_0);
      sprintf(aDataHsprd00Tab_0, aS, aDataHsprd00Tab);
    }
  }
  else if ( v0 <= 1u )
  {
    sprintf(aDataMsprd00Dat, aS, aDataMsprn00Dat);
    sprintf(aDataMsprd00Tab_0, aS, aDataMsprn00Tab);
    sprintf(aDataHsprd00Dat, aS, aDataHsprn00Dat);
    sprintf(aDataHsprd00Tab_0, aS, aDataHsprn00Tab);
  }
  else if ( v0 == 2 )
  {
    sprintf(aDataMsprd00Dat, aS, aDataMsprc00Dat);
    sprintf(aDataMsprd00Tab_0, aS, aDataMsprc00Tab);
    sprintf(aDataHsprd00Dat, aS, aDataHsprc00Dat);
    sprintf(aDataHsprd00Tab_0, aS, aDataHsprc00Tab);
  }
  if ( word_180660 == 1 )
  {
    sub_84250((int)aDataMsprd00Dat);
    if ( dword_E9C3C )
      sub_83E80(dword_E9C3C);
    dword_E9C3C = sub_83CD0(64000);
  }
  else
  {
    sub_84250((int)aDataHsprd00Dat);
    if ( dword_E9C3C )
      sub_83E80(dword_E9C3C);
    dword_E9C3C = sub_83CD0((int)&loc_4AFFE + 2);
    sub_6EB90((unsigned int **)&off_D91D4);
  }
  sub_6EB90((unsigned int **)off_D91BC);
  return sub_46F80();
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// D91BC: using guessed type int *off_D91BC[2];
// D91D4: using guessed type void *off_D91D4;
// E9C3C: using guessed type int dword_E9C3C;
// 180660: using guessed type __int16 word_180660;

//----- (00047320) --------------------------------------------------------
int __usercall sub_47320@<eax>(signed int a1@<edi>)
{
  _BYTE *v1; // ebx
  int v2; // esi
  unsigned int v3; // esi
  int v4; // edx
  int result; // eax

  *(_BYTE *)(dword_D41A4 + 51) = 0;
  v1 = 0;
  *(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) = 0;
  while ( 1 )
  {
    v4 = 2124 * *(signed __int16 *)(dword_D41A0 + 12);
    result = v4 + dword_D41A0;
    if ( *(_BYTE *)(v4 + dword_D41A0 + 11234) || *(_BYTE *)(result + 11232) & 8 )
      break;
    v2 = dword_17DB54;
    sub_47560(result, v4, v1, a1, dword_17DB54);
    v3 = v2 + 5;
    while ( v3 > dword_17DB54 )
      ;
    if ( (unsigned __int16)v1 < 2u )
    {
      sub_8E020();
      if ( (_WORD)v1 == 1 )
        sub_8E160(*(_WORD *)(dword_D41A0 + 565), 0x7Fu);
      ++v1;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 17DB54: using guessed type int dword_17DB54;

//----- (000473B0) --------------------------------------------------------
int sub_473B0()
{
  int result; // eax

  dword_EA3B4 = 0;
  result = (unsigned __int8)byte_1806E4;
  word_F42AE = (unsigned __int8)byte_1806E4;
  word_F42A8 = 64;
  return result;
}
// EA3B4: using guessed type int dword_EA3B4;
// F42A8: using guessed type __int16 word_F42A8;
// F42AE: using guessed type __int16 word_F42AE;
// 1806E4: using guessed type char byte_1806E4;

//----- (000473E0) --------------------------------------------------------
int sub_473E0()
{
  char v0; // bl
  __int16 v1; // ax

  v0 = 0;
  if ( dword_EA3B4 )
    return dword_EA3B4;
  if ( word_F42A8 )
    --word_F42A8;
  if ( !word_18074C && !word_18074A )
  {
    if ( byte_18068E || byte_18069A )
    {
      if ( (unsigned __int8)byte_1806E4 < 0x36u )
      {
        if ( byte_1806E4 != 42 )
          goto LABEL_24;
      }
      else if ( (unsigned __int8)byte_1806E4 > 0x36u
             && ((unsigned __int8)byte_1806E4 < 0x3Bu || (unsigned __int8)byte_1806E4 > 0x3Fu && byte_1806E4 != 66) )
      {
        goto LABEL_24;
      }
    }
    else if ( (unsigned __int8)byte_1806E4 < 0x3Bu )
    {
      if ( byte_1806E4 != 19 )
        goto LABEL_24;
    }
    else if ( (unsigned __int8)byte_1806E4 > 0x3Bu
           && ((unsigned __int8)byte_1806E4 < 0x3Fu || (unsigned __int8)byte_1806E4 > 0x41u) )
    {
LABEL_24:
      HIBYTE(v1) = HIBYTE(word_F42A8);
      if ( word_F42A8 )
      {
        word_F42AE = (unsigned __int8)byte_1806E4;
      }
      else
      {
        LOBYTE(v1) = byte_1806E4;
        if ( v1 != word_F42AE )
          v0 = 1;
      }
      goto LABEL_28;
    }
    sub_473B0();
    goto LABEL_24;
  }
  v0 = 1;
LABEL_28:
  if ( v0 )
    dword_EA3B4 = 1;
  return dword_EA3B4;
}
// EA3B4: using guessed type int dword_EA3B4;
// F42A8: using guessed type __int16 word_F42A8;
// F42AE: using guessed type __int16 word_F42AE;
// 18068E: using guessed type char byte_18068E;
// 18069A: using guessed type char byte_18069A;
// 1806E4: using guessed type char byte_1806E4;
// 18074A: using guessed type __int16 word_18074A;
// 18074C: using guessed type __int16 word_18074C;

//----- (00047560) --------------------------------------------------------
void __usercall sub_47560(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebx>, signed int a4@<edi>, __int16 a5@<si>)
{
  unsigned __int8 v5; // al
  signed int j; // ebx
  signed int i; // ebx
  int v8; // eax

  sub_47760(a1, a2, (int)a3);
  if ( !(*(_BYTE *)(dword_D41A4 + 24) & 1) )
    sub_715B0();
  sub_89D10();
  sub_17A00(a3, a4, a5);
  sub_51BB0(a4);
  sub_848A0();
  v5 = *(_BYTE *)(dword_D41A4 + 178);
  if ( v5 < 1u )
  {
    if ( !v5 )
      sub_57730();
  }
  else if ( v5 <= 1u )
  {
    for ( i = 0; i < 4; ++i )
      sub_57730();
  }
  else if ( v5 == 2 )
  {
    for ( j = 0; j < 8; ++j )
      sub_57730();
  }
  sub_84B80();
  sub_58F00();
  sub_59820();
  if ( !(*(_BYTE *)(dword_D41A4 + 24) & 1) )
    sub_57570();
  sub_575C0();
  sub_6E150();
  sub_2BE30();
  if ( *(_BYTE *)(dword_D41A4 + 10) )
    sub_871F0();
  *(_DWORD *)(dword_D41A4 + 196) = dword_17DB54 - *(_DWORD *)(dword_D41A4 + 196);
  sub_6FEC0();
  v8 = dword_D41A4;
  *(_DWORD *)(dword_D41A4 + 196) = dword_17DB54;
  if ( *(_BYTE *)(v8 + 51) >= 3u )
    sub_40F80();
}
// D41A4: using guessed type int dword_D41A4;
// 17DB54: using guessed type int dword_17DB54;

//----- (00047650) --------------------------------------------------------
int __fastcall sub_47650(int a1, int a2)
{
  unsigned __int8 v2; // al
  signed int v3; // esi
  int v4; // edx
  signed int v5; // ebx
  int v6; // ecx
  int v7; // eax
  int result; // eax

  qmemcpy((void *)dword_EA3D8, (const void *)dword_EA3B8, 0x300u);
  v2 = *(_BYTE *)(dword_D41A0 + 196308);
  if ( v2 < 1u )
  {
    if ( !v2 )
      a2 = *(char *)(dword_D41A4 + 11);
  }
  else if ( v2 <= 1u )
  {
    a2 = *(char *)(dword_D41A4 + 12);
  }
  else if ( v2 == 2 )
  {
    a2 = *(char *)(dword_D41A4 + 13);
  }
  v3 = 0;
  v4 = 6 * a2;
  while ( v3 < 256 )
  {
    v5 = 0;
    while ( v5 < 3 )
    {
      v6 = v4 + *(unsigned __int8 *)(dword_EA3D8 + v5 + 3 * v3);
      if ( v6 < 0 )
        v6 = 0;
      if ( v6 > 63 )
        LOBYTE(v6) = 63;
      v7 = v5++ + 3 * v3;
      *(_BYTE *)(dword_EA3D8 + v7) = v6;
    }
    ++v3;
  }
  result = dword_D41A4;
  *(_BYTE *)(dword_D41A4 + 180) = 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3B8: using guessed type int dword_EA3B8;
// EA3D8: using guessed type int dword_EA3D8;

//----- (00047760) --------------------------------------------------------
char __fastcall sub_47760(int a1, int a2, int a3)
{
  _BYTE *v3; // eax
  unsigned __int8 v4; // dl
  int v5; // ST00_4
  int v6; // edx
  unsigned __int8 v7; // al
  char *v8; // ST00_4
  char *v9; // ST00_4
  char *v10; // ST00_4
  signed int v11; // eax
  int v12; // edx
  signed int v13; // eax
  int v14; // ebx
  int v15; // ebx
  int v16; // ebx
  signed int v17; // edx
  int v18; // ebx
  int v19; // eax
  int v20; // ecx
  signed int v21; // eax
  int v22; // ebx
  signed int v23; // ebx
  int v24; // ecx
  __int64 v25; // rtt
  char v26; // al
  signed int v27; // eax
  int v28; // ebx

  v3 = (_BYTE *)dword_D41A4;
  v4 = *(_BYTE *)(dword_D41A4 + 51);
  *(_BYTE *)(dword_D41A4 + 181) = 0;
  if ( v4 < 2u )
  {
    sub_480A0((int)v3, v4, a3);
    v3 = (_BYTE *)dword_D41A4;
    ++v3[51];
  }
  else if ( v4 <= 2u )
  {
    v3[51] = v4 + 1;
    v5 = dword_EA3D8;
    v3[180] = 1;
    memset(v5, 0, 768);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
    v6 = dword_D41A0;
    v7 = *(_BYTE *)(dword_D41A0 + 196308);
    if ( v7 < 1u )
    {
      if ( !v7 )
      {
        sub_53E60((int)aDataPald0Dat, (char *)dword_EA3D8);
        sub_53E60((int)aDataClrd0Dat, byte_E8900);
      }
    }
    else if ( v7 <= 1u )
    {
      if ( *(_BYTE *)(dword_D41A0 + 196306) & 2 )
        sub_53E60((int)aDataPalf0Dat, (char *)dword_EA3D8);
      else
        sub_53E60((int)aDataPaln0Dat, (char *)dword_EA3D8);
      sub_53E60((int)aDataClrn0Dat, byte_E8900);
    }
    else if ( v7 == 2 )
    {
      sub_53E60((int)aDataPalc0Dat, (char *)dword_EA3D8);
      sub_53E60((int)aDataClrc0Dat, byte_E8900);
    }
    qmemcpy((void *)dword_EA3B8, (const void *)dword_EA3D8, 0x300u);
    sub_47650(768, v6);
    sub_90D27();
    byte_EB3A8 = byte_E8900[0];
    LOBYTE(v3) = sub_57640();
  }
  else if ( v4 == 3 )
  {
    switch ( v3[180] )
    {
      case 1:
        v8 = (char *)dword_EA3D8;
        v3[181] = 1;
        LOWORD(v3) = sub_90B27(v8, 4u, 1);
        if ( (_WORD)v3 == 4 )
        {
          LOBYTE(v3) = dword_D41A4;
          *(_BYTE *)(dword_D41A4 + 180) = 0;
        }
        break;
      case 2:
        v11 = 1;
        while ( v11 < 256 )
        {
          dword_F42A0 = *(unsigned __int8 *)(3 * v11 + dword_EA3D8) + 40;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA0[3 * v11] = dword_F42A0;
          dword_F42A0 = *(unsigned __int8 *)(3 * v11 + dword_EA3D8 + 1);
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA1[3 * v11] = dword_F42A0;
          dword_F42A0 = *(unsigned __int8 *)(3 * v11 + dword_EA3D8 + 2);
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          v12 = 3 * v11++;
          byte_F3FA2[v12] = dword_F42A0;
        }
        sub_90D27();
        sub_41A90((unsigned __int8 *)byte_F3FA0);
        v3 = (_BYTE *)dword_D41A4;
        *(_BYTE *)(dword_D41A4 + 180) = 1;
        v3[181] = 1;
        break;
      case 3:
        v13 = 1;
        while ( v13 < 256 )
        {
          v14 = *(signed __int16 *)(dword_D41A4 + 184);
          dword_F42A0 = *(unsigned __int8 *)(3 * v13 + dword_EA3D8);
          dword_F42A0 += -56 * v14 >> 8;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA0[3 * v13] = dword_F42A0;
          dword_F42A0 = *(unsigned __int8 *)(3 * v13 + dword_EA3D8 + 1);
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA1[3 * v13] = dword_F42A0;
          v15 = *(signed __int16 *)(dword_D41A4 + 184);
          dword_F42A0 = *(unsigned __int8 *)(3 * v13 + dword_EA3D8 + 2);
          dword_F42A0 += -56 * v15 >> 8;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          v16 = 3 * v13++;
          byte_F3FA2[v16] = dword_F42A0;
        }
        sub_90D27();
        sub_41A90((unsigned __int8 *)byte_F3FA0);
        v3 = (_BYTE *)dword_D41A4;
        *(_BYTE *)(dword_D41A4 + 180) = 1;
        v3[181] = 1;
        break;
      case 4:
        v17 = 1;
        while ( v17 < 256 )
        {
          v18 = dword_EA3D8;
          v19 = 3 * v17;
          v20 = *(unsigned __int8 *)(dword_EA3D8 + 3 * v17 + 2);
          dword_F42A0 = 255;
          byte_F3FA0[v19] = *(_BYTE *)(dword_EA3D8 + 3 * v17);
          byte_F3FA1[v19] = *(_BYTE *)(v18 + 3 * v17++ + 1);
          byte_F3FA2[v19] = 63;
        }
        sub_90D27();
        sub_41A90((unsigned __int8 *)byte_F3FA0);
        v3 = (_BYTE *)dword_D41A4;
        *(_BYTE *)(dword_D41A4 + 180) = 1;
        v3[181] = 1;
        break;
      case 5:
        memset(dword_EA3D8, 0, 768);
        v3 = (_BYTE *)dword_D41A4;
        *(_BYTE *)(dword_D41A4 + 180) = 10;
        v3[181] = 1;
        break;
      case 6:
        v21 = 1;
        while ( v21 < 256 )
        {
          dword_F42A0 = *(unsigned __int8 *)(3 * v21 + dword_EA3D8 + 2) + 48;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA0[3 * v21] = dword_F42A0;
          dword_F42A0 = *(unsigned __int8 *)(3 * v21 + dword_EA3D8 + 1) + 32;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA1[3 * v21] = dword_F42A0;
          dword_F42A0 = *(unsigned __int8 *)(3 * v21 + dword_EA3D8 + 2) + 32;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          v22 = 3 * v21++;
          byte_F3FA2[v22] = dword_F42A0;
        }
        sub_90D27();
        sub_41A90((unsigned __int8 *)byte_F3FA0);
        v3 = (_BYTE *)dword_D41A4;
        *(_BYTE *)(dword_D41A4 + 180) = 1;
        v3[181] = 1;
        break;
      case 7:
        v23 = 1;
        while ( v23 < 256 )
        {
          v24 = 3 * v23;
          v25 = *(unsigned __int8 *)(3 * v23 + dword_EA3D8)
              + *(unsigned __int8 *)(3 * v23 + dword_EA3D8 + 1)
              + *(unsigned __int8 *)(3 * v23 + dword_EA3D8 + 2);
          dword_F42A0 = (*(unsigned __int8 *)(3 * v23 + dword_EA3D8)
                       + *(unsigned __int8 *)(3 * v23 + dword_EA3D8 + 1)
                       + *(unsigned __int8 *)(3 * v23 + dword_EA3D8 + 2))
                      / 3;
          v26 = v25 / 3;
          byte_F3FA0[v24] = v26;
          byte_F3FA1[v24] = v26;
          ++v23;
          byte_F3FA2[v24] = v26;
        }
        sub_90D27();
        sub_41A90((unsigned __int8 *)byte_F3FA0);
        v3 = (_BYTE *)dword_D41A4;
        *(_BYTE *)(dword_D41A4 + 180) = 1;
        v3[181] = 1;
        break;
      case 8:
        v27 = 1;
        while ( v27 < 256 )
        {
          dword_F42A0 = *(unsigned __int8 *)(3 * v27 + dword_EA3D8) + 48;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA0[3 * v27] = dword_F42A0;
          dword_F42A0 = *(unsigned __int8 *)(3 * v27 + dword_EA3D8 + 1) + 48;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA1[3 * v27] = dword_F42A0;
          dword_F42A0 = *(unsigned __int8 *)(3 * v27 + dword_EA3D8 + 2) + 48;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          v28 = 3 * v27++;
          byte_F3FA2[v28] = dword_F42A0;
        }
        sub_90D27();
        sub_41A90((unsigned __int8 *)byte_F3FA0);
        v3 = (_BYTE *)dword_D41A4;
        *(_BYTE *)(dword_D41A4 + 180) = 9;
        v3[181] = 1;
        break;
      case 9:
        v9 = (char *)dword_EA3D8;
        v3[181] = 1;
        LOWORD(v3) = sub_90B27(v9, 0x10u, 1);
        if ( (_WORD)v3 == 16 )
        {
          LOBYTE(v3) = dword_D41A4;
          *(_BYTE *)(dword_D41A4 + 180) = 0;
        }
        break;
      case 0xA:
        v10 = (char *)dword_EA3D8;
        v3[181] = 1;
        LOWORD(v3) = sub_90B27(v10, 0x1Cu, 1);
        if ( (_WORD)v3 == 28 )
        {
          LOBYTE(v3) = dword_D41A4;
          *(_BYTE *)(dword_D41A4 + 180) = 0;
        }
        break;
      default:
        return (char)v3;
    }
  }
  return (char)v3;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3B8: using guessed type int dword_EA3B8;
// EA3D8: using guessed type int dword_EA3D8;
// EB3A8: using guessed type char byte_EB3A8;
// F42A0: using guessed type int dword_F42A0;

//----- (00047FC0) --------------------------------------------------------
int __cdecl sub_47FC0(char a1)
{
  int result; // eax

  sub_90B27(0, 0x10u, 0);
  if ( a1 )
    sub_53E60((int)aDataSmatitl2Da, (char *)dword_E9C38);
  else
    sub_53E60((int)aDataSmatitleDa, (char *)dword_E9C38);
  sub_85B20((_BYTE *)dword_E9C38, (_WORD *)dword_180628, 0x190u);
  if ( word_180660 & 1 )
    sub_90478();
  else
    sub_75200(480);
  if ( a1 )
    sub_53E60((int)aDataSmatitl2Pa, (char *)dword_EA3D8);
  else
    sub_53E60((int)aDataSmatitlePa, (char *)dword_EA3D8);
  sub_90B27((char *)dword_EA3D8, 0x20u, 0);
  result = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 570) = 1;
  *(_DWORD *)(result + 574) = 0;
  *(_DWORD *)(result + 578) = 0;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E9C38: using guessed type int dword_E9C38;
// EA3D8: using guessed type int dword_EA3D8;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (000480A0) --------------------------------------------------------
unsigned __int8 __fastcall sub_480A0(int a1, int a2, int a3)
{
  int v3; // ebx
  unsigned int v4; // eax
  int v5; // edx
  char *v6; // ST08_4

  v3 = j___clock(a1, a2, a3);
  sub_98790(0x1F4u, 0);
  do
    v4 = j___clock(v4, v5, v3) - v3;
  while ( v4 < 0x32 );
  sub_90B27(0, 0x10u, 0);
  v6 = (char *)dword_EA3D8;
  *(_DWORD *)(dword_D41A0 + 570) = 0;
  sub_53E60((int)aDataPald0Dat, v6);
  sub_53E60((int)aDataClrd0Dat, byte_E8900);
  return sub_48120();
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// EA3D8: using guessed type int dword_EA3D8;

//----- (00048120) --------------------------------------------------------
unsigned __int8 sub_48120()
{
  unsigned __int8 result; // al

  result = *(_BYTE *)(dword_D41A0 + 196308);
  if ( result >= 1u )
  {
    if ( result <= 1u )
    {
      byte_E88E0[0] = -92;
      byte_E88E1[0] = -86;
      byte_E88E3 = 119;
      byte_E88E2[0] = 123;
      byte_E88E4 = 125;
      byte_E88E5 = 123;
      byte_E88E7 = -58;
      byte_E88E8 = 123;
      byte_E88E6 = -64;
      byte_E88EC = -105;
      byte_E88EF = -41;
      byte_E88EB = 123;
      byte_E88F0 = -35;
      byte_E88E9 = 88;
    }
    else
    {
      if ( result != 2 )
        return result;
      byte_E88E0[0] = -32;
      byte_E88E1[0] = 88;
      byte_E88E3 = 119;
      byte_E88E2[0] = 123;
      byte_E88E4 = 125;
      byte_E88E5 = 123;
      byte_E88E7 = -58;
      byte_E88E8 = 123;
      byte_E88E9 = 88;
      byte_E88E6 = -64;
      byte_E88EC = -105;
      byte_E88EF = -41;
      byte_E88EB = 123;
      byte_E88F0 = -35;
    }
    byte_E88F3 = 98;
    byte_E88EA = 93;
    byte_E88F1 = 123;
    byte_E88ED = -99;
    byte_E88EE = 123;
    byte_E88F2 = 105;
    result = 123;
    byte_E88F4 = 123;
    byte_E88F5 = -55;
    byte_E88F7 = 123;
    byte_E88F6 = -49;
    return result;
  }
  if ( !result )
  {
    byte_E88E0[0] = 96;
    byte_E88E1[0] = 100;
    byte_E88E6 = 28;
    byte_E88E2[0] = 123;
    byte_E88E3 = 123;
    byte_E88E5 = 123;
    byte_E88E7 = 24;
    byte_E88E8 = 123;
    byte_E88ED = -105;
    result = -37;
    byte_E88E4 = 119;
    byte_E88E9 = 91;
    byte_E88EB = 123;
    byte_E88EF = -37;
    byte_E88F5 = 61;
    byte_E88EA = 87;
    byte_E88EC = -102;
    byte_E88EE = 123;
    byte_E88F0 = -40;
    byte_E88F1 = 123;
    byte_E88F6 = 58;
    byte_E88F2 = 118;
    byte_E88F3 = -96;
    byte_E88F7 = 123;
    byte_E88F4 = 123;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E88E3: using guessed type char byte_E88E3;
// E88E4: using guessed type char byte_E88E4;
// E88E5: using guessed type char byte_E88E5;
// E88E6: using guessed type char byte_E88E6;
// E88E7: using guessed type char byte_E88E7;
// E88E8: using guessed type char byte_E88E8;
// E88E9: using guessed type char byte_E88E9;
// E88EA: using guessed type char byte_E88EA;
// E88EB: using guessed type char byte_E88EB;
// E88EC: using guessed type char byte_E88EC;
// E88ED: using guessed type char byte_E88ED;
// E88EE: using guessed type char byte_E88EE;
// E88EF: using guessed type char byte_E88EF;
// E88F0: using guessed type char byte_E88F0;
// E88F1: using guessed type char byte_E88F1;
// E88F2: using guessed type char byte_E88F2;
// E88F3: using guessed type char byte_E88F3;
// E88F4: using guessed type char byte_E88F4;
// E88F5: using guessed type char byte_E88F5;
// E88F6: using guessed type char byte_E88F6;
// E88F7: using guessed type char byte_E88F7;

//----- (00048350) --------------------------------------------------------
int sub_48350()
{
  int result; // eax

  *(_BYTE *)(dword_D41A4 + 38545) &= 0x43u;
  result = dword_D41A0;
  *(_BYTE *)(result + 224779) &= 0xFEu;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00048370) --------------------------------------------------------
int __cdecl sub_48370(__int16 a1, __int16 a2, __int16 a3)
{
  int result; // eax
  int v4; // ebx
  int v5; // edx

  LOWORD(result) = a2 - a1;
  v4 = (signed __int16)(a2 - a1);
  v5 = a3 >> 1;
  if ( v4 > v5 )
    return (signed __int16)(result - a3);
  if ( v4 < -v5 )
    LOWORD(result) = a3 + result;
  return (signed __int16)result;
}

//----- (000483A0) --------------------------------------------------------
int __cdecl sub_483A0(__int16 a1, int a2, char a3, char a4)
{
  unsigned __int16 v4; // ax
  __int16 v5; // bx
  unsigned __int16 v6; // ax
  signed int v7; // ecx
  int result; // eax

  LOBYTE(v4) = a1;
  HIBYTE(v4) = a2;
  LOBYTE(v5) = byte_11B4E0[v4];
  LOBYTE(v6) = a3;
  v5 = (unsigned __int8)v5;
  HIBYTE(v6) = a4;
  v7 = (unsigned __int8)byte_11B4E0[v6];
  if ( v7 > (unsigned __int8)v5 )
    LOBYTE(v5) = byte_11B4E0[v6];
  word_EB398 = a1 << 8;
  result = a2 << 8;
  word_EB39C = 32 * v5;
  word_EB39A = (_WORD)a2 << 8;
  return result;
}
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00048400) --------------------------------------------------------
int __cdecl sub_48400(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // esi
  int v6; // ebx
  int result; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11; // edi
  int v12; // esi
  int v13; // eax
  int v14; // eax
  int v15; // ebx
  int v16; // edx
  int v17; // eax
  int v18; // edi
  int v19; // eax
  int v20; // esi
  int v21; // ecx
  int v22; // eax
  int v23; // ebx
  int v24; // eax
  int v25; // [esp+8h] [ebp-Ch]
  int i; // [esp+8h] [ebp-Ch]
  int v27; // [esp+Ch] [ebp-8h]
  int v28; // [esp+Ch] [ebp-8h]
  int v29; // [esp+10h] [ebp-4h]
  int v30; // [esp+10h] [ebp-4h]

  v4 = sub_48370(a1, a3, 256);
  v5 = v4;
  v6 = v4;
  result = sub_48370(a2, a4, 256);
  v8 = result;
  if ( v5 || result )
  {
    if ( v6 < 0 )
    {
      v9 = a1;
      v6 = -v6;
      v8 = -v8;
      a1 = a3;
      a3 = v9;
      v10 = a2;
      a2 = a4;
      a4 = v10;
    }
    if ( v6 <= abs(v8) )
    {
      v17 = abs(v8 / 10);
      v18 = v17 + 1;
      v19 = v8 / (v17 + 1);
      v20 = v19;
      v21 = v8 - v18 * v19;
      v30 = v6 / v18;
      result = v18 * (v6 / v18);
      v28 = v21;
      for ( i = v6 - result; v18; v28 = 0 )
      {
        sub_483A0(a1, (unsigned __int16)a2, a3, a4);
        v22 = sub_4A190((int)&word_EB398, 10, 27);
        if ( v20 >= 0 )
        {
          *(_BYTE *)(v22 + 69) = 28;
          v23 = v20 + v28;
        }
        else
        {
          *(_BYTE *)(v22 + 69) = 27;
          v23 = -v20 - v28;
        }
        *(_DWORD *)(v22 + 16) = v23;
        sub_483A0(a1, (unsigned __int16)(v20 + v28 + a2), a3, a4);
        --v18;
        a2 += v20 + v28;
        v24 = sub_4A190((int)&word_EB398, 10, 27);
        *(_BYTE *)(v24 + 69) = 29;
        *(_DWORD *)(v24 + 16) = i + v30;
        result = 0;
        a1 += i + v30;
        i = 0;
      }
    }
    else
    {
      v11 = v6 / 10 + 1;
      v29 = v6 / v11;
      v12 = v8 / v11;
      result = v11 * (v8 / v11);
      v25 = v6 - v11 * (v6 / v11);
      v27 = v8 - result;
      if ( v6 / 10 != -1 )
      {
        do
        {
          sub_483A0(a1, (unsigned __int16)a2, a3, a4);
          v13 = sub_4A190((int)&word_EB398, 10, 27);
          *(_BYTE *)(v13 + 69) = 29;
          *(_DWORD *)(v13 + 16) = v25 + v29;
          a1 += v25 + v29;
          sub_483A0(a1, (unsigned __int16)a2, a3, a4);
          v14 = sub_4A190((int)&word_EB398, 10, 27);
          if ( v12 >= 0 )
          {
            *(_BYTE *)(v14 + 69) = 28;
            v15 = v12 + v27;
          }
          else
          {
            *(_BYTE *)(v14 + 69) = 27;
            v15 = -v12 - v27;
          }
          *(_DWORD *)(v14 + 16) = v15;
          --v11;
          result = v12 + v27;
          v25 = 0;
          v16 = v12 + v27 + a2;
          v27 = 0;
          a2 = v16;
        }
        while ( v11 );
      }
    }
  }
  return result;
}
// EB398: using guessed type __int16 word_EB398;

//----- (00048690) --------------------------------------------------------
int __cdecl sub_48690(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  int v4; // eax
  int v5; // ebx
  signed __int16 v6; // si
  int v7; // eax
  signed __int16 v8; // bx
  int v9; // edi
  int v10; // eax
  int result; // eax
  int v12; // [esp+0h] [ebp-14h]
  int v13; // [esp+4h] [ebp-10h]
  signed __int16 v14; // [esp+8h] [ebp-Ch]
  signed __int16 v15; // [esp+Ch] [ebp-8h]
  int v16; // [esp+10h] [ebp-4h]

  v4 = sub_48370(a1, a3, 256);
  v5 = v4;
  v13 = v4;
  v6 = 0;
  v7 = sub_48370(a2, a4, 256);
  if ( v5 )
  {
    v6 = -1;
    if ( v5 > 0 )
      v6 = 1;
  }
  v8 = 0;
  if ( v7 )
  {
    v8 = -1;
    if ( v7 > 0 )
      v8 = 1;
  }
  v16 = abs(v7);
  v9 = abs(v13);
  v12 = abs(v16 - v9);
  if ( v9 <= v16 )
  {
    v15 = v8;
    v14 = 0;
  }
  else
  {
    v9 = v16;
    v14 = v6;
    v15 = 0;
  }
  word_EB398 = a1 << 8;
  word_EB39A = a2 << 8;
  v10 = sub_4A190((int)&word_EB398, 10, 30);
  if ( v10 )
  {
    *(_DWORD *)(v10 + 16) = v9;
    *(_WORD *)(v10 + 28) = v6;
    *(_WORD *)(v10 + 30) = v8;
  }
  word_EB398 = ((_WORD)v9 * v6 + a1) << 8;
  word_EB39A = ((_WORD)v9 * v8 + a2) << 8;
  result = sub_4A190((int)&word_EB398, 10, 30);
  if ( result )
  {
    *(_DWORD *)(result + 16) = v12;
    *(_WORD *)(result + 28) = v14;
    *(_WORD *)(result + 30) = v15;
  }
  return result;
}
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;

//----- (000487D0) --------------------------------------------------------
int __cdecl sub_487D0(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4, char a5)
{
  __int16 v5; // si
  unsigned __int16 v6; // bx
  int result; // eax
  __int16 v8; // [esp+0h] [ebp-10h]
  __int16 v9; // [esp+2h] [ebp-Eh]
  __int16 v10; // [esp+4h] [ebp-Ch]
  __int16 v11; // [esp+8h] [ebp-8h]
  __int16 v12; // [esp+Ah] [ebp-6h]

  v8 = a1 << 8;
  v9 = a2 << 8;
  v10 = 32 * (unsigned __int8)byte_11B4E0[256 * a2 + a1];
  v11 = a3 << 8;
  v12 = a4 << 8;
  v5 = sub_581E0(&v8, &v11);
  v6 = sub_58490(&v8, &v11);
  result = sub_4A190((int)&v8, 10, 32);
  if ( result )
  {
    *(_WORD *)(result + 28) = v5;
    *(_DWORD *)(result + 8) = (signed int)v6 >> 8;
    *(_BYTE *)(result + 70) = a5;
  }
  return result;
}

//----- (00048880) --------------------------------------------------------
int __cdecl sub_48880(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4)
{
  __int16 v4; // si
  unsigned __int16 v5; // di
  int result; // eax
  int v7; // ebx
  int v8; // ecx
  __int16 v9; // [esp+0h] [ebp-10h]
  __int16 v10; // [esp+2h] [ebp-Eh]
  __int16 v11; // [esp+4h] [ebp-Ch]
  __int16 v12; // [esp+8h] [ebp-8h]
  __int16 v13; // [esp+Ah] [ebp-6h]

  v9 = a1 << 8;
  v10 = a2 << 8;
  v11 = 16 * (unsigned __int8)byte_11B4E0[256 * a2 + a1];
  v12 = a3 << 8;
  v13 = a4 << 8;
  v4 = sub_581E0(&v9, &v12);
  v5 = sub_58490(&v9, &v12);
  result = sub_4A190((int)&v9, 10, 51);
  v7 = result;
  if ( result )
  {
    v8 = *(signed __int16 *)(result + 130);
    *(_WORD *)(result + 28) = v4;
    result = v5 / v8;
    *(_DWORD *)(v7 + 8) = result;
  }
  return result;
}

//----- (00048990) --------------------------------------------------------
int __cdecl sub_48990(char a1, char a2, char a3, char a4)
{
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // dx
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // ecx
  unsigned int v9; // ecx
  unsigned int v10; // ecx

  LOBYTE(v4) = a1;
  HIBYTE(v4) = a2;
  HIBYTE(v5) = a2;
  LOBYTE(v5) = a4 + a1;
  v6 = (unsigned __int8)byte_11B4E0[v4];
  v7 = v6;
  v8 = (unsigned __int8)byte_11B4E0[v5];
  if ( v8 <= v6 )
  {
    if ( v8 < v6 )
      v7 = (unsigned __int8)byte_11B4E0[v5];
  }
  else
  {
    v6 = (unsigned __int8)byte_11B4E0[v5];
  }
  HIBYTE(v5) = a3 + a2;
  v9 = (unsigned __int8)byte_11B4E0[v5];
  if ( v9 <= v6 )
  {
    if ( v9 < v7 )
      v7 = (unsigned __int8)byte_11B4E0[v5];
  }
  else
  {
    v6 = (unsigned __int8)byte_11B4E0[v5];
  }
  LOBYTE(v5) = a1;
  v10 = (unsigned __int8)byte_11B4E0[v5];
  if ( v10 > v6 )
    return v10 - v7;
  if ( v10 < v7 )
    v7 = (unsigned __int8)byte_11B4E0[v5];
  return v6 - v7;
}

//----- (00048A20) --------------------------------------------------------
__int16 __usercall sub_48A20@<ax>(int a1@<edi>, char a2, char a3, int a4, int a5, unsigned __int8 a6)
{
  int v6; // eax
  int v7; // esi
  unsigned __int16 v8; // bx
  unsigned __int16 v9; // bx
  int v10; // eax
  int v11; // edi
  char v13; // [esp+0h] [ebp-8h]
  char v14; // [esp+1h] [ebp-7h]
  __int16 v15; // [esp+2h] [ebp-6h]
  unsigned __int16 v16; // [esp+4h] [ebp-4h]
  unsigned __int16 v17; // [esp+4h] [ebp-4h]

  v13 = a2 - a5;
  v14 = a3 - a4;
  HIWORD(v6) = v15;
  HIBYTE(v16) = a3 - a4;
  HIBYTE(v8) = a3 - a4;
  v7 = 2 * a4;
  LOBYTE(v8) = a2 - a5 - a6;
  LOBYTE(v16) = 2 * a5 + a2 - a5;
  while ( (_WORD)--v7 != -1 )
  {
    LOWORD(a1) = a6;
    ++a1;
    while ( (_WORD)--a1 != -1 )
    {
      sub_48B90(v8);
      sub_48B90(v16);
      LOBYTE(v8) = v8 + 1;
      LOBYTE(v16) = v16 + 1;
    }
    LOBYTE(v16) = 2 * a5 + v13;
    LOBYTE(v8) = v13 - a6;
    ++HIBYTE(v8);
    ++HIBYTE(v16);
  }
  LOBYTE(v9) = v13 - a6;
  LOBYTE(v17) = v13 - a6;
  HIBYTE(v9) = v14 - a6;
  HIBYTE(v17) = 2 * a4 + v14;
  LOWORD(v6) = a6;
  v10 = 2 * v6;
  v11 = v10 + 2 * a5;
  while ( (_WORD)--v11 != -1 )
  {
    LOWORD(v7) = a6;
    ++v7;
    while ( (_WORD)--v7 != -1 )
    {
      sub_48B90(v9);
      sub_48B90(v17);
      ++HIBYTE(v9);
      ++HIBYTE(v17);
    }
    LOBYTE(v10) = 2 * a4;
    HIBYTE(v9) = v14 - a6;
    LOBYTE(v9) = v9 + 1;
    BYTE1(v10) = 2 * a4 + v14;
    HIBYTE(v17) = 2 * a4 + v14;
    LOBYTE(v17) = v17 + 1;
  }
  return v10;
}

//----- (00048B50) --------------------------------------------------------
__int16 __cdecl sub_48B50(unsigned __int8 a1, char a2, int a3, int a4)
{
  int v4; // edi
  unsigned __int16 v5; // bx
  int v6; // esi
  __int16 result; // ax

  LOBYTE(v5) = a1;
  v4 = a3;
  HIBYTE(v5) = a2;
  while ( (_WORD)--v4 != -1 )
  {
    v6 = a4;
    while ( (_WORD)--v6 != -1 )
    {
      result = sub_48B90(v5);
      LOBYTE(v5) = v5 + 1;
    }
    v5 = __PAIR__(HIBYTE(v5), a1) + 256;
  }
  return result;
}

//----- (00048B90) --------------------------------------------------------
__int16 __cdecl sub_48B90(int a1)
{
  int i; // eax
  unsigned int v2; // ecx
  unsigned int v3; // ebx
  char v4; // dl
  char v5; // dh
  unsigned __int8 v6; // dh
  char v7; // bl

  LOWORD(i) = a1;
  v2 = 0;
  v3 = 0;
  if ( byte_13B4E0[(unsigned __int16)a1] & 7
    && byte_11B4E0[(unsigned __int16)a1]
    && ((unsigned __int8)byte_10B3DF[(unsigned __int16)a1] <= 5u
     || (unsigned __int8)byte_10B3DF[(unsigned __int16)a1] > 0x22u)
    && ((unsigned __int8)byte_10B3E0[(unsigned __int16)a1] <= 5u
     || (unsigned __int8)byte_10B3E0[(unsigned __int16)a1] > 0x22u)
    && ((unsigned __int8)byte_10B4DF[(unsigned __int16)a1] <= 5u
     || (unsigned __int8)byte_10B4DF[(unsigned __int16)a1] > 0x22u)
    && ((unsigned __int8)byte_10B4E0[(unsigned __int16)a1] <= 5u
     || (unsigned __int8)byte_10B4E0[(unsigned __int16)a1] > 0x22u) )
  {
    v4 = 3;
    for ( i = a1 - 257; --v4 != -1; i += 253 )
    {
      v5 = 3;
      while ( --v5 != -1 )
      {
        if ( (unsigned __int8)byte_10B4E0[(unsigned __int16)i] <= 5u
          || (unsigned __int8)byte_10B4E0[(unsigned __int16)i] > 0x22u )
        {
          ++v3;
          v2 += (unsigned __int8)byte_11B4E0[(unsigned __int16)i];
        }
        ++i;
      }
    }
    if ( v3 )
    {
      i = (unsigned __int16)a1;
      byte_11B4E0[(unsigned __int16)a1] = v2 / v3;
      if ( byte_D41B6 )
      {
        v6 = byte_11B4E0[(unsigned __int16)a1];
        if ( (unsigned __int8)byte_14B4E0[(unsigned __int16)a1] > v6 )
        {
          byte_13B4E0[(unsigned __int16)a1] &= 0xF7u;
        }
        else
        {
          v7 = byte_13B4E0[(unsigned __int16)a1] | 8;
          byte_14B4E0[(unsigned __int16)a1] = v6 - 1;
          byte_13B4E0[(unsigned __int16)a1] = v7;
        }
      }
    }
  }
  return i;
}
// D41B6: using guessed type char byte_D41B6;

//----- (00048D20) --------------------------------------------------------
__int16 __cdecl sub_48D20(int a1, unsigned __int16 a2)
{
  unsigned int v2; // esi
  unsigned int v3; // ecx
  signed int v4; // eax
  int v5; // ebx
  unsigned __int8 v6; // bl
  unsigned __int8 v7; // dh
  char v9; // [esp+8h] [ebp-8h]
  char v10; // [esp+Ch] [ebp-4h]

  v2 = 0;
  v3 = 0;
  LOBYTE(v4) = byte_14B4E0[(unsigned __int16)a1];
  BYTE1(v4) = 3;
  v5 = a1 - 257;
  v9 = 3;
  while ( --v9 != -1 )
  {
    v10 = 3;
    while ( 1 )
    {
      BYTE1(v4) = v10 - 1;
      v10 = BYTE1(v4);
      if ( BYTE1(v4) == -1 )
        break;
      v4 = abs((unsigned __int8)byte_14B4E0[(unsigned __int16)v5] - (unsigned __int8)byte_14B4E0[(unsigned __int16)a1]);
      if ( v4 > a2 )
      {
        v4 = (unsigned __int8)byte_14B4E0[(unsigned __int16)v5];
        ++v3;
        v2 += v4;
      }
      ++v5;
    }
    v5 += 253;
  }
  if ( v3 )
  {
    v6 = v2 / v3;
    v4 = (unsigned __int16)a1;
    v7 = byte_11B4E0[(unsigned __int16)a1];
    byte_14B4E0[(unsigned __int16)a1] = v6;
    if ( v6 > v7 )
    {
      byte_13B4E0[(unsigned __int16)a1] &= 0xF7u;
    }
    else
    {
      byte_14B4E0[(unsigned __int16)a1] = v7 - 1;
      byte_13B4E0[(unsigned __int16)a1] |= 8u;
    }
  }
  return v4;
}

//----- (00048DF0) --------------------------------------------------------
__int16 __cdecl sub_48DF0(char a1, char a2, char a3, char a4)
{
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // dx
  int v6; // eax
  unsigned __int16 v7; // bx

  LOBYTE(v4) = a1;
  HIBYTE(v4) = a2;
  HIBYTE(v5) = a2;
  LOBYTE(v5) = a4 + a1;
  v6 = (unsigned __int8)byte_11B4E0[v5] + (unsigned __int8)byte_11B4E0[v4];
  HIBYTE(v5) = a3 + a2;
  v7 = v5;
  LOBYTE(v5) = a1;
  return ((unsigned __int8)byte_11B4E0[v5] + (unsigned int)(unsigned __int8)byte_11B4E0[v7] + v6) >> 2;
}

//----- (00048E60) --------------------------------------------------------
signed int __cdecl sub_48E60(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4)
{
  return sub_48F20(a1, a2, a3, a4, (int)byte_11B4E0);
}

//----- (00048E90) --------------------------------------------------------
signed int __cdecl sub_48E90(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4)
{
  return sub_48FD0(a1, a2, a3, a4, (int)byte_11B4E0);
}

//----- (00048EC0) --------------------------------------------------------
signed int __cdecl sub_48EC0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4)
{
  return sub_48F20(a1, a2, a3, a4, (int)byte_14B4E0);
}

//----- (00048EF0) --------------------------------------------------------
signed int __cdecl sub_48EF0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4)
{
  return sub_48FD0(a1, a2, a3, a4, (int)byte_14B4E0);
}

//----- (00048F20) --------------------------------------------------------
signed int __cdecl sub_48F20(char a1, char a2, __int16 a3, unsigned __int16 a4, int a5)
{
  signed int result; // eax
  unsigned __int16 v6; // dx
  int v7; // esi
  int v8; // ebx
  signed int v9; // ebx
  int v10; // ebx
  signed int v11; // ebx

  LOBYTE(v6) = a1;
  result = 250;
  HIBYTE(v6) = a2;
  v7 = a4;
  if ( a4 )
  {
    do
    {
      LOBYTE(v8) = v6;
      if ( result > *(unsigned __int8 *)(a5 + v6) )
        result = *(unsigned __int8 *)(a5 + v6);
      BYTE1(v8) = a3 + a2;
      v9 = *(unsigned __int8 *)(a5 + (unsigned __int16)v8);
      if ( v9 < result )
        result = v9;
      LOBYTE(v6) = v6 + 1;
      --v7;
    }
    while ( v7 );
    LOWORD(v7) = a3;
    if ( a3 )
      goto LABEL_9;
  }
  else
  {
    LOWORD(v7) = a3;
    while ( v7 )
    {
LABEL_9:
      BYTE1(v10) = HIBYTE(v6);
      if ( result > *(unsigned __int8 *)(a5 + v6) )
        result = *(unsigned __int8 *)(a5 + v6);
      LOBYTE(v10) = v6 - a4;
      v11 = *(unsigned __int8 *)(a5 + (unsigned __int16)v10);
      if ( v11 < result )
        result = v11;
      ++HIBYTE(v6);
      --v7;
    }
  }
  return result;
}

//----- (00048FD0) --------------------------------------------------------
signed int __cdecl sub_48FD0(char a1, char a2, __int16 a3, unsigned __int16 a4, int a5)
{
  signed int result; // eax
  unsigned __int16 v6; // dx
  int v7; // esi
  int v8; // ebx
  signed int v9; // ebx
  int v10; // ebx
  signed int v11; // ebx

  LOBYTE(v6) = a1;
  result = 0;
  HIBYTE(v6) = a2;
  v7 = a4;
  if ( a4 )
  {
    do
    {
      LOBYTE(v8) = v6;
      if ( result < *(unsigned __int8 *)(a5 + v6) )
        result = *(unsigned __int8 *)(a5 + v6);
      BYTE1(v8) = a3 + a2;
      v9 = *(unsigned __int8 *)(a5 + (unsigned __int16)v8);
      if ( v9 > result )
        result = v9;
      LOBYTE(v6) = v6 + 1;
      --v7;
    }
    while ( v7 );
    LOWORD(v7) = a3;
    if ( a3 )
      goto LABEL_9;
  }
  else
  {
    LOWORD(v7) = a3;
    while ( v7 )
    {
LABEL_9:
      BYTE1(v10) = HIBYTE(v6);
      if ( result < *(unsigned __int8 *)(a5 + v6) )
        result = *(unsigned __int8 *)(a5 + v6);
      LOBYTE(v10) = v6 - a4;
      v11 = *(unsigned __int8 *)(a5 + (unsigned __int16)v10);
      if ( v11 > result )
        result = v11;
      ++HIBYTE(v6);
      --v7;
    }
  }
  return result;
}

//----- (00049090) --------------------------------------------------------
void __cdecl sub_49090(int a1, _WORD *a2)
{
  _WORD *v2; // ebx
  unsigned __int16 v3; // si
  __int16 v4; // di
  unsigned __int16 v5; // dx
  __int16 v6; // dx
  unsigned __int16 v7; // cx
  unsigned int v8; // eax
  int (*v9)(); // [esp+4h] [ebp-10h]
  unsigned __int16 v10; // [esp+8h] [ebp-Ch]

  v2 = a2;
  v3 = a2[1];
  v4 = *a2;
  v9 = 0;
  if ( *a2 == 10 )
  {
    if ( v3 < 0x1Fu )
    {
      if ( v3 >= 0x1Cu )
      {
        if ( v3 <= 0x1Cu )
        {
          v9 = (int (*)())sub_48400;
        }
        else if ( v3 == 29 )
        {
          v9 = (int (*)())sub_48690;
        }
      }
    }
    else if ( v3 <= 0x1Fu )
    {
      v9 = (int (*)())sub_487D0;
    }
    else if ( v3 >= 0x32u )
    {
      if ( v3 <= 0x32u )
      {
        v9 = (int (*)())sub_48880;
      }
      else if ( v3 == 80 )
      {
        v9 = sub_48930;
      }
    }
  }
  if ( v9 )
  {
    while ( 1 )
    {
      v5 = v2[7];
      if ( !v5 )
        break;
      v2 = (_WORD *)(20 * v5 + a1 + 1091);
    }
    do
    {
      if ( v4 != *v2 )
        break;
      if ( v3 != v2[1] )
        break;
      v6 = v2[8];
      v2[6] = 0;
      if ( !v6 )
        break;
      v7 = v2[3];
      v10 = v2[2];
      v8 = (unsigned __int16)v2[9];
      v2 = (_WORD *)(20 * (unsigned __int16)v2[8] + a1 + 1091);
      if ( v3 >= 0x1Fu )
      {
        if ( v3 <= 0x1Fu )
        {
          if ( v8 <= 3 )
          {
            switch ( v8 )
            {
              case 0u:
                v8 = 2;
                break;
              case 1u:
                v8 = 6;
                break;
              case 2u:
                v8 = 16;
                break;
              case 3u:
                v8 = 32;
                break;
            }
          }
        }
        else if ( v3 == 80 )
        {
          v8 = v2[9] & 0xF | 16 * (v8 & 0xF);
        }
      }
      ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, unsigned int))v9)(
        v10,
        v7,
        (unsigned __int16)v2[2],
        (unsigned __int16)v2[3],
        v8);
    }
    while ( v2 );
  }
}
// 48930: using guessed type int sub_48930();

//----- (00049270) --------------------------------------------------------
int __cdecl sub_49270(int a1)
{
  sub_49830(a1);
  return sub_49290(a1, 1);
}

//----- (00049290) --------------------------------------------------------
int __cdecl sub_49290(int a1, char a2)
{
  __int16 *i; // ebx
  __int16 v3; // ax
  __int16 *j; // ebx
  __int16 v5; // cx
  __int16 v6; // ax
  __int16 *k; // ebx
  __int16 v8; // dx
  __int16 v9; // ax
  __int16 *l; // ebx
  __int16 v11; // ax
  __int16 *m; // ebx
  __int16 v13; // ax
  __int16 v14; // ax
  __int16 *n; // ebx
  __int16 v16; // ax
  __int16 *ii; // ebx
  __int16 v18; // ax

  for ( i = (__int16 *)(a1 + 1111); (unsigned int)i < a1 + 25091; i += 10 )
  {
    if ( i[4] == -1 && *i == 10 && i[1] == 82 )
    {
      sub_49540(a1, (int)i);
      if ( a2 )
        v3 = 0;
      else
        v3 = *i;
      *i = v3;
    }
  }
  sub_498A0();
  for ( j = (__int16 *)(a1 + 1111); (unsigned int)j < a1 + 25091; j += 10 )
  {
    if ( j[4] == -1 && *j == 10 )
    {
      v5 = j[1];
      if ( v5 == 9
        || v5 == 83
        || v5 == 84
        || v5 == 85
        || v5 == 11
        || v5 == 15
        || v5 == 30
        || v5 == 29
        || v5 == 32
        || v5 == 31
        || v5 == 51
        || v5 == 50
        || v5 == 88 )
      {
        sub_49540(a1, (int)j);
        if ( a2 )
          v6 = 0;
        else
          v6 = *j;
        *j = v6;
      }
    }
  }
  sub_498A0();
  for ( k = (__int16 *)(a1 + 1111); (unsigned int)k < a1 + 25091; k += 10 )
  {
    if ( k[4] == -1 && *k == 10 )
    {
      v8 = k[1];
      if ( v8 == 81 || v8 == 80 )
      {
        sub_49540(a1, (int)k);
        if ( a2 )
          v9 = 0;
        else
          v9 = *k;
        *k = v9;
      }
    }
  }
  sub_498A0();
  for ( l = (__int16 *)(a1 + 1111); (unsigned int)l < a1 + 25091; l += 10 )
  {
    if ( l[4] == -1 && *l == 14 && l[1] == 2 )
    {
      sub_49540(a1, (int)l);
      if ( a2 )
        v11 = 0;
      else
        v11 = *l;
      *l = v11;
    }
  }
  sub_498A0();
  for ( m = (__int16 *)(a1 + 1111); (unsigned int)m < a1 + 25091; m += 10 )
  {
    if ( m[4] == -1 && *m == 10 )
    {
      v13 = m[1];
      if ( v13 == 27 || v13 == 28 )
      {
        sub_49540(a1, (int)m);
        if ( a2 )
          v14 = 0;
        else
          v14 = *m;
        *m = v14;
      }
    }
  }
  sub_498A0();
  for ( n = (__int16 *)(a1 + 1111); (unsigned int)n < a1 + 25091; n += 10 )
  {
    if ( n[4] == -1 && *n == 10 && n[1] == 45 && byte_D93C2[4 * (unsigned __int16)n[7]] & 0x10 )
    {
      sub_49540(a1, (int)n);
      if ( a2 )
        v16 = 0;
      else
        v16 = *n;
      *n = v16;
    }
  }
  sub_498A0();
  for ( ii = (__int16 *)(a1 + 1111); (unsigned int)ii < a1 + 25091; ii += 10 )
  {
    if ( ii[4] == -1 && *ii == 10 && ii[1] == 45 && !(byte_D93C2[4 * (unsigned __int16)ii[7]] & 0x10) )
    {
      sub_49540(a1, (int)ii);
      if ( a2 )
        v18 = 0;
      else
        v18 = *ii;
      *ii = v18;
    }
  }
  return sub_498A0();
}

//----- (00049540) --------------------------------------------------------
void __cdecl sub_49540(int a1, int a2)
{
  unsigned __int16 v2; // ax
  __int16 v3; // ax
  unsigned __int16 v4; // dx
  int v5; // eax
  __int16 v6; // ax
  unsigned __int16 v7; // dx
  int v8; // eax
  int v9; // esi
  unsigned __int16 v10; // dx
  char *v11; // eax
  __int16 v12; // ax
  unsigned __int16 v13; // dx
  int v14; // eax

  if ( *(_WORD *)a2 < 0xAu )
    return;
  if ( *(_WORD *)a2 > 0xAu )
  {
    if ( *(_WORD *)a2 == 14 && *(_WORD *)(a2 + 2) == 2 )
    {
      word_EB398 = *(_WORD *)(a2 + 4) << 8;
      word_EB39A = *(_WORD *)(a2 + 6) << 8;
      v12 = sub_10C40(&word_EB398);
      v13 = *(_WORD *)(a2 + 2);
      word_EB39C = v12;
      if ( *(int (__cdecl **)(int))((char *)&off_D7B7A + 14 * v13) )
      {
        v14 = (*(int (__cdecl **)(int))((char *)&off_D7B7A + 14 * v13))((int)&word_EB398);
        if ( v14 )
        {
          *(_WORD *)(v14 + 44) = *(_WORD *)(a2 + 14);
          *(_WORD *)(v14 + 150) = *(_WORD *)(a2 + 18);
        }
      }
    }
    return;
  }
  v2 = *(_WORD *)(a2 + 2);
  if ( v2 < 0x2Du )
  {
    if ( v2 < 0x1Cu || v2 > 0x1Du && v2 != 31 )
      goto LABEL_20;
LABEL_18:
    if ( *(_WORD *)(a2 + 12) )
      sub_49090(a1, (_WORD *)a2);
    return;
  }
  if ( v2 <= 0x2Du )
  {
    word_EB398 = *(_WORD *)(a2 + 4) << 8;
    word_EB39A = *(_WORD *)(a2 + 6) << 8;
    v3 = sub_10C40(&word_EB398);
    v4 = *(_WORD *)(a2 + 2);
    word_EB39C = v3;
    if ( *(int (__cdecl **)(int))((char *)&off_D697E + 14 * v4) )
    {
      v5 = (*(int (__cdecl **)(int))((char *)&off_D697E + 14 * v4))((int)&word_EB398);
      if ( v5 )
        sub_49A30(v5, *(_WORD *)(a2 + 14));
    }
    return;
  }
  if ( v2 >= 0x32u && (v2 <= 0x32u || v2 == 80) )
    goto LABEL_18;
LABEL_20:
  word_EB398 = *(_WORD *)(a2 + 4) << 8;
  word_EB39A = *(_WORD *)(a2 + 6) << 8;
  v6 = sub_10C40(&word_EB398);
  v7 = *(_WORD *)(a2 + 2);
  word_EB39C = v6;
  if ( *(int (__cdecl **)(int))((char *)&off_D697E + 14 * v7) )
  {
    v8 = (*(int (__cdecl **)(int))((char *)&off_D697E + 14 * v7))((int)&word_EB398);
    v9 = v8;
    if ( v8 )
    {
      v10 = *(_WORD *)(a2 + 2);
      if ( v10 < 0x52u )
      {
        if ( v10 < 0xBu )
        {
          if ( v10 != 9 )
            return;
        }
        else if ( v10 > 0xBu && v10 != 15 )
        {
          return;
        }
        v11 = &byte_DA818[80 * (unsigned __int8)sub_6E020(*(_WORD *)(a2 + 2)) + 2 + 26 * *(unsigned __int16 *)(a2 + 14)];
        *(_WORD *)(v9 + 42) = *(_WORD *)v11;
        if ( *(_WORD *)(a2 + 2) == 9 )
          *(_DWORD *)(v9 + 4) = (unsigned __int8)v11[24];
        else
          *(_DWORD *)(v9 + 8) = (unsigned __int8)v11[24];
        return;
      }
      if ( v10 <= 0x52u )
      {
        *(_BYTE *)(v8 + 70) = *(_BYTE *)(a2 + 18);
        *(_BYTE *)(v8 + 67) = *(_BYTE *)(a2 + 14);
        *(_BYTE *)(v8 + 68) = *(_BYTE *)(a2 + 16);
      }
      else if ( v10 < 0x54u )
      {
        *(_WORD *)(v8 + 154) = *(_WORD *)(a2 + 10);
      }
      else if ( v10 <= 0x55u )
      {
        *(_WORD *)(v8 + 154) = *(_WORD *)(a2 + 10);
        *(_WORD *)(v8 + 80) = *(_WORD *)(a2 + 18);
      }
      else if ( v10 == 88 )
      {
        *(_WORD *)(v8 + 84) = *(_WORD *)(a2 + 14);
        *(_WORD *)(v8 + 86) = *(_WORD *)(a2 + 16);
      }
    }
  }
}
// D697E: using guessed type int (__cdecl *off_D697E)(int);
// D7B7A: using guessed type int (__cdecl *off_D7B7A)(int);
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00049830) --------------------------------------------------------
int __cdecl sub_49830(int a1)
{
  _WORD *v1; // edx
  int result; // eax
  unsigned __int16 v3; // ax

  v1 = (_WORD *)(a1 + 1111);
  result = a1 + 25091;
  if ( a1 + 1111 < (unsigned int)(a1 + 25091) )
  {
    do
    {
      if ( v1[4] != -1 || *v1 != 10 )
        goto LABEL_13;
      v3 = v1[1];
      if ( v3 < 0x1Fu )
      {
        if ( v3 < 0x1Cu || v3 > 0x1Du )
          goto LABEL_13;
      }
      else if ( v3 > 0x1Fu && (v3 < 0x32u || v3 > 0x32u && v3 != 80) )
      {
        goto LABEL_13;
      }
      v1[6] = 1;
LABEL_13:
      v1 += 10;
      result = a1 + 25091;
    }
    while ( (unsigned int)v1 < a1 + 25091 );
  }
  return result;
}

//----- (000498A0) --------------------------------------------------------
int sub_498A0()
{
  int result; // eax
  signed int v1; // esi
  unsigned int i; // ebx
  char v3; // ah
  unsigned __int8 v4; // al
  int v5; // eax
  int v6; // eax
  void (__cdecl *v7)(unsigned int); // [esp+0h] [ebp-8h]
  void (__cdecl *v8)(unsigned int, void (__cdecl *)(unsigned int)); // [esp+4h] [ebp-4h]

  result = dword_D41A0;
  v1 = 1;
  *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
LABEL_2:
  if ( v1 )
  {
    v1 = 0;
    for ( i = dword_D41A0 + 28470; ; i += 168 )
    {
      result = dword_D41A0 + 196302;
      if ( i >= dword_D41A0 + 196302 )
        goto LABEL_2;
      v3 = *(_BYTE *)(i + 63);
      if ( v3 )
        break;
LABEL_37:
      ;
    }
    if ( v3 != 10 )
    {
      if ( v3 == 14 )
      {
        if ( *(_BYTE *)(i + 64) == 2 && !*(_DWORD *)(i + 8) )
        {
          v6 = *(int *)((char *)&dword_D4C52 + 18 * *(char *)(i + 63)) + 14 * *(unsigned __int8 *)(i + 69);
          v1 = 1;
          v7 = *(void (__cdecl **)(unsigned int))(v6 + 6);
          if ( v7 )
          {
            if ( *(_DWORD *)(v6 + 10) )
              v7(i);
          }
        }
      }
      else
      {
        sub_57F10(i);
      }
      goto LABEL_35;
    }
    v4 = *(_BYTE *)(i + 64);
    if ( v4 < 0x1Bu )
    {
      if ( v4 >= 0xBu )
      {
        if ( v4 > 0xBu && v4 != 15 )
          goto LABEL_26;
        goto LABEL_23;
      }
      if ( v4 == 9 )
        goto LABEL_23;
    }
    else
    {
      if ( v4 <= 0x20u )
        goto LABEL_23;
      if ( v4 >= 0x32u )
      {
        if ( v4 > 0x33u && (v4 < 0x50u || v4 > 0x55u && v4 != 88) )
          goto LABEL_26;
LABEL_23:
        v5 = *(int *)((char *)&dword_D4C52 + 18 * *(char *)(i + 63)) + 14 * *(unsigned __int8 *)(i + 69);
        v1 = 1;
        v8 = *(void (__cdecl **)(unsigned int, void (__cdecl *)(unsigned int)))(v5 + 6);
        if ( v8 && *(_DWORD *)(v5 + 10) )
          v8(i, v7);
        goto LABEL_27;
      }
      if ( v4 == 45 )
      {
        if ( *(_BYTE *)(i + 69) != 51 )
        {
LABEL_27:
          ++*(_BYTE *)(i + 62);
LABEL_35:
          if ( *(_BYTE *)(i + 13) & 4 )
            sub_57F20(i);
          goto LABEL_37;
        }
        goto LABEL_23;
      }
    }
LABEL_26:
    sub_57F10(i);
    goto LABEL_27;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D4C52: using guessed type int dword_D4C52;

//----- (00049A20) --------------------------------------------------------
int __cdecl sub_49A20(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

//----- (00049A30) --------------------------------------------------------
__int16 __cdecl sub_49A30(int a1, unsigned __int16 a2)
{
  int v2; // eax
  __int16 v3; // dx
  int v4; // eax
  char v5; // dl
  int v6; // edx
  unsigned __int16 v8; // [esp+0h] [ebp-10h]
  unsigned __int16 v9; // [esp+4h] [ebp-Ch]
  unsigned __int8 v10; // [esp+8h] [ebp-8h]
  unsigned __int8 v11; // [esp+Ch] [ebp-4h]

  v2 = dword_EA3BC + 6 * a2;
  v8 = *(unsigned __int8 *)(v2 + 5);
  v9 = *(unsigned __int8 *)(v2 + 4);
  *(_DWORD *)(a1 + 16) = 2;
  v3 = word_180660;
  *(_WORD *)(a1 + 132) = (unsigned __int8)v9 * (unsigned __int8)v8 >> 4;
  if ( v3 == 1 )
  {
    v8 >>= 1;
    v9 >>= 1;
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  word_EB398 = *(_WORD *)(a1 + 76) >> 8 << 8;
  word_EB39A = *(_WORD *)(a1 + 78) >> 8 << 8;
  sub_57CF0(a1, (int)&word_EB398);
  v10 = (*(_WORD *)(a1 + 76) >> 8) - ((signed int)v9 >> 1);
  v11 = (*(_WORD *)(a1 + 78) >> 8) - ((signed int)v8 >> 1);
  if ( (v10 + v11) % 2 )
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    ++HIBYTE(word_EB398);
    sub_57CF0(a1, (int)&word_EB398);
    ++v10;
  }
  sub_49EC0((_WORD *)a1, a2);
  *(_WORD *)(a1 + 80) = 32 * sub_48DF0(v10, v11, v8, v9);
  *(_BYTE *)(a1 + 70) = a2;
  LOWORD(v4) = a2;
  *(_DWORD *)(a1 + 8) = 30;
  *(_WORD *)(a1 + 42) = word_D93C0[2 * a2];
  v5 = byte_D93C3[4 * a2];
  *(_BYTE *)(a1 + 65) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  *(_BYTE *)(a1 + 61) = v5;
  if ( !(byte_D93C2[4 * a2] & 8) )
  {
    v6 = *(_DWORD *)(a1 + 144);
    *(_BYTE *)(a1 + 56) |= 2u;
    if ( v6 < 0 )
      *(_DWORD *)(a1 + 144) = 0;
    if ( *(_DWORD *)(a1 + 144) > 1000 )
      *(_DWORD *)(a1 + 144) = 1000;
    v4 = 1000 * *(unsigned __int16 *)(a1 + 42) >> 7;
    *(_DWORD *)(a1 + 144) = v4;
  }
  if ( a2 == 68 )
  {
    v4 = (a1 - (dword_D41A0 + 28302)) / 168;
    *(_WORD *)(dword_D41A0 + 222538) = v4;
  }
  return v4;
}
// D41A0: using guessed type int dword_D41A0;
// D93C0: using guessed type __int16 word_D93C0[];
// EA3BC: using guessed type int dword_EA3BC;
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// 180660: using guessed type __int16 word_180660;

//----- (00049C70) --------------------------------------------------------
int __cdecl sub_49C70(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4) >> 1;
  *(_DWORD *)(a1 + 144) = result;
  return result;
}

//----- (00049C90) --------------------------------------------------------
char __cdecl sub_49C90(int a1, __int16 a2)
{
  char result; // al

  *(_WORD *)(a1 + 90) = a2;
  *(_BYTE *)(a1 + 92) = 0;
  result = byte_D8A2E[(unsigned __int8)byte_D9528[14 * a2]];
  *(_BYTE *)(a1 + 93) = result;
  return result;
}

//----- (00049CD0) --------------------------------------------------------
int __cdecl sub_49CD0(_WORD *a1, __int16 a2)
{
  int v2; // ebx
  int result; // eax

  sub_49C90((int)a1, a2);
  v2 = 7 * a2;
  a1[41] = (unsigned __int16)word_D9524[v2] / 2;
  a1[42] = (unsigned __int16)word_D9522[v2] / 2;
  a1[43] = (unsigned __int16)word_D9522[v2] / 2;
  result = (unsigned __int16)word_D9524[v2] / 2;
  a1[44] = result;
  return result;
}
// D9522: using guessed type __int16 word_D9522[];
// D9524: using guessed type __int16 word_D9524[];

//----- (00049D50) --------------------------------------------------------
int __cdecl sub_49D50(int a1, __int16 a2)
{
  int result; // eax

  *(_WORD *)(a1 + 90) = a2;
  *(_BYTE *)(a1 + 93) = byte_D8A2E[(unsigned __int8)byte_D9528[14 * a2]];
  result = (unsigned __int16)word_D9524[7 * a2] / 2;
  *(_WORD *)(a1 + 82) = result;
  return result;
}
// D9524: using guessed type __int16 word_D9524[];

//----- (00049DA0) --------------------------------------------------------
int __cdecl sub_49DA0(_WORD *a1, __int16 a2)
{
  int v2; // ebx
  int result; // eax

  sub_49CD0(a1, a2);
  v2 = 7 * a2;
  a1[42] = (unsigned __int16)word_D9522[v2] / 2;
  a1[43] = (unsigned __int16)word_D9522[v2] / 2;
  result = (unsigned __int16)word_D9524[v2] / 2;
  a1[44] = result;
  return result;
}
// D9522: using guessed type __int16 word_D9522[];
// D9524: using guessed type __int16 word_D9524[];

//----- (00049E10) --------------------------------------------------------
int __cdecl sub_49E10(_WORD *a1, __int16 a2)
{
  int result; // eax
  __int16 v3; // cx
  __int16 v4; // si

  result = sub_49CD0(a1, a2);
  v3 = a1[43];
  v4 = a1[44];
  a1[42] *= 2;
  a1[43] = 2 * v3;
  a1[44] = 2 * v4;
  return result;
}

//----- (00049EA0) --------------------------------------------------------
_WORD *__cdecl sub_49EA0(_WORD *a1, __int16 a2, __int16 a3)
{
  _WORD *result; // eax

  result = a1;
  a1[42] = a2;
  a1[43] = a2;
  a1[44] = a3;
  return result;
}

//----- (00049EC0) --------------------------------------------------------
unsigned int __cdecl sub_49EC0(_WORD *a1, __int16 a2)
{
  int v2; // eax
  unsigned int v3; // edx
  unsigned int v4; // eax
  unsigned int result; // eax

  v2 = dword_EA3BC + 6 * a2;
  v3 = *(unsigned __int8 *)(v2 + 5);
  v4 = *(unsigned __int8 *)(v2 + 4);
  if ( word_180660 == 1 )
  {
    v3 >>= 1;
    v4 >>= 1;
  }
  a1[42] = ((v4 << 8) + 1280) >> 1;
  a1[41] = 0;
  a1[44] = 256;
  result = ((v3 << 8) + 1280) >> 1;
  a1[43] = result;
  return result;
}
// EA3BC: using guessed type int dword_EA3BC;
// 180660: using guessed type __int16 word_180660;

//----- (00049F30) --------------------------------------------------------
signed int sub_49F30()
{
  int v0; // eax
  signed int result; // eax
  int v2; // edx
  int v3; // ebx
  int v4; // ebx
  int v5; // edx

  v0 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 28466) = &unk_F42B0;
  *(_DWORD *)(v0 + 53) = -1;
  *(_DWORD *)(v0 + 4582) = -1;
  result = 999;
  do
  {
    v2 = dword_D41A0;
    v3 = *(_DWORD *)(dword_D41A0 + 53) + 1;
    *(_DWORD *)(dword_D41A0 + 53) = v3;
    v4 = v2 + 4 * v3;
    v5 = dword_EA3E4[result--];
    *(_DWORD *)(v4 + 582) = v5;
  }
  while ( result > 0 );
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00049F90) --------------------------------------------------------
int sub_49F90()
{
  unsigned int i; // ebx
  int v1; // eax
  signed int v2; // ebx
  signed int v3; // edx
  int result; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // ecx
  int v8; // eax
  int v9; // esi
  int v10; // ecx

  for ( i = dword_EA3E8; i < dword_EB384; i += 168 )
  {
    if ( *(_BYTE *)(i + 63) && *(_BYTE *)(i + 13) & 4 )
      sub_57F20(i);
  }
  v1 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 53) = -1;
  v2 = 999;
  *(_DWORD *)(v1 + 4582) = -1;
  do
  {
    v3 = v2;
    result = dword_EA3E4[v2];
    if ( *(_BYTE *)(result + 63) )
    {
      if ( *(_BYTE *)(result + 14) & 2 )
      {
        v8 = dword_D41A0;
        v9 = *(_DWORD *)(dword_D41A0 + 4582) + 1;
        *(_DWORD *)(dword_D41A0 + 4582) = v9;
        v10 = v8 + 4 * v9;
        result = dword_EA3E4[v3];
        *(_DWORD *)(v10 + 4586) = result;
      }
    }
    else
    {
      v5 = dword_D41A0;
      v6 = *(_DWORD *)(dword_D41A0 + 53) + 1;
      *(_DWORD *)(dword_D41A0 + 53) = v6;
      v7 = v5 + 4 * v6;
      result = dword_EA3E4[v3];
      *(_DWORD *)(v7 + 582) = result;
    }
    --v2;
  }
  while ( v2 > 0 );
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EA3E8: using guessed type int dword_EA3E8;
// EB384: using guessed type int dword_EB384;

//----- (0004A050) --------------------------------------------------------
int sub_4A050()
{
  int v0; // edx
  int v1; // ebx
  int v2; // eax
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // edx
  int result; // eax

  v0 = *(_DWORD *)(dword_D41A0 + 53);
  if ( v0 >= 0 )
  {
    v1 = *(_DWORD *)(dword_D41A0 + 4 * v0 + 582);
    *(_DWORD *)(dword_D41A0 + 53) = v0 - 1;
LABEL_5:
    memset(v1, 0, 168);
    v4 = dword_D41A0;
    v5 = (v1 - (dword_D41A0 + 28302)) / 168;
    *(_DWORD *)(v1 + 4) = 300;
    *(_DWORD *)(v1 + 12) = 8;
    *(_WORD *)(v1 + 130) = 16;
    *(_WORD *)(v1 + 42) = 100;
    *(_WORD *)(v1 + 26) = v5;
    v6 = *(_DWORD *)(v4 + 8);
    *(_BYTE *)(v1 + 65) = -1;
    *(_BYTE *)(v1 + 66) = -1;
    *(_DWORD *)(v1 + 160) = &unk_D83AC;
    *(_DWORD *)(v1 + 164) = &unk_F42B0;
    *(_BYTE *)(v1 + 67) = 10;
    *(_BYTE *)(v1 + 57) = -6;
    LOWORD(v6) = v5 + v6;
    *(_BYTE *)(v1 + 62) = v5;
    result = v1;
    *(_WORD *)(v1 + 20) = v6;
    return result;
  }
  if ( *(_DWORD *)(dword_D41A0 + 4582) >= 0 )
  {
    memset(dword_D41A4 + 38403, 0, 116);
    v2 = dword_D41A4;
    *(_DWORD *)(dword_D41A4 + 38523) = 0;
    *(_DWORD *)(v2 + 38527) = 0;
    *(_DWORD *)(v2 + 38519) = 0;
    *(_DWORD *)(v2 + 38531) = 0;
    *(_DWORD *)(v2 + 38535) = 0;
    v1 = *(_DWORD *)(dword_D41A0 + 4 * *(_DWORD *)(dword_D41A0 + 4582) + 4586);
    sub_57E50(v1);
    v3 = dword_D41A0;
    *(_BYTE *)(v1 + 63) = 0;
    --*(_DWORD *)(v3 + 4582);
    goto LABEL_5;
  }
  return 0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (0004A190) --------------------------------------------------------
int __cdecl sub_4A190(int a1, int a2, int a3)
{
  int v3; // eax
  int result; // eax

  v3 = *(int *)((char *)&dword_D4C56 + 18 * a2) + 14 * a3;
  if ( *(_DWORD *)(v3 + 10) && *(signed __int16 *)(v3 + 4) == a3 )
    result = (*(int (__cdecl **)(int))(v3 + 6))(a1);
  else
    result = 0;
  return result;
}
// D4C56: using guessed type int dword_D4C56;

//----- (0004A1E0) --------------------------------------------------------
int __cdecl sub_4A1E0(int a1, char a2)
{
  int v2; // ebx
  unsigned __int16 *v3; // ebx
  unsigned __int16 v4; // ST04_2
  unsigned __int16 v5; // ST00_2
  unsigned __int16 *i; // ebx
  unsigned __int16 v7; // ax
  int result; // eax

  if ( !a1 )
  {
    v2 = dword_D41A0 + 222422;
    *(_DWORD *)(v2 - 4) = 0;
    memset(v2, 0, 104);
    sub_716A0();
    v3 = (unsigned __int16 *)((char *)&loc_30325 + dword_D41A0);
    while ( (unsigned int)v3 < dword_D41A0 + 221393 )
    {
      v4 = v3[1];
      v5 = *v3;
      v3 += 10;
      sub_716C0(v5, v4, 0xFFFFu);
    }
    sub_71780();
  }
  sub_49F90();
  sub_122C0(a1);
  for ( i = (unsigned __int16 *)((char *)&loc_30325 + dword_D41A0); (unsigned int)i < dword_D41A0 + 221393; i += 10 )
  {
    if ( *i && i[4] == a1 )
    {
      sub_4A310(i);
      if ( *i == 5 )
      {
        v7 = i[1];
        if ( v7 < 0xCu || v7 > 0xFu && v7 != 22 )
          ++*(_DWORD *)(dword_D41A0 + 222418);
      }
      if ( a2 )
        *i = 0;
    }
  }
  sub_12870();
  result = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 4582) = -1;
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;

//----- (0004A310) --------------------------------------------------------
int __cdecl sub_4A310(unsigned __int16 *a1)
{
  int result; // eax
  int v2; // edx
  int v3; // ebx
  unsigned __int8 v4; // al
  int v5; // eax
  __int16 v6; // di
  char *v7; // edx
  unsigned __int8 v8; // al
  int v9; // eax
  unsigned __int8 v10; // al
  __int16 v11; // [esp+0h] [ebp-8h]
  __int16 v12; // [esp+2h] [ebp-6h]
  __int16 v13; // [esp+4h] [ebp-4h]

  result = *(int *)((char *)&dword_D4C56 + 18 * *a1);
  if ( !*(_DWORD *)(result + 14 * a1[1] + 10) )
    return result;
  v11 = (a1[2] << 8) + 128;
  v12 = (a1[3] << 8) + 128;
  v13 = sub_10C40(&v11);
  result = sub_4A190((int)&v11, *a1, a1[1]);
  v2 = result;
  v3 = result;
  if ( !result )
    return result;
  switch ( *(_BYTE *)(result + 63) )
  {
    case 5:
      if ( *(_BYTE *)(result + 64) == 22 )
      {
        *(_BYTE *)(result + 70) = *((_BYTE *)a1 + 14);
        sub_4CB60(result);
      }
      sub_12100((int)a1, v3, *(_BYTE *)(v3 + 64) == 9);
      return sub_58DA0((int)a1, v3);
    case 0xA:
      v4 = *(_BYTE *)(result + 64);
      if ( v4 < 0x22u )
      {
        if ( v4 < 0xBu )
        {
          if ( v4 < 4u )
            return sub_58DA0((int)a1, v3);
          if ( v4 <= 4u )
          {
            *(_WORD *)(v2 + 26) = a1[6];
            sub_49EA0((_WORD *)v2, a1[5] << 8, a1[5] << 8);
            sub_49A20(v3);
            return sub_58DA0((int)a1, v3);
          }
          if ( v4 != 9 )
            return sub_58DA0((int)a1, v3);
        }
        else if ( v4 > 0xBu )
        {
          if ( v4 < 0x11u )
          {
            if ( v4 != 15 )
              return sub_58DA0((int)a1, v3);
          }
          else if ( v4 > 0x11u && v4 != 22 )
          {
            return sub_58DA0((int)a1, v3);
          }
        }
      }
      else
      {
        if ( v4 <= 0x22u )
        {
          *(_WORD *)(v2 + 154) = (a1[8] << 8) + 128;
          *(_WORD *)(v2 + 156) = (a1[7] << 8) + 128;
          return sub_58DA0((int)a1, v3);
        }
        if ( v4 < 0x43u )
        {
          if ( v4 < 0x36u )
          {
            if ( v4 == 45 )
            {
              sub_49A30(v2, a1[7]);
              *(_BYTE *)(v3 + 65) = *((_BYTE *)a1 + 16);
            }
            result = sub_58DA0((int)a1, v3);
          }
          else if ( v4 <= 0x36u )
          {
            *(_DWORD *)(v3 + 16) = (a1[6] << 8) * (a1[6] << 8);
            v5 = 8 * a1[6] + 16;
            *(_DWORD *)(v3 + 4) = v5;
            if ( v5 < 128 )
              *(_DWORD *)(v3 + 4) = 128;
            sub_49A20(v3);
            result = sub_58DA0((int)a1, v3);
          }
          else
          {
            if ( v4 < 0x3Du )
              return sub_58DA0((int)a1, v3);
            if ( v4 <= 0x3Eu )
              goto LABEL_49;
            result = sub_58DA0((int)a1, v3);
          }
          return result;
        }
        if ( v4 > 0x43u )
        {
          if ( v4 >= 0x53u )
          {
            if ( v4 <= 0x53u )
            {
              *(_WORD *)(v2 + 154) = a1[5];
              result = sub_58DA0((int)a1, v3);
            }
            else
            {
              if ( v4 <= 0x55u )
              {
                v6 = *(_WORD *)(v2 + 78);
                *(_WORD *)(v2 + 76) -= 128;
                *(_WORD *)(v2 + 78) = v6 - 128;
                *(_WORD *)(v2 + 154) = a1[5];
                *(_WORD *)(v2 + 80) = a1[9];
              }
              result = sub_58DA0((int)a1, v3);
            }
            return result;
          }
          if ( v4 != 71 )
            return sub_58DA0((int)a1, v3);
        }
      }
      v7 = &byte_DA818[80 * (unsigned __int16)sub_6E020(*(char *)(v3 + 64)) + 2 + 26 * a1[7]];
      *(_WORD *)(v3 + 42) = *(_WORD *)v7;
      v8 = *(_BYTE *)(v3 + 64);
      if ( v8 >= 0x11u )
      {
        if ( v8 <= 0x11u )
        {
          v9 = (unsigned __int8)v7[24];
        }
        else
        {
          if ( v8 >= 0x43u )
          {
            if ( v8 > 0x43u && v8 != 71 )
              return sub_58DA0((int)a1, v3);
LABEL_65:
            v9 = (unsigned __int8)v7[24];
LABEL_69:
            *(_DWORD *)(v3 + 8) = v9;
            return sub_58DA0((int)a1, v3);
          }
          if ( v8 != 22 )
            return sub_58DA0((int)a1, v3);
          v9 = 8 * (unsigned __int8)v7[24];
        }
        *(_DWORD *)(v3 + 4) = v9;
        goto LABEL_69;
      }
      if ( v8 >= 0xBu )
      {
        if ( v8 > 0xBu && v8 != 15 )
          return sub_58DA0((int)a1, v3);
        goto LABEL_65;
      }
      if ( v8 != 9 )
        return sub_58DA0((int)a1, v3);
      *(_DWORD *)(v3 + 4) = (unsigned __int8)v7[24];
      return sub_58DA0((int)a1, v3);
    case 0xB:
      *(_WORD *)(result + 26) = a1[6];
      if ( *(_BYTE *)(result + 64) == 32 )
        *(_BYTE *)(result + 70) = *((_BYTE *)a1 + 14);
      else
        sub_49EA0((_WORD *)result, a1[5] << 8, 4096);
      sub_49A20(v3);
      *(_BYTE *)(v3 + 12) |= 1u;
      return sub_58DA0((int)a1, v3);
    case 0xC:
    case 0xF:
      *(_BYTE *)(result + 69) += *((_BYTE *)a1 + 12);
      if ( a1[6] < 3u )
        return sub_58DA0((int)a1, v3);
      *(_BYTE *)(result + 69) -= 3;
      return sub_58DA0((int)a1, result);
    case 0xE:
      v10 = *(_BYTE *)(result + 64);
      if ( v10 < 1u )
        return sub_58DA0((int)a1, v3);
      if ( v10 <= 1u )
      {
LABEL_49:
        *(_BYTE *)(v2 + 70) = *((_BYTE *)a1 + 14);
        *(_DWORD *)(v2 + 16) = a1[8];
        result = sub_58DA0((int)a1, v3);
      }
      else
      {
        if ( v10 == 2 )
        {
          *(_WORD *)(v2 + 44) = a1[7];
          *(_WORD *)(v2 + 150) = a1[9];
          return sub_58DA0((int)a1, v3);
        }
        result = sub_58DA0((int)a1, v3);
      }
      return result;
    default:
      return sub_58DA0((int)a1, v3);
  }
}
// D4C56: using guessed type int dword_D4C56;

//----- (0004A810) --------------------------------------------------------
int sub_4A810()
{
  return *(_DWORD *)(dword_D41A0 + 53) + 1;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A820) --------------------------------------------------------
int __cdecl sub_4A820(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9058;
  result = 0;
  *(_DWORD *)v1 = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A840) --------------------------------------------------------
int __cdecl sub_4A840(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9064;
  result = 0;
  *(_DWORD *)v1 = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A860) --------------------------------------------------------
int __cdecl sub_4A860(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9070;
  result = 0;
  *(_DWORD *)v1 = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A880) --------------------------------------------------------
int __cdecl sub_4A880(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9076;
  result = 0;
  *(_DWORD *)v1 = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A8A0) --------------------------------------------------------
int __cdecl sub_4A8A0(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9082;
  result = 0;
  *(_DWORD *)v1 = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A8C0) --------------------------------------------------------
int __cdecl sub_4A8C0(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9088;
  result = 0;
  *(_DWORD *)v1 = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A8E0) --------------------------------------------------------
int __cdecl sub_4A8E0(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9094;
  result = 0;
  *(_DWORD *)v1 = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A900) --------------------------------------------------------
int __cdecl sub_4A900(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9100;
  result = 0;
  *(_DWORD *)v1 = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A920) --------------------------------------------------------
_WORD *__cdecl sub_4A920(int a1)
{
  int v1; // eax
  _WORD *v2; // esi
  int v3; // ecx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 0;
    *(_BYTE *)(v1 + 63) = 3;
    v3 = dword_D41A0;
    *(_BYTE *)(v1 + 64) = 0;
    *(_DWORD *)(v1 + 4) = 10000;
    *(_WORD *)(v1 + 132) = 80;
    *(_BYTE *)(v1 + 56) = 29;
    *(_WORD *)(v1 + 26) = (v1 - (v3 + 28302)) / 168;
    if ( *(_BYTE *)(v3 + 196308) == 2 )
      *(_DWORD *)(v1 + 160) = &unk_D89A6;
    else
      *(_DWORD *)(v1 + 160) = &unk_D849A;
    sub_57D70(v1, a1);
    sub_49CD0(v2, 44);
    sub_49A20((int)v2);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A9C0) --------------------------------------------------------
_WORD *__cdecl sub_4A9C0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 1;
    *(_BYTE *)(v1 + 63) = 3;
    v3 = dword_D41A0;
    *(_BYTE *)(v1 + 64) = 1;
    *(_DWORD *)(v1 + 4) = 10000;
    *(_WORD *)(v1 + 132) = 80;
    *(_DWORD *)(v1 + 160) = &unk_D84BC;
    *(_BYTE *)(v1 + 56) = 29;
    *(_WORD *)(v1 + 26) = (v1 - (v3 + 28302)) / 168;
    sub_57D70(v1, a1);
    sub_49CD0(v2, 44);
    sub_49A20((int)v2);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004AA40) --------------------------------------------------------
int __cdecl sub_4AA40(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // edx
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // cx
  int v6; // [esp+0h] [ebp-Ch]
  __int16 v7; // [esp+4h] [ebp-8h]
  int v8; // [esp+8h] [ebp-4h]

  *(_DWORD *)&word_EB398 = *(_DWORD *)a1;
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 4);
  result = sub_4A050();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 69) = 5;
    *(_BYTE *)(result + 63) = 3;
    *(_BYTE *)(result + 64) = 2;
    *(_DWORD *)(result + 4) = 40000;
    *(_DWORD *)(result + 16) = 0;
    *(_BYTE *)(result + 56) = 33;
    v6 = *(_DWORD *)&word_EB398;
    v7 = *(&word_EB398 + 2);
    LOWORD(v6) = BYTE1(v6);
    HIWORD(v6) = HIBYTE(word_EB39A);
    v7 = sub_10C40(&word_EB398);
    if ( ((signed __int16)v6 + SHIWORD(v6)) % 2 )
      LOWORD(v6) = v6 + 1;
    LOWORD(v6) = (_WORD)v6 << 8;
    HIWORD(v6) <<= 8;
    v3 = dword_EA3BC;
    HIBYTE(v4) = 0;
    *(_DWORD *)(v2 + 154) = v6;
    *(_WORD *)(v2 + 158) = v7;
    LOBYTE(v4) = *(_BYTE *)(v3 + 10);
    v5 = *(unsigned __int8 *)(v3 + 11);
    if ( word_180660 == 1 )
    {
      v5 >>= 1;
      v4 >>= 1;
    }
    v8 = ((signed __int16)v6 >> 8) - v4 / 2;
    *(_WORD *)(v2 + 158) = 32 * sub_48E60(((signed __int16)v6 >> 8) - v4 / 2, (SHIWORD(v6) >> 8) - v5 / 2, v4, v5);
    sub_57D70(v2, (int)&v6);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 177);
    result = v2;
  }
  return result;
}
// EA3BC: using guessed type int dword_EA3BC;
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;
// 180660: using guessed type __int16 word_180660;

//----- (0004ABA0) --------------------------------------------------------
int __cdecl sub_4ABA0(int a1)
{
  int result; // eax
  _WORD *v2; // ebx
  int v3; // esi

  result = sub_4A050();
  v2 = (_WORD *)result;
  v3 = result;
  if ( result )
  {
    *(_BYTE *)(result + 69) = 7;
    *(_BYTE *)(result + 63) = 3;
    *(_BYTE *)(result + 64) = 3;
    *(_DWORD *)(result + 4) = 10000;
    *(_WORD *)(result + 130) = 48;
    *(_DWORD *)(result + 140) = 10000;
    *(_DWORD *)(result + 144) = 0;
    *(_BYTE *)(result + 56) = 1;
    *(_DWORD *)(result + 160) = &unk_D84DE;
    sub_57D70(result, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 169);
    if ( byte_D41B6 )
      sub_49EA0(v2, 256, 768);
    result = v3;
  }
  return result;
}
// D41B6: using guessed type char byte_D41B6;

//----- (0004AC40) --------------------------------------------------------
int __cdecl sub_4AC40(int a1)
{
  int result; // eax
  int v2; // ebx
  unsigned __int16 v3; // ax
  int v4; // eax
  int v5; // [esp+0h] [ebp-Ch]
  __int16 v6; // [esp+4h] [ebp-8h]
  int v7; // [esp+8h] [ebp-4h]

  result = sub_4A050();
  v2 = result;
  v7 = result;
  if ( result )
  {
    *(_BYTE *)(result + 69) = 0;
    *(_BYTE *)(result + 63) = 2;
    *(_BYTE *)(result + 64) = 0;
    *(_DWORD *)(result + 16) = (result - (dword_D41A0 + 28302)) / 168 % 11;
    *(_WORD *)(result + 20) = 9377 * *(_WORD *)(result + 20) + 9439;
    v3 = *(_WORD *)(result + 20);
    *(_BYTE *)(v2 + 56) = 1;
    *(_DWORD *)(v2 + 8) = v3 % 0x1388u + 2500;
    v5 = *(_DWORD *)a1;
    v6 = *(_WORD *)(a1 + 4);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    LOWORD(v5) = (*(_WORD *)(v2 + 20) & 0x3F) - 32 + v5;
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    HIWORD(v5) += (*(_WORD *)(v2 + 20) & 0x3F) - 32;
    sub_57D70(v2, (int)&v5);
    sub_49A20(v2);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v4 = *(_WORD *)(v2 + 20) & 1;
    if ( v4 )
    {
      if ( v4 == 1 )
        sub_49DA0((_WORD *)v2, 84);
    }
    else
    {
      sub_49DA0((_WORD *)v2, 83);
    }
    result = v7;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004AD70) --------------------------------------------------------
_WORD *__cdecl sub_4AD70(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // ecx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    v3 = v1 - (dword_D41A0 + 28302);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    *(_DWORD *)(v1 + 16) = v3 / 168 % 11;
    *(_BYTE *)(v1 + 69) = 3;
    *(_BYTE *)(v1 + 63) = 2;
    *(_BYTE *)(v1 + 64) = 1;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49DA0(v2, 79);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004ADF0) --------------------------------------------------------
_WORD *__cdecl sub_4ADF0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // ecx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    v3 = v1 - (dword_D41A0 + 28302);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    *(_DWORD *)(v1 + 16) = v3 / 168 % 11;
    *(_BYTE *)(v1 + 69) = 6;
    *(_BYTE *)(v1 + 63) = 2;
    *(_BYTE *)(v1 + 64) = 2;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49DA0(v2, 39);
    sub_49EA0(v2, 1024, 1024);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004AE80) --------------------------------------------------------
_WORD *__cdecl sub_4AE80(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // ecx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    v3 = v1 - (dword_D41A0 + 28302);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    *(_DWORD *)(v1 + 16) = v3 / 168 % 11;
    *(_BYTE *)(v1 + 69) = 9;
    *(_BYTE *)(v1 + 63) = 2;
    *(_BYTE *)(v1 + 64) = 3;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49DA0(v2, 270);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004AF00) --------------------------------------------------------
_WORD *__cdecl sub_4AF00(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    v3 = dword_D41A0;
    *(_BYTE *)(v1 + 69) = 12;
    *(_BYTE *)(v1 + 63) = 2;
    *(_BYTE *)(v1 + 64) = 4;
    *(_DWORD *)(v1 + 16) = (v1 - (v3 + 28302)) / 168 % 11;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49DA0(v2, 48);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004AF70) --------------------------------------------------------
_WORD *__cdecl sub_4AF70(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    v3 = dword_D41A0;
    *(_BYTE *)(v1 + 69) = 15;
    *(_BYTE *)(v1 + 63) = 2;
    *(_BYTE *)(v1 + 64) = 5;
    *(_DWORD *)(v1 + 16) = (v1 - (v3 + 28302)) / 168 % 11;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49DA0(v2, 48);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004AFE0) --------------------------------------------------------
int __cdecl sub_4AFE0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  unsigned __int16 v4; // ax
  int v6; // [esp+0h] [ebp-8h]
  __int16 v7; // [esp+4h] [ebp-4h]

  if ( *(_BYTE *)(dword_D41A0 + 196308) != 2 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = 18;
  *(_BYTE *)(v1 + 63) = 2;
  v3 = *(_WORD *)(v1 + 20);
  *(_BYTE *)(v1 + 64) = 6;
  *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
  v4 = *(_WORD *)(v1 + 20);
  *(_BYTE *)(v2 + 56) = 1;
  *(_DWORD *)(v2 + 4) = v4 % 0x50u + 100;
  v6 = *(_DWORD *)a1;
  v7 = *(_WORD *)(a1 + 4);
  LOBYTE(v3) = -95 * *(_BYTE *)(v2 + 20) - 33;
  *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
  LOWORD(v6) = (v3 & 0x3F) - 32 + v6;
  *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
  HIWORD(v6) += (*(_WORD *)(v2 + 20) & 0x3F) - 32;
  sub_57D70(v2, (int)&v6);
  sub_49A20(v2);
  *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
  sub_49DA0((_WORD *)v2, (*(_WORD *)(v2 + 20) & 3) + 324);
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004B0F0) --------------------------------------------------------
int __cdecl sub_4B0F0(int a1)
{
  int result; // eax

  if ( *(_BYTE *)(dword_D41A0 + 196308) == 2 )
    result = 0;
  else
    result = sub_4B150(a1, 7, 20, 322);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004B120) --------------------------------------------------------
int __cdecl sub_4B120(int a1)
{
  int result; // eax

  if ( *(_BYTE *)(dword_D41A0 + 196308) == 2 )
    result = 0;
  else
    result = sub_4B150(a1, 8, 21, 323);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004B150) --------------------------------------------------------
int __cdecl sub_4B150(int a1, char a2, char a3, __int16 a4)
{
  int v4; // eax
  int v5; // ebx
  __int16 v6; // dx
  unsigned __int16 v7; // ax
  int v9; // [esp+0h] [ebp-8h]
  __int16 v10; // [esp+4h] [ebp-4h]

  v4 = sub_4A050();
  v5 = v4;
  if ( v4 )
  {
    *(_BYTE *)(v4 + 69) = a3;
    v6 = *(_WORD *)(v4 + 20);
    *(_BYTE *)(v4 + 64) = a2;
    *(_WORD *)(v4 + 20) = 9377 * v6 + 9439;
    v7 = *(_WORD *)(v4 + 20);
    *(_BYTE *)(v5 + 63) = 2;
    *(_BYTE *)(v5 + 56) = 1;
    *(_BYTE *)(v5 + 70) = 0;
    *(_WORD *)(v5 + 44) = -128;
    *(_WORD *)(v5 + 130) = 0;
    *(_DWORD *)(v5 + 4) = v7 % 0x7D0u + 400;
    v9 = *(_DWORD *)a1;
    v10 = *(_WORD *)(a1 + 4);
    *(_WORD *)(v5 + 20) = 9377 * *(_WORD *)(v5 + 20) + 9439;
    LOWORD(v9) = (*(_WORD *)(v5 + 20) & 0x3F) - 32 + v9;
    LOBYTE(v6) = -95 * *(_BYTE *)(v5 + 20) - 33;
    *(_WORD *)(v5 + 20) = 9377 * *(_WORD *)(v5 + 20) + 9439;
    HIWORD(v9) += (v6 & 0x3F) - 32;
    sub_57D70(v5, (int)&v9);
    sub_49A20(v5);
    sub_49DA0((_WORD *)v5, a4);
  }
  return v5;
}

//----- (0004B240) --------------------------------------------------------
_DWORD *__cdecl sub_4B240(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax
  __int16 v4; // dx
  int v5; // ecx
  int v6; // edx
  int v7; // eax
  int v8; // eax
  int v9; // ebx
  int v10; // edx
  _DWORD *v12; // [esp+0h] [ebp-10h]
  int v13; // [esp+4h] [ebp-Ch]
  int v14; // [esp+8h] [ebp-8h]
  signed int v15; // [esp+Ch] [ebp-4h]

  if ( sub_4A810() < 16 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  v12 = (_DWORD *)v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = 1;
  *(_BYTE *)(v1 + 63) = 5;
  *(_BYTE *)(v1 + 64) = 0;
  *(_WORD *)(v1 + 132) = 80;
  *(_WORD *)(v1 + 134) = 16;
  *(_WORD *)(v1 + 130) = 30;
  *(_DWORD *)(v1 + 4) = 4000;
  *(_DWORD *)(v1 + 144) = 4500;
  v3 = *(_DWORD *)(v1 + 144);
  *(_DWORD *)(v2 + 140) = v3;
  v4 = *(_WORD *)(v2 + 20);
  *(_DWORD *)(v2 + 144) = v3 / 2;
  *(_WORD *)(v2 + 20) = 9377 * v4 + 9439;
  LOWORD(v3) = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
  *(_WORD *)(v2 + 32) = v3;
  *(_WORD *)(v2 + 28) = v3;
  v5 = dword_D41A0;
  v6 = dword_D41A0 + 28302;
  *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
  *(_WORD *)(v2 + 34) = 0;
  *(_WORD *)(v2 + 54) = 96;
  *(_BYTE *)(v2 + 56) = 1;
  v7 = *(char *)(v2 + 64);
  *(_DWORD *)(v2 + 16) = (v2 - v6) / 168 % 100;
  LOBYTE(v6) = (*(_BYTE *)(v5 + v7 + 16))++;
  *(_DWORD *)(v2 + 160) = &unk_D8544;
  *(_BYTE *)(v2 + 62) = v6;
  LOWORD(v5) = *(_WORD *)(*(_DWORD *)(v2 + 160) + 26);
  LOWORD(v6) = (signed __int16)*(unsigned __int8 *)(v2 + 62) % *(_WORD *)(*(_DWORD *)(v2 + 160) + 26);
  *(_BYTE *)(v2 + 65) = 3;
  *(_WORD *)(v2 + 44) = 0;
  *(_BYTE *)(v2 + 70) = 0;
  v14 = v2;
  *(_BYTE *)(v2 + 61) = 0;
  v15 = 0;
  *(_BYTE *)(v2 + 57) = v5 - v6 + 4;
  while ( v15 <= 15 )
  {
    v8 = sub_4A050();
    v9 = v8;
    v13 = v8;
    if ( v8 )
    {
      qmemcpy((void *)v8, v12, 0xA8u);
      v10 = v8 - (dword_D41A0 + 28302);
      *(_WORD *)(v8 + 50) = (v14 - (dword_D41A0 + 28302)) / 168;
      *(_WORD *)(v14 + 52) = v10 / 168;
      *(_WORD *)(v8 + 52) = 0;
      *(_BYTE *)(v8 + 69) = -24;
      v12[36] = (v12[35] - (__CFSHL__(v12[35] >> 31, 5) + 32 * (v12[35] >> 31))) >> 5;
      *(_BYTE *)(v8 + 62) = v15;
      sub_49CD0((_WORD *)v8, v15 + 19);
      *(_WORD *)(v9 + 54) = *(_WORD *)(v9 + 84);
      sub_57D70(v9, a1);
      sub_49A20(v9);
    }
    v14 = v13;
    ++v15;
  }
  sub_57D70((int)v12, a1);
  sub_49A20((int)v12);
  sub_49CD0(v12, 40);
  return v12;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004B490) --------------------------------------------------------
int __cdecl sub_4B490(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 9;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 1;
    *(_WORD *)(v1 + 132) = 54;
    *(_WORD *)(v1 + 134) = 18;
    *(_DWORD *)(v1 + 4) = 600;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 134);
    sub_49C70(v1);
    *(_WORD *)(v2 + 32) = 0;
    *(_WORD *)(v2 + 28) = *(_WORD *)(v2 + 32);
    v3 = dword_D41A0;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    *(_DWORD *)(v2 + 16) = (v2 - (v3 + 28302)) / 168 % 100;
    v4 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 34) = 0;
    v5 = v4 + v3;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v4) = (*(_BYTE *)(v5 + 16))++;
    *(_DWORD *)(v2 + 160) = &unk_D88DA;
    *(_BYTE *)(v2 + 62) = v4;
    *(_BYTE *)(v2 + 57) = *(_BYTE *)(*(_DWORD *)(v2 + 160) + 26) + 1;
    *(_BYTE *)(v2 + 65) = 3;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 238);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004B590) --------------------------------------------------------
int __cdecl sub_4B590(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  __int16 v4; // ax
  int v5; // ecx
  int v6; // edx
  int v7; // edx
  int v8; // ecx

  if ( *(_BYTE *)(dword_D41A0 + 196308) )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = 17;
  *(_BYTE *)(v1 + 63) = 5;
  *(_BYTE *)(v1 + 64) = 2;
  *(_WORD *)(v1 + 132) = 64;
  v3 = *(signed __int16 *)(v1 + 132);
  *(_WORD *)(v1 + 134) = 30;
  *(_DWORD *)(v1 + 4) = 3000;
  *(_WORD *)(v1 + 130) = v3 / 2;
  sub_49C70(v1);
  *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
  v4 = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
  *(_WORD *)(v2 + 32) = v4;
  *(_WORD *)(v2 + 28) = v4;
  v5 = dword_D41A0;
  v6 = dword_D41A0 + 28302;
  *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
  *(_WORD *)(v2 + 34) = 0;
  *(_WORD *)(v2 + 42) = 200;
  *(_BYTE *)(v2 + 65) = 3;
  *(_BYTE *)(v2 + 66) = 0;
  *(_DWORD *)(v2 + 16) = (v2 - v6) / 168 % 100;
  v7 = *(char *)(v2 + 64);
  *(_BYTE *)(v2 + 56) = 1;
  LOBYTE(v4) = (*(_BYTE *)(v5 + v7 + 16))++;
  *(_DWORD *)(v2 + 160) = &unk_D8588;
  *(_BYTE *)(v2 + 62) = v4;
  v8 = *(signed __int16 *)(*(_DWORD *)(v2 + 160) + 26)
     - *(unsigned __int8 *)(v2 + 62) % *(signed __int16 *)(*(_DWORD *)(v2 + 160) + 26);
  *(_BYTE *)(v2 + 65) = 3;
  *(_BYTE *)(v2 + 57) = v8 + 4;
  sub_57D70(v2, a1);
  sub_49A20(v2);
  sub_49CD0((_WORD *)v2, 3);
  sub_49EA0((_WORD *)v2, 128, 128);
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004B6F0) --------------------------------------------------------
int __cdecl sub_4B6F0(int a1)
{
  int result; // eax
  int v2; // ebx
  __int64 v3; // rax
  int v4; // ecx
  int v5; // eax
  _WORD *v6; // ebx
  int v7; // edx
  unsigned __int16 v8; // ax
  int v9; // [esp+0h] [ebp-10h]
  int v10; // [esp+4h] [ebp-Ch]
  int v11; // [esp+8h] [ebp-8h]
  signed int v12; // [esp+Ch] [ebp-4h]

  result = sub_4A050();
  v2 = result;
  v9 = result;
  if ( result )
  {
    *(_BYTE *)(result + 69) = 25;
    *(_BYTE *)(result + 63) = 5;
    *(_BYTE *)(result + 64) = 3;
    *(_WORD *)(result + 132) = 64;
    *(_WORD *)(result + 134) = 16;
    *(_WORD *)(result + 130) = 30;
    *(_DWORD *)(result + 4) = 9000;
    sub_49C70(result);
    v3 = *(signed int *)(v2 + 144);
    *(_DWORD *)(v2 + 140) = v3;
    LODWORD(v3) = ((signed int)v3 - HIDWORD(v3)) >> 1;
    WORD2(v3) = *(_WORD *)(v2 + 20);
    *(_DWORD *)(v2 + 144) = v3;
    *(_WORD *)(v2 + 20) = 9377 * WORD2(v3) + 9439;
    LOWORD(v3) = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
    *(_WORD *)(v2 + 32) = v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = dword_D41A0;
    HIDWORD(v3) = dword_D41A0 + 28302;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    *(_WORD *)(v2 + 34) = 0;
    *(_WORD *)(v2 + 54) = 96;
    *(_BYTE *)(v2 + 56) = 1;
    LODWORD(v3) = *(char *)(v2 + 64);
    *(_DWORD *)(v2 + 16) = (v2 - HIDWORD(v3)) / 168 % 100;
    BYTE4(v3) = (*(_BYTE *)(v4 + v3 + 16))++;
    *(_DWORD *)(v2 + 160) = &unk_D85AA;
    *(_BYTE *)(v2 + 62) = BYTE4(v3);
    LOWORD(v4) = *(_WORD *)(*(_DWORD *)(v2 + 160) + 26);
    WORD2(v3) = (signed __int16)*(unsigned __int8 *)(v2 + 62) % *(_WORD *)(*(_DWORD *)(v2 + 160) + 26);
    v11 = v2;
    *(_BYTE *)(v2 + 65) = 3;
    v12 = 0;
    *(_BYTE *)(v2 + 57) = v4 - BYTE4(v3) + 4;
    while ( v12 <= 15 )
    {
      v5 = sub_4A050();
      v6 = (_WORD *)v5;
      v10 = v5;
      if ( v5 )
      {
        qmemcpy((void *)v5, (const void *)v9, 0xA8u);
        v7 = v5 - (dword_D41A0 + 28302);
        *(_WORD *)(v5 + 50) = (v11 - (dword_D41A0 + 28302)) / 168;
        *(_WORD *)(v11 + 52) = v7 / 168;
        *(_WORD *)(v5 + 52) = 0;
        *(_BYTE *)(v5 + 69) = -24;
        *(_DWORD *)(v5 + 144) = (*(_DWORD *)(v9 + 140)
                               - (__CFSHL__(*(_DWORD *)(v9 + 140) >> 31, 5)
                                + 32 * (*(_DWORD *)(v9 + 140) >> 31))) >> 5;
        *(_BYTE *)(v5 + 62) = v12;
        sub_49CD0((_WORD *)v5, v12 + 89);
        v6[42] = 65 * (unsigned __int16)word_D9522[7 * (v12 + 89)] / 100;
        v6[43] = 65 * (unsigned __int16)word_D9522[7 * (v12 + 89)] / 100;
        v6[44] = 65 * (unsigned __int16)word_D9524[7 * (v12 + 89)] / 100;
        v8 = v6[42];
        v6[27] = v8;
        if ( !v12 )
          v6[27] = 125 * v8 / 100;
        sub_57D70(v10, a1);
        sub_49A20(v10);
      }
      v11 = v10;
      ++v12;
    }
    sub_57D70(v9, a1);
    sub_49A20(v9);
    sub_49CD0((_WORD *)v9, 88);
    *(_WORD *)(v9 + 84) = 60 * (unsigned __int16)word_D99F2 / 100;
    *(_WORD *)(v9 + 86) = 60 * (unsigned __int16)word_D99F2 / 100;
    *(_WORD *)(v9 + 88) = 60 * (unsigned __int16)word_D99F4 / 100;
    result = v9;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D9522: using guessed type __int16 word_D9522[];
// D9524: using guessed type __int16 word_D9524[];
// D99F2: using guessed type __int16 word_D99F2;
// D99F4: using guessed type __int16 word_D99F4;

//----- (0004BA10) --------------------------------------------------------
int __cdecl sub_4BA10(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // ecx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 33;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 4;
    *(_WORD *)(v1 + 132) = 30;
    *(_WORD *)(v1 + 134) = 0;
    *(_DWORD *)(v1 + 4) = 1000;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    sub_49C70(v1);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v3 = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
    *(_WORD *)(v2 + 32) = v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = dword_D41A0;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    *(_WORD *)(v2 + 34) = 0;
    *(_DWORD *)(v2 + 16) = (v2 - (v4 + 28302)) / 168 % 100;
    v5 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 42) = 500;
    v6 = v5 + v4;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v5) = (*(_BYTE *)(v6 + 16))++;
    *(_DWORD *)(v2 + 160) = &off_D85CC;
    *(_BYTE *)(v2 + 62) = v5;
    v7 = *(signed __int16 *)(*(_DWORD *)(v2 + 160) + 26)
       - *(unsigned __int8 *)(v2 + 62) % *(signed __int16 *)(*(_DWORD *)(v2 + 160) + 26);
    *(_BYTE *)(v2 + 65) = 3;
    *(_BYTE *)(v2 + 57) = v7 + 4;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 0);
    sub_49EA0((_WORD *)v2, 128, 256);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D85CC: using guessed type void *off_D85CC;

//----- (0004BBB0) --------------------------------------------------------
int __cdecl sub_4BBB0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // ax
  unsigned __int16 v4; // ax
  __int16 v5; // dx
  int v6; // edx
  int v7; // eax
  int v8; // eax
  int v9; // esi

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 72;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 9;
    *(_WORD *)(v1 + 132) = 20;
    *(_WORD *)(v1 + 134) = 0;
    v3 = *(_WORD *)(v1 + 132);
    *(_DWORD *)(v2 + 4) = 1000;
    *(_WORD *)(v2 + 130) = v3;
    sub_49C70(v2);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v4 = *(_WORD *)(v2 + 20);
    *(_WORD *)(v2 + 34) = 0;
    v5 = v4 % 0x832u - 1;
    *(_WORD *)(v2 + 32) = v5;
    *(_WORD *)(v2 + 28) = v5;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    v6 = dword_D41A0;
    v7 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 42) = 500;
    v8 = v6 + v7;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v6) = (*(_BYTE *)(v8 + 16))++;
    *(_DWORD *)(v2 + 160) = &off_D8676;
    *(_BYTE *)(v2 + 62) = v6;
    v9 = *(signed __int16 *)(*(_DWORD *)(v2 + 160) + 26)
       - *(unsigned __int8 *)(v2 + 62) % *(signed __int16 *)(*(_DWORD *)(v2 + 160) + 26);
    *(_BYTE *)(v2 + 65) = 3;
    *(_DWORD *)(v2 + 16) = 16;
    *(_BYTE *)(v2 + 57) = v9 + 4;
    sub_57D70(v2, a1);
    *(_WORD *)(v2 + 80) = sub_10C40((__int16 *)(v2 + 76));
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 220);
    sub_49EA0((_WORD *)v2, 128, 128);
    if ( sub_102D0(v2, (__int16 *)(v2 + 76), 1) )
    {
      sub_57F20(v2);
      v2 = 0;
    }
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D8676: using guessed type void *off_D8676;

//----- (0004BD00) --------------------------------------------------------
int __cdecl sub_4BD00(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // edx
  int v5; // eax

  if ( !(*(_BYTE *)(dword_D41A0 + 196306) & 2) )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = 80;
  *(_BYTE *)(v1 + 63) = 5;
  *(_BYTE *)(v1 + 64) = 10;
  *(_DWORD *)(v1 + 4) = 300000;
  sub_49C70(v1);
  *(_DWORD *)(v2 + 12) |= 0x48800001u;
  v3 = dword_D41A0;
  v4 = *(char *)(v2 + 64);
  *(_WORD *)(v2 + 42) = 0;
  v5 = v4 + v3;
  *(_BYTE *)(v2 + 56) = 1;
  LOBYTE(v4) = (*(_BYTE *)(v5 + 16))++;
  *(_DWORD *)(v2 + 160) = &off_D89C8;
  *(_BYTE *)(v2 + 57) = 64;
  *(_BYTE *)(v2 + 65) = 3;
  *(_DWORD *)(v2 + 16) = 0;
  *(_BYTE *)(v2 + 70) = 0;
  *(_BYTE *)(v2 + 62) = v4;
  sub_57D70(v2, a1);
  *(_WORD *)(v2 + 80) = sub_10C40((__int16 *)(v2 + 76));
  sub_49A20(v2);
  sub_49C90(v2, 341);
  *(_WORD *)(v2 + 82) = 512;
  sub_49EA0((_WORD *)v2, 1024, 1280);
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D89C8: using guessed type void *off_D89C8;

//----- (0004BDF0) --------------------------------------------------------
int __cdecl sub_4BDF0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // cx
  __int16 v4; // dx
  __int16 v5; // dx
  int v6; // ecx
  int v7; // edx
  int v8; // edx
  char v9; // al

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_WORD *)(v1 + 134) = 24;
    v3 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 134);
    *(_BYTE *)(v1 + 69) = 97;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 12;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 132) = 54;
    *(_DWORD *)(v1 + 4) = 1000;
    v5 = (v4 & 0x7FF) - 1;
    *(_WORD *)(v1 + 32) = v5;
    *(_WORD *)(v1 + 28) = v5;
    v6 = dword_D41A0;
    *(_WORD *)(v1 + 30) = *(_WORD *)(v1 + 32);
    *(_DWORD *)(v1 + 144) = 0;
    *(_WORD *)(v1 + 34) = 0;
    *(_DWORD *)(v1 + 16) = (v1 - (v6 + 28302)) / 168 % 100;
    v7 = *(char *)(v1 + 64);
    *(_WORD *)(v1 + 42) = 500;
    v8 = v6 + v7;
    *(_BYTE *)(v1 + 56) = 1;
    v9 = (*(_BYTE *)(v8 + 16))++;
    *(_DWORD *)(v2 + 160) = &off_D8940;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_DWORD *)(v2 + 16) = 2;
    *(_BYTE *)(v2 + 62) = v9;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 221);
    sub_49EA0((_WORD *)v2, 128, 128);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D8940: using guessed type void *off_D8940;

//----- (0004BF40) --------------------------------------------------------
_WORD *__cdecl sub_4BF40(int a1)
{
  int v1; // eax
  int v2; // ebx
  _WORD *v3; // esi
  __int16 v4; // dx
  __int16 v5; // ax
  int v6; // ecx
  int v7; // edx
  int v8; // edx

  v1 = sub_4A050();
  v2 = v1;
  v3 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 105;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 13;
    *(_WORD *)(v1 + 132) = 54;
    *(_WORD *)(v1 + 134) = 18;
    v4 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 134);
    *(_WORD *)(v1 + 20) = 9377 * v4 + 9439;
    v5 = (*(_WORD *)(v1 + 20) & 0x7FF) - 1;
    *(_WORD *)(v2 + 32) = v5;
    *(_WORD *)(v2 + 28) = v5;
    v6 = dword_D41A0;
    v7 = dword_D41A0 + 28302;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    *(_DWORD *)(v2 + 4) = 1000;
    *(_DWORD *)(v2 + 144) = 0;
    *(_WORD *)(v2 + 34) = 0;
    *(_WORD *)(v2 + 42) = 500;
    *(_DWORD *)(v2 + 16) = (v2 - v7) / 168 % 100;
    v8 = *(char *)(v2 + 64);
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v5) = (*(_BYTE *)(v6 + v8 + 16))++;
    *(_DWORD *)(v2 + 160) = &off_D891E;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_DWORD *)(v2 + 16) = 2;
    *(_BYTE *)(v2 + 62) = v5;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    switch ( *(unsigned __int16 *)(v2 + 20) % 9u )
    {
      case 0u:
      case 1u:
      case 2u:
        sub_49CD0(v3, 242);
        break;
      case 3u:
      case 4u:
      case 5u:
        sub_49CD0(v3, 271);
        break;
      case 6u:
      case 7u:
        sub_49CD0(v3, 241);
        break;
      case 8u:
        sub_49CD0((_WORD *)v2, 239);
        break;
      default:
        break;
    }
    sub_49EA0(v3, 128, 128);
  }
  return v3;
}
// D41A0: using guessed type int dword_D41A0;
// D891E: using guessed type void *off_D891E;

//----- (0004C0B0) --------------------------------------------------------
int __cdecl sub_4C0B0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // cx
  __int16 v4; // dx
  __int16 v5; // dx
  int v6; // ecx
  int v7; // edx
  int v8; // edx
  char v9; // al

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_WORD *)(v1 + 134) = 18;
    v3 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 134);
    *(_BYTE *)(v1 + 69) = 113;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 14;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 132) = 54;
    *(_DWORD *)(v1 + 4) = 1000;
    v5 = (v4 & 0x7FF) - 1;
    *(_WORD *)(v1 + 32) = v5;
    *(_WORD *)(v1 + 28) = v5;
    v6 = dword_D41A0;
    *(_WORD *)(v1 + 30) = *(_WORD *)(v1 + 32);
    *(_DWORD *)(v1 + 144) = 0;
    *(_WORD *)(v1 + 34) = 0;
    *(_DWORD *)(v1 + 16) = (v1 - (v6 + 28302)) / 168 % 100;
    v7 = *(char *)(v1 + 64);
    *(_WORD *)(v1 + 42) = 500;
    v8 = v6 + v7;
    *(_BYTE *)(v1 + 56) = 1;
    v9 = (*(_BYTE *)(v8 + 16))++;
    *(_DWORD *)(v2 + 160) = &off_D891E;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_DWORD *)(v2 + 16) = 2;
    *(_BYTE *)(v2 + 62) = v9;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 219);
    sub_49EA0((_WORD *)v2, 128, 128);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D891E: using guessed type void *off_D891E;

//----- (0004C1E0) --------------------------------------------------------
int __cdecl sub_4C1E0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  char v6; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 121;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 15;
    *(_WORD *)(v1 + 132) = 30;
    *(_WORD *)(v1 + 134) = 0;
    *(_DWORD *)(v1 + 4) = 1000;
    *(_WORD *)(v1 + 32) = 0;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    *(_WORD *)(v1 + 28) = *(_WORD *)(v1 + 32);
    v3 = dword_D41A0;
    *(_WORD *)(v1 + 30) = *(_WORD *)(v1 + 32);
    *(_DWORD *)(v1 + 144) = 0;
    *(_WORD *)(v1 + 34) = 0;
    *(_DWORD *)(v1 + 16) = (v1 - (v3 + 28302)) / 168 % 100;
    v4 = *(char *)(v1 + 64);
    *(_WORD *)(v1 + 42) = 500;
    v5 = v4 + v3;
    *(_BYTE *)(v1 + 56) = 1;
    LOBYTE(v4) = (*(_BYTE *)(v5 + 16))++;
    *(_DWORD *)(v1 + 160) = &off_D86DC;
    *(_BYTE *)(v1 + 62) = v4;
    LOWORD(v5) = *(_WORD *)(*(_DWORD *)(v1 + 160) + 26);
    LOWORD(v4) = (signed __int16)*(unsigned __int8 *)(v1 + 62) % *(_WORD *)(*(_DWORD *)(v1 + 160) + 26);
    *(_BYTE *)(v1 + 65) = 3;
    v6 = *(_BYTE *)(v1 + 14) | 2;
    *(_BYTE *)(v2 + 57) = v5 - v4 + 4;
    *(_BYTE *)(v2 + 14) = v6;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 0);
    sub_49EA0((_WORD *)v2, 128, 128);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D86DC: using guessed type void *off_D86DC;

//----- (0004C310) --------------------------------------------------------
int __cdecl sub_4C310(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // ax
  __int16 v4; // ax
  int v5; // ecx
  int v6; // edx
  int v7; // eax
  int v8; // ecx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -127;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 16;
    *(_WORD *)(v1 + 132) = 60;
    *(_WORD *)(v1 + 134) = 20;
    v3 = *(_WORD *)(v1 + 132);
    *(_DWORD *)(v2 + 4) = 60000;
    *(_WORD *)(v2 + 130) = v3;
    sub_49C70(v2);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v4 = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
    *(_WORD *)(v2 + 32) = v4;
    *(_WORD *)(v2 + 28) = v4;
    v5 = dword_D41A0;
    v6 = dword_D41A0 + 28302;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    *(_WORD *)(v2 + 34) = 0;
    *(_WORD *)(v2 + 42) = 500;
    v7 = *(char *)(v2 + 64);
    *(_BYTE *)(v2 + 56) = 1;
    v8 = v7 + v5;
    *(_DWORD *)(v2 + 16) = (v2 - v6) / 168 % 100;
    LOBYTE(v7) = (*(_BYTE *)(v8 + 16))++;
    *(_DWORD *)(v2 + 160) = &unk_D86FE;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_DWORD *)(v2 + 16) = 0;
    *(_BYTE *)(v2 + 62) = v7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 207);
    *(_WORD *)(v2 + 82) = (5 * (unsigned __int16)word_DA076
                         - (__CFSHL__(5 * (unsigned __int16)word_DA076 >> 31, 3)
                          + 8 * (5 * (unsigned __int16)word_DA076 >> 31))) >> 3;
    sub_49EA0((_WORD *)v2, 128, 128);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// DA076: using guessed type __int16 word_DA076;

//----- (0004C460) --------------------------------------------------------
int __cdecl sub_4C460(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  int v4; // ecx
  int v5; // edx
  int v6; // edx
  char v7; // al

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -119;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 17;
    *(_WORD *)(v1 + 132) = 68;
    *(_WORD *)(v1 + 134) = 20;
    *(_DWORD *)(v1 + 4) = 10000;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    sub_49C70(v1);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v3 = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
    *(_WORD *)(v2 + 32) = v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = dword_D41A0;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    *(_WORD *)(v2 + 34) = 0;
    *(_DWORD *)(v2 + 16) = (v2 - (v4 + 28302)) / 168 % 100;
    v5 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 42) = 350;
    v6 = v4 + v5;
    *(_BYTE *)(v2 + 56) = 1;
    v7 = (*(_BYTE *)(v6 + 16))++;
    *(_DWORD *)(v2 + 160) = &unk_D8720;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_DWORD *)(v2 + 16) = 0;
    *(_BYTE *)(v2 + 62) = v7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 285);
    sub_49EA0((_WORD *)v2, 128, 128);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004C590) --------------------------------------------------------
int __cdecl sub_4C590(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  int v4; // ecx
  int v5; // edx
  int v6; // edx
  char v7; // al

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -109;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 18;
    *(_WORD *)(v1 + 132) = 10;
    *(_WORD *)(v1 + 134) = 6;
    *(_DWORD *)(v1 + 4) = 36000;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    sub_49C70(v1);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v3 = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
    *(_WORD *)(v2 + 32) = v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = dword_D41A0;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    *(_WORD *)(v2 + 34) = 0;
    *(_DWORD *)(v2 + 16) = (v2 - (v4 + 28302)) / 168 % 100;
    v5 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 42) = 500;
    v6 = v4 + v5;
    *(_BYTE *)(v2 + 56) = 1;
    v7 = (*(_BYTE *)(v6 + 16))++;
    *(_DWORD *)(v2 + 160) = &off_D8742;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_BYTE *)(v2 + 62) = v7;
    *(_DWORD *)(v2 + 16) = 100;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 286);
    sub_49EA0((_WORD *)v2, 512, 512);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D8742: using guessed type void *off_D8742;

//----- (0004C6B0) --------------------------------------------------------
int __cdecl sub_4C6B0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // ecx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -103;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 19;
    *(_WORD *)(v1 + 132) = 76;
    *(_WORD *)(v1 + 134) = 8;
    *(_DWORD *)(v1 + 4) = 600;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    sub_49C70(v1);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v3 = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
    *(_WORD *)(v2 + 32) = v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = dword_D41A0;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    *(_WORD *)(v2 + 34) = 0;
    *(_WORD *)(v2 + 42) = 300;
    *(_BYTE *)(v2 + 65) = 3;
    *(_DWORD *)(v2 + 16) = (v2 - (v4 + 28302)) / 168 % 100;
    v5 = *(char *)(v2 + 64);
    *(_BYTE *)(v2 + 66) = 0;
    v6 = v5 + v4;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v5) = (*(_BYTE *)(v6 + 16))++;
    *(_DWORD *)(v2 + 160) = &unk_D8786;
    *(_BYTE *)(v2 + 62) = v5;
    v7 = *(signed __int16 *)(*(_DWORD *)(v2 + 160) + 26)
       - *(unsigned __int8 *)(v2 + 62) % *(signed __int16 *)(*(_DWORD *)(v2 + 160) + 26);
    *(_BYTE *)(v2 + 65) = 3;
    *(_BYTE *)(v2 + 57) = v7 + 4;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 287);
    sub_49EA0((_WORD *)v2, 85, 51);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004C7F0) --------------------------------------------------------
int __cdecl sub_4C7F0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  int v4; // eax
  int v5; // edx
  int v6; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -95;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 20;
    *(_WORD *)(v1 + 132) = 32;
    *(_WORD *)(v1 + 134) = 20;
    *(_DWORD *)(v1 + 4) = 5500;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    sub_49C70(v1);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v3 = *(_WORD *)(v2 + 20) & 0x7FF;
    *(_WORD *)(v2 + 34) = 0;
    *(_WORD *)(v2 + 32) = --v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    v5 = dword_D41A0;
    *(_WORD *)(v2 + 42) = 100;
    v6 = v4 + v5;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v4) = (*(_BYTE *)(v6 + 16))++;
    *(_DWORD *)(v2 + 160) = &unk_D87A8;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_BYTE *)(v2 + 62) = v4;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 288);
    sub_49EA0((_WORD *)v2, 384, 512);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004C8F0) --------------------------------------------------------
int __cdecl sub_4C8F0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // cx
  __int16 v4; // dx
  __int16 v5; // dx
  int v6; // eax
  int v7; // edx
  int v8; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    v3 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 134);
    *(_BYTE *)(v1 + 69) = -87;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 21;
    *(_WORD *)(v1 + 132) = 96;
    *(_DWORD *)(v1 + 4) = 1000;
    *(_DWORD *)(v1 + 144) = 1000;
    *(_WORD *)(v1 + 34) = 0;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 42) = 400;
    *(_BYTE *)(v1 + 56) = 1;
    v5 = (v4 & 0x7FF) - 1;
    *(_WORD *)(v1 + 32) = v5;
    *(_WORD *)(v1 + 28) = v5;
    *(_WORD *)(v1 + 30) = *(_WORD *)(v1 + 32);
    v6 = *(char *)(v1 + 64);
    v7 = v6 + dword_D41A0;
    LOBYTE(v6) = *(_BYTE *)(v6 + dword_D41A0 + 16);
    *(_BYTE *)(v7 + 16) = v6 + 1;
    *(_DWORD *)(v2 + 160) = &unk_D8896;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_BYTE *)(v2 + 70) = 0;
    *(_WORD *)(v2 + 44) = 0;
    *(_BYTE *)(v2 + 68) = 0;
    *(_BYTE *)(v2 + 67) = 0;
    *(_BYTE *)(v2 + 62) = v6;
    sub_57D70(v2, a1);
    v8 = sub_49A20(v2);
    sub_26500(v8, v2);
    sub_268F0(v2, 1u);
    sub_49EA0((_WORD *)v2, 128, 128);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004CA00) --------------------------------------------------------
int __cdecl sub_4CA00(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax
  int v5; // ecx
  int v6; // eax
  int v7; // ecx
  __int16 v8; // dx

  if ( sub_4A810() < 15 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = -80;
  *(_BYTE *)(v1 + 63) = 5;
  *(_BYTE *)(v1 + 64) = 22;
  *(_WORD *)(v1 + 132) = 128;
  *(_WORD *)(v1 + 134) = 16;
  v3 = *(_WORD *)(v1 + 20);
  *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 134);
  *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
  v4 = (*(_WORD *)(v1 + 20) & 0x7FF) - 1;
  *(_WORD *)(v2 + 32) = v4;
  *(_WORD *)(v2 + 28) = v4;
  v5 = *(char *)(v2 + 64);
  *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
  v6 = dword_D41A0;
  *(_DWORD *)(v2 + 4) = 2000;
  v7 = v6 + v5;
  *(_WORD *)(v2 + 34) = 0;
  LOBYTE(v3) = (*(_BYTE *)(v7 + 16))++;
  *(_DWORD *)(v2 + 160) = &unk_D87CA;
  *(_BYTE *)(v2 + 62) = v3;
  LOWORD(v7) = *(_WORD *)(*(_DWORD *)(v2 + 160) + 26);
  v8 = (signed __int16)*(unsigned __int8 *)(v2 + 62) % *(_WORD *)(*(_DWORD *)(v2 + 160) + 26);
  *(_BYTE *)(v2 + 65) = 3;
  *(_BYTE *)(v2 + 56) = 3;
  *(_WORD *)(v2 + 148) = 0;
  *(_WORD *)(v2 + 82) = 0;
  *(_BYTE *)(v2 + 92) = 0;
  *(_WORD *)(v2 + 44) = 11;
  *(_WORD *)(v2 + 42) = 0;
  *(_WORD *)(v2 + 54) = 0;
  *(_WORD *)(v2 + 150) = 1024;
  *(_WORD *)(v2 + 36) = 0;
  *(_BYTE *)(v2 + 70) = 15;
  *(_BYTE *)(v2 + 57) = v7 - v8 + 4;
  *(_DWORD *)&word_EB398 = *(_DWORD *)a1;
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 4);
  word_EB39C = sub_10C40(&word_EB398) + 384;
  sub_57D70(v2, (int)&word_EB398);
  sub_49C70(v2);
  sub_49A20(v2);
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0004CB60) --------------------------------------------------------
signed int __cdecl sub_4CB60(int a1)
{
  signed int v1; // ebx
  __int16 v2; // di
  int v3; // eax
  _WORD *v5; // [esp+0h] [ebp-8h]
  int v6; // [esp+4h] [ebp-4h]

  v1 = 1;
  v5 = (_WORD *)a1;
  while ( (signed __int16)v1 <= *(char *)(a1 + 70) / 2 )
  {
    v2 = 0;
    while ( v2 < 2 )
    {
      v6 = sub_4A050();
      if ( v6 )
      {
        if ( v2 )
          v3 = -(signed __int16)v1;
        else
          LOWORD(v3) = v1;
        sub_274C0(a1, v6, v5, v3);
      }
      ++v2;
      v5 = (_WORD *)v6;
    }
    ++v1;
  }
  sub_27590(v1, a1);
  sub_27610(v1, a1);
  return sub_276E0(a1);
}

//----- (0004CBF0) --------------------------------------------------------
int __cdecl sub_4CBF0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax
  __int16 v5; // ax
  int v6; // edx
  int v7; // eax
  int v8; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -72;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 23;
    *(_WORD *)(v1 + 132) = 24;
    *(_WORD *)(v1 + 134) = 14;
    v3 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_DWORD *)(v2 + 4) = 10000;
    *(_DWORD *)(v2 + 144) = 100;
    v5 = (v4 & 0x7FF) - 1;
    *(_WORD *)(v2 + 32) = v5;
    v6 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 28) = v5;
    v7 = dword_D41A0;
    *(_WORD *)(v2 + 42) = 500;
    v8 = v6 + v7;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v6) = (*(_BYTE *)(v8 + 16))++;
    *(_DWORD *)(v2 + 160) = &unk_D87EC;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_WORD *)(v2 + 44) = 0x2000;
    *(_BYTE *)(v2 + 62) = v6;
    *(_WORD *)(a1 + 4) = *(_WORD *)(v2 + 44);
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 289);
    sub_49EA0((_WORD *)v2, 384, 384);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004CCF0) --------------------------------------------------------
int __cdecl sub_4CCF0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // ax
  __int16 v4; // ax
  int v5; // edx
  int v6; // eax
  int v7; // eax

  if ( *(_BYTE *)(dword_D41A0 + 196308) != 2 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = -63;
  *(_BYTE *)(v1 + 63) = 5;
  *(_BYTE *)(v1 + 64) = 24;
  *(_BYTE *)(v1 + 70) = 0;
  *(_WORD *)(v1 + 132) = 80;
  *(_WORD *)(v1 + 134) = 24;
  v3 = *(_WORD *)(v1 + 134);
  *(_DWORD *)(v2 + 4) = 16000;
  *(_WORD *)(v2 + 130) = v3;
  sub_49C70(v2);
  *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
  v4 = *(_WORD *)(v2 + 20) & 0x7FF;
  *(_WORD *)(v2 + 34) = 0;
  *(_WORD *)(v2 + 32) = --v4;
  *(_WORD *)(v2 + 28) = v4;
  v5 = *(char *)(v2 + 64);
  *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
  v6 = dword_D41A0;
  *(_WORD *)(v2 + 42) = 1500;
  v7 = v5 + v6;
  *(_BYTE *)(v2 + 56) = 1;
  LOBYTE(v5) = (*(_BYTE *)(v7 + 16))++;
  *(_BYTE *)(v2 + 62) = v5;
  *(_DWORD *)(v2 + 160) = &unk_D8962;
  *(_BYTE *)(v2 + 57) = 64;
  *(_BYTE *)(v2 + 65) = 3;
  sub_57D70(v2, a1);
  sub_49A20(v2);
  sub_49CD0((_WORD *)v2, 335);
  sub_49EA0((_WORD *)v2, 256, 640);
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004CE00) --------------------------------------------------------
int __cdecl sub_4CE00(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  int v4; // eax
  int v5; // edx
  int v6; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -55;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 25;
    *(_BYTE *)(v1 + 70) = 0;
    *(_WORD *)(v1 + 132) = 60;
    *(_WORD *)(v1 + 134) = 20;
    *(_DWORD *)(v1 + 4) = 7500;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    sub_49C70(v1);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v3 = *(_WORD *)(v2 + 20) & 0x7FF;
    *(_WORD *)(v2 + 34) = 0;
    *(_WORD *)(v2 + 32) = --v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    v5 = dword_D41A0;
    *(_WORD *)(v2 + 42) = 300;
    v6 = v4 + v5;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v4) = (*(_BYTE *)(v6 + 16))++;
    *(_DWORD *)(v2 + 160) = &unk_D880E;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_BYTE *)(v2 + 62) = v4;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 290);
    sub_49EA0((_WORD *)v2, 384, 384);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004CF00) --------------------------------------------------------
int __cdecl sub_4CF00(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  int v4; // eax
  int v5; // edx
  int v6; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -47;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 26;
    *(_WORD *)(v1 + 132) = 25;
    *(_WORD *)(v1 + 134) = 25;
    *(_DWORD *)(v1 + 4) = 4400;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 134);
    sub_49C70(v1);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v3 = *(_WORD *)(v2 + 20) & 0x7FF;
    *(_WORD *)(v2 + 34) = 0;
    *(_WORD *)(v2 + 32) = --v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    v5 = dword_D41A0;
    *(_WORD *)(v2 + 42) = 300;
    v6 = v4 + v5;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v4) = (*(_BYTE *)(v6 + 16))++;
    *(_DWORD *)(v2 + 160) = &unk_D88FC;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_BYTE *)(v2 + 62) = v4;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 318);
    sub_49EA0((_WORD *)v2, 256, 384);
    sub_293D0(v2);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004D000) --------------------------------------------------------
unsigned int __usercall sub_4D000@<eax>(unsigned int a1@<esi>, int a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // ebx
  int v4; // edi
  int v5; // eax
  __int64 v6; // rtt
  _BYTE *v7; // eax
  _WORD *v8; // ebx
  int v9; // eax
  _BYTE *v11; // [esp+0h] [ebp-14h]
  signed int i; // [esp+4h] [ebp-10h]
  _BYTE *v13; // [esp+8h] [ebp-Ch]
  int v14; // [esp+8h] [ebp-Ch]
  signed int v15; // [esp+Ch] [ebp-8h]
  char v16; // [esp+10h] [ebp-4h]

  v16 = 0;
  if ( *(_BYTE *)(dword_D41A0 + 196308) == 2 )
  {
    v16 = 1;
  }
  else
  {
    if ( sub_4A810() >= 51 )
    {
      v2 = (_BYTE *)sub_4A050();
      v3 = v2;
      a1 = (unsigned int)v2;
      if ( v2 )
      {
        v2[69] = -39;
        v2[63] = 5;
        v2[64] = 27;
        sub_57D70((int)v2, a2);
        v13 = v3;
        v15 = 0;
        v4 = (signed int)&v3[-dword_D41A0 - 28302] / 168;
        while ( v15 < 5 && !v16 )
        {
          v5 = sub_4A050();
          v11 = (_BYTE *)v5;
          if ( v5 )
          {
            *(_BYTE *)(v5 + 69) = -23;
            *(_BYTE *)(v5 + 63) = 5;
            *(_BYTE *)(v5 + 64) = 27;
            *(_BYTE *)(v5 + 59) = v15;
            v6 = v5 - (dword_D41A0 + 28302);
            *(_WORD *)(v5 + 26) = v4;
            *(_WORD *)(v5 + 50) = v4;
            *((_WORD *)v13 + 26) = v6 / 168;
            v14 = v5;
            *(_WORD *)(v5 + 52) = 0;
            sub_57D70(v5, a2);
            for ( i = 0; i < 9 && !v16; ++i )
            {
              v7 = (_BYTE *)sub_4A050();
              v8 = v7;
              v11 = v7;
              if ( v7 )
              {
                v7[69] = -22;
                v7[63] = 5;
                v7[64] = 27;
                v7[59] = v15;
                v9 = (signed int)&v7[-dword_D41A0 - 28302] / 168;
                v8[13] = v4;
                v8[25] = v4;
                *(_WORD *)(v14 + 52) = v9;
                v8[26] = 0;
                sub_57D70((int)v8, a2);
              }
              else
              {
                v16 = 1;
              }
              v14 = (int)v11;
            }
          }
          else
          {
            v16 = 1;
          }
          v13 = v11;
          ++v15;
        }
      }
    }
    if ( !a1 || v16 )
    {
      sub_2AE80(a1);
    }
    else
    {
      sub_2AC50(a1);
      sub_2AD40(a1);
      sub_2AE30(a1);
    }
  }
  if ( v16 )
    a1 = 0;
  return a1;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004D1D0) --------------------------------------------------------
int __cdecl sub_4D1D0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax
  int v5; // edx
  int v6; // eax
  int v7; // edx
  char v8; // cl
  int v9; // ecx
  int v10; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -31;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 28;
    *(_WORD *)(v1 + 132) = 120;
    *(_WORD *)(v1 + 134) = 64;
    *(_DWORD *)(v1 + 4) = 8000;
    sub_49C70(v1);
    v3 = *(_WORD *)(v2 + 20);
    *(_BYTE *)(v2 + 15) |= 8u;
    *(_WORD *)(v2 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v2 + 20) & 0x7FF;
    *(_WORD *)(v2 + 34) = 0;
    *(_WORD *)(v2 + 32) = --v4;
    *(_WORD *)(v2 + 28) = v4;
    v5 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    v6 = dword_D41A0;
    *(_WORD *)(v2 + 42) = 2000;
    v7 = v6 + v5;
    *(_BYTE *)(v2 + 56) = 1;
    v8 = (*(_BYTE *)(v7 + 16))++;
    *(_BYTE *)(v2 + 62) = v8;
    v9 = *(signed __int16 *)(v2 + 134);
    v10 = (*(signed __int16 *)(v2 + 132) - v9) / 2;
    *(_DWORD *)(v2 + 160) = &unk_D8830;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_WORD *)(v2 + 130) = v9 + v10;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 292);
    sub_49EA0((_WORD *)v2, 85, 42);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004D2E0) --------------------------------------------------------
int __cdecl sub_4D2E0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 0;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 0;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D8456;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 340);
    sub_847D0(v2, 128, 1, 0);
  }
  return v2;
}
// D8456: using guessed type void *off_D8456;

//----- (0004D380) --------------------------------------------------------
int __cdecl sub_4D380(int a1)
{
  int result; // eax

  result = sub_4D2E0(a1);
  if ( result )
  {
    *(_BYTE *)(result + 69) = 29;
    *(_BYTE *)(result + 64) = 28;
  }
  return result;
}

//----- (0004D3B0) --------------------------------------------------------
int __cdecl sub_4D3B0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_4A050();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 69) = 1;
    *(_BYTE *)(result + 63) = 9;
    *(_BYTE *)(result + 64) = 1;
    *(_WORD *)(result + 130) = 384;
    *(_WORD *)(result + 132) = 384;
    v3 = 4096 / *(signed __int16 *)(result + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 160) = &unk_D83F0;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_BYTE *)(v2 + 65) = 10;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 209);
    sub_49EA0((_WORD *)v2, 2 * *(_WORD *)(v2 + 84), 5 * *(signed __int16 *)(v2 + 88) / 2);
    result = v2;
  }
  return result;
}

//----- (0004D470) --------------------------------------------------------
int __cdecl sub_4D470(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 2;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 2;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 211);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D500) --------------------------------------------------------
int __cdecl sub_4D500(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 3;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 3;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 76);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D590) --------------------------------------------------------
int __cdecl sub_4D590(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 4;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 4;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 210);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D620) --------------------------------------------------------
int __cdecl sub_4D620(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 5;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 5;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 211);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D6B0) --------------------------------------------------------
int __cdecl sub_4D6B0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 6;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 6;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 212);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D740) --------------------------------------------------------
int __cdecl sub_4D740(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 7;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 7;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 213);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D7D0) --------------------------------------------------------
int __cdecl sub_4D7D0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 8;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 8;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D8434;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 214);
  }
  return v2;
}
// D8434: using guessed type void *off_D8434;

//----- (0004D860) --------------------------------------------------------
int __cdecl sub_4D860(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 9;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 9;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 3584 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D8434;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 216);
    sub_847D0(v2, 128, 9, 0);
  }
  return v2;
}
// D8434: using guessed type void *off_D8434;

//----- (0004D900) --------------------------------------------------------
int __cdecl sub_4D900(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 10;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 10;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 18);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D990) --------------------------------------------------------
int __cdecl sub_4D990(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 11;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 11;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 281);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004DA20) --------------------------------------------------------
int __cdecl sub_4DA20(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 12;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 12;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 2048 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 216);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004DAB0) --------------------------------------------------------
_WORD *__cdecl sub_4DAB0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 13;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 13;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    *(_DWORD *)(v1 + 4) = 5120 / *(signed __int16 *)(v1 + 130);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49E10(v2, 195);
  }
  return v2;
}

//----- (0004DBC0) --------------------------------------------------------
_WORD *__cdecl sub_4DBC0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 15;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 14;
    *(_WORD *)(v1 + 130) = 128;
    *(_WORD *)(v1 + 132) = 128;
    *(_DWORD *)(v1 + 4) = 4096 / *(signed __int16 *)(v1 + 130);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 196);
  }
  return v2;
}

//----- (0004DC40) --------------------------------------------------------
_WORD *__cdecl sub_4DC40(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 21;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 20;
    *(_WORD *)(v1 + 130) = 394;
    *(_WORD *)(v1 + 132) = *(_WORD *)(v1 + 130);
    *(_DWORD *)(v1 + 4) = 7680 / *(signed __int16 *)(v1 + 130);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 196);
  }
  return v2;
}

//----- (0004DCC0) --------------------------------------------------------
_WORD *__cdecl sub_4DCC0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 22;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 21;
    *(_WORD *)(v1 + 130) = 394;
    *(_WORD *)(v1 + 132) = *(_WORD *)(v1 + 130);
    *(_DWORD *)(v1 + 4) = 7680 / *(signed __int16 *)(v1 + 130);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 319);
    sub_49EA0(v2, 256, 512);
  }
  return v2;
}

//----- (0004DD50) --------------------------------------------------------
_WORD *__cdecl sub_4DD50(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 80;
    *(_BYTE *)(v1 + 69) = 16;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 15;
    *(_WORD *)(v1 + 130) = 128;
    *(_WORD *)(v1 + 132) = 128;
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 215);
  }
  return v2;
}

//----- (0004DDD0) --------------------------------------------------------
int __cdecl sub_4DDD0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 18;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 17;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 4096 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &unk_D83F0;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 209);
    sub_49EA0((_WORD *)v2, 2 * *(_WORD *)(v2 + 84), 2 * *(_WORD *)(v2 + 88));
  }
  return v2;
}

//----- (0004DEA0) --------------------------------------------------------
int __cdecl sub_4DEA0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 23;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 22;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 211);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004DF30) --------------------------------------------------------
int __cdecl sub_4DF30(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 28;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 27;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 215);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004DFC0) --------------------------------------------------------
int __cdecl sub_4DFC0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // esi
  int v4; // eax

  v1 = sub_4A050();
  v2 = v1;
  v3 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 24;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 23;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v4 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v4;
    BYTE1(v4) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v4) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 211);
  }
  return v3;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004E050) --------------------------------------------------------
int __cdecl sub_4E050(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax
  char v4; // dl

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 25;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 24;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    v4 = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 4) = v3;
    *(_BYTE *)(v2 + 12) = v4 & 0xF7;
    BYTE1(v3) = *(_BYTE *)(v2 + 4);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 4) = BYTE1(v3) & 0xFC;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 281);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004E0F0) --------------------------------------------------------
int __cdecl sub_4E0F0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 26;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 25;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 4096 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &unk_D83F0;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 321);
  }
  return v2;
}

//----- (0004E180) --------------------------------------------------------
int __cdecl sub_4E180(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 27;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 26;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 320);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004E210) --------------------------------------------------------
int __cdecl sub_4E210(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 31;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 30;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 211);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004E2A0) --------------------------------------------------------
int __cdecl sub_4E2A0(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 30;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 29;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    *(_DWORD *)(v1 + 4) = 10;
    v3 = *(_BYTE *)(v1 + 12);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = v3 & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 66);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004E320) --------------------------------------------------------
_WORD *__cdecl sub_4E320(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 8;
    *(_BYTE *)(v1 + 69) = 0;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 0;
    *(_WORD *)(v1 + 42) = 400;
    v3 = *(_DWORD *)(v1 + 12);
    *(_BYTE *)(v1 + 56) = 0;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 14) |= 2u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 7);
    sub_49EA0(v2, 128, 128);
    sub_847D0((int)v2, 128, 7, 1);
  }
  return v2;
}

//----- (0004E3B0) --------------------------------------------------------
_WORD *__cdecl sub_4E3B0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 1;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 1;
    *(_DWORD *)(v1 + 4) = 1;
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 42) = 400;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 14) |= 2u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 41);
    sub_847D0((int)v2, 128, 7, 1);
  }
  return v2;
}

//----- (0004E430) --------------------------------------------------------
int __cdecl sub_4E430(int a1)
{
  int v1; // eax
  int v2; // ebx
  unsigned int v3; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 8;
    *(_BYTE *)(v1 + 69) = 2;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 2;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    v3 = *(_DWORD *)(v1 + 12) & 0xFFFDFFF6;
    *(_DWORD *)(v1 + 16) = 0;
    *(_DWORD *)(v1 + 12) = v3 | 0x20001;
    sub_49A20(v1);
  }
  return v2;
}

//----- (0004E490) --------------------------------------------------------
int __cdecl sub_4E490(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  char v4; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 7;
    *(_BYTE *)(v1 + 69) = 3;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 3;
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 42) = 0;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    v4 = *(_BYTE *)(v1 + 14) | 2;
    *(_DWORD *)(v2 + 16) = 0;
    *(_BYTE *)(v2 + 14) = v4;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 36);
  }
  return v2;
}

//----- (0004E500) --------------------------------------------------------
int __cdecl sub_4E500(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 100;
    *(_BYTE *)(v1 + 69) = 4;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 4;
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 42) = 0;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 14) |= 2u;
    *(_DWORD *)(v1 + 16) = 0;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 80) = sub_10C40((__int16 *)(v1 + 76));
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004E570) --------------------------------------------------------
int __cdecl sub_4E570(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  char v4; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 8;
    *(_BYTE *)(v1 + 69) = 5;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 5;
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 42) = 0;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    v4 = *(_BYTE *)(v1 + 14) | 2;
    *(_DWORD *)(v2 + 16) = 0;
    *(_BYTE *)(v2 + 14) = v4;
    sub_57D70(v2, a1);
    *(_WORD *)(v2 + 80) = sub_10C40((__int16 *)(v2 + 76));
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 244);
  }
  return v2;
}

//----- (0004E5F0) --------------------------------------------------------
int __cdecl sub_4E5F0(__int16 *a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 6;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 6;
    *(_WORD *)(v1 + 42) = 50;
    *(_DWORD *)(v1 + 4) = 240;
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 44) = 0;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 14) |= 2u;
    sub_57D70(v1, (int)a1);
    *(_WORD *)(v2 + 80) = sub_10C40(a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 228);
    sub_49EA0((_WORD *)v2, 272, 1536);
    *(_DWORD *)(v2 + 16) = 0;
    sub_847D0(v2, 80, 11, 1);
  }
  return v2;
}

//----- (0004E6A0) --------------------------------------------------------
int __cdecl sub_4E6A0(__int16 *a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 7;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 7;
    v3 = *(_DWORD *)(v1 + 12);
    *(_DWORD *)(v1 + 4) = 12;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    LOWORD(v3) = *(_WORD *)(v1 + 20);
    *(_BYTE *)(v1 + 14) |= 2u;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    LOWORD(v3) = *(_WORD *)(v1 + 20) % 0x14u;
    *(_BYTE *)(v1 + 65) = 10;
    *(_BYTE *)(v1 + 66) = 7;
    *(_WORD *)(v1 + 130) = v3 + 20;
    sub_57D70(v1, (int)a1);
    *(_WORD *)(v2 + 80) = sub_10C40(a1);
    sub_49DA0((_WORD *)v2, 78);
    sub_49A20(v2);
    *(_BYTE *)(v2 + 12) |= 1u;
  }
  return v2;
}

//----- (0004E760) --------------------------------------------------------
int __cdecl sub_4E760(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 9;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 9;
    *(_DWORD *)(v1 + 4) = 11;
    *(_DWORD *)(v1 + 8) = 17;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 42) = 2000;
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_49EA0((_WORD *)v1, 7, 0x4000);
    *((_BYTE *)&loc_36E03 + dword_D41A0) = 0;
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004E7D0) --------------------------------------------------------
_WORD *__cdecl sub_4E7D0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 10;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 10;
    *(_DWORD *)(v1 + 4) = 1;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 42) = 100;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 14) |= 2u;
    sub_49A20(v1);
    sub_49EA0(v2, 128, 128);
  }
  return v2;
}

//----- (0004E840) --------------------------------------------------------
int __cdecl sub_4E840(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  char v4; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 11;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 11;
    *(_DWORD *)(v1 + 4) = 40;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 42) = 200;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    v4 = *(_BYTE *)(v1 + 14) | 2;
    *(_WORD *)(v2 + 38) = 11;
    *(_BYTE *)(v2 + 14) = v4;
    sub_49A20(v2);
    sub_49EA0((_WORD *)v2, 2304, 0x2000);
  }
  return v2;
}

//----- (0004E8C0) --------------------------------------------------------
int __cdecl sub_4E8C0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 12;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 12;
    *(_DWORD *)(v1 + 4) = 8;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 42) = -1536;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_57D70(v1, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 41);
    *(_BYTE *)(v2 + 12) |= 1u;
    sub_49EA0((_WORD *)v2, 512, 512);
  }
  return v2;
}

//----- (0004E950) --------------------------------------------------------
int __cdecl sub_4E950(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 77;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 70;
    *(_DWORD *)(v1 + 4) = 8;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 42) = -1536;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_57D70(v1, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 41);
    *(_BYTE *)(v2 + 12) |= 1u;
    sub_49EA0((_WORD *)v2, 512, 512);
  }
  return v2;
}

//----- (0004E9E0) --------------------------------------------------------
int __cdecl sub_4E9E0(int a1)
{
  int v1; // eax

  v1 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
  return sub_4EAA0(a1, 13, 13, 67, *(_DWORD *)(v1 + 8) % 0x17u + 17);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004EA20) --------------------------------------------------------
int __cdecl sub_4EA20(int a1)
{
  int v1; // eax

  v1 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
  return sub_4EAA0(a1, 14, 14, 9, *(_DWORD *)(v1 + 8) % 0x21u + 28);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004EA60) --------------------------------------------------------
int __cdecl sub_4EA60(int a1)
{
  int v1; // eax

  v1 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
  return sub_4EAA0(a1, 87, 94, 67, *(_DWORD *)(v1 + 8) % 0x17u + 17);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004EAA0) --------------------------------------------------------
int __cdecl sub_4EAA0(int a1, char a2, char a3, __int16 a4, int a5)
{
  int v5; // eax
  int v6; // ebx
  unsigned int v7; // edx
  unsigned __int64 v8; // rt2
  char v9; // ah

  v5 = sub_4A050();
  v6 = v5;
  if ( v5 )
  {
    v7 = *(_DWORD *)(v5 + 12) & 0xFFFDFFF7;
    *(_BYTE *)(v5 + 69) = a3;
    *(_DWORD *)(v5 + 12) = v7;
    *(_BYTE *)(v5 + 64) = a2;
    LOWORD(v7) = *(_WORD *)(v5 + 20);
    *(_DWORD *)(v5 + 4) = a5;
    *(_WORD *)(v5 + 20) = 9377 * v7 + 9439;
    v8 = *(unsigned __int16 *)(v5 + 20);
    *(_BYTE *)(v5 + 63) = 10;
    *(_WORD *)(v5 + 134) = 30;
    *(_BYTE *)(v5 + 65) = 10;
    *(_BYTE *)(v5 + 66) = a2;
    v9 = *(_BYTE *)(v5 + 14);
    *(_WORD *)(v6 + 130) = v8 % 0x35 + 51;
    *(_BYTE *)(v6 + 14) = v9 | 2;
    sub_57D70(v6, a1);
    sub_49DA0((_WORD *)v6, a4);
    sub_49A20(v6);
  }
  return v6;
}

//----- (0004EB50) --------------------------------------------------------
int __cdecl sub_4EB50(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // cx
  char v5; // ah

  if ( sub_4A810() < 32 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = 64;
  *(_BYTE *)(v1 + 63) = 10;
  v3 = *(_WORD *)(v1 + 20);
  *(_BYTE *)(v1 + 64) = 59;
  *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
  v4 = *(_WORD *)(v1 + 20);
  v5 = *(_BYTE *)(v1 + 12) & 0xF6;
  *(_DWORD *)(v2 + 4) = *(unsigned __int16 *)(v2 + 20) % 0x64u + 800;
  *(_BYTE *)(v2 + 12) = v5 | 1;
  *(_WORD *)(v2 + 20) = 9377 * v4 + 9439;
  *(_WORD *)(v2 + 130) = *(_WORD *)(v2 + 20) % 0x11u;
  *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
  *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
  sub_49A20(v2);
  return v2;
}

//----- (0004EC10) --------------------------------------------------------
int __cdecl sub_4EC10(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // cx
  char v5; // ah

  if ( sub_4A810() < 32 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = 65;
  *(_BYTE *)(v1 + 63) = 10;
  v3 = *(_WORD *)(v1 + 20);
  *(_BYTE *)(v1 + 64) = 60;
  *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
  v4 = *(_WORD *)(v1 + 20);
  v5 = *(_BYTE *)(v1 + 12) & 0xF6;
  *(_DWORD *)(v2 + 4) = *(unsigned __int16 *)(v2 + 20) % 0x64u + 800;
  *(_BYTE *)(v2 + 12) = v5 | 1;
  *(_WORD *)(v2 + 20) = 9377 * v4 + 9439;
  *(_WORD *)(v2 + 130) = *(_WORD *)(v2 + 20) % 0x11u;
  *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
  *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
  sub_49A20(v2);
  return v2;
}

//----- (0004ECD0) --------------------------------------------------------
int __cdecl sub_4ECD0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 15;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 15;
    *(_DWORD *)(v1 + 4) = 128;
    *(_WORD *)(v1 + 130) = 256;
    v3 = *(_WORD *)(v1 + 20);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    *(_WORD *)(v1 + 42) = 100;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_DWORD *)(v2 + 16) = 0;
    *(_WORD *)(v2 + 28) = v4 & 0x7FF;
    *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
    sub_49A20(v2);
    sub_49EA0((_WORD *)v2, 1024, 0x4000);
  }
  return v2;
}

//----- (0004ED70) --------------------------------------------------------
int __cdecl sub_4ED70(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 17;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 17;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_DWORD *)(v1 + 4) = 10;
    *(_WORD *)(v1 + 42) = 3000;
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_49A20(v1);
  }
  return v2;
}

//----- (0004EDC0) --------------------------------------------------------
int __cdecl sub_4EDC0(__int16 *a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  __int16 v4; // ax
  __int16 v5; // ax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 16;
    *(_BYTE *)(v1 + 63) = 10;
    v3 = *(_DWORD *)(v1 + 12);
    *(_BYTE *)(v1 + 64) = 16;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    LOWORD(v3) = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 42) = 200;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = 9377 * *(_WORD *)(v1 + 20);
    *(_DWORD *)(v2 + 4) = *(unsigned __int16 *)(v2 + 20) % 0x64u + 100;
    *(_WORD *)(v2 + 20) = v4 + 9439;
    LOWORD(v3) = *(_WORD *)(v2 + 20) % 0x32u;
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v5 = *(_WORD *)(v2 + 20);
    *(_WORD *)(v2 + 44) = 256;
    *(_WORD *)(v2 + 28) = v5 & 0x7FF;
    HIBYTE(v5) = *(_BYTE *)(v2 + 14);
    *(_WORD *)(v2 + 130) = v3 + 52;
    *(_BYTE *)(v2 + 14) = HIBYTE(v5) | 2;
    sub_57D70(v2, (int)a1);
    *(_WORD *)(v2 + 80) = sub_10C40(a1) + 64;
    sub_57FA0((_WORD *)(v2 + 154), *(_WORD *)(v2 + 28), 0, *(_WORD *)(v2 + 130));
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 210);
  }
  return v2;
}

//----- (0004EED0) --------------------------------------------------------
int __cdecl sub_4EED0(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 18;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 18;
    *(_WORD *)(v1 + 42) = 200;
    v3 = *(_BYTE *)(v1 + 12);
    *(_DWORD *)(v2 + 16) = 0;
    *(_DWORD *)(v2 + 4) = 10000;
    *(_BYTE *)(v2 + 12) = v3 & 0xF7;
    *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004EF30) --------------------------------------------------------
int __cdecl sub_4EF30(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 98;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 91;
    *(_WORD *)(v1 + 42) = 200;
    v3 = *(_BYTE *)(v1 + 12);
    *(_DWORD *)(v2 + 16) = 0;
    v3 &= 0xF6u;
    *(_DWORD *)(v2 + 4) = 10000;
    *(_BYTE *)(v2 + 12) = v3;
    *(_BYTE *)(v2 + 12) = v3 | 1;
    *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004EF90) --------------------------------------------------------
int __cdecl sub_4EF90(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 19;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 19;
    *(_WORD *)(v1 + 42) = 200;
    v3 = *(_DWORD *)(v1 + 12);
    *(_DWORD *)(v1 + 4) = 240;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 14) |= 2u;
    sub_57D70(v1, a1);
    *(_BYTE *)(v2 + 12) |= 1u;
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 228);
    sub_49EA0((_WORD *)v2, 512, 512);
  }
  return v2;
}

//----- (0004F040) --------------------------------------------------------
_WORD *__cdecl sub_4F040(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax
  __int16 v5; // ax
  int v6; // eax
  int v7; // ecx
  int v9; // [esp+0h] [ebp-10h]
  int v10; // [esp+4h] [ebp-Ch]
  _WORD *v11; // [esp+8h] [ebp-8h]
  signed int i; // [esp+Ch] [ebp-4h]

  if ( sub_4A810() < 12 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  v11 = (_WORD *)v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = 22;
  *(_BYTE *)(v1 + 63) = 10;
  *(_BYTE *)(v1 + 64) = 22;
  *(_WORD *)(v1 + 44) = 0;
  *(_WORD *)(v1 + 46) = 1;
  *(_BYTE *)(v1 + 60) = 0;
  *(_WORD *)(v1 + 132) = 20;
  *(_WORD *)(v1 + 134) = 10;
  *(_WORD *)(v1 + 130) = 50;
  *(_DWORD *)(v1 + 4) = 500;
  *(_WORD *)(v1 + 42) = 1000;
  v3 = *(_WORD *)(v1 + 20);
  *(_BYTE *)(v1 + 12) &= 0xF7u;
  *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
  v4 = *(_WORD *)(v1 + 20);
  *(_WORD *)(v2 + 34) = 0;
  *(_BYTE *)(v2 + 56) = 1;
  v5 = (v4 & 0x7FF) - 1;
  *(_WORD *)(v2 + 32) = v5;
  *(_WORD *)(v2 + 28) = v5;
  v10 = v2;
  *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
  sub_49A20(v2);
  for ( i = 0; i < 11; ++i )
  {
    v6 = sub_4A050();
    v9 = v6;
    if ( v6 )
    {
      qmemcpy((void *)v6, v11, 0xA8u);
      *(_BYTE *)(v6 + 64) = 75;
      v7 = dword_D41A0;
      *(_BYTE *)(v6 + 69) = 82;
      v7 += 28302;
      *(_WORD *)(v6 + 44) = i + 1;
      *(_WORD *)(v6 + 50) = (v10 - v7) / 168;
      *(_WORD *)(v10 + 52) = (v6 - v7) / 168;
      *(_WORD *)(v6 + 52) = 0;
      *(_BYTE *)(v6 + 62) = i;
      sub_57D70(v6, a1);
    }
    v10 = v9;
  }
  sub_57D70((int)v11, a1);
  sub_4F1C0(v11);
  return v11;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004F1C0) --------------------------------------------------------
unsigned __int16 __cdecl sub_4F1C0(_WORD *a1)
{
  _WORD *v1; // ebx
  int v2; // esi
  unsigned __int16 result; // ax
  int v4; // ecx
  unsigned __int16 v5; // di
  int v6; // ST0C_4
  int v7; // edi
  unsigned __int16 i; // [esp+4h] [ebp-8h]

  v1 = a1;
  v2 = 0;
  result = sub_10C40(a1 + 38);
  for ( i = result; (unsigned int)v1 > dword_EA3E4[0]; v1 = (_WORD *)dword_EA3E4[result] )
  {
    v4 = (signed __int16)v1[22] + 293;
    v5 = word_D9524[7 * v4];
    v6 = 550 * v5 / 1000;
    v7 = 450 * v5 / 1000;
    sub_49CD0(v1, v4);
    sub_49EA0(v1, v6, v7);
    v1[40] = v2 + i;
    result = v1[26];
    v1[27] = v2;
    v2 += 2 * v7;
  }
  return result;
}
// D9524: using guessed type __int16 word_D9524[];
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0004F2A0) --------------------------------------------------------
_WORD *__cdecl sub_4F2A0(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah
  int v4; // eax
  int v5; // ecx
  int v7; // [esp+0h] [ebp-10h]
  int v8; // [esp+4h] [ebp-Ch]
  signed int i; // [esp+8h] [ebp-8h]
  _WORD *v10; // [esp+Ch] [ebp-4h]

  v10 = 0;
  if ( sub_4A810() >= 26 )
  {
    v1 = sub_4A050();
    v2 = v1;
    v10 = (_WORD *)v1;
    if ( v1 )
    {
      *(_BYTE *)(v1 + 69) = 83;
      *(_BYTE *)(v1 + 63) = 10;
      *(_BYTE *)(v1 + 64) = 76;
      *(_DWORD *)(v1 + 4) = 80;
      *(_WORD *)(v1 + 42) = 70;
      *(_WORD *)(v1 + 130) = 40;
      *(_WORD *)(v1 + 134) = 192;
      *(_WORD *)(v1 + 132) = 480;
      *(_WORD *)(v1 + 130) = 40;
      v3 = *(_BYTE *)(v1 + 12);
      *(_BYTE *)(v2 + 56) = 1;
      *(_BYTE *)(v2 + 67) = 0;
      *(_BYTE *)(v2 + 68) = 0;
      *(_WORD *)(v2 + 44) = 0;
      *(_BYTE *)(v2 + 61) = 0;
      v8 = v2;
      *(_BYTE *)(v2 + 12) = v3 & 0xF6 | 1;
      sub_49A20(v2);
      for ( i = 0; i < 25; ++i )
      {
        v4 = sub_4A050();
        v7 = v4;
        if ( v4 )
        {
          qmemcpy((void *)v4, v10, 0xA8u);
          v5 = dword_D41A0 + 28302;
          *(_BYTE *)(v4 + 64) = 77;
          *(_BYTE *)(v4 + 69) = 84;
          *(_WORD *)(v4 + 50) = (v8 - v5) / 168;
          *(_WORD *)(v8 + 52) = (v4 - v5) / 168;
          *(_BYTE *)(v4 + 62) = i;
          *(_BYTE *)(v4 + 67) = i / 5;
          *(_WORD *)(v4 + 52) = 0;
          *(_BYTE *)(v4 + 68) = i % 5;
          sub_57D70(v4, a1);
        }
        v8 = v7;
      }
      sub_57D70((int)v10, a1);
      sub_49EA0(v10, 640, 640);
      sub_4F440((int)v10);
    }
  }
  return v10;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004F440) --------------------------------------------------------
__int16 __cdecl sub_4F440(int a1)
{
  unsigned __int16 v1; // ax
  int v2; // eax
  char v3; // ah
  char v4; // dl
  char v5; // cl
  __int16 v6; // ax
  int v7; // edx
  int v8; // edx
  __int16 v9; // dx
  signed __int16 v10; // cx
  __int16 v11; // dx
  __int16 v12; // dx
  unsigned int v13; // ebx

  v1 = *(_WORD *)(a1 + 134);
  *(_BYTE *)(a1 + 61) = 18;
  *(_WORD *)(a1 + 44) = v1;
  *(_WORD *)(a1 + 28) = 0;
  v2 = v1;
  LOWORD(v2) = *(_WORD *)(a1 + 52);
  *(_WORD *)(a1 + 30) = 0;
  while ( 1 )
  {
    v13 = dword_EA3E4[v2];
    if ( v13 <= dword_EA3E4[0] )
      return v2;
    v3 = *(_BYTE *)(v13 + 12) & 0xFE;
    v4 = *(_BYTE *)(v13 + 68);
    *(_BYTE *)(v13 + 12) = v3;
    if ( v4 )
    {
      v5 = *(_BYTE *)(v13 + 12) & 0xF7;
      *(_BYTE *)(v13 + 14) |= 0x80u;
      *(_BYTE *)(v13 + 12) = v5;
    }
    else
    {
      *(_BYTE *)(v13 + 12) = v3 | 8;
    }
    *(_WORD *)(v13 + 20) = 9377 * *(_WORD *)(v13 + 20) + 9439;
    v6 = (*(_WORD *)(v13 + 20) & 0x3F) + 84;
    v7 = *(unsigned __int8 *)(v13 + 67);
    switch ( (_BYTE)v7 )
    {
      case 0:
        LOWORD(v7) = *(char *)(v13 + 68);
        *(_WORD *)(v13 + 30) = 0;
        *(_WORD *)(v13 + 34) = 0;
        v8 = 512 - 96 * v7;
        *(_WORD *)(v13 + 32) = v6;
        BYTE1(v8) &= 7u;
        *(_WORD *)(v13 + 28) = v8;
        break;
      case 1:
        v9 = 96 * *(char *)(v13 + 68);
        v10 = 512;
        *(_WORD *)(v13 + 28) = 512;
        goto LABEL_11;
      case 2:
        v11 = *(char *)(v13 + 68);
        *(_WORD *)(v13 + 28) = 0;
        *(_WORD *)(v13 + 32) = 0;
        v12 = -96 * v11;
        goto LABEL_12;
      case 3:
        v9 = 96 * *(char *)(v13 + 68);
        v10 = 256;
        *(_WORD *)(v13 + 28) = 256;
        goto LABEL_11;
      case 4:
        v9 = 96 * *(char *)(v13 + 68);
        v10 = 768;
        *(_WORD *)(v13 + 28) = 768;
LABEL_11:
        *(_WORD *)(v13 + 32) = 0;
        v12 = v10 - v9;
LABEL_12:
        *(_WORD *)(v13 + 34) = v6;
        HIBYTE(v12) &= 7u;
        *(_WORD *)(v13 + 30) = v12;
        break;
      default:
        break;
    }
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    sub_57FA0(&word_EB398, *(_WORD *)(v13 + 28), *(_WORD *)(v13 + 30), *(_WORD *)(a1 + 44));
    sub_57CF0(v13, (int)&word_EB398);
    sub_49CD0((_WORD *)v13, 340);
    sub_847D0(v13, 128, 1, 0);
    v2 = *(unsigned __int16 *)(v13 + 52);
  }
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (0004F5F0) --------------------------------------------------------
int __cdecl sub_4F5F0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 8;
    *(_BYTE *)(v1 + 69) = 23;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 23;
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 42) = 25;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 14) |= 2u;
    sub_57D70(v1, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 7);
    sub_49EA0((_WORD *)v2, 200, 200);
    *(_BYTE *)(v2 + 12) |= 1u;
    sub_847D0(v2, 128, 9, 0);
  }
  return v2;
}

//----- (0004F6A0) --------------------------------------------------------
_WORD *__cdecl sub_4F6A0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 25;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 25;
    *(_DWORD *)(v1 + 4) = 8;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 42) = 2000;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49EA0(v2, 512, 512);
  }
  return v2;
}

//----- (0004F720) --------------------------------------------------------
_WORD *__cdecl sub_4F720(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 26;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 26;
    *(_DWORD *)(v1 + 4) = 8;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 42) = 200;
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 213);
    sub_49EA0(v2, 512, 512);
  }
  return v2;
}

//----- (0004F7A0) --------------------------------------------------------
int __cdecl sub_4F7A0(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 2;
    *(_BYTE *)(v1 + 69) = 27;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 27;
    *(_WORD *)(v1 + 42) = (*(_WORD *)(a1 + 4) >> 5) + 48;
    v3 = *(_BYTE *)(v1 + 12);
    *(_DWORD *)(v2 + 16) = 10;
    *(_BYTE *)(v2 + 12) = v3 & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004F800) --------------------------------------------------------
int __cdecl sub_4F800(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 69) = 30;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 28;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004F860) --------------------------------------------------------
int __cdecl sub_4F860(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 52;
    *(_BYTE *)(v1 + 69) = 66;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 61;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004F8B0) --------------------------------------------------------
int __cdecl sub_4F8B0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 52;
    *(_BYTE *)(v1 + 69) = 67;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 62;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004F900) --------------------------------------------------------
int __cdecl sub_4F900(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 1;
    *(_BYTE *)(v1 + 69) = 68;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 63;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004F950) --------------------------------------------------------
int __cdecl sub_4F950(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 1;
    *(_BYTE *)(v1 + 69) = 69;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 64;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004F9A0) --------------------------------------------------------
int __cdecl sub_4F9A0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 69) = 32;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 30;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004FA00) --------------------------------------------------------
int __cdecl sub_4FA00(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 69) = 31;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 29;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004FA60) --------------------------------------------------------
int __cdecl sub_4FA60(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 69) = 34;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 32;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    v3 = *(_BYTE *)(v1 + 12);
    *(_WORD *)(v2 + 130) = 256;
    *(_BYTE *)(v2 + 70) = 2;
    *(_BYTE *)(v2 + 12) = v3 & 0xF7;
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004FAC0) --------------------------------------------------------
int __cdecl sub_4FAC0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 69) = 33;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 31;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004FB20) --------------------------------------------------------
int __cdecl sub_4FB20(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // dl

  if ( !byte_D41B6 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_DWORD *)(v1 + 4) = 0;
  *(_BYTE *)(v1 + 69) = 88;
  *(_BYTE *)(v1 + 63) = 10;
  *(_BYTE *)(v1 + 64) = 81;
  *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
  *(_WORD *)(v1 + 130) = 256;
  v3 = *(_BYTE *)(v1 + 12);
  *(_BYTE *)(v1 + 70) = 2;
  *(_BYTE *)(v1 + 12) = v3 & 0xF7;
  sub_49A20(v1);
  return v2;
}
// D41B6: using guessed type char byte_D41B6;

//----- (0004FB80) --------------------------------------------------------
int __cdecl sub_4FB80(int a1)
{
  int v1; // eax
  int v2; // ebx

  if ( !byte_D41B6 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_DWORD *)(v1 + 4) = 0;
  *(_BYTE *)(v1 + 69) = 87;
  *(_BYTE *)(v1 + 63) = 10;
  *(_BYTE *)(v1 + 64) = 80;
  *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
  *(_BYTE *)(v1 + 12) &= 0xF7u;
  sub_57D70(v1, a1);
  sub_49A20(v2);
  return v2;
}
// D41B6: using guessed type char byte_D41B6;

//----- (0004FBE0) --------------------------------------------------------
int __cdecl sub_4FBE0(int a1)
{
  int result; // eax

  if ( !byte_D41B6 )
    return 0;
  result = sub_4A050();
  if ( !result )
    return 0;
  *(_DWORD *)(result + 4) = 0;
  *(_BYTE *)(result + 69) = 89;
  *(_BYTE *)(result + 63) = 10;
  *(_BYTE *)(result + 64) = 82;
  *(_DWORD *)(result + 76) = *(_DWORD *)a1;
  *(_WORD *)(result + 80) = *(_WORD *)(a1 + 4);
  *(_BYTE *)(result + 70) = 2;
  *(_BYTE *)(result + 67) = 3;
  *(_BYTE *)(result + 68) = 3;
  return result;
}
// D41B6: using guessed type char byte_D41B6;

//----- (0004FC30) --------------------------------------------------------
int __cdecl sub_4FC30(int a1)
{
  int result; // eax
  char v2; // dl

  if ( !byte_D41B6 )
    return 0;
  result = sub_4A050();
  if ( !result )
    return 0;
  *(_DWORD *)(result + 8) = 16;
  *(_BYTE *)(result + 69) = 90;
  *(_BYTE *)(result + 63) = 10;
  *(_BYTE *)(result + 64) = 83;
  *(_DWORD *)(result + 76) = *(_DWORD *)a1;
  *(_WORD *)(result + 80) = *(_WORD *)(a1 + 4);
  *(_BYTE *)(result + 70) = 0;
  *(_WORD *)(result + 154) = 2;
  v2 = *(_BYTE *)(result + 12);
  *(_WORD *)(result + 158) = 0;
  v2 |= 1u;
  *(_BYTE *)(result + 12) = v2;
  *(_WORD *)(result + 80) = 0;
  *(_BYTE *)(result + 12) = v2 & 0xF7;
  return result;
}
// D41B6: using guessed type char byte_D41B6;

//----- (0004FCA0) --------------------------------------------------------
int __cdecl sub_4FCA0(int a1)
{
  int result; // eax

  result = sub_4FD00(a1);
  if ( result )
  {
    *(_BYTE *)(result + 69) = 91;
    *(_BYTE *)(result + 64) = 84;
  }
  return result;
}

//----- (0004FCD0) --------------------------------------------------------
int __cdecl sub_4FCD0(int a1)
{
  int result; // eax

  result = sub_4FD00(a1);
  if ( result )
  {
    *(_BYTE *)(result + 69) = 92;
    *(_BYTE *)(result + 64) = 85;
  }
  return result;
}

//----- (0004FD00) --------------------------------------------------------
int __cdecl sub_4FD00(int a1)
{
  int v1; // edx
  int v2; // eax
  char v3; // bl

  v1 = 0;
  if ( byte_D41B6 )
  {
    v2 = sub_4A050();
    v1 = v2;
    if ( v2 )
    {
      *(_DWORD *)(v2 + 8) = 16;
      *(_BYTE *)(v2 + 63) = 10;
      *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
      *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
      *(_BYTE *)(v2 + 70) = 0;
      *(_WORD *)(v2 + 154) = 2;
      v3 = *(_BYTE *)(v2 + 12);
      *(_WORD *)(v2 + 158) = 0;
      v3 |= 1u;
      *(_BYTE *)(v2 + 12) = v3;
      *(_WORD *)(v2 + 80) = 0;
      *(_BYTE *)(v2 + 12) = v3 & 0xF7;
    }
  }
  return v1;
}
// D41B6: using guessed type char byte_D41B6;

//----- (0004FD70) --------------------------------------------------------
int __cdecl sub_4FD70(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 69) = 55;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 51;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    v3 = *(_BYTE *)(v1 + 12);
    *(_DWORD *)(v2 + 16) = 256;
    *(_WORD *)(v2 + 130) = 1024;
    *(_BYTE *)(v2 + 12) = v3 & 0xF7;
    sub_49EA0((_WORD *)v2, 768, 768);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004FDE0) --------------------------------------------------------
int __cdecl sub_4FDE0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 69) = 54;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 50;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004FE40) --------------------------------------------------------
_WORD *__cdecl sub_4FE40(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 36;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 34;
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 65) = 3;
    *(_BYTE *)(v1 + 66) = -1;
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    sub_49CD0((_WORD *)v1, 223);
    sub_49EA0(v2, 256, 256);
    sub_49A20((int)v2);
    sub_57D70((int)v2, a1);
    v2[40] = sub_10C40(v2 + 38) + 640;
    *(_DWORD *)(v2 + 77) = *((_DWORD *)v2 + 19);
    v2[79] = v2[40];
    v2[10] = 9377 * v2[10] + 9439;
    sub_57FA0(v2 + 77, v2[10] & 0x7FF, 0, -32768);
  }
  return v2;
}

//----- (0004FF20) --------------------------------------------------------
int sub_4FF20()
{
  return sub_4A050();
}

//----- (0004FF30) --------------------------------------------------------
_WORD *__cdecl sub_4FF30(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 38;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 36;
    *(_DWORD *)(v1 + 4) = 8;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 42) = -1536;
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 41);
    sub_49EA0(v2, 512, 512);
  }
  return v2;
}

//----- (0004FFB0) --------------------------------------------------------
int __cdecl sub_4FFB0(int a1)
{
  _BYTE *v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = (_BYTE *)sub_4A050();
  v2 = (int)v1;
  if ( v1 )
  {
    v1[69] = 40;
    v1[63] = 10;
    v1[64] = 38;
    v3 = v1[12] & 0xF7;
    *(_DWORD *)(v2 + 4) = 32;
    *(_BYTE *)(v2 + 12) = v3;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 272);
    sub_49EA0((_WORD *)v2, 512, 512);
  }
  return v2;
}

//----- (00050020) --------------------------------------------------------
_WORD *__cdecl sub_50020(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 35;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 33;
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    sub_49A20(v1);
    sub_49EA0(v2, 512, 512);
  }
  return v2;
}

//----- (00050080) --------------------------------------------------------
int __cdecl sub_50080(int a1)
{
  return sub_500C0(a1, 512);
}

//----- (000500A0) --------------------------------------------------------
int __cdecl sub_500A0(int a1)
{
  return sub_500C0(a1, 2560);
}

//----- (000500C0) --------------------------------------------------------
int __cdecl sub_500C0(int a1, __int16 a2)
{
  int result; // eax
  int v3; // ebx

  result = sub_4A050();
  v3 = result;
  if ( result )
  {
    *(_BYTE *)(result + 69) = 41;
    *(_BYTE *)(result + 63) = 10;
    *(_BYTE *)(result + 64) = 39;
    *(_BYTE *)(result + 65) = 10;
    *(_BYTE *)(result + 66) = 39;
    *(_WORD *)(result + 44) = 128;
    *(_WORD *)(result + 130) = 32;
    *(_BYTE *)(result + 56) = 3;
    *(_BYTE *)(result + 57) = -128;
    *(_BYTE *)(result + 58) = 0;
    *(_DWORD *)(result + 144) = a2;
    sub_57D70(result, a1);
    sub_49A20(v3);
    sub_36920(v3, v3);
    result = v3;
  }
  return result;
}

//----- (00050130) --------------------------------------------------------
int __cdecl sub_50130(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  unsigned __int64 v4; // rtt
  char v5; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 62;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 57;
    *(_BYTE *)(v1 + 65) = 10;
    *(_BYTE *)(v1 + 66) = 57;
    v3 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 44) = 128;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(unsigned __int16 *)(v1 + 20);
    *(_WORD *)(v1 + 130) = 0;
    *(_BYTE *)(v1 + 56) = 3;
    *(_BYTE *)(v1 + 57) = -128;
    *(_BYTE *)(v1 + 58) = 0;
    *(_BYTE *)(v1 + 67) = 10;
    *(_DWORD *)(v1 + 144) = v4 % 0x7D0;
    v5 = *(_BYTE *)(v1 + 14);
    *(_BYTE *)(v2 + 68) = 1;
    *(_BYTE *)(v2 + 14) = v5 | 2;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_36920(v2, v2);
  }
  return v2;
}

//----- (000501D0) --------------------------------------------------------
_WORD *__cdecl sub_501D0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    v3 = dword_D41A0;
    *(_BYTE *)(v1 + 69) = 42;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 40;
    *(_DWORD *)(v1 + 16) = (v1 - (v3 + 28302)) / 168 % 11;
    *(_BYTE *)(v1 + 56) = 2;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49DA0(v2, 65);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00050250) --------------------------------------------------------
_WORD *__cdecl sub_50250(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 30;
    *(_BYTE *)(v1 + 69) = 51;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 45;
    *(_WORD *)(v1 + 42) = 100;
    *(_DWORD *)(v1 + 16) = 4;
    *(_DWORD *)(v1 + 12) = 9;
    *(_BYTE *)(v1 + 56) = 33;
    sub_57D70(v1, a1);
    sub_49CD0(v2, 177);
  }
  return v2;
}

//----- (000502B0) --------------------------------------------------------
_WORD *__cdecl sub_502B0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 45;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 43;
    *(_DWORD *)(v1 + 4) = 8;
    *(_WORD *)(v1 + 42) = -1536;
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 41);
    sub_49EA0(v2, 512, 512);
  }
  return v2;
}

//----- (00050320) --------------------------------------------------------
int __cdecl sub_50320(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 43;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 41;
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    sub_49A20(v1);
  }
  return v2;
}

//----- (00050370) --------------------------------------------------------
int __cdecl sub_50370(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 44;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 42;
    *(_DWORD *)(v1 + 4) = 0;
    v3 = *(_BYTE *)(v1 + 12) & 0xF6;
    *(_BYTE *)(v2 + 12) = v3;
    *(_BYTE *)(v2 + 12) = v3 | 1;
    *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v2 + 59) = 1;
    sub_49A20(v2);
  }
  return v2;
}

//----- (000503D0) --------------------------------------------------------
_WORD *__cdecl sub_503D0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 46;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 44;
    *(_DWORD *)(v1 + 4) = 500;
    *(_WORD *)(v1 + 42) = 500;
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 8);
  }
  return v2;
}

//----- (00050430) --------------------------------------------------------
_WORD *__cdecl sub_50430(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 56;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 52;
    *(_DWORD *)(v1 + 4) = 100000;
    *(_WORD *)(v1 + 42) = 500;
    *(_DWORD *)(v1 + 16) = 600;
    *(_DWORD *)(v1 + 144) = 500;
    *(_DWORD *)(v1 + 140) = 2000;
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 205);
  }
  return v2;
}

//----- (000504B0) --------------------------------------------------------
int __cdecl sub_504B0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 58;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 53;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_DWORD *)(v1 + 4) = 6;
    *(_WORD *)(v1 + 42) = 3000;
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    sub_49A20(v1);
  }
  return v2;
}

//----- (00050500) --------------------------------------------------------
int __cdecl sub_50500(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 59;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 54;
    *(_DWORD *)(v1 + 4) = 128;
    *(_WORD *)(v1 + 130) = 256;
    v3 = *(_WORD *)(v1 + 20);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    *(_WORD *)(v1 + 42) = 100;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_DWORD *)(v2 + 16) = 12845056;
    *(_WORD *)(v2 + 28) = v4 & 0x7FF;
    *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v2 + 12) |= 1u;
    sub_49A20(v2);
    sub_49EA0((_WORD *)v2, 1024, 0x4000);
  }
  return v2;
}

//----- (000505A0) --------------------------------------------------------
int __cdecl sub_505A0(int a1)
{
  int result; // eax

  result = sub_505E0(a1);
  if ( result )
  {
    *(_BYTE *)(result + 64) = 68;
    *(_BYTE *)(result + 69) = 75;
  }
  return result;
}

//----- (000505E0) --------------------------------------------------------
int __cdecl sub_505E0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 63) = 10;
    *(_WORD *)(v1 + 130) = 64;
    *(_DWORD *)(v1 + 16) = 12845056;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_49EA0((_WORD *)v1, 256, 256);
  }
  return v2;
}

//----- (00050640) --------------------------------------------------------
int __cdecl sub_50640(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 60;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 55;
    *(_DWORD *)(v1 + 4) = 19;
    *(_WORD *)(v1 + 130) = 256;
    v3 = *(_WORD *)(v1 + 20);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    *(_WORD *)(v1 + 42) = 100;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_DWORD *)(v2 + 16) = 32;
    *(_WORD *)(v2 + 28) = v4 & 0x7FF;
    *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v2 + 12) |= 1u;
    sub_49A20(v2);
    sub_49EA0((_WORD *)v2, 1024, 0x4000);
  }
  return v2;
}

//----- (000506E0) --------------------------------------------------------
int __cdecl sub_506E0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 61;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 56;
    *(_DWORD *)(v1 + 4) = 128;
    *(_WORD *)(v1 + 130) = 256;
    v3 = *(_WORD *)(v1 + 20);
    *(_BYTE *)(v1 + 12) &= 0xF7u;
    *(_WORD *)(v1 + 42) = 100;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_DWORD *)(v2 + 16) = 0;
    *(_WORD *)(v2 + 28) = v4 & 0x7FF;
    *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v2 + 12) |= 1u;
    sub_49A20(v2);
    sub_49EA0((_WORD *)v2, 1024, 0x4000);
  }
  return v2;
}

//----- (00050780) --------------------------------------------------------
int __cdecl sub_50780(int a1)
{
  int result; // eax
  char v2; // dl

  result = sub_4A050();
  if ( result )
  {
    *(_BYTE *)(result + 69) = 70;
    v2 = *(_BYTE *)(result + 12);
    *(_BYTE *)(result + 63) = 10;
    v2 &= 0xF6u;
    *(_BYTE *)(result + 12) = v2;
    *(_BYTE *)(result + 64) = 65;
    *(_BYTE *)(result + 12) = v2 | 1;
    *(_DWORD *)(result + 76) = *(_DWORD *)a1;
    *(_WORD *)(result + 80) = *(_WORD *)(a1 + 4);
  }
  return result;
}

//----- (000507C0) --------------------------------------------------------
int __cdecl sub_507C0(int a1)
{
  int result; // eax
  char v2; // dl

  result = sub_4A050();
  if ( result )
  {
    *(_BYTE *)(result + 69) = 71;
    v2 = *(_BYTE *)(result + 12);
    *(_BYTE *)(result + 63) = 10;
    v2 &= 0xF6u;
    *(_BYTE *)(result + 12) = v2;
    *(_BYTE *)(result + 64) = 66;
    *(_BYTE *)(result + 12) = v2 | 1;
    *(_DWORD *)(result + 76) = *(_DWORD *)a1;
    *(_WORD *)(result + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(result + 42) = 200;
  }
  return result;
}

//----- (00050800) --------------------------------------------------------
_BYTE *sub_50800()
{
  _BYTE *result; // eax
  char v1; // bl

  result = (_BYTE *)sub_4A050();
  if ( result )
  {
    result[69] = 81;
    v1 = result[12];
    result[63] = 10;
    v1 &= 0xF6u;
    result[12] = v1;
    result[64] = 74;
    result[12] = v1 | 1;
  }
  return result;
}

//----- (00050840) --------------------------------------------------------
_WORD *__cdecl sub_50840(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 1000;
    *(_BYTE *)(v1 + 69) = 85;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 78;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    v3 = dword_D41A0 + 28302;
    *(_BYTE *)(v1 + 12) |= 8u;
    *(_WORD *)(v1 + 42) = 0;
    *(_BYTE *)(v1 + 70) = 0;
    *(_WORD *)(v1 + 54) = -1;
    *(_BYTE *)(v1 + 61) = 1;
    *(_BYTE *)(v1 + 67) = 1;
    *(_BYTE *)(v1 + 68) = 0;
    *(_WORD *)(v1 + 50) = (v1 - v3) / 168;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 66);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (000508E0) --------------------------------------------------------
int __cdecl sub_508E0(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 100000;
    *(_BYTE *)(v1 + 69) = 86;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 79;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    v3 = *(_BYTE *)(v1 + 12);
    *(_BYTE *)(v2 + 70) = 0;
    *(_BYTE *)(v2 + 67) = 0;
    *(_WORD *)(v2 + 44) = 0;
    *(_BYTE *)(v2 + 61) = 1;
    *(_WORD *)(v2 + 54) = 0;
    *(_BYTE *)(v2 + 12) = v3 & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 66);
  }
  return v2;
}

//----- (00050960) --------------------------------------------------------
int __cdecl sub_50960(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // edx
  __int16 v5; // ax
  __int16 v6; // dx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 9;
    v3 = *(_DWORD *)(v1 + 4);
    *(_BYTE *)(v2 + 69) = 93;
    v4 = *(_DWORD *)(v2 + 12);
    *(_BYTE *)(v2 + 63) = 10;
    *(_DWORD *)(v2 + 8) = v3;
    *(_DWORD *)(v2 + 12) = v4 & 0xFFFDFFF7;
    BYTE1(v3) = *(_BYTE *)(v2 + 14);
    *(_BYTE *)(v2 + 64) = 86;
    *(_BYTE *)(v2 + 14) = BYTE1(v3) | 2;
    sub_57D70(v2, a1);
    v5 = sub_10C40((__int16 *)(v2 + 76));
    v6 = *(_WORD *)(v2 + 20);
    *(_WORD *)(v2 + 80) = v5;
    *(_WORD *)(v2 + 20) = 9377 * v6 + 9439;
    sub_49CD0((_WORD *)v2, *(_WORD *)(v2 + 20) % 3u + 332);
    if ( !(sub_104A0(v2 + 76) & 1) )
    {
      sub_57F20(v2);
      v2 = 0;
    }
  }
  return v2;
}

//----- (00050A20) --------------------------------------------------------
int __cdecl sub_50A20(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // dl

  if ( *(_BYTE *)(dword_D41A0 + 196308) != 2 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  v3 = *(_BYTE *)(v1 + 12) & 0xF6;
  *(_BYTE *)(v1 + 12) = v3;
  *(_BYTE *)(v1 + 69) = 96;
  *(_BYTE *)(v1 + 12) = v3 | 1;
  *(_BYTE *)(v1 + 63) = 10;
  *(_BYTE *)(v1 + 64) = 89;
  *(_DWORD *)(v1 + 8) = 40;
  sub_57D70(v1, a1);
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00050A90) --------------------------------------------------------
int __cdecl sub_50A90(int a1, char a2, char a3)
{
  int v3; // eax
  int v4; // ebx
  char v5; // dl

  v3 = sub_4A050();
  v4 = v3;
  if ( v3 )
  {
    *(_BYTE *)(v3 + 63) = 11;
    *(_BYTE *)(v3 + 64) = a2;
    *(_BYTE *)(v3 + 69) = a3;
    *(_BYTE *)(v3 + 12) &= 0xF6u;
    v5 = *(_BYTE *)(v3 + 12);
    *(_DWORD *)(v3 + 16) = 0;
    *(_BYTE *)(v3 + 12) = v5 | 1;
    *(_DWORD *)(v3 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v3 + 80) = *(_WORD *)(a1 + 4);
    sub_49A20(v3);
  }
  return v4;
}

//----- (00050AE0) --------------------------------------------------------
int __cdecl sub_50AE0(int a1)
{
  return sub_50A90(a1, 0, 0);
}

//----- (00050B00) --------------------------------------------------------
int __cdecl sub_50B00(int a1)
{
  return sub_50A90(a1, 1, 1);
}

//----- (00050B20) --------------------------------------------------------
int __cdecl sub_50B20(int a1)
{
  return sub_50A90(a1, 2, 2);
}

//----- (00050B40) --------------------------------------------------------
int __cdecl sub_50B40(int a1)
{
  return sub_50A90(a1, 3, 3);
}

//----- (00050B60) --------------------------------------------------------
int __cdecl sub_50B60(int a1)
{
  return sub_50A90(a1, 4, 4);
}

//----- (00050B80) --------------------------------------------------------
int __cdecl sub_50B80(int a1)
{
  return sub_50A90(a1, 32, 32);
}

//----- (00050C10) --------------------------------------------------------
int __cdecl sub_50C10(int a1)
{
  return sub_50A90(a1, 12, 12);
}

//----- (00050C30) --------------------------------------------------------
int __cdecl sub_50C30(int a1)
{
  return sub_50A90(a1, 13, 13);
}

//----- (00050C50) --------------------------------------------------------
int __cdecl sub_50C50(int a1)
{
  return sub_50A90(a1, 14, 14);
}

//----- (00050C70) --------------------------------------------------------
int __cdecl sub_50C70(int a1)
{
  return sub_50A90(a1, 15, 15);
}

//----- (00050C90) --------------------------------------------------------
int __cdecl sub_50C90(int a1)
{
  return sub_50A90(a1, 16, 16);
}

//----- (00050CB0) --------------------------------------------------------
int __cdecl sub_50CB0(int a1)
{
  return sub_50A90(a1, 17, 17);
}

//----- (00050CD0) --------------------------------------------------------
int __cdecl sub_50CD0(int a1)
{
  return sub_50A90(a1, 18, 18);
}

//----- (00050CF0) --------------------------------------------------------
int __cdecl sub_50CF0(int a1)
{
  return sub_50A90(a1, 19, 19);
}

//----- (00050D10) --------------------------------------------------------
int __cdecl sub_50D10(int a1)
{
  return sub_50A90(a1, 20, 20);
}

//----- (00050D30) --------------------------------------------------------
int __cdecl sub_50D30(int a1)
{
  return sub_50A90(a1, 21, 21);
}

//----- (00050D50) --------------------------------------------------------
int __cdecl sub_50D50(int a1)
{
  return sub_50A90(a1, 22, 22);
}

//----- (00050D70) --------------------------------------------------------
int __cdecl sub_50D70(int a1)
{
  return sub_50A90(a1, 23, 23);
}

//----- (00050D90) --------------------------------------------------------
int __cdecl sub_50D90(int a1)
{
  return sub_50A90(a1, 24, 24);
}

//----- (00050DB0) --------------------------------------------------------
int __cdecl sub_50DB0(int a1)
{
  return sub_50A90(a1, 25, 25);
}

//----- (00050DD0) --------------------------------------------------------
int __cdecl sub_50DD0(int a1)
{
  return sub_50A90(a1, 26, 26);
}

//----- (00050DF0) --------------------------------------------------------
int __cdecl sub_50DF0(int a1)
{
  return sub_50A90(a1, 27, 27);
}

//----- (00050E10) --------------------------------------------------------
int __cdecl sub_50E10(int a1)
{
  return sub_50A90(a1, 28, 28);
}

//----- (00050E30) --------------------------------------------------------
int __cdecl sub_50E30(int a1)
{
  return sub_50A90(a1, 29, 29);
}

//----- (00050E50) --------------------------------------------------------
int __cdecl sub_50E50(int a1)
{
  return sub_50A90(a1, 33, 33);
}

//----- (00050E70) --------------------------------------------------------
int __cdecl sub_50E70(int a1)
{
  return sub_50A90(a1, 34, 34);
}

//----- (00050E90) --------------------------------------------------------
int __cdecl sub_50E90(int a1)
{
  return sub_50A90(a1, 35, 35);
}

//----- (00050EB0) --------------------------------------------------------
int __cdecl sub_50EB0(int a1)
{
  return sub_50A90(a1, 36, 36);
}

//----- (00050ED0) --------------------------------------------------------
int __cdecl sub_50ED0(int a1)
{
  return sub_50A90(a1, 37, 37);
}

//----- (00050EF0) --------------------------------------------------------
int __cdecl sub_50EF0(int a1)
{
  return sub_50A90(a1, 38, 38);
}

//----- (00050F10) --------------------------------------------------------
int __cdecl sub_50F10(int a1)
{
  return sub_50A90(a1, 39, 39);
}

//----- (00050F30) --------------------------------------------------------
int __cdecl sub_50F30(int a1)
{
  return sub_50A90(a1, 40, 40);
}

//----- (00050F50) --------------------------------------------------------
int __cdecl sub_50F50(int a1)
{
  return sub_50A90(a1, 41, 41);
}

//----- (00050F70) --------------------------------------------------------
int __cdecl sub_50F70(int a1)
{
  return sub_50A90(a1, 42, 42);
}

//----- (00050F90) --------------------------------------------------------
int __cdecl sub_50F90(int a1)
{
  return sub_50A90(a1, 43, 43);
}

//----- (00050FB0) --------------------------------------------------------
int __cdecl sub_50FB0(int a1)
{
  return sub_50A90(a1, 44, 44);
}

//----- (00050FD0) --------------------------------------------------------
int __cdecl sub_50FD0(int a1)
{
  return sub_50A90(a1, 30, 30);
}

//----- (00050FF0) --------------------------------------------------------
int __cdecl sub_50FF0(int a1)
{
  int v1; // edx
  int v2; // eax
  char v3; // cl

  v1 = 0;
  if ( !(*(_BYTE *)(dword_D41A4 + 22) & 0x10) && !(*(_BYTE *)(dword_D41A4 + 38545) & 8) )
  {
    v1 = sub_50A90(a1, 31, 31);
    if ( v1 )
    {
      v2 = dword_D41A0;
      v3 = *(_BYTE *)(dword_D41A0 + 224779);
      *(_BYTE *)(dword_D41A0 + 224770) = 1;
      *(_BYTE *)(v2 + 224779) = v3 | 1;
    }
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00051120) --------------------------------------------------------
int __cdecl sub_51120(int a1, char a2, char a3)
{
  int v3; // eax
  int v4; // ebx
  int v5; // esi
  char v6; // ah

  v3 = sub_4A050();
  v4 = v3;
  v5 = v3;
  if ( v3 )
  {
    *(_BYTE *)(v3 + 63) = 15;
    *(_DWORD *)(v3 + 4) = 0;
    *(_BYTE *)(v3 + 64) = a2;
    *(_BYTE *)(v3 + 69) = a3;
    v6 = *(_BYTE *)(v3 + 12);
    *(_DWORD *)(v4 + 8) = 0;
    *(_BYTE *)(v4 + 12) = v6 & 0xF7;
    sub_57D70(v4, a1);
    sub_49CD0((_WORD *)v4, 77);
    sub_49EA0((_WORD *)v4, 768, 1280);
    sub_49A20(v4);
    sub_6D5E0(v4, 0);
  }
  return v5;
}

//----- (000511A0) --------------------------------------------------------
int __cdecl sub_511A0(int a1)
{
  return sub_51120(a1, 0, 0);
}

//----- (000511C0) --------------------------------------------------------
int __cdecl sub_511C0(int a1)
{
  return sub_51120(a1, 1, 3);
}

//----- (000511E0) --------------------------------------------------------
int __cdecl sub_511E0(int a1)
{
  return sub_51120(a1, 2, 6);
}

//----- (00051200) --------------------------------------------------------
int __cdecl sub_51200(int a1)
{
  return sub_51120(a1, 3, 9);
}

//----- (00051220) --------------------------------------------------------
int __cdecl sub_51220(int a1)
{
  return sub_51120(a1, 4, 12);
}

//----- (00051240) --------------------------------------------------------
int __cdecl sub_51240(int a1)
{
  return sub_51120(a1, 5, 15);
}

//----- (00051260) --------------------------------------------------------
int __cdecl sub_51260(int a1)
{
  return sub_51120(a1, 6, 18);
}

//----- (00051280) --------------------------------------------------------
int __cdecl sub_51280(int a1)
{
  return sub_51120(a1, 7, 21);
}

//----- (000512A0) --------------------------------------------------------
int __cdecl sub_512A0(int a1)
{
  return sub_51120(a1, 8, 24);
}

//----- (000512C0) --------------------------------------------------------
int __cdecl sub_512C0(int a1)
{
  return sub_51120(a1, 9, 27);
}

//----- (000512E0) --------------------------------------------------------
int __cdecl sub_512E0(int a1)
{
  return sub_51120(a1, 10, 30);
}

//----- (00051300) --------------------------------------------------------
int __cdecl sub_51300(int a1)
{
  return sub_51120(a1, 11, 33);
}

//----- (00051320) --------------------------------------------------------
int __cdecl sub_51320(int a1)
{
  return sub_51120(a1, 12, 36);
}

//----- (00051340) --------------------------------------------------------
int __cdecl sub_51340(int a1)
{
  return sub_51120(a1, 13, 39);
}

//----- (00051360) --------------------------------------------------------
int __cdecl sub_51360(int a1)
{
  return sub_51120(a1, 14, 42);
}

//----- (00051380) --------------------------------------------------------
int __cdecl sub_51380(int a1)
{
  return sub_51120(a1, 15, 45);
}

//----- (000513A0) --------------------------------------------------------
int __cdecl sub_513A0(int a1)
{
  return sub_51120(a1, 16, 48);
}

//----- (000513C0) --------------------------------------------------------
int __cdecl sub_513C0(int a1)
{
  return sub_51120(a1, 17, 51);
}

//----- (000513E0) --------------------------------------------------------
int __cdecl sub_513E0(int a1)
{
  return sub_51120(a1, 18, 54);
}

//----- (00051400) --------------------------------------------------------
int __cdecl sub_51400(int a1)
{
  return sub_51120(a1, 19, 57);
}

//----- (00051420) --------------------------------------------------------
int __cdecl sub_51420(int a1)
{
  return sub_51120(a1, 20, 60);
}

//----- (00051440) --------------------------------------------------------
int __cdecl sub_51440(int a1)
{
  return sub_51120(a1, 21, 63);
}

//----- (00051460) --------------------------------------------------------
int __cdecl sub_51460(int a1)
{
  return sub_51120(a1, 22, 66);
}

//----- (00051480) --------------------------------------------------------
int __cdecl sub_51480(int a1)
{
  return sub_51120(a1, 23, 69);
}

//----- (000514A0) --------------------------------------------------------
int __cdecl sub_514A0(int a1)
{
  return sub_51120(a1, 24, 72);
}

//----- (000514C0) --------------------------------------------------------
int __cdecl sub_514C0(int a1)
{
  return sub_51120(a1, 25, 75);
}

//----- (000514E0) --------------------------------------------------------
int __cdecl sub_514E0(int a1, char a2, char a3, __int16 a4)
{
  int v4; // ebx

  v4 = sub_4A050();
  if ( v4 )
  {
    *(_BYTE *)(v4 + 63) = 14;
    *(_BYTE *)(v4 + 70) = 0;
    *(_BYTE *)(v4 + 69) = a3;
    *(_BYTE *)(v4 + 64) = a2;
    sub_57D70(v4, a1);
    sub_49A20(v4);
    sub_49DA0((_WORD *)v4, a4);
  }
  return v4;
}

//----- (00051530) --------------------------------------------------------
_WORD *__cdecl sub_51530(int a1)
{
  _WORD *v1; // eax
  _WORD *v2; // ebx

  v1 = (_WORD *)sub_514E0(a1, 0, 0, 77);
  v2 = v1;
  if ( v1 )
    sub_49EA0(v1, 384, 384);
  return v2;
}

//----- (00051570) --------------------------------------------------------
int __cdecl sub_51570(int a1)
{
  int result; // eax

  result = sub_514E0(a1, 3, 8, 338);
  if ( result )
  {
    *(_WORD *)(dword_D41A0 + 224766) = (result - (dword_D41A0 + 28302)) / 168;
    *(_BYTE *)(result + 12) |= 1u;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (000515C0) --------------------------------------------------------
int __cdecl sub_515C0(int a1)
{
  int result; // eax

  result = sub_514E0(a1, 4, 9, 339);
  if ( result )
  {
    *(_WORD *)((char *)&loc_36DFC + dword_D41A0) = (result - (dword_D41A0 + 28302)) / 168;
    *(_BYTE *)(result + 12) |= 1u;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00051610) --------------------------------------------------------
_WORD *__cdecl sub_51610(int a1)
{
  _WORD *v1; // eax
  _WORD *v2; // ebx
  _WORD *v3; // esi

  v1 = (_WORD *)sub_514E0(a1, 5, 10, 280);
  v2 = v1;
  v3 = v1;
  if ( v1 )
  {
    sub_49EA0(v1, 768, 1280);
    if ( *(_BYTE *)(dword_D41A4 + 38545) & 4 )
      *((_BYTE *)v2 + 12) |= 1u;
  }
  return v3;
}
// D41A4: using guessed type int dword_D41A4;

//----- (00051660) --------------------------------------------------------
int __cdecl sub_51660(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // dl

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 6;
    v3 = *(_BYTE *)(v1 + 12);
    *(_BYTE *)(v1 + 63) = 14;
    v3 &= 0xF6u;
    *(_BYTE *)(v1 + 12) = v3;
    *(_BYTE *)(v1 + 64) = 1;
    *(_BYTE *)(v1 + 12) = v3 | 1;
    *(_DWORD *)(v1 + 4) = 0;
    *(_DWORD *)(v1 + 8) = 0;
    *(_WORD *)(v1 + 42) = 0;
    sub_57D70(v1, a1);
  }
  return v2;
}

//----- (000516C0) --------------------------------------------------------
int __cdecl sub_516C0(int a1)
{
  int v1; // ebx
  int v2; // eax
  char v3; // dl

  v1 = 0;
  if ( byte_D41B6 )
  {
    v2 = sub_4A050();
    v1 = v2;
    if ( v2 )
    {
      *(_BYTE *)(v2 + 69) = 7;
      *(_BYTE *)(v2 + 63) = 14;
      v3 = *(_BYTE *)(v2 + 12);
      *(_BYTE *)(v2 + 64) = 2;
      v3 &= 0xF6u;
      *(_BYTE *)(v2 + 12) = v3;
      *(_DWORD *)(v2 + 8) = 0;
      *(_BYTE *)(v2 + 12) = v3 | 1;
      *(_WORD *)(v2 + 42) = 0;
      *(_WORD *)(v2 + 44) = 0;
      *(_WORD *)(v2 + 150) = 0;
      sub_57D70(v2, a1);
    }
  }
  return v1;
}
// D41B6: using guessed type char byte_D41B6;

//----- (00051730) --------------------------------------------------------
int __cdecl sub_51730(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // esi

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  v3 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 72;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 67;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    *(_DWORD *)(v1 + 8) = 120;
    *(_WORD *)(v1 + 42) = 20000;
    sub_57D70(v1, a1);
    sub_49EA0(v2, 4352, 4352);
  }
  return v3;
}

//----- (00051790) --------------------------------------------------------
_BYTE *__cdecl sub_51790(int a1)
{
  _BYTE *v1; // eax
  int v2; // ebx
  _BYTE *v3; // esi
  char v4; // ah

  v1 = (_BYTE *)sub_4A050();
  v2 = (int)v1;
  v3 = v1;
  if ( v1 )
  {
    v1[69] = 78;
    v1[63] = 10;
    v1[64] = 71;
    v4 = v1[12];
    *(_DWORD *)(v2 + 8) = 120;
    *(_WORD *)(v2 + 42) = 20000;
    *(_BYTE *)(v2 + 12) = v4 & 0xF6 | 1;
    *(_BYTE *)(v2 + 70) = 0;
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(v2 + 8);
    sub_57D70(v2, a1);
    sub_49EA0((_WORD *)v2, 1280, 2048);
  }
  return v3;
}

//----- (00051800) --------------------------------------------------------
_WORD *__cdecl sub_51800(int a1)
{
  int v1; // ebx
  int v2; // eax
  char v3; // dl
  int v4; // eax
  _WORD *v5; // ebx
  int v6; // edx
  int v7; // eax
  int v9; // [esp+0h] [ebp-10h]
  int v10; // [esp+4h] [ebp-Ch]
  _WORD *v11; // [esp+8h] [ebp-8h]
  signed __int16 v12; // [esp+Ch] [ebp-4h]

  v11 = 0;
  v1 = *(unsigned __int8 *)(dword_D41A4 + 224);
  if ( sub_4A810() >= v1 )
  {
    v2 = sub_4A050();
    v11 = (_WORD *)v2;
    if ( v2 )
    {
      *(_BYTE *)(v2 + 69) = 79;
      *(_BYTE *)(v2 + 63) = 10;
      *(_BYTE *)(v2 + 64) = 72;
      v3 = *(_BYTE *)(v2 + 12);
      *(_DWORD *)(v2 + 4) = 16;
      *(_BYTE *)(v2 + 12) = v3 & 0xF7;
      v10 = v2;
      *(_DWORD *)(v2 + 8) = *(_DWORD *)(v2 + 4);
      v12 = 1;
      *(_BYTE *)(v2 + 62) = 0;
      while ( *(unsigned __int8 *)(dword_D41A4 + 224) > v12 )
      {
        v4 = sub_4A050();
        v5 = (_WORD *)v4;
        v9 = v4;
        if ( v4 )
        {
          qmemcpy((void *)v4, v11, 0xA8u);
          v6 = v4 - (dword_D41A0 + 28302);
          *(_WORD *)(v4 + 50) = (v10 - (dword_D41A0 + 28302)) / 168;
          *(_WORD *)(v10 + 52) = v6 / 168;
          *(_WORD *)(v4 + 52) = 0;
          *(_BYTE *)(v4 + 62) = v12;
          v7 = dword_D41A4;
          *(_DWORD *)&word_EB398 = *(_DWORD *)a1;
          *(&word_EB398 + 2) = *(_WORD *)(a1 + 4);
          sub_57FA0(&word_EB398, v12 * (2048 / *(unsigned __int8 *)(v7 + 224)), 0, 512);
          word_EB39C = sub_10C40(&word_EB398);
          sub_57D70((int)v5, (int)&word_EB398);
          sub_49EA0(v5, 128, 256);
          sub_49CD0(v5, 220);
        }
        v10 = v9;
        ++v12;
      }
      *(_DWORD *)&word_EB398 = *(_DWORD *)a1;
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 4);
      sub_57FA0(&word_EB398, 0, 0, 512);
      word_EB39C = sub_10C40(&word_EB398);
      sub_57D70((int)v11, (int)&word_EB398);
      sub_49EA0(v11, 128, 256);
      sub_49CD0(v11, 220);
    }
  }
  return v11;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00051A00) --------------------------------------------------------
_BYTE *__cdecl sub_51A00(int a1)
{
  _BYTE *v1; // eax
  int v2; // ebx
  char v3; // ah
  _BYTE *v5; // [esp+0h] [ebp-4h]

  v1 = (_BYTE *)sub_4A050();
  v2 = (int)v1;
  v5 = v1;
  if ( v1 )
  {
    v1[69] = 80;
    v1[63] = 10;
    v1[64] = 73;
    v3 = v1[12] & 0xF7;
    *(_DWORD *)(v2 + 8) = 16;
    *(_BYTE *)(v2 + 12) = v3;
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(v2 + 8);
    *(_DWORD *)&word_EB398 = *(_DWORD *)a1;
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 4);
    word_EB39C = sub_10C40(&word_EB398);
    sub_57D70(v2, (int)&word_EB398);
    sub_49EA0((_WORD *)v2, 128, 256);
    sub_49CD0((_WORD *)v2, 220);
  }
  return v5;
}
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00051BB0) --------------------------------------------------------
int __usercall sub_51BB0@<eax>(int a1@<edi>)
{
  char v1; // al
  _BYTE *v2; // ecx
  unsigned __int16 v3; // dx
  int v4; // ebx
  char *v5; // esi
  char *v6; // edi
  char v7; // al
  char v8; // al
  int v9; // esi
  int v10; // edx
  int v11; // eax
  int v12; // esi
  char v13; // dl
  char v14; // bl
  signed __int16 v15; // bx
  char v16; // cl
  int v17; // eax
  int v18; // ebx
  int v19; // eax
  char *v20; // esi
  char *v21; // edi
  char v22; // al
  char v23; // al
  __int16 v24; // ST08_2
  __int16 v25; // ST08_2
  char *v26; // esi
  char *v27; // edi
  char v28; // al
  char v29; // al
  __int16 v30; // ax
  int v31; // eax
  int v32; // edx
  int v33; // eax
  int v34; // eax
  char v35; // al
  char v36; // dl
  const char *v37; // edi
  unsigned int v38; // kr04_4
  const char *v39; // edi
  unsigned int v40; // kr08_4
  char *v41; // esi
  char *v42; // edi
  char v43; // al
  char v44; // al
  char *v45; // edi
  char *v46; // esi
  char v47; // al
  char v48; // al
  int v49; // edx
  int v50; // ecx
  _BOOL1 v51; // zf
  char *v52; // esi
  char *v53; // edi
  char v54; // al
  char v55; // al
  int v56; // eax
  __int16 i; // ax
  int v58; // edx
  unsigned __int16 v59; // si
  int j; // eax
  int v61; // eax
  int v62; // esi
  int v63; // eax
  __int64 v64; // rtt
  __int16 n; // ax
  int v66; // edx
  unsigned int ii; // eax
  int v68; // eax
  int v69; // edx
  unsigned int k; // eax
  char v71; // dl
  unsigned int l; // eax
  unsigned int m; // eax
  __int16 v74; // ax
  int v75; // edx
  char v76; // dl
  char v77; // ch
  __int16 v78; // cx
  int v79; // eax
  int v80; // edx
  int v81; // edx
  int v82; // esi
  char *v83; // edi
  char *v84; // esi
  char v85; // al
  char v86; // al
  int v87; // eax
  int v88; // eax
  int v89; // edx
  int v90; // eax
  unsigned __int8 v91; // cl
  int v92; // edx
  char v93; // al
  int v94; // eax
  char v95; // dl
  int v96; // eax
  int v97; // edx
  unsigned int v98; // eax
  int v99; // ecx
  __int64 v100; // rax
  int v101; // ecx
  __int64 v102; // rax
  int v103; // esi
  int v104; // esi
  int result; // eax
  const char *v106; // [esp-4h] [ebp-120h]
  unsigned __int8 v107; // [esp+0h] [ebp-11Ch]
  unsigned __int8 v108; // [esp+1h] [ebp-11Bh]
  unsigned __int8 v109; // [esp+2h] [ebp-11Ah]
  unsigned __int8 v110; // [esp+3h] [ebp-119h]
  unsigned __int8 v111; // [esp+4h] [ebp-118h]
  int v112; // [esp+100h] [ebp-1Ch]
  int v113; // [esp+104h] [ebp-18h]
  int v114; // [esp+108h] [ebp-14h]
  int v115; // [esp+10Ch] [ebp-10h]
  unsigned int v116; // [esp+110h] [ebp-Ch]
  char v117; // [esp+114h] [ebp-8h]
  char v118; // [esp+118h] [ebp-4h]

  if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
  {
    sub_74374();
    sub_7438A(dword_D41A0 + 28222, 0xAu);
    v1 = 0;
    v2 = (_BYTE *)(dword_D41A0 + 28222);
    v3 = 0;
    v4 = dword_D41A0 + 11230;
    while ( 1 )
    {
      v9 = dword_D41A0;
      if ( v3 >= *(_WORD *)(dword_D41A0 + 14) )
        break;
      if ( *v2 == 1 )
      {
        *(_BYTE *)(v4 + 6) = 1;
        if ( v3 == *(signed __int16 *)(v9 + 12) && *(_BYTE *)(dword_D41A4 + 57) )
        {
          v5 = (char *)(dword_D41A4 + 57);
          v6 = (char *)(v4 + 927);
          do
          {
            v7 = *v5;
            *v6 = *v5;
            if ( !v7 )
              break;
            v8 = v5[1];
            v5 += 2;
            v6[1] = v8;
            v6 += 2;
          }
          while ( v8 );
          a1 = v4 + 927;
        }
        v1 = 1;
      }
      v2 += 10;
      v4 += 2124;
      ++v3;
    }
    if ( v1 )
      sub_7438A(dword_D41A0 + 11230, 0x84Cu);
  }
  v10 = 2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0;
  v11 = dword_D41A4;
  ++*(_DWORD *)(v10 + 11248);
  v12 = *(_DWORD *)(v11 + 30);
  ++*(_DWORD *)(v11 + 26);
  v13 = *(_BYTE *)(v11 + 38400);
  *(_DWORD *)(v11 + 30) = v12 + 1;
  if ( v13 )
    *(_BYTE *)(v11 + 38400) = v13 - 1;
  v14 = *(_BYTE *)(dword_D41A4 + 38401);
  if ( v14 )
    *(_BYTE *)(dword_D41A4 + 38401) = v14 - 1;
  v15 = 1;
  while ( v15 < 16 )
  {
    v16 = *(_DWORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248) / (unsigned int)v15 & 1;
    v17 = v15++;
    *(_BYTE *)(dword_D41A4 + v17 + 121) = v16;
  }
  v114 = dword_D41A0 + 28222;
  v18 = dword_D41A0 + 11230;
  v116 = 0;
  while ( 1 )
  {
    result = dword_D41A0;
    if ( (unsigned __int16)v116 >= *(_WORD *)(dword_D41A0 + 14) )
      return result;
    v113 = dword_EA3E4[*(unsigned __int16 *)(v18 + 10)];
    if ( *(_BYTE *)(dword_D41A4 + 22) & 0x20 )
    {
      a1 = v114;
      sub_53A40((char *)v114);
    }
    switch ( *(_BYTE *)v114 )
    {
      case 1:
        v19 = dword_D41A4;
        *(_BYTE *)(v18 + 6) = 1;
        if ( !(*(_BYTE *)(v19 + 22) & 0x10)
          && (unsigned __int16)v116 == *(signed __int16 *)(dword_D41A0 + 12)
          && *(_BYTE *)(dword_D41A4 + 57) )
        {
          v20 = (char *)(dword_D41A4 + 57);
          v21 = (char *)(v18 + 927);
          do
          {
            v22 = *v20;
            *v21 = *v20;
            if ( !v22 )
              break;
            v23 = v20[1];
            v20 += 2;
            v21[1] = v23;
            v21 += 2;
          }
          while ( v23 );
          a1 = v18 + 927;
        }
        goto LABEL_33;
      case 2:
        sub_53120();
        if ( *(signed __int16 *)(dword_D41A0 + 12) == (unsigned __int16)v116 )
          *(_BYTE *)(v18 + 4) = 1;
        if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
          sub_5E660(v113);
        sub_7373D(v116);
        *(_BYTE *)(v18 + 6) = 0;
        goto LABEL_215;
      case 3:
        goto LABEL_33;
      case 4:
        *(_BYTE *)(v18 + 5) ^= *(_BYTE *)(v114 + 1);
        goto LABEL_215;
      case 6:
        if ( *(_BYTE *)(v114 + 5) & 0x40 )
          *(_BYTE *)(*(_DWORD *)(v113 + 164) + 1112) = *(_BYTE *)(v114 + 1);
        if ( *(_BYTE *)(v114 + 5) < 0 && !*(_BYTE *)(v18 + 2118) )
          *(_BYTE *)(v18 + 2118) = 1;
        goto LABEL_215;
      case 7:
        if ( *(unsigned __int16 *)(v18 + 14) + (signed int)*(char *)(v114 + 1) >= 0
          && *(char *)(v114 + 1) + *(unsigned __int16 *)(v18 + 14) < *(unsigned __int16 *)(v18 + 16) - 1 )
        {
          *(_WORD *)(v18 + 14) += *(char *)(v114 + 1);
        }
        goto LABEL_215;
      case 8:
        *(_WORD *)(v18 + 477) += *(char *)(v114 + 1);
        goto LABEL_215;
      case 0xC:
        *(_BYTE *)(dword_D41A4 + 22) = (*(_BYTE *)(dword_D41A4 + 22) | 0x22) & 0xFB;
        goto LABEL_215;
      case 0xD:
        *(_BYTE *)(dword_D41A4 + 22) = (*(_BYTE *)(dword_D41A4 + 22) | 0x24) & 0xFD;
        goto LABEL_215;
      case 0xF:
        if ( *(_WORD *)(*(_DWORD *)(v113 + 164) + 58) )
          goto LABEL_33;
        if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
          goto LABEL_56;
        *(_BYTE *)(v18 + 2) |= 0xCu;
LABEL_33:
        sub_5C950(v18, v113);
        sub_6EDB0();
        sub_548F0((_WORD *)v18);
        sub_52E90(v18, 0, 0);
        goto LABEL_215;
      case 0x10:
        if ( *(_BYTE *)(dword_D41A0 + 224746) && (unsigned __int16)v116 == *(signed __int16 *)(dword_D41A0 + 12) )
        {
          v33 = v114;
          *(_BYTE *)(v114 + 3) = 0;
          *(_BYTE *)(v33 + 4) = 0;
          sub_6EDB0();
        }
        sub_52E90(v18, 3, 1);
        v34 = dword_D41A0;
        *(_BYTE *)(v18 + 994) = 0;
        if ( (unsigned __int16)v116 == *(signed __int16 *)(v34 + 12) )
        {
          v35 = *(_BYTE *)(v18 + 992);
          sub_54960();
        }
        goto LABEL_215;
      case 0x11:
        v36 = *(_BYTE *)(v114 + 1);
        if ( v36 == 8 )
        {
          v37 = (const char *)(48 * *(unsigned __int8 *)(v18 + 992) + v18 + 81);
          v38 = strlen(v37) + 1;
          a1 = (int)&v37[v38];
          if ( v38 != 1 )
          {
            --*(_BYTE *)(v18 + 994);
            *(_BYTE *)(v38 - 1 + v18 + 48 * *(unsigned __int8 *)(v18 + 992) + 80) = 0;
          }
        }
        else if ( v36 )
        {
          v39 = (const char *)(48 * *(unsigned __int8 *)(v18 + 992) + v18 + 81);
          v40 = strlen(v39) + 1;
          a1 = (int)&v39[v40];
          if ( v40 - 1 < 0x2B )
          {
            if ( !*(_BYTE *)(v18 + 994) )
              *(_BYTE *)(v18 + 48 * *(unsigned __int8 *)(v18 + 992) + 81) = 0;
            ++*(_BYTE *)(v18 + 994);
            sprintf(&v107, aC, *(char *)(v114 + 1));
            v41 = (char *)&v107;
            v106 = (const char *)(48 * *(unsigned __int8 *)(v18 + 992) + v18 + 81);
            v42 = (char *)&v106[strlen(v106)];
            do
            {
              v43 = *v41;
              *v42 = *v41;
              if ( !v43 )
                break;
              v44 = v41[1];
              v41 += 2;
              v42[1] = v44;
              v42 += 2;
            }
            while ( v44 );
            a1 = (int)v106;
          }
        }
        goto LABEL_215;
      case 0x12:
        sub_52E90(v18, 0, 1);
        goto LABEL_215;
      case 0x13:
        goto LABEL_82;
      case 0x14:
        if ( *(_BYTE *)(dword_D41A0 + 224746) && (unsigned __int16)v116 == *(signed __int16 *)(dword_D41A0 + 12) )
        {
          switch ( *(_BYTE *)(v114 + 1) )
          {
            case 3:
            case 5:
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
            case 0xD:
            case 0xE:
              v56 = v114;
              *(_BYTE *)(v114 + 3) = 0;
              *(_BYTE *)(v56 + 4) = 0;
              sub_6EDB0();
              break;
            default:
              break;
          }
        }
        sub_52E90(v18, *(char *)(v114 + 1), 1);
        goto LABEL_215;
      case 0x17:
        if ( *(char *)(v114 + 2) != -1 )
        {
          for ( i = 0; i < 26; ++i )
          {
            v58 = i + *(_DWORD *)(v113 + 164);
            if ( *(_BYTE *)(v58 + 923) == *(_BYTE *)(v114 + 2) )
              *(_BYTE *)(v58 + 923) = -1;
          }
          *(_BYTE *)(*(char *)(v114 + 1) + *(_DWORD *)(v113 + 164) + 923) = *(_BYTE *)(v114 + 2);
          sub_6E450(0, *(_WORD *)(v18 + 7), 14);
        }
        goto LABEL_215;
      case 0x19:
      case 0x1A:
        v59 = 0;
        for ( j = dword_D41A0; v59 < *(_WORD *)(dword_D41A0 + 14); j = dword_D41A0 )
        {
          v61 = 2124 * v59 + j;
          if ( *(_BYTE *)(v61 + 11236) )
          {
            *(_BYTE *)(v61 + 11234) = 1;
            sub_7373D(v59);
          }
          ++v59;
        }
        goto LABEL_215;
      case 0x1B:
        sub_53120();
        v24 = v116;
        *(_WORD *)(v18 + 2) = 10;
        sub_7373D(v24);
        goto LABEL_215;
      case 0x1C:
        v25 = v116;
        *(_WORD *)(v18 + 2) = 12;
        sub_7373D(v25);
        goto LABEL_215;
      case 0x1D:
LABEL_56:
        v26 = (char *)dword_EA0B8;
        v27 = (char *)(v18 + 28);
        do
        {
          v28 = *v26;
          *v27 = *v26;
          if ( !v28 )
            break;
          v29 = v26[1];
          v26 += 2;
          v27[1] = v29;
          v27 += 2;
        }
        while ( v29 );
        HIWORD(a1) = (unsigned int)(v18 + 28) >> 16;
        *(_WORD *)(v18 + 79) = 1;
        v30 = v116;
        *(_WORD *)(v18 + 77) = 100;
        *(_WORD *)(v18 + 2) = 8;
        sub_7373D(v30);
        v31 = dword_D41A4;
        *(_BYTE *)(v18 + 6) = 0;
        if ( *(_BYTE *)(v31 + 22) & 0x10 )
          sub_5E660(v113);
        LOWORD(a1) = *(_WORD *)(dword_D41A4 + 43);
        *(_BYTE *)(dword_D41A4 + 22) &= 0xD9u;
        if ( (unsigned __int16)a1 > 0x18u )
          *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) |= 0x10u;
        goto LABEL_215;
      case 0x1E:
        sub_53120();
        switch ( *(_BYTE *)(v114 + 1) )
        {
          case 1:
            v112 = 0;
            break;
          case 2:
            v68 = sub_4A190(v113 + 76, 10, 39);
            if ( v68 )
            {
              v69 = dword_D41A0;
              *(_DWORD *)(v68 + 144) = 100000;
              *(_WORD *)(v68 + 148) = (v113 - (v69 + 28302)) / 168;
            }
            *(_DWORD *)(v113 + 144) = *(_DWORD *)(v113 + 140);
            sub_52D70(v116, aCheatMoreMana);
            goto LABEL_215;
          case 3:
            for ( k = *(_DWORD *)(dword_D41A4 + 38519); k > dword_EA3E4[0]; k = *(_DWORD *)k )
            {
              if ( *(_WORD *)(k + 26) != *(_WORD *)(v113 + 26) )
              {
                v71 = *(_BYTE *)(k + 64);
                if ( !v71 || v71 == 1 )
                  *(_DWORD *)(k + 8) = -1;
              }
            }
            sub_52D70(v116, aCheatDestroyAl);
            goto LABEL_215;
          case 4:
            for ( l = *(_DWORD *)(dword_D41A4 + 38519); l > dword_EA3E4[0]; l = *(_DWORD *)l )
            {
              if ( *(_WORD *)(l + 26) != *(_WORD *)(v113 + 26) && *(_BYTE *)(l + 64) == 2 )
                *(_DWORD *)(l + 8) = -1;
            }
            sub_52D70(v116, aCheatDestroyAl_0);
            goto LABEL_215;
          case 5:
            for ( m = *(_DWORD *)(dword_D41A4 + 38519); m > dword_EA3E4[0]; m = *(_DWORD *)m )
            {
              if ( *(_WORD *)(m + 26) != *(_WORD *)(v113 + 26) && *(_BYTE *)(m + 64) == 3 )
                *(_DWORD *)(m + 8) = -1;
            }
            sub_52D70(v116, aCheatDestroyAl_1);
            goto LABEL_215;
          case 6:
            *(_DWORD *)(v113 + 8) = *(_DWORD *)(v113 + 4);
            sub_52D70(v116, aCheatHeal);
            goto LABEL_215;
          case 7:
            sub_1B5F0();
            sub_52D70(v116, aCheatKillAllCr);
            goto LABEL_215;
          case 8:
            v74 = 0;
            while ( v74 < 26 )
            {
              v75 = (unsigned __int8)byte_D94FF[v74++];
              *(_DWORD *)(*(_DWORD *)(v113 + 164) + 4 * v75 + 715) += 100;
            }
            sub_6DB50(0, 0);
            sub_52D70(v116, aCheatMoreSpell);
            goto LABEL_215;
          case 9:
            v76 = *(_BYTE *)(dword_D41A4 + 24);
            if ( v76 & 0x20 )
            {
              *(_BYTE *)(dword_D41A4 + 24) = v76 & 0xDF;
              sub_52D70(v116, aCheatFreeSpell);
            }
            else
            {
              *(_BYTE *)(dword_D41A4 + 24) = v76 | 0x20;
              sub_52D70(v116, aCheatFreeSpell_0);
            }
            goto LABEL_215;
          case 0xA:
            v77 = *(_BYTE *)(dword_D41A4 + 25);
            if ( v77 & 1 )
              *(_BYTE *)(dword_D41A4 + 25) = v77 & 0xFE;
            else
              *(_BYTE *)(dword_D41A4 + 25) = v77 | 1;
            if ( *(_BYTE *)(dword_D41A4 + 25) & 1 )
              sub_52D70(v116, aCheatInvincabi);
            else
              sub_52D70(v116, aCheatInvincabi_0);
            goto LABEL_215;
          default:
            goto LABEL_215;
        }
        break;
      case 0x1F:
      case 0x20:
        if ( *(char *)(v114 + 1) != -1 )
        {
          sub_6E450(0, *(_WORD *)(v18 + 7), 14);
          sub_87C10();
          v78 = (unsigned __int8)byte_D94FF[*(char *)(v114 + 1)];
          v79 = *(_DWORD *)(v113 + 164) + 611;
          *(_BYTE *)(v79 + (unsigned __int8)byte_D94FF[*(char *)(v114 + 1)] + 468) = *(_BYTE *)(v114 + 2);
          if ( *(_BYTE *)v114 >= 0x1Fu )
          {
            if ( *(_BYTE *)v114 <= 0x1Fu )
            {
              v80 = v114;
              *(_WORD *)(v79 + 494) = v78;
              *(_BYTE *)(v79 + 498) = *(_BYTE *)(v80 + 2);
              *(_BYTE *)(dword_D41A4 + 38400) = 8;
            }
            else if ( *(_BYTE *)v114 == 32 )
            {
              v81 = v114;
              *(_WORD *)(v79 + 496) = v78;
              *(_BYTE *)(v79 + 499) = *(_BYTE *)(v81 + 2);
              *(_BYTE *)(dword_D41A4 + 38401) = 8;
            }
          }
          v82 = v78;
          a1 = dword_EA3E4[*(signed __int16 *)(v79 + 2 * v78 + 208)];
          sub_6D5E0(dword_EA3E4[*(signed __int16 *)(v79 + 2 * v78 + 208)], *(_BYTE *)(v114 + 2));
          sub_6D830(a1, *(_BYTE *)(v114 + 2));
          if ( (unsigned __int16)v116 == *(signed __int16 *)(dword_D41A0 + 12) )
          {
            v83 = (char *)(v18 + 28);
            v84 = (char *)dword_E9C4C[word_DA82E[40 * v82 + 13 * *(char *)(v114 + 2)]];
            do
            {
              v85 = *v84;
              *v83 = *v84;
              if ( !v85 )
                break;
              v86 = v84[1];
              v84 += 2;
              v83[1] = v86;
              v83 += 2;
            }
            while ( v86 );
            a1 = v18 + 28;
            *(_WORD *)(v18 + 77) = 20;
            *(_WORD *)(v18 + 79) = 3;
          }
          if ( *(_BYTE *)(dword_D41A4 + 22) & 4 )
          {
            v87 = *(signed __int16 *)(dword_D41A0 + 12);
            if ( (unsigned __int16)v116 == v87 )
            {
              sub_6D200(dword_D41A0 + 11230 + 2124 * v87);
              sub_473B0();
            }
          }
        }
        goto LABEL_215;
      case 0x23:
        v93 = *(_BYTE *)(v114 + 1);
        *(_BYTE *)(v18 + 994) = 0;
        *(_BYTE *)(v18 + 992) = v93;
        goto LABEL_215;
      case 0x24:
        *(_BYTE *)(v18 + 993) = *(_BYTE *)(v114 + 1);
        goto LABEL_215;
      case 0x25:
        if ( *(_BYTE *)(v18 + 993) == 3 )
          *(_BYTE *)(v18 + 995) ^= 1 << *(_BYTE *)(v114 + 1);
        goto LABEL_215;
      case 0x26:
        *(_BYTE *)(*(char *)(v114 + 1) + *(_DWORD *)(v113 + 164) + 949) = *(_BYTE *)(v114 + 2);
        sub_6E450(0, *(_WORD *)(v18 + 7), 14);
        goto LABEL_215;
      case 0x27:
        v94 = v114;
        *(_BYTE *)(v114 + 3) = 0;
        v95 = *(_BYTE *)(v94 + 1);
        *(_BYTE *)(v94 + 4) = 0;
        if ( v95 )
        {
          v96 = v113;
          *(_WORD *)(v113 + 130) = 0;
          *(_WORD *)(*(_DWORD *)(v96 + 164) + 12) = 0;
          LOWORD(a1) = *(_WORD *)(*(_DWORD *)(v113 + 164) + 825);
          if ( (_WORD)a1 )
            *(_WORD *)(dword_EA3E4[(signed __int16)a1] + 46) = 0;
        }
        if ( *(_WORD *)(v18 + 7) == *(_WORD *)(dword_D41A0 + 12) )
          sub_6EDB0();
        goto LABEL_215;
      case 0x28:
        if ( *(_BYTE *)(dword_D41A4 + 22) & 4 )
        {
          v88 = *(_DWORD *)(v113 + 164);
          *(_BYTE *)(v88 + 1112) = *(_BYTE *)(v114 + 1);
          *(_BYTE *)(v88 + 1111) = *(_BYTE *)(v114 + 2);
          v89 = *(signed __int16 *)(dword_D41A0 + 12);
          if ( (unsigned __int16)v116 == v89 )
          {
            sub_6D200(2124 * v89 + dword_D41A0 + 11230);
            sub_473B0();
          }
        }
        goto LABEL_215;
      case 0x29:
        if ( *(_BYTE *)(dword_D41A4 + 22) & 4 )
        {
          v90 = *(_DWORD *)(v113 + 164);
          v91 = byte_D94FF[*(char *)(v90 + 1112)];
          v90 += 611;
          *(_BYTE *)(v90 + 502) = *(_BYTE *)(v114 + 1);
          *(_BYTE *)(v90 + v91 + 468) = *(_BYTE *)(v114 + 1);
          v92 = *(signed __int16 *)(dword_D41A0 + 12);
          if ( (unsigned __int16)v116 == v92 )
          {
            sub_6D200(dword_D41A0 + 11230 + 2124 * v92);
            sub_473B0();
          }
        }
        goto LABEL_215;
      case 0x2A:
        v97 = *(_DWORD *)(v113 + 164);
        a1 = dword_EA3E4[0];
        v98 = dword_EA3E4[*(unsigned __int16 *)(v97 + 58)];
        if ( v98 > dword_EA3E4[0] )
        {
          if ( *(_DWORD *)(v98 + 16) == 1 )
            *(_BYTE *)(v97 + 446) = 1;
          *(_DWORD *)(v98 + 8) = -1;
        }
        goto LABEL_215;
      case 0x2B:
        *(_BYTE *)(v18 + 992) = *(_BYTE *)(v114 + 1);
LABEL_82:
        v45 = (char *)&v107;
        v46 = (char *)(48 * *(unsigned __int8 *)(v18 + 992) + v18 + 81);
        do
        {
          v47 = *v46;
          *v45 = *v46;
          if ( !v47 )
            break;
          v48 = v46[1];
          v46 += 2;
          v45[1] = v48;
          v45 += 2;
        }
        while ( v48 );
        a1 = (int)&v107;
        v118 = 0;
        if ( v107 )
        {
          v118 = 1;
          if ( toupper(v107) == 87
            && toupper(v108) == 73
            && toupper(v109) == 78
            && toupper(v110) == 68
            && toupper(v111) == 89 )
          {
            if ( (unsigned __int16)v116 == *(signed __int16 *)(dword_D41A0 + 12) )
              *(_BYTE *)(dword_D41A4 + 23) |= 0x80u;
          }
          else
          {
            v117 = 0;
            v49 = *(signed __int16 *)(dword_D41A0 + 12);
            if ( (unsigned __int16)v116 == v49 )
            {
LABEL_98:
              v117 = 1;
            }
            else
            {
              v50 = 2124 * v49 + dword_D41A0;
              switch ( *(_BYTE *)(v18 + 993) )
              {
                case 0:
                  v51 = sub_61810(v113, dword_EA3E4[*(unsigned __int16 *)(v50 + 11240)]) == 0;
                  goto LABEL_97;
                case 1:
                  a1 = v113;
                  v51 = sub_61620(v113, dword_EA3E4[*(unsigned __int16 *)(v50 + 11240)]) == 0;
LABEL_97:
                  if ( !v51 )
                    goto LABEL_98;
                  break;
                case 2:
                  goto LABEL_98;
                case 3:
                  if ( (1 << *(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12284)) & *(unsigned __int8 *)(v18 + 995) )
                    goto LABEL_98;
                  break;
                default:
                  break;
              }
            }
            if ( v117 )
            {
              v52 = (char *)&v107;
              v53 = (char *)(v18 + 28);
              do
              {
                v54 = *v52;
                *v53 = *v52;
                if ( !v54 )
                  break;
                v55 = v52[1];
                v52 += 2;
                v53[1] = v55;
                v53 += 2;
              }
              while ( v55 );
              a1 = v18 + 28;
              *(_WORD *)(v18 + 77) = 200;
              *(_WORD *)(v18 + 79) = 2;
            }
          }
        }
        sub_52E90(v18, 0, v118);
        goto LABEL_215;
      case 0x2C:
        v32 = *(unsigned __int8 *)(v18 + 992);
        *(_BYTE *)(v18 + 994) = 0;
        *(_BYTE *)(v18 + 48 * v32 + 81) = 0;
        sub_6E450(0, *(_WORD *)(v18 + 7), 14);
        goto LABEL_215;
      default:
        goto LABEL_215;
    }
    do
    {
      v62 = 2 * v112;
      if ( !*(_WORD *)(2 * v112 + *(_DWORD *)(v113 + 164) + 819) )
      {
        v63 = (*(int (__cdecl **)(int))((char *)&off_D781E + 14 * v112))(v113 + 76);
        if ( v63 )
        {
          a1 = dword_D41A0 + 28302;
          *(_BYTE *)(v63 + 12) |= 1u;
          v115 = 168;
          v64 = v113 - a1;
          *(_DWORD *)(v63 + 136) = 0;
          *(_WORD *)(v63 + 40) = v64 / 168;
          *(_WORD *)(v62 + *(_DWORD *)(v113 + 164) + 819) = (v63 - a1) / 168;
          for ( n = 0; n < 10; ++n )
          {
            v66 = *(_DWORD *)(v113 + 164) + n;
            if ( *(char *)(v66 + 923) == -1 )
            {
              *(_BYTE *)(v66 + 923) = v112;
              break;
            }
          }
        }
      }
      ++v112;
    }
    while ( v112 < 26 );
    for ( ii = dword_EA3E8; ii < dword_EB384; ii += 168 )
    {
      if ( *(_BYTE *)(ii + 63) == 11 )
        *(_BYTE *)(ii + 12) &= 0xFEu;
    }
    sub_52D70(v116, aCheatAccessAll);
LABEL_215:
    v99 = *(_DWORD *)(v113 + 164);
    v100 = 2 * *(char *)(v114 + 3) - *(signed __int16 *)(v99 + 341);
    *(_WORD *)(v99 + 4) = (signed int)(v100 - (__CFSHL__(HIDWORD(v100), 2) + 4 * HIDWORD(v100))) >> 2;
    v101 = *(_DWORD *)(v113 + 164);
    v102 = 2 * *(char *)(v114 + 4) - *(signed __int16 *)(v101 + 343);
    LODWORD(v102) = (signed int)(v102 - (__CFSHL__(HIDWORD(v102), 2) + 4 * HIDWORD(v102))) >> 2;
    HIDWORD(v102) = v114;
    *(_WORD *)(v101 + 6) = v102;
    **(_DWORD **)(v113 + 164) = *(unsigned __int8 *)(HIDWORD(v102) + 5);
    *(_WORD *)(*(_DWORD *)(v113 + 164) + 24) = *(_WORD *)(v114 + 6);
    *(_WORD *)(*(_DWORD *)(v113 + 164) + 26) = *(_WORD *)(v114 + 8);
    v103 = dword_EA3E4[*(unsigned __int16 *)(v18 + 10)];
    sub_57B20(v18, v103);
    if ( *(_BYTE *)(v18 + 2118) )
      sub_55C60(a1, v103, v18);
    a1 = v114;
    v18 += 2124;
    v104 = v116 + 1;
    memset(v114, 0, 10);
    v116 = v104;
    v114 = a1 + 10;
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98805: using guessed type _DWORD __cdecl toupper(_DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D781E: using guessed type int (__cdecl *off_D781E)(int);
// DA82E: using guessed type __int16 word_DA82E[];
// EA0B8: using guessed type int dword_EA0B8;
// EA3E4: using guessed type int dword_EA3E4[];
// EA3E8: using guessed type int dword_EA3E8;
// EB384: using guessed type int dword_EB384;

//----- (00052D70) --------------------------------------------------------
char __cdecl sub_52D70(unsigned __int16 a1, char *a2)
{
  char *v2; // esi
  int v3; // edx
  char *v4; // edi
  char result; // al

  v2 = a2;
  v3 = dword_D41A0 + 11230 + 2124 * a1;
  v4 = (char *)(v3 + 28);
  do
  {
    result = *v2;
    *v4 = *v2;
    if ( !result )
      break;
    result = v2[1];
    v2 += 2;
    v4[1] = result;
    v4 += 2;
  }
  while ( result );
  *(_WORD *)(v3 + 77) = 100;
  *(_WORD *)(v3 + 79) = 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00052E90) --------------------------------------------------------
char __cdecl sub_52E90(int a1, signed int a2, char a3)
{
  int v3; // edx
  unsigned __int16 v4; // ax
  __int16 v5; // ax
  int v6; // edx
  unsigned __int16 v8; // [esp+0h] [ebp-4h]

  v3 = dword_D41A0;
  v4 = *(unsigned __int8 *)(a1 + 991);
  *(_BYTE *)(a1 + 991) = a2;
  v8 = v4;
  if ( *(_WORD *)(a1 + 7) != *(_WORD *)(v3 + 12) )
    return sub_53120();
  *(_BYTE *)(dword_D41A4 + 38544) = v4;
  sub_87C10();
  if ( (_WORD)a2 )
  {
    sub_41AF0();
  }
  else if ( v8 )
  {
    sub_41B60();
  }
  if ( (_WORD)a2 && ((unsigned __int16)a2 < 6u || (unsigned __int16)a2 > 7u) )
  {
    if ( word_1805C2 == 7 || word_1805C2 == 1 || word_1805C2 == 2 )
      sub_8CD27(6 * (unsigned __int8)byte_D419E + dword_EB394);
  }
  else if ( *(_BYTE *)(dword_D41A4 + 24) & 1 )
  {
    if ( word_1805C2 != 7 && word_1805C2 != 1 && word_1805C2 != 2 )
      sub_8CD27(dword_EB394);
    else
      sub_8CD27(dword_EB394 + 6 * (unsigned __int8)byte_D419E);
  }
  else
  {
    sub_8CD27(dword_EB394);
  }
  switch ( (_WORD)a2 )
  {
    case 3:
    case 7:
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
      *(_BYTE *)(dword_D41A0 + 224772) = 0;
      break;
    default:
      break;
  }
  switch ( v8 )
  {
    case 0u:
    case 6u:
      if ( (_WORD)a2 == v8 && !(*(_BYTE *)(dword_D41A4 + 24) & 1) )
        sub_548B0((__int16 *)a1);
      break;
    case 3u:
    case 5u:
    case 8u:
    case 9u:
    case 0xAu:
    case 0xBu:
    case 0xCu:
    case 0xDu:
    case 0xEu:
      sub_548B0((__int16 *)a1);
      sub_473B0();
      break;
    default:
      break;
  }
  switch ( (_WORD)a2 )
  {
    case 0:
    case 6:
      if ( (_WORD)a2 == v8 && *(_BYTE *)(dword_D41A4 + 24) & 1 )
      {
        sub_6EDB0();
        goto LABEL_31;
      }
      break;
    case 3:
    case 5:
    case 8:
LABEL_31:
      sub_548F0((_WORD *)a1);
      break;
    case 9:
    case 0xB:
      sub_1A280();
      v5 = sub_1A4A0();
      v6 = dword_D41A4;
      *(_BYTE *)(dword_D41A4 + 225) = 1;
      *(_WORD *)(v6 + 186) = v5;
      sub_548F0((_WORD *)a1);
      break;
    case 0xA:
    case 0xC:
      sub_548F0((_WORD *)a1);
      sub_19D60(a2, a1);
      break;
    case 0xD:
    case 0xE:
      sub_548F0((_WORD *)a1);
      sub_1A030();
      break;
    default:
      break;
  }
  if ( (unsigned __int16)a2 >= 5u )
  {
    if ( (unsigned __int16)a2 > 5u )
    {
      if ( (_WORD)a2 != 8 )
        goto LABEL_40;
      a3 = 0;
    }
    *(_BYTE *)(a1 + 2109) = 0;
    sub_6D200(a1);
    sub_473B0();
  }
LABEL_40:
  if ( v8 >= 5u && (v8 <= 5u || v8 == 8) )
    a3 = 0;
  switch ( (_WORD)a2 )
  {
    case 6:
    case 7:
    case 8:
    case 0xB:
    case 0xC:
    case 0xE:
      sub_2CA60(384, 0, 256, 400);
      break;
    default:
      sub_2CA90(*(char *)(dword_D41A0 + 8589));
      break;
  }
  if ( a3 )
    sub_6E450(0, *(_WORD *)(a1 + 7), 14);
  return sub_53120();
}
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EB394: using guessed type int dword_EB394;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (00053120) --------------------------------------------------------
char sub_53120()
{
  int v0; // eax

  LOBYTE(v0) = dword_D41A4;
  if ( !(*(_BYTE *)(dword_D41A4 + 26) & 7) )
  {
    LOBYTE(v0) = *(_BYTE *)(dword_D41A4 + 52) & 3;
    if ( (_BYTE)v0 == 1 )
    {
      LOWORD(v0) = sub_10010();
      if ( !v0 )
      {
        LOBYTE(v0) = dword_D41A0;
        *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11234) = 2;
      }
    }
  }
  return v0;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00053160) --------------------------------------------------------
int sub_53160()
{
  int v0; // ebx
  int v1; // esi
  int v2; // eax
  __int16 v3; // ax
  __int16 v4; // dx
  int v5; // eax
  char *v6; // edi
  char *v7; // esi
  char v8; // al
  char v9; // al
  int result; // eax
  _BYTE *v11; // [esp+4h] [ebp-Ch]
  unsigned __int16 v12; // [esp+8h] [ebp-8h]
  char v13; // [esp+Ch] [ebp-4h]

  v13 = 1;
  v12 = 0;
  v11 = (_BYTE *)(dword_D41A0 + 28222);
  v0 = dword_D41A0 + 11230;
  do
  {
    memset(v11, 0, 10);
    qmemcpy((void *)(dword_D41A4 + 256), (const void *)v0, 0x84Cu);
    memset(v0, 0, 2124);
    v1 = dword_D41A4 + 2255;
    qmemcpy((void *)(v0 + 1999), (const void *)(dword_D41A4 + 2255), 0x18u);
    qmemcpy((void *)(v0 + 2023), (const void *)(v1 + 24), 2u);
    if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
      v13 = 0;
    if ( v13 )
      sub_549A0(v0 + 1609, dword_D41A4 + 1865);
    v2 = dword_D41A4;
    *(_DWORD *)(v0 + 24) = *(_DWORD *)(dword_D41A4 + 280);
    *v11 = 1;
    *(_WORD *)(v0 + 7) = v12;
    if ( !(*(_BYTE *)(v2 + 22) & 0x10) && v12 != *(signed __int16 *)(dword_D41A0 + 12) )
      *(_BYTE *)(v0 + 9) = 1;
    *(_WORD *)(v0 + 16) = 32;
    *(_WORD *)(v0 + 477) = 128;
    v3 = *(_WORD *)(v0 + 16);
    *(_BYTE *)(v0 + 993) = 2;
    v4 = 0;
    *(_WORD *)(v0 + 14) = v3 - 1;
    while ( v4 < (signed int)*(unsigned __int16 *)(v0 + 16) )
    {
      v5 = 7 * v4++;
      *(_DWORD *)(v0 + 2 * v5 + 479) = *(_DWORD *)(v0 + 465);
      *(_DWORD *)(v0 + 2 * v5 + 483) = *(_DWORD *)(v0 + 469);
      *(_DWORD *)(v0 + 2 * v5 + 487) = *(_DWORD *)(v0 + 473);
      *(_WORD *)(v0 + 2 * v5 + 491) = *(_WORD *)(v0 + 477);
    }
    if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
      *(_BYTE *)(v0 + 1446) = byte_E131C[v12];
    v6 = (char *)(v0 + 927);
    v7 = (&off_D93A0)[sub_61790(v12)];
    do
    {
      v8 = *v7;
      *v6 = *v7;
      if ( !v8 )
        break;
      v9 = v7[1];
      v7 += 2;
      v6[1] = v9;
      v6 += 2;
    }
    while ( v9 );
    result = sub_54A50(v12, v0);
    v0 += 2124;
    v11 += 10;
    ++v12;
  }
  while ( v12 < 8u );
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D93A0: using guessed type char *off_D93A0;

//----- (000533B0) --------------------------------------------------------
char __cdecl sub_533B0(__int16 a1, void *a2)
{
  int v2; // edi
  int v3; // ebx
  int v5; // esi
  int *v6; // eax
  int v7; // edi
  char v8; // [esp+0h] [ebp-44h]
  int v9; // [esp+40h] [ebp-4h]

  v2 = dword_E9C38;
  if ( a1 < 1000 )
  {
    sprintf(&v8, aCSSLevelsDat, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aClevels);
    v3 = sub_98817((int)&v8, 512);
    if ( v3 == -1 )
    {
      v3 = sub_98817((int)aLevelsLevelsDa, 512);
      if ( v3 == -1 )
        return 0;
    }
    sprintf(&v8, aCSSLevelsTab, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aClevels);
    v5 = sub_98817((int)&v8, 512);
    if ( v5 == -1 )
    {
      v5 = sub_98817((int)aLevelsLevelsTa, 512);
      if ( v5 == -1 )
      {
        sub_98882(v3);
        return 0;
      }
    }
    sub_988A7(v5, v2, 4000);
    v6 = (int *)(v2 + 4 * a1);
    v7 = *v6;
    v9 = v6[1] - *v6;
    sub_98882(v5);
    if ( filelength )
    {
      sub_9891E(v3, v7, 0);
      sub_988A7(v3, dword_E9C38, v9);
      if ( sub_9894C(dword_E9C38, (char *)dword_E9C38) < 0 )
      {
        printf(aErrorDecompres);
        return 0;
      }
      qmemcpy(a2, (const void *)dword_E9C38, 0x6604u);
      memset(dword_E9C38, 0, 26116);
    }
    sub_98882(v3);
    sub_56C00((int)a2);
    sub_53590((int)a2);
  }
  return 1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// D41A4: using guessed type int dword_D41A4;
// E9C38: using guessed type int dword_E9C38;

//----- (00053590) --------------------------------------------------------
int __cdecl sub_53590(int a1)
{
  int result; // eax

  result = *(unsigned __int16 *)(a1 + 2);
  *(_DWORD *)(dword_D41A0 + 4) = result;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00053770) --------------------------------------------------------
char __cdecl sub_53770(__int16 a1)
{
  int v1; // eax
  char v3; // [esp+0h] [ebp-40h]

  sprintf(&v3, aSGam05dDat, aMovie, a1);
  v1 = sub_98817((int)&v3, 512);
  if ( v1 == -1 )
    return 0;
  sub_98882(v1);
  return 1;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (00053950) --------------------------------------------------------
char __cdecl sub_53950(__int16 a1)
{
  int v1; // eax
  char v3; // [esp+0h] [ebp-40h]

  sprintf(&v3, aSMap05dDat, aMovie, a1);
  v1 = sub_98817((int)&v3, 512);
  if ( v1 == -1 )
    return 0;
  sub_98882(v1);
  return 1;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (000539A0) --------------------------------------------------------
char sub_539A0()
{
  int v0; // eax
  int v1; // ebx
  char v3; // [esp+0h] [ebp-4h]

  v3 = 1;
  v0 = sub_98817((int)aDataBldgprmDat, 512);
  v1 = v0;
  if ( v0 < 0 )
    return 0;
  sub_988A7(v0, (int)word_D93C0, 304);
  sub_98882(v1);
  return v3;
}
// D93C0: using guessed type __int16 word_D93C0[];

//----- (00053A40) --------------------------------------------------------
void __cdecl sub_53A40(char *a1)
{
  char v1; // ah
  int v2; // eax
  int v3; // edx
  int v4; // edx
  char v5; // al
  int v6; // ecx
  char v7; // dh
  int v8; // edi
  int v9; // eax
  int v10; // edx
  int v11; // edx
  char v12; // ch
  int v13; // eax
  char v14; // [esp+0h] [ebp-48h]
  char v15; // [esp+40h] [ebp-8h]
  char v16; // [esp+44h] [ebp-4h]

  v1 = *(_BYTE *)(dword_D41A4 + 22);
  if ( v1 & 4 )
  {
    v15 = 0;
    if ( !*(_DWORD *)(dword_D41A4 + 35) && !((signed int)&a1[-dword_D41A0 - 28222] / 10) )
    {
      sprintf(&v14, aSMvi05dDat, aMovie, *(signed __int16 *)(dword_D41A4 + 39));
      v2 = sub_98817((int)&v14, 512);
      v3 = dword_D41A4;
      *(_DWORD *)(dword_D41A4 + 35) = v2;
      if ( v2 <= -1 || !sub_54D30(*(_WORD *)(v3 + 39)) )
        v15 = 1;
      if ( v15 )
      {
        v4 = dword_D41A4;
        v5 = *(_BYTE *)(dword_D41A4 + 22);
        *(_DWORD *)(dword_D41A4 + 35) = 0;
        *(_BYTE *)(v4 + 22) = v5 & 0xFB;
      }
      else
      {
        sub_53C70();
      }
    }
    if ( v15 )
      goto LABEL_21;
    v6 = *(_DWORD *)(dword_D41A4 + 35);
    if ( !v6 )
      goto LABEL_21;
    if ( *a1 != 2 && sub_988A7(v6, (int)a1, 10) == 10 )
    {
      v7 = *a1;
      if ( *a1 == 13 )
      {
        *a1 = 0;
        goto LABEL_21;
      }
      if ( v7 != 2 && v7 != 29 && !sub_473E0() )
        goto LABEL_21;
    }
    v15 = 1;
LABEL_21:
    if ( v15 )
    {
      sub_53CC0();
      *(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) = 8;
      sub_53CA0();
      *a1 = 0;
    }
    return;
  }
  if ( v1 & 2 )
  {
    v8 = *(_DWORD *)(dword_D41A4 + 35);
    v16 = 0;
    if ( !v8 && !((signed int)&a1[-dword_D41A0 - 28222] / 10) )
    {
      sprintf(&v14, aSMvi05dDat, aMovie, *(signed __int16 *)(dword_D41A4 + 39));
      v9 = sub_98817((int)&v14, 546);
      v10 = dword_D41A4;
      *(_DWORD *)(dword_D41A4 + 35) = v9;
      if ( v9 <= -1 || !sub_54F00(*(_WORD *)(v10 + 39)) )
        v16 = 1;
      if ( v16 )
      {
        v11 = dword_D41A4;
        v12 = *(_BYTE *)(dword_D41A4 + 22);
        *(_DWORD *)(dword_D41A4 + 35) = 0;
        *(_BYTE *)(v11 + 22) = v12 & 0xFD;
      }
      else
      {
        sub_53C70();
      }
    }
    if ( !v16 )
    {
      v13 = *(_DWORD *)(dword_D41A4 + 35);
      if ( v13 )
      {
        if ( sub_98CAA(v13, (int)a1, 10) != 10 )
          sub_53CC0();
        if ( *a1 == 12 )
          *a1 = 0;
      }
    }
  }
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00053C70) --------------------------------------------------------
int sub_53C70()
{
  int result; // eax
  int v1; // edx

  result = dword_D41A4;
  *(_DWORD *)(dword_D41A4 + 26) = 0;
  v1 = *(_DWORD *)(result + 22);
  *(_DWORD *)(result + 30) = 0;
  *(_DWORD *)(result + 22) = v1 | 0x1208000;
  return result;
}
// D41A4: using guessed type int dword_D41A4;

//----- (00053CA0) --------------------------------------------------------
int sub_53CA0()
{
  int result; // eax

  result = dword_D41A4;
  *(_DWORD *)(result + 22) &= 0xFEDF7FFF;
  return result;
}
// D41A4: using guessed type int dword_D41A4;

//----- (00053CC0) --------------------------------------------------------
int sub_53CC0()
{
  int result; // eax
  char v1; // dl

  result = dword_D41A4;
  if ( *(_DWORD *)(dword_D41A4 + 35) )
  {
    sub_98882(*(_DWORD *)(dword_D41A4 + 35));
    result = dword_D41A4;
    v1 = *(_BYTE *)(dword_D41A4 + 22);
    *(_DWORD *)(dword_D41A4 + 35) = 0;
    *(_BYTE *)(result + 22) = v1 & 0xD9;
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;

//----- (00053CF0) --------------------------------------------------------
int __cdecl sub_53CF0(int a1)
{
  return access(a1, 0);
}
// 98CF2: using guessed type _DWORD __cdecl access(_DWORD, _DWORD);

//----- (00053D10) --------------------------------------------------------
char __cdecl sub_53D10(unsigned __int8 a1, int a2, char *a3)
{
  char result; // al
  char *v4; // esi
  char *v5; // edi
  char v6; // al
  char v7; // al
  char *v8; // esi
  char *v9; // edi
  char v10; // al
  char v11; // al
  char *v12; // esi
  char *v13; // edi
  char v14; // al
  char v15; // al
  char v16; // [esp+0h] [ebp-12h]
  char v17[144]; // [esp+90h] [ebp+7Eh]
  char v18; // [esp+120h] [ebp+10Eh]

  if ( dos_getdiskfree(a1 - 64, &v18) )
    return 1;
  sprintf(&v16, aCS, a1, a2);
  if ( (signed __int16)sub_53CF0((int)&v16) <= -1 && mkdir(&v16) )
    return 2;
  v4 = &v16;
  v5 = v17;
  do
  {
    v6 = *v4;
    *v5 = *v4;
    if ( !v6 )
      break;
    v7 = v4[1];
    v4 += 2;
    v5[1] = v7;
    v5 += 2;
  }
  while ( v7 );
  v8 = &aVe[2];
  v9 = &v17[strlen(v17)];
  do
  {
    v10 = *v8;
    *v9 = *v8;
    if ( !v10 )
      break;
    v11 = v8[1];
    v8 += 2;
    v9[1] = v11;
    v9 += 2;
  }
  while ( v11 );
  v12 = a3;
  v13 = &v17[strlen(v17)];
  do
  {
    v14 = *v12;
    *v13 = *v12;
    if ( !v14 )
      break;
    v15 = v12[1];
    v12 += 2;
    v13[1] = v15;
    v13 += 2;
  }
  while ( v15 );
  if ( (sub_53CF0((int)v17) & 0x8000u) != 0 && mkdir(v17) )
    result = 2;
  else
    result = 3;
  return result;
}
// 8C1E8: using guessed type _DWORD __cdecl dos_getdiskfree(_DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98D30: using guessed type _DWORD __cdecl mkdir(_DWORD);
// 53D10: using guessed type char var_98[144];

//----- (00053E60) --------------------------------------------------------
int __cdecl sub_53E60(int a1, char *a2)
{
  int result; // eax
  int v3; // ebx
  int v4; // esi

  result = sub_98817(a1, 512);
  v3 = result;
  if ( result != -1 )
  {
    v4 = filelength(result);
    sub_988A7(v3, (int)a2, v4);
    sub_98882(v3);
    result = sub_9894C((int)a2, a2);
    if ( result >= 0 )
    {
      if ( !result )
        result = v4;
    }
    else
    {
      printf(aErrorDecompres_0);
      result = -2;
    }
  }
  return result;
}
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);

//----- (00053EF0) --------------------------------------------------------
int __cdecl sub_53EF0(int a1, int a2)
{
  int v2; // eax
  int v3; // ebx
  int v4; // esi
  int v5; // eax
  int v6; // edi
  unsigned __int8 v8; // [esp+0h] [ebp-4h]

  v8 = 0;
  v2 = sub_98817(a1, 512);
  v3 = v2;
  v4 = v2;
  v5 = sub_98817(a2, 512);
  v6 = v5;
  if ( v3 == -1 || v5 == -1 )
    v8 = 1;
  if ( v4 > -1 )
    sub_98882(v4);
  if ( v6 > -1 )
    sub_98882(v6);
  return v8;
}

//----- (00053F60) --------------------------------------------------------
bool __cdecl sub_53F60(int a1)
{
  return (unsigned __int16)access(a1, 0) == 0;
}
// 98CF2: using guessed type _DWORD __cdecl access(_DWORD, _DWORD);

//----- (00053F80) --------------------------------------------------------
char __cdecl sub_53F80(int a1, int a2, int a3)
{
  int v3; // ebx
  int v4; // esi
  int v5; // eax
  int v6; // edi
  int v8; // ebx
  int v9; // edi
  signed int v10; // ebx
  int v11; // eax
  int v12; // esi
  int v13; // esi
  int v14; // eax
  char v15; // [esp+0h] [ebp-194h]
  char v16; // [esp+90h] [ebp-104h]
  char v17; // [esp+120h] [ebp-74h]
  int v18; // [esp+184h] [ebp-10h]
  int v19; // [esp+188h] [ebp-Ch]
  int v20; // [esp+18Ch] [ebp-8h]
  int v21; // [esp+190h] [ebp-4h]

  if ( !sub_53F60(a1) )
    return 2;
  if ( !sub_53F60(a2) )
    return 1;
  sprintf(&v15, aSSTab, a1, a3);
  sprintf(&v16, aSSTab, a2, a3);
  v3 = sub_98817((int)&v15, 512);
  if ( v3 == -1 )
    return 3;
  v4 = sub_98817((int)&v16, 546);
  if ( v4 == -1 )
    return 3;
  v5 = filelength(v3);
  v6 = sub_988A7(v3, dword_180628, v5);
  v19 = sub_98CAA(v4, dword_180628, v6);
  sub_98882(v3);
  sub_98882(v4);
  if ( v6 != v19 )
    return 3;
  sprintf(&v15, aSSDat, a1, a3);
  sprintf(&v16, aSSDat, a2, a3);
  v8 = sub_98817((int)&v15, 512);
  v21 = v8;
  if ( v8 == -1 )
    return 3;
  v9 = sub_98817((int)&v16, 546);
  if ( v9 == -1 )
    return 3;
  v10 = filelength(v8);
  v18 = v10;
  v20 = 0;
  while ( v10 )
  {
    if ( v10 <= 64000 )
      v11 = v10;
    else
      v11 = 64000;
    v12 = sub_988A7(v21, dword_180628, v11);
    v10 -= v12;
    if ( sub_98CAA(v9, dword_180628, v12) != v12 )
    {
      sub_98882(v21);
      sub_98882(v9);
      return 3;
    }
    v20 += v12;
    v13 = v20;
    settextposition((signed __int16)dword_F4720, SHIWORD(dword_F4720));
    v14 = 100 * v13 / v18;
    if ( (signed __int16)v14 > 100 )
      LOWORD(v14) = 100;
    sprintf(&v17, aDC, (signed __int16)v14, 37);
    outtext(&v17);
  }
  sub_98882(v21);
  sub_98882(v9);
  memset(dword_180628, 0, 64000);
  return 0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// BD985: using guessed type _DWORD __cdecl settextposition(_DWORD, _DWORD);
// BDBED: using guessed type _DWORD __cdecl outtext(_DWORD);
// F4720: using guessed type int dword_F4720;
// 180628: using guessed type int dword_180628;

//----- (00054200) --------------------------------------------------------
char sub_54200()
{
  signed __int16 v0; // bx
  int v1; // eax
  int v2; // edx
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // edx
  char v10; // [esp+0h] [ebp-2h]
  char v11; // [esp+40h] [ebp+3Eh]
  int v12; // [esp+80h] [ebp+7Eh]

  v12 = 0;
  outtext(aCheckingSetupV);
  v0 = 1;
  sprintf(&v10, aCSSS, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata, aVersionDat);
  sub_53E60((int)&v10, (char *)&v12);
  if ( v12 != 60 )
    HIBYTE(v0) = 1;
  outtext(asc_D0650);
  sprintf(&v10, aCSSSDat, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata, aTmaps00);
  sprintf(&v11, aDataSDat, aTmaps00);
  if ( HIBYTE(v0) || (unsigned __int16)sub_53EF0((int)&v10, (int)&v11) )
  {
    v1 = outtext(aCreatingSetupD);
    dword_F4720 = gettextposition(v1, v2, v0);
    sprintf(&v10, aCSS, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata);
    if ( sub_53F80((int)aData, (int)&v10, (int)aTmaps00) )
      LOBYTE(v0) = 0;
    outtext(asc_D0650);
  }
  if ( (_BYTE)v0 )
  {
    sprintf(&v10, aCSSSDat, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata, aTmaps10);
    sprintf(&v11, aDataSDat, aTmaps10);
    if ( HIBYTE(v0) || (unsigned __int16)sub_53EF0((int)&v10, (int)&v11) )
    {
      v3 = outtext(aCreatingSetupD_0);
      dword_F4720 = gettextposition(v3, v4, v0);
      sprintf(&v10, aCSS, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata);
      if ( sub_53F80((int)aData, (int)&v10, (int)aTmaps10) )
        LOBYTE(v0) = 0;
      outtext(asc_D0650);
    }
  }
  if ( (_BYTE)v0 )
  {
    sprintf(&v10, aCSSSDat, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata, aTmaps20);
    sprintf(&v11, aDataSDat, aTmaps20);
    if ( HIBYTE(v0) || (unsigned __int16)sub_53EF0((int)&v10, (int)&v11) )
    {
      v5 = outtext(aCreatingSetupD_1);
      dword_F4720 = gettextposition(v5, v6, v0);
      sprintf(&v10, aCSS, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata);
      if ( sub_53F80((int)aData, (int)&v10, (int)aTmaps20) )
        LOBYTE(v0) = 0;
      outtext(asc_D0650);
    }
  }
  if ( (_BYTE)v0 && !(*(_BYTE *)(dword_D41A4 + 22) & 8) )
  {
    sprintf(&v10, aCSSLevelsDat, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aClevels);
    v7 = outtext(aSettingUpLevel);
    dword_F4720 = gettextposition(v7, v8, v0);
    sprintf(&v10, aCSS, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aClevels);
    if ( sub_53F80((int)aLevels, (int)&v10, (int)aLevels) )
      LOBYTE(v0) = 0;
    outtext(asc_D0650);
  }
  if ( (_BYTE)v0 && HIBYTE(v0) )
  {
    sprintf(&v10, aCSSS, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata, aVersionDat);
    v12 = 60;
    sub_98C48((int)&v10, (int)&v12, 4);
  }
  return v0;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// BD953: using guessed type int __fastcall gettextposition(_DWORD, _DWORD, _DWORD);
// BDBED: using guessed type _DWORD __cdecl outtext(_DWORD);
// D41A4: using guessed type int dword_D41A4;
// F4720: using guessed type int dword_F4720;

//----- (00054600) --------------------------------------------------------
int sub_54600()
{
  int result; // eax
  char v1; // [esp+0h] [ebp-38h]
  __int16 v2; // [esp+1Ch] [ebp-1Ch]

  v2 = 0;
  result = int386(51, &v2, &v1);
  dword_E3768 = 0;
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E3768: using guessed type int dword_E3768;

//----- (00054630) --------------------------------------------------------
__int16 __cdecl sub_54630(__int16 a1)
{
  __int16 result; // ax

  result = a1;
  if ( (unsigned __int16)a1 >= 0x10u )
  {
    if ( (unsigned __int16)a1 <= 0x10u )
    {
      result = sub_84250((int)aDataBlock16Dat);
    }
    else if ( a1 == 32 )
    {
      result = sub_84250((int)aDataBlock32Dat);
    }
  }
  return result;
}

//----- (00054660) --------------------------------------------------------
int __cdecl sub_54660(unsigned __int8 a1, int a2)
{
  int result; // eax

  result = a2;
  if ( a1 < 1u )
  {
    if ( !a1 )
    {
      if ( (unsigned __int16)a2 >= 0x10u )
      {
        if ( (unsigned __int16)a2 <= 0x10u )
        {
          sub_53E60((int)aDataBlock16Dat_0, (char *)dword_E9C2C);
          sub_53E60((int)aDataSkyd00Dat, off_D41A8);
        }
        else if ( (_WORD)a2 == 32 )
        {
          sub_53E60((int)aDataBlock32Dat_0, (char *)dword_E9C2C);
          sub_53E60((int)aDataSkyd00Dat, off_D41A8);
        }
      }
      result = sub_53E60((int)aDataTmaps00Tab, (char *)dword_F6ED0);
    }
  }
  else if ( a1 <= 1u )
  {
    if ( (unsigned __int16)a2 >= 0x10u )
    {
      if ( (unsigned __int16)a2 <= 0x10u )
      {
        if ( *(_BYTE *)(dword_D41A0 + 196306) & 2 )
          sub_53E60((int)aDataBl16f00Dat, (char *)dword_E9C2C);
        else
          sub_53E60((int)aDataBl16n00Dat, (char *)dword_E9C2C);
        sub_53E60((int)aDataSkyn00Dat, off_D41A8);
      }
      else if ( (_WORD)a2 == 32 )
      {
        if ( *(_BYTE *)(dword_D41A0 + 196306) & 2 )
          sub_53E60((int)aDataBl32f00Dat, (char *)dword_E9C2C);
        else
          sub_53E60((int)aDataBl32n00Dat, (char *)dword_E9C2C);
        sub_53E60((int)aDataSkyn00Dat, off_D41A8);
      }
    }
    result = sub_53E60((int)aDataTmaps10Tab, (char *)dword_F6ED0);
  }
  else if ( a1 == 2 )
  {
    if ( (unsigned __int16)a2 >= 0x10u )
    {
      if ( (unsigned __int16)a2 <= 0x10u )
      {
        sub_53E60((int)aDataBl16c00Dat, (char *)dword_E9C2C);
      }
      else if ( (_WORD)a2 == 32 )
      {
        sub_53E60((int)aDataBl32c00Dat, (char *)dword_E9C2C);
      }
    }
    result = sub_53E60((int)aDataTmaps20Tab, (char *)dword_F6ED0);
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A8: using guessed type char *off_D41A8;
// E9C2C: using guessed type int dword_E9C2C;
// F6ED0: using guessed type int dword_F6ED0;

//----- (00054800) --------------------------------------------------------
char __cdecl sub_54800(unsigned __int8 a1)
{
  char result; // al

  result = a1;
  if ( a1 < 1u )
  {
    if ( !a1 )
    {
      result = sub_53E60((int)aDataTablesdDat, byte_F6EE0);
      word_D4B7E = 0;
      word_D4B7C = 254;
    }
  }
  else if ( a1 <= 1u )
  {
    result = sub_53E60((int)aDataTablesnDat, byte_F6EE0);
    word_D4B7E = 255;
    word_D4B7C = 0;
  }
  else if ( a1 == 2 )
  {
    sub_53E60((int)aDataTablescDat, byte_F6EE0);
    result = -1;
    word_D4B7C = 254;
    word_D4B7E = 255;
  }
  return result;
}
// D4B7C: using guessed type __int16 word_D4B7C;
// D4B7E: using guessed type __int16 word_D4B7E;

//----- (000548B0) --------------------------------------------------------
__int16 __cdecl sub_548B0(__int16 *a1)
{
  __int16 result; // ax

  result = *(__int16 *)((char *)a1 + 7);
  if ( result == *(_WORD *)(dword_D41A0 + 12) )
    result = sub_5BDC0(a1[509], a1[510]);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (000548F0) --------------------------------------------------------
_WORD *__cdecl sub_548F0(_WORD *a1)
{
  _WORD *result; // eax
  __int16 v2; // dx

  result = a1;
  if ( *(_WORD *)((char *)a1 + 7) == *(_WORD *)(dword_D41A0 + 12) )
  {
    if ( word_1805C2 != 7 && word_1805C2 != 1 && word_1805C2 != 2 )
    {
      a1[509] = dword_1805B0;
      v2 = dword_1805B4;
    }
    else
    {
      a1[509] = word_E3760;
      v2 = word_E3762;
    }
    a1[510] = v2;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E3760: using guessed type __int16 word_E3760;
// E3762: using guessed type __int16 word_E3762;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (00054960) --------------------------------------------------------
int sub_54960()
{
  signed __int16 v0; // ax

  if ( word_180660 & 1 )
    v0 = 400;
  else
    v0 = 480;
  return sub_5BDC0(426, v0 - 72 + 17);
}
// 180660: using guessed type __int16 word_180660;

//----- (000549A0) --------------------------------------------------------
signed int __cdecl sub_549A0(int a1, int a2)
{
  signed int result; // eax

  qmemcpy((void *)(a1 + 390), (const void *)(a2 + 390), 0x18u);
  qmemcpy((void *)(a1 + 414), (const void *)(a2 + 414), 2u);
  qmemcpy((void *)a1, (const void *)a2, 0x68u);
  qmemcpy((void *)(a1 + 442), (const void *)(a2 + 442), 0x18u);
  qmemcpy((void *)(a1 + 466), (const void *)(a2 + 466), 2u);
  qmemcpy((void *)(a1 + 338), (const void *)(a2 + 338), 0x18u);
  qmemcpy((void *)(a1 + 362), (const void *)(a2 + 362), 2u);
  result = 26;
  qmemcpy((void *)(a1 + 468), (const void *)(a2 + 468), 0x18u);
  qmemcpy((void *)(a1 + 492), (const void *)(a2 + 492), 2u);
  return result;
}

//----- (00054A50) --------------------------------------------------------
int __cdecl sub_54A50(unsigned __int16 a1, int a2)
{
  signed int i; // eax
  int v3; // eax
  unsigned __int16 v4; // cx
  signed int v5; // esi
  int result; // eax
  int v7; // ebx
  char v8; // bl
  int v9; // ST00_4
  _BOOL1 v10; // zf
  int v11; // edi
  signed int v12; // [esp+1Ch] [ebp-14h]
  int v13; // [esp+20h] [ebp-10h]
  int v14; // [esp+24h] [ebp-Ch]
  int v15; // [esp+28h] [ebp-8h]
  signed int v16; // [esp+2Ch] [ebp-4h]

  for ( i = 0; i < 26; *(_BYTE *)(a2 + i + 2076) = 0 )
  {
    *(_WORD *)(a2 + 2 * ++i + 1815) = 0;
    *(_BYTE *)(a2 + i + 2024) = 0;
  }
  *(_WORD *)(a2 + 2103) = -1;
  v3 = dword_D41A4;
  *(_WORD *)(a2 + 2105) = -1;
  if ( *(_BYTE *)(v3 + 22) & 0x10 )
    v4 = 0;
  else
    v4 = a1;
  v5 = 0;
  v15 = 0;
  do
  {
    result = (unsigned __int8)byte_D94FF[v5];
    v7 = result + 110 * v4 + dword_D41A0;
    if ( *(_BYTE *)(v7 + 221435) > 2u )
      *(_BYTE *)(v7 + 221435) = 2;
    if ( *(_BYTE *)(a2 + 9) == 1 )
    {
      *(_BYTE *)(a2 + result + 2051) = *(_BYTE *)(110 * v4 + dword_D41A0 + result + 221435);
    }
    else if ( *(_BYTE *)(dword_D41A4 + 22) & 8 || *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
    {
      v12 = *(unsigned __int8 *)(110 * v4 + dword_D41A0 + result + 221435);
      if ( *(char *)(a2 + result + 2051) < v12 )
      {
        v16 = *(unsigned __int8 *)(110 * v4 + dword_D41A0 + result + 221435);
        if ( v12 < 0 )
          v16 = 0;
        if ( v16 > 2 )
          v16 = 2;
        *(_BYTE *)(a2 + result + 2051) = v16;
        *(_DWORD *)(a2 + 4 * result + 1609) = *(_DWORD *)&byte_DA818[80 * result + 18 + 26 * v16] + 1;
      }
    }
    *(_BYTE *)(a2 + v5 + 1921) = -1;
    v8 = 0;
    v13 = a2 + result;
    if ( *(_BYTE *)(a2 + 9) == 1 )
    {
      v9 = dword_D41A0;
      *(_BYTE *)(v13 + 1973) = *(_BYTE *)(result + 110 * v4 + dword_D41A0 + 221461);
      if ( !*(_BYTE *)(result + 110 * a1 + v9 + 221409) )
        goto LABEL_37;
      v10 = *(_BYTE *)(v13 + 1973) == 0;
      goto LABEL_35;
    }
    v14 = result + 110 * v4 + dword_D41A0;
    if ( *(_BYTE *)(v14 + 221461) )
      goto LABEL_37;
    if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
    {
      if ( !*(_BYTE *)(v14 + 221409) )
        goto LABEL_37;
      v10 = *(_BYTE *)(v14 + 221461) == 0;
LABEL_35:
      if ( !v10 )
        goto LABEL_37;
      goto LABEL_36;
    }
    if ( *(_BYTE *)(dword_D41A4 + 24) >= 0 && *(_WORD *)(dword_D41A4 + 43) )
    {
      if ( !*(_BYTE *)(v13 + 1999) )
        goto LABEL_37;
LABEL_36:
      v8 = 1;
      goto LABEL_37;
    }
    if ( *(_BYTE *)(a2 + result + 1999) )
      goto LABEL_36;
    v11 = result + 110 * v4 + dword_D41A0;
    if ( *(_BYTE *)(v11 + 221409) )
    {
      if ( !*(_BYTE *)(v11 + 221461) )
        goto LABEL_36;
    }
LABEL_37:
    if ( v8 )
    {
      *(_WORD *)(a2 + 2 * result + 1817) = 1;
      *(_BYTE *)(a2 + result + 1999) = 1;
      if ( *(signed __int16 *)(a2 + 2103) == -1 )
      {
        *(_WORD *)(a2 + 2103) = result;
      }
      else if ( *(signed __int16 *)(a2 + 2105) == -1 )
      {
        *(_WORD *)(a2 + 2105) = result;
      }
      result = v15 + 1;
      *(_BYTE *)(a2 + v15 + 1 + 1920) = v15;
      ++v15;
    }
    ++v5;
  }
  while ( v5 < 26 );
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00054D30) --------------------------------------------------------
char __cdecl sub_54D30(__int16 a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax
  _DWORD *v4; // edi
  _DWORD *v5; // edi
  char result; // al
  char v7; // [esp+0h] [ebp-36h]
  int v8; // [esp+80h] [ebp+4Ah]
  int v9; // [esp+84h] [ebp+4Eh]
  int v10; // [esp+88h] [ebp+52h]
  int v11; // [esp+8Ch] [ebp+56h]
  int v12; // [esp+90h] [ebp+5Ah]
  int v13; // [esp+94h] [ebp+5Eh]
  int v14; // [esp+98h] [ebp+62h]
  int v15; // [esp+9Ch] [ebp+66h]
  int v16; // [esp+A0h] [ebp+6Ah]
  int v17; // [esp+A4h] [ebp+6Eh]
  int v18; // [esp+A8h] [ebp+72h]
  int v19; // [esp+ACh] [ebp+76h]
  char v20; // [esp+B0h] [ebp+7Ah]

  v20 = 1;
  v16 = *(_DWORD *)(dword_D41A0 + 8586);
  v17 = *(_DWORD *)(dword_D41A0 + 8590);
  v18 = *(_DWORD *)(dword_D41A0 + 8594);
  v19 = *(_DWORD *)(dword_D41A0 + 8598);
  v12 = *(_DWORD *)(dword_D41A0 + 8602);
  v13 = *(_DWORD *)(dword_D41A0 + 8606);
  v14 = *(_DWORD *)(dword_D41A0 + 8610);
  v15 = *(_DWORD *)(dword_D41A0 + 8614);
  v8 = *(_DWORD *)(dword_D41A0 + 8618);
  v9 = *(_DWORD *)(dword_D41A0 + 8622);
  v10 = *(_DWORD *)(dword_D41A0 + 8626);
  v11 = *(_DWORD *)(dword_D41A0 + 8630);
  sprintf(&v7, aSS03dDat, aMovie, aSmap, a1);
  v1 = sub_98817((int)&v7, 512);
  v2 = v1;
  if ( v1 >= 0 )
  {
    sub_988A7(v1, (int)byte_10B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_11B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_12B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_13B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_14B4E0, (int)sub_10000);
    sub_988A7(v2, (int)word_15B4E0, (int)&loc_20000);
    sub_988A7(v2, (int)byte_F2CD0, 4802);
    sub_98882(v2);
  }
  sprintf(&v7, aSS03dDat, aMovie, aSlev, a1);
  sub_53E60((int)&v7, (char *)dword_D41A0);
  sub_55100(2);
  sub_57680();
  sub_49F90();
  *(_DWORD *)(dword_D41A0 + 4582) = -1;
  sub_71990();
  sub_473B0();
  v3 = dword_D41A0;
  v4 = (_DWORD *)(dword_D41A0 + 8586);
  *v4 = v16;
  ++v4;
  *v4 = v17;
  ++v4;
  *v4 = v18;
  v4[1] = v19;
  *(_DWORD *)(v3 + 8602) = v12;
  *(_DWORD *)(v3 + 8606) = v13;
  *(_DWORD *)(v3 + 8610) = v14;
  *(_DWORD *)(v3 + 8614) = v15;
  v5 = (_DWORD *)(v3 + 8618);
  result = v20;
  *v5 = v8;
  ++v5;
  *v5 = v9;
  ++v5;
  *v5 = v10;
  v5[1] = v11;
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;

//----- (00054F00) --------------------------------------------------------
char __cdecl sub_54F00(__int16 a1)
{
  int v1; // ST0C_4
  int v2; // eax
  int v3; // ebx
  char v5; // [esp+0h] [ebp-6h]
  char v6; // [esp+80h] [ebp+7Ah]

  v6 = 1;
  sub_71930();
  sub_55100(1);
  sprintf(&v5, aSS03dDat, aMovie, aSlev, a1);
  v1 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 224758) = &unk_D83AC;
  sub_98C48((int)&v5, v1, 224791);
  sprintf(&v5, aSS03dDat, aMovie, aSmap, a1);
  v2 = sub_98817((int)&v5, 546);
  v3 = v2;
  if ( v2 >= 0 )
  {
    sub_98CAA(v2, (int)byte_10B4E0, (int)sub_10000);
    sub_98CAA(v3, (int)byte_11B4E0, (int)sub_10000);
    sub_98CAA(v3, (int)byte_12B4E0, (int)sub_10000);
    sub_98CAA(v3, (int)byte_13B4E0, (int)sub_10000);
    sub_98CAA(v3, (int)byte_14B4E0, (int)sub_10000);
    sub_98CAA(v3, (int)word_15B4E0, (int)&loc_20000);
    sub_98CAA(v3, (int)byte_F2CD0, 4802);
    sub_98882(v3);
  }
  sub_55100(2);
  sub_49F90();
  *(_DWORD *)(dword_D41A0 + 4582) = -1;
  return v6;
}
// 10000: using guessed type void __noreturn sub_10000();
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;

//----- (00055080) --------------------------------------------------------
char __cdecl sub_55080(unsigned __int8 a1, int a2)
{
  char v2; // bl

  v2 = 0;
  if ( !(*(_BYTE *)(dword_D41A4 + 22) & 0x10) )
  {
    sub_71930();
    sub_55100(1);
    v2 = sub_55250(a1);
    if ( v2 )
    {
      v2 = sub_55320(a1);
      if ( v2 )
        v2 = sub_55450(a1, a2);
    }
    sub_55100(2);
    sub_49F90();
    *(_DWORD *)(dword_D41A0 + 4582) = -1;
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00055100) --------------------------------------------------------
int __cdecl sub_55100(char a1)
{
  int v1; // edi
  signed int v2; // eax
  int v3; // edx
  signed int v4; // ebx
  int v5; // esi
  int v6; // eax
  unsigned __int8 v7; // cl
  signed int i; // ebx
  unsigned __int8 v9; // al
  int v10; // eax
  unsigned int v11; // ecx
  int result; // eax
  signed int j; // ebx

  v1 = dword_D41A0;
  if ( a1 == 1 )
    v2 = -1;
  else
    v2 = 1;
  v3 = v2 * (dword_D41A0 + 28302);
  v4 = 0;
  v5 = v2 * (dword_D41A0 + 197393);
  while ( v4 < *(unsigned __int8 *)(v1 + 224769) )
  {
    v6 = v1 + 10 * v4;
    if ( !*(_DWORD *)(v6 + 222546) )
      goto LABEL_15;
    v7 = *(_BYTE *)(v6 + 222540);
    if ( v7 < 3u )
    {
      if ( v7 < 1u )
        goto LABEL_15;
LABEL_11:
      v6 = v1 + 10 * v4;
      if ( !(*(_BYTE *)(v6 + 222541) & 1) )
      {
        *(_DWORD *)(v6 + 222546) += v5;
        goto LABEL_15;
      }
LABEL_14:
      *(_DWORD *)(v6 + 222546) += v3;
      goto LABEL_15;
    }
    if ( v7 <= 3u )
    {
      if ( !(*(_BYTE *)(v6 + 222541) & 1) )
        goto LABEL_15;
      goto LABEL_14;
    }
    if ( v7 == 4 )
      goto LABEL_11;
LABEL_15:
    ++v4;
  }
  for ( i = 1; ; ++i )
  {
    result = v1;
    if ( i > *(unsigned __int8 *)(v1 + 224768) )
      break;
    v9 = *(_BYTE *)(v1 + 8 * i + 222708);
    if ( v9 >= 3u && (v9 <= 5u || v9 >= 8u && v9 <= 9u) )
    {
      v10 = v1 + 8 * i;
      if ( !(*(_BYTE *)(v10 + 222709) & 2) )
      {
        v11 = *(_DWORD *)((char *)sub_365F8 + v10);
        if ( v11 >= dword_EA3E4[0] && v11 < dword_EB384 )
          *(_DWORD *)((char *)sub_365F8 + v10) = v3 + v11;
      }
    }
  }
  for ( j = 1; j < 50; ++j )
  {
    result = v1 + 39 * j;
    if ( *(_BYTE *)(result + 222796) )
      *(_DWORD *)(result + 222806) += v3;
  }
  dword_D41A0 = v1;
  return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB384: using guessed type int dword_EB384;

//----- (00055250) --------------------------------------------------------
char __cdecl sub_55250(unsigned __int8 a1)
{
  char v1; // bl
  int v2; // eax
  int v3; // esi
  int v4; // edi
  int v5; // edx
  int v6; // eax
  int v7; // ST14_4
  char v9; // [esp+0h] [ebp-40h]

  v1 = 0;
  sprintf(&v9, aCSSSDDat, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSlev, a1 + 1);
  v2 = dword_D41A0;
  v3 = dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12);
  *(_DWORD *)(dword_D41A0 + 224758) = &unk_D83AC;
  v4 = *(_DWORD *)(v3 + 12621);
  v6 = j___clock(v2, v5, 0);
  v7 = dword_D41A0;
  *(_DWORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12621) = v6 - *(_DWORD *)(v3 + 12621);
  if ( sub_98C48((int)&v9, v7, 224791) == 224791 )
    v1 = 1;
  *(_DWORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12621) = v4;
  return v1;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00055320) --------------------------------------------------------
_BOOL1 __cdecl sub_55320(unsigned __int8 a1)
{
  int v1; // eax
  int v2; // ebx
  char v4; // [esp+0h] [ebp-48h]
  _BOOL1 v5; // [esp+40h] [ebp-8h]
  _BOOL1 v6; // [esp+44h] [ebp-4h]

  v6 = 0;
  sprintf(&v4, aCSSSDDat, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSmap, a1 + 1);
  v1 = sub_98817((int)&v4, 546);
  v2 = v1;
  if ( v1 >= 0 )
  {
    sub_98CAA(v1, (int)byte_10B4E0, (int)sub_10000);
    sub_98CAA(v2, (int)byte_11B4E0, (int)sub_10000);
    sub_98CAA(v2, (int)byte_12B4E0, (int)sub_10000);
    sub_98CAA(v2, (int)byte_13B4E0, (int)sub_10000);
    sub_98CAA(v2, (int)byte_14B4E0, (int)sub_10000);
    sub_98CAA(v2, (int)word_15B4E0, (int)&loc_20000);
    v5 = sub_98CAA(v2, (int)byte_F2CD0, 4802) != 4802;
    sub_98882(v2);
    v6 = v5 == 0;
  }
  return v6;
}
// 10000: using guessed type void __noreturn sub_10000();
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;

//----- (00055450) --------------------------------------------------------
char __cdecl sub_55450(unsigned __int8 a1, int a2)
{
  char v2; // bl
  char v4; // [esp+0h] [ebp-48h]
  int v5; // [esp+40h] [ebp-8h]
  int v6; // [esp+44h] [ebp-4h]

  v6 = a2;
  v5 = 15;
  v2 = 0;
  sprintf(&v4, aCSSSDDat, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSver, a1 + 1);
  if ( sub_98C48((int)&v4, (int)&v5, 8) == 8 )
    v2 = 1;
  return v2;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;

//----- (000555D0) --------------------------------------------------------
char __cdecl sub_555D0(unsigned __int8 a1, int a2)
{
  char v2; // bl
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  _DWORD *v7; // edi
  int v9; // [esp+0h] [ebp-34h]
  int v10; // [esp+4h] [ebp-30h]
  int v11; // [esp+8h] [ebp-2Ch]
  int v12; // [esp+Ch] [ebp-28h]
  int v13; // [esp+10h] [ebp-24h]
  int v14; // [esp+14h] [ebp-20h]
  int v15; // [esp+18h] [ebp-1Ch]
  int v16; // [esp+1Ch] [ebp-18h]
  int v17; // [esp+20h] [ebp-14h]
  int v18; // [esp+24h] [ebp-10h]
  int v19; // [esp+28h] [ebp-Ch]
  int v20; // [esp+2Ch] [ebp-8h]

  v2 = 0;
  if ( !(*(_BYTE *)(dword_D41A4 + 22) & 0x10) )
  {
    v13 = *(_DWORD *)(dword_D41A0 + 8586);
    v14 = *(_DWORD *)(dword_D41A0 + 8590);
    v15 = *(_DWORD *)(dword_D41A0 + 8594);
    v16 = *(_DWORD *)(dword_D41A0 + 8598);
    v9 = *(_DWORD *)(dword_D41A0 + 8602);
    v10 = *(_DWORD *)(dword_D41A0 + 8606);
    v11 = *(_DWORD *)(dword_D41A0 + 8610);
    v12 = *(_DWORD *)(dword_D41A0 + 8614);
    v17 = *(_DWORD *)(dword_D41A0 + 8618);
    v18 = *(_DWORD *)(dword_D41A0 + 8622);
    v19 = *(_DWORD *)(dword_D41A0 + 8626);
    v20 = *(_DWORD *)(dword_D41A0 + 8630);
    v2 = sub_55750(a1, a2);
    if ( v2 )
    {
      v2 = sub_558E0(a1);
      if ( v2 )
      {
        qmemcpy(
          (void *)(dword_D41A4 + 256),
          (const void *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230),
          0x84Cu);
        v2 = sub_55A10(a1);
        if ( v2 )
        {
          sub_55100(2);
          sub_57680();
          sub_549A0(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230 + 1609, dword_D41A4 + 1865);
          sub_49F90();
          v3 = dword_D41A0;
          v4 = 2124 * *(signed __int16 *)(dword_D41A0 + 12);
          v5 = dword_D41A0 + 11230;
          *(_DWORD *)(dword_D41A0 + 4582) = -1;
          sub_55AB0(*(unsigned __int16 *)(v3 + 12), v5 + v4);
          sub_71990();
          sub_473B0();
        }
      }
    }
    v6 = dword_D41A0;
    v7 = (_DWORD *)(dword_D41A0 + 8586);
    *v7 = v13;
    ++v7;
    *v7 = v14;
    ++v7;
    *v7 = v15;
    v7[1] = v16;
    *(_DWORD *)(v6 + 8602) = v9;
    *(_DWORD *)(v6 + 8606) = v10;
    *(_DWORD *)(v6 + 8610) = v11;
    *(_DWORD *)(v6 + 8614) = v12;
    *(_DWORD *)(v6 + 8618) = v17;
    *(_DWORD *)(v6 + 8622) = v18;
    *(_DWORD *)(v6 + 8626) = v19;
    *(_DWORD *)(v6 + 8630) = v20;
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00055750) --------------------------------------------------------
char __cdecl sub_55750(unsigned __int8 a1, int a2)
{
  int v2; // eax
  int v3; // esi
  int v4; // eax
  _BOOL1 v5; // bl
  int v6; // edi
  int v7; // eax
  int v8; // ebx
  void *v9; // esi
  char v11; // [esp+0h] [ebp-54h]
  int v12; // [esp+40h] [ebp-14h]
  int v13; // [esp+44h] [ebp-10h]
  char v14; // [esp+48h] [ebp-Ch]
  int v15; // [esp+4Ch] [ebp-8h]
  char v16; // [esp+50h] [ebp-4h]

  v16 = 0;
  sprintf(&v11, aCSSSDDat, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSver, a1 + 1);
  if ( sub_53E60((int)&v11, (char *)&v12) == 8 && v13 == a2 && v12 == 15 )
  {
    sprintf(&v11, aCSSSDDat, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSlev, a1 + 1);
    v2 = sub_98817((int)&v11, 512);
    v3 = v2;
    if ( v2 >= 0 )
    {
      v4 = sub_988A7(v2, (int)&v14, 8);
      v5 = v4 != 8;
      if ( v4 == 8 && v15 != *(_DWORD *)(dword_D41A0 + 4) )
        v5 = 1;
      v6 = filelength(v3);
      sub_98882(v3);
      if ( v6 == 224791 && !v5 )
      {
        sprintf(&v11, aCSSSDDat, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSmap, a1 + 1);
        v7 = sub_98817((int)&v11, 512);
        v8 = v7;
        if ( v7 >= 0 )
        {
          v9 = (void *)filelength(v7);
          sub_98882(v8);
          if ( v9 == &loc_712C2 )
            v16 = 1;
        }
      }
    }
  }
  return v16;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (000558E0) --------------------------------------------------------
_BOOL1 __cdecl sub_558E0(unsigned __int8 a1)
{
  int v1; // eax
  int v2; // ebx
  char v4; // [esp+0h] [ebp-48h]
  _BOOL1 v5; // [esp+40h] [ebp-8h]
  _BOOL1 v6; // [esp+44h] [ebp-4h]

  v6 = 0;
  sprintf(&v4, aCSSSDDat, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSmap, a1 + 1);
  v1 = sub_98817((int)&v4, 512);
  v2 = v1;
  if ( v1 >= 0 )
  {
    sub_988A7(v1, (int)byte_10B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_11B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_12B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_13B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_14B4E0, (int)sub_10000);
    sub_988A7(v2, (int)word_15B4E0, (int)&loc_20000);
    v5 = sub_988A7(v2, (int)byte_F2CD0, 4802) != 4802;
    sub_98882(v2);
    v6 = v5 == 0;
  }
  return v6;
}
// 10000: using guessed type void __noreturn sub_10000();
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;

//----- (00055A10) --------------------------------------------------------
char __cdecl sub_55A10(unsigned __int8 a1)
{
  char v1; // bl
  int v2; // edx
  int v3; // ebx
  char v5; // [esp+0h] [ebp-40h]

  v1 = 0;
  sprintf(&v5, aCSSSDDat, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSlev, a1 + 1);
  if ( sub_53E60((int)&v5, (char *)dword_D41A0) == 224791 )
  {
    v3 = dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12);
    *(_DWORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12621) = j___clock(dword_D41A0, v2, v3)
                                                                                    - *(_DWORD *)(v3 + 12621);
    v1 = 1;
  }
  return v1;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00055AB0) --------------------------------------------------------
int __cdecl sub_55AB0(int a1, int a2)
{
  int result; // eax
  signed int v3; // esi
  int v4; // edi
  int v5; // edx
  int v6; // ST0C_4
  int v7; // edx
  int v8; // ST08_4
  int v9; // edx
  int v10; // edx
  int v11; // [esp+4h] [ebp-8h]

  result = *(unsigned __int16 *)(a2 + 10);
  v3 = 0;
  v4 = dword_EA3E4[(unsigned __int16)result];
  while ( v3 < 26 )
  {
    v5 = (unsigned __int8)byte_D94FF[v3];
    result = a2 + v5;
    if ( *(_BYTE *)(a2 + v5 + 1999) || *(_BYTE *)(result + 2025) )
    {
      result = 2 * v5;
      v11 = a2 + 2 * v5;
      if ( !*(_WORD *)(v11 + 1817) )
      {
        result = sub_4A190(v4 + 76, 15, v5);
        if ( result )
        {
          v6 = dword_D41A0 + 28302;
          *(_WORD *)(v11 + 1817) = (result - (dword_D41A0 + 28302)) / 168;
          *(_WORD *)(result + 40) = (v4 - v6) / 168;
          *(_BYTE *)(result + 12) |= 1u;
          LOBYTE(result) = sub_6D5E0(result, *(_BYTE *)(a2 + *(char *)(result + 64) + 2077));
        }
      }
    }
    else
    {
      v7 = a2 + 2 * v5;
      LOWORD(result) = *(_WORD *)(v7 + 1817);
      if ( (_WORD)result )
      {
        v8 = dword_EA3E4[(signed __int16)result];
        *(_WORD *)(v7 + 1817) = 0;
        result = sub_57F20(v8);
      }
    }
    ++v3;
  }
  v9 = *(signed __int16 *)(a2 + 2103);
  if ( v9 != -1 && !*(_WORD *)(a2 + 2 * v9 + 1817) )
    *(_WORD *)(a2 + 2103) = -1;
  v10 = *(signed __int16 *)(a2 + 2105);
  if ( v10 != -1 && !*(_WORD *)(a2 + 2 * v10 + 1817) )
    *(_WORD *)(a2 + 2105) = -1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00055C00) --------------------------------------------------------
char __cdecl sub_55C00(__int16 a1)
{
  return sub_55750(0, a1);
}

//----- (00055C60) --------------------------------------------------------
unsigned int __usercall sub_55C60@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  unsigned int result; // eax
  int v4; // eax
  __int16 v5; // ax
  int v6; // edx
  char v7; // cl
  __int16 v8; // ax
  __int16 v9; // ax
  unsigned __int8 v10; // ch
  char v11; // dl
  __int16 v12; // ax
  __int16 v13; // dx
  signed int v14; // [esp+0h] [ebp-4h]

  result = dword_D41A4;
  if ( !(*(_BYTE *)(dword_D41A4 + 24) & 1) )
  {
    v4 = abs(*(signed __int16 *)(a3 + 1339));
    if ( (unsigned __int8)(*(_BYTE *)(a3 + 2118) - 1) <= 6u )
      JUMPOUT(__CS__, *(&off_55C38 + (unsigned __int8)(*(_BYTE *)(a3 + 2118) - 1)));
    if ( *(_BYTE *)(a3 + 2118) == 1 )
    {
      if ( *(_WORD *)(a3 + 1339) >= 0 )
        *(_BYTE *)(a3 + 2119) = 1;
      else
        *(_BYTE *)(a3 + 2119) = -1;
      v5 = abs(*(_WORD *)(a3 + 1339));
      *(_WORD *)(a3 + 2122) = 91;
      v6 = dword_D41A4;
      v7 = *(_BYTE *)(a3 + 2118);
      *(_WORD *)(a3 + 2120) = v5;
      v8 = dword_E3760;
      *(_BYTE *)(a3 + 2118) = v7 + 1;
      *(_WORD *)(v6 + 220) = v8;
      sub_55EB0(*(_WORD *)(a3 + 10));
    }
    *(_WORD *)(a3 + 2120) += a2 * *(_WORD *)(a3 + 2122);
    if ( a1 )
    {
      v9 = a1 + *(_WORD *)(a3 + 2122);
      *(_WORD *)(a3 + 2122) = v9;
      if ( v9 < 11 )
        *(_WORD *)(a3 + 2122) = 11;
      if ( *(_WORD *)(a3 + 2122) > 68 )
        *(_WORD *)(a3 + 2122) = 68;
    }
    if ( a2 > 0 && *(signed __int16 *)(a3 + 2120) >= v14 || a2 < 0 && *(signed __int16 *)(a3 + 2120) <= v14 )
    {
      v10 = *(_BYTE *)(a3 + 2118) + 1;
      *(_BYTE *)(a3 + 2118) = v10;
      if ( v10 > 3u )
        *(_WORD *)(a3 + 2122) >>= 1;
    }
    if ( *(_BYTE *)(a3 + 2118) >= 4u )
    {
      if ( abs((signed __int16)dword_E3760 - *(signed __int16 *)(dword_D41A4 + 220)) > 16 )
        *(_BYTE *)(a3 + 2118) = 8;
      *(_WORD *)(dword_D41A4 + 220) = dword_E3760;
    }
    v11 = *(_BYTE *)(a3 + 2118);
    *(_WORD *)(a3 + 1002) = 0;
    if ( v11 == 8 )
    {
      result = sub_55EB0(*(_WORD *)(a3 + 10));
      *(_BYTE *)(a3 + 2118) = 0;
    }
    else
    {
      v12 = *(_WORD *)(a3 + 2120) * *(char *)(a3 + 2119);
      HIBYTE(v12) &= 7u;
      v13 = v12;
      result = *(unsigned __int16 *)(a3 + 16) - 1;
      *(_WORD *)(a3 + 14 * result + 489) = v13;
    }
  }
  return result;
}
// 55C38: using guessed type void *off_55C38;
// D41A4: using guessed type int dword_D41A4;
// E3760: using guessed type int dword_E3760;

//----- (00055EB0) --------------------------------------------------------
unsigned int __cdecl sub_55EB0(__int16 a1)
{
  unsigned int result; // eax
  unsigned int i; // edx

  result = 0;
  do
  {
    if ( result < 0xC )
    {
      if ( result == 1 )
        goto LABEL_13;
    }
    else if ( result <= 0xF || result >= 0x16 && result <= 0x17 )
    {
      goto LABEL_13;
    }
    for ( i = *(_DWORD *)(dword_D41A4 + 4 * result + 38403); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(unsigned __int16 *)(i + 150) == a1 )
        *(_WORD *)(i + 150) = 0;
    }
LABEL_13:
    ++result;
  }
  while ( (signed int)result < 29 );
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00055F70) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  signed int v3; // edi
  unsigned __int16 v4; // si
  __int16 v6; // [esp+0h] [ebp-1Ch]
  __int16 v7; // [esp+Ch] [ebp-10h]

  memset(&v6, 0, 28);
  v7 = 0;
  v6 = 13057;
  int386(33, &v6, &v6);
  signal(7, 1);
  signal(4, 1);
  signal(6, 1);
  sub_56210(argc, (int)argv);
  sub_5B8D0();
  sub_46830(0, v3, v4);
  sub_5BC20();
  sub_56730();
  return 0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 98DC0: using guessed type _DWORD __cdecl signal(_DWORD, _DWORD);

//----- (000560D0) --------------------------------------------------------
char sub_560D0()
{
  int v0; // eax
  int v1; // ebx
  int v2; // eax
  int v3; // ebx
  char v5; // [esp+0h] [ebp-2Ah]
  char v6; // [esp+80h] [ebp+56h]
  char v7; // [esp+A8h] [ebp+7Eh]

  v7 = 1;
  sprintf(&v5, aDeviceNoneDriv);
  sprintf(&v6, aCSSDigIni, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_1, aSound_0);
  v0 = sub_98817((int)&v6, 512);
  if ( v0 == -1 )
  {
    v1 = sub_98817((int)&v6, 546);
    if ( v1 != -1 )
    {
      sub_98CAA(v1, (int)&v5, strlen(&v5));
      sub_98882(v1);
    }
  }
  else
  {
    sub_98882(v0);
  }
  sprintf(&v6, aCSSMdiIni, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_1, aSound_0);
  v2 = sub_98817((int)&v6, 512);
  if ( v2 == -1 )
  {
    v3 = sub_98817((int)&v6, 546);
    if ( v3 != -1 )
    {
      sub_98CAA(v3, (int)&v5, strlen(&v5));
      sub_98882(v3);
    }
  }
  else
  {
    sub_98882(v2);
  }
  return v7;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;

//----- (00056210) --------------------------------------------------------
int __cdecl sub_56210(unsigned __int16 a1, int a2)
{
  int v2; // ebx
  char v3; // dl
  char *v4; // edi
  char *v5; // esi
  char v6; // al
  char v7; // al
  unsigned __int8 v8; // al
  int v9; // ebx
  int v10; // esi
  int result; // eax
  char v12; // [esp+0h] [ebp-46h]
  int v13; // [esp+80h] [ebp+3Ah]
  char v14; // [esp+84h] [ebp+3Eh]
  unsigned __int8 v15; // [esp+88h] [ebp+42h]
  char v16; // [esp+8Ch] [ebp+46h]
  char v17; // [esp+90h] [ebp+4Ah]
  char v18; // [esp+94h] [ebp+4Eh]
  char v19; // [esp+98h] [ebp+52h]
  char v20; // [esp+9Ch] [ebp+56h]
  char v21; // [esp+A0h] [ebp+5Ah]
  char v22; // [esp+A4h] [ebp+5Eh]
  char v23; // [esp+A8h] [ebp+62h]
  unsigned __int8 v24; // [esp+ACh] [ebp+66h]
  char v25; // [esp+B0h] [ebp+6Ah]
  char v26; // [esp+B4h] [ebp+6Eh]
  char v27; // [esp+B8h] [ebp+72h]
  char v28; // [esp+BCh] [ebp+76h]

  v2 = 1;
  v13 = -1;
  v24 = 67;
  v14 = 0;
  v15 = 0;
  v23 = 0;
  v17 = 0;
  v28 = 0;
  v27 = 0;
  v22 = 0;
  v20 = 0;
  v21 = 0;
  v16 = 0;
  v18 = 0;
  v26 = 0;
  v19 = 0;
  v25 = 0;
  sub_89B60(7u);
  while ( (signed __int16)v2 < (signed int)a1 )
  {
    v3 = **(_BYTE **)(a2 + 4 * (signed __int16)v2);
    if ( v3 == 45 || v3 == 47 )
    {
      v4 = &v12;
      v5 = (char *)(*(_DWORD *)(a2 + 4 * (signed __int16)v2) + 1);
      do
      {
        v6 = *v5;
        *v4 = *v5;
        if ( !v6 )
          break;
        v7 = v5[1];
        v5 += 2;
        v4[1] = v7;
        v4 += 2;
      }
      while ( v7 );
    }
    if ( stricmp(aNetwork, &v12) )
    {
      if ( !stricmp(aLevel, &v12) )
      {
        v15 = unknown_libname_1(*(_DWORD *)(a2 + 4 * (signed __int16)++v2));
        byte_D419C = v15;
        v27 = 1;
      }
      else if ( !stricmp(aHarddrive, &v12) )
      {
        v24 = **(_BYTE **)(a2 + 4 * (signed __int16)++v2);
        v8 = toupper(v24);
        v24 = v8;
        if ( v8 < 0x41u || v8 > 0x5Au )
          v24 = 67;
      }
      else if ( !stricmp(aSkipscreens, &v12) )
      {
        byte_D41AD = 1;
      }
      else if ( !stricmp(aNocd, &v12) )
      {
        v22 = 1;
      }
      else if ( !stricmp(aShowversion, &v12) )
      {
        v20 = 1;
      }
      else if ( !stricmp(aShowversion2, &v12) )
      {
        v21 = 1;
      }
      else if ( !stricmp(aDetectoff, &v12) )
      {
        v26 = 1;
      }
      else if ( !stricmp(aLangcheck, &v12) )
      {
        v19 = 1;
      }
      else if ( !stricmp(&aMavio[2], &v12) )
      {
        v9 = v2 + 1;
        v10 = *(_DWORD *)(a2 + 4 * (signed __int16)v9);
        v2 = v9 + 1;
        word_1805C4 = unknown_libname_1(v10);
        word_1805C6 = unknown_libname_1(*(_DWORD *)(a2 + 4 * (signed __int16)v2));
        sub_89B60(1u);
      }
      else if ( !stricmp(aExtern, &v12) )
      {
        dword_E36C4 = sub_98FF5(*(char **)(a2 + 4 * (signed __int16)++v2));
        printf(aExternalCtrlAt);
        sub_89B60(6u);
      }
      else if ( !stricmp(aVfx1, &v12) )
      {
        sub_89B60(2u);
      }
      else if ( !stricmp(&aScc[3], &v12) )
      {
        v18 = unknown_libname_1(*(_DWORD *)(a2 + 4 * (signed __int16)++v2));
      }
      else if ( !stricmp(aSpellsedit, &v12) )
      {
        v28 = 1;
      }
      else if ( !stricmp(aMusic2, &v12) )
      {
        v25 = 1;
      }
    }
    ++v2;
  }
  if ( !v22 )
    sub_86A00();
  dword_D41A0 = sub_83CD0(224791);
  if ( !dword_D41A0 )
  {
    printf(aErrorCantAlloc_0);
LABEL_46:
    exit(-1);
  }
  dword_D41A4 = sub_83CD0(38547);
  if ( !dword_D41A4 )
  {
    sub_83E80(dword_D41A0);
    printf(aErrorCantAlloc);
    goto LABEL_46;
  }
  memset(dword_D41A0, 0, 224791);
  memset(dword_D41A4, 0, 38547);
  if ( v14 )
    *(_DWORD *)(dword_D41A4 + 22) |= 0x800008u;
  if ( v23 )
    *(_BYTE *)(dword_D41A4 + 24) |= 2u;
  if ( v17 )
    *(_BYTE *)(dword_D41A4 + 24) |= 8u;
  if ( v28 )
    *(_BYTE *)(dword_D41A4 + 24) |= 0x10u;
  if ( !v22 && byte_E2A28 )
    *(_BYTE *)(dword_D41A4 + 24) |= 0x40u;
  if ( v27 )
    *(_BYTE *)(dword_D41A4 + 24) |= 0x80u;
  if ( v16 )
    *(_BYTE *)(dword_D41A4 + 23) |= 2u;
  if ( v20 )
    *(_BYTE *)(dword_D41A4 + 25) |= 8u;
  if ( v19 )
    *(_BYTE *)(dword_D41A4 + 25) |= 0x10u;
  if ( v25 )
    *(_BYTE *)(dword_D41A4 + 25) |= 0x40u;
  if ( v26 )
    sub_99080(0);
  result = dword_D41A4;
  *(_WORD *)(dword_D41A4 + 43) = v15;
  *(_WORD *)(result + 45) = v13;
  *(_BYTE *)(result + 182) = v24;
  if ( v18 )
    *(_BYTE *)(result + 25) = (*(_BYTE *)(result + 25) | 4) & 0xFD;
  if ( v21 )
  {
    sub_70890();
    sub_5BC20();
    exit(1);
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98805: using guessed type _DWORD __cdecl toupper(_DWORD);
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// 98F9E: using guessed type _DWORD __cdecl unknown_libname_1(_DWORD);
// D419C: using guessed type char byte_D419C;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41AD: using guessed type char byte_D41AD;
// E2A28: using guessed type char byte_E2A28;
// E36C4: using guessed type int dword_E36C4;
// 1805C4: using guessed type __int16 word_1805C4;
// 1805C6: using guessed type __int16 word_1805C6;

//----- (00056730) --------------------------------------------------------
int sub_56730()
{
  return sub_8B5A0();
}

//----- (000567C0) --------------------------------------------------------
int sub_567C0()
{
  int result; // eax
  int v1; // ebx

  memset(dword_D41A0 + 16, 0, 29);
  memset(dword_D41A0 + 45, 0, 4);
  memset(dword_D41A0 + 49, 0, 2);
  memset(dword_D41A0 + 51, 0, 2);
  memset(dword_D41A0 + 53, 0, 4);
  memset(dword_D41A0 + 569, 0, 1);
  memset(dword_D41A0 + 222418, 0, 108);
  memset(dword_D41A0 + 9058, 0, 48);
  memset(dword_D41A0 + 28302, 0, 168000);
  memset(dword_D41A4 + 51, 0, 1);
  memset(dword_D41A4 + 121, 0, 16);
  memset(dword_D41A4 + 178, 0, 1);
  memset(dword_D41A4 + 180, 0, 1);
  memset(dword_D41A4 + 242, 0, 14);
  memset(dword_D41A4 + 38403, 0, 116);
  memset(dword_D41A4 + 38519, 0, 4);
  memset(dword_D41A4 + 38523, 0, 4);
  memset(dword_D41A4 + 38527, 0, 4);
  memset(dword_D41A4 + 38531, 0, 4);
  memset(dword_D41A4 + 38535, 0, 4);
  memset(word_15B4E0, 0, &loc_20000);
  memset(byte_10B4E0, 0, sub_10000);
  memset(byte_11B4E0, 0, sub_10000);
  memset(byte_12B4E0, 0, sub_10000);
  memset(byte_13B4E0, 0, sub_10000);
  memset(dword_E9C38, 0, 64000);
  result = dword_D41A4;
  *(_DWORD *)(dword_D41A4 + 30) = 0;
  v1 = *(_DWORD *)(result + 22);
  *(_DWORD *)(result + 26) = 0;
  *(_DWORD *)(result + 22) = v1 & 0xFFFE3FFF;
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E9C38: using guessed type int dword_E9C38;

//----- (00056A30) --------------------------------------------------------
char __usercall sub_56A30@<al>(unsigned int a1@<esi>)
{
  char v1; // bl
  int v2; // eax
  int v3; // ST08_4

  v1 = byte_E3799;
  byte_E3799 = 0;
  sub_567C0();
  if ( !(*(_BYTE *)(dword_D41A4 + 22) & 8) )
  {
    sub_70910();
    sub_533B0(*(_WORD *)(dword_D41A4 + 43), (void *)(dword_D41A0 + 196302));
  }
  sub_54660(*(_BYTE *)(dword_D41A0 + 196308), byte_D41B5);
  sub_54800(*(_BYTE *)(dword_D41A0 + 196308));
  if ( !(*(_BYTE *)(dword_D41A4 + 22) & 0x10) )
    *(_WORD *)(dword_D41A0 + 14) = *(_WORD *)(dword_D41A0 + 196311);
  sub_70910();
  if ( !(*(_BYTE *)(dword_D41A4 + 22) & 4) )
    sub_43830(a1, dword_D41A0 + 196302);
  sub_49F30();
  sub_70910();
  if ( !(*(_BYTE *)(dword_D41A4 + 22) & 4) )
    sub_49270(dword_D41A0 + 196302);
  sub_70910();
  memset(&word_EB398, 0, 6);
  sub_49F90();
  v2 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 4582) = -1;
  sub_71A70(*(_BYTE *)(v2 + 196308));
  if ( !(*(_BYTE *)(dword_D41A4 + 22) & 4) )
  {
    sub_58940(dword_D41A0 + 196302);
    sub_11EE0(dword_D41A0 + 196302);
    sub_84790();
  }
  sub_4A1E0(0, 1);
  byte_E3799 = v1;
  sub_53160();
  v3 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  return sub_60F00();
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B5: using guessed type char byte_D41B5;
// E3799: using guessed type char byte_E3799;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00056C00) --------------------------------------------------------
int __cdecl sub_56C00(int a1)
{
  unsigned __int8 v1; // al
  int v2; // eax
  char v3; // cl
  int result; // eax

  byte_D41B6 = 0;
  byte_DA972[0] = 19;
  word_DAE1E = 245;
  word_DA96E = 199;
  v1 = *(_BYTE *)(a1 + 6);
  byte_DAE22 = 19;
  if ( v1 < 1u )
  {
    if ( !v1 )
    {
      byte_DA972[0] = 2;
      word_DA96E = 198;
      byte_DAE22 = 2;
      word_DAE1E = 244;
      *(_BYTE *)(dword_D41A0 + 8600) = 0;
      sub_84300(0);
      byte_D419E = 1;
    }
  }
  else if ( v1 <= 1u )
  {
    *(_BYTE *)(dword_D41A0 + 8600) = 0;
    sub_84300(1u);
    byte_D419E = 9;
  }
  else if ( v1 == 2 )
  {
    *(_BYTE *)(dword_D41A0 + 8600) = 1;
    byte_D41B6 = 1;
    byte_D41B7 = *(_BYTE *)(a1 + 5);
    sub_84300(2u);
    byte_D419E = 10;
  }
  sub_5C0A0();
  v2 = dword_D41A0;
  *(_BYTE *)(dword_D41A0 + 224770) = 1;
  *(_WORD *)(v2 + 224766) = 0;
  *(_WORD *)((char *)&loc_36DFC + v2) = 0;
  *(_BYTE *)(v2 + 8625) = 0;
  v3 = *(_BYTE *)(v2 + 224779);
  *(_BYTE *)(v2 + 8593) = 0;
  *(_BYTE *)(v2 + 224779) = v3 & 0xFC;
  result = dword_D41A4;
  *(_BYTE *)(dword_D41A4 + 38546) = 0;
  if ( word_180660 == 1 )
    byte_D419D = 1;
  else
    byte_D419D = 3;
  return result;
}
// D419D: using guessed type char byte_D419D;
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// D41B7: using guessed type char byte_D41B7;
// DA96E: using guessed type __int16 word_DA96E;
// DAE1E: using guessed type __int16 word_DAE1E;
// DAE22: using guessed type char byte_DAE22;
// 180660: using guessed type __int16 word_180660;

//----- (00056D60) --------------------------------------------------------
char __usercall sub_56D60@<al>(unsigned int a1@<esi>, char a2)
{
  char v2; // bl
  int v3; // ST08_4
  int v4; // eax
  int v5; // ST08_4

  v2 = byte_E3799;
  byte_E3799 = 0;
  sub_567C0();
  sub_533B0(*(_WORD *)(dword_D41A4 + 43), (void *)(dword_D41A0 + 196302));
  if ( a2 )
  {
    sub_54660(*(_BYTE *)(dword_D41A0 + 196308), byte_D41B5);
    sub_54800(*(_BYTE *)(dword_D41A0 + 196308));
  }
  v3 = dword_D41A0 + 196302;
  *(_WORD *)(v3 - 196288) = *(_WORD *)(dword_D41A0 + 196311);
  sub_43830(a1, v3);
  sub_49F30();
  sub_49270(dword_D41A0 + 196302);
  memset(&word_EB398, 0, 6);
  sub_49F90();
  v4 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 4582) = -1;
  if ( a2 )
    sub_71A70(*(_BYTE *)(v4 + 196308));
  sub_58940(dword_D41A0 + 196302);
  sub_11EE0(dword_D41A0 + 196302);
  sub_84790();
  sub_4A1E0(0, 1);
  byte_E3799 = v2;
  sub_53160();
  v5 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  return sub_60F00();
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B5: using guessed type char byte_D41B5;
// E3799: using guessed type char byte_E3799;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00056EE0) --------------------------------------------------------
_BOOL1 __cdecl sub_56EE0(unsigned __int16 a1)
{
  char v1; // al

  v1 = byte_13B4E0[a1] & 7;
  return v1 != 5 && v1 != 2 && v1 != 3;
}

//----- (00056F10) --------------------------------------------------------
char __cdecl sub_56F10(__int16 a1, __int16 a2, __int16 a3, char a4)
{
  signed __int16 v4; // bx
  char v5; // dh
  int v6; // edx
  int v7; // eax
  char v8; // dl
  unsigned __int16 v9; // bx
  char v11; // [esp+0h] [ebp-8h]
  unsigned __int16 v12; // [esp+4h] [ebp-4h]

  LOBYTE(v12) = a1;
  HIBYTE(v12) = a2;
  v11 = 0;
  v4 = a3 + (unsigned __int8)byte_11B4E0[v12];
  if ( v4 > 200 )
  {
    v4 = 200;
    if ( !a1 && !a2 )
      v11 = 1;
  }
  if ( v4 < 0 )
  {
    v4 = 0;
    if ( !a1 && !a2 )
      v11 = 1;
  }
  if ( a4 && byte_13B4E0[v12] < 0 )
    return 1;
  v5 = byte_D41B6;
  byte_11B4E0[v12] = v4;
  if ( v5 )
  {
    v6 = (unsigned __int8)byte_14B4E0[v12] - a3;
    if ( v6 >= 255 )
      byte_14B4E0[v12] = -1;
    else
      byte_14B4E0[v12] = v6;
  }
  if ( v4 )
  {
    v7 = v12;
    v8 = byte_13B4E0[v12] & 0xF8 | 1;
  }
  else
  {
    LOBYTE(v9) = a1 - 1;
    HIBYTE(v9) = a2 - 1;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    LOBYTE(v9) = v9 + 1;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    LOBYTE(v9) = v9 + 1;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    HIBYTE(v9) = a2;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    LOBYTE(v9) = v9 - 2;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    HIBYTE(v9) = a2 + 1;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    LOBYTE(v9) = v9 + 1;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    LOBYTE(v9) = v9 + 1;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    v7 = v12;
    v8 = byte_13B4E0[v12] & 0xF0;
  }
  byte_13B4E0[v7] = v8;
LABEL_28:
  if ( a4 )
    sub_462A0(v12, v12);
  else
    sub_46570(v12, v12);
  return v11;
}
// D41B6: using guessed type char byte_D41B6;

//----- (000570F0) --------------------------------------------------------
char __cdecl sub_570F0(__int16 a1, __int16 a2, signed __int16 a3, char a4, char a5, char a6)
{
  unsigned __int16 v6; // bx
  char v8; // [esp+0h] [ebp-8h]
  unsigned __int16 v9; // [esp+4h] [ebp-4h]

  LOBYTE(v9) = a1;
  HIBYTE(v9) = a2;
  v8 = 0;
  if ( a3 > 255 )
  {
    a3 = 255;
    if ( !a1 && !a2 )
      v8 = 1;
  }
  if ( a3 < 0 )
  {
    a3 = 0;
    if ( !a1 && !a2 )
      v8 = 1;
  }
  if ( a4 && byte_13B4E0[v9] < 0 )
    return 1;
  byte_11B4E0[v9] = a3;
  if ( a5 || sub_57450(byte_10B4E0[v9]) )
    byte_13B4E0[v9] = byte_13B4E0[v9] & 0xF8 | 1;
  if ( !a3 )
  {
    if ( !a6 )
      goto LABEL_32;
    LOBYTE(v6) = a1 - 1;
    HIBYTE(v6) = a2 - 1;
    if ( sub_56EE0(v6) )
    {
      LOBYTE(v6) = v6 + 1;
      if ( sub_56EE0(v6) )
      {
        LOBYTE(v6) = v6 + 1;
        if ( sub_56EE0(v6) )
        {
          HIBYTE(v6) = a2;
          if ( sub_56EE0(v6) )
          {
            LOBYTE(v6) = v6 - 2;
            if ( sub_56EE0(v6) )
            {
              HIBYTE(v6) = a2 + 1;
              if ( sub_56EE0(v6) )
              {
                LOBYTE(v6) = v6 + 1;
                if ( sub_56EE0(v6) )
                {
                  LOBYTE(v6) = v6 + 1;
                  if ( sub_56EE0(v6) )
LABEL_32:
                    byte_13B4E0[v9] &= 0xF0u;
                }
              }
            }
          }
        }
      }
    }
  }
  if ( a4 )
    sub_462A0(v9, v9);
  else
    sub_46570(v9, v9);
  return v8;
}

//----- (000572C0) --------------------------------------------------------
char __cdecl sub_572C0(signed __int16 *a1, __int16 a2, __int16 a3, __int16 a4, char a5)
{
  int v5; // ebx
  int v6; // esi
  int v7; // edi
  int v8; // ebx
  int v10; // [esp+0h] [ebp-8h]
  int v11; // [esp+4h] [ebp-4h]

  LOWORD(v5) = a3;
  v6 = (a1[38] + 128) >> 8;
  v7 = (a1[39] + 128) >> 8;
  if ( a3 > (a1[42] - (__CFSHL__(a1[42] >> 31, 8) + (a1[42] >> 31 << 8))) >> 8 )
    v5 = (a1[42] - (__CFSHL__(a1[42] >> 31, 8) + (a1[42] >> 31 << 8))) >> 8;
  v8 = sub_10080(a2, (signed __int16)v5);
  if ( !v8 )
    return 0;
  do
  {
    if ( sub_10130(v8, &v11, &v10) != 1 )
    {
      sub_10100(v8);
      return 0;
    }
  }
  while ( !sub_56F10(v6 + v11, v7 + v10, a4, a5) );
  sub_10100(v8);
  return 1;
}

//----- (00057390) --------------------------------------------------------
unsigned __int8 __cdecl sub_57390(unsigned __int16 a1, unsigned __int16 a2)
{
  unsigned __int8 result; // al
  int i; // ebx
  char v4; // ah
  int v5; // ebx

  result = a1;
  for ( i = word_15B4E0[a1]; ; i = *(unsigned __int16 *)(v5 + 22) )
  {
    v5 = dword_EA3E4[i];
    if ( v5 == dword_EA3E4[0] )
      break;
    result = a2;
    if ( *(signed __int16 *)(v5 + 26) != a2 )
    {
      result = *(_BYTE *)(v5 + 63);
      if ( result >= 2u )
      {
        if ( result <= 2u )
        {
          result = sub_57F10(v5);
          continue;
        }
        if ( result == 5 )
        {
          v4 = 1;
          result = *(_BYTE *)(v5 + 64);
          if ( result < 0x10u )
          {
            if ( result < 8u )
            {
              if ( result != 6 )
                goto LABEL_25;
            }
            else if ( result > 8u && result != 10 )
            {
              goto LABEL_25;
            }
          }
          else if ( result > 0x10u )
          {
            if ( result < 0x19u )
            {
              if ( result < 0x16u || result > 0x17u )
                goto LABEL_25;
            }
            else if ( result <= 0x19u )
            {
              if ( *(_BYTE *)(v5 + 69) != -56 )
                goto LABEL_25;
            }
            else if ( result != 27 )
            {
LABEL_25:
              if ( v4 )
              {
                *(_DWORD *)(v5 + 8) = -1;
                *(_WORD *)(v5 + 36) = a2;
                *(_WORD *)(v5 + 38) = a2;
              }
              continue;
            }
          }
          v4 = 0;
          goto LABEL_25;
        }
      }
    }
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00057450) --------------------------------------------------------
char __cdecl sub_57450(unsigned __int8 a1)
{
  if ( a1 < 0x53u )
  {
    if ( a1 < 0x25u )
    {
      if ( a1 )
        return 0;
    }
    else if ( a1 > 0x26u )
    {
      if ( a1 >= 0x2Cu )
      {
        if ( a1 > 0x2Fu && a1 != 81 )
          return 0;
        return 1;
      }
      return 0;
    }
    return 1;
  }
  if ( a1 <= 0x53u )
    return 1;
  if ( a1 < 0x6Du )
  {
    if ( a1 >= 0x68u )
    {
      if ( a1 > 0x69u )
        return 0;
      return 1;
    }
    return 0;
  }
  if ( a1 <= 0x6Du )
    return 1;
  if ( a1 >= 0x72u )
  {
    if ( a1 > 0x72u && a1 != 116 )
      return 0;
    return 1;
  }
  return 0;
}

//----- (000574A0) --------------------------------------------------------
_WORD *sub_574A0()
{
  _WORD *result; // eax
  int v1; // ebx
  int v2; // edx

  result = (_WORD *)dword_D41A4;
  if ( !(*(_BYTE *)(dword_D41A4 + 22) & 0x10) )
  {
    memset(dword_D41A0 + 222422, 0, 104);
    result = (_WORD *)((char *)&loc_30325 + dword_D41A0);
    v1 = *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)]
                   + 164)
       + 611;
    while ( (unsigned int)result < dword_D41A0 + 221393 )
    {
      if ( *result == 15 )
      {
        v2 = (unsigned __int16)result[1];
        if ( !*(_WORD *)(v1 + 2 * (unsigned __int16)v2 + 208) && !*(_BYTE *)(v2 + v1 + 390) )
          ++*(_DWORD *)(dword_D41A0 + 4 * v2 + 222422);
      }
      result += 10;
    }
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00057570) --------------------------------------------------------
int sub_57570()
{
  int result; // eax
  int v1; // edx
  char v2; // ch

  result = dword_D41A4;
  if ( !(*(_BYTE *)(dword_D41A4 + 23) & 1) )
  {
    result = dword_D41A0;
    v1 = *(signed __int16 *)(dword_D41A0 + 12);
    if ( byte_3659C[11 * v1 + dword_D41A0] )
    {
      result = 2124 * v1 + dword_D41A0;
      v2 = *(_BYTE *)(result + 11232);
      if ( !(v2 & 0x10) )
        *(_BYTE *)(result + 11232) = v2 | 2;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (000575C0) --------------------------------------------------------
char sub_575C0()
{
  int v0; // edx
  int v1; // eax
  char v2; // dl

  v0 = 2124 * *(signed __int16 *)(dword_D41A0 + 12);
  LOBYTE(v1) = v0 + dword_D41A0;
  v2 = *(_BYTE *)(v0 + dword_D41A0 + 11232);
  if ( v2 & 8 )
  {
    if ( v2 & 4 )
    {
      LOBYTE(v1) = dword_D41A4;
      if ( !(*(_BYTE *)(dword_D41A4 + 22) & 0x10) && *(_BYTE *)(dword_D41A4 + 38545) < 0 )
      {
        LOBYTE(v1) = sub_555D0(1u, *(unsigned __int16 *)(dword_D41A4 + 43));
        if ( (_BYTE)v1 )
        {
          v1 = dword_D41A0;
          *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + v1 + 11232) &= 0xF7u;
          *(_BYTE *)(2124 * *(signed __int16 *)(v1 + 12) + v1 + 11232) &= 0xFBu;
        }
      }
    }
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00057640) --------------------------------------------------------
char sub_57640()
{
  int v0; // eax

  LOBYTE(v0) = dword_D41A4;
  if ( !(*(_BYTE *)(dword_D41A4 + 22) & 0x10) && *(_BYTE *)(dword_D41A4 + 38545) >= 0 )
  {
    LOBYTE(v0) = sub_55080(1u, *(unsigned __int16 *)(dword_D41A4 + 43));
    if ( (_BYTE)v0 )
    {
      v0 = dword_D41A4;
      *(_BYTE *)(v0 + 38545) |= 0x80u;
    }
  }
  return v0;
}
// D41A4: using guessed type int dword_D41A4;

//----- (00057680) --------------------------------------------------------
unsigned int sub_57680()
{
  signed int v0; // edx
  int v1; // ebx
  int v2; // ecx
  unsigned int result; // eax
  char *i; // edx

  v0 = 0;
  while ( v0 < *(unsigned __int16 *)(dword_D41A0 + 14) )
  {
    v1 = dword_D41A0 + 11230 + 2124 * v0;
    v2 = dword_EA3E4[*(unsigned __int16 *)(2124 * v0++ + dword_D41A0 + 11240)];
    *(_DWORD *)(v2 + 164) = v1 + 998;
  }
  result = dword_EA3E8;
  for ( i = (char *)&unk_D83AC - *(_DWORD *)(dword_D41A0 + 224758); result < dword_EB384; result += 168 )
  {
    if ( *(_BYTE *)(result + 63) )
      *(_DWORD *)(result + 160) += i;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EA3E8: using guessed type int dword_EA3E8;
// EB384: using guessed type int dword_EB384;

//----- (00057730) --------------------------------------------------------
char sub_57730()
{
  unsigned int i; // ebx
  int v1; // eax
  _DWORD *v2; // esi
  _DWORD *v3; // ecx
  _DWORD *v4; // edx
  int *j; // eax
  char v6; // bl
  unsigned __int8 v7; // bl
  _BOOL1 v8; // zf
  int v9; // ebx
  int **v10; // edi
  unsigned __int8 v11; // bl
  int v12; // ebx
  unsigned __int8 v13; // bl
  char result; // al
  signed int k; // esi
  unsigned int l; // ebx
  int v17; // ST08_4
  _BYTE *m; // ebx
  char v19; // cl
  int v20; // eax
  __int16 v21; // si
  int v22[29]; // [esp+0h] [ebp-7Ch]
  _DWORD *v23; // [esp+74h] [ebp-8h]
  _DWORD *v24; // [esp+78h] [ebp-4h]

  *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
  for ( i = dword_EA3E8; i < dword_EB384; i += 168 )
  {
    if ( *(_BYTE *)(i + 63) && *(_BYTE *)(i + 13) & 4 )
      sub_57F20(i);
  }
  memset(v22, 0, 116);
  memset(dword_D41A4 + 38403, 0, 116);
  v1 = dword_D41A4;
  v2 = 0;
  *(_DWORD *)(dword_D41A4 + 38523) = 0;
  v24 = 0;
  *(_DWORD *)(v1 + 38527) = 0;
  v23 = 0;
  *(_DWORD *)(v1 + 38519) = 0;
  *(_DWORD *)(v1 + 38531) = 0;
  v3 = 0;
  *(_DWORD *)(v1 + 38535) = 0;
  v4 = 0;
  for ( j = (int *)dword_EA3E8; (unsigned int)j < dword_EB384; j += 42 )
  {
    v6 = *((_BYTE *)j + 63);
    if ( v6 )
    {
      switch ( v6 )
      {
        case 3:
          if ( j[2] >= 0 )
          {
            if ( v3 )
              *v3 = j;
            else
              *(_DWORD *)(dword_D41A4 + 38519) = j;
            v12 = dword_EA3E4[0];
            v3 = j;
            goto LABEL_60;
          }
          continue;
        case 5:
          if ( j[2] < 0 )
            continue;
          v7 = *((_BYTE *)j + 69);
          if ( v7 < 0xE8u )
          {
            v8 = v7 == -76;
          }
          else
          {
            if ( v7 <= 0xE8u )
              continue;
            v8 = v7 == -22;
          }
          if ( !v8 )
          {
            v9 = *((char *)j + 64);
            v10 = (int **)v22[v9];
            if ( v10 )
              *v10 = j;
            else
              *(_DWORD *)(dword_D41A4 + v9 * 4 + 38403) = j;
            *j = dword_EA3E4[0];
            v22[*((char *)j + 64)] = (int)j;
          }
          continue;
        case 9:
          if ( v23 )
            *v23 = j;
          else
            *(_DWORD *)(dword_D41A4 + 38531) = j;
          v12 = dword_EA3E4[0];
          v23 = j;
          goto LABEL_60;
        case 10:
          v11 = *((_BYTE *)j + 64);
          if ( v11 < 0x2Du )
          {
            if ( v11 < 0x27u )
              continue;
            if ( v11 <= 0x28u )
              goto LABEL_32;
            if ( v11 != 42 )
              continue;
LABEL_40:
            if ( v4 )
              *v4 = j;
            else
              *(_DWORD *)(dword_D41A4 + 38535) = j;
            *j = dword_EA3E4[0];
            v4 = j;
            continue;
          }
          if ( v11 <= 0x2Du )
          {
            if ( v24 )
              *v24 = j;
            else
              *(_DWORD *)(dword_D41A4 + 38527) = j;
            v12 = dword_EA3E4[0];
            v24 = j;
            goto LABEL_60;
          }
          if ( v11 < 0x43u )
          {
            if ( v11 != 57 )
              continue;
LABEL_32:
            if ( v2 )
              *v2 = j;
            else
              *(_DWORD *)(dword_D41A4 + 38523) = j;
            v12 = dword_EA3E4[0];
            v2 = j;
LABEL_60:
            *j = v12;
            continue;
          }
          if ( v11 <= 0x43u || v11 == 78 )
            goto LABEL_40;
          break;
        case 11:
          v13 = *((_BYTE *)j + 64);
          if ( v13 >= 0xCu && (v13 <= 0xCu || v13 == 31) )
          {
            if ( v4 )
              *v4 = j;
            else
              *(_DWORD *)(dword_D41A4 + 38535) = j;
            *j = dword_EA3E4[0];
            v4 = j;
          }
          continue;
        default:
          continue;
      }
    }
  }
  result = dword_D41A4;
  if ( !(*(_BYTE *)(dword_D41A4 + 24) & 1) )
  {
    sub_12780();
    for ( k = 0; k < 29; ++k )
    {
      for ( l = *(_DWORD *)(dword_D41A4 + 4 * k + 38403); l > dword_EA3E4[0]; l = *(_DWORD *)l )
      {
        if ( *(_BYTE *)(l + 72) || *(_BYTE *)(l + 73) )
          sub_12500(l);
      }
    }
    if ( !(*(_BYTE *)(dword_D41A4 + 22) & 0x10) )
      sub_68BF0();
    sub_159E0();
    if ( byte_D41B6 )
      sub_58630();
    v17 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
    sub_60F00();
    for ( m = (_BYTE *)dword_EA3E8; (unsigned int)m < dword_EB384; m += 168 )
    {
      v19 = m[63];
      if ( v19 )
      {
        v20 = 14 * (unsigned __int8)m[69] + *(int *)((char *)&dword_D4C52 + 18 * v19);
        if ( (unsigned __int8)m[69] == *(_WORD *)(v20 + 4) )
        {
          if ( *(_DWORD *)(v20 + 10) )
          {
            (*(void (__cdecl **)(_BYTE *))(v20 + 6))(m);
            ++m[62];
          }
        }
        else
        {
          sub_57F10((int)m);
        }
      }
    }
    sub_585D0();
    result = dword_D41A0;
    v21 = *(_WORD *)(dword_D41A0 + 222538);
    if ( v21 )
      result = sub_21F60(dword_EA3E4[v21]);
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// D4C52: using guessed type int dword_D4C52;
// EA3E4: using guessed type int dword_EA3E4[];
// EA3E8: using guessed type int dword_EA3E8;
// EB384: using guessed type int dword_EB384;
// 57730: using guessed type int var_7C[29];

//----- (00057B20) --------------------------------------------------------
char __cdecl sub_57B20(int a1, int a2)
{
  __int16 v2; // t1
  int v3; // edi
  int v4; // ecx

  if ( !(*(_BYTE *)(dword_D41A4 + 24) & 1) )
  {
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 479) = *(_WORD *)(a2 + 76);
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 481) = *(_WORD *)(a2 + 78);
    sub_10C40((__int16 *)(a2 + 76));
    v2 = *(_WORD *)(a2 + 80);
    *(_WORD *)(14 * (*(unsigned __int16 *)(a1 + 16) - 1) + a1 + 483) = *(_WORD *)(a2 + 80);
    *(_WORD *)(14 * (*(unsigned __int16 *)(a1 + 16) - 1) + a1 + 485) = *(_WORD *)(a2 + 28);
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 491) = *(_WORD *)(a1 + 477);
    *(_WORD *)(14 * (*(unsigned __int16 *)(a1 + 16) - 1) + a1 + 489) = *(_WORD *)(*(_DWORD *)(a2 + 164) + 341);
    v3 = *(_DWORD *)(a2 + 164);
    v4 = *(signed __int16 *)(v3 + 30);
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 487) = *(_WORD *)(v3 + 343) / 2
                                                                     + *(unsigned __int8 *)(dword_D41A4 + 122)
                                                                     * (unsigned __int16)((signed int)(v4 - (__CFSHL__((unsigned __int64)*(signed __int16 *)(v3 + 30) >> 32, 4) + 16 * ((unsigned __int64)*(signed __int16 *)(v3 + 30) >> 32))) >> 4)
                                                                     - ((v4 - (__CFSHL__(v4 >> 31, 3) + 8 * (v4 >> 31))) >> 3);
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 485) += *(_WORD *)(*(_DWORD *)(a2 + 164) + 24);
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 487) += *(_WORD *)(*(_DWORD *)(a2 + 164) + 26);
  }
  return 1;
}
// D41A4: using guessed type int dword_D41A4;

//----- (00057CF0) --------------------------------------------------------
signed int __cdecl sub_57CF0(int a1, int a2)
{
  signed int result; // eax

  if ( *(_BYTE *)(a1 + 77) == *(_BYTE *)(a2 + 1) && *(_BYTE *)(a1 + 79) == *(_BYTE *)(a2 + 3) )
  {
    result = 0;
    *(_DWORD *)(a1 + 76) = *(_DWORD *)a2;
    *(_WORD *)(a1 + 80) = *(_WORD *)(a2 + 4);
  }
  else
  {
    sub_57E50(a1);
    sub_57D70(a1, a2);
    result = 1;
  }
  return result;
}

//----- (00057D40) --------------------------------------------------------
signed int __cdecl sub_57D40(int a1, int a2)
{
  sub_57E50(a1);
  sub_57D70(a1, a2);
  return 1;
}

//----- (00057D70) --------------------------------------------------------
int __cdecl sub_57D70(int a1, int a2)
{
  unsigned __int16 v2; // di
  int result; // eax

  if ( !(*(_BYTE *)(a1 + 12) & 4) )
  {
    *(_WORD *)(a1 + 24) = 0;
    v2 = word_15B4E0[(*(unsigned __int8 *)(a2 + 3) << 8) + *(unsigned __int8 *)(a2 + 1)];
    *(_WORD *)(a1 + 22) = v2;
    if ( v2 )
      *(_WORD *)(dword_D41A0 + 168 * v2 + 28326) = (a1 - (dword_D41A0 + 28302)) / 168;
    result = (*(unsigned __int8 *)(a2 + 3) << 8) + *(unsigned __int8 *)(a2 + 1);
    word_15B4E0[result] = (a1 - (dword_D41A0 + 28302)) / 168;
    *(_DWORD *)(a1 + 76) = *(_DWORD *)a2;
    *(_WORD *)(a1 + 80) = *(_WORD *)(a2 + 4);
    *(_BYTE *)(a1 + 12) |= 4u;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00057E50) --------------------------------------------------------
__int16 __cdecl sub_57E50(int a1)
{
  __int16 result; // ax
  unsigned __int16 v2; // cx

  if ( *(_BYTE *)(a1 + 12) & 4 )
  {
    if ( *(_WORD *)(a1 + 24) )
    {
      result = *(_WORD *)(a1 + 22);
      *(_WORD *)(168 * *(unsigned __int16 *)(a1 + 24) + dword_D41A0 + 28324) = result;
    }
    else
    {
      result = *(_WORD *)(a1 + 22);
      word_15B4E0[*(unsigned __int8 *)(a1 + 77) + (*(unsigned __int8 *)(a1 + 79) << 8)] = result;
    }
    v2 = *(_WORD *)(a1 + 22);
    if ( v2 )
    {
      result = *(_WORD *)(a1 + 24);
      *(_WORD *)(dword_D41A0 + 168 * v2 + 28326) = result;
    }
    *(_BYTE *)(a1 + 12) &= 0xFBu;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00057F10) --------------------------------------------------------
int __cdecl sub_57F10(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(result + 13) |= 4u;
  return result;
}

//----- (00057F20) --------------------------------------------------------
int __cdecl sub_57F20(int a1)
{
  int v1; // edx
  signed int v2; // ecx
  _DWORD *v3; // eax
  int v4; // edx
  int result; // eax
  int v6; // edx

  sub_57E50(a1);
  if ( *(_BYTE *)(a1 + 14) & 2 )
  {
    v1 = 0;
    v2 = 0;
    v3 = (_DWORD *)(dword_D41A0 + 4586);
    while ( v1 <= *(_DWORD *)(dword_D41A0 + 4582) )
    {
      if ( a1 == *v3 )
      {
        v2 = 1;
        break;
      }
      ++v3;
      ++v1;
    }
    if ( v2 )
    {
      v4 = dword_D41A0;
      *v3 = *(_DWORD *)(dword_D41A0 + 4 * *(_DWORD *)(dword_D41A0 + 4582) + 4586);
      --*(_DWORD *)(v4 + 4582);
    }
  }
  result = dword_D41A0;
  *(_BYTE *)(a1 + 63) = 0;
  v6 = *(_DWORD *)(result + 53) + 1;
  *(_DWORD *)(result + 53) = v6;
  *(_DWORD *)(result + 4 * v6 + 582) = a1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00057FA0) --------------------------------------------------------
_WORD *__cdecl sub_57FA0(_WORD *a1, unsigned __int16 a2, __int16 a3, __int16 a4)
{
  _WORD *result; // eax
  unsigned __int16 v5; // bx
  int v6; // edx

  result = a1;
  LOBYTE(v5) = a3;
  LOWORD(v6) = a4;
  if ( a4 )
  {
    HIBYTE(v5) = HIBYTE(a3) & 7;
    HIBYTE(a2) &= 7u;
    if ( v5 )
    {
      a1[2] -= (unsigned int)(a4 * dword_DB750[v5]) >> 16;
      v6 = a4 * (signed int)off_DBF50[v5] >> 16;
    }
    *a1 += (unsigned int)((signed __int16)v6 * dword_DB750[a2]) >> 16;
    a1[1] -= (unsigned int)((_DWORD)off_DBF50[a2] * (signed __int16)v6) >> 16;
  }
  return result;
}
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();

//----- (00058030) --------------------------------------------------------
_WORD *__cdecl sub_58030(int a1, _WORD *a2)
{
  _WORD *result; // eax
  unsigned __int16 v3; // dx
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // bl
  unsigned __int8 v6; // bl

  result = a2;
  LOBYTE(v3) = *(_BYTE *)(a1 + 1);
  HIBYTE(v3) = *(_BYTE *)(a1 + 3);
  v4 = byte_11B4E0[v3];
  *a2 = v4;
  LOBYTE(v3) = v3 + 1;
  a2[1] = v4;
  *a2 -= (unsigned __int8)byte_11B4E0[v3];
  v5 = byte_11B4E0[v3];
  ++HIBYTE(v3);
  result[1] += v5;
  *a2 -= (unsigned __int8)byte_11B4E0[v3];
  v6 = byte_11B4E0[v3];
  LOBYTE(v3) = v3 - 1;
  result[1] -= v6;
  *result += (unsigned __int8)byte_11B4E0[v3];
  a2[1] -= (unsigned __int8)byte_11B4E0[v3];
  return result;
}

//----- (000580E0) --------------------------------------------------------
signed int __cdecl sub_580E0(int a1, signed int a2, int a3, int a4, __int16 a5)
{
  signed int result; // eax

  result = 0;
  if ( *(signed __int16 *)(a1 + 4) > a2 )
  {
    result = 1;
    *(_WORD *)(a1 + 4) += a5;
  }
  if ( *(signed __int16 *)(a1 + 4) <= a2 + a3 )
  {
    result = 3;
    *(_WORD *)(a1 + 4) = a3 + a2;
  }
  return result;
}

//----- (000581E0) --------------------------------------------------------
__int16 __cdecl sub_581E0(_WORD *a1, _WORD *a2)
{
  return sub_72633(*a2 - *a1, a2[1] - a1[1]);
}

//----- (00058210) --------------------------------------------------------
__int16 __cdecl sub_58210(_WORD *a1, _WORD *a2)
{
  __int16 v2; // ax

  v2 = sub_58490(a1, a2);
  return sub_72633(a1[2] - a2[2], -v2);
}

//----- (000582B0) --------------------------------------------------------
int __cdecl sub_582B0(__int16 a1, __int16 a2)
{
  int result; // eax

  result = abs((a1 & 0x7FF) - (a2 & 0x7FF));
  if ( (unsigned __int16)result > 0x400u )
    result = 2048 - result;
  return result;
}

//----- (000582F0) --------------------------------------------------------
int __cdecl sub_582F0(int a1, __int16 a2)
{
  int v2; // edx
  int v3; // ebx

  v2 = a1;
  BYTE1(v2) &= 7u;
  v3 = (a2 & 0x7FF) - (unsigned __int16)v2;
  if ( (a2 & 0x7FF) == (unsigned __int16)v2 )
    return v2 ^ (unsigned __int16)v2;
  if ( abs(v3) > 1024 )
  {
    if ( v3 >= 0 )
      v3 -= 2048;
    else
      v3 += 2048;
  }
  if ( v3 )
  {
    if ( v3 > 0 )
      return 1;
    v3 = -1;
  }
  return v3;
}

//----- (00058350) --------------------------------------------------------
int __cdecl sub_58350(unsigned __int16 a1, __int16 a2, int a3, unsigned __int16 a4)
{
  int v4; // ebx
  int v5; // esi
  int v6; // eax

  if ( a1 == a2 )
    return 0;
  v4 = sub_582B0(a1, a2);
  v5 = sub_582F0(a1, a2);
  v6 = v4;
  if ( (signed __int16)v4 > (signed int)a4 )
    v6 = a4;
  return v5 * v6;
}

//----- (000583B0) --------------------------------------------------------
int __cdecl sub_583B0(_WORD *a1, _WORD *a2)
{
  int v2; // ebx
  int v3; // eax

  v2 = abs((signed __int16)(*a2 - *a1));
  v3 = abs((signed __int16)(a2[1] - a1[1]));
  if ( v2 < v3 )
    v2 = v3;
  return v2;
}

//----- (000583F0) --------------------------------------------------------
unsigned int __cdecl sub_583F0(_WORD *a1, _WORD *a2)
{
  __int16 v2; // cx

  v2 = a2[2] - a1[2];
  return sub_7277A(
           (signed __int16)(a2[1] - a1[1]) * (signed __int16)(a2[1] - a1[1])
         + (signed __int16)(*a2 - *a1) * (signed __int16)(*a2 - *a1)
         + v2 * v2);
}

//----- (00058440) --------------------------------------------------------
int __cdecl sub_58440(_WORD *a1, _WORD *a2)
{
  return (signed __int16)(a2[1] - a1[1]) * (signed __int16)(a2[1] - a1[1])
       + (signed __int16)(*a2 - *a1) * (signed __int16)(*a2 - *a1)
       + (signed __int16)(a2[2] - a1[2]) * (signed __int16)(a2[2] - a1[2]);
}

//----- (00058490) --------------------------------------------------------
unsigned int __cdecl sub_58490(_WORD *a1, _WORD *a2)
{
  return sub_7277A(
           (signed __int16)(*a2 - *a1) * (signed __int16)(*a2 - *a1)
         + (signed __int16)(a2[1] - a1[1]) * (signed __int16)(a2[1] - a1[1]));
}

//----- (000584D0) --------------------------------------------------------
int __cdecl sub_584D0(_WORD *a1, _WORD *a2)
{
  return (signed __int16)(*a2 - *a1) * (signed __int16)(*a2 - *a1)
       + (signed __int16)(a2[1] - a1[1]) * (signed __int16)(a2[1] - a1[1]);
}

//----- (000585A0) --------------------------------------------------------
signed int __cdecl sub_585A0(int a1)
{
  signed int result; // eax

  if ( *(_BYTE *)(a1 + 92) >= *(_BYTE *)(a1 + 93) )
    return 1;
  result = 0;
  ++*(_BYTE *)(a1 + 92);
  return result;
}

//----- (000585D0) --------------------------------------------------------
void sub_585D0()
{
  int v0; // esi
  unsigned int i; // ebx
  __int16 v2; // ax

  v0 = word_D84A6;
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( !*(_BYTE *)(i + 64) )
    {
      v2 = sub_10C40((__int16 *)(i + 76));
      if ( *(signed __int16 *)(i + 80) < v2 + v0 )
        *(_WORD *)(i + 80) = v0 + v2;
    }
  }
}
// D41A4: using guessed type int dword_D41A4;
// D84A6: using guessed type __int16 word_D84A6;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00058630) --------------------------------------------------------
char sub_58630()
{
  char v0; // bl
  unsigned int v1; // edx
  int v2; // eax
  unsigned int v3; // eax
  int v4; // eax
  __int16 v5; // cx
  int v6; // ebx
  unsigned int v7; // eax
  unsigned int v8; // edx
  int v9; // eax
  signed int v10; // esi
  signed int v11; // edi
  char v12; // ah
  unsigned __int16 v13; // bx
  int v15; // [esp+0h] [ebp-10h]
  __int16 v16; // [esp+4h] [ebp-Ch]
  int v17; // [esp+8h] [ebp-8h]
  int v18; // [esp+Ch] [ebp-4h]

  v0 = 0;
  v1 = 0;
  if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
  {
    v2 = dword_D41A0;
    *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
    v1 = *(_DWORD *)(v2 + 8) % (unsigned int)*(unsigned __int16 *)(v2 + 14);
  }
  else if ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248) & 7 )
  {
    goto LABEL_5;
  }
  v0 = 1;
LABEL_5:
  v3 = 2124 * v1 + dword_D41A0 + 11230;
  if ( !*(_BYTE *)(v3 + 6) )
    v0 = 0;
  if ( v0 )
  {
    v4 = dword_EA3E4[*(unsigned __int16 *)(v3 + 10)];
    v15 = *(_DWORD *)(v4 + 76);
    v16 = *(_WORD *)(v4 + 80);
    sub_57FA0(&v15, *(_WORD *)(v4 + 28), 0, 2560);
    LOBYTE(v5) = (unsigned __int16)(v15 + 128) >> 8;
    v6 = dword_D41A0;
    HIBYTE(v5) = (unsigned __int16)(HIWORD(v15) + 128) >> 8;
    v7 = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
    *(_DWORD *)(dword_D41A0 + 8) = v7;
    v8 = v7 % 0x14;
    v9 = 9377 * *(_DWORD *)(v6 + 8);
    v17 = v8;
    v3 = v9 + 9439;
    *(_DWORD *)(v6 + 8) = v3;
    LOBYTE(v5) = v5 - 10;
    HIBYTE(v5) -= 10;
    LOWORD(v18) = v5;
    v10 = v3 % 0x14;
    BYTE1(v18) = v3 % 0x14 + HIBYTE(v5);
    LOBYTE(v3) = 0;
    while ( v10 < 20 && !(_BYTE)v3 )
    {
      v11 = v17;
      HIBYTE(v13) = BYTE1(v18);
      v12 = v17;
      v17 = 0;
      LOBYTE(v13) = v12 + v18;
      while ( v11 < 20 && !(_BYTE)v3 )
      {
        if ( !byte_10B4E0[v13] && !(byte_13B4E0[v13] & 8) )
        {
          LOWORD(v15) = (unsigned __int8)v13 << 8;
          HIWORD(v15) = HIBYTE(v13) << 8;
          sub_4A190((int)&v15, 10, 86);
          LOBYTE(v3) = 1;
        }
        v11 += 11;
        LOBYTE(v13) = v13 + 11;
      }
      ++v10;
      ++BYTE1(v18);
    }
  }
  return v3;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00058940) --------------------------------------------------------
int __cdecl sub_58940(int a1)
{
  char *v1; // ST00_4
  int v2; // esi
  int v3; // ecx
  int result; // eax
  int v5; // edx
  int v6; // edi
  __int16 v7; // dx
  int v8; // edi
  int v9; // edi
  int v10; // ST0C_4
  int v11; // ebx
  int v12; // [esp+Ch] [ebp-8h]

  v1 = &byte_3659C[dword_D41A0];
  *(_BYTE *)(dword_D41A0 + 224769) = 0;
  memset(v1, 0, 88);
  memset(dword_D41A0 + 222540, 0, 80);
  v2 = dword_D41A0;
  v3 = dword_D41A4;
  *(_WORD *)((char *)&loc_2FED5 + dword_D41A0) = 0;
  if ( *(_BYTE *)(v3 + 22) & 0x10 )
  {
    *(_BYTE *)(v2 + 224769) = 1;
    *(_BYTE *)(v2 + 222540) = 8;
    result = 0;
    while ( (signed __int16)result < 8 )
    {
      v11 = 11 * (signed __int16)result++;
      byte_3659F[v2 + v11] = 1;
    }
    dword_D41A0 = v2;
  }
  else
  {
    result = 0;
    do
    {
      if ( *(char *)(7 * (signed __int16)result + a1 + 25972) != -1 )
      {
        switch ( *(_BYTE *)(v2 + 10 * *(unsigned __int8 *)(v2 + 224769) + 222540) )
        {
          case 1:
          case 2:
          case 4:
          case 6:
          case 7:
          case 9:
            v5 = a1 + 7 * (signed __int16)result;
            if ( !*(_WORD *)(v5 + 25973) )
              *(_BYTE *)(v5 + 25972) = -1;
            break;
          default:
            break;
        }
      }
      v6 = a1 + 7 * (signed __int16)result;
      if ( *(char *)(v6 + 25972) != -1 )
      {
        *(_BYTE *)(v2 + 10 * *(unsigned __int8 *)(v2 + 224769) + 222540) = *(_BYTE *)(v6 + 25972);
        v7 = 0;
        while ( v7 < 8 )
        {
          v8 = 11 * v7++ + v2;
          byte_3659F[v8 + *(unsigned __int8 *)(v2 + 224769)] = 1;
        }
        v9 = v2 + 10 * *(unsigned __int8 *)(v2 + 224769);
        v12 = v2 + 10 * *(unsigned __int8 *)(v2 + 224769);
        switch ( *(_BYTE *)(v9 + 222540) )
        {
          case 0:
            goto LABEL_17;
          case 1:
          case 2:
          case 6:
            *(_DWORD *)(v2 + 10 * *(unsigned __int8 *)(v2 + 224769) + 222546) = 20
                                                                              * *(unsigned __int16 *)(7 * (signed __int16)result + a1 + 25973)
                                                                              + a1
                                                                              + 1091;
            break;
          case 4:
            v10 = a1 + 7 * (signed __int16)result;
            *(_DWORD *)(v12 + 222546) = 20 * *(unsigned __int16 *)(a1 + 7 * (signed __int16)result + 25973) + a1 + 1091;
            *(_WORD *)((char *)&loc_3654E + 10 * *(unsigned __int8 *)(v2 + 224769) + v2) = *(_WORD *)(v10 + 25975) << 8;
            *(_WORD *)((char *)&loc_36550 + 10 * *(unsigned __int8 *)(v2 + 224769) + v2) = *(_WORD *)(v10 + 25977) << 8;
            break;
          case 5:
            *(_WORD *)((char *)&loc_3654E + v12) = *(_WORD *)(a1 + 7 * (signed __int16)result + 25975) << 8;
            *(_WORD *)((char *)&loc_36550 + 10 * *(unsigned __int8 *)(v2 + 224769) + v2) = *(_WORD *)(a1 + 7 * (signed __int16)result + 25977) << 8;
LABEL_17:
            *(_DWORD *)(v2 + 10 * *(unsigned __int8 *)(v2 + 224769) + 222546) = *(unsigned __int16 *)(7 * (signed __int16)result + a1 + 25973);
            break;
          case 7:
            *(_DWORD *)(v9 + 222546) = *(unsigned __int16 *)(a1
                                                           + 20
                                                           * *(unsigned __int16 *)(7 * (signed __int16)result
                                                                                 + a1
                                                                                 + 25973)
                                                           + 1093);
            break;
          case 8:
            break;
          case 9:
            *(_DWORD *)(v9 + 222546) = *(unsigned __int16 *)(a1
                                                           + 20
                                                           * *(unsigned __int16 *)(7 * (signed __int16)result
                                                                                 + a1
                                                                                 + 25973)
                                                           + 1105);
            break;
          default:
            *(_DWORD *)(v2 + 10 * *(unsigned __int8 *)(v2 + 224769) + 222546) = *(unsigned __int16 *)(7 * (signed __int16)result + a1 + 25973)
                                                                              - 1;
            break;
        }
        ++*(_BYTE *)(v2 + 224769);
      }
      ++result;
    }
    while ( (signed __int16)result < 8 );
    dword_D41A0 = v2;
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00058DA0) --------------------------------------------------------
int __cdecl sub_58DA0(int a1, int a2)
{
  signed __int16 i; // bx
  int v3; // esi
  int v4; // eax
  char v5; // dl
  char v6; // al
  int v7; // eax
  char v8; // dl
  char v9; // dh
  int result; // eax

  for ( i = 0; ; ++i )
  {
    result = *(unsigned __int8 *)(dword_D41A0 + 224769);
    if ( i >= (signed __int16)result )
      break;
    v3 = dword_D41A0 + 10 * i;
    switch ( *(_BYTE *)(v3 + 222540) )
    {
      case 1:
      case 2:
      case 4:
        v4 = dword_D41A0 + 10 * i;
        if ( a1 == *(_DWORD *)(v4 + 222546) )
        {
          v5 = *(_BYTE *)(v4 + 222541);
          *(_DWORD *)(v4 + 222546) = a2;
          *(_BYTE *)(v4 + 222541) = v5 | 1;
        }
        break;
      case 3:
        if ( *(_BYTE *)(a2 + 63) == 3 )
        {
          v6 = *(_BYTE *)(a2 + 64);
          if ( !v6 || v6 == 1 )
          {
            v7 = 10 * i + dword_D41A0;
            if ( *(signed __int16 *)(*(_DWORD *)(a2 + 164) + 56) == *(_DWORD *)(v7 + 222546) )
            {
              v8 = *(_BYTE *)(v7 + 222541);
              *(_DWORD *)(v7 + 222546) = a2;
              *(_BYTE *)(v7 + 222541) = v8 | 1;
            }
          }
        }
        break;
      case 6:
        if ( a1 == *(_DWORD *)(v3 + 222546) )
        {
          v9 = *(_BYTE *)(v3 + 222541);
          *(_DWORD *)(v3 + 222546) = (a2 - (dword_D41A0 + 28302)) / 168;
          *(_BYTE *)(v3 + 222541) = v9 | 1;
        }
        break;
      default:
        continue;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00058F00) --------------------------------------------------------
int sub_58F00()
{
  char *v0; // esi
  int result; // eax
  char v2; // dh
  signed __int16 v3; // bx
  signed __int16 v4; // cx
  int v5; // eax
  int v6; // eax
  int v7; // edi
  unsigned int v8; // edx
  __int16 j; // ax
  __int16 i; // ax
  __int64 v11; // rax
  __int64 v12; // rax
  __int16 v13; // dx
  signed __int16 v14; // ax
  signed __int16 k; // bx
  int v16; // edx
  int v17; // [esp+4h] [ebp-44h]
  int v18; // [esp+1Ch] [ebp-2Ch]
  int v19; // [esp+24h] [ebp-24h]
  int v20; // [esp+28h] [ebp-20h]
  int v21; // [esp+30h] [ebp-18h]
  signed __int16 v22; // [esp+34h] [ebp-14h]
  signed __int16 v23; // [esp+38h] [ebp-10h]
  int v24; // [esp+3Ch] [ebp-Ch]
  char v25; // [esp+40h] [ebp-8h]
  unsigned __int8 v26; // [esp+44h] [ebp-4h]

  if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
    v22 = *(_WORD *)(dword_D41A0 + 14);
  else
    v22 = 1;
  v24 = 0;
  v0 = &byte_3659C[dword_D41A0];
  result = 0;
  if ( v22 > 0 )
  {
    do
    {
      v2 = v0[2];
      if ( v2 )
      {
        v0[2] = v2 - 1;
      }
      else if ( !*v0 )
      {
        v3 = 0;
        v4 = 0;
        v23 = 0;
        v17 = dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 2124 * (signed __int16)v24 + 11240)];
        while ( v3 < *(unsigned __int8 *)(dword_D41A0 + 224769) )
        {
          v19 = 10 * v3;
          v5 = v19 + dword_D41A0;
          v21 = (int)&v0[v3];
          if ( *(_BYTE *)(v19 + dword_D41A0 + 222541) & 2 )
          {
            *(_BYTE *)(v21 + 3) = 2;
            v4 = 1;
            *(_BYTE *)(v5 + 222541) &= 0xFDu;
          }
          else if ( *(_BYTE *)(v21 + 3) == 1 )
          {
            switch ( *(_BYTE *)(v5 + 222540) )
            {
              case 0:
                v6 = *(_DWORD *)(v17 + 164);
                if ( *(_WORD *)(v6 + 58) )
                {
                  v18 = *(_DWORD *)(dword_D41A4 + 246);
                  if ( v18 > 0 )
                  {
                    v7 = dword_D41A0;
                    if ( (unsigned int)(100
                                      * (*(_DWORD *)(v6 + 316)
                                       + *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(v6 + 58)] + 144))
                                      / v18) >= *(_DWORD *)(dword_D41A0 + 10 * v3 + 222546) )
                    {
                      v0[v3 + 3] = 2;
                      v4 = 1;
                      *(_WORD *)((char *)&loc_2FED5 + v7) = 0;
                    }
                  }
                }
                if ( !*(_WORD *)((char *)&loc_2FED5 + dword_D41A0) && v3 == (unsigned __int8)v0[1] && !v4 )
                  *(_WORD *)((char *)&loc_2FED5 + dword_D41A0) = *(_WORD *)(dword_D41A0
                                                                          + 10 * (unsigned __int8)v0[1]
                                                                          + 222546);
                break;
              case 1:
                if ( *(_BYTE *)(dword_D41A0 + 10 * v3 + 222541) & 1
                  && *(_DWORD *)(*(_DWORD *)(dword_D41A0 + 10 * v3 + 222546) + 8) <= -1 )
                {
                  v4 = 1;
                  v0[v3 + 3] = 2;
                }
                break;
              case 2:
                if ( *(_BYTE *)(v5 + 222541) & 1
                  && *(_DWORD *)(*(_DWORD *)(v5 + 222546) + 8) <= -1
                  && !*(_BYTE *)(*(_DWORD *)(10 * v3 + dword_D41A0 + 222546) + 61) )
                {
                  v4 = 1;
                  v0[v3 + 3] = 2;
                }
                break;
              case 3:
                if ( !*(_BYTE *)(dword_D41A0
                               + 2124 * *(signed __int16 *)(*(_DWORD *)(*(_DWORD *)(v5 + 222546) + 164) + 56)
                               + 11236) )
                {
                  v4 = 1;
                  *(_BYTE *)(v21 + 3) = 2;
                }
                break;
              case 4:
                if ( *(_BYTE *)(v5 + 222541) & 1 )
                {
                  v20 = *(_DWORD *)(v5 + 222546);
                  if ( v17 == dword_EA3E4[*(unsigned __int16 *)(v20 + 40)] )
                  {
                    v11 = *(signed __int16 *)((char *)&loc_3654E + v5) - (signed int)*(signed __int16 *)(v20 + 76);
                    if ( (signed int)((HIDWORD(v11) ^ v11) - HIDWORD(v11)) <= 768
                      && abs(*(signed __int16 *)((char *)&loc_36550 + v19 + dword_D41A0) - *(signed __int16 *)(v20 + 78)) <= 768 )
                    {
                      v4 = 1;
                      *(_BYTE *)(v21 + 3) = 2;
                    }
                  }
                }
                break;
              case 5:
                if ( v3 == (unsigned __int8)v0[1] )
                {
                  v12 = *(signed __int16 *)((char *)&loc_3654E + v5) - (signed int)*(signed __int16 *)(v17 + 76);
                  if ( (signed int)((HIDWORD(v12) ^ v12) - HIDWORD(v12)) <= 768
                    && abs(*(signed __int16 *)((char *)&loc_36550 + v19 + dword_D41A0) - *(signed __int16 *)(v17 + 78)) <= 768 )
                  {
                    v4 = 1;
                    *(_BYTE *)(v21 + 3) = 2;
                  }
                }
                break;
              case 6:
                if ( v3 == (unsigned __int8)v0[1] && *(_BYTE *)(v5 + 222541) & 1 )
                {
                  v13 = 0;
                  while ( *(signed __int16 *)(dword_D41A0 + 11230 + 2124 * (signed __int16)v24 + 1426 + 2 * v13 + 2) != *(_DWORD *)(10 * v3 + dword_D41A0 + 222546) )
                  {
                    if ( ++v13 >= 8 )
                      goto LABEL_72;
                  }
                  v4 = 1;
                  v0[v3 + 3] = 2;
                }
                break;
              case 7:
                if ( v3 == (unsigned __int8)v0[1] && !*(_DWORD *)(dword_D41A4 + 4 * *(_DWORD *)(v5 + 222546) + 38403) )
                {
                  v4 = 1;
                  *(_BYTE *)(v21 + 3) = 2;
                }
                break;
              case 8:
                if ( v3 == (unsigned __int8)v0[1] )
                {
                  v4 = 1;
                  for ( i = 0; i < (signed int)*(unsigned __int16 *)(dword_D41A0 + 14); ++i )
                  {
                    if ( i != (_WORD)v24 && *(_BYTE *)(2124 * i + dword_D41A0 + 11236) )
                    {
                      v4 = 0;
                      break;
                    }
                  }
                  if ( v4 )
                    v0[v3 + 3] = 2;
                }
                break;
              case 9:
                if ( v3 == (unsigned __int8)v0[1] && !(*(_BYTE *)(dword_D41A4 + 26) & 0xF) )
                {
                  v8 = *(_DWORD *)(dword_D41A4 + 38527);
                  v25 = 0;
                  while ( v8 > dword_EA3E4[0] && !v25 )
                  {
                    v26 = 0;
                    for ( j = *(_WORD *)(dword_D41A0 + 10 * v3 + 222546);
                          j && !v25 && v26 < 8u;
                          j = (unsigned __int8)byte_D93C3[4 * j] )
                    {
                      if ( j == *(char *)(v8 + 70) )
                        v25 = 1;
                      ++v26;
                    }
                    v8 = *(_DWORD *)v8;
                  }
                  if ( !v25 )
                  {
                    v4 = 1;
                    v0[v3 + 3] = 2;
                  }
                }
                break;
              default:
                break;
            }
          }
LABEL_72:
          if ( v4 && v3 == (unsigned __int8)v0[1] )
            v23 = 1;
          ++v3;
        }
        if ( v4 )
        {
          sub_88B20();
          v14 = 1;
          for ( k = 0; k < *(unsigned __int8 *)(dword_D41A0 + 224769); ++k )
          {
            if ( v0[k + 3] == 1 )
            {
              v14 = 0;
              v0[1] = k;
              break;
            }
          }
          *v0 = v14;
          if ( v23 || v14 )
          {
            if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 && (_WORD)v24 != *(_WORD *)(dword_D41A0 + 12) )
            {
              v16 = 2124 * (signed __int16)v24 + dword_D41A0 + 11230 + 28;
              *(_WORD *)(v16 + 49) = 60;
              *(_WORD *)(v16 + 51) = 4;
              if ( v14 )
                sprintf(v16, (const char *)dword_EA308);
              else
                sprintf(v16, (const char *)dword_EA304);
            }
            if ( (_WORD)v24 == *(_WORD *)(dword_D41A0 + 12) )
              *(_BYTE *)(dword_D41A0 + 224770) = 1;
          }
        }
      }
      v0 += 11;
      result = ++v24;
    }
    while ( (signed __int16)v24 < v22 );
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA304: using guessed type int dword_EA304;
// EA308: using guessed type int dword_EA308;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000595C0) --------------------------------------------------------
char __cdecl sub_595C0(__int16 a1)
{
  char result; // al
  char *v2; // ebx

  result = -1;
  if ( *(_BYTE *)(dword_D41A0 + 224779) & 1 )
    return -3;
  v2 = &byte_3659C[11 * a1 + dword_D41A0];
  if ( !*v2 )
    result = *(_BYTE *)(dword_D41A0 + 10 * (unsigned __int8)v2[1] + 222540);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00059610) --------------------------------------------------------
char __cdecl sub_59610(int *a1, __int16 a2)
{
  int v2; // eax
  int v3; // ecx
  char *v4; // ebx
  char v5; // dl
  unsigned __int8 v6; // dh
  int v7; // eax
  int v8; // ebx
  unsigned __int8 v9; // al
  int v10; // eax
  int v11; // eax

  v2 = 11 * a2;
  v3 = dword_D41A0;
  v4 = &byte_3659C[dword_D41A0];
  *a1 = 0;
  v5 = 0;
  v6 = v4[v2 + 1];
  if ( v4[v2] )
    return v5;
  v7 = 10 * v6;
  v8 = v3 + v7;
  v9 = *(_BYTE *)(v3 + v7 + 222540);
  if ( v9 < 4u )
  {
    if ( v9 < 1u || v9 > 2u )
      return v5;
  }
  else if ( v9 > 4u )
  {
    if ( v9 == 6 && *(_BYTE *)(v8 + 222541) & 1 )
    {
      v11 = dword_EA3E4[*(_DWORD *)(v8 + 222546)];
      goto LABEL_12;
    }
    return v5;
  }
  v10 = dword_D41A0 + 10 * v6;
  if ( *(_BYTE *)(v10 + 222541) & 1 )
  {
    v11 = *(_DWORD *)(v10 + 222546);
LABEL_12:
    v5 = 1;
    *a1 = v11;
  }
  return v5;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000596C0) --------------------------------------------------------
char __cdecl sub_596C0(_WORD *a1, __int16 a2)
{
  int v2; // ebx
  char *v3; // ecx
  char v4; // dl
  int v5; // eax
  int v6; // edi
  unsigned __int8 v7; // al

  v2 = dword_D41A0;
  *a1 = -1;
  a1[1] = -1;
  v3 = &byte_3659C[11 * a2 + v2];
  a1[2] = -1;
  v4 = 0;
  if ( !*v3 )
  {
    v5 = 10 * (unsigned __int8)v3[1];
    v6 = v2 + v5;
    v7 = *(_BYTE *)(v2 + v5 + 222540);
    if ( v7 >= 4u && v7 <= 5u )
    {
      *a1 = *(_WORD *)((char *)&loc_3654E + v6);
      v4 = 1;
      a1[1] = *(_WORD *)((char *)&loc_36550 + 10 * (unsigned __int8)v3[1] + v2);
    }
  }
  return v4;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00059760) --------------------------------------------------------
int __cdecl sub_59760(int a1, int a2)
{
  int result; // eax
  signed int v3; // esi
  signed int v4; // ecx
  char *i; // ebx
  int j; // edx
  int v7; // eax

  result = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
    v3 = *(unsigned __int16 *)(dword_D41A0 + 14);
  else
    v3 = 1;
  v4 = 0;
  for ( i = &byte_3659C[dword_D41A0]; v4 < v3; i += 11 )
  {
    if ( !*i )
    {
      for ( j = 0; ; ++j )
      {
        result = *(unsigned __int8 *)(dword_D41A0 + 224769);
        if ( j >= result )
          break;
        if ( i[j + 3] == 1 )
        {
          v7 = dword_D41A0 + 10 * j;
          if ( *(_BYTE *)(v7 + 222540) == 2 && *(_DWORD *)(v7 + 222546) == a1 )
          {
            if ( *(_BYTE *)(v7 + 222541) & 1 )
              *(_DWORD *)(v7 + 222546) = a2;
          }
        }
      }
    }
    ++v4;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00059820) --------------------------------------------------------
void sub_59820()
{
  char v0; // dl
  int v1; // ebx
  int v2; // eax
  unsigned __int8 v3; // ch
  char v4; // cl
  int v5; // ebx
  unsigned __int16 v6; // dx
  int v7; // eax
  __int16 v8; // bx
  unsigned __int8 v9; // al
  char v10; // cl
  int v11; // ebx

  v0 = *(_BYTE *)(dword_D41A0 + 224772);
  if ( v0 )
  {
    *(_BYTE *)(dword_D41A0 + 224772) = v0 - 1;
    if ( v0 == 1 )
      sub_88BA0();
  }
  if ( *(_BYTE *)(dword_D41A4 + 38545) & 0x40 && sub_86180(word_1803EC) == 256 )
    sub_59AF0();
  v1 = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 51) >= 3u )
  {
    v2 = dword_D41A0;
    v3 = *(_BYTE *)(dword_D41A0 + 224770);
    if ( v3 )
    {
      if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
      {
LABEL_38:
        *(_BYTE *)(dword_D41A0 + 224770) = 0;
        return;
      }
      if ( *(_BYTE *)(dword_D41A4 + 24) & 0x40 )
      {
        if ( v3 < 7u )
        {
          if ( v3 == 1 )
          {
            ++*(_BYTE *)(dword_D41A0 + 224770);
            return;
          }
          goto LABEL_32;
        }
        if ( v3 > 7u )
        {
          if ( v3 > 8u )
          {
            if ( v3 != -56 )
            {
LABEL_32:
              ++*(_BYTE *)(dword_D41A0 + 224770);
              return;
            }
            goto LABEL_38;
          }
          v4 = *(_BYTE *)(dword_D41A0 + 224779);
          *(_BYTE *)(dword_D41A0 + 224770) = v3 + 1;
          if ( v4 & 1 )
          {
            *(_BYTE *)(v1 + 180) = 8;
            sub_86F20(*(_BYTE *)(2124 * *(signed __int16 *)(v2 + 12) + v2 + 12226));
            sub_59A50();
            return;
          }
          v5 = *(signed __int16 *)(v2 + 12);
          if ( byte_3659D[11 * v5 + v2] )
            sub_6E450(v5, -1, 61);
          v6 = *(_WORD *)(dword_D41A4 + 43);
          if ( v6 >= 0x1Eu && v6 <= 0x22u )
          {
            if ( !byte_3659C[11 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0] )
            {
              v9 = 4;
              LOBYTE(v8) = 0;
              goto LABEL_30;
            }
            LOBYTE(v8) = 10;
          }
          else
          {
            v7 = 11 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0;
            v8 = *(_WORD *)(dword_D41A4 + 43);
            if ( !byte_3659C[v7] )
            {
              v9 = byte_3659D[v7] + 1;
LABEL_30:
              *(_BYTE *)(dword_D41A4 + 180) = 8;
              sub_86EB0(v8, v9, 1);
              sub_59A50();
              return;
            }
          }
          v9 = 9;
          goto LABEL_30;
        }
        *(_BYTE *)(dword_D41A0 + 224770) = 8;
        *(_BYTE *)(v1 + 180) = 8;
        goto LABEL_36;
      }
      *(_BYTE *)(dword_D41A0 + 224770) = 0;
      v10 = *(_BYTE *)(v2 + 224779);
      *(_BYTE *)(v2 + 224772) = -56;
      if ( v10 & 1 )
      {
LABEL_36:
        sub_6E450(*(_WORD *)(v2 + 12), -1, 41);
        return;
      }
      v11 = *(signed __int16 *)(v2 + 12);
      if ( byte_3659D[11 * v11 + v2] )
        sub_6E450(v11, -1, 61);
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 1803EC: using guessed type __int16 word_1803EC;

//----- (00059A50) --------------------------------------------------------
int sub_59A50()
{
  int result; // eax

  if ( byte_D4B7A == 1 )
  {
    sub_92DC0(dword_F4940);
    byte_D4B7A = 0;
  }
  sub_8E470(*(signed __int16 *)(dword_D41A4 + 6) / 3);
  byte_D4B78 = *(_WORD *)(dword_D41A4 + 6) / 3;
  sub_8E410((_DWORD *)(*(signed __int16 *)(dword_D41A4 + 8) / 3));
  result = *(signed __int16 *)(dword_D41A4 + 8) / 3;
  byte_D4B79 = *(_WORD *)(dword_D41A4 + 8) / 3;
  *(_BYTE *)(dword_D41A4 + 38545) |= 0x40u;
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// D4B78: using guessed type char byte_D4B78;
// D4B79: using guessed type char byte_D4B79;
// D4B7A: using guessed type char byte_D4B7A;
// F4940: using guessed type int dword_F4940;

//----- (00059AF0) --------------------------------------------------------
int sub_59AF0()
{
  int result; // eax

  sub_86860(word_1803EC);
  dword_F4940 = sub_92600((int)sub_59B50);
  sub_92930(dword_F4940, 0x78u);
  sub_92BA0(dword_F4940);
  byte_D4B7A = 1;
  result = dword_D41A4;
  *(_BYTE *)(result + 38545) &= 0xBFu;
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// D4B7A: using guessed type char byte_D4B7A;
// F4940: using guessed type int dword_F4940;
// 1803EC: using guessed type __int16 word_1803EC;

//----- (00059B50) --------------------------------------------------------
int sub_59B50()
{
  __int16 v0; // bx
  __int16 v1; // dx

  v0 = *(_WORD *)(dword_D41A4 + 6);
  if ( (unsigned __int8)byte_D4B78 != v0
    || (HIBYTE(v1) = HIBYTE(v0), LOBYTE(v1) = byte_D4B79, v1 != *(_WORD *)(dword_D41A4 + 8)) )
  {
    if ( (signed __int16)(unsigned __int8)byte_D4B78 < *(_WORD *)(dword_D41A4 + 6) )
      sub_8E470((unsigned __int8)++byte_D4B78);
    if ( (signed __int16)(unsigned __int8)byte_D4B79 < *(_WORD *)(dword_D41A4 + 8) )
      sub_8E410((_DWORD *)(unsigned __int8)++byte_D4B79);
  }
  else
  {
    byte_D4B7A = 0;
    sub_92DC0(dword_F4940);
  }
  return 0;
}
// D41A4: using guessed type int dword_D41A4;
// D4B78: using guessed type char byte_D4B78;
// D4B79: using guessed type char byte_D4B79;
// D4B7A: using guessed type char byte_D4B7A;
// F4940: using guessed type int dword_F4940;

//----- (00059BF0) --------------------------------------------------------
_DWORD *sub_59BF0()
{
  if ( byte_D4B7A == 1 )
  {
    sub_92DC0(dword_F4940);
    byte_D4B7A = 0;
  }
  sub_8E470(*(signed __int16 *)(dword_D41A4 + 6));
  return sub_8E410((_DWORD *)*(signed __int16 *)(dword_D41A4 + 8));
}
// D41A4: using guessed type int dword_D41A4;
// D4B7A: using guessed type char byte_D4B7A;
// F4940: using guessed type int dword_F4940;

//----- (00059C40) --------------------------------------------------------
int __cdecl sub_59C40(int a1)
{
  int result; // eax

  result = sub_10C40((__int16 *)(a1 + 76));
  *(_WORD *)(a1 + 80) = result;
  return result;
}

//----- (00059C60) --------------------------------------------------------
int __cdecl sub_59C60(int a1)
{
  int result; // eax

  result = sub_10C40((__int16 *)(a1 + 76));
  *(_WORD *)(a1 + 80) = result;
  return result;
}

//----- (00059C80) --------------------------------------------------------
int __cdecl sub_59C80(int a1)
{
  int result; // eax
  int v2; // ebx
  unsigned int i; // ebx
  int v4; // edi
  int v5; // eax

  if ( *(_BYTE *)(dword_D41A4 + 38545) & 4 )
  {
    *(_BYTE *)(a1 + 12) |= 1u;
    result = sub_57F10(a1);
  }
  else
  {
    result = sub_10C40((__int16 *)(a1 + 76));
    v2 = dword_D41A4;
    *(_WORD *)(a1 + 80) = result;
    for ( i = *(_DWORD *)(v2 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( !*(_BYTE *)(i + 64) && *(_DWORD *)(i + 8) >= 0 )
      {
        result = sub_106C0(i, a1);
        if ( result )
        {
          v4 = *(signed __int16 *)(*(_DWORD *)(i + 164) + 56);
          if ( v4 == *(signed __int16 *)(dword_D41A0 + 12) )
          {
            if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
              v5 = 50;
            else
              v5 = 4;
            sub_6E090(*(_DWORD *)(i + 164) + 611, v5);
            sub_6E450(v4, -1, 63);
            if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
              sub_6DBD0();
            else
              sub_6DB50(0, 1);
          }
          result = sub_57F10(a1);
        }
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00059DC0) --------------------------------------------------------
char __cdecl sub_59DC0(_WORD *a1)
{
  int v1; // eax
  __int16 v2; // dx
  __int16 v3; // si
  int v4; // eax
  __int16 v5; // ST0C_2
  __int16 v6; // ST08_2
  __int16 v7; // ax
  __int16 v8; // ax
  int v10; // [esp+0h] [ebp-Ch]
  __int16 v11; // [esp+4h] [ebp-8h]
  char v12; // [esp+8h] [ebp-4h]

  v12 = 0;
  v1 = dword_EA3E4[(unsigned __int16)a1[20]];
  if ( *(_DWORD *)(v1 + 8) < 0 || *(_BYTE *)(v1 + 13) & 4 )
    return 1;
  if ( *((_DWORD *)a1 + 4) <= 5 )
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(v1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(v1 + 80);
    a1[14] = *(_WORD *)(v1 + 28);
    v2 = a1[8];
    v3 = *(_WORD *)(v1 + 30);
    a1[15] = v3;
    sub_57FA0(&word_EB398, *(_WORD *)(v1 + 28), v3 - 16 * v2, 384);
    sub_57CF0((int)a1, (int)&word_EB398);
    goto LABEL_10;
  }
  v4 = dword_EA3E4[(unsigned __int16)a1[19]];
  if ( *(_DWORD *)(v4 + 8) < 0 || *(_BYTE *)(v4 + 13) & 4 )
  {
    v12 = 1;
    goto LABEL_10;
  }
  v10 = *(_DWORD *)(v4 + 76);
  v11 = *(_WORD *)(v4 + 80);
  sub_57FA0(&v10, *(_WORD *)(v4 + 28), 0, 384);
  *(_DWORD *)&word_EB398 = *((_DWORD *)a1 + 19);
  *(&word_EB398 + 2) = a1[40];
  v5 = 32 * (a1[8] - 5);
  v6 = sub_58210(a1 + 38, &v10);
  v7 = sub_581E0(a1 + 38, &v10);
  sub_57FA0(&word_EB398, v7, v6, v5);
  sub_57CF0((int)a1, (int)&word_EB398);
  v8 = sub_10C40(a1 + 38);
  if ( (signed __int16)a1[40] >= v8 + 64 )
  {
LABEL_10:
    ++*((_DWORD *)a1 + 4);
    return v12;
  }
  a1[40] = v8;
  v12 = 1;
  ++*((_DWORD *)a1 + 4);
  return v12;
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00059F60) --------------------------------------------------------
void __cdecl sub_59F60(int a1)
{
  unsigned int v1; // eax
  int v2; // eax
  char v3; // al
  unsigned __int16 v4; // bx
  unsigned __int16 v5; // cx
  signed int v6; // eax
  unsigned __int16 v7; // bx
  unsigned __int16 v8; // cx
  signed int v9; // edx
  unsigned __int16 v10; // di
  int v11; // eax
  __int16 v12; // bx
  signed int v13; // edx
  unsigned __int16 v14; // cx
  unsigned __int16 v15; // di
  int v16; // edi
  __int16 v17; // bx
  unsigned __int16 v18; // cx
  unsigned __int8 v19; // dh
  signed int v20; // edx
  unsigned __int16 v21; // bx
  unsigned __int16 v22; // ax
  unsigned __int16 v23; // cx
  char v24; // al
  unsigned __int16 v25; // bx
  char v26; // cl
  unsigned __int16 v27; // ax
  int v28; // eax
  __int16 v29; // bx
  signed int v30; // edx
  unsigned __int16 v31; // cx
  unsigned __int16 v32; // di
  unsigned __int16 v33; // bx
  unsigned __int16 v34; // cx
  unsigned __int16 v35; // ax
  unsigned __int16 v36; // bx
  signed int v37; // eax
  signed int v38; // edx
  unsigned __int16 v39; // cx
  unsigned __int16 v40; // di
  __int16 v41; // bx
  signed int v42; // eax
  int v43; // edx
  unsigned __int16 v44; // cx
  unsigned __int16 v45; // di
  __int16 v46; // bx
  signed int v47; // edi
  unsigned __int16 v48; // cx
  unsigned __int8 v49; // dh
  signed int v50; // edx
  unsigned __int16 v51; // bx
  unsigned __int16 v52; // ax
  unsigned __int16 v53; // cx
  char v54; // al
  char v55; // cl
  unsigned __int16 v56; // ax
  signed int v57; // eax
  __int16 v58; // bx
  int v59; // edx
  unsigned __int16 v60; // cx
  unsigned __int16 v61; // di
  char v62; // al
  int v63; // eax
  unsigned __int16 v64; // bx
  unsigned __int16 v65; // cx
  signed int v66; // edx
  unsigned __int16 v67; // di
  int v68; // edx
  __int16 v69; // bx
  signed int v70; // eax
  unsigned __int16 v71; // cx
  unsigned __int16 v72; // di
  int v73; // edx
  __int16 j; // bx
  signed int v75; // eax
  unsigned __int16 v76; // cx
  unsigned __int16 v77; // di
  __int16 v78; // bx
  signed int v79; // edx
  int v80; // eax
  unsigned __int16 v81; // cx
  unsigned __int16 v82; // di
  signed int v83; // edx
  __int16 v84; // bx
  int v85; // eax
  unsigned __int16 v86; // cx
  unsigned __int16 v87; // di
  signed int v88; // edx
  __int16 v89; // bx
  int v90; // eax
  unsigned __int16 v91; // cx
  unsigned __int16 v92; // di
  char v93; // al
  int v94; // eax
  int v95; // ebx
  unsigned __int16 v96; // dx
  char v97; // cl
  unsigned __int16 v98; // dx
  int v99; // edx
  unsigned __int16 k; // bx
  unsigned __int8 v101; // ch
  unsigned __int8 v102; // ch
  int v103; // eax
  int v104; // ebx
  unsigned __int16 v105; // dx
  char v106; // cl
  int v107; // ebx
  unsigned __int16 v108; // dx
  int v109; // edx
  int v110; // ebx
  unsigned __int8 v111; // ch
  int v112; // ebx
  unsigned __int8 v113; // ch
  char v114; // al
  signed int v115; // edx
  unsigned __int16 l; // bx
  unsigned __int16 v117; // ax
  unsigned __int16 v118; // cx
  char v119; // al
  unsigned __int16 v120; // bx
  char v121; // cl
  unsigned __int16 v122; // ax
  unsigned __int16 v123; // bx
  signed int v124; // edx
  unsigned __int16 v125; // ax
  unsigned __int16 v126; // cx
  char v127; // al
  unsigned __int16 v128; // bx
  char v129; // cl
  unsigned __int16 v130; // ax
  int v131; // edx
  char v132; // al
  int v133; // edx
  unsigned __int16 m; // bx
  unsigned __int16 v135; // ax
  int v136; // ecx
  int v137; // edi
  int v138; // ecx
  int v139; // edx
  int v140; // ebx
  int v141; // ecx
  int v142; // edi
  int v143; // ebx
  int v144; // ecx
  __int16 v145; // di
  char v146; // al
  int v147; // edx
  unsigned __int16 v148; // bx
  unsigned __int16 v149; // ax
  unsigned __int16 v150; // di
  unsigned __int16 v151; // di
  unsigned __int16 v152; // di
  char v153; // ch
  char v154; // cl
  unsigned __int16 v155; // di
  char v156; // ah
  int v157; // edx
  unsigned __int16 v158; // bx
  unsigned __int8 v159; // ch
  unsigned __int8 v160; // ch
  unsigned __int8 v161; // ch
  unsigned __int8 v162; // ch
  int v163; // edx
  __int16 v164; // bx
  unsigned __int16 v165; // bx
  unsigned __int16 v166; // ax
  char v167; // dh
  unsigned __int16 v168; // ax
  char v169; // cl
  signed int v170; // eax
  unsigned __int16 v171; // cx
  unsigned __int16 v172; // di
  int v173; // edx
  int v174; // ebx
  unsigned __int16 v175; // ax
  int v176; // ebx
  unsigned __int16 v177; // di
  unsigned __int16 v178; // di
  unsigned __int16 v179; // di
  char v180; // ch
  char v181; // cl
  unsigned __int16 v182; // di
  char v183; // ah
  int v184; // edx
  int v185; // ebx
  int v186; // ebx
  unsigned __int8 v187; // ch
  int v188; // ebx
  unsigned __int8 v189; // ch
  int v190; // ebx
  unsigned __int8 v191; // ch
  int v192; // ebx
  unsigned __int8 v193; // ch
  signed int v194; // eax
  __int16 v195; // bx
  unsigned __int16 v196; // bx
  unsigned __int16 v197; // ax
  int v198; // edx
  unsigned __int16 v199; // cx
  unsigned __int16 v200; // di
  signed int v201; // [esp+4h] [ebp-1Ch]
  int v202; // [esp+8h] [ebp-18h]
  signed int v203; // [esp+Ch] [ebp-14h]
  int i; // [esp+10h] [ebp-10h]
  signed int v205; // [esp+14h] [ebp-Ch]
  int v206; // [esp+18h] [ebp-8h]
  int v207; // [esp+1Ch] [ebp-4h]
  unsigned __int16 v208; // [esp+1Ch] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 < 1 )
  {
    if ( !v1 )
    {
      LOBYTE(v208) = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
      v2 = (*(signed __int16 *)(a1 + 78) + 128) >> 8;
      HIBYTE(v208) = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
      BYTE1(v2) = *(_BYTE *)(a1 + 70);
      ++*(_DWORD *)(a1 + 16);
      if ( BYTE1(v2) )
        HIBYTE(v208) = v2 - 1;
      else
        --v208;
      v3 = *(_BYTE *)(a1 + 70);
      if ( v3 )
      {
        if ( v3 == 1 )
        {
          v33 = v208;
          v201 = 0;
          do
          {
            v34 = v33;
            for ( i = 0; i < *(_DWORD *)(a1 + 16); ++i )
            {
              if ( byte_10B4E0[v34] != 8
                || (LOBYTE(v35) = v33,
                    HIBYTE(v35) = HIBYTE(v34) + 1,
                    abs((unsigned __int8)byte_11B4E0[v34] - (unsigned __int8)byte_11B4E0[v35]) > 30) )
              {
                byte_11B4E0[v34] += 48;
              }
              ++HIBYTE(v34);
            }
            --v33;
            ++v201;
          }
          while ( v201 < 2 );
          v36 = v208;
          v37 = 0;
          while ( v37 < 3 )
          {
            v38 = -1;
            v39 = v36 - 256;
            while ( v38 < *(_DWORD *)(a1 + 16) )
            {
              v40 = v39;
              ++v38;
              ++HIBYTE(v39);
              byte_10B4E0[v40] = 8;
              byte_13B4E0[v40] = 1;
            }
            ++v37;
            --v36;
          }
          if ( byte_D41B6 )
          {
            v46 = v208 + 1;
            v47 = 0;
            while ( v47 < 4 )
            {
              v202 = -1;
              v48 = v46 - 256;
              while ( *(_DWORD *)(a1 + 16) + 1 > v202 )
              {
                v49 = byte_11B4E0[v48];
                if ( (unsigned __int8)byte_14B4E0[v48] > v49 )
                {
                  byte_13B4E0[v48] &= 0xF7u;
                }
                else
                {
                  byte_14B4E0[v48] = v49 - 1;
                  byte_13B4E0[v48] |= 8u;
                }
                ++HIBYTE(v48);
                ++v202;
              }
              ++v47;
              --v46;
            }
          }
          else
          {
            v41 = v208 + 1;
            v42 = 0;
            while ( v42 < 4 )
            {
              v43 = -1;
              v44 = v41 - 256;
              while ( v43 < *(_DWORD *)(a1 + 16) + 1 )
              {
                v45 = v44;
                ++v43;
                ++HIBYTE(v44);
                byte_13B4E0[v45] &= 0xF7u;
              }
              ++v42;
              --v41;
            }
          }
          v50 = -1;
          v51 = v208 - 256;
          while ( v50 < *(_DWORD *)(a1 + 16) )
          {
            LOBYTE(v51) = v51 + 1;
            ++HIBYTE(v51);
            v52 = v51;
            LOBYTE(v51) = v51 - 2;
            HIBYTE(v51) -= 2;
            v53 = v51;
            LOBYTE(v51) = v51 + 1;
            v54 = byte_11B4E0[v53] - byte_11B4E0[v52] + 32;
            ++HIBYTE(v51);
            if ( v54 >= 28 )
            {
              if ( v54 > 40 )
                v54 = (v54 & 7) + 40;
            }
            else
            {
              v54 = (v54 & 3) + 28;
            }
            if ( *(_BYTE *)(dword_D41A0 + 196308) )
              v55 = 32 - v54 + 32;
            else
              v55 = v54;
            v56 = v51;
            ++v50;
            ++HIBYTE(v51);
            byte_12B4E0[v56] = v55;
          }
          v57 = -3;
          v58 = v208 - 3;
          while ( v57 < 6 )
          {
            v59 = -3;
            v60 = v58 - 768;
            while ( v59 < *(_DWORD *)(a1 + 16) + 3 )
            {
              v61 = v60;
              ++v59;
              ++HIBYTE(v60);
              byte_13B4E0[v61] |= 0x80u;
            }
            ++v57;
            ++v58;
          }
        }
        *(_WORD *)(a1 + 42) = 48;
        *(_DWORD *)(a1 + 8) = 3;
      }
      else
      {
        v206 = 0;
        v4 = v208;
        while ( v206 < *(_DWORD *)(a1 + 16) )
        {
          v205 = 0;
          v5 = v4;
          while ( v205 < 2 )
          {
            if ( byte_10B4E0[v5] != 8
              || abs((unsigned __int8)byte_11B4E0[v5] - (unsigned __int8)byte_11B4E0[(unsigned __int16)(v5 + 1)]) > 30 )
            {
              byte_11B4E0[v5] += 48;
            }
            --HIBYTE(v5);
            ++v205;
          }
          ++v4;
          ++v206;
        }
        v6 = -1;
        v7 = v208 - 1;
        while ( v6 < *(_DWORD *)(a1 + 16) )
        {
          v8 = v7;
          v9 = 0;
          while ( v9 < 3 )
          {
            v10 = v8;
            ++v9;
            --HIBYTE(v8);
            byte_10B4E0[v10] = 8;
            byte_13B4E0[v10] = 1;
          }
          ++v6;
          ++v7;
        }
        if ( byte_D41B6 )
        {
          v16 = -1;
          v17 = v208 - 1;
          while ( v16 < *(_DWORD *)(a1 + 16) + 1 )
          {
            v203 = 0;
            v18 = v17 + 256;
            while ( v203 < 4 )
            {
              v19 = byte_11B4E0[v18];
              if ( (unsigned __int8)byte_14B4E0[v18] > v19 )
              {
                byte_13B4E0[v18] &= 0xF7u;
              }
              else
              {
                byte_14B4E0[v18] = v19 - 1;
                byte_13B4E0[v18] |= 8u;
              }
              --HIBYTE(v18);
              ++v203;
            }
            ++v16;
            ++v17;
          }
        }
        else
        {
          v11 = -1;
          v12 = v208 - 1;
          while ( v11 < *(_DWORD *)(a1 + 16) + 1 )
          {
            v13 = 0;
            v14 = v12 + 256;
            while ( v13 < 4 )
            {
              v15 = v14;
              ++v13;
              --HIBYTE(v14);
              byte_13B4E0[v15] &= 0xF7u;
            }
            ++v11;
            ++v12;
          }
        }
        v20 = -1;
        v21 = v208 - 1;
        while ( v20 < *(_DWORD *)(a1 + 16) )
        {
          LOBYTE(v21) = v21 + 1;
          ++HIBYTE(v21);
          v22 = v21;
          LOBYTE(v21) = v21 - 2;
          HIBYTE(v21) -= 2;
          v23 = v21;
          LOBYTE(v21) = v21 + 1;
          v24 = byte_11B4E0[v23] - byte_11B4E0[v22] + 32;
          HIBYTE(v25) = HIBYTE(v21) + 1;
          if ( v24 >= 28 )
          {
            if ( v24 > 40 )
              v24 = (v24 & 7) + 40;
          }
          else
          {
            v24 = (v24 & 3) + 28;
          }
          if ( *(_BYTE *)(dword_D41A0 + 196308) )
            v26 = 32 - v24 + 32;
          else
            v26 = v24;
          v27 = v25;
          ++v20;
          v21 = v25 + 1;
          byte_12B4E0[v27] = v26;
        }
        v28 = -3;
        v29 = v208 - 3;
        while ( v28 < *(_DWORD *)(a1 + 16) + 3 )
        {
          v30 = -3;
          v31 = v29 + 768;
          while ( v30 < 6 )
          {
            v32 = v31;
            ++v30;
            --HIBYTE(v31);
            byte_13B4E0[v32] |= 0x80u;
          }
          ++v28;
          ++v29;
        }
        *(_WORD *)(a1 + 42) = 48;
        *(_DWORD *)(a1 + 8) = 3;
      }
    }
    return;
  }
  if ( v1 <= 1 )
  {
    if ( *(_WORD *)(a1 + 42) < 0x30u )
    {
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 47);
      LOBYTE(v207) = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
      if ( *(_BYTE *)(a1 + 70) )
      {
        BYTE1(v207) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - 1;
      }
      else
      {
        BYTE1(v207) = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
        LOWORD(v207) = v207 - 1;
      }
      if ( !*(_WORD *)(a1 + 42) )
      {
        v62 = *(_BYTE *)(a1 + 70);
        if ( v62 )
        {
          if ( v62 == 1 )
          {
            v78 = v207;
            v79 = 0;
            while ( v79 < 3 )
            {
              v80 = 2;
              v81 = v78 + 512;
              while ( v80 < *(_DWORD *)(a1 + 16) - 3 )
              {
                v82 = v81;
                ++v80;
                ++HIBYTE(v81);
                byte_10B4E0[v82] = 8;
                byte_13B4E0[v82] = 1;
              }
              ++v79;
              --v78;
            }
            if ( !byte_D41B6 )
            {
              v83 = 0;
              v84 = v207 + 1;
              while ( v83 < 4 )
              {
                v85 = 2;
                v86 = v84 + 512;
                while ( v85 < *(_DWORD *)(a1 + 16) - 2 )
                {
                  v87 = v86;
                  ++v85;
                  ++HIBYTE(v86);
                  byte_13B4E0[v87] &= 0xF7u;
                }
                ++v83;
                --v84;
              }
            }
            v88 = -3;
            v89 = v207 - 3;
            while ( v88 < 6 )
            {
              v90 = -3;
              v91 = v89 - 768;
              while ( v90 < *(_DWORD *)(a1 + 16) + 3 )
              {
                v92 = v91;
                ++v90;
                ++HIBYTE(v91);
                byte_13B4E0[v92] |= 0x80u;
              }
              ++v88;
              ++v89;
            }
          }
        }
        else
        {
          v63 = 2;
          v64 = v207 + 2;
          while ( v63 < *(_DWORD *)(a1 + 16) - 3 )
          {
            v65 = v64;
            v66 = 0;
            while ( v66 < 3 )
            {
              v67 = v65;
              ++v66;
              --HIBYTE(v65);
              byte_10B4E0[v67] = 8;
              byte_13B4E0[v67] = 1;
            }
            ++v63;
            ++v64;
          }
          if ( !byte_D41B6 )
          {
            v68 = 2;
            v69 = v207 + 2;
            while ( v68 < *(_DWORD *)(a1 + 16) - 2 )
            {
              v70 = 0;
              v71 = v69 + 256;
              while ( v70 < 4 )
              {
                v72 = v71;
                ++v70;
                --HIBYTE(v71);
                byte_13B4E0[v72] &= 0xF7u;
              }
              ++v68;
              ++v69;
            }
          }
          v73 = -3;
          for ( j = v207 - 3; v73 < *(_DWORD *)(a1 + 16) + 3; ++j )
          {
            v75 = -3;
            v76 = j + 768;
            while ( v75 < 6 )
            {
              v77 = v76;
              ++v75;
              --HIBYTE(v76);
              byte_13B4E0[v77] |= 0x80u;
            }
            ++v73;
          }
        }
      }
      ++*(_WORD *)(a1 + 42);
      v93 = *(_BYTE *)(a1 + 70);
      if ( v93 )
      {
        if ( v93 == 1 )
        {
          v104 = v207;
          v103 = 3;
          BYTE1(v104) += 3;
          while ( v103 < *(_DWORD *)(a1 + 16) - 3 )
          {
            v105 = v104;
            v106 = byte_11B4E0[(unsigned __int16)v104] + 1;
            v107 = v104 - 1;
            byte_11B4E0[v105] = v106;
            v108 = v107;
            ++v103;
            v104 = v107 + 1;
            ++BYTE1(v104);
            ++byte_11B4E0[v108];
          }
          if ( byte_D41B6 )
          {
            v110 = v207;
            v109 = 3;
            BYTE1(v110) += 3;
            while ( v109 < *(_DWORD *)(a1 + 16) - 3 )
            {
              v111 = byte_11B4E0[(unsigned __int16)v110];
              if ( (unsigned __int8)byte_14B4E0[(unsigned __int16)v110] > v111 )
              {
                byte_13B4E0[(unsigned __int16)v110] &= 0xF7u;
              }
              else
              {
                byte_14B4E0[(unsigned __int16)v110] = v111 - 1;
                byte_13B4E0[(unsigned __int16)v110] |= 8u;
              }
              v112 = v110 - 1;
              v113 = byte_11B4E0[(unsigned __int16)v112];
              if ( (unsigned __int8)byte_14B4E0[(unsigned __int16)v112] > v113 )
              {
                byte_13B4E0[(unsigned __int16)v112] &= 0xF7u;
              }
              else
              {
                byte_14B4E0[(unsigned __int16)v112] = v113 - 1;
                byte_13B4E0[(unsigned __int16)v112] |= 8u;
              }
              v110 = v112 + 1;
              ++v109;
              ++BYTE1(v110);
            }
          }
        }
      }
      else
      {
        v94 = 3;
        v95 = v207 + 3;
        while ( v94 < *(_DWORD *)(a1 + 16) - 3 )
        {
          v96 = v95;
          v97 = byte_11B4E0[(unsigned __int16)v95] + 1;
          --BYTE1(v95);
          byte_11B4E0[v96] = v97;
          v98 = v95;
          ++v94;
          ++BYTE1(v95);
          ++v95;
          ++byte_11B4E0[v98];
        }
        if ( byte_D41B6 )
        {
          v99 = 3;
          for ( k = v207 + 3; v99 < *(_DWORD *)(a1 + 16) - 3; ++k )
          {
            v101 = byte_11B4E0[k];
            if ( (unsigned __int8)byte_14B4E0[k] > v101 )
            {
              byte_13B4E0[k] &= 0xF7u;
            }
            else
            {
              byte_14B4E0[k] = v101 - 1;
              byte_13B4E0[k] |= 8u;
            }
            --HIBYTE(k);
            v102 = byte_11B4E0[k];
            if ( (unsigned __int8)byte_14B4E0[k] > v102 )
            {
              byte_13B4E0[k] &= 0xF7u;
            }
            else
            {
              byte_14B4E0[k] = v102 - 1;
              byte_13B4E0[k] |= 8u;
            }
            ++HIBYTE(k);
            ++v99;
          }
        }
      }
      if ( *(_WORD *)(a1 + 42) >= 0x30u )
      {
        v114 = *(_BYTE *)(a1 + 70);
        if ( v114 )
        {
          if ( v114 == 1 )
          {
            v123 = v207;
            v124 = 0;
            do
            {
              LOBYTE(v123) = v123 + 1;
              ++HIBYTE(v123);
              v125 = v123;
              LOBYTE(v123) = v123 - 2;
              HIBYTE(v123) -= 2;
              v126 = v123;
              LOBYTE(v123) = v123 + 1;
              v127 = byte_11B4E0[v126] - byte_11B4E0[v125] + 32;
              HIBYTE(v128) = HIBYTE(v123) + 1;
              if ( v127 >= 28 )
              {
                if ( v127 > 40 )
                  v127 = (v127 & 7) + 40;
              }
              else
              {
                v127 = (v127 & 3) + 28;
              }
              if ( *(_BYTE *)(dword_D41A0 + 196308) )
                v129 = 32 - v127 + 32;
              else
                v129 = v127;
              v130 = v128;
              ++v124;
              v123 = v128 + 1;
              byte_12B4E0[v130] = v129;
            }
            while ( v124 < 3 );
          }
        }
        else
        {
          v115 = -1;
          for ( l = v207 - 1; v115 < *(_DWORD *)(a1 + 16); byte_12B4E0[v122] = v121 )
          {
            LOBYTE(l) = l + 1;
            ++HIBYTE(l);
            v117 = l;
            LOBYTE(l) = l - 2;
            HIBYTE(l) -= 2;
            v118 = l;
            LOBYTE(l) = l + 1;
            v119 = byte_11B4E0[v118] - byte_11B4E0[v117] + 32;
            HIBYTE(v120) = HIBYTE(l) + 1;
            if ( v119 >= 28 )
            {
              if ( v119 > 40 )
                v119 = (v119 & 7) + 40;
            }
            else
            {
              v119 = (v119 & 3) + 28;
            }
            if ( *(_BYTE *)(dword_D41A0 + 196308) )
              v121 = 32 - v119 + 32;
            else
              v121 = v119;
            v122 = v120;
            ++v115;
            l = v120 + 1;
          }
        }
      }
      return;
    }
    v131 = dword_D41A0 + 28302;
    *(_DWORD *)(a1 + 8) = 3;
LABEL_292:
    sub_6EAB0((signed __int16)((a1 - v131) / 168), -1, 47);
    return;
  }
  if ( v1 != 2 )
    return;
  if ( !*(_WORD *)(a1 + 42) )
  {
    v131 = dword_D41A0 + 28302;
    *(_DWORD *)(a1 + 8) = 4;
    goto LABEL_292;
  }
  sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 47);
  LOBYTE(v207) = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
  if ( *(_BYTE *)(a1 + 70) )
  {
    BYTE1(v207) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - 1;
  }
  else
  {
    BYTE1(v207) = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
    LOWORD(v207) = v207 - 1;
  }
  v132 = *(_BYTE *)(a1 + 70);
  if ( v132 )
  {
    if ( v132 == 1 )
    {
      v140 = v207;
      v139 = 3;
      BYTE1(v140) += 3;
      while ( v139 < *(_DWORD *)(a1 + 16) - 3 )
      {
        v141 = (unsigned __int8)byte_11B4E0[(unsigned __int16)v140];
        v142 = ((unsigned __int8)byte_11B4E0[(unsigned __int16)(v140 - 2)]
              + (unsigned __int8)byte_11B4E0[(unsigned __int16)(v140 + 1)]) >> 1;
        if ( v142 < v141 )
          byte_11B4E0[(unsigned __int16)v140] = v141 - 1;
        v143 = v140 - 1;
        v144 = (unsigned __int8)byte_11B4E0[(unsigned __int16)v143];
        if ( v142 < v144 )
          byte_11B4E0[(unsigned __int16)v143] = v144 - 1;
        v140 = v143 + 1;
        ++v139;
        ++BYTE1(v140);
      }
    }
  }
  else
  {
    v133 = 3;
    for ( m = v207 + 3; v133 < *(_DWORD *)(a1 + 16) - 3; ++m )
    {
      v135 = m + 256;
      HIBYTE(v135) = HIBYTE(m) - 2;
      v136 = (unsigned __int8)byte_11B4E0[m];
      v137 = ((unsigned __int8)byte_11B4E0[v135] + (unsigned __int8)byte_11B4E0[(unsigned __int16)(m + 256)]) >> 1;
      if ( v137 < v136 )
        byte_11B4E0[m] = v136 - 1;
      --HIBYTE(m);
      v138 = (unsigned __int8)byte_11B4E0[m];
      if ( v137 < v138 )
        byte_11B4E0[m] = v138 - 1;
      ++HIBYTE(m);
      ++v133;
    }
  }
  v145 = *(_WORD *)(a1 + 42) - 1;
  *(_WORD *)(a1 + 42) = v145;
  if ( !v145 )
  {
    v146 = *(_BYTE *)(a1 + 70);
    if ( v146 )
    {
      if ( v146 != 1 )
        return;
      v174 = v207;
      v173 = 3;
      BYTE1(v174) += 3;
      while ( v173 < *(_DWORD *)(a1 + 16) - 4 )
      {
        v175 = v174 + 2;
        if ( byte_10B4E0[(unsigned __int16)(v174 + 2)] == 8 )
          HIBYTE(v175) += *(_DWORD *)(a1 + 16) >> 1;
        v176 = v174 + 1;
        v177 = v176;
        byte_10B4E0[(unsigned __int16)v176] = byte_10B4E0[v175];
        byte_13B4E0[(unsigned __int16)v176] = byte_13B4E0[v175];
        byte_12B4E0[(unsigned __int16)v176--] = 32;
        byte_13B4E0[v177] |= 0x80u;
        v178 = v176;
        byte_10B4E0[(unsigned __int16)v176] = byte_10B4E0[v175];
        byte_13B4E0[(unsigned __int16)v176] = byte_13B4E0[v175];
        byte_12B4E0[(unsigned __int16)v176--] = 32;
        byte_13B4E0[v178] |= 0x80u;
        v179 = v176;
        byte_10B4E0[(unsigned __int16)v176] = byte_10B4E0[v175];
        byte_13B4E0[(unsigned __int16)v176] = byte_13B4E0[v175];
        byte_12B4E0[(unsigned __int16)v176] = 32;
        v180 = byte_13B4E0[(unsigned __int16)v176--] | 0x80;
        byte_13B4E0[v179] = v180;
        v181 = byte_10B4E0[v175];
        v182 = v176;
        ++v173;
        byte_13B4E0[(unsigned __int16)v176] = byte_13B4E0[v175];
        v174 = v176 + 2;
        byte_12B4E0[v182] = 32;
        v183 = byte_13B4E0[v182];
        byte_10B4E0[v182] = v181;
        ++BYTE1(v174);
        byte_13B4E0[v182] = v183 | 0x80;
      }
      if ( byte_D41B6 )
      {
        v185 = v207;
        v184 = 3;
        BYTE1(v185) += 3;
        if ( *(_DWORD *)(a1 + 16) - 4 > 3 )
        {
          do
          {
            v186 = v185 + 1;
            v187 = byte_11B4E0[(unsigned __int16)v186];
            if ( (unsigned __int8)byte_14B4E0[(unsigned __int16)v186] > v187 )
            {
              byte_13B4E0[(unsigned __int16)v186] &= 0xF7u;
            }
            else
            {
              byte_14B4E0[(unsigned __int16)v186] = v187 - 1;
              byte_13B4E0[(unsigned __int16)v186] |= 8u;
            }
            v188 = v186 - 1;
            v189 = byte_11B4E0[(unsigned __int16)v188];
            if ( (unsigned __int8)byte_14B4E0[(unsigned __int16)v188] > v189 )
            {
              byte_13B4E0[(unsigned __int16)v188] &= 0xF7u;
            }
            else
            {
              byte_14B4E0[(unsigned __int16)v188] = v189 - 1;
              byte_13B4E0[(unsigned __int16)v188] |= 8u;
            }
            v190 = v188 - 1;
            v191 = byte_11B4E0[(unsigned __int16)v190];
            if ( (unsigned __int8)byte_14B4E0[(unsigned __int16)v190] > v191 )
            {
              byte_13B4E0[(unsigned __int16)v190] &= 0xF7u;
            }
            else
            {
              byte_14B4E0[(unsigned __int16)v190] = v191 - 1;
              byte_13B4E0[(unsigned __int16)v190] |= 8u;
            }
            v192 = v190 - 1;
            v193 = byte_11B4E0[(unsigned __int16)v192];
            if ( (unsigned __int8)byte_14B4E0[(unsigned __int16)v192] > v193 )
            {
              byte_13B4E0[(unsigned __int16)v192] &= 0xF7u;
            }
            else
            {
              byte_14B4E0[(unsigned __int16)v192] = v193 - 1;
              byte_13B4E0[(unsigned __int16)v192] |= 8u;
            }
            v185 = v192 + 2;
            ++v184;
            ++BYTE1(v185);
          }
          while ( v184 < *(_DWORD *)(a1 + 16) - 4 );
          v194 = -3;
          v195 = v207 - 3;
          goto LABEL_286;
        }
      }
      else
      {
        v196 = v207 + 768;
        byte_13B4E0[(unsigned __int16)(v196 + 1)] &= 0xF7u;
        byte_13B4E0[v196] &= 0xF7u;
        v197 = v207 + 767;
        byte_13B4E0[v197] = byte_13B4E0[(unsigned __int16)(v207 + 767)] & 0xF7;
        byte_13B4E0[(unsigned __int16)(v197 - 1)] &= 0xF7u;
      }
      v194 = -3;
      v195 = v207 - 3;
      do
      {
LABEL_286:
        v198 = -3;
        v199 = v195 - 768;
        while ( v198 < *(_DWORD *)(a1 + 16) + 3 )
        {
          v200 = v199;
          ++v198;
          ++HIBYTE(v199);
          byte_13B4E0[v200] |= 0x80u;
        }
        ++v194;
        ++v195;
      }
      while ( v194 < 6 );
      return;
    }
    v147 = 3;
    v148 = v207 + 3;
    while ( v147 < *(_DWORD *)(a1 + 16) - 4 )
    {
      v149 = v148 + 512;
      if ( byte_10B4E0[(unsigned __int16)(v148 + 512)] == 8 )
        v149 += *(_DWORD *)(a1 + 16) >> 1;
      ++HIBYTE(v148);
      v150 = v148;
      byte_10B4E0[v148] = byte_10B4E0[v149];
      byte_13B4E0[v148] = byte_13B4E0[v149];
      byte_12B4E0[v148] = 32;
      --HIBYTE(v148);
      byte_13B4E0[v150] |= 0x80u;
      v151 = v148;
      byte_10B4E0[v148] = byte_10B4E0[v149];
      byte_13B4E0[v148] = byte_13B4E0[v149];
      byte_12B4E0[v148] = 32;
      --HIBYTE(v148);
      byte_13B4E0[v151] |= 0x80u;
      v152 = v148;
      byte_10B4E0[v148] = byte_10B4E0[v149];
      byte_13B4E0[v148] = byte_13B4E0[v149];
      byte_12B4E0[v148] = 32;
      v153 = byte_13B4E0[v148] | 0x80;
      --HIBYTE(v148);
      byte_13B4E0[v152] = v153;
      v154 = byte_10B4E0[v149];
      v155 = v148;
      ++v147;
      byte_13B4E0[v148] = byte_13B4E0[v149];
      HIBYTE(v148) += 2;
      byte_12B4E0[v155] = 32;
      v156 = byte_13B4E0[v155];
      byte_10B4E0[v155] = v154;
      ++v148;
      byte_13B4E0[v155] = v156 | 0x80;
    }
    if ( byte_D41B6 )
    {
      v157 = 3;
      v158 = v207 + 3;
      if ( *(_DWORD *)(a1 + 16) - 4 > 3 )
      {
        do
        {
          ++HIBYTE(v158);
          v159 = byte_11B4E0[v158];
          if ( (unsigned __int8)byte_14B4E0[v158] > v159 )
          {
            byte_13B4E0[v158] &= 0xF7u;
          }
          else
          {
            byte_14B4E0[v158] = v159 - 1;
            byte_13B4E0[v158] |= 8u;
          }
          --HIBYTE(v158);
          v160 = byte_11B4E0[v158];
          if ( (unsigned __int8)byte_14B4E0[v158] > v160 )
          {
            byte_13B4E0[v158] &= 0xF7u;
          }
          else
          {
            byte_14B4E0[v158] = v160 - 1;
            byte_13B4E0[v158] |= 8u;
          }
          --HIBYTE(v158);
          v161 = byte_11B4E0[v158];
          if ( (unsigned __int8)byte_14B4E0[v158] > v161 )
          {
            byte_13B4E0[v158] &= 0xF7u;
          }
          else
          {
            byte_14B4E0[v158] = v161 - 1;
            byte_13B4E0[v158] |= 8u;
          }
          --HIBYTE(v158);
          v162 = byte_11B4E0[v158];
          if ( (unsigned __int8)byte_14B4E0[v158] > v162 )
          {
            byte_13B4E0[v158] &= 0xF7u;
          }
          else
          {
            byte_14B4E0[v158] = v162 - 1;
            byte_13B4E0[v158] |= 8u;
          }
          HIBYTE(v158) += 2;
          ++v157;
          ++v158;
        }
        while ( v157 < *(_DWORD *)(a1 + 16) - 4 );
        v163 = -3;
        v164 = v207 - 3;
        goto LABEL_261;
      }
    }
    else
    {
      v165 = v207 + 259;
      HIBYTE(v165) = (unsigned __int16)(v207 + 3) >> 8;
      byte_13B4E0[(unsigned __int16)(v207 + 259)] &= 0xF7u;
      v166 = v165;
      v167 = byte_13B4E0[v165] & 0xF7;
      --HIBYTE(v165);
      byte_13B4E0[v166] = v167;
      v168 = v165;
      v169 = byte_13B4E0[v165] & 0xF7;
      --HIBYTE(v165);
      byte_13B4E0[v168] = v169;
      byte_13B4E0[v165] &= 0xF7u;
    }
    v163 = -3;
    v164 = v207 - 3;
LABEL_261:
    while ( v163 < *(_DWORD *)(a1 + 16) + 3 )
    {
      v170 = -3;
      v171 = v164 + 768;
      while ( v170 < 6 )
      {
        v172 = v171;
        ++v170;
        --HIBYTE(v171);
        byte_13B4E0[v172] |= 0x80u;
      }
      ++v163;
      ++v164;
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;

//----- (0005B070) --------------------------------------------------------
unsigned int __cdecl sub_5B070(int a1)
{
  int v1; // eax
  char v2; // dl
  char v3; // bl
  unsigned int result; // eax

  v1 = word_15B4E0[((unsigned __int8)((unsigned __int16)(*(_WORD *)(a1 + 78) - 128) >> 8) << 8)
                 + ((unsigned __int16)(*(_WORD *)(a1 + 76) - 128) >> 8)];
  v2 = 0;
  while ( 1 )
  {
    result = dword_EA3E4[v1];
    if ( result <= dword_EA3E4[0] )
      break;
    if ( *(_BYTE *)(result + 63) == 14 )
    {
      v3 = *(_BYTE *)(result + 64);
      if ( v3 == 1 || v3 == 2 )
      {
        v2 = 1;
        break;
      }
    }
    v1 = *(unsigned __int16 *)(result + 22);
  }
  if ( !v2 )
    result = 0;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005B100) --------------------------------------------------------
void __cdecl sub_5B100(int a1)
{
  int v1; // edi
  char v2; // ST60_1
  char v3; // ST61_1
  unsigned int v4; // eax
  int v69; // [esp+0h] [ebp-68h]
  int v78; // [esp+3Ch] [ebp-2Ch]

  if ( *(_DWORD *)(a1 + 8) <= 2u )
  {
    v1 = *(signed __int16 *)(a1 + 80);
    if ( *(_WORD *)(a1 + 44) )
    {
      v69 = (2 * ((*(unsigned __int16 *)(a1 + 150) << 8) + 512) + 128) >> 8;
      v78 = 2;
    }
    else
    {
      v78 = (2 * ((*(unsigned __int16 *)(a1 + 150) << 8) + 512) + 128) >> 8;
      v69 = 2;
    }
    v2 = (*(_WORD *)(a1 + 76) >> 8) - (v69 >> 1);
    v3 = (*(_WORD *)(a1 + 78) >> 8) - (v78 >> 1);
  }
  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 <= 4 )
    JUMPOUT(__CS__, *(&off_5B0E4 + v4));
}
// 5B0E4: using guessed type void *off_5B0E4;
// D41A0: using guessed type int dword_D41A0;

//----- (0005B7A0) --------------------------------------------------------
int sub_5B7A0()
{
  int v0; // ebx
  unsigned int v1; // edx
  int *v2; // ecx
  signed int i; // eax
  int v4; // edi
  int v6; // [esp+0h] [ebp-Ch]
  int v7; // [esp+4h] [ebp-8h]

  v0 = byte_D41B5;
  sub_3B4D0(byte_D41B5);
  v1 = 0x100u % (256 / v0);
  v2 = dword_DDF50;
  for ( i = 0; i < (signed int)(0x100u / (256 / v0)); ++i )
  {
    v1 = 0;
    while ( v1 < 256 / v0 )
    {
      v6 = v1 * v0 + dword_E9C2C;
      v7 = i * v0 << 8;
      ++v2;
      v4 = v7 + v6;
      ++v1;
      *(v2 - 1) = v4;
    }
  }
  _wcpp_1_unwind_leave__93(i, v1, v0, v2, v6, v7);
  return sub_5B840();
}
// 5B830: using guessed type int __fastcall _wcpp_1_unwind_leave__93(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// D41B5: using guessed type char byte_D41B5;
// DDF50: using guessed type int dword_DDF50[];
// E9C2C: using guessed type int dword_E9C2C;

//----- (0005B840) --------------------------------------------------------
int sub_5B840()
{
  sub_53E60((int)aDataPald0Dat_0, (char *)dword_EA3D8);
  return sub_53E60((int)aDataClrd0Dat_0, byte_E8900);
}
// EA3D8: using guessed type int dword_EA3D8;

//----- (0005B870) --------------------------------------------------------
int __cdecl sub_5B870(_BYTE *a1, int a2, int a3)
{
  _BYTE *v3; // edx
  int v4; // ecx
  int result; // eax
  _DWORD *v6; // ebx
  _BYTE *v7; // ebx

  v3 = a1;
  v4 = a3;
  result = 0;
  while ( (_WORD)--v4 != -1 )
  {
    v6 = (_DWORD *)(a2 + 4 * result++);
    *v6 = v3;
    do
      v7 = v3++;
    while ( *v7 );
  }
  return result;
}

//----- (0005B8D0) --------------------------------------------------------
char sub_5B8D0()
{
  int v0; // eax
  int v1; // ebx
  int v2; // eax
  int v3; // edx

  sub_70890();
  if ( *(_BYTE *)(dword_D41A4 + 25) & 8 )
    sub_5C490();
  if ( sub_53D10(*(_BYTE *)(dword_D41A4 + 182), (int)aNetherw_2, aSave_0) != 3
    || sub_53D10(*(_BYTE *)(dword_D41A4 + 182), (int)aNetherw_2, aCdata_0) != 3
    || sub_53D10(*(_BYTE *)(dword_D41A4 + 182), (int)aNetherw_2, aClevels_0) != 3
    || sub_53D10(*(_BYTE *)(dword_D41A4 + 182), (int)aNetherw_2, aSound_1) != 3
    || sub_53D10(*(_BYTE *)(dword_D41A4 + 182), (int)aNetherw_2, aLanguage) != 3
    || sub_53D10(*(_BYTE *)(dword_D41A4 + 182), (int)aNetherw_2, aShots) != 3 )
  {
    printf(aErrorCreatingS);
    goto LABEL_35;
  }
  sub_560D0();
  sub_5BCC0();
  if ( !(unsigned __int16)sub_5BF50() )
    goto LABEL_35;
  sub_5C1B0();
  if ( !sub_54200() )
  {
    printf(aErrorCopyingDa);
    goto LABEL_35;
  }
  sub_71410();
  sub_6EB90((unsigned int **)&off_D918C);
  sub_6EB90((unsigned int **)&off_D91EC);
  sub_101C0();
  if ( !(*(_BYTE *)(dword_D41A4 + 24) & 8) )
    sub_53E60((int)aDataSpellsDat, byte_DA818);
  v0 = sub_5C0A0();
  if ( byte_D4B80 )
LABEL_35:
    exit(-1);
  byte_D4B80 = 1;
  if ( word_180660 & 1 )
    sub_72883(v0, (void *)dword_180628, 0xC8u, 0);
  else
    sub_728A9(v0, (void *)dword_180628, 0x1E0u, 0);
  sub_90B27(0, 0x10u, 0);
  memset(dword_EA3D8, 0, 768);
  sub_41A90((unsigned __int8 *)dword_EA3D8);
  if ( *(_WORD *)(dword_D41A4 + 22) & 0x110 )
  {
    if ( word_180660 & 1 )
      sub_90D6E((unsigned __int8 *)dword_EA3D8);
    else
      sub_90E07((unsigned __int8 *)dword_EA3D8);
    memset(dword_EA3D8, 0, 768);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
  }
  else
  {
    sub_90B27(0, 0x10u, 0);
    if ( word_180660 & 1 )
      sub_90D6E((unsigned __int8 *)dword_180628);
    else
      sub_90E07((unsigned __int8 *)dword_180628);
    memset(dword_EA3D8, 0, 768);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
  }
  if ( *(_BYTE *)(dword_D41A4 + 22) & 8 )
    sub_8C2CD();
  else
    sub_753D0();
  byte_E3799 = byte_E3798;
  byte_E37FD = byte_E37FC;
  sub_8CEDF();
  if ( !dword_E3768 )
  {
    sub_5BC20();
    printf(aErrorMouseDriv);
    exit(-1);
  }
  v1 = dword_EB394;
  sub_8CD27(dword_EB394);
  v2 = sub_5C430();
  return sub_46DD0(v2, v3, v1);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// D4B80: using guessed type char byte_D4B80;
// D918C: using guessed type int *off_D918C;
// D91EC: using guessed type int *off_D91EC;
// E3768: using guessed type int dword_E3768;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// EA3D8: using guessed type int dword_EA3D8;
// EB394: using guessed type int dword_EB394;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0005BC20) --------------------------------------------------------
char sub_5BC20()
{
  if ( byte_D4B80 == 1 )
  {
    sub_5C450();
    if ( dword_E3768 )
      sub_54600();
    if ( *(_BYTE *)(dword_D41A4 + 22) & 8 )
      sub_8C2DE();
    else
      sub_75420();
    sub_46F50();
    sub_8C21F();
    sub_72D04();
    sub_6FE20();
    sub_5C060();
  }
  sub_83E80(dword_D4198);
  sub_83E80(dword_D41A0);
  sub_83E80(dword_D41A4);
  sub_86860(word_1803EC);
  return sub_86BD0();
}
// D4198: using guessed type int dword_D4198;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D4B80: using guessed type char byte_D4B80;
// E3768: using guessed type int dword_E3768;
// 1803EC: using guessed type __int16 word_1803EC;

//----- (0005BCC0) --------------------------------------------------------
int sub_5BCC0()
{
  int result; // eax

  byte_EB39E = 72;
  byte_EB39F = 80;
  byte_EB3A1 = 77;
  byte_EB3A5 = 54;
  byte_EB3A6 = 54;
  result = dword_D41A4;
  byte_EB3A3 = 29;
  *(_WORD *)(dword_D41A4 + 4) = 0;
  *(_WORD *)(result + 6) = 127;
  *(_WORD *)(result + 8) = 127;
  byte_EB3A0 = 75;
  *(_BYTE *)(result + 10) = 1;
  byte_EB3A2 = 28;
  *(_BYTE *)(result + 11) = 0;
  byte_EB3A4 = 56;
  *(_BYTE *)(result + 12) = 0;
  byte_EB3A7 = 56;
  *(_BYTE *)(result + 13) = 0;
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// EB39E: using guessed type char byte_EB39E;
// EB39F: using guessed type char byte_EB39F;
// EB3A0: using guessed type char byte_EB3A0;
// EB3A1: using guessed type char byte_EB3A1;
// EB3A2: using guessed type char byte_EB3A2;
// EB3A3: using guessed type char byte_EB3A3;
// EB3A4: using guessed type char byte_EB3A4;
// EB3A5: using guessed type char byte_EB3A5;
// EB3A6: using guessed type char byte_EB3A6;
// EB3A7: using guessed type char byte_EB3A7;

//----- (0005BDC0) --------------------------------------------------------
int __cdecl sub_5BDC0(__int16 a1, __int16 a2)
{
  __int16 v2; // bx
  __int16 v3; // si
  int v4; // ecx
  int v5; // edx
  int result; // eax
  int v7; // [esp+0h] [ebp-1Ch]
  int v8; // [esp+8h] [ebp-14h]
  int v9; // [esp+Ch] [ebp-10h]

  v2 = a1;
  v3 = a2;
  memset(&v7, 0, 28);
  if ( a1 < 0 )
    v2 = 0;
  if ( a2 < 0 )
    v3 = 0;
  _disable();
  v4 = dword_E36C4;
  word_E375C = v2;
  word_E3760 = v2;
  word_E375E = v3;
  word_E3762 = v3;
  dword_1805B8 = v2;
  dword_1805B0 = v2;
  v7 = 4;
  dword_1805BC = v3;
  dword_1805B4 = v3;
  if ( dword_E36C4 )
  {
    v5 = dword_1805B0;
    *(_DWORD *)(dword_E36C4 + 40) = v3;
    *(_DWORD *)(v4 + 36) = v5;
  }
  if ( word_180660 & 8 )
  {
    v2 *= 8;
    v3 *= 8;
  }
  v8 = v2;
  v9 = v3;
  result = int386(51, &v7, &v7);
  _enable();
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E36C4: using guessed type int dword_E36C4;
// E375C: using guessed type __int16 word_E375C;
// E375E: using guessed type __int16 word_E375E;
// E3760: using guessed type __int16 word_E3760;
// E3762: using guessed type __int16 word_E3762;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805B8: using guessed type int dword_1805B8;
// 1805BC: using guessed type int dword_1805BC;
// 180660: using guessed type __int16 word_180660;

//----- (0005BE80) --------------------------------------------------------
char __cdecl sub_5BE80(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  unsigned __int8 *v4; // eax
  signed int v5; // edx
  signed int v6; // ecx
  unsigned int v7; // edx
  int v9; // esi
  int v10; // esi
  int v11; // edi
  unsigned int v12; // [esp+0h] [ebp-8h]
  char v13; // [esp+4h] [ebp-4h]

  v4 = a1;
  if ( word_180660 & 6 )
    v5 = 16;
  else
    v5 = 256;
  v6 = 9999;
  v12 = v5;
  v7 = 0;
  if ( v12 <= 0 )
    return v13;
  do
  {
    v9 = a3 - v4[1];
    v10 = (a2 - *v4) * (a2 - *v4) + v9 * v9;
    v11 = a4 - v4[2];
    if ( v10 + v11 * v11 < v6 )
    {
      v6 = v10 + v11 * v11;
      v13 = v7;
    }
    ++v7;
    v4 += 3;
  }
  while ( v7 < v12 );
  return v13;
}
// 180660: using guessed type __int16 word_180660;

//----- (0005BF10) --------------------------------------------------------
char sub_5BF10()
{
  char result; // al

  if ( byte_E3799 )
    sub_8D8F0();
  if ( byte_E37FD )
    sub_8E020();
  result = 0;
  byte_E37FD = 0;
  byte_E3799 = 0;
  return result;
}
// E3799: using guessed type char byte_E3799;
// E37FD: using guessed type char byte_E37FD;

//----- (0005BF50) --------------------------------------------------------
signed int sub_5BF50()
{
  signed int result; // eax
  int v1; // eax
  int v2; // eax
  int v3; // eax

  dword_181C40 = sub_83D70(256);
  if ( dword_181C40 )
  {
    if ( sub_5C380(257) )
      byte_D41B4 = 1;
    else
      printf(aNoVesaDriverDe);
    LOWORD(v1) = sub_84250((int)aSearchd);
    if ( v1 )
    {
      printf(aNotEnoughMemor);
      sub_90D3F((int)aSearchd);
      result = 0;
    }
    else
    {
      LOWORD(v2) = sub_84250((int)aDataBuild00Dat);
      if ( v2 )
      {
        printf(aNotEnoughMemor);
        sub_90D3F((int)aSearchd);
        sub_90D3F((int)aDataBuild00Dat);
        result = 0;
      }
      else
      {
        sub_539A0();
        LOWORD(v3) = sub_84250((int)aWscreen);
        if ( v3 )
        {
          sub_90D3F((int)aWscreen);
          printf(aNotEnoughMemor);
          result = 0;
        }
        else
        {
          word_180660 = 1;
          sub_83B50();
          result = 1;
        }
      }
    }
  }
  else
  {
    printf(aNoVesaDriverDe);
    result = 0;
  }
  return result;
}
// D41B4: using guessed type char byte_D41B4;
// 180660: using guessed type __int16 word_180660;
// 181C40: using guessed type int dword_181C40;

//----- (0005C060) --------------------------------------------------------
signed int sub_5C060()
{
  sub_90D3F((int)aSearchd);
  sub_90D3F((int)aDataBuild00Dat);
  sub_90D3F((int)aWscreen);
  return 1;
}

//----- (0005C0A0) --------------------------------------------------------
int sub_5C0A0()
{
  char *v0; // ebx
  unsigned int v1; // ecx
  char v2; // dl
  char v3; // ah
  char v4; // dh
  int result; // eax

  v0 = byte_DA818;
  v1 = 0;
  do
  {
    while ( 1 )
    {
      v2 = v0[53];
      v0[1] = 0;
      v3 = v0[27];
      v0[53] = v2 & 0xFE;
      v4 = v0[79];
      v0[27] = v3 & 0xFE;
      v0[79] = v4 & 0xFE;
      if ( v1 < 7 )
      {
        if ( v1 < 3 )
        {
          if ( !v1 )
            v0[53] |= 1u;
        }
        else if ( v1 <= 4 || v1 == 6 )
        {
          goto LABEL_18;
        }
      }
      else
      {
        if ( v1 <= 7 )
        {
          v0[27] |= 1u;
          goto LABEL_22;
        }
        if ( v1 < 0xB )
        {
          if ( v1 != 8 )
            goto LABEL_22;
LABEL_18:
          v0[1] |= 4u;
          goto LABEL_22;
        }
        if ( v1 <= 0xC )
          goto LABEL_18;
        if ( v1 >= 0xE )
        {
          if ( v1 <= 0xE )
            goto LABEL_18;
          if ( v1 == 23 )
          {
            *(_DWORD *)(v0 + 10) = 50000;
            *((_DWORD *)v0 + 9) = 70000;
            *(_DWORD *)(v0 + 62) = 90000;
          }
        }
      }
LABEL_22:
      result = 1000 / *(_DWORD *)(v0 + 58);
      if ( *(_DWORD *)(v0 + 62) <= 0 && result > 0 )
      {
        v0[1] |= 0x20u;
        goto LABEL_30;
      }
      if ( *((_DWORD *)v0 + 9) > 0 || 1000 / *((_DWORD *)v0 + 8) <= 0 )
        break;
      v0[1] |= 0x10u;
      ++v1;
      v0 += 80;
      if ( (signed int)v1 >= 26 )
        return result;
    }
    v0[1] |= 8u;
LABEL_30:
    ++v1;
    v0 += 80;
  }
  while ( (signed int)v1 < 26 );
  return result;
}

//----- (0005C1B0) --------------------------------------------------------
signed int sub_5C1B0()
{
  _BYTE *v0; // eax
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  char v5; // dl
  unsigned __int16 v6; // dx
  unsigned __int16 v7; // bx

  sub_5C330();
  v0 = (_BYTE *)dword_D41A0;
  *(_BYTE *)(dword_D41A0 + 8618) = 1;
  v0[8619] = 1;
  v0[8620] = 1;
  v0[8621] = 1;
  v0[8622] = 1;
  v0[8623] = 1;
  v0[8624] = 1;
  v0[8625] = 0;
  v0[8626] = 1;
  v0[8627] = 1;
  v0[8628] = 1;
  v0[8630] = 1;
  v0[8631] = 1;
  v0[8632] = 1;
  v0[8633] = 1;
  sub_84050();
  if ( *(_BYTE *)(dword_D41A4 + 34) )
  {
    v1 = dword_D41A0;
    *(_BYTE *)(dword_D41A0 + 8586) = 1;
    *(_BYTE *)(v1 + 8588) = 1;
    *(_BYTE *)(v1 + 8598) = 1;
  }
  else
  {
    v2 = dword_D41A0;
    *(_BYTE *)(dword_D41A0 + 8586) = 0;
    *(_BYTE *)(v2 + 8588) = 0;
    *(_BYTE *)(v2 + 8598) = 0;
  }
  v3 = dword_D41A0;
  *(_BYTE *)(dword_D41A0 + 8587) = 1;
  *(_BYTE *)(v3 + 8591) = 1;
  *(_BYTE *)(v3 + 8590) = 1;
  *(_BYTE *)(v3 + 8589) = 40;
  *(_BYTE *)(v3 + 8599) = 0;
  *(_BYTE *)(v3 + 8600) = 0;
  *(_BYTE *)(v3 + 8601) = 0;
  *(_WORD *)(v3 + 14) = 2;
  v4 = dword_D41A4;
  strcpy((char *)(dword_D41A4 + 145), "NETHERW");
  *(_WORD *)(dword_D41A4 + 184) = 256;
  v5 = byte_D0C18;
  *(_WORD *)(v4 + 218) = 25;
  *(_BYTE *)(v4 + 57) = v5;
  v6 = *(_WORD *)(v4 + 43);
  v7 = *(_WORD *)(v4 + 218);
  *(_DWORD *)(v4 + 30) = 0;
  if ( v6 >= v7 )
    *(_WORD *)(v4 + 43) = v7 - 1;
  sub_87090();
  if ( byte_180552 )
    *(_BYTE *)(dword_D41A4 + 10) = 1;
  sub_2CA90(*(char *)(dword_D41A0 + 8589));
  return 1;
}
// D0C18: using guessed type char byte_D0C18;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 180552: using guessed type char byte_180552;

//----- (0005C330) --------------------------------------------------------
void sub_5C330()
{
  signed int i; // edx
  int v1; // eax

  if ( dword_D41A0 )
  {
    for ( i = 0; i < 1001; dword_EA3E0[i] = dword_D41A0 + 28302 + v1 )
      v1 = 168 * i++;
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E0: using guessed type int dword_EA3E0[];

//----- (0005C380) --------------------------------------------------------
signed int __cdecl sub_5C380(__int16 a1)
{
  _WORD *i; // eax

  if ( !(unsigned __int16)sub_995B0() )
  {
    for ( i = (_WORD *)(*(unsigned __int16 *)(dword_181C40 + 14) + 16 * *(unsigned __int16 *)(dword_181C40 + 16));
          *i != -1;
          ++i )
    {
      if ( a1 == *i )
        return 1;
    }
  }
  return 0;
}
// 181C40: using guessed type int dword_181C40;

//----- (0005C3D0) --------------------------------------------------------
signed int __cdecl sub_5C3D0(int a1, char *a2)
{
  char v3; // [esp+0h] [ebp-8h]
  char v4; // [esp+1h] [ebp-7h]
  char v5; // [esp+2h] [ebp-6h]
  char v6; // [esp+3h] [ebp-5h]
  char v7; // [esp+4h] [ebp-4h]

  v3 = 82;
  v4 = 78;
  v6 = 1;
  v5 = 67;
  v7 = 0;
  if ( strncmp(a1, &v3, 4) )
    return 0;
  sub_9894C(a1, a2);
  return 1;
}
// 99682: using guessed type _DWORD __cdecl strncmp(_DWORD, _DWORD, _DWORD);

//----- (0005C430) --------------------------------------------------------
int sub_5C430()
{
  int result; // eax

  result = sub_74556();
  *(_WORD *)(dword_D41A4 + 216) = result;
  return result;
}
// D41A4: using guessed type int dword_D41A4;

//----- (0005C450) --------------------------------------------------------
void sub_5C450()
{
  if ( *(_WORD *)(dword_D41A4 + 216) )
    sub_72D04();
}
// D41A4: using guessed type int dword_D41A4;

//----- (0005C490) --------------------------------------------------------
int sub_5C490()
{
  int result; // eax
  int v1; // edx

  printf(&aTa[3]);
  printf(asc_D0C20);
  printf(aTestersWriteDo);
  printf(aPressReturnToC);
  printf(asc_D0CE0);
  do
  {
    if ( dword_E3BB0 <= 0 || dword_E3BB8 & 4 || *(_BYTE *)dword_E3BAC == 13 || *(_BYTE *)dword_E3BAC == 26 )
    {
      result = fgetc(&dword_E3BAC);
      v1 = result;
    }
    else
    {
      result = dword_E3BAC + 1;
      dword_E3BAC = result;
      v1 = *(unsigned __int8 *)(result - 1);
      --dword_E3BB0;
    }
  }
  while ( v1 != 10 );
  return result;
}
// 996B7: using guessed type _DWORD __cdecl fgetc(_DWORD);
// E3BAC: using guessed type int dword_E3BAC;
// E3BB0: using guessed type int dword_E3BB0;
// E3BB8: using guessed type int dword_E3BB8;

//----- (0005C530) --------------------------------------------------------
int sub_5C530()
{
  int v0; // edx
  int v1; // ecx
  int v2; // ebx
  signed int i; // eax
  int v4; // esi
  signed int j; // eax
  int v6; // eax
  int v7; // ecx
  int v8; // edx
  int v9; // edi
  int v10; // eax
  int v11; // ecx
  int v12; // edx
  int v13; // edi
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int v17; // esi
  int v18; // edx
  int v19; // esi
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // eax

  v0 = 0;
  v1 = 0;
  v2 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  for ( i = 0; i < 26; ++i )
  {
    v4 = *(_DWORD *)(v2 + 164);
    if ( *(_WORD *)(v4 + 2 * i + 819) || *(_BYTE *)(v4 + i + 1027) )
      *(_BYTE *)(*(_DWORD *)(v2 + 164) + i + 1001) = 1;
  }
  if ( *(_BYTE *)(dword_D41A0 + 224779) & 1 )
    ++*(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12226);
  for ( j = 0; j < 26; ++j )
  {
    if ( *(_DWORD *)(4 * j + dword_D41A0 + 222422) )
    {
      ++v1;
      if ( *(_BYTE *)(*(_DWORD *)(v2 + 164) + j + 1027) )
        ++v0;
    }
  }
  if ( v1 )
  {
    v6 = 100 * v0 / v1;
    v0 = *(_DWORD *)(v2 + 164);
    *(_DWORD *)(v0 + 377) = v6;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(v2 + 164) + 377) = 100;
  }
  if ( *(_DWORD *)(dword_D41A0 + 222418) )
  {
    v7 = *(_DWORD *)(v2 + 164);
    v8 = 100 * *(_DWORD *)(v7 + 373);
    v9 = *(_DWORD *)(dword_D41A0 + 222418);
    v10 = v8 / v9;
    v0 = v8 % v9;
    *(_DWORD *)(v7 + 373) = v10;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(v2 + 164) + 373) = 100;
  }
  v11 = *(_DWORD *)(v2 + 164);
  if ( *(_DWORD *)(v11 + 357) )
  {
    v12 = 100 * *(_DWORD *)(v11 + 361);
    v13 = *(_DWORD *)(v11 + 357);
    v14 = v12 / v13;
    v0 = v12 % v13;
    *(_DWORD *)(v11 + 381) = v14;
  }
  else
  {
    *(_DWORD *)(v11 + 381) = 100;
  }
  v15 = *(_DWORD *)(v2 + 164);
  v16 = dword_EA3E4[*(unsigned __int16 *)(v15 + 58)];
  if ( v16 )
  {
    v17 = *(_DWORD *)(dword_D41A4 + 246) - 1;
    if ( v17 <= 0 )
    {
      *(_DWORD *)(v15 + 385) = 100;
      goto LABEL_29;
    }
    v18 = 100 * (*(_DWORD *)(v15 + 316) + *(_DWORD *)(v16 + 144));
    v16 = v18 / v17;
    v0 = v18 % v17;
  }
  *(_DWORD *)(v15 + 385) = v16;
LABEL_29:
  v19 = *(_DWORD *)(v2 + 164);
  *(_DWORD *)(*(_DWORD *)(v2 + 164) + 393) = (j___clock(v16, v0, v2) - *(_DWORD *)(v19 + 393)) / 0x64u;
  v20 = *(_DWORD *)(v2 + 164);
  if ( *(_DWORD *)(v20 + 377) < 0 )
    *(_DWORD *)(v20 + 377) = 0;
  v21 = *(_DWORD *)(v2 + 164);
  if ( *(_DWORD *)(v21 + 377) > 100 )
    *(_DWORD *)(v21 + 377) = 100;
  v22 = *(_DWORD *)(v2 + 164);
  if ( *(_DWORD *)(v22 + 373) < 0 )
    *(_DWORD *)(v22 + 373) = 0;
  v23 = *(_DWORD *)(v2 + 164);
  if ( *(_DWORD *)(v23 + 373) > 100 )
    *(_DWORD *)(v23 + 373) = 100;
  v24 = *(_DWORD *)(v2 + 164);
  if ( *(_DWORD *)(v24 + 381) < 0 )
    *(_DWORD *)(v24 + 381) = 0;
  v25 = *(_DWORD *)(v2 + 164);
  if ( *(_DWORD *)(v25 + 381) > 100 )
    *(_DWORD *)(v25 + 381) = 100;
  v26 = *(_DWORD *)(v2 + 164);
  if ( *(_DWORD *)(v26 + 385) < 0 )
    *(_DWORD *)(v26 + 385) = 0;
  v27 = *(_DWORD *)(v2 + 164);
  if ( *(_DWORD *)(v27 + 385) > 100 )
    *(_DWORD *)(v27 + 385) = 100;
  return sub_82AB0(*(_BYTE *)(dword_D41A4 + 43));
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005C800) --------------------------------------------------------
__int16 __cdecl sub_5C800(int a1, char a2)
{
  __int16 result; // ax

  result = *(_WORD *)(dword_D41A0 + 12);
  if ( result == *(_WORD *)(*(_DWORD *)(a1 + 164) + 56) )
  {
    result = dword_D41A4;
    *(_BYTE *)(dword_D41A4 + 180) = a2;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (0005C830) --------------------------------------------------------
__int16 __cdecl sub_5C830(int a1, char a2, __int16 a3)
{
  int v3; // eax

  LOWORD(v3) = *(_WORD *)(dword_D41A0 + 12);
  if ( (_WORD)v3 == *(_WORD *)(*(_DWORD *)(a1 + 164) + 56) )
  {
    v3 = dword_D41A4;
    *(_BYTE *)(dword_D41A4 + 180) = a2;
    *(_WORD *)(v3 + 184) = a3;
  }
  return v3;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (0005C870) --------------------------------------------------------
signed int __cdecl sub_5C870(int a1)
{
  int v1; // ebx
  int v2; // esi
  signed int result; // eax

  v1 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v2 = *(_DWORD *)(v1 + 164);
  result = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
  if ( result <= *(_DWORD *)(v2 + 410) )
    *(_DWORD *)(*(_DWORD *)(v1 + 164) + 410) = result;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005C8D0) --------------------------------------------------------
signed int __cdecl sub_5C8D0(int a1)
{
  int v1; // ebx
  int v2; // esi
  signed int result; // eax

  v1 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v2 = *(_DWORD *)(v1 + 164);
  result = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
  if ( result <= *(_DWORD *)(v2 + 414) )
    *(_DWORD *)(*(_DWORD *)(v1 + 164) + 414) = result;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005C950) --------------------------------------------------------
int __cdecl sub_5C950(int a1, int a2)
{
  int v2; // ebx
  __int16 v3; // ax
  int v4; // eax
  unsigned __int16 v5; // dx
  int v6; // esi
  int v7; // ecx
  char v8; // ST08_1
  int v9; // edi
  int v10; // edx
  signed int i; // eax
  int v12; // eax
  int v13; // edx
  __int16 v14; // cx
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // edi
  int v19; // esi
  int v20; // eax
  __int16 v21; // dx
  int v22; // edi
  int v23; // eax
  _WORD *v24; // edx
  int v25; // eax
  int v26; // ST08_4
  int v27; // esi
  int v28; // eax
  int v29; // eax
  int v30; // edx
  unsigned int k; // eax
  char v32; // dl
  signed int l; // eax
  int result; // eax
  int v35; // [esp+0h] [ebp-14h]
  __int16 v36; // [esp+4h] [ebp-10h]
  int v37; // [esp+8h] [ebp-Ch]
  int j; // [esp+Ch] [ebp-8h]
  int v39; // [esp+10h] [ebp-4h]

  v2 = a2;
  v37 = 0;
  sub_49F90();
  v35 = *(_DWORD *)(dword_D41A0 + 6 * ((a1 - (dword_D41A0 + 11230)) / 2124) + 9058);
  v36 = *(_WORD *)(dword_D41A0 + 6 * ((a1 - (dword_D41A0 + 11230)) / 2124) + 9062);
  v3 = sub_10C40((__int16 *)&v35);
  ++HIBYTE(v3);
  v36 = v3;
  if ( a2 == dword_EA3E4[0] )
  {
    v2 = sub_4A190((int)&v35, 3, *(_BYTE *)(a1 + 9) == 1);
    v37 = 1;
  }
  else
  {
    *(_BYTE *)(a2 + 69) = *(_BYTE *)(a1 + 9) == 1;
    v4 = *(_DWORD *)(a2 + 164);
    *(_BYTE *)(a2 + 12) &= 0xDFu;
    v5 = *(_WORD *)(v4 + 58);
    if ( v5 )
    {
      v6 = dword_EA3E4[v5] + 76;
      v35 = *(_DWORD *)v6;
      v36 = *(_WORD *)(v6 + 4);
    }
    sub_57CF0(a2, (int)&v35);
  }
  v7 = dword_D41A0;
  *(_WORD *)(a1 + 10) = (v2 - (dword_D41A0 + 28302)) / 168;
  *(_DWORD *)(v2 + 164) = a1 + 998;
  *(_WORD *)(*(_DWORD *)(v2 + 164) + 56) = (a1 - (v7 + 11230)) / 2124;
  *(_WORD *)(*(_DWORD *)(v2 + 164) + 345) = 100;
  *(_WORD *)(*(_DWORD *)(v2 + 164) + 588) = 0;
  *(_DWORD *)(*(_DWORD *)(v2 + 164) + 365) = 2000;
  *(_WORD *)(*(_DWORD *)(v2 + 164) + 12) = 0;
  *(_WORD *)(*(_DWORD *)(v2 + 164) + 32) = 0;
  *(_WORD *)(*(_DWORD *)(v2 + 164) + 34) = 0;
  *(_WORD *)(*(_DWORD *)(v2 + 164) + 30) = 0;
  *(_WORD *)(*(_DWORD *)(v2 + 164) + 16) = 0;
  memset(*(_DWORD *)(v2 + 164) + 428, 0, 18);
  *(_WORD *)(*(_DWORD *)(v2 + 164) + 586) = 256;
  v8 = v37;
  *(_DWORD *)(v2 + 140) = 1000;
  v9 = v37;
  *(_DWORD *)(v2 + 4) = 10000;
  sub_5CF40(v2, v8);
  if ( v9 )
  {
    sub_58DA0(0, v2);
    for ( i = 0; i < 26; *(_DWORD *)(*(_DWORD *)(v2 + 164) + 4 * i + 711) = 0 )
      ++i;
    *(_DWORD *)(*(_DWORD *)(v2 + 164) + 393) = j___clock(i, v10, v2);
    switch ( sub_616D0(*(signed __int16 *)(*(_DWORD *)(v2 + 164) + 56)) )
    {
      case 0:
        sub_49CD0((_WORD *)v2, 44);
        break;
      case 1:
        sub_49CD0((_WORD *)v2, 273);
        break;
      case 2:
        sub_49CD0((_WORD *)v2, 274);
        break;
      case 3:
        sub_49CD0((_WORD *)v2, 275);
        break;
      case 4:
        sub_49CD0((_WORD *)v2, 276);
        break;
      case 5:
        sub_49CD0((_WORD *)v2, 277);
        break;
      case 6:
        sub_49CD0((_WORD *)v2, 278);
        break;
      case 7:
        sub_49CD0((_WORD *)v2, 279);
        break;
      default:
        break;
    }
    if ( *(_BYTE *)(a1 + 9) == 1 )
    {
      v12 = dword_D41A0;
      *(_WORD *)(*(_DWORD *)(v2 + 164) + 578) = *(_WORD *)(110 * *(signed __int16 *)(*(_DWORD *)(v2 + 164) + 56)
                                                         + dword_D41A0
                                                         + 221397);
      *(_WORD *)(*(_DWORD *)(v2 + 164) + 580) = *(_WORD *)(110 * *(signed __int16 *)(*(_DWORD *)(v2 + 164) + 56)
                                                         + v12
                                                         + 221405);
      *(_WORD *)(*(_DWORD *)(v2 + 164) + 582) = *(_WORD *)(110 * *(signed __int16 *)(*(_DWORD *)(v2 + 164) + 56)
                                                         + v12
                                                         + 221401);
      v13 = *(_DWORD *)(v2 + 164);
      v14 = *(_WORD *)(110 * *(signed __int16 *)(v13 + 56) + v12 + 221487);
      if ( v14 )
      {
        *(_WORD *)(v13 + 586) = v14;
        *(_DWORD *)(v2 + 4) = *(_DWORD *)(v2 + 4) * (signed int)*(signed __int16 *)(*(_DWORD *)(v2 + 164) + 586) >> 8;
      }
      v15 = *(_DWORD *)(v2 + 164);
      if ( *(_WORD *)(v15 + 823) )
      {
        if ( *(_BYTE *)(dword_D41A0 + *(signed __int16 *)(v15 + 56) + 196313) )
        {
          v16 = sub_4A190(v2 + 76, 3, 2);
          v39 = v16;
          if ( v16 )
          {
            v17 = dword_D41A0 + 28302;
            *(_WORD *)(v16 + 26) = *(_WORD *)(v2 + 26);
            *(_WORD *)(*(_DWORD *)(v2 + 164) + 58) = (v16 - v17) / 168;
            sub_6E450((v2 - v17) / 168, -1, 30);
            for ( j = 0; ; j = v22 + 1 )
            {
              v23 = *(unsigned __int8 *)(dword_D41A0 + *(signed __int16 *)(*(_DWORD *)(v2 + 164) + 56) + 196313);
              if ( v23 <= j )
                break;
              v18 = dword_EA3E4[0] + 76;
              v19 = v39 + 154;
              *(_DWORD *)v18 = *(_DWORD *)(v39 + 154);
              *(_WORD *)(v18 + 4) = *(_WORD *)(v19 + 4);
              v20 = dword_EA3E4[0];
              v21 = *(_WORD *)(v39 + 26);
              *(_BYTE *)(dword_EA3E4[0] + 64) = 0;
              v22 = j;
              *(_DWORD *)(v20 + 16) = 0;
              *(_WORD *)(v20 + 26) = v21;
              *(_BYTE *)(v20 + 70) = j;
              sub_36FC0(v20);
            }
            v24 = (_WORD *)v39;
            *(_DWORD *)(v39 + 16) = v23 - 1;
            sub_49EC0(v24, v24[8]);
            v25 = v39;
            v26 = v39;
            *(_WORD *)(v39 + 82) = -8192;
            v27 = v25;
            *(_WORD *)(v25 + 88) = 0x4000;
            sub_60810(v26);
            v28 = *(_DWORD *)(v27 + 140);
            *(_DWORD *)(v27 + 144) = v28;
            if ( v28 < 0 )
              *(_DWORD *)(v27 + 144) = 0;
            if ( *(_DWORD *)(v39 + 144) > 320000 )
              *(_DWORD *)(v39 + 144) = 320000;
          }
        }
      }
    }
    *(_DWORD *)(*(_DWORD *)(v2 + 164) + 373) = 0;
  }
  if ( *(_WORD *)(dword_D41A0 + 12) == *(_WORD *)(*(_DWORD *)(v2 + 164) + 56) )
    *(_BYTE *)(v2 + 12) |= 1u;
  *(_DWORD *)(v2 + 8) = *(_DWORD *)(v2 + 4);
  v29 = *(_DWORD *)(v2 + 140);
  v30 = *(_DWORD *)(v2 + 164);
  *(_DWORD *)(v2 + 144) = v29;
  *(_DWORD *)(v30 + 336) = v29;
  for ( k = *(_DWORD *)(dword_D41A4 + 38519); k > dword_EA3E4[0]; k = *(_DWORD *)k )
  {
    if ( *(_WORD *)(k + 26) != *(_WORD *)(v2 + 26) )
    {
      v32 = *(_BYTE *)(k + 64);
      if ( !v32 || v32 == 1 )
        *(_WORD *)(*(_DWORD *)(k + 164) + 8 * *(signed __int16 *)(*(_DWORD *)(v2 + 164) + 56) + 516) = -24609;
    }
  }
  *(_WORD *)(*(_DWORD *)(v2 + 164) + 326) = 0;
  *(_WORD *)(*(_DWORD *)(v2 + 164) + 328) = 0;
  if ( *(_BYTE *)(v2 + 64) == 1 )
  {
    memset(*(_DWORD *)(v2 + 164) + 449, 0, 1);
    for ( l = 0; l < 8; *(_WORD *)(*(_DWORD *)(v2 + 164) + 8 * l + 508) = 24607 )
      ++l;
    *(_WORD *)(*(_DWORD *)(v2 + 164) + 875) = 4 * *(_WORD *)(*(_DWORD *)(v2 + 164) + 56);
  }
  *(_DWORD *)(*(_DWORD *)(v2 + 164) + 410) = 2048;
  *(_DWORD *)(*(_DWORD *)(v2 + 164) + 414) = 2048;
  *(_WORD *)(*(_DWORD *)(v2 + 164) + 54) = 0;
  memset(*(_DWORD *)(v2 + 164) + 347, 16, 8);
  result = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 4582) = -1;
  if ( *(_WORD *)(*(_DWORD *)(v2 + 164) + 56) == *(_WORD *)(result + 12) )
  {
    result = dword_D41A4;
    *(_BYTE *)(dword_D41A4 + 178) = 0;
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005CF40) --------------------------------------------------------
_WORD *__cdecl sub_5CF40(int a1, char a2)
{
  int i; // esi
  int v3; // edi
  int v4; // eax
  int v5; // ST0C_4
  signed int j; // edx
  signed int v7; // esi
  int v8; // eax
  __int16 v9; // cx

  for ( i = 0; i < 26; ++i )
  {
    v3 = 2 * i;
    if ( *(_WORD *)(2 * i + *(_DWORD *)(a1 + 164) + 819) )
    {
      v4 = sub_4A190(a1 + 76, 15, i);
      if ( v4 )
      {
        v5 = dword_D41A0 + 28302;
        *(_WORD *)(*(_DWORD *)(a1 + 164) + v3 + 819) = (v4 - (dword_D41A0 + 28302)) / 168;
        *(_WORD *)(v4 + 40) = (a1 - v5) / 168;
        *(_BYTE *)(v4 + 12) |= 1u;
      }
      else
      {
        *(_WORD *)(v3 + *(_DWORD *)(a1 + 164) + 819) = 0;
      }
    }
  }
  if ( a2 )
  {
    for ( j = 0; j < 26; *(_BYTE *)(j + *(_DWORD *)(a1 + 164) + 1078) = 0 )
      ++j;
  }
  v7 = 0;
  sub_6DB50(0, 0);
  while ( v7 < 26 )
  {
    v8 = *(_DWORD *)(a1 + 164);
    v9 = *(_WORD *)(v8 + 2 * v7 + 819);
    if ( v9 )
      sub_6D5E0(dword_EA3E4[v9], *(_BYTE *)(v7 + v8 + 1079));
    ++v7;
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1109) = *(_BYTE *)(*(_DWORD *)(a1 + 164)
                                                      + *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 1105)
                                                      + 1079);
  *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1110) = *(_BYTE *)(*(_DWORD *)(a1 + 164)
                                                      + *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 1107)
                                                      + 1079);
  return sub_574A0();
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005D0A0) --------------------------------------------------------
int __cdecl sub_5D0A0(int a1)
{
  unsigned __int16 v1; // di
  int v2; // eax
  int v3; // eax
  unsigned __int16 v4; // si
  unsigned __int16 v5; // ax
  unsigned __int16 v6; // ax
  int v7; // esi
  int v8; // esi
  __int16 v9; // ax
  int v10; // eax
  int v11; // edx
  int v12; // edx
  __int16 v13; // si
  __int16 v14; // ax
  int v15; // edi
  __int16 v16; // ax
  int v17; // esi
  int v18; // eax
  int *v19; // esi
  char v20; // ch
  int v21; // edx
  int v22; // eax
  int v23; // eax
  __int16 v24; // ax
  __int16 v25; // dx
  int v27; // [esp+0h] [ebp-60h]
  __int16 v28; // [esp+4h] [ebp-5Ch]
  int v29; // [esp+8h] [ebp-58h]
  __int16 v30; // [esp+Ch] [ebp-54h]
  int v31; // [esp+10h] [ebp-50h]
  __int16 v32; // [esp+14h] [ebp-4Ch]
  int v33; // [esp+18h] [ebp-48h]
  __int16 v34; // [esp+1Ch] [ebp-44h]
  int v35; // [esp+20h] [ebp-40h]
  int v36; // [esp+24h] [ebp-3Ch]
  int v37; // [esp+28h] [ebp-38h]
  int v38; // [esp+2Ch] [ebp-34h]
  int v39; // [esp+30h] [ebp-30h]
  int i; // [esp+34h] [ebp-2Ch]
  int v41; // [esp+38h] [ebp-28h]
  unsigned int v42; // [esp+3Ch] [ebp-24h]
  int v43; // [esp+40h] [ebp-20h]
  int v44; // [esp+44h] [ebp-1Ch]
  int v45; // [esp+48h] [ebp-18h]
  int v46; // [esp+4Ch] [ebp-14h]
  unsigned __int16 v47; // [esp+50h] [ebp-10h]
  int v48; // [esp+54h] [ebp-Ch]
  int v49; // [esp+58h] [ebp-8h]
  char v50; // [esp+5Ch] [ebp-4h]

  v46 = 1;
  if ( sub_104D0(&word_EB398) == (int (*)())256 )
  {
    ++*(_BYTE *)(*(_DWORD *)(a1 + 164) + 610);
    v1 = sub_581E0((_WORD *)(a1 + 76), &word_EB398);
    LOWORD(v2) = sub_58210((_WORD *)(a1 + 76), &word_EB398);
    v45 = v2;
    v42 = sub_583F0((_WORD *)(a1 + 76), &word_EB398);
    v41 = v1;
    v3 = (v41 - (__CFSHL__(v41 >> 31, 9) + (v41 >> 31 << 9))) >> 9;
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v4 = (_WORD)v3 << 9;
    v49 = (((_WORD)v3 + 1) << 9) & 0x7FF;
    v5 = sub_582B0(v41, (_WORD)v3 << 9);
    v36 = (unsigned __int16)v42;
    v35 = (unsigned __int16)v45;
    sub_57FA0(
      &word_EB398,
      v4,
      v45,
      ((unsigned __int16)v42 * (512 - v5)
     - (__CFSHL__((unsigned __int16)v42 * (512 - v5) >> 31, 9)
      + ((unsigned __int16)v42 * (512 - v5) >> 31 << 9))) >> 9);
    if ( sub_104D0(&word_EB398) == (int (*)())256 )
    {
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      v6 = sub_582B0(v41, v49);
      sub_57FA0(
        &word_EB398,
        v49,
        v35,
        (v36 * (512 - v6) - (__CFSHL__(v36 * (512 - v6) >> 31, 9) + (v36 * (512 - v6) >> 31 << 9))) >> 9);
      if ( sub_104D0(&word_EB398) == (int (*)())256 )
        v46 = 0;
    }
  }
  if ( !byte_D41B6 )
    return v46;
  v31 = *(_DWORD *)&word_EB398;
  v32 = *(&word_EB398 + 2);
  v7 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 12);
  v8 = v7 + (signed __int16)sub_10C40((__int16 *)&v31) + *(signed __int16 *)(a1 + 88);
  v9 = sub_10C60((__int16 *)&v31);
  LOBYTE(v47) = BYTE1(v31);
  HIBYTE(v47) = HIBYTE(v31);
  if ( v8 < v9 - 576 && !(byte_13B4E0[v47] & 8) )
    goto LABEL_30;
  v48 = 0;
  LOWORD(v10) = sub_581E0((_WORD *)(a1 + 76), &v31);
  v11 = v10 - 512;
  v50 = 0;
  BYTE1(v11) &= 7u;
  BYTE1(v10) = (BYTE1(v10) + 2) & 7;
  v43 = v11;
  v44 = v10;
  v12 = 16;
  for ( i = 0; ; ++i )
  {
    v39 = v12;
    if ( i >= 6 || v50 )
      break;
    v33 = v31;
    v34 = v32;
    v27 = v31;
    v28 = v32;
    v13 = v39;
    v37 = (unsigned __int16)v48;
    sub_57FA0(&v33, v43, v48, v39);
    v38 = (signed __int16)sub_10C60((__int16 *)&v33);
    v14 = sub_10C40((__int16 *)&v33);
    v15 = v38 - v14;
    sub_57FA0(&v27, v44, v37, v13);
    v38 = (signed __int16)sub_10C60((__int16 *)&v27);
    v16 = sub_10C40((__int16 *)&v27);
    v17 = v38 - v16;
    LOBYTE(v47) = BYTE1(v33);
    HIBYTE(v47) = HIBYTE(v33);
    v18 = (signed __int16)v27 >> 8;
    BYTE1(v18) = HIBYTE(v27);
    if ( !(byte_13B4E0[v47] & 8) || !(byte_13B4E0[(unsigned __int16)v18] & 8) )
    {
      if ( v15 > v17 && !(byte_13B4E0[v47] & 8) )
      {
        if ( sub_11E20(a1, (__int16 *)&v33) )
          goto LABEL_20;
        v19 = &v33;
        v50 = 1;
        goto LABEL_19;
      }
      if ( v17 > v15 && !(byte_13B4E0[(unsigned __int16)v18] & 8) && !sub_11E20(a1, (__int16 *)&v27) )
      {
        v19 = &v27;
        v50 = 2;
LABEL_19:
        v29 = *v19;
        v30 = *((_WORD *)v19 + 2);
        goto LABEL_20;
      }
    }
LABEL_20:
    v12 = 16 * (i + 1) + v39;
  }
  v20 = v50;
  if ( v50 )
  {
    v21 = i;
    v22 = 16 * i;
    *(_DWORD *)&word_EB398 = v29;
    *(&word_EB398 + 2) = v30;
    v23 = (v22 + v21) / 6;
    if ( v20 == 1 )
      v23 = -v23;
    v24 = *(_WORD *)(a1 + 28) + v23;
    HIBYTE(v24) &= 7u;
    *(_WORD *)(a1 + 28) = v24;
  }
  else if ( sub_11E20(a1, (__int16 *)&v31) )
  {
    v46 = 0;
  }
  else
  {
    *(_DWORD *)&word_EB398 = v31;
    *(&word_EB398 + 2) = v32;
  }
LABEL_30:
  if ( (_WORD)v46 )
  {
    LOBYTE(v47) = HIBYTE(word_EB398);
    HIBYTE(v47) = HIBYTE(word_EB39A);
    if ( byte_13B4E0[v47] & 8 )
      v46 = 0;
  }
  if ( !(_WORD)v46 )
  {
    ++*(_BYTE *)(*(_DWORD *)(a1 + 164) + 610);
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
    v25 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 825);
    if ( v25 )
      *(_WORD *)(dword_EA3E4[v25] + 46) = 0;
  }
  return v46;
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0005D530) --------------------------------------------------------
void __cdecl sub_5D530(int a1)
{
  char v1; // ah
  int v2; // ecx
  unsigned __int8 v3; // dh
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // edx
  int v8; // eax
  int v9; // edx
  __int16 v10; // ax
  int v11; // eax
  __int16 v12; // dx
  int v13; // eax
  unsigned __int8 v14; // cl
  int v15; // edx
  int v16; // eax
  int v17; // edx
  __int16 v18; // di
  int v19; // eax
  __int16 v20; // ST0C_2
  unsigned __int16 v21; // ax
  int v22; // eax
  __int16 v23; // dx
  int v24; // eax
  __int16 v25; // si
  _WORD *v26; // edx
  signed __int16 v27; // ax
  _WORD *v28; // edx
  __int16 v29; // si
  __int16 v30; // ax
  int v31; // edx
  char v32; // cl
  int v33; // edx
  char v34; // ah
  int v35; // eax
  char v36; // ch
  int v37; // edx
  char v38; // ch
  __int16 v39; // ax
  __int16 v40; // dx
  int v41; // ecx
  int v42; // eax
  __int16 v43; // ax
  unsigned int v44; // edx
  char v45; // al
  int v46; // ecx
  unsigned int v47; // eax
  __int16 v48; // si
  int v49; // edx
  __int16 v50; // ax

  v1 = *(_BYTE *)(a1 + 13);
  if ( v1 & 8 )
  {
    *(_BYTE *)(a1 + 13) = v1 & 0xF7;
    return;
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  v2 = *(_DWORD *)(a1 + 164);
  v3 = *(_BYTE *)(v2 + 332);
  if ( v3 )
  {
    v4 = *(signed __int16 *)(v2 + 4) * (4 - v3);
    *(_WORD *)(v2 + 341) += (v4 - (__CFSHL__(v4 >> 31, 2) + 4 * (v4 >> 31))) >> 2;
    v5 = *(_DWORD *)(a1 + 164);
    v6 = *(signed __int16 *)(v5 + 6) * (4 - *(unsigned __int8 *)(v5 + 332));
    *(_WORD *)(v5 + 343) += (v6 - (__CFSHL__(v6 >> 31, 2) + 4 * (v6 >> 31))) >> 2;
  }
  else
  {
    *(_WORD *)(v2 + 341) += *(_WORD *)(v2 + 4);
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 343) += *(_WORD *)(*(_DWORD *)(a1 + 164) + 6);
  }
  v7 = *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 341);
  *(_WORD *)(a1 + 28) = (*(_WORD *)(a1 + 28) + ((v7 - (__CFSHL__(v7 >> 31, 3) + 8 * (v7 >> 31))) >> 3)) & 0x7FF;
  v8 = *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 12) - *(signed __int16 *)(a1 + 130);
  if ( *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 12) != *(signed __int16 *)(a1 + 130) )
  {
    if ( v8 <= 0 )
      LOWORD(v8) = -1;
    else
      LOWORD(v8) = 1;
  }
  *(_WORD *)(a1 + 130) += v8 * dword_D4B84;
  v9 = ((word_EB39C - (signed __int16)sub_10C40(&word_EB398) - *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 10)) << 10)
     / *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 10);
  if ( v9 < -256 )
    v9 = -256;
  if ( v9 > 256 )
    v9 = 256;
  v10 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 343);
  HIBYTE(v10) &= 7u;
  *(_WORD *)(a1 + 30) = v10;
  if ( v10 > 1024 )
    v10 -= 2048;
  if ( *(_WORD *)(a1 + 130) >= 0 || v10 <= 0 )
  {
    if ( *(_WORD *)(a1 + 130) < 0 && v10 < 0 )
      goto LABEL_105;
    if ( *(_WORD *)(a1 + 130) > 0 && v10 < 0 )
    {
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 36) = (v10 * -v9 - (__CFSHL__(v10 * -v9 >> 31, 8) + (v10 * -v9 >> 31 << 8))) >> 8;
      goto LABEL_27;
    }
    if ( *(_WORD *)(a1 + 130) > 0 && v10 > 0 )
    {
LABEL_105:
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 36) = *(_WORD *)(*(_DWORD *)(a1 + 164) + 343);
      goto LABEL_27;
    }
  }
  else
  {
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 36) = (v10 * -v9 - (__CFSHL__(v10 * -v9 >> 31, 8) + (v10 * -v9 >> 31 << 8))) >> 8;
  }
LABEL_27:
  v11 = *(_DWORD *)(a1 + 164);
  v12 = *(_WORD *)(v11 + 36);
  HIBYTE(v12) &= 7u;
  *(_WORD *)(v11 + 36) = v12;
  v13 = *(_DWORD *)(a1 + 164);
  v14 = *(_BYTE *)(v13 + 332);
  if ( v14 )
  {
    v15 = *(signed __int16 *)(a1 + 130) * (4 - v14);
    v16 = (v15 - (__CFSHL__(v15 >> 31, 2) + 4 * (v15 >> 31))) >> 2;
  }
  else if ( *(_BYTE *)(v13 + 334) )
  {
    LOWORD(v16) = 0;
  }
  else
  {
    LOWORD(v16) = *(_WORD *)(a1 + 130);
  }
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(*(_DWORD *)(a1 + 164) + 36), v16);
  v17 = *(_DWORD *)(a1 + 164);
  v18 = *(_WORD *)(v17 + 16);
  if ( v18 )
  {
    LOBYTE(v19) = *(_BYTE *)(v17 + 332);
    if ( (_BYTE)v19 )
    {
      v19 = ((4 - *(unsigned __int8 *)(v17 + 332)) * v18
           - (__CFSHL__((4 - *(unsigned __int8 *)(v17 + 332)) * v18 >> 31, 2)
            + 4 * ((4 - *(unsigned __int8 *)(v17 + 332)) * v18 >> 31))) >> 2;
    }
    else if ( *(_BYTE *)(v17 + 334) )
    {
      BYTE1(v19) = 0;
    }
    else
    {
      LOWORD(v19) = *(_WORD *)(v17 + 16);
    }
    v20 = v19;
    v21 = *(_WORD *)(a1 + 28);
    HIBYTE(v21) += 2;
    sub_57FA0(&word_EB398, v21, 0, v20);
  }
  v22 = *(_DWORD *)(a1 + 164);
  v23 = *(_WORD *)(v22 + 30);
  if ( v23 )
  {
    if ( v23 > 128 )
      *(_WORD *)(v22 + 30) = 128;
    sub_57FA0(&word_EB398, *(_WORD *)(*(_DWORD *)(a1 + 164) + 32), 0, *(_WORD *)(*(_DWORD *)(a1 + 164) + 30));
    v24 = *(_DWORD *)(a1 + 164);
    v25 = *(_WORD *)(v24 + 30);
    v26 = (_WORD *)(v24 + 30);
    if ( v25 )
    {
      if ( v25 <= 0 )
        v27 = -1;
      else
        v27 = 1;
    }
    else
    {
      v27 = 0;
    }
    *v26 += v27 * dword_D4B90;
    if ( abs(*(signed __int16 *)(*(_DWORD *)(a1 + 164) + 30)) < 4 )
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 30) = 0;
  }
  v28 = *(_WORD **)(a1 + 164);
  v29 = v28[212] + word_EB39A;
  v30 = v28[213];
  word_EB398 += v28[211];
  word_EB39A = v29;
  word_EB39C += v30;
  v28[211] = 0;
  *(_WORD *)(*(_DWORD *)(a1 + 164) + 424) = 0;
  *(_WORD *)(*(_DWORD *)(a1 + 164) + 426) = 0;
  v31 = *(_DWORD *)(a1 + 164);
  v32 = *(_BYTE *)(v31 + 610);
  if ( v32 )
    *(_BYTE *)(v31 + 610) = v32 - 1;
  sub_5DE30(a1);
  v33 = *(_DWORD *)(a1 + 164);
  if ( *(_BYTE *)(v33 + 332) )
  {
    v34 = *(_BYTE *)(v33 + 333) - 1;
    *(_BYTE *)(v33 + 333) = v34;
    if ( !v34 )
    {
      v35 = *(_DWORD *)(a1 + 164);
      v36 = *(_BYTE *)(v35 + 332) - 1;
      *(_BYTE *)(v35 + 332) = v36;
      if ( v36 )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 333) = 8;
        *(_BYTE *)(dword_D41A4 + 181) = 1;
      }
      else
      {
        sub_5C800(a1, 1);
      }
    }
  }
  v37 = *(_DWORD *)(a1 + 164);
  if ( *(_BYTE *)(v37 + 334) )
  {
    v38 = *(_BYTE *)(v37 + 335) - 1;
    *(_BYTE *)(v37 + 335) = v38;
    if ( !v38 )
      --*(_BYTE *)(*(_DWORD *)(a1 + 164) + 334);
  }
  if ( (unsigned __int16)sub_5D0A0(a1) )
  {
    v39 = sub_10C40(&word_EB398);
    v40 = v39;
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 164) + 334) )
    {
      word_EB39C -= 51;
    }
    else
    {
      v41 = *(_DWORD *)(a1 + 160);
      if ( word_EB39C > *(signed __int16 *)(v41 + 12) + v39 )
        word_EB39C += *(_WORD *)(v41 + 14);
    }
    v42 = *(_DWORD *)(a1 + 160);
    if ( word_EB39C >= v40 + *(signed __int16 *)(v42 + 12) )
    {
      if ( byte_D41B6 )
      {
        v43 = sub_10C60(&word_EB398);
        if ( word_EB39C > v43 - 384 )
          word_EB39C = v43 - 384;
      }
    }
    else
    {
      word_EB39C = *(_WORD *)(v42 + 12) + v40;
    }
    sub_57CF0(a1, (int)&word_EB398);
  }
  else
  {
    sub_5DD50(a1);
  }
  if ( !(*(_BYTE *)(a1 + 62) & 0x3F) )
  {
    v44 = dword_EA3E4[*(signed __int16 *)(*(_DWORD *)(a1 + 164) + 827)];
    if ( v44 > dword_EA3E4[0] )
    {
      if ( *(_WORD *)(v44 + 46) )
      {
        v45 = byte_DA972[26 * *(char *)(v44 + 70)];
        if ( (unsigned __int8)v45 < 0x10u )
        {
          if ( v45 == 2 )
            sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 12);
        }
        else if ( (unsigned __int8)v45 <= 0x10u )
        {
          sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 39);
        }
        else if ( (unsigned __int8)v45 >= 0x13u )
        {
          if ( (unsigned __int8)v45 <= 0x13u )
          {
            sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 43);
          }
          else if ( v45 == 25 )
          {
            sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 37);
          }
        }
      }
    }
  }
  v46 = dword_D41A0;
  if ( *(_BYTE *)(dword_D41A0 + 196308) == 2 )
  {
    v47 = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
    *(_DWORD *)(dword_D41A0 + 8) = v47;
    *(_DWORD *)(v46 + 8) += *(_DWORD *)(dword_D41A4 + 30);
    if ( (signed int)(v47 % 0x83) < 5 )
    {
      v48 = *(_WORD *)(v46 + 12);
      if ( v48 == *(_WORD *)(*(_DWORD *)(a1 + 164) + 56) )
        sub_6E450(0, v48, v47 % 0x83 + 65);
    }
  }
  else if ( sub_104D0((signed __int16 *)(a1 + 76)) == (int (*)())1 )
  {
    sub_6E450(0, *(_WORD *)(dword_D41A0 + 12), 1);
    sub_6EAB0(0, *(_WORD *)(dword_D41A0 + 12), 2);
  }
  else
  {
    sub_6E450(0, *(_WORD *)(dword_D41A0 + 12), 2);
    sub_6EAB0(0, *(_WORD *)(dword_D41A0 + 12), 1);
  }
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 164) + 410) >= 1536 )
  {
    sub_6EAB0(0, *(_WORD *)(dword_D41A0 + 12), 5);
  }
  else
  {
    sub_6E450(0, *(_WORD *)(dword_D41A0 + 12), 5);
    *(_DWORD *)(*(_DWORD *)(a1 + 164) + 410) = 2048;
  }
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 164) + 414) >= 1536 )
  {
    sub_6EAB0(0, *(_WORD *)(dword_D41A0 + 12), 31);
  }
  else
  {
    sub_6E450(0, *(_WORD *)(dword_D41A0 + 12), 31);
    *(_DWORD *)(*(_DWORD *)(a1 + 164) + 414) = 2048;
  }
  v49 = *(_DWORD *)(a1 + 164);
  if ( *(_WORD *)(v49 + 56) == *(_WORD *)(dword_D41A0 + 12) )
  {
    v50 = *(_WORD *)(v49 + 54);
    if ( v50 <= 0 )
    {
      sub_99970(1, 3u);
    }
    else
    {
      *(_WORD *)(v49 + 54) = v50 - 1;
      sub_99970(2, 3u);
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// D4B84: using guessed type int dword_D4B84;
// D4B90: using guessed type int dword_D4B90;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0005DD50) --------------------------------------------------------
signed int __cdecl sub_5DD50(int a1)
{
  int v1; // eax
  signed int result; // eax
  char v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( sub_104D0((signed __int16 *)(a1 + 76)) == (int (*)())256
    || byte_D41B6
    && (v1 = *(signed __int16 *)(a1 + 76) >> 8,
        BYTE1(v1) = *(_WORD *)(a1 + 78) >> 8,
        byte_13B4E0[(unsigned __int16)v1] & 8) )
  {
    v3 = 1;
  }
  if ( !v3 && byte_D41B6 && *(_BYTE *)(*(_DWORD *)(a1 + 164) + 609) && sub_11E20(a1, (__int16 *)(a1 + 76)) )
    v3 = 1;
  if ( v3 )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 164) + 609) = 1;
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, 128);
    result = sub_57CF0(a1, (int)&word_EB398);
  }
  else
  {
    result = *(_DWORD *)(a1 + 164);
    *(_BYTE *)(result + 609) = 0;
  }
  return result;
}
// D41B6: using guessed type char byte_D41B6;
// EB398: using guessed type __int16 word_EB398;

//----- (0005DE30) --------------------------------------------------------
void __cdecl sub_5DE30(int a1)
{
  int v1; // edx
  unsigned int v2; // ebx
  int v3; // edi
  __int16 v4; // cx
  signed int v5; // ecx
  int v6; // edi
  __int16 v7; // ax
  unsigned __int16 v8; // ST10_2
  __int16 v9; // ax
  char v10; // al
  int v11; // esi
  int v12; // [esp+4h] [ebp-Ch]
  char *v13; // [esp+8h] [ebp-8h]

  v1 = *(_DWORD *)(a1 + 164);
  v2 = dword_EA3E4[*(unsigned __int16 *)(v1 + 326)];
  v3 = 0;
  if ( v2 > dword_EA3E4[0] )
  {
    v13 = (char *)&unk_DAC7A + 26 * *(signed __int16 *)(v1 + 330);
    v4 = *(_WORD *)(v1 + 847);
    if ( v4 )
      v3 = dword_EA3E4[v4];
    v5 = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v2 + 76));
    if ( v3 && *(_WORD *)(v3 + 46) && v5 < *(_DWORD *)v13 && *(_DWORD *)(v2 + 8) >= 0 )
    {
      v12 = 3 * *(signed __int16 *)(a1 + 132) / 2;
      LOWORD(v6) = (v5 - *(_DWORD *)(*(_DWORD *)(a1 + 164) + 322)) / (1024 / (signed __int16)v12);
      if ( (signed __int16)v6 < -(signed __int16)v12 )
        v6 = 3 * *(signed __int16 *)(a1 + 132) / -2;
      if ( (signed __int16)v6 > (signed __int16)v12 )
        LOWORD(v6) = v12;
      v7 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v2 + 76));
      v8 = v7;
      v9 = *(_WORD *)(a1 + 28) + sub_58350(*(_WORD *)(a1 + 28), v7, 5, 0x82u);
      HIBYTE(v9) &= 7u;
      *(_WORD *)(a1 + 28) = v9;
      sub_57FA0(&word_EB398, v8, *(_WORD *)(a1 + 30), v6);
      v10 = v13[24];
      if ( (unsigned __int8)v10 >= 1u )
      {
        if ( (unsigned __int8)v10 > 1u )
        {
          if ( v10 != 2 )
            return;
          *(_DWORD *)(v2 + 8) -= *(signed __int16 *)(*(_DWORD *)(v2 + 164) + 355) + 2;
        }
        v11 = *(_DWORD *)(v2 + 144) - (*(_DWORD *)(v2 + 136) + 8);
        *(_DWORD *)(v2 + 144) = v11;
        if ( v11 < 0 )
          *(_DWORD *)(v2 + 144) = 0;
      }
    }
    else
    {
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 326) = 0;
    }
  }
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (0005E010) --------------------------------------------------------
void __cdecl sub_5E010(unsigned int a1)
{
  unsigned __int16 v1; // dx
  int v2; // edx
  int v3; // edx
  unsigned __int8 v4; // cl
  int v5; // edx
  int v6; // edx
  int v7; // eax
  int v8; // edx
  __int16 v9; // cx
  int v10; // edi
  int v11; // edx
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  __int16 v15; // di
  char v16; // [esp+0h] [ebp-4h]

  v16 = 0;
  *(_WORD *)(a1 + 132) = dword_D4B8C;
  if ( !(*(_BYTE *)(dword_D41A4 + 24) & 1) )
  {
    v1 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 58);
    if ( v1 )
    {
      if ( sub_106C0(a1, dword_EA3E4[v1]) )
        v16 = 1;
    }
  }
  sub_5F380(a1);
  if ( !(*(_BYTE *)(dword_D41A4 + 24) & 1) && v16 )
  {
    if ( *(_WORD *)(a1 + 98) )
    {
      v2 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)];
      if ( *(_WORD *)(v2 + 98) )
        *(_DWORD *)(v2 + 94) += *(_DWORD *)(a1 + 94);
      else
        *(_DWORD *)(v2 + 94) = *(_DWORD *)(a1 + 94);
      *(_WORD *)(v2 + 98) = *(_WORD *)(a1 + 98);
    }
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 345) = 2;
  }
  if ( !(*(_BYTE *)(dword_D41A4 + 24) & 1) )
  {
    if ( *(_WORD *)(*(_DWORD *)(a1 + 164) + 345) )
    {
      memset(a1 + 94, 0, 36);
      --*(_WORD *)(*(_DWORD *)(a1 + 164) + 345);
    }
    else
    {
      sub_5EFA0(a1);
    }
    v3 = *(_DWORD *)(a1 + 164);
    v4 = *(_BYTE *)(v3 + 340);
    if ( v4 < 0xC8u )
      *(_BYTE *)(v3 + 340) = v4 + 1;
  }
  sub_5D530(a1);
  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    if ( !(*(_BYTE *)(dword_D41A4 + 24) & 1) )
    {
      v6 = *(_DWORD *)(a1 + 164);
      *(_DWORD *)(a1 + 144) += *(_DWORD *)(a1 + 136);
      v7 = *(_DWORD *)(v6 + 397);
      if ( v7 )
        *(_DWORD *)(v6 + 397) = v7 - 1;
      else
        *(_DWORD *)(a1 + 8) += *(signed __int16 *)(v6 + 355);
      v8 = *(_DWORD *)(a1 + 164);
      v9 = *(_WORD *)(v8 + 588);
      if ( v9 )
        *(_WORD *)(v8 + 588) = v9 - 1;
      if ( *(_DWORD *)(a1 + 144) < 0 )
        *(_DWORD *)(a1 + 144) = 0;
      v10 = *(_DWORD *)(a1 + 140);
      if ( *(_DWORD *)(a1 + 144) > v10 )
        *(_DWORD *)(a1 + 144) = v10;
      if ( *(_DWORD *)(a1 + 8) < -1 )
        *(_DWORD *)(a1 + 8) = -1;
      v11 = *(_DWORD *)(a1 + 4);
      if ( *(_DWORD *)(a1 + 8) > v11 )
        *(_DWORD *)(a1 + 8) = v11;
      v12 = *(_DWORD *)(a1 + 164);
      v13 = *(_DWORD *)(v12 + 365);
      if ( v13 )
        *(_DWORD *)(v12 + 365) = v13 - 1;
      v14 = *(_DWORD *)(a1 + 164);
      v15 = *(_WORD *)(v14 + 584);
      if ( v15 )
        *(_WORD *)(v14 + 584) = v15 - 1;
      if ( v16 || *(_BYTE *)(a1 + 13) & 0x10 )
      {
        *(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 140) / 200;
        *(_WORD *)(*(_DWORD *)(a1 + 164) + 355) = *(_DWORD *)(a1 + 4) / 250;
        if ( *(_DWORD *)(a1 + 136) < 1000 )
          *(_DWORD *)(a1 + 136) = 1000;
        *(_BYTE *)(a1 + 13) &= 0xEFu;
      }
      else
      {
        *(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 140) / 2000;
        *(_WORD *)(*(_DWORD *)(a1 + 164) + 355) = *(_DWORD *)(a1 + 4) / 2000;
        if ( *(_DWORD *)(a1 + 136) < 100 )
          *(_DWORD *)(a1 + 136) = 100;
      }
    }
  }
  else
  {
    v5 = dword_D41A0;
    *(_BYTE *)(a1 + 69) = 2;
    *(_WORD *)(a1 + 44) = 0;
    sub_6E450((signed int)(a1 - (v5 + 28302)) / 168, -1, 16);
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D4B8C: using guessed type int dword_D4B8C;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005E310) --------------------------------------------------------
int __cdecl sub_5E310(int a1)
{
  int v1; // edx
  __int16 v2; // cx
  int v3; // esi
  __int16 v4; // ax
  __int16 v5; // di
  int v6; // eax
  int result; // eax
  unsigned __int16 v8; // di
  int v9; // eax
  char v10; // dl
  int v11; // edx
  int v12; // eax
  int v13; // edx
  char *v14; // esi
  char *v15; // edi
  char v16; // al
  char v17; // al
  int v18; // eax
  unsigned int v19; // edx
  __int16 v20; // di
  __int16 v21; // ax
  int v22; // ecx
  unsigned int j; // ecx
  int v24; // [esp+0h] [ebp-Ch]
  signed int i; // [esp+4h] [ebp-8h]
  unsigned int v26; // [esp+8h] [ebp-4h]

  sub_5D530(a1);
  if ( *(_BYTE *)(dword_D41A4 + 127) )
    sub_5C800(a1, 7);
  v1 = 2124 * *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 56);
  if ( *(_BYTE *)(v1 + dword_D41A0 + 11230 + 991) )
    sub_52E90(v1 + dword_D41A0 + 11230, 0, 0);
  v2 = *(_WORD *)(a1 + 44) - 2;
  *(_WORD *)(a1 + 80) += *(_WORD *)(a1 + 44);
  *(_WORD *)(a1 + 44) = v2;
  if ( v2 < -256 )
    *(_WORD *)(a1 + 44) = -256;
  if ( *(_WORD *)(a1 + 44) > 0 )
    *(_WORD *)(a1 + 44) = 0;
  v3 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 12);
  v4 = sub_10C40((__int16 *)(a1 + 76));
  v5 = v4;
  if ( *(signed __int16 *)(a1 + 80) < v3 + v4 )
    *(_WORD *)(a1 + 80) = *(_WORD *)(*(_DWORD *)(a1 + 160) + 12) + v4;
  v6 = sub_4A190((int)&word_EB398, 10, 1);
  if ( v6 )
  {
    *(_BYTE *)(v6 + 12) |= 0x80u;
    *(_WORD *)(v6 + 26) = *(_WORD *)(a1 + 26);
  }
  result = v5 + *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 12);
  if ( *(signed __int16 *)(a1 + 80) == result )
  {
    sub_49F90();
    v8 = *(_WORD *)(a1 + 36);
    if ( v8 )
    {
      v9 = dword_EA3E4[v8];
      if ( *(_BYTE *)(v9 + 63) == 3 )
      {
        v10 = *(_BYTE *)(v9 + 64);
        if ( !v10 || v10 == 1 )
        {
          v11 = *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 36)] + 164);
          v12 = *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 56);
          ++*(_WORD *)(v11 + 2 * v12 + 38);
        }
      }
    }
    memset(a1 + 94, 0, 36);
    v13 = 2124 * *(signed __int16 *)(*(_DWORD *)(a1 + 164) + 56) + dword_D41A0 + 11230;
    v14 = (char *)dword_EA224;
    v15 = (char *)(v13 + 28);
    do
    {
      v16 = *v14;
      *v15 = *v14;
      if ( !v16 )
        break;
      v17 = v14[1];
      v14 += 2;
      v15[1] = v17;
      v15 += 2;
    }
    while ( v17 );
    *(_WORD *)(v13 + 79) = 1;
    *(_WORD *)(v13 + 77) = 100;
    for ( i = 0; i < 26; ++i )
    {
      v18 = *(_DWORD *)(a1 + 164) + 2 * i;
      v19 = dword_EA3E4[*(signed __int16 *)(v18 + 819)];
      v26 = v19;
      if ( v19 <= dword_EA3E4[0] )
      {
        *(_WORD *)(v18 + 819) = 0;
      }
      else
      {
        *(_WORD *)(v18 + 819) = 1;
        *(_BYTE *)(v19 + 12) &= 0xFEu;
        ++*(_BYTE *)(v19 + 69);
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v20 = *(_WORD *)(a1 + 20);
        word_EB398 += (*(_WORD *)(a1 + 20) & 0x1FF) - 256;
        v21 = 9377 * v20 + 9439;
        *(_WORD *)(a1 + 20) = v21;
        word_EB39A += (v21 & 0x1FF) - 256;
        sub_57CF0(v19, (int)&word_EB398);
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        *(_DWORD *)(v26 + 8) = *(unsigned __int16 *)(a1 + 20) % 0x5Au + 200;
      }
    }
    v24 = sub_4A190(a1 + 76, 10, 40);
    if ( v24 )
    {
      *(_BYTE *)(a1 + 69) = 3;
      v22 = dword_D41A4;
      *(_DWORD *)(a1 + 16) = 1200;
      for ( j = *(_DWORD *)(v22 + 38523); j > dword_EA3E4[0]; j = *(_DWORD *)j )
      {
        if ( *(_BYTE *)(j + 64) == 39 && *(unsigned __int16 *)(j + 148) == (a1 - (dword_D41A0 + 28302)) / 168 )
          *(_WORD *)(j + 148) = (v24 - (dword_D41A0 + 28302)) / 168;
      }
    }
    *(_BYTE *)(a1 + 12) |= 0x20u;
    result = dword_D41A0;
    --*(_DWORD *)(result + 4582);
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA224: using guessed type int dword_EA224;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;

//----- (0005E660) --------------------------------------------------------
int __cdecl sub_5E660(int a1)
{
  char v1; // ah
  signed int v2; // ebx

  v1 = *(_BYTE *)(a1 + 12);
  *(_DWORD *)(a1 + 8) = -1;
  v2 = 0;
  *(_BYTE *)(a1 + 12) = v1 | 0x20;
  while ( v2 < 26 )
  {
    if ( (unsigned int)dword_EA3E4[*(signed __int16 *)(*(_DWORD *)(a1 + 164) + 2 * v2 + 819)] > dword_EA3E4[0] )
      sub_57F10(dword_EA3E4[*(signed __int16 *)(*(_DWORD *)(a1 + 164) + 2 * v2 + 819)]);
    ++v2;
  }
  return sub_57F10(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005E6C0) --------------------------------------------------------
__int16 __cdecl sub_5E6C0(int a1)
{
  char v1; // al
  _WORD *v2; // edi
  __int16 v3; // ax
  __int16 v4; // ST04_2
  unsigned __int16 v5; // ST00_2
  __int16 v6; // ax
  unsigned __int16 v7; // ST00_2
  __int16 v8; // ax
  __int16 result; // ax

  v1 = 0;
  if ( !*(_WORD *)(a1 + 36) )
    v1 = 1;
  if ( v1 )
  {
    *(_WORD *)(a1 + 28) += 5;
    *(_BYTE *)(a1 + 29) &= 7u;
    v8 = sub_10C40((__int16 *)(a1 + 76));
    ++HIBYTE(v8);
  }
  else
  {
    v2 = (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 36)] + 76);
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), v2);
    v3 = sub_58210((_WORD *)(a1 + 76), v2);
    v4 = *(_WORD *)(a1 + 32);
    v5 = *(_WORD *)(a1 + 28);
    *(_WORD *)(a1 + 34) = v3;
    v6 = sub_58350(v5, v4, 5, 0x16u);
    LOWORD(v2) = *(_WORD *)(a1 + 34);
    *(_WORD *)(a1 + 28) += v6;
    v7 = *(_WORD *)(a1 + 30);
    *(_BYTE *)(a1 + 29) &= 7u;
    *(_WORD *)(a1 + 30) += sub_58350(v7, (__int16)v2, 5, 0x16u);
    *(_BYTE *)(a1 + 31) &= 7u;
    v8 = sub_10C40((__int16 *)(a1 + 76));
  }
  *(_WORD *)(a1 + 80) = v8;
  *(_WORD *)(a1 + 30) = 0;
  result = *(_WORD *)(a1 + 30);
  *(_WORD *)(*(_DWORD *)(a1 + 164) + 343) = result;
  *(_WORD *)(*(_DWORD *)(a1 + 164) + 341) = 0;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005E7C0) --------------------------------------------------------
char __cdecl sub_5E7C0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // ebx
  _BYTE *v5; // esi
  _BYTE *v6; // edi

  *(_WORD *)(*(_DWORD *)(a1 + 164) + 30) = 0;
  v1 = *(_DWORD *)(a1 + 164);
  v2 = 2124 * *(signed __int16 *)(v1 + 56);
  if ( *(_BYTE *)(dword_D41A0 + v2 + 11239) == 1 )
  {
    v3 = v2 + dword_D41A0 + 11230;
    if ( *(_WORD *)(v1 + 58) )
    {
      v4 = *(_DWORD *)(a1 + 16);
      if ( v4 )
        *(_DWORD *)(a1 + 16) = v4 - 1;
      else
        LOBYTE(v1) = sub_5C950(v3, a1);
    }
    else
    {
      if ( *(_BYTE *)(v3 + 6) )
      {
        v5 = (_BYTE *)dword_EA0B8;
        v6 = (_BYTE *)(v3 + 28);
        do
        {
          LOBYTE(v1) = *v5;
          *v6 = *v5;
          if ( !(_BYTE)v1 )
            break;
          LOBYTE(v1) = v5[1];
          v5 += 2;
          v6[1] = v1;
          v6 += 2;
        }
        while ( (_BYTE)v1 );
        *(_WORD *)(v3 + 79) = 1;
        *(_WORD *)(v3 + 77) = 200;
      }
      *(_BYTE *)(v3 + 6) = 0;
    }
  }
  else
  {
    sub_5C800(a1, 7);
    LOBYTE(v1) = sub_5E6C0(a1);
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// EA0B8: using guessed type int dword_EA0B8;

//----- (0005E8C0) --------------------------------------------------------
signed int __cdecl sub_5E8C0(int a1)
{
  __int16 v1; // si
  int v2; // eax
  unsigned __int8 v3; // dl
  __int16 v4; // di
  __int16 v5; // dx
  unsigned int v6; // eax
  char v7; // dl
  int v8; // esi
  signed __int16 v9; // ax
  __int16 v10; // si
  int v11; // eax
  int v12; // ecx
  int v13; // edx
  int v14; // esi
  __int16 v15; // di
  int v16; // esi
  __int16 v17; // cx
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // edx
  int v22; // eax
  __int16 v23; // ax
  int v24; // edx
  int v25; // esi
  int v26; // ecx
  signed int result; // eax
  char v28; // [esp+0h] [ebp-4h]

  v28 = 0;
  switch ( *(_BYTE *)(a1 + 70) )
  {
    case 0:
      sub_52E90(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230, 0, 0);
      if ( *(_WORD *)(*(_DWORD *)(a1 + 164) + 56) == *(_WORD *)(dword_D41A0 + 12) )
      {
        sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 41);
        sub_5C800(a1, 6);
      }
      *(_BYTE *)(*(_DWORD *)(a1 + 164) + 334) = 0;
      *(_BYTE *)(*(_DWORD *)(a1 + 164) + 332) = 0;
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 30) = 0;
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 16) = 0;
      v1 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 825);
      if ( v1 )
        *(_WORD *)(dword_EA3E4[v1] + 46) = 0;
      v2 = dword_D41A0;
      *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + v2 + 11232) |= 0x20u;
      v3 = *(_BYTE *)(a1 + 69);
      *(_WORD *)(a1 + 150) = 0;
      if ( v3 >= 0xBu )
      {
        if ( v3 <= 0xBu )
        {
          v5 = *(_WORD *)((char *)&loc_36DFC + v2);
          if ( v5 )
            *(_WORD *)(a1 + 150) = v5;
        }
        else if ( v3 == 12 )
        {
          v4 = *(_WORD *)(v2 + 224766);
          if ( v4 )
            *(_WORD *)(a1 + 150) = v4;
        }
      }
      v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
      if ( v6 > dword_EA3E4[0] )
      {
        if ( *(_BYTE *)(v6 + 63) != 14 || (v7 = *(_BYTE *)(v6 + 64), v7 != 4) && v7 != 3 )
          *(_WORD *)(a1 + 150) = 0;
      }
      *(_BYTE *)(a1 + 70) = 1;
      break;
    case 1:
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      v8 = *(signed __int16 *)(a1 + 130);
      sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
      if ( (unsigned __int16)sub_5D0A0(a1) )
        sub_57CF0(a1, (int)&word_EB398);
      else
        *(_WORD *)(a1 + 130) = 0;
      if ( abs(v8) <= 4 )
      {
        *(_WORD *)(a1 + 130) = 0;
      }
      else
      {
        if ( v8 <= 0 )
          v9 = 1;
        else
          v9 = -1;
        *(_WORD *)(a1 + 130) += 4 * v9;
      }
      if ( !*(_WORD *)(a1 + 130) )
        *(_BYTE *)(a1 + 70) = (*(_WORD *)(a1 + 150) == 0) + 3;
      break;
    case 3:
      v10 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 76));
      if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v10) <= 0xBu )
      {
        *(_BYTE *)(a1 + 70) = 4;
        *(_WORD *)(a1 + 28) = v10;
      }
      else
      {
        *(_WORD *)(a1 + 28) += sub_58350(*(_WORD *)(a1 + 28), v10, 0, 0xBu);
        *(_BYTE *)(a1 + 29) &= 7u;
      }
      break;
    case 4:
      *(_DWORD *)(a1 + 16) = 12;
      v11 = dword_D41A0;
      *(_BYTE *)(a1 + 70) = 5;
      *(_BYTE *)(v11 + 224779) |= 2u;
      goto LABEL_34;
    case 5:
LABEL_34:
      v12 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v12;
      if ( v12 )
      {
        if ( v12 > 4 )
          --*(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11707);
      }
      else
      {
        if ( *(_WORD *)(a1 + 150) )
          *(_BYTE *)(a1 + 70) = 6;
        else
          *(_BYTE *)(a1 + 70) = 8;
        if ( dword_E9C3C && !*(_BYTE *)(dword_D41A0 + 196308) )
        {
          sub_86860(word_1803EC);
          sub_53E60((int)aDataGtd2Dat, byte_FAEE0);
        }
      }
      break;
    case 6:
      *(_DWORD *)(a1 + 16) = 512;
      *(_WORD *)(a1 + 130) = 100;
      *(_BYTE *)(a1 + 70) = 7;
      v28 = 1;
      goto LABEL_44;
    case 7:
LABEL_44:
      v13 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v13;
      if ( !v13 )
        goto LABEL_51;
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      v14 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
      *(_WORD *)(a1 + 28) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v14 + 76));
      sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
      v15 = *(_WORD *)(a1 + 130) + 8;
      *(_WORD *)(a1 + 130) = v15;
      if ( v15 < 0 )
        *(_WORD *)(a1 + 130) = 0;
      if ( *(_WORD *)(a1 + 130) > 200 )
        *(_WORD *)(a1 + 130) = 200;
      if ( !(unsigned __int16)sub_5D0A0(a1) )
        goto LABEL_51;
      sub_57CF0(a1, (int)&word_EB398);
      if ( sub_58490((_WORD *)(a1 + 76), (_WORD *)(v14 + 76)) < 0x180 )
        goto LABEL_51;
      break;
    case 8:
      *(_DWORD *)(a1 + 16) = 128;
      *(_WORD *)(a1 + 130) = 100;
      *(_BYTE *)(a1 + 70) = 9;
      v28 = 1;
      goto LABEL_53;
    case 9:
LABEL_53:
      v16 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v16;
      if ( !v16 )
        goto LABEL_51;
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
      v17 = *(_WORD *)(a1 + 130) + 8;
      *(_WORD *)(a1 + 130) = v17;
      if ( v17 < 0 )
        *(_WORD *)(a1 + 130) = 0;
      if ( *(_WORD *)(a1 + 130) > 200 )
        *(_WORD *)(a1 + 130) = 200;
      if ( (unsigned __int16)sub_5D0A0(a1) )
        sub_57CF0(a1, (int)&word_EB398);
      else
LABEL_51:
        *(_BYTE *)(a1 + 70) = 10;
      break;
    case 0xA:
      *(_BYTE *)(a1 + 70) = 11;
      v18 = *(_DWORD *)(a1 + 164);
      *(_DWORD *)(a1 + 16) = 32;
      if ( *(_WORD *)(v18 + 56) == *(_WORD *)(dword_D41A0 + 12) )
        sub_5C800(a1, 5);
      goto LABEL_62;
    case 0xB:
LABEL_62:
      v19 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v19;
      if ( v19 && *(_BYTE *)(dword_D41A4 + 180) )
      {
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, 2);
        if ( (unsigned __int16)sub_5D0A0(a1) )
          sub_57CF0(a1, (int)&word_EB398);
      }
      else
      {
        *(_BYTE *)(a1 + 70) = 12;
      }
      break;
    case 0xC:
      v20 = dword_D41A0;
      v21 = 2124 * *(signed __int16 *)(dword_D41A0 + 12);
      *(_BYTE *)(dword_D41A0 + 8625) = 0;
      *(_BYTE *)(v20 + 8593) = 0;
      *(_WORD *)(v21 + v20 + 11232) = 10;
      if ( *(_BYTE *)(a1 + 69) == 11 )
        *(_BYTE *)(dword_D41A4 + 38545) &= 0xFBu;
      if ( *(_BYTE *)(a1 + 69) == 11 || *(_BYTE *)(dword_D41A4 + 38545) & 0x10 )
        *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) |= 0x10u;
      break;
    default:
      break;
  }
  if ( v28 )
  {
    if ( *(_WORD *)(*(_DWORD *)(a1 + 164) + 56) == *(_WORD *)(dword_D41A0 + 12) )
    {
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 19);
      if ( dword_E9C3C )
      {
        v22 = dword_D41A0;
        *(_BYTE *)(dword_D41A0 + 8625) = 1;
        *(_BYTE *)(v22 + 8593) = 2;
      }
    }
  }
  v23 = sub_10C40((__int16 *)(a1 + 76));
  v24 = *(signed __int16 *)(a1 + 80);
  if ( v24 <= v23 + 256 )
  {
    if ( v24 >= v23 )
      *(_WORD *)(a1 + 80) = v23 + 128;
    else
      *(_WORD *)(a1 + 80) += 128;
  }
  else
  {
    *(_WORD *)(a1 + 80) -= 128;
  }
  v25 = *(_DWORD *)(a1 + 164);
  *(_WORD *)(v25 + 341) -= (signed int)(*(signed __int16 *)(v25 + 341)
                                      - (__CFSHL__((unsigned __int64)*(signed __int16 *)(v25 + 341) >> 32, 3)
                                       + 8 * ((unsigned __int64)*(signed __int16 *)(v25 + 341) >> 32))) >> 3;
  v26 = *(_DWORD *)(a1 + 164);
  result = (signed int)(*(signed __int16 *)(v26 + 343)
                      - (__CFSHL__((unsigned __int64)*(signed __int16 *)(v26 + 343) >> 32, 2)
                       + 4 * ((unsigned __int64)*(signed __int16 *)(v26 + 343) >> 32))) >> 2;
  *(_WORD *)(v26 + 343) -= result;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E9C3C: using guessed type int dword_E9C3C;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// 1803EC: using guessed type __int16 word_1803EC;

//----- (0005EF70) --------------------------------------------------------
unsigned int __cdecl sub_5EF70(unsigned int a1)
{
  unsigned int result; // eax

  result = a1;
  if ( a1 > dword_EA3E4[0] && *(_BYTE *)(a1 + 63) == 3 && !*(_BYTE *)(a1 + 64) )
  {
    result = *(_DWORD *)(a1 + 164);
    *(_WORD *)(result + 54) = 100;
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005EFA0) --------------------------------------------------------
signed int __cdecl sub_5EFA0(unsigned int a1)
{
  signed int v1; // esi
  unsigned int v2; // eax
  int v3; // edi
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  __int16 v8; // ax
  char v9; // ch
  int v10; // eax
  char v11; // dl
  int v12; // edi
  char v13; // dh
  unsigned __int16 v14; // di
  int v15; // edi
  int v16; // eax
  int v17; // eax

  *(_WORD *)(a1 + 38) = 0;
  v1 = 0;
  if ( *(_WORD *)(a1 + 150) )
  {
    v2 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v2 > dword_EA3E4[0] && (*(_DWORD *)(v2 + 8) <= 0 || *(_BYTE *)(v2 + 13) & 4) )
      *(_WORD *)(a1 + 150) = 0;
  }
  if ( *(_DWORD *)(a1 + 8) >= 0 )
  {
    if ( *(_WORD *)(a1 + 122) )
    {
      v3 = dword_EA3E4[*(unsigned __int16 *)(a1 + 122)];
      if ( v3 )
      {
        *(_WORD *)(*(_DWORD *)(v3 + 164) + 326) = (signed int)(a1 - (dword_D41A0 + 28302)) / 168;
        *(_DWORD *)(*(_DWORD *)(v3 + 164) + 322) = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76));
        *(_WORD *)(*(_DWORD *)(v3 + 164) + 330) = *(_WORD *)(a1 + 118);
        v4 = *(_DWORD *)(v3 + 164);
        if ( *(_DWORD *)(v4 + 322) < 1024 )
          *(_DWORD *)(v4 + 322) = 1024;
        v5 = *(_DWORD *)(v3 + 164);
        if ( *(_DWORD *)(v5 + 322) > 3072 )
          *(_DWORD *)(v5 + 322) = 3072;
        sub_6D8B0(*(_WORD *)(a1 + 122), 0xEu, 1);
      }
      v6 = *(_DWORD *)(a1 + 164);
      *(_WORD *)(a1 + 122) = 0;
      *(_BYTE *)(v6 + 406) = 4;
      *(_DWORD *)(*(_DWORD *)(a1 + 164) + 397) = 16;
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 588) = 64;
      sub_5EF70(a1);
    }
    if ( *(_WORD *)(a1 + 116) )
      sub_61050(a1);
    v7 = *(_DWORD *)(a1 + 164);
    if ( *(_BYTE *)(v7 + 332) && *(_BYTE *)(dword_D41A4 + 181) )
      sub_5C830(a1, 3, 171 * *(unsigned __int8 *)(v7 + 332) / 3 + 85);
    v8 = *(_WORD *)(a1 + 98);
    if ( v8 )
    {
      v9 = *(_BYTE *)(a1 + 13);
      *(_WORD *)(a1 + 38) = v8;
      if ( v9 & 0x40 || *(_BYTE *)(a1 + 14) & 0x40 )
      {
        sub_6D8B0((signed int)(a1 - (dword_D41A0 + 28302)) / 168, 6u, 1);
        if ( *(_BYTE *)(a1 + 13) & 0x40 )
        {
          v10 = (*(_DWORD *)(a1 + 94) - (__CFSHL__(*(_DWORD *)(a1 + 94) >> 31, 2) + 4 * (*(_DWORD *)(a1 + 94) >> 31))) >> 2;
          v11 = *(_BYTE *)(a1 + 13);
          v12 = *(_DWORD *)(a1 + 144) - v10;
          *(_DWORD *)(a1 + 94) = v10;
          *(_DWORD *)(a1 + 144) = v12;
          *(_BYTE *)(a1 + 13) = v11 & 0xBF;
        }
        else
        {
          *(_DWORD *)(a1 + 12) &= 0xFFBFBFFF;
          v13 = *(_BYTE *)(a1 + 13);
          *(_DWORD *)(a1 + 94) = 0;
          *(_BYTE *)(a1 + 13) = v13 | 0x40;
        }
      }
      v14 = *(_WORD *)(a1 + 98);
      *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
      v15 = dword_EA3E4[v14];
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 32) = sub_581E0((_WORD *)(v15 + 76), (_WORD *)(a1 + 76));
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 34) = sub_58210((_WORD *)(v15 + 76), (_WORD *)(a1 + 76));
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 30) = *(_DWORD *)(a1 + 94) / 10;
      v16 = *(_DWORD *)(a1 + 164);
      if ( *(_WORD *)(v16 + 30) < 0 )
        *(_WORD *)(v16 + 30) = 0;
      v17 = *(_DWORD *)(a1 + 164);
      if ( *(_WORD *)(v17 + 30) > 80 )
        *(_WORD *)(v17 + 30) = 80;
      sub_5C800(a1, 2);
      *(_BYTE *)(*(_DWORD *)(a1 + 164) + 406) = 4;
      *(_DWORD *)(*(_DWORD *)(a1 + 164) + 397) = 16;
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 588) = 64;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      sub_6E450((signed int)(a1 - (dword_D41A0 + 28302)) / 168, -1, (*(_WORD *)(a1 + 20) & 3) + 54);
      if ( *(_DWORD *)(a1 + 8) < 0 )
      {
        *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 98);
        if ( *(_BYTE *)(v15 + 63) == 10 && *(_BYTE *)(v15 + 64) == 67 )
          *(_WORD *)(a1 + 36) = 0;
        v1 = 2;
      }
      if ( v1 != 2 )
      {
        v1 = 1;
        sub_5EF70(a1);
        *(_WORD *)(a1 + 98) = 0;
      }
    }
  }
  else
  {
    v1 = 2;
  }
  if ( *(_BYTE *)(dword_D41A4 + 25) & 1 && !*(_BYTE *)(a1 + 64) )
  {
    *(_WORD *)(a1 + 38) = 0;
    *(_WORD *)(a1 + 36) = 0;
    *(_WORD *)(a1 + 98) = 0;
    *(_DWORD *)(a1 + 8) = 10000;
    v1 = 0;
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005F380) --------------------------------------------------------
char __cdecl sub_5F380(int a1)
{
  signed __int16 v1; // ax
  int v2; // edx
  int v3; // edx
  int v4; // eax
  int v5; // eax
  signed __int16 v6; // ax
  __int16 v7; // di
  signed __int16 v8; // ax
  signed __int16 v9; // dx
  __int16 v10; // di
  signed int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // edx
  _BOOL1 v15; // zf
  _BOOL1 v16; // sf
  unsigned __int8 v17; // of
  int v18; // eax
  int v19; // edx
  int v20; // eax
  int v21; // eax
  _BYTE *v22; // eax

  v1 = 0;
  *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 0;
  v2 = *(_DWORD *)(a1 + 164);
  if ( *(_BYTE *)v2 & 1 && *(signed __int16 *)(v2 + 12) < dword_D4B8C )
    v1 = 1;
  v3 = *(_DWORD *)(a1 + 164);
  if ( *(_BYTE *)v3 & 2 && *(signed __int16 *)(v3 + 12) > dword_D4B88 )
    v1 = -1;
  if ( v1 )
  {
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) += dword_D4B84 * v1;
    v4 = *(_DWORD *)(a1 + 164);
    if ( *(signed __int16 *)(v4 + 12) < dword_D4B88 )
      *(_WORD *)(v4 + 12) = dword_D4B88;
    v5 = *(_DWORD *)(a1 + 164);
    if ( *(signed __int16 *)(v5 + 12) > dword_D4B8C )
      *(_WORD *)(v5 + 12) = dword_D4B8C;
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
  }
  v6 = 0;
  if ( **(_BYTE **)(a1 + 164) & 4 )
    v6 = -1;
  if ( **(_BYTE **)(a1 + 164) & 8 )
    v6 = 1;
  if ( v6 )
  {
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 16) += word_D4BA4 * v6;
    v18 = *(_DWORD *)(a1 + 164);
    if ( *(signed __int16 *)(v18 + 16) < dword_D4BA8 )
      *(_WORD *)(v18 + 16) = dword_D4BA8;
    v13 = *(_DWORD *)(a1 + 164);
    v19 = *(signed __int16 *)(v13 + 16);
    v17 = __OFSUB__(v19, dword_D4BAC);
    v15 = v19 == dword_D4BAC;
    v16 = v19 - dword_D4BAC < 0;
  }
  else
  {
    v7 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 16);
    if ( v7 )
    {
      if ( v7 <= 0 )
        v8 = -1;
      else
        v8 = 1;
    }
    else
    {
      v8 = 0;
    }
    v9 = v8;
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 16) += v8 * word_D4BB0;
    v10 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 16);
    if ( v10 )
    {
      if ( v10 <= 0 )
        v11 = -1;
      else
        v11 = 1;
    }
    else
    {
      v11 = 0;
    }
    if ( v9 != v11 )
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 16) = 0;
    v12 = *(_DWORD *)(a1 + 164);
    if ( *(signed __int16 *)(v12 + 16) < dword_D4BA8 )
      *(_WORD *)(v12 + 16) = dword_D4BA8;
    v13 = *(_DWORD *)(a1 + 164);
    v14 = *(signed __int16 *)(v13 + 16);
    v17 = __OFSUB__(v14, dword_D4BAC);
    v15 = v14 == dword_D4BAC;
    v16 = v14 - dword_D4BAC < 0;
  }
  if ( !((unsigned __int8)(v16 ^ v17) | (unsigned __int8)v15) )
    *(_WORD *)(v13 + 16) = dword_D4BAC;
  v20 = *(_DWORD *)(a1 + 164);
  if ( *(_BYTE *)v20 & 0x10 )
    sub_5F660(a1, dword_EA3E4[*(signed __int16 *)(v20 + 2 * *(signed __int16 *)(v20 + 1105) + 819)], 256);
  v21 = *(_DWORD *)(a1 + 164);
  if ( *(_BYTE *)v21 & 0x20 )
    sub_5F660(a1, dword_EA3E4[*(signed __int16 *)(v21 + 2 * *(signed __int16 *)(v21 + 1107) + 819)], 512);
  v22 = *(_BYTE **)(a1 + 164);
  if ( *v22 & 0x40 )
    LOBYTE(v22) = sub_5F660(
                    a1,
                    dword_EA3E4[*(signed __int16 *)&v22[2 * (unsigned __int8)byte_D94FF[(char)v22[1112]] + 819]],
                    256);
  return (char)v22;
}
// D4B84: using guessed type int dword_D4B84;
// D4B88: using guessed type int dword_D4B88;
// D4B8C: using guessed type int dword_D4B8C;
// D4BA4: using guessed type __int16 word_D4BA4;
// D4BA8: using guessed type int dword_D4BA8;
// D4BAC: using guessed type int dword_D4BAC;
// D4BB0: using guessed type __int16 word_D4BB0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005F660) --------------------------------------------------------
char __cdecl sub_5F660(int a1, unsigned int a2, int a3)
{
  int v3; // ecx
  char v5; // [esp+0h] [ebp-Ch]
  char v6; // [esp+4h] [ebp-8h]
  char v7; // [esp+8h] [ebp-4h]

  v3 = a3;
  v5 = 0;
  v7 = 0;
  v6 = 0;
  if ( a2 > dword_EA3E4[0] )
  {
    if ( *(_BYTE *)(a1 + 64) == 1 )
    {
      v5 = 1;
      v3 = 0;
    }
    switch ( *(_BYTE *)(a2 + 64) )
    {
      case 0:
        if ( *(_BYTE *)(a2 + 70) < 2 )
          break;
        goto LABEL_16;
      case 1:
        if ( *(_WORD *)(a2 + 46) <= 0 )
          break;
        *(_BYTE *)(a2 + 60) = 1;
        *(_BYTE *)(a1 + 13) &= 0xFCu;
        *(_DWORD *)(a1 + 12) |= v3;
        sub_5F7E0(a2, a1);
        v7 = 1;
        goto LABEL_23;
      case 2:
        if ( *(_WORD *)(a2 + 46) <= 0 )
          break;
        if ( !v5 )
          sub_6E450(0, *(_WORD *)(*(_DWORD *)(a1 + 164) + 56), 29);
        goto LABEL_23;
      case 4:
      case 6:
      case 8:
      case 0xB:
      case 0xC:
      case 0xE:
        if ( *(_BYTE *)(a1 + 64) )
          goto LABEL_16;
        if ( *(_WORD *)(a2 + 46) <= 0 )
          break;
        if ( *(_BYTE *)(a2 + 64) == 4 )
          *(_WORD *)(a2 + 46) = 7;
        else
          *(_WORD *)(a2 + 46) = 1;
        goto LABEL_23;
      case 7:
        if ( *(_BYTE *)(a2 + 70) < 1 || !*(_WORD *)(a2 + 46) )
          break;
        goto LABEL_23;
      case 9:
      case 0xA:
      case 0xD:
      case 0xF:
      case 0x10:
      case 0x11:
      case 0x12:
      case 0x13:
      case 0x14:
      case 0x15:
      case 0x16:
      case 0x17:
      case 0x18:
LABEL_16:
        if ( *(_WORD *)(a2 + 46) )
          goto LABEL_23;
        break;
      default:
        break;
    }
    if ( *(_DWORD *)(a1 + 144) < *(_DWORD *)(a2 + 140) )
    {
      v6 = 1;
    }
    else
    {
      sub_5F7B0(a2, a1, v3);
      v7 = 1;
    }
  }
LABEL_23:
  if ( v6 && !v5 )
  {
    sub_88B60();
    sub_6E450(0, *(_WORD *)(*(_DWORD *)(a1 + 164) + 56), 29);
  }
  return v7;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005F7B0) --------------------------------------------------------
unsigned __int8 __cdecl sub_5F7B0(int a1, int a2, int a3)
{
  *(_WORD *)(a1 + 46) = *(_WORD *)(a1 + 48);
  *(_BYTE *)(a2 + 13) &= 0xFCu;
  *(_DWORD *)(a2 + 12) |= a3;
  return sub_5F7E0(a1, a2);
}

//----- (0005F7E0) --------------------------------------------------------
unsigned __int8 __cdecl sub_5F7E0(int a1, int a2)
{
  unsigned __int8 result; // al

  result = *(_BYTE *)(*(_DWORD *)(a2 + 164) + 447);
  if ( result < 2u || result <= 2u && (result = *(_BYTE *)(a1 + 64), result != 1) )
    *(_BYTE *)(a2 + 12) &= 0xDFu;
  return result;
}

//----- (0005F810) --------------------------------------------------------
unsigned int __cdecl sub_5F810(int a1, int a2, int a3)
{
  unsigned int v3; // edi
  unsigned int v4; // esi
  unsigned int v5; // ebx
  unsigned int v7; // eax

  v3 = -1;
  v4 = 0;
  v5 = *(_DWORD *)(dword_D41A4 + 38523);
  if ( v5 <= dword_EA3E4[0] )
    return 0;
  do
  {
    if ( *(_BYTE *)(v5 + 64) == 39
      && !(*(_BYTE *)(v5 + 13) & 0x20)
      && *(unsigned __int16 *)(v5 + 148) == *(signed __int16 *)(a1 + 26)
      && v5 != a2
      && v5 != a3 )
    {
      v7 = sub_58440((_WORD *)(a1 + 76), (_WORD *)(v5 + 76));
      if ( v7 < v3 )
      {
        v4 = v5;
        v3 = v7;
      }
    }
    v5 = *(_DWORD *)v5;
  }
  while ( v5 > dword_EA3E4[0] );
  return v4;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005F890) --------------------------------------------------------
char __cdecl sub_5F890(int a1, __int16 a2)
{
  _WORD *v2; // eax
  __int16 v3; // bx

  v2 = *(_WORD **)(dword_EA3E4[*(signed __int16 *)(a1 + 26)] + 164);
  v3 = *(_WORD *)((char *)v2 + 823);
  if ( v3 )
  {
    if ( a2 )
    {
      v2 = (_WORD *)dword_EA3E4[v3];
      v2[23] = v2[24] - 1;
    }
    else
    {
      *(_WORD *)(dword_EA3E4[v3] + 46) = 0;
      LOBYTE(v2) = sub_6D880(a1);
    }
  }
  return (char)v2;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005F8F0) --------------------------------------------------------
void __cdecl sub_5F8F0(int a1)
{
  __int16 v1; // si
  char v2; // dl
  unsigned int v3; // esi

  v1 = *(_WORD *)(a1 + 48);
  if ( v1 )
  {
    if ( v1 == 1 )
    {
      if ( !(*(_BYTE *)(a1 + 14) & 0x10) )
      {
        *(_BYTE *)(a1 + 69) = 5;
        *(_WORD *)(a1 + 46) = 3;
        *(_WORD *)(a1 + 48) = 0;
      }
    }
    else
    {
      --*(_WORD *)(a1 + 48);
      sub_5F890(a1, 1);
      *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
    }
  }
  else
  {
    if ( sub_609E0(a1) == 2 )
    {
      *(_BYTE *)(a1 + 69) = 6;
    }
    else if ( *(_BYTE *)(a1 + 12) & 0x40 )
    {
      *(_WORD *)(a1 + 46) = 0;
      *(_BYTE *)(a1 + 69) = 5;
    }
    *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
    v2 = *(_BYTE *)(a1 + 62);
    *(_WORD *)(a1 + 148) = *(_WORD *)(a1 + 26);
    if ( !(v2 & 1) )
    {
      sub_5FD00(a1);
      sub_49EC0((_WORD *)a1, *(_WORD *)(a1 + 16));
      *(_WORD *)(a1 + 82) = -8192;
      *(_WORD *)(a1 + 88) = 0x4000;
      sub_5FF50(a1);
      if ( *(_DWORD *)(a1 + 144) < *(_DWORD *)(a1 + 140) )
      {
        v3 = *(_DWORD *)(dword_D41A4 + 38523);
        if ( v3 > dword_EA3E4[0] )
        {
          while ( *(_BYTE *)(v3 + 64) != 39
               || *(unsigned __int16 *)(v3 + 148) != *(signed __int16 *)(a1 + 26)
               || !sub_10750(a1, v3) )
          {
            v3 = *(_DWORD *)v3;
            if ( v3 <= dword_EA3E4[0] )
              return;
          }
          *(_DWORD *)(a1 + 144) += *(_DWORD *)(v3 + 144);
          sub_57F10(v3);
        }
      }
    }
  }
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005FA70) --------------------------------------------------------
void __cdecl sub_5FA70(int a1)
{
  JUMPOUT(*(_WORD *)(a1 + 46), 6, &loc_5FBBE);
  JUMPOUT(__CS__, off_5FA4C[*(unsigned __int16 *)(a1 + 46)]);
}
// 5FA4C: using guessed type int (*off_5FA4C[7])();

//----- (0005FA96) --------------------------------------------------------
#error "5FAC8: positive sp value has been found (funcsize=17)"

//----- (0005FB09) --------------------------------------------------------
#error "5FB1F: positive sp value has been found (funcsize=7)"

//----- (0005FB22) --------------------------------------------------------
#error "5FB37: positive sp value has been found (funcsize=8)"

//----- (0005FB3A) --------------------------------------------------------
#error "5FB89: positive sp value has been found (funcsize=25)"

//----- (0005FB8C) --------------------------------------------------------
#error "5FBAE: positive sp value has been found (funcsize=12)"

//----- (0005FBB1) --------------------------------------------------------
#error "5FBBF: positive sp value has been found (funcsize=5)"

//----- (0005FBD0) --------------------------------------------------------
unsigned int __cdecl sub_5FBD0(__int16 *a1)
{
  unsigned int result; // eax
  __int16 v2; // ST08_2

  result = sub_4A190((int)(a1 + 77), 10, 42);
  if ( result )
  {
    *(_BYTE *)(result + 70) = *((_BYTE *)a1 + 16);
    *(_WORD *)(result + 26) = a1[13];
    *(_WORD *)(result + 40) = (signed int)((char *)a1 - dword_D41A0 - 28302) / 168;
    v2 = a1[8];
    a1[23] = 4;
    result = sub_49EC0((_WORD *)result, v2);
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0005FC40) --------------------------------------------------------
int __cdecl sub_5FC40(int a1)
{
  int result; // eax
  int v2; // ebx

  result = sub_4A190(a1 + 154, 10, 41);
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = *(_BYTE *)(a1 + 16);
    *(_WORD *)(result + 26) = *(_WORD *)(a1 + 26);
    result = (a1 - (dword_D41A0 + 28302)) / 168;
    *(_WORD *)(v2 + 40) = result;
    *(_WORD *)(a1 + 46) = 6;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0005FCA0) --------------------------------------------------------
int __cdecl sub_5FCA0(int a1)
{
  int result; // eax

  result = sub_4A810();
  if ( result )
  {
    sub_605E0(a1);
    *(_BYTE *)(a1 + 69) = 4;
    sub_5FD00(a1);
    result = sub_5FF50(a1);
    *(_WORD *)(a1 + 46) = 0;
    *(_WORD *)(a1 + 48) = 5;
  }
  else
  {
    *(_BYTE *)(a1 + 69) = 4;
  }
  return result;
}

//----- (0005FD00) --------------------------------------------------------
int __cdecl sub_5FD00(int a1)
{
  int result; // eax
  int v2; // esi
  int v3; // esi
  int v4; // eax
  int v5; // esi
  __int16 v6; // di
  unsigned __int16 v7; // ax
  int v8; // edi
  __int16 v9; // ax
  __int16 v10; // ST0C_2
  int v11; // eax
  int v12; // edi
  signed int v13; // [esp+0h] [ebp-10h]
  int v14; // [esp+4h] [ebp-Ch]
  int v15; // [esp+8h] [ebp-8h]
  __int16 v16; // [esp+Ch] [ebp-4h]

  result = *(_DWORD *)(dword_EA3E4[*(signed __int16 *)(a1 + 26)] + 164);
  v14 = 0;
  v2 = *(_DWORD *)(a1 + 140);
  if ( *(_DWORD *)(result + 316) + *(_DWORD *)(a1 + 144) > v2 )
    v14 = *(_DWORD *)(a1 + 144) - v2;
  if ( !*(_DWORD *)(a1 + 16) )
  {
    result = *(_DWORD *)(a1 + 144);
    v14 = *(_DWORD *)(a1 + 144);
  }
  if ( v14 > 0 )
  {
    if ( v14 )
    {
      v3 = v14 / 1000;
      v16 = sub_4A810();
      if ( v16
        || (sub_49F90(), result = sub_4A810(), v3 = 8, v16 = result, *(_DWORD *)(dword_D41A0 + 4582) = -1, (_WORD)result) )
      {
        if ( v3 < 1 )
          v3 = 1;
        if ( v3 > 32 )
          v3 = 32;
        if ( v16 < 0 )
          v16 = 0;
        if ( v16 > v3 )
          v16 = v3;
        v13 = 0;
        v15 = v14 / v16;
        for ( result = v16; v16 > v13; result = v16 )
        {
          *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
          *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
          v4 = sub_4A190((int)&word_EB398, 10, 39);
          v5 = v4;
          if ( v4 )
          {
            *(_DWORD *)(v4 + 144) = v15;
            v6 = *(_WORD *)(v4 + 20);
            *(_WORD *)(v4 + 148) = *(_WORD *)(a1 + 26);
            *(_WORD *)(v4 + 20) = 9377 * v6 + 9439;
            v7 = *(_WORD *)(v4 + 20);
            *(_WORD *)(v5 + 154) = 0;
            *(_WORD *)(v5 + 156) = 0;
            *(_WORD *)(v5 + 130) = v7 % 0x30u + 16;
            v8 = *(signed __int16 *)(a1 + 80);
            v9 = sub_10C40((__int16 *)(a1 + 76));
            *(_WORD *)(v5 + 44) = (1024
                                 - (v8
                                  - v9)
                                 - (__CFSHL__((1024 - (v8 - v9)) >> 31, 3)
                                  + 8 * ((1024 - (v8 - v9)) >> 31))) >> 3;
            *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
            v10 = *(_WORD *)(a1 + 20) % 0x1400u + 3840;
            *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
            sub_57FA0(&word_EB398, *(_WORD *)(a1 + 20) & 0x7FF, 0, v10);
            sub_57CF0(v5, (int)&word_EB398);
            v11 = *(_DWORD *)(v5 + 144);
            v12 = v14 - v11;
            v14 = v12;
            *(_DWORD *)(a1 + 144) -= v11;
            if ( v12 < v15 )
              v15 = v12;
          }
          ++v13;
        }
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (0005FF50) --------------------------------------------------------
int __cdecl sub_5FF50(int a1)
{
  int v1; // edi
  int v2; // eax
  unsigned int v3; // esi
  unsigned int v4; // eax
  int v5; // eax
  int v6; // edx
  __int64 v7; // rtt
  int v8; // eax
  int v9; // esi
  unsigned int v10; // esi
  __int16 v11; // si
  int result; // eax
  int v13; // edi
  _BYTE *v14; // esi
  __int16 v15; // ax
  int v16; // [esp+4h] [ebp-1Ch]
  int v17; // [esp+8h] [ebp-18h]
  int v18; // [esp+Ch] [ebp-14h]
  __int16 v19; // [esp+14h] [ebp-Ch]
  int v20; // [esp+18h] [ebp-8h]
  __int16 v21; // [esp+1Ch] [ebp-4h]

  v18 = dword_EA3E4[*(signed __int16 *)(a1 + 26)];
  v1 = 0;
  sub_60400(*(_WORD *)(a1 + 16), &v21, &v19);
  if ( v21 > 0 )
  {
    do
    {
      while ( 1 )
      {
        *(_DWORD *)(*(_DWORD *)(v18 + 164) + 302) = 0;
        v2 = *(_DWORD *)(v18 + 164);
        v16 = 2 * (signed __int16)v1;
        v3 = dword_EA3E4[*(unsigned __int16 *)(v16 + v2 + 60)];
        if ( v3 <= dword_EA3E4[0] )
        {
          v8 = sub_4A190(a1 + 76, 3, 3);
          v9 = v8;
          if ( v8 )
          {
            *(_WORD *)(v8 + 26) = *(_WORD *)(a1 + 26);
            *(_WORD *)(v8 + 90) += sub_616D0(*(signed __int16 *)(*(_DWORD *)(v18 + 164) + 56));
            *(_WORD *)(v9 + 148) = *(_WORD *)(a1 + 26);
            *(_WORD *)(v16 + *(_DWORD *)(v18 + 164) + 60) = (v9 - (dword_D41A0 + 28302)) / 168;
            *(_BYTE *)(v9 + 69) = 9;
          }
          goto LABEL_17;
        }
        if ( *(_DWORD *)(v3 + 8) >= 0 )
          break;
        sub_36BA0(v3, 0);
        sub_57F10(v3);
        *(_WORD *)(v16 + *(_DWORD *)(v18 + 164) + 60) = 0;
LABEL_17:
        if ( (signed __int16)++v1 >= v21 )
          goto LABEL_22;
      }
      if ( *(_DWORD *)(v2 + 316) + *(_DWORD *)(a1 + 144) >= *(_DWORD *)(a1 + 140) )
      {
        v6 = a1 - (dword_D41A0 + 28302);
        v5 = a1 - (dword_D41A0 + 28302);
      }
      else
      {
        if ( *(unsigned __int8 *)(a1 + 62) % v21 )
          goto LABEL_13;
        if ( *(_BYTE *)(v3 + 69) != 9 )
          goto LABEL_13;
        *(_WORD *)(v3 + 150) = (a1 - (dword_D41A0 + 28302)) / 168;
        if ( *(_DWORD *)(v3 + 140) <= *(_DWORD *)(v3 + 144) )
          goto LABEL_13;
        *(_WORD *)(dword_EA3E4[0] + 150) = 0;
        v4 = sub_5F810(
               v3,
               dword_EA3E4[*(unsigned __int16 *)(dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(v18 + 164)
                                                                                 + 2 * (((signed __int16)v1 + 1) % 3)
                                                                                 + 60)]
                                               + 150)],
               dword_EA3E4[*(unsigned __int16 *)(dword_EA3E4[*(unsigned __int16 *)(2 * (((signed __int16)v1 + 2) % 3)
                                                                                 + *(_DWORD *)(v18 + 164)
                                                                                 + 60)]
                                               + 150)]);
        if ( !v4 )
          goto LABEL_13;
        v5 = v4 - (dword_D41A0 + 28302);
        v6 = v5;
      }
      LODWORD(v7) = v5;
      HIDWORD(v7) = v6 >> 31;
      *(_WORD *)(v3 + 150) = v7 / 168;
LABEL_13:
      *(_DWORD *)(*(_DWORD *)(v18 + 164) + 302) += *(_DWORD *)(v3 + 144);
      *(_DWORD *)(*(_DWORD *)(v18 + 164) + 298) += *(_DWORD *)(v3 + 140);
      ++v1;
    }
    while ( (signed __int16)v1 < v21 );
  }
LABEL_22:
  while ( (signed __int16)v1 < 3 )
  {
    v10 = dword_EA3E4[*(unsigned __int16 *)(2 * (signed __int16)v1 + *(_DWORD *)(v18 + 164) + 60)];
    if ( v10 > dword_EA3E4[0] )
    {
      sub_36BA0(v10, 0);
      sub_57F10(v10);
      *(_WORD *)(2 * (signed __int16)v1 + *(_DWORD *)(v18 + 164) + 60) = 0;
    }
    LOWORD(v1) = v1 + 1;
  }
  v11 = *(_WORD *)(a1 + 44);
  if ( v11 > 0 )
    *(_WORD *)(a1 + 44) = v11 - 1;
  v20 = 0;
  result = 0;
  if ( v19 > 0 )
  {
    do
    {
      v13 = 2 * (signed __int16)v20;
      v14 = (_BYTE *)dword_EA3E4[*(unsigned __int16 *)(v13 + *(_DWORD *)(v18 + 164) + 92)];
      if ( (unsigned int)v14 <= dword_EA3E4[0] )
      {
        if ( !*(_WORD *)(a1 + 44) )
        {
          v17 = sub_4A190(a1 + 76, 5, 15);
          if ( v17 )
          {
            *(_WORD *)(a1 + 44) = 16;
            v15 = *(_WORD *)(a1 + 26);
            *(_WORD *)(v17 + 26) = v15;
            *(_WORD *)(v17 + 148) = v15;
            *(_WORD *)(*(_DWORD *)(v18 + 164) + v13 + 92) = (v17 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v17 + 28) = 512;
            *(_WORD *)(v17 + 32) = *(_WORD *)(v17 + 28);
            *(_DWORD *)&word_EB398 = *(_DWORD *)(v17 + 76);
            *(&word_EB398 + 2) = *(_WORD *)(v17 + 80);
            word_EB398 += 128;
            word_EB39A += 640;
            word_EB39C = sub_10C40(&word_EB398);
            sub_57CF0(v17, (int)&word_EB398);
          }
        }
      }
      else if ( v14[63] != 5 || v14[64] != 15 || v14[69] == 125 )
      {
        *(_WORD *)(*(_DWORD *)(v18 + 164) + 2 * (signed __int16)v20 + 92) = 0;
        *(_WORD *)(a1 + 44) = 16;
      }
      result = ++v20;
    }
    while ( (signed __int16)v20 < v19 );
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00060400) --------------------------------------------------------
_WORD *__cdecl sub_60400(__int16 a1, _WORD *a2, _WORD *a3)
{
  _WORD *result; // eax

  result = a3;
  switch ( a1 )
  {
    case 1:
    case 2:
      *a2 = 1;
      *a3 = 0;
      break;
    case 3:
      *a2 = 1;
      *a3 = 4;
      break;
    case 4:
      *a2 = 2;
      *a3 = 6;
      break;
    case 5:
      *a2 = 2;
      *a3 = 14;
      break;
    case 6:
      *a2 = 3;
      *a3 = 18;
      break;
    case 7:
      *a2 = 3;
      *a3 = 34;
      break;
    default:
      *a2 = 0;
      *a3 = 0;
      break;
  }
  return result;
}

//----- (00060480) --------------------------------------------------------
char __cdecl sub_60480(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // edx
  __int16 v4; // ST08_2
  __int16 v5; // ST08_2
  int v6; // edi
  char v7; // dl

  v1 = sub_50370(a1 + 154);
  v2 = v1;
  if ( v1 )
  {
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
    v3 = *(_DWORD *)(a1 + 16) + 1;
    *(_BYTE *)(a1 + 12) &= 0xBFu;
    *(_DWORD *)(a1 + 16) = v3;
    v4 = *(_WORD *)(a1 + 16);
    *(_BYTE *)(a1 + 69) = 5;
    *(_WORD *)(a1 + 46) = 4;
    sub_49EC0((_WORD *)a1, v4);
    v5 = *(_WORD *)(a1 + 16);
    *(_WORD *)(a1 + 82) = -8192;
    *(_WORD *)(a1 + 88) = 0x4000;
    sub_49EC0((_WORD *)v2, v5);
    v6 = dword_EA3E4[*(signed __int16 *)(a1 + 26)];
    *(_WORD *)(*(_DWORD *)(v6 + 164) + 58) = (a1 - (dword_D41A0 + 28302)) / 168;
    *(_WORD *)(*(_DWORD *)(v6 + 164) + 450) = *(_WORD *)(a1 + 16);
    *(_BYTE *)(*(_DWORD *)(v6 + 164) + 446) = 0;
    sub_60810(a1);
    sub_613D0(a1);
    sub_6D8B0((v6 - (dword_D41A0 + 28302)) / 168, 2u, 1);
    *(_WORD *)(v2 + 40) = (a1 - (dword_D41A0 + 28302)) / 168;
    *(_WORD *)(v2 + 26) = *(_WORD *)(a1 + 26);
    v7 = *(_BYTE *)(v2 + 14);
    LOBYTE(v1) = *(_BYTE *)(a1 + 16);
    *(_BYTE *)(v2 + 59) = 0;
    *(_BYTE *)(v2 + 70) = v1;
    *(_BYTE *)(v2 + 14) = v7 | 1;
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000605E0) --------------------------------------------------------
char __cdecl sub_605E0(int a1)
{
  int v1; // esi
  __int16 v2; // ST00_2
  int v3; // edi
  int v4; // edx
  int v5; // eax
  int v6; // edx
  char result; // al
  int v8; // esi
  __int16 v9; // dx

  if ( *(_DWORD *)(a1 + 16) > 0 )
  {
    v1 = 10 * *(_DWORD *)(a1 + 140) / 100;
    *(_DWORD *)(a1 + 140) -= v1;
    sub_5FD00(a1);
    v2 = (a1 - (dword_D41A0 + 28302)) / 168;
    *(_DWORD *)(a1 + 140) += v1;
    sub_6E450(v2, -1, 30);
    v3 = dword_EA3E4[0] + 76;
    *(_DWORD *)v3 = *(_DWORD *)(a1 + 154);
    *(_WORD *)(v3 + 4) = *(_WORD *)(a1 + 158);
    v4 = dword_EA3E4[0];
    *(_BYTE *)(dword_EA3E4[0] + 70) = *(_BYTE *)(a1 + 16);
    *(_WORD *)(v4 + 26) = *(_WORD *)(a1 + 26);
    v5 = (a1 - (dword_D41A0 + 28302)) / 168;
    v6 = dword_EA3E4[0];
    *(_BYTE *)(dword_EA3E4[0] + 64) = 0;
    *(_DWORD *)(v6 + 16) = 0;
    *(_WORD *)(v6 + 40) = v5;
    sub_385C0(v6);
    --*(_DWORD *)(a1 + 16);
    sub_49EC0((_WORD *)a1, *(_WORD *)(a1 + 16));
    *(_WORD *)(a1 + 82) = -8192;
    *(_WORD *)(a1 + 88) = 0x4000;
    sub_60810(a1);
    sub_613D0(a1);
    result = sub_5F890(a1, 1);
  }
  if ( !*(_DWORD *)(a1 + 16) )
  {
    v8 = dword_EA3E4[*(signed __int16 *)(a1 + 26)];
    if ( *(_BYTE *)(v8 + 64) == 1 )
    {
      if ( *(_BYTE *)(dword_D41A0 + 196306) & 4 )
      {
        v9 = *(_WORD *)(*(_DWORD *)(v8 + 164) + 823);
        if ( v9 )
        {
          sub_57F10(dword_EA3E4[v9]);
          *(_WORD *)(*(_DWORD *)(v8 + 164) + 823) = 0;
        }
      }
    }
    else
    {
      sub_5F890(a1, *(_DWORD *)(a1 + 16));
    }
    *(_WORD *)(*(_DWORD *)(v8 + 164) + 58) = 0;
    result = sub_57F10(a1);
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E0: using guessed type int dword_EA3E0[];
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00060780) --------------------------------------------------------
int __cdecl sub_60780(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // edx
  int v5; // ecx
  char v6; // ST04_1
  __int16 v7; // di
  int result; // eax

  if ( a3 )
  {
    v4 = a1[2];
    v5 = 0;
    a1[1] = a3;
    if ( v4 < 0 )
    {
      v5 = -v4;
      if ( -v4 > a3 / 2 )
        v5 = a3 / 2;
    }
    a1[2] = a1[1] - v5;
  }
  if ( a2 )
  {
    v6 = *(_BYTE *)(a2 + 70);
    v7 = *(_WORD *)(a2 + 46);
    *(_WORD *)(a2 + 46) = 0;
    sub_6D5E0(a2, v6);
    *(_WORD *)(a2 + 46) = v7;
  }
  result = a4;
  a1[35] = a4;
  return result;
}

//----- (00060810) --------------------------------------------------------
unsigned int __cdecl sub_60810(int a1)
{
  int v1; // eax
  char v2; // dl
  __int16 v3; // cx
  int v4; // edx
  int v5; // ecx
  unsigned int result; // eax

  v1 = dword_EA3E4[*(signed __int16 *)(a1 + 26)];
  v2 = *(_BYTE *)(v1 + 69);
  if ( !v2 || v2 == 1 )
  {
    v3 = *(_WORD *)(*(_DWORD *)(v1 + 164) + 823);
    if ( v3 )
      v4 = dword_EA3E4[v3];
  }
  v5 = *(signed __int16 *)(*(_DWORD *)(v1 + 164) + 586)
     * ((*(char *)(*(_DWORD *)(a1 + 16) + *(_DWORD *)(v1 + 164) + 590) << 8) + 256);
  result = *(_DWORD *)(a1 + 16);
  if ( result <= 7 )
    JUMPOUT(__CS__, *(&off_607E8 + result));
  return result;
}
// 607E8: using guessed type void *off_607E8;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000609E0) --------------------------------------------------------
signed int __cdecl sub_609E0(int a1)
{
  signed int v1; // esi
  int v3; // ecx
  __int16 v4; // ax
  int v5; // eax

  v1 = 0;
  if ( *(_DWORD *)(a1 + 8) < 0 )
    return 2;
  if ( *(_WORD *)(a1 + 98) )
  {
    v3 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 94);
    *(_DWORD *)(a1 + 8) = v3;
    if ( v3 < 0 )
    {
      v4 = *(_WORD *)(a1 + 98);
      *(_WORD *)(a1 + 98) = 0;
      *(_WORD *)(a1 + 36) = v4;
      return 2;
    }
    _wcpp_1_unwind_leave__100(a1, *(_DWORD *)(a1 + 94));
    *(_WORD *)(a1 + 98) = 0;
    v5 = *(signed __int16 *)(a1 + 26);
    *(_DWORD *)(a1 + 94) = 0;
    v1 = 1;
    *(_BYTE *)(*(_DWORD *)(dword_EA3E4[v5] + 164) + 405) = 4;
  }
  if ( *(unsigned __int16 *)(a1 + 128) == *(signed __int16 *)(a1 + 26) )
  {
    if ( *(_DWORD *)(a1 + 16) < 7 )
      *(_BYTE *)(a1 + 12) |= 0x40u;
    *(_WORD *)(a1 + 128) = 0;
  }
  return v1;
}
// 5FCF0: using guessed type int __cdecl _wcpp_1_unwind_leave__100(_DWORD, _DWORD);
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00060AB0) --------------------------------------------------------
signed int __cdecl sub_60AB0(int a1)
{
  unsigned int v1; // eax
  _WORD *v2; // esi
  char v3; // dl
  signed int v4; // esi
  signed int v5; // edi
  signed int v6; // eax
  unsigned int v7; // edi
  int v8; // esi
  int v9; // ecx
  signed __int16 *v10; // eax
  __int16 v11; // ST10_2
  int v12; // ST0C_4
  int v13; // ST08_4
  __int16 v14; // ax
  int v16; // [esp+0h] [ebp-4h]

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v16 = v1;
  if ( v1 > dword_EA3E4[0] )
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v2 = (_WORD *)(v1 + 76);
    *(_WORD *)(a1 + 28) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
    v3 = *(_BYTE *)(v16 + 63);
    if ( v3 == 10 )
    {
      if ( *(unsigned __int16 *)(v16 + 148) != *(signed __int16 *)(a1 + 26) )
        goto LABEL_20;
      if ( byte_D41B6 )
        v4 = 2048;
      else
        v4 = 1024;
      v5 = sub_58490(&word_EB398, (_WORD *)(v16 + 76));
      if ( v5 > v4 )
      {
        *(_BYTE *)(v16 + 12) &= 0xBFu;
      }
      else
      {
        *(_BYTE *)(v16 + 12) |= 0x40u;
        *(_WORD *)(v16 + 150) = (a1 - (dword_D41A0 + 28302)) / 168;
        if ( sub_106C0(v16, a1) )
        {
          *(_DWORD *)(a1 + 144) += *(_DWORD *)(v16 + 144);
          *(_WORD *)(a1 + 148) = *(_WORD *)(v16 + 148);
          *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
          *(_WORD *)(a1 + 150) = 0;
          sub_57F10(v16);
        }
      }
      v6 = *(signed __int16 *)(a1 + 130);
      if ( v5 <= v6 )
      {
        word_EB398 = *(_WORD *)(v16 + 76);
        word_EB39A = *(_WORD *)(v16 + 78);
        goto LABEL_20;
      }
    }
    else
    {
      if ( v3 == 3 )
      {
        v7 = *(signed __int16 *)(a1 + 130) * *(_DWORD *)(v16 + 16);
        if ( sub_58490(&word_EB398, v2) <= v7 )
        {
          v8 = *(signed __int16 *)(*(_DWORD *)(a1 + 160) + 12);
          if ( word_EB39C <= v8 + (signed __int16)sub_10C40(&word_EB398) && *(_DWORD *)(v16 + 16) > 0 )
          {
            word_EB398 = *(_WORD *)(v16 + 76);
            v9 = *(_DWORD *)(v16 + 144);
            word_EB39A = *(_WORD *)(v16 + 78);
            *(_DWORD *)(v16 + 144) = *(_DWORD *)(a1 + 144) + v9;
            *(_DWORD *)(a1 + 144) = 0;
            *(_WORD *)(a1 + 148) = *(_WORD *)(a1 + 26);
            *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
          }
          goto LABEL_20;
        }
      }
      LOWORD(v6) = *(_WORD *)(a1 + 130);
    }
    sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), v6);
LABEL_20:
    if ( byte_D41B6 )
    {
      sub_60D50(&word_EB398, a1);
    }
    else
    {
      v10 = *(signed __int16 **)(a1 + 160);
      v11 = v10[7];
      v12 = v10[5];
      v13 = v10[6];
      v14 = sub_10C40(&word_EB398);
      sub_580E0((int)&word_EB398, v14, v13, v12, v11);
      sub_57CF0(a1, (int)&word_EB398);
    }
  }
  return sub_60EA0(a1);
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00060D50) --------------------------------------------------------
signed int __cdecl sub_60D50(__int16 *a1, int a2)
{
  int v2; // edx
  char v3; // ch
  signed __int16 *v4; // edx
  __int16 v5; // ST10_2
  int v6; // ST0C_4
  int v7; // ST08_4
  __int16 v8; // ax
  int v9; // edi
  int v10; // edx
  char v12; // [esp+0h] [ebp-4h]

  v12 = 0;
  v2 = *a1 >> 8;
  BYTE1(v2) = (unsigned __int16)a1[1] >> 8;
  if ( *(_BYTE *)(a2 + 12) & 1 )
  {
    if ( !(byte_13B4E0[(unsigned __int16)v2] & 8) && !sub_11E70(a2, a1) )
    {
      *(_BYTE *)(a2 + 12) &= 0xFEu;
      v12 = 1;
    }
    *(_WORD *)(a2 + 130) = 96;
  }
  else
  {
    if ( byte_13B4E0[(unsigned __int16)v2] & 8 || sub_11E70(a2, a1) )
    {
      v12 = 1;
      *(_BYTE *)(a2 + 12) |= 1u;
    }
    *(_WORD *)(a2 + 130) = 48;
  }
  v3 = *(_BYTE *)(a2 + 70);
  if ( v3 )
    *(_BYTE *)(a2 + 70) = v3 - 1;
  if ( v12 && !*(_BYTE *)(a2 + 70) )
  {
    sub_6E450((a2 - (dword_D41A0 + 28302)) / 168, -1, 22);
    *(_BYTE *)(a2 + 70) = 32;
  }
  v4 = *(signed __int16 **)(a2 + 160);
  v5 = v4[7];
  v6 = v4[5];
  v7 = v4[6];
  v8 = sub_10C40(a1);
  sub_580E0((int)a1, v8, v7, v6, v5);
  if ( !(*(_BYTE *)(a2 + 12) & 1) )
  {
    v9 = *(signed __int16 *)(a2 + 88);
    v10 = (signed __int16)sub_10C60(a1) - v9;
    if ( a1[2] > v10 )
      a1[2] = v10;
  }
  return sub_57CF0(a2, (int)a1);
}
// D41A0: using guessed type int dword_D41A0;

//----- (00060EA0) --------------------------------------------------------
signed int __cdecl sub_60EA0(int a1)
{
  signed int v1; // edx
  int v3; // edx

  v1 = 0;
  if ( *(_DWORD *)(a1 + 8) < 0 )
    return 2;
  if ( *(_WORD *)(a1 + 98) )
  {
    v3 = *(_DWORD *)(a1 + 164);
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    *(_BYTE *)(v3 + 407) = 4;
    if ( *(_DWORD *)(a1 + 8) < 0 )
    {
      *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 98);
      return 2;
    }
    v1 = 1;
    *(_WORD *)(a1 + 98) = 0;
  }
  return v1;
}

//----- (00060F00) --------------------------------------------------------
char sub_60F00()
{
  unsigned __int16 v0; // bx
  int v1; // eax
  int v2; // edx
  _DWORD *v3; // eax
  unsigned int v4; // ebx

  v0 = 0;
  v1 = dword_D41A0 + 11230;
  while ( v0 < *(_WORD *)(dword_D41A0 + 14) )
  {
    v2 = dword_EA3E4[*(unsigned __int16 *)(v1 + 10)];
    *(_DWORD *)(v2 + 140) = *(_DWORD *)(*(_DWORD *)(v2 + 164) + 336);
    v1 += 2124;
    ++v0;
    *(_DWORD *)(*(_DWORD *)(v2 + 164) + 316) = 0;
  }
  v3 = (_DWORD *)dword_D41A4;
  v4 = dword_EA3E8;
  *(_DWORD *)(dword_D41A4 + 246) = 1;
  *(_DWORD *)((char *)v3 + 250) = 0;
  if ( v4 < dword_EB384 )
  {
    while ( 1 )
    {
      LOBYTE(v3) = *(_BYTE *)(v4 + 63);
      if ( (unsigned __int8)v3 < 5u )
        break;
      if ( (unsigned __int8)v3 <= 5u )
        goto LABEL_23;
      if ( (_BYTE)v3 != 10 )
        goto LABEL_24;
      LOBYTE(v3) = *(_BYTE *)(v4 + 64);
      if ( (unsigned __int8)v3 < 0x2Du )
      {
        if ( (_BYTE)v3 == 39 )
          goto LABEL_23;
      }
      else
      {
        if ( (unsigned __int8)v3 <= 0x2Du )
        {
          LOWORD(v3) = sub_61000(v4);
          if ( v3 && v3[41] )
          {
            v3 = (_DWORD *)v3[41];
            v3[79] += *(_DWORD *)(v4 + 144);
          }
          goto LABEL_24;
        }
        if ( (_BYTE)v3 == 58 )
          goto LABEL_23;
      }
LABEL_24:
      v4 += 168;
      if ( v4 >= dword_EB384 )
        return (char)v3;
    }
    if ( (_BYTE)v3 != 3 )
      goto LABEL_24;
    LOBYTE(v3) = *(_BYTE *)(v4 + 64);
    if ( (unsigned __int8)v3 < 2u || (unsigned __int8)v3 > 2u && (_BYTE)v3 != 3 )
      goto LABEL_24;
LABEL_23:
    LOBYTE(v3) = sub_61000(v4);
    goto LABEL_24;
  }
  return (char)v3;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EA3E8: using guessed type int dword_EA3E8;
// EB384: using guessed type int dword_EB384;

//----- (00061000) --------------------------------------------------------
__int16 __cdecl sub_61000(int a1)
{
  int v1; // eax

  v1 = 0;
  if ( *(_WORD *)(a1 + 148) )
  {
    LOWORD(v1) = *(_WORD *)(a1 + 148);
    v1 = dword_EA3E4[v1];
    *(_DWORD *)(v1 + 140) += *(_DWORD *)(a1 + 144);
  }
  *(_DWORD *)(dword_D41A4 + 246) += *(_DWORD *)(a1 + 144);
  return v1;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00061050) --------------------------------------------------------
unsigned int __cdecl sub_61050(unsigned int a1)
{
  unsigned __int16 v1; // ax
  unsigned int v2; // edx
  int v3; // eax
  unsigned __int8 v4; // dl
  int v5; // eax
  unsigned int v6; // ebx
  unsigned int v7; // eax
  int v8; // ecx
  __int64 v9; // rtt
  int v10; // edx
  int v11; // edx
  int v12; // ecx
  __int16 v13; // ax
  __int16 v14; // si
  __int16 v15; // ax
  int v16; // eax
  int v17; // ebx
  __int16 v18; // ax
  __int16 v19; // si
  __int16 v20; // ST0C_2
  unsigned __int16 v21; // ax
  int v22; // esi
  int v23; // esi
  int v24; // ebx
  unsigned int result; // eax
  int v26; // [esp+0h] [ebp-28h]
  __int16 v27; // [esp+4h] [ebp-24h]
  int *v28; // [esp+8h] [ebp-20h]
  unsigned int v29; // [esp+Ch] [ebp-1Ch]
  int v30; // [esp+10h] [ebp-18h]
  int v31; // [esp+14h] [ebp-14h]
  _BYTE *v32; // [esp+18h] [ebp-10h]
  int v33; // [esp+1Ch] [ebp-Ch]
  _DWORD *v34; // [esp+20h] [ebp-8h]
  char v35; // [esp+24h] [ebp-4h]

  v33 = 0;
  v35 = 0;
  v1 = *(_WORD *)(a1 + 116);
  v2 = dword_EA3E4[v1];
  v34 = (_DWORD *)v2;
  if ( v2 < dword_EA3E4[0] )
    goto LABEL_35;
  if ( *(_BYTE *)(v2 + 63) == 3 )
  {
    sub_6D8B0(v1, 0xDu, 1);
    v3 = 26 * *(_DWORD *)(a1 + 112);
    v28 = (int *)&unk_DAC44;
    v32 = &byte_DAC2A[v3];
    v4 = byte_DAC2A[v3 + 24];
    if ( v4 )
    {
      if ( v4 > 2u )
        goto LABEL_23;
      v6 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)];
      v7 = dword_EA3E4[*(unsigned __int16 *)(v34[41] + 58)];
      v31 = dword_EA3E4[*(unsigned __int16 *)(v34[41] + 58)];
      if ( v6 <= dword_EA3E4[0] || v7 <= dword_EA3E4[0] || (v8 = *(_DWORD *)(v6 + 144), v8 <= 0) )
      {
        v35 = 1;
      }
      else
      {
        v9 = v8 * *(_DWORD *)v32;
        v10 = v31;
        *(_DWORD *)(v6 + 144) = v8 - v8 * *(_DWORD *)v32 / 100;
        v11 = *(signed __int16 *)(v10 + 84) * *(signed __int16 *)(v10 + 84);
        v33 = v9 / 100;
        v29 = sub_7277A(v11 + *(signed __int16 *)(v31 + 86) * *(signed __int16 *)(v31 + 86));
        while ( v33 > 0 )
        {
          if ( v33 <= 500 )
            v30 = v33;
          else
            v30 = 500;
          v12 = v33 - v30;
          v26 = *(_DWORD *)(v31 + 76);
          v27 = *(_WORD *)(v31 + 80);
          v13 = 9377 * *(_WORD *)(a1 + 20) + 9439;
          *(_WORD *)(a1 + 20) = v13;
          v14 = v13 & 0x7FF;
          v33 = v12;
          sub_57FA0(&v26, v13 & 0x7FF, 0, v29);
          v15 = sub_10C40((__int16 *)&v26);
          HIBYTE(v15) += 4;
          v27 = v15;
          v16 = sub_4A190((int)&v26, 10, 39);
          v17 = v16;
          if ( v16 )
          {
            *(_WORD *)(v16 + 20) = 9377 * *(_WORD *)(v16 + 20) + 9439;
            v18 = (v14 + *(_WORD *)(v16 + 20) % 0x71u - 56) & 0x7FF;
            v19 = *(_WORD *)(v17 + 20);
            *(_WORD *)(v17 + 28) = v18;
            *(_WORD *)(v17 + 20) = 9377 * v19 + 9439;
            *(_WORD *)(v17 + 130) = *(_WORD *)(v17 + 20) % 0x30u + 16;
            v20 = *(_WORD *)(v17 + 130);
            v21 = *(_WORD *)(v17 + 28);
            *(_WORD *)(v17 + 154) = 0;
            *(_WORD *)(v17 + 156) = 0;
            *(_WORD *)(v17 + 44) = 128;
            sub_57FA0((_WORD *)(v17 + 154), v21, 0, v20);
            *(_DWORD *)(v17 + 144) = v30;
            if ( v32[24] == 2 )
              *(_WORD *)(v17 + 148) = (signed int)((char *)v34 - dword_D41A0 - 28302) / 168;
            else
              *(_WORD *)(v17 + 148) = 0;
          }
        }
      }
      if ( !v35 )
        goto LABEL_23;
      v5 = *v28;
    }
    else
    {
      v5 = *(_DWORD *)v32;
      v35 = 1;
    }
    v33 = v5;
  }
LABEL_23:
  if ( v35 )
  {
    v22 = v33;
    if ( v33 )
    {
      v34[36] += v33;
      *(_DWORD *)(a1 + 144) -= v22;
    }
  }
  if ( v34[36] < 0 )
    v34[36] = 0;
  v23 = v34[35];
  if ( v34[36] > v23 )
    v34[36] = v23;
  if ( *(_DWORD *)(a1 + 144) < 0 )
    *(_DWORD *)(a1 + 144) = 0;
  v24 = *(_DWORD *)(a1 + 140);
  if ( *(_DWORD *)(a1 + 144) > v24 )
    *(_DWORD *)(a1 + 144) = v24;
  *(_BYTE *)(*(_DWORD *)(a1 + 164) + 406) = 4;
  *(_DWORD *)(*(_DWORD *)(a1 + 164) + 397) = 16;
  *(_WORD *)(*(_DWORD *)(a1 + 164) + 588) = 64;
LABEL_35:
  sub_5EF70(a1);
  result = a1;
  *(_WORD *)(a1 + 116) = 0;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000613D0) --------------------------------------------------------
__int16 __cdecl sub_613D0(int a1)
{
  int i; // eax
  int v2; // ebx
  __int16 v3; // dx
  signed int v4; // esi
  int v5; // edx
  int v6; // ebx
  int v7; // ebx
  signed int v8; // edx
  int v9; // ebx
  int v10; // ST14_4
  __int16 v11; // ax
  char *v13; // [esp+0h] [ebp-24h]
  int v14; // [esp+4h] [ebp-20h]
  int v15; // [esp+Ch] [ebp-18h]
  char v16; // [esp+10h] [ebp-14h]
  int v17; // [esp+14h] [ebp-10h]
  int v18; // [esp+18h] [ebp-Ch]
  unsigned __int8 v19; // [esp+1Ch] [ebp-8h]
  unsigned __int8 v20; // [esp+20h] [ebp-4h]

  for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v2 + 52) )
  {
    v2 = dword_EA3E4[i];
    if ( v2 == dword_EA3E4[0] )
      break;
    sub_57F20(dword_EA3E4[i]);
  }
  v3 = *(_WORD *)(a1 + 26);
  *(_WORD *)(a1 + 52) = 0;
  if ( v3 && *(_DWORD *)(a1 + 16) )
  {
    LOWORD(i) = v3;
    v4 = *(_DWORD *)(a1 + 16);
    v5 = dword_EA3E4[v3];
    while ( v4 > 0 )
    {
      LOWORD(i) = *(char *)(v4 + *(_DWORD *)(v5 + 164) + 599);
      v16 = *(_BYTE *)(v4 + *(_DWORD *)(v5 + 164) + 599);
      if ( *(_BYTE *)(v4 + *(_DWORD *)(v5 + 164) + 599) )
        break;
      --v4;
    }
    if ( v4 )
    {
      v6 = 6 * v4;
      i = word_180660 == 1 ? (signed int)*(unsigned __int8 *)(v6 + dword_EA3BC + 4) >> 1 : *(unsigned __int8 *)(v6 + dword_EA3BC + 4);
      v7 = 6 * v4;
      v8 = word_180660 == 1 ? (signed int)*(unsigned __int8 *)(v7 + dword_EA3BC + 5) >> 1 : *(unsigned __int8 *)(v7 + dword_EA3BC + 5);
      v20 = ((unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8) - (i >> 1);
      v19 = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - (v8 >> 1);
      v15 = 0;
      v14 = (unsigned __int8)byte_DB038[2 * v4];
      v18 = a1;
      v13 = (char *)&unk_DB04A + 2 * (unsigned __int8)byte_DB039[2 * v4];
      LOWORD(i) = 0;
      if ( v14 > 0 )
      {
        do
        {
          word_EB398 = (v20 + *v13) << 8;
          word_EB39A = (v19 + v13[1]) << 8;
          i = sub_4A190((int)&word_EB398, 10, 79);
          v9 = i;
          v17 = i;
          if ( !i )
            break;
          v10 = dword_D41A0 + 28302;
          *(_WORD *)(i + 50) = (v18 - (dword_D41A0 + 28302)) / 168;
          *(_WORD *)(v18 + 52) = (i - v10) / 168;
          *(_WORD *)(i + 52) = 0;
          *(_WORD *)(i + 26) = *(_WORD *)(a1 + 26);
          *(_BYTE *)(i + 67) = v16;
          *(_WORD *)(i + 74) = v4;
          v11 = sub_10C40((__int16 *)(i + 76));
          *(_WORD *)(v9 + 80) = v11;
          *(_WORD *)(v9 + 80) = v4 <= 1 ? v11 + 384 : v11 + 224;
          v18 = v17;
          ++v15;
          v13 += 2;
          LOWORD(i) = v15;
        }
        while ( v15 < v14 );
      }
    }
  }
  return i;
}
// D41A0: using guessed type int dword_D41A0;
// EA3BC: using guessed type int dword_EA3BC;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// 180660: using guessed type __int16 word_180660;

//----- (00061620) --------------------------------------------------------
char __cdecl sub_61620(int a1, int a2)
{
  void (__noreturn *v2)(); // edi
  unsigned int v3; // esi
  unsigned int i; // ebx
  signed int v5; // eax
  char v7; // [esp+0h] [ebp-4h]

  v2 = sub_10000;
  v3 = 0;
  v7 = 0;
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( !*(_BYTE *)(i + 64) && i != a1 )
    {
      v5 = sub_61810(a1, i);
      if ( v5 )
      {
        if ( v5 < (signed int)v2 )
        {
          v2 = (void (__noreturn *)())v5;
          v3 = i;
        }
      }
    }
  }
  if ( v3 == a2 )
    v7 = 1;
  return v7;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000616D0) --------------------------------------------------------
signed int __cdecl sub_616D0(signed int a1)
{
  signed int result; // eax

  result = 0;
  if ( a1 >= 0 && a1 <= 7 )
  {
    if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
    {
      switch ( *(_BYTE *)(2124 * a1 + dword_D41A0 + 12676) )
      {
        case 0:
LABEL_5:
          result = 0;
          break;
        case 1:
LABEL_7:
          result = 4;
          break;
        case 2:
LABEL_6:
          result = 1;
          break;
        case 3:
LABEL_9:
          result = 2;
          break;
        case 4:
LABEL_10:
          result = 5;
          break;
        case 5:
        case 7:
LABEL_13:
          result = 7;
          break;
        case 6:
LABEL_8:
          result = 3;
          break;
        default:
          return result;
      }
    }
    else
    {
      switch ( a1 )
      {
        case 0:
          goto LABEL_5;
        case 1:
          goto LABEL_6;
        case 2:
          goto LABEL_7;
        case 3:
          goto LABEL_8;
        case 4:
          goto LABEL_9;
        case 5:
          goto LABEL_10;
        case 6:
          goto LABEL_13;
        case 7:
          result = 6;
          break;
        default:
          return result;
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00061790) --------------------------------------------------------
signed int __cdecl sub_61790(signed int a1)
{
  signed int result; // eax

  result = a1;
  if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
  {
    switch ( *(_BYTE *)(2124 * a1 + dword_D41A0 + 12676) )
    {
      case 0:
        result = 0;
        break;
      case 1:
        result = 2;
        break;
      case 2:
        result = 1;
        break;
      case 3:
        result = 4;
        break;
      case 4:
        result = 5;
        break;
      case 5:
        result = 6;
        break;
      case 6:
        result = 3;
        break;
      case 7:
        result = 7;
        break;
      default:
        return result;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00061810) --------------------------------------------------------
signed int __cdecl sub_61810(int a1, int a2)
{
  signed int v2; // ebx
  signed int v3; // esi
  __int16 v4; // ax

  v2 = 0;
  v3 = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
  if ( v3 < 5376 )
  {
    v4 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
    if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v4) < 0x100u )
      v2 = v3;
  }
  return v2;
}

//----- (00061880) --------------------------------------------------------
char *__cdecl sub_61880(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8)
{
  char *result; // eax

  if ( *(_BYTE *)(dword_D41A0 + 8592) == 1 )
    result = sub_627F0(a1, a2, a3, a4, a5, a6, a7, a8);
  else
    result = sub_61A00(a1, a2, a3, a4, a5, a6, a7, a8);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00061A00) --------------------------------------------------------
char *__cdecl sub_61A00(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8)
{
  int v8; // edx
  int v9; // esi
  int v10; // ebx
  unsigned __int8 v11; // al
  __int64 v12; // rtt
  int v13; // ebx
  int v14; // edx
  int v15; // ebx
  __int16 v16; // dx
  int v17; // ebx
  int v18; // eax
  int v19; // edx
  int v20; // esi
  int v21; // edi
  int v22; // edx
  int v23; // eax
  int v24; // edx
  int v25; // ebx
  int v26; // ST48_4
  int v27; // edx
  int i; // eax
  int v29; // ebx
  unsigned int j; // ebx
  unsigned __int8 v31; // al
  unsigned __int8 v32; // ah
  unsigned __int8 v33; // ah
  unsigned __int8 v34; // ah
  unsigned __int16 v35; // si
  int v36; // eax
  char v37; // al
  char v38; // al
  int v39; // eax
  unsigned __int16 v40; // si
  int v41; // eax
  unsigned __int8 v42; // ah
  char v43; // al
  unsigned __int8 v44; // ah
  int v45; // eax
  unsigned __int8 v46; // al
  char v47; // al
  char v48; // dl
  char v49; // al
  unsigned __int8 v50; // ah
  __int16 v51; // ax
  int v52; // edx
  int v53; // ecx
  int v54; // esi
  int v55; // edi
  char *v56; // edx
  int v57; // ecx
  char *v58; // edx
  int v59; // eax
  int v60; // ebx
  int v61; // edx
  int v62; // eax
  int v63; // esi
  int v64; // edi
  unsigned __int8 *v65; // ST14_4
  unsigned __int8 v66; // al
  int v67; // esi
  _BYTE *v68; // ebx
  char *result; // eax
  _BYTE *v70; // edx
  int v71; // ecx
  int v72; // [esp+0h] [ebp-60h]
  int v73; // [esp+8h] [ebp-58h]
  int v74; // [esp+Ch] [ebp-54h]
  signed int v75; // [esp+10h] [ebp-50h]
  int v76; // [esp+14h] [ebp-4Ch]
  _BYTE *v77; // [esp+18h] [ebp-48h]
  signed int v78; // [esp+1Ch] [ebp-44h]
  int v79; // [esp+20h] [ebp-40h]
  int v80; // [esp+24h] [ebp-3Ch]
  _BYTE *v81; // [esp+28h] [ebp-38h]
  int v82; // [esp+2Ch] [ebp-34h]
  int v83; // [esp+30h] [ebp-30h]
  int v84; // [esp+34h] [ebp-2Ch]
  int v85; // [esp+38h] [ebp-28h]
  int v86; // [esp+3Ch] [ebp-24h]
  unsigned __int16 v87; // [esp+40h] [ebp-20h]
  unsigned __int16 v88; // [esp+44h] [ebp-1Ch]
  char v89; // [esp+48h] [ebp-18h]
  char v90; // [esp+4Ch] [ebp-14h]
  char v91; // [esp+50h] [ebp-10h]
  char v92; // [esp+54h] [ebp-Ch]
  unsigned __int8 v93; // [esp+58h] [ebp-8h]
  char v94; // [esp+5Ch] [ebp-4h]

  v8 = a1;
  v9 = a2;
  v10 = a8;
  v11 = *(_BYTE *)(dword_D41A0 + 196308);
  v83 = 0;
  if ( v11 < 1u )
  {
    if ( !v11 )
    {
      v92 = byte_E8900[0];
      v93 = byte_E8900[0];
      v91 = -24;
      v90 = 28;
    }
  }
  else if ( v11 <= 1u )
  {
    v92 = byte_E98FF;
    v93 = byte_E98FF;
    v91 = -24;
    v90 = -124;
  }
  else if ( v11 == 2 )
  {
    v92 = byte_E98FF;
    v93 = byte_E98FF;
    v91 = 28;
    v90 = byte_E89F0;
  }
  if ( word_180660 & 1 )
  {
    v8 = a1 >> 1;
    v9 = a2 >> 1;
    v10 = 2 * a8;
    a5 >>= 1;
    a6 >>= 1;
  }
  v84 = v9 * dword_18062C + dword_180628 + v8;
  LODWORD(v12) = sub_10000;
  HIDWORD(v12) = (signed int)sub_10000 >> 31;
  v13 = v12 / v10;
  v82 = a5 / 2;
  v14 = v13 * dword_DB750[a7 & 0x7FF];
  v76 = a6 / 2;
  v15 = (_DWORD)off_DBF50[a7 & 0x7FF] * v13;
  v86 = -v14 >> 16;
  sub_6FC50(byte_D419D);
  v73 = v15 >> 16;
  v80 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v16 = *(_WORD *)(*(_DWORD *)(v80 + 164) + 843);
  if ( v16 )
    v83 = *(signed __int16 *)(dword_EA3E4[v16] + 46);
  v17 = *(_DWORD *)(v80 + 164);
  if ( *(_WORD *)(v17 + 58) )
  {
    v18 = (signed __int16)(*(_WORD *)(v80 + 76) - a3);
    v19 = (signed __int16)(*(_WORD *)(v80 + 78) - a4);
    v20 = v82 + ((v18 * v73 - v19 * v86) >> 16);
    v21 = ((v73 * v19 + v86 * v18) >> 16) + v76;
    v22 = dword_EA3E4[*(unsigned __int16 *)(v17 + 58)];
    v23 = (signed __int16)(*(_WORD *)(v22 + 76) - a3);
    v24 = (signed __int16)(*(_WORD *)(v22 + 78) - a4);
    v25 = v82 + ((v23 * v73 - v24 * v86) >> 16);
    v26 = ((v73 * v24 + v86 * v23) >> 16) + v76;
    v27 = v82 + ((v23 * v73 - v24 * v86) >> 16) - v20;
    v75 = sub_7277A(v27 * v27 + (v26 - v21) * (v26 - v21));
    v72 = (unsigned __int16)sub_72633(v25 - v20, v26 - v21);
    for ( i = *(_DWORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248) & 3;
          ;
          *(_BYTE *)(v84 + v20 + (i * dword_DB750[v72] >> 16) + dword_18062C * v85) = byte_FAEE0[256
                                                                                               * *(unsigned __int8 *)(v84 + v20 + (i * dword_DB750[v72] >> 16) + dword_18062C * v85)
                                                                                               + (unsigned __int8)byte_E98FF] )
    {
      i += 4;
      if ( i > v75 )
        break;
      v29 = v20 + (i * dword_DB750[v72] >> 16);
      v85 = v21 + (-i * (signed int)off_DBF50[v72] >> 16);
      if ( v29 < 0 || v29 >= a5 || v85 < 0 || v85 >= a6 || v29 < word_F4962[2 * v85] || v29 >= word_F4960[2 * v85] )
        break;
    }
  }
  for ( j = dword_D41A0 + 28470; j < dword_D41A0 + 196302; j += 168 )
  {
    v31 = 0;
    v89 = 0;
    v78 = 1;
    v32 = *(_BYTE *)(j + 63) - 2;
    v88 = 0;
    if ( v32 <= 0xDu )
    {
      switch ( v32 )
      {
        case 0u:
          v42 = *(_BYTE *)(j + 64);
          if ( v42 > 3u )
          {
LABEL_78:
            v38 = v90;
            goto LABEL_121;
          }
          switch ( v42 )
          {
            case 0u:
              if ( *(_BYTE *)(j + 69) != 2 )
                goto LABEL_78;
              v94 = v90;
              v31 = 0;
              break;
            case 1u:
              v31 = 1;
              if ( *(_BYTE *)(dword_D41A4 + 124) )
                v94 = byte_E8988;
              else
                v89 = 1;
              v88 = 27;
              break;
            case 2u:
              if ( *(_BYTE *)(dword_D41A4 + 123) )
                v43 = byte_E9188;
              else
                v43 = v90;
              v94 = v43;
              v31 = 1;
              v88 = 22;
              break;
            case 3u:
              goto LABEL_123;
          }
          break;
        case 1u:
          v50 = *(_BYTE *)(j + 64);
          if ( v50 >= 2u )
          {
            if ( v50 <= 2u )
            {
              LOBYTE(v51) = *(_WORD *)(j + 26) != *(_WORD *)(v80 + 26);
              HIBYTE(v51) = 0;
              v88 = v51 + 24;
              v31 = sub_616D0(*(signed __int16 *)(*(_DWORD *)(dword_EA3E4[*(signed __int16 *)(j + 26)] + 164) + 56))
                  + 58;
            }
            else if ( v50 == 3 )
            {
              if ( *(_WORD *)(j + 26) == *(_WORD *)(v80 + 26) || v83 )
                v31 = sub_616D0(*(signed __int16 *)(*(_DWORD *)(dword_EA3E4[*(signed __int16 *)(j + 26)] + 164) + 56))
                    + 66;
              if ( *(_WORD *)(j + 26) == *(_WORD *)(v80 + 26) )
              {
                v88 = 23;
              }
              else if ( v83 )
              {
                v88 = 26;
              }
            }
          }
          break;
        case 2u:
        case 4u:
        case 5u:
        case 6u:
        case 0xBu:
          break;
        case 3u:
          v44 = *(_BYTE *)(j + 69);
          if ( v44 >= 0xB4u && (v44 <= 0xB4u || v44 >= 0xE8u && v44 <= 0xEAu) || *(_BYTE *)(j + 12) & 1 )
            break;
          v45 = *(signed __int16 *)(j + 26);
          if ( v45 != (signed int)(j - (dword_D41A0 + 28302)) / 168 )
          {
            v47 = byte_E88E1[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(dword_EA3E4[v45] + 164) + 56))];
            goto LABEL_102;
          }
          v46 = *(_BYTE *)(j + 64);
          if ( v46 >= 0xCu )
          {
            if ( v46 <= 0xEu )
            {
              v47 = byte_E890F;
LABEL_102:
              v94 = v47;
              goto LABEL_122;
            }
            if ( v46 == 22 )
            {
              if ( *(unsigned __int16 *)(j + 148) != *(signed __int16 *)(v80 + 26) )
                v88 = 18;
              v47 = v92;
              goto LABEL_102;
            }
          }
          v48 = *(_BYTE *)(j + 73);
          v94 = v92;
          v49 = 1;
          if ( (v48 == 14 || v48 == 13) && *(unsigned __int16 *)(j + 40) == *(signed __int16 *)(v80 + 26) )
            v49 = 0;
          if ( v49 )
            v88 = 19;
          goto LABEL_122;
        case 7u:
          goto LABEL_56;
        case 8u:
          v34 = *(_BYTE *)(j + 64);
          if ( v34 < 0x27u )
          {
            if ( v34 >= 0x12u )
            {
              if ( v34 <= 0x12u )
                break;
              if ( v34 == 34 )
                v78 = 2;
            }
            goto LABEL_56;
          }
          if ( v34 <= 0x27u )
            goto LABEL_173;
          if ( v34 < 0x39u )
          {
            if ( v34 != 45 )
              goto LABEL_56;
            v40 = *(_WORD *)(j + 148);
            if ( v40 )
            {
              v41 = dword_EA3E4[v40];
              if ( *(_BYTE *)(v41 + 63) == 3 )
              {
                if ( *(_BYTE *)(dword_D41A4 + 124) )
                  v38 = byte_E88E0[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(v41 + 164) + 56))];
                else
                  v38 = byte_E88E1[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(v41 + 164) + 56))];
                goto LABEL_121;
              }
            }
            if ( !(byte_D93C2[4 * *(char *)(j + 70)] & 8) )
              v88 = 21;
LABEL_56:
            v39 = dword_EA3E4[*(signed __int16 *)(j + 26)];
            if ( *(_BYTE *)(v39 + 63) == 3 )
              v38 = byte_E88E0[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(v39 + 164) + 56))];
            else
              v38 = byte_E980F;
LABEL_121:
            v94 = v38;
            goto LABEL_122;
          }
          if ( v34 <= 0x39u )
          {
LABEL_173:
            v35 = *(_WORD *)(j + 148);
            if ( v35 && (v36 = dword_EA3E4[v35], *(_BYTE *)(v36 + 63) == 3) )
            {
              if ( *(_BYTE *)(dword_D41A4 + 124) )
                v37 = byte_E88E0[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(v36 + 164) + 56))];
              else
                v37 = byte_E88E1[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(v36 + 164) + 56))];
              v94 = v37;
            }
            else
            {
              v94 = v91;
              v88 = 18;
            }
LABEL_122:
            v31 = 1;
          }
          else
          {
            if ( v34 < 0x4Eu )
              goto LABEL_56;
            if ( v34 <= 0x4Eu )
            {
              if ( *(_WORD *)(j + 50) != *(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240) )
                break;
              v38 = byte_E88E0[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(v80 + 164) + 56))
                             + *(unsigned __int8 *)(dword_D41A4 + 124)];
              goto LABEL_121;
            }
            if ( v34 < 0x56u || v34 > 0x57u )
              goto LABEL_56;
          }
          break;
        case 9u:
          v33 = *(_BYTE *)(j + 64);
          if ( v33 <= 0x2Cu )
          {
            switch ( v33 )
            {
              case 0u:
              case 1u:
              case 2u:
              case 3u:
              case 4u:
              case 5u:
              case 6u:
              case 7u:
              case 8u:
              case 9u:
              case 0xAu:
              case 0xBu:
              case 0xDu:
              case 0xEu:
              case 0xFu:
              case 0x10u:
              case 0x11u:
              case 0x12u:
              case 0x13u:
              case 0x14u:
              case 0x15u:
              case 0x16u:
              case 0x17u:
              case 0x18u:
              case 0x19u:
              case 0x1Au:
              case 0x1Bu:
              case 0x1Cu:
              case 0x1Du:
              case 0x1Eu:
              case 0x20u:
              case 0x21u:
              case 0x22u:
              case 0x23u:
              case 0x24u:
              case 0x25u:
              case 0x26u:
              case 0x27u:
              case 0x28u:
              case 0x29u:
              case 0x2Au:
              case 0x2Bu:
              case 0x2Cu:
                goto LABEL_123;
              case 0xCu:
                v31 = 83;
                v88 = 83;
                break;
              case 0x1Fu:
                v31 = 84;
                v88 = 83;
                break;
            }
          }
          break;
        case 0xAu:
        case 0xDu:
          if ( *(_BYTE *)(j + 12) & 1 )
            break;
          v38 = byte_E9800;
          v88 = 20;
          goto LABEL_121;
        case 0xCu:
          if ( *(_BYTE *)(j + 64) != 5 )
            break;
          if ( *(_BYTE *)(dword_D41A4 + 124) )
            v38 = byte_E9800;
          else
            v38 = byte_E98FF;
          goto LABEL_121;
      }
    }
LABEL_123:
    if ( v31 )
    {
      v52 = (signed __int16)(*(_WORD *)(j + 76) - a3);
      v53 = (signed __int16)(*(_WORD *)(j + 78) - a4);
      v54 = v82 + ((v52 * v73 - v53 * v86) >> 16);
      if ( v54 >= 0 && v54 < a5 )
      {
        v55 = ((v73 * v53 + v86 * v52) >> 16) + v76;
        if ( v55 >= 0 && v55 < a6 && v54 >= word_F4962[2 * v55] && v54 < word_F4960[2 * v55] )
        {
          v56 = (char *)(v54 + v84 + v55 * dword_18062C);
          if ( !v89 )
          {
            if ( v31 <= 1u )
            {
              *v56 = v94;
              if ( v78 > 1 )
              {
                v57 = dword_18062C;
                v56[1] = v94;
                v58 = &v56[v57];
                *v58 = v94;
                v58[1] = v94;
              }
            }
            else if ( word_180660 == 1 )
            {
              if ( v31 < 0x42u || v31 >= 0x4Au )
              {
                if ( v31 < 0x3Au || v31 >= 0x42u )
                {
                  if ( v31 == 83 || v31 == 84 )
                    sub_2BB40(
                      2 * v54 - *(unsigned __int8 *)(6 * v31 + dword_EA3DC + 4) / 2,
                      2 * v55 - *(unsigned __int8 *)(6 * v31 + dword_EA3DC + 5) / 2,
                      6 * v31 + dword_EA3DC);
                }
                else
                {
                  sub_2BB40(2 * v54, 2 * v55 - *(unsigned __int8 *)(6 * v31 + dword_EA3DC + 5), 6 * v31 + dword_EA3DC);
                }
              }
              else
              {
                sub_2BB40(
                  2 * v54 - *(unsigned __int8 *)(6 * v31 + dword_EA3DC + 4) / 2,
                  2 * v55 - *(unsigned __int8 *)(6 * v31 + dword_EA3DC + 5),
                  6 * v31 + dword_EA3DC);
              }
            }
            else if ( v31 >= 0x3Cu )
            {
              sub_2BB40(
                v54 - *(unsigned __int8 *)(6 * v31 + dword_EA3DC + 4) / 2,
                v55 - *(unsigned __int8 *)(6 * v31 + dword_EA3DC + 5),
                6 * v31 + dword_EA3DC);
            }
            else
            {
              sub_2BB40(v54, v55 - *(unsigned __int8 *)(6 * v31 + dword_EA3DC + 5), 6 * v31 + dword_EA3DC);
            }
          }
          if ( v88 )
            sub_885E0(j, (signed __int16)v54, (signed __int16)v55, v88);
        }
      }
    }
  }
  if ( v83 )
  {
    v87 = 0;
    v74 = dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12) + 11240)];
    while ( v87 < *(_WORD *)(dword_D41A0 + 14) )
    {
      if ( v87 != *(signed __int16 *)(dword_D41A0 + 12) )
      {
        v79 = 2124 * v87;
        v59 = *(unsigned __int16 *)(2124 * v87 + dword_D41A0 + 11240);
        v60 = dword_EA3E4[v59];
        if ( *(_DWORD *)(v60 + 8) >= 0 )
        {
          if ( sub_63570(v74, dword_EA3E4[v59]) )
          {
            v61 = (signed __int16)(*(_WORD *)(v60 + 76) - a3);
            v62 = (signed __int16)(*(_WORD *)(v60 + 78) - a4);
            v63 = v82 + ((v61 * v73 - v62 * v86) >> 16);
            if ( v63 >= 0 && v63 < a5 )
            {
              v64 = v76 + ((v86 * v61 + v73 * v62) >> 16);
              if ( v64 >= 0 && v64 < a6 && v63 >= word_F4962[2 * v64] && v63 < word_F4960[2 * v64] )
              {
                v65 = (unsigned __int8 *)(v64 * dword_18062C + v63 + v84);
                v66 = byte_E88E0[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(v60 + 164) + 56))];
                *v65 = v66;
                if ( word_180660 == 1 )
                  sub_2BC10((_BYTE *)(v79 + dword_D41A0 + 11230 + 927), 2 * v63 + 4, 2 * v64, v66);
                else
                  sub_2BC10((_BYTE *)(v79 + dword_D41A0 + 11230 + 927), v63 + 4, v64, v66);
              }
            }
          }
        }
      }
      ++v87;
    }
  }
  v67 = a5 / 12;
  v68 = (_BYTE *)(dword_18062C * (a6 / 2) + a5 / 2 + v84 - 1);
  result = &byte_FAEE0[256 * v93];
  v70 = (_BYTE *)(dword_18062C * (a6 / 2) + a5 / 2 + v84 - 1);
  v77 = (_BYTE *)(dword_18062C * (a6 / 2) + a5 / 2 + v84 - 1);
  v81 = (_BYTE *)(dword_18062C * (a6 / 2) + a5 / 2 + v84 - 1);
  for ( *v68 = result[(unsigned __int8)*v68]; v67; *v68 = byte_FAEE0[256 * v93 + v71] )
  {
    v81 -= dword_18062C;
    v70 += dword_18062C;
    ++v77;
    *v81 = byte_FAEE0[256 * v93 + (unsigned __int8)*v81];
    *v77 = byte_FAEE0[256 * v93 + (unsigned __int8)*v77];
    *v70 = byte_FAEE0[256 * v93 + (unsigned __int8)*v70];
    v71 = (unsigned __int8)*(v68-- - 1);
    --v67;
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// D419D: using guessed type char byte_D419D;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// E890F: using guessed type char byte_E890F;
// E8988: using guessed type char byte_E8988;
// E89F0: using guessed type char byte_E89F0;
// E9188: using guessed type char byte_E9188;
// E9800: using guessed type char byte_E9800;
// E980F: using guessed type char byte_E980F;
// E98FF: using guessed type char byte_E98FF;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// F4960: using guessed type __int16 word_F4960[];
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (000627F0) --------------------------------------------------------
char *__cdecl sub_627F0(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8)
{
  int v8; // edx
  int v9; // esi
  int v10; // ebx
  unsigned __int8 v11; // al
  char v12; // al
  __int64 v13; // rtt
  int v14; // ebx
  int v15; // edx
  int v16; // ebx
  __int16 v17; // dx
  int v18; // ebx
  int v19; // edx
  int v20; // eax
  int v21; // esi
  int v22; // edx
  int v23; // eax
  int v24; // edi
  int v25; // edx
  int v26; // eax
  int v27; // ebx
  int v28; // ST48_4
  int v29; // edx
  int v30; // eax
  int v31; // ebx
  char *v32; // edx
  char *v33; // ST44_4
  char v34; // bl
  unsigned int i; // ebx
  unsigned __int8 v36; // al
  unsigned __int8 v37; // ah
  unsigned __int8 v38; // ah
  unsigned __int8 v39; // ah
  unsigned __int16 v40; // si
  int v41; // eax
  char v42; // al
  char v43; // al
  int v44; // eax
  unsigned __int16 v45; // si
  int v46; // eax
  _BOOL1 v47; // zf
  unsigned __int8 v48; // ah
  unsigned __int8 v49; // ah
  int v50; // eax
  unsigned __int8 v51; // al
  char v52; // al
  char v53; // al
  char v54; // ah
  unsigned __int8 v55; // ah
  __int16 v56; // ax
  int v57; // edx
  int v58; // ecx
  int v59; // esi
  int v60; // edi
  char *v61; // ecx
  char *v62; // edx
  char *v63; // edx
  char *v64; // ecx
  int v65; // eax
  int v66; // ebx
  int v67; // edx
  int v68; // eax
  int v69; // esi
  int v70; // edi
  unsigned __int8 *v71; // ST2C_4
  unsigned __int8 *v72; // ST28_4
  unsigned __int8 v73; // al
  int v74; // eax
  char *v75; // esi
  char *v76; // ebx
  char *result; // eax
  char *v78; // edx
  char v79; // cl
  char v80; // cl
  char v81; // cl
  char v82; // cl
  char *v83; // [esp+0h] [ebp-1Eh]
  char *v84; // [esp+4h] [ebp-1Ah]
  int v85; // [esp+8h] [ebp-16h]
  int v86; // [esp+Ch] [ebp-12h]
  int v87; // [esp+10h] [ebp-Eh]
  char *v88; // [esp+14h] [ebp-Ah]
  int v89; // [esp+20h] [ebp+2h]
  int v90; // [esp+24h] [ebp+6h]
  signed int v91; // [esp+28h] [ebp+Ah]
  signed int v92; // [esp+2Ch] [ebp+Eh]
  int v93; // [esp+30h] [ebp+12h]
  int v94; // [esp+38h] [ebp+1Ah]
  char *v95; // [esp+3Ch] [ebp+1Eh]
  int v96; // [esp+40h] [ebp+22h]
  int v97; // [esp+44h] [ebp+26h]
  int v98; // [esp+48h] [ebp+2Ah]
  int v99; // [esp+4Ch] [ebp+2Eh]
  int v100; // [esp+50h] [ebp+32h]
  char *v101; // [esp+54h] [ebp+36h]
  int v102; // [esp+58h] [ebp+3Ah]
  unsigned __int16 j; // [esp+5Ch] [ebp+3Eh]
  unsigned __int16 v104; // [esp+60h] [ebp+42h]
  char v105; // [esp+68h] [ebp+4Ah]
  unsigned __int8 v106; // [esp+6Ch] [ebp+4Eh]
  char v107; // [esp+70h] [ebp+52h]
  char v108; // [esp+74h] [ebp+56h]
  char v109; // [esp+78h] [ebp+5Ah]
  char v110; // [esp+7Ch] [ebp+5Eh]

  v8 = a1;
  v9 = a2;
  v10 = a8;
  v11 = *(_BYTE *)(dword_D41A0 + 196308);
  v93 = 0;
  if ( v11 < 1u )
  {
    if ( !v11 )
    {
      v109 = byte_E8900[0];
      v106 = byte_E8900[0];
      v108 = 28;
      v107 = -24;
    }
    goto LABEL_10;
  }
  if ( v11 <= 1u )
  {
    v109 = byte_E98FF;
    v106 = byte_E98FF;
    v12 = -124;
    v107 = -24;
  }
  else
  {
    if ( v11 != 2 )
      goto LABEL_10;
    v109 = byte_E98FF;
    v106 = byte_E98FF;
    v107 = 28;
    v12 = byte_E89F0;
  }
  v108 = v12;
LABEL_10:
  if ( word_180660 & 1 )
  {
    v8 = a1 >> 1;
    v9 = a2 >> 1;
    v10 = 2 * a8;
    a5 >>= 1;
    a6 >>= 1;
  }
  v99 = v9 * dword_18062C + dword_180628 + v8;
  v100 = v9 * dword_18062C + dword_E9C3C + v8;
  LODWORD(v13) = sub_10000;
  HIDWORD(v13) = (signed int)sub_10000 >> 31;
  v14 = v13 / v10;
  v98 = a5 / 2;
  v15 = v14 * dword_DB750[a7 & 0x7FF];
  v16 = (_DWORD)off_DBF50[a7 & 0x7FF] * v14;
  v85 = a6 / 2;
  v86 = -v15 >> 16;
  sub_6FC50(byte_D419D);
  v87 = v16 >> 16;
  v102 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v17 = *(_WORD *)(*(_DWORD *)(v102 + 164) + 843);
  if ( v17 )
    v93 = *(signed __int16 *)(dword_EA3E4[v17] + 46);
  v18 = *(_DWORD *)(v102 + 164);
  if ( *(_WORD *)(v18 + 58) )
  {
    v19 = (signed __int16)(*(_WORD *)(v102 + 76) - a3);
    v20 = (signed __int16)(*(_WORD *)(v102 + 78) - a4);
    v21 = v98 + ((v19 * v87 - v20 * v86) >> 16);
    v22 = v87 * v20 + v86 * v19;
    v23 = dword_EA3E4[*(unsigned __int16 *)(v18 + 58)];
    v24 = (v22 >> 16) + v85;
    v25 = (signed __int16)(*(_WORD *)(v23 + 76) - a3);
    v26 = (signed __int16)(*(_WORD *)(v23 + 78) - a4);
    v27 = v98 + ((v25 * v87 - v26 * v86) >> 16);
    v28 = ((v86 * v25 + v87 * v26) >> 16) + v85;
    v29 = v98 + ((v25 * v87 - v26 * v86) >> 16) - v21;
    v91 = sub_7277A(v29 * v29 + (v28 - v24) * (v28 - v24));
    v89 = (unsigned __int16)sub_72633(v27 - v21, v28 - v24);
    v30 = *(_DWORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248) & 3;
    while ( 1 )
    {
      v30 += 4;
      if ( v30 > v91 )
        break;
      v31 = v21 + (v30 * dword_DB750[v89] >> 16);
      v94 = v24 + (-v30 * (signed int)off_DBF50[v89] >> 16);
      if ( v31 < 0 || v31 >= a5 || v94 < 0 || v94 >= a6 || v31 < word_F4962[2 * v94] || v31 >= word_F4960[2 * v94] )
        break;
      v32 = (char *)(dword_18062C * v94 + v31 + v99);
      v33 = (char *)(v100 + v31 + dword_18062C * v94);
      v34 = byte_FAEE0[256 * (unsigned __int8)*v32 + (unsigned __int8)byte_E98FF];
      *v33 = v34;
      *v32 = v34;
    }
  }
  for ( i = dword_D41A0 + 28470; i < dword_D41A0 + 196302; i += 168 )
  {
    v36 = 0;
    v105 = 0;
    v92 = 1;
    v37 = *(_BYTE *)(i + 63) - 2;
    v104 = 0;
    if ( v37 <= 0xDu )
    {
      switch ( v37 )
      {
        case 0u:
          v48 = *(_BYTE *)(i + 64);
          if ( v48 > 3u )
          {
LABEL_74:
            v110 = v108;
            goto LABEL_118;
          }
          switch ( v48 )
          {
            case 0u:
              if ( *(_BYTE *)(i + 69) != 2 )
                goto LABEL_74;
              v110 = v108;
              v36 = 0;
              break;
            case 1u:
              v36 = 1;
              if ( *(_BYTE *)(dword_D41A4 + 123) )
                v110 = byte_E8988;
              else
                v105 = 1;
              v104 = 27;
              break;
            case 2u:
              v110 = v108;
              v104 = 22;
              goto LABEL_118;
            case 3u:
              goto LABEL_119;
          }
          break;
        case 1u:
          v55 = *(_BYTE *)(i + 64);
          if ( v55 >= 2u )
          {
            if ( v55 <= 2u )
            {
              LOBYTE(v56) = *(_WORD *)(i + 26) != *(_WORD *)(v102 + 26);
              HIBYTE(v56) = 0;
              v104 = v56 + 24;
              v36 = *(_BYTE *)(*(_DWORD *)(dword_EA3E4[*(signed __int16 *)(i + 26)] + 164) + 56) + 58;
            }
            else if ( v55 == 3 )
            {
              if ( *(_WORD *)(i + 26) == *(_WORD *)(v102 + 26) || v93 )
                v36 = *(_BYTE *)(*(_DWORD *)(dword_EA3E4[*(signed __int16 *)(i + 26)] + 164) + 56) + 66;
              if ( *(_WORD *)(i + 26) == *(_WORD *)(v102 + 26) )
              {
                v104 = 23;
              }
              else if ( v93 )
              {
                v104 = 26;
              }
            }
          }
          break;
        case 2u:
        case 4u:
        case 5u:
        case 6u:
        case 0xBu:
          break;
        case 3u:
          v49 = *(_BYTE *)(i + 69);
          if ( v49 >= 0xB4u && (v49 <= 0xB4u || v49 >= 0xE8u && v49 <= 0xEAu) || *(_BYTE *)(i + 12) & 1 )
            break;
          v50 = *(signed __int16 *)(i + 26);
          if ( v50 != (signed int)(i - (dword_D41A0 + 28302)) / 168 )
          {
            v52 = byte_E88E1[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(dword_EA3E4[v50] + 164) + 56))];
            goto LABEL_98;
          }
          v51 = *(_BYTE *)(i + 64);
          if ( v51 >= 0xCu )
          {
            if ( v51 <= 0xEu )
            {
              v52 = byte_E890F;
LABEL_98:
              v110 = v52;
              goto LABEL_118;
            }
            if ( v51 == 22 )
            {
              if ( *(unsigned __int16 *)(i + 148) != *(signed __int16 *)(v102 + 26) )
                v104 = 18;
              v52 = v109;
              goto LABEL_98;
            }
          }
          v110 = v109;
          v53 = 1;
          v54 = *(_BYTE *)(i + 73);
          if ( (v54 == 14 || v54 == 13) && *(unsigned __int16 *)(i + 40) == *(signed __int16 *)(v102 + 26) )
            v53 = 0;
          if ( v53 )
            v104 = 19;
          goto LABEL_118;
        case 7u:
          goto LABEL_57;
        case 8u:
          v39 = *(_BYTE *)(i + 64);
          if ( v39 < 0x27u )
          {
            if ( v39 >= 0x12u )
            {
              if ( v39 <= 0x12u )
                break;
              if ( v39 == 34 )
                v92 = 2;
            }
            goto LABEL_57;
          }
          if ( v39 <= 0x27u )
            goto LABEL_169;
          if ( v39 < 0x39u )
          {
            if ( v39 == 45 )
            {
              v45 = *(_WORD *)(i + 148);
              if ( v45 && (v46 = dword_EA3E4[v45], *(_BYTE *)(v46 + 63) == 3) )
              {
                v47 = *(_BYTE *)(dword_D41A4 + 124) == 0;
                sub_61790(*(signed __int16 *)(*(_DWORD *)(v46 + 164) + 56));
              }
              else
              {
                if ( !(byte_D93C2[4 * *(char *)(i + 70)] & 8) )
                  v104 = 21;
                v105 = 1;
              }
            }
LABEL_57:
            v44 = dword_EA3E4[*(signed __int16 *)(i + 26)];
            if ( *(_BYTE *)(v44 + 63) == 3 )
              v43 = byte_E88E0[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(v44 + 164) + 56))];
            else
              v43 = byte_E980F;
LABEL_117:
            v110 = v43;
            goto LABEL_118;
          }
          if ( v39 <= 0x39u )
          {
LABEL_169:
            v40 = *(_WORD *)(i + 148);
            if ( v40 && (v41 = dword_EA3E4[v40], *(_BYTE *)(v41 + 63) == 3) )
            {
              if ( *(_BYTE *)(dword_D41A4 + 124) )
                v42 = byte_E88E0[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(v41 + 164) + 56))];
              else
                v42 = byte_E88E1[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(v41 + 164) + 56))];
              v110 = v42;
            }
            else
            {
              v110 = v107;
              v104 = 18;
            }
LABEL_118:
            v36 = 1;
          }
          else
          {
            if ( v39 < 0x4Eu )
              goto LABEL_57;
            if ( v39 <= 0x4Eu )
            {
              if ( *(_WORD *)(i + 50) != *(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240) )
                break;
              v43 = byte_E88E0[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(v102 + 164) + 56))
                             + *(unsigned __int8 *)(dword_D41A4 + 124)];
              goto LABEL_117;
            }
            if ( v39 < 0x56u || v39 > 0x57u )
              goto LABEL_57;
          }
          break;
        case 9u:
          v38 = *(_BYTE *)(i + 64);
          if ( v38 <= 0x2Cu )
          {
            switch ( v38 )
            {
              case 0u:
              case 1u:
              case 2u:
              case 3u:
              case 4u:
              case 5u:
              case 6u:
              case 7u:
              case 8u:
              case 9u:
              case 0xAu:
              case 0xBu:
              case 0xDu:
              case 0xEu:
              case 0xFu:
              case 0x10u:
              case 0x11u:
              case 0x12u:
              case 0x13u:
              case 0x14u:
              case 0x15u:
              case 0x16u:
              case 0x17u:
              case 0x18u:
              case 0x19u:
              case 0x1Au:
              case 0x1Bu:
              case 0x1Cu:
              case 0x1Du:
              case 0x1Eu:
              case 0x20u:
              case 0x21u:
              case 0x22u:
              case 0x23u:
              case 0x24u:
              case 0x25u:
              case 0x26u:
              case 0x27u:
              case 0x28u:
              case 0x29u:
              case 0x2Au:
              case 0x2Bu:
              case 0x2Cu:
                goto LABEL_119;
              case 0xCu:
                v36 = 83;
                v104 = 83;
                break;
              case 0x1Fu:
                v36 = 84;
                v104 = 83;
                break;
            }
          }
          break;
        case 0xAu:
        case 0xDu:
          if ( *(_BYTE *)(i + 12) & 1 )
            break;
          v43 = byte_E9800;
          v104 = 20;
          goto LABEL_117;
        case 0xCu:
          if ( *(_BYTE *)(i + 64) != 5 )
            break;
          if ( *(_BYTE *)(dword_D41A4 + 124) )
            v43 = byte_E9800;
          else
            v43 = byte_E98FF;
          goto LABEL_117;
      }
    }
LABEL_119:
    if ( v36 )
    {
      v57 = (signed __int16)(*(_WORD *)(i + 76) - a3);
      v58 = (signed __int16)(*(_WORD *)(i + 78) - a4);
      v59 = v98 + ((v57 * v87 - v58 * v86) >> 16);
      if ( v59 >= 0 && v59 < a5 )
      {
        v60 = ((v87 * v58 + v86 * v57) >> 16) + v85;
        if ( v60 >= 0 && v60 < a6 && v59 >= word_F4962[2 * v60] && v59 < word_F4960[2 * v60] )
        {
          v61 = (char *)(v60 * dword_18062C + v59 + v99);
          v62 = (char *)(v60 * dword_18062C + v59 + v100);
          if ( !v105 )
          {
            if ( v36 <= 1u )
            {
              *v62 = v110;
              *v61 = v110;
              if ( v92 > 1 )
              {
                v62[1] = v110;
                v61[1] = v110;
                v63 = &v62[dword_18062C];
                *v63 = v110;
                v64 = &v61[dword_18062C];
                *v64 = v110;
                v63[1] = v110;
                v64[1] = v110;
              }
            }
            else if ( word_180660 == 1 )
            {
              if ( v36 < 0x42u || v36 >= 0x4Au )
              {
                if ( v36 < 0x3Au || v36 >= 0x42u )
                {
                  if ( v36 == 83 || v36 == 84 )
                    sub_2BB40(
                      2 * v59 - *(unsigned __int8 *)(6 * v36 + dword_EA3DC + 4) / 2,
                      2 * v60 - *(unsigned __int8 *)(6 * v36 + dword_EA3DC + 5) / 2,
                      6 * v36 + dword_EA3DC);
                }
                else
                {
                  sub_2BB40(2 * v59, 2 * v60 - *(unsigned __int8 *)(dword_EA3DC + 6 * v36 + 5), dword_EA3DC + 6 * v36);
                }
              }
              else
              {
                sub_2BB40(
                  2 * v59 - *(unsigned __int8 *)(6 * v36 + dword_EA3DC + 4) / 2,
                  2 * v60 - *(unsigned __int8 *)(6 * v36 + dword_EA3DC + 5),
                  6 * v36 + dword_EA3DC);
              }
            }
            else if ( v36 >= 0x3Cu )
            {
              sub_2BB40(
                v59 - *(unsigned __int8 *)(6 * v36 + dword_EA3DC + 4) / 2,
                v60 - *(unsigned __int8 *)(6 * v36 + dword_EA3DC + 5),
                6 * v36 + dword_EA3DC);
            }
            else
            {
              sub_2BB40(v59, v60 - *(unsigned __int8 *)(6 * v36 + dword_EA3DC + 5), 6 * v36 + dword_EA3DC);
            }
          }
          if ( v104 )
            sub_885E0(i, (signed __int16)v59, (signed __int16)v60, v104);
        }
      }
    }
  }
  if ( v93 )
  {
    v90 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
    for ( j = 0; j < *(_WORD *)(dword_D41A0 + 14); ++j )
    {
      if ( j != *(signed __int16 *)(dword_D41A0 + 12) )
      {
        v96 = 2124 * j;
        v65 = *(unsigned __int16 *)(2124 * j + dword_D41A0 + 11240);
        v66 = dword_EA3E4[v65];
        if ( *(_DWORD *)(v66 + 8) >= 0 )
        {
          if ( sub_63570(v90, dword_EA3E4[v65]) )
          {
            v67 = (signed __int16)(*(_WORD *)(v66 + 76) - a3);
            v68 = (signed __int16)(*(_WORD *)(v66 + 78) - a4);
            v69 = v98 + ((v67 * v87 - v68 * v86) >> 16);
            if ( v69 >= 0 && v69 < a5 )
            {
              v70 = ((v86 * v67 + v87 * v68) >> 16) + v85;
              if ( v70 >= 0 && v70 < a6 && v69 >= word_F4962[2 * v70] && v69 < word_F4960[2 * v70] )
              {
                v71 = (unsigned __int8 *)(v70 * dword_18062C + v69 + v99);
                v72 = (unsigned __int8 *)(v70 * dword_18062C + v69 + v100);
                v73 = byte_E88E1[3 * sub_61790(*(signed __int16 *)(*(_DWORD *)(v66 + 164) + 56))];
                *v72 = v73;
                *v71 = v73;
                if ( word_180660 == 1 )
                  sub_2BC10((_BYTE *)(v96 + dword_D41A0 + 11230 + 927), 2 * v69 + 4, 2 * v70, v73);
                else
                  sub_2BC10((_BYTE *)(v96 + dword_D41A0 + 11230 + 927), v69 + 4, v70, v73);
              }
            }
          }
        }
      }
    }
  }
  v97 = a5 / 12;
  v74 = dword_18062C * (a6 / 2);
  v75 = (char *)(v100 + a5 / 2 + v74 - 1);
  v76 = (char *)(v74 + a5 / 2 + v99 - 1);
  result = &byte_FAEE0[256 * v106];
  v88 = v76;
  v101 = v76;
  *v76 = result[(unsigned __int8)*v76];
  v78 = v76;
  v83 = v75;
  v84 = v75;
  v95 = v75;
  for ( *v75 = result[(unsigned __int8)*v76]; v97; --v97 )
  {
    ++v101;
    v88 += dword_18062C;
    v78 -= dword_18062C;
    v95 -= dword_18062C;
    ++v84;
    v83 += dword_18062C;
    v79 = byte_FAEE0[256 * v106 + (unsigned __int8)*v78];
    *v78 = v79;
    *v95 = v79;
    v80 = byte_FAEE0[256 * v106 + (unsigned __int8)*v101];
    *v101 = v80;
    *v84 = v80;
    v81 = byte_FAEE0[256 * v106 + (unsigned __int8)*v88];
    *v88 = v81;
    *v83 = v81;
    v82 = byte_FAEE0[256 * v106 + (unsigned __int8)*(v76 - 1)];
    *(v76 - 1) = v82;
    *(v75 - 1) = v82;
    --v76;
    --v75;
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// D419D: using guessed type char byte_D419D;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// E890F: using guessed type char byte_E890F;
// E8988: using guessed type char byte_E8988;
// E89F0: using guessed type char byte_E89F0;
// E9800: using guessed type char byte_E9800;
// E980F: using guessed type char byte_E980F;
// E98FF: using guessed type char byte_E98FF;
// E9C3C: using guessed type int dword_E9C3C;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// F4960: using guessed type __int16 word_F4960[];
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (00063570) --------------------------------------------------------
char __cdecl sub_63570(int a1, int a2)
{
  unsigned int v2; // ecx
  char v3; // ah
  unsigned int v4; // ebx
  char v5; // dl
  unsigned __int8 v6; // al

  v2 = dword_EA3E4[*(signed __int16 *)(*(_DWORD *)(a1 + 164) + 843)];
  v3 = 1;
  v4 = dword_EA3E4[*(signed __int16 *)(*(_DWORD *)(a2 + 164) + 827)];
  v5 = 0;
  if ( v4 > dword_EA3E4[0] && *(_WORD *)(v4 + 46) )
    v5 = 1;
  if ( v2 > dword_EA3E4[0] )
  {
    v6 = *(_BYTE *)(v2 + 70);
    if ( v6 < 1u )
    {
      if ( v6 )
        return v3;
      if ( *(_BYTE *)(*(_DWORD *)(a2 + 164) + 447) )
        return 0;
    }
    else if ( v6 > 1u )
    {
      return v3;
    }
    if ( v5 )
      return 0;
  }
  return v3;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00063600) --------------------------------------------------------
int __cdecl sub_63600(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10)
{
  int result; // eax

  if ( *(_BYTE *)(dword_D41A0 + 8592) == 1 )
    result = sub_63670(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  else
    result = sub_63C90(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00063670) --------------------------------------------------------
int __cdecl sub_63670(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10)
{
  int v10; // eax
  int v11; // esi
  int v12; // edi
  int v13; // ecx
  _BOOL1 v14; // dl
  __int16 *v15; // ebx
  int v16; // edx
  __int16 *v17; // esi
  int v18; // ebx
  __int16 v19; // ax
  __int16 *v20; // edx
  __int16 v21; // ax
  int v22; // edx
  int v23; // ebx
  int v24; // esi
  int v25; // eax
  int v26; // eax
  int result; // eax
  int v28; // ebx
  int v29; // ecx
  char *v30; // edi
  int v31; // esi
  int v32; // eax
  int v33; // edx
  char v34; // al
  int v35; // ecx
  int v36; // ebx
  _BYTE *v37; // edi
  int v38; // ecx
  int v39; // esi
  int v40; // eax
  int v41; // edx
  int v42; // ebx
  char *v43; // edi
  int v44; // ecx
  int v45; // esi
  int v46; // eax
  int v47; // edx
  char v48; // al
  int v49; // ecx
  int v50; // ebx
  _BYTE *v51; // edi
  int v52; // ecx
  int v53; // esi
  int v54; // eax
  int v55; // edx
  int v56; // ebx
  char *v57; // edi
  int v58; // ecx
  int v59; // esi
  int v60; // eax
  int v61; // edx
  char v62; // al
  char *v63; // edi
  int v64; // [esp+0h] [ebp-60h]
  int v65; // [esp+4h] [ebp-5Ch]
  int v66; // [esp+8h] [ebp-58h]
  int v67; // [esp+Ch] [ebp-54h]
  int v68; // [esp+10h] [ebp-50h]
  int v69; // [esp+14h] [ebp-4Ch]
  int v70; // [esp+18h] [ebp-48h]
  int v71; // [esp+1Ch] [ebp-44h]
  int l; // [esp+20h] [ebp-40h]
  int v73; // [esp+24h] [ebp-3Ch]
  int i; // [esp+28h] [ebp-38h]
  int k; // [esp+2Ch] [ebp-34h]
  int m; // [esp+30h] [ebp-30h]
  int j; // [esp+34h] [ebp-2Ch]
  int v78; // [esp+38h] [ebp-28h]
  __int16 *v79; // [esp+3Ch] [ebp-24h]
  int v80; // [esp+40h] [ebp-20h]
  int v81; // [esp+44h] [ebp-1Ch]
  int v82; // [esp+48h] [ebp-18h]
  int v83; // [esp+4Ch] [ebp-14h]
  int v84; // [esp+50h] [ebp-10h]
  int v85; // [esp+54h] [ebp-Ch]
  __int16 *v86; // [esp+58h] [ebp-8h]
  _BOOL1 v87; // [esp+5Ch] [ebp-4h]

  v10 = a1;
  v11 = a2;
  v12 = a5;
  v13 = a6;
  v14 = !*(_BYTE *)(dword_D41A0 + 8600) && *(_BYTE *)(dword_D41A0 + 196308) != 2;
  v87 = v14;
  if ( word_180660 & 1 )
  {
    v10 = a1 >> 1;
    v11 = a2 >> 1;
    v12 = a5 >> 1;
    v13 = a6 >> 1;
    a8 *= 2;
  }
  v70 = v11 * dword_18062C + dword_180628 + v10;
  v71 = v11 * dword_18062C + dword_E9C3C + v10;
  if ( a10 )
  {
    v15 = word_F4960;
    v16 = v13;
    while ( v16 )
    {
      v15 += 2;
      *(v15 - 1) = 0;
      --v16;
      *(v15 - 2) = v12;
    }
  }
  else
  {
    v78 = v13 / 2;
    v17 = &word_F4960[2 * (v13 / 2)];
    v79 = v17 - 2;
    v73 = 0;
    v68 = v13 >> 1;
    v18 = v12 >> 1;
    v69 = 0x1000000 / (v13 >> 1);
    while ( v78 )
    {
      v65 = v18 * (unsigned __int8)byte_10B1E0[v73 >> 16] >> 8;
      v19 = v18 + v65;
      v20 = v79;
      *v17 = v18 + v65;
      *v20 = v19;
      v21 = v18 - v65;
      v22 = (int)v79;
      v17[1] = v18 - v65;
      *(_WORD *)(v22 + 2) = v21;
      v79 = (__int16 *)(v22 - 4);
      v17 += 2;
      v73 += v69;
      --v78;
    }
  }
  v23 = a7 & 0x7FF;
  v24 = v13 * (a8 * dword_DB750[v23] >> 16);
  v25 = a8 * (signed int)off_DBF50[v23] >> 16;
  v80 = a8 * dword_DB750[v23] >> 16;
  v81 = v25;
  v67 = v24 / v12;
  v26 = v13 * v25;
  v66 = v26 / v12;
  v85 = a3 - (v12 * (v26 / v12) - v24) / 2;
  v86 = word_F4960;
  v83 = a4 - (v26 + v12 * (v24 / v12)) / 2;
  v84 = v70;
  result = v71;
  v82 = v71;
  if ( byte_D41B6 )
  {
    if ( a10 )
    {
      for ( i = v13; i; --i )
      {
        v33 = v86[1];
        v28 = v85 + v33 * v66;
        v29 = v83 + v33 * v67;
        v30 = (char *)(v33 + v84);
        v64 = v33 + v82;
        v31 = *v86 - v86[1];
        v32 = 0;
        HIWORD(v33) = 0;
        do
        {
          LOBYTE(v33) = BYTE1(v28);
          BYTE1(v33) = BYTE1(v29);
          v34 = 0;
          if ( !(byte_13B4E0[v33] & 8) )
          {
            LOBYTE(v32) = byte_10B4E0[v33];
            BYTE1(v33) = byte_12B4E0[v33];
            LOBYTE(v33) = byte_10AEE0[v32];
            v34 = byte_F6EE0[v33];
          }
          *v30++ = v34;
          LOWORD(v28) = v66 + v28;
          LOWORD(v29) = v67 + v29;
          --v31;
        }
        while ( v31 );
        v84 += dword_18062C;
        v82 += dword_18062C;
        v86 += 2;
        v85 -= v80;
        result = i - 1;
        v83 += v81;
      }
    }
    else if ( v87 )
    {
      for ( j = v13; j; --j )
      {
        v35 = v86[1];
        v36 = v85 + v35 * v66;
        v37 = (_BYTE *)(v35 + v84);
        v64 = v35 + v82;
        v38 = v83 + v35 * v67;
        v39 = *v86 - v86[1];
        v40 = 0;
        HIWORD(v41) = 0;
        do
        {
          LOBYTE(v41) = BYTE1(v36);
          BYTE1(v41) = BYTE1(v38);
          if ( !(byte_13B4E0[v41] & 8) )
          {
            LOBYTE(v40) = byte_10B4E0[v41];
            BYTE1(v41) = byte_12B4E0[v41];
            LOBYTE(v41) = byte_10AEE0[v40];
            LOBYTE(v41) = byte_F6EE0[v41];
            BYTE1(v41) = *v37;
            *v37 = byte_FAEE0[v41];
          }
          ++v37;
          LOWORD(v36) = v66 + v36;
          LOWORD(v38) = v67 + v38;
          --v39;
        }
        while ( v39 );
        v84 += dword_18062C;
        v82 += dword_18062C;
        v86 += 2;
        v85 -= v80;
        result = j - 1;
        v83 += v81;
      }
    }
    else
    {
      for ( k = v13; k; v83 += v81 )
      {
        v47 = v86[1];
        v42 = v85 + v47 * v66;
        v43 = (char *)(v47 + v84);
        v44 = v83 + v47 * v67;
        v64 = v47 + v82;
        v45 = *v86 - v86[1];
        v46 = 0;
        HIWORD(v47) = 0;
        do
        {
          LOBYTE(v47) = BYTE1(v42);
          BYTE1(v47) = BYTE1(v44);
          if ( byte_13B4E0[v47] & 8 )
          {
            v48 = 0;
          }
          else
          {
            LOBYTE(v46) = byte_10B4E0[v47];
            BYTE1(v47) = byte_12B4E0[v47];
            LOBYTE(v47) = byte_10AEE0[v46];
            v48 = byte_F6EE0[v47];
          }
          *v43++ = v48;
          LOWORD(v42) = v66 + v42;
          LOWORD(v44) = v67 + v44;
          --v45;
        }
        while ( v45 );
        v84 += dword_18062C;
        v82 += dword_18062C;
        v86 += 2;
        result = v81;
        v85 -= v80;
        --k;
      }
    }
  }
  else if ( a10 )
  {
    for ( l = v13; l; --l )
    {
      v49 = v86[1];
      v50 = v85 + v49 * v66;
      v51 = (_BYTE *)(v49 + v84);
      v64 = v49 + v82;
      v52 = v83 + v49 * v67;
      v53 = *v86 - v86[1];
      v54 = 0;
      HIWORD(v55) = 0;
      do
      {
        LOBYTE(v55) = BYTE1(v50);
        BYTE1(v55) = BYTE1(v52);
        LOBYTE(v54) = byte_10B4E0[v55];
        BYTE1(v55) = byte_12B4E0[v55];
        LOBYTE(v55) = byte_10AEE0[v54];
        *v51++ = byte_F6EE0[v55];
        v50 += v66;
        v52 += v67;
        --v53;
      }
      while ( v53 );
      v84 += dword_18062C;
      v82 += dword_18062C;
      v86 += 2;
      v85 -= v80;
      result = l - 1;
      v83 += v81;
    }
  }
  else
  {
    for ( m = v13; m; v83 += v81 )
    {
      v61 = v86[1];
      v56 = v85 + v61 * v66;
      v57 = (char *)(v61 + v84);
      v58 = v83 + v61 * v67;
      v64 = v61 + v82;
      v59 = *v86 - v86[1];
      v60 = 0;
      HIWORD(v61) = 0;
      do
      {
        LOBYTE(v61) = BYTE1(v56);
        BYTE1(v61) = BYTE1(v58);
        LOBYTE(v60) = byte_10B4E0[v61];
        BYTE1(v61) = byte_12B4E0[v61];
        LOBYTE(v61) = byte_10AEE0[v60];
        LOBYTE(v61) = byte_F6EE0[v61];
        BYTE1(v61) = *v57;
        v62 = byte_FAEE0[v61];
        *v57 = v62;
        v63 = (char *)_InterlockedExchange(&v64, (signed __int32)(v57 + 1));
        *v63 = v62;
        v57 = (char *)_InterlockedExchange(&v64, (signed __int32)(v63 + 1));
        v56 += v66;
        v58 += v67;
        --v59;
      }
      while ( v59 );
      v84 += dword_18062C;
      v82 += dword_18062C;
      v86 += 2;
      result = v81;
      v85 -= v80;
      --m;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// E9C3C: using guessed type int dword_E9C3C;
// F4960: using guessed type __int16 word_F4960[];
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (00063C90) --------------------------------------------------------
int __cdecl sub_63C90(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10)
{
  int v10; // ebx
  int v11; // edx
  int v12; // edi
  int v13; // ecx
  _BOOL1 v14; // al
  __int16 *v15; // ebx
  int v16; // edx
  __int16 *v17; // esi
  int v18; // ebx
  int v19; // ST00_4
  int v20; // ebx
  int v21; // esi
  int v22; // eax
  int v23; // eax
  int v24; // edx
  int result; // eax
  int v26; // ebx
  int v27; // ecx
  char *v28; // edi
  int v29; // esi
  int v30; // eax
  int v31; // edx
  char v32; // al
  int v33; // ebx
  int v34; // ecx
  _BYTE *v35; // edi
  int v36; // esi
  int v37; // eax
  int v38; // edx
  int v39; // ebx
  int v40; // ecx
  char *v41; // edi
  int v42; // esi
  int v43; // eax
  int v44; // edx
  char v45; // al
  int v46; // ebx
  int v47; // ecx
  _BYTE *v48; // edi
  int v49; // esi
  int v50; // eax
  int v51; // edx
  int v52; // ebx
  int v53; // ecx
  _BYTE *v54; // edi
  int v55; // esi
  int v56; // eax
  int v57; // edx
  int v58; // [esp+4h] [ebp-50h]
  int v59; // [esp+8h] [ebp-4Ch]
  int v60; // [esp+14h] [ebp-40h]
  int m; // [esp+18h] [ebp-3Ch]
  int l; // [esp+1Ch] [ebp-38h]
  int k; // [esp+20h] [ebp-34h]
  int v64; // [esp+24h] [ebp-30h]
  int i; // [esp+28h] [ebp-2Ch]
  int j; // [esp+2Ch] [ebp-28h]
  int v67; // [esp+30h] [ebp-24h]
  __int16 *v68; // [esp+34h] [ebp-20h]
  int v69; // [esp+38h] [ebp-1Ch]
  int v70; // [esp+3Ch] [ebp-18h]
  int v71; // [esp+40h] [ebp-14h]
  int v72; // [esp+44h] [ebp-10h]
  int v73; // [esp+48h] [ebp-Ch]
  __int16 *v74; // [esp+4Ch] [ebp-8h]
  _BOOL1 v75; // [esp+50h] [ebp-4h]

  v10 = a1;
  v11 = a2;
  v12 = a5;
  v13 = a6;
  v14 = !*(_BYTE *)(dword_D41A0 + 8600) && *(_BYTE *)(dword_D41A0 + 196308) != 2;
  v75 = v14;
  if ( word_180660 & 1 )
  {
    v10 = a1 >> 1;
    v11 = a2 >> 1;
    v12 = a5 >> 1;
    v13 = a6 >> 1;
    a8 *= 2;
  }
  v60 = dword_18062C * v11 + v10 + dword_180628;
  if ( a10 )
  {
    v15 = word_F4960;
    v16 = v13;
    while ( v16 )
    {
      v15 += 2;
      *(v15 - 1) = 0;
      --v16;
      *(v15 - 2) = v12;
    }
  }
  else
  {
    v67 = v13 / 2;
    v17 = &word_F4960[2 * (v13 / 2)];
    v68 = v17 - 2;
    v64 = 0;
    v18 = v12 >> 1;
    while ( v67 )
    {
      v19 = v18 * (unsigned __int8)byte_10B1E0[v64 >> 16] >> 8;
      *v17 = v18 + v19;
      *v68 = v18 + v19;
      v17[1] = v18 - v19;
      v68[1] = v18 - v19;
      v68 -= 2;
      v17 += 2;
      v64 += 0x1000000 / (v13 >> 1);
      --v67;
    }
  }
  v20 = a7 & 0x7FF;
  v21 = v13 * (a8 * dword_DB750[v20] >> 16);
  v22 = a8 * (signed int)off_DBF50[v20] >> 16;
  v70 = a8 * dword_DB750[v20] >> 16;
  v69 = v22;
  v59 = v21 / v12;
  v23 = v13 * v22;
  v58 = v23 / v12;
  v72 = a3 - (v12 * (v23 / v12) - v21) / 2;
  v74 = word_F4960;
  v24 = a4 - (v23 + v12 * (v21 / v12)) / 2;
  result = v60;
  v73 = v24;
  v71 = v60;
  if ( byte_D41B6 )
  {
    if ( a10 )
    {
      for ( i = v13; i; v73 += v69 )
      {
        v31 = v74[1];
        v26 = v72 + v31 * v58;
        v27 = v73 + v31 * v59;
        v28 = (char *)(v31 + v71);
        v29 = *v74 - v31;
        v30 = 0;
        HIWORD(v31) = 0;
        do
        {
          LOBYTE(v31) = BYTE1(v26);
          BYTE1(v31) = BYTE1(v27);
          v32 = 0;
          if ( !(byte_13B4E0[v31] & 8) )
          {
            LOBYTE(v30) = byte_10B4E0[v31];
            BYTE1(v31) = byte_12B4E0[v31];
            LOBYTE(v31) = byte_10AEE0[v30];
            v32 = byte_F6EE0[v31];
          }
          *v28++ = v32;
          LOWORD(v26) = v58 + v26;
          LOWORD(v27) = v59 + v27;
          --v29;
        }
        while ( v29 );
        v71 += dword_18062C;
        v74 += 2;
        result = v69;
        --i;
        v72 -= v70;
      }
    }
    else if ( v75 )
    {
      for ( j = v13; j; v73 += v69 )
      {
        v38 = v74[1];
        v33 = v72 + v38 * v58;
        v34 = v73 + v38 * v59;
        v35 = (_BYTE *)(v38 + v71);
        v36 = *v74 - v38;
        v37 = 0;
        HIWORD(v38) = 0;
        do
        {
          LOBYTE(v38) = BYTE1(v33);
          BYTE1(v38) = BYTE1(v34);
          if ( !(byte_13B4E0[v38] & 8) )
          {
            LOBYTE(v37) = byte_10B4E0[v38];
            BYTE1(v38) = byte_12B4E0[v38];
            LOBYTE(v38) = byte_10AEE0[v37];
            LOBYTE(v38) = byte_F6EE0[v38];
            BYTE1(v38) = *v35;
            *v35 = byte_FAEE0[v38];
          }
          ++v35;
          LOWORD(v33) = v58 + v33;
          LOWORD(v34) = v59 + v34;
          --v36;
        }
        while ( v36 );
        v71 += dword_18062C;
        v74 += 2;
        result = v69;
        --j;
        v72 -= v70;
      }
    }
    else
    {
      for ( k = v13; k; v73 += v69 )
      {
        v44 = v74[1];
        v39 = v72 + v44 * v58;
        v40 = v73 + v44 * v59;
        v41 = (char *)(v44 + v71);
        v42 = *v74 - v44;
        v43 = 0;
        HIWORD(v44) = 0;
        do
        {
          LOBYTE(v44) = BYTE1(v39);
          BYTE1(v44) = BYTE1(v40);
          if ( byte_13B4E0[v44] & 8 )
          {
            v45 = 0;
          }
          else
          {
            LOBYTE(v43) = byte_10B4E0[v44];
            BYTE1(v44) = byte_12B4E0[v44];
            LOBYTE(v44) = byte_10AEE0[v43];
            v45 = byte_F6EE0[v44];
          }
          *v41++ = v45;
          LOWORD(v39) = v58 + v39;
          LOWORD(v40) = v59 + v40;
          --v42;
        }
        while ( v42 );
        v71 += dword_18062C;
        v74 += 2;
        result = v69;
        --k;
        v72 -= v70;
      }
    }
  }
  else if ( a10 )
  {
    for ( l = v13; l; v73 += v69 )
    {
      v51 = v74[1];
      v46 = v72 + v51 * v58;
      v47 = v73 + v51 * v59;
      v48 = (_BYTE *)(v51 + v71);
      v49 = *v74 - v51;
      v50 = 0;
      HIWORD(v51) = 0;
      do
      {
        LOBYTE(v51) = BYTE1(v46);
        BYTE1(v51) = BYTE1(v47);
        LOBYTE(v50) = byte_10B4E0[v51];
        BYTE1(v51) = byte_12B4E0[v51];
        LOBYTE(v51) = byte_10AEE0[v50];
        *v48++ = byte_F6EE0[v51];
        v46 += v58;
        v47 += v59;
        --v49;
      }
      while ( v49 );
      v71 += dword_18062C;
      v74 += 2;
      result = v69;
      --l;
      v72 -= v70;
    }
  }
  else
  {
    for ( m = v13; m; v73 += v69 )
    {
      v57 = v74[1];
      v52 = v72 + v57 * v58;
      v53 = v73 + v57 * v59;
      v54 = (_BYTE *)(v57 + v71);
      v55 = *v74 - v57;
      v56 = 0;
      HIWORD(v57) = 0;
      do
      {
        LOBYTE(v57) = BYTE1(v52);
        BYTE1(v57) = BYTE1(v53);
        LOBYTE(v56) = byte_10B4E0[v57];
        BYTE1(v57) = byte_12B4E0[v57];
        LOBYTE(v57) = byte_10AEE0[v56];
        LOBYTE(v57) = byte_F6EE0[v57];
        BYTE1(v57) = *v54;
        *v54++ = byte_FAEE0[v57];
        v52 += v58;
        v53 += v59;
        --v55;
      }
      while ( v55 );
      v71 += dword_18062C;
      v74 += 2;
      result = v69;
      --m;
      v72 -= v70;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// F4960: using guessed type __int16 word_F4960[];
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (000644F0) --------------------------------------------------------
char __cdecl sub_644F0(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8)
{
  signed int v8; // ebx
  __int64 v9; // rtt
  int v10; // edi
  int v11; // edx
  int v12; // eax
  __int16 v13; // ST10_2
  char v14; // dl
  unsigned int i; // eax
  _WORD *v16; // eax
  char *v17; // esi
  int v18; // edx
  signed int v19; // eax
  signed int v20; // eax
  int v21; // ebx
  int v22; // ecx
  int v23; // ebx
  int v24; // ecx
  int v25; // esi
  signed int v26; // edx
  int v27; // ecx
  void (__noreturn *v28)(); // ebx
  int v29; // eax
  unsigned __int8 v30; // cl
  signed int v31; // ebx
  int v32; // eax
  int v33; // edi
  unsigned __int8 v34; // bl
  int *v36; // [esp-4h] [ebp-BEh]
  int v37; // [esp+0h] [ebp-BAh]
  int v38[5]; // [esp+4h] [ebp-B6h]
  int v39; // [esp+18h] [ebp-A2h]
  int v40; // [esp+1Ch] [ebp-9Eh]
  int v41; // [esp+30h] [ebp-8Ah]
  int v42; // [esp+34h] [ebp-86h]
  int v43; // [esp+48h] [ebp-72h]
  int v44; // [esp+4Ch] [ebp-6Eh]
  int v45; // [esp+60h] [ebp-5Ah]
  int v46; // [esp+64h] [ebp-56h]
  int v47; // [esp+78h] [ebp-42h]
  int v48; // [esp+7Ch] [ebp-3Eh]
  int v49; // [esp+90h] [ebp-2Ah]
  int v50; // [esp+94h] [ebp-26h]
  int v51; // [esp+A8h] [ebp-12h]
  __int16 v52; // [esp+ACh] [ebp-Eh]
  int v53; // [esp+AEh] [ebp-Ch]
  int v54; // [esp+B2h] [ebp-8h]
  int v55; // [esp+B6h] [ebp-4h]
  int v56; // [esp+BAh] [ebp+0h]
  int v57; // [esp+BEh] [ebp+4h]
  int v58; // [esp+C2h] [ebp+8h]
  int v59; // [esp+C6h] [ebp+Ch]
  int v60; // [esp+CAh] [ebp+10h]
  int v61; // [esp+CEh] [ebp+14h]
  __int16 v62; // [esp+D2h] [ebp+18h]
  __int16 v63; // [esp+D4h] [ebp+1Ah]
  char v64; // [esp+D6h] [ebp+1Ch]
  int v65; // [esp+D8h] [ebp+1Eh]
  __int16 v66; // [esp+DCh] [ebp+22h]
  int v67; // [esp+E0h] [ebp+26h]
  __int16 v68; // [esp+E4h] [ebp+2Ah]
  int v69; // [esp+E8h] [ebp+2Eh]
  int v70; // [esp+ECh] [ebp+32h]
  int v71; // [esp+F0h] [ebp+36h]
  int v72; // [esp+F4h] [ebp+3Ah]
  int v73; // [esp+F8h] [ebp+3Eh]
  int v74; // [esp+FCh] [ebp+42h]
  int v75; // [esp+100h] [ebp+46h]
  int v76; // [esp+104h] [ebp+4Ah]
  int v77; // [esp+108h] [ebp+4Eh]
  int v78; // [esp+10Ch] [ebp+52h]
  int v79; // [esp+110h] [ebp+56h]
  unsigned __int8 j; // [esp+114h] [ebp+5Ah]
  char v81; // [esp+118h] [ebp+5Eh]
  int v82; // [esp+148h] [ebp+8Eh]
  int v83; // [esp+14Ch] [ebp+92h]

  v8 = 0x1000000;
  v81 = 0;
  if ( word_180660 & 1 )
  {
    a1 >>= 1;
    a2 >>= 1;
    a5 >>= 1;
    a6 >>= 1;
    a8 *= 2;
  }
  v53 = dword_18062C * a2 + dword_180628 + a1;
  LODWORD(v9) = sub_10000;
  HIDWORD(v9) = (signed int)sub_10000 >> 31;
  v83 = v9 / a8;
  v56 = a3;
  v57 = a4;
  v58 = a5;
  v59 = a6;
  v60 = a5 / 2;
  v10 = a7 & 0x7FF;
  v11 = v83 * dword_DB750[v10];
  v61 = a6 / 2;
  v12 = v83 * (signed int)off_DBF50[v10] >> 16;
  v55 = -v11 >> 16;
  v54 = v12;
  v82 = a7 & 0x7FF;
  v13 = *(_WORD *)(dword_D41A0 + 12);
  v75 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  LOBYTE(i) = sub_595C0(v13);
  v14 = i;
  LOBYTE(i) = i + 3;
  switch ( (_BYTE)i )
  {
    case 0:
    case 1:
    case 2:
      if ( v14 == -3 )
      {
        for ( i = *(_DWORD *)(dword_D41A4 + 38535); ; i = *(_DWORD *)v72 )
        {
          v72 = i;
          if ( i <= dword_EA3E4[0] )
            break;
          LOBYTE(i) = v72;
          if ( *(_BYTE *)(v72 + 64) == 31 )
          {
            v81 = 1;
            break;
          }
        }
      }
      else
      {
        for ( i = *(_DWORD *)(dword_D41A4 + 38535); ; i = *(_DWORD *)v72 )
        {
          v72 = i;
          if ( i <= dword_EA3E4[0] )
            break;
          LOBYTE(i) = v72;
          if ( *(_BYTE *)(v72 + 64) == 12 )
          {
            v81 = 1;
            break;
          }
        }
      }
      if ( v81 )
      {
        v36 = &v67;
        v16 = (_WORD *)(v75 + 76);
        v17 = (char *)(v72 + 76);
        goto LABEL_47;
      }
      break;
    case 4:
    case 5:
      LOBYTE(i) = sub_59610(&v72, *(_WORD *)(dword_D41A0 + 12));
      if ( (_BYTE)i )
      {
        v64 = byte_E9800;
        v51 = *(_DWORD *)(v72 + 76);
        v52 = *(_WORD *)(v72 + 80);
        if ( sub_64CE0((int)&v51) )
          sub_885E0(v72, v62, v63, 0x52u);
        v36 = (int *)(v72 + 76);
        v17 = (char *)(v72 + 76);
        v16 = (_WORD *)(v75 + 76);
        v81 = 1;
        goto LABEL_47;
      }
      break;
    case 8:
      LOBYTE(i) = sub_596C0(&v65, *(_WORD *)(dword_D41A0 + 12));
      if ( (_BYTE)i )
      {
        v64 = byte_E98F0;
        v51 = v65;
        v52 = v66;
        if ( sub_64CE0((int)&v51) )
          sub_885E0(0, v62, v63, 0x51u);
        v36 = &v65;
        v17 = (char *)&v65;
        v16 = (_WORD *)(v75 + 76);
        v81 = 1;
LABEL_47:
        v67 = *(_DWORD *)v17;
        v68 = *((_WORD *)v17 + 2);
        i = sub_58490(v16, v36);
        v8 = i;
      }
      break;
    case 0xA:
      v18 = *(_DWORD *)(dword_D41A0
                      + 10 * (unsigned __int8)byte_3659D[11 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0]
                      + 222546);
      v64 = byte_E9800;
      for ( i = *(_DWORD *)(dword_D41A4 + 4 * v18 + 38403); ; i = *(_DWORD *)v72 )
      {
        v72 = i;
        if ( i <= dword_EA3E4[0] )
          break;
        v51 = *(_DWORD *)(v72 + 76);
        v52 = *(_WORD *)(v72 + 80);
        if ( sub_64CE0((int)&v51) )
          sub_885E0(v72, v62, v63, 0x52u);
        v19 = sub_58490((_WORD *)(v75 + 76), (_WORD *)(v72 + 76));
        if ( v19 < v8 )
        {
          v81 = 1;
          v8 = v19;
          v67 = *(_DWORD *)(v72 + 76);
          v68 = *(_WORD *)(v72 + 80);
        }
      }
      break;
    case 0xC:
      v64 = byte_E9800;
      v76 = *(_DWORD *)(dword_D41A0
                      + 10 * (unsigned __int8)byte_3659D[11 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0]
                      + 222546);
      for ( i = *(_DWORD *)(dword_D41A4 + 38527); ; i = *(_DWORD *)v72 )
      {
        v72 = i;
        if ( i <= dword_EA3E4[0] )
          break;
        v79 = v76;
        for ( j = 0; v79 && j < 8u; ++j )
        {
          if ( *(char *)(v72 + 70) == v79 )
          {
            v51 = *(_DWORD *)(v72 + 76);
            v52 = *(_WORD *)(v72 + 80);
            if ( sub_64CE0((int)&v51) )
              sub_885E0(v72, v62, v63, 0x52u);
            v20 = sub_58490((_WORD *)(v75 + 76), (_WORD *)(v72 + 76));
            if ( v20 < v8 )
            {
              v8 = v20;
              v81 = 1;
              v67 = *(_DWORD *)(v72 + 76);
              v68 = *(_WORD *)(v72 + 80);
            }
          }
          v79 = (unsigned __int8)byte_D93C3[4 * v79];
        }
      }
      break;
    default:
      break;
  }
  if ( v81 )
  {
    LOBYTE(i) = dword_D41A4;
    if ( *(_BYTE *)(dword_D41A4 + 26) & 0x40 )
    {
      if ( *(_BYTE *)(dword_D41A4 + 127) )
      {
        v21 = v8 - 512;
        LOWORD(v78) = sub_581E0((_WORD *)(v75 + 76), &v67);
        v78 = (unsigned __int16)v78;
        if ( v21 > 15872 )
          LOWORD(v21) = 15872;
        v67 = *(_DWORD *)(v75 + 76);
        v68 = *(_WORD *)(v75 + 80);
        sub_57FA0(&v67, v78, 0, v21);
        v22 = v83 * dword_DB750[v82];
        v23 = v83 * (_DWORD)off_DBF50[v82];
        v71 = (signed __int16)(v67 - a3);
        v23 >>= 16;
        v24 = -v22 >> 16;
        v25 = a5 / 2 + ((v23 * v71 - v24 * (signed __int16)(HIWORD(v67) - a4)) >> 16);
        v40 = 13;
        v42 = 13;
        v44 = 13;
        v50 = 13;
        v39 = 9;
        v77 = a6 / 2 + ((v71 * v24 + (signed __int16)(HIWORD(v67) - a4) * v23) >> 16);
        v37 = 0;
        v38[0] = 0;
        v41 = -9;
        v47 = -4;
        v49 = -4;
        v46 = 23;
        v48 = 23;
        v43 = 4;
        v45 = 4;
        v26 = 1;
        v78 = ((_WORD)v78 - (_WORD)v82) & 0x7FF;
        v27 = dword_DB750[v78];
        v28 = off_DBF50[v78];
        while ( v26 < 7 )
        {
          v29 = 3 * v26;
          v70 = 16 * *(&v37 + 6 * v26);
          v69 = 16 * v38[6 * v26];
          *(&v37 + 2 * v29) = ((signed int)v28 * v70 - v27 * v69) >> 20;
          v73 = v27 * v70;
          v74 = (_DWORD)v28 * v69;
          ++v26;
          v38[2 * v29] = ((signed int)v28 * v69 + v27 * v70) >> 20;
        }
        if ( word_180660 & 1 )
        {
          v25 *= 2;
          v77 *= 2;
        }
        v30 = byte_E9800;
        v31 = 0;
        while ( v31 < 7 )
        {
          v32 = 3 * v31;
          *(&v37 + 2 * v32) = v25 + a1 + *(&v37 + 6 * v31);
          v33 = v38[6 * v31++];
          v38[2 * v32] = v77 + a2 + v33;
        }
        v34 = v30;
        sub_2BD10(v37, v38[0], v39, v40, v30);
        sub_2BD10(v39, v40, v43, v44, v34);
        sub_2BD10(v43, v44, v45, v46, v34);
        sub_2BD10(v45, v46, v47, v48, v34);
        sub_2BD10(v47, v48, v49, v50, v34);
        sub_2BD10(v49, v50, v41, v42, v34);
        LOBYTE(i) = sub_2BD10(v41, v42, v37, v38[0], v34);
      }
    }
  }
  return i;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// E9800: using guessed type char byte_E9800;
// E98F0: using guessed type char byte_E98F0;
// EA3E4: using guessed type int dword_EA3E4[];
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;
// 644F0: using guessed type int var_118[5];

//----- (00064CE0) --------------------------------------------------------
char __cdecl sub_64CE0(int a1)
{
  int v1; // ecx
  int v2; // esi
  char v3; // ah
  int v4; // ebx
  char v5; // al
  int v6; // ecx
  int v7; // esi
  int v8; // ecx
  int v9; // ebx
  _BYTE *v10; // edx
  _BYTE *v11; // edx
  _BYTE *v12; // edx
  _BYTE *v13; // edx
  _BYTE *v14; // edx
  _BYTE *v15; // edx

  v1 = (signed __int16)(*(_WORD *)a1 - *(_WORD *)(a1 + 18));
  v2 = (signed __int16)(*(_WORD *)(a1 + 2) - *(_WORD *)(a1 + 22));
  v3 = 0;
  v4 = *(_DWORD *)(a1 + 34) + ((v1 * *(_DWORD *)(a1 + 10) - v2 * *(_DWORD *)(a1 + 14)) >> 16);
  v5 = *(_BYTE *)(a1 + 46);
  if ( v4 >= 0 && v4 < *(_DWORD *)(a1 + 26) )
  {
    v6 = *(_DWORD *)(a1 + 38) + ((*(_DWORD *)(a1 + 10) * v2 + *(_DWORD *)(a1 + 14) * v1) >> 16);
    if ( v6 >= 3 && v6 < *(_DWORD *)(a1 + 30) - 3 && v4 >= word_F4962[2 * v6] + 3 && v4 < word_F4960[2 * v6] - 3 )
    {
      *(_WORD *)(a1 + 42) = v4;
      *(_WORD *)(a1 + 44) = v6;
      v3 = 1;
      if ( !(*(_BYTE *)(dword_D41A4 + 26) & 3) )
      {
        v7 = dword_18062C;
        v8 = dword_18062C * (v6 - 1);
        v9 = v4 - 1;
        v10 = (_BYTE *)(v8 + v9 + dword_180628);
        *v10 = v5;
        v10[1] = v5;
        v10[2] = v5;
        v11 = &v10[v7];
        *v11 = v5;
        v11[2] = v5;
        v12 = &v11[v7];
        *v12 = v5;
        v12[1] = v5;
        v12[2] = v5;
        if ( 1 == *(_BYTE *)(dword_D41A0 + 8592) )
        {
          v13 = (_BYTE *)(v8 + v9 + dword_E9C3C);
          *v13 = v5;
          v13[1] = v5;
          v13[2] = v5;
          v14 = &v13[v7];
          *v14 = v5;
          v14[2] = v5;
          v15 = &v14[v7];
          *v15 = v5;
          v15[1] = v5;
          v15[2] = v5;
        }
      }
    }
  }
  return v3;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E9C3C: using guessed type int dword_E9C3C;
// F4960: using guessed type __int16 word_F4960[];
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;

//----- (00064E20) --------------------------------------------------------
int (*__cdecl sub_64E20(int a1))()
{
  __int16 v1; // dx
  int v2; // edx
  int v3; // eax
  int v4; // ecx
  int v5; // esi
  __int64 v6; // rax
  __int16 v7; // di
  unsigned int v8; // edx
  int v9; // esi
  int (*result)(); // eax
  int v11; // eax

  v1 = *(_WORD *)(a1 + 98);
  *(_BYTE *)(a1 + 14) |= 2u;
  if ( v1 )
  {
    v2 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 94);
    *(_DWORD *)(a1 + 8) = v2;
    if ( v2 < 0 )
    {
      v3 = sub_4A190(a1 + 76, 10, 6);
      v4 = v3;
      v5 = v3;
      if ( v3 )
      {
        *(_WORD *)(v3 + 26) = *(_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 98)] + 26);
        v6 = 3 * *(signed __int16 *)(a1 + 88);
        v7 = *(_WORD *)(v4 + 80);
        *(_WORD *)(v4 + 44) = (signed int)(v6 - (__CFSHL__(HIDWORD(v6), 2) + 4 * HIDWORD(v6))) >> 2;
        if ( v7 <= 128 )
          *(_WORD *)(v4 + 80) = 0;
        else
          *(_WORD *)(v4 + 80) = v7 - 128;
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v8 = *(unsigned __int16 *)(a1 + 20) % 0x3Cu + 130;
        *(_DWORD *)(v5 + 8) = v8;
        v9 = *(_DWORD *)(a1 + 12);
        *(_DWORD *)(a1 + 8) = v8;
        *(_DWORD *)(a1 + 12) = v9 & 0xFFFDFFF7;
        LOBYTE(v8) = *(_BYTE *)(a1 + 14);
        *(_BYTE *)(a1 + 69) = 1;
        *(_BYTE *)(a1 + 14) = v8 | 2;
        sub_57D40(a1, a1 + 76);
      }
    }
    *(_WORD *)(a1 + 98) = 0;
  }
  *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
  result = sub_104D0((signed __int16 *)(a1 + 76));
  if ( result == (int (*)())1 )
  {
    v11 = sub_4A190(a1 + 76, 10, 5);
    if ( v11 )
      *(_WORD *)(v11 + 26) = *(_WORD *)(a1 + 26);
    result = (int (*)())sub_57F10(a1);
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00064F60) --------------------------------------------------------
int (*__cdecl sub_64F60(int a1))()
{
  int v1; // edx
  unsigned __int16 v2; // si
  int (*result)(); // eax
  int v4; // eax

  v1 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v1;
  if ( v1 < 60 )
  {
    v2 = *(_WORD *)(a1 + 90);
    *(_BYTE *)(a1 + 69) = 2;
    if ( v2 >= 0x53u )
    {
      if ( v2 <= 0x53u )
      {
        sub_49DA0((_WORD *)a1, 226);
      }
      else if ( v2 == 84 )
      {
        sub_49DA0((_WORD *)a1, 227);
      }
    }
  }
  *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
  result = sub_104D0((signed __int16 *)(a1 + 76));
  if ( result == (int (*)())1 )
  {
    v4 = sub_4A190(a1 + 76, 10, 5);
    if ( v4 )
      *(_WORD *)(v4 + 26) = *(_WORD *)(a1 + 26);
    result = (int (*)())sub_57F10(a1);
  }
  return result;
}

//----- (00064FF0) --------------------------------------------------------
int (*__cdecl sub_64FF0(_WORD *a1))()
{
  int (*result)(); // eax
  int v2; // eax

  a1[40] = sub_10C40(a1 + 38);
  result = sub_104D0(a1 + 38);
  if ( result == (int (*)())1 )
  {
    v2 = sub_4A190((int)(a1 + 38), 10, 5);
    if ( v2 )
      *(_WORD *)(v2 + 26) = a1[13];
    result = (int (*)())sub_57F10((int)a1);
  }
  return result;
}

//----- (00065040) --------------------------------------------------------
int __cdecl sub_65040(int a1)
{
  int result; // eax

  *(_BYTE *)(a1 + 14) |= 2u;
  result = sub_10C40((__int16 *)(a1 + 76));
  *(_WORD *)(a1 + 80) = result;
  return result;
}

//----- (00065080) --------------------------------------------------------
int __cdecl sub_65080(int a1)
{
  unsigned __int16 v1; // di
  int v2; // esi
  int v3; // ebx
  int result; // eax

  v1 = 0;
  v2 = dword_D41A0 + 11230;
  while ( v1 < *(_WORD *)(dword_D41A0 + 14) )
  {
    v3 = dword_EA3E4[*(unsigned __int16 *)(v2 + 10)];
    if ( *(_DWORD *)(v3 + 8) >= 0 && sub_106C0(v3, a1) )
      *(_BYTE *)(v3 + 13) |= 0x10u;
    v2 += 2124;
    ++v1;
  }
  result = sub_10C40((__int16 *)(a1 + 76));
  *(_WORD *)(a1 + 80) = result;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00065110) --------------------------------------------------------
int __cdecl sub_65110(int a1)
{
  int result; // eax

  *(_BYTE *)(a1 + 14) |= 2u;
  result = sub_10C40((__int16 *)(a1 + 76));
  *(_WORD *)(a1 + 80) = result;
  return result;
}

//----- (000651B0) --------------------------------------------------------
int (*__cdecl sub_651B0(int a1))()
{
  __int16 v1; // dx
  int v2; // edx
  __int16 v3; // ax
  char v4; // dl
  int (*result)(); // eax

  v1 = *(_WORD *)(a1 + 98);
  *(_BYTE *)(a1 + 14) |= 2u;
  if ( v1 )
  {
    v2 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 94);
    *(_DWORD *)(a1 + 8) = v2;
    if ( v2 < 0 )
    {
      v3 = *(_WORD *)(a1 + 90);
      *(_WORD *)(a1 + 98) = 0;
      v4 = *(_BYTE *)(a1 + 12);
      *(_BYTE *)(a1 + 69) = 19;
      *(_BYTE *)(a1 + 12) = v4 & 0xF7;
      sub_49DA0((_WORD *)a1, v3 + 4);
      sub_4A190(a1 + 76, 10, 13);
    }
    *(_WORD *)(a1 + 98) = 0;
  }
  *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
  result = sub_104D0((signed __int16 *)(a1 + 76));
  if ( result == (int (*)())1 )
    result = (int (*)())sub_57F10(a1);
  return result;
}

//----- (00065240) --------------------------------------------------------
int (*__cdecl sub_65240(int a1))()
{
  int (*result)(); // eax

  *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
  result = sub_104D0((signed __int16 *)(a1 + 76));
  if ( result == (int (*)())1 )
    result = (int (*)())sub_57F10(a1);
  return result;
}

//----- (00065280) --------------------------------------------------------
void __cdecl sub_65280(int a1)
{
  sub_652C0(a1);
}

//----- (000652A0) --------------------------------------------------------
void __cdecl sub_652A0(int a1)
{
  sub_652C0(a1);
}

//----- (000652C0) --------------------------------------------------------
void __cdecl sub_652C0(int a1)
{
  char v1; // ah
  __int16 v2; // dx
  __int16 v3; // cx
  __int16 v4; // di
  __int16 v5; // ax
  signed int v6; // esi
  signed int v7; // ecx
  signed int v8; // ecx
  __int16 v9; // ax
  unsigned int v10; // edx
  __int16 v11; // di
  __int16 v12; // ax
  int v13; // eax
  int v14; // edx

  v1 = *(_BYTE *)(a1 + 13);
  if ( v1 & 8 )
  {
    *(_BYTE *)(a1 + 13) = v1 & 0xF7;
  }
  else
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    if ( *(signed __int16 *)(a1 + 80) > (signed __int16)sub_10C40((__int16 *)(a1 + 76)) )
    {
      v2 = *(_WORD *)(a1 + 130);
      if ( v2 )
        sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, v2);
    }
    else
    {
      *(_WORD *)(a1 + 130) = 0;
      sub_654B0(&word_EB398, a1);
    }
    sub_57CF0(a1, (int)&word_EB398);
    v3 = *(_WORD *)(a1 + 130);
    if ( v3 )
      *(_WORD *)(a1 + 130) = v3 - 1;
    v4 = *(_WORD *)(a1 + 44) + *(_WORD *)(a1 + 80);
    v5 = *(_WORD *)(a1 + 44) - 24;
    *(_WORD *)(a1 + 44) = v5;
    *(_WORD *)(a1 + 80) = v4;
    if ( v5 < -192 )
      *(_WORD *)(a1 + 44) = -192;
    if ( *(_WORD *)(a1 + 44) > 192 )
      *(_WORD *)(a1 + 44) = 192;
    v6 = (signed __int16)sub_10C40((__int16 *)(a1 + 76));
    if ( *(signed __int16 *)(a1 + 80) <= v6 )
      *(_WORD *)(a1 + 80) = v6;
    if ( *(_WORD *)(a1 + 98) )
    {
      if ( *(signed __int16 *)(a1 + 80) <= v6 )
      {
        v7 = *(_DWORD *)(a1 + 94) >> 2;
        if ( v7 < 2 )
          v7 = 2;
        if ( v7 > 192 )
          v7 = 192;
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v8 = *(unsigned __int16 *)(a1 + 20) % (unsigned int)v7 + v7;
        v9 = 9377 * *(_WORD *)(a1 + 20);
        *(_WORD *)(a1 + 44) = v8;
        *(_WORD *)(a1 + 20) = v9 + 9439;
        v10 = *(unsigned __int16 *)(a1 + 20) % (unsigned int)(v8 >> 1);
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v11 = *(_WORD *)(a1 + 80);
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 20) & 0x7FF;
        v12 = *(_WORD *)(a1 + 44);
        *(_WORD *)(a1 + 130) = v10 + 1;
        *(_WORD *)(a1 + 80) = v12 + v11;
      }
      v13 = *(_DWORD *)(a1 + 94);
      v14 = *(_DWORD *)(a1 + 8);
      *(_WORD *)(a1 + 98) = 0;
      *(_DWORD *)(a1 + 8) = v14 - v13;
    }
    if ( *(_DWORD *)(a1 + 8) < 0 )
    {
      sub_4A190(a1 + 76, 10, 13);
      goto LABEL_27;
    }
    if ( *(signed __int16 *)(a1 + 80) <= v6 && sub_104D0((signed __int16 *)(a1 + 76)) == (int (*)())1 )
    {
      sub_4A190(a1 + 76, 10, 5);
LABEL_27:
      sub_57F10(a1);
      return;
    }
  }
}
// EB398: using guessed type __int16 word_EB398;

//----- (000654B0) --------------------------------------------------------
int __cdecl sub_654B0(signed __int16 *a1, int a2)
{
  int result; // eax
  void (__noreturn *v3)(); // esi
  void (__noreturn *v4)(); // eax
  int v5; // [esp+0h] [ebp-1Ch]
  __int16 v6; // [esp+4h] [ebp-18h]
  int v7; // [esp+8h] [ebp-14h]
  __int16 v8; // [esp+Ch] [ebp-10h]
  int v9; // [esp+10h] [ebp-Ch]
  void (__noreturn *v10)(); // [esp+14h] [ebp-8h]
  int v11; // [esp+18h] [ebp-4h]

  result = sub_1B7A0(a1);
  if ( result > 20 )
  {
    v9 = 0;
    v5 = *(_DWORD *)a1;
    v6 = a1[2];
    result = *(unsigned __int16 *)(a2 + 28);
    v10 = sub_10000;
    while ( 1 )
    {
      v11 = result;
      if ( v9 >= 8 )
        break;
      v7 = *(_DWORD *)a1;
      v8 = a1[2];
      sub_57FA0(&v7, v11, 0, 64);
      v3 = v10;
      v4 = (void (__noreturn *)())(signed __int16)sub_10C40((__int16 *)&v7);
      if ( (signed __int16)v4 < (signed int)v3 )
      {
        v10 = v4;
        v5 = v7;
        v6 = v8;
      }
      result = ((_WORD)v11 + 256) & 0x7FF;
      ++v9;
    }
    *(_DWORD *)a1 = v5;
    a1[2] = v6;
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();

//----- (00065580) --------------------------------------------------------
int __cdecl sub_65580(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_BYTE *)(a1 + 64) != 2 )
    *(_WORD *)(a1 + 80) += *(_WORD *)(a1 + 82);
  return result;
}

//----- (000655A0) --------------------------------------------------------
int __cdecl sub_655A0(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_BYTE *)(a1 + 64) != 2 )
    *(_WORD *)(a1 + 80) -= *(_WORD *)(a1 + 82);
  return result;
}

//----- (000655C0) --------------------------------------------------------
int __cdecl sub_655C0(_WORD *a1, int a2)
{
  sub_65580(a2);
  a1[16] = sub_581E0(a1 + 38, (_WORD *)(a2 + 76));
  a1[17] = sub_58210(a1 + 38, (_WORD *)(a2 + 76));
  return sub_655A0(a2);
}

//----- (00065610) --------------------------------------------------------
int __cdecl sub_65610(int a1, int a2)
{
  int v2; // ebx
  __int16 v3; // ax
  int v4; // esi
  __int16 v5; // ax
  int v6; // esi
  __int16 v7; // ax

  v2 = a1;
  sub_65580(a2);
  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
  v3 = sub_58210((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
  v4 = *(_DWORD *)(a1 + 160);
  *(_WORD *)(a1 + 34) = v3;
  v5 = *(_WORD *)(v2 + 28)
     + sub_58350(*(_WORD *)(v2 + 28), *(_WORD *)(v2 + 32), *(unsigned __int16 *)(v4 + 4), *(_WORD *)(v4 + 2));
  HIBYTE(v5) &= 7u;
  v6 = *(_DWORD *)(a1 + 160);
  *(_WORD *)(a1 + 28) = v5;
  v7 = *(_WORD *)(v2 + 30)
     + sub_58350(*(_WORD *)(v2 + 30), *(_WORD *)(v2 + 34), *(unsigned __int16 *)(v6 + 8), *(_WORD *)(v6 + 6));
  HIBYTE(v7) &= 7u;
  *(_WORD *)(a1 + 30) = v7;
  return sub_655A0(a2);
}

//----- (000656D0) --------------------------------------------------------
__int16 __cdecl sub_656D0(int a1, int a2)
{
  int v2; // ebx
  __int16 v3; // ax
  int v4; // esi
  __int16 v5; // ax
  int v6; // esi
  __int16 result; // ax

  v2 = a1;
  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
  v3 = sub_58210((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
  v4 = *(_DWORD *)(a1 + 160);
  *(_WORD *)(a1 + 34) = v3;
  v5 = *(_WORD *)(v2 + 28)
     + sub_58350(*(_WORD *)(v2 + 28), *(_WORD *)(v2 + 32), *(unsigned __int16 *)(v4 + 4), *(_WORD *)(v4 + 2));
  HIBYTE(v5) &= 7u;
  v6 = *(_DWORD *)(a1 + 160);
  *(_WORD *)(a1 + 28) = v5;
  result = *(_WORD *)(v2 + 30)
         + sub_58350(*(_WORD *)(v2 + 30), *(_WORD *)(v2 + 34), *(unsigned __int16 *)(v6 + 8), *(_WORD *)(v6 + 6));
  HIBYTE(result) &= 7u;
  *(_WORD *)(a1 + 30) = result;
  return result;
}

//----- (00065780) --------------------------------------------------------
char __cdecl sub_65780(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // eax
  int v4; // ebx

  LOBYTE(v3) = *(_BYTE *)(a1 + 64);
  if ( (unsigned __int8)v3 < 0xCu )
  {
    if ( (unsigned __int8)v3 < 3u )
    {
      if ( (unsigned __int8)v3 > 1u )
        return v3;
    }
    else if ( (unsigned __int8)v3 > 3u && ((unsigned __int8)v3 < 7u || (unsigned __int8)v3 > 9u) )
    {
      return v3;
    }
  }
  else if ( (unsigned __int8)v3 > 0xCu )
  {
    if ( (unsigned __int8)v3 < 0x19u )
    {
      if ( (_BYTE)v3 != 17 )
        return v3;
    }
    else if ( (unsigned __int8)v3 > 0x19u && (_BYTE)v3 != 28 )
    {
      return v3;
    }
  }
  v3 = dword_EA3E4[*(signed __int16 *)(a1 + 26)];
  if ( *(_BYTE *)(v3 + 63) == 3 && !*(_BYTE *)(v3 + 64) )
  {
    ++*(_DWORD *)(*(_DWORD *)(v3 + 164) + 357);
    if ( a2 > dword_EA3E4[0] && a3 > dword_EA3E4[0] && *(_WORD *)(a2 + 26) == *(_WORD *)(a3 + 26) )
    {
      v4 = *(_DWORD *)(v3 + 164);
      if ( v4 )
        ++*(_DWORD *)(v4 + 361);
    }
  }
  return v3;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00065820) --------------------------------------------------------
int __cdecl sub_65820(int a1)
{
  unsigned int v1; // eax
  char v2; // dl
  signed __int16 v3; // ax
  int v4; // eax
  unsigned int v5; // esi
  __int16 v6; // ax
  __int16 v7; // cx
  char v8; // al
  int v9; // eax
  int v10; // edi
  int v11; // edi
  unsigned int v13; // [esp+0h] [ebp-8h]
  char v14; // [esp+4h] [ebp-4h]

  v14 = 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v13 = v1;
  if ( v1 <= dword_EA3E4[0] )
  {
    v2 = *(_BYTE *)(a1 + 12);
    if ( !(v2 & 2) )
    {
      *(_BYTE *)(a1 + 12) = v2 | 2;
      if ( sub_68940(a1) || sub_67CB0(a1) )
      {
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
      }
      else
      {
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 28);
        *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 30);
      }
    }
  }
  else
  {
    sub_65610(a1, v1);
  }
  v3 = *(_WORD *)(a1 + 132) - *(_WORD *)(a1 + 130);
  if ( *(signed __int16 *)(a1 + 132) != *(signed __int16 *)(a1 + 130) )
  {
    if ( *(signed __int16 *)(a1 + 132) - *(signed __int16 *)(a1 + 130) <= 0 )
      v3 = -1;
    else
      v3 = 1;
  }
  *(_WORD *)(a1 + 130) += 2 * v3;
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  sub_57CF0(a1, (int)&word_EB398);
  v4 = sub_10780(a1);
  v5 = v4;
  if ( v4 )
  {
    if ( *(_WORD *)(v4 + 12) & 0x8010 && sub_68740(a1, v4, 0x2Du, 22) )
      return 0;
    sub_65580(v5);
    sub_57CF0(a1, v5 + 76);
    sub_655A0(v5);
    v14 = 1;
    goto LABEL_29;
  }
  v6 = sub_10C40((__int16 *)(a1 + 76));
  v7 = *(_WORD *)(a1 + 80);
  word_EB39C = v6;
  if ( v6 > v7
    || byte_D41B6
    && (word_EB39C = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88), *(_WORD *)(a1 + 80) > word_EB39C) )
  {
    *(_WORD *)(a1 + 80) = word_EB39C;
    v8 = *(_BYTE *)(a1 + 64);
    if ( v8 != 4 && v8 != 22 && v8 != 24 && v8 != 26 && sub_104D0((signed __int16 *)(a1 + 76)) == (int (*)())1 )
    {
      v9 = sub_4A190(a1 + 76, 10, 5);
      if ( v9 )
        *(_WORD *)(v9 + 26) = *(_WORD *)(a1 + 26);
      sub_57F10(a1);
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  v10 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v10;
  if ( v10 < 0 )
LABEL_28:
    v14 = 1;
LABEL_29:
  if ( !v14 )
    return 0;
  if ( sub_68AC0(a1, v5) )
  {
    sub_57F10(a1);
    return 0;
  }
  v11 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
  if ( !v11 )
    return 0;
  sub_65780(a1, v5, v13);
  sub_686D0(a1, v5);
  if ( v5 > dword_EA3E4[0] && *(_WORD *)(a1 + 38) )
    sub_6D8B0(*(_WORD *)(a1 + 26), *(char *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 64), 1);
  if ( *(_BYTE *)(a1 + 68) == 34 )
    *(_DWORD *)(v11 + 8) = *(unsigned __int16 *)(a1 + 42);
  *(_WORD *)(v11 + 26) = *(_WORD *)(a1 + 26);
  *(_WORD *)(v11 + 28) = *(_WORD *)(a1 + 28);
  *(_WORD *)(v11 + 30) = *(_WORD *)(a1 + 30);
  if ( v5 )
    *(_WORD *)(v11 + 150) = (signed int)(v5 - (dword_D41A0 + 28302)) / 168;
  *(_WORD *)(v11 + 42) = *(_WORD *)(a1 + 42);
  *(_BYTE *)(v11 + 70) = *(_BYTE *)(a1 + 70);
  sub_57F10(a1);
  return v11;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00065B30) --------------------------------------------------------
int __cdecl sub_65B30(int a1)
{
  int result; // eax

  result = sub_65C20(a1);
  if ( result )
    result = sub_57F10(a1);
  return result;
}

//----- (00065B50) --------------------------------------------------------
int __cdecl sub_65B50(int a1)
{
  int result; // eax
  int v2; // esi
  __int16 v3; // bx
  __int16 v4; // dx
  int v5; // eax
  unsigned int i; // ebx
  char v7; // [esp+0h] [ebp-4h]

  v7 = 0;
  result = sub_65C20(a1);
  v2 = result;
  if ( result )
  {
    v3 = *(_WORD *)(a1 + 150);
    *(_DWORD *)(result + 4) = 30;
    *(_WORD *)(result + 150) = v3;
    v4 = *(_WORD *)(result + 26);
    *(_DWORD *)(result + 8) = *(_DWORD *)(result + 4);
    if ( v4 )
    {
      v5 = dword_EA3E4[v4];
      if ( *(_BYTE *)(v5 + 63) == 3
        && !*(_BYTE *)(v5 + 64)
        && *(_WORD *)(*(_DWORD *)(v5 + 164) + 56) == *(_WORD *)(dword_D41A0 + 12) )
      {
        v7 = 1;
      }
    }
    for ( i = dword_EA3E4[*(unsigned __int16 *)(v2 + 52)];
          i > dword_EA3E4[0];
          i = dword_EA3E4[*(unsigned __int16 *)(i + 52)] )
    {
      *(_WORD *)(i + 26) = *(_WORD *)(v2 + 26);
      if ( v7 )
        sub_49C90(i, 42);
    }
    result = sub_57F10(a1);
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00065C20) --------------------------------------------------------
int __cdecl sub_65C20(int a1)
{
  unsigned int v1; // eax
  char v2; // dl
  signed __int16 v3; // si
  __int16 v4; // dx
  __int16 v5; // ax
  signed __int16 v6; // si
  __int16 v7; // cx
  int v8; // eax
  unsigned int v9; // esi
  __int16 v11; // ax
  __int16 v12; // dx
  int v13; // eax
  int v14; // edi
  _WORD *v15; // edi
  int v16; // [esp+0h] [ebp-14h]
  __int16 v17; // [esp+4h] [ebp-10h]
  _WORD *v18; // [esp+8h] [ebp-Ch]
  unsigned int v19; // [esp+Ch] [ebp-8h]
  char v20; // [esp+10h] [ebp-4h]

  v20 = 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v18 = 0;
  v19 = v1;
  if ( v1 > dword_EA3E4[0] )
  {
    sub_65610(a1, v1);
    goto LABEL_18;
  }
  v2 = *(_BYTE *)(a1 + 12);
  if ( !(v2 & 2) )
  {
    *(_BYTE *)(a1 + 12) = v2 | 2;
    if ( sub_68940(a1) )
    {
      v6 = sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32));
      if ( v6 < 0 )
        v6 = 0;
      if ( v6 > 34 )
        v6 = 34;
      v7 = v6 * sub_582F0(*(unsigned __int16 *)(a1 + 28), *(_WORD *)(a1 + 32)) + *(_WORD *)(a1 + 28);
      v5 = *(_WORD *)(a1 + 34);
      *(_WORD *)(a1 + 28) = v7;
    }
    else
    {
      if ( !sub_67CB0(a1) )
      {
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 28);
        *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 30);
        goto LABEL_18;
      }
      v3 = sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32));
      if ( v3 < 0 )
        v3 = 0;
      if ( v3 > 34 )
        v3 = 34;
      v4 = v3 * sub_582F0(*(unsigned __int16 *)(a1 + 28), *(_WORD *)(a1 + 32)) + *(_WORD *)(a1 + 28);
      v5 = *(_WORD *)(a1 + 34);
      *(_WORD *)(a1 + 28) = v4;
    }
    *(_WORD *)(a1 + 30) = v5;
  }
LABEL_18:
  v16 = *(_DWORD *)(a1 + 76);
  v17 = *(_WORD *)(a1 + 80);
  *(_DWORD *)&word_EB398 = v16;
  *(&word_EB398 + 2) = v17;
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  sub_57CF0(a1, (int)&word_EB398);
  v8 = sub_10780(a1);
  v9 = v8;
  if ( !v8 )
  {
    v11 = sub_10C40((__int16 *)(a1 + 76));
    v12 = *(_WORD *)(a1 + 80);
    word_EB39C = v11;
    if ( v11 > v12
      || byte_D41B6
      && (word_EB39C = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88), *(_WORD *)(a1 + 80) > word_EB39C) )
    {
      v17 = word_EB39C;
      sub_57CF0(a1, (int)&v16);
      if ( *(_BYTE *)(a1 + 64) != 4 && sub_104D0((signed __int16 *)(a1 + 76)) == (int (*)())1 )
      {
        v13 = sub_4A190(a1 + 76, 10, 5);
        if ( v13 )
          *(_WORD *)(v13 + 26) = *(_WORD *)(a1 + 26);
        sub_57F10(a1);
        goto LABEL_35;
      }
    }
    else
    {
      v14 = *(_DWORD *)(a1 + 8) - 1;
      *(_DWORD *)(a1 + 8) = v14;
      if ( v14 >= 0 )
        goto LABEL_35;
    }
    v20 = 1;
    goto LABEL_35;
  }
  if ( *(_WORD *)(v8 + 12) & 0x8010 )
  {
    if ( sub_68740(a1, v8, 0x5Bu, 45) )
      return 0;
  }
  else
  {
    if ( *(_BYTE *)(*(_DWORD *)(v8 + 160) + 32) & 0x10 )
      *(_WORD *)(a1 + 42) = 1;
    sub_65580(v8);
    sub_57CF0(a1, v9 + 76);
    sub_655A0(v9);
    v20 = 1;
  }
LABEL_35:
  if ( v20 )
  {
    if ( sub_68AC0(a1, v9) )
    {
      sub_57F10(a1);
    }
    else
    {
      v18 = (_WORD *)sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
      if ( v18 )
      {
        sub_65780(a1, v9, v19);
        sub_686D0(a1, v9);
        if ( v9 > dword_EA3E4[0] )
          sub_6D8B0(*(_WORD *)(a1 + 26), 0, 1);
        v15 = v18;
        v18[21] = *(_WORD *)(a1 + 42);
        v15[13] = *(_WORD *)(a1 + 26);
        v15[14] = *(_WORD *)(a1 + 28);
        v15[15] = *(_WORD *)(a1 + 30);
        if ( !v9 )
          *(_WORD *)(a1 + 150) = 0;
      }
    }
  }
  return (int)v18;
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00065F60) --------------------------------------------------------
__int16 __cdecl sub_65F60(int a1)
{
  unsigned int v1; // eax
  char v2; // dl
  __int16 v3; // ax
  __int16 v4; // ax
  int v5; // eax
  int v6; // esi
  unsigned int v7; // edi
  int v8; // eax
  signed __int16 v9; // dx
  signed __int16 v10; // cx
  int v11; // esi
  _WORD *v12; // esi
  unsigned int v14; // [esp+0h] [ebp-8h]
  char v15; // [esp+4h] [ebp-4h]

  v15 = 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v14 = v1;
  if ( v1 <= dword_EA3E4[0] )
  {
    v2 = *(_BYTE *)(a1 + 12);
    if ( !(v2 & 2) )
    {
      *(_BYTE *)(a1 + 12) = v2 | 2;
      if ( sub_67CB0(a1) )
      {
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
      }
    }
  }
  else
  {
    sub_65610(a1, v1);
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  v3 = sub_10C40(&word_EB398);
  if ( v3 > word_EB39C )
    word_EB39C = v3;
  if ( byte_D41B6 )
  {
    v4 = sub_10C60(&word_EB398) - *(_WORD *)(a1 + 88);
    if ( v4 < word_EB39C )
      word_EB39C = v4;
  }
  sub_57CF0(a1, (int)&word_EB398);
  v5 = sub_108B0(a1);
  v6 = v5;
  v7 = v5;
  if ( !v5 )
  {
    LOWORD(v8) = sub_10C40((__int16 *)(a1 + 76));
    v9 = *(_WORD *)(a1 + 80);
    word_EB39C = v8;
    if ( (signed __int16)v8 > v9
      || byte_D41B6
      && (LOWORD(v8) = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88),
          word_EB39C = v8,
          v10 = v8,
          LOWORD(v8) = *(_WORD *)(a1 + 80),
          (signed __int16)v8 > v10) )
    {
      LOWORD(v8) = word_EB39C;
      *(_WORD *)(a1 + 80) = word_EB39C;
    }
    else
    {
      v11 = *(_DWORD *)(a1 + 8) - 1;
      *(_DWORD *)(a1 + 8) = v11;
      if ( v11 >= 0 )
        goto LABEL_19;
    }
    v15 = 1;
    goto LABEL_19;
  }
  sub_65580(v5);
  sub_57CF0(a1, v6 + 76);
  LOWORD(v8) = sub_655A0(v6);
  v15 = 1;
LABEL_19:
  if ( v15 )
  {
    v8 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
    v12 = (_WORD *)v8;
    if ( v8 )
    {
      sub_65780(a1, v7, v14);
      if ( v7 > dword_EA3E4[0] )
        sub_6D8B0(*(_WORD *)(a1 + 26), 1u, 1);
      v12[13] = *(_WORD *)(a1 + 26);
      v12[14] = *(_WORD *)(a1 + 28);
      v12[15] = *(_WORD *)(a1 + 30);
      LOWORD(v8) = sub_57F10(a1);
    }
  }
  return v8;
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00066160) --------------------------------------------------------
int __cdecl sub_66160(int a1)
{
  int result; // eax

  result = sub_65820(a1);
  if ( result )
    *(_DWORD *)(result + 8) = *(char *)(a1 + 70);
  return result;
}

//----- (00066180) --------------------------------------------------------
int __cdecl sub_66180(int a1)
{
  int v1; // esi
  int result; // eax
  __int16 v3; // dx
  __int16 v4; // [esp+0h] [ebp-8h]
  __int16 v5; // [esp+2h] [ebp-6h]
  __int16 v6; // [esp+4h] [ebp-4h]

  result = sub_65820(a1);
  v1 = result;
  BYTE1(result) = *(_BYTE *)(a1 + 63);
  if ( BYTE1(result) )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v4 = *(_WORD *)(a1 + 20) % 0x81u + *(_WORD *)(a1 + 76) - 96 - 64;
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v5 = *(_WORD *)(a1 + 20) % 0x81u + *(_WORD *)(a1 + 78) - 96 - 64;
    v6 = *(_WORD *)(a1 + 80);
    result = sub_4A190((int)&v4, 10, 0);
    if ( result )
    {
      *(_DWORD *)(result + 12) |= (unsigned int)sub_10080;
      *(_WORD *)(result + 26) = *(_WORD *)(a1 + 26);
      v3 = *(_WORD *)(a1 + 28);
      *(_DWORD *)(result + 8) = 4;
      *(_BYTE *)(result + 92) = 3;
      *(_WORD *)(result + 28) = v3;
    }
    if ( v1 )
    {
      result = *(char *)(a1 + 70);
      *(_DWORD *)(v1 + 4) = result;
      *(_DWORD *)(v1 + 8) = result;
    }
  }
  return result;
}

//----- (00066250) --------------------------------------------------------
int __cdecl sub_66250(int a1)
{
  int result; // eax
  int v2; // edx

  result = sub_65820(a1);
  if ( result )
  {
    v2 = *(char *)(a1 + 70);
    *(_BYTE *)(result + 70) = 0;
    *(_DWORD *)(result + 4) = v2;
  }
  return result;
}

//----- (00066280) --------------------------------------------------------
int __cdecl sub_66280(int a1)
{
  int result; // eax

  result = sub_65820(a1);
  if ( result )
    *(_DWORD *)(result + 8) = *(char *)(a1 + 70);
  return result;
}

//----- (000662A0) --------------------------------------------------------
int __cdecl sub_662A0(int a1)
{
  return sub_65820(a1);
}

//----- (000662C0) --------------------------------------------------------
char __cdecl sub_662C0(int a1)
{
  return sub_662E0(a1);
}

//----- (000662E0) --------------------------------------------------------
char __cdecl sub_662E0(int a1)
{
  unsigned int v1; // eax
  char v2; // dl
  signed __int16 v3; // ax
  int v4; // eax
  unsigned int v5; // esi
  int (*v6)(); // eax
  signed __int16 v7; // cx
  signed __int16 v8; // di
  int v9; // eax
  int v10; // edi
  char v11; // al
  int (*v12)(); // edi
  unsigned int v14; // [esp+0h] [ebp-8h]
  char v15; // [esp+4h] [ebp-4h]

  v15 = 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v14 = v1;
  if ( v1 <= dword_EA3E4[0] )
  {
    v2 = *(_BYTE *)(a1 + 12);
    if ( !(v2 & 2) )
    {
      *(_BYTE *)(a1 + 12) = v2 | 2;
      if ( sub_68940(a1) || sub_67CB0(a1) )
      {
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
      }
      else
      {
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 28);
        *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 30);
      }
    }
  }
  else
  {
    sub_65610(a1, v1);
  }
  v3 = *(_WORD *)(a1 + 132) - *(_WORD *)(a1 + 130);
  if ( *(signed __int16 *)(a1 + 132) != *(signed __int16 *)(a1 + 130) )
  {
    if ( *(signed __int16 *)(a1 + 132) - *(signed __int16 *)(a1 + 130) <= 0 )
      v3 = -1;
    else
      v3 = 1;
  }
  *(_WORD *)(a1 + 130) += 2 * v3;
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  sub_57CF0(a1, (int)&word_EB398);
  v4 = sub_10780(a1);
  v5 = v4;
  if ( v4 )
  {
    if ( *(_WORD *)(v4 + 12) & 0x8010 )
    {
      LOBYTE(v6) = sub_68740(a1, v4, 0x2Du, 22);
      if ( (_BYTE)v6 )
        return (char)v6;
    }
    sub_65580(v5);
    sub_57CF0(a1, v5 + 76);
    LOBYTE(v6) = sub_655A0(v5);
    v15 = 1;
  }
  else
  {
    LOWORD(v6) = sub_10C40((__int16 *)(a1 + 76));
    v7 = *(_WORD *)(a1 + 80);
    word_EB39C = (signed __int16)v6;
    if ( (signed __int16)v6 > v7
      || byte_D41B6
      && (LOWORD(v6) = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88),
          word_EB39C = (signed __int16)v6,
          v8 = (signed __int16)v6,
          LOWORD(v6) = *(_WORD *)(a1 + 80),
          (signed __int16)v6 > v8) )
    {
      LOBYTE(v6) = word_EB39C;
      *(_WORD *)(a1 + 80) = word_EB39C;
      if ( *(_BYTE *)(a1 + 64) != 4 )
      {
        v6 = sub_104D0((signed __int16 *)(a1 + 76));
        if ( v6 == (int (*)())1 )
        {
          v9 = sub_4A190(a1 + 76, 10, 5);
          if ( v9 )
            *(_WORD *)(v9 + 26) = *(_WORD *)(a1 + 26);
          LOBYTE(v6) = sub_57F10(a1);
          goto LABEL_26;
        }
      }
    }
    else
    {
      v10 = *(_DWORD *)(a1 + 8) - 1;
      *(_DWORD *)(a1 + 8) = v10;
      if ( v10 >= 0 )
        goto LABEL_26;
    }
    v15 = 1;
  }
LABEL_26:
  if ( v15 )
  {
    if ( sub_68AC0(a1, v5) )
    {
      LOBYTE(v6) = sub_57F10(a1);
    }
    else if ( !v5 || *(_BYTE *)(v5 + 63) != 3 || (v11 = *(_BYTE *)(v5 + 64)) != 0 && v11 != 1 )
    {
      sub_65780(a1, 0, v14);
      LOBYTE(v6) = sub_57F10(a1);
    }
    else
    {
      v6 = (int (*)())sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
      v12 = v6;
      if ( v6 )
      {
        sub_65780(a1, v5, v14);
        sub_686D0(a1, v5);
        if ( v5 > dword_EA3E4[0] && *(_WORD *)(a1 + 38) )
          sub_6D8B0(*(_WORD *)(a1 + 26), *(char *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 64), 1);
        if ( *(_BYTE *)(a1 + 68) == 34 )
          *((_DWORD *)v12 + 2) = *(unsigned __int16 *)(a1 + 42);
        *((_WORD *)v12 + 13) = *(_WORD *)(a1 + 26);
        *((_WORD *)v12 + 14) = *(_WORD *)(a1 + 28);
        *((_WORD *)v12 + 15) = *(_WORD *)(a1 + 30);
        *((_WORD *)v12 + 75) = (signed int)(v5 - (dword_D41A0 + 28302)) / 168;
        *((_WORD *)v12 + 21) = *(_WORD *)(a1 + 42);
        *((_BYTE *)v12 + 70) = *(_BYTE *)(a1 + 70);
        LOBYTE(v6) = sub_57F10(a1);
      }
    }
  }
  return (char)v6;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00066610) --------------------------------------------------------
__int16 __cdecl sub_66610(int a1)
{
  char v1; // dl
  int v2; // eax
  signed __int16 v3; // dx
  signed __int16 v4; // cx
  int v5; // ecx
  char v7; // [esp+0h] [ebp-4h]

  v7 = 0;
  if ( dword_EA3E4[0] >= (unsigned int)dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] )
  {
    v1 = *(_BYTE *)(a1 + 12);
    if ( !(v1 & 2) )
    {
      *(_BYTE *)(a1 + 12) = v1 | 2;
      if ( sub_68940(a1) || sub_67CB0(a1) )
      {
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
      }
      else
      {
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 28);
        *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 30);
      }
    }
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  *(_DWORD *)(a1 + 76) = *(_DWORD *)&word_EB398;
  *(_WORD *)(a1 + 80) = *(&word_EB398 + 2);
  v2 = sub_10780(a1);
  if ( v2 )
  {
    v7 = 1;
    *(_DWORD *)(a1 + 76) = *(_DWORD *)(v2 + 76);
    *(_WORD *)(a1 + 80) = *(_WORD *)(v2 + 80);
  }
  else
  {
    LOWORD(v2) = sub_10C40((__int16 *)(a1 + 76));
    v3 = *(_WORD *)(a1 + 80);
    word_EB39C = v2;
    if ( (signed __int16)v2 > v3
      || byte_D41B6
      && (LOWORD(v2) = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88),
          word_EB39C = v2,
          v4 = v2,
          LOWORD(v2) = *(_WORD *)(a1 + 80),
          (signed __int16)v2 > v4)
      || (v5 = *(_DWORD *)(a1 + 8) - 1, *(_DWORD *)(a1 + 8) = v5, v5 < 0) )
    {
      v7 = 1;
    }
  }
  if ( v7 )
    LOWORD(v2) = sub_57F10(a1);
  return v2;
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00066750) --------------------------------------------------------
__int16 __cdecl sub_66750(unsigned int a1)
{
  __int16 v1; // di
  __int16 v2; // si
  int v3; // edx
  __int16 v4; // ST08_2
  unsigned __int16 v5; // ST04_2
  unsigned int v6; // eax
  int v7; // esi
  signed __int16 v8; // cx
  int v9; // esi
  int v10; // esi
  int v11; // esi
  unsigned __int16 v12; // ax
  unsigned int v13; // esi
  int v14; // eax
  _WORD *v15; // edi
  char v16; // cl
  int v18; // [esp+0h] [ebp-2Ch]
  __int16 v19; // [esp+4h] [ebp-28h]
  int v20; // [esp+8h] [ebp-24h]
  __int16 v21; // [esp+Ch] [ebp-20h]
  int v22; // [esp+10h] [ebp-1Ch]
  int v23; // [esp+14h] [ebp-18h]
  unsigned int v24; // [esp+18h] [ebp-14h]
  int v25; // [esp+1Ch] [ebp-10h]
  int v26; // [esp+20h] [ebp-Ch]
  int v27; // [esp+24h] [ebp-8h]
  int v28; // [esp+28h] [ebp-4h]

  *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
  v18 = *(_DWORD *)(a1 + 76);
  v19 = *(_WORD *)(a1 + 80);
  sub_57E50(a1);
  sub_66610(a1);
  v1 = *(_WORD *)(a1 + 28);
  v2 = *(_WORD *)(a1 + 30);
  v27 = 1;
  while ( !(*(_BYTE *)(a1 + 13) & 4) )
  {
    sub_66610(a1);
    ++v27;
  }
  *(_WORD *)(a1 + 28) = v1;
  *(_WORD *)(a1 + 30) = v2;
  v22 = 0;
  LOWORD(v23) = 0;
  v3 = *(signed __int16 *)(a1 + 130);
  v27 *= 8;
  v26 = (v3 - (__CFSHL__(v3 >> 31, 3) + 8 * (v3 >> 31))) >> 3;
  v4 = *(_WORD *)(a1 + 30);
  v5 = *(_WORD *)(a1 + 28);
  v25 = 0;
  v28 = 0;
  sub_57FA0(&v22, v5, v4, v26);
  *(_DWORD *)&word_EB398 = v18;
  *(&word_EB398 + 2) = v19;
  v20 = v18;
  v21 = v19;
  while ( (v27 & 0x8000u) == 0 )
  {
    v6 = sub_4A050();
    v7 = v6;
    if ( v6 )
    {
      *(_BYTE *)(v6 + 69) = 14;
      *(_BYTE *)(v6 + 63) = 9;
      *(_BYTE *)(v6 + 64) = 9;
      *(_WORD *)(v6 + 26) = *(_WORD *)(a1 + 26);
      *(_DWORD *)(v6 + 4) = (v6 >= a1) - 1;
      sub_49CD0((_WORD *)v6, 216);
      sub_57D70(v7, (int)&v20);
      sub_49A20(v7);
    }
    v8 = (signed __int16)v27 / 2;
    if ( (signed __int16)v27 / 2 < 0 )
      v8 = 0;
    if ( v8 > 8 )
      v8 = 8;
    if ( v8 >= (signed __int16)v28 )
    {
      v10 = (signed __int16)v28;
      if ( (signed __int16)v28 < -v8 )
      {
        ++v28;
        goto LABEL_17;
      }
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v9 = 2 * ((signed int)(*(unsigned __int16 *)(a1 + 20) % 0x9Du) / 79) - 1 + v10;
    }
    else
    {
      v9 = v28 - 1;
    }
    v28 = v9;
LABEL_17:
    if ( v8 >= (signed __int16)v25 )
    {
      v11 = (signed __int16)v25;
      if ( (signed __int16)v25 >= -v8 )
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v25 = 2 * ((signed int)(*(unsigned __int16 *)(a1 + 20) % 0x9Du) / 79) - 1 + v11;
      }
      else
      {
        ++v25;
      }
    }
    else
    {
      --v25;
    }
    word_EB398 += v22;
    word_EB39A += HIWORD(v22);
    word_EB39C += v23;
    v20 = *(_DWORD *)&word_EB398;
    v21 = *(&word_EB398 + 2);
    v21 = v28
        * (((signed __int16)v26 - (__CFSHL__((signed __int16)v26 >> 31, 2) + 4 * ((signed __int16)v26 >> 31))) >> 2)
        + word_EB39C;
    v12 = *(_WORD *)(a1 + 28);
    HIBYTE(v12) = (HIBYTE(v12) + 2) & 7;
    sub_57FA0(
      &v20,
      v12,
      0,
      v28 * (((signed __int16)v26 - (__CFSHL__((signed __int16)v26 >> 31, 2) + 4 * ((signed __int16)v26 >> 31))) >> 2));
    --v27;
  }
  v13 = sub_10780(a1);
  v24 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v14 = sub_4A190((int)&v20, *(char *)(a1 + 67), *(char *)(a1 + 68));
  v15 = (_WORD *)v14;
  if ( !v14 )
    return v14;
  sub_65780(a1, v13, v24);
  sub_686D0(a1, v13);
  sub_68AC0(a1, v13);
  if ( v13 > dword_EA3E4[0] )
    sub_6D8B0(*(_WORD *)(a1 + 26), 7u, 1);
  v15[13] = *(_WORD *)(a1 + 26);
  v15[14] = *(_WORD *)(a1 + 28);
  v15[15] = *(_WORD *)(a1 + 30);
  v16 = 0;
  v14 = (signed int)(v13 - (dword_D41A0 + 28302)) / 168;
  v15[75] = v14;
  if ( !v13 || *(_BYTE *)(v13 + 63) != 3 || !(*(_WORD *)(v13 + 12) & 0x8010) )
  {
LABEL_35:
    v16 = 1;
    goto LABEL_36;
  }
  if ( *(_BYTE *)(v13 + 13) >= 0 )
  {
    v14 = (*(_DWORD *)(a1 + 144) - (__CFSHL__(*(_DWORD *)(a1 + 144) >> 31, 3) + 8 * (*(_DWORD *)(a1 + 144) >> 31))) >> 3;
    if ( v14 <= *(_DWORD *)(v13 + 144) )
    {
      v14 = *(unsigned __int16 *)(a1 + 42) / 2;
      v15[21] = v14;
      goto LABEL_36;
    }
    goto LABEL_35;
  }
  v14 = (*(_DWORD *)(a1 + 144) - (__CFSHL__(*(_DWORD *)(a1 + 144) >> 31, 2) + 4 * (*(_DWORD *)(a1 + 144) >> 31))) >> 2;
  if ( v14 > *(_DWORD *)(v13 + 144) )
    goto LABEL_35;
  v14 = (signed int)*(unsigned __int16 *)(a1 + 42) >> 2;
  v15[21] = v14;
LABEL_36:
  if ( v16 )
  {
    LOWORD(v14) = *(_WORD *)(a1 + 42);
    v15[21] = v14;
  }
  return v14;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00066B30) --------------------------------------------------------
char __cdecl sub_66B30(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // ax
  int v3; // eax
  __int16 v4; // dx
  __int16 v5; // ax
  __int16 v6; // cx
  int v7; // edi
  int v8; // eax
  int v10; // [esp+0h] [ebp-8h]
  char v11; // [esp+4h] [ebp-4h]

  v11 = 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v10 = v1;
  if ( v1 > dword_EA3E4[0] )
  {
    sub_656D0(a1, v1);
    v3 = *(signed __int16 *)(a1 + 132) - *(signed __int16 *)(a1 + 130);
    if ( *(signed __int16 *)(a1 + 132) != *(signed __int16 *)(a1 + 130) )
    {
      if ( v3 <= 0 )
        LOWORD(v3) = -1;
      else
        LOWORD(v3) = 1;
    }
    *(_WORD *)(a1 + 130) += 2 * v3;
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
    sub_57CF0(a1, (int)&word_EB398);
    if ( sub_106C0(a1, v10) )
    {
      LOBYTE(v2) = sub_57CF0(a1, v10 + 76);
      v11 = 1;
    }
    else
    {
      v2 = sub_10C40((__int16 *)(a1 + 76));
      v4 = *(_WORD *)(a1 + 80);
      word_EB39C = v2;
      if ( v2 > v4
        || byte_D41B6
        && (v5 = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88),
            word_EB39C = v5,
            v6 = v5,
            v2 = *(_WORD *)(a1 + 80),
            v2 > v6) )
      {
        LOBYTE(v2) = word_EB39C;
        v11 = 1;
        *(_WORD *)(a1 + 80) = word_EB39C;
      }
      else
      {
        v7 = *(_DWORD *)(a1 + 8) - 1;
        *(_DWORD *)(a1 + 8) = v7;
        if ( v7 < 0 )
          v11 = 1;
      }
    }
    if ( v11 )
    {
      if ( *(_BYTE *)(a1 + 67) == 3 && *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(signed __int16 *)(a1 + 26)] + 164) + 58) )
      {
        LOBYTE(v2) = sub_57F10(a1);
      }
      else
      {
        v8 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
        if ( v8 )
        {
          *(_WORD *)(v8 + 26) = *(_WORD *)(a1 + 26);
          LOBYTE(v2) = sub_57F10(a1);
        }
        else
        {
          LOBYTE(v2) = sub_5F890(dword_EA3E4[*(signed __int16 *)(a1 + 26)], 0);
        }
      }
    }
  }
  else
  {
    LOBYTE(v2) = sub_66D00(a1);
  }
  return v2;
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00066D00) --------------------------------------------------------
char __cdecl sub_66D00(int a1)
{
  char v1; // dh
  int v2; // eax
  __int16 v3; // ax
  __int16 v4; // ax
  signed __int16 v5; // ax
  unsigned __int16 v6; // ax
  unsigned int v7; // esi
  signed __int16 v8; // di
  signed __int16 v9; // dx
  int v10; // ecx
  unsigned __int16 v11; // ax
  char v13; // [esp+0h] [ebp-8h]
  char v14; // [esp+4h] [ebp-4h]

  v1 = *(_BYTE *)(a1 + 12);
  v13 = 0;
  v14 = 0;
  if ( !(v1 & 2) )
  {
    *(_BYTE *)(a1 + 12) = v1 | 2;
    LOBYTE(v2) = sub_11CB0((__int16 *)(a1 + 76));
    if ( !(_BYTE)v2 )
    {
      sub_5F890(a1, 0);
      sub_57F10(a1);
      LOBYTE(v2) = sub_88D00();
    }
    return v2;
  }
  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a1 + 154));
  *(_WORD *)(a1 + 34) = sub_58210((_WORD *)(a1 + 76), (_WORD *)(a1 + 154));
  v3 = *(_WORD *)(a1 + 28)
     + sub_58350(
         *(_WORD *)(a1 + 28),
         *(_WORD *)(a1 + 32),
         *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 4),
         *(_WORD *)(*(_DWORD *)(a1 + 160) + 2));
  HIBYTE(v3) &= 7u;
  *(_WORD *)(a1 + 28) = v3;
  v4 = *(_WORD *)(a1 + 30)
     + sub_58350(
         *(_WORD *)(a1 + 30),
         *(_WORD *)(a1 + 34),
         *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 8),
         *(_WORD *)(*(_DWORD *)(a1 + 160) + 6));
  HIBYTE(v4) &= 7u;
  *(_WORD *)(a1 + 30) = v4;
  v5 = *(_WORD *)(a1 + 132) - *(_WORD *)(a1 + 130);
  if ( *(signed __int16 *)(a1 + 132) != *(signed __int16 *)(a1 + 130) )
  {
    if ( *(signed __int16 *)(a1 + 132) - *(signed __int16 *)(a1 + 130) <= 0 )
      v5 = -1;
    else
      v5 = 1;
  }
  *(_WORD *)(a1 + 130) += 2 * v5;
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  sub_57CF0(a1, (int)&word_EB398);
  v6 = *(_WORD *)(a1 + 150);
  v7 = dword_EA3E4[v6];
  if ( v7 > dword_EA3E4[0] && sub_106C0(a1, dword_EA3E4[v6]) )
  {
    sub_65580(v7);
    LOBYTE(v2) = sub_57CF0(a1, v7 + 76);
    v13 = 1;
    goto LABEL_18;
  }
  LOWORD(v2) = sub_10C40((__int16 *)(a1 + 76));
  v8 = *(_WORD *)(a1 + 80);
  word_EB39C = v2;
  if ( (signed __int16)v2 > v8
    || byte_D41B6
    && (LOWORD(v2) = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88),
        word_EB39C = v2,
        v9 = v2,
        LOWORD(v2) = *(_WORD *)(a1 + 80),
        (signed __int16)v2 > v9) )
  {
    LOBYTE(v2) = word_EB39C;
    *(_WORD *)(a1 + 80) = word_EB39C;
LABEL_17:
    v13 = 1;
    goto LABEL_18;
  }
  v10 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v10;
  if ( v10 < 0 )
    goto LABEL_17;
  LOBYTE(v2) = sub_11CB0((__int16 *)(a1 + 76)) == 0;
  v14 = v2;
  if ( (_BYTE)v2 )
    goto LABEL_17;
LABEL_18:
  if ( v13 )
  {
    if ( v14 )
    {
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      v11 = *(_WORD *)(a1 + 28);
      HIBYTE(v11) = (HIBYTE(v11) + 4) & 7;
      sub_57FA0(&word_EB398, v11, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
      sub_57CF0(a1, (int)&word_EB398);
    }
    v2 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
    if ( v2 )
    {
      *(_WORD *)(v2 + 26) = *(_WORD *)(a1 + 26);
      LOBYTE(v2) = sub_57F10(a1);
    }
  }
  return v2;
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00066FB0) --------------------------------------------------------
int __cdecl sub_66FB0(int a1)
{
  return sub_65820(a1);
}

//----- (00066FD0) --------------------------------------------------------
char __cdecl sub_66FD0(int a1)
{
  unsigned int v1; // eax
  char v2; // dl
  int v3; // esi
  unsigned __int16 v4; // dx
  signed __int16 v5; // ax
  int v6; // eax
  unsigned int v7; // edi
  int (*v8)(); // eax
  __int16 v9; // ax
  __int16 v10; // dx
  int v11; // eax
  int (*v12)(); // esi
  unsigned int v14; // [esp+0h] [ebp-8h]
  char v15; // [esp+4h] [ebp-4h]

  v15 = 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v14 = v1;
  if ( v1 <= dword_EA3E4[0] )
  {
    v2 = *(_BYTE *)(a1 + 12);
    if ( !(v2 & 2) )
    {
      *(_BYTE *)(a1 + 12) = v2 | 2;
      if ( sub_68940(a1) )
      {
        v3 = *(_DWORD *)(a1 + 8) + 32;
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        *(_DWORD *)(a1 + 8) = v3;
        *(_DWORD *)(a1 + 4) = v3;
        v4 = *(_WORD *)(a1 + 52);
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
        if ( v4 )
        {
          sub_57F20(dword_EA3E4[v4]);
          *(_WORD *)(a1 + 52) = 0;
        }
      }
      else if ( sub_67CB0(a1) )
      {
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
      }
      else
      {
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 28);
        *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 30);
      }
    }
  }
  else
  {
    sub_65610(a1, v1);
  }
  v5 = *(_WORD *)(a1 + 132) - *(_WORD *)(a1 + 130);
  if ( *(signed __int16 *)(a1 + 132) != *(signed __int16 *)(a1 + 130) )
  {
    if ( *(signed __int16 *)(a1 + 132) - *(signed __int16 *)(a1 + 130) <= 0 )
      v5 = -1;
    else
      v5 = 1;
  }
  *(_WORD *)(a1 + 130) += 2 * v5;
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  sub_57CF0(a1, (int)&word_EB398);
  v6 = sub_10780(a1);
  v7 = v6;
  if ( v6 )
  {
    if ( *(_WORD *)(v6 + 12) & 0x8010 )
    {
      LOBYTE(v8) = sub_68740(a1, v6, 0x2Du, 22);
      if ( (_BYTE)v8 )
        return (char)v8;
    }
    sub_65580(v7);
    sub_57CF0(a1, v7 + 76);
    LOBYTE(v8) = sub_655A0(v7);
    v15 = 1;
  }
  else
  {
    v9 = sub_10C40((__int16 *)(a1 + 76));
    v10 = *(_WORD *)(a1 + 80);
    word_EB39C = v9;
    if ( v9 > v10
      || byte_D41B6
      && (word_EB39C = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88), *(_WORD *)(a1 + 80) > word_EB39C) )
    {
      LOBYTE(v8) = word_EB39C;
      *(_WORD *)(a1 + 80) = word_EB39C;
      if ( *(_BYTE *)(a1 + 64) != 4 )
      {
        v8 = sub_104D0((signed __int16 *)(a1 + 76));
        if ( v8 == (int (*)())1 )
        {
          v11 = sub_4A190(a1 + 76, 10, 5);
          if ( v11 )
            *(_WORD *)(v11 + 26) = *(_WORD *)(a1 + 26);
          LOBYTE(v8) = sub_57F10(a1);
          goto LABEL_28;
        }
      }
    }
    else
    {
      v8 = (int (*)())(*(_DWORD *)(a1 + 8) - 1);
      *(_DWORD *)(a1 + 8) = v8;
      if ( (signed int)v8 >= 0 )
        goto LABEL_28;
    }
    v15 = 1;
  }
LABEL_28:
  if ( v15 )
  {
    if ( sub_68AC0(a1, v7) )
    {
      LOBYTE(v8) = sub_57F10(a1);
    }
    else
    {
      v8 = (int (*)())sub_4A190(a1 + 76, 10, 38);
      v12 = v8;
      if ( v8 )
      {
        sub_65780(a1, v7, v14);
        if ( v7 > dword_EA3E4[0] )
          sub_6D8B0(*(_WORD *)(a1 + 26), 7u, 1);
        *((_WORD *)v12 + 13) = *(_WORD *)(a1 + 26);
        *((_WORD *)v12 + 14) = *(_WORD *)(a1 + 28);
        *((_WORD *)v12 + 15) = *(_WORD *)(a1 + 30);
        *((_WORD *)v12 + 75) = (signed int)(v7 - (dword_D41A0 + 28302)) / 168;
        *((_WORD *)v12 + 21) = *(_WORD *)(a1 + 42);
        *((_BYTE *)v12 + 67) = *(_BYTE *)(a1 + 67);
        *((_BYTE *)v12 + 68) = *(_BYTE *)(a1 + 68);
        LOBYTE(v8) = sub_57F10(a1);
      }
    }
  }
  return (char)v8;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (000672E0) --------------------------------------------------------
char __cdecl sub_672E0(int a1)
{
  int v1; // esi
  int v2; // eax
  int v3; // edi
  int v4; // eax
  char result; // al

  if ( !(*(_BYTE *)(a1 + 12) & 2) )
  {
    v1 = dword_D41A0;
    v2 = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
    *(_DWORD *)(dword_D41A0 + 8) = v2;
    sub_6E450((a1 - (v1 + 28302)) / 168, -1, (v2 & 1) + 33);
    *(_BYTE *)(a1 + 12) |= 2u;
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  v3 = sub_10780(a1);
  if ( (signed __int16)sub_10C40(&word_EB398) <= word_EB39C )
  {
    v4 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v4 - 1;
    if ( v4 )
    {
      if ( !v3 )
        return sub_57CF0(a1, (int)&word_EB398);
    }
  }
  if ( !v3 )
  {
LABEL_10:
    sub_10C80(a1, 0, *(_WORD *)(a1 + 42));
    return sub_57F10(a1);
  }
  if ( !(*(_WORD *)(v3 + 12) & 0x8010) || (result = sub_68740(a1, v3, 0x2Du, 22)) == 0 )
  {
    sub_65580(v3);
    sub_57CF0(a1, v3 + 76);
    sub_655A0(v3);
    goto LABEL_10;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00067410) --------------------------------------------------------
int __cdecl sub_67410(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = result - 1;
  if ( result < 0 )
    result = sub_57F10(a1);
  return result;
}

//----- (00067430) --------------------------------------------------------
int __cdecl sub_67430(int a1)
{
  return sub_65820(a1);
}

//----- (00067450) --------------------------------------------------------
int __cdecl sub_67450(int a1)
{
  return sub_65820(a1);
}

//----- (00067470) --------------------------------------------------------
int __cdecl sub_67470(int a1)
{
  int result; // eax
  char v2; // dh

  result = sub_65820(a1);
  BYTE1(result) = *(_BYTE *)(a1 + 63);
  if ( BYTE1(result) )
  {
    result = sub_4A190(a1 + 76, 10, 0);
    if ( result )
    {
      *(_BYTE *)(result + 12) |= 0x80u;
      v2 = *(_BYTE *)(result + 14) | 1;
      *(_WORD *)(result + 26) = *(_WORD *)(a1 + 26);
      *(_BYTE *)(result + 14) = v2;
    }
  }
  return result;
}

//----- (000674C0) --------------------------------------------------------
__int16 __cdecl sub_674C0(int a1)
{
  unsigned int v1; // eax
  char v2; // dl
  __int16 v3; // ax
  int v4; // eax
  int v5; // esi
  unsigned int v6; // edi
  __int16 result; // ax
  __int16 v8; // cx
  __int16 v9; // ax
  __int16 v10; // si
  int v11; // esi
  int v12; // eax
  _WORD *v13; // esi
  int v14; // esi
  unsigned int v15; // [esp+0h] [ebp-8h]
  char v16; // [esp+4h] [ebp-4h]

  v16 = 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v15 = v1;
  if ( v1 <= dword_EA3E4[0] )
  {
    v2 = *(_BYTE *)(a1 + 12);
    if ( !(v2 & 2) )
    {
      *(_BYTE *)(a1 + 12) = v2 | 2;
      if ( sub_67CB0(a1) )
      {
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
      }
    }
  }
  else
  {
    sub_65610(a1, v1);
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  v3 = sub_10C40(&word_EB398);
  if ( v3 > word_EB39C )
    word_EB39C = v3;
  sub_57CF0(a1, (int)&word_EB398);
  v4 = sub_108B0(a1);
  v5 = v4;
  v6 = v4;
  if ( v4 )
  {
    sub_65580(v4);
    sub_57CF0(a1, v5 + 76);
    result = sub_655A0(v5);
    v16 = 1;
    goto LABEL_16;
  }
  result = sub_10C40((__int16 *)(a1 + 76));
  v8 = *(_WORD *)(a1 + 80);
  word_EB39C = result;
  if ( result > v8
    || byte_D41B6
    && (v9 = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88),
        word_EB39C = v9,
        v10 = v9,
        result = *(_WORD *)(a1 + 80),
        result > v10) )
  {
    result = word_EB39C;
    *(_WORD *)(a1 + 80) = word_EB39C;
  }
  else
  {
    v11 = *(_DWORD *)(a1 + 8) - 1;
    *(_DWORD *)(a1 + 8) = v11;
    if ( v11 >= 0 )
      goto LABEL_16;
  }
  v16 = 1;
LABEL_16:
  if ( v16 )
  {
    if ( v6 )
    {
      if ( *(_BYTE *)(a1 + 67) != 10 || *(_BYTE *)(a1 + 68) != 69 )
        v12 = sub_4A190(a1 + 76, 10, 12);
      else
        v12 = sub_4A190(a1 + 76, 10, 70);
      v13 = (_WORD *)v12;
      if ( v12 )
      {
        sub_65780(a1, v6, v15);
        v13[13] = *(_WORD *)(a1 + 26);
        v13[14] = *(_WORD *)(a1 + 28);
        v13[15] = *(_WORD *)(a1 + 30);
      }
      v14 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
      if ( v14 )
      {
        sub_65780(a1, v6, v15);
        sub_6D8B0(*(_WORD *)(a1 + 26), 1u, 1);
        *(_WORD *)(v14 + 26) = *(_WORD *)(a1 + 26);
        *(_WORD *)(v14 + 28) = *(_WORD *)(a1 + 28);
        *(_WORD *)(v14 + 30) = *(_WORD *)(a1 + 30);
        *(_DWORD *)(v14 + 16) = *(_DWORD *)(a1 + 16);
      }
    }
    result = sub_57F10(a1);
  }
  return result;
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (000676F0) --------------------------------------------------------
_WORD *__cdecl sub_676F0(int a1)
{
  _WORD *result; // eax

  result = (_WORD *)sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
  if ( result )
  {
    result[13] = *(_WORD *)(a1 + 26);
    result[14] = *(_WORD *)(a1 + 28);
    result[15] = *(_WORD *)(a1 + 30);
    result[21] = *(_WORD *)(a1 + 42);
    result = (_WORD *)sub_57F10(a1);
  }
  return result;
}

//----- (00067740) --------------------------------------------------------
int __cdecl sub_67740(int a1)
{
  return sub_65820(a1);
}

//----- (00067760) --------------------------------------------------------
int __cdecl sub_67760(int a1)
{
  return sub_65820(a1);
}

//----- (00067780) --------------------------------------------------------
int __cdecl sub_67780(int a1)
{
  return sub_65820(a1);
}

//----- (000677A0) --------------------------------------------------------
int __cdecl sub_677A0(int a1)
{
  int result; // eax
  int v2; // edx

  result = sub_65820(a1);
  if ( result )
  {
    v2 = *(char *)(a1 + 70);
    *(_BYTE *)(result + 70) = 0;
    *(_DWORD *)(result + 8) = v2;
  }
  return result;
}

//----- (000677D0) --------------------------------------------------------
int __cdecl sub_677D0(int a1)
{
  int result; // eax
  int v2; // edx

  result = sub_65820(a1);
  if ( result )
  {
    v2 = *(char *)(a1 + 70);
    LOBYTE(v2) = v2 & 0xF0;
    *(_BYTE *)(result + 70) = 0;
    *(_DWORD *)(result + 4) = v2;
    *(_DWORD *)(result + 8) = v2;
  }
  return result;
}

//----- (00067800) --------------------------------------------------------
int __cdecl sub_67800(int a1)
{
  unsigned __int8 v1; // al
  int result; // eax

  v1 = *(_BYTE *)(a1 + 70);
  if ( v1 < 0x10u )
  {
    if ( v1 != 2 )
      goto LABEL_10;
LABEL_8:
    *(_BYTE *)(dword_D41A4 + 224) = 8;
    goto LABEL_11;
  }
  if ( v1 <= 0x10u || v1 < 0x13u )
    goto LABEL_10;
  if ( v1 <= 0x13u )
    goto LABEL_8;
  if ( v1 == 25 )
  {
    *(_BYTE *)(dword_D41A4 + 224) = 4;
    goto LABEL_11;
  }
LABEL_10:
  *(_BYTE *)(dword_D41A4 + 224) = 2;
LABEL_11:
  result = sub_65820(a1);
  if ( result )
  {
    while ( result != dword_EA3E4[0] )
    {
      *(_BYTE *)(result + 70) = *(_BYTE *)(a1 + 70);
      *(_WORD *)(result + 40) = *(_WORD *)(a1 + 40);
      *(_WORD *)(result + 26) = *(_WORD *)(a1 + 26);
      result = dword_EA3E4[*(unsigned __int16 *)(result + 52)];
    }
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00067890) --------------------------------------------------------
unsigned int __cdecl sub_67890(int a1)
{
  unsigned int result; // eax
  char v2; // dh

  result = sub_65820(a1);
  if ( result )
  {
    result = dword_EA3E4[*(signed __int16 *)(a1 + 26)];
    if ( result > dword_EA3E4[0] && *(_BYTE *)(result + 63) == 3 )
    {
      v2 = *(_BYTE *)(result + 64);
      if ( !v2 || v2 == 1 )
        *(_WORD *)(result + 150) = 0;
    }
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000678E0) --------------------------------------------------------
int __cdecl sub_678E0(int a1)
{
  int result; // eax
  int v2; // edx

  result = sub_65820(a1);
  if ( result )
  {
    v2 = 8 * *(char *)(a1 + 70);
    *(_DWORD *)(result + 4) = v2;
    *(_DWORD *)(result + 8) = v2;
  }
  return result;
}

//----- (00067910) --------------------------------------------------------
int __cdecl sub_67910(int a1)
{
  int result; // eax
  int v2; // edx

  result = sub_65820(a1);
  if ( result )
  {
    v2 = *(char *)(a1 + 70);
    *(_BYTE *)(result + 70) = 0;
    *(_DWORD *)(result + 4) = v2;
  }
  return result;
}

//----- (00067940) --------------------------------------------------------
int __cdecl sub_67940(int a1)
{
  return sub_65820(a1);
}

//----- (00067960) --------------------------------------------------------
int __usercall sub_67960@<eax>(unsigned int a1@<esi>, int a2)
{
  int v2; // eax
  unsigned int v3; // eax
  unsigned int i; // edi
  signed int v5; // ST10_4
  signed int v6; // eax
  int v7; // eax
  unsigned __int16 v8; // ax
  __int16 v9; // ax
  __int16 v10; // dx
  int result; // eax
  __int16 v12; // dx
  __int16 *v13; // [esp+4h] [ebp-18h]
  void (__noreturn *v14)(); // [esp+8h] [ebp-14h]
  int v15; // [esp+Ch] [ebp-10h]
  unsigned int v16; // [esp+10h] [ebp-Ch]
  char v17; // [esp+14h] [ebp-8h]
  char v18; // [esp+18h] [ebp-4h]

  v15 = 0;
  v17 = 0;
  v18 = 0;
  v14 = sub_10000;
  if ( *(_DWORD *)(a2 + 8) == *(_DWORD *)(a2 + 4) && *(_WORD *)(a2 + 42) >= 2u )
  {
    v2 = *(signed __int16 *)(a2 + 26);
    *(_WORD *)(a2 + 150) = 0;
    v3 = dword_EA3E4[v2];
    v16 = v3;
    if ( v3 > dword_EA3E4[0] && *(_BYTE *)(v3 + 63) == 3 )
    {
      for ( i = *(_DWORD *)(dword_D41A4 + 38535); i > dword_EA3E4[0]; i = *(_DWORD *)i )
      {
        if ( *(_BYTE *)(i + 64) == 78
          && *(unsigned __int16 *)(i + 50) != *(signed __int16 *)(a2 + 26)
          && *(_WORD *)(i + 42) < 2u )
        {
          v5 = *(signed __int16 *)(*(_DWORD *)(v16 + 160) + 28);
          v6 = sub_583F0((_WORD *)(i + 76), (_WORD *)(a2 + 76));
          if ( v6 < v5 && v6 < (signed int)v14 )
          {
            v15 = i;
            v14 = (void (__noreturn *)())v6;
          }
        }
      }
      if ( v15 )
      {
        *(_DWORD *)(a2 + 4) = 32;
        *(_DWORD *)(a2 + 8) = *(_DWORD *)(a2 + 4) - 1;
        *(_WORD *)(a2 + 150) = (v15 - (dword_D41A0 + 28302)) / 168;
        sub_655C0((_WORD *)a2, v15);
      }
    }
  }
  v7 = *(signed __int16 *)(a2 + 132) - *(signed __int16 *)(a2 + 130);
  if ( *(signed __int16 *)(a2 + 132) != *(signed __int16 *)(a2 + 130) )
  {
    if ( v7 <= 0 )
      LOWORD(v7) = -1;
    else
      LOWORD(v7) = 1;
  }
  *(_WORD *)(a2 + 130) += 2 * v7;
  if ( *(_WORD *)(a2 + 150) )
  {
    v8 = *(_WORD *)(a2 + 150);
    a1 = dword_EA3E4[v8];
    if ( a1 <= dword_EA3E4[0] || *(_DWORD *)(a1 + 8) < 0 || *(_BYTE *)(a1 + 13) & 4 )
    {
      *(_WORD *)(a2 + 150) = 0;
    }
    else
    {
      sub_65610(a2, dword_EA3E4[v8]);
      if ( sub_106C0(a2, a1) )
        v17 = 1;
    }
  }
  v13 = (__int16 *)(a2 + 76);
  if ( v17 )
  {
    sub_65580(a1);
    sub_57CF0(a2, a1 + 76);
    sub_655A0(a1);
    *(_BYTE *)(a1 + 70) = 8;
    sub_4A190((int)v13, 10, 0);
    result = sub_57F10(a2);
  }
  else
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a2 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a2 + 80);
    sub_57FA0(&word_EB398, *(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 130));
    sub_57CF0(a2, (int)&word_EB398);
    v9 = sub_10C40(v13);
    v10 = *(_WORD *)(a2 + 80);
    word_EB39C = v9;
    if ( v9 > v10 || byte_D41B6 && (word_EB39C = sub_10C60(v13) - *(_WORD *)(a2 + 88), *(_WORD *)(a2 + 80) > word_EB39C) )
    {
      v18 = 1;
      *(_WORD *)(a2 + 80) = word_EB39C;
    }
    result = *(_DWORD *)(a2 + 8) - 1;
    *(_DWORD *)(a2 + 8) = result;
    if ( result < 0 )
      v18 = 1;
    if ( v18 )
    {
      result = sub_4A190(a2 + 76, *(char *)(a2 + 67), *(char *)(a2 + 68));
      if ( result )
      {
        *(_WORD *)(result + 50) = *(_WORD *)(a2 + 26);
        v12 = *(_WORD *)(a2 + 42);
        *(_BYTE *)(result + 70) = 0;
        *(_WORD *)(result + 42) = v12;
        result = sub_57F10(a2);
      }
    }
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00067CB0) --------------------------------------------------------
signed int __cdecl sub_67CB0(int a1)
{
  unsigned int v1; // edi
  unsigned int ii; // esi
  unsigned int v3; // ST10_4
  unsigned int v4; // eax
  unsigned int kk; // esi
  unsigned int v6; // eax
  _BYTE *v8; // esi
  unsigned int i; // edi
  unsigned int v10; // ST10_4
  unsigned int v11; // eax
  unsigned int k; // edi
  __int16 v13; // cx
  unsigned int v14; // eax
  unsigned int l; // edi
  int m; // eax
  unsigned int v17; // eax
  unsigned int v18; // edi
  unsigned int ll; // esi
  unsigned int v20; // ST10_4
  unsigned int v21; // eax
  unsigned int nn; // esi
  __int16 v23; // cx
  unsigned int v24; // eax
  unsigned int v25; // edi
  unsigned int v26; // esi
  unsigned __int8 v27; // al
  int v28; // eax
  int v29; // edx
  unsigned int v30; // eax
  unsigned int i3; // esi
  unsigned int v32; // eax
  unsigned int i4; // esi
  int i5; // eax
  unsigned int v35; // eax
  unsigned int v36; // edi
  unsigned int n; // esi
  unsigned int v38; // ST10_4
  unsigned int v39; // eax
  int v40; // edi
  unsigned int i2; // esi
  unsigned int v42; // eax
  int v43; // [esp+4h] [ebp-40h]
  int v44; // [esp+8h] [ebp-3Ch]
  int v45; // [esp+Ch] [ebp-38h]
  signed int j; // [esp+10h] [ebp-34h]
  unsigned int v47; // [esp+14h] [ebp-30h]
  unsigned int v48; // [esp+18h] [ebp-2Ch]
  signed int jj; // [esp+1Ch] [ebp-28h]
  signed int mm; // [esp+20h] [ebp-24h]
  signed int i1; // [esp+24h] [ebp-20h]
  int v52; // [esp+28h] [ebp-1Ch]
  int v53; // [esp+2Ch] [ebp-18h]
  int v54; // [esp+30h] [ebp-14h]
  unsigned int v55; // [esp+34h] [ebp-10h]
  int v56; // [esp+38h] [ebp-Ch]
  unsigned int v57; // [esp+40h] [ebp-4h]

  switch ( *(_BYTE *)(a1 + 64) )
  {
    case 0:
    case 3:
    case 4:
    case 0x12:
    case 0x13:
    case 0x16:
    case 0x1A:
    case 0x1C:
    case 0x1E:
      v57 = -1;
      v43 = dword_EA3E4[*(signed __int16 *)(a1 + 26)];
      v8 = 0;
      for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
      {
        if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) && !(*(_BYTE *)(i + 12) & 0x20) )
        {
          v10 = *(signed __int16 *)(*(_DWORD *)(v43 + 160) + 28);
          if ( sub_583F0((_WORD *)(i + 76), (_WORD *)(a1 + 76)) <= v10 )
          {
            v11 = *(_BYTE *)(i + 64) == 2 ? sub_685D0((__int16 *)a1, i, 0x71u, 0x71u) : sub_68490(
                                                                                          (__int16 *)a1,
                                                                                          i,
                                                                                          0x71u,
                                                                                          0x71u);
            if ( v11 < v57 )
            {
              v8 = (_BYTE *)i;
              v57 = v11;
            }
          }
        }
      }
      for ( j = 0; j < 29; ++j )
      {
        if ( j != 22 )
        {
          for ( k = *(_DWORD *)(dword_D41A4 + 4 * j + 38403); k > dword_EA3E4[0]; k = *(_DWORD *)k )
          {
            v13 = *(_WORD *)(a1 + 26);
            if ( *(_WORD *)(k + 26) != v13
              && *(_BYTE *)(k + 57)
              && (*(_BYTE *)(k + 73) != 14 || *(unsigned __int16 *)(k + 40) != v13) )
            {
              v14 = sub_68490((__int16 *)a1, k, 0x71u, 0x71u);
              if ( v14 < v57 )
              {
                v8 = (_BYTE *)k;
                v57 = v14;
              }
            }
          }
        }
      }
      if ( !v8 )
      {
        for ( l = *(_DWORD *)(dword_D41A4 + 38491); l > dword_EA3E4[0]; l = *(_DWORD *)l )
        {
          if ( *(_BYTE *)(l + 57) )
          {
            for ( m = *(unsigned __int16 *)(l + 52); ; m = *(unsigned __int16 *)(v53 + 52) )
            {
              v53 = dword_EA3E4[m];
              if ( v53 == dword_EA3E4[0] )
                break;
              v17 = sub_68490((__int16 *)a1, v53, 0x71u, 0x71u);
              if ( v17 < v57 )
              {
                v8 = (_BYTE *)v53;
                v57 = v17;
              }
            }
          }
        }
      }
      if ( !v8 )
        return 0;
      *(_WORD *)(a1 + 150) = (signed int)&v8[-dword_D41A0 - 28302] / 168;
      sub_68BD0(a1, v8);
      sub_655C0((_WORD *)a1, (int)v8);
      if ( v8[63] == 3 && !v8[64] )
        sub_5EF70((unsigned int)v8);
      return 1;
    case 1:
    case 0x11:
      v25 = -1;
      v56 = 0;
      v26 = *(_DWORD *)(dword_D41A4 + 38523);
      break;
    case 7:
    case 8:
    case 0xB:
    case 0xC:
      v48 = -1;
      v36 = 0;
      v44 = dword_EA3E4[*(signed __int16 *)(a1 + 26)];
      for ( n = *(_DWORD *)(dword_D41A4 + 38519); n > dword_EA3E4[0]; n = *(_DWORD *)n )
      {
        if ( *(_WORD *)(n + 26) != *(_WORD *)(a1 + 26) && !(*(_BYTE *)(n + 12) & 0x20) )
        {
          v38 = *(signed __int16 *)(*(_DWORD *)(v44 + 160) + 28);
          if ( sub_583F0((_WORD *)(n + 76), (_WORD *)(a1 + 76)) <= v38 )
          {
            v39 = sub_68490((__int16 *)a1, n, 0x71u, 0x71u);
            if ( v39 < v48 )
            {
              v36 = n;
              v48 = v39;
            }
          }
        }
      }
      if ( !v36 )
        return 0;
      *(_WORD *)(a1 + 150) = (signed int)(v36 - (dword_D41A0 + 28302)) / 168;
      sub_655C0((_WORD *)a1, v36);
      if ( *(_BYTE *)(v36 + 63) == 3 && !*(_BYTE *)(v36 + 64) )
        sub_5EF70(v36);
      return 1;
    case 9:
      v1 = -1;
      v54 = 0;
      for ( ii = *(_DWORD *)(dword_D41A4 + 38519); ii > dword_EA3E4[0]; ii = *(_DWORD *)ii )
      {
        if ( *(_WORD *)(ii + 26) != *(_WORD *)(a1 + 26) && !(*(_BYTE *)(ii + 12) & 0x20) )
        {
          v3 = *(signed __int16 *)(a1 + 132) * *(_DWORD *)(a1 + 4);
          if ( sub_583F0((_WORD *)(ii + 76), (_WORD *)(a1 + 76)) <= v3 )
          {
            v4 = *(_BYTE *)(ii + 64) == 2 ? sub_685D0((__int16 *)a1, ii, 0x71u, 0x71u) : sub_68490(
                                                                                           (__int16 *)a1,
                                                                                           ii,
                                                                                           0x71u,
                                                                                           0x71u);
            if ( v4 < v1 )
            {
              v54 = ii;
              v1 = v4;
            }
          }
        }
      }
      for ( jj = 0; jj < 29; ++jj )
      {
        for ( kk = *(_DWORD *)(dword_D41A4 + 4 * jj + 38403); kk > dword_EA3E4[0]; kk = *(_DWORD *)kk )
        {
          if ( *(_WORD *)(kk + 26) != *(_WORD *)(a1 + 26)
            && *(_BYTE *)(kk + 57)
            && (*(_BYTE *)(kk + 73) != 14 || *(unsigned __int16 *)(kk + 40) != *(signed __int16 *)(a1 + 26)) )
          {
            v6 = sub_68490((__int16 *)a1, kk, 0x71u, 0x200u);
            if ( v6 < v1 )
            {
              v54 = kk;
              v1 = v6;
            }
          }
        }
      }
      if ( !v54 )
        return 0;
      *(_WORD *)(a1 + 150) = (v54 - (dword_D41A0 + 28302)) / 168;
      sub_655C0((_WORD *)a1, v54);
      return 1;
    case 0x10:
      v55 = -1;
      v45 = dword_EA3E4[*(signed __int16 *)(a1 + 26)];
      v18 = 0;
      for ( ll = *(_DWORD *)(dword_D41A4 + 38519); ll > dword_EA3E4[0]; ll = *(_DWORD *)ll )
      {
        if ( *(_WORD *)(ll + 26) != *(_WORD *)(a1 + 26) && !(*(_BYTE *)(ll + 12) & 0x20) )
        {
          v20 = *(signed __int16 *)(*(_DWORD *)(v45 + 160) + 28);
          if ( sub_583F0((_WORD *)(ll + 76), (_WORD *)(a1 + 76)) <= v20 )
          {
            v21 = *(_BYTE *)(ll + 64) == 2 ? sub_685D0((__int16 *)a1, ll, 0x100u, 0x71u) : sub_68490(
                                                                                             (__int16 *)a1,
                                                                                             ll,
                                                                                             0x100u,
                                                                                             0x71u);
            if ( v21 < v55 )
            {
              v18 = ll;
              v55 = v21;
            }
          }
        }
      }
      for ( mm = 0; mm < 29; ++mm )
      {
        for ( nn = *(_DWORD *)(dword_D41A4 + 4 * mm + 38403); nn > dword_EA3E4[0]; nn = *(_DWORD *)nn )
        {
          v23 = *(_WORD *)(a1 + 26);
          if ( *(_WORD *)(nn + 26) != v23
            && *(_BYTE *)(nn + 57)
            && (*(_BYTE *)(nn + 73) != 14 || *(unsigned __int16 *)(nn + 40) != v23) )
          {
            v24 = sub_68490((__int16 *)a1, nn, 0x100u, 0x71u);
            if ( v24 < v55 )
            {
              v18 = nn;
              v55 = v24;
            }
          }
        }
      }
      if ( !v18 )
        return 0;
      *(_WORD *)(a1 + 150) = (signed int)(v18 - (dword_D41A0 + 28302)) / 168;
      sub_655C0((_WORD *)a1, v18);
      if ( *(_BYTE *)(v18 + 63) == 3 && !*(_BYTE *)(v18 + 64) )
        sub_5EF70(v18);
      return 1;
    case 0x19:
      v40 = 0;
      v47 = -1;
      for ( i1 = 0; i1 < 29; ++i1 )
      {
        for ( i2 = *(_DWORD *)(dword_D41A4 + 4 * i1 + 38403); i2 > dword_EA3E4[0]; i2 = *(_DWORD *)i2 )
        {
          if ( *(_WORD *)(i2 + 26) != *(_WORD *)(a1 + 26) )
          {
            if ( *(_BYTE *)(i2 + 57) )
            {
              if ( sub_3A7F0((_BYTE *)i2) )
              {
                v42 = sub_68490((__int16 *)a1, i2, 0x71u, 0x71u);
                if ( v42 < v47 )
                {
                  v40 = i2;
                  v47 = v42;
                }
              }
            }
          }
        }
      }
      if ( !v40 )
        return 0;
      *(_WORD *)(a1 + 150) = (v40 - (dword_D41A0 + 28302)) / 168;
      sub_655C0((_WORD *)a1, v40);
      return 1;
    default:
      return 0;
  }
  while ( v26 > dword_EA3E4[0] )
  {
    v27 = *(_BYTE *)(v26 + 64);
    if ( v27 < 0x27u )
      goto LABEL_105;
    if ( v27 <= 0x27u )
    {
      v28 = *(signed __int16 *)(a1 + 26);
      v29 = *(unsigned __int16 *)(v26 + 148);
    }
    else
    {
      if ( v27 != 57 )
        goto LABEL_105;
      v28 = *(signed __int16 *)(a1 + 26);
      v29 = *(unsigned __int16 *)(v26 + 40);
    }
    if ( v29 != v28 )
    {
      if ( *(_BYTE *)(v26 + 57) )
      {
        v30 = sub_68490((__int16 *)a1, v26, 0x71u, 0x71u);
        if ( v30 < v25 )
        {
          v56 = v26;
          v25 = v30;
        }
      }
    }
LABEL_105:
    v26 = *(_DWORD *)v26;
  }
  for ( i3 = *(_DWORD *)(dword_D41A4 + 38527); i3 > dword_EA3E4[0]; i3 = *(_DWORD *)i3 )
  {
    if ( *(unsigned __int16 *)(i3 + 148) != *(signed __int16 *)(a1 + 26) )
    {
      if ( *(_BYTE *)(i3 + 57) )
      {
        if ( !(byte_D93C2[4 * *(char *)(i3 + 70)] & 8) )
        {
          v32 = sub_68490((__int16 *)a1, i3, 0x71u, 0x71u);
          if ( v32 < v25 )
          {
            v56 = i3;
            v25 = v32;
          }
        }
      }
    }
  }
  for ( i4 = *(_DWORD *)(dword_D41A4 + 38491); i4 > dword_EA3E4[0]; i4 = *(_DWORD *)i4 )
  {
    if ( *(_BYTE *)(i4 + 57) )
    {
      for ( i5 = *(unsigned __int16 *)(i4 + 52); ; i5 = *(unsigned __int16 *)(v52 + 52) )
      {
        v52 = dword_EA3E4[i5];
        if ( v52 == dword_EA3E4[0] )
          break;
        v35 = sub_68490((__int16 *)a1, v52, 0x71u, 0x71u);
        if ( v35 < v25 )
        {
          v25 = v35;
          v56 = v52;
        }
      }
    }
  }
  if ( !v56 )
    return 0;
  *(_WORD *)(a1 + 150) = (v56 - (dword_D41A0 + 28302)) / 168;
  sub_655C0((_WORD *)a1, v56);
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068490) --------------------------------------------------------
int __cdecl sub_68490(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  _WORD *v4; // edi
  __int16 v5; // ax
  int result; // eax
  __int16 v7; // ax
  signed int v8; // ebx
  int v9; // esi
  int v10; // edi
  int v11; // eax
  int v12; // edx
  unsigned __int16 v13; // [esp+0h] [ebp-8h]
  unsigned __int16 v14; // [esp+4h] [ebp-4h]

  sub_65580(a2);
  v4 = a1 + 38;
  v5 = sub_581E0(a1 + 38, (_WORD *)(a2 + 76));
  v13 = sub_582B0(a1[14], v5);
  if ( v13 <= a3 )
  {
    v7 = sub_58210(v4, (_WORD *)(a2 + 76));
    v14 = sub_582B0(a1[15], v7);
    if ( v14 <= a4 )
    {
      v8 = sub_58490(v4, (_WORD *)(a2 + 76));
      if ( v8 <= 5120 )
      {
        sub_655A0(a2);
        v9 = v8 * (_DWORD)off_DBF50[v13];
        v10 = v8 * dword_DB750[v13];
        v11 = v8 * (_DWORD)off_DBF50[v14];
        v12 = 4 * dword_DB750[v14] * v8 >> 16;
        result = (v11 >> 16) * (v11 >> 16) + (v9 >> 16) * (v9 >> 16) + (4 * v10 >> 16) * (4 * v10 >> 16) + v12 * v12;
      }
      else
      {
        sub_655A0(a2);
        result = -1;
      }
    }
    else
    {
      sub_655A0(a2);
      result = -1;
    }
  }
  else
  {
    sub_655A0(a2);
    result = -1;
  }
  return result;
}
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();

//----- (000685D0) --------------------------------------------------------
int __cdecl sub_685D0(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  _WORD *v4; // ebx
  _WORD *v5; // esi
  __int16 v6; // ax
  __int16 v8; // ax
  unsigned __int16 v9; // di
  signed int v10; // eax
  int v11; // ebx
  int v12; // ecx
  int v13; // esi
  int v14; // eax
  unsigned __int16 v15; // [esp+0h] [ebp-4h]

  v4 = (_WORD *)(a2 + 76);
  v5 = a1 + 38;
  v6 = sub_581E0(a1 + 38, (_WORD *)(a2 + 76));
  v15 = sub_582B0(a1[14], v6);
  if ( v15 > a3 )
    return -1;
  v8 = sub_58210(v5, v4);
  v9 = sub_582B0(a1[15], v8);
  if ( v9 > a4 )
    return -1;
  v10 = sub_58490(v5, v4);
  if ( v10 > 5120 )
    return -1;
  v11 = v10 * (_DWORD)off_DBF50[v15];
  v12 = v10 * dword_DB750[v15];
  v13 = v10 * (_DWORD)off_DBF50[v9];
  v14 = 4 * dword_DB750[v9] * v10 >> 16;
  return (4 * v12 >> 16) * (4 * v12 >> 16) + (v11 >> 16) * (v11 >> 16) + (v13 >> 16) * (v13 >> 16) + v14 * v14;
}
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();

//----- (000686D0) --------------------------------------------------------
int __cdecl sub_686D0(int a1, unsigned int a2)
{
  int result; // eax
  unsigned int v3; // ebx
  char v4; // dh

  result = a2;
  v3 = dword_EA3E4[*(signed __int16 *)(a1 + 26)];
  if ( v3 > dword_EA3E4[0] && *(_BYTE *)(v3 + 63) == 3 )
  {
    v4 = *(_BYTE *)(v3 + 64);
    if ( !v4 || v4 == 1 )
    {
      if ( a2 )
      {
        if ( a2 > dword_EA3E4[0] )
        {
          result = (signed int)(a2 - (dword_D41A0 + 28302)) / 168;
          *(_WORD *)(v3 + 150) = result;
        }
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068740) --------------------------------------------------------
char __cdecl sub_68740(int a1, int a2, unsigned __int16 a3, __int16 a4)
{
  char v4; // cl
  char v5; // ch
  unsigned __int8 v6; // al
  __int16 v7; // ax
  int v8; // esi
  int v9; // eax
  __int16 v10; // dx
  int v11; // eax

  v4 = 0;
  v5 = 0;
  if ( (*(_DWORD *)(a1 + 144) - (__CFSHL__(*(_DWORD *)(a1 + 144) >> 31, 2) + 4 * (*(_DWORD *)(a1 + 144) >> 31))) >> 2 > *(_DWORD *)(a2 + 144) )
    return v4;
  if ( *(_BYTE *)(a1 + 67) != 10 )
  {
    if ( *(_BYTE *)(a1 + 64) != 13 )
      goto LABEL_23;
    goto LABEL_22;
  }
  v6 = *(_BYTE *)(a1 + 68);
  if ( v6 >= 0x11u )
  {
    if ( v6 > 0x11u )
    {
      if ( v6 < 0x43u )
      {
        if ( v6 != 22 )
          goto LABEL_23;
      }
      else if ( v6 > 0x43u && (v6 < 0x47u || v6 > 0x47u && v6 != 89) )
      {
        goto LABEL_23;
      }
    }
LABEL_22:
    v5 = 1;
    goto LABEL_23;
  }
  if ( v6 < 9u )
  {
    if ( v6 > 1u )
      goto LABEL_23;
    goto LABEL_22;
  }
  if ( v6 <= 9u || v6 >= 0xBu && (v6 <= 0xBu || v6 == 15) )
    goto LABEL_22;
LABEL_23:
  if ( v5 )
  {
    sub_6E450((a2 - (dword_D41A0 + 28302)) / 168, -1, 28);
    sub_6D8B0((a2 - (dword_D41A0 + 28302)) / 168, 8u, 1);
    *(_DWORD *)(a2 + 144) -= (*(_DWORD *)(a1 + 144)
                            - (__CFSHL__(*(_DWORD *)(a1 + 144) >> 31, 2)
                             + 4 * (*(_DWORD *)(a1 + 144) >> 31))) >> 2;
    v7 = *(_WORD *)(a1 + 28);
    HIBYTE(v7) = (HIBYTE(v7) + 4) & 7;
    *(_WORD *)(a1 + 32) = v7;
    v8 = sub_582F0(0, *(_WORD *)(a1 + 30));
    v9 = -(v8 * sub_582B0(0, *(_WORD *)(a1 + 30)));
    BYTE1(v9) &= 7u;
    *(_WORD *)(a1 + 34) = v9;
    *(_WORD *)(a1 + 30) = v9;
    if ( *(_BYTE *)(a2 + 12) & 0x10 )
    {
      v10 = *(_WORD *)(a1 + 42);
      *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
      *(_WORD *)(a1 + 42) = 2 * v10;
    }
    else
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 20) % a3 - a4;
    }
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 26);
    *(_WORD *)(a1 + 26) = *(_WORD *)(a2 + 26);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
    v11 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    *(_BYTE *)(a1 + 65) = *(_BYTE *)(v11 + 63);
    *(_BYTE *)(a1 + 66) = *(_BYTE *)(v11 + 64);
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a2 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a2 + 80);
    word_EB39C += *(_WORD *)(a2 + 88);
    sub_57CF0(a1, (int)&word_EB398);
    v4 = 1;
  }
  return v4;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00068940) --------------------------------------------------------
char __cdecl sub_68940(int a1)
{
  unsigned __int8 v1; // al
  __int16 v2; // dx
  unsigned int i; // ebx
  signed int v4; // ST08_4
  signed int v5; // edi
  __int16 v6; // ax
  void (__noreturn *v8)(); // [esp+8h] [ebp-10h]
  int v9; // [esp+Ch] [ebp-Ch]
  int v10; // [esp+10h] [ebp-8h]
  char v11; // [esp+14h] [ebp-4h]

  v11 = 0;
  v10 = 0;
  v1 = *(_BYTE *)(a1 + 64);
  v8 = sub_10000;
  if ( v1 < 0xCu )
  {
    if ( v1 < 2u )
    {
      if ( v1 )
        return v11;
    }
    else if ( v1 > 5u && (v1 < 8u || v1 > 9u) )
    {
      return v11;
    }
  }
  else if ( v1 > 0xCu )
  {
    if ( v1 < 0x1Au )
    {
      if ( v1 < 0x16u || v1 > 0x17u )
        return v11;
    }
    else if ( v1 > 0x1Au && (v1 < 0x1Cu || v1 > 0x1Cu && v1 != 30) )
    {
      return v11;
    }
  }
  v2 = *(_WORD *)(a1 + 26);
  if ( v2 )
  {
    v9 = dword_EA3E4[v2];
    if ( *(_BYTE *)(v9 + 63) == 3 )
    {
      for ( i = *(_DWORD *)(dword_D41A4 + 38535); i > dword_EA3E4[0]; i = *(_DWORD *)i )
      {
        if ( *(_BYTE *)(i + 64) == 78
          && *(unsigned __int16 *)(i + 50) == *(signed __int16 *)(a1 + 26)
          && *(_WORD *)(i + 54) == -1 )
        {
          v4 = *(signed __int16 *)(*(_DWORD *)(v9 + 160) + 28);
          v5 = sub_583F0((_WORD *)(i + 76), (_WORD *)(v9 + 76));
          if ( v5 < v4 && v5 < (signed int)v8 )
          {
            v6 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
            if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v6) < 0xAAu )
            {
              v10 = i;
              v8 = (void (__noreturn *)())v5;
            }
          }
        }
      }
      if ( v10 )
      {
        *(_WORD *)(a1 + 150) = (v10 - (dword_D41A0 + 28302)) / 168;
        v11 = 1;
        sub_655C0((_WORD *)a1, v10);
      }
    }
  }
  return v11;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068AC0) --------------------------------------------------------
char __cdecl sub_68AC0(int a1, int a2)
{
  unsigned __int8 v2; // al
  char v3; // dl
  unsigned __int16 v4; // di
  int v5; // edx

  v2 = *(_BYTE *)(a1 + 64);
  v3 = 0;
  if ( v2 < 0xCu )
  {
    if ( v2 < 2u )
    {
      if ( v2 )
        return v3;
    }
    else if ( v2 > 5u && (v2 < 8u || v2 > 9u) )
    {
      return v3;
    }
  }
  else if ( v2 > 0xCu )
  {
    if ( v2 < 0x1Au )
    {
      if ( v2 < 0x16u || v2 > 0x17u )
        return v3;
    }
    else if ( v2 > 0x1Au && (v2 < 0x1Cu || v2 > 0x1Cu && v2 != 30) )
    {
      return v3;
    }
  }
  if ( a2
    && *(_BYTE *)(a2 + 63) == 10
    && *(_BYTE *)(a2 + 64) == 78
    && *(unsigned __int16 *)(a2 + 50) == *(signed __int16 *)(a1 + 26)
    && *(_WORD *)(a2 + 54) == -1 )
  {
    sub_4A190(a1 + 76, 10, 0);
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 26);
    v4 = *(_WORD *)(a1 + 38);
    if ( v4 )
    {
      v5 = dword_EA3E4[v4];
      *(_WORD *)(a2 + 54) = *(char *)(v5 + 64);
      *(_WORD *)(a2 + 52) = *(char *)(v5 + 70);
      *(_WORD *)(v5 + 46) = 1;
    }
    v3 = 1;
  }
  return v3;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068BD0) --------------------------------------------------------
char __cdecl sub_68BD0(int a1, _BYTE *a2)
{
  char result; // al

  result = a2[63];
  if ( result == 5 )
  {
    result = a2[64];
    if ( !result )
      a2[61] = 32;
  }
  return result;
}

//----- (00068BF0) --------------------------------------------------------
int sub_68BF0()
{
  __int16 i; // si
  int result; // eax
  unsigned int j; // ebx
  _DWORD *k; // ebx

  for ( i = 0; i < 29; ++i )
  {
    result = dword_D41A4;
    for ( j = *(_DWORD *)(dword_D41A4 + 4 * i + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
    {
      if ( *(_DWORD *)(j + 8) >= 0 )
      {
        result = sub_68C70(j);
      }
      else
      {
        *(_BYTE *)(j + 57) = -6;
        *(_BYTE *)(j + 58) = 0;
      }
    }
  }
  for ( k = *(_DWORD **)(dword_D41A4 + 38523); (unsigned int)k > dword_EA3E4[0]; k = (_DWORD *)*k )
    result = sub_68C70((int)k);
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068C70) --------------------------------------------------------
int __cdecl sub_68C70(int a1)
{
  char v1; // dh
  int v2; // eax
  unsigned int v3; // eax
  int result; // eax
  int i; // eax
  unsigned int v6; // eax

  if ( *(_BYTE *)(a1 + 57) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 <= dword_EA3E4[0] )
        break;
      *(_BYTE *)(v6 + 57) = *(_BYTE *)(a1 + 57);
    }
    --*(_BYTE *)(a1 + 57);
    return 0;
  }
  if ( *(_BYTE *)(a1 + 12) & 1 )
    return 0;
  v1 = *(_BYTE *)(a1 + 58);
  if ( v1 )
  {
    *(_BYTE *)(a1 + 58) = v1 - 1;
    result = 0;
  }
  else
  {
    if ( (unsigned int)sub_584D0(
                         (_WORD *)(a1 + 76),
                         (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12)
                                                                   + dword_D41A0
                                                                   + 11240)]
                                 + 76)) < 0x2400000 )
    {
      v2 = *(unsigned __int16 *)(a1 + 52);
      *(_BYTE *)(a1 + 57) = 16;
      while ( 1 )
      {
        v3 = dword_EA3E4[v2];
        if ( v3 <= dword_EA3E4[0] )
          break;
        *(_BYTE *)(v3 + 57) = *(_BYTE *)(a1 + 57) + 2;
        v2 = *(unsigned __int16 *)(v3 + 52);
      }
    }
    *(_BYTE *)(a1 + 58) = 0;
    result = 0;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068D50) --------------------------------------------------------
signed int __cdecl sub_68D50(int a1, _DWORD *a2)
{
  int v2; // esi
  unsigned __int16 v3; // cx
  signed int result; // eax

  if ( a2[36] < 0 )
    goto LABEL_14;
  if ( a2[2] < 0 )
    goto LABEL_14;
  v2 = *(_DWORD *)(a1 + 136);
  if ( v2 )
  {
    v3 = *(_WORD *)(a2[41] + 58);
    if ( !v3 || v2 > *(_DWORD *)(dword_EA3E4[v3] + 144) )
      goto LABEL_14;
  }
  if ( a2[36] >= *(_DWORD *)(a1 + 140) && *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
    return 1;
  if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
LABEL_14:
    result = 0;
  else
    result = 1;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068DE0) --------------------------------------------------------
signed int __cdecl sub_68DE0(int a1, int a2)
{
  __int16 v2; // bx
  int v3; // ebx
  signed int result; // eax

  v2 = *(_WORD *)(a1 + 46);
  if ( v2 == *(_WORD *)(a1 + 48) )
  {
    v3 = *(_DWORD *)(a2 + 136);
    if ( v3 >= 0 )
      *(_DWORD *)(a2 + 136) = -*(_DWORD *)(a1 + 140);
    else
      *(_DWORD *)(a2 + 136) = v3 - *(_DWORD *)(a1 + 140);
    result = 1;
  }
  else
  {
    if ( v2 && *(_DWORD *)(a2 + 136) > 0 )
      *(_DWORD *)(a2 + 136) = 0;
    result = 0;
  }
  return result;
}

//----- (00068E50) --------------------------------------------------------
signed int __cdecl sub_68E50(int a1, int a2, int a3)
{
  char v3; // cl
  unsigned __int16 v4; // cx
  unsigned __int16 v5; // ax
  signed __int16 v6; // ax
  int i; // eax
  int v8; // esi
  signed int result; // eax
  unsigned __int16 v10; // cx
  unsigned __int16 v11; // ax
  signed __int16 v12; // ax
  int j; // esi
  int v14; // [esp+0h] [ebp-8h]
  int v15; // [esp+4h] [ebp-4h]

  v14 = *(_DWORD *)(a2 + 76);
  LOWORD(v15) = *(_WORD *)(a2 + 80);
  v3 = *(_BYTE *)(a1 + 13);
  if ( v3 & 1 )
  {
    if ( *(_BYTE *)(a3 + 64) == 4 && (v4 = *(_WORD *)(a3 + 150)) != 0 )
    {
      LOWORD(v15) = *(_WORD *)(dword_EA3E4[v4] + 82) + *(_WORD *)(dword_EA3E4[v4] + 80);
    }
    else
    {
      v5 = *(_WORD *)(a1 + 28) - 512;
      HIBYTE(v5) &= 7u;
      sub_57FA0(&v14, v5, 0, 256);
    }
    v6 = sub_10C40((__int16 *)&v14);
    if ( v6 > (signed __int16)v15 )
    {
      v14 = *(_DWORD *)(a2 + 76);
      LOWORD(v15) = *(_WORD *)(a2 + 80);
    }
    for ( i = *(unsigned __int16 *)(a2 + 52); ; i = *(unsigned __int16 *)(v8 + 52) )
    {
      v8 = dword_EA3E4[i];
      if ( v8 == dword_EA3E4[0] )
        break;
      sub_57CF0(v8, (int)&v14);
    }
    result = sub_57CF0(a2, (int)&v14);
  }
  else
  {
    if ( v3 & 2 )
    {
      if ( *(_BYTE *)(a3 + 64) == 4 && (v10 = *(_WORD *)(a3 + 150)) != 0 )
      {
        LOWORD(v15) = *(_WORD *)(dword_EA3E4[v10] + 82) + *(_WORD *)(dword_EA3E4[v10] + 80);
      }
      else
      {
        v11 = *(_WORD *)(a1 + 28);
        HIBYTE(v11) = (HIBYTE(v11) + 2) & 7;
        sub_57FA0(&v14, v11, 0, 256);
      }
      v12 = sub_10C40((__int16 *)&v14);
      if ( v12 > (signed __int16)v15 )
      {
        v14 = *(_DWORD *)(a2 + 76);
        LOWORD(v15) = *(_WORD *)(a2 + 80);
      }
      for ( j = dword_EA3E4[*(unsigned __int16 *)(a2 + 52)];
            j != dword_EA3E4[0];
            j = dword_EA3E4[*(unsigned __int16 *)(j + 52)] )
      {
        sub_57CF0(j, (int)&v14);
      }
    }
    result = sub_57CF0(a2, (int)&v14);
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068FF0) --------------------------------------------------------
signed int __cdecl sub_68FF0(int a1, char a2, char a3)
{
  int v3; // edx
  __int16 v4; // ax
  unsigned int i; // esi
  int v6; // eax
  char v7; // al
  int v8; // ecx
  __int16 v9; // ax
  int v10; // eax
  char v12; // [esp+0h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 8);
  v12 = 0;
  if ( v3 && (*(_DWORD *)(a1 + 8) = v3 - 1, v3 == 1) )
  {
    sub_57F10(a1);
  }
  else
  {
    v4 = sub_10C40((__int16 *)(a1 + 76));
    sub_580E0(a1 + 76, v4, 0, 0x2000, -128);
    if ( !(*(_BYTE *)(a1 + 62) & 3) )
    {
      for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
      {
        if ( !*(_BYTE *)(i + 64) && *(_DWORD *)(i + 8) >= 0 )
        {
          v6 = *(_DWORD *)(i + 164);
          if ( *(_WORD *)(v6 + 56) == *(_WORD *)(dword_D41A0 + 12)
            && !(*(_BYTE *)(a1 + 12) & 1)
            && *(_WORD *)(v6 + 2 * *(char *)(a1 + 64) + 819) )
          {
            *(_BYTE *)(a1 + 12) |= 1u;
          }
          if ( sub_106C0(i, a1) )
          {
            v7 = 0;
            if ( *(_WORD *)(*(_DWORD *)(i + 164) + 2 * a2 + 819) )
              v7 = 1;
            if ( !v7 )
            {
              sub_6E450((signed int)(i - (dword_D41A0 + 28302)) / 168, -1, 18);
              v8 = dword_D41A0;
              *(_BYTE *)(a1 + 12) |= 1u;
              v8 += 28302;
              *(_BYTE *)(a1 + 15) &= 0xFDu;
              *(_WORD *)(a1 + 40) = (signed int)(i - v8) / 168;
              *(_BYTE *)(a1 + 69) = a3;
              *(_WORD *)(a1 + 54) = 64;
              *(_WORD *)(2 * a2 + *(_DWORD *)(i + 164) + 819) = (a1 - v8) / 168;
              *(_BYTE *)(*(_DWORD *)(i + 164) + a2 + 1027) = 1;
              v9 = *(_WORD *)(a1 + 74);
              if ( v9 )
              {
                if ( v9 == 2 )
                  v12 = 1;
                *(_WORD *)(a1 + 74) = 0;
              }
              else
              {
                v10 = *(_DWORD *)(i + 164);
                if ( *(signed __int16 *)(v10 + 1105) == -1 || *(signed __int16 *)(v10 + 1107) != -1 )
                  v12 = 1;
              }
              if ( v12 )
              {
                *(_WORD *)(*(_DWORD *)(i + 164) + 1105) = *(char *)(a1 + 64);
                *(_BYTE *)(*(_DWORD *)(i + 164) + 1109) = *(_BYTE *)(*(char *)(a1 + 64) + *(_DWORD *)(i + 164) + 1079);
              }
              else
              {
                *(_WORD *)(*(_DWORD *)(i + 164) + 1107) = *(char *)(a1 + 64);
                *(_BYTE *)(*(_DWORD *)(i + 164) + 1110) = *(_BYTE *)(*(char *)(a1 + 64) + *(_DWORD *)(i + 164) + 1079);
              }
              sub_6D5E0(a1, *(_BYTE *)(*(char *)(a1 + 64) + *(_DWORD *)(i + 164) + 1079));
              return 1;
            }
          }
        }
      }
    }
  }
  return 0;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00069250) --------------------------------------------------------
signed int __cdecl sub_69250(int a1)
{
  signed int result; // eax

  result = sub_68FF0(a1, *(_BYTE *)(a1 + 64), *(_BYTE *)(a1 + 69) - 2);
  if ( result )
  {
    result = (*(int (__cdecl **)(int))((char *)&off_D781E + 14 * *(char *)(a1 + 64)))(a1 + 76);
    if ( result )
      *(_BYTE *)(result + 69) += 2;
  }
  return result;
}
// D781E: using guessed type int (__cdecl *off_D781E)(int);

//----- (000692A0) --------------------------------------------------------
signed int __cdecl sub_692A0(int a1)
{
  return sub_68FF0(a1, *(_BYTE *)(a1 + 64), *(_BYTE *)(a1 + 69) - 1);
}

//----- (000692C0) --------------------------------------------------------
char __cdecl sub_692C0(int a1)
{
  char result; // al
  char v2; // ah

  result = sub_59DC0((_WORD *)a1);
  if ( result )
  {
    result = 3 * *(_BYTE *)(a1 + 64) + 1;
    *(_BYTE *)(a1 + 69) = result;
    v2 = *(_BYTE *)(a1 + 15);
    *(_WORD *)(a1 + 38) = 0;
    *(_BYTE *)(a1 + 15) = v2 | 2;
  }
  return result;
}

//----- (00069300) --------------------------------------------------------
void __cdecl sub_69300(int a1, int a2)
{
  char v2; // ah
  int v3; // eax
  int v4; // edx
  int v5; // edx
  int v6; // [esp+0h] [ebp-4h]

  if ( !*(_WORD *)(a1 + 54) )
  {
    *(_WORD *)(a1 + 38) = (a2 - (dword_D41A0 + 28302)) / 168;
    v2 = *(_BYTE *)(a1 + 12);
    *(_BYTE *)(a1 + 69) = 78;
    *(_BYTE *)(a1 + 12) = v2 & 0xFE;
    v3 = *(unsigned __int16 *)(a1 + 40);
    *(_DWORD *)(a1 + 16) = 0;
    v6 = dword_EA3E4[v3];
    *(_DWORD *)&word_EB398 = *(_DWORD *)(v6 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(v6 + 80);
    sub_57CF0(a1, (int)&word_EB398);
    *(_WORD *)(*(_DWORD *)(v6 + 164) + 2 * *(char *)(a1 + 64) + 819) = 0;
    *(_WORD *)(a1 + 74) = 0;
    v4 = *(_DWORD *)(v6 + 164);
    if ( *(char *)(a1 + 64) == *(_WORD *)(v4 + 1107) )
    {
      *(_WORD *)(v4 + 1107) = -1;
      *(_WORD *)(a1 + 74) = 1;
    }
    v5 = *(_DWORD *)(v6 + 164);
    if ( *(char *)(a1 + 64) == *(_WORD *)(v5 + 1105) )
    {
      *(_WORD *)(v5 + 1105) = -1;
      *(_WORD *)(a1 + 74) = 2;
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (000693F0) --------------------------------------------------------
int __cdecl sub_693F0(int a1)
{
  unsigned int v1; // ebx
  int v2; // eax
  __int16 v3; // si
  int result; // eax
  __int16 v5; // dx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (_DWORD *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = sub_6DCA0(
                 v1,
                 v1 + 76,
                 0,
                 (__int16 *)&byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)],
                 *(_WORD *)(v1 + 130),
                 1);
          v6 = v2;
          if ( v2 )
          {
            sub_68E50(v1, v2, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 42) = *(_WORD *)(a1 + 42);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0(
              (_WORD *)(v6 + 154),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30),
              0x4000);
            if ( *(_WORD *)(*(_DWORD *)(v1 + 164) + 56) == *(_WORD *)(dword_D41A0 + 12) )
              sub_49C90(v6, 42);
          }
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00069600) --------------------------------------------------------
signed int __cdecl sub_69600(int a1)
{
  return sub_692A0(a1);
}

//----- (00069620) --------------------------------------------------------
signed int __cdecl sub_69620(int a1)
{
  return sub_69250(a1);
}

//----- (00069640) --------------------------------------------------------
void __cdecl sub_69640(int a1)
{
  _DWORD *v1; // eax
  char *v2; // edi
  char v3; // dl
  int v4; // esi
  char v5; // dl
  char v6; // ah
  char v7; // cl
  __int16 v8; // di
  __int16 v9; // dx
  int v10; // [esp+4h] [ebp-4h]

  if ( *(_WORD *)(a1 + 46) <= 0 )
    goto LABEL_28;
  v1 = (_DWORD *)dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
  v10 = (int)v1;
  if ( (unsigned int)v1 > dword_EA3E4[0] )
  {
    if ( sub_68D50(a1, v1) )
    {
      if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
      {
        v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
        v3 = v2[24];
        if ( v3 )
        {
          if ( (unsigned __int8)v3 <= 3u )
          {
            v4 = sub_4A190(v10 + 76, 9, 17);
            if ( v4 )
            {
              *(_WORD *)(v4 + 130) += *(_WORD *)(v10 + 130);
              sub_68E50(v10, v4, a1);
              *(_WORD *)(v4 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
              v5 = v2[24];
              if ( (unsigned __int8)v5 >= 1u )
              {
                if ( (unsigned __int8)v5 <= 1u )
                {
                  *(_BYTE *)(v4 + 68) = 54;
                }
                else if ( v5 == 2 )
                {
                  *(_BYTE *)(v4 + 68) = 69;
                }
              }
              *(_BYTE *)(v4 + 67) = 10;
              *(_WORD *)(v4 + 26) = *(_WORD *)(v10 + 26);
              *(_DWORD *)(v4 + 144) = *(_DWORD *)(a1 + 144);
              *(_WORD *)(v4 + 80) += *(_WORD *)(v10 + 88);
              *(_WORD *)(v4 + 28) = *(_WORD *)(*(_DWORD *)(v10 + 164) + 24) + *(_WORD *)(v10 + 28);
              *(_WORD *)(v4 + 30) = *(_WORD *)(*(_DWORD *)(v10 + 164) + 26) + *(_WORD *)(v10 + 30);
              *(_DWORD *)(v4 + 16) = (*(unsigned __int16 *)(a1 + 42) << 8) * (*(unsigned __int16 *)(a1 + 42) << 8);
              *(_BYTE *)(*(_DWORD *)(v10 + 164) + 340) = 0;
              *(_DWORD *)(v4 + 154) = *(_DWORD *)(v10 + 76);
              *(_WORD *)(v4 + 158) = *(_WORD *)(v10 + 80);
              sub_57FA0(
                (_WORD *)(v4 + 154),
                *(_WORD *)(*(_DWORD *)(v10 + 164) + 24) + *(_WORD *)(v10 + 28),
                *(_WORD *)(*(_DWORD *)(v10 + 164) + 26) + *(_WORD *)(v10 + 30),
                0x4000);
              sub_6E450((v4 - (dword_D41A0 + 28302)) / 168, -1, 40);
              sub_68DE0(a1, v10);
              goto LABEL_26;
            }
          }
        }
        else
        {
          sub_69900(a1, v10);
        }
      }
      else
      {
        v6 = *(_BYTE *)(a1 + 60);
        if ( v6 )
        {
          if ( *(_BYTE *)(a1 + 70) )
          {
            if ( v6 == 1 )
              sub_69900(a1, v10);
            v7 = *(_BYTE *)(a1 + 60) + 1;
            *(_BYTE *)(a1 + 60) = v7;
            if ( v7 > 3 )
            {
              *(_BYTE *)(a1 + 60) = 0;
              sub_68DE0(a1, v10);
              goto LABEL_26;
            }
          }
          else
          {
            *(_BYTE *)(a1 + 60) = 0;
          }
        }
      }
      sub_68DE0(a1, v10);
    }
    else
    {
      *(_WORD *)(a1 + 46) = 1;
    }
  }
LABEL_26:
  v8 = *(_WORD *)(a1 + 46) - 1;
  *(_WORD *)(a1 + 46) = v8;
  if ( !v8 )
    sub_6D880(a1);
LABEL_28:
  v9 = *(_WORD *)(a1 + 54);
  if ( v9 )
    *(_WORD *)(a1 + 54) = v9 - 1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00069900) --------------------------------------------------------
void __cdecl sub_69900(int a1, int a2)
{
  int v2; // ebx
  int v3; // edx
  int v4; // eax

  v2 = sub_4A190(a2 + 76, 9, 1);
  if ( v2 )
  {
    *(_WORD *)(v2 + 130) += *(_WORD *)(a2 + 130);
    sub_68E50(a2, v2, a1);
    v3 = a1 - (dword_D41A0 + 28302);
    *(_BYTE *)(v2 + 67) = 10;
    *(_WORD *)(v2 + 38) = v3 / 168;
    *(_BYTE *)(v2 + 68) = 12;
    *(_WORD *)(v2 + 26) = *(_WORD *)(a2 + 26);
    *(_WORD *)(v2 + 80) += *(_WORD *)(a2 + 88);
    *(_DWORD *)(v2 + 144) = *(_DWORD *)(a1 + 144);
    *(_DWORD *)(v2 + 16) = 200;
    *(_BYTE *)(*(_DWORD *)(a2 + 164) + 340) = 0;
    *(_DWORD *)(v2 + 154) = *(_DWORD *)(a2 + 76);
    *(_WORD *)(v2 + 158) = *(_WORD *)(a2 + 80);
    sub_57FA0(
      (_WORD *)(v2 + 154),
      *(_WORD *)(*(_DWORD *)(a2 + 164) + 24) + *(_WORD *)(a2 + 28),
      *(_WORD *)(*(_DWORD *)(a2 + 164) + 26) + *(_WORD *)(a2 + 30),
      10240);
    *(_WORD *)(v2 + 28) = *(_WORD *)(*(_DWORD *)(a2 + 164) + 24) + *(_WORD *)(a2 + 28);
    v4 = dword_D41A0 + 28302;
    *(_WORD *)(v2 + 30) = *(_WORD *)(*(_DWORD *)(a2 + 164) + 26) + *(_WORD *)(a2 + 30);
    sub_6E450((v2 - v4) / 168, -1, 40);
  }
}
// D41A0: using guessed type int dword_D41A0;

//----- (00069A70) --------------------------------------------------------
signed int __cdecl sub_69A70(int a1)
{
  return sub_692A0(a1);
}

//----- (00069A90) --------------------------------------------------------
signed int __cdecl sub_69A90(int a1)
{
  return sub_69250(a1);
}

//----- (00069AB0) --------------------------------------------------------
int __cdecl sub_69AB0(int a1)
{
  unsigned int v1; // ebx
  unsigned __int16 v2; // si
  char *v3; // edx
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  unsigned int v7; // edx
  __int16 v8; // ax
  int result; // eax
  __int16 v10; // di
  int v11; // [esp+0h] [ebp-8h]
  int v12; // [esp+4h] [ebp-4h]

  if ( *(_WORD *)(a1 + 46) <= 0 )
  {
    sub_6D880(a1);
  }
  else
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (_DWORD *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = *(_WORD *)(*(_DWORD *)(v1 + 164) + 58);
          v3 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v4 = 1;
          if ( v2 )
            v4 = *(_DWORD *)(dword_EA3E4[v2] + 16) + 1;
          *(_BYTE *)(*(_DWORD *)(v1 + 164) + v4 + 590) = *v3;
          *(_BYTE *)(*(_DWORD *)(v1 + 164) + v4 + 599) = v3[24];
          sub_68DE0(a1, v1);
          v5 = sub_4A190(v1 + 76, 9, 10);
          v12 = v5;
          v11 = v5;
          if ( v5 )
          {
            *(_WORD *)(a1 + 46) = *(_WORD *)(a1 + 48) - 1;
            *(_WORD *)(v5 + 130) += *(_WORD *)(v1 + 130);
            sub_68E50(v1, v5, a1);
            v6 = dword_D41A0 + 28302;
            *(_WORD *)(v12 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v12 + 42) = *(_WORD *)(a1 + 42);
            *(_WORD *)(v12 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v12 + 80) += *(_WORD *)(v1 + 88);
            *(_DWORD *)(v12 + 144) = *(_DWORD *)(a1 + 144);
            v7 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(v1 + 164) + 58)];
            if ( v7 <= dword_EA3E4[0] )
            {
              *(_DWORD *)(v12 + 154) = *(_DWORD *)(v1 + 76);
              *(_WORD *)(v12 + 158) = *(_WORD *)(v1 + 80);
              sub_57FA0((_WORD *)(v12 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
              v8 = sub_10C40((__int16 *)(v12 + 154));
              *(_BYTE *)(v12 + 67) = 3;
              *(_BYTE *)(v12 + 68) = 2;
              *(_WORD *)(v12 + 158) = v8;
            }
            else
            {
              *(_BYTE *)(v12 + 67) = 10;
              *(_BYTE *)(v12 + 68) = 43;
              *(_WORD *)(v12 + 150) = (signed int)(v7 - v6) / 168;
            }
            *(_DWORD *)(v11 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_WORD *)(v11 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v11 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
            sub_6E450((v11 - (dword_D41A0 + 28302)) / 168, -1, 15);
          }
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 0;
      }
    }
  }
  result = a1;
  v10 = *(_WORD *)(a1 + 54);
  if ( v10 )
    *(_WORD *)(a1 + 54) = v10 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00069D70) --------------------------------------------------------
signed int __cdecl sub_69D70(int a1)
{
  return sub_692A0(a1);
}

//----- (00069D90) --------------------------------------------------------
signed int __cdecl sub_69D90(int a1)
{
  return sub_69250(a1);
}

//----- (00069DB0) --------------------------------------------------------
void __cdecl sub_69DB0(int a1)
{
  unsigned int v1; // esi
  signed __int16 v2; // di
  char v3; // dl
  int v4; // eax
  char v5; // cl
  int v6; // eax
  int v7; // ecx
  __int16 v8; // cx
  __int16 v9; // cx
  signed int v10; // [esp+0h] [ebp-8h]
  char *v11; // [esp+4h] [ebp-4h]

  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( *(_BYTE *)(v1 + 64) == 1 )
        v10 = 64;
      else
        v10 = 2;
      if ( *(_WORD *)(*(_DWORD *)(v1 + 164) + 12) >= 0 )
        v2 = 1;
      else
        v2 = -1;
      if ( !sub_68D50(a1, (_DWORD *)v1) || *(_WORD *)(*(_DWORD *)(v1 + 164) + 14) )
      {
        if ( *(_WORD *)(*(_DWORD *)(v1 + 164) + 14) )
          *(_WORD *)(a1 + 46) = 1;
      }
      else
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v3 = *(_BYTE *)(a1 + 12);
          if ( v3 >= 0 )
          {
            v4 = dword_D41A0 + 28302;
            *(_BYTE *)(a1 + 12) = v3 | 0x80;
            sub_6E450((signed int)(v1 - v4) / 168, -1, 19);
          }
        }
        if ( *(signed __int16 *)(a1 + 46) == *(signed __int16 *)(a1 + 48) - v10 )
        {
          v5 = *(_BYTE *)(a1 + 12);
          if ( v5 < 0 )
            *(_BYTE *)(a1 + 12) = v5 & 0x7F;
        }
        v11 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
        _wcpp_1_unwind_leave__98(v1);
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          sub_6D8B0(*(_WORD *)(a1 + 40), 3u, 1);
          *(_WORD *)(*(_DWORD *)(v1 + 164) + 12) = v2 * *(_WORD *)(v1 + 132) * (*(_WORD *)v11 + 1);
        }
        else
        {
          *(_WORD *)(*(_DWORD *)(v1 + 164) + 12) = v2 * *(_WORD *)v11 * *(_WORD *)(v1 + 132);
        }
        *(_WORD *)(v1 + 130) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 12);
        if ( !(*(_BYTE *)(a1 + 62) & 3) )
        {
          v6 = sub_4A190(v1 + 76, 10, 2);
          if ( v6 )
          {
            v7 = 4 * *(_DWORD *)(v6 + 8);
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_DWORD *)(v6 + 8) = v7;
          }
        }
        sub_68DE0(a1, v1);
      }
      v8 = *(_WORD *)(a1 + 46) - 1;
      *(_WORD *)(a1 + 46) = v8;
      if ( !v8 )
      {
        *(_WORD *)(*(_DWORD *)(v1 + 164) + 12) = *(_WORD *)(v1 + 132) * v2;
        *(_WORD *)(v1 + 130) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 12);
        *(_BYTE *)(a1 + 12) &= 0x7Fu;
        sub_6D880(a1);
      }
    }
  }
  v9 = *(_WORD *)(a1 + 54);
  if ( v9 )
    *(_WORD *)(a1 + 54) = v9 - 1;
}
// 5D520: using guessed type int __cdecl _wcpp_1_unwind_leave__98(_DWORD);
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00069FF0) --------------------------------------------------------
signed int __cdecl sub_69FF0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006A010) --------------------------------------------------------
signed int __cdecl sub_6A010(int a1)
{
  return sub_69250(a1);
}

//----- (0006A030) --------------------------------------------------------
char __cdecl sub_6A030(int a1)
{
  unsigned __int16 v1; // ax
  unsigned int v2; // esi
  int v3; // edi
  int v4; // eax
  int v5; // ecx
  char v6; // al
  int v7; // ST0C_4
  int v8; // eax
  unsigned int v9; // ecx
  int v10; // edx
  __int16 v11; // dx
  unsigned __int16 v12; // di
  int v13; // eax
  __int16 v14; // si
  int v16; // [esp+4h] [ebp-8h]

  v1 = *(_WORD *)(a1 + 40);
  v2 = dword_EA3E4[v1];
  v3 = -1;
  if ( v2 > dword_EA3E4[0] && *(_WORD *)(a1 + 46) > 0 )
  {
    if ( sub_68D50(a1, (_DWORD *)v2) )
    {
      if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
      {
        sub_6D8B0(*(_WORD *)(a1 + 40), 4u, 1);
        v4 = sub_4A190(v2 + 76, 5, (unsigned __int8)byte_DA818[80 * *(char *)(a1 + 64) + 26 + 26 * *(char *)(a1 + 70)]);
        v5 = v4;
        if ( v4 )
        {
          v6 = 8 * *(_BYTE *)(v4 + 64);
          *(_BYTE *)(v5 + 73) = 12;
          *(_BYTE *)(v5 + 69) = v6 + 7;
          *(_WORD *)(v5 + 40) = *(_WORD *)(a1 + 40);
          *(_WORD *)(v5 + 26) = *(_WORD *)(v2 + 26);
          v7 = dword_D41A0;
          *(_WORD *)(a1 + 150) = (v5 - (dword_D41A0 + 28302)) / 168;
          *(_BYTE *)(v5 + 12) |= 1u;
          v8 = *(_DWORD *)(v2 + 164);
          *(_BYTE *)(v2 + 12) |= 0x21u;
          if ( *(_WORD *)(v8 + 56) != *(_WORD *)(v7 + 12) )
          {
            *(_BYTE *)(v5 + 12) &= 0xFEu;
            *(_BYTE *)(v2 + 12) |= 1u;
          }
          sub_6E450((signed int)(v2 - (dword_D41A0 + 28302)) / 168, -1, 60);
        }
      }
      sub_68DE0(a1, v2);
    }
    else
    {
      *(_WORD *)(a1 + 46) = 1;
    }
    v1 = *(_WORD *)(*(_DWORD *)(v2 + 164) + 56);
    if ( v1 != *(_WORD *)(dword_D41A0 + 12) )
    {
      v1 = *(_WORD *)(a1 + 150);
      v9 = dword_EA3E4[v1];
      if ( v9 > dword_EA3E4[0] )
      {
        v10 = *(signed __int16 *)(a1 + 48);
        v16 = *(signed __int16 *)(a1 + 46);
        LOBYTE(v1) = *(_WORD *)(a1 + 46);
        if ( v16 <= v10 - 7 )
        {
          v1 = *(_WORD *)(a1 + 46);
          if ( (signed __int16)v1 < 7 )
          {
            LOBYTE(v1) = v1 & 1;
            v3 = (unsigned __int8)v1;
          }
        }
        else
        {
          v3 = ((_BYTE)v10 - (_BYTE)v16) & 1;
        }
        if ( v3 != -1 )
        {
          if ( v3 )
          {
            if ( v3 == 1 )
            {
              *(_BYTE *)(v9 + 12) |= 1u;
              *(_BYTE *)(v2 + 12) &= 0xFEu;
            }
          }
          else
          {
            *(_BYTE *)(v9 + 12) &= 0xFEu;
            *(_BYTE *)(v2 + 12) |= 1u;
          }
        }
      }
    }
    v11 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v11;
    if ( !v11 )
    {
      v12 = *(_WORD *)(a1 + 150);
      if ( v12 )
      {
        sub_57F10(dword_EA3E4[v12]);
        *(_WORD *)(a1 + 150) = 0;
      }
      v13 = *(_DWORD *)(v2 + 164);
      *(_BYTE *)(v2 + 12) &= 0xDFu;
      if ( *(_WORD *)(v13 + 56) == *(_WORD *)(dword_D41A0 + 12) )
        sub_6E450((signed int)(v2 - (dword_D41A0 + 28302)) / 168, -1, 60);
      else
        *(_BYTE *)(v2 + 12) &= 0xFEu;
      LOBYTE(v1) = sub_6D880(a1);
    }
  }
  v14 = *(_WORD *)(a1 + 54);
  if ( v14 )
    *(_WORD *)(a1 + 54) = v14 - 1;
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006A2C0) --------------------------------------------------------
signed int __cdecl sub_6A2C0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006A2E0) --------------------------------------------------------
signed int __cdecl sub_6A2E0(int a1)
{
  return sub_69250(a1);
}

//----- (0006A300) --------------------------------------------------------
void __cdecl sub_6A300(int a1)
{
  _DWORD *v1; // esi
  int v2; // edx
  int v3; // ecx
  int v4; // edi
  __int16 v5; // ax
  __int16 v6; // cx

  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = (_DWORD *)dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( (unsigned int)v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, v1) && v1[36] >= *(_DWORD *)(a1 + 140) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
          sub_6E450((signed int)((char *)v1 - dword_D41A0 - 28302) / 168, -1, 25);
        if ( v1[2] < v1[1] )
        {
          if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
            sub_6D8B0(*(_WORD *)(a1 + 40), 5u, 1);
          v2 = v1[1] * *(unsigned __int16 *)(a1 + 42) / 100 + v1[2];
          v3 = v1[1];
          v1[2] = v2;
          if ( v2 > v3 )
            v1[2] = v3;
          v4 = v1[34];
          if ( v4 >= 0 )
            v1[34] = -*(_DWORD *)(a1 + 140);
          else
            v1[34] = v4 - *(_DWORD *)(a1 + 140);
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v5 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v5;
    if ( !v5 )
      sub_6D880(a1);
  }
  v6 = *(_WORD *)(a1 + 54);
  if ( v6 )
    *(_WORD *)(a1 + 54) = v6 - 1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006A440) --------------------------------------------------------
signed int __cdecl sub_6A440(int a1)
{
  return sub_692A0(a1);
}

//----- (0006A460) --------------------------------------------------------
signed int __cdecl sub_6A460(int a1)
{
  return sub_69250(a1);
}

//----- (0006A480) --------------------------------------------------------
char __cdecl sub_6A480(int a1)
{
  signed int v1; // eax
  unsigned int v2; // esi
  __int16 v3; // cx

  LOWORD(v1) = *(_WORD *)(a1 + 40);
  v2 = dword_EA3E4[(unsigned __int16)v1];
  if ( v2 <= dword_EA3E4[0] || *(_WORD *)(a1 + 46) <= 0 )
    goto LABEL_15;
  LOBYTE(v1) = byte_DA818[80 * *(char *)(a1 + 64) + 26 + 26 * *(char *)(a1 + 70)];
  if ( !(_BYTE)v1 )
  {
    v1 = sub_68D50(a1, (_DWORD *)v2);
    if ( v1 )
    {
      *(_BYTE *)(v2 + 13) |= 0x40u;
      LOBYTE(v1) = sub_68DE0(a1, v2);
      --*(_WORD *)(a1 + 46);
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if ( (_BYTE)v1 == 1 )
  {
    v1 = sub_68D50(a1, (_DWORD *)v2);
    if ( v1 )
    {
      if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        *(_BYTE *)(v2 + 14) |= 0x40u;
      --*(_WORD *)(a1 + 46);
      LOBYTE(v1) = sub_68DE0(a1, v2);
      goto LABEL_13;
    }
LABEL_12:
    *(_WORD *)(a1 + 46) = 0;
  }
LABEL_13:
  if ( !*(_WORD *)(a1 + 46) )
  {
    *(_DWORD *)(v2 + 12) &= 0xFFBFBFFF;
    LOBYTE(v1) = sub_6D880(a1);
  }
LABEL_15:
  v3 = *(_WORD *)(a1 + 54);
  if ( v3 )
    *(_WORD *)(a1 + 54) = v3 - 1;
  return v1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006A580) --------------------------------------------------------
signed int __cdecl sub_6A580(int a1)
{
  return sub_692A0(a1);
}

//----- (0006A5A0) --------------------------------------------------------
signed int __cdecl sub_6A5A0(int a1)
{
  return sub_69250(a1);
}

//----- (0006A5C0) --------------------------------------------------------
int __cdecl sub_6A5C0(int a1)
{
  unsigned int v1; // ebx
  char *v2; // edx
  char v3; // al
  int v4; // eax
  __int16 v5; // ax
  int v6; // edx
  __int16 v7; // ax
  int v8; // ecx
  __int16 v9; // bx
  int result; // eax
  __int16 v11; // si
  int v12; // [esp+0h] [ebp-20h]
  int v13; // [esp+4h] [ebp-1Ch]
  char *v14; // [esp+Ch] [ebp-14h]
  int v15; // [esp+10h] [ebp-10h]
  int v16; // [esp+14h] [ebp-Ch]
  __int16 v17; // [esp+18h] [ebp-8h]
  __int16 v18; // [esp+1Ch] [ebp-4h]

  v12 = 0;
  v13 = 0;
  if ( *(_WORD *)(a1 + 46) <= 0 )
    goto LABEL_29;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
  if ( v1 > dword_EA3E4[0] )
  {
    if ( sub_68D50(a1, (_DWORD *)v1) )
    {
      if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
      {
        v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
        v3 = v2[24];
        v14 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
        if ( v3 )
        {
          if ( (unsigned __int8)v3 <= 2u )
          {
            v18 = 0;
            v17 = (v3 != 1) + 1;
            while ( v18 < v17 )
            {
              v16 = sub_6DCA0(v1, v1 + 76, 7u, (__int16 *)v14, *(_WORD *)(v1 + 130), 1);
              if ( v16 )
              {
                sub_68E50(v1, v16, a1);
                *(_WORD *)(v16 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
                *(_WORD *)(v16 + 42) = *(_WORD *)(a1 + 42);
                *(_WORD *)(v16 + 26) = *(_WORD *)(v1 + 26);
                *(_WORD *)(v16 + 80) += *(_WORD *)(v1 + 88);
                *(_DWORD *)(v16 + 144) = *(_DWORD *)(a1 + 144);
                *(_WORD *)(v16 + 42) = *(_WORD *)v14;
                *(_DWORD *)(v16 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
                *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
                *(_DWORD *)(v16 + 154) = *(_DWORD *)(v1 + 76);
                *(_WORD *)(v16 + 158) = *(_WORD *)(v1 + 80);
                sub_57FA0(
                  (_WORD *)(v16 + 154),
                  *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28),
                  *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30),
                  0x4000);
                if ( v14[24] == 2 )
                {
                  if ( v18 )
                    v5 = *(_WORD *)(v1 + 28) - 113;
                  else
                    v5 = *(_WORD *)(v1 + 28) + 113;
                  v6 = v16;
                  v7 = (*(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + v5) & 0x7FF;
                }
                else
                {
                  v6 = v16;
                  v7 = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
                }
                *(_WORD *)(v6 + 28) = v7;
                *(_WORD *)(v16 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
                if ( v18 )
                  v13 = v16;
                else
                  v12 = v16;
              }
              ++v18;
            }
            if ( v13 )
            {
              v8 = dword_D41A0 + 28302;
              *(_WORD *)(v12 + 52) = (v13 - (dword_D41A0 + 28302)) / 168;
              *(_WORD *)(v13 + 52) = (v12 - v8) / 168;
            }
          }
        }
        else
        {
          v4 = sub_6DCA0(v1, v1 + 76, 7u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          v15 = v4;
          if ( v4 )
          {
            sub_68E50(v1, v4, a1);
            *(_WORD *)(v15 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v15 + 26) = *(_WORD *)(v1 + 26);
            *(_DWORD *)(v15 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v15 + 80) += *(_WORD *)(v1 + 88);
            *(_WORD *)(v15 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v15 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
            *(_WORD *)(v15 + 42) = *(_WORD *)v14;
            *(_DWORD *)(v15 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v15 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v15 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0(
              (_WORD *)(v15 + 154),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30),
              0x4000);
            sub_68DE0(a1, v1);
            goto LABEL_27;
          }
        }
      }
      sub_68DE0(a1, v1);
    }
    else
    {
      *(_WORD *)(a1 + 46) = 1;
    }
  }
LABEL_27:
  v9 = *(_WORD *)(a1 + 46) - 1;
  *(_WORD *)(a1 + 46) = v9;
  if ( !v9 )
    sub_6D880(a1);
LABEL_29:
  result = a1;
  v11 = *(_WORD *)(a1 + 54);
  if ( v11 )
    *(_WORD *)(a1 + 54) = v11 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006A9C0) --------------------------------------------------------
signed int __cdecl sub_6A9C0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006A9E0) --------------------------------------------------------
signed int __cdecl sub_6A9E0(int a1)
{
  return sub_69250(a1);
}

//----- (0006AA00) --------------------------------------------------------
__int16 __cdecl sub_6AA00(int a1)
{
  unsigned int v1; // esi
  char *v2; // edi
  char v3; // al
  __int16 v4; // cx
  __int16 result; // ax

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
  if ( v1 > dword_EA3E4[0] )
  {
    if ( *(_WORD *)(a1 + 46) <= 0 )
    {
      *(_WORD *)(v1 + 12) &= 0x7FEFu;
    }
    else
    {
      v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
      if ( sub_68D50(a1, (_DWORD *)v1) )
      {
        v3 = v2[24];
        if ( v3 )
        {
          if ( v3 == 1 )
            *(_BYTE *)(v1 + 12) |= 0x10u;
        }
        else
        {
          *(_BYTE *)(v1 + 13) |= 0x80u;
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
      v4 = *(_WORD *)(a1 + 46) - 1;
      *(_WORD *)(a1 + 46) = v4;
      if ( !v4 )
        sub_6D880(a1);
    }
  }
  result = *(_WORD *)(a1 + 54);
  if ( result )
    *(_WORD *)(a1 + 54) = result - 1;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006AAC0) --------------------------------------------------------
signed int __cdecl sub_6AAC0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006AAE0) --------------------------------------------------------
signed int __cdecl sub_6AAE0(int a1)
{
  return sub_69250(a1);
}

//----- (0006AB00) --------------------------------------------------------
int __cdecl sub_6AB00(int a1)
{
  unsigned int v1; // ebx
  char *v2; // esi
  __int16 v3; // si
  int result; // eax
  __int16 v5; // dx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (_DWORD *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v6 = sub_6DCA0(v1, v1 + 76, 9u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v6 )
          {
            sub_68E50(v1, v6, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v6 + 42) = *(_WORD *)v2;
            *(_BYTE *)(v6 + 70) = v2[24];
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0(
              (_WORD *)(v6 + 154),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30),
              10240);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
          }
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006AD00) --------------------------------------------------------
signed int __cdecl sub_6AD00(int a1)
{
  return sub_692A0(a1);
}

//----- (0006AD20) --------------------------------------------------------
signed int __cdecl sub_6AD20(int a1)
{
  return sub_69250(a1);
}

//----- (0006AD60) --------------------------------------------------------
void __cdecl sub_6AD60(int a1)
{
  _DWORD *v1; // eax
  char *v2; // esi
  char v3; // al
  int v4; // eax
  unsigned int v5; // esi
  int v6; // esi
  unsigned __int16 v7; // ax
  unsigned int v8; // edx
  __int16 v9; // ax
  int v10; // esi
  unsigned __int16 v11; // ax
  unsigned int v12; // esi
  _BOOL1 v13; // cf
  _BOOL1 v14; // zf
  int v15; // eax
  unsigned int v16; // eax
  int v17; // esi
  unsigned __int16 v18; // ax
  unsigned __int16 v19; // si
  __int16 v20; // ax
  int v21; // esi
  int v22; // ecx
  __int16 v23; // cx
  __int16 v24; // di
  int v25; // [esp+0h] [ebp-14h]
  __int16 v26; // [esp+4h] [ebp-10h]
  int v27; // [esp+8h] [ebp-Ch]
  int v28; // [esp+Ch] [ebp-8h]
  _DWORD *v29; // [esp+10h] [ebp-4h]

  v28 = 1;
  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = (_DWORD *)dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    v29 = v1;
    if ( (unsigned int)v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          sub_6D8B0(*(_WORD *)(a1 + 40), 0xAu, 1);
          v3 = v2[24];
          if ( (unsigned __int8)v3 < 1u )
          {
            if ( !v3 )
            {
              v4 = (int)v29;
              *(_WORD *)(a1 + 150) = 0;
              v5 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(v4 + 164) + 58)];
              if ( v5 <= dword_EA3E4[0] )
              {
                v28 = 0;
              }
              else
              {
                v6 = v5 + 76;
                v25 = *(_DWORD *)v6;
                v26 = *(_WORD *)(v6 + 4);
                v7 = *((_WORD *)v29 + 14) - 204;
                HIBYTE(v7) &= 7u;
                sub_57FA0(&v25, v7, 0, -448);
                sub_57CF0((int)v29, (int)&v25);
              }
            }
          }
          else if ( (unsigned __int8)v3 <= 1u )
          {
            v8 = dword_EA3E4[*(unsigned __int16 *)(v29[41] + 58)];
            if ( v8 <= dword_EA3E4[0] )
            {
              v28 = 0;
            }
            else
            {
              v9 = *(_WORD *)(a1 + 150);
              if ( v9 && v9 == 1 )
              {
                sub_57CF0((int)v29, a1 + 154);
                *(_WORD *)(a1 + 150) = 0;
              }
              else
              {
                v10 = (int)(v29 + 19);
                *(_DWORD *)(a1 + 154) = v29[19];
                *(_WORD *)(a1 + 158) = *(_WORD *)(v10 + 4);
                v25 = *(_DWORD *)(v8 + 76);
                v26 = *(_WORD *)(v8 + 80);
                v11 = *((_WORD *)v29 + 14) - 204;
                HIBYTE(v11) &= 7u;
                sub_57FA0(&v25, v11, 0, -448);
                sub_57CF0((int)v29, (int)&v25);
                *(_WORD *)(a1 + 150) = 1;
              }
            }
          }
          else if ( v3 == 2 )
          {
            v27 = 0;
            v28 = 0;
            while ( v27 < 9 && !v28 )
            {
              switch ( *(_WORD *)(a1 + 150) )
              {
                case 1:
                  break;
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                  v15 = *(unsigned __int16 *)(a1 + 150) - 2;
                  if ( v15 != *(signed __int16 *)(v29[41] + 56) && v15 < *(unsigned __int16 *)(dword_D41A0 + 14) )
                  {
                    v16 = dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 2124 * v15 + 11240)];
                    if ( v16 > dword_EA3E4[0] )
                    {
                      v12 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(v16 + 164) + 58)];
                      v13 = v12 < dword_EA3E4[0];
                      v14 = v12 == dword_EA3E4[0];
                      goto LABEL_26;
                    }
                  }
                  break;
                default:
                  v12 = dword_EA3E4[*(unsigned __int16 *)(v29[41] + 58)];
                  v13 = v12 < dword_EA3E4[0];
                  v14 = v12 == dword_EA3E4[0];
LABEL_26:
                  if ( !((unsigned __int8)v13 | (unsigned __int8)v14) )
                  {
                    v17 = v12 + 76;
                    v25 = *(_DWORD *)v17;
                    v26 = *(_WORD *)(v17 + 4);
                    v18 = *((_WORD *)v29 + 14) - 204;
                    HIBYTE(v18) &= 7u;
                    sub_57FA0(&v25, v18, 0, -448);
                    sub_57CF0((int)v29, (int)&v25);
                    v28 = 1;
                  }
                  break;
              }
              v19 = *(_WORD *)(a1 + 150) + 1;
              *(_WORD *)(a1 + 150) = v19;
              if ( v19 >= 9u )
                *(_WORD *)(a1 + 150) = 0;
              ++v27;
            }
          }
          v20 = v28;
          if ( !v28 )
          {
            v21 = (int)(v29 + 19);
            *(_DWORD *)(a1 + 154) = v29[19];
            *(_WORD *)(a1 + 158) = *(_WORD *)(v21 + 4);
            *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
            sub_57FA0((_WORD *)(a1 + 154), *(_WORD *)(a1 + 20) & 0x7FF, v20, 0x4000);
            sub_57CF0((int)v29, a1 + 154);
            *(_WORD *)(a1 + 150) = 0;
          }
          v22 = v28;
          *(_WORD *)(v29[41] + 12) = 0;
          if ( v22 )
            sub_6E450((signed int)((char *)v29 - dword_D41A0 - 28302) / 168, -1, 22);
        }
        sub_68DE0(a1, (int)v29);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
      v23 = *(_WORD *)(a1 + 46) - 1;
      *(_WORD *)(a1 + 46) = v23;
      if ( !v23 )
      {
        *(_WORD *)(v29[41] + 12) = 0;
        sub_6D880(a1);
      }
    }
  }
  v24 = *(_WORD *)(a1 + 54);
  if ( v24 )
    *(_WORD *)(a1 + 54) = v24 - 1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006B180) --------------------------------------------------------
signed int __cdecl sub_6B180(int a1)
{
  return sub_692A0(a1);
}

//----- (0006B1A0) --------------------------------------------------------
signed int __cdecl sub_6B1A0(int a1)
{
  return sub_69250(a1);
}

//----- (0006B1C0) --------------------------------------------------------
void __cdecl sub_6B1C0(int a1)
{
  unsigned int v1; // esi
  char *v2; // edx
  __int16 v3; // di
  int v4; // eax
  __int16 v5; // dx

  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (_DWORD *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          sub_6D8B0(*(_WORD *)(a1 + 40), 0xBu, 1);
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          *(_WORD *)(*(_DWORD *)(v1 + 164) + 345) = 0;
          *(_BYTE *)(*(_DWORD *)(v1 + 164) + 447) = v2[24];
          *(_BYTE *)(v1 + 12) |= 0x20u;
        }
        else if ( !(*(_BYTE *)(v1 + 12) & 0x20) )
        {
          *(_WORD *)(a1 + 46) = 1;
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
    {
      v4 = *(_DWORD *)(v1 + 164);
      *(_BYTE *)(v1 + 12) &= 0xDFu;
      *(_BYTE *)(v4 + 447) = 0;
      sub_6D880(a1);
    }
  }
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006B2D0) --------------------------------------------------------
signed int __cdecl sub_6B2D0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006B2F0) --------------------------------------------------------
signed int __cdecl sub_6B2F0(int a1)
{
  return sub_69250(a1);
}

//----- (0006B310) --------------------------------------------------------
__int16 __cdecl sub_6B310(_WORD *a1)
{
  unsigned __int16 v1; // ax
  _DWORD *v2; // esi
  __int16 v3; // si
  __int16 result; // ax

  if ( a1[23] > 0 )
  {
    v1 = a1[20];
    v2 = (_DWORD *)dword_EA3E4[v1];
    if ( (unsigned int)v2 > dword_EA3E4[0] )
    {
      if ( a1[23] == a1[24] )
        sub_6D8B0(v1, 0xCu, 1);
      if ( sub_68D50((int)a1, v2) )
        sub_68DE0((int)a1, (int)v2);
      else
        a1[23] = 1;
    }
    v3 = a1[23] - 1;
    a1[23] = v3;
    if ( !v3 )
      sub_6D880((int)a1);
  }
  result = a1[27];
  if ( result )
    a1[27] = result - 1;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006B3A0) --------------------------------------------------------
signed int __cdecl sub_6B3A0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006B3C0) --------------------------------------------------------
signed int __cdecl sub_6B3C0(int a1)
{
  return sub_69250(a1);
}

//----- (0006B3E0) --------------------------------------------------------
int __cdecl sub_6B3E0(int a1)
{
  unsigned int v1; // ebx
  int v2; // eax
  __int16 v3; // dx
  int result; // eax
  __int16 v5; // cx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (_DWORD *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = sub_6DCA0(
                 v1,
                 v1 + 76,
                 0xDu,
                 (__int16 *)&byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)],
                 *(_WORD *)(v1 + 130),
                 1);
          v6 = v2;
          if ( v2 )
          {
            sub_68E50(v1, v2, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_BYTE *)(v6 + 70) = *(_BYTE *)(a1 + 70);
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0(
              (_WORD *)(v6 + 154),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30),
              0x4000);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
          }
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006B5D0) --------------------------------------------------------
signed int __cdecl sub_6B5D0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006B5F0) --------------------------------------------------------
signed int __cdecl sub_6B5F0(int a1)
{
  return sub_69250(a1);
}

//----- (0006B610) --------------------------------------------------------
__int16 __cdecl sub_6B610(int a1)
{
  _DWORD *v1; // eax
  int v2; // eax
  int v3; // edi
  __int16 v4; // ax
  __int16 v5; // si
  __int16 result; // ax
  _WORD *v7; // [esp+0h] [ebp-Ch]
  int v8; // [esp+4h] [ebp-8h]
  char v9; // [esp+8h] [ebp-4h]

  v9 = 0;
  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = (_DWORD *)dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    v8 = (int)v1;
    if ( (unsigned int)v1 > dword_EA3E4[0] )
    {
      if ( !sub_68D50(a1, v1) )
        goto LABEL_19;
      if ( *(signed __int16 *)(a1 + 46) <= *(signed __int16 *)(a1 + 48) - 28 && !*(_WORD *)(*(_DWORD *)(v8 + 164) + 326) )
        v9 = 1;
      if ( v9 )
      {
LABEL_19:
        *(_WORD *)(a1 + 46) = 1;
      }
      else
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = sub_4A190(v8 + 76, 9, 7);
          v7 = (_WORD *)v2;
          if ( v2 )
          {
            v3 = v2;
            sub_68E50(v8, v2, a1);
            *(_WORD *)(v3 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            v4 = *(_WORD *)(a1 + 42);
            *(_BYTE *)(v3 + 67) = 10;
            *(_WORD *)(v3 + 42) = v4;
            *(_BYTE *)(v3 + 68) = 26;
            *(_WORD *)(v3 + 26) = *(_WORD *)(v8 + 26);
            *(_WORD *)(v3 + 80) += *(_WORD *)(v8 + 88);
            *(_DWORD *)(v3 + 144) = *(_DWORD *)(a1 + 144);
            *(_BYTE *)(v3 + 70) = *(_BYTE *)(a1 + 70);
            v3 += 154;
            *(_DWORD *)v3 = *(_DWORD *)(v8 + 76);
            *(_WORD *)(v3 + 4) = *(_WORD *)(v8 + 80);
            sub_57FA0(
              v7 + 77,
              *(_WORD *)(*(_DWORD *)(v8 + 164) + 24) + *(_WORD *)(v8 + 28),
              *(_WORD *)(*(_DWORD *)(v8 + 164) + 26) + *(_WORD *)(v8 + 30),
              10240);
            v7[14] = *(_WORD *)(*(_DWORD *)(v8 + 164) + 24) + *(_WORD *)(v8 + 28);
            v7[15] = *(_WORD *)(*(_DWORD *)(v8 + 164) + 26) + *(_WORD *)(v8 + 30);
            sub_6E450((signed int)((char *)v7 - dword_D41A0 - 28302) / 168, -1, 9);
          }
        }
        sub_68DE0(a1, v8);
      }
    }
    v5 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v5;
    if ( !v5 )
      sub_6D880(a1);
  }
  result = *(_WORD *)(a1 + 54);
  if ( result )
    *(_WORD *)(a1 + 54) = result - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006B830) --------------------------------------------------------
signed int __cdecl sub_6B830(int a1)
{
  return sub_692A0(a1);
}

//----- (0006B850) --------------------------------------------------------
signed int __cdecl sub_6B850(int a1)
{
  return sub_69250(a1);
}

//----- (0006B870) --------------------------------------------------------
int __cdecl sub_6B870(int a1)
{
  unsigned int v1; // ebx
  char *v2; // esi
  __int16 v3; // si
  int result; // eax
  __int16 v5; // dx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (_DWORD *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v6 = sub_6DCA0(v1, v1 + 76, 0xFu, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v6 )
          {
            sub_68E50(v1, v6, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v6 + 42) = *(_WORD *)v2;
            *(_BYTE *)(v6 + 70) = v2[24];
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0((_WORD *)(v6 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
            *(_WORD *)(v6 + 158) = sub_10C40((__int16 *)(v6 + 154));
          }
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006BA70) --------------------------------------------------------
signed int __cdecl sub_6BA70(int a1)
{
  return sub_692A0(a1);
}

//----- (0006BA90) --------------------------------------------------------
signed int __cdecl sub_6BA90(int a1)
{
  return sub_69250(a1);
}

//----- (0006BAB0) --------------------------------------------------------
int __cdecl sub_6BAB0(int a1)
{
  unsigned int v1; // ebx
  char *v2; // esi
  __int16 v3; // si
  int result; // eax
  __int16 v5; // dx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (_DWORD *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v6 = sub_6DCA0(v1, v1 + 76, 0x10u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v6 )
          {
            sub_68E50(v1, v6, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v6 + 42) = *(_WORD *)v2;
            *(_BYTE *)(v6 + 70) = v2[24];
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0((_WORD *)(v6 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
            *(_WORD *)(v6 + 158) = sub_10C40((__int16 *)(v6 + 154));
          }
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006BCB0) --------------------------------------------------------
signed int __cdecl sub_6BCB0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006BCD0) --------------------------------------------------------
signed int __cdecl sub_6BCD0(int a1)
{
  return sub_69250(a1);
}

//----- (0006BCF0) --------------------------------------------------------
int __cdecl sub_6BCF0(int a1)
{
  unsigned int v1; // ebx
  char *v2; // esi
  __int16 v3; // si
  int result; // eax
  __int16 v5; // dx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (_DWORD *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v6 = sub_6DCA0(v1, v1 + 76, 0x11u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v6 )
          {
            sub_68E50(v1, v6, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v6 + 42) = *(_WORD *)v2;
            *(_BYTE *)(v6 + 70) = v2[24];
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0((_WORD *)(v6 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
            *(_WORD *)(v6 + 158) = sub_10C40((__int16 *)(v6 + 154));
          }
          sub_68DE0(a1, v1);
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006BEF0) --------------------------------------------------------
signed int __cdecl sub_6BEF0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006BF10) --------------------------------------------------------
signed int __cdecl sub_6BF10(int a1)
{
  return sub_69250(a1);
}

//----- (0006BF30) --------------------------------------------------------
int __cdecl sub_6BF30(int a1)
{
  unsigned int v1; // ebx
  char *v2; // esi
  __int16 v3; // dx
  int result; // eax
  __int16 v5; // cx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (_DWORD *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v6 = sub_6DCA0(v1, v1 + 76, 0x12u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v6 )
          {
            sub_68E50(v1, v6, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v6 + 42) = *(_WORD *)v2;
            *(_BYTE *)(v6 + 70) = v2[24];
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0((_WORD *)(v6 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
            *(_WORD *)(v6 + 158) = sub_10C40((__int16 *)(v6 + 154));
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
          }
          sub_68DE0(a1, v1);
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006C130) --------------------------------------------------------
signed int __cdecl sub_6C130(int a1)
{
  return sub_692A0(a1);
}

//----- (0006C150) --------------------------------------------------------
signed int __cdecl sub_6C150(int a1)
{
  return sub_69250(a1);
}

//----- (0006C170) --------------------------------------------------------
__int16 __cdecl sub_6C170(int a1)
{
  _DWORD *v1; // eax
  char *v2; // esi
  __int16 v3; // ax
  __int16 v4; // si
  __int16 result; // ax
  int v6; // [esp+0h] [ebp-8h]
  int v7; // [esp+4h] [ebp-4h]

  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = (_DWORD *)dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    v7 = (int)v1;
    if ( (unsigned int)v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v6 = sub_4A190(v7 + 76, 9, 24);
          if ( v6 )
          {
            *(_WORD *)(v6 + 130) += *(_WORD *)(v7 + 130);
            sub_68E50(v7, v6, a1);
            v3 = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_BYTE *)(v6 + 67) = 10;
            *(_WORD *)(v6 + 38) = v3;
            *(_BYTE *)(v6 + 68) = 72;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v7 + 26);
            *(_WORD *)(v6 + 40) = *(_WORD *)(a1 + 40);
            *(_BYTE *)(v6 + 70) = v2[24];
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v7 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v7 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v7 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v7 + 80);
            sub_57FA0(
              (_WORD *)(v6 + 154),
              *(_WORD *)(*(_DWORD *)(v7 + 164) + 24) + *(_WORD *)(v7 + 28),
              *(_WORD *)(*(_DWORD *)(v7 + 164) + 26) + *(_WORD *)(v7 + 30),
              0x4000);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v7 + 164) + 24) + *(_WORD *)(v7 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v7 + 164) + 26) + *(_WORD *)(v7 + 30);
            sub_6E450((v6 - (dword_D41A0 + 28302)) / 168, -1, 9);
          }
        }
        sub_68DE0(a1, v7);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v4 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v4;
    if ( !v4 )
      sub_6D880(a1);
  }
  result = *(_WORD *)(a1 + 54);
  if ( result )
    *(_WORD *)(a1 + 54) = result - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006C3A0) --------------------------------------------------------
signed int __cdecl sub_6C3A0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006C3C0) --------------------------------------------------------
signed int __cdecl sub_6C3C0(int a1)
{
  return sub_69250(a1);
}

//----- (0006C3E0) --------------------------------------------------------
int __cdecl sub_6C3E0(int a1)
{
  unsigned int v1; // ebx
  char *v2; // esi
  __int16 v3; // si
  int result; // eax
  __int16 v5; // dx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (_DWORD *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v6 = sub_6DCA0(v1, v1 + 76, 0x14u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v6 )
          {
            sub_68E50(v1, v6, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v6 + 42) = *(_WORD *)v2;
            *(_BYTE *)(v6 + 70) = v2[24];
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0((_WORD *)(v6 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
            *(_WORD *)(v6 + 158) = sub_10C40((__int16 *)(v6 + 154));
          }
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006C5E0) --------------------------------------------------------
signed int __cdecl sub_6C5E0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006C600) --------------------------------------------------------
signed int __cdecl sub_6C600(int a1)
{
  return sub_69250(a1);
}

//----- (0006C620) --------------------------------------------------------
int __cdecl sub_6C620(int a1)
{
  unsigned int v1; // ebx
  char *v2; // edi
  int v3; // esi
  unsigned __int8 v4; // ah
  int v5; // eax
  __int16 v6; // dx
  int result; // eax
  __int16 v8; // cx

  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (_DWORD *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v3 = sub_6DCA0(v1, v1 + 76, 0x15u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v3 )
          {
            sub_68E50(v1, v3, a1);
            *(_WORD *)(v3 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v3 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v3 + 80) += *(_WORD *)(v1 + 88);
            *(_DWORD *)(v3 + 144) = *(_DWORD *)(a1 + 144);
            v4 = v2[24];
            if ( v4 )
              v5 = *(_DWORD *)v2 / (signed int)v4;
            else
              LOWORD(v5) = *(_WORD *)v2;
            *(_WORD *)(v3 + 42) = v5;
            *(_BYTE *)(v3 + 70) = v2[24];
            *(_DWORD *)(v3 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v3 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v3 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0((_WORD *)(v3 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
            *(_WORD *)(v3 + 158) = sub_10C40((__int16 *)(v3 + 154));
            *(_WORD *)(v3 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v3 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
          }
          sub_68DE0(a1, v1);
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v6 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v6;
    if ( !v6 )
      sub_6D880(a1);
  }
  result = a1;
  v8 = *(_WORD *)(a1 + 54);
  if ( v8 )
    *(_WORD *)(a1 + 54) = v8 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006C830) --------------------------------------------------------
signed int __cdecl sub_6C830(int a1)
{
  return sub_692A0(a1);
}

//----- (0006C850) --------------------------------------------------------
signed int __cdecl sub_6C850(int a1)
{
  return sub_69250(a1);
}

//----- (0006C870) --------------------------------------------------------
__int16 __cdecl sub_6C870(int a1)
{
  int v1; // esi
  unsigned int v2; // edi
  int v3; // eax
  __int16 v4; // si
  __int16 result; // ax
  signed int v6; // [esp+0h] [ebp-8h]
  char *v7; // [esp+4h] [ebp-4h]

  v1 = 0;
  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v2 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v2 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (_DWORD *)v2) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          if ( sub_4A810() > 6 )
          {
            v6 = 0;
            v7 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
            while ( v6 < 6 )
            {
              v1 = sub_4A190(v2 + 76, 10, 57);
              if ( v1 )
              {
                v3 = 4 * *(signed __int16 *)(v2 + 130);
                if ( v3 < 140 )
                  v3 = 140;
                if ( v3 > 280 )
                  LOWORD(v3) = 280;
                *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
                *(_WORD *)(v1 + 130) = (*(_WORD *)(a1 + 20) & 0x7F) + v3;
                sub_68E50(v2, v1, a1);
                *(_WORD *)(v1 + 40) = *(_WORD *)(v2 + 26);
                *(_WORD *)(v1 + 42) = *(_WORD *)v7;
                *(_BYTE *)(v1 + 70) = v7[24];
                *(_WORD *)(v1 + 148) = 0;
                if ( (unsigned __int8)v7[24] >= 3u )
                {
                  *(_WORD *)(v1 + 148) = *(_WORD *)(v2 + 26);
                  sub_36920(a1, v1);
                }
                *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
                *(_WORD *)(v1 + 28) = (*(_WORD *)(v2 + 28)
                                     - 85
                                     + *(_WORD *)(a1 + 20) % 0xAAu
                                     + *(_WORD *)(*(_DWORD *)(v2 + 164) + 24)) & 0x7FF;
                *(_WORD *)(v1 + 30) = *(_WORD *)(*(_DWORD *)(v2 + 164) + 26) + *(_WORD *)(v2 + 30);
              }
              ++v6;
            }
            if ( v1 )
              sub_6E450((v1 - (dword_D41A0 + 28302)) / 168, -1, 11);
          }
          sub_68DE0(a1, v2);
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v4 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v4;
    if ( !v4 )
      sub_6D880(a1);
  }
  result = *(_WORD *)(a1 + 54);
  if ( result )
    *(_WORD *)(a1 + 54) = result - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006CA80) --------------------------------------------------------
signed int __cdecl sub_6CA80(int a1)
{
  return sub_692A0(a1);
}

//----- (0006CAA0) --------------------------------------------------------
signed int __cdecl sub_6CAA0(int a1)
{
  return sub_69250(a1);
}

//----- (0006CAC0) --------------------------------------------------------
int __cdecl sub_6CAC0(int a1)
{
  _DWORD *v1; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // eax
  __int16 v5; // di
  int result; // eax
  __int16 v7; // bx
  int v8; // [esp+0h] [ebp-4h]

  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = (_DWORD *)dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    v8 = (int)v1;
    if ( (unsigned int)v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = sub_4A190(v8 + 76, 9, 29);
          if ( v2 )
          {
            *(_WORD *)(v2 + 130) += *(_WORD *)(v8 + 130);
            sub_68E50(v8, v2, a1);
            v3 = a1 - (dword_D41A0 + 28302);
            *(_BYTE *)(v2 + 67) = 10;
            *(_BYTE *)(v2 + 68) = 78;
            *(_WORD *)(v2 + 38) = v3 / 168;
            *(_WORD *)(v2 + 26) = *(_WORD *)(v8 + 26);
            *(_WORD *)(v2 + 80) += *(_WORD *)(v8 + 88);
            *(_DWORD *)(v2 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v2 + 42) = *(char *)(a1 + 70);
            *(_DWORD *)(v2 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v8 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v8 + 164) + 340) = 0;
            *(_DWORD *)(v2 + 154) = *(_DWORD *)(v8 + 76);
            *(_WORD *)(v2 + 158) = *(_WORD *)(v8 + 80);
            sub_57FA0((_WORD *)(v2 + 154), *(_WORD *)(*(_DWORD *)(v8 + 164) + 24) + *(_WORD *)(v8 + 28), 0, 4096);
            *(_WORD *)(v2 + 158) = sub_10C40((__int16 *)(v2 + 154));
            *(_WORD *)(v2 + 28) = *(_WORD *)(*(_DWORD *)(v8 + 164) + 24) + *(_WORD *)(v8 + 28);
            v4 = dword_D41A0 + 28302;
            *(_WORD *)(v2 + 30) = *(_WORD *)(*(_DWORD *)(v8 + 164) + 26) + *(_WORD *)(v8 + 30);
            sub_6E450((v2 - v4) / 168, -1, 15);
          }
          sub_68DE0(a1, v8);
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v5 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v5;
    if ( !v5 )
      sub_6D880(a1);
  }
  result = a1;
  v7 = *(_WORD *)(a1 + 54);
  if ( v7 )
    *(_WORD *)(a1 + 54) = v7 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006CCE0) --------------------------------------------------------
signed int __cdecl sub_6CCE0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006CD00) --------------------------------------------------------
signed int __cdecl sub_6CD00(int a1)
{
  return sub_69250(a1);
}

//----- (0006CD20) --------------------------------------------------------
int __cdecl sub_6CD20(int a1)
{
  _DWORD *v1; // eax
  char *v2; // esi
  int v3; // ebx
  __int16 v4; // ax
  int v5; // eax
  __int16 v6; // di
  int result; // eax
  __int16 v8; // bx
  int v9; // [esp+0h] [ebp-4h]

  if ( *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = (_DWORD *)dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    v9 = (int)v1;
    if ( (unsigned int)v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v3 = sub_4A190(v9 + 76, 9, 25);
          if ( v3 )
          {
            *(_WORD *)(v3 + 130) += *(_WORD *)(v9 + 130);
            sub_68E50(v9, v3, a1);
            v4 = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_BYTE *)(v3 + 67) = 10;
            *(_WORD *)(v3 + 38) = v4;
            *(_BYTE *)(v3 + 68) = 74;
            *(_WORD *)(v3 + 26) = *(_WORD *)(v9 + 26);
            *(_WORD *)(v3 + 40) = *(_WORD *)(a1 + 40);
            *(_WORD *)(v3 + 42) = *(_WORD *)v2;
            *(_BYTE *)(v3 + 70) = v2[24];
            *(_DWORD *)(v3 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v9 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v9 + 164) + 340) = 0;
            *(_DWORD *)(v3 + 154) = *(_DWORD *)(v9 + 76);
            *(_WORD *)(v3 + 158) = *(_WORD *)(v9 + 80);
            sub_57FA0(
              (_WORD *)(v3 + 154),
              *(_WORD *)(*(_DWORD *)(v9 + 164) + 24) + *(_WORD *)(v9 + 28),
              *(_WORD *)(*(_DWORD *)(v9 + 164) + 26) + *(_WORD *)(v9 + 30),
              0x4000);
            *(_WORD *)(v3 + 28) = *(_WORD *)(*(_DWORD *)(v9 + 164) + 24) + *(_WORD *)(v9 + 28);
            v5 = dword_D41A0 + 28302;
            *(_WORD *)(v3 + 30) = *(_WORD *)(*(_DWORD *)(v9 + 164) + 26) + *(_WORD *)(v9 + 30);
            sub_6E450((v3 - v5) / 168, -1, 9);
          }
        }
        sub_68DE0(a1, v9);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v6 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v6;
    if ( !v6 )
      sub_6D880(a1);
  }
  result = a1;
  v8 = *(_WORD *)(a1 + 54);
  if ( v8 )
    *(_WORD *)(a1 + 54) = v8 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006CF60) --------------------------------------------------------
signed int __cdecl sub_6CF60(int a1)
{
  return sub_692A0(a1);
}

//----- (0006CF80) --------------------------------------------------------
signed int __cdecl sub_6CF80(int a1)
{
  return sub_69250(a1);
}

//----- (0006CFA0) --------------------------------------------------------
int __cdecl sub_6CFA0(int a1)
{
  unsigned int v1; // ebx
  char *v2; // edi
  int v3; // esi
  unsigned __int8 v4; // dl
  int v5; // eax
  __int16 v6; // dx
  int result; // eax
  __int16 v8; // cx

  if ( byte_D41B6 && *(_WORD *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (_DWORD *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v3 = sub_6DCA0(v1, v1 + 76, 0x19u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v3 )
          {
            sub_68E50(v1, v3, a1);
            *(_WORD *)(v3 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v3 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v3 + 80) += *(_WORD *)(v1 + 88);
            *(_DWORD *)(v3 + 144) = *(_DWORD *)(a1 + 144);
            v4 = v2[24];
            if ( v4 )
              v5 = *(_DWORD *)v2 / (signed int)v4;
            else
              LOWORD(v5) = *(_WORD *)v2;
            *(_WORD *)(v3 + 42) = v5;
            *(_BYTE *)(v3 + 70) = v2[24];
            *(_DWORD *)(v3 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v3 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v3 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0((_WORD *)(v3 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
            *(_WORD *)(v3 + 158) = sub_10C40((__int16 *)(v3 + 154));
            *(_WORD *)(v3 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v3 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
          }
          sub_68DE0(a1, v1);
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v6 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v6;
    if ( !v6 )
      sub_6D880(a1);
  }
  result = a1;
  v8 = *(_WORD *)(a1 + 54);
  if ( v8 )
    *(_WORD *)(a1 + 54) = v8 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006D1C0) --------------------------------------------------------
signed int __cdecl sub_6D1C0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006D1E0) --------------------------------------------------------
signed int __cdecl sub_6D1E0(int a1)
{
  return sub_69250(a1);
}

//----- (0006D200) --------------------------------------------------------
__int16 __cdecl sub_6D200(int a1)
{
  int v1; // eax
  signed int v2; // ecx
  char v3; // bl
  __int16 v4; // ax
  unsigned __int8 v5; // bl
  int v6; // ebx
  int v7; // edx
  __int16 v8; // bx
  __int16 v9; // di
  int v10; // ebx
  int v11; // eax
  __int16 v12; // bx
  __int16 v13; // ax
  int v15; // [esp+8h] [ebp-14h]
  __int16 v16; // [esp+Ch] [ebp-10h]
  __int16 v17; // [esp+14h] [ebp-8h]

  LOWORD(v1) = *(_WORD *)(a1 + 7);
  if ( (_WORD)v1 == *(_WORD *)(dword_D41A0 + 12) )
  {
    BYTE1(v1) = *(_BYTE *)(a1 + 991);
    if ( BYTE1(v1) == 5 || BYTE1(v1) == 8 )
    {
      if ( word_180660 & 1 )
        v2 = 400;
      else
        v2 = 480;
      v3 = *(_BYTE *)(a1 + 2110);
      if ( v3 < 13 )
        v4 = v3;
      else
        v4 = v3 - 13;
      v17 = v4;
      v1 = dword_EA3DC;
      v15 = *(unsigned __int8 *)(dword_EA3DC + 539);
      v5 = *(_BYTE *)(a1 + 2109);
      if ( v5 )
      {
        if ( v5 <= 2u )
        {
          v8 = (unsigned __int8)byte_D94FF[*(char *)(a1 + 2110)];
          LOBYTE(v8) = *(_BYTE *)(dword_EA3DC + 982);
          v9 = 3 * v8;
          v16 = v8;
          LOWORD(v1) = *(unsigned __int8 *)(dword_EA3DC + 983);
          v10 = v2 - 2 * v15 - v1;
          v11 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 538) >> 1)
              + *(unsigned __int8 *)(dword_EA3DC + 538) * v17
              + *(unsigned __int8 *)(dword_EA3DC + 532)
              - (v9 >> 1);
          v12 = v10 + 18;
          if ( 640 - v9 >= (signed __int16)v11 )
          {
            if ( (v11 & 0x8000u) != 0 )
              LOWORD(v11) = 0;
          }
          else
          {
            LOWORD(v11) = 640 - v9;
          }
          v13 = v16 * *(char *)((unsigned __int8)byte_D94FF[*(char *)(a1 + 2110)] + a1 + 1609 + 468)
              + (v16 >> 1)
              + 8
              + v11;
          if ( word_1805C2 != 7 && word_1805C2 != 1 && word_1805C2 != 2 )
          {
            dword_1805B0 = v13;
            LOWORD(v1) = v12;
            dword_1805B4 = v12;
          }
          else
          {
            LOWORD(v1) = sub_5BDC0(v13, v12);
          }
        }
      }
      else
      {
        v6 = *(unsigned __int8 *)(dword_EA3DC + 538) * v17
           + *(unsigned __int8 *)(dword_EA3DC + 532)
           + ((signed int)*(unsigned __int8 *)(dword_EA3DC + 538) >> 1);
        v7 = ((signed __int16)v15 >> 1)
           + (signed __int16)v2
           - 2 * (signed __int16)v15
           + (signed __int16)v15 * (*(_BYTE *)(a1 + 2110) >= 13);
        if ( word_1805C2 != 7 && word_1805C2 != 1 && word_1805C2 != 2 )
        {
          dword_1805B0 = (signed __int16)v6;
          LOWORD(v1) = v7;
          dword_1805B4 = (signed __int16)v7;
        }
        else
        {
          LOWORD(v1) = sub_5BDC0(v6, v7);
        }
      }
    }
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3DC: using guessed type int dword_EA3DC;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;
// 180660: using guessed type __int16 word_180660;

//----- (0006D420) --------------------------------------------------------
int __cdecl sub_6D420(__int16 a1, __int16 a2)
{
  signed __int16 v2; // ax
  int v3; // ebx
  int v4; // eax

  if ( word_180660 & 1 )
    v2 = 400;
  else
    v2 = 480;
  v3 = (a2 - (signed __int16)(v2 - 2 * *(unsigned __int8 *)(dword_EA3DC + 539)))
     / *(unsigned __int8 *)(dword_EA3DC + 539);
  v4 = (a1 - *(unsigned __int8 *)(dword_EA3DC + 532)) / *(unsigned __int8 *)(dword_EA3DC + 538);
  if ( (v3 & 0x8000u) == 0 )
  {
    if ( (signed __int16)v3 > 1 )
      v3 = 1;
  }
  else
  {
    v3 = 0;
  }
  if ( (v4 & 0x8000u) == 0 )
  {
    if ( (signed __int16)v4 > 12 )
      v4 = 12;
  }
  else
  {
    v4 = 0;
  }
  return 13 * v3 + v4;
}
// EA3DC: using guessed type int dword_EA3DC;
// 180660: using guessed type __int16 word_180660;

//----- (0006D4C0) --------------------------------------------------------
char __cdecl sub_6D4C0(int a1)
{
  char result; // al

  result = *(_BYTE *)(a1 + (unsigned __int8)byte_D94FF[*(char *)(a1 + 501)] + 468);
  *(_BYTE *)(a1 + 502) = result;
  return result;
}

//----- (0006D4F0) --------------------------------------------------------
int __cdecl sub_6D4F0(int a1, __int16 a2)
{
  __int16 v2; // cx
  int v3; // esi
  int v4; // eax
  int result; // eax
  int v6; // edx

  v2 = 3 * *(unsigned __int8 *)(dword_EA3DC + 982);
  v3 = *(unsigned __int8 *)(dword_EA3DC + 538) / 2
     + *(unsigned __int8 *)(dword_EA3DC + 532)
     + *(unsigned __int8 *)(dword_EA3DC + 538) * (*(char *)(a1 + 501) % 13)
     - v2 / 2;
  v4 = *(unsigned __int8 *)(dword_EA3DC + 538) / 2
     + *(unsigned __int8 *)(dword_EA3DC + 532)
     + *(unsigned __int8 *)(dword_EA3DC + 538) * (*(char *)(a1 + 501) % 13)
     - v2 / 2;
  if ( (signed __int16)v3 <= 640 - v2 )
  {
    if ( (v3 & 0x8000u) != 0 )
      LOWORD(v4) = v3 ^ v4;
  }
  else
  {
    LOWORD(v4) = 640 - v2;
  }
  result = (a2 - (signed __int16)v4) / *(unsigned __int8 *)(dword_EA3DC + 982);
  v6 = a1 + (unsigned __int8)byte_D94FF[*(char *)(a1 + 501)];
  LOWORD(v6) = *(char *)(v6 + 442);
  if ( (signed __int16)result > (signed __int16)v6 )
    return v6;
  if ( (result & 0x8000u) != 0 )
    result = 0;
  return result;
}
// EA3DC: using guessed type int dword_EA3DC;

//----- (0006D5E0) --------------------------------------------------------
char __cdecl sub_6D5E0(int a1, char a2)
{
  int v2; // eax
  int v3; // edx
  char *v4; // esi
  unsigned __int8 v5; // dl
  unsigned __int8 v6; // ST04_1
  unsigned __int16 v7; // dx
  __int16 v8; // cx
  int v9; // edi

  LOBYTE(v2) = a2;
  v3 = 80 * *(char *)(a1 + 64);
  if ( a2 > (unsigned __int8)byte_DA818[v3] - 1 )
    LOBYTE(v2) = byte_DA818[v3] - 1;
  if ( *(_WORD *)(a1 + 46) )
  {
    *(_WORD *)(a1 + 44) = (char)v2 + 1;
  }
  else
  {
    v4 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * (char)v2];
    *(_BYTE *)(a1 + 70) = v2;
    *(_WORD *)(a1 + 42) = *(_WORD *)v4;
    *(_WORD *)(a1 + 48) = *((_WORD *)v4 + 11);
    *(_BYTE *)(a1 + 59) = (v4[25] & 1) == 0;
    v5 = *(_BYTE *)(a1 + 64);
    *(_BYTE *)(a1 + 60) = 0;
    v6 = v5;
    v7 = *(_WORD *)(a1 + 40);
    *(_BYTE *)(a1 + 61) = 0;
    v2 = sub_6D710(dword_EA3E4[v7], v6, v2);
    v8 = *(_WORD *)(a1 + 48);
    v9 = v2;
    if ( v8 )
      v2 /= v8;
    *(_DWORD *)(a1 + 144) = v2;
    *(_DWORD *)(a1 + 140) = v9;
    *(_DWORD *)(a1 + 136) = *((_DWORD *)v4 + 2);
    if ( *(_BYTE *)(dword_D41A4 + 24) & 0x20 )
    {
      *(_DWORD *)(a1 + 136) = 0;
      *(_DWORD *)(a1 + 144) = 1;
    }
  }
  return v2;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006D710) --------------------------------------------------------
int __cdecl sub_6D710(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3)
{
  signed int v3; // ecx
  int result; // eax
  int v5; // edx
  unsigned int v6; // ebx
  int v7; // edx
  int v8; // eax

  v3 = 0;
  result = *(_DWORD *)&byte_DA818[80 * a2 + 6 + 26 * a3];
  if ( a2 == 2 && a1 > dword_EA3E4[0] )
  {
    v5 = *(_DWORD *)(a1 + 164);
    v6 = dword_EA3E4[*(unsigned __int16 *)(v5 + 58)];
    if ( v6 <= dword_EA3E4[0] )
      goto LABEL_23;
    switch ( *(_DWORD *)(v6 + 16) )
    {
      case 0:
        result = 1000;
        break;
      case 1:
        result = 10000;
        break;
      case 2:
        result = 20000;
        break;
      case 3:
        result = 40000;
        break;
      case 4:
        result = (int)nullsub_1;
        break;
      case 5:
        result = 160000;
        break;
      case 6:
        result = 320000;
        break;
      default:
        result = 300000000;
        break;
    }
    if ( *(_DWORD *)(v6 + 16) >= 7 )
      goto LABEL_25;
    if ( a3 >= 1u )
    {
      if ( a3 <= 1u )
      {
        v7 = 320 * result;
        v8 = 320 * result;
      }
      else
      {
        if ( a3 != 2 )
          goto LABEL_21;
        v8 = 384 * result;
        v7 = v8;
      }
      result = (v8 - (__CFSHL__(v7 >> 31, 8) + (v7 >> 31 << 8))) >> 8;
    }
LABEL_21:
    if ( *(_DWORD *)(v6 + 16) )
    {
LABEL_25:
      if ( v3 )
        result += 3000;
      return result;
    }
    v5 = *(_DWORD *)(a1 + 164);
LABEL_23:
    if ( *(_BYTE *)(v5 + 446) )
      v3 = 1;
    goto LABEL_25;
  }
  return result;
}
// 13880: using guessed type int __fastcall nullsub_1(_DWORD);
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006D830) --------------------------------------------------------
char __cdecl sub_6D830(int a1, char a2)
{
  char *v2; // eax
  unsigned int v3; // esi
  int v4; // esi

  LOBYTE(v2) = *(_BYTE *)(a1 + 64);
  if ( (_BYTE)v2 == 10 )
  {
    v2 = (char *)&unk_DAB3A + 26 * a2;
    v3 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v3 > dword_EA3E4[0] && v2[24] == 1 )
    {
      v4 = v3 + 76;
      *(_DWORD *)(a1 + 154) = *(_DWORD *)v4;
      *(_WORD *)(a1 + 158) = *(_WORD *)(v4 + 4);
    }
  }
  return (char)v2;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006D880) --------------------------------------------------------
char __cdecl sub_6D880(int a1)
{
  char result; // al

  if ( *(_WORD *)(a1 + 44) )
  {
    result = sub_6D5E0(a1, *(_BYTE *)(a1 + 44) - 1);
    *(_WORD *)(a1 + 44) = 0;
  }
  return result;
}

//----- (0006D8B0) --------------------------------------------------------
void __cdecl sub_6D8B0(unsigned __int16 a1, unsigned __int16 a2, __int16 a3)
{
  int v3; // eax
  int v4; // ebx
  int v5; // ecx
  int v6; // ebx

  if ( !(*(_BYTE *)(dword_D41A4 + 38545) & 4) )
  {
    if ( a1 )
    {
      v3 = dword_EA3E4[a1];
      if ( *(_BYTE *)(v3 + 63) == 3 && !*(_BYTE *)(v3 + 64) )
      {
        v4 = *(_DWORD *)(v3 + 164);
        v5 = *(_DWORD *)(v4 + 4 * a2 + 715);
        v6 = v4 + 611;
        *(_DWORD *)(v6 + 4 * a2 + 104) = a3 + v5;
        if ( a2 == 2 )
          sub_6D5E0(dword_EA3E4[*(signed __int16 *)(v6 + 212)], *(_BYTE *)(v6 + 470));
        if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
        {
          if ( a1 == *(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240) )
            sub_6DAD0(v6, (unsigned __int8 *)&byte_DA818[80 * a2], a2);
        }
        else
        {
          sub_6D9C0(v6, (unsigned __int8 *)&byte_DA818[80 * a2], a2, 0, 1);
        }
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006D9C0) --------------------------------------------------------
int __cdecl sub_6D9C0(int a1, unsigned __int8 *a2, __int16 a3, char a4, char a5)
{
  signed int v5; // esi
  int v6; // eax
  int v7; // edi
  int v8; // edx
  int result; // eax
  char v10; // dh

  v5 = 0;
  if ( (*(_BYTE *)(a1 + a3 + 390) || *(_WORD *)(a1 + 2 * a3 + 208)) && (byte_D41B6 || a3 != 25) )
    v5 = 1;
  if ( *(_BYTE *)(dword_D41A4 + 23) >= 0 && *(_DWORD *)(a1 + 112) > 7 )
    *(_DWORD *)(a1 + 112) = 7;
  v6 = *a2;
  v7 = *(_DWORD *)(a1 + 4 * a3 + 104) + *(_DWORD *)(a1 + 4 * a3);
  do
    --v6;
  while ( v6 >= 0 && v7 < *(_DWORD *)&a2[26 * v6 + 14] );
  if ( v6 < 0 )
    v6 = 0;
  v8 = a1 + a3;
  if ( v6 != *(char *)(v8 + 442) )
  {
    *(_BYTE *)(v8 + 442) = v6;
    if ( v5 )
    {
      if ( a5 )
        sub_6DC40(a3);
    }
  }
  result = a1 + a3;
  v10 = *(_BYTE *)(result + 442);
  if ( *(_BYTE *)(result + 468) > v10 )
    *(_BYTE *)(result + 468) = v10;
  if ( v5 && a4 )
  {
    if ( v7 >= *(_DWORD *)(a2 + 66) )
    {
      result = *(_DWORD *)(a2 + 66);
      *(_DWORD *)(4 * a3 + a1) = result;
    }
    else
    {
      result = a3;
      *(_DWORD *)(a1 + 4 * a3) = v7;
    }
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;

//----- (0006DAD0) --------------------------------------------------------
void __cdecl sub_6DAD0(int a1, unsigned __int8 *a2, __int16 a3)
{
  int v3; // eax
  int v4; // edx

  if ( *(_WORD *)(a1 + 2 * a3 + 208) && *(char *)(a1 + a3 + 442) < *a2 - 1 )
  {
    v3 = *(_DWORD *)(a1 + 4 * a3 + 104) + *(_DWORD *)(a1 + 4 * a3);
    if ( v3 < 0 )
      v3 = 0;
    if ( v3 > *(_DWORD *)(a2 + 70) + 2 )
      v3 = *(_DWORD *)(a2 + 70) + 2;
    v4 = a1 + a3;
    if ( v3 >= *(_DWORD *)&a2[26 * (*(char *)(v4 + 442) + 1) + 18] )
    {
      ++*(_BYTE *)(v4 + 442);
      sub_6DC40(a3);
    }
  }
}

//----- (0006DB50) --------------------------------------------------------
int __cdecl sub_6DB50(char a1, char a2)
{
  int result; // eax
  unsigned __int8 *v3; // esi
  signed int v4; // ebx
  int v5; // edi
  __int16 v6; // ST08_2

  result = dword_D41A4;
  if ( !(*(_BYTE *)(dword_D41A4 + 22) & 0x10) )
  {
    v3 = (unsigned __int8 *)byte_DA818;
    result = *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(dword_D41A0
                                                         + 2124 * *(signed __int16 *)(dword_D41A0 + 12)
                                                         + 11240)]
                       + 164);
    v4 = 0;
    v5 = result + 611;
    while ( v4 < 26 )
    {
      v6 = v4++;
      result = sub_6D9C0(v5, v3, v6, a1, a2);
      v3 += 80;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006DBD0) --------------------------------------------------------
void sub_6DBD0()
{
  unsigned __int8 *v0; // esi
  signed int v1; // ebx
  int v2; // edi
  __int16 v3; // ST08_2

  if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
  {
    v0 = (unsigned __int8 *)byte_DA818;
    v1 = 0;
    v2 = *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)]
                   + 164)
       + 611;
    while ( v1 < 26 )
    {
      v3 = v1++;
      sub_6DAD0(v2, v0, v3);
      v0 += 80;
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006DC40) --------------------------------------------------------
void __cdecl sub_6DC40(unsigned __int8 a1)
{
  char v1; // [esp+0h] [ebp-2h]

  sprintf(&v1, (const char *)dword_E9EC8, dword_E9ECC[a1]);
  sub_19760(&v1, 5u, 200);
  sub_6E450(*(_WORD *)(dword_D41A0 + 12), -1, 61);
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// E9EC8: using guessed type int dword_E9EC8;

//----- (0006DCA0) --------------------------------------------------------
int __cdecl sub_6DCA0(int a1, int a2, unsigned __int16 a3, __int16 *a4, __int16 a5, char a6)
{
  __int16 v6; // di
  int v7; // ebx
  int v8; // eax
  unsigned __int8 v9; // dl
  int v10; // eax
  __int16 v11; // ax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  int v23; // eax
  __int16 v24; // dx

  v6 = 15;
  v7 = 0;
  if ( a3 < 0x10u )
  {
    if ( a3 < 9u )
    {
      if ( a3 )
      {
        if ( a3 != 7 )
          goto LABEL_60;
        v9 = *((_BYTE *)a4 + 24);
        if ( v9 )
        {
          if ( v9 > 2u )
            goto LABEL_60;
          v12 = sub_4A190(a2, 9, 12);
          v7 = v12;
          if ( !v12 )
            goto LABEL_60;
          *(_BYTE *)(v12 + 67) = 9;
          *(_BYTE *)(v12 + 68) = 9;
          v11 = *a4;
          v6 = 9;
        }
        else
        {
          v10 = sub_4A190(a2, 9, 9);
          v7 = v10;
          if ( !v10 )
            goto LABEL_60;
          *(_BYTE *)(v10 + 67) = 10;
          *(_BYTE *)(v10 + 68) = 23;
          v11 = *a4;
          v6 = 23;
        }
        *(_WORD *)(v7 + 42) = v11;
        goto LABEL_60;
      }
      if ( *((_BYTE *)a4 + 24) >= 2u )
        v8 = sub_4A190(a2, 9, 28);
      else
        v8 = sub_4A190(a2, 9, 0);
      v7 = v8;
      if ( v8 )
      {
        *(_BYTE *)(v8 + 67) = 10;
        if ( *((_BYTE *)a4 + 24) >= 2u )
          *(_BYTE *)(v8 + 68) = 76;
        else
          *(_BYTE *)(v8 + 68) = 0;
        v6 = 9;
      }
    }
    else
    {
      if ( a3 <= 9u )
      {
        v13 = sub_4A190(a2, 9, 3);
        v7 = v13;
        if ( !v13 )
          goto LABEL_60;
        *(_BYTE *)(v13 + 67) = 10;
        *(_BYTE *)(v13 + 68) = 17;
        *(_WORD *)(v13 + 42) = *a4;
        goto LABEL_59;
      }
      if ( a3 < 0xDu )
        goto LABEL_60;
      if ( a3 <= 0xDu )
      {
        v14 = sub_4A190(a2, 9, 8);
        v7 = v14;
        if ( v14 )
        {
          *(_BYTE *)(v14 + 67) = 10;
          *(_BYTE *)(v14 + 68) = 25;
        }
      }
      else if ( a3 == 15 )
      {
        v15 = sub_4A190(a2, 9, 23);
        v7 = v15;
        if ( v15 )
        {
          *(_BYTE *)(v15 + 67) = 10;
          *(_BYTE *)(v15 + 68) = 71;
          *(_WORD *)(v15 + 42) = *a4;
LABEL_59:
          *(_BYTE *)(v7 + 70) = *((_BYTE *)a4 + 24);
          goto LABEL_60;
        }
      }
    }
  }
  else if ( a3 <= 0x10u )
  {
    v16 = sub_4A190(a2, 9, 5);
    v7 = v16;
    if ( v16 )
    {
      *(_BYTE *)(v16 + 67) = 10;
      *(_BYTE *)(v16 + 68) = 11;
      *(_WORD *)(v16 + 42) = *a4;
      *(_BYTE *)(v16 + 70) = *((_BYTE *)a4 + 24);
    }
  }
  else if ( a3 < 0x14u )
  {
    if ( a3 <= 0x11u )
    {
      v17 = sub_4A190(a2, 9, 2);
      v7 = v17;
      if ( v17 )
      {
        *(_BYTE *)(v17 + 67) = 10;
        *(_BYTE *)(v17 + 68) = 15;
        *(_WORD *)(v17 + 42) = *a4;
        *(_BYTE *)(v17 + 70) = *((_BYTE *)a4 + 24);
      }
    }
    else if ( a3 == 18 )
    {
      v18 = sub_4A190(a2, 9, 4);
      v7 = v18;
      if ( v18 )
      {
        *(_BYTE *)(v18 + 67) = 10;
        *(_BYTE *)(v18 + 68) = 9;
        *(_WORD *)(v18 + 42) = *a4;
        *(_BYTE *)(v18 + 70) = *((_BYTE *)a4 + 24);
      }
    }
  }
  else if ( a3 <= 0x14u )
  {
    v19 = sub_4A190(a2, 9, 22);
    v7 = v19;
    if ( v19 )
    {
      *(_BYTE *)(v19 + 67) = 10;
      *(_BYTE *)(v19 + 68) = 67;
      *(_WORD *)(v19 + 42) = *a4;
      *(_BYTE *)(v19 + 70) = *((_BYTE *)a4 + 24);
    }
  }
  else
  {
    if ( a3 <= 0x15u )
    {
      v20 = sub_4A190(a2, 9, 26);
      v21 = v20;
      v7 = v20;
      if ( !v20 )
        goto LABEL_60;
      *(_BYTE *)(v20 + 67) = 10;
      *(_BYTE *)(v20 + 68) = 22;
      if ( *((_BYTE *)a4 + 24) )
        v22 = *(_DWORD *)a4 / (signed int)*((unsigned __int8 *)a4 + 24);
      else
        LOWORD(v22) = *a4;
      goto LABEL_58;
    }
    if ( a3 == 25 )
    {
      v23 = sub_4A190(a2, 9, 30);
      v21 = v23;
      v7 = v23;
      if ( v23 )
      {
        *(_BYTE *)(v23 + 67) = 10;
        *(_BYTE *)(v23 + 68) = 89;
        if ( *((_BYTE *)a4 + 24) )
          v22 = *(_DWORD *)a4 / (signed int)*((unsigned __int8 *)a4 + 24);
        else
          LOWORD(v22) = *a4;
LABEL_58:
        *(_WORD *)(v21 + 42) = v22;
        goto LABEL_59;
      }
    }
  }
LABEL_60:
  if ( v7 )
  {
    v24 = a5 + *(_WORD *)(v7 + 130);
    *(_WORD *)(v7 + 130) = v24;
    if ( v24 < 384 )
      *(_WORD *)(v7 + 130) = 384;
    if ( *(_WORD *)(v7 + 130) > 0x2000 )
      *(_WORD *)(v7 + 130) = 0x2000;
    if ( a6 )
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, v6);
  }
  return v7;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0006E020) --------------------------------------------------------
signed int __cdecl sub_6E020(unsigned __int16 a1)
{
  signed int result; // eax

  result = 0;
  if ( a1 < 0x11u )
  {
    if ( a1 < 0xBu )
    {
      if ( a1 == 9 )
        result = 18;
    }
    else if ( a1 <= 0xBu )
    {
      result = 16;
    }
    else if ( a1 == 15 )
    {
      result = 17;
    }
  }
  else if ( a1 <= 0x11u )
  {
    result = 9;
  }
  else if ( a1 < 0x43u )
  {
    if ( a1 == 22 )
      result = 21;
  }
  else if ( a1 <= 0x43u )
  {
    result = 20;
  }
  else if ( a1 == 71 )
  {
    result = 15;
  }
  return result;
}

//----- (0006E090) --------------------------------------------------------
int __cdecl sub_6E090(int a1, int a2)
{
  signed int i; // eax
  int result; // eax

  for ( i = 0; i < 26; ++i )
  {
    if ( *(_WORD *)(a1 + 2 * i + 208) )
      *(_DWORD *)(a1 + 4 * i + 104) += a2;
  }
  result = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 23) >= 0 && *(_DWORD *)(a1 + 112) > 7 )
    *(_DWORD *)(a1 + 112) = 7;
  return result;
}
// D41A4: using guessed type int dword_D41A4;

//----- (0006E0D0) --------------------------------------------------------
int sub_6E0D0()
{
  signed int v0; // edx
  int v1; // ecx
  int v2; // ebx

  v0 = 0;
  v1 = *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)]
                 + 164)
     + 611;
  while ( v0 < 26 )
  {
    *(_BYTE *)(v1 + v0 + 390) = 1;
    v2 = dword_DA85A[20 * v0++];
    *(_DWORD *)(v1 + 4 * v0 - 4) = v2 + 1;
  }
  return sub_6DB50(1, 0);
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006E150) --------------------------------------------------------
void sub_6E150()
{
  __int16 v0; // si
  int v1; // ebx
  unsigned __int16 v2; // di
  int v3; // ebx
  int v4; // ebx

  if ( byte_E3799 && byte_E3798 && (!(*(_BYTE *)(dword_D41A4 + 24) & 1) || *(_BYTE *)(dword_D41A4 + 38543)) )
  {
    v0 = 0;
    do
    {
      v1 = 6 * v0;
      switch ( word_F4FE0[v1] )
      {
        case 1:
          sub_75110(word_F4FE6[6 * v0], v0, word_F4FE4[6 * v0], word_F4FE2[6 * v0], word_F4FEA[6 * v0]);
          word_F4FE0[6 * v0] = 0;
          word_F4FE8[6 * v0] = 2;
          break;
        case 2:
          sub_751B0(word_F4FE6[v1], v0, word_F4FE4[v1], word_F4FE2[v1], word_F4FEA[v1]);
          word_F4FE0[v1] = 0;
          word_F4FE8[v1] = 2;
          break;
        case 3:
          sub_75160(word_F4FE6[v1], v0, word_F4FE4[v1], word_F4FE2[v1], word_F4FEA[v1]);
          word_F4FE0[v1] = 0;
          word_F4FE8[v1] = 2;
          break;
        case 4:
          v2 = word_F4FE4[v1];
          if ( v2 == 512 )
            sub_8F420(0, v0);
          else
            sub_8F100(0, v0, (signed int)v2 >> 8, 64, 0x64u, -1, 2u);
          v3 = 3 * v0;
          word_F4FE8[2 * v3] = 2;
          word_F4FE0[2 * v3] = 0;
          break;
        default:
          break;
      }
      v4 = 3 * v0++;
      word_F4FE4[2 * v4] = 0;
    }
    while ( v0 < 70 );
  }
}
// D41A4: using guessed type int dword_D41A4;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// F4FE0: using guessed type __int16 word_F4FE0[];
// F4FE2: using guessed type __int16 word_F4FE2[];
// F4FE4: using guessed type __int16 word_F4FE4[];
// F4FE6: using guessed type __int16 word_F4FE6[];
// F4FE8: using guessed type __int16 word_F4FE8[];

//----- (0006E450) --------------------------------------------------------
void __cdecl sub_6E450(__int16 a1, __int16 a2, __int16 a3)
{
  unsigned int v3; // edx
  _WORD *v4; // esi
  unsigned int v5; // eax
  __int16 v6; // ax
  unsigned __int16 v7; // ax
  int v8; // edx
  int v9; // eax
  int v10; // esi
  int v11; // edx
  int v12; // edi
  unsigned int v13; // eax
  unsigned int v14; // edx
  int v15; // ebx
  int v16; // ebx
  int v17; // ebx
  int v18; // ebx
  int v19; // ebx
  int v20; // ebx
  __int16 v21; // [esp+0h] [ebp-24h]
  unsigned int v22; // [esp+4h] [ebp-20h]
  signed int v23; // [esp+8h] [ebp-1Ch]
  int v24; // [esp+Ch] [ebp-18h]
  unsigned int v25; // [esp+10h] [ebp-14h]
  int v26; // [esp+14h] [ebp-10h]
  unsigned __int16 v27; // [esp+18h] [ebp-Ch]
  __int16 v28; // [esp+1Ch] [ebp-8h]
  __int16 v29; // [esp+20h] [ebp-4h]

  v29 = 0;
  v21 = 0;
  v24 = *(_DWORD *)(dword_D41A0 + 8);
  if ( !byte_E3799 || !byte_E3798 )
    return;
  v3 = dword_EA3E4[a1];
  v22 = v3;
  if ( v3 <= dword_EA3E4[0] )
  {
    v10 = 0x7FFF;
    LOWORD(v12) = 0x7FFF;
  }
  else
  {
    if ( *(_BYTE *)(v3 + 12) < 0 )
      return;
    v4 = (_WORD *)(v3 + 76);
    if ( (unsigned int)sub_584D0(
                         (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12)
                                                                   + dword_D41A0
                                                                   + 11240)]
                                 + 76),
                         (_WORD *)(v3 + 76)) > 0x9000000 )
      return;
    v26 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
    v29 = *(_WORD *)(v22 + 26);
    v5 = sub_58490((_WORD *)(v26 + 76), v4);
    v25 = v5;
    v23 = v5;
    v6 = sub_581E0((_WORD *)(v26 + 76), v4);
    v28 = v6;
    v7 = sub_582B0(*(_WORD *)(v26 + 28), v6);
    v27 = v7;
    v8 = 12288 * (512 - v7 / 2 + 512);
    v9 = (v8 - (__CFSHL__(v8 >> 31, 10) + (v8 >> 31 << 10))) >> 10;
    v10 = v9 ? (signed int)(0x7FFF * (v9 - v25)) / v9 : 0x7FFF;
    v11 = (signed __int16)sub_582F0(*(unsigned __int16 *)(v26 + 28), v28);
    if ( v10 < 512 )
      return;
    if ( v10 > 0x7FFF )
      v10 = 0x7FFF;
    if ( v23 > 320 )
    {
      if ( v27 > 0x200u )
        v27 = 1024 - v27;
      v12 = (((v27 << 15) * v11 - (__CFSHL__((v27 << 15) * v11 >> 31, 9) + ((v27 << 15) * v11 >> 31 << 9))) >> 9)
          + 0x7FFF;
      if ( v12 < 0 )
        v12 = 0;
      if ( v12 > 0xFFFF )
        LOWORD(v12) = -1;
    }
    else
    {
      LOWORD(v12) = 0x7FFF;
    }
    if ( (unsigned __int16)a3 >= 0x2Au )
    {
      v13 = 9377 * v24 + 9439;
      if ( (unsigned __int16)a3 <= 0x2Cu )
      {
        v14 = v13 % 0x1E - 15;
      }
      else
      {
        if ( a3 != 46 )
          goto LABEL_29;
        v14 = v13 % 0x14;
        if ( *(_BYTE *)(v22 + 69) == 14 )
          LOWORD(v14) = v14 + 10;
        else
          LOWORD(v14) = v14 - 10;
      }
      v21 = v14;
    }
  }
LABEL_29:
  if ( (unsigned __int16)a3 < 0x2Au )
  {
    if ( (unsigned __int16)a3 < 0x20u )
    {
      if ( a3 != 7 )
        goto LABEL_46;
      goto LABEL_45;
    }
    if ( (unsigned __int16)a3 <= 0x20u || a3 == 38 )
    {
LABEL_45:
      v29 = 0;
      goto LABEL_46;
    }
  }
  else
  {
    if ( (unsigned __int16)a3 <= 0x2Cu )
      goto LABEL_45;
    if ( (unsigned __int16)a3 >= 0x31u )
    {
      if ( (unsigned __int16)a3 > 0x35u && ((unsigned __int16)a3 < 0x3Au || (unsigned __int16)a3 > 0x3Bu && a3 != 62) )
        goto LABEL_46;
      goto LABEL_45;
    }
    if ( (unsigned __int16)a3 >= 0x2Eu && (unsigned __int16)a3 <= 0x2Fu )
      goto LABEL_45;
  }
LABEL_46:
  switch ( a3 )
  {
    case 1:
    case 2:
      if ( a2 == *(_WORD *)(dword_D41A0 + 12) )
      {
        sub_8F100(0, a3, 0, 64, 0x64u, -1, 2u);
        sub_8F710(0, a3, 70, 2u, 0);
      }
      break;
    case 3:
    case 4:
    case 6:
    case 9:
    case 10:
    case 11:
    case 15:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 30:
    case 38:
    case 40:
    case 41:
    case 48:
    case 50:
    case 51:
    case 52:
    case 53:
    case 60:
    case 61:
    case 63:
    case 64:
      v17 = 6 * a3;
      if ( sub_6EA90(v10, (unsigned __int16)word_F4FE4[v17]) )
      {
        word_F4FE4[v17] = v10;
        word_F4FE2[v17] = v12;
        word_F4FEA[v17] = v21;
        word_F4FE0[v17] = 1;
        word_F4FE6[v17] = v29;
      }
      break;
    case 5:
      if ( a2 == *(_WORD *)(dword_D41A0 + 12) )
      {
        sub_8F100(0, a3, 0, 64, 0x64u, -1, 2u);
        sub_8F710(0, a3, 120, 2u, 0);
      }
      break;
    case 7:
    case 8:
    case 12:
    case 13:
    case 16:
    case 17:
    case 32:
    case 33:
    case 34:
    case 37:
    case 39:
    case 42:
    case 43:
    case 44:
    case 46:
    case 58:
    case 59:
    case 62:
      v20 = 6 * a3;
      if ( sub_6EA90(v10, (unsigned __int16)word_F4FE4[v20]) )
      {
        word_F4FE4[v20] = v10;
        word_F4FE2[v20] = v12;
        word_F4FEA[v20] = v21;
        word_F4FE0[v20] = 3;
        word_F4FE6[v20] = v29;
      }
      break;
    case 14:
    case 29:
      v18 = 6 * a3;
      if ( sub_6EA90(v10, (unsigned __int16)word_F4FE4[v18]) )
      {
        if ( a2 == *(_WORD *)(dword_D41A0 + 12) )
        {
          word_F4FE4[v18] = v10;
          word_F4FE2[v18] = v12;
          word_F4FEA[v18] = v21;
          word_F4FE6[v18] = 0;
          word_F4FE0[v18] = 1;
        }
        else if ( a2 == -1 )
        {
          word_F4FE4[v18] = v10;
          word_F4FE2[v18] = v12;
          word_F4FEA[v18] = v21;
          word_F4FE6[v18] = v29;
          word_F4FE0[v18] = 1;
        }
      }
      break;
    case 31:
      if ( a2 == *(_WORD *)(dword_D41A0 + 12) )
      {
        sub_8F100(0, a3, 0, 64, 0x64u, -1, 2u);
        sub_8F710(0, a3, 85, 2u, 0);
      }
      break;
    case 47:
    case 49:
      v15 = 6 * a3;
      if ( sub_6EA90(v10, (unsigned __int16)word_F4FE4[v15]) )
      {
        word_F4FE4[v15] = v10;
        word_F4FE2[v15] = v12;
        word_F4FEA[v15] = v21;
        word_F4FE6[v15] = v29;
        word_F4FE0[v15] = 4;
      }
      break;
    case 54:
    case 55:
    case 56:
    case 57:
      v19 = 6 * a3;
      if ( sub_6EA90(v10, (unsigned __int16)word_F4FE4[v19]) )
      {
        if ( a2 == *(_WORD *)(dword_D41A0 + 12) )
        {
          word_F4FE4[v19] = v10;
          word_F4FE2[v19] = v12;
          word_F4FEA[v19] = v21;
          word_F4FE6[v19] = 0;
          word_F4FE0[v19] = 3;
        }
        else if ( a2 == -1 )
        {
          word_F4FE4[v19] = v10;
          word_F4FE2[v19] = v12;
          word_F4FEA[v19] = v21;
          word_F4FE6[v19] = v29;
          word_F4FE0[v19] = 3;
        }
      }
      break;
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
      v16 = 3 * a3;
      word_F4FE4[2 * v16] = v10;
      word_F4FE2[2 * v16] = v12;
      word_F4FE0[2 * v16] = 3;
      word_F4FEA[2 * v16] = v21;
      word_F4FE6[2 * v16] = v29;
      break;
    default:
      return;
  }
}
// D41A0: using guessed type int dword_D41A0;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// EA3E4: using guessed type int dword_EA3E4[];
// F4FE0: using guessed type __int16 word_F4FE0[];
// F4FE2: using guessed type __int16 word_F4FE2[];
// F4FE4: using guessed type __int16 word_F4FE4[];
// F4FE6: using guessed type __int16 word_F4FE6[];

//----- (0006EA90) --------------------------------------------------------
bool __cdecl sub_6EA90(int a1, int a2)
{
  return a1 - a2 >= -8;
}

//----- (0006EAB0) --------------------------------------------------------
void __cdecl sub_6EAB0(int a1, __int16 a2, __int16 a3)
{
  if ( !byte_E3799 || !byte_E3798 )
    return;
  if ( (unsigned __int16)a3 < 0x1Fu )
  {
    if ( (unsigned __int16)a3 < 1u || (unsigned __int16)a3 > 2u && a3 != 5 )
      return;
  }
  else if ( (unsigned __int16)a3 > 0x1Fu )
  {
    if ( (unsigned __int16)a3 >= 0x2Fu && ((unsigned __int16)a3 <= 0x2Fu || a3 == 49) )
      sub_8F710(0, a3, 0, 4u, 1);
    return;
  }
  if ( a2 == *(_WORD *)(dword_D41A0 + 12) )
    sub_8F710(0, a3, 0, 2u, 1);
}
// D41A0: using guessed type int dword_D41A0;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;

//----- (0006EB90) --------------------------------------------------------
unsigned int __cdecl sub_6EB90(unsigned int **a1)
{
  unsigned int **i; // ebx
  unsigned int result; // eax

  for ( i = a1; *i; i += 3 )
  {
    if ( word_180660 & 1 )
      result = sub_98709(**i, *i[1], *i[2]);
    else
      result = (unsigned int)sub_9874D((unsigned int *)**i, *i[1], *i[2]);
  }
  return result;
}
// 180660: using guessed type __int16 word_180660;

//----- (0006EBF0) --------------------------------------------------------
unsigned int __cdecl sub_6EBF0(unsigned int **a1)
{
  unsigned int **i; // ebx
  unsigned int result; // eax

  for ( i = a1; *i; i += 3 )
  {
    if ( word_180660 & 1 )
      result = sub_99A77(**i, *i[1], *i[2]);
    else
      result = (unsigned int)sub_99AEB((unsigned int *)**i, *i[1], *i[2]);
  }
  return result;
}
// 180660: using guessed type __int16 word_180660;

//----- (0006EDB0) --------------------------------------------------------
int sub_6EDB0()
{
  int result; // eax

  if ( word_180660 == 1 )
    result = sub_6EDE0(320, 200);
  else
    result = sub_6EDE0(320, 240);
  return result;
}
// 180660: using guessed type __int16 word_180660;

//----- (0006EDE0) --------------------------------------------------------
int __cdecl sub_6EDE0(signed __int16 a1, signed __int16 a2)
{
  signed __int16 v2; // si
  signed __int16 v3; // bx
  int result; // eax
  __int16 v5; // ax
  __int16 v6; // [esp+0h] [ebp-38h]
  __int16 v7; // [esp+8h] [ebp-30h]
  __int16 v8; // [esp+Ch] [ebp-2Ch]
  char v9; // [esp+1Ch] [ebp-1Ch]

  v2 = a1;
  v3 = a2;
  memset(&v6, 0, 28);
  result = memset(&v9, 0, 28);
  if ( dword_E3768 > 0 )
  {
    if ( a1 != -1 || (result = a2, a2 != -1) )
    {
      result = a1;
      if ( a1 != -1 )
      {
        v6 = 4;
        if ( a1 <= 0 )
        {
          if ( !(word_180660 & 1) )
            v2 = 8 * a1;
        }
        else
        {
          if ( a1 > 638 )
            v2 = 638;
          word_E3760 = v2;
          if ( !(word_180660 & 1) )
            v2 *= 8;
        }
        v7 = v2;
        if ( a2 <= 0 )
        {
          if ( word_180660 & 1 )
            v5 = word_E3762;
          else
            v5 = 8 * word_E3762;
          v8 = v5;
        }
        else
        {
          if ( word_180660 & 1 )
          {
            if ( a2 > 398 )
              v3 = 398;
            word_E3762 = v3;
            if ( !(word_180660 & 1) )
              v3 *= 8;
          }
          else
          {
            if ( a2 > 478 )
              v3 = 478;
            word_E3762 = v3;
            if ( !(word_180660 & 1) )
              v3 *= 8;
          }
          v8 = v3;
        }
        result = int386(51, &v6, &v9);
      }
    }
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E3760: using guessed type __int16 word_E3760;
// E3762: using guessed type __int16 word_E3762;
// E3768: using guessed type int dword_E3768;
// 180660: using guessed type __int16 word_180660;

//----- (0006EF10) --------------------------------------------------------
__int16 __cdecl sub_6EF10(__int16 a1, signed __int16 a2, __int16 a3, signed __int16 a4)
{
  signed __int16 v4; // si
  signed __int16 v5; // bx
  __int16 result; // ax
  char v7; // [esp+0h] [ebp-38h]
  __int16 v8; // [esp+1Ch] [ebp-1Ch]
  __int16 v9; // [esp+24h] [ebp-14h]
  __int16 v10; // [esp+28h] [ebp-10h]

  v4 = a2;
  v5 = a4;
  memset(&v8, 0, 28);
  memset(&v7, 0, 28);
  if ( a2 > 638 )
    v4 = 638;
  result = word_180660;
  if ( (unsigned __int16)word_180660 >= 1u )
  {
    if ( (unsigned __int16)word_180660 <= 1u )
    {
      v9 = a1;
      v10 = v4;
      v8 = 7;
      int386(51, &v8, &v7);
      v8 = 8;
      v9 = a3;
      if ( a4 > 398 )
        v5 = 398;
    }
    else
    {
      if ( word_180660 != 8 )
        return result;
      v8 = 7;
      v9 = 8 * a1;
      v10 = 8 * v4;
      int386(51, &v8, &v7);
      v8 = 8;
      if ( a4 > 478 )
        v5 = 478;
      v9 = 8 * a3;
      v5 *= 8;
    }
    v10 = v5;
    result = int386(51, &v8, &v7);
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 180660: using guessed type __int16 word_180660;

//----- (0006F030) --------------------------------------------------------
unsigned int __cdecl sub_6F030(int a1)
{
  unsigned int result; // eax

  result = sub_6F850(a1, 1);
  if ( result )
  {
    sub_4A1E0(*(signed __int16 *)(a1 + 26), 1);
    result = sub_57F10(a1);
  }
  return result;
}

//----- (0006F070) --------------------------------------------------------
unsigned int __cdecl sub_6F070(int a1)
{
  unsigned int result; // eax

  result = sub_6F850(a1, 0);
  if ( result )
  {
    sub_4A1E0(*(signed __int16 *)(a1 + 26), 1);
    result = sub_57F10(a1);
  }
  return result;
}

//----- (0006F0B0) --------------------------------------------------------
unsigned int __cdecl sub_6F0B0(int a1)
{
  unsigned int result; // eax

  if ( *(_DWORD *)(a1 + 16) )
  {
    result = sub_6F8E0(a1, 1);
    if ( !result )
      --*(_DWORD *)(a1 + 16);
  }
  else
  {
    result = sub_6F850(a1, 1);
    if ( result )
    {
      result = sub_4A1E0(*(signed __int16 *)(a1 + 26), 0);
      *(_DWORD *)(a1 + 16) = 10;
    }
  }
  return result;
}

//----- (0006F100) --------------------------------------------------------
unsigned int __cdecl sub_6F100(int a1)
{
  unsigned int result; // eax

  if ( *(_DWORD *)(a1 + 16) )
  {
    result = sub_6F8E0(a1, 0);
    if ( !result )
      --*(_DWORD *)(a1 + 16);
  }
  else
  {
    result = sub_6F850(a1, 0);
    if ( result )
    {
      result = sub_4A1E0(*(signed __int16 *)(a1 + 26), 0);
      *(_DWORD *)(a1 + 16) = 10;
    }
  }
  return result;
}

//----- (0006F150) --------------------------------------------------------
unsigned int __cdecl sub_6F150(int a1)
{
  unsigned int result; // eax

  result = *(_DWORD *)(dword_D41A4 + 38519);
  if ( result > dword_EA3E4[0] )
  {
    while ( *(_BYTE *)(result + 64)
         || !byte_3659C[11 * *(signed __int16 *)(*(_DWORD *)(result + 164) + 56) + dword_D41A0] )
    {
      result = *(_DWORD *)result;
      if ( result <= dword_EA3E4[0] )
        return result;
    }
    sub_4A1E0(*(signed __int16 *)(a1 + 26), 1);
    result = sub_57F10(a1);
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006F1C0) --------------------------------------------------------
int __cdecl sub_6F1C0(int a1)
{
  int result; // eax
  signed __int16 v2; // bx
  signed __int16 v3; // dx

  result = *(unsigned __int8 *)(dword_D41A0 + 224769);
  if ( *(char *)(a1 + 70) < result )
  {
    if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
      v2 = *(_WORD *)(dword_D41A0 + 14);
    else
      v2 = 1;
    v3 = 0;
    result = (int)&byte_3659C[dword_D41A0];
    while ( v3 < v2 )
    {
      if ( *(_BYTE *)(*(char *)(a1 + 70) + result + 3) == 2 )
      {
        *(_BYTE *)(result + 2) = 1;
        sub_4A1E0(*(signed __int16 *)(a1 + 26), 1);
        return sub_57F10(a1);
      }
      ++v3;
      result += 11;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (0006F2B0) --------------------------------------------------------
_BYTE *__cdecl sub_6F2B0(int a1)
{
  _BYTE *result; // eax
  unsigned __int16 v2; // dx

  result = (_BYTE *)sub_6F850(a1, 1);
  if ( result )
  {
    result[69] = 12;
    result[70] = 0;
    sub_57F10(a1);
    result = (_BYTE *)dword_D41A0;
    v2 = *(_WORD *)(dword_D41A0 + 224766);
    if ( v2 )
    {
      result = (_BYTE *)dword_EA3E4[v2];
      result[12] &= 0xFEu;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006F300) --------------------------------------------------------
unsigned int __cdecl sub_6F300(int a1, unsigned int a2)
{
  unsigned int result; // eax
  int v3; // esi

  result = a2;
  if ( a2 == -1 )
  {
    for ( result = 0; (signed int)result <= 16; ++result )
    {
      if ( (result <= 0xB || result >= 0x10 && result <= 0x1C) && *(_DWORD *)(dword_D41A4 + 4 * result + 38403) )
        return result;
    }
    v3 = *(_DWORD *)(a1 + 16);
    if ( !v3 )
    {
      *(_DWORD *)(a1 + 16) = 16;
      return result;
    }
    if ( v3 == 1 )
    {
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 41);
      sub_4A1E0(*(signed __int16 *)(a1 + 26), 1);
      return sub_57F10(a1);
    }
  }
  else
  {
    if ( *(_DWORD *)(dword_D41A4 + 4 * a2 + 38403) )
      return result;
    v3 = *(_DWORD *)(a1 + 16);
    if ( !v3 )
    {
      *(_DWORD *)(a1 + 16) = 16;
      return result;
    }
    if ( v3 == 1 )
    {
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 41);
      sub_4A1E0(*(signed __int16 *)(a1 + 26), 1);
      return sub_57F10(a1);
    }
  }
  result = v3 - 1;
  *(_DWORD *)(a1 + 16) = v3 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (0006F420) --------------------------------------------------------
unsigned int __cdecl sub_6F420(int a1)
{
  return sub_6F300(a1, 0);
}

//----- (0006F440) --------------------------------------------------------
unsigned int __cdecl sub_6F440(int a1)
{
  return sub_6F300(a1, 1u);
}

//----- (0006F460) --------------------------------------------------------
unsigned int __cdecl sub_6F460(int a1)
{
  return sub_6F300(a1, 2u);
}

//----- (0006F480) --------------------------------------------------------
unsigned int __cdecl sub_6F480(int a1)
{
  return sub_6F300(a1, 3u);
}

//----- (0006F4A0) --------------------------------------------------------
unsigned int __cdecl sub_6F4A0(int a1)
{
  return sub_6F300(a1, 4u);
}

//----- (0006F4C0) --------------------------------------------------------
unsigned int __cdecl sub_6F4C0(int a1)
{
  return sub_6F300(a1, 5u);
}

//----- (0006F4E0) --------------------------------------------------------
unsigned int __cdecl sub_6F4E0(int a1)
{
  return sub_6F300(a1, 6u);
}

//----- (0006F500) --------------------------------------------------------
unsigned int __cdecl sub_6F500(int a1)
{
  return sub_6F300(a1, 7u);
}

//----- (0006F520) --------------------------------------------------------
unsigned int __cdecl sub_6F520(int a1)
{
  return sub_6F300(a1, 8u);
}

//----- (0006F540) --------------------------------------------------------
unsigned int __cdecl sub_6F540(int a1)
{
  return sub_6F300(a1, 9u);
}

//----- (0006F560) --------------------------------------------------------
unsigned int __cdecl sub_6F560(int a1)
{
  return sub_6F300(a1, 0xAu);
}

//----- (0006F580) --------------------------------------------------------
unsigned int __cdecl sub_6F580(int a1)
{
  return sub_6F300(a1, 0xBu);
}

//----- (0006F5A0) --------------------------------------------------------
unsigned int __cdecl sub_6F5A0(int a1)
{
  return sub_6F300(a1, 0xCu);
}

//----- (0006F5C0) --------------------------------------------------------
unsigned int __cdecl sub_6F5C0(int a1)
{
  return sub_6F300(a1, 0xDu);
}

//----- (0006F5E0) --------------------------------------------------------
unsigned int __cdecl sub_6F5E0(int a1)
{
  return sub_6F300(a1, 0xEu);
}

//----- (0006F600) --------------------------------------------------------
unsigned int __cdecl sub_6F600(int a1)
{
  return sub_6F300(a1, 0xFu);
}

//----- (0006F620) --------------------------------------------------------
unsigned int __cdecl sub_6F620(int a1)
{
  return sub_6F300(a1, 0x10u);
}

//----- (0006F640) --------------------------------------------------------
unsigned int __cdecl sub_6F640(int a1)
{
  return sub_6F300(a1, 0x11u);
}

//----- (0006F660) --------------------------------------------------------
unsigned int __cdecl sub_6F660(int a1)
{
  return sub_6F300(a1, 0x12u);
}

//----- (0006F680) --------------------------------------------------------
unsigned int __cdecl sub_6F680(int a1)
{
  return sub_6F300(a1, 0x13u);
}

//----- (0006F6A0) --------------------------------------------------------
unsigned int __cdecl sub_6F6A0(int a1)
{
  return sub_6F300(a1, 0x14u);
}

//----- (0006F6C0) --------------------------------------------------------
unsigned int __cdecl sub_6F6C0(int a1)
{
  return sub_6F300(a1, 0x15u);
}

//----- (0006F6E0) --------------------------------------------------------
unsigned int __cdecl sub_6F6E0(int a1)
{
  return sub_6F300(a1, 0x16u);
}

//----- (0006F700) --------------------------------------------------------
unsigned int __cdecl sub_6F700(int a1)
{
  return sub_6F300(a1, 0x17u);
}

//----- (0006F720) --------------------------------------------------------
unsigned int __cdecl sub_6F720(int a1)
{
  return sub_6F300(a1, 0x18u);
}

//----- (0006F740) --------------------------------------------------------
unsigned int __cdecl sub_6F740(int a1)
{
  return sub_6F300(a1, 0x19u);
}

//----- (0006F760) --------------------------------------------------------
unsigned int __cdecl sub_6F760(int a1)
{
  return sub_6F300(a1, 0x1Au);
}

//----- (0006F780) --------------------------------------------------------
unsigned int __cdecl sub_6F780(int a1)
{
  return sub_6F300(a1, 0x1Bu);
}

//----- (0006F7A0) --------------------------------------------------------
unsigned int __cdecl sub_6F7A0(int a1)
{
  return sub_6F300(a1, 0x1Cu);
}

//----- (0006F7C0) --------------------------------------------------------
unsigned int __cdecl sub_6F7C0(int a1)
{
  return sub_6F300(a1, 0xFFFFFFFF);
}

//----- (0006F7E0) --------------------------------------------------------
_BYTE *__cdecl sub_6F7E0(int a1)
{
  _BYTE *result; // eax
  unsigned __int16 v2; // dx

  if ( *(_BYTE *)(dword_D41A4 + 38545) & 8 )
    return (_BYTE *)sub_57F10(a1);
  result = (_BYTE *)sub_6F850(a1, 1);
  if ( result )
  {
    result[69] = 11;
    result[70] = 0;
    sub_57F10(a1);
    result = (_BYTE *)dword_D41A0;
    v2 = *(_WORD *)((char *)&loc_36DFC + dword_D41A0);
    if ( v2 )
    {
      result = (_BYTE *)dword_EA3E4[v2];
      result[12] &= 0xFEu;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006F850) --------------------------------------------------------
unsigned int __cdecl sub_6F850(int a1, int a2)
{
  unsigned int i; // ebx

  if ( *(_BYTE *)(a1 + 62) & 7 )
    return 0;
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); ; i = *(_DWORD *)i )
  {
    if ( i <= dword_EA3E4[0] )
    {
      *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
      return 0;
    }
    if ( !*(_BYTE *)(i + 64) && sub_10750(a1, i) == a2 )
      break;
  }
  if ( *(_BYTE *)(a1 + 64) > 3u )
    sub_6E450((signed int)(i - (dword_D41A0 + 28302)) / 168, -1, 41);
  return i;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006F8E0) --------------------------------------------------------
int __cdecl sub_6F8E0(int a1, int a2)
{
  unsigned __int16 v2; // bx
  int v3; // esi
  int v4; // edi

  v2 = 0;
  v3 = dword_D41A0 + 11230;
  while ( v2 < *(_WORD *)(dword_D41A0 + 14) )
  {
    v4 = dword_EA3E4[*(unsigned __int16 *)(v3 + 10)];
    if ( sub_10750(a1, v4) == a2 )
      return v4;
    v3 += 2124;
    ++v2;
  }
  return 0;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006F940) --------------------------------------------------------
int __cdecl sub_6F940(_BYTE *a1, int a2, int a3, unsigned __int8 a4)
{
  _BYTE *v4; // esi
  int v5; // ebx
  unsigned __int16 v6; // ax
  int v7; // eax
  int v8; // edi
  int v9; // eax
  int result; // eax

  v4 = a1;
  v5 = a2;
  word_E36D4 = 64;
  while ( *v4 && (signed __int16)v5 < 640 )
  {
    v6 = (unsigned __int8)*v4;
    if ( v6 < 0xAu )
    {
      if ( !*v4 )
        goto LABEL_16;
      if ( v6 == 9 )
        goto LABEL_14;
    }
    else
    {
      if ( (unsigned __int8)v6 <= 0xAu )
      {
        LOWORD(v7) = sub_6FC30();
        v5 = a2;
        a3 += v7;
        goto LABEL_16;
      }
      if ( v6 >= 0xDu )
      {
        if ( v6 <= 0xDu )
          goto LABEL_16;
        if ( v6 == 32 )
        {
LABEL_14:
          LOWORD(v9) = sub_6FC10();
          goto LABEL_15;
        }
      }
    }
    if ( !*v4 )
      goto LABEL_14;
    v8 = 6 * ((unsigned __int8)*v4 + 1);
    sub_72C40(v5, a3, v8 + dword_EA3D4, a4);
    v9 = *(unsigned __int8 *)(dword_EA3D4 + v8 + 4);
LABEL_15:
    v5 += v9;
LABEL_16:
    ++v4;
  }
  result = v5;
  word_E36D4 = 0;
  return result;
}
// E36D4: using guessed type __int16 word_E36D4;
// EA3D4: using guessed type int dword_EA3D4;

//----- (0006FC10) --------------------------------------------------------
__int16 sub_6FC10()
{
  return *(unsigned __int8 *)(dword_EA3D4 + 202);
}
// EA3D4: using guessed type int dword_EA3D4;

//----- (0006FC30) --------------------------------------------------------
__int16 sub_6FC30()
{
  return *(unsigned __int8 *)(dword_EA3D4 + 203);
}
// EA3D4: using guessed type int dword_EA3D4;

//----- (0006FC50) --------------------------------------------------------
int __cdecl sub_6FC50(__int16 a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  v2 = dword_E9B20[result];
  if ( !v2 )
    v2 = dword_E9B20[0];
  dword_EA3D4 = v2;
  return result * 4;
}
// E9B20: using guessed type int dword_E9B20[];
// EA3D4: using guessed type int dword_EA3D4;

//----- (0006FC80) --------------------------------------------------------
unsigned int __cdecl sub_6FC80(char *a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5)
{
  unsigned int v5; // kr04_4
  int v6; // esi
  int v7; // eax
  __int16 v9; // [esp+0h] [ebp-4h]

  v9 = a3 - a2;
  v5 = strlen(a1) + 1;
  if ( (_WORD)v5 == 1 )
  {
    v6 = a2 + v9 / 2;
  }
  else
  {
    v6 = a2 + v9 / 2 - (signed __int16)(v5 - 1) * sub_6FC10() / 2;
    sub_2BC10(a1, v6, a4, a5);
  }
  LOWORD(v7) = sub_6FC10();
  return v6 + v7 * strlen(a1);
}

//----- (0006FD30) --------------------------------------------------------
#error "6FD9C: positive sp value has been found (funcsize=32)"

//----- (0006FDA0) --------------------------------------------------------
int sub_6FDA0()
{
  int v0; // eax
  int v1; // eax
  __int16 v2; // dx
  int result; // eax

  v0 = dword_D41A4;
  *(_DWORD *)(dword_D41A4 + 2388) = 10022;
  *(_DWORD *)(v0 + 2392) = 0;
  v1 = dos_getvect(8);
  word_F5334 = v2;
  dword_F5330 = v1;
  __outbyte(0x43u, 0x36u);
  __outbyte(0x40u, *(_DWORD *)(dword_D41A4 + 2388));
  __outbyte(0x40u, *(_WORD *)(dword_D41A4 + 2388) >> 8);
  result = dos_setvect(8, sub_6FD30, (unsigned __int16)__CS__);
  BYTE1(result) = 1;
  byte_DB734 = 1;
  return result;
}
// 6FD30: using guessed type int sub_6FD30();
// 99BA7: using guessed type _DWORD __cdecl dos_getvect(_DWORD);
// 99BDB: using guessed type _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// DB734: using guessed type char byte_DB734;
// F5330: using guessed type int dword_F5330;
// F5334: using guessed type __int16 word_F5334;

//----- (0006FE20) --------------------------------------------------------
void sub_6FE20()
{
  int v0; // et1
  int v1; // eax

  if ( byte_DB734 == 1 )
  {
    v0 = *(_DWORD *)(dword_D41A4 + 2380);
    __outbyte(0x43u, 0x36u);
    __outbyte(0x40u, 0);
    __outbyte(0x40u, 0);
    v1 = dos_setvect(8, dword_F5330, (unsigned __int16)word_F5334);
    _wcpp_1_unwind_leave__130(v1);
  }
  byte_DB734 = 0;
}
// 6FE80: using guessed type int __fastcall _wcpp_1_unwind_leave__130(_DWORD);
// 99BDB: using guessed type _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// DB734: using guessed type char byte_DB734;
// F5330: using guessed type int dword_F5330;
// F5334: using guessed type __int16 word_F5334;

//----- (0006FE90) --------------------------------------------------------
int __cdecl sub_6FE90(unsigned __int8 *a1, unsigned int a2)
{
  unsigned __int8 *v2; // eax
  int v3; // edx
  int v5; // ebx

  v2 = a1;
  v3 = 0;
  if ( (unsigned int)a1 >= a2 )
    return 0;
  do
  {
    v5 = *v2++;
    v3 += v5;
  }
  while ( (unsigned int)v2 < a2 );
  return v3;
}

//----- (0006FEC0) --------------------------------------------------------
int sub_6FEC0()
{
  int v0; // edx
  int result; // eax
  char v2; // dl
  int v3; // eax
  int v4; // ebx
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // ebx
  int v9; // eax
  int v10; // ebx
  int v11; // eax
  int v12; // ebx
  int v13; // eax
  int v14; // ebx
  int v15; // eax
  int v16; // ebx
  int v17; // eax
  int v18; // ebx
  int v19; // eax
  int v20; // ebx
  int v21; // eax
  int v22; // ebx
  int v23; // eax
  int v24; // ebx
  int v25; // eax
  int v26; // ebx
  int v27; // eax
  int v28; // ebx
  int v29; // eax
  int v30; // edx
  unsigned int v31; // eax
  __int16 v32; // bx
  __int16 v33; // bx
  __int16 v34; // bx
  __int16 v35; // bx
  __int16 v36; // bx
  __int16 v37; // bx
  __int16 v38; // bx
  int v39; // eax
  __int16 v40; // bx
  __int16 v41; // bx
  __int16 v42; // bx
  __int16 v43; // bx
  __int16 v44; // bx
  int *v45; // edi
  int v46; // ebx
  unsigned __int8 v47; // al
  int v48; // eax
  int v49; // eax
  __int16 v50; // bx
  __int16 v51; // bx
  __int16 v52; // bx
  __int16 v53; // bx
  __int16 v54; // bx
  __int16 v55; // bx
  __int16 v56; // bx
  __int16 v57; // bx
  __int16 v58; // bx
  __int16 v59; // bx
  __int16 v60; // bx
  __int16 v61; // bx
  __int16 v62; // bx
  __int16 v63; // bx
  char v64; // [esp+0h] [ebp+7Eh]
  int i; // [esp+100h] [ebp+17Eh]

  v0 = 2124 * *(signed __int16 *)(dword_D41A0 + 12);
  result = v0 + dword_D41A0;
  v2 = *(_BYTE *)(v0 + dword_D41A0 + 11235);
  if ( v2 & 8 )
  {
    sub_6FC50(1);
    sub_2BC10(aProductName, 320, 0, byte_E9800);
    LOWORD(v3) = sub_6FC30();
    v4 = v3;
    sub_2BC10(aMagicCarpet2Ne, 320, v3, byte_E890F);
    LOWORD(v5) = sub_6FC30();
    v6 = v5 + v4;
    sub_2BC10(aVersionNumber, 320, v6, byte_E9800);
    LOWORD(v7) = sub_6FC30();
    v8 = v7 + v6;
    sub_2BC10(aBeta, 320, v8, byte_E890F);
    LOWORD(v9) = sub_6FC30();
    v10 = v9 + v8;
    sub_2BC10(aVersionDate, 320, v10, byte_E9800);
    LOWORD(v11) = sub_6FC30();
    v12 = v11 + v10;
    sprintf(&v64, aSS_4, a034213, aSep061995);
    sub_2BC10(&v64, 320, v12, byte_E890F);
    LOWORD(v13) = sub_6FC30();
    v14 = v13 + v12;
    sub_2BC10(aProgrammer, 320, v14, byte_E9800);
    LOWORD(v15) = sub_6FC30();
    v16 = v15 + v14;
    sub_2BC10(aBullfrogAlanWr, 320, v16, byte_E890F);
    LOWORD(v17) = sub_6FC30();
    v18 = v17 + v16;
    sub_2BC10(aSuppliedTo, 320, v18, byte_E9800);
    LOWORD(v19) = sub_6FC30();
    v20 = v19 + v18;
    sub_2BC10(aPublic, 320, v20, byte_E890F);
    LOWORD(v21) = sub_6FC30();
    v22 = v21 + v20;
    sub_2BC10(aLevelNumber, 320, v22, byte_E9800);
    LOWORD(v23) = sub_6FC30();
    v24 = v23 + v22;
    sprintf(&v64, &aApD[3], *(unsigned __int16 *)(dword_D41A4 + 43));
    sub_2BC10(&v64, 320, v24, byte_E890F);
    LOWORD(v25) = sub_6FC30();
    v26 = v25 + v24;
    if ( *(_BYTE *)(dword_D41A4 + 22) & 0x10 )
    {
      sub_2BC10(aTransferRate, 320, v26, byte_E9800);
      LOWORD(v27) = sub_6FC30();
      v28 = v27 + v26;
      sprintf(&v64, &aApD[3], *(_DWORD *)(dword_D41A4 + 200));
      sub_2BC10(&v64, 320, v28, byte_E890F);
      LOWORD(v29) = sub_6FC30();
      v26 = v29 + v28;
    }
    v30 = 2124 * *(signed __int16 *)(dword_D41A0 + 12);
    dword_E9C14 = *(_DWORD *)(v30 + dword_D41A0 + 11248);
    v31 = j___clock(dword_E9C14, v30, v26) / 0x64u;
    dword_E9C1C = v31;
    if ( v31 != dword_E9C20 )
    {
      dword_E9C20 = v31;
      dword_E9C24 = dword_E9C14 - dword_E9C18;
      dword_E9C18 = dword_E9C14;
    }
    sub_2BC10(&aHfps[1], 320, v26, byte_E9800);
    v32 = sub_6FC30() + v26;
    sprintf(&v64, &aApD[3], dword_E9C24);
    sub_2BC10(&v64, 320, v32, byte_E890F);
    v33 = sub_6FC30() + v32;
    sub_2BC10(aSoundNumber, 320, v33, byte_E9800);
    v34 = sub_6FC30() + v33;
    sprintf(&v64, &aApD[3], (unsigned __int16)word_E37B6);
    sub_2BC10(&v64, 320, v34, byte_E890F);
    v35 = sub_6FC30() + v34;
    sub_2BC10(aGameTurn, 320, v35, byte_E9800);
    v36 = sub_6FC30() + v35;
    sprintf(&v64, aDD, *(_DWORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248), dword_17DB54);
    sub_2BC10(&v64, 320, v36, byte_E890F);
    v37 = sub_6FC30() + v36;
    sub_2BC10(aThing, 320, v37, byte_E9800);
    v38 = sub_6FC30() + v37;
    v39 = sub_4A810();
    sprintf(&v64, aThingDActiveD, 168, 1000 - v39);
    sub_2BC10(&v64, 320, v38, byte_E890F);
    v40 = sub_6FC30() + v38;
    sprintf(&v64, aCarpetD, 224791);
    sub_2BC10(&v64, 320, v40, byte_E890F);
    v41 = sub_6FC30() + v40;
    sprintf(&v64, aTapeD, 38547);
    sub_2BC10(&v64, 320, v41, byte_E890F);
    v42 = sub_6FC30() + v41;
    sprintf(&v64, aHeapD, *(_DWORD *)(dword_D41A4 + 230));
    sub_2BC10(&v64, 320, v42, byte_E890F);
    v43 = sub_6FC30() + v42;
    sub_85350();
    sub_2BC10(aMemoryUsedFree, 320, v43, byte_E9800);
    v44 = sub_6FC30() + v43;
    sprintf(&v64, aDD_0, dword_17FEA8, dword_17FEA4);
    sub_2BC10(&v64, 320, v44, byte_E890F);
    v45 = &dword_17ECA0;
    LOWORD(result) = sub_6FC30();
    v46 = 0;
    for ( i = 0; v45; v45 = (int *)v45[2] )
    {
      sprintf(&v64, aS77dU01d, v45[1], *((unsigned __int8 *)v45 + 16));
      if ( dword_17E0A4[3 * *((unsigned __int8 *)v45 + 17)] )
        v47 = byte_E8900[0];
      else
        v47 = byte_E9800;
      sub_2BC10(&v64, i, v46, v47);
      LOWORD(v48) = sub_6FC30();
      v46 += v48;
      result = 400 - sub_6FC30();
      if ( (signed __int16)v46 > result )
      {
        LOWORD(v49) = sub_6FC10();
        result = 12 * v49;
        i += result;
        v46 = 0;
      }
    }
  }
  else if ( v2 & 0x40 )
  {
    v50 = 6 * sub_6FC30();
    sub_2BC10(aThing_0, 10, v50, byte_E9800);
    v51 = sub_6FC30() + v50;
    sprintf(
      &v64,
      aLdLd,
      *(_DWORD *)(dword_D41A4 + 38396),
      (*(_DWORD *)(dword_D41A4 + 38396) - (dword_D41A0 + 28302)) / 168);
    sub_2BC10(&v64, 10, v51, byte_E89FF);
    v52 = sub_6FC30() + v51;
    sub_2BC10(aClassModelStat, 10, v52, byte_E9800);
    v53 = sub_6FC30() + v52;
    sprintf(
      &v64,
      aLdLdLd,
      *(char *)(*(_DWORD *)(dword_D41A4 + 38396) + 63),
      *(char *)(*(_DWORD *)(dword_D41A4 + 38396) + 64),
      *(unsigned __int8 *)(*(_DWORD *)(dword_D41A4 + 38396) + 69));
    sub_2BC10(&v64, 10, v53, byte_E89FF);
    v54 = sub_6FC30() + v53;
    sub_2BC10(aLifeMaxLife, 10, v54, byte_E9800);
    v55 = sub_6FC30() + v54;
    sprintf(
      &v64,
      aLdLd,
      *(_DWORD *)(*(_DWORD *)(dword_D41A4 + 38396) + 8),
      *(_DWORD *)(*(_DWORD *)(dword_D41A4 + 38396) + 4));
    sub_2BC10(&v64, 10, v55, byte_E89FF);
    v56 = sub_6FC30() + v55;
    sub_2BC10(aSpeedActualMin, 10, v56, byte_E9800);
    v57 = sub_6FC30() + v56;
    sprintf(
      &v64,
      aLdLdLd,
      *(signed __int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 130),
      *(signed __int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 132),
      *(signed __int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 134));
    sub_2BC10(&v64, 10, v57, byte_E89FF);
    v58 = sub_6FC30() + v57;
    sub_2BC10(aActualXYZ, 10, v58, byte_E9800);
    v59 = sub_6FC30() + v58;
    sprintf(
      &v64,
      aLdLdLd,
      *(signed __int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 76),
      *(signed __int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 78),
      *(signed __int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 80));
    sub_2BC10(&v64, 10, v59, byte_E89FF);
    v60 = sub_6FC30() + v59;
    sub_2BC10(aIdWhoOwnsMe, 10, v60, byte_E9800);
    v61 = sub_6FC30() + v60;
    sprintf(
      &v64,
      aLdLd,
      *(signed __int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 26),
      *(unsigned __int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 40));
    sub_2BC10(&v64, 10, v61, byte_E89FF);
    v62 = sub_6FC30() + v61;
    sub_2BC10(aManaActualMaxi, 10, v62, byte_E9800);
    v63 = sub_6FC30() + v62;
    sprintf(
      &v64,
      aLdLd,
      *(_DWORD *)(*(_DWORD *)(dword_D41A4 + 38396) + 144),
      *(_DWORD *)(*(_DWORD *)(dword_D41A4 + 38396) + 140));
    sub_2BC10(&v64, 10, v63, byte_E89FF);
    LOWORD(result) = sub_6FC30();
  }
  if ( *(_DWORD *)(dword_D41A4 + 53) == 16273849 )
    *(_BYTE *)(dword_D41A4 + 52) |= 2u;
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E37B6: using guessed type __int16 word_E37B6;
// E890F: using guessed type char byte_E890F;
// E89FF: using guessed type char byte_E89FF;
// E9800: using guessed type char byte_E9800;
// E9C14: using guessed type int dword_E9C14;
// E9C18: using guessed type int dword_E9C18;
// E9C1C: using guessed type int dword_E9C1C;
// E9C20: using guessed type int dword_E9C20;
// E9C24: using guessed type int dword_E9C24;
// 17DB54: using guessed type int dword_17DB54;
// 17E0A4: using guessed type int dword_17E0A4[];
// 17ECA0: using guessed type int dword_17ECA0;
// 17FEA4: using guessed type int dword_17FEA4;
// 17FEA8: using guessed type int dword_17FEA8;

//----- (00070890) --------------------------------------------------------
int sub_70890()
{
  printf(aCopyrightC1995);
  printf(aAllRightsReser);
  return printf(aS_0);
}

//----- (00070910) --------------------------------------------------------
int sub_70910()
{
  int result; // eax

  result = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 23) & 1 )
    result = printf(&off_D189C);
  return result;
}
// D189C: using guessed type void *off_D189C;
// D41A4: using guessed type int dword_D41A4;

//----- (00070940) --------------------------------------------------------
unsigned int sub_70940()
{
  _WORD *v0; // ebx
  int v1; // edi
  unsigned int result; // eax
  int v3; // esi
  int i; // eax
  char v5; // dl
  int v6; // eax
  int v7; // [esp+0h] [ebp-10h]
  int v8; // [esp+4h] [ebp-Ch]
  int v9; // [esp+8h] [ebp-8h]
  char v10; // [esp+Ch] [ebp-4h]

  v0 = (_WORD *)dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v1 = ((signed __int16)v0[38] + 128) >> 8;
  v9 = ((signed __int16)v0[39] + 128) >> 8;
  result = sub_10080(0, 128);
  v3 = result;
  if ( result )
  {
    v10 = 0;
    while ( sub_10130(v3, &v8, &v7) == 1 && !v10 )
    {
      for ( i = word_15B4E0[((unsigned __int8)(v9 + v7) << 8) + (unsigned __int8)(v1 + v8)];
            ;
            i = *(unsigned __int16 *)(v6 + 22) )
      {
        v6 = dword_EA3E4[i];
        if ( v6 == dword_EA3E4[0] || v10 )
          break;
        v5 = 1;
        if ( (_WORD *)v6 == v0 || *(_BYTE *)(v6 + 63) == 15 && *(_WORD *)(v6 + 26) == v0[13] || *(_BYTE *)(v6 + 12) & 1 )
          v5 = 0;
        if ( v5 )
        {
          v10 = 1;
          *(_DWORD *)(dword_D41A4 + 38396) = v6;
        }
      }
    }
    result = sub_10100(v3);
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00070A60) --------------------------------------------------------
char sub_70A60()
{
  char v1; // [esp+0h] [ebp-40h]

  sprintf(&v1, aCSSSDat_0, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_4, aCdata_1, aTmaps00_0);
  dword_DB740 = sub_98817((int)&v1, 512);
  if ( dword_DB740 == -1 )
  {
    sprintf(&v1, aDataSDat_0, aTmaps00_0);
    dword_DB740 = sub_98817((int)&v1, 512);
  }
  sprintf(&v1, aCSSSDat_0, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_4, aCdata_1, aTmaps10_0);
  dword_DB744 = sub_98817((int)&v1, 512);
  if ( dword_DB744 == -1 )
  {
    sprintf(&v1, aDataSDat_0, aTmaps10_0);
    dword_DB744 = sub_98817((int)&v1, 512);
  }
  sprintf(&v1, aCSSSDat_0, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_4, aCdata_1, aTmaps20_0);
  dword_DB748 = sub_98817((int)&v1, 512);
  if ( dword_DB748 == -1 )
  {
    sprintf(&v1, aDataSDat_0, aTmaps20_0);
    dword_DB748 = sub_98817((int)&v1, 512);
  }
  dword_DB73C = dword_DB740;
  return 1;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;
// DB73C: using guessed type int dword_DB73C;
// DB740: using guessed type int dword_DB740;
// DB744: using guessed type int dword_DB744;
// DB748: using guessed type int dword_DB748;

//----- (00070BF0) --------------------------------------------------------
int sub_70BF0()
{
  int result; // eax

  if ( dword_DB740 != -1 )
  {
    result = sub_98882(dword_DB740);
    dword_DB740 = -1;
  }
  if ( dword_DB744 != -1 )
  {
    sub_98882(dword_DB744);
    result = -1;
    dword_DB744 = -1;
  }
  if ( dword_DB748 != -1 )
  {
    result = sub_98882(dword_DB748);
    dword_DB748 = -1;
  }
  dword_DB73C = -1;
  return result;
}
// DB73C: using guessed type int dword_DB73C;
// DB740: using guessed type int dword_DB740;
// DB744: using guessed type int dword_DB744;
// DB748: using guessed type int dword_DB748;

//----- (00070C60) --------------------------------------------------------
int __cdecl sub_70C60(unsigned __int16 a1, char *a2)
{
  int v2; // edi
  int v3; // ebx
  int result; // eax

  if ( dword_DB73C == -1 )
    return dword_DB73C;
  v2 = 10 * a1;
  sub_9891E(dword_DB73C, *(_DWORD *)(v2 + dword_F6ED0 + 4), 0);
  v3 = *(_DWORD *)(dword_F6ED0 + 10 * (a1 + 1) + 4) - *(_DWORD *)(dword_F6ED0 + v2 + 4);
  if ( sub_988A7(dword_DB73C, (int)a2, v3) != v3 )
    return -1;
  result = sub_9894C((int)a2, a2);
  if ( result >= 0 )
  {
    if ( !result )
      result = v3;
  }
  else
  {
    printf(aErrorDecompres_1);
    result = -2;
  }
  return result;
}
// DB73C: using guessed type int dword_DB73C;
// F6ED0: using guessed type int dword_F6ED0;

//----- (00070D20) --------------------------------------------------------
char __cdecl sub_70D20(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  __int16 v2; // di
  unsigned __int16 i; // bx
  _BYTE **v4; // ecx
  _DWORD *v5; // eax

  v1 = *(_WORD *)(10 * a1 + dword_F6ED0 + 8);
  if ( byte_F5340[v1] )
    return 0;
  v2 = *(_WORD *)(10 * a1 + dword_F6ED0 + 8);
  if ( !dword_F66F0[v1] )
    return 0;
  for ( i = *(_WORD *)(10 * a1 + dword_F6ED0 + 8); i < 0x1F8u && v2 == *(_WORD *)(dword_F6ED0 + 10 * i + 8); ++i )
  {
    v4 = (_BYTE **)dword_F66F0[i];
    if ( v4 )
    {
      if ( **v4 & 1 )
      {
        v5 = (_DWORD *)sub_724F0(dword_E9C08, i);
        sub_72410(v5);
      }
      sub_71F20(dword_E9C28, dword_F5F10[i]);
      dword_F66F0[i] = 0;
      dword_F5F10[i] = 0;
      dword_F5730[i] = 0;
    }
  }
  return 1;
}
// E9C08: using guessed type int dword_E9C08;
// E9C28: using guessed type int dword_E9C28;
// F6ED0: using guessed type int dword_F6ED0;

//----- (00070E10) --------------------------------------------------------
char __cdecl sub_70E10(unsigned __int16 a1)
{
  int v1; // edx
  __int16 v2; // di
  unsigned __int16 i; // bx
  _BYTE **v4; // ecx
  _DWORD *v5; // eax

  v1 = 10 * a1;
  v2 = *(_WORD *)(v1 + dword_F6ED0 + 8);
  if ( !dword_F66F0[*(unsigned __int16 *)(v1 + dword_F6ED0 + 8)] )
    return 0;
  for ( i = *(_WORD *)(v1 + dword_F6ED0 + 8); i < 0x1F8u && v2 == *(_WORD *)(dword_F6ED0 + 10 * i + 8); ++i )
  {
    v4 = (_BYTE **)dword_F66F0[i];
    if ( v4 )
    {
      if ( **v4 & 1 )
      {
        v5 = (_DWORD *)sub_724F0(dword_E9C08, i);
        sub_72410(v5);
      }
      sub_71F20(dword_E9C28, dword_F5F10[i]);
      dword_F66F0[i] = 0;
      dword_F5F10[i] = 0;
      dword_F5730[i] = 0;
    }
  }
  return 1;
}
// E9C08: using guessed type int dword_E9C08;
// E9C28: using guessed type int dword_E9C28;
// F6ED0: using guessed type int dword_F6ED0;

//----- (00070EF0) --------------------------------------------------------
int __cdecl sub_70EF0(unsigned __int16 a1)
{
  unsigned __int16 v1; // dx
  int i; // ebx
  int v3; // ecx

  v1 = *(_WORD *)(10 * a1 + dword_F6ED0 + 8);
  for ( i = 0; v1 < 0x1F8u; i += *(_DWORD *)(v3 + dword_F6ED0) + 10 )
  {
    v3 = 10 * v1;
    if ( *(_WORD *)(10 * a1 + dword_F6ED0 + 8) != *(_WORD *)(v3 + dword_F6ED0 + 8) )
      break;
    ++v1;
  }
  return i;
}
// F6ED0: using guessed type int dword_F6ED0;

//----- (00070F50) --------------------------------------------------------
int __cdecl sub_70F50(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int16 v2; // bx
  unsigned __int16 i; // si
  int v4; // edi
  int v5; // [esp+0h] [ebp-Ch]
  int v6; // [esp+8h] [ebp-4h]

  v5 = *(_DWORD *)(dword_D41A4 + 26);
  result = dword_F6ED0;
  v2 = *(_WORD *)(10 * a1 + dword_F6ED0 + 8);
  for ( i = *(_WORD *)(10 * a1 + dword_F6ED0 + 8); i < 0x1F8u; ++i )
  {
    result = 10 * i + dword_F6ED0;
    if ( v2 != *(_WORD *)(result + 8) )
      break;
    v6 = i;
    if ( !dword_F66F0[i] )
    {
      result = sub_71E70(dword_E9C28, (unsigned __int16)(4 * ((unsigned int)(*(_DWORD *)result + 13) >> 2)), i);
      v4 = result;
      if ( result )
      {
        result = sub_70C60(i, *(char **)result);
        if ( result != -1 )
        {
          dword_F5F10[v6] = v4;
          dword_F66F0[v6] = v4;
          dword_F5730[v6] = v5;
          result = dword_F66F0[v6];
          if ( **(_BYTE **)result & 1 )
            result = sub_721C0((unsigned __int16 *)dword_E9C08, (int *)result, i);
          if ( v2 < 0x1E0u )
          {
            if ( v2 != 311 )
              continue;
LABEL_14:
            result = *(_DWORD *)dword_F66F0[i];
            *(_BYTE *)result |= 0x20u;
            continue;
          }
          if ( v2 <= 0x1E0u || v2 >= 0x1E8u && (v2 <= 0x1E8u || v2 == 496) )
            goto LABEL_14;
        }
      }
    }
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// E9C08: using guessed type int dword_E9C08;
// E9C28: using guessed type int dword_E9C28;
// F6ED0: using guessed type int dword_F6ED0;

//----- (00071090) --------------------------------------------------------
unsigned int __cdecl sub_71090(unsigned int a1)
{
  int v1; // eax
  unsigned __int16 v2; // dx
  int v3; // eax
  int v4; // ebx
  int v5; // ebx
  int v6; // ecx
  unsigned int v7; // eax
  int v8; // edx
  int v9; // esi
  int v10; // esi
  int v11; // edi
  int v12; // edi
  int v13; // esi
  int v14; // esi
  int v15; // edi
  unsigned __int16 v16; // di
  unsigned int v17; // ebx
  char v18; // al
  int v19; // esi
  int v21; // [esp+0h] [ebp-2Ch]
  int v22; // [esp+4h] [ebp-28h]
  int v23; // [esp+8h] [ebp-24h]
  int v24; // [esp+Ch] [ebp-20h]
  int v25; // [esp+10h] [ebp-1Ch]
  unsigned int v26; // [esp+14h] [ebp-18h]
  unsigned int v27; // [esp+18h] [ebp-14h]
  unsigned int v28; // [esp+1Ch] [ebp-10h]
  unsigned int v29; // [esp+20h] [ebp-Ch]
  unsigned int v30; // [esp+24h] [ebp-8h]
  char v31; // [esp+28h] [ebp-4h]

  v31 = 1;
  v1 = 0;
  do
  {
    v2 = v1++;
    *(&v26 + v2) = -1;
    *(&v21 + v2) = -1;
  }
  while ( (unsigned __int16)v1 < 5u );
  v3 = 0;
  do
  {
    v4 = *(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)v3 + 8);
    if ( dword_F66F0[v4] && !byte_F5340[v4] )
      v31 = 0;
    while ( (unsigned __int16)v3 < 0x1F8u
         && *(unsigned __int16 *)(10 * ((unsigned __int16)v3 + 1) + dword_F6ED0 + 8) == v4 )
      ++v3;
    ++v3;
  }
  while ( (unsigned __int16)v3 < 0x1F8u );
  v5 = 0;
  do
  {
    v6 = *(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)v5 + 8);
    if ( (!byte_F5340[v6] || v31) && dword_F66F0[v6] )
    {
      v7 = dword_F5730[v6];
      v8 = *(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)v5 + 8);
      if ( v7 < v26 )
      {
        v9 = v7 ^ v26;
        v7 ^= v26 ^ v7;
        v26 = v7 ^ v9;
        v8 = v6 ^ v6 ^ v21;
        v21 ^= v8 ^ v6;
      }
      if ( v7 < v27 )
      {
        v10 = v7 ^ v27;
        v11 = v8 ^ v22;
        v7 ^= v27 ^ v7;
        v8 ^= v22 ^ v8;
        v27 = v7 ^ v10;
        v22 = v8 ^ v11;
      }
      if ( v7 < v28 )
      {
        v12 = v7 ^ v28;
        v13 = v8 ^ v23;
        v7 ^= v28 ^ v7;
        v8 ^= v23 ^ v8;
        v28 = v7 ^ v12;
        v23 = v8 ^ v13;
      }
      if ( v7 < v29 )
      {
        v14 = v7 ^ v29;
        v15 = v8 ^ v24;
        v7 ^= v29 ^ v7;
        v8 ^= v24 ^ v8;
        v29 = v7 ^ v14;
        v24 = v8 ^ v15;
      }
      if ( v7 < v30 )
      {
        v30 ^= v7 ^ v7 ^ v7 ^ v30;
        v25 ^= v8 ^ v8 ^ v8 ^ v25;
      }
    }
    while ( (unsigned __int16)v5 < 0x1F8u
         && *(unsigned __int16 *)(10 * ((unsigned __int16)v5 + 1) + dword_F6ED0 + 8) == v6 )
      ++v5;
    ++v5;
  }
  while ( (unsigned __int16)v5 < 0x1F8u );
  v16 = 0;
  v17 = 0;
  while ( v16 < 5u )
  {
    if ( v17 >= a1 )
      break;
    v19 = 4 * v16;
    if ( *(int *)((char *)&v21 + v19) <= -1 )
      break;
    if ( v31 )
      v18 = sub_70E10(*(_WORD *)((char *)&v21 + v19));
    else
      v18 = sub_70D20(*(_WORD *)((char *)&v21 + v19));
    if ( v18 )
      v17 += sub_70EF0(*(_WORD *)((char *)&v21 + v19));
    ++v16;
  }
  return v17;
}
// F6ED0: using guessed type int dword_F6ED0;

//----- (000712F0) --------------------------------------------------------
__int16 sub_712F0()
{
  dword_E9C28 = sub_71B40(*(_DWORD *)(dword_D41A4 + 230), 0x1F8u, *(_DWORD *)(dword_D41A4 + 226));
  if ( dword_E9C28 )
    dword_E9C08 = sub_72120(0x1F8u);
  sub_70A60();
  sub_71A70(*(_BYTE *)(dword_D41A0 + 196308));
  memset(dword_F66F0, 0, 2016);
  memset(dword_F5F10, 0, 2016);
  memset(dword_F5730, 0, 2016);
  sub_71890();
  return sub_718F0();
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E9C08: using guessed type int dword_E9C08;
// E9C28: using guessed type int dword_E9C28;

//----- (000713A0) --------------------------------------------------------
int sub_713A0()
{
  sub_720C0(&dword_E9C28);
  sub_72550(&dword_E9C08);
  sub_716A0();
  memset(dword_F66F0, 0, 2016);
  memset(dword_F5F10, 0, 2016);
  memset(dword_F5730, 0, 2016);
  byte_DB738 = 0;
  return sub_70BF0();
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// DB738: using guessed type char byte_DB738;
// E9C08: using guessed type int dword_E9C08;
// E9C28: using guessed type int dword_E9C28;

//----- (00071410) --------------------------------------------------------
int sub_71410()
{
  unsigned __int16 *v0; // esi
  int v1; // ebx
  unsigned __int16 v2; // di

  sub_70A60();
  v0 = (unsigned __int16 *)word_D951C;
  v1 = dword_180628;
  while ( v0[3] || v0[4] )
  {
    v2 = *v0;
    memset(v1, 0, *(_DWORD *)(dword_F6ED0 + 10 * (*v0 + 1) + 4) - *(_DWORD *)(10 * *v0 + dword_F6ED0 + 4));
    if ( sub_70C60(v2, (char *)v1) == -1 )
    {
      *(_WORD *)(v1 + 2) = 255;
      *(_WORD *)(v1 + 4) = 255;
      *(_BYTE *)(v1 + 1) = 1;
    }
    if ( !*(_WORD *)(v1 + 4) || !*(_WORD *)(v1 + 2) )
    {
      *(_WORD *)(v1 + 2) = 255;
      *(_WORD *)(v1 + 4) = 255;
      *(_BYTE *)(v1 + 1) = 1;
    }
    if ( v0[3] )
    {
      if ( !v0[4] )
        v0[4] = *(unsigned __int16 *)(v1 + 4) * v0[3] / *(unsigned __int16 *)(v1 + 2);
    }
    else
    {
      v0[3] = *(unsigned __int16 *)(v1 + 2) * v0[4] / *(unsigned __int16 *)(v1 + 4);
    }
    v0 += 7;
    *((_BYTE *)v0 - 2) = *(_BYTE *)(v1 + 1);
  }
  return sub_70BF0();
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D951C: using guessed type __int16 word_D951C[];
// F6ED0: using guessed type int dword_F6ED0;
// 180628: using guessed type int dword_180628;

//----- (00071520) --------------------------------------------------------
bool __cdecl sub_71520(unsigned __int16 a1)
{
  int v1; // esi
  int v2; // ebx
  signed int i; // ebx
  unsigned __int16 v4; // ax

  v1 = 0;
  v2 = sub_70EF0(a1);
  for ( i = v2 - sub_71E60(dword_E9C28) + 20; i > 0; i -= sub_71090(i) )
  {
    v4 = v1++;
    if ( v4 >= 4u )
      break;
  }
  if ( i <= 0 )
  {
    sub_70F50(a1);
    *(_BYTE *)(dword_D41A4 + 177) = 5;
  }
  return dword_F66F0[a1] != 0;
}
// D41A4: using guessed type int dword_D41A4;
// E9C28: using guessed type int dword_E9C28;

//----- (000715B0) --------------------------------------------------------
int sub_715B0()
{
  unsigned __int16 v0; // bx
  int result; // eax
  int *v2; // ecx
  char v3; // cl
  char v4; // cl
  int v5; // eax
  __int16 v6; // si
  unsigned __int16 i; // bx
  int *v8; // edi
  char v9; // cl
  int v10; // eax

  v0 = 0;
  do
  {
    result = 4 * v0;
    v2 = *(int **)((char *)dword_F66F0 + result);
    if ( v2 )
    {
      result = *v2;
      v3 = *(_BYTE *)*v2;
      if ( v3 & 8 )
      {
        if ( v3 & 0x20 )
        {
          result = 5 * v0;
          v6 = *(_WORD *)(dword_F6ED0 + 10 * v0 + 8);
          for ( i = *(_WORD *)(dword_F6ED0 + 10 * v0 + 8); i < 0x1F8u; ++i )
          {
            result = 5 * i;
            if ( v6 != *(_WORD *)(dword_F6ED0 + 10 * i + 8) )
              break;
            result = 4 * i;
            v8 = (int *)dword_F66F0[i];
            if ( v8 )
            {
              result = *v8;
              v9 = *(_BYTE *)*v8 & 0xF7;
              *(_BYTE *)*v8 = v9;
              if ( v9 & 1 )
              {
                v10 = sub_724F0(dword_E9C08, i);
                result = sub_72350(v10);
              }
            }
          }
          v0 = i - 1;
        }
        else
        {
          v4 = v3 & 0xF7;
          *(_BYTE *)result = v4;
          if ( v4 & 1 )
          {
            v5 = sub_724F0(dword_E9C08, v0);
            result = sub_72350(v5);
          }
        }
      }
    }
    ++v0;
  }
  while ( v0 < 0x1F8u );
  return result;
}
// E9C08: using guessed type int dword_E9C08;
// F6ED0: using guessed type int dword_F6ED0;

//----- (000716A0) --------------------------------------------------------
int sub_716A0()
{
  return memset(byte_F5538, 0, 504);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);

//----- (000716C0) --------------------------------------------------------
signed __int16 *__cdecl sub_716C0(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3)
{
  signed __int16 *result; // eax
  unsigned __int16 *v4; // ebx
  unsigned __int16 v5; // cx

  result = (signed __int16 *)&unk_D7BD6;
  v4 = 0;
  while ( *result >= 0 )
  {
    if ( *result == a1 && result[1] == a2 )
      v4 = (unsigned __int16 *)(result + 2);
    result += 17;
  }
  if ( v4 )
  {
    while ( 1 )
    {
      v5 = *v4;
      if ( (*v4 & 0x8000u) != 0 )
        break;
      ++v4;
      result = (signed __int16 *)sub_71730(v5);
    }
  }
  else if ( (a3 & 0x8000u) == 0 )
  {
    result = (signed __int16 *)sub_71730(a3);
  }
  return result;
}

//----- (00071730) --------------------------------------------------------
int __cdecl sub_71730(unsigned __int16 a1)
{
  __int16 *v1; // eax
  char v2; // bl
  int result; // eax

  v1 = &word_D951C[7 * a1];
  v2 = *((_BYTE *)v1 + 11);
  result = *(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)*v1 + 8);
  byte_F5538[result] = v2;
  return result;
}
// D951C: using guessed type __int16 word_D951C[];
// F6ED0: using guessed type int dword_F6ED0;

//----- (00071780) --------------------------------------------------------
char sub_71780()
{
  unsigned __int16 v0; // bx
  unsigned int v1; // eax
  char i; // bl
  unsigned __int16 j; // si
  unsigned int v4; // ST0C_4
  char v6; // [esp+4h] [ebp-4h]

  v6 = 0;
  if ( !dword_E9C28 )
    sub_712F0();
  sub_71A70(*(_BYTE *)(dword_D41A0 + 196308));
  v0 = 0;
  memset(dword_F5730, 0, 2016);
  do
  {
    LOBYTE(v1) = v0;
    if ( !byte_F5538[v0] )
      LOBYTE(v1) = sub_70D20(v0);
    ++v0;
  }
  while ( v0 < 0x1F8u );
  for ( i = -1; i && !v6; --i )
  {
    for ( j = 0; j < 0x1F8u && !v6; ++j )
    {
      if ( i == byte_F5538[j] && !dword_F66F0[j] )
      {
        v4 = sub_70EF0(j);
        if ( sub_71E60(dword_E9C28) <= v4 )
        {
          v1 = sub_71E60(dword_E9C28);
          if ( v1 < 0x400 )
            v6 = 1;
        }
        else
        {
          LOBYTE(v1) = sub_70F50(j);
        }
      }
    }
  }
  return v1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// E9C28: using guessed type int dword_E9C28;

//----- (00071890) --------------------------------------------------------
char sub_71890()
{
  __int16 *v0; // ebx
  char result; // al

  v0 = word_D951C;
  result = memset(byte_F5340, 0, 504);
  if ( byte_DB74C )
  {
    while ( v0[3] || v0[4] )
    {
      if ( *((_BYTE *)v0 + 11) == -1 )
      {
        result = *((_BYTE *)v0 + 11);
        byte_F5340[(unsigned __int16)*v0] = result;
      }
      v0 += 7;
    }
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D951C: using guessed type __int16 word_D951C[];
// DB74C: using guessed type char byte_DB74C;

//----- (000718F0) --------------------------------------------------------
__int16 sub_718F0()
{
  unsigned __int16 v0; // bx
  __int16 result; // ax

  v0 = 0;
  do
  {
    result = v0;
    if ( byte_F5340[v0] )
      result = sub_70F50(v0);
    ++v0;
  }
  while ( v0 < 0x1F8u );
  return result;
}

//----- (00071930) --------------------------------------------------------
int sub_71930()
{
  int result; // eax
  int v1; // ebx

  memset(dword_D41A0 + 57, 0, 508);
  result = 0;
  do
  {
    if ( dword_F66F0[(unsigned __int16)result] )
    {
      v1 = (unsigned __int16)result + dword_D41A0;
      *(_BYTE *)(v1 + 57) = 1;
      if ( byte_F5340[(unsigned __int16)result] )
        ++*(_BYTE *)(v1 + 57);
    }
    ++result;
  }
  while ( (unsigned __int16)result < 0x1F8u );
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;

//----- (00071990) --------------------------------------------------------
char sub_71990()
{
  unsigned __int16 v0; // bx
  unsigned int v1; // eax
  char i; // bl
  unsigned __int16 j; // si
  unsigned int v4; // ST04_4
  char v6; // [esp+4h] [ebp-4h]

  v6 = 0;
  if ( !dword_E9C28 )
    sub_712F0();
  v0 = 0;
  do
  {
    LOBYTE(v1) = v0;
    if ( !*(_BYTE *)(dword_D41A0 + v0 + 57) )
      LOBYTE(v1) = sub_70D20(v0);
    ++v0;
  }
  while ( v0 < 0x1F8u );
  for ( i = 2; i && !v6; --i )
  {
    for ( j = 0; j < 0x1F8u && !v6; ++j )
    {
      LOBYTE(v1) = dword_D41A0;
      if ( i == *(_BYTE *)(j + dword_D41A0 + 57) && !dword_F66F0[j] )
      {
        v4 = sub_70EF0(j);
        if ( sub_71E60(dword_E9C28) <= v4 )
        {
          v1 = sub_71E60(dword_E9C28);
          if ( v1 < 0x400 )
            v6 = 1;
        }
        else
        {
          LOBYTE(v1) = sub_70F50(j);
        }
      }
    }
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// E9C28: using guessed type int dword_E9C28;

//----- (00071A70) --------------------------------------------------------
unsigned __int8 __cdecl sub_71A70(unsigned __int8 a1)
{
  int v1; // edx
  unsigned __int8 result; // al

  v1 = dword_DB73C;
  result = a1;
  if ( a1 < 1u )
  {
    if ( !a1 )
      v1 = dword_DB740;
  }
  else if ( a1 <= 1u )
  {
    v1 = dword_DB744;
  }
  else if ( a1 == 2 )
  {
    v1 = dword_DB748;
  }
  dword_DB73C = v1;
  return result;
}
// DB73C: using guessed type int dword_DB73C;
// DB740: using guessed type int dword_DB740;
// DB744: using guessed type int dword_DB744;
// DB748: using guessed type int dword_DB748;

//----- (00071AB0) --------------------------------------------------------
__int16 __cdecl sub_71AB0(__int16 a1, char a2)
{
  _BYTE *v2; // eax
  __int16 v3; // si
  __int16 i; // bx
  _DWORD *v5; // ecx
  int v6; // eax

  LOWORD(v2) = 5 * a1;
  v3 = *(_WORD *)(dword_F6ED0 + 10 * a1 + 8);
  for ( i = *(_WORD *)(dword_F6ED0 + 10 * a1 + 8); i < 504; ++i )
  {
    LOWORD(v2) = v3;
    if ( *(unsigned __int16 *)(10 * i + dword_F6ED0 + 8) != v3 )
      break;
    v5 = (_DWORD *)dword_F66F0[i];
    if ( v5 )
    {
      v2 = (_BYTE *)*v5;
      if ( *(_BYTE *)*v5 & 1 )
      {
        v6 = sub_724F0(dword_E9C08, i);
        LOWORD(v2) = sub_723B0(v6, a2);
      }
    }
  }
  return (signed __int16)v2;
}
// E9C08: using guessed type int dword_E9C08;
// F6ED0: using guessed type int dword_F6ED0;

//----- (00071B40) --------------------------------------------------------
int __cdecl sub_71B40(int a1, unsigned __int16 a2, int a3)
{
  unsigned __int16 v3; // di
  int v4; // eax
  int v5; // eax
  int v6; // edx
  int v7; // esi
  int v8; // eax
  int v10; // ebx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // [esp+0h] [ebp-Ch]

  v3 = a2;
  if ( a3 )
  {
    v4 = 14 * a2;
    v14 = v4;
    v5 = 4 * a2 + v4 + 26;
    v6 = a1 - v5;
    if ( a1 == v5 )
      return 0;
    *(_WORD *)(a3 + 20) = 0;
    *(_WORD *)(a3 + 24) = 2;
    *(_DWORD *)a3 = v6;
    *(_DWORD *)(a3 + 4) = v6;
    v7 = a3;
    *(_WORD *)(a3 + 22) = a2;
    *(_DWORD *)(a3 + 8) = a3 + 26;
    v8 = v14 + a3 + 26;
    *(_DWORD *)(a3 + 12) = v8;
    *(_DWORD *)(a3 + 16) = 4 * a2 + v8;
    while ( --v3 != -1 )
      *(_DWORD *)(*(_DWORD *)(a3 + 8) + 14 * v3 + 4) = 0;
  }
  else
  {
    v10 = sub_83CD0(26);
    v7 = v10;
    if ( !v10
      || (v11 = sub_83CD0(a1), (*(_DWORD *)(v10 + 16) = v11) == 0)
      || (v12 = sub_83CD0(14 * a2), (*(_DWORD *)(v10 + 8) = v12) == 0)
      || (v13 = sub_83CD0(4 * a2), (*(_DWORD *)(v10 + 12) = v13) == 0) )
    {
      if ( v10 )
      {
        if ( *(_DWORD *)(v10 + 16) )
        {
          if ( *(_DWORD *)(v10 + 8) )
            sub_83E80(*(_DWORD *)(v10 + 8));
          sub_83E80(*(_DWORD *)(v10 + 16));
        }
        sub_83E80(v10);
      }
      exit(1);
    }
    *(_WORD *)(v10 + 20) = 0;
    *(_WORD *)(v10 + 24) = 1;
    *(_WORD *)(v10 + 22) = a2;
    *(_DWORD *)v10 = a1;
    *(_DWORD *)(v10 + 4) = a1;
    while ( --v3 != -1 )
      *(_DWORD *)(*(_DWORD *)(v10 + 8) + 14 * v3 + 4) = 0;
  }
  return v7;
}

//----- (00071CD0) --------------------------------------------------------
signed int __cdecl sub_71CD0(int a1)
{
  int i; // edx

  for ( i = 0; (signed __int16)i < (signed int)*(unsigned __int16 *)(a1 + 22); ++i )
  {
    if ( !*(_DWORD *)(14 * (signed __int16)i + *(_DWORD *)(a1 + 8) + 4) )
      return i;
  }
  return -1;
}

//----- (00071E60) --------------------------------------------------------
int __cdecl sub_71E60(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (00071E70) --------------------------------------------------------
int __cdecl sub_71E70(int a1, unsigned int a2, __int16 a3)
{
  signed __int16 v3; // si
  signed __int16 v4; // ax
  signed __int16 v5; // dx
  int v6; // ecx
  int v7; // eax
  int result; // eax

  v3 = -1;
  if ( a2 < *(_DWORD *)(a1 + 4) )
  {
    v4 = sub_71CD0(a1);
    v5 = v4;
    v6 = v4;
    v3 = v4;
    if ( v4 > -1 )
    {
      v7 = 14 * v4;
      *(_WORD *)(*(_DWORD *)(a1 + 8) + v7 + 10) = v5;
      *(_DWORD *)(*(_DWORD *)(a1 + 8) + v7 + 4) = a2;
      *(_DWORD *)(*(_DWORD *)(a1 + 8) + v7) = *(_DWORD *)a1 + *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 4);
      *(_WORD *)(*(_DWORD *)(a1 + 8) + v7 + 12) = a3;
      *(_DWORD *)(a1 + 4) -= a2;
      *(_WORD *)(*(_DWORD *)(a1 + 8) + v7 + 8) = *(_WORD *)(a1 + 20);
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * (unsigned __int16)(*(_WORD *)(a1 + 20))++) = *(_DWORD *)(a1 + 8) + 14 * v6;
    }
  }
  if ( v3 <= -1 )
    result = 0;
  else
    result = 14 * v3 + *(_DWORD *)(a1 + 8);
  return result;
}

//----- (00071F20) --------------------------------------------------------
__int16 __cdecl sub_71F20(int a1, int a2)
{
  int v2; // eax
  int v3; // ecx
  unsigned __int16 v4; // bx
  int v5; // esi
  int v6; // ecx
  unsigned __int16 v7; // cx
  int v8; // edi
  int v9; // eax
  const void *v10; // esi
  char *i; // [esp+4h] [ebp-4h]

  LOWORD(v2) = *(_WORD *)(a2 + 10);
  if ( (unsigned __int16)v2 < *(_WORD *)(a1 + 22) )
  {
    v2 = 14 * (unsigned __int16)v2;
    v3 = v2 + *(_DWORD *)(a1 + 8);
    if ( *(_DWORD *)(v3 + 4) )
    {
      v4 = *(_WORD *)(v3 + 8);
      v5 = *(_DWORD *)(v3 + 4) + *(_DWORD *)(a1 + 4);
      v6 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 4) = v5;
      *(_DWORD *)(v6 + v2 + 4) = 0;
      v2 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + v2);
      for ( i = (char *)v2; ; i += v2 )
      {
        ++v4;
        v7 = *(_WORD *)(a1 + 20);
        if ( v4 >= v7 )
          break;
        v8 = 4 * v4;
        *(_DWORD *)(v8 + *(_DWORD *)(a1 + 12) - 4) = *(_DWORD *)(v8 + *(_DWORD *)(a1 + 12));
        v9 = *(_DWORD *)(v8 + *(_DWORD *)(a1 + 12));
        *(_WORD *)(v9 + 8) = v4 - 1;
        v10 = *(const void **)v9;
        **(_DWORD **)(v8 + *(_DWORD *)(a1 + 12)) = i;
        qmemcpy(i, v10, *(_DWORD *)(*(_DWORD *)(v8 + *(_DWORD *)(a1 + 12)) + 4));
        v2 = *(_DWORD *)(*(_DWORD *)(4 * v4 + *(_DWORD *)(a1 + 12)) + 4);
      }
      *(_WORD *)(a1 + 20) = v7 - 1;
    }
  }
  return v2;
}

//----- (000720C0) --------------------------------------------------------
void __cdecl sub_720C0(int *a1)
{
  int v1; // edx

  v1 = *a1;
  if ( *a1 )
  {
    if ( *(_WORD *)(v1 + 24) == 1 )
    {
      sub_83E80(*(_DWORD *)(v1 + 16));
      sub_83E80(*(_DWORD *)(*a1 + 8));
      sub_83E80(*(_DWORD *)(*a1 + 12));
      sub_83E80(*a1);
    }
    *a1 = 0;
  }
}

//----- (00072120) --------------------------------------------------------
int __cdecl sub_72120(unsigned __int16 a1)
{
  unsigned __int16 v1; // di
  int v2; // esi
  int v3; // ebx
  int v4; // eax
  int v5; // eax

  v1 = a1;
  sub_83CC0(9);
  v2 = sub_83CD0(6);
  v3 = v2;
  if ( v2 && (v4 = sub_83CD0(28 * a1), (*(_DWORD *)(v2 + 2) = v4) != 0) )
  {
    *(_WORD *)v2 = a1;
    while ( --v1 != -1 )
    {
      v5 = 7 * v1;
      *(_DWORD *)(*(_DWORD *)(v2 + 2) + 4 * v5 + 4) = 0;
      *(_DWORD *)(*(_DWORD *)(v2 + 2) + 4 * v5) = 0;
    }
  }
  else if ( v2 )
  {
    sub_83E80(v2);
    v3 = 0;
  }
  sub_83CC0(10);
  return v3;
}

//----- (000721C0) --------------------------------------------------------
int __cdecl sub_721C0(unsigned __int16 *a1, int *a2, __int16 a3)
{
  signed __int16 v3; // cx
  signed __int16 v4; // si
  signed __int16 i; // bx
  _DWORD *v6; // edx
  int v7; // ebx
  int v8; // ecx
  __int16 v9; // ST08_2
  int v10; // edx
  signed __int16 v12; // [esp+Ch] [ebp-4h]

  v3 = -1;
  v4 = -1;
  if ( !*a1 )
    return 0;
  for ( i = 0; i < (signed int)*a1; ++i )
  {
    v6 = (_DWORD *)(28 * i + *(_DWORD *)(a1 + 1));
    if ( v6[1] )
    {
      if ( !*v6 )
        v4 = i;
    }
    else
    {
      v3 = i;
    }
  }
  v12 = v3 <= 0 ? v4 : v3;
  if ( v12 <= -1 )
    return 0;
  v7 = *a2;
  v8 = *(unsigned __int16 *)(*a2 + 4) * *(unsigned __int16 *)(*a2 + 2);
  v9 = *(_WORD *)(v8 + *a2 + 6);
  v10 = 28 * v12;
  *(_DWORD *)(v10 + *(_DWORD *)(a1 + 1) + 4) = a2;
  *(_WORD *)(v10 + *(_DWORD *)(a1 + 1) + 12) = 6;
  *(_WORD *)(v10 + *(_DWORD *)(a1 + 1) + 14) = v8 + 6;
  *(_WORD *)(v10 + *(_DWORD *)(a1 + 1) + 16) = v9;
  *(_WORD *)(v10 + *(_DWORD *)(a1 + 1) + 18) = *(_WORD *)(v7 + 2);
  *(_WORD *)(v10 + *(_DWORD *)(a1 + 1) + 20) = *(_WORD *)(v7 + 4);
  *(_DWORD *)(v10 + *(_DWORD *)(a1 + 1) + 8) = v8 + 6;
  *(_WORD *)(v10 + *(_DWORD *)(a1 + 1) + 22) = 1;
  *(_DWORD *)(v10 + *(_DWORD *)(a1 + 1)) = 1;
  *(_WORD *)(v10 + *(_DWORD *)(a1 + 1) + 24) = v12;
  *(_WORD *)(v10 + *(_DWORD *)(a1 + 1) + 26) = a3;
  return v10 + *(_DWORD *)(a1 + 1);
}

//----- (00072350) --------------------------------------------------------
int __cdecl sub_72350(int a1)
{
  int v1; // esi
  int v2; // edi
  int v3; // eax
  __int16 v4; // cx
  int result; // eax

  if ( *(_WORD *)(a1 + 22) > *(_WORD *)(a1 + 16) )
  {
    *(_WORD *)(a1 + 22) = 1;
    *(_DWORD *)(a1 + 8) = *(unsigned __int16 *)(a1 + 14);
  }
  v1 = **(_DWORD **)(a1 + 4);
  v2 = *(_DWORD *)(a1 + 8);
  sub_765FC(*(_WORD *)(a1 + 18), 0);
  v1 += 6;
  v3 = sub_76619(v1 + v2, v1);
  v4 = *(_WORD *)(a1 + 22);
  result = v3 - v1;
  *(_DWORD *)(a1 + 8) = result;
  *(_WORD *)(a1 + 22) = v4 + 1;
  return result;
}

//----- (000723B0) --------------------------------------------------------
unsigned __int16 __cdecl sub_723B0(int a1, char a2)
{
  unsigned __int16 result; // ax

  if ( a2 )
  {
    while ( 1 )
    {
      result = *(_WORD *)(a1 + 22);
      if ( result > *(_WORD *)(a1 + 16) )
        break;
      sub_72350(a1);
    }
  }
  else
  {
    memset(**(_DWORD **)(a1 + 4) + 6, 0, *(unsigned __int16 *)(a1 + 18) * *(unsigned __int16 *)(a1 + 20));
    *(_WORD *)(a1 + 22) = 1;
    result = *(_WORD *)(a1 + 14);
    *(_DWORD *)(a1 + 8) = result;
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);

//----- (00072410) --------------------------------------------------------
_DWORD *__cdecl sub_72410(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  if ( a1 )
  {
    *a1 = 0;
    a1[1] = 0;
  }
  return result;
}

//----- (000724F0) --------------------------------------------------------
int __cdecl sub_724F0(int a1, __int16 a2)
{
  int result; // eax
  int v3; // edx

  HIWORD(v3) = HIWORD(a1);
  result = *(_DWORD *)(a1 + 2);
  LOWORD(v3) = *(_WORD *)a1;
  if ( !*(_WORD *)a1 )
    return 0;
  while ( !*(_DWORD *)(result + 4) || a2 != *(_WORD *)(result + 26) )
  {
    --v3;
    result += 28;
    if ( !(_WORD)v3 )
      return 0;
  }
  return result;
}

//----- (00072550) --------------------------------------------------------
void __cdecl sub_72550(int *a1)
{
  if ( *a1 )
  {
    sub_83E80(*(_DWORD *)(*a1 + 2));
    *(_DWORD *)(*a1 + 2) = 0;
    sub_83E80(*a1);
    *a1 = 0;
  }
}

//----- (00072633) --------------------------------------------------------
__int16 __cdecl __spoils<> sub_72633(__int16 a1, __int16 a2)
{
  signed int v2; // ebx
  __int16 result; // ax
  int v4; // ebx
  int v5; // eax
  int v6; // ebx

  if ( a1 )
  {
    v2 = a2;
  }
  else
  {
    v2 = a2;
    if ( !a2 )
      return 0;
  }
  if ( a1 < 0 )
  {
    v5 = -a1;
    if ( v2 < 0 )
    {
      v6 = -v2;
      if ( v5 < v6 )
        result = 2048 - word_DE350[-256 * a1 / (unsigned int)v6];
      else
        result = word_DE350[(v6 << 8) / (unsigned int)v5] + 1536;
    }
    else if ( v5 < v2 )
    {
      result = word_DE350[-256 * a1 / (unsigned int)v2] + 1024;
    }
    else
    {
      result = 1536 - word_DE350[(v2 << 8) / (unsigned int)v5];
    }
  }
  else if ( v2 < 0 )
  {
    v4 = -v2;
    if ( a1 < v4 )
      result = word_DE350[(a1 << 8) / (unsigned int)v4];
    else
      result = 512 - word_DE350[(v4 << 8) / (unsigned int)a1];
  }
  else if ( a1 < v2 )
  {
    result = 1024 - word_DE350[(a1 << 8) / (unsigned int)v2];
  }
  else
  {
    result = word_DE350[(v2 << 8) / (unsigned int)a1] + 512;
  }
  return result;
}
// DE350: using guessed type __int16 word_DE350[];

//----- (0007277A) --------------------------------------------------------
unsigned int __cdecl sub_7277A(unsigned int a1)
{
  int v1; // eax
  unsigned int i; // ebx

  if ( !a1 )
    return 0;
  _BitScanReverse((unsigned int *)&v1, a1);
  for ( i = (unsigned __int16)word_727B0[v1]; (signed int)(a1 / i) < (signed int)i; i = (a1 / i + i) >> 1 )
    ;
  return i;
}
// 727B0: using guessed type __int16 word_727B0[];

//----- (000727F0) --------------------------------------------------------
void __cdecl sub_727F0(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  __outbyte(0x3C8u, a1);
  __outbyte(0x3C9u, a2);
  __outbyte(0x3C9u, a3);
  __outbyte(0x3C9u, a4);
}

//----- (00072883) --------------------------------------------------------
void __usercall __spoils<ecx> sub_72883(int a1@<eax>, void *a2, unsigned __int16 a3, char a4)
{
  int v4; // eax

  LOBYTE(a1) = a4;
  BYTE1(a1) = a4;
  v4 = a1 << 16;
  LOBYTE(v4) = a4;
  BYTE1(v4) = a4;
  memset32(a2, v4, 80 * a3);
}

//----- (000728A9) --------------------------------------------------------
void __usercall __spoils<ecx> sub_728A9(int a1@<eax>, void *a2, unsigned __int16 a3, char a4)
{
  int v4; // eax

  LOBYTE(a1) = a4;
  BYTE1(a1) = a4;
  v4 = a1 << 16;
  LOBYTE(v4) = a4;
  BYTE1(v4) = a4;
  memset32(a2, v4, 160 * a3);
}

//----- (00072C40) --------------------------------------------------------
int __cdecl sub_72C40(__int16 a1, __int16 a2, int a3, unsigned __int8 a4)
{
  __int16 v4; // dx
  char *v5; // esi
  int result; // eax
  int v7; // [esp+4h] [ebp-4h]

  v4 = *(_WORD *)(a3 + 4);
  v5 = *(char **)a3;
  if ( word_180660 & 1 )
  {
    sub_8F920(v4, a2, a1, v5, a4, 0);
    result = v7;
  }
  else
  {
    if ( word_180660 & 8 )
      sub_8F935(v4, a2, a1, v5, a4, 0);
    result = v7;
  }
  return result;
}
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (00072CB0) --------------------------------------------------------
int __cdecl sub_72CB0(unsigned __int8 *a1, int a2)
{
  int v3; // [esp+4h] [ebp-Ch]
  int v4; // [esp+8h] [ebp-8h]
  unsigned __int8 *v5; // [esp+Ch] [ebp-4h]

  v5 = a1;
  v4 = a2;
  v3 = 0;
  while ( v4 )
  {
    --v4;
    v3 += *v5++;
  }
  return v3;
}

//----- (00072D04) --------------------------------------------------------
void sub_72D04()
{
  signed int i; // [esp+0h] [ebp-8h]
  signed int j; // [esp+4h] [ebp-4h]

  if ( byte_E1274 )
  {
    for ( i = 0; word_E127A > i; ++i )
    {
      while ( *(_BYTE *)(dword_E12AE[i] + 49) == -1 )
        ;
    }
    while ( *(_BYTE *)(dword_E12AA + 49) == -1 )
      ;
    sub_83E80(dword_E12AA);
    for ( j = 0; j < 8; ++j )
    {
      sub_83E80(dword_E12AE[j]);
      sub_83E80(dword_E1286[j]);
    }
    sub_83E80(dword_E127E);
    sub_83E80(dword_E1282);
    byte_E1274 = 0;
  }
}
// E1274: using guessed type char byte_E1274;
// E127A: using guessed type __int16 word_E127A;
// E127E: using guessed type int dword_E127E;
// E1282: using guessed type int dword_E1282;
// E12AA: using guessed type int dword_E12AA;

//----- (00072DDE) --------------------------------------------------------
int __usercall sub_72DDE@<eax>(signed __int16 *a1@<ebx>, int a2)
{
  char v3; // [esp+0h] [ebp-1Ch]
  int v4; // [esp+14h] [ebp-8h]

  sprintf(&v3, aSD, aTester, a2);
  do
  {
    v4 = sub_74767(a1, (_BYTE *)dword_E12AE[a2], (int)&v3);
    if ( v4 && v4 == 13 )
      sub_74A86((_BYTE *)dword_E12AE[a2], (int)&v3);
  }
  while ( v4 == 13 && !word_E12A6 );
  return v4;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// E12A6: using guessed type __int16 word_E12A6;

//----- (00072E70) --------------------------------------------------------
int __fastcall sub_72E70(int a1, int a2, signed __int16 *a3)
{
  int v3; // edx
  char v5; // [esp+0h] [ebp-30h]
  char v6[8]; // [esp+18h] [ebp-18h]
  int v7; // [esp+20h] [ebp-10h]
  int i; // [esp+28h] [ebp-8h]
  int v9; // [esp+2Ch] [ebp-4h]

  for ( i = 0; word_E127A > i; ++i )
  {
    if ( word_E1276 != i )
      sub_74809(i);
  }
  memset(v6, 0, 8);
  v9 = 0;
  while ( v9 < 2 )
  {
    v3 = v6[word_E1276];
    if ( v3 == word_E127A - 1 || word_E12A6 )
      break;
    for ( i = 0; word_E127A > i; ++i )
    {
      if ( word_E1276 != i )
      {
        v5 = *(_BYTE *)(dword_E12AE[i] + 49);
        if ( v5 )
        {
          if ( v5 == -1 )
          {
            if ( v9 )
              sub_748F7(i);
          }
          else if ( !v6[i] )
          {
            ++v6[word_E1276];
            v6[i] = 1;
          }
        }
        else if ( ++v9 == 1 )
        {
          word_E12A8 = i;
        }
      }
    }
    sub_7C230(word_E127A, v3, a3);
  }
  v7 = v9;
  return v9;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A6: using guessed type __int16 word_E12A6;
// E12A8: using guessed type __int16 word_E12A8;
// 72E70: using guessed type char var_18[8];

//----- (00072FBB) --------------------------------------------------------
signed int __fastcall sub_72FBB(int a1, int a2, signed __int16 *a3)
{
  int v3; // edx
  int i; // [esp+4h] [ebp-4h]

  sub_74809(0);
  for ( i = dword_17DB54; ; sub_7C230(dword_17DB54 - i, v3, a3) )
  {
    if ( *(_BYTE *)(dword_E12AE[0] + 49) != -1 )
      return 1;
    if ( (unsigned int)(dword_17DB54 - i) > 0x78 )
      break;
  }
  sub_748F7(0);
  return 0;
}
// 17DB54: using guessed type int dword_17DB54;

//----- (0007302E) --------------------------------------------------------
signed int sub_7302E()
{
  signed int i; // [esp+4h] [ebp-4h]

  for ( i = 0; word_E127A > i && !word_E12A6; ++i )
  {
    if ( word_E1276 != i )
      sub_74B75(i);
  }
  return 1;
}
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A6: using guessed type __int16 word_E12A6;

//----- (0007308F) --------------------------------------------------------
int __usercall sub_7308F@<eax>(signed __int16 *a1@<ebx>, int a2, __int16 a3)
{
  int v3; // edx
  int v4; // eax
  int v6; // [esp+4h] [ebp-24h]
  char v7; // [esp+8h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]

  if ( !byte_E1274 || byte_E1275 )
    return -1;
  if ( a3 )
    word_E127A = a3;
  else
    word_E127A = 8;
  byte_E1275 = 0;
  word_E12A6 = 0;
  strcpy(aTester, a2);
  for ( i = 0; word_E127A > i; ++i )
    byte_E12CE[i] = 0;
  for ( i = 0; word_E127A > i; ++i )
  {
    while ( *(_BYTE *)(dword_E12AE[i] + 49) == -1 )
      ;
  }
  while ( *(_BYTE *)(dword_E12AA + 49) == -1 )
    ;
  i = 0;
  word_E1276 = -1;
  while ( word_E127A > i && word_E1276 == -1 && !word_E12A6 )
  {
    v6 = sub_72DDE(a1, i);
    if ( v6 )
    {
      if ( v6 == 255 )
      {
        sub_748F7(i);
        i = word_E127A;
      }
    }
    else
    {
      word_E1276 = i;
    }
    ++i;
  }
  if ( word_E1276 == -1 )
    return -1;
  for ( i = 0; ; ++i )
  {
    v4 = word_E127A;
    if ( word_E127A <= i )
      break;
    if ( word_E1276 != i )
    {
      strcpy(dword_E12AE[i] + 26, dword_E12AE[word_E1276] + 26);
      v3 = dword_E12AE[word_E1276];
      LOBYTE(v3) = *(_BYTE *)(v3 + 3);
      *(_BYTE *)(dword_E12AE[i] + 3) = v3;
    }
  }
  LOWORD(v4) = word_E1276;
  if ( word_E1276 )
  {
    if ( !sub_72FBB(v4, v3, a1) )
      word_E12A6 = 1;
  }
  else
  {
    sub_7302E();
    word_E12A8 = word_E1276;
  }
  if ( word_E12A6 == 1 )
  {
    for ( i = 0; word_E127A > i; ++i )
    {
      if ( word_E1276 != i )
        sub_748F7(i);
    }
    sprintf(&v7, aSD, aTester, word_E1276);
    sub_74A86((_BYTE *)dword_E12AE[word_E1276], (int)&v7);
    v9 = -1;
  }
  else
  {
    sub_74F76();
    byte_E1275 = 1;
    v9 = word_E1276;
  }
  return v9;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// E1274: using guessed type char byte_E1274;
// E1275: using guessed type char byte_E1275;
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A6: using guessed type __int16 word_E12A6;
// E12A8: using guessed type __int16 word_E12A8;
// E12AA: using guessed type int dword_E12AA;

//----- (00073669) --------------------------------------------------------
int __cdecl sub_73669(__int16 a1)
{
  int result; // eax
  char v2; // [esp+0h] [ebp-18h]
  int i; // [esp+14h] [ebp-4h]

  if ( word_E1276 == a1 )
  {
    for ( i = 0; (signed __int16)i < word_E127A; ++i )
    {
      if ( (_WORD)i != word_E1276 )
      {
        sub_748F7(i);
        sub_74B19((_BYTE *)dword_E12AE[(signed __int16)i]);
      }
    }
    sprintf(&v2, aSD, aTester, word_E1276);
    result = sub_74A86((_BYTE *)dword_E12AE[a1], (int)&v2);
    byte_E1275 = 0;
  }
  else
  {
    sub_748F7(a1);
    result = sub_74B19((_BYTE *)dword_E12AE[a1]);
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// E1275: using guessed type char byte_E1275;
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;

//----- (0007373D) --------------------------------------------------------
int __cdecl sub_7373D(__int16 a1)
{
  int result; // eax
  char v2; // [esp+0h] [ebp-64h]
  char v3[8]; // [esp+54h] [ebp-10h]
  int i; // [esp+5Ch] [ebp-8h]

  if ( byte_E1274 && byte_E1275 )
  {
    if ( (unsigned __int16)word_E12A8 == a1 )
    {
      if ( word_E1276 == a1 )
      {
        for ( i = 0; word_E127A > i; ++i )
          v3[i] = byte_E12CE[i] == 1;
        for ( i = 0; word_E127A > i; ++i )
        {
          if ( v3[i] == 1 )
            sub_74006(i, (int)v3, 8u);
        }
        result = sub_73669(a1);
      }
      else
      {
        sub_7404E(word_E12A8, (int)v3, 8u);
        sub_73669(a1);
        for ( i = 0; word_E127A > i; ++i )
        {
          if ( v3[i] == 1 )
          {
            word_E12A8 = i;
            v3[i] = 0;
            break;
          }
        }
        if ( (unsigned __int16)word_E12A8 == word_E1276 )
        {
          for ( i = 0; ; ++i )
          {
            result = word_E127A;
            if ( word_E127A <= i )
              break;
            if ( word_E1276 != i && v3[i] == 1 )
            {
              sub_74B75(i);
              while ( *(_BYTE *)(dword_E12AE[i] + 49) == -1 )
                ;
              if ( *(_BYTE *)(dword_E12AE[i] + 49) )
                sprintf(&v2, aErrorCodeListe, *(unsigned __int8 *)(dword_E12AE[i] + 49));
            }
          }
        }
        else
        {
          while ( 1 )
          {
            sub_74809(word_E12A8);
            while ( *(_BYTE *)(dword_E12AE[(unsigned __int16)word_E12A8] + 49) == -1 )
              ;
            result = dword_E12AE[(unsigned __int16)word_E12A8];
            if ( !*(_BYTE *)(result + 49) )
              break;
            sprintf(&v2, aErrorCodeCallD, *(unsigned __int8 *)(dword_E12AE[(unsigned __int16)word_E12A8] + 49));
          }
        }
      }
    }
    else
    {
      result = sub_73669(a1);
    }
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// E1274: using guessed type char byte_E1274;
// E1275: using guessed type char byte_E1275;
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A8: using guessed type __int16 word_E12A8;
// 7373D: using guessed type char var_10[8];

//----- (000739AD) --------------------------------------------------------
__int16 __cdecl sub_739AD(__int16 a1)
{
  __int16 result; // ax
  char v2; // [esp+0h] [ebp-18h]
  int i; // [esp+14h] [ebp-4h]

  if ( word_E1276 == a1 )
  {
    for ( i = 0; (signed __int16)i < word_E127A; ++i )
    {
      if ( (_WORD)i != word_E1276 )
      {
        sub_748F7(i);
        sub_74B19((_BYTE *)dword_E12AE[(signed __int16)i]);
      }
    }
    sprintf(&v2, aSD, aTester, word_E1276);
    result = sub_74A86((_BYTE *)dword_E12AE[a1], (int)&v2);
    byte_E1275 = 0;
  }
  else
  {
    sub_748F7(a1);
    sub_74B19((_BYTE *)dword_E12AE[a1]);
    result = word_E12A8;
    if ( word_E1276 == (unsigned __int16)word_E12A8 )
      result = sub_74B75(a1);
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// E1275: using guessed type char byte_E1275;
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A8: using guessed type __int16 word_E12A8;

//----- (00073AA1) --------------------------------------------------------
__int16 __cdecl sub_73AA1(__int16 a1)
{
  int v1; // eax
  char v3; // [esp+0h] [ebp-64h]
  char v4[8]; // [esp+54h] [ebp-10h]
  int i; // [esp+5Ch] [ebp-8h]

  if ( byte_E1274 && byte_E1275 )
  {
    if ( (unsigned __int16)word_E12A8 == a1 )
    {
      if ( word_E1276 == a1 )
      {
        for ( i = 0; word_E127A > i; ++i )
          v4[i] = byte_E12CE[i] == 1;
        for ( i = 0; word_E127A > i; ++i )
        {
          if ( v4[i] == 1 )
            sub_74006(i, (int)v4, 8u);
        }
        LOWORD(v1) = sub_739AD(a1);
      }
      else
      {
        sub_7404E(word_E12A8, (int)v4, 8u);
        sub_739AD(a1);
        for ( i = 0; word_E127A > i; ++i )
        {
          if ( v4[i] == 1 )
          {
            word_E12A8 = i;
            v4[i] = 0;
            break;
          }
        }
        if ( (unsigned __int16)word_E12A8 == word_E1276 )
        {
          for ( i = 0; ; ++i )
          {
            LOWORD(v1) = word_E127A;
            if ( word_E127A <= i )
              break;
            if ( word_E1276 != i && v4[i] == 1 )
            {
              sub_74B75(i);
              while ( *(_BYTE *)(dword_E12AE[i] + 49) == -1 )
                ;
              if ( *(_BYTE *)(dword_E12AE[i] + 49) )
                sprintf(&v3, aErrorCodeListe, *(unsigned __int8 *)(dword_E12AE[i] + 49));
            }
          }
        }
        else
        {
          while ( 1 )
          {
            sub_74809(word_E12A8);
            while ( *(_BYTE *)(dword_E12AE[(unsigned __int16)word_E12A8] + 49) == -1 )
              ;
            v1 = dword_E12AE[(unsigned __int16)word_E12A8];
            if ( !*(_BYTE *)(v1 + 49) )
              break;
            sprintf(&v3, aErrorCodeCallD, *(unsigned __int8 *)(dword_E12AE[(unsigned __int16)word_E12A8] + 49));
          }
        }
      }
    }
    else
    {
      LOWORD(v1) = sub_739AD(a1);
    }
  }
  return v1;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// E1274: using guessed type char byte_E1274;
// E1275: using guessed type char byte_E1275;
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A8: using guessed type __int16 word_E12A8;
// 73AA1: using guessed type char var_10[8];

//----- (00073D11) --------------------------------------------------------
__int16 __cdecl sub_73D11(__int16 a1)
{
  __int16 result; // ax
  char v2; // [esp+0h] [ebp-18h]
  int i; // [esp+14h] [ebp-4h]

  if ( word_E1276 == a1 )
  {
    for ( i = 0; (signed __int16)i < word_E127A; ++i )
    {
      if ( (_WORD)i != word_E1276 )
      {
        sub_748F7(i);
        sub_74B19((_BYTE *)dword_E12AE[(signed __int16)i]);
      }
    }
    sprintf(&v2, aSD, aTester, word_E1276);
    result = sub_74A86((_BYTE *)dword_E12AE[a1], (int)&v2);
    byte_E1275 = 0;
  }
  else
  {
    sub_748F7(a1);
    sub_74B19((_BYTE *)dword_E12AE[a1]);
    result = word_E12A8;
    if ( word_E1276 == (unsigned __int16)word_E12A8 )
      result = sub_74B75(a1);
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// E1275: using guessed type char byte_E1275;
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A8: using guessed type __int16 word_E12A8;

//----- (00074006) --------------------------------------------------------
unsigned __int16 __cdecl sub_74006(unsigned __int16 a1, int a2, unsigned int a3)
{
  unsigned __int16 result; // ax

  if ( byte_E1274 )
  {
    result = a1;
    if ( byte_E12CE[a1] == 1 )
      result = sub_74EF1(dword_E12AE[a1], a2, a3);
  }
  return result;
}
// E1274: using guessed type char byte_E1274;

//----- (0007404E) --------------------------------------------------------
unsigned __int16 __cdecl sub_7404E(unsigned __int16 a1, int a2, unsigned int a3)
{
  unsigned __int16 result; // ax

  if ( byte_E1274 )
  {
    result = a1;
    if ( byte_E12CE[a1] == 1 )
      result = sub_74D41(dword_E12AE[a1], a2, a3);
  }
  return result;
}
// E1274: using guessed type char byte_E1274;

//----- (00074374) --------------------------------------------------------
__int16 sub_74374()
{
  return sub_74F76();
}

//----- (0007438A) --------------------------------------------------------
unsigned __int16 __cdecl sub_7438A(int a1, unsigned int a2)
{
  unsigned __int16 result; // ax
  signed __int16 i; // [esp+4h] [ebp-4h]
  signed __int16 j; // [esp+4h] [ebp-4h]

  if ( byte_E1274 )
  {
    if ( word_E1276 == (unsigned __int16)word_E12A8 )
    {
      for ( i = 0; i < word_E1278; ++i )
      {
        if ( i != word_E1276 )
          sub_7404E(i, a1 + a2 * i, a2);
      }
      for ( j = 0; ; ++j )
      {
        result = j;
        if ( j >= word_E1278 )
          break;
        if ( j != word_E1276 )
          sub_74006(j, a1, a2 * word_E1278);
      }
    }
    else
    {
      sub_74006(word_E12A8, a1 + a2 * word_E1276, a2);
      result = sub_7404E(word_E12A8, a1, a2 * word_E1278);
    }
  }
  return result;
}
// E1274: using guessed type char byte_E1274;
// E1276: using guessed type __int16 word_E1276;
// E1278: using guessed type __int16 word_E1278;
// E12A8: using guessed type __int16 word_E12A8;

//----- (0007449C) --------------------------------------------------------
__int16 sub_7449C()
{
  __int16 result; // ax
  signed int i; // [esp+0h] [ebp-4h]

  if ( byte_E1274 )
  {
    result = word_E12A8;
    if ( word_E1276 == (unsigned __int16)word_E12A8 )
    {
      for ( i = 0; ; ++i )
      {
        result = word_E127A;
        if ( word_E127A <= i )
          break;
        if ( word_E1276 != i && *(_BYTE *)(dword_E12AE[i] + 49) == -1 )
          sub_748F7(i);
      }
    }
  }
  return result;
}
// E1274: using guessed type char byte_E1274;
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A8: using guessed type __int16 word_E12A8;

//----- (00074515) --------------------------------------------------------
int sub_74515()
{
  return (unsigned __int16)word_E12A8;
}
// E12A8: using guessed type __int16 word_E12A8;

//----- (00074536) --------------------------------------------------------
int sub_74536()
{
  return word_E1276;
}
// E1276: using guessed type __int16 word_E1276;

//----- (00074556) --------------------------------------------------------
int sub_74556()
{
  signed int v2; // [esp+4h] [ebp-8h]
  signed int i; // [esp+8h] [ebp-4h]
  signed int j; // [esp+8h] [ebp-4h]

  v2 = 1;
  if ( !byte_E1274 && !dword_E12AA )
  {
    dword_E12AA = sub_83D70(66);
    if ( dword_E12AA )
    {
      if ( sub_74A11() == -1 )
        return 0;
      dword_E127E = sub_83D70(2048);
      if ( dword_E127E )
      {
        dword_E1282 = sub_83D70(2048);
        if ( dword_E1282 )
        {
          for ( i = 0; i < 8; ++i )
          {
            dword_E1286[i] = sub_83D70(2048);
            if ( !dword_E1286[i] )
            {
              v2 = 0;
              break;
            }
            dword_E12AE[i] = sub_83D70(66);
            if ( !dword_E12AE[i] )
            {
              v2 = 0;
              break;
            }
          }
          if ( i == 8 )
            byte_E1274 = 1;
        }
        else
        {
          v2 = 0;
        }
      }
      else
      {
        v2 = 0;
      }
    }
    else
    {
      v2 = 0;
    }
  }
  if ( !v2 )
  {
    byte_E1274 = 0;
    if ( dword_E12AA )
      sub_83E80(dword_E12AA);
    if ( dword_E127E )
      sub_83E80(dword_E127E);
    if ( dword_E1282 )
      sub_83E80(dword_E1282);
    for ( j = 0; j < 8; ++j )
    {
      if ( dword_E12AE[j] )
        sub_83E80(dword_E12AE[j]);
      if ( dword_E1286[j] )
        sub_83E80(dword_E1286[j]);
    }
  }
  return (unsigned __int8)byte_E1274;
}
// E1274: using guessed type char byte_E1274;
// E127E: using guessed type int dword_E127E;
// E1282: using guessed type int dword_E1282;
// E12AA: using guessed type int dword_E12AA;

//----- (00074767) --------------------------------------------------------
signed int __usercall sub_74767@<eax>(signed __int16 *a1@<ebx>, _BYTE *a2, int a3)
{
  int v3; // edx

  strcpy(a2 + 26, a3);
  while ( strlen(a2 + 26) < 0xFu )
    strcat(a2 + 26, asc_D1949);
  *a2 = -80;
  if ( sub_75044((unsigned int)a2) == -1 )
    return -99;
  while ( a2[49] == -1 && !word_E12A6 )
    sub_7C230((int)a2, v3, a1);
  return (unsigned __int8)a2[49];
}
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// 99D6B: using guessed type _DWORD __cdecl strlen(_DWORD);
// 99D84: using guessed type _DWORD __cdecl strcat(_DWORD, _DWORD);
// E12A6: using guessed type __int16 word_E12A6;

//----- (00074809) --------------------------------------------------------
int __cdecl sub_74809(__int16 a1)
{
  int v2; // [esp+14h] [ebp-8h]

  *(_BYTE *)dword_E12AE[a1] = -112;
  sprintf(dword_E12AE[a1] + 10, aSD, aTester, a1);
  while ( strlen(dword_E12AE[a1] + 10) < 0xFu )
    strcat(dword_E12AE[a1] + 10, asc_D1949);
  *(_BYTE *)(dword_E12AE[a1] + 42) = 0;
  *(_BYTE *)(dword_E12AE[a1] + 43) = 0;
  if ( sub_75044(dword_E12AE[a1]) == -1 )
    v2 = -99;
  else
    v2 = -*(unsigned __int8 *)(dword_E12AE[a1] + 49);
  return v2;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 99D6B: using guessed type _DWORD __cdecl strlen(_DWORD);
// 99D84: using guessed type _DWORD __cdecl strcat(_DWORD, _DWORD);

//----- (000748F7) --------------------------------------------------------
signed int __cdecl sub_748F7(__int16 a1)
{
  if ( *(_BYTE *)(dword_E12AE[a1] + 49) != -1 )
    return -*(unsigned __int8 *)(dword_E12AA + 49);
  *(_BYTE *)dword_E12AA = 53;
  *(_WORD *)(dword_E12AA + 6) = (unsigned int)dword_E12AE[a1] >> 4;
  if ( sub_75044(dword_E12AA) != -1 )
  {
    do
    {
      while ( *(_BYTE *)(dword_E12AA + 49) == -1 )
        ;
    }
    while ( *(_BYTE *)(dword_E12AE[a1] + 49) == -1 );
    return -*(unsigned __int8 *)(dword_E12AA + 49);
  }
  return -99;
}
// E12AA: using guessed type int dword_E12AA;

//----- (00074A11) --------------------------------------------------------
signed int sub_74A11()
{
  __int16 v0; // dx

  if ( !dos_getvect(92) && !v0 )
    return -1;
  *(_BYTE *)dword_E12AA = 127;
  if ( sub_75044(dword_E12AA) == -1 )
    return -1;
  if ( *(_BYTE *)(dword_E12AA + 1) == 3 )
    return 0;
  return -1;
}
// 99BA7: using guessed type _DWORD __cdecl dos_getvect(_DWORD);
// E12AA: using guessed type int dword_E12AA;

//----- (00074A86) --------------------------------------------------------
int __cdecl sub_74A86(_BYTE *a1, int a2)
{
  strcpy(a1 + 26, a2);
  while ( strlen(a1 + 26) < 0xFu )
    strcat(a1 + 26, asc_D1949);
  *a1 = -79;
  if ( sub_75044((unsigned int)a1) == -1 )
    return -99;
  while ( a1[49] == -1 )
    ;
  return -(unsigned __int8)a1[49];
}
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// 99D6B: using guessed type _DWORD __cdecl strlen(_DWORD);
// 99D84: using guessed type _DWORD __cdecl strcat(_DWORD, _DWORD);

//----- (00074B19) --------------------------------------------------------
int __cdecl sub_74B19(_BYTE *a1)
{
  *a1 = -110;
  if ( sub_75044((unsigned int)a1) == -1 )
    return -99;
  while ( a1[49] == -1 )
    ;
  a1[2] = 0;
  return -(unsigned __int8)a1[49];
}

//----- (00074B75) --------------------------------------------------------
signed int __cdecl sub_74B75(__int16 a1)
{
  char v2; // [esp+0h] [ebp-18h]

  if ( *(_BYTE *)(dword_E12AE[a1] + 49) == -1 )
    return -*(unsigned __int8 *)(dword_E12AE[a1] + 49);
  sprintf(&v2, aSD, aTester, a1);
  *(_BYTE *)dword_E12AE[a1] = -111;
  strcpy(dword_E12AE[a1] + 10, &v2);
  while ( strlen(dword_E12AE[a1] + 10) < 0xFu )
    strcat(dword_E12AE[a1] + 10, asc_D1949);
  *(_BYTE *)(dword_E12AE[a1] + 42) = 0;
  *(_BYTE *)(dword_E12AE[a1] + 43) = 0;
  if ( sub_75044(dword_E12AE[a1]) != -1 )
  {
    *(_WORD *)(dword_E12AE[a1] + 4) = 0;
    return -*(unsigned __int8 *)(dword_E12AE[a1] + 49);
  }
  return -99;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// 99D6B: using guessed type _DWORD __cdecl strlen(_DWORD);
// 99D84: using guessed type _DWORD __cdecl strcat(_DWORD, _DWORD);

//----- (00074C9D) --------------------------------------------------------
int __cdecl sub_74C9D(unsigned int a1, int a2)
{
  *(_BYTE *)a1 = -107;
  *(_WORD *)(a1 + 6) = (unsigned int)dword_E1282 >> 4;
  *(_WORD *)(a1 + 8) = 2048;
  if ( sub_75044(a1) == -1 )
    return -99;
  while ( *(_BYTE *)(a1 + 49) == -1 )
    ;
  if ( *(_BYTE *)(a1 + 49) )
    return -*(unsigned __int8 *)(a1 + 49);
  memcpy(a2, dword_E1282, *(unsigned __int16 *)(a1 + 8));
  return *(unsigned __int16 *)(a1 + 8);
}
// 99DBD: using guessed type _DWORD __cdecl memcpy(_DWORD, _DWORD, _DWORD);
// E1282: using guessed type int dword_E1282;

//----- (00074D41) --------------------------------------------------------
int __cdecl sub_74D41(unsigned int a1, int a2, unsigned int a3)
{
  int v3; // eax
  int v5; // [esp+0h] [ebp-10h]
  int v6; // [esp+4h] [ebp-Ch]
  unsigned int v7; // [esp+8h] [ebp-8h]
  int v8; // [esp+Ch] [ebp-4h]

  v8 = a2;
  v7 = 0;
  while ( a3 >> 11 > v7 )
  {
    v6 = sub_74C9D(a1, v8);
    if ( v6 != 2048 )
      return v6;
    ++v7;
    v8 += 2048;
  }
  v3 = sub_74C9D(a1, v8);
  if ( (a3 & 0x7FF) == v3 )
    v5 = a3;
  else
    v5 = v3;
  return v5;
}

//----- (00074DD4) --------------------------------------------------------
signed int __cdecl sub_74DD4(unsigned int a1, int a2, unsigned __int16 a3)
{
  signed int v4; // [esp+0h] [ebp-4h]

  *(_BYTE *)a1 = -107;
  *(_WORD *)(a1 + 6) = (unsigned int)dword_E1286[a3] >> 4;
  *(_WORD *)(a1 + 8) = 2048;
  if ( sub_75044(a1) == -1 )
    v4 = -99;
  else
    v4 = 1;
  return v4;
}

//----- (00074E6D) --------------------------------------------------------
int __cdecl sub_74E6D(unsigned int a1, int a2, int a3)
{
  memcpy(dword_E127E, a2, a3);
  *(_BYTE *)a1 = -108;
  *(_WORD *)(a1 + 6) = (unsigned int)dword_E127E >> 4;
  *(_WORD *)(a1 + 8) = a3;
  if ( sub_75044(a1) == -1 )
    return -99;
  while ( *(_BYTE *)(a1 + 49) == -1 )
    ;
  return -*(unsigned __int8 *)(a1 + 49);
}
// 99DBD: using guessed type _DWORD __cdecl memcpy(_DWORD, _DWORD, _DWORD);
// E127E: using guessed type int dword_E127E;

//----- (00074EF1) --------------------------------------------------------
int __cdecl sub_74EF1(unsigned int a1, int a2, unsigned int a3)
{
  unsigned int v5; // [esp+4h] [ebp-Ch]
  int v6; // [esp+8h] [ebp-8h]
  __int16 v7; // [esp+Ch] [ebp-4h]

  v6 = a2;
  v5 = 0;
  while ( 1 )
  {
    if ( a3 >> 11 <= v5 )
      return sub_74E6D(a1, v6, a3 & 0x7FF);
    v7 = sub_74E6D(a1, v6, 2048);
    if ( v7 )
      break;
    ++v5;
    v6 += 2048;
  }
  return v7;
}

//----- (00074F76) --------------------------------------------------------
__int16 sub_74F76()
{
  __int16 result; // ax
  __int16 i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < word_E127A; ++i )
  {
    byte_E12CE[i] = sub_74FE1(i);
    if ( byte_E12CE[i] )
      word_E1278 = i + 1;
  }
  result = word_E127A;
  word_E1278 = word_E127A;
  return result;
}
// E1278: using guessed type __int16 word_E1278;
// E127A: using guessed type __int16 word_E127A;

//----- (00074FE1) --------------------------------------------------------
signed int __cdecl sub_74FE1(__int16 a1)
{
  signed int v2; // [esp+0h] [ebp-4h]

  if ( a1 == word_E1276 )
    v2 = 2;
  else
    v2 = *(_BYTE *)(dword_E12AE[a1] + 2) && !*(_BYTE *)(dword_E12AE[a1] + 49);
  return v2;
}
// E1276: using guessed type __int16 word_E1276;

//----- (00075044) --------------------------------------------------------
int __cdecl sub_75044(unsigned int a1)
{
  char v2; // [esp+0h] [ebp-7Ch]
  int v3; // [esp+10h] [ebp-6Ch]
  int v4; // [esp+1Ch] [ebp-60h]
  __int16 v5; // [esp+22h] [ebp-5Ah]
  __int16 v6; // [esp+24h] [ebp-58h]
  int v7; // [esp+34h] [ebp-48h]
  int v8; // [esp+38h] [ebp-44h]
  char *v9; // [esp+48h] [ebp-34h]
  char v10; // [esp+50h] [ebp-2Ch]
  int v11; // [esp+68h] [ebp-14h]
  char v12; // [esp+6Ch] [ebp-10h]
  int v13; // [esp+78h] [ebp-4h]

  *(_BYTE *)(a1 + 49) = 0;
  memset(&v2, 0, 50);
  v6 = a1 >> 4;
  v5 = a1 >> 4;
  v3 = 0;
  v4 = 256;
  memset(&v7, 0, 28);
  memset(&v10, 0, 28);
  memset(&v12, 0, 12);
  segread(&v12);
  v7 = 768;
  v8 = 92;
  v9 = &v2;
  int386x(49, &v7, &v10, &v12);
  if ( v11 )
    v13 = -1;
  else
    v13 = 0;
  return v13;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99DE6: using guessed type _DWORD __cdecl segread(_DWORD);
// 99E10: using guessed type _DWORD __cdecl int386x(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00075110) --------------------------------------------------------
int **__cdecl sub_75110(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5)
{
  return sub_8F100((int *)a1, a2, a3 >> 8, 127 * a4 / 0xFFFF, a5 + 100, 0, 3u);
}

//----- (00075160) --------------------------------------------------------
int **__cdecl sub_75160(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5)
{
  return sub_8F100((int *)a1, a2, a3 >> 8, 127 * a4 / 0xFFFF, a5 + 100, 0, 2u);
}

//----- (000751B0) --------------------------------------------------------
int **__cdecl sub_751B0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5)
{
  return sub_8F100((int *)a1, a2, a3 >> 8, 127 * a4 / 0xFFFF, a5 + 100, 0, 1u);
}

//----- (00075200) --------------------------------------------------------
void __cdecl sub_75200(__int16 a1)
{
  char *v1; // esi
  int v2; // esi

  if ( !byte_E3766 )
    sub_8CACD();
  sub_9951B(0);
  qmemcpy(&loc_A0000, (const void *)dword_180628, 0x10000u);
  v1 = (char *)(dword_180628 + 0x10000);
  sub_9951B(1);
  qmemcpy(&loc_A0000, v1, 0x10000u);
  v1 += 0x10000;
  sub_9951B(2);
  qmemcpy(&loc_A0000, v1, 0x10000u);
  v2 = (int)(v1 + 0x10000);
  sub_9951B(3);
  if ( a1 == 400 )
  {
    qmemcpy(&loc_A0000, (const void *)v2, 0xE800u);
    sub_8CB1F();
  }
  else
  {
    qmemcpy(&loc_A0000, (const void *)v2, 0x10000u);
    sub_9951B(4);
    qmemcpy(&loc_A0000, (const void *)(v2 + 0x10000), 0xB000u);
    if ( !byte_E3766 )
      sub_8CB1F();
  }
}
// E3766: using guessed type char byte_E3766;
// 180628: using guessed type int dword_180628;

//----- (000752C0) --------------------------------------------------------
#error "753C1: positive sp value has been found (funcsize=79)"

//----- (000753D0) --------------------------------------------------------
int sub_753D0()
{
  __int16 v0; // ax
  int v1; // edx
  int v2; // eax
  __int16 v3; // dx

  v0 = 0;
  while ( v0 < 128 )
  {
    v1 = v0++;
    byte_180664[v1] = 0;
  }
  v2 = dos_getvect(9);
  word_17D434 = v3;
  dword_17D430 = v2;
  return dos_setvect(9, sub_752C0, (unsigned __int16)__CS__);
}
// 752C0: using guessed type int sub_752C0();
// 99BA7: using guessed type _DWORD __cdecl dos_getvect(_DWORD);
// 99BDB: using guessed type _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD);
// 17D430: using guessed type int dword_17D430;
// 17D434: using guessed type __int16 word_17D434;

//----- (00075420) --------------------------------------------------------
int sub_75420()
{
  return dos_setvect(9, dword_17D430, (unsigned __int16)word_17D434);
}
// 99BDB: using guessed type _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD);
// 17D430: using guessed type int dword_17D430;
// 17D434: using guessed type __int16 word_17D434;

//----- (00075440) --------------------------------------------------------
int sub_75440()
{
  signed int v0; // ebx
  int v1; // esi

  v0 = 96;
  do
  {
    v1 = v0 << 8;
    LOWORD(v1) = ((_WORD)v0 << 8) | 0x7F;
    memset(&unk_17D6D4, 0, 50);
    dword_17D6F0 = v1;
    dword_17D6E4 = 0;
    dword_17D6EC = 0;
    dword_17D6E8 = 0;
    sub_75AE0((int)&unk_17D6D4);
    if ( (v0 | 0x7F00) == dword_17D6F0 )
      return v1 & 0xFF00;
    ++v0;
  }
  while ( v0 <= 112 );
  return 0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 17D6E4: using guessed type int dword_17D6E4;
// 17D6E8: using guessed type int dword_17D6E8;
// 17D6EC: using guessed type int dword_17D6EC;
// 17D6F0: using guessed type int dword_17D6F0;

//----- (000754C0) --------------------------------------------------------
int __cdecl sub_754C0(int a1, _DWORD *a2, int a3)
{
  int v3; // eax
  int v4; // ecx
  int i; // eax

  memset(&unk_17D6D4, 0, 50);
  v3 = a1;
  LOBYTE(v3) = a1 | 3;
  dword_17D6EC = 0;
  dword_17D6F0 = v3;
  dword_17D6E8 = 0;
  word_17D6F6 = word_17D708;
  sub_75AE0((int)&unk_17D6D4);
  v4 = dword_17D6C8;
  for ( i = 0; i < dword_17D6EC; *(_BYTE *)(a3 + i - 1) = *(_BYTE *)(v4 + i - 1) )
    ++i;
  *a2 = dword_17D6EC;
  return dword_17D6F0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 17D6C8: using guessed type int dword_17D6C8;
// 17D6E8: using guessed type int dword_17D6E8;
// 17D6EC: using guessed type int dword_17D6EC;
// 17D6F0: using guessed type int dword_17D6F0;
// 17D6F6: using guessed type __int16 word_17D6F6;
// 17D708: using guessed type __int16 word_17D708;

//----- (00075540) --------------------------------------------------------
int __cdecl sub_75540(int a1, int a2)
{
  int v2; // ecx
  signed int v3; // eax
  int v4; // eax

  v2 = dword_17D6C8;
  v3 = 0;
  do
  {
    ++v3;
    *(_BYTE *)(v2 + v3 - 1) = *(_BYTE *)(a2 + v3 - 1);
  }
  while ( v3 < 256 );
  memset(&unk_17D6D4, 0, 50);
  v4 = a1;
  LOBYTE(v4) = a1 | 4;
  dword_17D6EC = 0;
  dword_17D6F0 = v4;
  dword_17D6E8 = 0;
  word_17D6F6 = word_17D708;
  sub_75AE0((int)&unk_17D6D4);
  return dword_17D6F0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 17D6C8: using guessed type int dword_17D6C8;
// 17D6E8: using guessed type int dword_17D6E8;
// 17D6EC: using guessed type int dword_17D6EC;
// 17D6F0: using guessed type int dword_17D6F0;
// 17D6F6: using guessed type __int16 word_17D6F6;
// 17D708: using guessed type __int16 word_17D708;

//----- (000755B0) --------------------------------------------------------
int __cdecl sub_755B0(int a1, _DWORD *a2, int a3)
{
  int v3; // eax
  int v4; // ecx
  int i; // eax

  memset(&unk_17D6D4, 0, 50);
  v3 = a1;
  LOBYTE(v3) = a1 | 5;
  dword_17D6EC = 0;
  dword_17D6F0 = v3;
  dword_17D6E8 = 0;
  word_17D6F6 = word_17D708;
  sub_75AE0((int)&unk_17D6D4);
  v4 = dword_17D6C8;
  for ( i = 0; i < dword_17D6EC; *(_BYTE *)(a3 + i - 1) = *(_BYTE *)(v4 + i - 1) )
    ++i;
  *a2 = dword_17D6EC;
  return dword_17D6F0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 17D6C8: using guessed type int dword_17D6C8;
// 17D6E8: using guessed type int dword_17D6E8;
// 17D6EC: using guessed type int dword_17D6EC;
// 17D6F0: using guessed type int dword_17D6F0;
// 17D6F6: using guessed type __int16 word_17D6F6;
// 17D708: using guessed type __int16 word_17D708;

//----- (00075650) --------------------------------------------------------
signed int sub_75650()
{
  signed int result; // eax
  unsigned __int8 *v1; // eax
  signed int v2; // eax
  int v3; // eax
  char v4; // [esp+0h] [ebp-4h]

  memset(&word_17D6CC, 0, 6);
  memset(&word_17D70A, 0, 7);
  dword_17D6C8 = sub_75B80(256, &word_17D708, &word_17D706);
  if ( !dword_17D6C8 )
    return 0;
  v1 = (unsigned __int8 *)getenv(aVipport);
  if ( v1 )
  {
    v2 = sub_99FF0(v1, (unsigned __int8 **)&v4, 16);
    dword_17D6B0 = v2;
    dword_17D6A0 = v2 + 1;
    v3 = sub_75440();
    dword_17D640 = v3;
    if ( v3 )
    {
      if ( sub_754C0(v3, &dword_17D648, (int)byte_17D440) )
      {
        sub_75AB0();
        result = 0;
      }
      else
      {
        dword_17D644 = 0;
        dword_17D6A8 = 0;
        dword_17D698 = 0;
        dword_17D6AC = (int)&unk_17D540;
        while ( dword_17D698 < dword_17D648 )
        {
          dword_17D6A4 = byte_17D440[dword_17D698];
          if ( (unsigned __int8)byte_17D441[dword_17D698] <= 7u )
            JUMPOUT(__CS__, *(&off_75628 + (unsigned __int8)byte_17D441[dword_17D698]));
          dword_17D698 += dword_17D6A4;
        }
        if ( sub_75540(dword_17D640, (int)byte_17D440) )
        {
          sub_75AB0();
          result = 0;
        }
        else
        {
          if ( dword_17D6A8 )
            byte_E12EC = 1;
          if ( dword_17D644 )
            byte_E12ED = 1;
          result = 1;
        }
      }
    }
    else
    {
      sub_75AB0();
      result = 0;
    }
  }
  else
  {
    dword_17D6B0 = 768;
    sub_75AB0();
    result = 0;
  }
  return result;
}
// 75628: using guessed type void *off_75628;
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99E33: using guessed type _DWORD __cdecl getenv(_DWORD);
// 9A050: using guessed type _DWORD __cdecl strcmp(_DWORD, _DWORD);
// E12EC: using guessed type char byte_E12EC;
// E12ED: using guessed type char byte_E12ED;
// 17D640: using guessed type int dword_17D640;
// 17D644: using guessed type int dword_17D644;
// 17D648: using guessed type int dword_17D648;
// 17D698: using guessed type int dword_17D698;
// 17D6A0: using guessed type int dword_17D6A0;
// 17D6A4: using guessed type int dword_17D6A4;
// 17D6A8: using guessed type int dword_17D6A8;
// 17D6AC: using guessed type int dword_17D6AC;
// 17D6B0: using guessed type int dword_17D6B0;
// 17D6B8: using guessed type int dword_17D6B8;
// 17D6BC: using guessed type int dword_17D6BC;
// 17D6C0: using guessed type int dword_17D6C0;
// 17D6C4: using guessed type int dword_17D6C4;
// 17D6C8: using guessed type int dword_17D6C8;
// 17D6CC: using guessed type __int16 word_17D6CC;
// 17D706: using guessed type __int16 word_17D706;
// 17D708: using guessed type __int16 word_17D708;
// 17D70A: using guessed type __int16 word_17D70A;
// 17D711: using guessed type char byte_17D711;

//----- (00075900) --------------------------------------------------------
int sub_75900()
{
  return sub_75AB0();
}

//----- (00075910) --------------------------------------------------------
signed int sub_75910()
{
  signed int result; // eax
  unsigned __int16 v1; // ax
  unsigned __int8 v2; // al

  if ( sub_755B0(dword_17D640, &dword_17D648, (int)&unk_17D540) )
  {
    sub_75AB0();
    result = 0;
  }
  else
  {
    if ( byte_E12EC )
    {
      __GS__ = *(_WORD *)&byte_17D674[4];
      word_17D6CC = __readgsword(*(unsigned int *)byte_17D674);
      v1 = __readgsword(*(_DWORD *)byte_17D674 + 4);
      word_17D6CE = __readgsword(*(_DWORD *)byte_17D674 + 2);
      word_17D6D0 = v1;
    }
    if ( byte_E12ED )
    {
      __GS__ = *(_WORD *)&byte_17D650[4];
      word_17D70A = __readgsword(*(unsigned int *)byte_17D650);
      word_17D70C = __readgsword(*(_DWORD *)byte_17D650 + 2);
      v2 = __readgsbyte(*(_DWORD *)byte_17D650 + 6);
      word_17D70E = __readgsword(*(_DWORD *)byte_17D650 + 4);
      byte_17D710 = v2;
    }
    result = 1;
  }
  return result;
}
// E12EC: using guessed type char byte_E12EC;
// E12ED: using guessed type char byte_E12ED;
// 17D640: using guessed type int dword_17D640;
// 17D648: using guessed type int dword_17D648;
// 17D6CC: using guessed type __int16 word_17D6CC;
// 17D6CE: using guessed type __int16 word_17D6CE;
// 17D6D0: using guessed type __int16 word_17D6D0;
// 17D70A: using guessed type __int16 word_17D70A;
// 17D70C: using guessed type __int16 word_17D70C;
// 17D70E: using guessed type __int16 word_17D70E;
// 17D710: using guessed type char byte_17D710;

//----- (000759B0) --------------------------------------------------------
int sub_759B0()
{
  int result; // eax
  __int16 v1; // [esp+0h] [ebp-1Ch]
  unsigned __int16 v2; // [esp+4h] [ebp-18h]

  if ( byte_E12EC )
  {
    memset(&v1, 0, 28);
    v1 = 24584;
    v2 = _byteswap_ushort(*(_WORD *)(dword_17D6C4 + 2));
    result = int386(51, &v1, &v1);
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E12EC: using guessed type char byte_E12EC;
// 17D6C4: using guessed type int dword_17D6C4;

//----- (00075A10) --------------------------------------------------------
unsigned __int8 __cdecl sub_75A10(int a1, unsigned __int8 *a2)
{
  unsigned __int8 v2; // al
  unsigned __int8 *v3; // ebx
  char v4; // dl
  unsigned __int8 v5; // al
  signed int v6; // ecx
  unsigned __int8 v7; // al
  unsigned __int8 *v8; // ebx
  unsigned __int8 v9; // al
  unsigned __int8 result; // al

  __outbyte(dword_17D6B0, 7u);
  __outbyte(dword_17D6A0, 0xFFu);
  __outbyte(dword_17D6B0, 6u);
  v2 = __inbyte(dword_17D6A0);
  v3 = a2;
  v4 = v2 & 0xF8;
  if ( a1 )
  {
    if ( a1 == 1 )
      v5 = v4 | 1;
    else
      v5 = (v2 | 4) & 0xFE;
  }
  else
  {
    v5 = v4 | 3;
  }
  __outbyte(dword_17D6A0, v5);
  __outbyte(dword_17D6B0, 9u);
  __outbyte(dword_17D6A0, 0);
  v6 = 0;
  __outbyte(dword_17D6B0, 0xAu);
  do
  {
    v7 = *v3;
    v8 = v3 + 1;
    __outbyte(dword_17D6A0, v7);
    v9 = *v8++;
    __outbyte(dword_17D6A0, v9);
    ++v6;
    result = *v8;
    v3 = v8 + 1;
    __outbyte(dword_17D6A0, result);
  }
  while ( v6 < 256 );
  return result;
}
// 17D6A0: using guessed type int dword_17D6A0;
// 17D6B0: using guessed type int dword_17D6B0;

//----- (00075AB0) --------------------------------------------------------
int sub_75AB0()
{
  int result; // eax

  if ( dword_17D6C8 )
  {
    result = sub_75B50(word_17D706);
    dword_17D6C8 = 0;
  }
  return result;
}
// 17D6C8: using guessed type int dword_17D6C8;
// 17D706: using guessed type __int16 word_17D706;

//----- (00075AE0) --------------------------------------------------------
int __cdecl sub_75AE0(int a1)
{
  int v2; // [esp+0h] [ebp-28h]
  int v3; // [esp+4h] [ebp-24h]
  int v4; // [esp+8h] [ebp-20h]
  int v5; // [esp+14h] [ebp-14h]
  __int16 v6; // [esp+1Ch] [ebp-Ch]

  memset(&v6, 0, 12);
  memset(&v2, 0, 28);
  v4 = 0;
  v5 = a1;
  v2 = 768;
  v3 = 51;
  v6 = __DS__;
  return int386x(49, &v2, &v2, &v6);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99E10: using guessed type _DWORD __cdecl int386x(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00075B50) --------------------------------------------------------
int __cdecl sub_75B50(__int16 a1)
{
  int v2; // [esp+0h] [ebp-1Ch]
  int v3; // [esp+Ch] [ebp-10h]

  v3 = a1;
  v2 = 257;
  return int386(49, &v2, &v2);
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (00075B80) --------------------------------------------------------
int __cdecl sub_75B80(int a1, _WORD *a2, _WORD *a3)
{
  int v3; // ebx
  int v5; // [esp+0h] [ebp-28h]
  unsigned int v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+18h] [ebp-10h]
  char v9; // [esp+1Ch] [ebp-Ch]

  *a2 = 0;
  *a3 = 0;
  segread(&v9);
  v3 = 0;
  v6 = (unsigned int)(a1 + 15) >> 4;
  v5 = 256;
  int386(49, &v5, &v5);
  if ( !v8 )
  {
    *a2 = v5;
    *a3 = v7;
    v3 = 16 * (signed __int16)*a2;
  }
  return v3;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 99DE6: using guessed type _DWORD __cdecl segread(_DWORD);

//----- (00075C50) --------------------------------------------------------
void sub_75C50()
{
  __outbyte(0x302u, 2u);
  __outbyte(0x303u, 1u);
  memset(dword_180628, 0, dword_180624 * dword_18062C);
  if ( word_180660 & 1 )
    sub_90478();
  else
    sub_75200(480);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 180624: using guessed type int dword_180624;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (00075CB0) --------------------------------------------------------
void sub_75CB0()
{
  if ( word_E12FE && sub_473E0() )
  {
    word_17DB5A = 1;
  }
  else if ( word_17DB5C && (byte_1806E4 || word_180746 || word_180744) )
  {
    word_17DB5A = 1;
  }
  else
  {
    while ( dword_17DB54 < (unsigned int)dword_E3844 )
    {
      if ( word_E12FE && sub_473E0() )
      {
        word_17DB5A = 1;
        return;
      }
      if ( word_17DB5C && (byte_1806E4 || word_180746 || word_180744) )
      {
        word_17DB5A = 1;
        return;
      }
    }
    dword_17DB54 = 0;
  }
}
// E12FE: using guessed type __int16 word_E12FE;
// E3844: using guessed type int dword_E3844;
// 17DB54: using guessed type int dword_17DB54;
// 17DB5A: using guessed type __int16 word_17DB5A;
// 17DB5C: using guessed type __int16 word_17DB5C;
// 1806E4: using guessed type char byte_1806E4;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;

//----- (00075D70) --------------------------------------------------------
unsigned int __cdecl sub_75D70(void *a1, unsigned int a2)
{
  unsigned int result; // eax

  if ( a1 )
  {
    result = a2;
    qmemcpy(a1, (const void *)dword_17DB50, a2);
  }
  dword_17DB50 += a2;
  return result;
}
// 17DB50: using guessed type int dword_17DB50;

//----- (00075DB0) --------------------------------------------------------
int sub_75DB0()
{
  int result; // eax

  dword_17D730 = dword_E1300;
  sub_988A7(dword_17DB38, (int)&dword_17D720, 16);
  while ( word_17D724 != -3590 )
    printf(aErrorUnknownFr);
  sub_988A7(dword_17DB38, dword_E9C38, dword_17D720 - 16);
  result = dword_17D720;
  dword_E1300 += dword_17D720;
  return result;
}
// E1300: using guessed type int dword_E1300;
// E9C38: using guessed type int dword_E9C38;
// 17D720: using guessed type int dword_17D720;
// 17D724: using guessed type __int16 word_17D724;
// 17D730: using guessed type int dword_17D730;
// 17DB38: using guessed type int dword_17DB38;

//----- (00075E70) --------------------------------------------------------
void __fastcall sub_75E70(__int16 a1)
{
  int v1; // eax
  unsigned int v2; // ebx
  char *v3; // esi
  char *v4; // edi
  char v5; // al
  char v6; // al
  char *v7; // esi
  char *v8; // esi
  char *v9; // edi
  char v10; // al
  char v11; // al
  char *v12; // esi
  char *v13; // edi
  char v14; // al
  char v15; // al
  char *v16; // edi
  char v17; // al
  char v18; // al
  char v19; // al
  int v20; // [esp+0h] [ebp-10h]
  int v21; // [esp+4h] [ebp-Ch]
  int v22; // [esp+8h] [ebp-8h]
  char v23; // [esp+Ch] [ebp-4h]

  HIBYTE(a1) = 0;
  v23 = 0;
  dword_17DB50 = dword_E9C38;
  byte_17D738[0] = 0;
  if ( word_17D724 == -3840 )
  {
    sub_75D70(0, dword_17D720 - 16);
    v1 = sub_75DB0();
    a1 = sub_75E70(v1);
  }
  else if ( word_17D724 == -3590 )
  {
    v2 = 0;
    while ( 1 )
    {
      a1 = word_17D726;
      if ( v2 >= (unsigned __int16)word_17D726 )
        break;
      v22 = dword_17DB50;
      sub_75D70(&v20, 6u);
      switch ( (_WORD)v21 )
      {
        case 4:
          v3 = aColour256;
          sub_76260();
          v4 = &byte_17D738[strlen(byte_17D738)];
          do
          {
            v5 = *v3;
            *v4 = *v3;
            if ( !v5 )
              break;
            v6 = v3[1];
            v3 += 2;
            v4[1] = v6;
            v4 += 2;
          }
          while ( v6 );
          v23 = 1;
          break;
        case 7:
          v7 = aSs2;
          sub_76300();
          goto LABEL_23;
        case 0xB:
          sub_76260();
          v8 = aColour;
          v9 = &byte_17D738[strlen(byte_17D738)];
          do
          {
            v10 = *v8;
            *v9 = *v8;
            if ( !v10 )
              break;
            v11 = v8[1];
            v8 += 2;
            v9[1] = v11;
            v9 += 2;
          }
          while ( v11 );
          v23 = 1;
          break;
        case 0xC:
          v7 = aLc;
          sub_76430();
          goto LABEL_23;
        case 0xD:
          memset(dword_E12F4, 0, (unsigned __int16)word_17DB48 * (unsigned __int16)word_17DB4A);
          v7 = aBlack;
          goto LABEL_23;
        case 0xF:
          v7 = aBrun;
          sub_76540();
          goto LABEL_23;
        case 0x10:
          sub_75D70((void *)dword_E12F4, (unsigned __int16)word_17DB4A * (unsigned __int16)word_17DB48);
          v12 = aCopy;
          v13 = &byte_17D738[strlen(byte_17D738)];
          do
          {
            v14 = *v12;
            *v13 = *v12;
            if ( !v14 )
              break;
            v15 = v12[1];
            v12 += 2;
            v13[1] = v15;
            v13 += 2;
          }
          while ( v15 );
          v20 = (unsigned __int16)word_17DB4A * (unsigned __int16)word_17DB48;
          break;
        case 0x12:
          sub_75D70(0, v20 - 6);
          v7 = aPstamp;
LABEL_23:
          v16 = &byte_17D738[strlen(byte_17D738)];
          do
          {
            v17 = *v7;
            *v16 = *v7;
            if ( !v17 )
              break;
            v18 = v7[1];
            v7 += 2;
            v16[1] = v18;
            v16 += 2;
          }
          while ( v18 );
          break;
        default:
          break;
      }
      ++v2;
      dword_17DB50 = v20 + v22;
    }
  }
  if ( dword_17DB3C )
    dword_17DB3C(a1);
  sub_75CB0();
  if ( v23 )
  {
    sub_9A0FC();
    if ( word_E12FC )
    {
      sub_41A90((unsigned __int8 *)&unk_17D838);
      v19 = sub_5BE80((unsigned __int8 *)&unk_17D838, 0x3Fu, 0x3Fu, 0x3Fu);
      sub_2EC90(v19);
    }
  }
  if ( byte_D41C1 )
  {
    dword_180628 += 9920;
    sub_90478();
    dword_180628 -= 9920;
  }
  else
  {
    sub_90478();
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41C1: using guessed type char byte_D41C1;
// E12F4: using guessed type int dword_E12F4;
// E12FC: using guessed type __int16 word_E12FC;
// E9C38: using guessed type int dword_E9C38;
// 17D720: using guessed type int dword_17D720;
// 17D724: using guessed type __int16 word_17D724;
// 17D726: using guessed type __int16 word_17D726;
// 17DB3C: using guessed type int (__fastcall *dword_17DB3C)(_DWORD);
// 17DB48: using guessed type __int16 word_17DB48;
// 17DB4A: using guessed type __int16 word_17DB4A;
// 17DB50: using guessed type int dword_17DB50;
// 180628: using guessed type int dword_180628;

//----- (00076160) --------------------------------------------------------
int __cdecl sub_76160(__int16 a1, __int16 a2, int a3)
{
  int result; // eax
  __int16 v4; // ax

  word_E12FC = a2;
  word_D4004 = 0;
  word_17DB58 = 0;
  word_17DB60 = 0;
  dword_E12F4 = dword_180628;
  result = sub_98817((int)&unk_E3848, 512);
  dword_17DB38 = result;
  if ( result >= 0 )
  {
    sub_988A7(result, (int)&unk_17DB40, 12);
    word_180744 = 0;
    word_180746 = 0;
    dword_E1300 += 12;
    byte_1806E4 = 0;
    word_17DB5A = 0;
    sub_473B0();
    word_17DB5C = a1;
    do
    {
      if ( word_17DB5A )
        break;
      if ( word_17DB60 >= (unsigned __int16)word_17DB46 - 1 )
        break;
      sub_1B280(a3);
      v4 = sub_75DB0();
      sub_75E70(v4);
      ++word_17DB60;
    }
    while ( byte_1806E4 != 1 );
    result = sub_98882(dword_17DB38);
  }
  return result;
}
// D4004: using guessed type __int16 word_D4004;
// E12F4: using guessed type int dword_E12F4;
// E12FC: using guessed type __int16 word_E12FC;
// E1300: using guessed type int dword_E1300;
// 17DB38: using guessed type int dword_17DB38;
// 17DB46: using guessed type __int16 word_17DB46;
// 17DB58: using guessed type __int16 word_17DB58;
// 17DB5A: using guessed type __int16 word_17DB5A;
// 17DB5C: using guessed type __int16 word_17DB5C;
// 17DB60: using guessed type __int16 word_17DB60;
// 180628: using guessed type int dword_180628;
// 1806E4: using guessed type char byte_1806E4;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;

//----- (00076260) --------------------------------------------------------
unsigned int sub_76260()
{
  char *v0; // ebx
  int v1; // esi
  unsigned int result; // eax
  unsigned __int16 v3; // di
  unsigned __int16 v4; // [esp+0h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-8h]
  unsigned __int8 v6; // [esp+8h] [ebp-4h]

  v0 = (char *)&unk_17D838;
  v1 = 0;
  result = sub_75D70(&v4, 2u);
  if ( v4 > 0u )
  {
    do
    {
      sub_75D70(&v6, 1u);
      v0 += 3 * v6;
      v5 = 0;
      result = sub_75D70(&v5, 1u);
      if ( !(_WORD)v5 )
        v5 = 256;
      v3 = 0;
      while ( v3 < (unsigned __int16)v5 )
      {
        ++v3;
        result = sub_75D70(v0, 3u);
        v0 += 3;
      }
      ++v1;
    }
    while ( (unsigned __int16)v1 < v4 );
  }
  return result;
}

//----- (00076300) --------------------------------------------------------
__int16 sub_76300()
{
  int v0; // edi
  __int16 result; // ax
  int v2; // esi
  char *v3; // ebx
  unsigned __int16 v4; // cx
  unsigned __int16 v5; // [esp+0h] [ebp-1Ch]
  int v6; // [esp+4h] [ebp-18h]
  int i; // [esp+8h] [ebp-14h]
  int v8; // [esp+Ch] [ebp-10h]
  int v9; // [esp+10h] [ebp-Ch]
  char v10; // [esp+14h] [ebp-8h]
  unsigned __int8 v11; // [esp+18h] [ebp-4h]

  v0 = 0;
  result = sub_75D70(&v5, 2u);
  v2 = dword_E12F4;
  if ( v5 > 0u )
  {
    do
    {
      v3 = (char *)v2;
      sub_75D70(&v9, 2u);
      if ( (v9 & 0x8000) == 0 )
      {
        v6 = v9;
        for ( i = 0; (unsigned __int16)i < (unsigned __int16)v6; ++i )
        {
          sub_75D70(&v11, 1u);
          v3 += v11;
          sub_75D70(&v10, 1u);
          if ( v10 >= 0 )
          {
            if ( v10 > 0 )
            {
              sub_75D70(v3, 2 * v10);
              v3 += 2 * v10;
            }
          }
          else
          {
            sub_75D70(&v8, 2u);
            v4 = 0;
            while ( abs(v10) > (signed int)v4 )
            {
              v3 += 2;
              ++v4;
              *((_WORD *)v3 - 1) = v8;
            }
          }
        }
      }
      else if ( v9 & 0x4000 )
      {
        --v0;
        v2 += (unsigned __int16)word_17DB48 * (abs((signed __int16)v9) - 1);
      }
      else
      {
        *(_BYTE *)(v2 + (unsigned __int16)word_17DB48 - 1) = v9;
      }
      result = word_17DB48;
      ++v0;
      v2 += (unsigned __int16)word_17DB48;
    }
    while ( (unsigned __int16)v0 < v5 );
  }
  return result;
}
// E12F4: using guessed type int dword_E12F4;
// 17DB48: using guessed type __int16 word_17DB48;

//----- (00076430) --------------------------------------------------------
int sub_76430()
{
  int v0; // edi
  int result; // eax
  char *v2; // ebx
  unsigned __int16 v3; // si
  int v4; // eax
  int v5; // [esp+0h] [ebp-18h]
  unsigned __int16 v6; // [esp+4h] [ebp-14h]
  unsigned __int8 v7; // [esp+8h] [ebp-10h]
  char v8; // [esp+Ch] [ebp-Ch]
  unsigned __int8 v9; // [esp+10h] [ebp-8h]
  unsigned __int8 v10; // [esp+14h] [ebp-4h]

  sub_75D70(&v6, 2u);
  v0 = (unsigned __int16)word_17DB48 * v6 + dword_E12F4;
  sub_75D70(&v6, 2u);
  v5 = 0;
  result = 0;
  if ( v6 > 0u )
  {
    do
    {
      v2 = (char *)v0;
      v3 = 0;
      sub_75D70(&v9, 1u);
      while ( v3 < (signed int)v9 )
      {
        sub_75D70(&v7, 1u);
        v2 += v7;
        sub_75D70(&v8, 1u);
        if ( v8 >= 0 )
        {
          if ( v8 <= 0 )
            goto LABEL_8;
          sub_75D70(v2, v8);
          v4 = v8;
        }
        else
        {
          sub_75D70(&v10, 1u);
          memset(v2, v10, abs(v8));
          v4 = abs(v8);
        }
        v2 += v4;
LABEL_8:
        ++v3;
      }
      ++v5;
      v0 += (unsigned __int16)word_17DB48;
      result = v5;
    }
    while ( (unsigned __int16)v5 < v6 );
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// E12F4: using guessed type int dword_E12F4;
// 17DB48: using guessed type __int16 word_17DB48;

//----- (00076540) --------------------------------------------------------
int sub_76540()
{
  int v0; // esi
  char *v1; // ebx
  unsigned __int16 v2; // di
  int result; // eax
  int v4; // [esp+0h] [ebp-Ch]
  unsigned __int8 v5; // [esp+4h] [ebp-8h]
  char v6; // [esp+8h] [ebp-4h]

  v0 = dword_E12F4;
  v4 = 0;
  while ( 1 )
  {
    result = v4;
    if ( (unsigned __int16)v4 >= (unsigned __int16)word_17DB4A )
      break;
    v1 = (char *)v0;
    v2 = 0;
    sub_75D70(0, 1u);
    while ( v2 < (unsigned __int16)word_17DB48 )
    {
      sub_75D70(&v6, 1u);
      if ( v6 >= 0 )
      {
        if ( v6 > 0 )
        {
          sub_75D70(&v5, 1u);
          memset(v1, v5, v6);
        }
      }
      else
      {
        v6 = abs(v6);
        sub_75D70(v1, v6);
      }
      v2 += v6;
      v1 += v6;
    }
    ++v4;
    v0 += (unsigned __int16)word_17DB48;
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// E12F4: using guessed type int dword_E12F4;
// 17DB48: using guessed type __int16 word_17DB48;
// 17DB4A: using guessed type __int16 word_17DB4A;

//----- (000765FC) --------------------------------------------------------
void __cdecl sub_765FC(__int16 a1, __int16 a2)
{
  word_E130E = a1;
  word_E1310 = a2;
}
// E130E: using guessed type __int16 word_E130E;
// E1310: using guessed type __int16 word_E1310;

//----- (00076619) --------------------------------------------------------
int __cdecl sub_76619(int a1, int a2)
{
  dword_E1308 = a1;
  dword_E1304 = a2;
  while ( 1 )
  {
    qmemcpy(&word_E1312, (const void *)dword_E1308, 4u);
    dword_E1308 += 4;
    qmemcpy(&word_E130C, (const void *)dword_E1308, sizeof(word_E130C));
    dword_E1308 += 2;
    if ( word_E130C != -20718 )
      break;
    sub_76752();
  }
  if ( word_E130C != -3590 )
    return 0;
  sub_766A4();
  return dword_E1308;
}
// E1304: using guessed type int dword_E1304;
// E1308: using guessed type int dword_E1308;
// E130C: using guessed type __int16 word_E130C;
// E1312: using guessed type __int16 word_E1312;

//----- (000766A4) --------------------------------------------------------
__int16 sub_766A4()
{
  __int16 result; // ax

  qmemcpy(&word_E1316, (const void *)dword_E1308, sizeof(word_E1316));
  dword_E1308 += 2;
  dword_E1308 += 8;
  while ( word_E1316 )
  {
    --word_E1316;
    qmemcpy(&word_E1312, (const void *)dword_E1308, 4u);
    dword_E1308 += 4;
    qmemcpy(&word_E130C, (const void *)dword_E1308, sizeof(word_E130C));
    dword_E1308 += 2;
    switch ( word_E130C )
    {
      case 7:
        result = sub_7678D();
        break;
      case 4:
        result = sub_7677C();
        break;
      case 15:
        result = sub_76840();
        break;
      default:
        result = sub_7677C();
        break;
    }
  }
  return result;
}
// E1308: using guessed type int dword_E1308;
// E130C: using guessed type __int16 word_E130C;
// E1312: using guessed type __int16 word_E1312;
// E1316: using guessed type __int16 word_E1316;

//----- (00076752) --------------------------------------------------------
__int16 sub_76752()
{
  __int16 result; // ax

  word_E130E = *(_WORD *)(dword_E1308 + 2);
  result = *(_WORD *)(dword_E1308 + 4);
  word_E1310 = *(_WORD *)(dword_E1308 + 4);
  dword_E1308 += 6;
  return result;
}
// E1308: using guessed type int dword_E1308;
// E130E: using guessed type __int16 word_E130E;
// E1310: using guessed type __int16 word_E1310;

//----- (0007677C) --------------------------------------------------------
int sub_7677C()
{
  int result; // eax

  result = (unsigned __int16)word_E1312 - 6;
  dword_E1308 += result;
  return result;
}
// E1308: using guessed type int dword_E1308;
// E1312: using guessed type __int16 word_E1312;

//----- (0007678D) --------------------------------------------------------
__int16 sub_7678D()
{
  _WORD *v0; // edi
  _WORD *v1; // esi
  __int16 result; // ax
  _BYTE *v3; // edi
  _BYTE *v4; // esi
  char v5; // dl
  _WORD *v6; // [esp-4h] [ebp-14h]
  _WORD *v7; // [esp+0h] [ebp-10h]
  __int16 i; // [esp+6h] [ebp-Ah]
  __int16 v9; // [esp+8h] [ebp-8h]
  int v10; // [esp+Ch] [ebp-4h]

  v10 = (unsigned __int16)word_E130E;
  v0 = (_WORD *)dword_E1304;
  v1 = (_WORD *)(dword_E1308 + 2);
  v9 = *(_WORD *)dword_E1308;
  do
  {
    while ( 1 )
    {
      result = *v1;
      ++v1;
      v7 = v0;
      if ( result >= 0 )
        goto LABEL_10;
      if ( !(result & 0x4000) )
        break;
      v0 = (_WORD *)((char *)v0 + v10 * -result);
    }
    v6 = v0;
    v3 = (char *)v0 + v10 - 1;
    if ( byte_E2A20 == 1 )
    {
      if ( (_BYTE)result )
        *v3 = result;
    }
    else
    {
      *v3 = result;
    }
    v0 = v6;
LABEL_10:
    for ( i = result; i; --i )
    {
      while ( 1 )
      {
        LOBYTE(result) = *(_BYTE *)v1;
        v4 = (char *)v1 + 1;
        result = (unsigned __int8)result;
        v0 = (_WORD *)((char *)v0 + (unsigned __int8)result);
        v5 = *v4;
        v1 = v4 + 1;
        if ( v5 > 0 )
          break;
        result = *v1;
        ++v1;
        do
        {
          *v0 = result;
          ++v0;
          ++v5;
        }
        while ( v5 );
        if ( !--i )
          goto LABEL_18;
      }
      do
      {
        *v0 = *v1;
        ++v1;
        ++v0;
        --v5;
      }
      while ( v5 );
    }
LABEL_18:
    v0 = (_WORD *)((char *)v7 + v10);
    --v9;
  }
  while ( v9 );
  dword_E1308 = (int)v1;
  return result;
}
// E1304: using guessed type int dword_E1304;
// E1308: using guessed type int dword_E1308;
// E130E: using guessed type __int16 word_E130E;
// E1310: using guessed type __int16 word_E1310;
// E1312: using guessed type __int16 word_E1312;
// E2A20: using guessed type char byte_E2A20;

//----- (00076840) --------------------------------------------------------
int sub_76840()
{
  _BYTE *v0; // edi
  char *v1; // esi
  __int16 v2; // bx
  __int16 v3; // cx
  unsigned __int8 v4; // dl
  __int16 v5; // ax
  char v6; // dh
  char v7; // dh
  int result; // eax
  int v9; // [esp-8h] [ebp-Ch]
  int v10; // [esp-4h] [ebp-8h]
  __int16 v11; // [esp+2h] [ebp-2h]

  v11 = word_E130E;
  v0 = (_BYTE *)dword_E1304;
  v1 = (char *)dword_E1308;
  v10 = (unsigned __int16)word_E1312 - 6;
  v9 = dword_E1308;
  v2 = word_E1310;
  do
  {
    ++v1;
    v3 = v11;
    do
    {
      v4 = *v1++;
      if ( (char)v4 > 0 )
      {
        v3 -= v4;
      }
      else
      {
        HIBYTE(v5) = -1;
        LOBYTE(v5) = v4;
        v3 += v5;
      }
      if ( (char)v4 > 0 )
      {
        v7 = *v1++;
        do
        {
          if ( byte_E2A20 == 1 )
          {
            if ( v7 )
              *v0 = v7;
          }
          else
          {
            *v0 = v7;
          }
          ++v0;
          --v4;
        }
        while ( v4 );
      }
      else
      {
        do
        {
          v6 = *v1++;
          if ( byte_E2A20 == 1 )
          {
            if ( v6 )
              *v0 = v6;
          }
          else
          {
            *v0 = v6;
          }
          ++v0;
          ++v4;
        }
        while ( v4 );
      }
    }
    while ( v3 );
    --v2;
  }
  while ( v2 );
  result = v10;
  dword_E1308 = v10 + v9;
  return result;
}
// E1304: using guessed type int dword_E1304;
// E1308: using guessed type int dword_E1308;
// E130E: using guessed type __int16 word_E130E;
// E1310: using guessed type __int16 word_E1310;
// E1312: using guessed type __int16 word_E1312;
// E2A20: using guessed type char byte_E2A20;

//----- (00076930) --------------------------------------------------------
signed int __fastcall sub_76930(int a1, int a2, signed __int16 *a3)
{
  int v3; // eax
  int v4; // edx

  byte_E29DE = word_180660;
  word_E29DC = 0;
  if ( byte_D41AD == 1 || word_E29D8 )
  {
    sub_82670();
    sub_7AC00();
  }
  if ( byte_D41AD == 1 )
  {
    sub_76A40();
    word_E29D8 = 4;
  }
  memset(&dword_17DE38, 0, 613);
  dword_17DEE0 = -1;
  sub_7BEC0();
  sub_6EDB0();
  v3 = sub_81DB0();
  do
  {
    LOWORD(v3) = word_E29D8;
    switch ( word_E29D8 )
    {
      case 0:
        v3 = sub_76A40();
        break;
      case 1:
        sub_76CF0();
        break;
      case 2:
        v3 = _wcpp_1_unwind_leave__131(v3);
        break;
      case 3:
        sub_76D10(0);
        break;
      case 4:
        v3 = sub_76FA0(v3, v4, a3);
        break;
      case 5:
        word_E29DC = 1;
        break;
      case 12:
        sub_779E0(0);
        break;
      default:
        break;
    }
  }
  while ( !word_E29DC );
  sub_7ADE0(byte_E29DE);
  if ( byte_E29E1 )
    byte_E29E1 = 0;
  return sub_81DB0();
}
// 76D00: using guessed type int __fastcall _wcpp_1_unwind_leave__131(_DWORD);
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41AD: using guessed type char byte_D41AD;
// E29D8: using guessed type __int16 word_E29D8;
// E29DC: using guessed type __int16 word_E29DC;
// E29DE: using guessed type char byte_E29DE;
// E29E1: using guessed type char byte_E29E1;
// 17DE38: using guessed type int dword_17DE38;
// 17DEE0: using guessed type int dword_17DEE0;
// 180660: using guessed type __int16 word_180660;

//----- (00076A40) --------------------------------------------------------
int sub_76A40()
{
  int v0; // ebx
  int v1; // edi
  __int16 v2; // si
  int v3; // eax
  int v4; // ebx
  int v5; // edi
  int v6; // esi
  int result; // eax
  char v8; // [esp+0h] [ebp-42h]
  char v9; // [esp+50h] [ebp+Eh]
  char v10; // [esp+A0h] [ebp+5Eh]
  char v11; // [esp+A4h] [ebp+62h]
  int v12; // [esp+B4h] [ebp+72h]
  __int16 v13; // [esp+BEh] [ebp+7Ch]
  int v14; // [esp+C0h] [ebp+7Eh]

  v14 = 0;
  memset(&v8, 0, 80);
  memset(&dword_17DE38, 0, 613);
  dword_17DEE0 = -1;
  memset(&v10, 0, 32);
  sprintf(&v8, aCS_0, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherwConfigD);
  v0 = sub_98817((int)&v8, 512);
  if ( v0 == -1 )
  {
    sub_7AC00();
    sub_779E0(0);
    sub_7ADE0(1);
  }
  else
  {
    sub_988A7(v0, (int)&v14, 4);
    if ( v14 == -9 )
    {
      sub_988A7(v0, (int)&v11, 28);
      v1 = dword_D41A4;
      qmemcpy((void *)dword_D41A4, &v10, 0x14u);
      qmemcpy((void *)(v1 + 20), &v12, 2u);
      qmemcpy(&byte_EB39E, (char *)&v12 + 2, 8u);
      qmemcpy(&byte_EB39E + 8, &v13, 2u);
      sub_98882(v0);
      sub_8E470(*(signed __int16 *)(dword_D41A4 + 6));
      sub_8E410((_DWORD *)*(signed __int16 *)(dword_D41A4 + 8));
      v2 = 0;
      sprintf(
        &v9,
        aCSLDTxt,
        *(unsigned __int8 *)(dword_D41A4 + 182),
        aNetherwLanguag,
        *(signed __int16 *)(dword_D41A4 + 4));
      while ( v2 < 2 )
      {
        *(_BYTE *)(dword_D41A4 + 179) = *(_BYTE *)(dword_D41A4 + 4);
        if ( byte_E29E0 || dword_D41BC )
          sub_83E80(dword_D41BC);
        v3 = sub_98817((int)&v9, 512);
        v4 = v3;
        v5 = v3;
        if ( v3 != -1 )
        {
          v6 = filelength(v3) - 4785;
          dword_D41BC = sub_83CD0(v6);
          if ( dword_D41BC )
          {
            sub_9891E(v4, 4785, 0);
            sub_988A7(v4, dword_D41BC, v6);
          }
          sub_98882(v5);
          sub_5B870((_BYTE *)dword_D41BC, (int)dword_E9C4C, 471);
          break;
        }
        ++v2;
        sprintf(&v9, aLanguageLDTxt, *(unsigned __int8 *)(dword_D41A4 + 179));
      }
    }
    else
    {
      sub_98882(v0);
      sub_7AC00();
      sub_779E0(0);
      sub_7ADE0(1);
    }
  }
  result = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 179) != 2 || !byte_E3798 )
    byte_D41C0 = 1;
  word_E29D8 = 1;
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// D41A4: using guessed type int dword_D41A4;
// D41BC: using guessed type int dword_D41BC;
// D41C0: using guessed type char byte_D41C0;
// E29D8: using guessed type __int16 word_E29D8;
// E29E0: using guessed type char byte_E29E0;
// E3798: using guessed type char byte_E3798;
// EB39E: using guessed type char byte_EB39E;
// 17DE38: using guessed type int dword_17DE38;
// 17DEE0: using guessed type int dword_17DEE0;

//----- (00076CF0) --------------------------------------------------------
void sub_76CF0()
{
  word_E29D8 = 3;
}
// E29D8: using guessed type __int16 word_E29D8;

//----- (00076D10) --------------------------------------------------------
char __cdecl sub_76D10(char a1)
{
  int v1; // eax
  signed int v2; // eax
  signed int v3; // eax

  dword_17DE48 = *(_DWORD *)(dword_D41A4 + 226);
  dword_17DE54 = dword_17DE48 + 301787;
  dword_17DEC0 = dword_17DE48 + 308527;
  dword_17DEC4 = (int)&algn_4BB85[dword_17DE48 + 10];
  sub_7AA70((int)aDataScreensHsc, (char *)(dword_17DE48 + 301787), (int)&unk_164FCD, 860);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC0, (int)&unk_165329, 548);
  sub_7AA70(0, 0, 0, 0);
  if ( word_180660 & 1 )
    sub_98709(dword_17DEC0, dword_17DEC4, dword_17DE54);
  else
    sub_9874D((unsigned int *)dword_17DEC0, dword_17DEC4, dword_17DE54);
  sub_2EB40();
  if ( byte_E3798 && *(_BYTE *)(dword_D41A4 + 179) == 2 )
  {
    byte_D41C1 = 0;
    byte_D41C0 = 0;
  }
  else
  {
    byte_D41C0 = 1;
    byte_D41C1 = 1;
  }
  sub_8CD27(dword_EB394);
  sprintf(&unk_E3848, aIntroIntroDat);
  switch ( a1 )
  {
    case 0:
      sub_83850();
      sub_76160(1, 1, (int)&unk_E17CC);
      v1 = sub_2EB40();
      byte_D41C1 = 0;
      byte_D41C0 = 0;
      while ( sub_9A10A(v1) )
      {
        byte_1806E4 = 0;
        LOBYTE(v1) = sub_7A060();
      }
      j___delay(50);
      sprintf(&unk_E3848, aIntroIntro2Dat);
      goto LABEL_17;
    case 1:
      sub_76160(1, 1, (int)&unk_E17CC);
      break;
    case 2:
      byte_1806E4 = 0;
      byte_D41C1 = 0;
      byte_D41C0 = 0;
      sprintf(&unk_E3848, aIntroIntro2Dat);
LABEL_17:
      sub_76160(1, 1, (int)&unk_E192C);
      break;
  }
  sub_90B27(0, 0x10u, 0);
  sub_8D8F0();
  sub_8E020();
  sub_7B5D0();
  LOBYTE(v2) = 0;
  word_E29D8 = 4;
  byte_D41C0 = 0;
  byte_D41C1 = 0;
  v3 = sub_9A10A(v2);
  if ( v3 )
    LOBYTE(v3) = sub_7A060();
  byte_17DF11 = 0;
  byte_17DF10 = 0;
  if ( !a1 )
    LOBYTE(v3) = sub_7AC00();
  return v3;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 9A122: using guessed type _DWORD __cdecl j___delay(_DWORD);
// D41A4: using guessed type int dword_D41A4;
// D41C0: using guessed type char byte_D41C0;
// D41C1: using guessed type char byte_D41C1;
// E29D8: using guessed type __int16 word_E29D8;
// E3798: using guessed type char byte_E3798;
// EB394: using guessed type int dword_EB394;
// 17DE48: using guessed type int dword_17DE48;
// 17DE54: using guessed type int dword_17DE54;
// 17DEC0: using guessed type int dword_17DEC0;
// 17DEC4: using guessed type int dword_17DEC4;
// 17DF10: using guessed type char byte_17DF10;
// 17DF11: using guessed type char byte_17DF11;
// 180660: using guessed type __int16 word_180660;
// 1806E4: using guessed type char byte_1806E4;

//----- (00076F40) --------------------------------------------------------
#error "76F96: positive sp value has been found (funcsize=32)"

//----- (00076FA0) --------------------------------------------------------
int __fastcall sub_76FA0(int a1, int a2, signed __int16 *a3)
{
  int v3; // eax
  __int16 v4; // dx
  int result; // eax
  int v6; // eax
  int v7; // edx
  int v8; // edx
  int v9; // edx
  unsigned __int16 v10; // di
  int v11; // eax
  unsigned __int16 v12; // si
  int v13; // eax
  int v14; // edx
  int v15; // esi
  int v16; // edx
  int v17; // eax
  char v18; // dh
  __int16 v19; // ax
  int v20; // edx
  int (__cdecl **v21)(int); // eax
  int v22; // edx
  int v23; // edx
  __int16 v24; // [esp+0h] [ebp-24h]
  __int16 v25; // [esp+Ch] [ebp-18h]
  int v26; // [esp+1Ch] [ebp-8h]
  int v27; // [esp+20h] [ebp-4h]

  memset(&v24, 0, 28);
  v24 = 13057;
  v25 = 0;
  int386(33, &v24, &v24);
  sub_86860(word_1803EC);
  sub_84300(0);
  memset(&dword_17DBB8, 0, 16);
  byte_17DBC6 = 2;
  word_17DF04 = -1;
  dword_17DE44 = dword_E9C38;
  sub_6EDB0();
  sub_8E020();
  sub_8E160(4, 0x7Fu);
  sub_75420();
  v3 = dos_getvect(9);
  LOWORD(a3) = 256;
  word_17DE26 = v4;
  dword_17DE22 = v3;
  dos_setvect(9, sub_76F40, (unsigned __int16)__CS__);
  if ( byte_E29E1 || *(_BYTE *)(dword_D41A4 + 22) & 0x10 || (sub_77350(0), !word_E29DC) )
  {
    *(_BYTE *)(dword_D41A4 + 22) &= 0xEFu;
    sub_7A110(word_180660, 4);
    sub_7B5A0();
    sub_8CD27(dword_17DED4 + 234);
    v6 = dword_D41A4;
    byte_17DF13 = *(_BYTE *)(dword_D41A4 + 10);
    LOBYTE(v6) = byte_17DF13;
    dword_17DBB8 = j___clock(v6, v7, 256);
    v26 = j___clock(dword_17DBB8, v8, 256);
    v10 = dword_17DEE4;
    v11 = (unsigned __int8)byte_17DF10;
    v12 = HIWORD(dword_17DEE4);
    v27 = (unsigned __int8)byte_17DF10;
    while ( !word_E29DC )
    {
      v13 = j___clock(v11, v9, (_WORD)a3);
      if ( __PAIR__(v12, v10) == dword_17DEE4
        && (v14 = (unsigned __int8)byte_17DF10, (unsigned __int8)byte_17DF10 == (_WORD)v27) )
      {
        if ( (v13 - v26) / 0x64u > 0x3C )
        {
          v15 = dword_E9C38;
          dword_E9C38 = dword_17DE44;
          sub_83250(SBYTE1(a3));
          dword_E9C38 = v15;
          BYTE1(a3) = (BYTE1(a3) == 1) + 1;
          v12 = HIWORD(dword_17DEE4);
          v10 = dword_17DEE4;
          byte_17DF10 = 0;
          v27 = 0;
          v26 = j___clock(0, v16, (_WORD)a3);
          sub_8E020();
          LOBYTE(a3) = 0;
          sub_8E160(4, 0x7Fu);
        }
      }
      else
      {
        v12 = HIWORD(dword_17DEE4);
        v10 = dword_17DEE4;
        v27 = (unsigned __int8)byte_17DF10;
        v26 = j___clock((unsigned __int8)byte_17DF10, v14, (_WORD)a3);
      }
      if ( byte_17DF10 == 59 )
      {
        v17 = dword_D41A4;
        v18 = *(_BYTE *)(dword_D41A4 + 10);
        *(_BYTE *)(dword_D41A4 + 10) = v18 != 1;
        byte_17DF13 = v18 != 1;
        *(_BYTE *)(v17 + 38402) = 1;
      }
      if ( word_180660 & 1 )
        sub_9A128((const void *)dword_E9C38, (void *)dword_180628, 0xC8u);
      else
        sub_9A144((const void *)dword_E9C38, (void *)dword_180628, 0x1E0u);
      v19 = sub_7C120(185, 232, dword_17DED4 + 396);
      v21 = sub_7AB00(v19, v20, a3, 4u);
      if ( sub_7B250((int)v21, v22, (__int16)a3) )
      {
        v12 = HIWORD(dword_17DEE4);
        v10 = dword_17DEE4;
        LOBYTE(a3) = 0;
        v27 = (unsigned __int8)byte_17DF10;
        v26 = j___clock((unsigned __int8)byte_17DF10, v23, (_WORD)a3);
      }
      if ( (_BYTE)a3 )
      {
        if ( word_180660 & 1 )
          sub_90478();
        else
          sub_75200(480);
      }
      else
      {
        LOBYTE(a3) = 1;
        sub_90B27((char *)dword_17DE38, 0x20u, 0);
      }
      LOBYTE(v11) = sub_7A060();
    }
    sub_41BC0();
    *(_BYTE *)(dword_D41A0 + 8592) = 0;
    dos_setvect(9, dword_17DE22, (unsigned __int16)word_17DE26);
    sub_753D0();
    result = dword_17DE44;
    dword_E9C38 = dword_17DE44;
  }
  else
  {
    sub_41BC0();
    *(_BYTE *)(dword_D41A0 + 8592) = 0;
    dos_setvect(9, dword_17DE22, (unsigned __int16)word_17DE26);
    result = sub_753D0();
  }
  return result;
}
// 76F40: using guessed type int sub_76F40();
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 99BA7: using guessed type _DWORD __cdecl dos_getvect(_DWORD);
// 99BDB: using guessed type _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E29DC: using guessed type __int16 word_E29DC;
// E29E1: using guessed type char byte_E29E1;
// E9C38: using guessed type int dword_E9C38;
// 17DBB8: using guessed type int dword_17DBB8;
// 17DBC6: using guessed type char byte_17DBC6;
// 17DE22: using guessed type int dword_17DE22;
// 17DE26: using guessed type __int16 word_17DE26;
// 17DE38: using guessed type int dword_17DE38;
// 17DE44: using guessed type int dword_17DE44;
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DF04: using guessed type __int16 word_17DF04;
// 17DF10: using guessed type char byte_17DF10;
// 17DF13: using guessed type char byte_17DF13;
// 1803EC: using guessed type __int16 word_1803EC;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (00077350) --------------------------------------------------------
char __cdecl sub_77350(int a1)
{
  unsigned __int16 v1; // bx
  char v2; // cl
  char result; // al
  unsigned __int8 v4; // al
  unsigned __int8 v5; // al
  int v6; // eax
  char v7; // bl

  v1 = 0;
  v2 = *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232);
  word_E29D6 = 0;
  if ( v2 & 2 && *(_WORD *)(dword_D41A4 + 43) == 24 )
    sub_833C0();
  memset(&unk_17DBA8, 0, 16);
  byte_17DBB6 = 2;
  if ( byte_D419C <= -1 )
  {
    byte_17E09D = 0;
    byte_17E083 = 16;
    word_17E06E = 480;
    word_17E080 = 13;
    byte_17E09C = 0;
    byte_17E082 = 13;
    word_17E06C = 0;
    memset(&dword_17DB70, 0, 56);
    if ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) & 2 )
      byte_17DB8F = 4;
    else
      byte_17DB8F = 1;
    sub_7A110(word_180660, 6);
    sub_8CD27(dword_EB394);
    sub_7B5A0();
    sub_90B27(0, 0x10u, 0);
    if ( word_180660 & 1 )
    {
      v4 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, 0);
      sub_72883(v4, (void *)dword_180628, 0xC8u, v4);
    }
    else
    {
      v5 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, 0);
      sub_728A9(v5, (void *)dword_180628, 0x1E0u, v5);
    }
    if ( word_180660 & 1 )
      sub_90478();
    else
      sub_75200(480);
    sub_41A90((unsigned __int8 *)dword_17DE38);
    sub_7DD70();
    word_17DEEC = 0;
    sub_6EDB0();
    sub_8CD27(dword_17DED4 + 1434);
    word_17DB8A = *(_WORD *)(dword_D41A4 + 43);
    while ( !v1 )
    {
      if ( byte_17DF10 == 59 )
      {
        v6 = dword_D41A4;
        v7 = *(_BYTE *)(dword_D41A4 + 10);
        *(_BYTE *)(dword_D41A4 + 10) = v7 != 1;
        byte_17DF13 = v7 != 1;
        *(_BYTE *)(v6 + 38402) = 1;
      }
      v1 = sub_7EAE0(
             (__int16 *)&unk_17DB76,
             (__int16 *)&unk_17DB78,
             (__int16 *)&unk_17DB7E,
             (__int16 *)&unk_17DB80,
             &byte_17DB8F,
             &unk_17DB90);
      if ( word_180660 & 1 )
        sub_90478();
      else
        sub_75200(480);
      sub_7A060();
    }
    sub_86860(word_1803EC);
    *(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) = 0;
    sub_8D8F0();
    word_E29D6 = 0;
    if ( v1 >= 1u )
    {
      if ( v1 <= 1u )
      {
        word_E29DC = 1;
        if ( a1 )
          *(_DWORD *)(a1 + 4) = 0;
      }
      else if ( v1 == 2 && a1 )
      {
        *(_DWORD *)(a1 + 4) = 1;
      }
    }
    sub_8CD27(dword_EB394);
    sub_90B27(0, 0x10u, 0);
    result = 1;
  }
  else
  {
    word_E29DC = 1;
    *(_WORD *)(dword_D41A4 + 43) = byte_D419C;
    if ( a1 )
      *(_DWORD *)(a1 + 4) = 0;
    result = 1;
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D419C: using guessed type char byte_D419C;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E29D6: using guessed type __int16 word_E29D6;
// E29DC: using guessed type __int16 word_E29DC;
// EB394: using guessed type int dword_EB394;
// 17DB70: using guessed type int dword_17DB70;
// 17DB8A: using guessed type __int16 word_17DB8A;
// 17DB8F: using guessed type char byte_17DB8F;
// 17DBB6: using guessed type char byte_17DBB6;
// 17DE38: using guessed type int dword_17DE38;
// 17DED4: using guessed type int dword_17DED4;
// 17DEEC: using guessed type __int16 word_17DEEC;
// 17DF10: using guessed type char byte_17DF10;
// 17DF13: using guessed type char byte_17DF13;
// 17E06C: using guessed type __int16 word_17E06C;
// 17E06E: using guessed type __int16 word_17E06E;
// 17E080: using guessed type __int16 word_17E080;
// 17E082: using guessed type char byte_17E082;
// 17E083: using guessed type char byte_17E083;
// 17E09C: using guessed type char byte_17E09C;
// 17E09D: using guessed type char byte_17E09D;
// 1803EC: using guessed type __int16 word_1803EC;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (00077680) --------------------------------------------------------
char __fastcall sub_77680(int a1, int a2, signed __int16 *a3)
{
  char result; // al
  int v4; // eax
  int v5; // edx
  int v6; // eax
  __int16 v7; // dx
  char *v8; // esi
  char v9; // [esp+0h] [ebp-4h]
  char v10; // [esp+50h] [ebp+4Ch]
  char v11; // [esp+60h] [ebp+5Ch]
  int v12; // [esp+74h] [ebp+70h]
  int v13; // [esp+78h] [ebp+74h]
  __int16 v14; // [esp+80h] [ebp+7Ch]
  char v15; // [esp+82h] [ebp+7Eh]

  word_E2094 = (unsigned __int8)byte_E2096;
  memset(&v9, 0, 80);
  memset(&v12, 0, 16);
  v15 = 2;
  sprintf(&v9, aNethD, (unsigned __int16)word_17DEFA + 20);
  LOWORD(a3) = 0;
  word_17DEFC = sub_7308F(a3, (int)&v9, 8);
  if ( word_17DEFC == -1 )
  {
    sub_8CD27(dword_17DED4 + 234);
    result = 0;
  }
  else
  {
    sub_7A110(word_180660, 7);
    word_17DEFE = 0;
    sub_8CD27(dword_EB394);
    dword_17DEDC = 0;
    word_17DEEE = 0;
    sub_7B5A0();
    memset(byte_17DE68, 0, 88);
    memset(&v9, 0, 80);
    word_17DEF6 = 5;
    word_17DEEC = 0;
    sub_6EDB0();
    dword_17DEE4 = 15728960;
    if ( *(_WORD *)(dword_D41A4 + 43) >= 0x32u )
      byte_17DE72[11 * word_17DEFC] = *(_BYTE *)(dword_D41A4 + 43);
    else
      byte_17DE72[11 * word_17DEFC] = 50;
    byte_17DE71[11 * word_17DEFC] = 2;
    word_17DEEE = 0;
    while ( !BYTE1(a3) )
    {
      if ( byte_17DF10 == 59 )
      {
        v4 = dword_D41A4;
        *(_BYTE *)(dword_D41A4 + 10) = *(_BYTE *)(dword_D41A4 + 10) != 1;
        *(_BYTE *)(v4 + 38402) = 1;
      }
      BYTE1(a3) = sub_7C390();
      v6 = dword_D41A4;
      if ( *(_BYTE *)(dword_D41A4 + 10) == 1 )
      {
        LOBYTE(v6) = v15;
        if ( v15 == 2 )
        {
          v13 = j___clock(v6, v5, (_WORD)a3);
          if ( (v13 - v12) / 0x64u > 1 )
          {
            v7 = word_E2572[9 * (signed __int16)(v14++ + 1)];
            if ( !v7 )
              v14 = 0;
            v12 = v13;
          }
          memset(&v10, 0, 36);
          v8 = (char *)&unk_E2570 + 18 * v14;
          qmemcpy(&v10, v8, 0x10u);
          qmemcpy(&v11, v8 + 16, 2u);
          sub_7E840((signed __int16 *)&v10, 21, 27);
        }
        else if ( v15 == 3 )
        {
          v13 = j___clock(v6, v5, (_WORD)a3);
          if ( (v13 - v12) / 0x64u > 1 )
            v15 = 2;
        }
      }
      if ( !(_BYTE)a3 )
      {
        sub_90B27((char *)dword_17DE38, 0x20u, 0);
        LOBYTE(a3) = 1;
        sub_8CD27(dword_17DED4 + 90);
      }
      if ( word_180660 & 1 )
        sub_90478();
      else
        sub_75200(480);
      sub_7A060();
    }
    sub_7B5D0();
    sub_7AA70(0, 0, 0, 0);
    sub_7C710();
    result = 1;
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E2094: using guessed type __int16 word_E2094;
// E2096: using guessed type char byte_E2096;
// EB394: using guessed type int dword_EB394;
// 17DE38: using guessed type int dword_17DE38;
// 17DED4: using guessed type int dword_17DED4;
// 17DEDC: using guessed type int dword_17DEDC;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEC: using guessed type __int16 word_17DEEC;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DEF6: using guessed type __int16 word_17DEF6;
// 17DEFA: using guessed type __int16 word_17DEFA;
// 17DEFC: using guessed type __int16 word_17DEFC;
// 17DEFE: using guessed type __int16 word_17DEFE;
// 17DF10: using guessed type char byte_17DF10;
// 180660: using guessed type __int16 word_180660;

//----- (00077980) --------------------------------------------------------
char __cdecl sub_77980(int a1)
{
  __int16 v1; // ax
  char v2; // bl

  v1 = sub_7BF20((signed __int16 *)(a1 + 26));
  v2 = v1;
  if ( v1 == 1 )
  {
    word_E29DC = 1;
    *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11234) = 1;
  }
  else if ( v1 == 2 )
  {
    v2 = 1;
    sub_7C020((_WORD *)(a1 + 26));
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// E29DC: using guessed type __int16 word_E29DC;

//----- (000779E0) --------------------------------------------------------
char __cdecl sub_779E0(int a1)
{
  unsigned int v1; // ebx
  int v2; // eax
  char *v3; // eax
  char v4; // al
  int v5; // esi
  int v6; // eax
  int v7; // edx
  int v8; // eax
  char *v9; // esi
  __int16 v10; // si
  __int16 v11; // ax
  int v12; // esi
  char v13; // al
  int v14; // ebx
  int v15; // eax
  char v17; // [esp+0h] [ebp-142h]
  char v18; // [esp+A0h] [ebp-A2h]
  char v19; // [esp+F0h] [ebp-52h]
  char v20; // [esp+10Eh] [ebp-34h]
  char v21; // [esp+11Ch] [ebp-26h]
  char v22; // [esp+13Ah] [ebp-8h]
  char v23; // [esp+148h] [ebp+6h]
  char v24; // [esp+158h] [ebp+16h]
  int v25; // [esp+16Ch] [ebp+2Ah]
  __int16 v26; // [esp+170h] [ebp+2Eh]
  int v27; // [esp+180h] [ebp+3Eh]
  char v28; // [esp+18Ah] [ebp+48h]
  int v29; // [esp+18Ch] [ebp+4Ah]
  int v30; // [esp+190h] [ebp+4Eh]
  __int16 v31; // [esp+198h] [ebp+56h]
  char v32; // [esp+19Ah] [ebp+58h]
  unsigned int v33; // [esp+19Ch] [ebp+5Ah]
  int v34; // [esp+1A0h] [ebp+5Eh]
  unsigned int *v35; // [esp+1A4h] [ebp+62h]
  unsigned int *v36; // [esp+1A8h] [ebp+66h]
  unsigned int v37; // [esp+1ACh] [ebp+6Ah]
  int v38; // [esp+1B0h] [ebp+6Eh]
  int v39; // [esp+1B4h] [ebp+72h]
  __int16 v40; // [esp+1B8h] [ebp+76h]
  int v41; // [esp+1BCh] [ebp+7Ah]

  v34 = 0;
  v41 = 0;
  v40 = 0;
  v39 = 0;
  sprintf(&v18, aCS_0, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherwConfigD);
  memset(&v25, 0, 32);
  memset(&v29, 0, 16);
  qmemcpy(&v25, (const void *)dword_D41A4, 0x14u);
  qmemcpy(&v27, (const void *)(dword_D41A4 + 20), 2u);
  v32 = 2;
  sub_6EDB0();
  dword_17DEE4 = 13107520;
  if ( a1 )
  {
    sub_7A110(word_180660, 12);
    v1 = dword_E9C38 + 307200;
  }
  else
  {
    v38 = dword_E9C38;
    dword_E9C38 = *(_DWORD *)(dword_D41A4 + 226);
    v1 = dword_E9C38 + 307200;
    sub_7A110(word_180660, 14);
  }
  sub_7B5A0();
  sub_8CD27(dword_EB394);
  word_17DEEC = 0;
  if ( !unknown_libname_2(aLanguageLTxt, 0, &v19) )
  {
    v2 = unknown_libname_2(aLanguageDTxt, 0, &v21);
    if ( a1 || v2 )
      v3 = &v20;
    else
      v3 = &v22;
    v4 = sub_7F7D0((unsigned int *)&v35, &v33, v1, (int)v3);
    *(_BYTE *)(dword_D41A4 + 179) = v4;
    unknown_libname_4(&v21);
    v36 = v35;
    v37 = v33;
    if ( a1 )
    {
      v5 = sub_98817((int)&v18, 512);
      if ( v5 != -1 )
      {
        sub_988A7(v5, (int)&v34, 4);
        if ( v34 == -9 )
        {
          sub_988A7(v5, (int)&v40, 2);
          sprintf(&v17, aLDTxt, v40);
          *(_BYTE *)(dword_D41A4 + 179) = sub_7F960(v36, v37, v1, (int)&v17);
        }
        sub_98882(v5);
      }
    }
    sub_7B5A0();
    word_17DEEE = 0;
    sub_8CD27(dword_17DED4 + 222);
    while ( (_WORD)v39 != 2 )
    {
      if ( byte_17DF10 == 59 )
      {
        v6 = dword_D41A4;
        *(_BYTE *)(dword_D41A4 + 10) = *(_BYTE *)(dword_D41A4 + 10) != 1;
        *(_BYTE *)(v6 + 38402) = 1;
      }
      if ( word_180660 & 1 )
        sub_9A128((const void *)dword_E9C38, (void *)dword_180628, 0xC8u);
      else
        sub_9A144((const void *)dword_E9C38, (void *)dword_180628, 0x1E0u);
      v39 = sub_7E0E0();
      sub_2BB40(263, 134, (int)v36 + 6);
      v8 = dword_D41A4;
      if ( *(_BYTE *)(dword_D41A4 + 10) == 1 )
      {
        LOBYTE(v8) = v32;
        if ( v32 == 2 )
        {
          v30 = j___clock(v8, v7, v1);
          if ( (v30 - v29) / 0x64u > 1 )
          {
            if ( !word_E24BE[9 * ++v31] )
              v31 = 0;
            v29 = v30;
          }
          memset(&v23, 0, 36);
          v9 = (char *)&unk_E24BC + 18 * v31;
          qmemcpy(&v23, v9, 0x10u);
          qmemcpy(&v24, v9 + 16, 2u);
          sub_7E840((signed __int16 *)&v23, 83, 100);
        }
        else if ( v32 == 3 )
        {
          v30 = j___clock(v8, v7, v1);
          if ( (v30 - v29) / 0x64u > 1 )
            v32 = 2;
        }
      }
      if ( (_WORD)v41 )
      {
        if ( word_180660 & 1 )
          sub_90478();
        else
          sub_75200(480);
      }
      else
      {
        sub_90B27((char *)dword_17DE38, 0x20u, 0);
        ++v41;
      }
      v10 = v39;
      sub_7A060();
      if ( v10 == 1 )
      {
        if ( unknown_libname_3(&v19) )
        {
          unknown_libname_4(&v19);
          unknown_libname_2(aLanguageLTxt, 0, &v19);
        }
        v11 = sub_7F960(v36, v37, v1, (int)&v20);
        v12 = dword_D41A4;
        v40 = v11;
        if ( *(unsigned __int8 *)(dword_D41A4 + 179) == v11 )
        {
          if ( unknown_libname_3(&v19) )
          {
            unknown_libname_4(&v19);
            unknown_libname_2(aLanguageLTxt, 0, &v19);
          }
          v13 = sub_7F960(v36, v37, v1, (int)&v20);
          v12 = dword_D41A4;
        }
        else
        {
          v13 = v40;
        }
        *(_BYTE *)(v12 + 179) = v13;
      }
    }
  }
  unknown_libname_4(&v19);
  v14 = sub_98817((int)&v18, 546);
  if ( v14 != -1 )
  {
    if ( *(_BYTE *)(dword_D41A4 + 38402) == 1 )
      *(_BYTE *)(dword_D41A4 + 38402) = 0;
    qmemcpy(&v25, (const void *)dword_D41A4, 0x14u);
    qmemcpy(&v27, (const void *)(dword_D41A4 + 20), 2u);
    qmemcpy((char *)&v27 + 2, &byte_EB39E, 8u);
    qmemcpy(&v28, &byte_EB39E + 8, 2u);
    v25 = -9;
    v26 = *(unsigned __int8 *)(dword_D41A4 + 179);
    sub_98CAA(v14, (int)&v25, 32);
    sub_98882(v14);
  }
  LOWORD(v15) = sub_90B27(0, 0x10u, 0);
  if ( word_180660 & 1 )
  {
    v15 = dword_180628;
    sub_72883(dword_180628, (void *)dword_180628, 0xC8u, 0);
  }
  else
  {
    sub_728A9(v15, (void *)dword_180628, 0x1E0u, 0);
  }
  if ( word_180660 & 1 )
    sub_72883(v15, (void *)dword_E9C38, 0xC8u, 0);
  else
    sub_728A9(v15, (void *)dword_E9C38, 0x1E0u, 0);
  sub_7B5A0();
  if ( word_180660 & 1 )
    sub_90478();
  else
    sub_75200(480);
  if ( a1 )
  {
    sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, 0, 768);
    sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE40, dword_17DEDC, 168081);
    sub_41A90((unsigned __int8 *)dword_17DE38);
    sub_8CD27(dword_EB394);
    sub_8CD27(dword_17DED4 + 234);
    if ( word_180660 & 1 )
      sub_9A128((const void *)dword_180628, (void *)dword_E9C38, 0xC8u);
    else
      sub_9A144((const void *)dword_180628, (void *)dword_E9C38, 0x1E0u);
    sub_7C120(185, 232, dword_17DED4 + 396);
  }
  else
  {
    dword_E9C38 = v38;
  }
  sub_7AA70(0, 0, 0, 0);
  return 1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 9A166: using guessed type _DWORD __cdecl unknown_libname_2(_DWORD, _DWORD, _DWORD);
// 9A193: using guessed type _DWORD __cdecl unknown_libname_3(_DWORD);
// 9A1B3: using guessed type int __cdecl unknown_libname_4(_DWORD);
// D41A4: using guessed type int dword_D41A4;
// E9C38: using guessed type int dword_E9C38;
// EB394: using guessed type int dword_EB394;
// EB39E: using guessed type char byte_EB39E;
// 17DE38: using guessed type int dword_17DE38;
// 17DE40: using guessed type int dword_17DE40;
// 17DED4: using guessed type int dword_17DED4;
// 17DEDC: using guessed type int dword_17DEDC;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEC: using guessed type __int16 word_17DEEC;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (000780F0) --------------------------------------------------------
char __cdecl sub_780F0(int a1)
{
  _WORD *v1; // ebx
  int v2; // edx
  char *v3; // esi
  char *v4; // edi
  char v5; // al
  char v6; // al
  int v7; // eax
  int v8; // esi
  int v9; // eax
  int v10; // esi
  __int16 *v11; // edi
  __int16 v12; // ax
  _WORD *v13; // esi
  _WORD *v14; // eax
  __int16 v15; // si
  char *v16; // eax
  __int16 v17; // si
  char v18; // cl
  signed int j; // esi
  int v20; // eax
  unsigned __int8 v21; // di
  __int16 v22; // ax
  __int16 v23; // di
  signed __int16 k; // si
  __int16 v25; // di
  char v26; // ch
  unsigned __int8 v27; // ST10_1
  __int16 v28; // ST0C_2
  __int16 v29; // ax
  __int16 v31; // [esp-8h] [ebp-5Eh]
  unsigned __int8 v32; // [esp-4h] [ebp-5Ah]
  char v33; // [esp+0h] [ebp-56h]
  char v34; // [esp+50h] [ebp-6h]
  __int16 v35; // [esp+5Ah] [ebp+4h]
  __int16 v36; // [esp+5Ch] [ebp+6h]
  __int16 v37; // [esp+5Eh] [ebp+8h]
  __int16 v38; // [esp+60h] [ebp+Ah]
  char v39; // [esp+7Ch] [ebp+26h]
  int v40; // [esp+88h] [ebp+32h]
  char v41; // [esp+90h] [ebp+3Ah]
  int v42; // [esp+94h] [ebp+3Eh]
  int v43; // [esp+98h] [ebp+42h]
  int v44; // [esp+9Ch] [ebp+46h]
  int v45; // [esp+A0h] [ebp+4Ah]
  _BYTE *v46; // [esp+A4h] [ebp+4Eh]
  int v47; // [esp+A8h] [ebp+52h]
  int v48; // [esp+ACh] [ebp+56h]
  int v49; // [esp+B0h] [ebp+5Ah]
  _BYTE *v50; // [esp+B4h] [ebp+5Eh]
  __int16 v51; // [esp+B8h] [ebp+62h]
  int v52; // [esp+BCh] [ebp+66h]
  int v53; // [esp+C0h] [ebp+6Ah]
  int i; // [esp+C4h] [ebp+6Eh]
  __int16 v55; // [esp+C8h] [ebp+72h]
  unsigned __int8 v56; // [esp+CCh] [ebp+76h]
  unsigned __int8 v57; // [esp+D0h] [ebp+7Ah]

  v42 = 0;
  v44 = 0;
  v55 = 0;
  v1 = (_WORD *)(a1 + 26);
  v57 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x3Fu, 0x3Fu, 0x3Fu);
  v56 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x16u, 0x10u, 9u);
  if ( word_17DF04 == -1 )
  {
    for ( i = 1; (signed __int16)i < 9; ++i )
    {
      v2 = (signed __int16)i;
      v48 = 43 * ((signed __int16)i - 1);
      v3 = (char *)dword_EA2C4;
      v4 = &byte_17DF14[v48];
      v46 = &byte_17DF14[v48];
      do
      {
        v5 = *v3;
        *v4 = *v3;
        if ( !v5 )
          break;
        v6 = v3[1];
        v3 += 2;
        v4[1] = v6;
        v4 += 2;
      }
      while ( v6 );
      v7 = v48;
      byte_17DF3D[v48] = 0;
      byte_17DF3E[v7] = 0;
      sprintf(&v33, aCSSaveSaveDGam, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_5, v2);
      v8 = sub_98817((int)&v33, 512);
      if ( v8 != -1 )
      {
        sub_988A7(v8, (int)&v43, 4);
        if ( v43 == -9 )
        {
          sub_988A7(v8, (int)v46, 20);
          byte_17DF3D[v48] = 1;
        }
        sub_98882(v8);
      }
    }
    word_17DF04 = 0;
  }
  v51 = sub_7BF20((signed __int16 *)(a1 + 26));
  if ( (_BYTE)v51 )
  {
    sub_7C020((_WORD *)(a1 + 26));
    if ( (_BYTE)v51 == 1 && word_17DF04 > 0 )
    {
      sprintf(&v33, aCSSaveSaveDGam, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_5, word_17DF04);
      v9 = sub_98817((int)&v33, 512);
      v10 = v9;
      if ( v9 != -1 )
      {
        sub_988A7(v9, (int)&v43, 4);
        if ( v43 == -9 )
        {
          if ( *(_BYTE *)(a1 + 25) )
            sub_7E640(0);
          sub_988A7(v10, (int)&byte_17DF14[43 * (word_17DF04 - 1)], 20);
          sub_988A7(v10, dword_D41A4 + 57, 32);
          v11 = word_E2970;
          sub_988A7(v10, dword_D41A4 + 89, 32);
          while ( v11 < &word_E29D6 )
          {
            sub_988A7(v10, (int)&v39, 17);
            v12 = v40;
            v11[6] = v40;
            if ( v12 == 1 )
              v11[7] = 305;
            else
              v11[7] = 270;
            v11 = (__int16 *)((char *)v11 + 17);
          }
          sub_988A7(v10, dword_D41A0 + 8586, 16);
          sub_988A7(v10, (int)&v42, 4);
          sub_988A7(v10, (int)&v44, 4);
          sub_988A7(v10, 2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230 + 1609, 505);
          sub_988A7(v10, (int)dword_17DBC8, 500);
          sub_988A7(v10, (int)dword_17DDBC, 100);
          sub_98882(v10);
          v13 = &unk_E1960;
          *(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) = 0;
          while ( v13[2] )
          {
            v13 += 11;
            *((_BYTE *)v13 - 4) = 2;
          }
          v14 = &unk_E1960;
          v15 = 0;
          while ( v15 < v42 && v14[2] )
          {
            v14 += 11;
            ++v15;
            *((_BYTE *)v14 - 4) = 1;
          }
          v16 = (char *)&unk_E1960;
          v17 = 0;
          while ( *((_WORD *)v16 + 2) )
          {
            if ( v16[18] == 1 )
              *(_WORD *)(dword_D41A4 + 43) = v17;
            v16 += 22;
            ++v17;
          }
          byte_17DB8F = 1;
          memset(&dword_17DE28, 0, 13);
          v18 = *(_BYTE *)(a1 + 25);
          word_17DB8A = -1;
          if ( v18 )
          {
            sub_81760(a1);
          }
          else
          {
            word_17DF04 = -1;
            sub_77350(a1);
            *(_DWORD *)(a1 + 4) = 2;
          }
        }
      }
    }
    word_17DF04 = -1;
    v55 = 1;
  }
  for ( j = 1; (signed __int16)j < 9; ++j )
  {
    sub_6FC50(1);
    if ( *(signed __int16 *)(a1 + 36) > 16 * (signed __int16)j + 3 * sub_6FC30() )
    {
      sprintf(&v41, &aDD_1[2], (signed __int16)j);
      v53 = 16 * j;
      v20 = 43 * ((signed __int16)j - 1);
      v50 = &byte_17DF14[v20];
      if ( (_WORD)j == word_17DF04 )
      {
        LOWORD(v20) = *v1;
        v52 = v20 + 20;
        v23 = v53 + *(_WORD *)(a1 + 28) + 16;
        v47 = v57;
        sub_2BC10(&v41, v20 + 20, v23, v57);
        v32 = v47;
        v31 = v23;
        v22 = v52 + 3 * sub_6FC10();
      }
      else
      {
        v21 = v56;
        sub_2BC10(&v41, *(_WORD *)(a1 + 26) + 20, v53 + *(_WORD *)(a1 + 28) + 16, v56);
        v32 = v21;
        v31 = v53 + *(_WORD *)(a1 + 28) + 16;
        v22 = *v1 + 20 + 3 * sub_6FC10();
      }
      sub_2BC10(v50, v22, v31, v32);
    }
  }
  if ( *(_WORD *)(a1 + 36) >= *(_WORD *)(a1 + 34) )
  {
    for ( k = 1; k < 9; ++k )
    {
      v35 = *v1 + 20;
      v25 = 16 * k;
      v36 = 16 * k + *(_WORD *)(a1 + 28) + 16;
      v37 = 100;
      v45 = k;
      v38 = 16;
      v26 = byte_17DF3D[43 * (k - 1)];
      v49 = 43 * (k - 1);
      if ( v26 && sub_7B200(&v34, dword_17DEE4, SHIWORD(dword_17DEE4)) )
      {
        if ( word_17DEEE & 1 )
        {
          word_17DF04 = k;
        }
        else
        {
          sprintf(&v41, &aDD_1[2], v45);
          v47 = v57;
          sub_2BC10(&v41, *(_WORD *)(a1 + 26) + 20, v25 + *(_WORD *)(a1 + 28) + 16, v57);
          v27 = v47;
          v28 = v25 + *(_WORD *)(a1 + 28) + 16;
          v29 = sub_6FC10();
          sub_2BC10(&byte_17DF14[v49], *v1 + 20 + 3 * v29, v28, v27);
        }
      }
    }
  }
  return v55;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E29D6: using guessed type __int16 word_E29D6;
// EA2C4: using guessed type int dword_EA2C4;
// 17DB8A: using guessed type __int16 word_17DB8A;
// 17DB8F: using guessed type char byte_17DB8F;
// 17DBC8: using guessed type int dword_17DBC8[];
// 17DDBC: using guessed type int dword_17DDBC[];
// 17DE28: using guessed type int dword_17DE28;
// 17DE38: using guessed type int dword_17DE38;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF04: using guessed type __int16 word_17DF04;

//----- (00078730) --------------------------------------------------------
char __cdecl sub_78730(_WORD *a1)
{
  signed __int16 *v1; // ebx
  int v2; // edx
  int v3; // eax
  char *v4; // esi
  char *v5; // edi
  char v6; // al
  char v7; // al
  int v8; // esi
  char *v9; // edi
  char *v10; // esi
  char v11; // al
  char v12; // al
  int v13; // esi
  _WORD *v14; // eax
  signed int j; // esi
  char *v16; // edi
  unsigned __int8 v17; // ST10_1
  __int16 v18; // ST0C_2
  __int16 v19; // ST08_2
  signed __int16 v20; // ax
  int v21; // eax
  unsigned __int8 v22; // ST10_1
  __int16 v23; // ST0C_2
  __int16 v24; // ST08_2
  __int16 v25; // ax
  char *v26; // esi
  _BYTE *v27; // edi
  char v28; // al
  char v29; // al
  int v30; // eax
  int v31; // edi
  unsigned __int8 v32; // si
  __int16 v33; // ST0C_2
  __int16 v34; // ax
  int v35; // eax
  int v36; // eax
  unsigned __int8 v37; // ST10_1
  char *v38; // eax
  _BYTE *v39; // ST0C_4
  char *v40; // ST08_4
  __int16 v41; // ST04_2
  __int16 v42; // ax
  int v43; // edx
  char *v45; // [esp-4h] [ebp-46h]
  char v46; // [esp+0h] [ebp-42h]
  char v47; // [esp+50h] [ebp+Eh]
  __int16 v48; // [esp+5Ah] [ebp+18h]
  __int16 v49; // [esp+5Ch] [ebp+1Ah]
  __int16 v50; // [esp+5Eh] [ebp+1Ch]
  __int16 v51; // [esp+60h] [ebp+1Eh]
  char v52; // [esp+7Ch] [ebp+3Ah]
  int v53; // [esp+80h] [ebp+3Eh]
  int v54; // [esp+84h] [ebp+42h]
  int v55; // [esp+88h] [ebp+46h]
  char *v56; // [esp+8Ch] [ebp+4Ah]
  int v57; // [esp+90h] [ebp+4Eh]
  int v58; // [esp+94h] [ebp+52h]
  __int16 v59; // [esp+98h] [ebp+56h]
  __int16 v60; // [esp+9Ch] [ebp+5Ah]
  int v61; // [esp+A0h] [ebp+5Eh]
  int v62; // [esp+A4h] [ebp+62h]
  int v63; // [esp+A8h] [ebp+66h]
  int v64; // [esp+ACh] [ebp+6Ah]
  int i; // [esp+B0h] [ebp+6Eh]
  int k; // [esp+B4h] [ebp+72h]
  unsigned __int8 v67; // [esp+B8h] [ebp+76h]
  unsigned __int8 v68; // [esp+BCh] [ebp+7Ah]

  v60 = 0;
  v68 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x3Fu, 0x3Fu, 0x3Fu);
  v67 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x16u, 0x10u, 9u);
  v1 = a1 + 13;
  if ( word_17DF04 == -1 )
  {
    for ( i = 1; (signed __int16)i < 9; ++i )
    {
      v2 = (signed __int16)i;
      v3 = 43 * ((signed __int16)i - 1);
      v4 = (char *)dword_EA2C4;
      v5 = &byte_17DF14[v3];
      v45 = &byte_17DF14[v3];
      do
      {
        v6 = *v4;
        *v5 = *v4;
        if ( !v6 )
          break;
        v7 = v4[1];
        v4 += 2;
        v5[1] = v7;
        v5 += 2;
      }
      while ( v7 );
      v56 = v45;
      sprintf(&v46, aCSSaveSaveDGam, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_5, v2);
      v8 = sub_98817((int)&v46, 512);
      if ( v8 != -1 )
      {
        sub_988A7(v8, (int)&v54, 4);
        if ( v54 == -9 )
          sub_988A7(v8, (int)v56, 20);
        sub_98882(v8);
      }
    }
    word_17DF04 = 0;
  }
  v59 = sub_7BF20(v1);
  if ( (_BYTE)v59 )
  {
    sub_7C020(v1);
    if ( (_BYTE)v59 == 1 && word_17DF04 > 0 )
    {
      v9 = &byte_17DF14[43 * (word_17DF04 - 1)];
      v10 = v9 + 20;
      do
      {
        v11 = *v10;
        *v9 = *v10;
        if ( !v11 )
          break;
        v12 = v10[1];
        v10 += 2;
        v9[1] = v12;
        v9 += 2;
      }
      while ( v12 );
      sprintf(&v46, aCSSaveSaveDGam, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_5, word_17DF04);
      v13 = sub_98817((int)&v46, 546);
      if ( v13 != -1 )
      {
        v14 = &unk_E1960;
        v54 = -9;
        v55 = 0;
        while ( v14[2] && *((_BYTE *)v14 + 18) != 2 )
        {
          v14 += 11;
          ++v55;
        }
        v53 = *(signed __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232);
        sub_98CAA(v13, (int)&v54, 4);
        sub_98CAA(v13, (int)&byte_17DF14[43 * (word_17DF04 - 1)], 20);
        sub_98CAA(v13, dword_D41A4 + 57, 32);
        sub_98CAA(v13, dword_D41A4 + 89, 32);
        sub_98CAA(v13, (int)word_E2970, 102);
        sub_98CAA(v13, dword_D41A0 + 8586, 16);
        sub_98CAA(v13, (int)&v55, 4);
        sub_98CAA(v13, (int)&v53, 4);
        sub_98CAA(v13, 2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230 + 1609, 505);
        sub_98CAA(v13, (int)dword_17DBC8, 500);
        sub_98CAA(v13, (int)dword_17DDBC, 100);
        sub_98882(v13);
      }
    }
    word_17DF04 = -1;
    v60 = 1;
  }
  for ( j = 1; (signed __int16)j < 9; ++j )
  {
    sub_6FC50(1);
    if ( (signed __int16)a1[18] > 16 * (signed __int16)j + 3 * sub_6FC30() )
    {
      sprintf(&v52, &aDD_1[2], (signed __int16)j);
      v62 = 16 * j;
      v16 = &byte_17DF14[43 * ((signed __int16)j - 1)];
      if ( (_WORD)j == word_17DF04 )
      {
        v20 = *v1;
        v21 = 16 * j + 20;
        v63 = 16 * j + 20;
        LOWORD(v21) = a1[14];
        v57 = v68;
        v58 = (signed __int16)(v21 + 16 + v62);
        v61 = v21 + 16 + v62;
        sub_2BC10(&v52, v63, v21 + 16 + v62, v68);
        v22 = v57;
        v23 = v58;
        v24 = v63 + 3 * sub_6FC10();
        sub_2BC10(v16 + 20, v24, v23, v22);
      }
      else
      {
        v57 = v67;
        sub_2BC10(&v52, a1[13] + 20, v62 + a1[14] + 16, v67);
        v17 = v57;
        v18 = v62 + a1[14] + 16;
        v19 = *v1 + 20 + 3 * sub_6FC10();
        sub_2BC10(v16, v19, v18, v17);
      }
    }
  }
  if ( a1[18] >= a1[17] )
  {
    for ( k = 1; (signed __int16)k < 9; ++k )
    {
      v48 = *v1 + 20;
      v25 = a1[14];
      v64 = 16 * k;
      v51 = 16;
      v50 = 90;
      v49 = v25 + 16 + 16 * k;
      if ( sub_7B200(&v47, dword_17DEE4, SHIWORD(dword_17DEE4)) )
      {
        if ( word_17DEEE & 1 )
        {
          word_17DF04 = k;
          v26 = &byte_17DF14[43 * ((signed __int16)k - 1)];
          v27 = v26 + 20;
          do
          {
            v28 = *v26;
            *v27 = *v26;
            if ( !v28 )
              break;
            v29 = v26[1];
            v26 += 2;
            v27[1] = v29;
            v27 += 2;
          }
          while ( v29 );
          v30 = 43 * (word_17DF04 - 1);
          byte_17DF3C[v30] = 0;
          LOWORD(v30) = *v1;
          v30 += 20;
          v63 = v30;
          LOWORD(v30) = a1[14];
          v61 = v30 + 16 + v64;
          byte_17DF3E[43 * (word_17DF04 - 1)] = 0;
        }
        else if ( (_WORD)k != word_17DF04 )
        {
          v31 = 43 * ((signed __int16)k - 1);
          sprintf(&v52, &aDD_1[2], (signed __int16)k);
          v32 = v68;
          sub_2BC10(&v52, a1[13] + 20, v64 + a1[14] + 16, v68);
          v33 = v64 + a1[14] + 16;
          v34 = sub_6FC10();
          sub_2BC10(&byte_17DF14[v31], *v1 + 20 + 3 * v34, v33, v32);
        }
      }
    }
    if ( word_17DF04 )
    {
      sub_6FC50(1);
      if ( byte_17DF10 != 1 && byte_17DF10 != 28 && byte_17DF10 != 14
        || (v35 = 43 * (word_17DF04 - 1), byte_17DF3E[v35]) )
      {
        if ( byte_17DF11 )
        {
          if ( sub_7C200(byte_17DF11) )
          {
            v36 = 43 * (word_17DF04 - 1);
            if ( !byte_17DF3E[v36] )
            {
              byte_17DF3E[v36] = 1;
              sprintf(&byte_17DF14[43 * (word_17DF04 - 1) + 20], aC_0, (unsigned __int8)byte_17DF11);
              byte_17DF10 = 0;
              byte_17DF11 = 0;
            }
          }
        }
      }
      else
      {
        byte_17DF3E[v35] = 1;
      }
      v37 = v68;
      v38 = &byte_17DF14[43 * (word_17DF04 - 1)];
      v39 = v38 + 40;
      v40 = v38 + 20;
      v41 = v61;
      v42 = sub_6FC10();
      sub_7F6A0((signed __int16)(v63 + 3 * v42), v43, v63 + 3 * v42, v41, v40, v39, v37);
    }
  }
  return v60;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA2C4: using guessed type int dword_EA2C4;
// 17DBC8: using guessed type int dword_17DBC8[];
// 17DDBC: using guessed type int dword_17DDBC[];
// 17DE38: using guessed type int dword_17DE38;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF04: using guessed type __int16 word_17DF04;
// 17DF10: using guessed type char byte_17DF10;
// 17DF11: using guessed type char byte_17DF11;

//----- (00078E00) --------------------------------------------------------
char __usercall sub_78E00@<al>(int a1@<eax>, int a2@<ebx>, signed __int16 *a3)
{
  int v3; // eax
  int v4; // esi
  int v5; // esi
  const char *v6; // edi
  char *v7; // edx
  char v8; // al
  __int16 v9; // si
  unsigned __int8 v10; // al
  __int16 v11; // bx
  unsigned __int8 v12; // al
  char *v13; // esi
  char *v14; // edi
  char v15; // al
  char v16; // al
  char *v17; // edi
  char *v18; // esi
  char v19; // al
  char v20; // al
  char *v21; // edi
  char *v22; // esi
  char v23; // al
  char v24; // al
  int v26; // [esp+0h] [ebp-14h]
  int v27; // [esp+4h] [ebp-10h]
  char v28; // [esp+8h] [ebp-Ch]
  int v29; // [esp+Ch] [ebp-8h]
  char v30; // [esp+10h] [ebp-4h]

  v28 = 0;
  v26 = j___clock(a1, 0, a2);
  v3 = sub_6FC50(1);
  LOWORD(v3) = a3[13];
  v29 = v3 + 10;
  HIWORD(v3) = HIWORD(dword_17DED4);
  LOWORD(v3) = *(unsigned __int8 *)(dword_17DED4 + 436);
  v27 = v29 + v3 - 22;
  v4 = a3[14] + a3[17] / 2;
  v5 = v4 - sub_6FC30();
  v30 = sub_7BF20(a3 + 13);
  if ( a3[18] <= a3[17] / 2 )
    goto LABEL_15;
  word_17DEF0 = strlen((const char *)dword_17DE50);
  if ( (unsigned __int8)byte_17DF10 < 0xFu )
  {
    if ( byte_17DF10 != 14 )
    {
LABEL_9:
      if ( (unsigned __int16)word_17DEF0 < 0xCu && byte_17DF11 && sub_7C200(byte_17DF11) )
      {
        v7 = (char *)(dword_17DE50 + (unsigned __int16)word_17DEF0);
        v8 = byte_17DF11;
        v7[1] = 0;
        *v7 = v8;
      }
      goto LABEL_13;
    }
LABEL_7:
    if ( word_17DEF0 )
    {
      v6 = (const char *)dword_17DE50;
      *(_BYTE *)(strlen((const char *)dword_17DE50) + dword_17DE50 - 1) = 0;
      word_17DEF0 = strlen(v6);
    }
    goto LABEL_13;
  }
  if ( (unsigned __int8)byte_17DF10 > 0xFu )
  {
    if ( byte_17DF10 != 83 )
      goto LABEL_9;
    goto LABEL_7;
  }
LABEL_13:
  strupr(dword_17DE50);
  sub_6FC50(1);
  v9 = sub_6FC30() + v5;
  v10 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x16u, 0x10u, 9u);
  v11 = sub_6FC80((char *)dword_17DE50, v29, v27, v9, v10);
  if ( (v26 - dword_17DED0) / 0xCu >= 1 )
  {
    v12 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x16u, 0x10u, 9u);
    sub_2BC10(&asc_D1AB3[1], v11 + 2, v9, v12);
    dword_17DED0 = v26;
  }
LABEL_15:
  if ( v30 )
  {
    if ( v30 == 1 )
    {
      v13 = (char *)dword_17DE50;
      v14 = (char *)(dword_D41A0 + 11230 + 2124 * *(signed __int16 *)(dword_D41A0 + 12) + 927);
      do
      {
        v15 = *v13;
        *v14 = *v13;
        if ( !v15 )
          break;
        v16 = v13[1];
        v13 += 2;
        v14[1] = v16;
        v14 += 2;
      }
      while ( v16 );
      v17 = (char *)(dword_D41A4 + 57);
      v18 = (char *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230 + 927);
      do
      {
        v19 = *v18;
        *v17 = *v18;
        if ( !v19 )
          break;
        v20 = v18[1];
        v18 += 2;
        v17[1] = v20;
        v17 += 2;
      }
      while ( v20 );
    }
    else
    {
      *(_BYTE *)(dword_D41A4 + 57) = 0;
    }
    v21 = (char *)dword_17DE50;
    v22 = (char *)(dword_D41A0 + 11230 + 2124 * *(signed __int16 *)(dword_D41A0 + 12) + 927);
    do
    {
      v23 = *v22;
      *v21 = *v22;
      if ( !v23 )
        break;
      v24 = v22[1];
      v22 += 2;
      v21[1] = v24;
      v21 += 2;
    }
    while ( v24 );
    sub_7C020(a3 + 13);
    v28 = 1;
  }
  return v28;
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 9A20A: using guessed type _DWORD __cdecl strupr(_DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 17DE38: using guessed type int dword_17DE38;
// 17DE50: using guessed type int dword_17DE50;
// 17DED0: using guessed type int dword_17DED0;
// 17DED4: using guessed type int dword_17DED4;
// 17DEF0: using guessed type __int16 word_17DEF0;
// 17DF10: using guessed type char byte_17DF10;
// 17DF11: using guessed type char byte_17DF11;

//----- (00079160) --------------------------------------------------------
char __cdecl sub_79160(int a1)
{
  signed __int16 *v1; // esi
  int v2; // eax
  int v3; // eax
  int v4; // edx
  int v5; // ebx
  int v6; // ebx
  signed __int16 *v7; // esi
  char *v8; // ST00_4
  int v9; // ebx
  signed __int16 *v10; // esi
  int v11; // eax
  _WORD *v12; // esi
  int v13; // eax
  int v14; // esi
  unsigned int v15; // ebx
  __int16 v16; // cx
  unsigned __int8 v18; // al
  char v19; // [esp+0h] [ebp-4Ch]
  __int16 v20; // [esp+Ah] [ebp-42h]
  __int16 v21; // [esp+Ch] [ebp-40h]
  __int16 v22; // [esp+Eh] [ebp-3Eh]
  __int16 v23; // [esp+10h] [ebp-3Ch]
  unsigned int v24; // [esp+2Ch] [ebp-20h]
  _WORD *v25; // [esp+30h] [ebp-1Ch]
  int v26; // [esp+34h] [ebp-18h]
  __int16 v27; // [esp+38h] [ebp-14h]
  int v28; // [esp+3Ch] [ebp-10h]
  char v29; // [esp+40h] [ebp-Ch]
  unsigned __int8 v30; // [esp+44h] [ebp-8h]
  unsigned __int8 v31; // [esp+48h] [ebp-4h]

  v25 = 0;
  v27 = 0;
  v1 = (signed __int16 *)(a1 + 26);
  v31 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x3Fu, 0x3Fu, 0x3Fu);
  v30 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, 0);
  BYTE1(v2) = *(_BYTE *)(a1 + 25);
  if ( !BYTE1(v2) )
  {
    LOWORD(v2) = *v1;
    v26 = v2 + 10;
    HIWORD(v3) = HIWORD(dword_17DED4);
    LOWORD(v3) = *(unsigned __int8 *)(dword_17DED4 + 436);
    v4 = *(signed __int16 *)(a1 + 34);
    v28 = v26 + v3 - 22;
    v5 = *(signed __int16 *)(a1 + 28) + v4 / 2;
    v6 = v5 - 2 * sub_6FC30();
    v29 = sub_7BF20((signed __int16 *)(a1 + 26));
    if ( *(_WORD *)(a1 + 36) >= *(_WORD *)(a1 + 34) )
    {
      v7 = (signed __int16 *)&unk_E2690;
      sub_6FC50(1);
      while ( v7[6] )
      {
        if ( v7[7] )
        {
          sub_6FC50(1);
          v8 = (char *)dword_E9C4C[v7[6]];
          v25 = v7;
          sub_6FC80(v8, v26, v28, v6, v31);
        }
        else
        {
          sub_6FC50(1);
          sub_6FC80((char *)dword_E9C4C[v7[6]], v26, v28, v6, v30);
        }
        v7 += 9;
        LOWORD(v6) = sub_6FC30() + v6;
      }
      v9 = *(signed __int16 *)(a1 + 28) + *(signed __int16 *)(a1 + 34) / 2;
      v6 = v9 - 2 * sub_6FC30();
      v20 = v26;
      v10 = (signed __int16 *)&unk_E2690;
      v22 = *(unsigned __int8 *)(dword_17DED4 + 436);
      v23 = sub_6FC30();
      while ( v10[6] )
      {
        v21 = v6;
        if ( sub_7B200(&v19, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        {
          if ( word_17DEEE & 1 )
          {
            if ( v25 )
              v25[7] = 0;
            v10[7] = 1;
          }
          sub_6FC50(1);
          sub_6FC80((char *)dword_E9C4C[v10[6]], v26, v28, v6, v31);
        }
        LOWORD(v11) = sub_6FC30();
        v10 += 9;
        v6 += v11;
      }
    }
    if ( v29 )
    {
      v12 = &unk_E2690;
      while ( v12[6] )
      {
        if ( v12[7] )
        {
          v25 = v12;
          break;
        }
        LOWORD(v13) = sub_6FC30();
        v12 += 9;
        v6 += v13;
      }
      if ( v29 != 1 )
      {
        switch ( word_1805C2 )
        {
          case 4:
          case 11:
            word_1805C2 = 7;
            break;
          case 8:
            word_1805C2 = 1;
            break;
          case 9:
            word_1805C2 = 2;
            break;
          default:
            goto LABEL_41;
        }
        goto LABEL_41;
      }
      v27 = 1;
      v14 = (unsigned __int16)word_1805C2;
      if ( !v25 )
        goto LABEL_42;
      v15 = (unsigned __int16)word_1805C2 - 1;
      v24 = 4 * v15;
      v16 = v25[8];
      if ( v16 == 2 )
      {
        if ( (signed __int16)sub_89B60(4u) == -1 )
        {
          word_1805C2 = v14;
        }
        else if ( v15 <= 0xC )
        {
          JUMPOUT(__CS__, *(void **)((char *)&off_790E4 + v24));
        }
LABEL_41:
        v27 = 1;
        goto LABEL_42;
      }
      if ( v16 != 1 )
      {
LABEL_42:
        sub_7C020((_WORD *)(a1 + 26));
        return v27;
      }
      if ( (signed __int16)sub_89B60(0xBu) != -1 )
      {
        if ( v15 <= 8 )
          JUMPOUT(__CS__, *(void **)((char *)&off_79118 + v24));
        *(_BYTE *)(a1 + 25) = 1;
        v27 = 0;
        goto LABEL_42;
      }
      word_1805C2 = v14;
      sub_7C020((_WORD *)(a1 + 26));
    }
    return v27;
  }
  v27 = 0;
  if ( BYTE1(v2) >= 1u )
  {
    if ( BYTE1(v2) <= 1u )
    {
      *(_WORD *)(a1 + 38) = 439;
      *(_WORD *)(a1 + 42) = 0;
    }
    else if ( BYTE1(v2) == 2 )
    {
      *(_WORD *)(a1 + 38) = 439;
    }
  }
  sub_7BF20(v1);
  if ( *(_WORD *)(a1 + 36) < *(_WORD *)(a1 + 34) )
    return v27;
  v18 = *(_BYTE *)(a1 + 25);
  if ( v18 < 2u )
  {
    if ( v18 == 1 )
    {
      *(_BYTE *)(a1 + 25) = 2;
      return v27;
    }
    return v27;
  }
  if ( v18 > 2u )
  {
    if ( v18 != 3 )
      return v27;
    *(_BYTE *)(a1 + 25) = 0;
    *(_WORD *)(a1 + 38) = 411;
    *(_WORD *)(a1 + 42) = 3;
    sub_7C020((_WORD *)(a1 + 26));
    return 1;
  }
  byte_17DF10 = 0;
  sub_8C0E0((unsigned __int8 (__fastcall *)(signed int))sub_7A060);
  if ( byte_17DF10 == 1 )
  {
    if ( (unsigned __int16)word_1805C2 < 0xCu )
    {
      if ( word_1805C2 == 11 )
        word_1805C2 = 7;
    }
    else if ( (unsigned __int16)word_1805C2 <= 0xCu )
    {
      word_1805C2 = 1;
    }
    else if ( word_1805C2 == 13 )
    {
      word_1805C2 = 2;
    }
  }
  ++*(_BYTE *)(a1 + 25);
  return v27;
}
// 790E4: using guessed type void *off_790E4;
// 79118: using guessed type void *off_79118;
// 17DE38: using guessed type int dword_17DE38;
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (00079610) --------------------------------------------------------
char sub_79610()
{
  int v0; // eax
  signed __int16 v1; // si
  signed __int16 *v2; // ebx
  int v3; // edi
  int v4; // ST0C_4
  int v5; // ST04_4
  _BYTE *v6; // ST00_4
  _WORD *i; // eax
  int v8; // eax
  int v9; // edx
  _WORD *j; // ebx
  _WORD *k; // eax
  _WORD *l; // eax
  char *v13; // ebx
  signed __int16 *v14; // edi
  char *m; // edi
  signed __int16 v16; // ax
  int v17; // eax
  char v18; // dl
  char *n; // eax
  signed __int16 v20; // ax
  int v21; // eax
  char v22; // dl
  char *ii; // eax
  signed __int16 v24; // dx
  unsigned int v25; // eax
  int v26; // eax
  char v28; // [esp+0h] [ebp-16h]
  char v29; // [esp+3Ch] [ebp+26h]
  __int16 v30; // [esp+46h] [ebp+30h]
  __int16 v31; // [esp+48h] [ebp+32h]
  __int16 v32; // [esp+4Ah] [ebp+34h]
  __int16 v33; // [esp+4Ch] [ebp+36h]
  int v34; // [esp+68h] [ebp+52h]
  int v35; // [esp+6Ch] [ebp+56h]
  int v36; // [esp+70h] [ebp+5Ah]
  unsigned int v37; // [esp+74h] [ebp+5Eh]
  int v38; // [esp+78h] [ebp+62h]
  int v39; // [esp+7Ch] [ebp+66h]
  int v40; // [esp+80h] [ebp+6Ah]
  int v41; // [esp+84h] [ebp+6Eh]
  int v42; // [esp+88h] [ebp+72h]
  int v43; // [esp+8Ch] [ebp+76h]
  int v44; // [esp+90h] [ebp+7Ah]
  int v45; // [esp+94h] [ebp+7Eh]

  HIWORD(v0) = HIWORD(dword_17DED4);
  v1 = 0;
  v39 = 359;
  v43 = 372;
  v42 = 410;
  v44 = 0;
  v41 = 0;
  LOBYTE(v0) = *(_BYTE *)(dword_17DED4 + 647);
  v45 = 191;
  LOWORD(v0) = (unsigned __int8)v0;
  v40 = v0;
  v38 = j___clock(v0, 191, 372);
  v35 = v38;
  memset(&v28, 0, 60);
  v2 = (signed __int16 *)&unk_E28A8;
  sub_7A110(word_180660, 15);
  v3 = dword_180628;
  dword_180628 = dword_E9C38;
  while ( *v2 )
  {
    v4 = v2[1];
    v5 = *v2;
    v6 = (_BYTE *)dword_E9C4C[v2[6]];
    v2 += 9;
    sub_7FCB0((int)v2, v6, v5, (signed __int16)v39, v4, 4, 0, 0);
  }
  dword_180628 = v3;
  sub_7B5A0();
  for ( i = &unk_E28A8; *i; *(i - 2) = 0 )
    i += 9;
  word_E28B6 = 1;
  v8 = sub_8CD27(dword_17DED4 + 660);
  while ( (_WORD)v44 != 2 )
  {
    v34 = j___clock(v8, v9, v2);
    v36 = v34;
    if ( word_180660 & 1 )
      sub_9A128((const void *)dword_E9C38, (void *)dword_180628, 0xC8u);
    else
      sub_9A144((const void *)dword_E9C38, (void *)dword_180628, 0x1E0u);
    if ( word_17DEEE & 1 )
    {
      for ( j = &unk_E28A8; *j; j += 9 )
      {
        v30 = v45;
        v31 = j[1] - 4;
        v32 = v42;
        v33 = v40;
        if ( sub_7B200(&v29, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        {
          for ( k = &unk_E28A8; *k; *(k - 2) = 0 )
            k += 9;
          j[7] = 1;
          v1 = 0;
          break;
        }
      }
    }
    v44 = sub_7E1F0();
    if ( (_WORD)v44 == 1 )
    {
      *(_BYTE *)(dword_D41A4 + 38402) = 1;
      sub_5BCC0();
      for ( l = &unk_E28A8; *l; *(l - 2) = 0 )
        l += 9;
      v1 = 0;
      word_E28B6 = 1;
    }
    v13 = &byte_EB39E;
    v14 = (signed __int16 *)&unk_E28A8;
    while ( v13 < &byte_EB3A8 )
    {
      memset(&v28, 0, 60);
      if ( !v14[7] )
      {
        sub_79E10(&v28, *v13);
        sub_7FCB0((int)v13, &v28, (signed __int16)v43, (signed __int16)v42, v14[1], 4, 0, 0);
      }
      ++v13;
      v14 += 9;
    }
    v2 = (signed __int16 *)&unk_E28A8;
    for ( m = &byte_EB39E; m < &byte_EB3A8 && !v1; ++m )
    {
      v16 = v2[7];
      if ( (unsigned __int16)v16 >= 1u )
      {
        v37 = v34 - v38;
        if ( (unsigned __int16)v16 <= 1u )
        {
          memset(&v28, 0, 60);
          sub_79E10(&v28, *m);
          sub_7FCB0((int)v2, &v28, (signed __int16)v43, (signed __int16)v42, v2[1], 4, 0, 0);
          if ( v37 > 0x32 )
          {
            v17 = v34;
            v2[7] = 2;
            v38 = v17;
          }
          sub_2BB40(v45, v2[1], dword_17DED4 + 642);
          if ( byte_17DF10 && (unsigned __int16)sub_79E10(&v28, byte_17DF10) )
          {
            v18 = 0;
            if ( m != &byte_EB3A4 )
            {
              for ( n = &byte_EB39E; n < &byte_EB3A8; ++n )
              {
                if ( byte_17DF10 == *n )
                {
                  v18 = 1;
                  break;
                }
              }
            }
            if ( !v18 )
            {
              *(_BYTE *)(dword_D41A4 + 38402) = 1;
              v2 += 9;
              *m = byte_17DF10;
              *(v2 - 2) = 0;
              v20 = *v2;
              byte_17DF10 = 0;
              if ( v20 )
              {
                v2[7] = 1;
              }
              else
              {
                v1 = 1;
                v38 = v34;
              }
            }
          }
        }
        else if ( v16 == 2 )
        {
          if ( (unsigned int)(v34 - v38) > 0x32 )
          {
            v21 = v34;
            v2[7] = 1;
            v38 = v21;
          }
          sub_2BB40(v45, v2[1], dword_17DED4 + 642);
          if ( byte_17DF10 )
          {
            if ( (unsigned __int16)sub_79E10(&v28, byte_17DF10) )
            {
              v22 = 0;
              if ( m != &byte_EB3A4 )
              {
                for ( ii = &byte_EB39E; ii < &byte_EB3A8; ++ii )
                {
                  if ( byte_17DF10 == *ii )
                  {
                    v22 = 1;
                    break;
                  }
                }
              }
              if ( !v22 )
              {
                *(_BYTE *)(dword_D41A4 + 38402) = 1;
                *m = byte_17DF10;
                v2[7] = 0;
                byte_17DF10 = 0;
                v24 = v2[9];
                v2 += 9;
                if ( v24 )
                  v2[7] = 1;
                else
                  v1 = 1;
              }
            }
          }
        }
      }
      v2 += 9;
    }
    if ( (unsigned __int16)v1 >= 1u )
    {
      v25 = v34 - v38;
      if ( (unsigned __int16)v1 <= 1u )
      {
        if ( v25 > 0x32 )
        {
          v1 = 2;
          v38 = v34;
        }
        sub_2BB40(283, 381, dword_17DED4 + 648);
      }
      else if ( v1 == 2 && v25 > 0x32 )
      {
        v1 = 1;
        v38 = v34;
      }
    }
    if ( word_180660 & 1 )
      sub_90478();
    else
      sub_75200(480);
    if ( !(_WORD)v41 )
    {
      sub_90B27((char *)dword_17DE38, 0x20u, 0);
      v41 = 1;
    }
    v8 = v36 - v35;
    if ( (unsigned int)(v36 - v35) > 0xA )
    {
      sub_7A060();
      v8 = v36;
      v35 = v36;
    }
    if ( byte_17DF10 == 1 )
      v44 = 2;
    if ( byte_17DF10 == 28 )
    {
      if ( v1 )
        v44 = 2;
    }
  }
  sub_81DB0();
  LOWORD(v26) = sub_90B27(0, 0x10u, 0);
  if ( word_180660 & 1 )
  {
    v26 = dword_180628;
    sub_72883(dword_180628, (void *)dword_180628, 0xC8u, 0);
  }
  else
  {
    sub_728A9(v26, (void *)dword_180628, 0x1E0u, 0);
  }
  if ( word_180660 & 1 )
    sub_72883(v26, (void *)dword_E9C38, 0xC8u, 0);
  else
    sub_728A9(v26, (void *)dword_E9C38, 0x1E0u, 0);
  sub_7B5A0();
  if ( word_180660 & 1 )
    sub_90478();
  else
    sub_75200(480);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, 0, 768);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE40, dword_17DEDC, 168081);
  sub_7AA70(0, 0, 0, 0);
  sub_8CD27(dword_EB394);
  sub_41A90((unsigned __int8 *)dword_17DE38);
  sub_8CD27(dword_17DED4 + 234);
  if ( word_180660 & 1 )
    sub_9A128((const void *)dword_180628, (void *)dword_E9C38, 0xC8u);
  else
    sub_9A144((const void *)dword_180628, (void *)dword_E9C38, 0x1E0u);
  return 1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E28B6: using guessed type __int16 word_E28B6;
// E9C38: using guessed type int dword_E9C38;
// EB394: using guessed type int dword_EB394;
// EB39E: using guessed type char byte_EB39E;
// EB3A4: using guessed type char byte_EB3A4;
// EB3A8: using guessed type char byte_EB3A8;
// 17DE38: using guessed type int dword_17DE38;
// 17DE40: using guessed type int dword_17DE40;
// 17DED4: using guessed type int dword_17DED4;
// 17DEDC: using guessed type int dword_17DEDC;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (00079E10) --------------------------------------------------------
signed int __cdecl sub_79E10(char *a1, char a2)
{
  signed int result; // eax

  result = 0;
  switch ( a2 )
  {
    case 12:
    case 13:
      *(_WORD *)a1 = word_D1B40;
      result = 1;
      break;
    case 16:
      *(_WORD *)a1 = word_D1B24;
      result = 1;
      break;
    case 17:
      *(_WORD *)a1 = word_D1B30;
      result = 1;
      break;
    case 18:
      *(_WORD *)a1 = word_D1B08;
      result = 1;
      break;
    case 20:
      *(_WORD *)a1 = word_D1B28;
      result = 1;
      break;
    case 21:
      *(_WORD *)a1 = word_D1B38;
      result = 1;
      break;
    case 22:
      *(_WORD *)a1 = word_D1B2C;
      result = 1;
      break;
    case 28:
      result = 1;
      strcpy(a1, "ENTER");
      break;
    case 29:
      result = 1;
      strcpy(a1, "CTRL");
      break;
    case 30:
      *(_WORD *)a1 = word_D1B00;
      result = 1;
      break;
    case 33:
      *(_WORD *)a1 = word_D1B0C;
      result = 1;
      break;
    case 34:
      *(_WORD *)a1 = word_D1B10;
      result = 1;
      break;
    case 35:
      *(_WORD *)a1 = word_D1B14;
      result = 1;
      break;
    case 36:
      *(_WORD *)a1 = word_D1B18;
      result = 1;
      break;
    case 37:
      *(_WORD *)a1 = word_D1B1C;
      result = 1;
      break;
    case 39:
      *(_WORD *)a1 = word_D1B44;
      result = 1;
      break;
    case 42:
      result = 1;
      strcpy(a1, "Left Shift");
      break;
    case 43:
      *(_WORD *)a1 = word_D1B48;
      result = 1;
      break;
    case 44:
      *(_WORD *)a1 = word_D1B3C;
      result = 1;
      break;
    case 45:
      *(_WORD *)a1 = word_D1B34;
      result = 1;
      break;
    case 48:
      *(_WORD *)a1 = word_D1B04;
      result = 1;
      break;
    case 49:
      *(_WORD *)a1 = word_D1B20;
      result = 1;
      break;
    case 51:
      *(_WORD *)a1 = word_D1B4C;
      result = 1;
      break;
    case 52:
      *(_WORD *)a1 = word_D1B50;
      result = 1;
      break;
    case 53:
      *(_WORD *)a1 = word_D1B54;
      result = 1;
      break;
    case 54:
      result = 1;
      strcpy(a1, "Right Shift");
      break;
    case 56:
      *(_DWORD *)a1 = dword_D1AE4;
      result = 1;
      break;
    case 72:
      result = 1;
      strcpy(a1, "UP");
      break;
    case 75:
      result = 1;
      strcpy(a1, "LEFT");
      break;
    case 77:
      result = 1;
      strcpy(a1, "RIGHT");
      break;
    case 80:
      result = 1;
      strcpy(a1, "DOWN");
      break;
    default:
      return result;
  }
  return result;
}
// D1AE4: using guessed type int dword_D1AE4;
// D1B00: using guessed type __int16 word_D1B00;
// D1B04: using guessed type __int16 word_D1B04;
// D1B08: using guessed type __int16 word_D1B08;
// D1B0C: using guessed type __int16 word_D1B0C;
// D1B10: using guessed type __int16 word_D1B10;
// D1B14: using guessed type __int16 word_D1B14;
// D1B18: using guessed type __int16 word_D1B18;
// D1B1C: using guessed type __int16 word_D1B1C;
// D1B20: using guessed type __int16 word_D1B20;
// D1B24: using guessed type __int16 word_D1B24;
// D1B28: using guessed type __int16 word_D1B28;
// D1B2C: using guessed type __int16 word_D1B2C;
// D1B30: using guessed type __int16 word_D1B30;
// D1B34: using guessed type __int16 word_D1B34;
// D1B38: using guessed type __int16 word_D1B38;
// D1B3C: using guessed type __int16 word_D1B3C;
// D1B40: using guessed type __int16 word_D1B40;
// D1B44: using guessed type __int16 word_D1B44;
// D1B48: using guessed type __int16 word_D1B48;
// D1B4C: using guessed type __int16 word_D1B4C;
// D1B50: using guessed type __int16 word_D1B50;
// D1B54: using guessed type __int16 word_D1B54;

//----- (0007A060) --------------------------------------------------------
char sub_7A060()
{
  char result; // al

  word_17DEEE = 0;
  if ( word_180746 )
    word_17DEEE = 1;
  if ( word_180744 )
    LOBYTE(word_17DEEE) = word_17DEEE | 2;
  dword_17DEE4 = dword_E3760;
  sub_7C050(SHIWORD(dword_E3760), 0);
  result = byte_17DF10;
  word_180744 = 0;
  word_180746 = 0;
  word_18074A = 0;
  word_18074C = 0;
  return result;
}
// E3760: using guessed type int dword_E3760;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;
// 18074A: using guessed type __int16 word_18074A;
// 18074C: using guessed type __int16 word_18074C;

//----- (0007A110) --------------------------------------------------------
void __cdecl sub_7A110(char a1, char a2)
{
  int v2; // eax

  dword_17DE38 = dword_EA3D8;
  word_17DEEC = 0;
  dword_17DE40 = dword_180628;
  dword_17DEE0 = -1;
  v2 = *(_DWORD *)(dword_D41A4 + 226);
  dword_17DEDC = 0;
  dword_17DE48 = v2;
  sub_7B5D0();
  if ( a1 == 8 )
  {
    switch ( a2 )
    {
      case 4:
        dword_17DED8 = (int)&loc_36F44 + dword_17DE48;
        dword_17DED4 = (int)&loc_36CAA + dword_17DE48;
        dword_17DE4C = (int)&loc_36F44 + dword_17DE48 + 2;
        dword_17DE54 = (int)&loc_36F44 + dword_17DE48 + 16386;
        dword_17DEC4 = (int)&loc_36F44 + dword_17DE48 + 24631;
        dword_17DE50 = (int)&loc_36F44 + dword_17DE48 + 24631;
        dword_17DEC0 = (int)&loc_36F44 + dword_17DE48 + 22999;
        qmemcpy(
          (char *)&loc_36F44 + dword_17DE48 + 24631,
          (const void *)(dword_D41A0 + 11230 + 2124 * *(signed __int16 *)(dword_D41A0 + 12) + 927),
          0x20u);
        dword_E9C38 = dword_17DE50 + 32;
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, 0, 768);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_E9C38, dword_17DEDC, 168081);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE48, dword_17DEDC, 102213);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DED4, dword_17DEDC, 411);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE54, (int)&unk_13ACCA, 1226);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC0, (int)&unk_13B194, 548);
        sub_7AA70(0, 0, 0, 0);
        if ( word_180660 & 1 )
          sub_98709(dword_17DED4, dword_17DED8, dword_17DE48);
        else
          sub_9874D((unsigned int *)dword_17DED4, dword_17DED8, dword_17DE48);
        if ( word_180660 & 1 )
          sub_98709(dword_17DEC0, dword_17DEC4, dword_17DE54);
        else
          sub_9874D((unsigned int *)dword_17DEC0, dword_17DEC4, dword_17DE54);
        word_17DF06 = 72;
        word_17DF08 = 68;
        word_17DF0A = 69;
        word_17DF0C = 70;
        word_17DF0E = 71;
        break;
      case 6:
        dword_17DE54 = dword_17DE48 + 301787;
        dword_17DEC4 = dword_17DE48 + 316179;
        dword_17DE58 = dword_17DE48 + 316179;
        dword_17DEC8 = dword_17DE48 + 322754;
        dword_17DECC = dword_17DE48 + 324380;
        dword_17DED4 = dword_17DE48 + 324380;
        dword_17DED8 = dword_17DE48 + 326258;
        dword_17DE60 = dword_17DE44;
        dword_17DE64 = dword_17DE48 + 326258;
        dword_17DE3C = (int)&unk_12C000 + dword_17DE48 + 326258;
        dword_17DEC0 = dword_17DE48 + 314541;
        dword_17DE5C = dword_17DE3C + 0x4000;
        sub_7AA70((int)aDataScreensHsc, (char *)(dword_17DE48 + 301787), (int)&unk_1641FC, 1214);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC0, (int)&unk_1646BA, 589);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE58, (int)&unk_164907, 1191);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC8, (int)&unk_164DAE, 543);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, (int)&unk_13A9CA, 768);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE64, (int)&loc_B2C44 + 3, (int)&loc_87D80 + 3);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE48, (int)&loc_783BD, 103577);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DED4, (int)&off_91856, 1027);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE3C, (int)&unk_13B3B8, 6760);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE60, (int)&unk_13CE20, 20581);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE5C, (int)&unk_141E85, 13195);
        sub_7AA70(0, 0, 0, 0);
        if ( word_180660 & 1 )
          sub_98709(dword_17DED4, dword_17DED8, dword_17DE48);
        else
          sub_9874D((unsigned int *)dword_17DED4, dword_17DED8, dword_17DE48);
        if ( word_180660 & 1 )
          sub_98709(dword_17DEC0, dword_17DEC4, dword_17DE54);
        else
          sub_9874D((unsigned int *)dword_17DEC0, dword_17DEC4, dword_17DE54);
        if ( word_180660 & 1 )
          sub_98709(dword_17DEC8, dword_17DECC, dword_17DE58);
        else
          sub_9874D((unsigned int *)dword_17DEC8, dword_17DECC, dword_17DE58);
        word_17DF06 = 254;
        word_17DF08 = 255;
        word_17DF0A = 256;
        word_17DF0C = 257;
        word_17DF0E = 258;
        dword_17DEC0 += 6;
        break;
      case 7:
        dword_17DE48 += 371200;
        dword_17DE54 = dword_17DE48 + 42428;
        dword_17DEC4 = dword_17DE48 + 50673;
        dword_17DED4 = dword_17DE48 + 50673;
        dword_17DED8 = dword_17DE48 + 50871;
        dword_17DE3C = dword_17DE48 + 50871;
        dword_17DE4C = dword_17DE48 + 51639;
        dword_17DEC0 = dword_17DE48 + 49041;
        dword_17DE50 = dword_17DE48 + 68023;
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, (int)&loc_42471, 768);
        sub_7AA70((int)aDataScreensHsc, *(char **)(dword_D41A4 + 226), dword_17DEDC, 82233);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE48, (int)&loc_568AA, 21216);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DED4, 375690, 148);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE54, (int)&unk_13ACCA, 1226);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC0, (int)&unk_13B194, 548);
        if ( word_180660 & 1 )
          sub_98709(dword_17DED4, dword_17DED8, dword_17DE48);
        else
          sub_9874D((unsigned int *)dword_17DED4, dword_17DED8, dword_17DE48);
        if ( word_180660 & 1 )
          sub_98709(dword_17DEC0, dword_17DEC4, dword_17DE54);
        else
          sub_9874D((unsigned int *)dword_17DEC0, dword_17DEC4, dword_17DE54);
        break;
      case 12:
        sub_7AA70((int)aDataScreensHsc, (char *)dword_E9C38, (int)&loc_91C54 + 5, 134382);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, (int)&off_B2947, 768);
        break;
      case 14:
        dword_17DE48 += (int)&loc_4D54A;
        dword_17DE54 = (int)&loc_36CAA + dword_17DE48;
        dword_17DEC4 = dword_17DE48 + 232671;
        dword_17DED4 = dword_17DE48 + 232671;
        dword_17DED8 = dword_17DE48 + 233337;
        dword_17DE4C = dword_17DE48 + 233339;
        dword_17DE50 = dword_17DE48 + 249723;
        dword_17DEC0 = dword_17DE48 + 231039;
        qmemcpy(
          (void *)(dword_17DE48 + 249723),
          (const void *)(dword_D41A0 + 11230 + 2124 * *(signed __int16 *)(dword_D41A0 + 12) + 927),
          0x20u);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE54, (int)&unk_13ACCA, 1226);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC0, (int)&unk_13B194, 548);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE48, 168849, 102213);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DED4, 271062, 411);
        sub_7AA70((int)aDataScreensHsc, *(char **)(dword_D41A4 + 226), (int)&loc_91C54 + 5, 134382);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, (int)&off_B2947, 768);
        if ( word_180660 & 1 )
          sub_98709(dword_17DED4, dword_17DED8, dword_17DE48);
        else
          sub_9874D((unsigned int *)dword_17DED4, dword_17DED8, dword_17DE48);
        if ( word_180660 & 1 )
          sub_98709(dword_17DEC0, dword_17DEC4, dword_17DE54);
        else
          sub_9874D((unsigned int *)dword_17DEC0, dword_17DEC4, dword_17DE54);
        break;
      case 15:
        sub_7AA70((int)aDataScreensHsc, (char *)dword_E9C38, (int)&unk_145210, 126188);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, (int)&unk_163EFC, 768);
        break;
      default:
        return;
    }
  }
}
// 91856: using guessed type void *off_91856;
// B2947: using guessed type void *off_B2947;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E9C38: using guessed type int dword_E9C38;
// EA3D8: using guessed type int dword_EA3D8;
// 17DE38: using guessed type int dword_17DE38;
// 17DE3C: using guessed type int dword_17DE3C;
// 17DE40: using guessed type int dword_17DE40;
// 17DE44: using guessed type int dword_17DE44;
// 17DE48: using guessed type int dword_17DE48;
// 17DE4C: using guessed type int dword_17DE4C;
// 17DE50: using guessed type int dword_17DE50;
// 17DE54: using guessed type int dword_17DE54;
// 17DE58: using guessed type int dword_17DE58;
// 17DE5C: using guessed type int dword_17DE5C;
// 17DE60: using guessed type int dword_17DE60;
// 17DE64: using guessed type int dword_17DE64;
// 17DEC0: using guessed type int dword_17DEC0;
// 17DEC4: using guessed type int dword_17DEC4;
// 17DEC8: using guessed type int dword_17DEC8;
// 17DECC: using guessed type int dword_17DECC;
// 17DED4: using guessed type int dword_17DED4;
// 17DED8: using guessed type int dword_17DED8;
// 17DEDC: using guessed type int dword_17DEDC;
// 17DEE0: using guessed type int dword_17DEE0;
// 17DEEC: using guessed type __int16 word_17DEEC;
// 17DF06: using guessed type __int16 word_17DF06;
// 17DF08: using guessed type __int16 word_17DF08;
// 17DF0A: using guessed type __int16 word_17DF0A;
// 17DF0C: using guessed type __int16 word_17DF0C;
// 17DF0E: using guessed type __int16 word_17DF0E;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0007AA70) --------------------------------------------------------
signed int __cdecl sub_7AA70(int a1, char *a2, int a3, int a4)
{
  signed int result; // eax

  if ( dword_17DEE0 != -1 || (result = sub_98817(a1, 512), dword_17DEE0 = result, result != -1) )
  {
    result = dword_17DEE0;
    if ( dword_17DEE0 != -1 )
    {
      if ( a2 )
      {
        sub_9891E(dword_17DEE0, a3, 0);
        sub_988A7(dword_17DEE0, (int)a2, a4);
        result = sub_5C3D0((int)a2, a2);
        dword_17DEDC = a4 + a3;
      }
      else
      {
        result = sub_98882(dword_17DEE0);
        dword_17DEE0 = -1;
      }
    }
  }
  return result;
}
// 17DEDC: using guessed type int dword_17DEDC;
// 17DEE0: using guessed type int dword_17DEE0;

//----- (0007AB00) --------------------------------------------------------
int (__cdecl **__usercall sub_7AB00@<eax>(__int16 a1@<ax>, int a2@<edx>, signed __int16 *a3@<ebx>, unsigned __int8 a4))(int)
{
  _WORD *v4; // esi
  int v5; // eax
  int v6; // edi
  signed __int16 v7; // ax
  _WORD *i; // ebx
  int v10; // [esp+0h] [ebp-4h]

  HIBYTE(a1) = a4;
  v4 = 0;
  if ( a4 >= 4u )
  {
    if ( a4 <= 4u )
    {
      a3 = (signed __int16 *)&unk_E1748;
    }
    else if ( a4 == 6 )
    {
      a3 = (signed __int16 *)&unk_E1784;
    }
  }
  while ( a3[2] )
  {
    v5 = j___clock(a1, a2, a3);
    v6 = v5;
    v10 = v5;
    a1 = sub_2BB40(a3[2], a3[3], 6 * a3[4] + dword_17DED4);
    if ( (unsigned int)(v6 - *(_DWORD *)a3) >> 2 >= 1 )
    {
      LOWORD(a2) = a3[4];
      ++a2;
      v7 = *((unsigned __int8 *)a3 + 11);
      a3[4] = a2;
      if ( v7 < (signed __int16)a2 )
        a3[4] = *((unsigned __int8 *)a3 + 10);
      a1 = v10;
      *(_DWORD *)a3 = v10;
    }
    a3 += 6;
  }
  if ( a4 == 4 )
  {
    for ( i = off_E1BAC; i[5]; i += 22 )
    {
      if ( *((_BYTE *)i + 23) && *((_BYTE *)i + 24) )
      {
        v4 = i;
        sub_2BB40(i[5], i[6], dword_17DED4 + 6 * *((unsigned __int8 *)i + 21));
      }
    }
  }
  return (int (__cdecl **)(int))v4;
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 17DED4: using guessed type int dword_17DED4;

//----- (0007AC00) --------------------------------------------------------
int sub_7AC00()
{
  char v0; // al
  unsigned __int8 v1; // al
  unsigned __int8 v2; // al

  if ( !(word_180660 & 8) )
  {
    if ( dword_E9C3C )
    {
      sub_83E80(dword_E9C3C);
      dword_E9C3C = 0;
    }
    sub_54600();
    sub_6EBF0((unsigned int **)&off_D918C);
    if ( word_180660 == 1 )
    {
      word_E29DA = word_180660;
      word_180660 = 8;
      dword_E9C3C = sub_83CD0(307200);
      sub_6EB90((unsigned int **)&off_D918C);
      memset(dword_EA3D8, 0, 768);
      if ( word_180660 & 1 )
      {
        v0 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
        sub_72883(dword_180628, (void *)dword_180628, 0xC8u, v0);
      }
      else
      {
        v1 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
        sub_728A9(v1, (void *)dword_180628, 0x1E0u, v1);
      }
      memset(dword_EA3D8, 0, 768);
      sub_41A90((unsigned __int8 *)dword_EA3D8);
      if ( word_180660 & 1 )
        sub_90D6E((unsigned __int8 *)dword_EA3D8);
      else
        sub_90E07((unsigned __int8 *)dword_EA3D8);
      sub_41A90((unsigned __int8 *)dword_EA3D8);
      v2 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
      byte_EB3A8 = v2;
      if ( word_180660 & 1 )
        sub_72883(v2, (void *)dword_180628, 0xC8u, v2);
      else
        sub_728A9(v2, (void *)dword_180628, 0x1E0u, v2);
      sub_8CEDF();
      sub_8CD27(dword_EB394);
    }
  }
  return sub_8CD27(dword_EB394);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D918C: using guessed type int *off_D918C;
// E29DA: using guessed type __int16 word_E29DA;
// E9C3C: using guessed type int dword_E9C3C;
// EA3D8: using guessed type int dword_EA3D8;
// EB394: using guessed type int dword_EB394;
// EB3A8: using guessed type char byte_EB3A8;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0007ADE0) --------------------------------------------------------
int __cdecl sub_7ADE0(char a1)
{
  char v1; // al
  unsigned __int8 v2; // al
  unsigned __int8 v3; // al

  if ( a1 == 1 )
  {
    if ( dword_E9C3C )
    {
      sub_83E80(dword_E9C3C);
      dword_E9C3C = 0;
    }
    sub_54600();
    sub_6EBF0((unsigned int **)&off_D918C);
    word_180660 = 1;
    word_E29DA = 1;
    dword_E9C3C = sub_83CD0(64000);
    sub_6EB90((unsigned int **)&off_D918C);
    memset(dword_EA3D8, 0, 768);
    if ( word_180660 & 1 )
    {
      v1 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
      sub_72883(dword_180628, (void *)dword_180628, 0xC8u, v1);
    }
    else
    {
      v2 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
      sub_728A9(v2, (void *)dword_180628, 0x1E0u, v2);
    }
    memset(dword_EA3D8, 0, 768);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
    if ( word_180660 & 1 )
      sub_90D6E((unsigned __int8 *)dword_EA3D8);
    else
      sub_90E07((unsigned __int8 *)dword_EA3D8);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
    v3 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
    byte_EB3A8 = v3;
    if ( word_180660 & 1 )
      sub_72883(v3, (void *)dword_180628, 0xC8u, v3);
    else
      sub_728A9(v3, (void *)dword_180628, 0x1E0u, v3);
    sub_8CEDF();
  }
  return sub_8CD27(dword_EB394);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D918C: using guessed type int *off_D918C;
// E29DA: using guessed type __int16 word_E29DA;
// E9C3C: using guessed type int dword_E9C3C;
// EA3D8: using guessed type int dword_EA3D8;
// EB394: using guessed type int dword_EB394;
// EB3A8: using guessed type char byte_EB3A8;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0007B200) --------------------------------------------------------
bool __cdecl sub_7B200(_WORD *a1, __int16 a2, __int16 a3)
{
  __int16 v3; // dx
  __int16 v4; // bx
  bool result; // eax

  v3 = a1[5];
  result = 0;
  if ( a2 >= v3 && a2 < v3 + (signed __int16)a1[7] )
  {
    v4 = a1[6];
    if ( a3 >= v4 && a3 < v4 + (signed __int16)a1[8] )
      result = 1;
  }
  return result;
}

//----- (0007B250) --------------------------------------------------------
char __fastcall sub_7B250(int a1, int a2, __int16 a3)
{
  int (__cdecl **i)(int); // esi
  char result; // al
  int (__cdecl **j)(int); // esi
  char v6; // ah
  __int16 v7; // bx
  char *v8; // esi
  int (__cdecl **v9)(int); // edi
  _WORD *v10; // edi
  int v11; // eax
  int v12; // edx
  int v13; // eax
  char v14; // [esp+0h] [ebp-24h]
  char v15; // [esp+10h] [ebp-14h]

  for ( i = (int (__cdecl **)(int))off_E1BAC; *((_WORD *)i + 5); i += 11 )
  {
    if ( *((_WORD *)i + 4) && *i )
    {
      if ( (unsigned __int8)(*i)((int)i) )
      {
        *((_WORD *)i + 4) = 0;
        sub_7B5A0();
      }
      if ( i[1] )
      {
        *((_WORD *)i + 4) = 0;
        sub_6EDB0();
        sub_7A110(word_180660, 4);
        sub_7B5A0();
        sub_8CD27(dword_17DED4 + 234);
        if ( i[1] == (int (__cdecl *)(int))2 )
          i[1] = 0;
        return 1;
      }
      return 0;
    }
  }
  for ( j = (int (__cdecl **)(int))off_E1BAC; *((_WORD *)j + 5); j += 11 )
  {
    *((_WORD *)j + 4) = 0;
    v6 = byte_17DF10;
    *((_BYTE *)j + 24) = 0;
    if ( v6 == 1 && *((_BYTE *)j + 22) == 11 )
      *((_WORD *)j + 4) = 1;
  }
  if ( byte_17DF10 == 1 )
  {
    byte_17DF10 = 0;
  }
  else
  {
    j = (int (__cdecl **)(int))off_E1BAC;
    if ( off_E1BAC[5] )
    {
      while ( !sub_7B200(j, dword_17DEE4, SHIWORD(dword_17DEE4)) || !*((_BYTE *)j + 23) )
      {
        j += 11;
        if ( !*((_WORD *)j + 5) )
          goto LABEL_28;
      }
      if ( word_17DEEE & 1 )
      {
        sub_8F100(0, 14, 127, 64, 0x64u, 0, 3u);
        *((_WORD *)j + 4) = 1;
        sub_7B5A0();
      }
      else
      {
        *((_BYTE *)j + 24) = 1;
        byte_17DBC6 = 1;
      }
    }
  }
LABEL_28:
  if ( *(_BYTE *)(dword_D41A4 + 10) != 1 || !byte_17DF13 || word_E29DC )
    return 0;
  LOBYTE(a3) = byte_17DBC6;
  if ( byte_17DBC6 == 2 )
  {
    dword_17DBBC = j___clock(dword_D41A4, a2, a3);
    if ( (dword_17DBBC - dword_17DBB8) / 0x64u > 1 )
    {
      v7 = word_E25DE[9 * (signed __int16)(word_17DBC4++ + 1)];
      if ( !v7 )
        word_17DBC4 = 0;
      dword_17DBB8 = dword_17DBBC;
    }
    memset(&v14, 0, 36);
    v8 = (char *)&unk_E25DC + 18 * word_17DBC4;
    qmemcpy(&v14, v8, 0x10u);
    qmemcpy(&v15, v8 + 16, 2u);
    v9 = (int (__cdecl **)(int))off_E1BAC;
    sub_7E840((signed __int16 *)&v14, 80, 89);
    if ( !off_E1BAC[5] )
      return 0;
    do
    {
      if ( *((_BYTE *)v9 + 22) == byte_E25ED[18 * word_17DBC4] )
      {
        *((_BYTE *)v9 + 24) = 1;
        return 0;
      }
      v9 += 11;
    }
    while ( *((_WORD *)v9 + 5) );
    result = 0;
  }
  else
  {
    if ( byte_17DBC6 == 3 )
    {
      dword_17DBBC = j___clock(dword_D41A4, a2, a3);
      if ( (dword_17DBBC - dword_17DBB8) / 0x64u > 1 )
      {
        byte_17DBC6 = 2;
        return 0;
      }
      return 0;
    }
    v10 = &unk_E25DC;
    if ( *((_WORD *)&unk_E25DC + 1) )
    {
      while ( *((_BYTE *)v10 + 17) != *((_BYTE *)j + 22) )
      {
        v10 += 9;
        if ( !v10[1] )
          return 0;
      }
      memset(&v14, 0, 36);
      qmemcpy(&v14, v10, 0x10u);
      qmemcpy(&v15, v10 + 8, 2u);
      v11 = sub_7E840((signed __int16 *)&v14, 80, 89);
      v13 = j___clock(v11, v12, a3);
      dword_17DBBC = v13;
      dword_17DBB8 = v13;
      byte_17DBC6 = 3;
      result = 0;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E25DE: using guessed type __int16 word_E25DE[];
// E29DC: using guessed type __int16 word_E29DC;
// 17DBB8: using guessed type int dword_17DBB8;
// 17DBBC: using guessed type int dword_17DBBC;
// 17DBC4: using guessed type __int16 word_17DBC4;
// 17DBC6: using guessed type char byte_17DBC6;
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 17DF13: using guessed type char byte_17DF13;
// 180660: using guessed type __int16 word_180660;

//----- (0007B5A0) --------------------------------------------------------
void sub_7B5A0()
{
  _disable();
  word_17DEEE = 0;
  word_180744 = 0;
  word_18074A = 0;
  word_180746 = 0;
  word_18074C = 0;
  _enable();
}
// 17DEEE: using guessed type __int16 word_17DEEE;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;
// 18074A: using guessed type __int16 word_18074A;
// 18074C: using guessed type __int16 word_18074C;

//----- (0007B5D0) --------------------------------------------------------
void sub_7B5D0()
{
  int v0; // eax

  sub_90B27(0, 0x10u, 0);
  v0 = memset(dword_EA3D8, 0, 768);
  BYTE1(v0) = word_180660;
  if ( word_180660 & 1 )
    sub_72883(v0, (void *)dword_180628, 0xC8u, 0);
  else
    sub_728A9(v0, (void *)dword_180628, 0x1E0u, 0);
  if ( word_180660 & 1 )
    sub_90478();
  else
    sub_75200(480);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// EA3D8: using guessed type int dword_EA3D8;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0007B660) --------------------------------------------------------
int __cdecl sub_7B660(int a1, int a2, __int16 a3, _WORD *a4, _BYTE *a5, char a6)
{
  int v6; // ebx
  unsigned __int8 v7; // al
  int v8; // edx
  __int16 v9; // ax
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // edx
  int v14; // esi
  int v15; // esi
  int v16; // eax
  int v17; // ecx
  __int16 v18; // bx
  int v19; // edx
  __int16 v20; // si
  __int16 v21; // ax
  __int16 v22; // cx
  __int16 v23; // bx
  int v24; // edx
  int v25; // eax
  int v26; // eax
  __int16 v27; // cx
  int v28; // edx
  int v29; // eax
  int v30; // ebx
  unsigned __int8 v31; // al
  char v33; // [esp+0h] [ebp-4Ch]
  __int16 v34; // [esp+Ah] [ebp-42h]
  __int16 v35; // [esp+Ch] [ebp-40h]
  __int16 v36; // [esp+Eh] [ebp-3Eh]
  __int16 v37; // [esp+10h] [ebp-3Ch]
  int v38; // [esp+2Ch] [ebp-20h]
  int v39; // [esp+30h] [ebp-1Ch]
  int v40; // [esp+34h] [ebp-18h]
  int v41; // [esp+38h] [ebp-14h]
  int v42; // [esp+3Ch] [ebp-10h]
  int v43; // [esp+40h] [ebp-Ch]
  unsigned __int8 v44; // [esp+44h] [ebp-8h]
  unsigned __int8 v45; // [esp+48h] [ebp-4h]
  int v46; // [esp+64h] [ebp+18h]

  HIWORD(v6) = HIWORD(a4);
  v44 = 0;
  if ( !a3 )
  {
    sub_7C120(a1, a2, dword_17DED4 + 6 * word_17DF06);
    goto LABEL_31;
  }
  v45 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x25u, 0x1Fu, 0x19u);
  v38 = (signed __int16)a2;
  v41 = (signed __int16)a1;
  sub_7C120(a1, a2, 6 * word_17DF06 + dword_17DED4);
  v7 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x2Au, 0x24u, 0x1Du);
  sub_7C140(
    (signed __int16)(a1 + 10),
    a2 + *(unsigned __int8 *)(dword_17DED4 + 6 * word_17DF06 + 5) - 2,
    (signed __int16)(*(unsigned __int8 *)(dword_17DED4 + 6 * word_17DF06 + 4) - 22),
    a3,
    v7);
  v39 = v45;
  v40 = (signed __int16)(a3 + a2);
  sub_2BD10(a1 + 10, a2, a1 + 10, a3 + a2, v45);
  v8 = 6 * word_17DF06 + dword_17DED4;
  v9 = a2 + *(unsigned __int8 *)(v8 + 5) - 2;
  sub_2BD10(a1 + *(unsigned __int8 *)(v8 + 4) - 12, v9, a1 + *(unsigned __int8 *)(v8 + 4) - 12, v9 + a3, v45);
  v10 = sub_7C120(a1, v40, dword_17DED4 + 6 * word_17DF06);
  if ( a4[5] >= a4[4] )
  {
    switch ( a6 )
    {
      case 3:
        LOWORD(v10) = *a4;
        v43 = v10 + 15;
        v12 = 6 * word_17DF0C;
        v13 = v12 + dword_17DED4;
        LOWORD(v11) = a4[4];
        LOWORD(v12) = a4[1];
        LOWORD(v14) = *(unsigned __int8 *)(v13 + 5);
        HIWORD(v14) = (signed __int16)a1 >> 15;
        v15 = v11 + v12 - v14;
        v35 = v15;
        v34 = v43;
        v36 = *(unsigned __int8 *)(v13 + 4);
        v37 = *(unsigned __int8 *)(v13 + 5);
        if ( sub_7B200(&v33, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        {
          sub_7C120(v43, v15, dword_17DED4 + 6 * word_17DF0E);
          if ( word_17DEEE & 1 )
            v44 = 1;
        }
        else
        {
          sub_7C120(v43, v15, dword_17DED4 + 6 * word_17DF0C);
        }
        v16 = 3 * word_17DF06;
        LOWORD(v16) = *(unsigned __int8 *)(dword_17DED4 + 6 * word_17DF06 + 4);
        LOWORD(v6) = *a4;
        v42 = v16 - 12 + v6;
        v17 = dword_17DED4 + 6 * word_17DF08;
        LOWORD(v16) = v42 - *(unsigned __int8 *)(v17 + 4);
        v35 = v15;
        v18 = v16;
        v34 = v16;
        v36 = *(unsigned __int8 *)(v17 + 4);
        v39 = word_17DF0A;
        v37 = *(unsigned __int8 *)(6 * word_17DF0A + dword_17DED4 + 5);
        if ( sub_7B200(&v33, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        {
          sub_7C120(v18, v15, dword_17DED4 + 6 * word_17DF0A);
          if ( word_17DEEE & 1 )
            v44 = 2;
        }
        else
        {
          sub_7C120(v18, v15, dword_17DED4 + 6 * word_17DF08);
        }
        goto LABEL_23;
      case 1:
        v19 = 6 * word_17DF0C + dword_17DED4;
        v20 = *a4 + 30;
        v21 = a4[4] + a4[1];
        v22 = *(unsigned __int8 *)(v19 + 5);
        v34 = *a4 + 30;
        v23 = v21 - v22;
        v35 = v21 - v22;
        v36 = *(unsigned __int8 *)(v19 + 4);
        v37 = *(unsigned __int8 *)(v19 + 5);
        if ( sub_7B200(&v33, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        {
          sub_7C120(v20, v23, dword_17DED4 + 6 * word_17DF0E);
          if ( word_17DEEE & 1 )
            v44 = 1;
          goto LABEL_23;
        }
        v24 = dword_17DED4;
        v25 = 6 * word_17DF0E;
        break;
      case 2:
        v26 = 3 * word_17DF0C;
        v20 = *a4 + 40;
        LOWORD(v26) = *(unsigned __int8 *)(dword_17DED4 + 6 * word_17DF0C + 5);
        v27 = a4[4];
        v42 = v26;
        v23 = v27 + a4[1] - (unsigned __int8)v26;
        v35 = v27 + a4[1] - (unsigned __int8)v26;
        v39 = word_17DF08;
        v28 = 6 * word_17DF08 + dword_17DED4;
        v34 = v20;
        v36 = *(unsigned __int8 *)(v28 + 4);
        v37 = *(unsigned __int8 *)(v28 + 5);
        if ( sub_7B200(&v33, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        {
          sub_7C120(v20, v23, dword_17DED4 + 6 * word_17DF0A);
          if ( word_17DEEE & 1 )
            v44 = 1;
          goto LABEL_23;
        }
        v24 = 6 * word_17DF08;
        v25 = dword_17DED4;
        break;
      default:
        goto LABEL_23;
    }
    sub_7C120(v20, v23, v24 + v25);
LABEL_23:
    if ( !v44 )
    {
      if ( byte_17DF10 == 28 )
      {
        v44 = 1;
      }
      else if ( byte_17DF10 == 1 )
      {
        v44 = 2;
      }
    }
  }
  sub_6FC50(1);
  v29 = 6 * word_17DF06 + dword_17DED4;
  v30 = a1 + 10 + *(unsigned __int8 *)(v29 + 4) - 22;
  LOWORD(v29) = *(unsigned __int8 *)(v29 + 5);
  v46 = v29 + 2 + a2;
  if ( a5 )
  {
    v31 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x16u, 0x10u, 9u);
    sub_7FCB0(v30, a5, (signed __int16)(a1 + 10), (signed __int16)v30, (signed __int16)v46, 1, v31, 0);
  }
LABEL_31:
  if ( v44 )
    sub_8F100(0, 14, 127, 64, 0x64u, 0, 3u);
  return v44;
}
// 17DE38: using guessed type int dword_17DE38;
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF06: using guessed type __int16 word_17DF06;
// 17DF08: using guessed type __int16 word_17DF08;
// 17DF0A: using guessed type __int16 word_17DF0A;
// 17DF0C: using guessed type __int16 word_17DF0C;
// 17DF0E: using guessed type __int16 word_17DF0E;
// 17DF10: using guessed type char byte_17DF10;

//----- (0007BEC0) --------------------------------------------------------
int (__cdecl **sub_7BEC0())(int)
{
  int (__cdecl **result)(int); // eax
  unsigned __int8 v1; // dl

  result = (int (__cdecl **)(int))off_E1BAC;
  if ( off_E1BAC[5] )
  {
    do
    {
      *((_WORD *)result + 4) = 0;
      v1 = *((_BYTE *)result + 22);
      *((_BYTE *)result + 24) = 0;
      if ( v1 >= 7u )
      {
        if ( v1 <= 7u )
        {
          *((_BYTE *)result + 23) = *(_WORD *)(dword_D41A4 + 216) != 0;
        }
        else if ( v1 == 13 )
        {
          *((_BYTE *)result + 23) = 1;
        }
      }
      result += 11;
    }
    while ( *((_WORD *)result + 5) );
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;

//----- (0007BF20) --------------------------------------------------------
int __cdecl sub_7BF20(signed __int16 *a1)
{
  _BYTE *v1; // esi
  int result; // eax
  int v3; // edx
  signed __int16 v4; // di
  signed __int16 v5; // cx
  int v6; // eax
  signed __int16 v7; // ax

  v1 = 0;
  result = 0;
  if ( !*a1 )
    return result;
  if ( *(_BYTE *)(dword_D41A4 + 10) == 1 )
    byte_17DF13 = 0;
  sub_6FC50(1);
  if ( !a1[7] )
  {
    v4 = a1[5];
    if ( v4 )
    {
      if ( v4 <= a1[4] - 1 )
        a1[5] = v4 + 16;
      else
        a1[5] = a1[4];
    }
    else
    {
      ++a1[5];
    }
    goto LABEL_14;
  }
  v5 = a1[5] - 16;
  a1[5] = v5;
  if ( v5 >= 0 )
  {
LABEL_14:
    if ( a1[5] > sub_6FC30() + 10 )
      v1 = (_BYTE *)dword_E9C4C[a1[6]];
    v7 = sub_7B660(*a1, a1[1], a1[5], a1, v1, *((_BYTE *)a1 + 16));
    if ( v7 )
    {
      if ( !a1[7] )
        a1[7] = v7;
    }
    return 0;
  }
  a1[5] = 0;
  v6 = dword_D41A4;
  LOWORD(v3) = a1[7];
  a1[7] = 0;
  if ( *(_BYTE *)(v6 + 10) == 1 )
    byte_17DF13 = 1;
  return v3;
}
// D41A4: using guessed type int dword_D41A4;
// 17DF13: using guessed type char byte_17DF13;

//----- (0007C020) --------------------------------------------------------
_WORD *__cdecl sub_7C020(_WORD *a1)
{
  _WORD *result; // eax

  result = a1;
  if ( a1[2] )
  {
    a1[3] = 0;
    a1[2] = a1[3];
  }
  a1[5] = 0;
  return result;
}

//----- (0007C050) --------------------------------------------------------
signed int __fastcall sub_7C050(__int16 a1, __int16 a2)
{
  char v2; // bl
  unsigned int v3; // eax
  __int16 v4; // dx
  unsigned int v5; // esi
  _BOOL1 v6; // zf
  signed int result; // eax

  byte_17DF10 = 0;
  byte_17DF11 = 0;
  HIBYTE(a1) = 2;
  __asm { int     16h; KEYBOARD - GET SHIFT STATUS }
  HIBYTE(a2) = 1;
  v2 = a1;
  if ( a1 )
  {
    if ( a1 & 1 )
    {
      byte_17DF10 = 54;
    }
    else if ( a1 & 2 )
    {
      byte_17DF10 = 42;
    }
    else if ( a1 & 4 )
    {
      byte_17DF10 = 29;
    }
    else if ( a1 & 8 )
    {
      byte_17DF10 = 56;
    }
  }
  v3 = j___clock(a1, a2, a1);
  v5 = v3;
  do
  {
    v6 = (v2 & 1) == 0;
    if ( !(v2 & 1) )
    {
      v6 = (v2 & 2) == 0;
      if ( !(v2 & 2) )
      {
        v6 = (v2 & 4) == 0;
        if ( !(v2 & 4) )
        {
          v6 = (v2 & 8) == 0;
          if ( !(v2 & 8) )
            break;
        }
      }
    }
    BYTE1(v3) = 2;
    HIBYTE(v4) = 2;
    __asm { int     16h; KEYBOARD - GET SHIFT STATUS }
    if ( v6 )
      HIBYTE(v4) = 1;
    v2 = v3;
    v3 = j___clock((_WORD)v3, v4, (_WORD)v3) - v5;
  }
  while ( v3 <= 5 );
  while ( 1 )
  {
    result = sub_9A10A(v3);
    if ( !result )
      break;
    BYTE1(result) = 0;
    __asm { int     16h; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY }
    byte_17DF11 = result;
    v3 = (signed int)(unsigned __int16)result >> 8;
    byte_17DF10 = v3;
  }
  return result;
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 17DF10: using guessed type char byte_17DF10;
// 17DF11: using guessed type char byte_17DF11;

//----- (0007C120) --------------------------------------------------------
int __cdecl sub_7C120(__int16 a1, __int16 a2, int a3)
{
  return sub_2BB40(a1, a2, a3);
}

//----- (0007C140) --------------------------------------------------------
int __cdecl sub_7C140(int a1, __int16 a2, int a3, __int16 a4, unsigned __int8 a5)
{
  __int16 v5; // si
  __int16 v6; // bx
  int result; // eax
  __int16 v8; // dx
  __int16 v9; // cx

  v5 = a1;
  v6 = a2;
  result = a3;
  v8 = a4;
  if ( (signed __int16)a1 < 640 && a2 < 480 )
  {
    if ( a4 + a2 > 480 )
      v8 = 480 - a2;
    if ( (signed __int16)a1 + (signed __int16)a3 > 640 )
      result = 640 - a1;
    if ( (signed __int16)result >= 1 && v8 >= 1 )
    {
      if ( a2 < 0 )
      {
        v8 += a2;
        v6 = 0;
      }
      if ( (a1 & 0x8000u) != 0 )
      {
        LOWORD(result) = a1 + result;
        v5 = 0;
      }
      v9 = result;
      result = v5 + (signed __int16)result;
      if ( result >= 1 )
      {
        result = v6;
        if ( v6 + v8 >= 1 )
          result = sub_2BC80(v5, result, v9, v8, a5);
      }
    }
  }
  return result;
}

//----- (0007C200) --------------------------------------------------------
char __cdecl sub_7C200(unsigned __int8 a1)
{
  char result; // al

  result = 0;
  if ( a1 == 32 || a1 >= 0x30u && a1 <= 0x39u || a1 >= 0x41u && a1 <= 0x5Au || a1 >= 0x61u && a1 <= 0x7Au )
    result = 1;
  return result;
}

//----- (0007C230) --------------------------------------------------------
int __fastcall sub_7C230(int a1, int a2, signed __int16 *a3)
{
  __int16 v3; // ax
  int v4; // edx
  _WORD *v5; // eax
  int v6; // edx
  _WORD *v7; // ebx
  int v8; // edx

  if ( word_180660 & 1 )
  {
    a3 = (signed __int16 *)dword_E9C38;
    sub_9A128((const void *)dword_E9C38, (void *)dword_180628, 0xC8u);
  }
  else
  {
    sub_9A144((const void *)dword_E9C38, (void *)dword_180628, 0x1E0u);
  }
  v3 = sub_7C120(185, 232, dword_17DED4 + 396);
  sub_7AB00(v3, v4, a3, 4u);
  v5 = (_WORD *)sub_7BF20(word_E1F70);
  v7 = v5;
  if ( (_WORD)v5 )
  {
    word_E131A = 1;
    v5 = sub_7C020(word_E1F70);
  }
  v8 = j___clock(v5, v6, v7);
  if ( (unsigned int)(v8 - dword_E208C) >> 2 >= 1 )
  {
    if ( (unsigned __int8)byte_E2097 >= word_E2094 )
      ++word_E2094;
    else
      word_E2094 = (unsigned __int8)byte_E2096;
    dword_E208C = v8;
  }
  sub_7C120(dword_17DEE4, SHIWORD(dword_17DEE4), 6 * word_E2094 + dword_17DED4);
  if ( word_180660 & 1 )
    sub_90478();
  else
    sub_75200(480);
  sub_7A060();
  return (signed __int16)v7;
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// E131A: using guessed type __int16 word_E131A;
// E208C: using guessed type int dword_E208C;
// E2094: using guessed type __int16 word_E2094;
// E2096: using guessed type char byte_E2096;
// E2097: using guessed type char byte_E2097;
// E9C38: using guessed type int dword_E9C38;
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0007C390) --------------------------------------------------------
signed int sub_7C390()
{
  signed int result; // eax
  int *v1; // ebx
  _WORD *v2; // ebx
  int v3; // esi
  signed __int16 v4; // dx
  __int16 i; // ax
  int v6; // [esp+0h] [ebp-8h]
  char *v7; // [esp+4h] [ebp-4h]

  v6 = dword_E9C38;
  dword_E9C38 = *(_DWORD *)(dword_D41A4 + 226);
  v7 = (char *)(dword_E9C38 + 307200);
  word_17DF00 = word_17DEFE;
  qmemcpy(byte_E1BA4, byte_E1B9C, sizeof(byte_E1BA4));
  if ( (unsigned __int16)sub_7CE50() )
  {
    dword_E9C38 = v6;
    result = 1;
  }
  else
  {
    qmemcpy(byte_E1B9C, &byte_17DE68[11 * sub_74515() + 1], sizeof(byte_E1B9C));
    v1 = (int *)(&off_E1E98 + 6 * word_17DEF4);
    if ( word_180660 & 1 )
      sub_9A128((const void *)dword_E9C38, (void *)dword_180628, 0xC8u);
    else
      sub_9A144((const void *)dword_E9C38, (void *)dword_180628, 0x1E0u);
    switch ( word_17DEF6 )
    {
      case 1:
        sub_7AA70((int)aDataScreensHsc, v7, *v1, v1[1]);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE3C, v1[2], v1[3]);
        word_17DF02 = 0;
        word_17DEF6 = 3;
        v2 = off_E1D64;
        v3 = sub_7CB10();
        break;
      case 2:
        word_17DF02 += 16;
        sub_7C9D0(word_17DF02);
        if ( (unsigned __int16)word_17DF02 < 0xFFu )
          goto LABEL_13;
        sub_7C7C0((unsigned __int8)word_17DEF2, dword_E9C38);
        word_17DEF6 = 1;
        v2 = off_E1D64;
        v3 = sub_7CB10();
        break;
      case 3:
        sub_7C720(word_17DEF4, v7);
        word_17DF02 += 16;
        sub_7C800(word_17DF02);
        if ( (unsigned __int16)word_17DF02 <= 0xFEu )
          goto LABEL_13;
        word_17DEF6 = 4;
        v2 = off_E1D64;
        v3 = sub_7CB10();
        break;
      case 5:
        sub_7C7C0((unsigned __int8)word_17DEF2, dword_E9C38);
        word_17DF02 = 255;
        sub_7C9D0(255);
        word_17DEF6 = 1;
        byte_17DE72[11 * word_17DEFC] = byte_17DE72[11 * sub_74515()];
        goto LABEL_13;
      default:
LABEL_13:
        v2 = off_E1D64;
        v3 = sub_7CB10();
        break;
    }
    while ( v2[5] )
    {
      if ( *((_BYTE *)v2 + 23) && *((_BYTE *)v2 + 24) )
        sub_7C120(v2[5], v2[6], 6 * *((unsigned __int8 *)v2 + 21) + dword_17DED4);
      v2 += 22;
    }
    sub_7C140(382, 18, 16, 16, 0);
    sprintf(dword_17DE50, &aDD_2[2], (unsigned __int16)word_17DEFA);
    sub_7FAE0((char *)dword_17DE50, 382, 398, 18, 0);
    sub_7D380();
    sub_7D310();
    v4 = 0;
    for ( i = 0; i < 8; ++i )
    {
      if ( byte_E1BA4[i] != byte_E1B9C[i] )
      {
        v4 = 1;
        break;
      }
    }
    if ( v4 || word_17DF00 != word_17DEFE )
      sub_41A90((unsigned __int8 *)dword_17DE38);
    dword_E9C38 = v6;
    result = v3;
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;
// E1E98: using guessed type void *off_E1E98;
// E9C38: using guessed type int dword_E9C38;
// 17DE38: using guessed type int dword_17DE38;
// 17DE3C: using guessed type int dword_17DE3C;
// 17DE50: using guessed type int dword_17DE50;
// 17DED4: using guessed type int dword_17DED4;
// 17DEF2: using guessed type __int16 word_17DEF2;
// 17DEF4: using guessed type __int16 word_17DEF4;
// 17DEF6: using guessed type __int16 word_17DEF6;
// 17DEFA: using guessed type __int16 word_17DEFA;
// 17DEFC: using guessed type __int16 word_17DEFC;
// 17DEFE: using guessed type __int16 word_17DEFE;
// 17DF00: using guessed type __int16 word_17DF00;
// 17DF02: using guessed type __int16 word_17DF02;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0007C710) --------------------------------------------------------
void sub_7C710()
{
  word_17DF02 = 0;
}
// 17DF02: using guessed type __int16 word_17DF02;

//----- (0007C720) --------------------------------------------------------
int __cdecl sub_7C720(unsigned __int8 a1, _BYTE *a2)
{
  void **v2; // eax
  __int16 v3; // bx
  __int16 v4; // dx
  __int16 v5; // cx
  __int16 v6; // ax

  v2 = &off_E1E98 + 6 * a1;
  v3 = *((_WORD *)v2 + 9);
  v4 = *((_WORD *)v2 + 8);
  v5 = *((_WORD *)v2 + 10);
  v6 = *((_WORD *)v2 + 11);
  if ( v3 + v6 > 480 )
    v6 = 480 - v3;
  if ( v5 + v4 > 640 )
    v4 = v5 + v4 - 640;
  return sub_85BF5(a2, dword_E9C38, v4, v3, v5, v6);
}
// E1E98: using guessed type void *off_E1E98;
// E9C38: using guessed type int dword_E9C38;

//----- (0007C7C0) --------------------------------------------------------
int __cdecl sub_7C7C0(int a1, int a2)
{
  return sub_85C42(a2, 208, 111, 200, 369, 0x9Fu);
}

//----- (0007C800) --------------------------------------------------------
char __cdecl sub_7C800(signed __int16 a1)
{
  signed __int16 v1; // bx
  unsigned __int8 *v2; // edx
  unsigned __int8 *v3; // eax
  unsigned __int8 v4; // ch
  unsigned __int8 v5; // ch
  unsigned __int8 v6; // ch
  unsigned __int8 *v7; // edx
  unsigned __int8 v8; // ch
  _BYTE *v9; // eax
  unsigned __int8 v10; // ch
  unsigned __int8 v11; // ch
  unsigned __int8 v12; // cl
  unsigned __int8 *v13; // edx
  unsigned __int8 v14; // ch
  int v15; // eax
  unsigned __int8 v16; // ch
  unsigned __int8 v17; // ch
  unsigned int v19; // [esp+4h] [ebp-4h]

  v1 = a1;
  if ( (unsigned __int16)a1 > 0xFFu )
    v1 = 255;
  v2 = (unsigned __int8 *)(dword_17DE3C + 477);
  v19 = dword_17DE38 + 765;
  v3 = (unsigned __int8 *)(dword_17DE38 + 477);
  while ( (unsigned int)v3 < v19 )
  {
    v4 = *v2;
    if ( *v3 < *v2 )
      *v3 = (unsigned __int16)(v4 * v1) >> 8;
    else
      *v3 = v4;
    v5 = v2[1];
    if ( v3[1] < v5 )
      v3[1] = (unsigned __int16)(v5 * v1) >> 8;
    else
      v3[1] = v5;
    v6 = v2[2];
    if ( v3[2] < v6 )
      v3[2] = (unsigned __int16)(v6 * v1) >> 8;
    else
      v3[2] = v6;
    v3 += 3;
    v2 += 3;
  }
  v7 = (unsigned __int8 *)(dword_17DE38 + 444);
  v8 = *(_BYTE *)(dword_17DE3C + 444);
  v9 = (_BYTE *)(dword_17DE3C + 444);
  if ( *(_BYTE *)(dword_17DE38 + 444) < v8 )
    *v7 = (unsigned __int16)(v8 * v1) >> 8;
  else
    *v7 = v8;
  v10 = v9[1];
  if ( v7[1] < v10 )
    v7[1] = (unsigned __int16)(v10 * v1) >> 8;
  else
    v7[1] = v10;
  v11 = v9[2];
  if ( v7[2] < v11 )
    v7[2] = (unsigned __int16)(v1 * (unsigned __int8)v9[2]) >> 8;
  else
    v7[2] = v11;
  v12 = v7[3];
  v13 = v7 + 3;
  v14 = v9[3];
  v15 = (int)(v9 + 3);
  if ( v12 < v14 )
    *v13 = (unsigned __int16)(v14 * v1) >> 8;
  else
    *v13 = v14;
  v16 = *(_BYTE *)(v15 + 1);
  if ( v13[1] < v16 )
    v13[1] = (unsigned __int16)(v16 * v1) >> 8;
  else
    v13[1] = v16;
  v17 = *(_BYTE *)(v15 + 2);
  if ( v13[2] < v17 )
    v13[2] = (unsigned __int16)(*(unsigned __int8 *)(v15 + 2) * v1) >> 8;
  else
    v13[2] = v17;
  sub_9A0FC();
  return sub_41A90((unsigned __int8 *)dword_17DE38);
}
// 17DE38: using guessed type int dword_17DE38;
// 17DE3C: using guessed type int dword_17DE3C;

//----- (0007C9D0) --------------------------------------------------------
char __cdecl sub_7C9D0(signed __int16 a1)
{
  signed __int16 v1; // cx
  unsigned __int8 *i; // eax
  __int16 v3; // bx
  int v4; // eax
  int v5; // eax
  unsigned int v7; // [esp+4h] [ebp-4h]

  v1 = a1;
  if ( (unsigned __int16)a1 > 0xFFu )
    v1 = 255;
  v7 = dword_17DE38 + 765;
  for ( i = (unsigned __int8 *)(dword_17DE38 + 477);
        (unsigned int)i < v7;
        *(i - 1) = v3 - ((unsigned __int16)(v3 * v1) >> 8) )
  {
    *i -= (unsigned __int16)(v1 * *i) >> 8;
    i[1] -= (unsigned __int16)(v1 * i[1]) >> 8;
    v3 = i[2];
    i += 3;
  }
  v4 = dword_17DE38;
  *(_BYTE *)(dword_17DE38 + 447) -= (unsigned __int16)(v1 * *(unsigned __int8 *)(dword_17DE38 + 447)) >> 8;
  *(_BYTE *)(v4 + 448) -= (unsigned __int16)(v1 * *(unsigned __int8 *)(v4 + 448)) >> 8;
  *(_BYTE *)(v4 + 449) -= (unsigned __int16)(v1 * *(unsigned __int8 *)(v4 + 449)) >> 8;
  v5 = dword_17DE38;
  *(_BYTE *)(dword_17DE38 + 444) -= (unsigned __int16)(v1 * *(unsigned __int8 *)(dword_17DE38 + 444)) >> 8;
  *(_BYTE *)(v5 + 445) -= (unsigned __int16)(v1 * *(unsigned __int8 *)(v5 + 445)) >> 8;
  *(_BYTE *)(v5 + 446) -= (unsigned __int16)(*(unsigned __int8 *)(v5 + 446) * v1) >> 8;
  sub_9A0FC();
  return sub_41A90((unsigned __int8 *)dword_17DE38);
}
// 17DE38: using guessed type int dword_17DE38;

//----- (0007CB10) --------------------------------------------------------
int sub_7CB10()
{
  int (**i)(); // ebx
  int result; // eax
  int (**j)(); // ebx
  int (**v3)(); // ebx

  for ( i = (int (**)())off_E1D64; *((_WORD *)i + 5); i += 11 )
  {
    if ( *((_WORD *)i + 4) && *i )
    {
      result = ((int (__cdecl *)(int (**)()))*i)(i);
      if ( (_BYTE)result )
      {
        *((_WORD *)i + 4) = 0;
        sub_7B5A0();
        result = 1;
      }
      else
      {
        LOWORD(result) = 0;
        *((_WORD *)i + 4) = 0;
      }
      return result;
    }
  }
  for ( j = (int (**)())off_E1D64; *((_WORD *)j + 5); *((_BYTE *)j - 20) = 0 )
  {
    j += 11;
    *((_WORD *)j - 18) = 0;
  }
  v3 = (int (**)())off_E1D64;
  if ( !off_E1D64[5] )
    return 0;
  while ( !sub_7B200(v3, dword_17DEE4, SHIWORD(dword_17DEE4)) || !*((_BYTE *)v3 + 23) )
  {
    v3 += 11;
    if ( !*((_WORD *)v3 + 5) )
      return 0;
  }
  if ( word_17DEEE & 1 )
  {
    *((_WORD *)v3 + 4) = 1;
    sub_7B5A0();
    sub_8F100(0, 14, 127, 64, 0x64u, 0, 3u);
  }
  else
  {
    *((_BYTE *)v3 + 24) = 1;
  }
  return 0;
}
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;

//----- (0007CBF0) --------------------------------------------------------
char sub_7CBF0()
{
  word_17DEF8 = 0;
  byte_17DE71[11 * word_17DEFC] = 3;
  word_17DF02 = 0;
  word_17DEF6 = 2;
  word_17DEF2 = word_17DEF4;
  return 0;
}
// 17DEF2: using guessed type __int16 word_17DEF2;
// 17DEF4: using guessed type __int16 word_17DEF4;
// 17DEF6: using guessed type __int16 word_17DEF6;
// 17DEF8: using guessed type __int16 word_17DEF8;
// 17DEFC: using guessed type __int16 word_17DEFC;
// 17DF02: using guessed type __int16 word_17DF02;

//----- (0007CC40) --------------------------------------------------------
char sub_7CC40()
{
  word_17DF02 = 0;
  word_17DEF8 = 1;
  byte_17DE71[11 * word_17DEFC] = 4;
  word_17DEF6 = 2;
  word_17DEF2 = word_17DEF4;
  return 0;
}
// 17DEF2: using guessed type __int16 word_17DEF2;
// 17DEF4: using guessed type __int16 word_17DEF4;
// 17DEF6: using guessed type __int16 word_17DEF6;
// 17DEF8: using guessed type __int16 word_17DEF8;
// 17DEFC: using guessed type __int16 word_17DEFC;
// 17DF02: using guessed type __int16 word_17DF02;

//----- (0007CCA0) --------------------------------------------------------
int sub_7CCA0()
{
  int v0; // ebx
  int v1; // ebx

  v0 = word_17DEFC;
  if ( v0 == sub_74515() && word_17DEFE == 1 || (v1 = word_17DEFC, v1 != sub_74515()) )
    byte_17DE71[11 * word_17DEFC] = 1;
  return 0;
}
// 17DEFC: using guessed type __int16 word_17DEFC;
// 17DEFE: using guessed type __int16 word_17DEFE;

//----- (0007CCF0) --------------------------------------------------------
int sub_7CCF0()
{
  int v0; // eax
  char v1; // dl

  v0 = 11 * word_17DEFC;
  v1 = byte_17DE72[v0];
  if ( v1 > 50 )
  {
    byte_17DE72[v0] = v1 - 1;
    byte_17DE71[11 * word_17DEFC] = 6;
  }
  return 0;
}
// 17DEFC: using guessed type __int16 word_17DEFC;

//----- (0007CD30) --------------------------------------------------------
int sub_7CD30()
{
  char *v0; // esi
  char v2; // [esp+0h] [ebp-Ch]
  char v3; // [esp+4h] [ebp-8h]

  v0 = (&off_D9208)[byte_17DE72[11 * word_17DEFC]];
  qmemcpy(&v2, v0, 4u);
  qmemcpy(&v3, v0 + 4, sizeof(v3));
  if ( v2 && v2 != 48 )
  {
    ++byte_17DE72[11 * word_17DEFC];
    byte_17DE71[11 * word_17DEFC] = 6;
  }
  return 0;
}
// D9208: using guessed type char *off_D9208;
// 17DEFC: using guessed type __int16 word_17DEFC;

//----- (0007CDA0) --------------------------------------------------------
int sub_7CDA0()
{
  byte_17DE71[11 * word_17DEFC] = 5;
  return 0;
}
// 17DEFC: using guessed type __int16 word_17DEFC;

//----- (0007CDC0) --------------------------------------------------------
int __cdecl sub_7CDC0(unsigned __int8 a1, unsigned __int8 a2)
{
  _BYTE *v2; // eax
  int v3; // edx

  v2 = (_BYTE *)(3 * (2 * a1 + 134) + dword_EA3D8);
  v3 = 3 * a2;
  *v2 = byte_E1711[v3];
  v2[1] = byte_E1712[v3];
  v2[2] = byte_E1713[v3];
  v2[3] = byte_E172C[v3];
  v2[4] = byte_E172D[v3];
  v2[5] = byte_E172E[v3];
  return 0;
}
// EA3D8: using guessed type int dword_EA3D8;

//----- (0007CE50) --------------------------------------------------------
signed int sub_7CE50()
{
  __int16 v0; // bx
  char *v1; // esi
  char *v2; // edx
  __int16 i; // bx
  int v4; // eax
  __int16 v5; // di
  _BYTE *v6; // esi
  int v7; // edi
  int v8; // eax
  char v9; // ST10_1
  int v10; // edi
  int v11; // eax
  char v12; // ST10_1
  int v13; // edi
  int v14; // eax
  char v15; // ST10_1
  __int16 v16; // dx
  int v17; // eax
  char v18; // ch
  signed int v20; // [esp+0h] [ebp-Ch]

  v20 = 0;
  byte_17DE68[11 * word_17DEFC] = 1;
  sub_74374();
  v0 = 0;
  sub_7438A((int)byte_17DE68, 0xBu);
  do
  {
    v1 = &byte_17DE68[11 * sub_74515() + 1];
    v2 = &byte_17DE68[11 * v0 + 1];
    qmemcpy(v2, v1, 8u);
    ++v0;
    qmemcpy(byte_E131C, v2, sizeof(byte_E131C));
  }
  while ( v0 < 8 );
  for ( i = 0; i < 8; ++i )
  {
    v4 = 11 * i;
    if ( byte_17DE68[v4] )
    {
      switch ( byte_17DE71[v4] )
      {
        case 1:
          v5 = 0;
          while ( v5 < 7 )
          {
            v6 = (_BYTE *)(3 * (2 * v5 + 134) + dword_17DE38);
            *v6 = 0;
            v6 += 3;
            *(v6 - 2) = 0;
            *(v6 - 1) = 0;
            v6[1] = 0;
            v6[2] = 0;
            *v6 = 0;
            ++v5;
            sub_41A90((unsigned __int8 *)dword_17DE38);
          }
          byte_17DE68[11 * i] = 0;
          sub_73AA1(i);
          if ( i == word_17DEFC )
            v20 = 1;
          break;
        case 2:
          v7 = sub_74515();
          if ( v7 == sub_74536() )
          {
            if ( i <= 0 )
              byte_17DE69[11 * sub_74515() + i] = i;
            else
              byte_17DE69[11 * sub_74515() + i] = i - 1;
            v8 = sub_74515();
            v9 = sub_7D230(1, byte_17DE69[11 * v8 + i], i);
            byte_17DE69[11 * sub_74515() + i] = v9;
          }
          break;
        case 3:
          v13 = sub_74515();
          if ( v13 == sub_74536() && (unsigned __int16)word_17DEFE < 7u )
          {
            v14 = sub_74515();
            v15 = sub_7D230(1, byte_17DE69[11 * v14 + i], i);
            byte_17DE69[11 * sub_74515() + i] = v15;
          }
          break;
        case 4:
          v10 = sub_74515();
          if ( v10 == sub_74536() && (unsigned __int16)word_17DEFE < 7u )
          {
            v11 = sub_74515();
            v12 = sub_7D230(0, byte_17DE69[11 * v11 + i], i);
            byte_17DE69[11 * sub_74515() + i] = v12;
          }
          break;
        case 5:
          *(_WORD *)(dword_D41A0 + 12) = word_17DEFC;
          v16 = byte_17DE72[11 * sub_74515()];
          v17 = dword_D41A4;
          v18 = *(_BYTE *)(dword_D41A4 + 22);
          *(_WORD *)(dword_D41A4 + 43) = v16;
          *(_BYTE *)(v17 + 22) = v18 | 0x10;
          *(_WORD *)(dword_D41A0 + 14) = word_17DEFE;
          sub_7449C();
          word_E29DC = 1;
          v20 = 1;
          break;
        case 6:
          byte_17DE72[11 * word_17DEFC] = byte_17DE72[11 * i];
          break;
        default:
          continue;
      }
    }
  }
  byte_17DE71[11 * word_17DEFC] = 0;
  word_17DEF4 = byte_17DE69[11 * sub_74515() + word_17DEFC];
  sub_7D1F0();
  return v20;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E29DC: using guessed type __int16 word_E29DC;
// 17DE38: using guessed type int dword_17DE38;
// 17DEF4: using guessed type __int16 word_17DEF4;
// 17DEFC: using guessed type __int16 word_17DEFC;
// 17DEFE: using guessed type __int16 word_17DEFE;

//----- (0007D1F0) --------------------------------------------------------
int sub_7D1F0()
{
  int result; // eax

  result = 0;
  word_17DEFE = 0;
  do
  {
    if ( byte_17DE68[11 * (signed __int16)result] )
      ++word_17DEFE;
    ++result;
  }
  while ( (signed __int16)result < 8 );
  return result;
}
// 17DEFE: using guessed type __int16 word_17DEFE;

//----- (0007D230) --------------------------------------------------------
signed int __cdecl sub_7D230(char a1, unsigned __int8 a2, unsigned __int8 a3)
{
  signed int v3; // ebx
  __int16 v4; // si
  __int16 v5; // si
  signed __int16 v7; // [esp+0h] [ebp-8h]
  signed __int16 v8; // [esp+4h] [ebp-4h]

  v3 = a2;
  if ( a1 )
  {
    do
    {
      if ( (--v3 & 0x8000u) != 0 )
        v3 = 7;
      v5 = 0;
      v7 = 0;
      while ( v5 < 8 )
      {
        if ( v5 != a3 && byte_17DE68[11 * v5] && byte_17DE69[11 * sub_74515() + v5] == (_WORD)v3 )
        {
          v7 = 1;
          break;
        }
        ++v5;
      }
    }
    while ( v7 );
  }
  else
  {
    do
    {
      if ( (signed __int16)++v3 > 7 )
        v3 = 0;
      v4 = 0;
      v8 = 0;
      while ( v4 < 8 )
      {
        if ( v4 != a3 && byte_17DE68[11 * v4] && byte_17DE69[11 * sub_74515() + v4] == (_WORD)v3 )
        {
          v8 = 1;
          break;
        }
        ++v4;
      }
    }
    while ( v8 );
  }
  return v3;
}

//----- (0007D310) --------------------------------------------------------
int sub_7D310()
{
  __int16 v0; // bx
  int result; // eax
  int v2; // eax
  __int16 v3; // [esp+0h] [ebp-4h]

  v0 = 0;
  v3 = 0;
  do
  {
    result = 11 * v0;
    if ( byte_17DE68[result] )
    {
      if ( v0 != word_17DEFC )
      {
        v2 = sub_74515();
        result = sub_7CDC0(v3++, byte_17DE69[11 * v2 + v0]);
      }
    }
    ++v0;
  }
  while ( v0 < 8 );
  return result;
}
// 17DEFC: using guessed type __int16 word_17DEFC;

//----- (0007D380) --------------------------------------------------------
unsigned int sub_7D380()
{
  int v0; // eax
  char v2; // [esp+0h] [ebp-28h]

  sub_85C42(dword_180628, 246, 14, 109, 14, 0x9Fu);
  sub_6FC50(1);
  v0 = byte_17DE72[11 * word_17DEFC];
  sprintf(&v2, aDS, v0 - 49, off_D9204[v0]);
  return sub_7FAE0(&v2, 246, 355, 14, 0);
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D9204: using guessed type char *off_D9204[2];
// 17DEFC: using guessed type __int16 word_17DEFC;
// 180628: using guessed type int dword_180628;

//----- (0007D400) --------------------------------------------------------
int __usercall sub_7D400@<eax>(int a1@<eax>, __int16 a2, __int16 a3, char a4)
{
  _WORD *v4; // ebx
  int v5; // edx
  __int16 v6; // cx
  char *i; // ebx
  unsigned __int8 v8; // al
  char v9; // cl
  _WORD *j; // ebx
  unsigned __int16 v11; // ax
  int v12; // edx
  char v13; // dl
  int v14; // edx
  int v15; // edx
  int v16; // eax
  int v17; // eax
  int v18; // edi
  char *v20; // eax
  char *v21; // edx
  _WORD *v22; // eax
  __int16 v23; // bx
  signed __int16 *k; // eax
  __int16 v25; // [esp+0h] [ebp-54h]
  __int16 v26; // [esp+2h] [ebp-52h]
  __int16 v27; // [esp+4h] [ebp-50h]
  __int16 v28; // [esp+6h] [ebp-4Eh]
  __int16 v29; // [esp+8h] [ebp-4Ch]
  __int16 v30; // [esp+Ch] [ebp-48h]
  __int16 v31; // [esp+Eh] [ebp-46h]
  char v32; // [esp+10h] [ebp-44h]
  int v33; // [esp+24h] [ebp-30h]
  __int16 v34; // [esp+30h] [ebp-24h]
  __int16 v35; // [esp+32h] [ebp-22h]
  int v36; // [esp+34h] [ebp-20h]
  int v37; // [esp+3Ch] [ebp-18h]
  int v38; // [esp+40h] [ebp-14h]
  int v39; // [esp+44h] [ebp-10h]
  _WORD *v40; // [esp+48h] [ebp-Ch]
  char *v41; // [esp+4Ch] [ebp-8h]
  int v42; // [esp+50h] [ebp-4h]

  v42 = -1;
  v4 = &unk_E26C8;
  v41 = 0;
  v40 = 0;
  v39 = j___clock(a1, 0, &unk_E26C8);
  while ( v4[4] )
  {
    if ( byte_E1B82 != 1 || (v6 = v4[6], v6 != 85) && v6 != 86 )
      sub_81CA0(a2, v5, a2, a3, (int)v4);
    v4 += 15;
  }
  for ( i = (char *)&unk_E1960; *((_WORD *)i + 2); i += 22 )
  {
    v8 = i[18];
    if ( v8 >= 1u )
    {
      if ( v8 <= 1u )
      {
        v41 = i;
        sub_7E5A0(a2, v5, a2, a3, (int)i, 37, 43);
      }
      else if ( v8 == 2 )
      {
        LOBYTE(v5) = a4;
        if ( a4 == 3 || a4 == 5 )
        {
          v9 = i[19];
          v40 = i;
          if ( v9 )
          {
            if ( v9 == 1 )
            {
              if ( (unsigned __int16)sub_7E5A0(a2, v5, a2, a3, (int)i, 70, 83) )
              {
                *((_WORD *)i + 8) = 33;
                i[19] = 2;
              }
            }
            else
            {
              sub_7E5A0(a2, v5, a2, a3, (int)i, 33, 35);
            }
          }
          else
          {
            sub_8F100(0, 41, 127, 64, 0x64u, 0, 2u);
            i[19] = 1;
          }
        }
      }
    }
    if ( i[18] == 2 )
      break;
  }
  for ( j = word_E2970; j[6]; j = (_WORD *)((char *)j + 17) )
  {
    v11 = j[6];
    if ( v11 < 1u )
      continue;
    if ( v11 <= 1u )
    {
      memset(&v33, 0, 22);
      v33 = *(_DWORD *)j;
      LOWORD(v36) = j[7];
      v34 = j[4];
      v35 = j[5];
      sub_7E5A0(a2, v12, a2, a3, (int)&v33, 305, 311);
LABEL_40:
      *(_DWORD *)j = v33;
      j[7] = v36;
      continue;
    }
    if ( v11 == 2 && a4 == 3 )
    {
      v13 = *((_BYTE *)j + 16);
      if ( !v13 )
      {
        sub_8F100(0, 41, 127, 64, 0x64u, 0, 2u);
        *((_BYTE *)j + 16) = 1;
        continue;
      }
      if ( v13 != 1 )
      {
        memset(&v33, 0, 22);
        v33 = *(_DWORD *)j;
        LOWORD(v36) = j[7];
        v34 = j[4];
        v35 = j[5];
        sub_7E5A0(a2, v15, a2, a3, (int)&v33, 270, 272);
        goto LABEL_40;
      }
      memset(&v33, 0, 22);
      v33 = *(_DWORD *)j;
      LOWORD(v36) = j[7];
      v34 = j[4];
      v35 = j[5];
      if ( (unsigned __int16)sub_7E5A0(a2, v14, a2, a3, (int)&v33, 70, 83) )
      {
        j[7] = 270;
        *((_BYTE *)j + 16) = 2;
      }
      else
      {
        j[7] = v36;
      }
      *(_DWORD *)j = v33;
    }
  }
  LOBYTE(j) = a4;
  if ( a4 == 3 && *(_BYTE *)(dword_D41A4 + 10) == 1 )
  {
    v38 = dword_17DEC0;
    v37 = dword_17DEC4;
    dword_17DEC0 = dword_17DEC8;
    HIWORD(v16) = HIWORD(dword_17DECC);
    dword_17DEC4 = dword_17DECC;
    if ( (unsigned __int16)word_17DB74 < 1u )
    {
      if ( !word_17DB74 )
      {
        LOBYTE(v16) = v40 != 0;
        BYTE1(v16) = 0;
        v17 = v16 + 1;
        word_17DB74 = v17;
        dword_17DB70 = j___clock(v17, v5, j);
      }
    }
    else if ( (unsigned __int16)word_17DB74 <= 1u )
    {
      if ( v41 )
      {
        if ( 3 == byte_17DB8F )
        {
          memset(&v25, 0, 36);
          qmemcpy(&v25, &unk_E24F2, 0x10u);
          qmemcpy(&v32, (char *)&unk_E24F2 + 16, 2u);
          v26 = *((_WORD *)v41 + 6) - 80 - a2;
          v27 = *((_WORD *)v41 + 7) - 60 - a3;
          v28 = *((_WORD *)v41 + 6) + 16 - a2;
          v29 = *((_WORD *)v41 + 7) - 60 - a3;
          v30 = *((_WORD *)v41 + 6) + 16 - a2;
          v31 = *((_WORD *)v41 + 7) - 4 - a3;
          v25 = 464;
          v18 = (int)v40;
          sub_7E840(&v25, 238, 264);
          if ( v18 )
          {
            if ( (v39 - dword_17DB70) / 0x64u > 8 )
            {
              dword_17DB70 = v39;
              word_17DB74 = 2;
            }
          }
        }
      }
    }
    else if ( word_17DB74 == 2 )
    {
      if ( v40 )
      {
        if ( byte_17DB8F == 3 )
        {
          memset(&v25, 0, 36);
          v26 = v40[6] - 80 - a2;
          v27 = v40[7] - 60 - a3;
          v28 = v40[6] + 16 - a2;
          v29 = v40[7] - 60 - a3;
          v30 = v40[6] + 16 - a2;
          v31 = v40[7] - 4 - a3;
          v25 = 465;
          sub_7E840(&v25, 238, 264);
          if ( v41 )
          {
            if ( (v39 - dword_17DB70) / 0x64u > 8 )
            {
              dword_17DB70 = v39;
              word_17DB74 = 1;
            }
          }
        }
      }
    }
    dword_17DEC0 = v38;
    dword_17DEC4 = v37;
  }
  if ( byte_17DB8E )
    return v42;
  if ( word_17DB8A != -1 )
  {
    v20 = (char *)&unk_E1960;
    v21 = 0;
    while ( *((_WORD *)v20 + 2) )
    {
      if ( v20[18] == 1 )
        v21 = v20;
      v20 += 22;
    }
    v22 = &unk_E1960;
    v23 = 0;
    while ( v22[2] )
    {
      if ( v23 == word_17DB8A )
      {
        sub_7DA70(v22[6], v22[7], *((_WORD *)v21 + 6), *((_WORD *)v21 + 7), a2, a3);
        return v42;
      }
      v22 += 11;
      ++v23;
    }
    for ( k = word_E2970; k[6]; k = (signed __int16 *)((char *)k + 17) )
    {
      if ( word_17DB8A == k[3] )
      {
        sub_7DA70(k[4], k[5], word_E196C[11 * k[2]], word_E196E[11 * k[2]], a2, a3);
        return v42;
      }
    }
    return v42;
  }
  if ( v41 && v40 )
  {
    sub_7DA70(*((_WORD *)v41 + 6), *((_WORD *)v41 + 7), v40[6], v40[7], a2, a3);
    return v42;
  }
  if ( !v41 || v40 )
    return v42;
  sub_7DA70(*((_WORD *)v41 + 6), *((_WORD *)v41 + 7), word_E1B66, word_E1B68, a2, a3);
  return v42;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E196C: using guessed type __int16 word_E196C[];
// E196E: using guessed type __int16 word_E196E[];
// E1B66: using guessed type __int16 word_E1B66;
// E1B68: using guessed type __int16 word_E1B68;
// E1B82: using guessed type char byte_E1B82;
// 17DB70: using guessed type int dword_17DB70;
// 17DB74: using guessed type __int16 word_17DB74;
// 17DB8A: using guessed type __int16 word_17DB8A;
// 17DB8E: using guessed type char byte_17DB8E;
// 17DB8F: using guessed type char byte_17DB8F;
// 17DEC0: using guessed type int dword_17DEC0;
// 17DEC4: using guessed type int dword_17DEC4;
// 17DEC8: using guessed type int dword_17DEC8;
// 17DECC: using guessed type int dword_17DECC;

//----- (0007DA70) --------------------------------------------------------
int __cdecl sub_7DA70(__int16 a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6)
{
  int v6; // edx
  int v7; // ebx
  __int16 v8; // ax
  int v9; // edx
  __int16 v10; // ax
  int v11; // ebx
  int v12; // edx
  __int16 v14; // [esp+0h] [ebp-10h]
  __int16 v15; // [esp+2h] [ebp-Eh]
  __int16 v16; // [esp+8h] [ebp-8h]
  __int16 v17; // [esp+Ah] [ebp-6h]

  word_17E074 = a3;
  v6 = *(unsigned __int8 *)(dword_17DED4 + 226);
  word_17E06C = a1;
  v7 = v6 / 2;
  v8 = v6 / 2 + a3;
  v9 = *(unsigned __int8 *)(dword_17DED4 + 227);
  word_17E074 = v8;
  v9 /= 2;
  word_17E076 = v9 + a4;
  word_17E06C = v7 + a1;
  word_17E06E = v9 + a2;
  v16 = v8;
  v17 = v9 + a4;
  v14 = v7 + a1;
  v15 = v9 + a2;
  v10 = sub_581E0(&v16, &v14);
  if ( v10 <= 1024 || v10 >= 1536 )
  {
    if ( v10 <= 1536 || v10 >= 2048 )
    {
      if ( v10 <= 2048 && v10 <= 0 || v10 >= 512 )
      {
        if ( v10 <= 512 || v10 >= 1024 )
        {
          if ( v10 != 2048 && v10 )
          {
            if ( v10 == 512 )
            {
              if ( byte_17E082 != 9 )
              {
                word_17E080 = 9;
                byte_17E083 = 12;
                byte_17E082 = 9;
              }
            }
            else if ( v10 == 1024 )
            {
              if ( byte_17E082 != 1 )
              {
                byte_17E082 = 1;
                word_17E080 = 1;
                byte_17E083 = 4;
              }
            }
            else if ( v10 == 1536 && byte_17E082 != 25 )
            {
              word_17E080 = 25;
              byte_17E082 = 25;
              byte_17E083 = 28;
            }
          }
          else if ( byte_17E082 != 17 )
          {
            byte_17E082 = 17;
            word_17E080 = 17;
            byte_17E083 = 20;
          }
        }
        else if ( byte_17E082 != 13 )
        {
          word_17E080 = 13;
          byte_17E082 = 13;
          byte_17E083 = 16;
        }
      }
      else if ( byte_17E082 != 5 )
      {
        byte_17E082 = 5;
        word_17E080 = 5;
        byte_17E083 = 8;
      }
    }
    else if ( byte_17E082 != 29 )
    {
      word_17E080 = 29;
      byte_17E083 = 32;
      byte_17E082 = 29;
    }
  }
  else if ( byte_17E082 != 21 )
  {
    word_17E080 = 21;
    byte_17E082 = 21;
    byte_17E083 = 24;
  }
  word_17E07C = word_17E06C;
  word_17E07E = word_17E06E;
  v11 = 6 * word_17E080 + dword_17DED4;
  v12 = word_17E06C - *(unsigned __int8 *)(v11 + 4) / 2 - a5;
  return sub_81260(
           (signed __int16)v12,
           v12,
           (int)&unk_17E078,
           word_17E06C - *(unsigned __int8 *)(v11 + 4) / 2 - a5,
           word_17E06E - *(unsigned __int8 *)(v11 + 5) / 2 - a6);
}
// 17DED4: using guessed type int dword_17DED4;
// 17E06C: using guessed type __int16 word_17E06C;
// 17E06E: using guessed type __int16 word_17E06E;
// 17E074: using guessed type __int16 word_17E074;
// 17E076: using guessed type __int16 word_17E076;
// 17E07C: using guessed type __int16 word_17E07C;
// 17E07E: using guessed type __int16 word_17E07E;
// 17E080: using guessed type __int16 word_17E080;
// 17E082: using guessed type char byte_17E082;
// 17E083: using guessed type char byte_17E083;

//----- (0007DD70) --------------------------------------------------------
int sub_7DD70()
{
  int v0; // esi
  int result; // eax
  __int16 v2; // dx
  char v3; // bl

  v0 = dword_D41A4;
  result = (int)&unk_E1960;
  v2 = 0;
  while ( *(_WORD *)(result + 4) )
  {
    v3 = *(_BYTE *)(result + 18);
    *(_BYTE *)(result + 20) = 0;
    if ( v3 == 2 )
      *(_WORD *)(result + 16) = 70;
    if ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) & 2
      && *(unsigned __int16 *)(v0 + 43) == v2 )
    {
      *(_BYTE *)(result + 18) = 1;
    }
    if ( *(_BYTE *)(result + 18) == 1 )
      *(_WORD *)(result + 16) = 37;
    result += 22;
    ++v2;
    *(_BYTE *)(result - 3) = 0;
  }
  if ( *(_WORD *)(v0 + 43) > 0x18u )
  {
    for ( result = (int)word_E2970; *(_WORD *)(result + 12); result += 17 )
    {
      if ( *(unsigned __int16 *)(v0 + 43) == *(signed __int16 *)(result + 6) )
      {
        if ( *(_BYTE *)(dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12) + 11232) & 2 )
        {
          *(_WORD *)(result + 12) = 1;
          *(_WORD *)(result + 14) = 305;
        }
        else if ( *(_WORD *)(result + 12) == 3 )
        {
          *(_WORD *)(result + 12) = 2;
          *(_WORD *)(result + 14) = 70;
        }
        byte_E1972[22 * *(signed __int16 *)(result + 4)] = 1;
        result = 22 * *(signed __int16 *)(result + 4);
        *(__int16 *)((char *)&word_E1970 + result) = 37;
        break;
      }
    }
  }
  dword_D41A4 = v0;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E1970: using guessed type __int16 word_E1970;

//----- (0007DE80) --------------------------------------------------------
char __usercall sub_7DE80@<al>(int a1@<ebx>, int a2)
{
  int v2; // edx
  int v3; // edi
  int v4; // eax
  signed __int16 *v5; // ebx
  int v6; // edx
  int v7; // esi
  int v8; // esi
  char v9; // al
  int v10; // edx
  _BOOL1 v11; // zf
  __int16 v12; // si
  unsigned __int8 v13; // al
  __int16 v14; // si
  unsigned __int8 v15; // al
  int v16; // eax
  int v17; // edx
  char v19; // [esp+0h] [ebp-20h]
  int v20; // [esp+Ch] [ebp-14h]
  __int16 v21; // [esp+10h] [ebp-10h]
  int v22; // [esp+14h] [ebp-Ch]
  char v23; // [esp+18h] [ebp-8h]
  char v24; // [esp+1Ch] [ebp-4h]

  v21 = 0;
  memset(&v19, 0, 10);
  *(_DWORD *)(a2 + 4) = 0;
  v3 = j___clock(a2, v2, a1);
  v4 = sub_6FC50(1);
  LOWORD(v4) = *(_WORD *)(a2 + 26);
  v22 = v4 + 10;
  HIWORD(v4) = HIWORD(dword_17DED4);
  v5 = (signed __int16 *)(a2 + 26);
  LOWORD(v4) = *(unsigned __int8 *)(dword_17DED4 + 436);
  v6 = *(signed __int16 *)(a2 + 34);
  v20 = v22 + v4 - 22;
  v7 = v6 / 2 + *(signed __int16 *)(a2 + 28);
  v8 = v7 - sub_6FC30();
  v9 = sub_7BF20((signed __int16 *)(a2 + 26));
  v10 = *(signed __int16 *)(a2 + 34);
  v23 = v9;
  if ( *(signed __int16 *)(a2 + 36) <= v10 / 2 )
    goto LABEL_13;
  if ( (unsigned __int8)byte_17DF10 < 0xFu )
  {
    v11 = byte_17DF10 == 14;
    goto LABEL_6;
  }
  if ( (unsigned __int8)byte_17DF10 > 0xFu )
  {
    v11 = byte_17DF10 == 83;
LABEL_6:
    if ( !v11
      && (unsigned __int16)word_17DEF0 < 0xCu
      && (unsigned __int8)byte_17DF11 >= 0x30u
      && (unsigned __int8)byte_17DF11 <= 0x39u )
    {
      byte_E29DF = byte_17DF11 - 48;
    }
  }
  sprintf(&v19, &aGD[1], (unsigned __int8)byte_E29DF);
  sub_6FC50(1);
  v12 = sub_6FC30() + v8;
  v13 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, 0);
  v5 = (signed __int16 *)v12;
  v14 = sub_6FC80(&v19, v22, v20, v12, v13);
  if ( (v3 - dword_17DED0) / 0xCu >= 1 )
  {
    sub_6FC50(1);
    v15 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, 0);
    sub_2BC10(&asc_D1AB3[1], v14 - 2, (__int16)v5, v15);
    dword_17DED0 = v3;
  }
LABEL_13:
  if ( v23 )
  {
    LOBYTE(v5) = v23;
    sub_7C020((_WORD *)(a2 + 26));
    if ( (_BYTE)v5 == 1 )
    {
      word_E131A = 0;
      word_17DEFA = (unsigned __int8)byte_E29DF;
      sub_7B5A0();
      if ( 1 == *(_BYTE *)(dword_D41A4 + 10) )
        v24 = byte_17DF13;
      v16 = sub_8CD27(dword_EB394);
      *(_DWORD *)(a2 + 4) = sub_77680(v16, v17, v5) != 0;
      if ( *(_BYTE *)(dword_D41A4 + 10) == 1 )
        byte_17DF13 = v24;
    }
    else
    {
      byte_E29DF = word_17DEFA;
    }
    v21 = 1;
  }
  return v21;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E131A: using guessed type __int16 word_E131A;
// E29DF: using guessed type char byte_E29DF;
// EB394: using guessed type int dword_EB394;
// 17DE38: using guessed type int dword_17DE38;
// 17DED0: using guessed type int dword_17DED0;
// 17DED4: using guessed type int dword_17DED4;
// 17DEF0: using guessed type __int16 word_17DEF0;
// 17DEFA: using guessed type __int16 word_17DEFA;
// 17DF10: using guessed type char byte_17DF10;
// 17DF11: using guessed type char byte_17DF11;
// 17DF13: using guessed type char byte_17DF13;

//----- (0007E0E0) --------------------------------------------------------
signed int sub_7E0E0()
{
  int v0; // esi
  _WORD *v2; // ebx
  int v3; // edx

  v0 = 0;
  if ( byte_17DF10 == 1 )
    return 2;
  v2 = word_E1F84;
  if ( !word_E1F84[5] )
    return 0;
  do
  {
    if ( !(word_17DEEE & 1) || (_WORD)v0 )
    {
      if ( *((_BYTE *)v2 + 24) && sub_7B200(v2, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        v3 = *((unsigned __int8 *)v2 + 20);
      else
        v3 = *((unsigned __int8 *)v2 + 21);
      sub_2BB40(v2[5], v2[6], dword_17DED4 + 6 * v3);
    }
    else if ( sub_7B200(v2, dword_17DEE4, SHIWORD(dword_17DEE4)) )
    {
      sub_8F100(0, 14, 127, 64, 0x64u, 0, 3u);
      sub_2BB40(v2[5], v2[6], dword_17DED4 + 6 * *((unsigned __int8 *)v2 + 20));
      LOWORD(v0) = *((unsigned __int8 *)v2 + 22);
    }
    v2 += 22;
  }
  while ( v2[5] );
  return v0;
}
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;

//----- (0007E1F0) --------------------------------------------------------
int sub_7E1F0()
{
  _WORD *v0; // ebx
  int v1; // esi
  int v3; // ecx
  int v4; // edx

  v0 = word_E2008;
  v1 = 0;
  if ( !word_E2008[5] )
    return 0;
  do
  {
    v3 = dword_17DED4;
    v4 = *((unsigned __int8 *)v0 + 21);
    v0[7] = *(unsigned __int8 *)(dword_17DED4 + 6 * v4 + 4);
    v0[8] = *(unsigned __int8 *)(v3 + 6 * v4 + 5);
    if ( !(word_17DEEE & 1) )
    {
      if ( sub_7B200(v0, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        sub_2BB40(v0[5], v0[6], 6 * *((unsigned __int8 *)v0 + 21) + dword_17DED4);
      goto LABEL_9;
    }
    if ( sub_7B200(v0, dword_17DEE4, SHIWORD(dword_17DEE4)) )
    {
      sub_8F100(0, 14, 127, 64, 0x64u, 0, 3u);
      sub_2BB40(v0[5], v0[6], dword_17DED4 + 6 * *((unsigned __int8 *)v0 + 21));
      LOWORD(v1) = *((unsigned __int8 *)v0 + 22);
      if ( *((_BYTE *)v0 + 22) )
        break;
    }
LABEL_9:
    v0 += 22;
  }
  while ( v0[5] );
  return v1;
}
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;

//----- (0007E320) --------------------------------------------------------
signed int __usercall sub_7E320@<eax>(__int16 a1@<dx>, int a2@<edi>)
{
  int (__cdecl **i)(int); // esi
  int (__cdecl **v3)(int); // esi
  int (__cdecl **j)(int); // esi
  unsigned __int8 v5; // al
  int (__cdecl **k)(int); // esi
  int v8; // edi
  int v9; // edx
  int v10; // eax
  char *v11; // edi
  int v12; // edi
  int v13; // esi
  char v14; // [esp+0h] [ebp-24h]
  char v15; // [esp+10h] [ebp-14h]

  for ( i = (int (__cdecl **)(int))off_E23E0; *((_BYTE *)i + 25); i += 11 )
  {
    if ( *((_BYTE *)i + 23) )
    {
      a2 = *((unsigned __int8 *)i + 21);
      sub_7C120(*((_WORD *)i + 5), *((_WORD *)i + 6), dword_17DED4 + 6 * a2);
    }
  }
  if ( byte_17DB8E )
    return 0;
  v3 = (int (__cdecl **)(int))off_E23E0;
  if ( off_E23E0[25] )
  {
    do
    {
      if ( *((_WORD *)v3 + 4) && *v3 )
      {
        v5 = (*v3)((int)v3);
        LOWORD(a2) = v5;
        if ( !v5 )
          return 1;
        *((_WORD *)v3 + 4) = 0;
        sub_7B5A0();
        return a2;
      }
      v3 += 11;
    }
    while ( *((_BYTE *)v3 + 25) );
    j = (int (__cdecl **)(int))off_E23E0;
    if ( !off_E23E0[25] )
    {
      k = (int (__cdecl **)(int))off_E23E0;
      goto LABEL_34;
    }
    goto LABEL_17;
  }
  for ( j = (int (__cdecl **)(int))off_E23E0; *((_BYTE *)j + 25); *((_BYTE *)j - 20) = 0 )
  {
LABEL_17:
    if ( *((_BYTE *)j + 23) && *((_BYTE *)j + 24) )
      sub_7C120(*((_WORD *)j + 5), *((_WORD *)j + 6), dword_17DED4 + 6 * *((unsigned __int8 *)j + 20));
    j += 11;
    *((_WORD *)j - 18) = 0;
  }
  for ( k = (int (__cdecl **)(int))off_E23E0; ; k += 11 )
  {
LABEL_34:
    if ( !*((_BYTE *)k + 25) )
    {
      sub_82510(a1, (int *)&unk_17DBA8);
      return 0;
    }
    if ( *((_BYTE *)k + 23) )
    {
      v8 = dword_17DED4;
      v9 = *((unsigned __int8 *)k + 20);
      *((_WORD *)k + 7) = *(unsigned __int8 *)(dword_17DED4 + 6 * v9 + 4);
      *((_WORD *)k + 8) = *(unsigned __int8 *)(v8 + 6 * v9 + 5);
      if ( sub_7B200(k, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        break;
    }
LABEL_33:
    ;
  }
  if ( word_17DEEE & 1 )
  {
    *((_WORD *)k + 4) = 1;
    sub_7B5A0();
    sub_8F100(0, 14, 127, 64, 0x64u, 0, 3u);
    goto LABEL_33;
  }
  v10 = dword_D41A4;
  *((_BYTE *)k + 24) = 1;
  if ( *(_BYTE *)(v10 + 10) != 1 )
    return 0;
  v11 = (char *)&unk_E2516;
  if ( !*((_WORD *)&unk_E2516 + 1) )
    return 0;
  do
  {
    if ( v11[17] == *((_BYTE *)k + 22) )
    {
      memset(&v14, 0, 36);
      qmemcpy(&v14, v11, 0x10u);
      qmemcpy(&v15, v11 + 16, 2u);
      v12 = dword_17DEC0;
      v13 = dword_17DEC4;
      dword_17DEC0 = dword_17DEC8;
      dword_17DEC4 = dword_17DECC;
      sub_7E840((signed __int16 *)&v14, 238, 264);
      dword_17DEC0 = v12;
      dword_17DEC4 = v13;
      return 0;
    }
    v11 += 18;
  }
  while ( *((_WORD *)v11 + 1) );
  return 0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// 17DB8E: using guessed type char byte_17DB8E;
// 17DEC0: using guessed type int dword_17DEC0;
// 17DEC4: using guessed type int dword_17DEC4;
// 17DEC8: using guessed type int dword_17DEC8;
// 17DECC: using guessed type int dword_17DECC;
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;

//----- (0007E5A0) --------------------------------------------------------
signed int __usercall sub_7E5A0@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3, __int16 a4, int a5, __int16 a6, __int16 a7)
{
  int v7; // edx
  signed int v8; // esi
  __int16 v9; // ax

  v7 = j___clock(a1, a2, a5);
  v8 = 0;
  if ( (unsigned int)(v7 - *(_DWORD *)a5) >> 3 >= 1 )
  {
    v9 = *(_WORD *)(a5 + 16);
    if ( v9 <= a7 )
    {
      *(_WORD *)(a5 + 16) = v9 + 1;
    }
    else
    {
      v8 = 1;
      *(_WORD *)(a5 + 16) = a6;
    }
    *(_DWORD *)a5 = v7;
  }
  sub_7C120(*(_WORD *)(a5 + 12) - a3, *(_WORD *)(a5 + 14) - a4, dword_17DED4 + 6 * *(signed __int16 *)(a5 + 16));
  return v8;
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 17DED4: using guessed type int dword_17DED4;

//----- (0007E620) --------------------------------------------------------
signed int __cdecl sub_7E620(int a1)
{
  *(_WORD *)(a1 + 8) = 0;
  return 2;
}

//----- (0007E640) --------------------------------------------------------
signed int __cdecl sub_7E640(int a1)
{
  signed __int16 v1; // ax
  _WORD *i; // eax
  _WORD *j; // eax
  signed int result; // eax

  if ( a1 )
    v1 = sub_7BF20((signed __int16 *)(a1 + 26));
  else
    v1 = 1;
  if ( v1 == 1 )
  {
    *(_WORD *)(dword_D41A4 + 43) = 0;
    memset(dword_17DBC8, 0, 500);
    memset(dword_17DDBC, 0, 100);
    for ( i = &unk_E1960; i[2]; *(i - 3) = 70 )
    {
      i += 11;
      *((_BYTE *)i - 4) = 2;
      *((_BYTE *)i - 3) = 0;
    }
    for ( j = word_E2970; j[6]; *((_BYTE *)j - 1) = 0 )
    {
      j = (_WORD *)((char *)j + 17);
      *(_WORD *)((char *)j - 5) = 3;
      *(_WORD *)((char *)j - 3) = 70;
    }
    memset(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230 + 1609, 0, 505);
    sub_86860(word_1803EC);
    sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE64, (int)&loc_B2C44 + 3, (int)&loc_87D80 + 3);
    sub_7AA70(0, 0, 0, 0);
    byte_17E09D = 0;
    *(_WORD *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) = 0;
    memset(&dword_17DB70, 0, 56);
    word_17E080 = 13;
    word_17E06C = 0;
    byte_17E082 = 13;
    byte_17E09C = 0;
    word_17E06E = 480;
    byte_17E083 = 16;
    byte_17DB8F = 1;
    if ( a1 )
    {
      *(_WORD *)(a1 + 8) = 0;
      sub_7C020((_WORD *)(a1 + 26));
    }
    result = 1;
  }
  else if ( v1 == 2 )
  {
    *(_WORD *)(a1 + 8) = 0;
    sub_7C020((_WORD *)(a1 + 26));
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 17DB70: using guessed type int dword_17DB70;
// 17DB8F: using guessed type char byte_17DB8F;
// 17DBC8: using guessed type int dword_17DBC8[];
// 17DDBC: using guessed type int dword_17DDBC[];
// 17DE64: using guessed type int dword_17DE64;
// 17E06C: using guessed type __int16 word_17E06C;
// 17E06E: using guessed type __int16 word_17E06E;
// 17E080: using guessed type __int16 word_17E080;
// 17E082: using guessed type char byte_17E082;
// 17E083: using guessed type char byte_17E083;
// 17E09C: using guessed type char byte_17E09C;
// 17E09D: using guessed type char byte_17E09D;
// 1803EC: using guessed type __int16 word_1803EC;

//----- (0007E800) --------------------------------------------------------
char __cdecl sub_7E800(_WORD *a1)
{
  char result; // al

  result = sub_78730(a1);
  if ( result )
    a1[4] = 0;
  return result;
}

//----- (0007E820) --------------------------------------------------------
char __cdecl sub_7E820(int a1)
{
  char result; // al

  result = sub_780F0(a1);
  if ( result )
    *(_WORD *)(a1 + 8) = 0;
  return result;
}

//----- (0007E840) --------------------------------------------------------
int __cdecl sub_7E840(signed __int16 *a1, __int16 a2, __int16 a3)
{
  signed __int16 *v3; // ebx
  signed __int16 v5; // si
  signed __int16 v6; // di

  v3 = a1;
  if ( !a1[1] )
    return 0;
  do
  {
    if ( v3[1] )
    {
      v5 = v3[1];
      v6 = v3[1];
      sub_81360(v3[3], v3[4], v3[6], v3[7], a3);
      sub_7FCB0((int)v3, (_BYTE *)dword_E9C4C[*v3], v5, (signed __int16)(v6 + 180), v3[2], 0, 0, a2);
    }
    v3 += 9;
  }
  while ( v3[1] );
  return 0;
}

//----- (0007E8D0) --------------------------------------------------------
int __cdecl sub_7E8D0(_WORD *a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7)
{
  __int16 v7; // dx
  __int16 v8; // dx
  __int16 v9; // dx
  __int16 v10; // ax
  int result; // eax
  __int16 v12; // di
  __int16 v13; // dx

  *a1 = a2 - a4;
  a1[1] = a3 - a5;
  a1[2] = 2 * abs(*a1);
  v7 = *a1;
  a1[3] = 2 * abs((signed __int16)a1[1]);
  if ( v7 >= 0 )
  {
    if ( v7 )
      a1[4] = a6;
    else
      a1[4] = 0;
  }
  else
  {
    a1[4] = -a6;
  }
  v8 = a1[1];
  if ( v8 >= 0 )
  {
    if ( v8 )
      a1[5] = a7;
    else
      a1[5] = 0;
  }
  else
  {
    a1[5] = -a7;
  }
  a1[6] = a2;
  a1[7] = a3;
  v9 = a1[3];
  v10 = a1[2];
  if ( v10 <= v9 )
  {
    result = v10 - (v9 >> 1);
    a1[8] = result;
  }
  else
  {
    result = v10 >> 1;
    a1[8] = v9 - result;
  }
  v12 = a1[6];
  a1[9] = 0;
  if ( a4 >= v12 )
  {
    if ( a4 > v12 )
      a1[10] = 1;
  }
  else
  {
    a1[10] = 2;
  }
  v13 = a1[7];
  if ( a5 >= v13 )
  {
    if ( a5 > v13 )
      a1[11] = 1;
  }
  else
  {
    a1[11] = 2;
  }
  return result;
}

//----- (0007E9D0) --------------------------------------------------------
signed int __cdecl sub_7E9D0(_WORD *a1, _WORD *a2, _WORD *a3)
{
  __int16 v4; // cx
  unsigned __int16 v5; // cx
  __int16 v6; // si
  __int16 v7; // di
  unsigned __int16 v8; // dx
  __int16 v9; // cx
  __int16 v10; // si

  if ( a3[2] <= a3[3] )
  {
    if ( *a2 == a3[7] )
      return 1;
    if ( a3[8] >= 0 )
    {
      *a1 += a3[4];
      a3[8] -= a3[3];
    }
    *a2 += a3[5];
    v4 = a3[2];
  }
  else
  {
    if ( *a1 == a3[6] )
      return 1;
    if ( a3[8] >= 0 )
    {
      *a2 += a3[5];
      a3[8] -= a3[2];
    }
    *a1 += a3[4];
    v4 = a3[3];
  }
  a3[8] += v4;
  v5 = a3[10];
  if ( v5 >= 1u )
  {
    if ( v5 <= 1u )
    {
      v6 = a3[6];
      if ( *a1 < v6 )
        *a1 = v6;
    }
    else if ( v5 == 2 )
    {
      v7 = a3[6];
      if ( *a1 > v7 )
        *a1 = v7;
    }
  }
  v8 = a3[11];
  if ( v8 >= 1u )
  {
    if ( v8 <= 1u )
    {
      v9 = a3[7];
      if ( *a2 < v9 )
        *a2 = v9;
    }
    else if ( v8 == 2 )
    {
      v10 = a3[7];
      if ( *a2 > v10 )
        *a2 = v10;
    }
  }
  return 0;
}

//----- (0007EAE0) --------------------------------------------------------
int __cdecl sub_7EAE0(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, char *a5, _WORD *a6)
{
  char v6; // al
  int v7; // eax
  _WORD *v8; // eax
  char *v9; // eax
  int v10; // ecx
  int v11; // edx
  _WORD *v12; // eax
  int v13; // ecx
  __int16 v14; // dx
  _WORD *v15; // eax
  __int16 v16; // cx
  signed __int16 *i; // eax
  int v18; // ecx
  _WORD *j; // eax
  int v20; // edx
  int v21; // eax
  int v22; // edx
  __int16 v23; // cx
  int v24; // eax
  int v25; // ST18_4
  int v26; // ST14_4
  int v27; // eax
  int v28; // edx
  __int16 v29; // cx
  __int16 v30; // dx
  __int16 v31; // dx
  int v32; // edx
  signed int v33; // eax
  __int16 v34; // dx
  char v35; // cl
  __int16 v36; // ax
  int v37; // edx
  signed int v38; // eax
  signed int v39; // eax
  int v40; // edx
  char v41; // ch
  char v42; // cl
  int v43; // ecx
  unsigned __int8 *v44; // edi
  int v45; // eax
  _WORD *v46; // eax
  _WORD *v47; // edi
  __int16 v48; // ST10_2
  __int16 v49; // ST0C_2
  __int16 v50; // ST08_2
  __int16 v51; // ax
  int v52; // eax
  __int16 v54; // [esp-Ch] [ebp-68h]
  char v55; // [esp+0h] [ebp-5Ch]
  __int16 v56; // [esp+Ah] [ebp-52h]
  __int16 v57; // [esp+Ch] [ebp-50h]
  __int16 v58; // [esp+Eh] [ebp-4Eh]
  __int16 v59; // [esp+10h] [ebp-4Ch]
  int v60; // [esp+2Ch] [ebp-30h]
  _WORD *v61; // [esp+30h] [ebp-2Ch]
  _WORD *k; // [esp+34h] [ebp-28h]
  _WORD *v63; // [esp+38h] [ebp-24h]
  _WORD *v64; // [esp+3Ch] [ebp-20h]
  int v65; // [esp+40h] [ebp-1Ch]
  int v66; // [esp+44h] [ebp-18h]
  int v67; // [esp+48h] [ebp-14h]
  int v68; // [esp+4Ch] [ebp-10h]
  int v69; // [esp+50h] [ebp-Ch]
  char *v70; // [esp+54h] [ebp-8h]
  int v71; // [esp+58h] [ebp-4h]

  v6 = *a5;
  v71 = 0;
  v67 = -1;
  switch ( v6 )
  {
    case 1:
      v12 = &unk_E1960;
      v13 = 0;
      v61 = 0;
      while ( v12[2] )
      {
        if ( *((_BYTE *)v12 + 18) == 1 )
        {
          *a1 = v12[2];
          v61 = v12;
          v14 = v12[3];
          v67 = v13;
          *a2 = v14;
        }
        v12 += 11;
        ++v13;
      }
      if ( v61 && word_17DB8A != -1 && (_WORD)v67 != word_17DB8A )
      {
        v15 = &unk_E1960;
        v16 = 0;
        while ( v15[2] )
        {
          if ( v16 == word_17DB8A )
          {
            *a1 = v15[2];
            *a2 = v15[3];
            *a5 = 3;
            break;
          }
          v15 += 11;
          ++v16;
        }
        if ( *a5 != 3 )
        {
          for ( i = word_E2970; i[6]; i = (signed __int16 *)((char *)i + 17) )
          {
            if ( word_17DB8A == i[3] )
            {
              *a1 = word_E1964[11 * i[2]];
              *a2 = word_E1966[11 * i[2]];
              *a5 = 3;
              break;
            }
          }
        }
      }
      else
      {
        word_17DB8A = -1;
      }
      memset(&dword_17DE28, 0, 13);
      if ( word_17DB8A == -1 )
      {
        v18 = 0;
        for ( j = &unk_E1960; ; j += 11 )
        {
          v66 = v18;
          if ( !j[2] )
            break;
          if ( *((_BYTE *)j + 18) == 2 )
          {
            *a3 = j[2];
            *a4 = j[3];
            if ( (_WORD)v66 )
            {
              *a5 = 2;
              j = (_WORD *)sub_7E8D0(a6, *a3, *a4, *a1, *a2, 4, 4);
            }
            else
            {
              *a1 = j[2];
              LOWORD(j) = j[3];
              *a2 = (signed __int16)j;
              *a5 = 3;
              if ( *a2 > 480 )
                *a2 = 480;
              if ( *a1 > 640 )
                *a1 = 640;
              v20 = v66;
              *a5 = 3;
              if ( (signed __int16)v20 < 24 )
              {
                word_17DE30 = *a1;
                word_17DE32 = *a2;
                v21 = dword_D41A4;
                byte_17DE34 = ((*(_BYTE *)(dword_D41A4 + 24) & 0x40) != 0) + 1;
                LOBYTE(v21) = byte_17DE34;
                j = (_WORD *)j___clock(v21, v20, a2);
                dword_17DE28 = (int)j;
              }
            }
            break;
          }
          v18 = v66 + 1;
        }
        if ( *a5 != 1 || byte_17DB8E )
          goto LABEL_66;
      }
      else
      {
        memset(&dword_17DE28, 0, 13);
        j = &unk_E1960;
        v23 = 0;
        while ( j[2] )
        {
          if ( *((_BYTE *)j + 18) == 2 )
          {
            if ( v23 < 24 )
            {
              word_17DE30 = *a1;
              word_17DE32 = *a2;
              v24 = dword_D41A4;
              byte_17DE34 = ((*(_BYTE *)(dword_D41A4 + 24) & 0x40) != 0) + 1;
              LOBYTE(v24) = byte_17DE34;
              j = (_WORD *)j___clock(v24, v22, a2);
              dword_17DE28 = (int)j;
            }
            break;
          }
          j += 11;
          ++v23;
        }
      }
      *a5 = 3;
LABEL_66:
      sub_81760((int)j);
      goto LABEL_92;
    case 2:
      v25 = *a4;
      v26 = *a3;
      if ( (unsigned __int16)sub_7E9D0(a1, a2, a6) )
      {
        *a5 = 3;
        memset(&dword_17DE28, 0, 13);
        word_17DE30 = *a1;
        word_17DE32 = *a2;
        v27 = dword_D41A4;
        byte_17DE34 = ((*(_BYTE *)(dword_D41A4 + 24) & 0x40) != 0) + 1;
        LOBYTE(v27) = byte_17DE34;
        dword_17DE28 = j___clock(v27, v28, a2);
      }
      goto LABEL_92;
    case 3:
      if ( byte_17DB8E )
        goto LABEL_92;
      v29 = dword_17DEE4;
      if ( (_WORD)dword_17DEE4 )
      {
        if ( (signed __int16)dword_17DEE4 < 638 )
          goto LABEL_75;
        v29 = 0;
        v30 = word_17DB82 + *a1;
      }
      else
      {
        v30 = *a1 - word_17DB82;
      }
      word_E29D6 = v29;
      *a1 = v30;
LABEL_75:
      if ( HIWORD(dword_17DEE4) )
      {
        if ( SHIWORD(dword_17DEE4) < 478 )
          goto LABEL_80;
        v31 = word_17DB82 + *a2;
      }
      else
      {
        v31 = *a2 - word_17DB82;
      }
      word_E29D6 = 0;
      *a2 = v31;
LABEL_80:
      if ( *a1 >= 0 )
      {
        if ( *a1 >= 638 )
          *a1 = 638;
      }
      else
      {
        *a1 = 0;
      }
      if ( *a2 >= 0 )
      {
        if ( *a2 >= 478 )
          *a2 = 478;
      }
      else
      {
        *a2 = 0;
      }
      if ( word_E29D6 )
      {
        word_17DB82 = 0;
      }
      else
      {
        word_17DB82 += 4;
        if ( word_17DB82 > 24 )
          word_17DB82 = 24;
      }
      goto LABEL_92;
    case 4:
      if ( word_17DB8A > 24 )
      {
        v8 = sub_824E0(word_17DB8A);
        if ( !v8 )
          goto LABEL_10;
        *a1 = word_E1964[11 * (signed __int16)v8[2]];
        v7 = 11 * (signed __int16)v8[2];
      }
      else
      {
        v7 = 11 * word_17DB8A;
        *a1 = word_E1964[v7];
      }
      *a2 = word_E1966[v7];
LABEL_10:
      if ( byte_17DF10 || word_17DEEE )
      {
        *a5 = 1;
        word_17DEEE = 0;
        byte_17DF11 = 0;
        byte_17DF10 = 0;
      }
      v9 = (char *)&unk_E1960;
      v64 = 0;
      v70 = 0;
      while ( *((_WORD *)v9 + 2) )
      {
        if ( v9[18] == 2 )
        {
          v64 = v9;
          break;
        }
        v9 += 22;
        ++v70;
      }
      v10 = (int)v64;
      if ( v64 )
      {
        LOWORD(v9) = v64[2];
        *((_BYTE *)v64 - 4) = 2;
        v70 = v9;
        *(_WORD *)(v10 + 4) = 0;
      }
      sub_81760((int)v9);
      if ( v64 )
      {
        v11 = (int)v64;
        *((_BYTE *)v64 - 4) = 1;
        *(_WORD *)(v11 + 4) = (_WORD)v70;
      }
LABEL_92:
      if ( word_E29D6 )
      {
        sub_85C8B(dword_17DE64, (char *)dword_180628, *a1, *a2, 160, 480);
        sub_7D400(*a1, *a1, *a2, *a5);
        LOWORD(v38) = sub_81EE0(*a1, v37, (int)a2, (signed __int16)a5, *a1, *a2);
        LOBYTE(v38) = byte_17DB8E;
        if ( byte_17DB8E )
        {
          v38 = sub_80D40((__int16)a1, *a1, *a2, word_17DB84, word_17DB86, word_17DB88);
          v71 = v38;
          if ( (_WORD)v38 )
          {
            BYTE1(v38) = 0;
            byte_17DB8E = 0;
          }
        }
        HIBYTE(v34) = BYTE1(dword_17DE5C);
        sub_85CC3(v38, (int)a2, (unsigned __int16 *)dword_17DE5C);
        LOBYTE(v34) = *a5;
        if ( *a5 == 4 )
        {
          v36 = word_17DB8A;
          goto LABEL_107;
        }
        if ( (_BYTE)v34 == 5 )
        {
          v36 = word_17DB8C;
          goto LABEL_107;
        }
      }
      else
      {
        sub_85C8B(dword_17DE64, (char *)dword_180628, *a1, *a2, 160, 480);
        sub_7D400(*a1, *a1, *a2, *a5);
        LOWORD(v33) = sub_81EE0(*a1, v32, (int)a2, (signed __int16)a5, *a1, *a2);
        if ( byte_17DB8E )
        {
          v33 = sub_80D40((__int16)a1, *a1, *a2, word_17DB84, word_17DB86, word_17DB88);
          v71 = v33;
          if ( (_WORD)v33 )
            byte_17DB8E = 0;
        }
        sub_85CC3(v33, (int)a2, (unsigned __int16 *)dword_17DE5C);
        v34 = 1;
        v35 = *a5;
        word_E29D6 = 1;
        if ( v35 == 4 )
        {
          v36 = word_17DB8A;
LABEL_107:
          sub_82C20(v36);
          goto LABEL_108;
        }
        if ( v35 == 5 )
        {
          v36 = word_17DB8C;
          goto LABEL_107;
        }
      }
LABEL_108:
      v39 = sub_7E320(v34, (int)a5);
      v69 = v39;
      if ( !byte_17DB8E && !(_WORD)v71 && !(_WORD)v39 )
      {
        v41 = *a5;
        if ( *a5 != 4 && v41 != 5 && v41 == 3 )
        {
          LOBYTE(v40) = byte_17DF11;
          if ( byte_17DF11 == 111 || byte_17DF11 == 79 )
          {
            v42 = byte_17DE34;
            if ( byte_17DE34 == 1 )
            {
              v39 = dword_17DE2C;
              dword_17DE28 = dword_17DE2C;
              byte_17DE34 = 2;
              byte_17E09D = v42;
            }
            else if ( byte_17DE34 == 2 )
            {
              v39 = j___clock(v39, v40, a2);
              LOWORD(v40) = 1;
              dword_17DE2C = v39;
              byte_17DE34 = 1;
              dword_17DE28 = v39;
              byte_17E09D = 0;
            }
          }
          LOBYTE(v39) = byte_17DE34;
          if ( (unsigned __int8)byte_17DE34 < 2u )
          {
            if ( byte_17DE34 == 1 )
            {
              v43 = j___clock(v39, v40, a2);
              dword_17DE2C = v43;
              v60 = 100;
              if ( (v43 - dword_17DE28) / 0x64u > 0xF )
              {
                dword_17DE28 = v43;
                byte_17DE34 = 2;
              }
              if ( word_17DE32 < 478 )
                v54 = 280;
              else
                v54 = 60;
              sub_80C30(130, v54, 380);
            }
          }
          else if ( (unsigned __int8)byte_17DE34 <= 2u || byte_17DE34 == 3 )
          {
            sub_80C30(0, 0, 0);
          }
        }
      }
      if ( (_WORD)v69 == 2 && !(_WORD)v71 && !byte_17DB8E )
        v71 = v69;
      if ( !(_WORD)v69 && !(_WORD)v71 )
      {
        if ( *a5 == 3 && !(_WORD)v71 )
        {
          BYTE1(v39) = byte_17DB8E;
          if ( !byte_17DB8E )
          {
            if ( word_17DEEE & 1 )
            {
              v44 = (unsigned __int8 *)&unk_E1960;
              v68 = 0;
              while ( *((_WORD *)v44 + 2) )
              {
                v56 = *((_WORD *)v44 + 6) - *a1;
                v57 = *((_WORD *)v44 + 7) - *a2;
                v58 = *((_WORD *)v44 + 4);
                v59 = *((_WORD *)v44 + 5);
                if ( sub_7B200(&v55, dword_17DEE4, SHIWORD(dword_17DEE4)) )
                {
                  word_17DB84 = *((_WORD *)v44 + 6);
                  word_17DB86 = *((_WORD *)v44 + 7);
                  word_17DB88 = v44[18];
                  sub_80D40((__int16)a1, *a1, *a2, *((_WORD *)v44 + 6), *((_WORD *)v44 + 7), v44[18]);
                  v45 = dword_D41A4;
                  byte_17DB8E = 1;
                  *(_WORD *)(dword_D41A4 + 43) = v68;
                  if ( v44[18] == 1 )
                    *(_BYTE *)(v45 + 38545) |= 4u;
                  v46 = sub_824B0(*(_WORD *)(dword_D41A4 + 43));
                  if ( v46 && v46[6] == 2 )
                    *(_BYTE *)(dword_D41A4 + 38545) |= 0x10u;
                  if ( *(_WORD *)(dword_D41A4 + 43) == 24 )
                    *(_BYTE *)(dword_D41A4 + 38545) |= 0x20u;
                  break;
                }
                if ( v44[18] == 2 )
                  break;
                v44 += 22;
                ++v68;
              }
              if ( !(_WORD)v71 && !byte_17DB8E )
              {
                v47 = word_E2970;
                if ( word_E2970[4] )
                {
                  while ( 1 )
                  {
                    if ( v47[6] != 3 )
                    {
                      v56 = v47[4] - *a1;
                      v57 = v47[5] - *a2;
                      v58 = 40;
                      v59 = 40;
                      if ( sub_7B200(&v55, dword_17DEE4, SHIWORD(dword_17DEE4)) )
                        break;
                    }
                    v47 = (_WORD *)((char *)v47 + 17);
                    if ( !v47[4] )
                      goto LABEL_179;
                  }
                  if ( v47[6] == 1 )
                    *(_BYTE *)(dword_D41A4 + 38545) |= 4u;
                  word_17DB84 = v47[4];
                  word_17DB86 = v47[5];
                  v48 = v47[4];
                  v49 = *a2;
                  v50 = *a1;
                  word_17DB88 = 1;
                  sub_80D40((__int16)a1, v50, v49, v48, word_17DB86, 1);
                  v51 = v47[3];
                  byte_17DB8E = 1;
                  *(_WORD *)(dword_D41A4 + 43) = v51;
                }
              }
            }
            else if ( word_17DEEE & 2 )
            {
              LOBYTE(v39) = 0;
              v63 = &unk_E1960;
              v65 = v39;
              while ( v63[2] )
              {
                v56 = v63[6] - *a1;
                v57 = v63[7] - *a2;
                v58 = v63[4];
                v59 = v63[5];
                if ( sub_7B200(&v55, dword_17DEE4, SHIWORD(dword_17DEE4)) )
                {
                  if ( *((_BYTE *)v63 + 18) == 1 )
                  {
                    word_17DB8C = v65;
                    *a5 = 5;
                    word_17DEEE = 0;
                  }
                  break;
                }
                v63 += 11;
                ++v65;
              }
              if ( *a5 != 5 )
              {
                for ( k = word_E2970; k[4]; k = (_WORD *)((char *)k + 17) )
                {
                  if ( k[6] != 3 )
                  {
                    v56 = k[4] - *a1;
                    v57 = k[5] - *a2;
                    v58 = 40;
                    v59 = 40;
                    if ( sub_7B200(&v55, dword_17DEE4, SHIWORD(dword_17DEE4)) )
                    {
                      v52 = (int)k;
                      if ( k[6] == 1 )
                      {
                        *a5 = 5;
                        word_17DB8C = *(_WORD *)(v52 + 6);
                      }
                      break;
                    }
                  }
                }
              }
            }
          }
        }
LABEL_179:
        if ( !(_WORD)v71 && byte_17DF10 == 1 )
          v71 = 2;
      }
      return v71;
    case 5:
      if ( byte_17DF10 || word_17DEEE )
      {
        word_17DEEE = 0;
        *a5 = 3;
        byte_17DF11 = 0;
        byte_17DF10 = 0;
      }
      goto LABEL_92;
    default:
      goto LABEL_92;
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E1964: using guessed type __int16 word_E1964[];
// E1966: using guessed type __int16 word_E1966[];
// E29D6: using guessed type __int16 word_E29D6;
// 17DB82: using guessed type __int16 word_17DB82;
// 17DB84: using guessed type __int16 word_17DB84;
// 17DB86: using guessed type __int16 word_17DB86;
// 17DB88: using guessed type __int16 word_17DB88;
// 17DB8A: using guessed type __int16 word_17DB8A;
// 17DB8C: using guessed type __int16 word_17DB8C;
// 17DB8E: using guessed type char byte_17DB8E;
// 17DE28: using guessed type int dword_17DE28;
// 17DE2C: using guessed type int dword_17DE2C;
// 17DE30: using guessed type __int16 word_17DE30;
// 17DE32: using guessed type __int16 word_17DE32;
// 17DE34: using guessed type char byte_17DE34;
// 17DE5C: using guessed type int dword_17DE5C;
// 17DE64: using guessed type int dword_17DE64;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 17DF11: using guessed type char byte_17DF11;
// 17E09D: using guessed type char byte_17E09D;
// 180628: using guessed type int dword_180628;

//----- (0007F6A0) --------------------------------------------------------
int __usercall sub_7F6A0@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3, __int16 a4, char *a5, _BYTE *a6, unsigned __int8 a7)
{
  char v7; // al
  __int16 v8; // si
  int v10; // [esp+0h] [ebp-4h]

  v10 = j___clock(a1, a2, a5);
  v7 = byte_17DF10;
  *a6 = strlen(a5);
  if ( (unsigned __int8)v7 < 0xFu )
  {
    if ( (unsigned __int8)v7 < 1u )
      goto LABEL_12;
    if ( (unsigned __int8)v7 <= 1u )
      goto LABEL_16;
    if ( v7 != 14 )
      goto LABEL_12;
  }
  else
  {
    if ( (unsigned __int8)v7 <= 0xFu )
      goto LABEL_16;
    if ( (unsigned __int8)v7 < 0x1Cu )
      goto LABEL_12;
    if ( (unsigned __int8)v7 <= 0x1Cu )
      goto LABEL_16;
    if ( v7 != 83 )
    {
LABEL_12:
      if ( *a6 < 0xFu && byte_17DF11 && sub_7C200(byte_17DF11) )
      {
        a5[(unsigned __int8)*a6] = byte_17DF11;
        a5[(unsigned __int8)*a6 + 1] = 0;
      }
      goto LABEL_16;
    }
  }
  if ( *a6 )
  {
    a5[strlen(a5) - 1] = 0;
    *a6 = strlen(a5);
  }
LABEL_16:
  strupr(a5);
  sub_2BC10(a5, a3, a4, a7);
  if ( (v10 - dword_17DED0) / 0xCu >= 1 )
  {
    v8 = sub_6FC10();
    sub_2BC10(&asc_D1AB3[1], a3 + v8 * strlen(a5), a4, a7);
    dword_17DED0 = v10;
  }
  return 0;
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 9A20A: using guessed type _DWORD __cdecl strupr(_DWORD);
// 17DED0: using guessed type int dword_17DED0;
// 17DF10: using guessed type char byte_17DF10;
// 17DF11: using guessed type char byte_17DF11;

//----- (0007F7D0) --------------------------------------------------------
int __cdecl sub_7F7D0(unsigned int *a1, _DWORD *a2, unsigned int a3, int a4)
{
  int v4; // edi
  int v5; // eax
  int v6; // ebx
  int v7; // ebx
  int v8; // eax
  unsigned __int8 v9; // bl
  char v10; // cl
  char v12; // [esp+0h] [ebp-5Ch]
  int v13; // [esp+50h] [ebp-Ch]
  int v14; // [esp+54h] [ebp-8h]
  unsigned __int8 i; // [esp+58h] [ebp-4h]

  v4 = 0;
  sprintf(&v12, aCSS_0, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherwLanguag, a4);
  for ( i = 0; i < 2u; i = v9 + 1 )
  {
    v4 = unknown_libname_1(a4 + 1);
    v5 = sub_98817((int)&v12, 512);
    v6 = v5;
    v14 = v5;
    if ( v5 != -1 )
    {
      v13 = filelength(v5);
      sub_988A7(v6, a3, 4773);
      sub_988A7(v6, a3 + 4773, 12);
      if ( byte_E29E0 || dword_D41BC )
        sub_83E80(dword_D41BC);
      v7 = v13 - 4785;
      v8 = sub_83CD0(v13 - 4785);
      dword_D41BC = v8;
      if ( v8 )
      {
        byte_E29E0 = 1;
        sub_988A7(v14, v8, v7);
      }
      sub_98882(v14);
      break;
    }
    v9 = i;
    sprintf(&v12, aLanguageS, a4);
  }
  *a1 = a3 + 4773;
  v10 = word_180660;
  *a2 = a3 + 4785;
  if ( v10 & 1 )
    sub_98709(*a1, a3 + 4785, a3);
  else
    sub_9874D((unsigned int *)*a1, a3 + 4785, a3);
  sub_5B870((_BYTE *)dword_D41BC, (int)dword_E9C4C, 471);
  return v4;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// 98F9E: using guessed type _DWORD __cdecl unknown_libname_1(_DWORD);
// D41A4: using guessed type int dword_D41A4;
// D41BC: using guessed type int dword_D41BC;
// E29E0: using guessed type char byte_E29E0;
// 180660: using guessed type __int16 word_180660;

//----- (0007F960) --------------------------------------------------------
int __cdecl sub_7F960(unsigned int *a1, unsigned int a2, unsigned int a3, int a4)
{
  int v4; // esi
  int v5; // eax
  int v6; // ebx
  int v7; // edi
  int v8; // ebx
  int v9; // eax
  unsigned __int8 v10; // bl
  char v12; // [esp+0h] [ebp-58h]
  int v13; // [esp+50h] [ebp-8h]
  unsigned __int8 i; // [esp+54h] [ebp-4h]

  v4 = 0;
  sprintf(&v12, aCSS_0, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherwLanguag, a4);
  for ( i = 0; i < 2u; i = v10 + 1 )
  {
    v4 = unknown_libname_1(a4 + 1);
    v5 = sub_98817((int)&v12, 512);
    v6 = v5;
    v7 = v5;
    if ( v5 != -1 )
    {
      v13 = filelength(v5);
      sub_988A7(v6, a3, 4773);
      sub_988A7(v6, a3 + 4773, 12);
      if ( byte_E29E0 || dword_D41BC )
        sub_83E80(dword_D41BC);
      v8 = v13 - 4785;
      v9 = sub_83CD0(v13 - 4785);
      dword_D41BC = v9;
      if ( v9 )
      {
        byte_E29E0 = 1;
        sub_988A7(v7, v9, v8);
      }
      sub_98882(v7);
      break;
    }
    v10 = i;
    sprintf(&v12, aLanguageS, a4);
  }
  if ( word_180660 & 1 )
    sub_98709((unsigned int)a1, a2, a3);
  else
    sub_9874D(a1, a2, a3);
  sub_5B870((_BYTE *)dword_D41BC, (int)dword_E9C4C, 471);
  return v4;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// 98F9E: using guessed type _DWORD __cdecl unknown_libname_1(_DWORD);
// D41A4: using guessed type int dword_D41A4;
// D41BC: using guessed type int dword_D41BC;
// E29E0: using guessed type char byte_E29E0;
// 180660: using guessed type __int16 word_180660;

//----- (0007FAE0) --------------------------------------------------------
unsigned int __cdecl sub_7FAE0(char *a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5)
{
  unsigned int v5; // kr04_4
  __int16 v6; // bx
  int v7; // ebx

  v5 = strlen(a1) + 1;
  v6 = a3 - a2;
  if ( (_WORD)v5 == 1 )
  {
    v7 = a2 + v6 / 2;
  }
  else
  {
    v7 = v6 / 2 + a2 - *(unsigned __int8 *)(dword_17DEC0 + 394) * (signed __int16)(v5 - 1) / 2;
    sub_7FB90(a1, (signed __int16)v7, a4, a5);
  }
  return v7 + *(unsigned __int8 *)(dword_17DEC0 + 394) * strlen(a1);
}
// 17DEC0: using guessed type int dword_17DEC0;

//----- (0007FB90) --------------------------------------------------------
int __cdecl sub_7FB90(_BYTE *a1, int a2, __int16 a3, unsigned __int8 a4)
{
  _BYTE *v4; // esi
  int v5; // ebx
  __int16 v6; // di
  unsigned __int16 v7; // ax
  int v8; // eax
  int result; // eax
  int v10; // [esp+0h] [ebp-4h]

  v4 = a1;
  v5 = a2;
  v6 = a3;
  if ( a4 )
    word_E36D4 = 64;
  if ( (a2 & 0x8000u) != 0 )
    v5 = 0;
  v10 = v5;
  while ( *v4 && (signed __int16)v5 < 640 )
  {
    v7 = (unsigned __int8)*v4;
    if ( v7 < 0xAu )
    {
      if ( !*v4 )
        goto LABEL_21;
      if ( v7 == 9 )
        goto LABEL_20;
LABEL_16:
      if ( *v4 )
      {
        if ( a4 )
          sub_72C40(v5, v6, 6 * (unsigned __int8)*v4 + dword_17DEC0, a4);
        else
          sub_7C120(v5, v6, 6 * (unsigned __int8)*v4 + dword_17DEC0);
      }
      goto LABEL_20;
    }
    if ( (unsigned __int8)v7 <= 0xAu )
    {
      v5 = v10;
      v6 += *(unsigned __int8 *)(dword_17DEC0 + 395);
      goto LABEL_21;
    }
    if ( v7 < 0xDu )
      goto LABEL_16;
    if ( v7 <= 0xDu )
      goto LABEL_21;
    if ( v7 != 32 )
      goto LABEL_16;
LABEL_20:
    HIWORD(v8) = HIWORD(dword_17DEC0);
    LOWORD(v8) = *(unsigned __int8 *)(dword_17DEC0 + 394);
    v5 += v8;
LABEL_21:
    ++v4;
  }
  result = v5;
  word_E36D4 = 0;
  return result;
}
// E36D4: using guessed type __int16 word_E36D4;
// 17DEC0: using guessed type int dword_17DEC0;

//----- (0007FCB0) --------------------------------------------------------
int __usercall sub_7FCB0@<eax>(int a1@<ebx>, _BYTE *a2, int a3, int a4, int a5, char a6, unsigned __int8 a7, __int16 a8)
{
  int v8; // esi
  signed __int16 j; // di
  int v10; // eax
  int v11; // ebx
  unsigned __int8 v12; // al
  int v13; // edi
  __int16 v14; // ST0C_2
  int v15; // eax
  int v16; // eax
  signed __int16 i; // di
  int v18; // eax
  _BYTE *v19; // ecx
  __int16 v20; // di
  int v21; // eax
  char v22; // al
  char v23; // ah
  char v24; // cl
  __int16 v25; // ax
  int v26; // esi
  unsigned __int8 v27; // al
  int v28; // esi
  __int16 v29; // ST0C_2
  int v30; // eax
  _BYTE *v31; // ecx
  signed __int16 v32; // ax
  __int16 v33; // si
  int v34; // eax
  __int16 v35; // ST0C_2
  __int16 v36; // ST08_2
  signed __int16 v37; // di
  _BYTE *v38; // ecx
  __int16 v39; // si
  unsigned __int16 v40; // ax
  __int16 v41; // di
  int v42; // eax
  int v43; // eax
  int v44; // eax
  unsigned __int8 v45; // al
  int v46; // esi
  __int16 v47; // ST0C_2
  int v48; // edi
  __int16 v49; // ST0C_2
  int v50; // eax
  int v51; // ebx
  unsigned __int8 v52; // al
  __int16 v53; // ST0C_2
  int v54; // ST08_4
  int v55; // eax
  signed __int16 v56; // si
  signed __int16 v57; // si
  _BYTE *v58; // ecx
  int v59; // eax
  __int16 v60; // ax
  int v61; // edi
  int v62; // eax
  int v63; // ebx
  _BYTE *v64; // ecx
  signed __int16 v65; // di
  __int16 v66; // si
  int v67; // eax
  signed __int16 v68; // si
  __int16 v69; // ST0C_2
  __int16 v70; // ST08_2
  int v71; // eax
  _BYTE *v72; // ecx
  signed __int16 l; // si
  __int16 v74; // ax
  int v75; // esi
  int v76; // eax
  int v77; // ebx
  _BYTE *v78; // ecx
  signed __int16 v79; // si
  __int16 v80; // ax
  int v81; // eax
  signed __int16 v82; // si
  __int16 v83; // ST08_2
  int v84; // eax
  unsigned __int8 v86; // [esp-4h] [ebp-FCh]
  char v87[180]; // [esp+0h] [ebp-F8h]
  int v88; // [esp+B4h] [ebp-44h]
  int v89; // [esp+B8h] [ebp-40h]
  int v90; // [esp+BCh] [ebp-3Ch]
  int v91; // [esp+C0h] [ebp-38h]
  int v92; // [esp+C4h] [ebp-34h]
  int v93; // [esp+C8h] [ebp-30h]
  int v94; // [esp+CCh] [ebp-2Ch]
  int v95; // [esp+D0h] [ebp-28h]
  int v96; // [esp+D4h] [ebp-24h]
  unsigned __int16 v97; // [esp+D8h] [ebp-20h]
  int v98; // [esp+DCh] [ebp-1Ch]
  int v99; // [esp+E0h] [ebp-18h]
  int k; // [esp+E4h] [ebp-14h]
  int v101; // [esp+E8h] [ebp-10h]
  int v102; // [esp+ECh] [ebp-Ch]
  int v103; // [esp+F0h] [ebp-8h]
  int v104; // [esp+F4h] [ebp-4h]

  v8 = a5;
  v98 = a5;
  v102 = a5;
  v95 = 0;
  v103 = 0;
  v104 = 0;
  memset(v87, 0, 180);
  if ( a6 )
  {
    if ( a6 == 2 || a6 == 5 )
    {
      v104 = a4 - a3;
      if ( a8 )
      {
        v103 = *(unsigned __int8 *)(dword_17DED4 + 1654);
        v90 = *(unsigned __int8 *)(dword_17DED4 + 1654);
        v94 = (signed __int16)v104 / v90;
        if ( (signed __int16)v104 % v90 )
        {
          v16 = v103 * (v94++ + 1);
          v104 = v16;
          a4 = v16 + a3 - *(unsigned __int8 *)(dword_17DED4 + 1648);
        }
        for ( i = 0; i < (signed __int16)v104; i += v103 )
          sub_7C120(i + a3, a5, dword_17DED4 + 1650);
        HIWORD(v18) = HIWORD(dword_17DED4);
        LOWORD(v18) = *(unsigned __int8 *)(dword_17DED4 + 1655);
        v8 = v18 + a5;
        v93 = 0;
        v19 = (_BYTE *)(dword_180628 + (signed __int16)a3 + 640 * (signed __int16)(v18 + a5));
        while ( *(unsigned __int8 *)(dword_17DED4 + 1649) > (signed __int16)v93 )
        {
          v20 = 0;
          while ( 1 )
          {
            v90 = *(unsigned __int8 *)(dword_17DED4 + 1648);
            if ( v20 >= (signed __int16)a4 - (v90 + (signed __int16)a3) )
              break;
            HIBYTE(v97) = 15;
            LOBYTE(v97) = *v19;
            ++v20;
            *(++v19 - 1) = *(_BYTE *)(dword_17DE3C + v97);
          }
          v19 += 640 - v20;
          ++v93;
        }
        sub_7C120(a3, v8, dword_17DED4 + 1644);
        sub_7C120(a4 - *(unsigned __int8 *)(dword_17DED4 + 1648), v8, dword_17DED4 + 1644);
      }
      if ( a8 )
      {
        HIWORD(v21) = HIWORD(dword_17DED4);
        LOWORD(v21) = *(unsigned __int8 *)(dword_17DED4 + 1649);
        a1 = v21 + v8;
        v98 += v21;
      }
      else
      {
        v98 = v8;
      }
    }
  }
  else
  {
    v104 = a4 - a3;
    v88 = a8;
    v92 = dword_17DED4;
    v103 = *(unsigned __int8 *)(dword_17DED4 + 6 * a8 + 4);
    if ( (signed __int16)(a4 - a3) % (signed int)(unsigned __int8)v103 )
    {
      v104 = ((signed __int16)(a4 - a3) / (signed int)(unsigned __int8)v103 + 1) * v103;
      a4 = v104 + a3 - *(unsigned __int8 *)(v92 + 6 * (v88 - 1) + 4);
    }
    for ( j = 0; j < (signed __int16)v104; j += v103 )
      sub_7C120(j + a3, a5, 6 * a8 + dword_17DED4);
    HIWORD(v10) = HIWORD(dword_17DED4);
    LOWORD(v10) = *(unsigned __int8 *)(dword_17DED4 + 6 * a8 + 5);
    v11 = v10 + a5;
    v98 += v10;
    v12 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, v86);
    *(_DWORD *)&v86 = v12;
    v13 = 6 * (a8 - 1);
    v14 = *(unsigned __int8 *)(v13 + dword_17DED4 + 5);
    v91 = (signed __int16)v11;
    v90 = (signed __int16)a3;
    sub_7C140((signed __int16)a3, v11, (signed __int16)v104, v14, v12);
    sub_7C120(v90, v91, v13 + dword_17DED4);
    sub_7C120(a4, v91, v13 + dword_17DED4);
    HIWORD(v15) = HIWORD(dword_17DED4);
    LOWORD(v15) = *(unsigned __int8 *)(v13 + dword_17DED4 + 5);
    a1 = v15 + v11;
    v98 += v15;
  }
  v99 = a3;
  if ( !a6 )
    v98 = v8 + 12;
  v96 = 0;
  v101 = 0;
  for ( k = 0; ; ++k )
  {
    v22 = 0;
    if ( a6 )
    {
      v24 = a2[(signed __int16)k];
      if ( v24 == 32 || !v24 )
      {
LABEL_38:
        v22 = 1;
        goto LABEL_39;
      }
    }
    else
    {
      v23 = a2[(signed __int16)k];
      if ( v23 == 32 || !v23 || v23 == 44 || v23 == 45 || v23 == 46 )
        goto LABEL_38;
    }
LABEL_39:
    if ( v22 )
    {
      if ( (_WORD)v101 )
      {
        if ( a6 && a6 != 4 && a6 != 5 )
        {
          sub_6FC50(*(__int16 *)&v86);
          v25 = sub_6FC10();
        }
        else
        {
          v25 = *(unsigned __int8 *)(dword_17DEC0 + 394);
        }
        v89 = (signed __int16)k;
        v26 = (signed __int16)v99;
        if ( (signed __int16)v99 + v25 * ((signed __int16)k - (signed __int16)v96) <= (signed __int16)a4 - 3 * v25 )
        {
          *(_DWORD *)&v86 = &v87[strlen(v87)];
          qmemcpy(*(void **)&v86, &a2[(signed __int16)v101 + 1], v89 - (signed __int16)v101);
        }
        else
        {
          if ( a6 && a6 != 4 )
          {
            if ( a6 == 2 )
            {
              sub_6FC50(*(__int16 *)&v86);
              v31 = (_BYTE *)(dword_180628 + v26 + 640 * (signed __int16)a1);
              v32 = 0;
              while ( v32 < *(unsigned __int8 *)(dword_17DED4 + 1649) )
              {
                v33 = 0;
                while ( v33 < (signed __int16)a4 - ((signed __int16)v99 - *(unsigned __int8 *)(dword_17DED4 + 1648)) )
                {
                  HIBYTE(v97) = 15;
                  LOBYTE(v97) = *v31;
                  ++v33;
                  *(++v31 - 1) = *(_BYTE *)(dword_17DE3C + v97);
                }
                ++v32;
                v31 += 640 - v33;
              }
              sub_7C120(v99, a1, dword_17DED4 + 1644);
              sub_7C120(a4, a1, dword_17DED4 + 1644);
              HIWORD(v34) = HIWORD(dword_17DED4);
              LOWORD(v34) = *(unsigned __int8 *)(dword_17DED4 + 1649);
              a1 += v34;
              *(_DWORD *)&v86 = a7;
              v35 = v98;
              v36 = a4 - 2 * sub_6FC10();
              sub_6FC80(v87, v99 + *(unsigned __int8 *)(dword_17DED4 + 1654), v36, v35, a7);
            }
            else if ( a6 == 5 )
            {
              if ( a8 )
              {
                v37 = 0;
                v38 = (_BYTE *)(dword_180628 + (signed __int16)v99 + 640 * (signed __int16)a1);
                while ( v37 < *(unsigned __int8 *)(dword_17DED4 + 1649) )
                {
                  v39 = 0;
                  while ( 1 )
                  {
                    v90 = *(unsigned __int8 *)(dword_17DED4 + 1648);
                    if ( v39 >= (signed __int16)a4 - (v90 + (signed __int16)v99) )
                      break;
                    HIBYTE(v40) = 15;
                    LOBYTE(v40) = *v38;
                    ++v39;
                    *(++v38 - 1) = *(_BYTE *)(dword_17DE3C + v40);
                  }
                  ++v37;
                  v38 += 640 - v39;
                }
                v41 = v99;
                sub_7C120(v99, a1, dword_17DED4 + 1644);
                *(_DWORD *)&v86 = dword_17DED4 + 1644;
                sub_7C120(a4 - *(unsigned __int8 *)(dword_17DED4 + 1648), a1, dword_17DED4 + 1644);
                HIWORD(v42) = HIWORD(dword_17DED4);
                LOWORD(v42) = *(unsigned __int8 *)(dword_17DED4 + 1649);
                a1 += v42;
                sub_7FAE0(v87, v41, a4, v98, v86);
              }
              else
              {
                sub_7FAE0(v87, v99, a4, v98, v86);
              }
            }
            else
            {
              sub_6FC80(v87, v99, a4, v98, a7);
            }
          }
          else
          {
            if ( !a6 )
            {
              v27 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, v86);
              *(_DWORD *)&v86 = v27;
              v28 = 6 * (a8 - 1);
              v29 = *(unsigned __int8 *)(v28 + dword_17DED4 + 5);
              v90 = (signed __int16)v99;
              sub_7C140((signed __int16)v99, a1, (signed __int16)v104, v29, v27);
              sub_7C120(v90, a1, v28 + dword_17DED4);
              sub_7C120(a4, a1, v28 + dword_17DED4);
              HIWORD(v30) = HIWORD(dword_17DED4);
              LOWORD(v30) = *(unsigned __int8 *)(v28 + dword_17DED4 + 5);
              a1 += v30;
            }
            sub_7FAE0(v87, v99, a4, v98, v86);
          }
          if ( a6 && a6 != 4 && a6 != 5 )
          {
            LOWORD(v44) = sub_6FC30();
            v98 += v44 + 2;
          }
          else
          {
            HIWORD(v43) = HIWORD(dword_17DEC0);
            LOWORD(v43) = *(unsigned __int8 *)(dword_17DEC0 + 395);
            v98 += v43;
          }
          memset(v87, 0, 180);
          *(_DWORD *)&v86 = v87;
          qmemcpy(v87, &a2[(signed __int16)v101 + 1], (signed __int16)k - (signed __int16)v101);
          v96 = v101;
        }
      }
      else
      {
        *(_DWORD *)&v86 = v87;
        qmemcpy(v87, a2, (signed __int16)k + 1);
      }
      v101 = k;
    }
    if ( !a2[(signed __int16)k] )
      break;
  }
  if ( !(_WORD)v95 )
  {
    if ( a6 && a6 != 4 )
    {
      sub_6FC50(*(__int16 *)&v86);
      if ( a6 == 2 )
      {
        sub_6FC50(*(__int16 *)&v86);
        v57 = 0;
        v58 = (_BYTE *)((signed __int16)v99 + 640 * (signed __int16)a1);
        v59 = dword_180628;
        while ( 1 )
        {
          v58 += v59;
          if ( v57 >= *(unsigned __int8 *)(dword_17DED4 + 1649) )
            break;
          v60 = 0;
          while ( 1 )
          {
            v91 = *(unsigned __int8 *)(dword_17DED4 + 1648);
            if ( v60 >= (signed __int16)a4 - ((signed __int16)v99 - v91) )
              break;
            HIBYTE(v97) = 15;
            LOBYTE(v97) = *v58;
            ++v60;
            *(++v58 - 1) = *(_BYTE *)(dword_17DE3C + v97);
          }
          v59 = 640 - v60;
          ++v57;
        }
        v61 = (signed __int16)v99;
        sub_7C120(v99, a1, dword_17DED4 + 1644);
        sub_7C120(a4, a1, dword_17DED4 + 1644);
        HIWORD(v62) = HIWORD(dword_17DED4);
        LOWORD(v62) = *(unsigned __int8 *)(dword_17DED4 + 1649);
        v63 = v62 + a1;
        sub_6FC50(*(__int16 *)&v86);
        v64 = (_BYTE *)(640 * (signed __int16)v63 + v61 + dword_180628);
        v65 = 0;
        while ( v65 < *(unsigned __int8 *)(dword_17DED4 + 1649) )
        {
          v66 = 0;
          while ( 1 )
          {
            v91 = *(unsigned __int8 *)(dword_17DED4 + 1648);
            if ( v66 >= (signed __int16)a4 - ((signed __int16)v99 - v91) )
              break;
            HIBYTE(v97) = 15;
            LOBYTE(v97) = *v64;
            ++v66;
            *(++v64 - 1) = *(_BYTE *)(dword_17DE3C + v97);
          }
          ++v65;
          v64 += 640 - v66;
        }
        sub_7C120(v99, v63, dword_17DED4 + 1644);
        sub_7C120(a4, v63, dword_17DED4 + 1644);
        HIWORD(v67) = HIWORD(dword_17DED4);
        LOWORD(v67) = *(unsigned __int8 *)(dword_17DED4 + 1649);
        v68 = 0;
        a1 = v67 + v63;
        while ( v68 < (signed __int16)v104 )
        {
          sub_7C120(v68 + a3, a1, dword_17DED4 + 1650);
          v68 += v103;
        }
        *(_DWORD *)&v86 = a7;
        v69 = v98;
        v70 = a4 - 2 * sub_6FC10();
        sub_6FC80(v87, v99 + *(unsigned __int8 *)(dword_17DED4 + 1654), v70, v69, a7);
      }
      else if ( a6 == 5 )
      {
        if ( a8 )
        {
          v71 = 640 * (signed __int16)a1 + (signed __int16)v99;
          v72 = (_BYTE *)dword_180628;
          for ( l = 0; ; ++l )
          {
            v72 += v71;
            if ( l >= *(unsigned __int8 *)(dword_17DED4 + 1649) )
              break;
            v74 = 0;
            while ( 1 )
            {
              v91 = *(unsigned __int8 *)(dword_17DED4 + 1648);
              if ( v74 >= (signed __int16)a4 - (v91 + (signed __int16)v99) )
                break;
              HIBYTE(v97) = 15;
              LOBYTE(v97) = *v72;
              ++v74;
              *(++v72 - 1) = *(_BYTE *)(dword_17DE3C + v97);
            }
            v71 = 640 - v74;
          }
          v75 = (signed __int16)v99;
          sub_7C120(v99, a1, dword_17DED4 + 1644);
          *(_DWORD *)&v86 = dword_17DED4 + 1644;
          sub_7C120(a4 - *(unsigned __int8 *)(dword_17DED4 + 1648), a1, dword_17DED4 + 1644);
          HIWORD(v76) = HIWORD(dword_17DED4);
          LOWORD(v76) = *(unsigned __int8 *)(dword_17DED4 + 1649);
          v77 = v76 + a1;
          v78 = (_BYTE *)(640 * (signed __int16)v77 + v75 + dword_180628);
          v79 = 0;
          while ( v79 < *(unsigned __int8 *)(dword_17DED4 + 1649) )
          {
            v80 = 0;
            while ( 1 )
            {
              v90 = *(unsigned __int8 *)(dword_17DED4 + 1648);
              if ( v80 >= (signed __int16)a4 - (v90 + (signed __int16)v99) )
                break;
              HIBYTE(v97) = 15;
              LOBYTE(v97) = *v78;
              ++v80;
              *(++v78 - 1) = *(_BYTE *)(dword_17DE3C + v97);
            }
            ++v79;
            v78 += 640 - v80;
          }
          sub_7C120(v99, v77, dword_17DED4 + 1644);
          *(_DWORD *)&v86 = dword_17DED4 + 1644;
          sub_7C120(a4 - *(unsigned __int8 *)(dword_17DED4 + 1648), v77, dword_17DED4 + 1644);
          HIWORD(v81) = HIWORD(dword_17DED4);
          LOWORD(v81) = *(unsigned __int8 *)(dword_17DED4 + 1649);
          v82 = 0;
          a1 = v81 + v77;
          while ( v82 < (signed __int16)v104 )
          {
            v83 = v82 + a3;
            v82 += v103;
            sub_7C120(v83, a1, dword_17DED4 + 1650);
          }
          sub_7FAE0(v87, v99 + *(unsigned __int8 *)(dword_17DED4 + 1654), a4, v98, 0);
        }
        else
        {
          sub_7FAE0(v87, v99, a4, v98, v86);
        }
      }
      else
      {
        sub_6FC80(v87, v99, a4, v98, a7);
      }
    }
    else
    {
      if ( !a6 )
      {
        v45 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, v86);
        *(_DWORD *)&v86 = v45;
        v46 = 6 * (a8 - 1);
        v47 = *(unsigned __int8 *)(v46 + dword_17DED4 + 5);
        v91 = (signed __int16)v104;
        v48 = (signed __int16)v99;
        v90 = (signed __int16)a1;
        sub_7C140((signed __int16)v99, a1, (signed __int16)v104, v47, v45);
        sub_7C120(v48, v90, v46 + dword_17DED4);
        v49 = v90;
        v90 = (signed __int16)a4;
        sub_7C120(a4, v49, v46 + dword_17DED4);
        HIWORD(v50) = HIWORD(dword_17DED4);
        LOWORD(v50) = *(unsigned __int8 *)(v46 + dword_17DED4 + 5);
        v51 = v50 + a1;
        v52 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, v86);
        *(_DWORD *)&v86 = v52;
        v53 = *(unsigned __int8 *)(v46 + dword_17DED4 + 5);
        v54 = v91;
        v91 = (signed __int16)v51;
        sub_7C140(v48, v51, v54, v53, v52);
        sub_7C120(v48, v91, v46 + dword_17DED4);
        sub_7C120(v90, v91, v46 + dword_17DED4);
        HIWORD(v55) = HIWORD(dword_17DED4);
        LOWORD(v55) = *(unsigned __int8 *)(v46 + dword_17DED4 + 5);
        v56 = 0;
        a1 = v55 + v51;
        while ( v56 < (signed __int16)v104 )
        {
          sub_7C120(v56 + v99, a1, 6 * a8 + dword_17DED4);
          v56 += v103;
        }
      }
      sub_7FAE0(v87, v99, a4, v98, v86);
    }
  }
  if ( a6 )
    return v98 - v102;
  HIWORD(v84) = HIWORD(dword_17DED4);
  LOWORD(v84) = *(unsigned __int8 *)(dword_17DED4 + 6 * (a8 + 2) + 5);
  return a1 - v102 + v84;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 17DE38: using guessed type int dword_17DE38;
// 17DE3C: using guessed type int dword_17DE3C;
// 17DEC0: using guessed type int dword_17DEC0;
// 17DED4: using guessed type int dword_17DED4;
// 180628: using guessed type int dword_180628;
// 7FCB0: using guessed type char var_F8[180];

//----- (00080C30) --------------------------------------------------------
void __cdecl sub_80C30(__int16 a1, __int16 a2, __int16 a3)
{
  signed int v3; // ebx
  char *v4; // eax
  signed int v5; // edx
  _WORD *i; // eax
  unsigned __int8 v7; // ST14_1
  int v8; // ST08_4
  __int16 v9; // ax

  v3 = -1;
  v4 = (char *)&unk_E1960;
  v5 = 0;
  while ( *((_WORD *)v4 + 2) )
  {
    if ( v4[18] == 2 )
    {
      v3 = v5;
      break;
    }
    v4 += 22;
    ++v5;
  }
  if ( a2 + a1 > 0 )
  {
    for ( i = word_E2970; i[6]; i = (_WORD *)((char *)i + 17) )
    {
      if ( i[6] != 3 && (_WORD)v3 == i[2] )
      {
        byte_17DE34 = 3;
        return;
      }
    }
    sub_6FC50(1);
    v7 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x3Fu, 0x3Fu, 0x3Fu);
    v8 = (signed __int16)(a1 + a3 - 3 * sub_6FC10());
    v9 = sub_6FC10();
    sub_7FCB0(v3, (_BYTE *)dword_E9CA8[(signed __int16)v3], (signed __int16)(a1 + 4 * v9), v8, a2, 5, v7, 1);
  }
  if ( byte_17DE34 != 3 && *(_BYTE *)(dword_D41A4 + 24) & 0x40 && !byte_17E09D )
  {
    byte_17E09D = 1;
    if ( (signed __int16)v3 != -1 )
      sub_86EB0(v3, 0, 0);
  }
}
// D41A4: using guessed type int dword_D41A4;
// 17DE34: using guessed type char byte_17DE34;
// 17DE38: using guessed type int dword_17DE38;
// 17E09D: using guessed type char byte_17E09D;

//----- (00080D40) --------------------------------------------------------
signed int __usercall sub_80D40@<eax>(__int16 a1@<si>, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  signed int v6; // ebx
  char *v7; // eax
  char v8; // dl
  int v10; // edx
  int v11; // ebx
  __int16 v12; // ax
  int v13; // edx
  int v14; // edx
  __int16 v15; // si
  __int16 v16; // ax
  char v17; // dh
  signed __int16 v18; // cx
  int v19; // ecx
  int v20; // edx
  __int16 v21; // [esp+0h] [ebp-10h]
  __int16 v22; // [esp+2h] [ebp-Eh]
  __int16 v23; // [esp+8h] [ebp-8h]
  __int16 v24; // [esp+Ah] [ebp-6h]

  v6 = 1;
  if ( (unsigned __int8)byte_17E09C >= 1u )
  {
    if ( (unsigned __int8)byte_17E09C > 2u )
      return v6;
    v15 = 0;
    while ( v15 < 3 )
    {
      ++v15;
      v6 = sub_7E9D0(&word_17E06C, &word_17E06E, &unk_17E084);
    }
    v23 = word_17E074;
    v24 = word_17E076;
    v21 = word_17E06C;
    v22 = word_17E06E;
    v16 = sub_581E0(&v23, &v21);
    if ( v16 > 1024 && v16 < 1536 )
    {
      if ( byte_17E082 != 21 )
      {
        word_17E080 = 21;
        byte_17E082 = 21;
        byte_17E083 = 24;
      }
      goto LABEL_54;
    }
    if ( v16 <= 1536 || v16 >= 2048 )
    {
      if ( (v16 > 2048 || v16 > 0) && v16 < 512 )
      {
        if ( byte_17E082 != 5 )
        {
          word_17E080 = 5;
          byte_17E082 = 5;
          byte_17E083 = 8;
        }
        goto LABEL_54;
      }
      if ( v16 <= 512 || v16 >= 1024 )
      {
        switch ( v16 )
        {
          case 2048:
          case 0:
            if ( byte_17E082 != 17 )
            {
              word_17E080 = 17;
              byte_17E082 = 17;
              byte_17E083 = 20;
            }
            goto LABEL_54;
          case 512:
            if ( byte_17E082 == 9 )
              goto LABEL_54;
            byte_17E082 = 9;
            v17 = 12;
            word_17E080 = 9;
            goto LABEL_53;
          case 1024:
            if ( byte_17E082 != 1 )
            {
              word_17E080 = 1;
              byte_17E082 = 1;
              byte_17E083 = 4;
            }
            goto LABEL_54;
        }
        if ( v16 != 1536 || byte_17E082 == 25 )
        {
LABEL_54:
          word_17E07C = word_17E06C;
          word_17E07E = word_17E06E;
          if ( a6 != 1
            && byte_17E09C != 2
            && !(_WORD)v6
            && (abs(word_17E06E - word_17E072) > 8 || abs(word_17E06C - word_17E070) > 8) )
          {
            if ( word_17DB8A == -1 )
              sub_812D0(word_17E07C, word_17E07E);
            word_17E070 = word_17E06C;
            word_17E072 = word_17E06E;
          }
          v19 = 6 * word_17E080 + dword_17DED4;
          v20 = word_17E06C - *(unsigned __int8 *)(v19 + 4) / 2 - a2;
          sub_81260(
            (signed __int16)v20,
            v20,
            (int)&unk_17E078,
            word_17E06C - *(unsigned __int8 *)(v19 + 4) / 2 - a2,
            word_17E06E - *(unsigned __int8 *)(v19 + 5) / 2 - a3);
          if ( (_WORD)v6 )
            byte_17E09C = 3;
          return v6;
        }
        v18 = 25;
        byte_17E082 = 25;
        v17 = 28;
      }
      else
      {
        if ( byte_17E082 == 13 )
          goto LABEL_54;
        v18 = 13;
        byte_17E082 = 13;
        v17 = 16;
      }
      word_17E080 = v18;
    }
    else
    {
      if ( byte_17E082 == 29 )
        goto LABEL_54;
      byte_17E082 = 29;
      v17 = 32;
      word_17E080 = 29;
    }
LABEL_53:
    byte_17E083 = v17;
    goto LABEL_54;
  }
  if ( !byte_17E09C )
  {
    if ( word_17DB8A == -1 )
    {
      v7 = (char *)&unk_E1960;
      a1 = 0;
      word_17E06C = 0;
      word_17E06E = 0;
      while ( *((_WORD *)v7 + 2) )
      {
        v8 = v7[18];
        if ( v8 == 1 )
        {
          word_17E06C = *((_WORD *)v7 + 6);
          word_17E06E = *((_WORD *)v7 + 7);
        }
        else if ( v8 == 2 && !a1 )
        {
          return 1;
        }
        v7 += 22;
        ++a1;
      }
    }
    word_17E074 = a4;
    v10 = *(unsigned __int8 *)(dword_17DED4 + 226);
    word_17E076 = a5;
    v11 = v10 / 2;
    v12 = v10 / 2 + a4;
    v13 = *(unsigned __int8 *)(dword_17DED4 + 227);
    word_17E074 = v12;
    v14 = v13 / 2;
    word_17E076 = v14 + a5;
    if ( word_17DB8A == -1 )
    {
      word_17E06C += v11;
      word_17E06E += v14;
    }
    sub_7E8D0(&unk_17E084, word_17E074, word_17E076, word_17E06C, word_17E06E, 2, 2);
    byte_17E09C = (a1 == 0) + 1;
    word_17E070 = word_17E06C;
    word_17E072 = word_17E06E;
    v6 = 0;
    if ( abs(word_17E074 - word_17E06C) > 5 && abs(word_17E076 - word_17E06E) > 6 )
    {
      sub_8F100(0, 19, (unsigned __int8)byte_E1324, 64, 0x64u, 0, 2u);
      return 0;
    }
  }
  return v6;
}
// E1324: using guessed type char byte_E1324;
// 17DB8A: using guessed type __int16 word_17DB8A;
// 17DED4: using guessed type int dword_17DED4;
// 17E06C: using guessed type __int16 word_17E06C;
// 17E06E: using guessed type __int16 word_17E06E;
// 17E070: using guessed type __int16 word_17E070;
// 17E072: using guessed type __int16 word_17E072;
// 17E074: using guessed type __int16 word_17E074;
// 17E076: using guessed type __int16 word_17E076;
// 17E07C: using guessed type __int16 word_17E07C;
// 17E07E: using guessed type __int16 word_17E07E;
// 17E080: using guessed type __int16 word_17E080;
// 17E082: using guessed type char byte_17E082;
// 17E083: using guessed type char byte_17E083;
// 17E09C: using guessed type char byte_17E09C;

//----- (00081260) --------------------------------------------------------
int __usercall sub_81260@<eax>(int a1@<eax>, int a2@<edx>, int a3, __int16 a4, __int16 a5)
{
  int v5; // ecx

  v5 = j___clock(a1, a2, a3);
  if ( (unsigned int)(v5 - *(_DWORD *)a3) >> 4 >= 1 )
  {
    if ( *(signed __int16 *)(a3 + 8) <= *(unsigned __int8 *)(a3 + 11) - 1 )
      ++*(_WORD *)(a3 + 8);
    else
      *(_WORD *)(a3 + 8) = *(unsigned __int8 *)(a3 + 10);
    *(_DWORD *)a3 = v5;
  }
  return sub_7C120(a4, a5, dword_17DED4 + 6 * *(signed __int16 *)(a3 + 8));
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 17DED4: using guessed type int dword_17DED4;

//----- (000812D0) --------------------------------------------------------
int __cdecl sub_812D0(__int16 a1, __int16 a2)
{
  int v2; // edi
  __int16 v3; // si
  __int16 v4; // bx
  int result; // eax

  _disable();
  v2 = dword_180628;
  dword_180628 = dword_17DE64;
  v3 = dword_180624;
  dword_180644 = 960;
  dword_180624 = 960;
  v4 = dword_18062C;
  dword_180648 = 1280;
  dword_18062C = 1280;
  sub_7C120(a1, a2, dword_17DED4 + 834);
  dword_18062C = v4;
  dword_180624 = v3;
  dword_180648 = v4;
  result = v3;
  dword_180628 = v2;
  dword_180644 = v3;
  _enable();
  return result;
}
// 17DE64: using guessed type int dword_17DE64;
// 17DED4: using guessed type int dword_17DED4;
// 180624: using guessed type int dword_180624;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180644: using guessed type int dword_180644;
// 180648: using guessed type int dword_180648;

//----- (00081360) --------------------------------------------------------
int __cdecl sub_81360(int a1, int a2, int a3, int a4, __int16 a5)
{
  int v5; // edi
  int v6; // esi
  __int16 v7; // bx
  __int16 v8; // ax
  int v9; // ecx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // edx
  int v17; // edx
  int v18; // eax
  __int16 v19; // [esp+0h] [ebp-38h]
  __int16 v20; // [esp+2h] [ebp-36h]
  __int16 v21; // [esp+8h] [ebp-30h]
  __int16 v22; // [esp+Ah] [ebp-2Eh]
  int v23; // [esp+10h] [ebp-28h]
  int v24; // [esp+14h] [ebp-24h]
  int v25; // [esp+18h] [ebp-20h]
  int v26; // [esp+1Ch] [ebp-1Ch]
  int v27; // [esp+20h] [ebp-18h]
  int v28; // [esp+24h] [ebp-14h]
  int v29; // [esp+28h] [ebp-10h]
  int v30; // [esp+2Ch] [ebp-Ch]
  int v31; // [esp+30h] [ebp-8h]
  int v32; // [esp+34h] [ebp-4h]

  v5 = a1;
  v6 = a2;
  v21 = a1;
  v19 = a3;
  v22 = a2;
  v20 = a4;
  v7 = 0;
  v29 = 0;
  v28 = 0;
  v8 = sub_581E0(&v19, &v21);
  if ( v8 <= 1024 || v8 >= 1536 )
  {
    if ( v8 <= 1536 || v8 >= 2048 )
    {
      if ( v8 <= 2048 && v8 <= 0 || v8 >= 512 )
      {
        if ( v8 <= 512 || v8 >= 1024 )
        {
          if ( v8 != 2048 && v8 )
          {
            switch ( v8 )
            {
              case 512:
                v7 = a5 - 3;
                break;
              case 1024:
                v7 = a5 - 5;
                break;
              case 1536:
                v7 = a5 + 3;
                break;
            }
          }
          else
          {
            v7 = a5 - 1;
          }
        }
        else
        {
          v7 = a5 - 4;
        }
      }
      else
      {
        v7 = a5 - 2;
      }
    }
    else
    {
      v7 = a5 + 2;
    }
  }
  else
  {
    v7 = a5 + 4;
  }
  v24 = a3 - a1;
  v9 = 6 * a5;
  v25 = a4 - a2;
  v23 = *(unsigned __int8 *)(v9 + dword_17DED4 + 4);
  v31 = 2 * abs((signed __int16)(a3 - a1) / v23);
  v23 = *(unsigned __int8 *)(v9 + dword_17DED4 + 5);
  v30 = 2 * abs((signed __int16)(a4 - a2) / v23);
  v10 = a3 - a1;
  if ( (signed __int16)(a3 - a1) >= 0 )
  {
    if ( (_WORD)a3 != (_WORD)a1 )
    {
      HIWORD(v10) = HIWORD(dword_17DED4);
      LOWORD(v10) = *(unsigned __int8 *)(v9 + dword_17DED4 + 4);
    }
  }
  else
  {
    HIWORD(v11) = HIWORD(dword_17DED4);
    LOWORD(v11) = *(unsigned __int8 *)(v9 + dword_17DED4 + 4);
    v10 = -v11;
  }
  v27 = v10;
  v12 = v25;
  if ( (v25 & 0x8000u) == 0 )
  {
    if ( (_WORD)v25 )
    {
      v12 = 3 * a5;
      LOWORD(v12) = *(unsigned __int8 *)(dword_17DED4 + 6 * a5 + 5);
    }
  }
  else
  {
    v13 = 3 * a5;
    LOWORD(v13) = *(unsigned __int8 *)(dword_17DED4 + 6 * a5 + 5);
    v12 = -v13;
  }
  v26 = v12;
  if ( (signed __int16)a1 >= (signed __int16)a3 )
  {
    if ( (signed __int16)a1 > (signed __int16)a3 )
      v29 = 1;
  }
  else
  {
    v29 = 2;
  }
  if ( (signed __int16)a2 >= (signed __int16)a4 )
  {
    if ( (signed __int16)a2 > (signed __int16)a4 )
      v28 = 1;
  }
  else
  {
    v28 = 2;
  }
  if ( (signed __int16)v31 <= (signed __int16)v30 )
  {
    v14 = (signed __int16)v30;
    v15 = (signed __int16)v31;
  }
  else
  {
    v14 = (signed __int16)v31;
    v15 = (signed __int16)v30;
  }
  v32 = v15 - (v14 >> 1);
  while ( 1 )
  {
    if ( (signed __int16)v31 <= (signed __int16)v30 )
    {
      if ( (_WORD)v6 == (_WORD)a4 )
        return sub_7C120(v5, a4, dword_17DED4 + 6 * v7);
      if ( (v32 & 0x8000u) == 0 )
      {
        v5 += v27;
        v32 -= v30;
      }
      v17 = v32;
      v6 += v26;
      v18 = v31;
    }
    else
    {
      if ( (_WORD)v5 == (_WORD)a3 )
        return sub_7C120(a3, v6, dword_17DED4 + 6 * v7);
      if ( (v32 & 0x8000u) == 0 )
      {
        v6 += v26;
        v32 -= v31;
      }
      v17 = v32;
      v5 += v27;
      v18 = v30;
    }
    v32 = v18 + v17;
    if ( (unsigned __int16)v29 >= 1u )
    {
      if ( (unsigned __int16)v29 <= 1u )
      {
        if ( (signed __int16)v5 < (signed __int16)a3 )
          return sub_7C120(a3, a4, dword_17DED4 + 6 * v7);
      }
      else if ( (_WORD)v29 == 2 && (signed __int16)v5 > (signed __int16)a3 )
      {
        return sub_7C120(a3, a4, 6 * v7 + dword_17DED4);
      }
    }
    if ( (unsigned __int16)v28 < 1u )
      goto LABEL_70;
    if ( (unsigned __int16)v28 > 1u )
      break;
    if ( (signed __int16)v6 < (signed __int16)a4 )
      return sub_7C120(a3, a4, dword_17DED4 + 6 * v7);
LABEL_70:
    sub_7C120(v5, v6, 6 * a5 + dword_17DED4);
  }
  if ( (_WORD)v28 != 2 || (signed __int16)v6 <= (signed __int16)a4 )
    goto LABEL_70;
  return sub_7C120(a3, a4, 6 * v7 + dword_17DED4);
}
// 17DED4: using guessed type int dword_17DED4;

//----- (00081760) --------------------------------------------------------
signed int __fastcall sub_81760(int a1)
{
  signed int v1; // esi
  __int16 v2; // bx
  __int16 v3; // di
  _WORD *i; // ebx
  int v5; // edx
  int v6; // edi
  char *v7; // ebx
  signed __int16 v8; // cx
  char *v9; // edx
  int k; // eax
  int v11; // edi
  int v12; // ebx
  char v14; // [esp+0h] [ebp-44h]
  int v15; // [esp+18h] [ebp-2Ch]
  int j; // [esp+1Ch] [ebp-28h]
  int v17; // [esp+20h] [ebp-24h]
  int v18; // [esp+24h] [ebp-20h]
  int v19; // [esp+28h] [ebp-1Ch]
  int l; // [esp+2Ch] [ebp-18h]
  int v21; // [esp+30h] [ebp-14h]
  int v22; // [esp+34h] [ebp-10h]
  int v23; // [esp+38h] [ebp-Ch]
  int v24; // [esp+3Ch] [ebp-8h]
  int v25; // [esp+40h] [ebp-4h]

  v1 = 0;
  v24 = 0;
  if ( byte_E1B82 == 1 )
  {
    _disable();
    v15 = dword_180628;
    dword_180628 = dword_17DE64;
    v2 = dword_180624;
    dword_180644 = 960;
    dword_180624 = 960;
    v3 = dword_18062C;
    dword_180648 = 1280;
    dword_18062C = 1280;
    sub_7C120(518, 17, dword_17DED4 + 1710);
    sub_7C120(583, 17, dword_17DED4 + 1716);
    sub_7C120(657, 17, dword_17DED4 + 1722);
    sub_7C120(696, 17, dword_17DED4 + 1728);
    sub_7C120(518, 88, dword_17DED4 + 1734);
    sub_7C120(574, 88, dword_17DED4 + 1740);
    sub_7C120(657, 88, dword_17DED4 + 1746);
    sub_7C120(706, 88, dword_17DED4 + 1752);
    sub_7C120(518, 156, dword_17DED4 + 1758);
    sub_7C120(582, 156, dword_17DED4 + 1764);
    sub_7C120(657, 156, dword_17DED4 + 1770);
    sub_7C120(703, 156, dword_17DED4 + 1776);
    dword_18062C = v3;
    dword_180624 = v2;
    dword_180648 = v3;
    dword_180644 = v2;
    HIWORD(a1) = HIWORD(v15);
    dword_180628 = v15;
    _enable();
  }
  for ( i = &unk_E1960; i[2]; i += 11 )
  {
    if ( *((_BYTE *)i + 18) == 1 && !(_WORD)v24 )
    {
      LOWORD(a1) = i[6];
      v17 = a1;
      LOWORD(a1) = i[7];
      v19 = a1;
      v17 = *(unsigned __int8 *)(dword_17DED4 + 226) / 2 + (signed __int16)v17;
      a1 = *(unsigned __int8 *)(dword_17DED4 + 227) / 2 + (signed __int16)a1;
      v24 = 1;
LABEL_19:
      v19 = a1;
      continue;
    }
    if ( (_WORD)v24 && *((_BYTE *)i + 18) == 1 )
    {
      LOWORD(a1) = i[7];
      v5 = *(unsigned __int8 *)(dword_17DED4 + 226);
      v21 = a1;
      v6 = v5 / 2 + (signed __int16)i[6];
      v21 = *(unsigned __int8 *)(dword_17DED4 + 227) / 2 + (signed __int16)a1;
      memset(&v14, 0, 24);
      sub_7E8D0(&v14, v6, v21, v17, v19, 2, 2);
      v25 = v17;
      v22 = v19;
      while ( !(_WORD)v1 )
      {
        for ( j = v1; ; j = v1 )
        {
          while ( (signed __int16)j < 3 )
          {
            v1 = sub_7E9D0(&v17, &v19, &v14);
            ++j;
          }
          if ( abs((signed __int16)v19 - (signed __int16)v22) <= 8
            && abs((signed __int16)v17 - (signed __int16)v25) <= 8 )
          {
            break;
          }
          sub_812D0(v17, v19);
          v25 = v17;
          v22 = v19;
          if ( (_WORD)v1 )
            goto LABEL_18;
        }
      }
LABEL_18:
      a1 = v21;
      v17 = v6;
      v1 = 0;
      goto LABEL_19;
    }
  }
  if ( word_17DB8A != -1 )
  {
    v7 = (char *)&unk_E1960;
    v8 = 0;
    v9 = 0;
    for ( k = 0; *((_WORD *)v7 + 2); ++k )
    {
      if ( v7[18] == 1 )
      {
        v8 = 1;
        v9 = v7;
      }
      if ( v7[18] == 2 )
        break;
      v7 += 22;
    }
    if ( (signed __int16)k < 24 && v8 )
    {
      LOWORD(k) = *((_WORD *)v9 + 6);
      v17 = k;
      LOWORD(k) = *((_WORD *)v9 + 7);
      v19 = k;
      v17 = *(unsigned __int8 *)(dword_17DED4 + 226) / 2 + (signed __int16)v17;
      v19 = *(unsigned __int8 *)(dword_17DED4 + 227) / 2 + (signed __int16)k;
      v11 = *(unsigned __int8 *)(dword_17DED4 + 226) / 2 + *((signed __int16 *)v7 + 6);
      v12 = *(unsigned __int8 *)(dword_17DED4 + 227) / 2 + *((signed __int16 *)v7 + 7);
      memset(&v14, 0, 24);
      sub_7E8D0(&v14, v11, v12, v17, v19, 2, 2);
      v1 = 0;
      v18 = v17;
      v23 = v19;
      while ( !(_WORD)v1 )
      {
        for ( l = v1; ; l = v1 )
        {
          while ( (signed __int16)l < 3 )
          {
            v1 = sub_7E9D0(&v17, &v19, &v14);
            ++l;
          }
          if ( abs((signed __int16)v19 - (signed __int16)v23) <= 8
            && abs((signed __int16)v17 - (signed __int16)v18) <= 8 )
          {
            break;
          }
          sub_812D0(v17, v19);
          v18 = v17;
          v23 = v19;
          if ( (_WORD)v1 )
            return v1;
        }
      }
    }
  }
  return v1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// E1B82: using guessed type char byte_E1B82;
// 17DB8A: using guessed type __int16 word_17DB8A;
// 17DE64: using guessed type int dword_17DE64;
// 17DED4: using guessed type int dword_17DED4;
// 180624: using guessed type int dword_180624;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180644: using guessed type int dword_180644;
// 180648: using guessed type int dword_180648;

//----- (00081CA0) --------------------------------------------------------
unsigned int __usercall sub_81CA0@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3, __int16 a4, int a5)
{
  unsigned int result; // eax
  unsigned __int8 v6; // dl
  unsigned int v7; // ecx
  int v8; // eax

  result = j___clock(a1, a2, a5);
  v6 = *(_BYTE *)(a5 + 20);
  v7 = result;
  if ( v6 < 1u )
  {
    if ( !v6 )
    {
      *(_BYTE *)(a5 + 20) = 2;
      *(_DWORD *)a5 = result;
      *(_DWORD *)(a5 + 4) = result;
    }
  }
  else if ( v6 <= 1u )
  {
    if ( (result - *(_DWORD *)(a5 + 4)) >> 3 >= 1 )
    {
      if ( *(signed __int16 *)(a5 + 16) <= *(signed __int16 *)(a5 + 14) - 2 )
      {
        ++*(_WORD *)(a5 + 16);
      }
      else
      {
        if ( *(_BYTE *)(a5 + 21) == 1 )
        {
          v8 = *(signed __int16 *)(a5 + 22);
          *(_BYTE *)(a5 + 20) = 0;
        }
        *(_WORD *)(a5 + 16) = *(_WORD *)(a5 + 12);
      }
      *(_DWORD *)(a5 + 4) = v7;
    }
    result = sub_7C120(
               *(_WORD *)(a5 + 8) - a3,
               *(_WORD *)(a5 + 10) - a4,
               dword_17DED4 + 6 * *(signed __int16 *)(a5 + 16));
    if ( word_17DEEE & 1 )
      ++*(_WORD *)(a5 + 16);
  }
  else if ( v6 == 2 )
  {
    result = (result - *(_DWORD *)a5) / 0x64;
    if ( result > *(signed __int16 *)(a5 + 18) )
    {
      result = *(signed __int16 *)(a5 + 22);
      *(_BYTE *)(a5 + 20) = 1;
      if ( result != -1 )
        result = (unsigned int)sub_8F100(
                                 0,
                                 *(_WORD *)(a5 + 24),
                                 (unsigned __int8)byte_E1324,
                                 64,
                                 0x64u,
                                 *(_BYTE *)(a5 + 28),
                                 *(_BYTE *)(a5 + 26));
    }
  }
  return result;
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// E1324: using guessed type char byte_E1324;
// 17DED4: using guessed type int dword_17DED4;
// 17DEEE: using guessed type __int16 word_17DEEE;

//----- (00081DB0) --------------------------------------------------------
signed int sub_81DB0()
{
  signed int result; // eax
  int v1; // ebx
  char v2; // [esp+0h] [ebp-70h]
  int v3; // [esp+50h] [ebp-20h]
  __int16 v4; // [esp+54h] [ebp-1Ch]
  int v5; // [esp+64h] [ebp-Ch]
  char v6; // [esp+6Eh] [ebp-2h]

  result = 0;
  if ( *(_BYTE *)(dword_D41A4 + 38402) == 1 )
  {
    memset(&v2, 0, 80);
    sprintf(&v2, aCS_0, *(unsigned __int8 *)(dword_D41A4 + 182), aNetherwConfigD);
    memset(&v3, 0, 32);
    v1 = sub_98817((int)&v2, 546);
    if ( v1 != -1 )
    {
      qmemcpy(&v3, (const void *)dword_D41A4, 0x14u);
      qmemcpy(&v5, (const void *)(dword_D41A4 + 20), 2u);
      qmemcpy((char *)&v5 + 2, &byte_EB39E, 8u);
      qmemcpy(&v6, &byte_EB39E + 8, 2u);
      v3 = -9;
      v4 = *(unsigned __int8 *)(dword_D41A4 + 179);
      sub_98CAA(v1, (int)&v3, 32);
      sub_98882(v1);
    }
    result = 1;
    *(_BYTE *)(dword_D41A4 + 38402) = 0;
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;
// EB39E: using guessed type char byte_EB39E;

//----- (00081EE0) --------------------------------------------------------
signed __int16 __usercall sub_81EE0@<ax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, signed __int16 a4@<di>, __int16 a5, __int16 a6)
{
  int v6; // eax
  signed __int16 *v7; // ebx
  int v8; // esi
  signed __int16 result; // ax
  unsigned __int8 v10; // al
  unsigned __int8 v11; // cl
  char v12; // ah
  __int16 v13; // ax
  unsigned __int8 v14; // ST18_1
  int v15; // ST08_4
  __int16 v16; // ST04_2
  int v17; // ST18_4
  int v18; // ST14_4
  unsigned __int8 v19; // ST18_1
  int v20; // ST08_4
  char v21; // dh
  __int16 v22; // ST04_2
  int v23; // edx
  int v24; // eax
  _WORD *v25; // edx
  signed __int16 v26; // ax
  char v27; // al
  __int16 v28; // ax
  int v29; // ST18_4
  int v30; // ST14_4
  unsigned __int8 v31; // ST18_1
  int v32; // ST08_4
  char v33; // dl
  __int16 v34; // ST04_2
  _WORD *v35; // edx
  __int16 v36; // ax
  unsigned __int8 v37; // al
  char v38; // ch
  int v39; // ST18_4
  int v40; // ST14_4
  __int16 v41; // ST2C_2
  __int16 v42; // ST30_2
  int v43; // ST1C_4
  int v44; // edx
  __int16 v45; // ST14_2
  __int16 v46; // ST10_2
  __int16 k; // [esp+8h] [ebp-14h]
  __int16 i; // [esp+Ch] [ebp-10h]
  __int16 j; // [esp+18h] [ebp-4h]

  v6 = j___clock(a1, a2, a3);
  v7 = word_E20A4;
  v8 = v6;
  for ( result = word_E20A4[11]; result; result = v7[11] )
  {
    v10 = *((_BYTE *)v7 + 42);
    if ( v10 < 2u )
    {
      if ( v10 == 1 )
      {
        v11 = *((_BYTE *)v7 + 43);
        if ( v11 <= 4u )
        {
          switch ( v11 )
          {
            case 0u:
              v12 = *((_BYTE *)v7 + 43);
              *(_DWORD *)v7 = v8;
              *((_BYTE *)v7 + 43) = v12 + 1;
              break;
            case 1u:
              if ( (v8 - *(_DWORD *)v7) / 0x64u > v7[20] )
                *((_BYTE *)v7 + 43) = v11 + 1;
              break;
            case 2u:
              v7[9] = v7[11];
              v13 = v7[12];
              v7[10] = v13;
              sub_7E8D0((signed __int16 *)((char *)v7 + 45), v7[13], v7[14], v7[11], v13, 2, 2);
              v7[17] = v7[15];
              v14 = *((_BYTE *)v7 + 12);
              v15 = (unsigned __int8)byte_E1324;
              v16 = v7[5];
              ++*((_BYTE *)v7 + 43);
              sub_8F100(0, v16, v15, 64, 0x64u, 0, v14);
              break;
            case 3u:
              for ( i = 0; i < 4; ++i )
              {
                v17 = v7[14];
                v18 = v7[13];
                a4 = sub_7E9D0(v7 + 9, v7 + 10, (signed __int16 *)((char *)v7 + 45));
              }
              if ( (unsigned int)(v8 - *(_DWORD *)v7) >> 3 >= 1 )
              {
                if ( v7[17] <= v7[16] - 1 )
                  ++v7[17];
                else
                  v7[17] = v7[15];
                *(_DWORD *)v7 = v8;
              }
              sub_7C120(v7[9] - a5, v7[10] - a6, dword_17DED4 + 6 * v7[17]);
              if ( a4 )
              {
                v7[17] = v7[18];
                v19 = *((_BYTE *)v7 + 16);
                v20 = (unsigned __int8)byte_E1324;
                v21 = *((_BYTE *)v7 + 43);
                v22 = v7[7];
                *(_DWORD *)v7 = v8;
                *((_BYTE *)v7 + 43) = v21 + 1;
                sub_8F100(0, v22, v20, 64, 0x64u, 0, v19);
              }
              break;
            case 4u:
              a4 = 0;
              if ( (unsigned int)(v8 - *(_DWORD *)v7) >> 3 >= 1 )
              {
                if ( v7[17] <= v7[19] - 1 )
                {
                  ++v7[17];
                }
                else
                {
                  a4 = 1;
                  v7[17] = v7[18];
                }
                *(_DWORD *)v7 = v8;
              }
              if ( !a4 )
              {
                v23 = dword_17DED4;
                v24 = 6 * v7[17];
                goto LABEL_85;
              }
              *((_BYTE *)v7 + 43) = 0;
              break;
          }
        }
      }
    }
    else if ( v10 <= 2u )
    {
      if ( byte_17DB8F != 4 )
      {
        v25 = &unk_E1960;
        v26 = 0;
        while ( v25[2] && *((_BYTE *)v25 + 18) != 2 )
        {
          v25 += 11;
          ++v26;
        }
        if ( v26 == 25 )
          v26 = 24;
        if ( v26 == *((unsigned __int8 *)v7 + 44) )
        {
          switch ( *((_BYTE *)v7 + 43) )
          {
            case 0:
              v27 = *((_BYTE *)v7 + 43);
              *(_DWORD *)v7 = v8;
              *((_BYTE *)v7 + 43) = v27 + 1;
              break;
            case 1:
              goto LABEL_42;
            case 2:
              for ( j = 0; j < 4; ++j )
              {
                v29 = v7[14];
                v30 = v7[13];
                a4 = sub_7E9D0(v7 + 9, v7 + 10, (signed __int16 *)((char *)v7 + 45));
              }
              if ( (unsigned int)(v8 - *(_DWORD *)v7) >> 3 >= 1 )
              {
                if ( v7[17] <= v7[16] - 1 )
                  ++v7[17];
                else
                  v7[17] = v7[15];
                *(_DWORD *)v7 = v8;
              }
              sub_7C120(v7[9] - a5, v7[10] - a6, dword_17DED4 + 6 * v7[17]);
              if ( a4 )
              {
                v7[17] = v7[18];
                v31 = *((_BYTE *)v7 + 16);
                v32 = (unsigned __int8)byte_E1324;
                v33 = *((_BYTE *)v7 + 43);
                v34 = v7[7];
                *(_DWORD *)v7 = v8;
                *((_BYTE *)v7 + 43) = v33 + 1;
                sub_8F100(0, v34, v32, 64, 0x64u, 0, v31);
              }
              break;
            case 3:
              a4 = 0;
              if ( (unsigned int)(v8 - *(_DWORD *)v7) >> 3 >= 1 )
              {
                if ( v7[17] <= v7[19] - 1 )
                {
                  ++v7[17];
                }
                else
                {
                  a4 = 1;
                  v7[17] = v7[18];
                }
                *(_DWORD *)v7 = v8;
              }
              if ( !a4 )
                goto LABEL_84;
              ++*((_BYTE *)v7 + 43);
              break;
            default:
              break;
          }
        }
        else
        {
          *((_BYTE *)v7 + 43) = 0;
        }
      }
    }
    else if ( v10 == 3 )
    {
      v35 = &unk_E1960;
      v36 = 0;
      while ( v35[2] && *((_BYTE *)v35 + 18) != 2 )
      {
        v35 += 11;
        ++v36;
      }
      if ( v36 )
        --v36;
      if ( v36 == *((unsigned __int8 *)v7 + 44) )
      {
        v37 = *((_BYTE *)v7 + 43);
        if ( v37 < 1u )
        {
          if ( !v37 )
          {
            v38 = *((_BYTE *)v7 + 43);
            *(_DWORD *)v7 = v8;
            *((_BYTE *)v7 + 43) = v38 + 1;
          }
        }
        else if ( v37 <= 1u )
        {
LABEL_42:
          v7[9] = v7[11];
          v28 = v7[12];
          v7[10] = v28;
          sub_7E8D0((signed __int16 *)((char *)v7 + 45), v7[13], v7[14], v7[11], v28, 2, 2);
          v7[17] = v7[15];
          ++*((_BYTE *)v7 + 43);
          sub_8F100(0, v7[5], (unsigned __int8)byte_E1324, 64, 0x64u, 0, *((_BYTE *)v7 + 12));
        }
        else if ( v37 == 2 )
        {
          for ( k = 0; k < 4; ++k )
          {
            v39 = v7[14];
            v40 = v7[13];
            a4 = sub_7E9D0(v7 + 9, v7 + 10, (signed __int16 *)((char *)v7 + 45));
          }
          if ( (unsigned int)(v8 - *(_DWORD *)v7) >> 3 >= 1 )
          {
            if ( v7[17] <= v7[16] - 1 )
              ++v7[17];
            else
              v7[17] = v7[15];
            *(_DWORD *)v7 = v8;
          }
          if ( byte_E1B82 == 1 )
          {
            _disable();
            v41 = dword_18062C;
            v42 = dword_180624;
            v43 = dword_180628;
            dword_180628 = dword_17DE64;
            v44 = v7[17];
            dword_180648 = 1280;
            dword_18062C = 1280;
            v45 = v7[10];
            v46 = v7[9];
            dword_180644 = 960;
            dword_180624 = 960;
            sub_7C120(v46, v45, 6 * v44 + dword_17DED4);
            dword_18062C = v41;
            dword_180624 = v42;
            dword_180648 = v41;
            dword_180644 = v42;
            dword_180628 = v43;
            _enable();
          }
          else
          {
LABEL_84:
            v23 = 6 * v7[17];
            v24 = dword_17DED4;
LABEL_85:
            sub_7C120(v7[9] - a5, v7[10] - a6, v23 + v24);
          }
        }
      }
      else
      {
        *((_BYTE *)v7 + 43) = 0;
      }
    }
    v7 = (signed __int16 *)((char *)v7 + 69);
  }
  return result;
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// E1324: using guessed type char byte_E1324;
// E1B82: using guessed type char byte_E1B82;
// 17DB8F: using guessed type char byte_17DB8F;
// 17DE64: using guessed type int dword_17DE64;
// 17DED4: using guessed type int dword_17DED4;
// 180624: using guessed type int dword_180624;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180644: using guessed type int dword_180644;
// 180648: using guessed type int dword_180648;

//----- (000824B0) --------------------------------------------------------
_WORD *__cdecl sub_824B0(__int16 a1)
{
  _WORD *result; // eax

  result = word_E2970;
  if ( !word_E2970[6] )
    return 0;
  while ( a1 != result[2] )
  {
    result = (_WORD *)((char *)result + 17);
    if ( !result[6] )
      return 0;
  }
  return result;
}

//----- (000824E0) --------------------------------------------------------
_WORD *__cdecl sub_824E0(__int16 a1)
{
  _WORD *result; // eax

  result = word_E2970;
  if ( !word_E2970[6] )
    return 0;
  while ( a1 != result[3] )
  {
    result = (_WORD *)((char *)result + 17);
    if ( !result[6] )
      return 0;
  }
  return result;
}

//----- (00082510) --------------------------------------------------------
int __usercall sub_82510@<eax>(__int16 a1@<dx>, int *a2)
{
  int v2; // eax
  int v3; // edx
  __int16 v4; // dx
  char *v5; // esi
  _BYTE *v6; // edx
  int v7; // eax
  int v8; // ecx
  int result; // eax
  char v10; // [esp+0h] [ebp-2Ch]
  char v11; // [esp+10h] [ebp-1Ch]
  int v12; // [esp+24h] [ebp-8h]
  int v13; // [esp+28h] [ebp-4h]

  v13 = dword_17DEC0;
  v12 = dword_17DEC4;
  dword_17DEC0 = dword_17DEC8;
  dword_17DEC4 = dword_17DECC;
  if ( *(_BYTE *)(dword_D41A4 + 10) == 1 )
  {
    HIBYTE(a1) = *((_BYTE *)a2 + 14);
    if ( HIBYTE(a1) == 2 )
    {
      v2 = j___clock(dword_D41A4, a1, a2);
      v3 = *a2;
      a2[1] = v2;
      if ( (v2 - v3) / 0x64u > 1 )
      {
        v4 = *((_WORD *)a2 + 6) + 1;
        *((_WORD *)a2 + 6) = v4;
        if ( !word_E2518[9 * v4] )
          *((_WORD *)a2 + 6) = 0;
        *a2 = a2[1];
      }
      memset(&v10, 0, 36);
      v5 = (char *)&unk_E2516 + 18 * *((signed __int16 *)a2 + 6);
      v6 = off_E23E0;
      qmemcpy(&v10, v5, 0x10u);
      qmemcpy(&v11, v5 + 16, 2u);
      while ( v6[25] )
      {
        if ( v6[23] && v6[22] == byte_E2527[18 * *((signed __int16 *)a2 + 6)] )
        {
          v6[24] = 1;
          break;
        }
        v6 += 44;
      }
      sub_7E840((signed __int16 *)&v10, 238, 264);
    }
    else if ( HIBYTE(a1) == 3 )
    {
      v7 = j___clock(dword_D41A4, a1, a2);
      v8 = *a2;
      a2[1] = v7;
      if ( (v7 - v8) / 0x64u > 1 )
        *((_BYTE *)a2 + 14) = 2;
    }
  }
  dword_17DEC0 = v13;
  result = v12;
  dword_17DEC4 = v12;
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E2518: using guessed type __int16 word_E2518[];
// 17DEC0: using guessed type int dword_17DEC0;
// 17DEC4: using guessed type int dword_17DEC4;
// 17DEC8: using guessed type int dword_17DEC8;
// 17DECC: using guessed type int dword_17DECC;

//----- (00082670) --------------------------------------------------------
__int16 sub_82670()
{
  __int16 v0; // si
  _WORD *v1; // eax
  int v2; // eax
  void **v3; // ebx
  __int16 v4; // cx
  _WORD *v5; // edi
  int v6; // eax
  int v7; // eax
  int v8; // eax
  char v10; // [esp+0h] [ebp-54h]
  unsigned __int8 v11; // [esp+50h] [ebp-4h]

  v0 = 0;
  v11 = word_180660;
  LOWORD(v1) = (unsigned __int8)word_180660;
  byte_1806E4 = 0;
  if ( !byte_E29E1 )
  {
    LOWORD(v1) = dword_D41A4;
    if ( !(*(_BYTE *)(dword_D41A4 + 22) & 0x10) )
    {
      v2 = *(_DWORD *)(dword_D41A4 + 226);
      byte_D41C1 = 0;
      dword_17DE48 = v2;
      dword_17DE54 = v2 + 301787;
      dword_17DEC0 = v2 + 308527;
      dword_17DEC4 = (int)&algn_4BB85[v2 + 10];
      sub_7AA70((int)aDataScreensHsc, (char *)(v2 + 301787), (int)&unk_164FCD, 860);
      sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC0, (int)&unk_165329, 548);
      sub_7AA70(0, 0, 0, 0);
      if ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) & 2
        || (LOWORD(v1) = dword_D41A4, *(_WORD *)(dword_D41A4 + 43) > 0x18u) )
      {
        v3 = &off_E16E0;
        LOWORD(v1) = 1;
        while ( *((_BYTE *)v3 + 4) )
        {
          if ( *(unsigned __int16 *)(dword_D41A4 + 43) + 1 == *((unsigned __int8 *)v3 + 4) )
          {
            if ( !*((_BYTE *)v3 + 5) )
            {
              v0 = (signed __int16)v1;
              *((_BYTE *)v3 + 5) = 1;
            }
            break;
          }
          v3 = (void **)((char *)v3 + 7);
          LOWORD(v1) = (_WORD)v1 + 1;
        }
        if ( !v0 )
        {
          LOWORD(v1) = dword_D41A4;
          v4 = *(_WORD *)(dword_D41A4 + 43);
          if ( (unsigned __int16)v4 > 0x18u )
          {
            v1 = sub_824E0(v4);
            v5 = v1;
            if ( v1 )
            {
              v3 = &off_E16E0;
              LOWORD(v1) = 1;
              while ( *((_BYTE *)v3 + 4) )
              {
                if ( (signed __int16)v5[2] + 1 == *((unsigned __int8 *)v3 + 4) )
                {
                  if ( !*((_BYTE *)v3 + 5) )
                  {
                    v0 = (signed __int16)v1;
                    *((_BYTE *)v3 + 5) = 1;
                  }
                  break;
                }
                v3 = (void **)((char *)v3 + 7);
                LOWORD(v1) = (_WORD)v1 + 1;
              }
            }
          }
        }
        if ( v0 )
        {
          if ( *(_BYTE *)(dword_D41A4 + 179) == 2 && byte_E3798 || v0 >= 6 )
          {
            byte_D41C1 = 0;
            byte_D41C0 = 0;
          }
          else
          {
            sub_2EB40();
            byte_D41C1 = 1;
            byte_D41C0 = 1;
          }
          sub_8CD27(dword_EB394);
          memset(dword_180628, 0, 307200);
          if ( word_180660 != 1 )
          {
            sub_54600();
            v6 = memset(dword_EA3D8, 0, 768);
            if ( word_180660 & 1 )
              sub_72883(dword_180628, (void *)dword_180628, 0xC8u, 0);
            else
              sub_728A9(v6, (void *)dword_180628, 0x1E0u, 0);
            sub_41A90((unsigned __int8 *)dword_EA3D8);
            word_180660 = 1;
            sub_90D6E((unsigned __int8 *)dword_EA3D8);
            sub_8CEDF();
            sub_8CD27(dword_EB394);
          }
          if ( word_180660 & 1 )
            sub_98709(dword_17DEC0, dword_17DEC4, dword_17DE54);
          else
            sub_9874D((unsigned int *)dword_17DEC0, dword_17DEC4, dword_17DE54);
          sprintf(&v10, aIntroCutDDat, *((unsigned __int8 *)v3 + 6));
          sprintf(&unk_E3848, &v10);
          sub_76160(0, 1, (int)*v3);
          sub_90B27(0, 0x10u, 0);
          sub_8D8F0();
          sub_8E020();
          sub_7B5D0();
          if ( word_180660 & 1 )
            sub_72883(v7, (void *)dword_180628, 0xC8u, 0);
          else
            sub_728A9(v7, (void *)dword_180628, 0x1E0u, 0);
          if ( word_180660 & 1 )
            sub_90478();
          else
            sub_75200(480);
          LOWORD(v1) = v11;
          if ( v11 != word_180660 )
          {
            sub_54600();
            v8 = memset(dword_EA3D8, 0, 768);
            if ( word_180660 & 1 )
              sub_72883(v8, (void *)dword_180628, 0xC8u, 0);
            else
              sub_728A9(v8, (void *)dword_180628, 0x1E0u, 0);
            sub_41A90((unsigned __int8 *)dword_EA3D8);
            word_180660 = v11;
            if ( v11 & 1 )
              sub_90D6E((unsigned __int8 *)dword_EA3D8);
            else
              sub_90E07((unsigned __int8 *)dword_EA3D8);
            sub_8CEDF();
            LOWORD(v1) = sub_8CD27(dword_EB394);
          }
        }
      }
    }
  }
  byte_D41C1 = 0;
  return (signed __int16)v1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41C0: using guessed type char byte_D41C0;
// D41C1: using guessed type char byte_D41C1;
// E16E0: using guessed type void *off_E16E0;
// E29E1: using guessed type char byte_E29E1;
// E3798: using guessed type char byte_E3798;
// EA3D8: using guessed type int dword_EA3D8;
// EB394: using guessed type int dword_EB394;
// 17DE48: using guessed type int dword_17DE48;
// 17DE54: using guessed type int dword_17DE54;
// 17DEC0: using guessed type int dword_17DEC0;
// 17DEC4: using guessed type int dword_17DEC4;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;
// 1806E4: using guessed type char byte_1806E4;

//----- (00082AB0) --------------------------------------------------------
int __cdecl sub_82AB0(unsigned __int8 a1)
{
  int v1; // eax
  int v2; // edx
  int result; // eax
  _WORD *v4; // ebx
  __int16 i; // cx
  int v6; // eax
  int v7; // edx

  if ( a1 > 0x18u )
  {
    v4 = word_E2970;
    for ( i = 0; v4[6]; ++i )
    {
      result = a1;
      if ( a1 == v4[3] )
      {
        v6 = dword_D41A0;
        v7 = 5 * i;
        dword_17DDBC[v7] = *(_DWORD *)(dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12) + 12605);
        dword_17DDC0[v7] = *(_DWORD *)(2124 * *(signed __int16 *)(v6 + 12) + v6 + 12609);
        dword_17DDC4[v7] = *(_DWORD *)(2124 * *(signed __int16 *)(v6 + 12) + v6 + 12601);
        dword_17DDC8[v7] = *(_DWORD *)(2124 * *(signed __int16 *)(v6 + 12) + v6 + 12613);
        result = *(_DWORD *)(2124 * *(signed __int16 *)(v6 + 12) + v6 + 12621);
        dword_17DDCC[v7] = result;
      }
      v4 = (_WORD *)((char *)v4 + 17);
    }
  }
  else
  {
    v1 = dword_D41A0;
    v2 = 5 * a1;
    dword_17DBC8[v2] = *(_DWORD *)(dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12) + 12605);
    dword_17DBCC[v2] = *(_DWORD *)(2124 * *(signed __int16 *)(v1 + 12) + v1 + 12609);
    dword_17DBD0[v2] = *(_DWORD *)(2124 * *(signed __int16 *)(v1 + 12) + v1 + 12601);
    dword_17DBD4[v2] = *(_DWORD *)(2124 * *(signed __int16 *)(v1 + 12) + v1 + 12613);
    result = *(_DWORD *)(2124 * *(signed __int16 *)(v1 + 12) + v1 + 12621);
    dword_17DBD8[v2] = result;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// 17DBC8: using guessed type int dword_17DBC8[];
// 17DBCC: using guessed type int dword_17DBCC[];
// 17DBD0: using guessed type int dword_17DBD0[];
// 17DBD4: using guessed type int dword_17DBD4[];
// 17DDBC: using guessed type int dword_17DDBC[];
// 17DDC0: using guessed type int dword_17DDC0[];
// 17DDC4: using guessed type int dword_17DDC4[];
// 17DDC8: using guessed type int dword_17DDC8[];

//----- (00082C20) --------------------------------------------------------
void __cdecl sub_82C20(__int16 a1)
{
  _WORD *v1; // edx
  __int16 v2; // si
  int v3; // ebx
  signed __int16 v4; // bx
  __int16 v5; // si
  int v6; // edx
  signed __int16 v7; // bx
  unsigned int v8; // esi
  int v9; // edx
  int v10; // eax
  int v11; // esi
  int v12; // edi
  signed __int16 i; // bx
  int v14; // eax
  _BYTE *v15; // ebx
  __int16 v16; // ax
  unsigned __int16 v17; // dx
  signed __int16 j; // bx
  int v19; // eax
  __int16 v20; // di
  signed int v21; // ebx
  int v22; // edx
  char v23; // [esp+0h] [ebp-12h]
  char *v24; // [esp+28h] [ebp+16h]
  int v25; // [esp+2Ch] [ebp+1Ah]
  int v26; // [esp+30h] [ebp+1Eh]
  int v27; // [esp+34h] [ebp+22h]
  int v28; // [esp+38h] [ebp+26h]
  _BYTE *v29; // [esp+3Ch] [ebp+2Ah]
  int v30; // [esp+40h] [ebp+2Eh]
  int v31; // [esp+44h] [ebp+32h]
  int v32; // [esp+48h] [ebp+36h]
  int v33; // [esp+4Ch] [ebp+3Ah]
  int v34; // [esp+50h] [ebp+3Eh]
  int v35; // [esp+54h] [ebp+42h]
  int v36; // [esp+58h] [ebp+46h]
  int v37; // [esp+5Ch] [ebp+4Ah]
  int v38; // [esp+60h] [ebp+4Eh]
  int v39; // [esp+64h] [ebp+52h]
  int v40; // [esp+68h] [ebp+56h]
  int v41; // [esp+6Ch] [ebp+5Ah]
  int v42; // [esp+70h] [ebp+5Eh]
  int v43; // [esp+74h] [ebp+62h]
  int v44; // [esp+78h] [ebp+66h]
  int v45; // [esp+7Ch] [ebp+6Ah]
  int v46; // [esp+80h] [ebp+6Eh]
  int v47; // [esp+84h] [ebp+72h]
  int v48; // [esp+88h] [ebp+76h]
  int v49; // [esp+8Ch] [ebp+7Ah]

  v42 = 50;
  v48 = 50;
  if ( a1 > -1 )
  {
    v24 = off_D9204[a1];
    v25 = dword_EA254;
    v26 = dword_EA250;
    v30 = 0;
    v27 = dword_EA24C;
    v31 = 0;
    v28 = dword_EA230;
    v37 = 0;
    v29 = (_BYTE *)dword_EA274;
    if ( a1 > 24 )
    {
      v1 = word_E2970;
      v2 = 0;
      while ( v1[6] )
      {
        if ( a1 == v1[3] )
        {
          v3 = 5 * v2;
          v32 = dword_17DDBC[v3];
          v33 = dword_17DDC0[v3];
          v34 = dword_17DDC4[v3];
          v35 = dword_17DDC8[v3];
          v36 = dword_17DDCC[v3];
        }
        v1 = (_WORD *)((char *)v1 + 17);
        ++v2;
      }
    }
    else
    {
      v32 = dword_17DBC8[5 * a1];
      v33 = dword_17DBCC[5 * a1];
      v34 = dword_17DBD0[5 * a1];
      v35 = dword_17DBD4[5 * a1];
      v36 = dword_17DBD8[5 * a1];
    }
    v4 = 1;
    v5 = strlen(v24);
    while ( v4 < 6 )
    {
      v6 = v4;
      if ( strlen((&v24)[v6]) > v5 )
        v5 = strlen((&v24)[v6]);
      ++v4;
    }
    v7 = 1;
    v8 = strlen(v24);
    while ( v7 < 6 )
    {
      v9 = v7;
      if ( strlen((&v24)[v9]) > (signed __int16)v8 )
        v8 = strlen((&v24)[v9]);
      ++v7;
    }
    HIWORD(v10) = HIWORD(dword_17DEC0);
    LOWORD(v10) = *(unsigned __int8 *)(dword_17DEC0 + 394);
    v11 = 2 * v10 * v8;
    v12 = 320 - (signed __int16)v11 / 2;
    v44 = *(unsigned __int8 *)(dword_17DED4 + 1654);
    v40 = (unsigned __int8)v44;
    if ( (signed __int16)v11 % (signed int)(unsigned __int8)v44 )
      v11 = ((signed __int16)v11 / (signed int)(unsigned __int8)v44 + 1) * v44;
    for ( i = 0; i < (signed __int16)v11; i += v44 )
      sub_7C120(i + v12, v48, dword_17DED4 + 1650);
    HIWORD(v14) = HIWORD(dword_17DED4);
    LOWORD(v14) = *(unsigned __int8 *)(dword_17DED4 + 1655);
    v49 = 0;
    v48 += v14;
    do
    {
      v41 = (signed __int16)v12 + *(unsigned __int8 *)(dword_17DED4 + 1648);
      v39 = (signed __int16)v48;
      v40 = (signed __int16)v48;
      v15 = (_BYTE *)(v41 + 640 * (signed __int16)v48 + dword_180628);
      sub_7C120(v12, v48, dword_17DED4 + 1644);
      sub_7C120(v11 + v12 - *(unsigned __int8 *)(dword_17DED4 + 1648), v40, dword_17DED4 + 1644);
      v45 = 0;
      while ( *(unsigned __int8 *)(dword_17DED4 + 1649) > (signed __int16)v45 )
      {
        v16 = 0;
        while ( v16 < (signed __int16)v11 - 2 * *(unsigned __int8 *)(dword_17DED4 + 1648) )
        {
          HIBYTE(v17) = 15;
          LOBYTE(v17) = *v15;
          v41 = v17;
          ++v15;
          ++v16;
          *(v15 - 1) = *(_BYTE *)(v17 + dword_17DE3C);
        }
        ++v45;
        v15 += 640 - v16;
        ++v48;
      }
      ++v49;
    }
    while ( (signed __int16)v49 < 12 );
    for ( j = 0; j < (signed __int16)v11; j += v44 )
      sub_7C120(j + v12, v48, dword_17DED4 + 1650);
    HIWORD(v19) = HIWORD(dword_17DED4);
    LOWORD(v19) = *(unsigned __int8 *)(dword_17DED4 + 1648);
    v47 = 2 * v19 + v42;
    LOWORD(v19) = *(unsigned __int8 *)(dword_17DEC0 + 394);
    v20 = v19 + v12;
    sub_7FAE0(v24, v20, v11 - (unsigned __int8)v19 + v20, v47, 0);
    v21 = 1;
    v47 += 5;
    while ( 1 )
    {
      v46 = v47 + 2;
      if ( (signed __int16)v21 >= 5 )
      {
        sub_7FB90(
          v29,
          (signed __int16)(v20 + 2 * *(unsigned __int8 *)(dword_17DEC0 + 394)),
          v46 + 5 * *(unsigned __int8 *)(dword_17DEC0 + 395) + *(unsigned __int8 *)(dword_17DEC0 + 395),
          0);
        v39 = 60;
        v41 = v36 % 3600 / 60;
        v38 = v36 % 3600 / 60;
        sprintf(&v23, a02d02d02d, v36 / 3600, v41, v36 % 3600 % 60);
        sub_7FB90(
          &v23,
          (signed __int16)(v20 + v11 - 14 * *(unsigned __int8 *)(dword_17DEC0 + 394)),
          v46 + 5 * *(unsigned __int8 *)(dword_17DEC0 + 395) + *(unsigned __int8 *)(dword_17DEC0 + 395),
          0);
        return;
      }
      v22 = (signed __int16)v21;
      if ( (&v24)[v22] )
        break;
LABEL_47:
      ++v21;
    }
    if ( *(_BYTE *)(dword_D41A4 + 179) != 2 )
    {
      v43 = v21 * *(unsigned __int8 *)(dword_17DEC0 + 395);
      sub_7FB90((&v24)[v22], (signed __int16)(v20 + 2 * *(unsigned __int8 *)(dword_17DEC0 + 394)), v43 + v46, 0);
      goto LABEL_46;
    }
    if ( (unsigned __int16)v21 < 2u )
      goto LABEL_44;
    if ( (unsigned __int16)v21 <= 2u )
    {
      sub_7FB90(
        aHitAccuracy,
        (signed __int16)(v20 + 2 * *(unsigned __int8 *)(dword_17DEC0 + 394)),
        v46 + v21 * *(unsigned __int8 *)(dword_17DEC0 + 395),
        0);
    }
    else
    {
      if ( (_WORD)v21 != 4 )
      {
LABEL_44:
        sub_7FB90(
          (&v24)[(signed __int16)v21],
          (signed __int16)(v20 + 2 * *(unsigned __int8 *)(dword_17DEC0 + 394)),
          *(unsigned __int8 *)(dword_17DEC0 + 395) * (_WORD)v21 + v47 + 2,
          0);
        goto LABEL_46;
      }
      sub_7FB90(
        aManaCollected,
        (signed __int16)(v20 + 2 * *(unsigned __int8 *)(dword_17DEC0 + 394)),
        v46 + 4 * *(unsigned __int8 *)(dword_17DEC0 + 395),
        0);
    }
LABEL_46:
    sprintf(&v23, a3d, *(&v31 + (signed __int16)v21));
    sub_7FB90(
      &v23,
      (signed __int16)(v20 + v11 - 8 * *(unsigned __int8 *)(dword_17DEC0 + 394)),
      v47 + 2 + v21 * *(unsigned __int8 *)(dword_17DEC0 + 395),
      0);
    goto LABEL_47;
  }
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;
// D9204: using guessed type char *off_D9204[2];
// EA230: using guessed type int dword_EA230;
// EA24C: using guessed type int dword_EA24C;
// EA250: using guessed type int dword_EA250;
// EA254: using guessed type int dword_EA254;
// EA274: using guessed type int dword_EA274;
// 17DBC8: using guessed type int dword_17DBC8[];
// 17DBCC: using guessed type int dword_17DBCC[];
// 17DBD0: using guessed type int dword_17DBD0[];
// 17DBD4: using guessed type int dword_17DBD4[];
// 17DDBC: using guessed type int dword_17DDBC[];
// 17DDC0: using guessed type int dword_17DDC0[];
// 17DDC4: using guessed type int dword_17DDC4[];
// 17DDC8: using guessed type int dword_17DDC8[];
// 17DE3C: using guessed type int dword_17DE3C;
// 17DEC0: using guessed type int dword_17DEC0;
// 17DED4: using guessed type int dword_17DED4;
// 180628: using guessed type int dword_180628;

//----- (00083250) --------------------------------------------------------
signed int __cdecl sub_83250(char a1)
{
  int v1; // eax

  sub_8CD27(dword_EB394);
  memset(dword_180628, 0, 307200);
  if ( word_180660 != 1 )
  {
    sub_54600();
    memset(dword_EA3D8, 0, 768);
    word_180660 = 1;
    sub_90D6E((unsigned __int8 *)dword_EA3D8);
    sub_8CEDF();
    sub_8CD27(dword_EB394);
  }
  sub_76D10(a1);
  sub_54600();
  v1 = memset(dword_EA3D8, 0, 768);
  BYTE1(v1) = word_180660;
  if ( word_180660 & 1 )
    sub_72883(v1, (void *)dword_180628, 0xC8u, 0);
  else
    sub_728A9(v1, (void *)dword_180628, 0x1E0u, 0);
  sub_41A90((unsigned __int8 *)dword_EA3D8);
  word_180660 = 8;
  sub_90E07((unsigned __int8 *)dword_EA3D8);
  sub_8CEDF();
  sub_8CD27(dword_EB394);
  sub_6EDB0();
  sub_7A110(word_180660, 4);
  sub_7B5A0();
  sub_8CD27(dword_17DED4 + 234);
  word_17DEEE = 0;
  byte_17DF10 = 0;
  return sub_84300(0);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// EA3D8: using guessed type int dword_EA3D8;
// EB394: using guessed type int dword_EB394;
// 17DED4: using guessed type int dword_17DED4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (000833C0) --------------------------------------------------------
void sub_833C0()
{
  int v0; // eax
  char *v1; // eax
  int v2; // edx
  signed int v3; // eax
  signed int v4; // esi
  int v5; // ebx
  int v6; // eax
  int v7; // edx
  int v8; // eax
  unsigned int v9; // eax
  int v10; // edi
  char *v11; // ecx
  int v12; // eax
  int v13; // edx
  int v14; // eax
  unsigned __int8 v15; // al
  int v16; // eax
  int v17; // eax
  int v18; // [esp+0h] [ebp-14h]
  int v19; // [esp+8h] [ebp-Ch]
  signed __int16 v20; // [esp+Ch] [ebp-8h]
  int i; // [esp+10h] [ebp-4h]

  v19 = 0;
  v20 = 0;
  dword_17DE38 = dword_EA3D8;
  word_17DEEC = 0;
  dword_17DE40 = dword_180628;
  dword_17DEE0 = -1;
  v0 = *(_DWORD *)(dword_D41A4 + 226);
  dword_17DEDC = 0;
  dword_17DE48 = v0;
  sub_7B5D0();
  dword_17DE54 = dword_17DE48 + 301787;
  dword_17DEC4 = dword_17DE48 + 316179;
  dword_17DE58 = dword_17DE48 + 316179;
  dword_17DEC8 = dword_17DE48 + 322754;
  dword_17DECC = dword_17DE48 + 324380;
  dword_17DED4 = dword_17DE48 + 324380;
  dword_17DED8 = dword_17DE48 + 326258;
  dword_17DE60 = dword_17DE44;
  dword_17DE64 = dword_17DE48 + 326258;
  v1 = (char *)&unk_12C000 + dword_17DE48 + 326258;
  dword_17DE3C = (int)v1;
  dword_17DEC0 = dword_17DE48 + 314541;
  dword_17DE5C = (int)(v1 + 0x4000);
  v3 = j___clock(v1 + 0x4000, v2, -1);
  v4 = v3;
  while ( sub_9A10A(v3) )
  {
    byte_1806E4 = 0;
    LOBYTE(v3) = sub_7A060();
  }
  sub_8CD27(dword_EB394);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE54, (int)&unk_1641FC, 1214);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC0, (int)&unk_1646BA, 589);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE58, (int)&unk_164907, 1191);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC8, (int)&unk_164DAE, 543);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, (int)&unk_178B5F, 768);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE64, (int)&unk_16554D, 79378);
  sub_7AA70(0, 0, 0, 0);
  if ( word_180660 & 1 )
    sub_98709(dword_17DEC0, dword_17DEC4, dword_17DE54);
  else
    sub_9874D((unsigned int *)dword_17DEC0, dword_17DEC4, dword_17DE54);
  if ( word_180660 & 1 )
    sub_98709(dword_17DEC8, dword_17DECC, dword_17DE58);
  else
    sub_9874D((unsigned int *)dword_17DEC8, dword_17DECC, dword_17DE58);
  byte_17DF10 = 0;
  v5 = dword_17DEC0 + 6;
  word_17DEEE = 0;
  dword_17DEC0 += 6;
  while ( !byte_17DF10 && !word_17DEEE )
  {
    if ( word_180660 & 1 )
      sub_9A128((const void *)dword_17DE64, (void *)dword_180628, 0xC8u);
    else
      sub_9A144((const void *)dword_17DE64, (void *)dword_180628, 0x1E0u);
    v8 = j___clock(v6, v7, v5);
    v5 = v19;
    v18 = v8;
    for ( i = 0; ; i += v16 + 2 )
    {
      v9 = (v18 - v4) / 0x64u;
      v10 = (signed __int16)v5;
      v11 = off_DB558[v10];
      if ( !v11 )
      {
        if ( v9 > 5 )
        {
          v12 = j___clock(v9, (v18 - v4) % 0x64u, v5);
          v5 = 0;
          v4 = v12;
          v19 = 0;
        }
        goto LABEL_24;
      }
      if ( !stricmp(v11, &aE[1]) )
        break;
      v15 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x3Fu, 0x3Fu, 0x3Fu);
      sub_7FCB0(v5, off_DB558[v10], 10, 620, (signed __int16)(i + 200), 5, v15, 0);
      HIWORD(v16) = HIWORD(dword_17DEC0);
      LOWORD(v16) = *(unsigned __int8 *)(dword_17DEC0 + 395);
      ++v5;
    }
    if ( (v18 - v4) / 0x64u > 2 )
    {
      v14 = j___clock(0, v13, v5++);
      v4 = v14;
      v19 = v5;
    }
LABEL_24:
    sub_7A060();
    if ( v20 )
    {
      if ( word_180660 & 1 )
        sub_90478();
      else
        sub_75200(480);
    }
    else
    {
      sub_90B27((char *)dword_17DE38, 0x20u, 0);
      v20 = 1;
    }
  }
  sub_90B27(0, 0x10u, 0);
  v17 = memset(dword_EA3D8, 0, 768);
  LOBYTE(v17) = word_180660;
  if ( word_180660 & 1 )
    sub_72883(v17, (void *)dword_180628, 0xC8u, 0);
  else
    sub_728A9(v17, (void *)dword_180628, 0x1E0u, 0);
  if ( word_180660 & 1 )
    sub_90478();
  else
    sub_75200(480);
  while ( byte_17DF10 || word_17DEEE )
    sub_7A060();
  byte_17DF10 = 0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// DB558: using guessed type char *off_DB558[3];
// EA3D8: using guessed type int dword_EA3D8;
// EB394: using guessed type int dword_EB394;
// 17DE38: using guessed type int dword_17DE38;
// 17DE3C: using guessed type int dword_17DE3C;
// 17DE40: using guessed type int dword_17DE40;
// 17DE44: using guessed type int dword_17DE44;
// 17DE48: using guessed type int dword_17DE48;
// 17DE54: using guessed type int dword_17DE54;
// 17DE58: using guessed type int dword_17DE58;
// 17DE5C: using guessed type int dword_17DE5C;
// 17DE60: using guessed type int dword_17DE60;
// 17DE64: using guessed type int dword_17DE64;
// 17DEC0: using guessed type int dword_17DEC0;
// 17DEC4: using guessed type int dword_17DEC4;
// 17DEC8: using guessed type int dword_17DEC8;
// 17DECC: using guessed type int dword_17DECC;
// 17DED4: using guessed type int dword_17DED4;
// 17DED8: using guessed type int dword_17DED8;
// 17DEDC: using guessed type int dword_17DEDC;
// 17DEE0: using guessed type int dword_17DEE0;
// 17DEEC: using guessed type __int16 word_17DEEC;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;
// 1806E4: using guessed type char byte_1806E4;

//----- (00083850) --------------------------------------------------------
int sub_83850()
{
  signed int v0; // eax
  signed int v1; // ebx
  int v2; // edx
  int v3; // edx
  int v4; // esi
  int v5; // eax
  int v6; // eax
  signed int v7; // eax

  sub_7AA70((int)aDataScreensHsc, (char *)dword_E9C38, (int)&unk_178E5F, 12985);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_EA3D8, (int)&unk_17C118, 768);
  v0 = sub_7AA70(0, 0, 0, 0);
  v1 = 0;
  v5 = j___clock(v0, v2, 0);
  v4 = v5;
  BYTE1(v5) = 0;
  byte_1806E4 = 0;
  while ( !byte_1806E4 && !word_180746 && !word_180744 && (j___clock(v5, v3, v1) - v4) / 0x64u <= 0x14 )
  {
    if ( word_180660 & 1 )
      sub_9A128((const void *)dword_E9C38, (void *)dword_180628, 0xC8u);
    else
      sub_9A144((const void *)dword_E9C38, (void *)dword_180628, 0x1E0u);
    if ( (_WORD)v1 )
    {
      if ( word_180660 & 1 )
        sub_90478();
      else
        sub_75200(480);
    }
    else
    {
      v1 = 1;
      LOWORD(v5) = sub_90B27((char *)dword_EA3D8, 0x20u, 0);
    }
  }
  LOWORD(v6) = sub_90B27(0, 0x10u, 0);
  if ( word_180660 & 1 )
    sub_72883(dword_180628, (void *)dword_180628, 0xC8u, 0);
  else
    sub_728A9(v6, (void *)dword_180628, 0x1E0u, 0);
  if ( word_180660 & 1 )
    sub_90478();
  else
    sub_75200(480);
  while ( sub_9A10A(v7) )
  {
    byte_1806E4 = 0;
    LOBYTE(v7) = sub_7A060();
  }
  return j___delay(50);
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 9A122: using guessed type _DWORD __cdecl j___delay(_DWORD);
// E9C38: using guessed type int dword_E9C38;
// EA3D8: using guessed type int dword_EA3D8;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;
// 1806E4: using guessed type char byte_1806E4;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;

//----- (00083B50) --------------------------------------------------------
int sub_83B50()
{
  int result; // eax
  int v1; // edx
  int v2; // edx
  int v3; // eax
  int v4; // ST04_4

  result = dword_D41A4;
  if ( !*(_DWORD *)(dword_D41A4 + 226) )
  {
    byte_D41B5 = 32;
    byte_DB74C = 1;
    if ( (unsigned int)dword_17FEAC <= 0x800000 )
    {
      if ( (unsigned int)dword_17FEAC <= 0x700000 )
      {
        v1 = dword_17FEAC - 2398576;
        if ( (unsigned int)dword_17FEAC <= 0x600000 )
        {
          if ( (unsigned int)dword_17FEAC <= 0x500000 )
          {
            if ( (unsigned int)dword_17FEAC <= 0x400000 )
            {
              if ( (unsigned int)dword_17FEAC <= 0x300000 )
              {
                *(_DWORD *)(dword_D41A4 + 230) = 0x200000;
                byte_D41B5 = 16;
              }
              else
              {
                *(_DWORD *)(dword_D41A4 + 230) = dword_17FEAC - 1398576;
              }
              sub_9A230(811);
            }
            else
            {
              *(_DWORD *)(dword_D41A4 + 230) = v1;
              sub_9A230(811);
            }
          }
          else
          {
            *(_DWORD *)(dword_D41A4 + 230) = v1;
            sub_9A230(822);
          }
        }
        else
        {
          *(_DWORD *)(dword_D41A4 + 230) = v1;
          sub_9A230(822);
        }
        *(_BYTE *)(dword_D41A0 + 8628) = 0;
      }
      else
      {
        *(_DWORD *)(dword_D41A4 + 230) = dword_17FEAC - 3398576;
        sub_9A230(822);
      }
    }
    else
    {
      *(_DWORD *)(dword_D41A4 + 230) = 0x400000;
      sub_9A230(822);
    }
    v2 = sub_83CD0(*(_DWORD *)(dword_D41A4 + 230));
    v3 = dword_D41A4;
    *(_DWORD *)(dword_D41A4 + 226) = v2;
    if ( !v2 )
    {
      v4 = *(_DWORD *)(v3 + 230);
      printf(aError1NotEnoug);
      exit(1);
    }
    sub_54630(byte_D41B5);
    result = sub_5B7A0();
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B5: using guessed type char byte_D41B5;
// DB74C: using guessed type char byte_DB74C;
// 17FEAC: using guessed type int dword_17FEAC;

//----- (00083CC0) --------------------------------------------------------
char __cdecl sub_83CC0(char a1)
{
  char result; // al

  result = a1;
  byte_E29E8 = a1;
  return result;
}
// E29E8: using guessed type char byte_E29E8;

//----- (00083CD0) --------------------------------------------------------
int __cdecl sub_83CD0(int a1)
{
  int *v1; // eax
  unsigned int v2; // ecx
  int *v3; // ebx
  unsigned int v4; // esi
  unsigned int v5; // edx

  sub_85070();
  v1 = &dword_17ECA0;
  v2 = -1;
  v4 = a1 + 259;
  v3 = 0;
  LOWORD(v4) = (a1 + 259) & 0xFFFC;
  while ( v1 )
  {
    v5 = v1[1];
    if ( v4 <= v5 && v2 > v5 && !*((_BYTE *)v1 + 16) && !dword_17E0A4[3 * *((unsigned __int8 *)v1 + 17)] )
    {
      v3 = v1;
      v2 = v1[1];
    }
    v1 = (int *)v1[2];
  }
  if ( !v3 || !sub_83E00((int)v3, v4) )
    return sub_83D70(v4);
  sub_85350();
  memset(*v3, 0, v4);
  return *v3;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 17E0A4: using guessed type int dword_17E0A4[];
// 17ECA0: using guessed type int dword_17ECA0;

//----- (00083D70) --------------------------------------------------------
int __cdecl sub_83D70(int a1)
{
  int *v1; // eax
  unsigned int v2; // edi
  int *v3; // ebx
  unsigned int v4; // esi
  unsigned int v5; // edx

  sub_85070();
  v1 = &dword_17ECA0;
  v2 = -1;
  v4 = a1 + 271;
  v3 = 0;
  LOWORD(v4) = (a1 + 271) & 0xFFF0;
  while ( v1 )
  {
    v5 = v1[1];
    if ( v4 <= v5 && v2 > v5 && !*((_BYTE *)v1 + 16) && dword_17E0A4[3 * *((unsigned __int8 *)v1 + 17)] )
    {
      v3 = v1;
      v2 = v1[1];
    }
    v1 = (int *)v1[2];
  }
  if ( !v3 || !sub_83E00((int)v3, v4) )
    return 0;
  sub_85350();
  memset(*v3, 0, v4);
  return *v3;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 17E0A4: using guessed type int dword_17E0A4[];
// 17ECA0: using guessed type int dword_17ECA0;

//----- (00083E00) --------------------------------------------------------
char __cdecl sub_83E00(int a1, int a2)
{
  int *i; // eax
  char v4; // bl
  int v5; // edi

  if ( a2 == *(_DWORD *)(a1 + 4) )
  {
    *(_BYTE *)(a1 + 16) = byte_E29E8;
  }
  else
  {
    for ( i = &dword_17ECA0; i < &dword_17FEA0 && i[1]; i = (int *)((char *)i + 18) )
      ;
    if ( i == &dword_17FEA0 )
      return 0;
    i[1] = *(_DWORD *)(a1 + 4) - a2;
    *i = a2 + *(_DWORD *)a1;
    v4 = byte_E29E8;
    *(_DWORD *)(a1 + 4) = a2;
    *(_BYTE *)(a1 + 16) = v4;
    *((_BYTE *)i + 17) = *(_BYTE *)(a1 + 17);
    i[2] = *(_DWORD *)(a1 + 8);
    i[3] = a1;
    v5 = *(_DWORD *)(a1 + 8);
    if ( v5 )
      *(_DWORD *)(v5 + 12) = i;
    *(_DWORD *)(a1 + 8) = i;
  }
  return 1;
}
// E29E8: using guessed type char byte_E29E8;
// 17ECA0: using guessed type int dword_17ECA0;
// 17FEA0: using guessed type int dword_17FEA0;

//----- (00083E80) --------------------------------------------------------
void __cdecl sub_83E80(int a1)
{
  int *v1; // eax
  char v2; // bl
  int *i; // ebx

  if ( a1 )
  {
    v1 = &dword_17ECA0;
    v2 = 0;
    while ( v1 )
    {
      if ( a1 == *v1 )
      {
        v2 = 1;
        *((_BYTE *)v1 + 16) = 0;
        break;
      }
      v1 = (int *)v1[2];
    }
    if ( v2 == 1 )
    {
      for ( i = &dword_17ECA0; i; i = (int *)i[2] )
      {
        if ( !*((_BYTE *)i + 16) )
          sub_84000((int)i);
      }
    }
    sub_85350();
  }
}
// 17ECA0: using guessed type int dword_17ECA0;

//----- (00084000) --------------------------------------------------------
int __cdecl sub_84000(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // ebx

  result = a1;
  if ( *(_DWORD *)(a1 + 12) )
  {
    *(_BYTE *)(a1 + 16) = 0;
    v2 = *(_DWORD *)(a1 + 12);
    if ( *(_BYTE *)(a1 + 17) == *(_BYTE *)(v2 + 17) && !*(_BYTE *)(v2 + 16) )
    {
      v3 = *(_DWORD *)(a1 + 8);
      if ( v3 )
        *(_DWORD *)(v3 + 12) = v2;
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 8) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) += *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a1 + 4) = 0;
    }
  }
  return result;
}

//----- (00084050) --------------------------------------------------------
int sub_84050()
{
  char v0; // sf
  int result; // eax
  char v2; // [esp+0h] [ebp-8h]
  char v3; // [esp+1h] [ebp-7h]
  char v4; // [esp+2h] [ebp-6h]
  char v5; // [esp+3h] [ebp-5h]
  char v6; // [esp+4h] [ebp-4h]

  sub_840B8(0, 0, v0, 0);
  v2 = byte_E29EC;
  v4 = byte_E29ED;
  v5 = byte_E29EE;
  v6 = byte_E29EF;
  v3 = byte_E29F0;
  if ( byte_E29EC == 5 )
  {
    result = dword_D41A4;
    *(_BYTE *)(dword_D41A4 + 34) = 1;
  }
  else
  {
    result = dword_D41A4;
    *(_BYTE *)(dword_D41A4 + 34) = 0;
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E29EC: using guessed type char byte_E29EC;
// E29ED: using guessed type char byte_E29ED;
// E29EE: using guessed type char byte_E29EE;
// E29EF: using guessed type char byte_E29EF;
// E29F0: using guessed type char byte_E29F0;

//----- (000840B8) --------------------------------------------------------
void __usercall sub_840B8(char a1@<cf>, _BOOL1 a2@<zf>, char a3@<sf>, char a4@<of>)
{
  unsigned int v4; // et0
  __int16 v5; // fps

  v4 = __readeflags();
  sub_840D3(a1, a2, a3, a4);
  sub_841CE(v5);
  __writeeflags(v4);
}

//----- (000840D3) --------------------------------------------------------
__int16 __usercall sub_840D3@<ax>(char _CF@<cf>, _BOOL1 _ZF@<zf>, char _SF@<sf>, char _OF@<of>)
{
  unsigned int v5; // et0
  unsigned int v6; // ecx
  unsigned int v7; // et0
  unsigned int v8; // et0
  unsigned int v9; // ecx
  unsigned int v10; // et0
  int *v16; // esi
  _BYTE *v17; // edi
  signed int v18; // ecx
  __int16 v24; // [esp-6h] [ebp-Ah]

  __asm { pushfw }
  LOWORD(_EAX) = (v24 | 0xF000) & 0xF000;
  byte_E29EC = 2;
  if ( (_WORD)_EAX )
  {
    v5 = __readeflags();
    v6 = v5;
    __writeeflags((unsigned int)&loc_40000 ^ v5);
    v7 = __readeflags();
    LOWORD(_EAX) = v6 ^ v7;
    byte_E29EC = 3;
    if ( v6 != v7 )
    {
      byte_E29EC = 4;
      v8 = __readeflags();
      v9 = v8;
      __writeeflags(v8 ^ 0x200000);
      v10 = __readeflags();
      LOWORD(_EAX) = v9 ^ v10;
      if ( v9 != v10 )
      {
        byte_E2A06 = 1;
        _EAX = 0;
        __asm { cpuid }
        dword_E29FA = _EBX;
        dword_E29FE = _EDX;
        dword_E2A02 = _ECX;
        v16 = &dword_E29FA;
        v17 = &unk_E2A08;
        v18 = 1;
        do
        {
          if ( !v18 )
            break;
          _ZF = *(_BYTE *)v16 == *v17;
          v16 = (int *)((char *)v16 + 1);
          ++v17;
          --v18;
        }
        while ( _ZF );
        if ( !v18 )
          byte_E29ED = 1;
        _EAX = 1;
        __asm { cpuid }
        dword_E29F6 = _EAX;
        byte_E29EC = (unsigned __int16)(_EAX & 0xF00) >> 8;
        byte_E29EF = _EAX & 0xF;
        byte_E29EE = (unsigned __int8)(_EAX & 0xF0) >> 4;
      }
    }
  }
  return _EAX;
}
// E29EC: using guessed type char byte_E29EC;
// E29ED: using guessed type char byte_E29ED;
// E29EE: using guessed type char byte_E29EE;
// E29EF: using guessed type char byte_E29EF;
// E29F6: using guessed type int dword_E29F6;
// E29FA: using guessed type int dword_E29FA;
// E29FE: using guessed type int dword_E29FE;
// E2A02: using guessed type int dword_E2A02;
// E2A06: using guessed type char byte_E2A06;

//----- (000841CE) --------------------------------------------------------
void __usercall __spoils<st0> sub_841CE(__int16 a1@<fpstat>)
{
  __int16 v1; // fps
  double v2; // st6
  _BOOL1 v3; // c0
  char v4; // c2
  _BOOL1 v5; // c3

  __asm { fninit }
  word_E29F4 = a1;
  if ( (_BYTE)a1 )
  {
    byte_E29F0 = 0;
  }
  else if ( (word_E29F4 & 0x103F) == 63 )
  {
    byte_E29F0 = 1;
    if ( byte_E29EC == 3 )
    {
      v2 = -(1.0 / 0.0);
      v3 = v2 < 1.0 / 0.0;
      v4 = 0;
      v5 = v2 == 1.0 / 0.0;
      word_E29F4 = v1;
      byte_E29F1 = 2;
      if ( v2 != 1.0 / 0.0 )
        byte_E29F1 = 3;
    }
  }
  else
  {
    byte_E29F0 = 0;
  }
}
// E29EC: using guessed type char byte_E29EC;
// E29F0: using guessed type char byte_E29F0;
// E29F1: using guessed type char byte_E29F1;
// E29F4: using guessed type __int16 word_E29F4;

//----- (00084250) --------------------------------------------------------
__int16 __cdecl sub_84250(int a1)
{
  int v1; // ebx
  __int16 v2; // si
  int v3; // ebx
  __int16 v4; // ax
  char v6; // [esp+0h] [ebp-64h]

  sub_85070();
  v1 = a1;
  v2 = 0;
  if ( *(_DWORD *)(a1 + 28) )
  {
    do
    {
      sub_9A2F5(v1);
      v1 += 44;
    }
    while ( *(_DWORD *)(v1 + 28) );
    v3 = a1;
  }
  else
  {
    v3 = a1;
  }
  while ( *(_DWORD *)(v3 + 28) )
  {
    v4 = sub_9A32D(v3);
    if ( v4 >= 0 )
    {
      if ( v4 )
        goto LABEL_10;
      sub_41A90((unsigned __int8 *)dword_EA3D8);
      printf(aErrorFileS);
    }
    else
    {
      sub_41A90((unsigned __int8 *)dword_EA3D8);
      printf(aErrorAllocatio);
    }
    printf(aPressReturnToC_0);
    ++v2;
    gets(&v6);
LABEL_10:
    v3 += 44;
  }
  return v2;
}
// 9A464: using guessed type _DWORD __cdecl gets(_DWORD);
// EA3D8: using guessed type int dword_EA3D8;

//----- (00084300) --------------------------------------------------------
signed int __cdecl sub_84300(unsigned __int8 a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edi
  int v4; // eax
  __int16 v6[6]; // [esp+0h] [ebp-14h]
  int v7; // [esp+Ch] [ebp-8h]
  int v8; // [esp+10h] [ebp-4h]

  if ( byte_E3798 && byte_E37AD != a1 )
  {
    if ( HIBYTE(word_E2A14) )
      sub_8D8F0();
    v1 = sub_98817((int)aSoundSoundDat, 512);
    v2 = v1;
    v3 = v1;
    if ( v1 != -1 )
    {
      sub_9891E(v1, 0, 2);
      v4 = tell(v2);
      sub_9891E(v2, v4 - 4, 0);
      sub_988A7(v2, (int)&v7, 4);
      sub_9891E(v2, v7, 0);
      sub_988A7(v2, (int)v6, 12);
      if ( (unsigned __int16)word_E37B6 < 0x336u )
      {
        if ( (unsigned __int16)word_E37B6 >= 0x320u )
        {
          if ( (unsigned __int16)word_E37B6 <= 0x320u )
          {
            v8 = 5;
          }
          else if ( word_E37B6 == 811 )
          {
            v8 = 4;
          }
        }
      }
      else if ( (unsigned __int16)word_E37B6 <= 0x336u )
      {
        v8 = 3;
      }
      else if ( (unsigned __int16)word_E37B6 < 0x656u )
      {
        if ( word_E37B6 == 1611 )
          v8 = 2;
      }
      else if ( (unsigned __int16)word_E37B6 <= 0x656u )
      {
        v8 = 1;
      }
      else if ( word_E37B6 == 1644 )
      {
        v8 = 0;
      }
      if ( (unsigned __int16)(a1 + 1) > (unsigned __int16)v6[v8] )
      {
        sub_98882(v3);
        return 1;
      }
      sub_9891E(v3, 96 * a1, 1);
      if ( !sub_844F0(v3, v8) )
      {
        sub_98882(v3);
        return 1;
      }
      byte_E37AD = a1;
      sub_98882(v3);
    }
  }
  return 0;
}
// 9A510: using guessed type _DWORD __cdecl tell(_DWORD);
// E2A14: using guessed type __int16 word_E2A14;
// E3798: using guessed type char byte_E3798;
// E37AD: using guessed type char byte_E37AD;
// E37B6: using guessed type __int16 word_E37B6;
// 84300: using guessed type __int16 var_14[6];

//----- (000844A0) --------------------------------------------------------
void sub_844A0()
{
  __int16 v0; // bx
  unsigned int v1; // eax
  int v2; // esi

  v0 = word_180B50;
  if ( dword_E37A0 && dword_E37A8 )
  {
    v1 = dword_E37A0 + 32;
    v0 = 0;
    while ( v1 < dword_E37A4 )
    {
      v2 = *(_DWORD *)(v1 + 18);
      v1 += 32;
      ++v0;
      *(_DWORD *)(v1 - 14) = dword_E37A8 + v2;
    }
  }
  word_180B50 = v0;
}
// E37A0: using guessed type int dword_E37A0;
// E37A4: using guessed type int dword_E37A4;
// E37A8: using guessed type int dword_E37A8;
// 180B50: using guessed type __int16 word_180B50;

//----- (000844F0) --------------------------------------------------------
char __cdecl sub_844F0(int a1, unsigned __int8 a2)
{
  int v2; // ebx
  int v3; // eax
  char result; // al
  int v5; // eax
  char *v6; // ebx
  char *v7; // esi
  char v8[96]; // [esp+0h] [ebp-60h]
  char _4[96]; // [esp+4h] [ebp-5Ch]
  char _8[96]; // [esp+8h] [ebp-58h]
  char _C[96]; // [esp+Ch] [ebp-54h]

  tell(a1);
  v2 = 16 * a2;
  sub_988A7(a1, (int)v8, 96);
  if ( *(_DWORD *)&_4[v2] == -1 )
    return 0;
  if ( !HIBYTE(word_E2A14) )
  {
    dword_E37A8 = sub_83CD0(*(_DWORD *)&_C[v2] + 256);
    v3 = sub_83CD0(3100);
    dword_E37A0 = v3;
    LOBYTE(word_E2A14) = 1;
    if ( !dword_E37A8 || !v3 )
    {
      sub_83E80(dword_E37A8);
      sub_83E80(dword_E37A0);
      LOBYTE(word_E2A14) = 0;
      result = 0;
      byte_E37AD = -1;
      return result;
    }
    dword_E2A18 = *(_DWORD *)&_C[v2] + 256;
    HIBYTE(word_E2A14) = 1;
    dword_E2A1C = 3100;
  }
  byte_E3798 = 0;
  if ( !dword_E37A8 || !dword_E37A0 )
    return 0;
  memset(dword_E37A8, 0, dword_E2A18);
  memset(dword_E37A0, 0, dword_E2A1C);
  v5 = 16 * a2;
  v6 = (char *)dword_E37A0;
  dword_E37A4 = dword_E37A0 + *(_DWORD *)&_8[v5];
  v7 = (char *)dword_E37A8;
  sub_9891E(a1, *(_DWORD *)&_4[v5], 0);
  sub_988A7(a1, dword_E37A8, 8);
  if ( *v7 != 82 || v7[1] != 78 || v7[2] != 67 )
  {
    sub_988A7(a1, dword_E37A8 + 8, *(_DWORD *)&_C[16 * a2] - 8);
  }
  else
  {
    sub_988A7(
      a1,
      dword_E37A8 + 8,
      (unsigned __int8)v7[7]
    + (((unsigned __int8)v7[6] + (((unsigned __int8)v7[5] + ((unsigned __int8)v7[4] << 8)) << 8)) << 8)
    - 8);
    sub_9894C((int)v7, v7);
  }
  sub_9891E(a1, *(_DWORD *)&v8[16 * a2], 0);
  sub_988A7(a1, dword_E37A0, 8);
  if ( *v6 != 82 || v6[1] != 78 || v6[2] != 67 )
  {
    sub_988A7(a1, dword_E37A0 + 8, *(_DWORD *)&_8[16 * a2] - 8);
  }
  else
  {
    sub_988A7(
      a1,
      dword_E37A0 + 8,
      (unsigned __int8)v6[7]
    + (((unsigned __int8)v6[6] + (((unsigned __int8)v6[5] + ((unsigned __int8)v6[4] << 8)) << 8)) << 8)
    - 8);
    sub_9894C((int)v6, v6);
  }
  sub_844A0();
  byte_E3798 = 1;
  return 1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 9A510: using guessed type _DWORD __cdecl tell(_DWORD);
// E2A14: using guessed type __int16 word_E2A14;
// E2A18: using guessed type int dword_E2A18;
// E2A1C: using guessed type int dword_E2A1C;
// E3798: using guessed type char byte_E3798;
// E37A0: using guessed type int dword_E37A0;
// E37A4: using guessed type int dword_E37A4;
// E37A8: using guessed type int dword_E37A8;
// E37AD: using guessed type char byte_E37AD;
// 844F0: using guessed type char var_60[96];

//----- (00084790) --------------------------------------------------------
int sub_84790()
{
  int result; // eax

  memset(dword_D41A0 + 222796, 0, 1950);
  result = dword_D41A0;
  *(_WORD *)(dword_D41A0 + 224762) = 0;
  *(_DWORD *)(result + 224754) = &loc_3A013;
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;

//----- (000847D0) --------------------------------------------------------
char __cdecl sub_847D0(int a1, char a2, char a3, char a4)
{
  __int16 v4; // dx
  unsigned __int8 v5; // dh
  int v6; // eax

  LOBYTE(v4) = 0;
  if ( *(_BYTE *)(dword_D41A0 + 8598) )
  {
    v5 = *(_BYTE *)(dword_D41A0 + 196308);
    if ( v5 >= 1u && v5 <= 2u && *(_WORD *)(dword_D41A0 + 224762) < 50 )
    {
      v6 = dword_D41A0 + 222796;
      HIBYTE(v4) = 0;
      while ( v4 < 50 && *(_BYTE *)v6 )
      {
        ++v4;
        v6 += 39;
      }
      *(_BYTE *)v6 = 1;
      *(_BYTE *)(v6 + 1) = a4;
      *(_BYTE *)(v6 + 2) = a2;
      *(_BYTE *)(v6 + 3) = a3;
      *(_DWORD *)(v6 + 4) = *(_DWORD *)(a1 + 76);
      *(_WORD *)(v6 + 8) = *(_WORD *)(a1 + 80);
      *(_DWORD *)(v6 + 10) = a1;
      *(_BYTE *)(a1 + 14) |= 8u;
      memset(v6 + 14, 0, 25);
      LOBYTE(v4) = 1;
      ++*(_WORD *)(dword_D41A0 + 224762);
    }
  }
  return v4;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;

//----- (00084880) --------------------------------------------------------
int __cdecl sub_84880(_BYTE *a1)
{
  int result; // eax

  *a1 = 0;
  result = dword_D41A0;
  --*(_WORD *)(result + 224762);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (000848A0) --------------------------------------------------------
char sub_848A0()
{
  unsigned __int16 v0; // ax
  int v1; // edx
  __int16 v2; // bx
  __int16 v3; // si
  int v4; // eax
  unsigned __int16 v5; // di
  unsigned __int16 v6; // di
  unsigned __int16 v7; // di
  unsigned __int16 v8; // di
  unsigned __int16 v9; // di
  unsigned __int16 v10; // di
  unsigned __int16 v11; // di
  unsigned __int16 v12; // di
  unsigned __int16 v13; // di
  unsigned __int16 v14; // di
  unsigned __int16 v15; // di
  unsigned __int16 v16; // di
  unsigned __int16 v17; // di
  unsigned __int16 v18; // di
  unsigned __int16 v19; // di
  unsigned __int16 v20; // di
  unsigned __int16 v21; // di
  unsigned __int16 v22; // di
  unsigned __int16 v23; // di
  unsigned __int16 v24; // di
  unsigned __int16 v25; // di
  unsigned __int16 v26; // di
  unsigned __int16 v27; // di
  char v28; // ch
  unsigned __int16 v29; // di
  __int16 v31; // [esp+4h] [ebp-4h]

  LOBYTE(v0) = *(_BYTE *)(dword_D41A0 + 196308);
  if ( (unsigned __int8)v0 >= 1u && (unsigned __int8)v0 <= 2u )
  {
    v0 = *(_WORD *)(dword_D41A0 + 224762);
    v31 = v0;
    if ( v0 )
    {
      v1 = dword_D41A0 + 222796;
      v2 = 0;
      v3 = 0;
      while ( v2 < 50 && v3 < v31 )
      {
        if ( *(_BYTE *)v1 )
        {
          v4 = *(signed __int16 *)(v1 + 4) >> 8;
          BYTE1(v4) = (*(_WORD *)(v1 + 6) >> 8) - 2;
          LOBYTE(v4) = v4 - 2;
          v5 = v4;
          LOBYTE(v4) = v4 + 1;
          byte_12B4E0[v5] -= *(_BYTE *)(v1 + 14);
          v6 = v4;
          LOBYTE(v4) = v4 + 1;
          byte_12B4E0[v6] -= *(_BYTE *)(v1 + 15);
          v7 = v4;
          LOBYTE(v4) = v4 + 1;
          byte_12B4E0[v7] -= *(_BYTE *)(v1 + 16);
          v8 = v4;
          LOBYTE(v4) = v4 + 1;
          byte_12B4E0[v8] -= *(_BYTE *)(v1 + 17);
          v9 = v4;
          ++BYTE1(v4);
          byte_12B4E0[v9] -= *(_BYTE *)(v1 + 18);
          v10 = v4;
          LOBYTE(v4) = v4 - 1;
          byte_12B4E0[v10] -= *(_BYTE *)(v1 + 19);
          v11 = v4;
          LOBYTE(v4) = v4 - 1;
          byte_12B4E0[v11] -= *(_BYTE *)(v1 + 20);
          v12 = v4;
          LOBYTE(v4) = v4 - 1;
          byte_12B4E0[v12] -= *(_BYTE *)(v1 + 21);
          v13 = v4;
          LOBYTE(v4) = v4 - 1;
          byte_12B4E0[v13] -= *(_BYTE *)(v1 + 22);
          v14 = v4;
          ++BYTE1(v4);
          byte_12B4E0[v14] -= *(_BYTE *)(v1 + 23);
          v15 = v4;
          LOBYTE(v4) = v4 + 1;
          byte_12B4E0[v15] -= *(_BYTE *)(v1 + 24);
          v16 = v4;
          LOBYTE(v4) = v4 + 1;
          byte_12B4E0[v16] -= *(_BYTE *)(v1 + 25);
          v17 = v4;
          LOBYTE(v4) = v4 + 1;
          byte_12B4E0[v17] -= *(_BYTE *)(v1 + 26);
          v18 = v4;
          LOBYTE(v4) = v4 + 1;
          byte_12B4E0[v18] -= *(_BYTE *)(v1 + 27);
          v19 = v4;
          ++BYTE1(v4);
          byte_12B4E0[v19] -= *(_BYTE *)(v1 + 28);
          v20 = v4;
          LOBYTE(v4) = v4 - 1;
          byte_12B4E0[v20] -= *(_BYTE *)(v1 + 29);
          ++v3;
          byte_12B4E0[(unsigned __int16)v4] -= *(_BYTE *)(v1 + 30);
          LOBYTE(v4) = v4 - 1;
          v21 = v4;
          LOBYTE(v4) = v4 - 1;
          byte_12B4E0[v21] -= *(_BYTE *)(v1 + 31);
          v22 = v4;
          LOBYTE(v4) = v4 - 1;
          byte_12B4E0[v22] -= *(_BYTE *)(v1 + 32);
          v23 = v4;
          HIBYTE(v0) = BYTE1(v4) + 1;
          byte_12B4E0[v23] -= *(_BYTE *)(v1 + 33);
          v24 = v0;
          LOBYTE(v0) = v0 + 1;
          byte_12B4E0[v24] -= *(_BYTE *)(v1 + 34);
          v25 = v0;
          LOBYTE(v0) = v0 + 1;
          byte_12B4E0[v25] -= *(_BYTE *)(v1 + 35);
          v26 = v0;
          LOBYTE(v0) = v0 + 1;
          byte_12B4E0[v26] -= *(_BYTE *)(v1 + 36);
          v27 = v0;
          v28 = byte_12B4E0[v0] - *(_BYTE *)(v1 + 37);
          LOBYTE(v0) = v0 + 1;
          byte_12B4E0[v27] = v28;
          v29 = v0;
          LOBYTE(v0) = *(_BYTE *)(v1 + 38);
          byte_12B4E0[v29] -= v0;
        }
        ++v2;
        v1 += 39;
      }
    }
  }
  return v0;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00084B80) --------------------------------------------------------
int sub_84B80()
{
  int result; // eax
  unsigned __int8 v1; // dl
  int v2; // esi
  int v3; // esi
  unsigned __int16 v4; // bx
  int v5; // eax
  int i; // [esp+0h] [ebp-10h]
  int v7; // [esp+4h] [ebp-Ch]
  __int16 v8; // [esp+8h] [ebp-8h]
  signed __int16 v9; // [esp+Ch] [ebp-4h]

  result = dword_D41A0;
  v1 = *(_BYTE *)(dword_D41A0 + 196308);
  if ( v1 >= 1u && v1 <= 2u )
  {
    v9 = *(_WORD *)(dword_D41A0 + 224762);
    if ( v9 )
    {
      result = dword_D41A0 + 222796;
      v8 = 0;
      v7 = 0;
      for ( i = dword_D41A0 + 222796; v8 < 50; i += 39 )
      {
        result = v7;
        if ( (signed __int16)v7 >= v9 )
          break;
        result = i;
        if ( *(_BYTE *)i )
        {
          v2 = *(_DWORD *)(i + 10);
          ++v7;
          if ( *(_DWORD *)(v2 + 8) < 0 || *(_BYTE *)(v2 + 13) & 4 )
          {
            result = sub_84880((_BYTE *)i);
          }
          else
          {
            v3 = v2 + 76;
            *(_DWORD *)(i + 4) = *(_DWORD *)v3;
            *(_WORD *)(i + 8) = *(_WORD *)(v3 + 4);
            LOBYTE(v4) = *(_WORD *)(i + 4) >> 8;
            HIBYTE(v4) = *(_WORD *)(i + 6) >> 8;
            v5 = dword_D41A0;
            *(_DWORD *)(dword_D41A0 + 224754) = 9377 * *(_DWORD *)(dword_D41A0 + 224754) + 9439;
            LOWORD(v3) = *(_DWORD *)(v5 + 224754) % (unsigned int)*(unsigned __int8 *)(i + 3)
                       - *(unsigned __int8 *)(i + 3) / 2;
            HIBYTE(v4) -= 2;
            LOBYTE(v4) = v4 - 2;
            sub_84EA0(v4, i, 0, v3);
            LOBYTE(v4) = v4 + 1;
            sub_84EA0(v4, i, 1, v3);
            LOBYTE(v4) = v4 + 1;
            sub_84EA0(v4, i, 2, v3);
            LOBYTE(v4) = v4 + 1;
            sub_84EA0(v4, i, 3, v3);
            LOBYTE(v4) = v4 + 1;
            sub_84EA0(v4, i, 4, v3);
            ++HIBYTE(v4);
            sub_84EA0(v4, i, 5, v3);
            LOBYTE(v4) = v4 - 1;
            sub_84EA0(v4, i, 6, v3);
            LOBYTE(v4) = v4 - 1;
            sub_84EA0(v4, i, 7, v3);
            LOBYTE(v4) = v4 - 1;
            sub_84EA0(v4, i, 8, v3);
            LOBYTE(v4) = v4 - 1;
            sub_84EA0(v4, i, 9, v3);
            ++HIBYTE(v4);
            sub_84EA0(v4, i, 10, v3);
            LOBYTE(v4) = v4 + 1;
            sub_84EA0(v4, i, 11, v3);
            LOBYTE(v4) = v4 + 1;
            sub_84EA0(v4, i, 12, v3);
            LOBYTE(v4) = v4 + 1;
            sub_84EA0(v4, i, 13, v3);
            LOBYTE(v4) = v4 + 1;
            sub_84EA0(v4, i, 14, v3);
            ++HIBYTE(v4);
            sub_84EA0(v4, i, 15, v3);
            LOBYTE(v4) = v4 - 1;
            sub_84EA0(v4, i, 16, v3);
            LOBYTE(v4) = v4 - 1;
            sub_84EA0(v4, i, 17, v3);
            LOBYTE(v4) = v4 - 1;
            sub_84EA0(v4, i, 18, v3);
            LOBYTE(v4) = v4 - 1;
            sub_84EA0(v4, i, 19, v3);
            ++HIBYTE(v4);
            sub_84EA0(v4, i, 20, v3);
            LOBYTE(v4) = v4 + 1;
            sub_84EA0(v4, i, 21, v3);
            LOBYTE(v4) = v4 + 1;
            sub_84EA0(v4, i, 22, v3);
            LOBYTE(v4) = v4 + 1;
            sub_84EA0(v4, i, 23, v3);
            LOBYTE(v4) = v4 + 1;
            result = sub_84EA0(v4, i, 24, v3);
          }
        }
        ++v8;
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00084EA0) --------------------------------------------------------
int __cdecl sub_84EA0(unsigned __int16 a1, int a2, char a3, __int16 a4)
{
  signed int v4; // esi
  signed int v5; // edi
  int v6; // ebx
  int v7; // ecx
  int v8; // edx
  signed int v9; // ebx
  int v10; // edx
  int result; // eax
  __int16 v12; // [esp+0h] [ebp-8h]
  __int16 v13; // [esp+2h] [ebp-6h]
  __int16 v14; // [esp+4h] [ebp-4h]

  v4 = 31;
  v5 = (unsigned __int8)byte_12B4E0[a1];
  LOBYTE(v6) = 0;
  if ( v5 < 63 )
  {
    v12 = ((unsigned __int8)a1 << 8) + 128;
    v13 = (HIBYTE(a1) << 8) + 128;
    v14 = sub_10C40(&v12);
    v7 = sub_84FB0((signed __int16 *)(a2 + 4), &v12);
    if ( v7 < 294912 )
    {
      if ( *(_BYTE *)(a2 + 1) & 1 )
      {
        v8 = *(_DWORD *)(a2 + 10);
        v9 = *(_DWORD *)(v8 + 8);
        if ( v9 <= 0 )
        {
          v4 = 0;
        }
        else if ( v9 < 31 )
        {
          v4 = *(_DWORD *)(v8 + 8);
        }
      }
      v10 = 31 * (294912 - v7) / 294912 * *(unsigned __int8 *)(a2 + 2);
      v6 = a4 + ((v10 - (__CFSHL__(v10 >> 31, 7) + (v10 >> 31 << 7))) >> 7);
      if ( v6 > v4 )
        v6 = v4;
      if ( v5 + v6 > 63 )
        v6 = 63 - v5;
      if ( v6 < 0 )
        LOBYTE(v6) = 0;
      byte_12B4E0[a1] += v6;
    }
  }
  result = a2 + a3;
  *(_BYTE *)(result + 14) = v6;
  return result;
}

//----- (00084FB0) --------------------------------------------------------
int __cdecl sub_84FB0(signed __int16 *a1, signed __int16 *a2)
{
  int v2; // eax
  int v3; // edx
  int v4; // eax

  v2 = a1[1] - a2[1];
  v3 = v2 * v2;
  v4 = *a1 - *a2;
  return v4 * v4 + v3 + (a1[2] - a2[2]) * (a1[2] - a2[2]);
}

//----- (00085060) --------------------------------------------------------
int __cdecl sub_85060(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (00085070) --------------------------------------------------------
void sub_85070()
{
  signed int v0; // ebx
  int *v1; // ST04_4
  signed int v2; // ebx
  char *v3; // ST04_4
  char *v4; // ebx
  int v5; // esi
  unsigned int v6; // eax
  int v7; // edi
  int v8; // edx
  int v9; // eax
  signed int i; // ebx
  int v11; // eax
  signed int j; // edi
  int k; // ebx
  int v14; // edx
  int v15; // eax
  signed int v16; // ebx
  int v17; // eax
  int l; // ebx
  int v19; // edx
  int v20; // eax
  int v21; // [esp+0h] [ebp-Ch]
  int v22; // [esp+8h] [ebp-4h]

  if ( !dword_17E0A8[0] )
  {
    v0 = 0;
    v21 = sub_85450((unsigned int)sub_10000);
    do
    {
      v1 = &dword_17E0A0[3 * v0++];
      memset(v1, 0, 12);
    }
    while ( v0 < 256 );
    v2 = 0;
    while ( v2 < 256 )
    {
      v3 = (char *)&dword_17ECA0 + 18 * v2++;
      memset(v3, 0, 18);
    }
    v4 = (char *)&loc_A0000;
    v5 = 0;
    while ( (signed int)v4 >= 1024 )
    {
      v6 = sub_85450((unsigned int)v4);
      if ( v6 )
      {
        v7 = (unsigned __int16)v6;
        v8 = v6 >> 16;
        v9 = 3 * v5;
        dword_17E0A8[v9] = (int)v4;
        ++v5;
        dword_17E0A4[v9] = v8;
        v4 += 1024;
        dword_17E0A0[v9] = 16 * v7;
      }
      v4 -= 1024;
    }
    for ( i = 0x1000000; i >= 4096; i -= 4096 )
    {
      v11 = malloc(i);
      dword_17E0A0[3 * v5] = v11;
      if ( v11 )
      {
        for ( j = 4096; j > 0; j -= 16 )
        {
          v22 = 3 * v5;
          if ( expand(dword_17E0A0[3 * v5], i + j) )
          {
            dword_17E0A8[v22] = i + j;
            dword_17E0A4[v22] = 0;
            break;
          }
        }
        i += 4096;
        ++v5;
      }
    }
    for ( k = 4096; k >= 16; k -= 16 )
    {
      v14 = malloc(k);
      v15 = 3 * v5;
      dword_17E0A0[3 * v5] = v14;
      if ( v14 )
      {
        ++v5;
        dword_17E0A8[v15] = k;
        k += 4096;
        dword_17E0A4[v15] = 0;
      }
    }
    v16 = 0;
    qsort(dword_17E0A0, v5, 12, sub_85060);
    do
    {
      v17 = 9 * v16++;
      *(int *)((char *)&dword_17ECA4 + 2 * v17) = 0;
    }
    while ( v16 < 256 );
    for ( l = 0; l < v5; ++l )
    {
      v19 = 18 * l;
      *(int *)((char *)&dword_17ECA0 + v19) = dword_17E0A0[3 * l];
      *(int *)((char *)&dword_17ECA4 + v19) = dword_17E0A8[3 * l];
      if ( l )
        *(int *)((char *)&dword_17ECAC + v19) = (int)&dword_17ECA0 + 18 * (l - 1);
      else
        *(int *)((char *)&dword_17ECAC + v19) = 0;
      v20 = 9 * l;
      *(int *)((char *)&dword_17ECA8 + 2 * v20) = (int)&dword_17ECA0 + 18 * (l + 1);
      byte_17ECB0[2 * v20] = 0;
      byte_17ECB1[2 * v20] = l;
    }
    *(int *)((char *)&dword_17ECA8 + 18 * (v5 - 1)) = 0;
    sub_9AD16(HIWORD(v21));
  }
}
// 10000: using guessed type void __noreturn sub_10000();
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 9A522: using guessed type _DWORD __cdecl malloc(_DWORD);
// 9A61E: using guessed type _DWORD __cdecl expand(_DWORD, _DWORD);
// 9A8EE: using guessed type _DWORD __cdecl qsort(_DWORD, _DWORD, _DWORD, _DWORD);
// 17E0A0: using guessed type int dword_17E0A0[];
// 17E0A4: using guessed type int dword_17E0A4[];
// 17ECA0: using guessed type int dword_17ECA0;
// 17ECA4: using guessed type int dword_17ECA4;
// 17ECA8: using guessed type int dword_17ECA8;
// 17ECAC: using guessed type int dword_17ECAC;

//----- (00085350) --------------------------------------------------------
int *sub_85350()
{
  int *result; // eax
  unsigned int v1; // edx
  int v2; // edx

  result = &dword_17ECA0;
  dword_17FEA0 = 0;
  dword_17FEA4 = 0;
  dword_17FEA8 = 0;
  dword_17FEAC = 0;
  dword_17FEB0 = -1;
  while ( result )
  {
    if ( *((_BYTE *)result + 16) )
    {
      v2 = result[1];
      dword_17FEA8 += v2;
      dword_17FEA0 += v2;
    }
    else
    {
      v1 = result[1];
      dword_17FEA4 += v1;
      if ( v1 > dword_17FEAC )
        dword_17FEAC = v1;
      if ( result[1] < (unsigned int)dword_17FEB0 )
        dword_17FEB0 = result[1];
      dword_17FEA0 += result[1];
    }
    result = (int *)result[2];
  }
  LOBYTE(dword_17FEA0) = dword_17FEA0 & 0xFC;
  LOBYTE(dword_17FEA4) = dword_17FEA4 & 0xFC;
  LOBYTE(dword_17FEAC) = dword_17FEAC & 0xFC;
  LOBYTE(dword_17FEA8) = dword_17FEA8 & 0xFC;
  LOBYTE(dword_17FEB0) = dword_17FEB0 & 0xFC;
  return result;
}
// 17ECA0: using guessed type int dword_17ECA0;
// 17FEA0: using guessed type int dword_17FEA0;
// 17FEA4: using guessed type int dword_17FEA4;
// 17FEA8: using guessed type int dword_17FEA8;
// 17FEAC: using guessed type int dword_17FEAC;
// 17FEB0: using guessed type int dword_17FEB0;

//----- (00085450) --------------------------------------------------------
int __cdecl sub_85450(unsigned int a1)
{
  int v1; // ebx
  int v3; // [esp+0h] [ebp-38h]
  unsigned int v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+28h] [ebp-10h]
  int v7; // [esp+34h] [ebp-4h]

  v1 = 0;
  if ( a1 < (unsigned int)&loc_A0000 )
  {
    v4 = (a1 + 15) >> 4;
    v3 = 256;
    int386(49, &v3, &v5);
    if ( !v7 )
      v1 = v5 | (v6 << 16);
  }
  return v1;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (000856D0) --------------------------------------------------------
__int16 __cdecl sub_856D0(int a1, int a2, __int16 a3, int a4)
{
  unsigned __int8 v4; // dl
  unsigned __int8 v5; // dh
  __int16 v6; // di
  __int16 v7; // si
  int v8; // eax
  int v9; // ecx
  unsigned __int8 v10; // cl
  _BYTE *v11; // edx
  __int16 v12; // si
  char v13; // cl
  int v14; // edi
  int v15; // esi
  _BYTE *v16; // eax
  char v17; // ch
  _BOOL1 v18; // zf
  int v19; // edx
  char v20; // cl
  char v21; // cl
  unsigned __int8 v22; // cl
  int v23; // edi
  int v24; // eax
  _BYTE *v25; // eax
  char v26; // ch
  unsigned __int8 v27; // ch
  int v29; // [esp+0h] [ebp-38h]
  int v30; // [esp+8h] [ebp-30h]
  int v31; // [esp+Ch] [ebp-2Ch]
  int v32; // [esp+10h] [ebp-28h]
  int v33; // [esp+14h] [ebp-24h]
  int v34; // [esp+1Ch] [ebp-1Ch]
  __int16 v35; // [esp+24h] [ebp-14h]
  unsigned __int8 v36; // [esp+28h] [ebp-10h]
  unsigned __int8 v37; // [esp+2Ch] [ebp-Ch]
  unsigned __int8 v38; // [esp+30h] [ebp-8h]

  v4 = *(_BYTE *)(a4 + 4);
  v5 = *(_BYTE *)(a4 + 5);
  v6 = dword_17FEC0 + a2;
  v7 = dword_17FEC8 + a3;
  v8 = -a2;
  if ( (-(signed __int16)a2 & 0x8000u) != 0 || (_WORD)a2 == 0 )
  {
    v36 = 0;
  }
  else
  {
    if ( (signed __int16)v8 >= v4 )
      return v8;
    v36 = -(char)a2;
  }
  v9 = v4;
  LOWORD(v8) = v4 + v6 - dword_17FEC4;
  if ( (signed __int16)v8 > 0 )
  {
    if ( (signed __int16)v8 >= v4 )
      return v8;
    v4 = dword_17FEC4 - v6;
  }
  LOWORD(v8) = -a3;
  if ( a3 >= 0 )
  {
    v10 = 0;
  }
  else
  {
    v9 = v5;
    if ( (signed __int16)v8 >= v5 )
      return v8;
    v10 = -(char)a3;
  }
  LOWORD(v8) = v7 + v5 - dword_17FECC;
  if ( (signed __int16)v8 > 0 )
  {
    if ( (signed __int16)v8 >= v5 )
      return v8;
    v5 = dword_17FECC - v7;
  }
  v37 = v4 - v36;
  BYTE1(v9) = v5 - v10;
  v8 = *(_DWORD *)a4;
  v35 = dword_18062C;
  v11 = (_BYTE *)(dword_18062C * (v7 + (unsigned __int8)v9) + dword_180628 + v6 + v36);
  if ( (_BYTE)v9 )
  {
    v12 = v10;
    do
    {
      while ( *(_BYTE *)v8 > 0 )
        v8 += *(char *)v8 + 1;
      v13 = *(_BYTE *)v8++;
    }
    while ( v13 || --v12 );
  }
  v14 = (signed __int16)dword_18062C;
  v15 = (int)&v11[(signed __int16)dword_18062C];
  v29 = (int)&v11[(signed __int16)dword_18062C];
  LOWORD(v15) = v37;
  LOWORD(v9) = BYTE1(v9);
  v34 = v9;
  if ( v36 )
  {
LABEL_68:
    if ( !v36 )
      goto LABEL_22;
    v38 = v36;
    while ( 1 )
    {
      while ( 1 )
      {
        v21 = *(_BYTE *)v8;
        if ( *(_BYTE *)v8 > 0 )
          break;
        if ( !*(_BYTE *)v8 )
        {
          v15 = 0;
          goto LABEL_22;
        }
        v14 = v21;
        v9 = -v38;
        if ( v14 < v9 )
        {
          LOBYTE(v9) = -*(_BYTE *)v8 - v38;
          if ( (unsigned __int8)v9 > v37 )
            LOBYTE(v9) = v37;
          v14 = (unsigned __int8)v9;
          ++v8;
          v11 += (unsigned __int8)v9;
          BYTE1(v9) = 0;
          v15 -= v9;
          goto LABEL_22;
        }
        v27 = *(_BYTE *)v8++ + v38;
        v38 = v27;
        if ( !v27 )
          goto LABEL_22;
      }
      v14 = v21;
      v9 = v38;
      if ( v38 < v14 )
        break;
      v38 -= *(_BYTE *)v8;
      v9 = v14 + 1;
      v8 += v14 + 1;
      if ( !v38 )
        goto LABEL_22;
    }
    v22 = *(_BYTE *)v8 - v38;
    if ( v22 > v37 )
      v22 = v37;
    v31 = (int)&v11[v22];
    v23 = *(char *)v8;
    v24 = v8 + 1;
    v33 = v24 + v23;
    v25 = (_BYTE *)(v38 + v24);
    v15 -= v22;
    v14 = *(_WORD *)(a1 + 4) & 0xC000;
    if ( (unsigned __int16)v14 >= 0x4000u )
    {
      if ( (unsigned __int16)v14 > 0x4000u )
      {
        if ( (_WORD)v14 != -32768 )
          goto LABEL_105;
        while ( 1 )
        {
          if ( *v25 >= 1u )
          {
            if ( *v25 > 1u )
            {
              if ( *v25 != 2 )
                goto LABEL_104;
LABEL_103:
              v18 = (*(_BYTE *)(a1 + 4) & 2) == 0;
              goto LABEL_104;
            }
            if ( !(*(_BYTE *)(a1 + 4) & 1) )
              goto LABEL_103;
          }
LABEL_104:
          ++v25;
          ++v11;
          if ( !--v22 )
            goto LABEL_105;
        }
      }
      while ( 1 )
      {
        if ( *v25 >= 1u )
        {
          if ( *v25 > 1u )
          {
            if ( *v25 != 2 )
              goto LABEL_96;
LABEL_95:
            v18 = (*(_BYTE *)(a1 + 4) & 2) == 0;
            goto LABEL_96;
          }
          if ( !(*(_BYTE *)(a1 + 4) & 1) )
            goto LABEL_95;
        }
LABEL_96:
        ++v25;
        ++v11;
        if ( !--v22 )
        {
          v8 = v33;
          v11 = (_BYTE *)v31;
          goto LABEL_22;
        }
      }
    }
    if ( (_WORD)v14 )
    {
LABEL_105:
      v8 = v33;
      v11 = (_BYTE *)v31;
      goto LABEL_22;
    }
    while ( 1 )
    {
      if ( *v25 >= 1u )
      {
        if ( *v25 > 1u )
        {
          if ( *v25 != 2 || !(*(_BYTE *)(a1 + 4) & 2) )
            goto LABEL_88;
          v26 = *(_BYTE *)(a1 + 7);
          goto LABEL_87;
        }
        if ( *(_BYTE *)(a1 + 4) & 1 )
        {
          v26 = *(_BYTE *)(a1 + 6);
LABEL_87:
          *v11 = v26;
          goto LABEL_88;
        }
      }
LABEL_88:
      ++v25;
      ++v11;
      if ( !--v22 )
        goto LABEL_105;
    }
  }
LABEL_22:
  while ( 2 )
  {
    while ( 2 )
    {
      if ( (signed __int16)v15 <= 0 )
      {
        HIWORD(v15) = HIWORD(v34);
        LOWORD(v15) = v34 - 1;
        v18 = (_WORD)v34 == 1;
        v34 = v15;
        if ( v18 )
          return v8;
        do
        {
          while ( *(_BYTE *)v8 > 0 )
            v8 += *(char *)v8 + 1;
          v20 = *(_BYTE *)v8++;
        }
        while ( v20 );
        v11 = (_BYTE *)v29;
        v9 = v35;
        v14 = v29 + v35;
        LOWORD(v15) = v37;
        v29 += v35;
        goto LABEL_68;
      }
      LOBYTE(v9) = *(_BYTE *)v8;
      if ( *(_BYTE *)v8 > 0 )
      {
        if ( (char)v9 >= (signed __int16)v15 )
          v9 = (signed __int16)v15;
        else
          v9 = *(char *)v8;
        LOWORD(v14) = *(char *)v8;
        v15 -= v14;
        v32 = (int)&v11[(unsigned __int8)v9];
        v30 = *(char *)v8 + v8 + 1;
        v14 = *(_WORD *)(a1 + 4) & 0xC000;
        v16 = (_BYTE *)(v8 + 1);
        if ( (unsigned __int16)v14 >= 0x4000u )
        {
          if ( (unsigned __int16)v14 > 0x4000u )
          {
            if ( (_WORD)v14 != -32768 )
              goto LABEL_58;
            while ( 1 )
            {
              if ( *v16 >= 1u )
              {
                if ( *v16 > 1u )
                {
                  if ( *v16 != 2 )
                    goto LABEL_57;
LABEL_56:
                  v18 = (*(_BYTE *)(a1 + 4) & 2) == 0;
                  goto LABEL_57;
                }
                if ( !(*(_BYTE *)(a1 + 4) & 1) )
                  goto LABEL_56;
              }
LABEL_57:
              ++v16;
              ++v11;
              LOBYTE(v9) = v9 - 1;
              if ( !(_BYTE)v9 )
                goto LABEL_58;
            }
          }
          while ( 1 )
          {
            if ( *v16 >= 1u )
            {
              if ( *v16 > 1u )
              {
                if ( *v16 != 2 )
                  goto LABEL_49;
LABEL_48:
                v18 = (*(_BYTE *)(a1 + 4) & 2) == 0;
                goto LABEL_49;
              }
              if ( !(*(_BYTE *)(a1 + 4) & 1) )
                goto LABEL_48;
            }
LABEL_49:
            ++v16;
            ++v11;
            LOBYTE(v9) = v9 - 1;
            if ( !(_BYTE)v9 )
            {
              v11 = (_BYTE *)v32;
              v8 = v30;
              goto LABEL_22;
            }
          }
        }
        if ( (_WORD)v14 )
        {
LABEL_58:
          v11 = (_BYTE *)v32;
          v8 = v30;
          continue;
        }
        while ( 1 )
        {
          if ( *v16 >= 1u )
          {
            if ( *v16 > 1u )
            {
              if ( *v16 != 2 || !(*(_BYTE *)(a1 + 4) & 2) )
                goto LABEL_41;
              v17 = *(_BYTE *)(a1 + 7);
              goto LABEL_40;
            }
            if ( *(_BYTE *)(a1 + 4) & 1 )
            {
              v17 = *(_BYTE *)(a1 + 6);
LABEL_40:
              *v11 = v17;
              goto LABEL_41;
            }
          }
LABEL_41:
          ++v16;
          ++v11;
          LOBYTE(v9) = v9 - 1;
          if ( !(_BYTE)v9 )
            goto LABEL_58;
        }
      }
      break;
    }
    if ( *(_BYTE *)v8 < 0 )
    {
      LOWORD(v9) = (char)v9;
      v15 += v9;
      v9 = *(char *)v8++;
      v11 -= v9;
      continue;
    }
    break;
  }
  HIWORD(v19) = HIWORD(v34);
  LOWORD(v19) = v34 - 1;
  v18 = (_WORD)v34 == 1;
  v34 = v19;
  if ( !v18 )
  {
    v11 = (_BYTE *)v29;
    v9 = v35;
    v15 = v29 + v35;
    ++v8;
    v29 += v35;
    LOWORD(v15) = v37;
    goto LABEL_68;
  }
  return v8;
}
// 17FEC0: using guessed type int dword_17FEC0;
// 17FEC4: using guessed type int dword_17FEC4;
// 17FEC8: using guessed type int dword_17FEC8;
// 17FECC: using guessed type int dword_17FECC;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;

//----- (00085AF0) --------------------------------------------------------
unsigned int *__cdecl sub_85AF0(int a1)
{
  unsigned int *result; // eax
  unsigned int v2; // ecx

  result = *(unsigned int **)a1;
  if ( *(_DWORD *)a1 < *(_DWORD *)(a1 + 4) )
  {
    do
    {
      v2 = *(_DWORD *)(a1 + 8);
      if ( *result < v2 )
        *result += v2;
      result = (unsigned int *)((char *)result + 6);
    }
    while ( (unsigned int)result < *(_DWORD *)(a1 + 4) );
  }
  return result;
}

//----- (00085B20) --------------------------------------------------------
int __cdecl sub_85B20(_BYTE *a1, _WORD *a2, unsigned __int16 a3)
{
  _BYTE *v3; // esi
  _WORD *v4; // edi
  int result; // eax
  __int16 v6; // bx
  signed __int16 v7; // cx
  __int16 v8; // ax
  _BYTE *v9; // esi
  _WORD *v10; // edi
  signed __int16 v11; // cx
  __int16 v12; // ax
  _BYTE *v13; // esi
  _WORD *v14; // edi
  signed int v15; // ecx
  _BYTE *v16; // [esp-14h] [ebp-1Ch]
  int v17; // [esp+4h] [ebp-4h]

  v3 = a1;
  v4 = a2;
  if ( word_180660 & 1 )
  {
    sub_9A128(a1, a2, 0xC8u);
    result = v17;
  }
  else
  {
    v6 = a3 >> 1;
    do
    {
      v16 = v3;
      v7 = 40;
      do
      {
        LOBYTE(v8) = *v3;
        v9 = v3 + 1;
        HIBYTE(v8) = v8;
        *v4 = v8;
        v10 = v4 + 1;
        LOBYTE(v8) = *v9++;
        HIBYTE(v8) = v8;
        *v10 = v8;
        ++v10;
        LOBYTE(v8) = *v9++;
        HIBYTE(v8) = v8;
        *v10 = v8;
        ++v10;
        LOBYTE(v8) = *v9++;
        HIBYTE(v8) = v8;
        *v10 = v8;
        ++v10;
        LOBYTE(v8) = *v9++;
        HIBYTE(v8) = v8;
        *v10 = v8;
        ++v10;
        LOBYTE(v8) = *v9++;
        HIBYTE(v8) = v8;
        *v10 = v8;
        ++v10;
        LOBYTE(v8) = *v9++;
        HIBYTE(v8) = v8;
        *v10 = v8;
        ++v10;
        LOBYTE(v8) = *v9;
        v3 = v9 + 1;
        HIBYTE(v8) = v8;
        *v10 = v8;
        v4 = v10 + 1;
        --v7;
      }
      while ( v7 );
      v3 = v16;
      v11 = 40;
      do
      {
        LOBYTE(v12) = *v3;
        v13 = v3 + 1;
        HIBYTE(v12) = v12;
        *v4 = v12;
        v14 = v4 + 1;
        LOBYTE(v12) = *v13++;
        HIBYTE(v12) = v12;
        *v14 = v12;
        ++v14;
        LOBYTE(v12) = *v13++;
        HIBYTE(v12) = v12;
        *v14 = v12;
        ++v14;
        LOBYTE(v12) = *v13++;
        HIBYTE(v12) = v12;
        *v14 = v12;
        ++v14;
        LOBYTE(v12) = *v13++;
        HIBYTE(v12) = v12;
        *v14 = v12;
        ++v14;
        LOBYTE(v12) = *v13++;
        HIBYTE(v12) = v12;
        *v14 = v12;
        ++v14;
        LOBYTE(v12) = *v13++;
        HIBYTE(v12) = v12;
        *v14 = v12;
        ++v14;
        LOBYTE(v12) = *v13;
        v3 = v13 + 1;
        HIBYTE(v12) = v12;
        *v14 = v12;
        v4 = v14 + 1;
        --v11;
      }
      while ( v11 );
      --v6;
    }
    while ( v6 );
    if ( a2 != (_WORD *)&loc_A0000 && a3 >= 0x190u )
    {
      v15 = 12800;
      do
      {
        *(_DWORD *)v4 = 0;
        v4 += 2;
        --v15;
      }
      while ( v15 );
    }
    result = v17;
  }
  return result;
}
// 180660: using guessed type __int16 word_180660;

//----- (00085BF5) --------------------------------------------------------
int __cdecl sub_85BF5(_BYTE *a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // esi
  _BYTE *v7; // edi
  int v8; // edx
  int v9; // ecx
  int v11; // [esp+4h] [ebp-4h]

  v6 = a1;
  v7 = (_BYTE *)(a3 + 640 * a4 + a2);
  v8 = a6;
  do
  {
    v9 = a5;
    do
    {
      if ( *v6 && *v6 != -1 )
      {
        *v7++ = *v6++;
      }
      else
      {
        ++v6;
        ++v7;
      }
      --v9;
    }
    while ( v9 );
    v7 = &v7[-a5 + 640];
    --v8;
  }
  while ( v8 );
  return v11;
}

//----- (00085C42) --------------------------------------------------------
int __cdecl sub_85C42(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6)
{
  unsigned __int8 *v6; // edi
  int v7; // edx
  int v8; // ecx
  int v10; // [esp+4h] [ebp-4h]

  v6 = (unsigned __int8 *)(a2 + 640 * a3 + a1);
  v7 = a5;
  do
  {
    v8 = a4;
    do
    {
      if ( *v6 >= a6 )
        *v6 = 0;
      ++v6;
      --v8;
    }
    while ( v8 );
    v6 = &v6[-a4 + 640];
    --v7;
  }
  while ( v7 );
  return v10;
}

//----- (00085C8B) --------------------------------------------------------
void __cdecl sub_85C8B(int a1, char *a2, int a3, int a4, int a5, int a6)
{
  int v6; // edx
  char *v7; // edi
  char *v8; // esi

  v6 = a6;
  v7 = a2;
  v8 = (char *)(a3 + 1280 * a4 + a1);
  do
  {
    qmemcpy(v7, v8, 4 * a5);
    v7 += 4 * a5;
    v8 += 4 * a5 + 640;
    --v6;
  }
  while ( v6 );
}

//----- (00085CC3) --------------------------------------------------------
void __usercall __spoils<ecx> sub_85CC3(unsigned int a1@<eax>, int a2@<ebx>, unsigned __int16 *a3)
{
  unsigned __int16 *v3; // esi
  char *v4; // edi
  int v5; // edx
  unsigned __int16 *v6; // ST04_4
  __int16 v7; // ST02_2
  char *v8; // esi
  char v9; // al
  int v10; // edx
  unsigned int v11; // ecx
  _BYTE *v12; // edi
  _BYTE *v13; // ebx
  char v14; // al
  int v15; // [esp-1Eh] [ebp-2Eh]
  __int16 v16; // [esp-1Ah] [ebp-2Ah]
  int v17; // [esp+0h] [ebp-10h]
  int v18; // [esp+4h] [ebp-Ch]
  _BYTE *v19; // [esp+8h] [ebp-8h]
  int v20; // [esp+Ch] [ebp-4h]

  v3 = a3;
  v4 = (char *)dword_180628;
  v19 = (_BYTE *)(dword_180628 + 306560);
  v17 = dword_180628 + 640;
  v18 = dword_180628 + 307200;
  v20 = 0;
  LOWORD(a2) = 240;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v5 = *v3;
        ++v3;
        if ( (signed __int16)v5 <= 0 )
          break;
        a1 = (unsigned __int16)v5;
        qmemcpy(v4, v3, (unsigned __int16)v5);
        v10 = (int)&v4[(unsigned __int16)v5];
        qmemcpy(v19, v3, a1);
        v19 += a1;
        v16 = a1;
        v15 = a2;
        v11 = a1;
        v12 = (_BYTE *)v17;
        v13 = (_BYTE *)v18;
        do
        {
          v14 = *(_BYTE *)v3;
          *v12 = *(_BYTE *)v3;
          *v13 = v14;
          v3 = (unsigned __int16 *)((char *)v3 + 1);
          --v12;
          --v13;
          --v11;
        }
        while ( v11 );
        v17 = (int)v12;
        v18 = (int)v13;
        v4 = (char *)v10;
        a2 = v15;
        LOWORD(a1) = v16;
      }
      if ( (v5 & 0x8000u) == 0 && !(_WORD)v5 )
        break;
      LOWORD(v5) = -(signed __int16)v5;
      v4 += (unsigned __int16)v5;
      v20 += a1 + (unsigned __int16)v5;
      v19 += (unsigned __int16)v5;
      v17 -= v5;
      v18 -= v5;
    }
    if ( (signed __int16)a2 > 221 )
    {
      v6 = v3;
      v7 = a1;
      v8 = (char *)v3 - 3;
      v9 = *v8;
      *v4 = *v8;
      *v19 = v9;
      LOWORD(a1) = v7;
      v3 = v6;
    }
    v4 = &v4[-a1 + 640 - v20];
    v19 = &v19[-a1 - 640 - v20];
    v17 += v20 + a1 + 640;
    v18 = v20 + a1 + v18 - 640;
    v20 = 0;
    LOWORD(a2) = a2 - 1;
  }
  while ( (_WORD)a2 );
}
// 180628: using guessed type int dword_180628;

//----- (00085E40) --------------------------------------------------------
signed __int16 sub_85E40()
{
  signed __int16 result; // ax

  if ( word_E2A24 )
    return 1;
  dword_17FF10 = 4096;
  dword_17FF0C = 256;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  word_E2A24 = dword_17FF0C;
  word_17FF5A = word_17FF18;
  LOBYTE(result) = dword_17FF24 == 0;
  HIBYTE(result) = 0;
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A24: using guessed type __int16 word_E2A24;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF18: using guessed type __int16 word_17FF18;
// 17FF24: using guessed type int dword_17FF24;
// 17FF5A: using guessed type __int16 word_17FF5A;

//----- (00085EB0) --------------------------------------------------------
__int16 __cdecl sub_85EB0(__int16 a1)
{
  __int16 result; // ax

  LOWORD(dword_17FF10) = a1;
  LOWORD(dword_17FF0C) = 256;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  if ( dword_17FF24 )
    result = 0;
  else
    result = dword_17FF0C;
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF24: using guessed type int dword_17FF24;

//----- (00085F00) --------------------------------------------------------
__int16 __cdecl sub_85F00(__int16 a1)
{
  __int16 result; // ax

  word_17FF18 = a1;
  LOWORD(dword_17FF0C) = 256;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  if ( dword_17FF24 )
    printf(aFdmErrorFreein);
  LOBYTE(result) = dword_17FF24 == 0;
  HIBYTE(result) = 0;
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF18: using guessed type __int16 word_17FF18;
// 17FF24: using guessed type int dword_17FF24;

//----- (00085F60) --------------------------------------------------------
int __cdecl sub_85F60(int a1)
{
  return 75 * BYTE1(a1) + 4500 * BYTE2(a1) + (unsigned __int8)a1;
}

//----- (00085FD0) --------------------------------------------------------
bool sub_85FD0()
{
  __int16 v0; // ax

  dword_E2A6C = sub_85EB0(2);
  v0 = sub_85EB0(256);
  dword_E2A70 = v0;
  return dword_E2A6C && v0;
}
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;

//----- (00086010) --------------------------------------------------------
int sub_86010()
{
  dword_17FF38 = 0;
  dword_17FF44 = 5376;
  dword_17FF0C = 768;
  dword_17FF10 = 47;
  dword_17FF14 = 0;
  dword_17FF20 = (int)&unk_17FF28;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  word_1803EA = dword_17FF38;
  word_1803EC = dword_17FF40;
  return dword_17FF38;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 1803EA: using guessed type __int16 word_1803EA;
// 1803EC: using guessed type __int16 word_1803EC;

//----- (00086180) --------------------------------------------------------
__int16 __cdecl sub_86180(unsigned __int16 a1)
{
  int v1; // ecx
  __int16 result; // ax
  char *v3; // esi
  int v4; // ebx
  __int16 v5; // ax

  if ( !dword_E2A6C )
    return 0;
  v1 = dword_E2A70;
  if ( !dword_E2A70 )
    return 0;
  v3 = (char *)(16 * dword_E2A6C);
  *v3 = 26;
  v3[1] = 0;
  v3[2] = 3;
  *(_WORD *)(v3 + 3) = 0;
  v3[13] = 0;
  *((_WORD *)v3 + 9) = 5;
  *((_WORD *)v3 + 10) = 0;
  *(_DWORD *)(v3 + 22) = 0;
  v4 = 16 * v1;
  *(_DWORD *)(v3 + 14) = v1 << 16;
  v5 = dword_E2A6C;
  *(_BYTE *)(16 * v1) = 6;
  word_17FF4A = v5;
  dword_17FF38 = 0;
  dword_17FF10 = 47;
  dword_17FF14 = 0;
  dword_17FF40 = a1;
  dword_17FF44 = 5392;
  dword_17FF0C = 768;
  dword_17FF20 = (int)&unk_17FF28;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  qmemcpy(&unk_1803C0, v3, 0x1Au);
  result = word_1803C3;
  unk_180498 = *(_DWORD *)v4;
  *((_BYTE *)&unk_180498 + 4) = *(_BYTE *)(v4 + 4);
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 17FF4A: using guessed type __int16 word_17FF4A;
// 1803C3: using guessed type __int16 word_1803C3;

//----- (00086270) --------------------------------------------------------
__int16 __cdecl sub_86270(unsigned __int16 a1)
{
  int v1; // ecx
  __int16 result; // ax
  char *v3; // esi
  int v4; // ebx

  if ( !dword_E2A6C )
    return 0;
  v1 = dword_E2A70;
  if ( !dword_E2A70 )
    return 0;
  v3 = (char *)(16 * dword_E2A6C);
  *v3 = 26;
  v3[1] = 0;
  v3[2] = 3;
  *(_WORD *)(v3 + 3) = 0;
  v3[13] = 0;
  *((_WORD *)v3 + 9) = 7;
  *((_WORD *)v3 + 10) = 0;
  *(_DWORD *)(v3 + 22) = 0;
  v4 = 16 * v1;
  *(_DWORD *)(v3 + 14) = v1 << 16;
  *(_BYTE *)(16 * v1) = 10;
  word_17FF58 = 0;
  word_17FF56 = 0;
  word_17FF4A = dword_E2A6C;
  dword_17FF38 = 0;
  dword_17FF14 = 0;
  dword_17FF10 = 47;
  dword_17FF40 = a1;
  dword_17FF44 = 5392;
  dword_17FF0C = 768;
  dword_17FF20 = (int)&unk_17FF28;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  qmemcpy(&unk_1803C0, v3, 0x1Au);
  result = word_1803C3;
  unk_180470 = *(_DWORD *)v4;
  *((_WORD *)&unk_180470 + 2) = *(_WORD *)(v4 + 4);
  *((_BYTE *)&unk_180470 + 6) = *(_BYTE *)(v4 + 6);
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 17FF4A: using guessed type __int16 word_17FF4A;
// 17FF56: using guessed type __int16 word_17FF56;
// 17FF58: using guessed type __int16 word_17FF58;
// 1803C3: using guessed type __int16 word_1803C3;

//----- (00086370) --------------------------------------------------------
__int16 __cdecl sub_86370(unsigned __int16 a1, char a2)
{
  int v2; // ecx
  __int16 result; // ax
  char *v4; // esi
  int v5; // ebx

  if ( !dword_E2A6C )
    return 0;
  v2 = dword_E2A70;
  if ( !dword_E2A70 )
    return 0;
  v4 = (char *)(16 * dword_E2A6C);
  *v4 = 26;
  v4[1] = 0;
  v4[2] = 3;
  *(_WORD *)(v4 + 3) = 0;
  v4[13] = 0;
  *((_WORD *)v4 + 9) = 7;
  *((_WORD *)v4 + 10) = 0;
  *(_DWORD *)(v4 + 22) = 0;
  v5 = 16 * v2;
  *(_DWORD *)(v4 + 14) = v2 << 16;
  *(_BYTE *)v5 = 11;
  *(_BYTE *)(v5 + 1) = a2;
  dword_17FF38 = 0;
  dword_17FF10 = 47;
  word_17FF4A = dword_E2A6C;
  dword_17FF14 = 0;
  dword_17FF40 = a1;
  dword_17FF44 = 5392;
  dword_17FF0C = 768;
  dword_17FF20 = (int)&unk_17FF28;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  qmemcpy(&unk_1803C0, v4, 0x1Au);
  result = word_1803C3;
  unk_180484 = *(_DWORD *)v5;
  *((_WORD *)&unk_180484 + 2) = *(_WORD *)(v5 + 4);
  *((_BYTE *)&unk_180484 + 6) = *(_BYTE *)(v5 + 6);
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 17FF4A: using guessed type __int16 word_17FF4A;
// 1803C3: using guessed type __int16 word_1803C3;

//----- (00086460) --------------------------------------------------------
__int16 __cdecl sub_86460(unsigned __int16 a1)
{
  int v1; // ecx
  __int16 result; // ax
  char *v3; // esi
  int v4; // ebx
  __int16 v5; // ax

  if ( !dword_E2A6C )
    return 0;
  v1 = dword_E2A70;
  if ( !dword_E2A70 )
    return 0;
  v3 = (char *)(16 * dword_E2A6C);
  *v3 = 26;
  v3[1] = 0;
  v3[2] = 3;
  *(_WORD *)(v3 + 3) = 0;
  v3[13] = 0;
  *((_WORD *)v3 + 9) = 11;
  *((_WORD *)v3 + 10) = 0;
  *(_DWORD *)(v3 + 22) = 0;
  v4 = 16 * v1;
  *(_DWORD *)(v3 + 14) = v1 << 16;
  v5 = dword_E2A6C;
  *(_BYTE *)(16 * v1) = 12;
  word_17FF4A = v5;
  dword_17FF38 = 0;
  dword_17FF10 = 47;
  dword_17FF14 = 0;
  dword_17FF40 = a1;
  dword_17FF44 = 5392;
  dword_17FF0C = 768;
  dword_17FF20 = (int)&unk_17FF28;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  qmemcpy(&unk_1803C0, v3, 0x1Au);
  result = word_1803C3;
  unk_18048B = *(_DWORD *)v4;
  *((_DWORD *)&unk_18048B + 1) = *(_DWORD *)(v4 + 4);
  *((_WORD *)&unk_18048B + 4) = *(_WORD *)(v4 + 8);
  *((_BYTE *)&unk_18048B + 10) = *(_BYTE *)(v4 + 10);
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 17FF4A: using guessed type __int16 word_17FF4A;
// 1803C3: using guessed type __int16 word_1803C3;

//----- (00086550) --------------------------------------------------------
int sub_86550()
{
  dword_17FF38 = 0;
  dword_17FF44 = 5388;
  dword_17FF0C = 768;
  dword_17FF10 = 47;
  dword_17FF14 = 0;
  dword_17FF20 = (int)&unk_17FF28;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  return dword_17FF38;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF44: using guessed type int dword_17FF44;

//----- (00086780) --------------------------------------------------------
char __cdecl sub_86780(unsigned __int16 a1, int a2, int a3)
{
  char *v4; // esi

  if ( !byte_E2A28 )
    return 0;
  if ( !dword_E2A6C || !dword_E2A70 )
    return 0;
  v4 = (char *)(16 * dword_E2A70);
  *v4 = 22;
  v4[1] = 0;
  v4[2] = -124;
  *(_WORD *)(v4 + 3) = 0;
  v4[13] = 0;
  *(_DWORD *)(v4 + 14) = a2;
  *(_DWORD *)(v4 + 18) = a3;
  dword_17FF38 = 0;
  dword_17FF10 = 47;
  dword_17FF14 = 0;
  word_17FF4A = dword_E2A70;
  dword_17FF20 = (int)&unk_17FF28;
  dword_17FF40 = a1;
  dword_17FF0C = 768;
  dword_17FF44 = 5392;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  qmemcpy(&unk_1803A8, v4, 0x16u);
  return word_1803AB;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A28: using guessed type char byte_E2A28;
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 17FF4A: using guessed type __int16 word_17FF4A;
// 1803AB: using guessed type __int16 word_1803AB;

//----- (00086860) --------------------------------------------------------
char __cdecl sub_86860(unsigned __int16 a1)
{
  int v2; // esi
  __int16 v3; // ax

  if ( !byte_E2A28 )
    return 0;
  if ( !dword_E2A6C || !dword_E2A70 )
    return 0;
  v2 = 16 * dword_E2A70;
  *(_BYTE *)v2 = 13;
  v3 = dword_E2A70;
  *(_BYTE *)(v2 + 1) = 0;
  *(_BYTE *)(v2 + 2) = -123;
  *(_WORD *)(v2 + 3) = 0;
  word_17FF4A = v3;
  dword_17FF38 = 0;
  dword_17FF10 = 47;
  dword_17FF14 = 0;
  dword_17FF20 = (int)&unk_17FF28;
  dword_17FF40 = a1;
  dword_17FF0C = 768;
  dword_17FF44 = 5392;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  unk_180452 = *(_DWORD *)v2;
  v2 += 4;
  *((_DWORD *)&unk_180452 + 1) = *(_DWORD *)v2;
  v2 += 4;
  *((_DWORD *)&unk_180452 + 2) = *(_DWORD *)v2;
  *((_BYTE *)&unk_180452 + 12) = *(_BYTE *)(v2 + 4);
  return word_180455;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A28: using guessed type char byte_E2A28;
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 17FF4A: using guessed type __int16 word_17FF4A;
// 180455: using guessed type __int16 word_180455;

//----- (00086930) --------------------------------------------------------
char __cdecl sub_86930(unsigned __int16 a1)
{
  int v2; // esi
  __int16 v3; // ax

  if ( !byte_E2A28 )
    return 0;
  if ( !dword_E2A6C || !dword_E2A70 )
    return 0;
  v2 = 16 * dword_E2A70;
  *(_BYTE *)v2 = 13;
  v3 = dword_E2A70;
  *(_BYTE *)(v2 + 1) = 0;
  *(_BYTE *)(v2 + 2) = -120;
  *(_WORD *)(v2 + 3) = 0;
  word_17FF4A = v3;
  dword_17FF38 = 0;
  dword_17FF10 = 47;
  dword_17FF14 = 0;
  dword_17FF20 = (int)&unk_17FF28;
  dword_17FF40 = a1;
  dword_17FF0C = 768;
  dword_17FF44 = 5392;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  unk_180460 = *(_DWORD *)v2;
  v2 += 4;
  *((_DWORD *)&unk_180460 + 1) = *(_DWORD *)v2;
  v2 += 4;
  *((_DWORD *)&unk_180460 + 2) = *(_DWORD *)v2;
  *((_BYTE *)&unk_180460 + 12) = *(_BYTE *)(v2 + 4);
  return word_180463;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A28: using guessed type char byte_E2A28;
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 17FF4A: using guessed type __int16 word_17FF4A;
// 180463: using guessed type __int16 word_180463;

//----- (00086A00) --------------------------------------------------------
_BOOL1 sub_86A00()
{
  _BOOL2 v0; // ax
  int v1; // ebx
  unsigned __int16 v2; // bx
  int v3; // esi
  int v4; // ST04_4
  signed __int16 v5; // bx
  unsigned __int16 i; // ax
  int v7; // edi
  unsigned __int16 v8; // bx
  int v9; // eax
  unsigned __int16 v10; // bx
  int v11; // esi
  int v12; // eax
  unsigned __int16 v13; // ax
  int v14; // edx
  int v15; // ecx

  sub_85E40();
  v0 = sub_85FD0();
  if ( v0 )
  {
    if ( sub_86010() )
    {
      sub_86550();
      v1 = 0;
      while ( (((unsigned __int16)sub_86270(word_1803EC) >> 8) & 0x80u) != 0 )
      {
        j___delay(1000);
        if ( (_WORD)++v1 == 4 )
        {
          LOBYTE(v0) = sub_86BD0();
          return v0;
        }
      }
      byte_1804A1 = byte_180471;
      v2 = (unsigned __int8)byte_180471;
      byte_18049E = byte_180472;
      while ( v2 <= (signed int)(unsigned __int8)byte_180472 )
      {
        sub_86370(word_1803EC, v2);
        v3 = v2;
        v4 = dword_180486;
        byte_1803EE[v2++] = (byte_18048A & 0x40) == 0;
        dword_180084[v3] = sub_85F60(v4);
      }
      v5 = 0;
      for ( i = (unsigned __int8)byte_180471; i <= (signed int)(unsigned __int8)byte_180472; ++i )
      {
        if ( byte_1803EE[i] )
          v5 = 1;
      }
      if ( v5 )
      {
        v7 = dword_180088[0];
        v8 = (unsigned __int8)byte_180471;
        while ( 1 )
        {
          v9 = v8;
          if ( v8 > (signed int)(unsigned __int8)byte_180472 )
            break;
          ++v8;
          dword_180084[v9] -= v7;
        }
        v10 = (unsigned __int8)byte_180471;
        while ( v10 <= (signed int)(unsigned __int8)byte_180472 )
        {
          v11 = v10;
          if ( v10 == (unsigned __int8)byte_180472 )
            v12 = sub_85F60(dword_180473) - v7;
          else
            v12 = dword_180088[v11];
          dword_180214[v11] = v12;
          v13 = v10;
          v14 = dword_180084[v10];
          v15 = dword_180214[v10++];
          dword_180214[v13] = v15 - v14;
        }
        LOBYTE(v0) = sub_86460(word_1803EC);
        byte_E2A28 = 1;
      }
      else
      {
        LOBYTE(v0) = sub_86BD0();
      }
    }
    else
    {
      LOBYTE(v0) = sub_86BD0();
    }
  }
  return v0;
}
// 9A122: using guessed type _DWORD __cdecl j___delay(_DWORD);
// E2A28: using guessed type char byte_E2A28;
// 180084: using guessed type int dword_180084[];
// 180088: using guessed type int dword_180088[];
// 1803EC: using guessed type __int16 word_1803EC;
// 180471: using guessed type char byte_180471;
// 180472: using guessed type char byte_180472;
// 180473: using guessed type int dword_180473;
// 180486: using guessed type int dword_180486;
// 18048A: using guessed type char byte_18048A;
// 18049E: using guessed type char byte_18049E;
// 1804A1: using guessed type char byte_1804A1;

//----- (00086BD0) --------------------------------------------------------
char sub_86BD0()
{
  char result; // al

  if ( dword_E2A6C )
    result = sub_85F00(dword_E2A6C);
  if ( dword_E2A70 )
    result = sub_85F00(dword_E2A70);
  byte_E2A28 = 0;
  dword_E2A6C = 0;
  dword_E2A70 = 0;
  return result;
}
// E2A28: using guessed type char byte_E2A28;
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;

//----- (00086EA0) --------------------------------------------------------
int __fastcall sub_86EA0(int a1, int a2, int a3)
{
  sub_47760(a1, a2, a3);
  return 0;
}

//----- (00086EB0) --------------------------------------------------------
void __cdecl sub_86EB0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int v3; // eax
  unsigned __int8 v4; // dl
  int v5; // eax
  __int16 v6; // bx
  __int16 v7; // ax

  v3 = 42 * a1;
  v4 = byte_DB080[v3];
  v5 = 4 * a2 + v3;
  v6 = *(__int16 *)((char *)word_DB082 + v5);
  v7 = *(__int16 *)((char *)word_DB084 + v5);
  if ( v4 && v7 )
  {
    if ( a3 )
      sub_86F70(v4, v6, v7);
    else
      sub_86FF0(v4, v6, v7);
  }
}
// DB082: using guessed type __int16 word_DB082[];
// DB084: using guessed type __int16 word_DB084[];

//----- (00086F20) --------------------------------------------------------
void __cdecl sub_86F20(char a1)
{
  int v1; // eax
  unsigned __int8 v2; // dl
  __int16 v3; // bx
  __int16 v4; // ax

  v1 = 21 * ((a1 != 0) + 25);
  v2 = byte_DB080[v1 * 2];
  v3 = word_DB082[v1];
  v4 = word_DB084[v1];
  if ( v2 )
  {
    if ( v4 )
      sub_86F70(v2, v3, v4);
  }
}
// DB082: using guessed type __int16 word_DB082[];
// DB084: using guessed type __int16 word_DB084[];

//----- (00086F70) --------------------------------------------------------
void __cdecl sub_86F70(unsigned __int8 a1, __int16 a2, __int16 a3)
{
  if ( byte_E2A28 && (byte_E37FC || byte_E3798) )
  {
    dword_180078 = sub_92600((int)sub_86EA0);
    sub_92930(dword_180078, 0x32u);
    sub_92BA0(dword_180078);
    sub_86FF0(a1, a2, a3);
    sub_92DC0(dword_180078);
  }
}
// E2A28: using guessed type char byte_E2A28;
// E3798: using guessed type char byte_E3798;
// E37FC: using guessed type char byte_E37FC;
// 180078: using guessed type int dword_180078;

//----- (00086FF0) --------------------------------------------------------
void __cdecl sub_86FF0(unsigned __int8 a1, __int16 a2, __int16 a3)
{
  if ( byte_E2A28 && (byte_E37FC || byte_E3798) )
  {
    word_1803E8 = a1;
    sub_86860(word_1803EC);
    if ( (unsigned __int16)word_1803E8 >= (signed int)(unsigned __int8)byte_1804A1
      && (unsigned __int16)word_1803E8 <= (signed int)(unsigned __int8)byte_18049E )
    {
      if ( byte_1803EE[(unsigned __int16)word_1803E8] )
        sub_86780(word_1803EC, dword_180084[(unsigned __int16)word_1803E8] + a2, a3);
    }
  }
}
// E2A28: using guessed type char byte_E2A28;
// E3798: using guessed type char byte_E3798;
// E37FC: using guessed type char byte_E37FC;
// 180084: using guessed type int dword_180084[];
// 1803E8: using guessed type __int16 word_1803E8;
// 1803EA: using guessed type __int16 word_1803EA;
// 1803EC: using guessed type __int16 word_1803EC;
// 18049E: using guessed type char byte_18049E;
// 1804A1: using guessed type char byte_1804A1;

//----- (00087090) --------------------------------------------------------
char sub_87090()
{
  signed int i; // edx
  char result; // al
  void **v2; // eax
  int v3; // edx

  memset(&unk_1804B0, 0, 171);
  for ( i = 1; i < 120 && !dword_180516; ++i )
  {
    if ( !word_E2A74[15 * i] )
      dword_180516 = i - 1;
  }
  result = sub_871E0();
  if ( result )
  {
    byte_180552 = 1;
    word_1804C0 = 8;
    word_1804C2 = 14;
    word_1804BE = 400;
    word_1804C6 = 600;
    word_1804C8 = 80;
    word_1804CA = 260;
    word_1804C4 = 40;
    qmemcpy(word_1804E3, &unk_1804B0, 0x30u);
    qmemcpy(&word_1804E3[24], (char *)&unk_1804B0 + 48, 3u);
    v2 = &off_E2A92;
    word_1804FD = 370;
    word_1804F7 = 30;
    word_1804F9 = 610;
    word_1804FB = 30;
    v3 = 0;
    while ( v3 < dword_180516 )
    {
      v2[4] = v2[6];
      if ( !*((_BYTE *)v2 + 29) )
        *((_BYTE *)v2 + 29) = *((_BYTE *)v2 + 28);
      v2 = (void **)((char *)v2 + 30);
      *(void **)((char *)v2 - 18) = 0;
      ++v3;
      *(void **)((char *)v2 - 10) = 0;
    }
    dword_180532 = *(_DWORD *)(dword_D41A0 + 8);
    result = sub_88B20();
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// E2A74: using guessed type __int16 word_E2A74[];
// E2A92: using guessed type void *off_E2A92;
// 1804BE: using guessed type __int16 word_1804BE;
// 1804C0: using guessed type __int16 word_1804C0;
// 1804C2: using guessed type __int16 word_1804C2;
// 1804C4: using guessed type __int16 word_1804C4;
// 1804C6: using guessed type __int16 word_1804C6;
// 1804C8: using guessed type __int16 word_1804C8;
// 1804CA: using guessed type __int16 word_1804CA;
// 1804F7: using guessed type __int16 word_1804F7;
// 1804F9: using guessed type __int16 word_1804F9;
// 1804FB: using guessed type __int16 word_1804FB;
// 1804FD: using guessed type __int16 word_1804FD;
// 180516: using guessed type int dword_180516;
// 180532: using guessed type int dword_180532;
// 180552: using guessed type char byte_180552;

//----- (000871E0) --------------------------------------------------------
char sub_871E0()
{
  return 1;
}

//----- (000871F0) --------------------------------------------------------
int sub_871F0()
{
  void **v0; // eax
  char v1; // bl
  int v2; // eax
  int v4; // eax

  v0 = (void **)sub_872A0();
  BYTE1(v0) = word_18054E;
  v1 = 1;
  if ( word_18054E & 0x10 )
  {
    v0 = (void **)sub_87C10();
  }
  else
  {
    if ( word_18054E & 0x2000 || word_18054E & 0x1000 )
      v1 = 0;
    if ( word_18054E & 2 || word_18054E & 0x800 )
      v1 = 1;
    if ( v1 )
    {
      if ( word_180536 )
      {
        sub_87610();
        sub_87B30();
      }
      else if ( --dword_180522 <= 0 )
      {
        sub_87580();
      }
      v0 = sub_87B70();
    }
    else
    {
      if ( word_18054E & 0x1000 )
      {
        v2 = sub_87A30();
        return _wcpp_1_unwind_leave__132(v2);
      }
      if ( word_18054E & 0x2000 )
      {
        v4 = sub_87860();
        return _wcpp_1_unwind_leave__132(v4);
      }
    }
  }
  return _wcpp_1_unwind_leave__132(v0);
}
// 87BD0: using guessed type int __fastcall _wcpp_1_unwind_leave__132(_DWORD);
// 180522: using guessed type int dword_180522;
// 180536: using guessed type __int16 word_180536;
// 18054E: using guessed type __int16 word_18054E;

//----- (000872A0) --------------------------------------------------------
int sub_872A0()
{
  int v0; // edx
  unsigned __int8 v1; // al
  int v2; // esi
  char v3; // dh
  int v4; // ebx
  int v5; // edx
  int v6; // ebx
  int v7; // eax
  char v8; // cl
  char v9; // bh
  int result; // eax
  char v11; // ch
  __int16 v12; // cx
  int v13; // ebx

  v0 = 2124 * *(signed __int16 *)(dword_D41A0 + 12);
  v1 = *(_BYTE *)(v0 + dword_D41A0 + 12221);
  v2 = dword_EA3E4[*(unsigned __int16 *)(v0 + dword_D41A0 + 11240)];
  if ( v1 < 6u || v1 > 8u )
    LOBYTE(word_18054E) = word_18054E & 0xFA;
  else
    LOBYTE(word_18054E) = word_18054E | 5;
  word_18054E &= 0xC7FDu;
  v3 = *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221);
  if ( v3 != 5 && v3 != 8 )
  {
    dword_18051E = 20;
    byte_180554 = 0;
    byte_180555 = -1;
  }
  else
  {
    LOBYTE(word_18054E) = word_18054E | 2;
    v4 = *(_DWORD *)(v2 + 164);
    dword_18051E = 6;
    v5 = *(char *)(v4 + 1112);
    v6 = v4 + 611;
    if ( v5 != (unsigned __int8)byte_180555 || *(char *)(v6 + 502) != (unsigned __int8)byte_180556 )
    {
      v7 = (unsigned __int8)byte_D94FF[*(char *)(v6 + 501)];
      if ( (unsigned __int8)byte_180554 > 1u || !*(_WORD *)(v6 + 2 * v7 + 208) || !byte_D41B6 && v7 == 25 )
        sub_87C10();
      byte_180554 = 0;
      sub_88D40();
      dword_180526 = 0;
    }
    byte_180555 = *(_BYTE *)(v6 + 501);
    byte_180556 = *(_BYTE *)(v6 + 502);
  }
  if ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) == 7 )
  {
    HIBYTE(word_18054E) |= 8u;
  }
  else if ( word_E2A74[15 * word_180536] == 12 )
  {
    sub_87C10();
  }
  if ( *(_BYTE *)(dword_D41A4 + 24) & 1 )
    HIBYTE(word_18054E) |= 0x20u;
  if ( *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) == 3 )
    HIBYTE(word_18054E) |= 0x10u;
  if ( *(_WORD *)(v2 + 130) )
    dword_18053A = 0;
  else
    ++dword_18053A;
  v8 = HIBYTE(word_18054E) & 0xFB;
  HIBYTE(word_18054E) &= 0xFBu;
  if ( *(_BYTE *)(v2 + 69) == 3 )
    HIBYTE(word_18054E) = v8 | 4;
  LOBYTE(word_18054E) = word_18054E & 0xEF;
  if ( *(_BYTE *)(dword_D41A0 + 224772)
    || *(_BYTE *)(dword_D41A4 + 225)
    || (v9 = *(_BYTE *)(v2 + 69), v9 == 12)
    || v9 == 11
    || (result = 2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0, v11 = *(_BYTE *)(result + 12221), v11 == 13)
    || v11 == 14 )
  {
    result = dword_18051E;
    dword_180522 = dword_18051E;
    LOBYTE(word_18054E) = word_18054E | 0x10;
  }
  if ( word_180536 )
  {
    result = 30 * word_180536;
    v12 = *(__int16 *)((char *)word_E2A74 + result);
    if ( v12 == 2 || v12 == 8 )
    {
      if ( !(word_18054E & 0x200)
        || (result = 30 * word_180536, byte_E2A76[30 * word_180536] >= 0)
        && ((v13 = *(int *)((char *)&dword_E2A80 + result)) == 0
         || (result = *(int *)((char *)&dword_E2A80 + result), *(_DWORD *)(v13 + 8) < 0)
         || *(_BYTE *)(v13 + 13) & 4) )
      {
        result = sub_87C10();
      }
    }
    if ( *(_BYTE *)(v2 + 69) == 2 )
      result = sub_87C10();
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// E2A74: using guessed type __int16 word_E2A74[];
// E2A80: using guessed type int dword_E2A80;
// EA3E4: using guessed type int dword_EA3E4[];
// 18051E: using guessed type int dword_18051E;
// 180522: using guessed type int dword_180522;
// 180526: using guessed type int dword_180526;
// 180536: using guessed type __int16 word_180536;
// 18053A: using guessed type int dword_18053A;
// 18054C: using guessed type __int16 word_18054C;
// 18054E: using guessed type __int16 word_18054E;
// 180554: using guessed type char byte_180554;
// 180555: using guessed type char byte_180555;
// 180556: using guessed type char byte_180556;

//----- (00087580) --------------------------------------------------------
void sub_87580()
{
  int v0; // eax

  sub_87BE0();
  if ( word_18054E & 0x400 )
  {
    sub_884D0(91, 1, (int)&unk_E3522, 1, 0);
  }
  else if ( word_18054E & 2 )
  {
    sub_88D40();
  }
  else if ( word_18054E & 0x800 )
  {
    sub_89360();
  }
  else
  {
    sub_87CF0();
    v0 = sub_88450();
    sub_884D0(v0, 1, (int)&word_E2A74[15 * v0 + 2], ((byte_E2A76[30 * v0] & 4) == 0) + 1, 0);
  }
}
// E2A74: using guessed type __int16 word_E2A74[];
// 18054E: using guessed type __int16 word_18054E;

//----- (00087610) --------------------------------------------------------
char sub_87610()
{
  const char *v0; // edi
  __int16 *v1; // esi
  char result; // al
  __int16 v3; // ax
  signed int v4; // esi
  int v5; // edi
  unsigned __int8 v6; // al
  _BYTE *v7; // ST04_4
  char v8; // [esp+0h] [ebp-80h]

  v0 = (const char *)dword_E9C4C[word_18053E[0]];
  v1 = &word_E2A74[15 * word_180536];
  if ( *((_BYTE *)v1 + 3) & 1 )
  {
    v0 = &v8;
    sub_89AC0(&v8, word_180536);
  }
  *((_BYTE *)&unk_1804B0 + 48) = byte_E98FF;
  *((_BYTE *)&unk_1804B0 + 49) = byte_E8900[0];
  *((_BYTE *)&unk_1804B0 + 50) = byte_E9800;
  result = byte_180553;
  if ( (unsigned __int8)byte_180553 >= 2u )
  {
    if ( (unsigned __int8)byte_180553 <= 2u )
    {
      *((_WORD *)&unk_1804B0 + 14) = v1[4];
      v3 = v1[5];
      *((_WORD *)&unk_1804B0 + 6) = 220;
      *((_WORD *)&unk_1804B0 + 15) = v3;
      if ( word_18054E & 8 )
      {
        sub_89830(&unk_1804B0);
        sub_89420(&unk_1804B0, v0);
        sub_89520((signed __int16 *)&unk_1804B0);
        sub_89980((signed __int16 *)&unk_1804B0);
      }
      sub_898A0(&unk_1804B0);
      sub_2E790(
        *((_WORD *)&unk_1804B0 + 18),
        *((signed __int16 *)&unk_1804B0 + 19),
        *((signed __int16 *)&unk_1804B0 + 20),
        *((signed __int16 *)&unk_1804B0 + 21),
        *((_BYTE *)&unk_1804B0 + 49));
      sub_895D0((int)&unk_1804B0, v0);
    }
    else
    {
      if ( byte_180553 != 3 )
        goto LABEL_22;
      *((_WORD *)&unk_1804B0 + 14) = v1[4];
      *((_WORD *)&unk_1804B0 + 15) = v1[5];
      sub_89830(&unk_1804B0);
      sub_89920(&unk_1804B0, (unsigned __int8)byte_180550, (int)word_18053E);
      sub_89520((signed __int16 *)&unk_1804B0);
      sub_89980((signed __int16 *)&unk_1804B0);
      sub_898A0(&unk_1804B0);
      v4 = 0;
      sub_2E790(
        *((_WORD *)&unk_1804B0 + 18),
        *((signed __int16 *)&unk_1804B0 + 19),
        *((signed __int16 *)&unk_1804B0 + 20),
        *((signed __int16 *)&unk_1804B0 + 21),
        *((_BYTE *)&unk_1804B0 + 49));
      v5 = *((signed __int16 *)&unk_1804B0 + 5);
      while ( v4 < (unsigned __int8)byte_180550 )
      {
        if ( v4 == (unsigned __int8)byte_180551 )
          v6 = *((_BYTE *)&unk_1804B0 + 50);
        else
          v6 = *((_BYTE *)&unk_1804B0 + 48);
        v7 = (_BYTE *)dword_E9C4C[word_18053E[v4++]];
        sub_2BC10(v7, *((_WORD *)&unk_1804B0 + 4), v5, v6);
        v5 += *((signed __int16 *)&unk_1804B0 + 9);
      }
    }
    sub_89A30(&unk_1804B0);
    goto LABEL_21;
  }
  if ( byte_180553 == 1 )
  {
    if ( word_18054E & 8 )
    {
      unk_1804B0 = 320;
      *((_WORD *)&unk_1804B0 + 1) = 80;
      *((_WORD *)&unk_1804B0 + 6) = 320;
      sub_89420(&unk_1804B0, v0);
      sub_89520((signed __int16 *)&unk_1804B0);
      sub_89980((signed __int16 *)&unk_1804B0);
    }
    sub_2E790(
      *((_WORD *)&unk_1804B0 + 18),
      *((signed __int16 *)&unk_1804B0 + 19),
      *((signed __int16 *)&unk_1804B0 + 20),
      *((signed __int16 *)&unk_1804B0 + 21),
      *((_BYTE *)&unk_1804B0 + 49));
    sub_895D0((int)&unk_1804B0, v0);
LABEL_21:
    result = sub_89690((signed __int16 *)&unk_1804B0);
  }
LABEL_22:
  LOBYTE(word_18054E) = word_18054E & 0xF7;
  return result;
}
// E2A74: using guessed type __int16 word_E2A74[];
// E9800: using guessed type char byte_E9800;
// E98FF: using guessed type char byte_E98FF;
// 180536: using guessed type __int16 word_180536;
// 18054E: using guessed type __int16 word_18054E;
// 180550: using guessed type char byte_180550;
// 180551: using guessed type char byte_180551;
// 180553: using guessed type char byte_180553;

//----- (00087860) --------------------------------------------------------
int sub_87860()
{
  __int16 *v0; // eax
  const char *v1; // ebx
  __int16 v2; // dx
  int result; // eax

  if ( byte_18055A >= 0 )
  {
    sub_87970();
    v0 = &word_E2A74[15 * (byte_18055A + 86)];
    v1 = (const char *)dword_E9C4C[v0[2]];
    v2 = v0[4];
    LOWORD(v0) = v0[5];
    word_1804FF = v2;
    word_180501 = (signed __int16)v0;
    byte_180513 = byte_E98FF;
    word_1804EF = 220;
    byte_180514 = byte_E8900[0];
    sub_89830(word_1804E3);
    sub_89420(word_1804E3, v1);
    sub_89520(word_1804E3);
    sub_89980(word_1804E3);
    sub_898A0(word_1804E3);
    sub_2E790(word_180507, word_180509, word_18050B, word_18050D, byte_180514);
    sub_895D0((int)word_1804E3, v1);
    sub_89A30(word_1804E3);
    result = sub_89690(word_1804E3);
  }
  return result;
}
// E2A74: using guessed type __int16 word_E2A74[];
// E98FF: using guessed type char byte_E98FF;
// 1804EF: using guessed type __int16 word_1804EF;
// 1804FF: using guessed type __int16 word_1804FF;
// 180501: using guessed type __int16 word_180501;
// 180507: using guessed type __int16 word_180507;
// 180509: using guessed type __int16 word_180509;
// 18050B: using guessed type __int16 word_18050B;
// 18050D: using guessed type __int16 word_18050D;
// 180513: using guessed type char byte_180513;
// 180514: using guessed type char byte_180514;
// 18055A: using guessed type char byte_18055A;

//----- (00087970) --------------------------------------------------------
int sub_87970()
{
  int result; // eax
  int v1; // [esp+0h] [ebp-10h]
  int v2; // [esp+4h] [ebp-Ch]
  int v3; // [esp+8h] [ebp-8h]
  int v4; // [esp+Ch] [ebp-4h]

  sub_2FFE0(&v4, &v3, &v2, &v1);
  word_E3490 = v2 + v4 - 12;
  word_E3492 = v3 + 6;
  word_E34AE = v2 + v4 - 12;
  word_E34B0 = v1 + v3 + 6;
  word_E34CC = v4 + v2 / 2 - 12;
  word_E34CE = v3 + 2 * v1 + 6;
  word_E34EA = v2 + v4 - 12;
  word_E34EC = v3 + 2 * v1 + 6;
  word_E3508 = v2 + v4 - 12;
  result = v3 + 3 * v1 + 6;
  word_E350A = v3 + 3 * v1 + 6;
  return result;
}
// E3490: using guessed type __int16 word_E3490;
// E3492: using guessed type __int16 word_E3492;
// E34AE: using guessed type __int16 word_E34AE;
// E34B0: using guessed type __int16 word_E34B0;
// E34CC: using guessed type __int16 word_E34CC;
// E34CE: using guessed type __int16 word_E34CE;
// E34EA: using guessed type __int16 word_E34EA;
// E34EC: using guessed type __int16 word_E34EC;
// E3508: using guessed type __int16 word_E3508;
// E350A: using guessed type __int16 word_E350A;

//----- (00087A30) --------------------------------------------------------
int sub_87A30()
{
  int result; // eax
  __int16 *v1; // eax
  int v2; // ebx
  const char *v3; // ebx

  BYTE1(result) = byte_180559;
  if ( byte_180559 > 0 )
  {
    v1 = &word_E2A74[15 * byte_180559];
    v2 = v1[2];
    word_1804FF = v1[4];
    v3 = (const char *)dword_E9C4C[v2];
    word_180501 = v1[5];
    byte_180513 = byte_E98FF;
    word_1804EF = 220;
    byte_180514 = byte_E8900[0];
    sub_89830(word_1804E3);
    sub_89420(word_1804E3, v3);
    sub_89520(word_1804E3);
    sub_89980(word_1804E3);
    sub_898A0(word_1804E3);
    sub_2E790(word_180507, word_180509, word_18050B, word_18050D, byte_180514);
    sub_895D0((int)word_1804E3, v3);
    sub_89A30(word_1804E3);
    result = sub_89690(word_1804E3);
  }
  return result;
}
// E2A74: using guessed type __int16 word_E2A74[];
// E98FF: using guessed type char byte_E98FF;
// 1804EF: using guessed type __int16 word_1804EF;
// 1804FF: using guessed type __int16 word_1804FF;
// 180501: using guessed type __int16 word_180501;
// 180507: using guessed type __int16 word_180507;
// 180509: using guessed type __int16 word_180509;
// 18050B: using guessed type __int16 word_18050B;
// 18050D: using guessed type __int16 word_18050D;
// 180513: using guessed type char byte_180513;
// 180514: using guessed type char byte_180514;
// 180559: using guessed type char byte_180559;

//----- (00087B30) --------------------------------------------------------
int sub_87B30()
{
  int result; // eax

  if ( ++dword_180526 >= dword_18052A || (result = 15 * word_180536, !(byte_E2A76[30 * word_180536] & 1)) )
    result = sub_87C10();
  return result;
}
// 180526: using guessed type int dword_180526;
// 18052A: using guessed type int dword_18052A;
// 180536: using guessed type __int16 word_180536;

//----- (00087B70) --------------------------------------------------------
void **sub_87B70()
{
  void **result; // eax
  int i; // ebx
  int v2; // edx
  void *v3; // ecx
  int v4; // edx
  char v5; // dl

  result = &off_E2A92;
  for ( i = 0; i < dword_180516; result = (void **)((char *)result + 30) )
  {
    v2 = (int)result[4] + 1;
    v3 = result[6];
    result[4] = (void *)v2;
    v4 = v2 - (_DWORD)v3;
    if ( v4 > 0 && v4 > 2 * (signed int)v3 )
    {
      result[4] = result[6];
      v5 = *((_BYTE *)result + 29) + 1;
      *((_BYTE *)result + 29) = v5;
      if ( v5 < 0 )
        *((_BYTE *)result + 29) = 0;
      if ( *((_BYTE *)result + 29) > 5 )
        *((_BYTE *)result + 29) = 5;
    }
    ++i;
  }
  return result;
}
// E2A92: using guessed type void *off_E2A92;
// 180516: using guessed type int dword_180516;

//----- (00087BE0) --------------------------------------------------------
void **sub_87BE0()
{
  void **result; // eax
  int i; // edx
  char v2; // bl

  result = &off_E2A92;
  for ( i = 0; i < dword_180516; *((_BYTE *)result - 28) = v2 & 0xFE )
  {
    v2 = *((_BYTE *)result + 2);
    result = (void **)((char *)result + 30);
    ++i;
  }
  return result;
}
// E2A92: using guessed type void *off_E2A92;
// 180516: using guessed type int dword_180516;

//----- (00087C10) --------------------------------------------------------
int sub_87C10()
{
  int result; // eax
  int v1; // edx
  int v2; // eax

  result = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 10) )
  {
    dword_18051A = 0;
    word_18054E &= 0xFEDFu;
    v1 = word_180536;
    dword_180522 = dword_18051E;
    v2 = 15 * word_180536;
    byte_E2A76[2 * v2] &= 0xFDu;
    *(int *)((char *)&dword_E2A84 + 2 * v2) = 0;
    *(int *)((char *)&dword_E2A80 + 2 * v2) = 0;
    byte_E2A91[2 * v2] = byte_E2A90[2 * v2];
    result = sub_889F0(v1);
    word_180536 = 0;
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// E2A80: using guessed type int dword_E2A80;
// E2A84: using guessed type int dword_E2A84;
// 18051A: using guessed type int dword_18051A;
// 18051E: using guessed type int dword_18051E;
// 180522: using guessed type int dword_180522;
// 180536: using guessed type __int16 word_180536;
// 18054E: using guessed type __int16 word_18054E;

//----- (00087CF0) --------------------------------------------------------
int sub_87CF0()
{
  signed int v0; // ecx
  _DWORD *v1; // esi
  _WORD *v2; // edx
  unsigned __int16 v3; // bx
  int v4; // edi
  int v5; // eax
  signed int v6; // ebx
  int v7; // eax
  int v8; // eax
  void **v9; // ebx
  char v10; // ah
  char v11; // dh
  int v12; // eax
  _BOOL1 v13; // zf
  int v14; // eax
  signed __int16 v15; // bx
  _BOOL1 v16; // bl
  int v17; // edx
  int v18; // edx
  _BOOL1 v19; // al
  char v20; // al
  signed int v21; // edx
  void **v22; // ebx
  signed int v23; // edx
  void **v24; // ebx
  char v25; // ah
  int result; // eax
  signed int v27; // edx
  void **v28; // ebx
  int v29; // [esp+0h] [ebp-28h]
  bool v30; // [esp+8h] [ebp-20h]
  bool v31; // [esp+Ch] [ebp-1Ch]
  bool v32; // [esp+10h] [ebp-18h]
  signed int v33; // [esp+14h] [ebp-14h]
  int v34; // [esp+18h] [ebp-10h]
  unsigned int v35; // [esp+1Ch] [ebp-Ch]
  int v36; // [esp+20h] [ebp-8h]
  signed int v37; // [esp+24h] [ebp-4h]

  v34 = 0;
  v37 = -1;
  v0 = -1;
  v1 = (_DWORD *)dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 2124 * *(signed __int16 *)(dword_D41A0 + 12) + 11240)];
  v2 = (_WORD *)v1[41];
  v3 = v2[29];
  v4 = (int)v2 + 611;
  if ( v3 )
    v5 = dword_EA3E4[v3];
  else
    v5 = 0;
  v36 = v5;
  v6 = 0;
  v29 = 0;
  while ( v6 < 26 )
  {
    v7 = *(_WORD *)(v4 + 2 * v6++ + 208) != 0;
    v29 += v7;
  }
  if ( v29 )
  {
    v30 = *(_WORD *)((char *)v2 + 823) != 0;
    v32 = *(_WORD *)((char *)v2 + 821) != 0;
    v31 = *(_WORD *)((char *)v2 + 819) != 0;
    v0 = *(signed __int16 *)((char *)v2 + 1105);
    v37 = *(signed __int16 *)((char *)v2 + 1107);
  }
  v8 = dword_D41A0 + 11 * *(signed __int16 *)(dword_D41A0 + 12);
  if ( byte_3659C[v8] )
    v33 = -1;
  else
    v33 = *(char *)(dword_D41A0 + 10 * (unsigned __int8)byte_3659D[v8] + 222540);
  v35 = 1;
  v9 = &off_E2A92;
  while ( (signed int)v35 <= dword_180516 )
  {
    switch ( *(_WORD *)v9 )
    {
      case 1:
        if ( v35 >= 1 && (v35 <= 2 || v35 == 92) )
          goto LABEL_32;
        break;
      case 2:
        v10 = *((_BYTE *)v9 + 2);
        if ( v10 & 0x18 )
          *((_BYTE *)v9 + 2) = v10 | 1;
        break;
      case 3:
        if ( v36 )
        {
          if ( v35 != 35 )
            goto LABEL_32;
          if ( !v33 )
          {
            v12 = dword_D41A0;
            *((_BYTE *)v9 + 2) |= 1u;
            word_E2E96 = (*(unsigned __int16 *)((char *)&loc_2FED5 + v12) << 6) / 100
                       + *(unsigned __int8 *)(dword_EA3DC + 244)
                       + 60;
            word_E2E98 = 38;
          }
        }
        break;
      case 5:
      case 7:
      case 0xC:
      case 0xD:
        break;
      case 6:
        v13 = (word_18054E & 2) == 0;
        goto LABEL_31;
      case 8:
        v11 = *((_BYTE *)v9 + 2);
        if ( v11 & 0x10 || v11 & 0x40 )
          *((_BYTE *)v9 + 2) |= 1u;
        if ( *((_BYTE *)v9 + 2) & 0x40 )
          ++v34;
        break;
      default:
        v13 = v35 == 85;
LABEL_31:
        if ( !v13 )
LABEL_32:
          *((_BYTE *)v9 + 2) |= 1u;
        break;
    }
    v9 = (void **)((char *)v9 + 30);
    ++v35;
  }
  if ( word_18054E & 4 )
  {
    word_E2AB8 = 190;
    word_E2ABA = 202;
  }
  else
  {
    word_E2AB8 = 64;
    word_E2ABA = 66;
  }
  if ( !v34 && !(word_18054E & 4) )
    byte_E2AEE |= 1u;
  if ( v1[1] >> 2 >= v1[2] )
    byte_E2B0C |= 1u;
  if ( *(_BYTE *)(v1[41] + 610) )
    byte_E2AD0 |= 1u;
  byte_E2BA2 |= 4u;
  byte_E2BC0 |= 4u;
  byte_E2BDE |= 4u;
  if ( v29 )
  {
    v14 = word_18054E & 0x40;
    if ( word_18054E & 0x80 )
    {
      if ( v31 )
      {
        byte_E2BA2 |= 1u;
        if ( v0 && v37 )
        {
          byte_E2BFC |= 1u;
        }
        else
        {
          byte_E2BA2 &= 0xFBu;
          if ( v0 )
            v15 = 600;
          else
            v15 = 540;
          word_E2BA8 = v15;
          word_E2BAA = 32;
        }
      }
      else
      {
        byte_E2B48 |= 1u;
      }
      LOBYTE(word_18054E) = word_18054E & 0x7F;
    }
    if ( v14 )
    {
      if ( v32 )
      {
        byte_E2BC0 |= 1u;
        if ( v0 != 1 && v37 != 1 )
        {
          byte_E2BFC |= 1u;
        }
        else
        {
          byte_E2BC0 &= 0xFBu;
          if ( v0 == 1 )
            word_E2BC6 = 540;
          else
            word_E2BC6 = 600;
          word_E2BC8 = 32;
        }
      }
      else
      {
        byte_E2B84 |= 1u;
      }
      LOBYTE(word_18054E) = word_18054E & 0xBF;
    }
    if ( v30 )
    {
      if ( !v36 )
      {
        byte_E2BDE |= 1u;
        if ( v0 != 2 && v37 != 2 )
        {
          byte_E2BFC |= 1u;
        }
        else
        {
          byte_E2BDE &= 0xFBu;
          if ( v0 == 2 )
            word_E2BE4 = 540;
          else
            word_E2BE4 = 600;
          word_E2BE6 = 32;
        }
      }
    }
    else
    {
      byte_E2B66 |= 1u;
    }
  }
  else
  {
    byte_E2B2A |= 1u;
  }
  if ( v36 )
  {
    if ( v1[36] >= *(_DWORD *)(dword_EA3E4[*(signed __int16 *)(v4 + 212)] + 140) && *(_DWORD *)(v36 + 16) < 6 )
      byte_E2C1A |= 1u;
    if ( *(_BYTE *)(v1[41] + 405) )
      dword_E2C86 = 100;
    if ( dword_E2C86 )
      --dword_E2C86;
    if ( dword_E2C86 )
      byte_E2C74 |= 1u;
  }
  if ( v29 )
  {
    if ( v0 > -1 )
      byte_E2EEA |= 1u;
    if ( v37 > -1 )
      byte_E2F08 |= 1u;
    if ( v0 > -1 )
    {
      word_E2F2C = 540;
      byte_E2F26 |= 1u;
      word_E2F2E = 40;
      byte_E2F62 |= 1u;
      word_E2F6A = 16;
      word_E2F68 = 560;
    }
    v16 = 0;
    if ( v0 > -1 )
    {
      v17 = dword_EA3E4[*(signed __int16 *)(v4 + 2 * v0 + 208)];
      if ( v0 == 2 )
      {
        if ( v1[36] < *(_DWORD *)(v17 + 140) )
          v16 = 1;
      }
      else
      {
        v16 = sub_68D50(v17, v1) == 0;
      }
      if ( v16 )
      {
        word_E2F4A = 540;
        word_E2F4C = 48;
        byte_E2F44 |= 1u;
      }
    }
    if ( v37 > -1 && !v16 )
    {
      v18 = dword_EA3E4[*(signed __int16 *)(v4 + 2 * v37 + 208)];
      v19 = v37 == 2 ? v1[36] < *(_DWORD *)(v18 + 140) : sub_68D50(v18, v1) == 0;
      if ( v19 )
      {
        byte_E2F44 |= 1u;
        word_E2F4C = 48;
        word_E2F4A = 600;
      }
    }
  }
  if ( v33 == -1 )
  {
    v20 = 1;
    byte_E33D6 |= 1u;
    if ( byte_E3430 & 0x40 )
      byte_E3430 |= 1u;
  }
  else
  {
    v20 = 0;
    switch ( v33 )
    {
      case 0:
        byte_E32E6 |= 1u;
        break;
      case 1:
        byte_E3340 |= 1u;
        break;
      case 2:
        byte_E3304 |= 1u;
        break;
      case 3:
        byte_E337C |= 1u;
        break;
      case 5:
        byte_E33B8 |= 1u;
        break;
      case 7:
        byte_E335E |= 1u;
        break;
      case 8:
        byte_E339A |= 1u;
        break;
      case 9:
        byte_E3322 |= 1u;
        break;
      default:
        break;
    }
  }
  if ( dword_18053A > 100 )
  {
    byte_E2C38 |= 1u;
    byte_E2C56 |= 1u;
  }
  if ( v20 )
  {
    v21 = 1;
    v22 = &off_E2A92;
    while ( v21 <= dword_180516 )
    {
      if ( *((_BYTE *)v22 + 3) & 4 )
        *((_BYTE *)v22 + 2) &= 0xFEu;
      ++v21;
      v22 = (void **)((char *)v22 + 30);
    }
  }
  if ( word_18054E & 4 )
  {
    v23 = 1;
    v24 = &off_E2A92;
    while ( v23 <= dword_180516 )
    {
      v25 = *((_BYTE *)v24 + 2);
      if ( v25 & 0x20 )
        *((_BYTE *)v24 + 2) = v25 & 0xFE;
      ++v23;
      v24 = (void **)((char *)v24 + 30);
    }
  }
  result = dword_D41A0;
  if ( !*(_BYTE *)(dword_D41A0 + 8590) )
  {
    v27 = 1;
    v28 = &off_E2A92;
    while ( v27 <= dword_180516 )
    {
      if ( *((_BYTE *)v28 + 3) & 2 )
        *((_BYTE *)v28 + 2) &= 0xFEu;
      ++v27;
      v28 = (void **)((char *)v28 + 30);
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E2A92: using guessed type void *off_E2A92;
// E2AB8: using guessed type __int16 word_E2AB8;
// E2ABA: using guessed type __int16 word_E2ABA;
// E2AD0: using guessed type char byte_E2AD0;
// E2AEE: using guessed type char byte_E2AEE;
// E2B0C: using guessed type char byte_E2B0C;
// E2B2A: using guessed type char byte_E2B2A;
// E2B48: using guessed type char byte_E2B48;
// E2B66: using guessed type char byte_E2B66;
// E2B84: using guessed type char byte_E2B84;
// E2BA2: using guessed type char byte_E2BA2;
// E2BA8: using guessed type __int16 word_E2BA8;
// E2BAA: using guessed type __int16 word_E2BAA;
// E2BC0: using guessed type char byte_E2BC0;
// E2BC6: using guessed type __int16 word_E2BC6;
// E2BC8: using guessed type __int16 word_E2BC8;
// E2BDE: using guessed type char byte_E2BDE;
// E2BE4: using guessed type __int16 word_E2BE4;
// E2BE6: using guessed type __int16 word_E2BE6;
// E2BFC: using guessed type char byte_E2BFC;
// E2C1A: using guessed type char byte_E2C1A;
// E2C38: using guessed type char byte_E2C38;
// E2C56: using guessed type char byte_E2C56;
// E2C74: using guessed type char byte_E2C74;
// E2C86: using guessed type int dword_E2C86;
// E2E96: using guessed type __int16 word_E2E96;
// E2E98: using guessed type __int16 word_E2E98;
// E2EEA: using guessed type char byte_E2EEA;
// E2F08: using guessed type char byte_E2F08;
// E2F26: using guessed type char byte_E2F26;
// E2F2C: using guessed type __int16 word_E2F2C;
// E2F2E: using guessed type __int16 word_E2F2E;
// E2F44: using guessed type char byte_E2F44;
// E2F4A: using guessed type __int16 word_E2F4A;
// E2F4C: using guessed type __int16 word_E2F4C;
// E2F62: using guessed type char byte_E2F62;
// E2F68: using guessed type __int16 word_E2F68;
// E2F6A: using guessed type __int16 word_E2F6A;
// E32E6: using guessed type char byte_E32E6;
// E3304: using guessed type char byte_E3304;
// E3322: using guessed type char byte_E3322;
// E3340: using guessed type char byte_E3340;
// E335E: using guessed type char byte_E335E;
// E337C: using guessed type char byte_E337C;
// E339A: using guessed type char byte_E339A;
// E33B8: using guessed type char byte_E33B8;
// E33D6: using guessed type char byte_E33D6;
// E3430: using guessed type char byte_E3430;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// 180516: using guessed type int dword_180516;
// 18053A: using guessed type int dword_18053A;
// 18054E: using guessed type __int16 word_18054E;

//----- (00088450) --------------------------------------------------------
int sub_88450()
{
  signed int v0; // ebx
  int v1; // edx
  void **v2; // eax
  int v3; // ecx
  int v4; // edi

  if ( word_180538 )
  {
    v1 = word_180538;
    word_180538 = 0;
  }
  else
  {
    v0 = 6;
    v1 = 0;
    while ( v0 >= 0 && !v1 )
    {
      v2 = &off_E2A92;
      v3 = 0;
      v4 = 0;
      while ( v3 < dword_180516 )
      {
        if ( *((_BYTE *)v2 + 2) & 1
          && v0 == *((char *)v2 + 29)
          && (_BYTE *)v2[4] - (_BYTE *)v2[6] > 0
          && (_BYTE *)v2[4] - (_BYTE *)v2[6] > v4 )
        {
          v1 = v3 + 1;
          v4 = (_BYTE *)v2[4] - (_BYTE *)v2[6];
        }
        ++v3;
        v2 = (void **)((char *)v2 + 30);
      }
      --v0;
    }
  }
  return v1;
}
// E2A92: using guessed type void *off_E2A92;
// 180516: using guessed type int dword_180516;
// 180538: using guessed type __int16 word_180538;

//----- (000884D0) --------------------------------------------------------
void __cdecl sub_884D0(int a1, __int16 a2, int a3, char a4, char a5)
{
  signed int i; // eax
  char v6; // dl

  if ( a1 )
  {
    dword_18052A = word_E2A7A[15 * a1];
    byte_180553 = a4;
    word_180536 = a1;
    LOBYTE(word_18054E) = word_18054E | 8;
    byte_180551 = a5;
    dword_180526 = 0;
    byte_180550 = a2;
    for ( i = 0; i < a2; *((_WORD *)&dword_18053A + i + 1) = *(_WORD *)(a3 + 2 * i - 2) )
      ++i;
    v6 = byte_E2A76[30 * a1] | 3;
    byte_E2A76[30 * a1] = v6;
    if ( v6 & 8 )
    {
      LOBYTE(word_18054E) = word_18054E | 0x20;
    }
    else if ( v6 & 0x10 )
    {
      HIBYTE(word_18054E) |= 1u;
    }
  }
}
// E2A7A: using guessed type __int16 word_E2A7A[];
// 180526: using guessed type int dword_180526;
// 18052A: using guessed type int dword_18052A;
// 180536: using guessed type __int16 word_180536;
// 18053A: using guessed type int dword_18053A;
// 18054E: using guessed type __int16 word_18054E;
// 180550: using guessed type char byte_180550;
// 180551: using guessed type char byte_180551;
// 180553: using guessed type char byte_180553;

//----- (00088580) --------------------------------------------------------
void **sub_88580()
{
  signed int v0; // edx
  void **result; // eax

  v0 = 1;
  for ( result = &off_E2A92; v0 <= dword_180516; result = (void **)((char *)result + 30) )
  {
    if ( *(_WORD *)result >= 2u && (*(_WORD *)result <= 2u || *(_WORD *)result == 8) )
    {
      *((_BYTE *)result + 2) &= 0xA7u;
      if ( result[3] )
      {
        if ( *((_BYTE *)result + 2) & 2 )
          HIBYTE(word_18054E) &= 0xFDu;
        else
          result[3] = 0;
      }
    }
    ++v0;
  }
  return result;
}
// E2A92: using guessed type void *off_E2A92;
// 180516: using guessed type int dword_180516;
// 18054E: using guessed type __int16 word_18054E;

//----- (000885E0) --------------------------------------------------------
char __cdecl sub_885E0(int a1, int a2, int a3, unsigned __int16 a4)
{
  signed int v4; // eax
  int v5; // edx
  unsigned int v6; // ebx
  int v7; // ebx
  char v8; // al
  char v9; // dl
  char v10; // dh
  char v12; // [esp+0h] [ebp-4h]

  LOBYTE(v4) = dword_D41A4;
  v5 = 0;
  if ( *(_BYTE *)(dword_D41A4 + 10) )
  {
    LOBYTE(v4) = a4;
    if ( !(byte_E2A76[30 * (signed __int16)a4] & 8) )
    {
      if ( word_180660 & 1 )
      {
        a2 *= 2;
        a3 *= 2;
      }
      LOBYTE(v4) = a4;
      v6 = 30 * (signed __int16)a4;
      if ( byte_E2A76[v6] & 2 )
      {
        if ( a1 == *(int *)((char *)&dword_E2A80 + v6) && !(word_18054E & 0x20) )
        {
          v9 = byte_E2A76[v6] | 0x10;
          word_E2A7C[v6 / 2] = a2;
          byte_E2A76[v6] = v9;
          LOBYTE(v4) = a3;
          v10 = HIBYTE(word_18054E) | 2;
          word_E2A7E[v6 / 2] = a3;
          HIBYTE(word_18054E) = v10;
        }
      }
      else
      {
        v12 = 0;
        if ( !a1
          || (v4 = sub_58490(
                     (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12)
                                                               + dword_D41A0
                                                               + 11240)]
                             + 76),
                     (_WORD *)(a1 + 76)),
              v5 = v4,
              !*(int *)((char *)&dword_E2A80 + v6))
          || v4 < *(int *)((char *)&dword_E2A88 + v6) )
        {
          v12 = 1;
        }
        if ( v12 )
        {
          v7 = 15 * (signed __int16)a4;
          *(int *)((char *)&dword_E2A80 + 2 * v7) = a1;
          v8 = byte_E2A76[30 * (signed __int16)a4];
          *(int *)((char *)&dword_E2A88 + 2 * v7) = v5;
          LOBYTE(v4) = v8 | 0x10;
          byte_E2A76[2 * v7] = v4;
        }
      }
    }
    if ( a4 >= 0x51u && a4 <= 0x53u )
    {
      LOBYTE(v4) = a4;
      byte_E2A76[30 * (signed __int16)a4] |= 0x40u;
    }
  }
  return v4;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E2A7C: using guessed type __int16 word_E2A7C[];
// E2A7E: using guessed type __int16 word_E2A7E[];
// E2A80: using guessed type int dword_E2A80;
// E2A88: using guessed type int dword_E2A88;
// EA3E4: using guessed type int dword_EA3E4[];
// 18054E: using guessed type __int16 word_18054E;
// 180660: using guessed type __int16 word_180660;

//----- (00088740) --------------------------------------------------------
void __cdecl sub_88740(int a1, int a2, int a3)
{
  int v3; // esi
  int v4; // edx
  unsigned __int8 v5; // al
  unsigned __int8 v6; // al
  unsigned __int8 v7; // al
  unsigned __int8 v8; // al
  char v9; // cl
  signed int v10; // eax
  unsigned __int8 v11; // al
  unsigned int v12; // edi
  signed int v13; // eax
  int v14; // esi
  char v15; // dl
  char v16; // dh
  char v17; // bl
  char v18; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( word_18054E & 1 )
    return;
  v4 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v5 = *(_BYTE *)(a1 + 63);
  if ( v5 < 5u )
  {
    if ( v5 >= 2u )
    {
      if ( v5 <= 2u )
      {
        v6 = *(_BYTE *)(a1 + 64);
        if ( v6 >= 1u )
        {
          if ( v6 <= 1u )
          {
            v3 = 27;
          }
          else if ( v6 == 2 )
          {
            v3 = 22;
          }
        }
      }
      else if ( v5 == 3 )
      {
        v11 = *(_BYTE *)(a1 + 64);
        if ( v11 < 2u )
        {
          if ( v11 == 1 )
            v3 = 28;
        }
        else if ( v11 <= 2u )
        {
          v3 = (*(_WORD *)(a1 + 26) != *(_WORD *)(v4 + 26)) + 24;
        }
        else if ( v11 == 3 )
        {
          if ( *(_WORD *)(a1 + 26) == *(_WORD *)(v4 + 26) )
            v3 = 23;
          else
            v3 = 26;
        }
      }
    }
    goto LABEL_48;
  }
  if ( v5 > 5u )
  {
    if ( v5 >= 0xAu )
    {
      if ( v5 <= 0xAu )
      {
        if ( *(_BYTE *)(a1 + 64) == 39 && *(unsigned __int16 *)(a1 + 148) != *(signed __int16 *)(v4 + 26) )
          v3 = 18;
      }
      else if ( v5 == 15 && !(*(_BYTE *)(a1 + 12) & 1) )
      {
        v3 = 20;
      }
    }
    goto LABEL_48;
  }
  if ( *(_WORD *)(a1 + 26) != *(_WORD *)(v4 + 26) )
  {
    v7 = *(_BYTE *)(a1 + 64);
    if ( v7 < 0xCu )
      goto LABEL_30;
    if ( v7 > 0xEu )
    {
      if ( v7 == 22 )
      {
        if ( *(_BYTE *)(a1 + 69) != -76 && *(unsigned __int16 *)(a1 + 148) != *(signed __int16 *)(v4 + 26) )
          v3 = 18;
        goto LABEL_48;
      }
LABEL_30:
      v8 = *(_BYTE *)(a1 + 69);
      if ( v8 < 0xE8u || v8 > 0xEAu )
      {
        v9 = *(_BYTE *)(a1 + 73);
        v10 = 1;
        if ( (v9 == 14 || v9 == 13) && *(unsigned __int16 *)(a1 + 40) == *(signed __int16 *)(v4 + 26) )
          v10 = 0;
        if ( v10 )
          v3 = 19;
      }
      goto LABEL_48;
    }
  }
LABEL_48:
  if ( v3 )
  {
    if ( word_180660 & 1 )
    {
      a2 *= 2;
      a3 *= 2;
    }
    v12 = 30 * v3;
    if ( byte_E2A76[30 * v3] & 2 )
    {
      if ( a1 == *(int *)((char *)&dword_E2A80 + v12) )
      {
        v16 = HIBYTE(word_18054E);
        if ( !(word_18054E & 0x100) )
        {
          v17 = byte_E2A76[v12] | 8;
          word_E2A7C[v12 / 2] = a2;
          byte_E2A76[v12] = v17;
          word_E2A7E[v12 / 2] = a3;
          HIBYTE(word_18054E) = v16 | 2;
        }
      }
    }
    else
    {
      v18 = 0;
      v13 = sub_58490((_WORD *)(v4 + 76), (_WORD *)(a1 + 76));
      if ( !*(int *)((char *)&dword_E2A80 + v12) || v13 < *(int *)((char *)&dword_E2A88 + v12) && v13 > 1024 )
        v18 = 1;
      if ( v18 )
      {
        v14 = 15 * v3;
        *(int *)((char *)&dword_E2A88 + 2 * v14) = v13;
        v15 = byte_E2A76[2 * v14];
        *(int *)((char *)&dword_E2A80 + 2 * v14) = a1;
        byte_E2A76[2 * v14] = v15 | 8;
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// E2A7C: using guessed type __int16 word_E2A7C[];
// E2A7E: using guessed type __int16 word_E2A7E[];
// E2A80: using guessed type int dword_E2A80;
// E2A88: using guessed type int dword_E2A88;
// EA3E4: using guessed type int dword_EA3E4[];
// 18054E: using guessed type __int16 word_18054E;
// 180660: using guessed type __int16 word_180660;

//----- (000889F0) --------------------------------------------------------
int __cdecl sub_889F0(int a1)
{
  int result; // eax

  result = a1;
  if ( (unsigned __int16)a1 < 0x15u )
  {
    if ( (unsigned __int16)a1 < 0x12u )
    {
      if ( (_WORD)a1 == 15 )
      {
        byte_E2C71 = 6;
        return result;
      }
      goto LABEL_22;
    }
    if ( (unsigned __int16)a1 > 0x12u )
    {
      if ( (_WORD)a1 != 19 )
        goto LABEL_22;
      goto LABEL_19;
    }
LABEL_18:
    LOBYTE(word_18054E) = word_18054E | 0x40;
    return result;
  }
  if ( (unsigned __int16)a1 <= 0x15u )
    goto LABEL_18;
  if ( (unsigned __int16)a1 < 0x1Cu )
  {
    if ( (unsigned __int16)a1 < 0x19u || (unsigned __int16)a1 > 0x1Au )
      goto LABEL_22;
    goto LABEL_19;
  }
  if ( (unsigned __int16)a1 <= 0x1Cu )
    goto LABEL_19;
  if ( (unsigned __int16)a1 < 0x52u )
  {
LABEL_22:
    if ( word_E2A74[15 * (signed __int16)a1] == 7 )
    {
      switch ( *(_BYTE *)(dword_D41A0
                        + 10 * (unsigned __int8)byte_3659D[11 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0]
                        + 222540) )
      {
        case 0:
          LOBYTE(word_18054E) = word_18054E | 0x40;
          break;
        case 1:
        case 2:
        case 3:
        case 7:
        case 8:
        case 9:
          LOBYTE(word_18054E) = word_18054E | 0x80;
          break;
        default:
          break;
      }
    }
    if ( (_WORD)a1 == 79 )
    {
      byte_E2ACD = 6;
      byte_E340F = 6;
    }
    return result;
  }
  if ( (unsigned __int16)a1 <= 0x52u )
  {
LABEL_19:
    LOBYTE(word_18054E) = word_18054E | 0x80;
    return result;
  }
  if ( (_WORD)a1 != 93 )
    goto LABEL_22;
  if ( *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(dword_D41A0
                                                              + 2124 * *(signed __int16 *)(dword_D41A0 + 12)
                                                              + 11240)]
                            + 164)
                + 58) )
    word_180538 = 94;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E2A74: using guessed type __int16 word_E2A74[];
// E2ACD: using guessed type char byte_E2ACD;
// E2C71: using guessed type char byte_E2C71;
// E340F: using guessed type char byte_E340F;
// EA3E4: using guessed type int dword_EA3E4[];
// 180538: using guessed type __int16 word_180538;
// 18054E: using guessed type __int16 word_18054E;

//----- (00088B20) --------------------------------------------------------
int sub_88B20()
{
  int result; // eax
  signed int v1; // edx
  void **v2; // ebx

  result = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 10) )
  {
    v1 = 1;
    v2 = &off_E2A92;
    while ( v1 <= dword_180516 )
    {
      if ( *(_WORD *)v2 == 7 )
      {
        result = 15 * v1;
        byte_E2A91[30 * v1] = 6;
      }
      ++v1;
      v2 = (void **)((char *)v2 + 30);
    }
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// E2A92: using guessed type void *off_E2A92;
// 180516: using guessed type int dword_180516;

//----- (00088B60) --------------------------------------------------------
int sub_88B60()
{
  int result; // eax

  result = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 10) )
    byte_E2F5F = 6;
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// E2F5F: using guessed type char byte_E2F5F;

//----- (00088BA0) --------------------------------------------------------
char sub_88BA0()
{
  char result; // al
  int v1; // ebx

  result = -1;
  if ( *(_BYTE *)(dword_D41A4 + 10) )
  {
    v1 = dword_D41A0 + 11 * *(signed __int16 *)(dword_D41A0 + 12);
    if ( !byte_3659C[v1] )
      result = *(_BYTE *)(dword_D41A0 + 10 * (unsigned __int8)byte_3659D[v1] + 222540);
    if ( result == -1 )
    {
      word_180538 = 80;
LABEL_15:
      dword_18051E = 8;
      result = sub_87C10();
    }
    else
    {
      switch ( result )
      {
        case 0:
          word_180538 = 72;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        case 1:
          word_180538 = 75;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        case 2:
          word_180538 = 73;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        case 3:
          word_180538 = 77;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        case 5:
          word_180538 = 79;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        case 7:
          word_180538 = 76;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        case 8:
          word_180538 = 78;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        case 9:
          word_180538 = 74;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        default:
          goto LABEL_15;
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 18051E: using guessed type int dword_18051E;
// 180538: using guessed type __int16 word_180538;

//----- (00088D00) --------------------------------------------------------
int sub_88D00()
{
  int result; // eax

  result = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 10) )
    word_180538 = 93;
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// 180538: using guessed type __int16 word_180538;

//----- (00088D40) --------------------------------------------------------
char sub_88D40()
{
  unsigned __int16 v0; // dx
  int v1; // ebx
  signed int v2; // eax
  int v3; // edx
  signed int v4; // ebx
  int v5; // ecx
  int v6; // edx
  int v7; // ebx
  int v8; // edi
  int v9; // ecx
  int v10; // esi
  int v11; // edi
  int v12; // eax
  char v13; // cl
  int v20; // [esp+0h] [ebp-2h]
  __int16 v21; // [esp+Ch] [ebp+Ah]
  int i; // [esp+18h] [ebp+16h]
  int v23; // [esp+1Ch] [ebp+1Ah]
  int v24; // [esp+24h] [ebp+22h]
  int v25; // [esp+28h] [ebp+26h]
  int v26; // [esp+2Ch] [ebp+2Ah]
  int v27; // [esp+30h] [ebp+2Eh]
  int v28; // [esp+34h] [ebp+32h]
  int v29; // [esp+38h] [ebp+36h]
  int v30; // [esp+3Ch] [ebp+3Ah]
  int v32; // [esp+44h] [ebp+42h]
  int v33; // [esp+48h] [ebp+46h]
  int v34; // [esp+4Ch] [ebp+4Ah]
  int v35; // [esp+50h] [ebp+4Eh]
  int v36; // [esp+54h] [ebp+52h]
  int v37; // [esp+58h] [ebp+56h]
  char *v39; // [esp+60h] [ebp+5Eh]
  int v40; // [esp+64h] [ebp+62h]
  int v41; // [esp+68h] [ebp+66h]
  int v42; // [esp+6Ch] [ebp+6Ah]
  int v43; // [esp+70h] [ebp+6Eh]
  char v44; // [esp+78h] [ebp+76h]
  char v45; // [esp+7Ch] [ebp+7Ah]
  _BOOL1 v46; // [esp+80h] [ebp+7Eh]

  v40 = 0;
  v45 = 0;
  v42 = 0;
  v34 = 0;
  v36 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v0 = *(_WORD *)(*(_DWORD *)(v36 + 164) + 58);
  if ( v0 )
    v40 = dword_EA3E4[v0];
  v1 = 0;
  v30 = *(_DWORD *)(v36 + 164) + 611;
  v2 = 0;
  while ( v2 < 26 )
  {
    v3 = *(_WORD *)(v30 + 2 * v2++ + 208) != 0;
    v1 += v3;
  }
  if ( v1 )
  {
    if ( word_180660 & 1 )
      v4 = 400;
    else
      v4 = 480;
    v5 = *(unsigned __int8 *)(dword_EA3DC + 539);
    v6 = *(unsigned __int8 *)(dword_EA3DC + 532);
    v32 = v4 - 2 * v5;
    v26 = v6;
    v23 = *(unsigned __int8 *)(dword_EA3DC + 538);
    v7 = v5;
    v41 = (unsigned __int8)byte_D94FF[*(char *)(v30 + 501)];
    v46 = *(_WORD *)(v30 + 2 * v41 + 208) != 0;
    if ( *(_BYTE *)(dword_D41A0 + 196308) != 2 && v41 == 25 )
      v46 = 0;
    v35 = *(char *)(v41 + v30 + 442);
    v8 = *(char *)(v30 + 501);
    v39 = &byte_DA818[80 * v41 + 2];
    v43 = 13;
    v20 = *(unsigned __int8 *)(dword_EA3DC + 982);
    v9 = 3 * v20;
    v33 = v23 / 2 + v23 * (v8 % 13) + v26;
    v43 = 13;
    v10 = *(unsigned __int8 *)(dword_EA3DC + 983);
    v37 = v32 - v10;
    v29 = v7 / 2 + v7 * (v8 / 13) + v32;
    v11 = v33 - 3 * v20 / 2;
    if ( v11 <= 640 - 3 * v20 )
    {
      if ( v11 < 0 )
        v11 = 0;
    }
    else
    {
      v11 = 640 - v9;
    }
    v12 = v9 / 2;
    v13 = 0;
    v25 = v11 + v12;
    for ( i = 0; i < 8 && !v13; ++i )
    {
      v44 = 2;
      v34 = 1;
      if ( (unsigned __int8)byte_180554 <= 6u )
      {
        v43 = 4 * (unsigned __int8)byte_180554;
        v24 = v10 / 2;
        v28 = v20 / 2;
        v27 = v10 / 2 + v37;
        JUMPOUT(__CS__, *(&off_88D1C + (unsigned __int8)byte_180554));
      }
      if ( (unsigned __int8)++byte_180554 > 7u )
        byte_180554 = 0;
    }
    if ( v42 )
      sub_884D0(v42, v34, (int)&v21, v44, v45);
  }
  return v42;
}
// 88D1C: using guessed type void *off_88D1C;
// D41A0: using guessed type int dword_D41A0;
// E2F2C: using guessed type __int16 word_E2F2C;
// E2F2E: using guessed type __int16 word_E2F2E;
// E2F4A: using guessed type __int16 word_E2F4A;
// E2F4C: using guessed type __int16 word_E2F4C;
// E2F68: using guessed type __int16 word_E2F68;
// E2F6A: using guessed type __int16 word_E2F6A;
// E3292: using guessed type __int16 word_E3292;
// E32AC: using guessed type __int16 word_E32AC;
// E32B0: using guessed type __int16 word_E32B0;
// E32B2: using guessed type __int16 word_E32B2;
// E32CE: using guessed type __int16 word_E32CE;
// E32D0: using guessed type __int16 word_E32D0;
// E3472: using guessed type __int16 word_E3472;
// E3474: using guessed type __int16 word_E3474;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// 180554: using guessed type char byte_180554;
// 180660: using guessed type __int16 word_180660;

//----- (00089360) --------------------------------------------------------
char sub_89360()
{
  char v0; // al
  int v1; // ebx
  int v2; // eax
  int v4; // [esp+0h] [ebp-4h]

  v0 = 0;
  v1 = 0;
  if ( byte_180557 )
  {
    byte_180557 = 0;
    if ( byte_180558 && *(_WORD *)(dword_D41A0 + 14) > 1u )
    {
      word_E35BC = word_18054A;
      v1 = 96;
      word_E35BE = word_18054C;
    }
    else
    {
      v0 = 1;
    }
  }
  else
  {
    v0 = 1;
    byte_180557 = 1;
  }
  if ( v0 )
  {
    v1 = 95;
    word_E359E = word_180546;
    byte_180558 = 0;
    word_E35A0 = word_180548;
  }
  if ( v1 )
  {
    v2 = 15 * v1;
    LOWORD(v2) = word_E2A78[15 * v1];
    v4 = v2;
    sub_884D0(v1, 1, (int)&v4, 2, 0);
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// E2A78: using guessed type __int16 word_E2A78[];
// E359E: using guessed type __int16 word_E359E;
// E35A0: using guessed type __int16 word_E35A0;
// E35BC: using guessed type __int16 word_E35BC;
// E35BE: using guessed type __int16 word_E35BE;
// 180546: using guessed type __int16 word_180546;
// 180548: using guessed type __int16 word_180548;
// 18054A: using guessed type __int16 word_18054A;
// 18054C: using guessed type __int16 word_18054C;
// 180557: using guessed type char byte_180557;
// 180558: using guessed type char byte_180558;

//----- (00089420) --------------------------------------------------------
int __cdecl sub_89420(_WORD *a1, const char *a2)
{
  int result; // eax
  unsigned int v3; // kr04_4
  signed int v4; // ecx
  signed int v5; // ebx
  unsigned int v6; // ecx
  unsigned int v7; // edx
  _BYTE *i; // ecx
  signed __int16 v9; // [esp+4h] [ebp-4h]

  result = 0;
  v3 = strlen(a2) + 1;
  v9 = 1;
  a1[2] = 0;
  a1[3] = 0;
  if ( v3 != 1 )
  {
    HIWORD(result) = 0;
    v4 = (signed __int16)a1[8] * strlen(a2);
    v5 = (signed __int16)a1[6];
    if ( v4 <= v5 )
    {
      a1[2] = v4;
    }
    else
    {
      result = v5 / 2;
      if ( v4 % v5 < v5 / 2 )
      {
        while ( 1 )
        {
          result = v5 / 2;
          if ( v4 % v5 >= v5 / 2 || v5 <= 0 )
            break;
          v5 -= (signed __int16)a1[8];
        }
      }
      if ( v5 > 0 )
      {
        result = (v5 + (signed __int16)a1[8] - 1) / (signed __int16)a1[8];
        v9 = 0;
        v6 = (unsigned int)a2;
        v7 = (unsigned int)&a2[v3 - 1];
        while ( v6 < v7 )
        {
          for ( i = (_BYTE *)(result + v6); *i != 32 && (unsigned int)i < v7; --i )
            ;
          v6 = (unsigned int)(i + 1);
          ++v9;
        }
        a1[2] = v5;
      }
    }
    LOWORD(result) = a1[9];
    a1[3] = result * v9;
  }
  return result;
}

//----- (00089520) --------------------------------------------------------
int __cdecl sub_89520(signed __int16 *a1)
{
  int v1; // edi
  int v2; // ecx
  int v3; // esi
  int result; // eax
  int v5; // [esp+0h] [ebp-Ch]
  int v6; // [esp+4h] [ebp-8h]
  int v7; // [esp+8h] [ebp-4h]

  v5 = a1[2];
  v1 = a1[3];
  v2 = *a1 - v5 / 2;
  v3 = a1[1] - v1 / 2;
  if ( v2 < a1[10] )
    v2 = a1[10];
  if ( v3 < a1[12] )
    v3 = a1[12];
  v7 = a1[11];
  if ( v2 + v5 >= v7 )
    LOWORD(v2) = v7 - v5;
  v6 = a1[13];
  if ( v3 + v1 >= v6 )
    v3 = v6 - v1;
  *a1 = v2 + a1[2] / 2;
  a1[4] = v2;
  a1[5] = v3;
  result = v3 + v1 / 2;
  a1[1] = result;
  return result;
}

//----- (000895D0) --------------------------------------------------------
int __cdecl sub_895D0(int a1, const char *a2)
{
  unsigned int v2; // edi
  int result; // eax
  char *i; // ebx
  char *v5; // eax
  char *v6; // edx
  char v7; // cl
  unsigned __int8 v8; // ST0C_1
  __int16 v9; // ST04_2
  int v10; // ebx
  char v11; // [esp+0h] [ebp-12h]
  int v12; // [esp+80h] [ebp+6Eh]
  int v13; // [esp+84h] [ebp+72h]
  unsigned int v14; // [esp+88h] [ebp+76h]

  v14 = (unsigned int)a2;
  v13 = *(signed __int16 *)(a1 + 10);
  v2 = (unsigned int)&a2[strlen(a2)];
  result = *(signed __int16 *)(a1 + 4) / *(signed __int16 *)(a1 + 16);
  v12 = *(signed __int16 *)(a1 + 4) / *(signed __int16 *)(a1 + 16);
  if ( v2 > (unsigned int)a2 )
  {
    do
    {
      for ( i = (char *)(v12 + v14); *i != 32 && (unsigned int)i < v2; --i )
        ;
      v5 = (char *)v14;
      v6 = &v11;
      while ( v5 < i )
      {
        ++v6;
        v7 = *v5++;
        *(v6 - 1) = v7;
      }
      *v6 = 0;
      v8 = *(_BYTE *)(a1 + 48);
      v9 = *(_WORD *)(a1 + 8);
      v14 = (unsigned int)(i + 1);
      v10 = v13;
      sub_2BC10(&v11, v9, v13, v8);
      result = *(signed __int16 *)(a1 + 18);
      v13 = result + v10;
    }
    while ( v2 > v14 );
  }
  return result;
}

//----- (00089690) --------------------------------------------------------
int __cdecl sub_89690(signed __int16 *a1)
{
  __int16 v1; // ST0C_2
  int v2; // edi
  int v3; // esi
  __int16 v4; // bx
  __int16 v5; // bx
  int result; // eax
  int i; // ebx
  __int16 v8; // [esp+Ch] [ebp-1Ch]
  int v9; // [esp+10h] [ebp-18h]
  __int16 v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+1Ch] [ebp-Ch]
  int v13; // [esp+20h] [ebp-8h]
  __int16 v14; // [esp+24h] [ebp-4h]

  v11 = *(unsigned __int8 *)(dword_EA3DC + 1042);
  v12 = *(unsigned __int8 *)(dword_EA3DC + 1036);
  v1 = *(unsigned __int8 *)(dword_EA3DC + 1031);
  v10 = *(unsigned __int8 *)(dword_EA3DC + 1037);
  v2 = a1[18] - v12;
  v3 = a1[20] + a1[18];
  v14 = a1[19] - *(unsigned __int8 *)(dword_EA3DC + 1043);
  v8 = a1[19] + a1[21];
  v4 = a1[19] - *(unsigned __int8 *)(dword_EA3DC + 1043);
  v9 = a1[3] / a1[9];
  sub_2BB40(a1[18] - v12, v14, dword_EA3DC + 1026);
  sub_2BB40(v3, v4, dword_EA3DC + 1026);
  v13 = 0;
  v5 = v1 + v14;
  while ( v13 < v9 )
  {
    sub_2BB40(v2, v5, dword_EA3DC + 1032);
    sub_2BB40(v3, v5, dword_EA3DC + 1032);
    v5 += v10;
    ++v13;
  }
  sub_2BB40(v2, v5, dword_EA3DC + 1026);
  result = sub_2BB40(v3, v5, dword_EA3DC + 1026);
  for ( i = v2 + v12; i < v3; i += v11 )
  {
    sub_2BB40(i, v14, dword_EA3DC + 1038);
    result = sub_2BB40(i, v8, dword_EA3DC + 1038);
  }
  return result;
}
// EA3DC: using guessed type int dword_EA3DC;

//----- (00089830) --------------------------------------------------------
int __cdecl sub_89830(_WORD *a1)
{
  int v1; // eax
  __int16 v2; // si
  int result; // eax
  int v4; // [esp+0h] [ebp-4h]

  v1 = (signed __int16)a1[14];
  v2 = v1 + 25;
  v4 = (signed __int16)a1[15];
  if ( (signed __int16)a1[11] < v1 + 135 )
    v2 = v1 - 135;
  result = v4 - 94;
  if ( v4 - 94 + 28 < (signed __int16)a1[12] )
    result = v4 + 66;
  *a1 = v2;
  a1[1] = result;
  return result;
}

//----- (000898A0) --------------------------------------------------------
_WORD *__cdecl sub_898A0(_WORD *a1)
{
  _WORD *result; // eax
  int v2; // ebx
  int v3; // edx
  __int16 v4; // dx
  int v5; // edx
  int v6; // ebx
  __int16 v7; // dx

  result = a1;
  v2 = (signed __int16)a1[18];
  v3 = (signed __int16)a1[14];
  if ( v3 >= v2 - 30 )
  {
    if ( v3 <= (signed __int16)a1[20] + v2 + 30 )
      v4 = *a1;
    else
      v4 = a1[20] + a1[18];
  }
  else
  {
    v4 = a1[18] - 2;
  }
  a1[16] = v4;
  v5 = (signed __int16)a1[19];
  v6 = (signed __int16)a1[15];
  if ( v6 >= v5 - 30 )
  {
    if ( v6 > (signed __int16)a1[21] + v5 + 30 )
    {
      a1[17] = a1[21] + a1[19];
      return result;
    }
    v7 = a1[1];
  }
  else
  {
    v7 = a1[19] - 2;
  }
  a1[17] = v7;
  return result;
}

//----- (00089920) --------------------------------------------------------
int __cdecl sub_89920(_WORD *a1, __int16 a2, int a3)
{
  signed int v3; // edx
  int v4; // ebx
  int result; // eax
  unsigned int v6; // kr04_4
  __int16 v7; // dx

  v3 = 0;
  v4 = 0;
  while ( v3 < a2 )
  {
    result = 0;
    v6 = strlen((const char *)dword_E9C4C[*(signed __int16 *)(a3 + 2 * v3)]) + 1;
    if ( (signed int)(v6 - 1) > v4 )
      v4 = v6 - 1;
    ++v3;
  }
  v7 = a1[9];
  a1[2] = a1[8] * v4;
  a1[3] = v7 * a2;
  return result;
}

//----- (00089980) --------------------------------------------------------
int __cdecl sub_89980(signed __int16 *a1)
{
  __int16 v1; // di
  int v2; // ecx
  __int16 v3; // ST00_2
  signed __int16 v4; // ax
  int v5; // edx
  signed __int16 v6; // ax
  int v7; // edx
  int result; // eax

  v1 = *(unsigned __int8 *)(dword_EA3DC + 1043);
  v2 = *(unsigned __int8 *)(dword_EA3DC + 1037);
  v3 = *(unsigned __int8 *)(dword_EA3DC + 1031);
  v4 = *(unsigned __int8 *)(dword_EA3DC + 1042)
     * (unsigned __int16)((*(unsigned __int8 *)(dword_EA3DC + 1042) - 1 + a1[2] + 8)
                        / *(unsigned __int8 *)(dword_EA3DC + 1042));
  v5 = a1[2];
  a1[20] = v4;
  a1[18] = a1[4] - (v4 - v5) / 2;
  v6 = (v2 - 1 + a1[3]) / v2 * v2 + 2 * (v3 - v1);
  v7 = a1[3];
  a1[21] = v6;
  result = (v6 - v7) / 2;
  a1[19] = a1[5] - result;
  return result;
}
// EA3DC: using guessed type int dword_EA3DC;

//----- (00089A30) --------------------------------------------------------
__int16 __cdecl sub_89A30(_WORD *a1)
{
  __int16 v1; // si
  __int16 result; // ax

  v1 = ((word_180660 & 1) != 0) + 1;
  if ( a1[16] != *a1 || (result = a1[17], result != a1[1]) )
  {
    sub_2BD10(a1[14], a1[15], a1[16], a1[17], byte_E8900[0]);
    result = sub_2BD10(a1[14] + v1, a1[15], v1 + a1[16], a1[17], byte_E9800);
  }
  return result;
}
// E9800: using guessed type char byte_E9800;
// 180660: using guessed type __int16 word_180660;

//----- (00089AC0) --------------------------------------------------------
int __cdecl sub_89AC0(_BYTE *a1, int a2)
{
  int result; // eax
  signed int v3; // eax

  result = a2;
  if ( (unsigned __int16)a2 < 0x5Cu )
    goto LABEL_10;
  if ( (unsigned __int16)a2 <= 0x5Cu )
    return sprintf(a1, aF1S, dword_E9C84);
  if ( (_WORD)a2 == 96 )
  {
    v3 = sub_61790((unsigned __int8)byte_180558);
    result = sprintf(a1, (const char *)dword_EA1D0, (&off_D93A0)[v3]);
  }
  else
  {
LABEL_10:
    *a1 = 0;
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D93A0: using guessed type char *off_D93A0;
// E9C84: using guessed type int dword_E9C84;
// EA1D0: using guessed type int dword_EA1D0;
// 180558: using guessed type char byte_180558;

//----- (00089B60) --------------------------------------------------------
signed int __cdecl sub_89B60(unsigned __int8 a1)
{
  signed int v1; // esi
  __int16 v2; // ax
  _BOOL1 v3; // zf

  v1 = -1;
  dword_1805AC = 0;
  dword_1805A8 = 0;
  dword_1805A4 = 0;
  dword_180598 = 0;
  dword_180594 = 0;
  dword_180590 = 0;
  dword_1805A0 = 0;
  dword_18059C = 0;
  word_1805C8 = 0;
  switch ( a1 )
  {
    case 1u:
      v1 = sub_8B600((int)&unk_18058C);
      if ( (signed __int16)v1 != -1 )
        goto LABEL_3;
      break;
    case 2u:
      if ( (unsigned __int16)sub_75650() )
      {
        v1 = 1;
        printf(aVfxInitialised);
        word_1805C8 = 1;
        v2 = a1;
        dword_1805A0 = 0;
        dword_18059C = 0;
        goto LABEL_12;
      }
      break;
    case 4u:
      memset(&unk_180560, 0, 44);
      sub_8BB40((int)&unk_180560, 8);
      v3 = byte_180584 == 0;
      goto LABEL_10;
    case 6u:
      memset(&unk_180560, 0, 44);
      v1 = 1;
      v2 = a1;
      goto LABEL_12;
    case 7u:
      v2 = a1;
      v1 = 1;
      goto LABEL_12;
    case 8u:
    case 9u:
LABEL_3:
      word_1805C8 = 1;
      break;
    case 0xBu:
      memset(&unk_180560, 0, 44);
      sub_8BB40((int)&unk_180560, 4);
      v3 = byte_180584 == 0;
LABEL_10:
      if ( !v3 )
      {
        sub_8BBE0((int)&unk_180560);
        v1 = 1;
        v2 = a1;
LABEL_12:
        word_1805C2 = v2;
      }
      break;
    default:
      break;
  }
  word_1805C2 = a1;
  if ( (signed __int16)v1 > 0 )
    byte_E36D1 = a1;
  return v1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// E36D1: using guessed type char byte_E36D1;
// 180584: using guessed type char byte_180584;
// 180590: using guessed type int dword_180590;
// 180594: using guessed type int dword_180594;
// 180598: using guessed type int dword_180598;
// 18059C: using guessed type int dword_18059C;
// 1805A0: using guessed type int dword_1805A0;
// 1805A4: using guessed type int dword_1805A4;
// 1805A8: using guessed type int dword_1805A8;
// 1805AC: using guessed type int dword_1805AC;
// 1805C2: using guessed type __int16 word_1805C2;
// 1805C8: using guessed type __int16 word_1805C8;

//----- (00089D10) --------------------------------------------------------
int sub_89D10()
{
  char v0; // bl
  char v2; // dl
  unsigned __int8 v3; // al
  int v4; // eax
  int v5; // ecx
  unsigned __int8 v6; // al
  int v7; // ebx
  signed int v8; // edx
  int v9; // edx
  signed int v10; // eax
  signed int v11; // eax
  signed int v12; // ecx
  int v13; // eax
  signed int v14; // edx
  signed int v15; // eax
  int v16; // ecx
  signed int v17; // eax
  signed int v18; // eax
  unsigned __int8 v19; // al
  int v20; // esi
  int v21; // ecx
  int v22; // ebx
  int v23; // eax
  int v24; // ecx
  int v25; // eax
  __int64 v26; // rax
  __int64 v27; // rax
  __int16 v28; // si
  char v29; // dl
  char v30; // cl
  unsigned __int8 v31; // al
  int v32; // edx
  unsigned __int8 v33; // al
  int v34; // edx
  signed int v35; // edx
  signed int v36; // eax
  char v37; // ch
  int v38; // edx
  int v39; // edx
  signed int v40; // edx
  int v41; // ebx
  signed int v42; // eax
  signed int v43; // ecx
  signed int v44; // eax
  int v45; // ebx
  int v46; // ecx
  signed int v47; // eax
  int v48; // esi
  signed int v49; // eax
  unsigned __int8 v50; // al
  int v51; // esi
  int v52; // ecx
  int v53; // ebx
  int v54; // eax
  int v55; // ecx
  char v56; // [esp+0h] [ebp-48h]
  int v57; // [esp+34h] [ebp-14h]
  int v58; // [esp+38h] [ebp-10h]
  int v59; // [esp+3Ch] [ebp-Ch]
  int v60; // [esp+40h] [ebp-8h]
  int v61; // [esp+44h] [ebp-4h]

  v61 = -1;
  if ( !byte_E36D0 )
  {
    dword_1805A0 = 0;
    dword_18059C = 0;
    byte_E36D0 = 1;
  }
  if ( !byte_E36D1 )
    return v61;
  switch ( word_1805C2 )
  {
    case 1:
    case 8:
    case 12:
      word_1805C8 = 1;
      v61 = sub_8B790(&unk_18058C);
      if ( word_1805C2 != 8 && word_1805C2 != 12 )
      {
        dword_1805B0 = (signed __int16)dword_E3760;
        dword_1805B4 = SHIWORD(dword_E3760);
        dword_1805B8 = word_E375C;
        dword_1805BC = word_E375E;
        v0 = byte_180664[(unsigned __int8)byte_EB39E];
        word_1805C0 = 0;
        if ( v0 )
          word_1805C0 = 1;
        if ( byte_180664[(unsigned __int8)byte_EB39F] )
          LOBYTE(word_1805C0) = word_1805C0 | 2;
        if ( byte_180664[(unsigned __int8)byte_EB3A0] )
          LOBYTE(word_1805C0) = word_1805C0 | 4;
        if ( byte_180664[(unsigned __int8)byte_EB3A1] )
          LOBYTE(word_1805C0) = word_1805C0 | 8;
        dword_18059C = 0;
        if ( word_180746 )
          dword_18059C = 1;
        if ( word_180744 )
          LOBYTE(dword_18059C) = dword_18059C | 2;
        if ( word_18074C )
          LOBYTE(dword_18059C) = dword_18059C | 4;
        if ( word_18074A )
          LOBYTE(dword_18059C) = dword_18059C | 8;
        if ( byte_180664[(unsigned __int8)byte_EB3A3] )
          LOBYTE(dword_18059C) = dword_18059C | 0x10;
      }
      dword_180594 *= 4;
      dword_180590 = (dword_180590 << 11) / 360;
      if ( word_1805C2 == 8 )
        goto LABEL_53;
      if ( word_1805C2 == 12 )
        goto LABEL_217;
      return v61;
    case 2:
    case 9:
    case 13:
      word_1805C8 = 1;
      sub_75910();
      if ( word_1805C2 != 9 && word_1805C2 != 13 )
      {
        dword_1805B0 = (signed __int16)dword_E3760;
        dword_1805B4 = SHIWORD(dword_E3760);
        dword_1805B8 = word_E375C;
        dword_1805BC = word_E375E;
        v2 = byte_180664[(unsigned __int8)byte_EB39E];
        word_1805C0 = 0;
        if ( v2 )
          word_1805C0 = 1;
        if ( byte_180664[(unsigned __int8)byte_EB39F] )
          LOBYTE(word_1805C0) = word_1805C0 | 2;
        if ( byte_180664[(unsigned __int8)byte_EB3A0] )
          LOBYTE(word_1805C0) = word_1805C0 | 4;
        if ( byte_180664[(unsigned __int8)byte_EB3A1] )
          LOBYTE(word_1805C0) = word_1805C0 | 8;
        dword_18059C = 0;
        if ( word_180746 )
          dword_18059C = 1;
        if ( word_180744 )
          LOBYTE(dword_18059C) = dword_18059C | 2;
        if ( word_18074C )
          LOBYTE(dword_18059C) = dword_18059C | 4;
        if ( word_18074A )
          LOBYTE(dword_18059C) = dword_18059C | 8;
        if ( byte_180664[(unsigned __int8)byte_EB3A3] )
          LOBYTE(dword_18059C) = dword_18059C | 0x10;
      }
      dword_180590 = -2048 * word_17D6CC / 0xFFFFu & 0x7FF;
      if ( byte_1806E4 == 46 )
        sub_759B0();
      if ( word_1805C2 == 9 )
        goto LABEL_53;
      if ( word_1805C2 == 13 )
        goto LABEL_217;
      dword_180594 = 0;
      return v61;
    case 4:
LABEL_53:
      word_1805C0 = 0;
      sub_8BBE0((int)&unk_180560);
      goto LABEL_54;
    case 6:
      memset(&v56, 0, 50);
      sub_8C140(*(_WORD *)dword_E36C4, (int)&v56);
      dword_180590 = *(_DWORD *)(dword_E36C4 + 4);
      v28 = *(_WORD *)(dword_E36C4 + 62);
      dword_180594 = *(_DWORD *)(dword_E36C4 + 8);
      if ( !v28 )
      {
        dword_1805B0 = (signed __int16)dword_E3760;
        dword_1805B4 = SHIWORD(dword_E3760);
        dword_1805B8 = word_E375C;
        dword_1805BC = word_E375E;
        v29 = byte_180664[(unsigned __int8)byte_EB39E];
        word_1805C0 = 0;
        if ( v29 )
          word_1805C0 = 1;
        if ( byte_180664[(unsigned __int8)byte_EB39F] )
          LOBYTE(word_1805C0) = word_1805C0 | 2;
        if ( byte_180664[(unsigned __int8)byte_EB3A0] )
          LOBYTE(word_1805C0) = word_1805C0 | 4;
        if ( byte_180664[(unsigned __int8)byte_EB3A1] )
          LOBYTE(word_1805C0) = word_1805C0 | 8;
        dword_18059C = 0;
        if ( word_180746 )
          dword_18059C = 1;
        if ( word_180744 )
          LOBYTE(dword_18059C) = dword_18059C | 2;
        if ( word_18074C )
          LOBYTE(dword_18059C) = dword_18059C | 4;
        if ( word_18074A )
          LOBYTE(dword_18059C) = dword_18059C | 8;
        if ( byte_180664[(unsigned __int8)byte_EB3A3] )
        {
          LOBYTE(dword_18059C) = dword_18059C | 0x10;
          return v61;
        }
        return v61;
      }
      if ( v28 != 4 )
      {
        if ( v28 != 11 )
          return v61;
        byte_180586 = *(_BYTE *)(dword_E36C4 + 16);
        byte_180588 = dword_1805B0;
        byte_180589 = dword_1805B4;
LABEL_218:
        if ( !(byte_180586 & 1) || byte_180587 & 1 )
        {
          if ( !(byte_180586 & 1) && byte_180587 & 1 )
          {
            LOBYTE(dword_18059C) = dword_18059C & 0xFA;
            byte_180587 &= 0xFEu;
          }
        }
        else
        {
          dword_1805B8 = dword_1805B0;
          LOBYTE(dword_18059C) = dword_18059C | 5;
          dword_1805BC = dword_1805B4;
          byte_180587 |= 1u;
        }
        if ( !(byte_180586 & 2) || byte_180587 & 2 )
        {
          if ( !(byte_180586 & 2) && byte_180587 & 2 )
          {
            LOBYTE(dword_18059C) = dword_18059C & 0xF5;
            byte_180587 &= 0xFDu;
          }
        }
        else
        {
          dword_1805B8 = dword_1805B0;
          LOBYTE(dword_18059C) = dword_18059C | 0xA;
          dword_1805BC = dword_1805B4;
          byte_180587 |= 2u;
        }
        if ( byte_180664[(unsigned __int8)byte_EB3A3] )
        {
          byte_180587 &= 0xF7u;
          byte_180586 &= 0xF7u;
          LOBYTE(dword_18059C) = dword_18059C | 0x10;
        }
        else if ( !(byte_180586 & 8) || byte_180587 & 8 || dword_18059C & 0x10 )
        {
          if ( byte_180586 & 8 || !(byte_180587 & 8) || dword_18059C & 0x10 )
          {
            if ( byte_180586 & 8 && byte_180587 & 8 && dword_18059C & 0x10 )
            {
              byte_180587 &= 0xF7u;
              byte_180586 &= 0xF7u;
            }
            else if ( !(byte_180586 & 8) && !(byte_180587 & 8) && dword_18059C & 0x10 )
            {
              LOBYTE(dword_18059C) = dword_18059C & 0xEF;
            }
          }
          else
          {
            LOBYTE(dword_18059C) = dword_18059C | 0x10;
          }
        }
        else
        {
          byte_180587 |= 8u;
        }
        v31 = *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221);
        if ( v31 < 5u )
        {
          if ( v31 == 3 )
          {
            if ( 82 - *(unsigned __int8 *)(dword_EA3DC + 934) <= dword_1805B0 )
            {
              if ( dword_1805B0 >= 384 )
              {
                if ( word_180660 & 1 )
                  v49 = 400;
                else
                  v49 = 480;
                v60 = v49 - 72;
                if ( v49 - 46 >= dword_1805B4 )
                  v50 = *(_BYTE *)(dword_EA3DC + 1558);
                else
                  v50 = *(_BYTE *)(dword_EA3DC + 946);
                v42 = (signed int)v50 >> 2;
                v9 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 947) >> 1) + v60 + 26;
                v51 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 1559) >> 1) + 4 + v60;
                v59 = 0;
                v60 = v51;
                v41 = 640;
                v43 = *(unsigned __int8 *)(dword_EA3DC + 1559);
              }
              else
              {
                if ( word_180660 & 1 )
                  v47 = 400;
                else
                  v47 = 480;
                v60 = v47 - 72;
                v48 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 929) >> 1) + 32 + v47 - 72;
                v59 = 0;
                v60 = v48;
                v41 = 640;
                v9 = v48;
                v42 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 928) >> 2;
                v43 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 929) >> 1;
              }
            }
            else
            {
              if ( word_180660 & 1 )
                v44 = 400;
              else
                v44 = 480;
              v60 = v44 - 72;
              v45 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 935) >> 1) + 28 + v44 - 72;
              v60 = v45;
              v59 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 934) >> 1) + 4;
              v46 = *(unsigned __int8 *)(dword_EA3DC + 935);
              v9 = v45 + v46;
              v43 = v46 >> 1;
              v42 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 934) >> 2;
              v41 = v59 + 640 - ((signed int)*(unsigned __int8 *)(dword_EA3DC + 934) >> 1);
            }
            goto LABEL_301;
          }
        }
        else if ( v31 <= 5u || v31 == 8 )
        {
          v32 = dword_D41A0 + 11230 + 2124 * *(signed __int16 *)(dword_D41A0 + 12);
          v33 = *(_BYTE *)(v32 + 2109);
          v34 = v32 + 1609;
          if ( v33 )
          {
            if ( v33 <= 2u )
            {
              v58 = 3 * *(unsigned __int8 *)(dword_EA3DC + 982);
              v37 = *(_BYTE *)(v34 + 501);
              if ( v37 < 13 )
                v38 = v37;
              else
                v38 = v37 - 13;
              v39 = *(unsigned __int8 *)(dword_EA3DC + 532)
                  + *(unsigned __int8 *)(dword_EA3DC + 538) * v38
                  + ((signed int)*(unsigned __int8 *)(dword_EA3DC + 538) >> 1)
                  - (v58 >> 1);
              v59 = v39;
              if ( 640 - v58 >= v39 )
              {
                if ( v39 < 0 )
                  v59 = 0;
              }
              else
              {
                v59 = 640 - v58;
              }
              v41 = v58 + v59;
              if ( word_180660 & 1 )
                v40 = 400;
              else
                v40 = 480;
              v9 = v40
                 - 2 * *(unsigned __int8 *)(dword_EA3DC + 539)
                 - ((signed int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1);
              v60 = v9;
              v42 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 982) >> 2;
              v43 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 983) >> 1;
            }
            else
            {
              v41 = 640;
              v9 = 480;
              v42 = 12;
              v43 = 32;
              v59 = 0;
              v60 = 0;
            }
          }
          else
          {
            v41 = 640;
            v59 = 0;
            if ( word_180660 & 1 )
              v35 = 400;
            else
              v35 = 480;
            v9 = v35 - ((signed int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1);
            if ( word_180660 & 1 )
              v36 = 400;
            else
              v36 = 480;
            v60 = v36;
            v60 = v36 - 2 * *(unsigned __int8 *)(dword_EA3DC + 539);
            v60 += (signed int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1;
            v42 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 538) >> 2;
            v43 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1;
          }
          goto LABEL_301;
        }
        if ( *(_BYTE *)(dword_D41A4 + 38546) )
        {
          sub_30BE0(&v59, &v60);
          v59 += (signed int)*(unsigned __int8 *)(dword_EA3DC + 1546) >> 1;
          v52 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 1547) >> 1) + v60;
          v60 = v52;
          v42 = *(unsigned __int8 *)(dword_EA3DC + 1546);
          v9 = v52;
          v41 = v42 + v59;
          v43 = 0;
        }
        else if ( *(_BYTE *)(dword_D41A4 + 225) )
        {
          v53 = *(signed __int16 *)(dword_D41A4 + 186);
          v43 = 4;
          v60 = 67;
          v54 = (v53 >> 1) + (640 - v53) / 2;
          v9 = 393;
          dword_1805B0 = v54;
          v41 = (v53 >> 1) + (640 - v53) / 2;
          v59 = v54;
          v42 = 0;
        }
        else if ( *(_BYTE *)(dword_D41A4 + 38543) )
        {
          sub_2FFE0(&v59, &v60, &v58, &v57);
          v58 -= 2;
          v41 = v58 + v59;
          v9 = 4 * v57 + 12 + v60;
          v43 = 0;
          v42 = 4;
          v60 += 4 * v57 + 12;
        }
        else if ( *(_BYTE *)(dword_D41A4 + 24) & 1 )
        {
          v58 = *(unsigned __int8 *)(dword_EA3DC + 1048);
          v57 = *(unsigned __int8 *)(dword_EA3DC + 1073)
              + *(unsigned __int8 *)(dword_EA3DC + 1061)
              + *(unsigned __int8 *)(dword_EA3DC + 1055)
              + *(unsigned __int8 *)(dword_EA3DC + 1049);
          v60 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 1049) >> 1) + (400 - v57) / 2 - 60;
          v59 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 1048) >> 2) + (640 - v58) / 2;
          v55 = *(unsigned __int8 *)(dword_EA3DC + 1049);
          v9 = v57 + v60 - v55;
          v43 = v55 >> 2;
          v42 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 1048) >> 2;
          v41 = v58 + v59 - ((signed int)*(unsigned __int8 *)(dword_EA3DC + 1048) >> 1);
        }
        else
        {
          v41 = 640;
          v9 = 480;
          v43 = 32;
          v59 = 0;
          v60 = 0;
          v42 = 12;
        }
LABEL_301:
        if ( !(dword_18059C & 0x10)
          && !(*(_BYTE *)(dword_D41A4 + 24) & 1)
          && !*(_BYTE *)(dword_D41A4 + 38546)
          && !*(_BYTE *)(dword_D41A4 + 225)
          && *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) != 3 )
        {
          if ( byte_180586 & 4 )
          {
            if ( byte_180589 < 0 )
              word_1805C0 |= 1u;
            if ( byte_180589 > 0 )
              LOBYTE(word_1805C0) = word_1805C0 | 2;
            if ( byte_180588 < 0 )
              LOBYTE(word_1805C0) = word_1805C0 | 4;
            if ( byte_180588 > 0 )
              LOBYTE(word_1805C0) = word_1805C0 | 8;
          }
          else
          {
            word_E36CC = byte_180588;
            word_E36CE = byte_180589;
            dword_1805B0 = 2 * byte_180588 + 320;
            dword_1805B4 = 2 * byte_180589 + 200;
            if ( byte_180664[(unsigned __int8)byte_EB39E] )
              word_1805C0 |= 1u;
            if ( byte_180664[(unsigned __int8)byte_EB39F] )
              LOBYTE(word_1805C0) = word_1805C0 | 2;
            if ( byte_180664[(unsigned __int8)byte_EB3A0] )
              LOBYTE(word_1805C0) = word_1805C0 | 4;
            if ( byte_180664[(unsigned __int8)byte_EB3A1] )
            {
              LOBYTE(word_1805C0) = word_1805C0 | 8;
              return v61;
            }
          }
          return v61;
        }
        if ( byte_180589 >= 0 )
        {
          if ( byte_180589 > 0 )
            dword_1805B4 += v43;
        }
        else
        {
          dword_1805B4 -= v43;
        }
        if ( byte_180588 >= 0 )
        {
          if ( byte_180588 > 0 )
            dword_1805B0 += v42;
        }
        else
        {
          dword_1805B0 -= v42;
        }
        if ( dword_1805B0 >= v59 )
        {
          if ( v41 < dword_1805B0 )
            dword_1805B0 = v41;
        }
        else
        {
          dword_1805B0 = v59;
        }
        v25 = dword_1805B4;
        if ( dword_1805B4 < v60 )
        {
          dword_1805B4 = v60;
          return v61;
        }
LABEL_157:
        if ( v9 >= v25 )
          return v61;
        dword_1805B4 = v9;
        return v61;
      }
      byte_180586 = *(_BYTE *)(dword_E36C4 + 16);
      byte_180588 = dword_1805B0;
      byte_180589 = dword_1805B4;
LABEL_54:
      if ( !(byte_180586 & 1) || byte_180587 & 1 )
      {
        if ( !(byte_180586 & 1) && byte_180587 & 1 )
        {
          LOBYTE(dword_18059C) = dword_18059C & 0xFA;
          byte_180587 &= 0xFEu;
        }
      }
      else
      {
        LOBYTE(dword_18059C) = dword_18059C | 5;
        dword_1805B8 = dword_1805B0;
        byte_180587 |= 1u;
        dword_1805BC = dword_1805B4;
      }
      if ( !(byte_180586 & 2) || byte_180587 & 2 )
      {
        if ( !(byte_180586 & 2) && byte_180587 & 2 )
        {
          LOBYTE(dword_18059C) = dword_18059C & 0xF5;
          byte_180587 &= 0xFDu;
        }
      }
      else
      {
        LOBYTE(dword_18059C) = dword_18059C | 0xA;
        dword_1805B8 = dword_1805B0;
        byte_180587 |= 2u;
        dword_1805BC = dword_1805B4;
      }
      if ( byte_180664[(unsigned __int8)byte_EB3A3] )
      {
        byte_180586 &= 0xF7u;
        LOBYTE(dword_18059C) = dword_18059C | 0x10;
        byte_180587 &= 0xF7u;
      }
      else if ( !(*(_BYTE *)(dword_D41A4 + 24) & 1) )
      {
        if ( !(byte_180586 & 8) || byte_180587 & 8 || dword_18059C & 0x10 )
        {
          if ( byte_180586 & 8 || !(byte_180587 & 8) || dword_18059C & 0x10 )
          {
            if ( byte_180586 & 8 && byte_180587 & 8 && dword_18059C & 0x10 )
            {
              byte_180587 &= 0xF7u;
              byte_180586 &= 0xF7u;
            }
            else if ( !(byte_180586 & 8) && !(byte_180587 & 8) && dword_18059C & 0x10 )
            {
              LOBYTE(dword_18059C) = dword_18059C & 0xEF;
            }
          }
          else
          {
            LOBYTE(dword_18059C) = dword_18059C | 0x10;
          }
        }
        else
        {
          byte_180587 |= 8u;
        }
      }
      v3 = *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221);
      if ( v3 < 5u )
      {
        if ( v3 == 3 )
        {
          if ( 82 - *(unsigned __int8 *)(dword_EA3DC + 934) <= dword_1805B0 )
          {
            if ( dword_1805B0 >= 384 )
            {
              if ( word_180660 & 1 )
                v18 = 400;
              else
                v18 = 480;
              v60 = v18 - 72;
              if ( v18 - 46 >= dword_1805B4 )
                v19 = *(_BYTE *)(dword_EA3DC + 1558);
              else
                v19 = *(_BYTE *)(dword_EA3DC + 946);
              v11 = (signed int)v19 >> 2;
              v9 = v60 + 26 + ((signed int)*(unsigned __int8 *)(dword_EA3DC + 947) >> 1);
              v20 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 1559) >> 1) + 4 + v60;
              v59 = 0;
              v60 = v20;
              v7 = 640;
              v12 = *(unsigned __int8 *)(dword_EA3DC + 1559);
            }
            else
            {
              if ( word_180660 & 1 )
                v17 = 400;
              else
                v17 = 480;
              v60 = v17 - 72;
              v9 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 929) >> 1) + 32 + v17 - 72;
              v59 = 0;
              v60 = v9;
              v7 = 640;
              v11 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 928) >> 2;
              v12 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 929) >> 1;
            }
          }
          else
          {
            if ( word_180660 & 1 )
              v15 = 400;
            else
              v15 = 480;
            v60 = v15 - 72;
            v60 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 935) >> 1) + 28 + v15 - 72;
            v59 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 934) >> 1) + 4;
            v16 = *(unsigned __int8 *)(dword_EA3DC + 935);
            v9 = v60 + v16;
            v12 = v16 >> 1;
            v11 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 934) >> 2;
            v7 = v59 + 640 - ((signed int)*(unsigned __int8 *)(dword_EA3DC + 934) >> 1);
          }
          goto LABEL_138;
        }
      }
      else if ( v3 <= 5u || v3 == 8 )
      {
        v4 = 2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230;
        v5 = v4 + 1609;
        v6 = *(_BYTE *)(v4 + 2109);
        if ( !v6 )
        {
          v7 = 640;
          v59 = 0;
          if ( word_180660 & 1 )
            v8 = 400;
          else
            v8 = 480;
          v9 = v8 - ((signed int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1);
          if ( word_180660 & 1 )
            v10 = 400;
          else
            v10 = 480;
          v60 = v10;
          v60 = v10 - 2 * *(unsigned __int8 *)(dword_EA3DC + 539);
          v60 += (signed int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1;
          v11 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 538) >> 2;
          v12 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1;
          goto LABEL_138;
        }
        if ( v6 <= 2u )
        {
          v58 = 3 * *(unsigned __int8 *)(dword_EA3DC + 982);
          LOBYTE(v13) = *(_BYTE *)(v5 + 501);
          if ( (char)v13 < 13 )
            v13 = (char)v13;
          else
            v13 = (char)v13 - 13;
          v59 = *(unsigned __int8 *)(dword_EA3DC + 538) * v13
              + *(unsigned __int8 *)(dword_EA3DC + 532)
              + ((signed int)*(unsigned __int8 *)(dword_EA3DC + 538) >> 1)
              - (v58 >> 1);
          if ( 640 - v58 >= v59 )
          {
            if ( v59 < 0 )
              v59 = 0;
          }
          else
          {
            v59 = 640 - v58;
          }
          v7 = v58 + v59;
          if ( word_180660 & 1 )
            v14 = 400;
          else
            v14 = 480;
          v9 = v14
             - 2 * *(unsigned __int8 *)(dword_EA3DC + 539)
             - ((signed int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1);
          v60 = v9;
          v11 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 982) >> 2;
          v12 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 983) >> 1;
          goto LABEL_138;
        }
        goto LABEL_137;
      }
      if ( *(_BYTE *)(dword_D41A4 + 38546) )
      {
        sub_30BE0(&v59, &v60);
        v59 += (signed int)*(unsigned __int8 *)(dword_EA3DC + 1546) >> 1;
        v21 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 1547) >> 1) + v60;
        v60 = v21;
        v11 = *(unsigned __int8 *)(dword_EA3DC + 1546);
        v9 = v21;
        v7 = v11 + v59;
        v12 = 0;
        goto LABEL_138;
      }
      if ( *(_BYTE *)(dword_D41A4 + 225) )
      {
        v22 = *(signed __int16 *)(dword_D41A4 + 186);
        v12 = 4;
        v60 = 67;
        v23 = (v22 >> 1) + (640 - v22) / 2;
        v9 = 393;
        dword_1805B0 = v23;
        v7 = (v22 >> 1) + (640 - v22) / 2;
        v59 = v23;
        v11 = 0;
        goto LABEL_138;
      }
      if ( *(_BYTE *)(dword_D41A4 + 38543) )
      {
        sub_2FFE0(&v59, &v60, &v58, &v57);
        v58 -= 2;
        v7 = v58 + v59;
        v9 = 4 * v57 + 12 + v60;
        v12 = 0;
        v11 = 4;
        v60 += 4 * v57 + 12;
        goto LABEL_138;
      }
      if ( *(_BYTE *)(dword_D41A4 + 24) & 1 )
      {
        v58 = *(unsigned __int8 *)(dword_EA3DC + 1048);
        v57 = *(unsigned __int8 *)(dword_EA3DC + 1073)
            + *(unsigned __int8 *)(dword_EA3DC + 1061)
            + *(unsigned __int8 *)(dword_EA3DC + 1055)
            + *(unsigned __int8 *)(dword_EA3DC + 1049);
        v60 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 1049) >> 1) + (400 - v57) / 2 - 60;
        v59 = ((signed int)*(unsigned __int8 *)(dword_EA3DC + 1048) >> 2) + (640 - v58) / 2;
        v24 = *(unsigned __int8 *)(dword_EA3DC + 1049);
        v9 = v57 + v60 - v24;
        v12 = v24 >> 2;
        v11 = (signed int)*(unsigned __int8 *)(dword_EA3DC + 1048) >> 2;
        v7 = v58 + v59 - ((signed int)*(unsigned __int8 *)(dword_EA3DC + 1048) >> 1);
        goto LABEL_138;
      }
LABEL_137:
      v7 = 640;
      v9 = 480;
      v12 = 32;
      v59 = 0;
      v60 = 0;
      v11 = 12;
LABEL_138:
      if ( dword_18059C & 0x10
        || *(_BYTE *)(dword_D41A4 + 24) & 1
        || *(_BYTE *)(dword_D41A4 + 38546)
        || *(_BYTE *)(dword_D41A4 + 225)
        || *(_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) == 3 )
      {
        if ( byte_180589 >= 0 )
        {
          if ( byte_180589 > 0 )
            dword_1805B4 += v12;
        }
        else
        {
          dword_1805B4 -= v12;
        }
        if ( byte_180588 >= 0 )
        {
          if ( byte_180588 > 0 )
            dword_1805B0 += v11;
        }
        else
        {
          dword_1805B0 -= v11;
        }
        if ( dword_1805B0 >= v59 )
        {
          if ( v7 < dword_1805B0 )
            dword_1805B0 = v7;
        }
        else
        {
          dword_1805B0 = v59;
        }
        v25 = dword_1805B4;
        if ( dword_1805B4 < v60 )
        {
          dword_1805B4 = v60;
          return v61;
        }
        goto LABEL_157;
      }
      if ( byte_180586 & 4 )
      {
        if ( byte_180589 < 0 )
          word_1805C0 |= 1u;
        if ( byte_180589 > 0 )
          LOBYTE(word_1805C0) = word_1805C0 | 2;
        if ( byte_180588 < 0 )
          LOBYTE(word_1805C0) = word_1805C0 | 4;
        if ( byte_180588 > 0 )
        {
          LOBYTE(word_1805C0) = word_1805C0 | 8;
          return v61;
        }
      }
      else
      {
        v26 = 28 * (signed __int16)(32 * byte_180588 + word_E36CC);
        word_E36CC = (signed int)(v26 - (__CFSHL__(HIDWORD(v26), 5) + 32 * HIDWORD(v26))) >> 5;
        v27 = 31 * (signed __int16)(16 * byte_180589 + word_E36CE);
        word_E36CE = (signed int)(v27 - (__CFSHL__(HIDWORD(v27), 5) + 32 * HIDWORD(v27))) >> 5;
        dword_1805B0 = 2 * word_E36CC + 320;
        dword_1805B4 = 2 * word_E36CE + 200;
        if ( byte_180664[(unsigned __int8)byte_EB39E] )
          word_1805C0 |= 1u;
        if ( byte_180664[(unsigned __int8)byte_EB39F] )
          LOBYTE(word_1805C0) = word_1805C0 | 2;
        if ( byte_180664[(unsigned __int8)byte_EB3A0] )
          LOBYTE(word_1805C0) = word_1805C0 | 4;
        if ( byte_180664[(unsigned __int8)byte_EB3A1] )
        {
          LOBYTE(word_1805C0) = word_1805C0 | 8;
          return v61;
        }
      }
      return v61;
    case 7:
      dword_1805B0 = (signed __int16)dword_E3760;
      dword_1805B4 = SHIWORD(dword_E3760);
      dword_1805B8 = word_E375C;
      dword_1805BC = word_E375E;
      v30 = byte_180664[(unsigned __int8)byte_EB39E];
      word_1805C0 = 0;
      if ( v30 )
        word_1805C0 = 1;
      if ( byte_180664[(unsigned __int8)byte_EB39F] )
        LOBYTE(word_1805C0) = word_1805C0 | 2;
      if ( byte_180664[(unsigned __int8)byte_EB3A0] )
        LOBYTE(word_1805C0) = word_1805C0 | 4;
      if ( byte_180664[(unsigned __int8)byte_EB3A1] )
        LOBYTE(word_1805C0) = word_1805C0 | 8;
      dword_18059C = 0;
      if ( word_180746 )
        dword_18059C = 1;
      if ( word_180744 )
        LOBYTE(dword_18059C) = dword_18059C | 2;
      if ( word_18074C )
        LOBYTE(dword_18059C) = dword_18059C | 4;
      if ( word_18074A )
        LOBYTE(dword_18059C) = dword_18059C | 8;
      if ( !byte_180664[(unsigned __int8)byte_EB3A3] )
        return v61;
      LOBYTE(dword_18059C) = dword_18059C | 0x10;
      return v61;
    case 11:
LABEL_217:
      word_1805C0 = 0;
      sub_8BBE0((int)&unk_180560);
      goto LABEL_218;
    default:
      return v61;
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E36C4: using guessed type int dword_E36C4;
// E36CC: using guessed type __int16 word_E36CC;
// E36CE: using guessed type __int16 word_E36CE;
// E36D0: using guessed type char byte_E36D0;
// E36D1: using guessed type char byte_E36D1;
// E375C: using guessed type __int16 word_E375C;
// E375E: using guessed type __int16 word_E375E;
// E3760: using guessed type int dword_E3760;
// EA3DC: using guessed type int dword_EA3DC;
// EB39E: using guessed type char byte_EB39E;
// EB39F: using guessed type char byte_EB39F;
// EB3A0: using guessed type char byte_EB3A0;
// EB3A1: using guessed type char byte_EB3A1;
// EB3A3: using guessed type char byte_EB3A3;
// 17D6CC: using guessed type __int16 word_17D6CC;
// 180586: using guessed type char byte_180586;
// 180587: using guessed type char byte_180587;
// 180588: using guessed type char byte_180588;
// 180589: using guessed type char byte_180589;
// 180590: using guessed type int dword_180590;
// 180594: using guessed type int dword_180594;
// 180598: using guessed type int dword_180598;
// 18059C: using guessed type int dword_18059C;
// 1805A0: using guessed type int dword_1805A0;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805B8: using guessed type int dword_1805B8;
// 1805BC: using guessed type int dword_1805BC;
// 1805C0: using guessed type __int16 word_1805C0;
// 1805C2: using guessed type __int16 word_1805C2;
// 1805C8: using guessed type __int16 word_1805C8;
// 180660: using guessed type __int16 word_180660;
// 1806E4: using guessed type char byte_1806E4;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;
// 18074A: using guessed type __int16 word_18074A;
// 18074C: using guessed type __int16 word_18074C;

//----- (0008B5A0) --------------------------------------------------------
int sub_8B5A0()
{
  if ( byte_E36D1 )
  {
    switch ( word_1805C2 )
    {
      case 1:
        sub_8B770();
        break;
      case 9:
        sub_75900();
        break;
      default:
        break;
    }
    byte_E36D1 = 0;
  }
  return 0;
}
// E36D1: using guessed type char byte_E36D1;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (0008B600) --------------------------------------------------------
signed int __cdecl sub_8B600(int a1)
{
  int v1; // edi
  char v2; // bl
  __int16 v3; // dx
  char v4; // al
  int v5; // edx
  int v6; // eax
  int v7; // eax
  char v9; // [esp+0h] [ebp-40h]
  char v10; // [esp+3Ch] [ebp-4h]

  v1 = sub_9AD9C(3);
  memset(&v9, 0, 60);
  memset(a1 + 66, 0, 84);
  v2 = 1;
  switch ( *(_WORD *)(a1 + 58) )
  {
    case 1:
      v2 = 0;
      break;
    case 3:
      v2 = 2;
      break;
    case 4:
      v2 = 3;
      break;
    default:
      break;
  }
  v3 = *(_WORD *)(a1 + 56);
  switch ( v3 )
  {
    case 1200:
      v4 = sub_8B880((int *)(a1 + 66), v2, 1200, v1);
      break;
    case 2400:
      v4 = sub_8B880((int *)(a1 + 66), v2, 2400, v1);
      break;
    case 4800:
      v4 = sub_8B880((int *)(a1 + 66), v2, 4800, v1);
      break;
    case 9600:
      v4 = sub_8B880((int *)(a1 + 66), v2, 9600, v1);
      break;
    case 19200:
      v4 = sub_8B880((int *)(a1 + 66), v2, 19200, v1);
      break;
    default:
      goto LABEL_16;
  }
  v10 = v4;
LABEL_16:
  sub_9B498(v10);
  printf(aS_1);
  sub_8BA10((int)&v9, v5, (int *)(a1 + 66), &v9, v1);
  printf(&v9);
  printf(&unk_D1F0C);
  v6 = sub_9AD9C(2);
  sub_9B038((int *)(a1 + 66), (char *)&off_D1F10, v6);
  v7 = sub_9AD9C(2);
  if ( !sub_9B038((int *)(a1 + 66), aM1PB, v7) )
    return 1;
  sub_9B234((int *)(a1 + 66));
  printf(aCouldNotSendIn);
  return -1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D1F10: using guessed type void *off_D1F10;

//----- (0008B770) --------------------------------------------------------
int sub_8B770()
{
  return sub_9B234((int *)&unk_1805CE);
}

//----- (0008B790) --------------------------------------------------------
signed int __cdecl sub_8B790(_DWORD *a1)
{
  int v1; // eax
  signed int v2; // esi
  signed int v3; // eax
  double v4; // st7
  double v5; // st7
  int v6; // eax
  double v7; // st7
  int v8; // eax
  int v9; // ecx
  int v10; // edi
  int v11; // eax
  int v12; // ecx
  int v13; // eax
  int v14; // edx

  v1 = sub_9AD9C(1);
  v2 = 1;
  if ( sub_9B274((_DWORD *)((char *)a1 + 66), v1 / 2) )
    v2 = -1;
  v3 = sub_9B260((_DWORD **)((char *)a1 + 66));
  v4 = (double)*(signed int *)((char *)a1 + 94) * flt_D1F40;
  _CHP(v3);
  a1[1] = (signed int)v4;
  v5 = (double)*(signed int *)((char *)a1 + 90) * flt_D1F40;
  _CHP(v6);
  a1[2] = (signed int)v5;
  v7 = (double)*(signed int *)((char *)a1 + 98) * flt_D1F40;
  _CHP(v8);
  a1[3] = (signed int)v7;
  if ( byte_1806E4 == 46 )
  {
    dword_1805A4 = dword_180590;
    dword_1805A8 = dword_180594;
    dword_1805AC = dword_180598;
  }
  else
  {
    v9 = a1[2];
    v10 = a1[3];
    v11 = a1[7];
    a1[1] -= a1[6];
    v12 = v9 - v11;
    v13 = a1[8];
    a1[2] = v12;
    a1[3] = v10 - v13;
  }
  v14 = -a1[2];
  a1[1] = -a1[1];
  a1[2] = v14;
  return v2;
}
// 9B4F6: using guessed type double __fastcall _CHP(_DWORD);
// D1F40: using guessed type float flt_D1F40;
// 180590: using guessed type int dword_180590;
// 180594: using guessed type int dword_180594;
// 180598: using guessed type int dword_180598;
// 1805A4: using guessed type int dword_1805A4;
// 1805A8: using guessed type int dword_1805A8;
// 1805AC: using guessed type int dword_1805AC;
// 1806E4: using guessed type char byte_1806E4;

//----- (0008B880) --------------------------------------------------------
char __cdecl sub_8B880(int *a1, char a2, signed int a3, int a4)
{
  int v4; // esi
  char result; // al
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // edx

  switch ( a2 )
  {
    case 0:
      v4 = 0;
      goto LABEL_7;
    case 1:
      v4 = 1;
      goto LABEL_7;
    case 2:
      v4 = 2;
      goto LABEL_7;
    case 3:
      v4 = 3;
LABEL_7:
      v6 = calloc(1, 90);
      *a1 = v6;
      if ( v6 )
      {
        v7 = sub_9BE18(v6, v4, 1, 0x400u, 0x400u);
        if ( v7 )
        {
          if ( v7 == -1 )
          {
            printf(aNoSerial);
            result = 1;
          }
          else
          {
            printf(aNoMemory);
            result = 9;
          }
        }
        else
        {
          sub_9BAC4(*a1, a3);
          sub_9CCF8(*a1, 1);
          sub_9CD9C(*a1, 1);
          v8 = sub_9CCB4(*a1, 0);
          result = sub_8B980(v8, v9, (_DWORD **)a1, a4);
        }
      }
      else
      {
        printf(aNoMemoryForSer);
        result = 1;
      }
      break;
    default:
      result = 1;
      break;
  }
  return result;
}
// 9B513: using guessed type _DWORD __cdecl calloc(_DWORD, _DWORD);

//----- (0008B980) --------------------------------------------------------
char __usercall sub_8B980@<al>(int a1@<eax>, int a2@<edx>, _DWORD **a3, int a4)
{
  int v4; // edi
  bool v5; // eax
  int v6; // edx
  int v7; // esi
  int v9; // eax
  int v10; // edx
  int v11; // eax

  v4 = j_j___clock(a1, a2, a3);
  sub_9CBBC(*a3);
  do
  {
    v7 = j_j___clock(v5, v6, a3);
    sub_9AEEC(a3, (char *)&off_D1F10);
    do
    {
      if ( !sub_9C9D0((int)*a3) && sub_9C938(*a3) == 79 )
        return 0;
      v9 = sub_9ADB4(1);
      v11 = sub_9AE04(v9, v10, (int)a3, v7, v9);
    }
    while ( !v11 );
    v5 = sub_9AE04(v11, a4, (int)a3, v4, a4);
  }
  while ( !v5 );
  return 3;
}
// 9ADFC: using guessed type int __fastcall j_j___clock(_DWORD, _DWORD, _DWORD);
// D1F10: using guessed type void *off_D1F10;

//----- (0008BA10) --------------------------------------------------------
char __usercall sub_8BA10@<al>(int a1@<eax>, int a2@<edx>, int *a3, char *a4, int a5)
{
  int v5; // esi
  bool v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // edx
  char v10; // ah
  unsigned int i; // edx
  char v12; // cl
  double v13; // rax
  int v15; // eax
  int v16; // edx
  int v17; // eax
  int v18; // [esp+8h] [ebp-4h]

  v5 = j_j___clock(a1, a2, a4);
  sub_9CBBC((_DWORD *)*a3);
  while ( 2 )
  {
    v18 = j_j___clock(v6, v7, a4);
    sub_9AEEC((_DWORD **)a3, (char *)&off_D1F78);
    do
    {
      sub_9AEEC((_DWORD **)a3, (char *)&off_D1F78);
      sub_9AE90(v8, v9, (int)a4, a3, a4, 60, a5);
      v10 = *a4;
      a4[59] = 0;
      if ( v10 == 77 )
      {
        for ( i = 0; i < strlen(a4); ++i )
        {
          v12 = a4[i];
          if ( v12 == 70 || v12 == 102 )
          {
            LODWORD(v13) = strtod(&a4[i + 1], 0);
            if ( v13 < dbl_D1F7C )
              dword_E36C8 = 0;
            return 0;
          }
        }
        return 0;
      }
      v15 = sub_9ADB4(1);
      v17 = sub_9AE04(v18, v16, (int)a4, v18, v15);
    }
    while ( !v17 );
    v6 = sub_9AE04(v17, a5, (int)a4, v5, a5);
    if ( !v6 )
      continue;
    break;
  }
  return 3;
}
// 9ADFC: using guessed type int __fastcall j_j___clock(_DWORD, _DWORD, _DWORD);
// 9CF81: using guessed type _DWORD __cdecl strtod(_DWORD, _DWORD);
// D1F78: using guessed type void *off_D1F78;
// D1F7C: using guessed type double dbl_D1F7C;
// E36C8: using guessed type int dword_E36C8;

//----- (0008BB10) --------------------------------------------------------
int __cdecl sub_8BB10(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 36) = 2;
  *(_DWORD *)(a1 + 8) = 10000000;
  *(_DWORD *)(a1 + 20) = 10000000;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return result;
}

//----- (0008BB40) --------------------------------------------------------
int __cdecl sub_8BB40(int a1, char a2)
{
  int result; // eax

  *(_BYTE *)(a1 + 37) = a2;
  result = sub_8BB10(a1);
  BYTE1(result) = a2;
  if ( a2 == 8 )
  {
    *(_BYTE *)(a1 + 37) = 7;
    *(_BYTE *)(a1 + 36) = 3;
  }
  return result;
}

//----- (0008BBE0) --------------------------------------------------------
signed int __cdecl sub_8BBE0(int a1)
{
  char v1; // dl
  unsigned __int8 v2; // al
  char v3; // al
  signed int result; // eax
  signed int v5; // ecx
  unsigned __int8 v6; // al
  signed int v7; // ecx
  unsigned __int8 v8; // al
  signed int v9; // ecx
  unsigned __int8 v10; // al
  unsigned __int8 v11; // al
  int v12; // esi
  int v13; // esi
  int v14; // edi
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // esi
  int v19; // eax
  int v20; // eax
  int v21; // ecx
  int v22; // esi
  int v23; // eax
  int v24; // ecx
  int v25; // edi
  int v26; // eax
  int v27; // ecx
  int v28; // esi
  int v29; // eax
  int v30; // eax
  int v31; // ecx
  int v32; // esi
  int v33; // eax
  char v34; // al
  int v35; // edx
  int v36; // esi
  unsigned __int8 v37; // al
  int v38; // eax
  char v39; // dh
  int v40; // [esp+0h] [ebp-14h]
  int v41; // [esp+4h] [ebp-10h]
  int v42; // [esp+8h] [ebp-Ch]
  int v43; // [esp+Ch] [ebp-8h]
  unsigned __int8 v44; // [esp+10h] [ebp-4h]
  char v45; // [esp+10h] [ebp-4h]

  v1 = 0;
  v43 = 0;
  v42 = 0;
  v41 = 0;
  v40 = 0;
  v44 = 0;
  if ( *(_BYTE *)(a1 + 36) )
  {
    _disable();
    v2 = *(_BYTE *)(a1 + 37);
    switch ( v2 )
    {
      case 0u:
LABEL_3:
        *(_BYTE *)(a1 + 38) = 0;
        *(_BYTE *)(a1 + 43) = 0;
        v3 = *(_BYTE *)(a1 + 43);
        *(_BYTE *)(a1 + 42) = v3;
        *(_BYTE *)(a1 + 41) = v3;
        *(_BYTE *)(a1 + 40) = v3;
        return 0;
      case 1u:
      case 2u:
      case 3u:
      case 4u:
        v5 = 10000;
        _disable();
        v1 = 1;
        __outbyte(0x201u, v2);
        do
        {
          v6 = __inbyte(0x201u);
          if ( !(v6 & 3) )
            break;
          if ( v6 & 1 )
            ++v43;
          if ( v6 & 2 )
            ++v42;
          --v5;
        }
        while ( v5 );
        _enable();
        v44 = v6;
        if ( !v5 )
          *(_BYTE *)(a1 + 36) = 0;
        break;
      case 5u:
      case 6u:
        v7 = 10000;
        _disable();
        v1 = 1;
        __outbyte(0x201u, v2);
        do
        {
          v8 = __inbyte(0x201u);
          if ( !(v8 & 0xB) )
            break;
          if ( v8 & 1 )
            ++v43;
          if ( v8 & 2 )
            ++v42;
          if ( v8 & 8 )
            ++v40;
          --v7;
        }
        while ( v7 );
        _enable();
        v44 = v8;
        if ( !v7 )
          *(_BYTE *)(a1 + 36) = 0;
        break;
      case 7u:
        v9 = 10000;
        _disable();
        v1 = 1;
        __outbyte(0x201u, v2);
        do
        {
          v10 = __inbyte(0x201u);
          if ( !(v10 & 0xF) )
            break;
          if ( v10 & 1 )
            ++v43;
          if ( v10 & 2 )
            ++v42;
          if ( v10 & 4 )
            ++v41;
          if ( v10 & 8 )
            ++v40;
          --v9;
        }
        while ( v9 );
        _enable();
        v44 = v10;
        if ( !v9 )
        {
          if ( *(_BYTE *)(a1 + 36) == 3 )
          {
            v1 = 123;
            *(_BYTE *)(a1 + 37) = 2;
          }
          else
          {
            *(_BYTE *)(a1 + 36) = 1;
          }
        }
        break;
      default:
        break;
    }
    _enable();
  }
  v45 = (~v44 >> 4) & 0xF;
  v11 = *(_BYTE *)(a1 + 37);
  if ( v11 < 3u )
  {
    if ( v11 != 1 )
      goto LABEL_46;
    goto LABEL_45;
  }
  if ( v11 <= 3u || v11 == 5 )
LABEL_45:
    v45 &= 3u;
LABEL_46:
  switch ( *(_BYTE *)(a1 + 36) )
  {
    case 0:
      goto LABEL_3;
    case 1:
      *(_BYTE *)(a1 + 38) = v45;
      switch ( *(_BYTE *)(a1 + 37) )
      {
        case 1:
        case 2:
          goto LABEL_52;
        case 3:
        case 4:
          goto LABEL_66;
        case 5:
        case 6:
          switch ( 8 * v40 / *(_DWORD *)(a1 + 32) )
          {
            case 0:
              *(_BYTE *)(a1 + 42) = 0;
              *(_BYTE *)(a1 + 43) = -1;
              goto LABEL_66;
            case 1:
            case 2:
              *(_BYTE *)(a1 + 42) = 1;
              break;
            case 3:
            case 4:
              *(_BYTE *)(a1 + 42) = 0;
              *(_BYTE *)(a1 + 43) = 1;
              goto LABEL_66;
            case 5:
            case 6:
              *(_BYTE *)(a1 + 42) = -1;
              break;
            default:
              *(_BYTE *)(a1 + 42) = 0;
              break;
          }
          *(_BYTE *)(a1 + 43) = 0;
LABEL_66:
          v14 = *(_DWORD *)(a1 + 16);
          v15 = v43 - v14;
          if ( v43 - v14 < 0 )
          {
            v20 = (*(_DWORD *)(a1 + 8) - v14) >> 3;
            v21 = v15 - v20;
            v22 = *(_DWORD *)(a1 + 8) - v14 - 2 * v20;
            if ( v21 <= 0 )
            {
              if ( *(_DWORD *)(a1 + 8) - v14 == 2 * v20 )
                v22 = 1;
              v23 = -127 * v21 / v22;
              if ( v23 <= -127 )
                *(_BYTE *)(a1 + 40) = -127;
              else
                *(_BYTE *)(a1 + 40) = v23;
            }
            else
            {
              *(_BYTE *)(a1 + 40) = 0;
            }
          }
          else
          {
            v16 = (*(_DWORD *)(a1 + 12) - v14) >> 3;
            v17 = v15 - v16;
            v18 = *(_DWORD *)(a1 + 12) - v14 - 2 * v16;
            if ( v17 >= 0 )
            {
              if ( *(_DWORD *)(a1 + 12) - v14 == 2 * v16 )
                v18 = 1;
              v19 = 127 * v17 / v18;
              if ( v19 >= 127 )
                *(_BYTE *)(a1 + 40) = 127;
              else
                *(_BYTE *)(a1 + 40) = v19;
            }
            else
            {
              *(_BYTE *)(a1 + 40) = 0;
            }
          }
          v24 = v42 - *(_DWORD *)(a1 + 28);
          if ( v24 < 0 )
          {
            v30 = (*(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 28)) >> 3;
            v31 = v24 - v30;
            v32 = *(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 28) - 2 * v30;
            if ( v31 <= 0 )
            {
              if ( *(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 28) == 2 * v30 )
                v32 = 1;
              v33 = -127 * v31 / v32;
              if ( v33 <= -127 )
                *(_BYTE *)(a1 + 41) = -127;
              else
                *(_BYTE *)(a1 + 41) = v33;
              result = 0;
            }
            else
            {
              *(_BYTE *)(a1 + 41) = 0;
              result = 0;
            }
          }
          else
          {
            v25 = *(_DWORD *)(a1 + 28);
            v26 = (*(_DWORD *)(a1 + 24) - v25) >> 3;
            v27 = v24 - v26;
            v28 = *(_DWORD *)(a1 + 24) - v25 - 2 * v26;
            if ( v27 >= 0 )
            {
              if ( *(_DWORD *)(a1 + 24) - v25 == 2 * v26 )
                v28 = 1;
              v29 = 127 * v27 / v28;
              if ( v29 >= 127 )
                *(_BYTE *)(a1 + 41) = 127;
              else
                *(_BYTE *)(a1 + 41) = v29;
              result = 0;
            }
            else
            {
              *(_BYTE *)(a1 + 41) = 0;
              result = 0;
            }
          }
          break;
        case 7:
          if ( v41 < *(_DWORD *)(a1 + 32) )
            *(_BYTE *)(a1 + 38) |= 0x10u;
          if ( v40 < *(_DWORD *)(a1 + 32) )
            *(_BYTE *)(a1 + 38) |= 0x20u;
LABEL_52:
          v12 = *(_DWORD *)(a1 + 16);
          if ( (v12 + *(_DWORD *)(a1 + 8)) >> 1 <= v43 )
            *(_BYTE *)(a1 + 40) = (v12 + *(_DWORD *)(a1 + 12)) >> 1 < v43;
          else
            *(_BYTE *)(a1 + 40) = -1;
          v13 = *(_DWORD *)(a1 + 28);
          if ( (v13 + *(_DWORD *)(a1 + 20)) >> 1 <= v42 )
            *(_BYTE *)(a1 + 41) = (v13 + *(_DWORD *)(a1 + 24)) >> 1 < v42;
          else
            *(_BYTE *)(a1 + 41) = -1;
          *(_DWORD *)a1 = v43;
          *(_DWORD *)(a1 + 4) = v42;
          result = 0;
          break;
        default:
          goto LABEL_123;
      }
      return result;
    case 2:
      *(_BYTE *)(a1 + 38) = 0;
      *(_BYTE *)(a1 + 43) = 0;
      v34 = *(_BYTE *)(a1 + 43);
      *(_BYTE *)(a1 + 42) = v34;
      *(_BYTE *)(a1 + 41) = v34;
      *(_BYTE *)(a1 + 40) = v34;
      if ( !(v45 & 1)
        || (*(_DWORD *)(a1 + 16) = v43,
            *(_DWORD *)(a1 + 28) = v42,
            v35 = *(_DWORD *)(a1 + 16),
            v35 <= *(_DWORD *)(a1 + 8))
        || v35 >= *(_DWORD *)(a1 + 12)
        || (v36 = *(_DWORD *)(a1 + 28), *(_DWORD *)(a1 + 20) >= v36)
        || v36 >= *(_DWORD *)(a1 + 24) )
      {
        if ( v43 < *(_DWORD *)(a1 + 8) )
          *(_DWORD *)(a1 + 8) = v43;
        if ( v43 > *(_DWORD *)(a1 + 12) )
          *(_DWORD *)(a1 + 12) = v43;
        if ( v42 < *(_DWORD *)(a1 + 20) )
          *(_DWORD *)(a1 + 20) = v42;
        if ( v42 > *(_DWORD *)(a1 + 24) )
          *(_DWORD *)(a1 + 24) = v42;
        return 1;
      }
      v37 = *(_BYTE *)(a1 + 37);
      if ( v37 < 5u )
        goto LABEL_122;
      if ( v37 <= 6u )
      {
        v38 = v40;
      }
      else
      {
        if ( v37 != 7 )
          goto LABEL_122;
        v38 = (v40 + v41) >> 2;
      }
      *(_DWORD *)(a1 + 32) = v38;
LABEL_122:
      *(_BYTE *)(a1 + 36) = 1;
LABEL_123:
      result = 0;
      break;
    case 3:
      if ( v1 == 123 )
        goto LABEL_123;
      *(_DWORD *)(a1 + 16) = v43;
      *(_DWORD *)(a1 + 28) = v42;
      *(_DWORD *)(a1 + 12) = v43 / 2 + v43;
      *(_DWORD *)(a1 + 24) = v42 / 2 + v42;
      *(_DWORD *)(a1 + 8) = v43 / 6;
      v39 = *(_BYTE *)(a1 + 37);
      *(_DWORD *)(a1 + 20) = v42 / 6;
      if ( v39 == 7 )
        *(_DWORD *)(a1 + 32) = (v40 + v41) >> 2;
      goto LABEL_122;
    default:
      goto LABEL_123;
  }
  return result;
}

//----- (0008C0E0) --------------------------------------------------------
void __cdecl sub_8C0E0(unsigned __int8 (__fastcall *a1)(signed int))
{
  signed int v1; // eax
  signed int v2; // eax

  byte_180586 = 0;
  while ( !(byte_180586 & 1) )
  {
    v1 = sub_8BBE0((int)&unk_180560);
    if ( a1 && a1(v1) )
      return;
  }
  while ( byte_180586 & 1 )
  {
    v2 = sub_8BBE0((int)&unk_180560);
    if ( a1 )
    {
      if ( a1(v2) )
        break;
    }
  }
}
// 180586: using guessed type char byte_180586;

//----- (0008C140) --------------------------------------------------------
char __cdecl sub_8C140(unsigned __int16 a1, int a2)
{
  int v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+14h] [ebp-14h]
  char v6; // [esp+1Ch] [ebp-Ch]

  memset(&v3, 0, 28);
  v4 = a1;
  v3 = 768;
  segread(&v6);
  v5 = a2;
  int386x(49, &v3, &v3, &v6);
  return *(_BYTE *)(a2 + 28);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99DE6: using guessed type _DWORD __cdecl segread(_DWORD);
// 99E10: using guessed type _DWORD __cdecl int386x(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0008C21F) --------------------------------------------------------
int sub_8C21F()
{
  char v1; // [esp+0h] [ebp-38h]
  int v2; // [esp+1Ch] [ebp-1Ch]

  v2 = (unsigned __int16)word_180662;
  return int386(16, &v2, &v1);
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 180662: using guessed type __int16 word_180662;

//----- (0008C2CD) --------------------------------------------------------
void sub_8C2CD()
{
  ;
}

//----- (0008C2DE) --------------------------------------------------------
void sub_8C2DE()
{
  ;
}

//----- (0008C329) --------------------------------------------------------
int sub_8C329()
{
  int result; // eax
  _BYTE *v1; // eax
  _BYTE *v2; // eax

  dword_1806E8 = dword_E3760;
  if ( word_180660 & 1 )
  {
    LOWORD(dword_1806E8) = (signed __int16)dword_1806E8 >> 1;
    SHIWORD(dword_1806E8) >>= 1;
  }
  dword_1806F4 = (unk_1806E6 >> 16) + (dword_1806E8 >> 16) * dword_18062C;
  if ( word_180660 & 8 )
  {
    HIWORD(dword_18073A) = HIWORD(dword_1806F4);
    sub_9951B(SHIWORD(dword_1806F4));
  }
  unk_1806EC = dword_18062C - dword_1806E8;
  if ( (signed __int16)(dword_18062C - dword_1806E8) > word_18072C )
    unk_1806EC = word_18072C;
  word_1806EE = dword_180624 - HIWORD(dword_1806E8);
  if ( (signed __int16)(dword_180624 - HIWORD(dword_1806E8)) > word_18072E )
    word_1806EE = word_18072E;
  dword_180714 = dword_1806F0;
  dword_180708 = (int)&loc_A0000 + (unsigned __int16)dword_1806F4;
  dword_18070C = dword_180730;
  if ( word_180660 & 1 )
  {
    for ( word_180738 = 0; ; ++word_180738 )
    {
      result = unk_1806EC >> 16;
      if ( (signed int)(unsigned __int16)word_180738 >= unk_1806EC >> 16 )
        break;
      LOWORD(dword_18073A) = 0;
      while ( (unsigned __int16)dword_18073A < *(int *)((char *)&dword_1806E8 + 2) >> 16 )
      {
        v1 = (_BYTE *)dword_180714++;
        *v1 = *(_BYTE *)dword_180708;
        if ( *(_BYTE *)dword_18070C != -2 )
          *(_BYTE *)dword_180708 = *(_BYTE *)dword_18070C;
        ++dword_180708;
        ++dword_18070C;
        LOWORD(dword_18073A) = dword_18073A + 1;
      }
      dword_180708 += dword_18062C - (*(int *)((char *)&dword_1806E8 + 2) >> 16);
      dword_18070C += (*(int *)((char *)&dword_180730 + 2) >> 16) - (*(int *)((char *)&dword_1806E8 + 2) >> 16);
    }
  }
  else
  {
    for ( word_180738 = 0; ; ++word_180738 )
    {
      result = unk_1806EC >> 16;
      if ( (signed int)(unsigned __int16)word_180738 >= unk_1806EC >> 16 )
        break;
      LOWORD(dword_18073A) = 0;
      while ( (unsigned __int16)dword_18073A < *(int *)((char *)&dword_1806E8 + 2) >> 16 )
      {
        v2 = (_BYTE *)dword_180714++;
        *v2 = *(_BYTE *)dword_180708;
        if ( *(_BYTE *)dword_18070C != -2 )
          *(_BYTE *)dword_180708 = *(_BYTE *)dword_18070C;
        if ( ++dword_180708 >= (unsigned int)&loc_AFFFE + 2 )
        {
          ++HIWORD(dword_18073A);
          sub_9951B(SHIWORD(dword_18073A));
          dword_180708 -= (signed int)sub_10000;
        }
        ++dword_18070C;
        LOWORD(dword_18073A) = dword_18073A + 1;
      }
      dword_180708 += dword_18062C - (*(int *)((char *)&dword_1806E8 + 2) >> 16);
      if ( dword_180708 >= (unsigned int)&loc_AFFFE + 2 )
      {
        ++HIWORD(dword_18073A);
        sub_9951B(SHIWORD(dword_18073A));
        dword_180708 -= (signed int)sub_10000;
      }
      dword_18070C += (*(int *)((char *)&dword_180730 + 2) >> 16) - (*(int *)((char *)&dword_1806E8 + 2) >> 16);
    }
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// E3760: using guessed type int dword_E3760;
// 180624: using guessed type int dword_180624;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;
// 1806E8: using guessed type int dword_1806E8;
// 1806EE: using guessed type __int16 word_1806EE;
// 1806F0: using guessed type int dword_1806F0;
// 1806F4: using guessed type int dword_1806F4;
// 180708: using guessed type int dword_180708;
// 18070C: using guessed type int dword_18070C;
// 180714: using guessed type int dword_180714;
// 18072C: using guessed type __int16 word_18072C;
// 18072E: using guessed type __int16 word_18072E;
// 180730: using guessed type int dword_180730;
// 180738: using guessed type __int16 word_180738;
// 18073A: using guessed type int dword_18073A;

//----- (0008C635) --------------------------------------------------------
int sub_8C635()
{
  int result; // eax
  _BYTE *v1; // eax
  _BYTE *v2; // edx

  dword_1806F8 = dword_E3760;
  dword_1806E8 = dword_E3760;
  if ( word_180660 & 1 )
  {
    LOWORD(dword_1806F8) = (signed __int16)dword_1806F8 >> 1;
    SHIWORD(dword_1806F8) >>= 1;
  }
  dword_180704 = (*(int *)((char *)&dword_1806F4 + 2) >> 16) + (dword_1806F8 >> 16) * dword_18062C;
  dword_1806F4 = (*(int *)((char *)&dword_1806F4 + 2) >> 16) + (dword_1806F8 >> 16) * dword_18062C;
  LOWORD(dword_1806FC) = dword_18062C - dword_1806F8;
  if ( (signed __int16)(dword_18062C - dword_1806F8) > word_18072C )
    LOWORD(dword_1806FC) = word_18072C;
  unk_1806EC = dword_1806FC;
  HIWORD(dword_1806FC) = dword_180624 - HIWORD(dword_1806F8);
  if ( (signed __int16)(dword_180624 - HIWORD(dword_1806F8)) > word_18072E )
    HIWORD(dword_1806FC) = word_18072E;
  word_1806EE = HIWORD(dword_1806FC);
  dword_180714 = dword_180700;
  dword_180718 = dword_1806F0;
  dword_180708 = dword_180704 + dword_180628;
  dword_18070C = dword_180730;
  for ( word_180738 = 0; ; ++word_180738 )
  {
    result = dword_1806FC >> 16;
    if ( (unsigned __int16)word_180738 >= dword_1806FC >> 16 )
      break;
    LOWORD(dword_18073A) = 0;
    while ( (unsigned __int16)dword_18073A < *(int *)((char *)&dword_1806F8 + 2) >> 16 )
    {
      v1 = (_BYTE *)dword_180714++;
      *v1 = *(_BYTE *)dword_180708;
      v2 = (_BYTE *)dword_180718++;
      *v2 = *(_BYTE *)dword_180708;
      if ( *(_BYTE *)dword_18070C != -2 )
        *(_BYTE *)dword_180708 = *(_BYTE *)dword_18070C;
      ++dword_180708;
      ++dword_18070C;
      LOWORD(dword_18073A) = dword_18073A + 1;
    }
    dword_180708 += dword_18062C - (*(int *)((char *)&dword_1806F8 + 2) >> 16);
    dword_18070C += (*(int *)((char *)&dword_180730 + 2) >> 16) - (*(int *)((char *)&dword_1806F8 + 2) >> 16);
  }
  return result;
}
// E3760: using guessed type int dword_E3760;
// 180624: using guessed type int dword_180624;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;
// 1806E8: using guessed type int;
// 1806EE: using guessed type __int16 word_1806EE;
// 1806F0: using guessed type int dword_1806F0;
// 1806F4: using guessed type int dword_1806F4;
// 1806F8: using guessed type int dword_1806F8;
// 1806FC: using guessed type int dword_1806FC;
// 180700: using guessed type int dword_180700;
// 180704: using guessed type int dword_180704;
// 180708: using guessed type int dword_180708;
// 18070C: using guessed type int dword_18070C;
// 180714: using guessed type int dword_180714;
// 180718: using guessed type int dword_180718;
// 18072C: using guessed type __int16 word_18072C;
// 18072E: using guessed type __int16 word_18072E;
// 180730: using guessed type int dword_180730;
// 180738: using guessed type __int16 word_180738;
// 18073A: using guessed type int dword_18073A;

//----- (0008C839) --------------------------------------------------------
int sub_8C839()
{
  int result; // eax
  _BYTE *v1; // eax
  _BYTE *v2; // edx
  _BYTE *v3; // eax
  _BYTE *v4; // edx

  if ( !(word_180660 & 1) )
  {
    HIWORD(dword_18073A) = HIWORD(dword_1806F4);
    sub_9951B(SHIWORD(dword_1806F4));
  }
  dword_180714 = dword_1806F0;
  dword_180708 = (int)&loc_A0000 + (unsigned __int16)dword_1806F4;
  if ( word_180660 & 1 )
  {
    for ( word_180738 = 0; ; ++word_180738 )
    {
      result = unk_1806EC >> 16;
      if ( (signed int)(unsigned __int16)word_180738 >= unk_1806EC >> 16 )
        break;
      LOWORD(dword_18073A) = 0;
      while ( (unsigned __int16)dword_18073A < *(int *)((char *)&dword_1806E8 + 2) >> 16 )
      {
        v1 = (_BYTE *)dword_180714++;
        v2 = (_BYTE *)dword_180708++;
        *v2 = *v1;
        LOWORD(dword_18073A) = dword_18073A + 1;
      }
      dword_180708 += dword_18062C - (*(int *)((char *)&dword_1806E8 + 2) >> 16);
    }
  }
  else
  {
    for ( word_180738 = 0; ; ++word_180738 )
    {
      result = unk_1806EC >> 16;
      if ( (signed int)(unsigned __int16)word_180738 >= unk_1806EC >> 16 )
        break;
      LOWORD(dword_18073A) = 0;
      while ( (unsigned __int16)dword_18073A < *(int *)((char *)&dword_1806E8 + 2) >> 16 )
      {
        v3 = (_BYTE *)dword_180714++;
        v4 = (_BYTE *)dword_180708++;
        *v4 = *v3;
        if ( dword_180708 >= (unsigned int)&loc_AFFFE + 2 )
        {
          ++HIWORD(dword_18073A);
          sub_9951B(SHIWORD(dword_18073A));
          dword_180708 -= (signed int)sub_10000;
        }
        LOWORD(dword_18073A) = dword_18073A + 1;
      }
      dword_180708 += dword_18062C - (*(int *)((char *)&dword_1806E8 + 2) >> 16);
      if ( dword_180708 >= (unsigned int)&loc_AFFFE + 2 )
      {
        ++HIWORD(dword_18073A);
        sub_9951B(SHIWORD(dword_18073A));
        dword_180708 -= (signed int)sub_10000;
      }
    }
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;
// 1806E8: using guessed type int dword_1806E8;
// 1806F0: using guessed type int dword_1806F0;
// 1806F4: using guessed type int dword_1806F4;
// 180708: using guessed type int dword_180708;
// 180714: using guessed type int dword_180714;
// 180738: using guessed type __int16 word_180738;
// 18073A: using guessed type int dword_18073A;

//----- (0008CA16) --------------------------------------------------------
int sub_8CA16()
{
  int result; // eax
  _BYTE *v1; // eax
  _BYTE *v2; // edx

  dword_180714 = dword_180700;
  dword_180708 = dword_180704 + dword_180628;
  for ( word_180738 = 0; ; ++word_180738 )
  {
    result = dword_1806FC >> 16;
    if ( (unsigned __int16)word_180738 >= dword_1806FC >> 16 )
      break;
    LOWORD(dword_18073A) = 0;
    while ( (unsigned __int16)dword_18073A < *(int *)((char *)&dword_1806F8 + 2) >> 16 )
    {
      v1 = (_BYTE *)dword_180714++;
      v2 = (_BYTE *)dword_180708++;
      *v2 = *v1;
      LOWORD(dword_18073A) = dword_18073A + 1;
    }
    dword_180708 += dword_18062C - (*(int *)((char *)&dword_1806F8 + 2) >> 16);
  }
  return result;
}
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 1806F8: using guessed type int dword_1806F8;
// 1806FC: using guessed type int dword_1806FC;
// 180700: using guessed type int dword_180700;
// 180704: using guessed type int dword_180704;
// 180708: using guessed type int dword_180708;
// 180714: using guessed type int dword_180714;
// 180738: using guessed type __int16 word_180738;
// 18073A: using guessed type int dword_18073A;

//----- (0008CACD) --------------------------------------------------------
int sub_8CACD()
{
  int result; // eax

  if ( dword_E3768 )
  {
    dword_E3758 = 1;
    result = sub_8C635();
  }
  return result;
}
// E3758: using guessed type int dword_E3758;
// E3768: using guessed type int dword_E3768;

//----- (0008CB1F) --------------------------------------------------------
void sub_8CB1F()
{
  dword_E3758 = 0;
}
// E3758: using guessed type int dword_E3758;

//----- (0008CB3A) --------------------------------------------------------
void sub_8CB3A()
{
  ((void (__cdecl *)(_DWORD))_GETDS)((unsigned __int16)__DS__);
}
// 8CB3A: could not find valid save-restore pair for ebx
// 8CB3A: could not find valid save-restore pair for ebp
// 8CB3A: could not find valid save-restore pair for edi
// 8CB3A: could not find valid save-restore pair for esi
// E3758: using guessed type int dword_E3758;
// E375C: using guessed type __int16 word_E375C;
// E375E: using guessed type __int16 word_E375E;
// E3760: using guessed type int dword_E3760;
// E3767: using guessed type char byte_E3767;
// E3768: using guessed type int dword_E3768;
// E3BA4: using guessed type __int16 word_E3BA4;
// 180660: using guessed type __int16 word_180660;
// 180710: using guessed type int dword_180710;
// 180734: using guessed type int dword_180734;
// 18073E: using guessed type __int16 word_18073E;
// 180740: using guessed type __int16 word_180740;
// 180742: using guessed type __int16 word_180742;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;
// 180748: using guessed type __int16 word_180748;
// 18074A: using guessed type __int16 word_18074A;
// 18074C: using guessed type __int16 word_18074C;

//----- (0008CD27) --------------------------------------------------------
int __cdecl sub_8CD27(int a1)
{
  int result; // eax
  unsigned int i; // [esp+0h] [ebp-10h]
  int v3; // [esp+4h] [ebp-Ch]
  __int16 v4; // [esp+8h] [ebp-8h]
  int v5; // [esp+Ch] [ebp-4h]

  dword_E3758 = 1;
  v5 = dword_180628;
  dword_180628 = dword_180730;
  if ( a1 )
  {
    word_18072C = *(unsigned __int8 *)(a1 + 4);
    word_18072E = *(unsigned __int8 *)(a1 + 5);
  }
  else
  {
    word_18072C = 0;
    word_18072E = 0;
  }
  if ( word_180660 & 1 )
  {
    word_18072C >>= 1;
    word_18072E >>= 1;
  }
  dword_18065C = dword_180650;
  dword_180640 = dword_180630;
  dword_180638 = dword_18063C;
  dword_18064C = dword_180634;
  dword_180658 = dword_180648;
  dword_180654 = dword_180644;
  dword_180650 = 0;
  dword_180630 = 64;
  dword_18063C = 0;
  dword_180634 = 64;
  dword_180648 = 64;
  dword_180644 = 64;
  v4 = word_E36D4;
  word_E36D4 = 0;
  v3 = dword_18062C;
  dword_18062C = 64;
  for ( i = 0; i < 0x1000; ++i )
    *(_BYTE *)(i + dword_180730) = -2;
  if ( a1 )
    sub_8F8B0(0, 0, a1);
  dword_18062C = v3;
  word_E36D4 = v4;
  dword_180650 = dword_18065C;
  dword_180630 = dword_180640;
  dword_18063C = dword_180638;
  dword_180634 = dword_18064C;
  dword_180648 = dword_180658;
  dword_180644 = dword_180654;
  result = v5;
  dword_180628 = v5;
  dword_E3758 = 0;
  return result;
}
// E36D4: using guessed type __int16 word_E36D4;
// E3758: using guessed type int dword_E3758;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180630: using guessed type int dword_180630;
// 180634: using guessed type int dword_180634;
// 180638: using guessed type int dword_180638;
// 18063C: using guessed type int dword_18063C;
// 180640: using guessed type int dword_180640;
// 180644: using guessed type int dword_180644;
// 180648: using guessed type int dword_180648;
// 18064C: using guessed type int dword_18064C;
// 180650: using guessed type int dword_180650;
// 180654: using guessed type int dword_180654;
// 180658: using guessed type int dword_180658;
// 18065C: using guessed type int dword_18065C;
// 180660: using guessed type __int16 word_180660;
// 18072C: using guessed type __int16 word_18072C;
// 18072E: using guessed type __int16 word_18072E;
// 180730: using guessed type int dword_180730;

//----- (0008CEDF) --------------------------------------------------------
signed int sub_8CEDF()
{
  __int16 v1; // [esp+0h] [ebp-54h]
  __int16 v2; // [esp+1Ch] [ebp-38h]
  __int16 v3; // [esp+24h] [ebp-30h]
  void (*v4)(); // [esp+28h] [ebp-2Ch]
  __int16 v5; // [esp+38h] [ebp-1Ch]
  void (*v6)(); // [esp+44h] [ebp-10h]
  int v7; // [esp+48h] [ebp-Ch]
  int i; // [esp+4Ch] [ebp-8h]

  dword_E3768 = 0;
  segread(&v5);
  v2 = 0;
  int386(51, &v2, &v1);
  if ( v1 != -1 )
    return 0;
  v2 = 12;
  v3 = 127;
  LOWORD(v7) = __CS__;
  v6 = sub_8CB3A;
  v4 = sub_8CB3A;
  v5 = __CS__;
  int386x(51, &v2, &v1, &v5);
  sub_8D12F();
  if ( !dword_180730 )
    dword_180730 = sub_83CD0(4096);
  if ( !dword_180700 )
    dword_180700 = sub_83CD0(4096);
  if ( !dword_1806F0 )
    dword_1806F0 = sub_83CD0(4096);
  if ( !dword_180730 || !dword_180700 || !dword_1806F0 )
    return 0;
  word_18072C = 0;
  word_18072E = 0;
  LOWORD(dword_180734) = 64;
  for ( i = 0; i < 4096; ++i )
    *(_BYTE *)(i + dword_180730) = -2;
  if ( dword_180720 )
    sub_8CD27(dword_180720);
  v2 = 2;
  int386(51, &v2, &v1);
  if ( word_180660 & 8 )
  {
    v2 = 15;
    v3 = 1;
    LOWORD(v4) = 1;
    int386(51, &v2, &v1);
  }
  dword_E3768 = 1;
  return 1;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 99DE6: using guessed type _DWORD __cdecl segread(_DWORD);
// 99E10: using guessed type _DWORD __cdecl int386x(_DWORD, _DWORD, _DWORD, _DWORD);
// E3768: using guessed type int dword_E3768;
// 180660: using guessed type __int16 word_180660;
// 1806F0: using guessed type int dword_1806F0;
// 180700: using guessed type int dword_180700;
// 180720: using guessed type int dword_180720;
// 18072C: using guessed type __int16 word_18072C;
// 18072E: using guessed type __int16 word_18072E;
// 180730: using guessed type int dword_180730;
// 180734: using guessed type int dword_180734;

//----- (0008D12F) --------------------------------------------------------
int sub_8D12F()
{
  int result; // eax
  char v1; // [esp+0h] [ebp-38h]
  __int16 v2; // [esp+1Ch] [ebp-1Ch]
  __int16 v3; // [esp+24h] [ebp-14h]
  __int16 v4; // [esp+28h] [ebp-10h]

  if ( word_180660 == 8 )
  {
    v2 = 7;
    v3 = 0;
    v4 = 5120;
    int386(51, &v2, &v1);
    v2 = 8;
    v3 = 0;
    v4 = 3840;
    result = int386(51, &v2, &v1);
  }
  if ( word_180660 == 2 )
  {
    v2 = 7;
    v3 = 0;
    v4 = 640;
    int386(51, &v2, &v1);
    v2 = 8;
    v3 = 0;
    v4 = 480;
    result = int386(51, &v2, &v1);
  }
  if ( word_180660 == 4 )
  {
    v2 = 7;
    v3 = 0;
    v4 = 640;
    int386(51, &v2, &v1);
    v2 = 8;
    v3 = 0;
    v4 = 400;
    result = int386(51, &v2, &v1);
  }
  if ( word_180660 == 1 )
  {
    v2 = 7;
    v3 = 0;
    v4 = 640;
    int386(51, &v2, &v1);
    v2 = 8;
    v3 = 0;
    v4 = 400;
    result = int386(51, &v2, &v1);
  }
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 180660: using guessed type __int16 word_180660;

//----- (0008D290) --------------------------------------------------------
void __fastcall sub_8D290(int a1, int a2, int a3)
{
  int (__cdecl *v3)(int); // eax
  _DWORD *v4; // eax
  int v5; // [esp+4h] [ebp-3Ch]
  char v6; // [esp+1Ch] [ebp-24h]
  int v7; // [esp+2Ch] [ebp-14h]
  char *v8; // [esp+34h] [ebp-Ch]
  int v9; // [esp+38h] [ebp-8h]
  char v10; // [esp+3Ch] [ebp-4h]

  v10 = 0;
  if ( !byte_E3798 )
    return;
  word_E37B6 = word_E37B4;
  if ( !word_E37B4 )
  {
    if ( !byte_E37FC )
    {
      if ( byte_E37B8 )
        sub_919C0();
    }
    byte_E3798 = 0;
    byte_E3799 = 0;
    printf(aCouldNotLoadAn);
    return;
  }
  if ( !byte_E37B8 )
  {
    sub_90F60();
    sub_9D3F0(sub_83CD0);
    v3 = sub_9D420((int (__cdecl *)(int))sub_83E80);
    ((void (__fastcall *)(int (__cdecl *)(int)))loc_917D0)(v3);
    byte_E37B8 = 1;
  }
  if ( (char)sub_90EE0() == -1 )
  {
    byte_E3798 = 0;
    byte_E3799 = 0;
    if ( byte_E37FC && byte_E37FE )
    {
      sub_99C90();
    }
    else
    {
      byte_E37FC = 0;
      byte_E37FD = 0;
      sub_919C0();
    }
    return;
  }
  v7 = getenv(aMdsound);
  if ( v7 )
  {
    sscanf(v7, aSXDDD, (unsigned int)&v6);
    dword_180B48 = (int)sub_93330(a3, (int)&v6, &v5);
    if ( !dword_180B48 )
    {
      if ( !byte_E37FC )
        sub_919C0();
      sub_90F20();
      byte_E3798 = 0;
      byte_E3799 = 0;
      return;
    }
    sprintf(&unk_180AB0, aS_2, &v6);
    word_180B30 = v5;
    sub_93480((unsigned int *)dword_180B48);
    v10 = 1;
  }
  else
  {
    if ( sub_92190((int)&unk_180A30, (int)aDigIni) )
    {
      if ( !stricmp(&unk_180AB0, aNone) )
      {
        if ( !byte_E37FC )
          sub_919C0();
        sub_90F20();
        byte_E3798 = 0;
        byte_E3799 = 0;
        return;
      }
      if ( !sub_931F0(a3, (int **)&dword_180B48) )
      {
        sub_93480((unsigned int *)dword_180B48);
        v10 = 1;
      }
    }
    if ( !v10 )
    {
      if ( !byte_E37FC )
        sub_919C0();
      sub_90F20();
      byte_E3798 = 0;
      byte_E3799 = 0;
      return;
    }
    sub_90F20();
  }
  sub_90F20();
  sub_8D800();
  if ( word_E37B6 )
  {
    if ( (unsigned __int16)word_E37B6 < 0x336u )
    {
      if ( (unsigned __int16)word_E37B6 < 0x320u )
      {
        if ( !word_E37B6 )
        {
          byte_E3798 = 0;
          byte_E3799 = 0;
          printf(aCouldNotLoadAn_1);
          return;
        }
      }
      else if ( (unsigned __int16)word_E37B6 <= 0x320u )
      {
        dword_E37BC = 11025;
        byte_E37AE = 0;
      }
      else if ( word_E37B6 == 811 )
      {
        dword_E37BC = 11025;
        byte_E37AE = 0;
      }
    }
    else if ( (unsigned __int16)word_E37B6 <= 0x336u )
    {
      dword_E37BC = 22050;
      byte_E37AE = 0;
    }
    else if ( (unsigned __int16)word_E37B6 < 0x656u )
    {
      if ( word_E37B6 == 1611 )
      {
        dword_E37BC = 11025;
        byte_E37AE = 1;
      }
    }
    else if ( (unsigned __int16)word_E37B6 <= 0x656u )
    {
      dword_E37BC = 22050;
      byte_E37AE = 1;
    }
    else if ( word_E37B6 == 1644 )
    {
      dword_E37BC = 44100;
      byte_E37AE = 1;
    }
    sub_91A80(0, 200);
    sub_91A80(1, dword_E37BC);
    sub_91A80(3, 100);
    sub_91A80(4, dword_E3794 + 1);
    sub_91A80(5, 127);
    sub_91A80(6, 655);
    if ( byte_E379C )
      sub_91A80(7, 1);
    else
      sub_91A80(7, 0);
    if ( !byte_E379B )
      sub_91A80(17, 0);
    if ( byte_E37AE )
    {
      sub_91A80(8, 1);
      sub_91A80(9, 1);
    }
    else
    {
      sub_91A80(8, 0);
      sub_91A80(9, 0);
    }
    sub_90EE0();
    dword_180B48 = (int)sub_93330(a3, (int)&unk_180AB0, &unk_181D90);
    if ( dword_180B48 )
    {
      sub_90F20();
      if ( byte_E3798 )
      {
        dword_180B4C = (int)&unk_180750 + 23 * dword_E3794;
        v8 = (char *)&unk_180750;
        v9 = 0;
        while ( (unsigned int)v8 < dword_180B4C )
        {
          v4 = sub_93510(dword_180B48);
          *(_DWORD *)v8 = v4;
          v8[20] = 0;
          v8 += 23;
          ++v9;
        }
        byte_E379A = 1;
        sub_8E470(dword_E37B0);
      }
    }
    else
    {
      if ( !byte_E37FC )
        sub_919C0();
      sub_90F20();
      byte_E3798 = 0;
      byte_E3799 = 0;
      sub_83E80(dword_E37A0);
      dword_E37A4 = 0;
      sub_83E80(dword_E37A8);
    }
  }
  else
  {
    if ( !byte_E37FC )
      sub_919C0();
    byte_E3798 = 0;
    byte_E3799 = 0;
    printf(aCouldNotLoadAn_0);
  }
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// 99E33: using guessed type _DWORD __cdecl getenv(_DWORD);
// 9E187: using guessed type _DWORD __cdecl sscanf(_DWORD, _DWORD, char);
// E3794: using guessed type int dword_E3794;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E379A: using guessed type char byte_E379A;
// E379B: using guessed type char byte_E379B;
// E379C: using guessed type char byte_E379C;
// E37A0: using guessed type int dword_E37A0;
// E37A4: using guessed type int dword_E37A4;
// E37A8: using guessed type int dword_E37A8;
// E37AE: using guessed type char byte_E37AE;
// E37B0: using guessed type int dword_E37B0;
// E37B4: using guessed type __int16 word_E37B4;
// E37B6: using guessed type __int16 word_E37B6;
// E37B8: using guessed type char byte_E37B8;
// E37BC: using guessed type int dword_E37BC;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E37FE: using guessed type char byte_E37FE;
// 180B30: using guessed type __int16 word_180B30;
// 180B48: using guessed type int dword_180B48;
// 180B4C: using guessed type int dword_180B4C;

//----- (0008D800) --------------------------------------------------------
void sub_8D800()
{
  signed int v0; // [esp+4h] [ebp-4h]

  v0 = 1;
  while ( v0 )
  {
    v0 = sub_84300(byte_E37AC);
    if ( v0 )
    {
      if ( (unsigned __int16)word_E37B6 < 0x336u )
      {
        if ( (unsigned __int16)word_E37B6 >= 0x320u )
        {
          if ( (unsigned __int16)word_E37B6 <= 0x320u )
          {
            word_E37B6 = 0;
            return;
          }
          if ( word_E37B6 == 811 )
            word_E37B6 = 800;
        }
      }
      else if ( (unsigned __int16)word_E37B6 <= 0x336u )
      {
        word_E37B6 = 1611;
      }
      else if ( (unsigned __int16)word_E37B6 < 0x656u )
      {
        if ( word_E37B6 == 1611 )
          word_E37B6 = 811;
      }
      else if ( (unsigned __int16)word_E37B6 <= 0x656u )
      {
        word_E37B6 = 822;
      }
      else if ( word_E37B6 == 1644 )
      {
        word_E37B6 = 1622;
      }
    }
  }
}
// E37AC: using guessed type char byte_E37AC;
// E37B6: using guessed type __int16 word_E37B6;

//----- (0008D8F0) --------------------------------------------------------
int sub_8D8F0()
{
  int *i; // [esp+0h] [ebp-4h]

  if ( byte_E3798 && byte_E3799 )
  {
    sub_8F850();
    for ( i = (int *)&unk_180750; (unsigned int)i < dword_180B4C; i = (int *)((char *)i + 23) )
    {
      sub_93D00(*i);
      *((_WORD *)i + 9) = 0;
      *(int *)((char *)i + 14) = 0;
      *((_BYTE *)i + 20) = 0;
      *((_BYTE *)i + 21) = 0;
    }
  }
  return sub_9F040();
}
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// 180B4C: using guessed type int dword_180B4C;

//----- (0008D970) --------------------------------------------------------
void __fastcall sub_8D970(int a1, int a2, int a3)
{
  int (__cdecl *v3)(int); // eax
  char v4; // [esp+0h] [ebp-C8h]
  char v5; // [esp+90h] [ebp-38h]
  char v6; // [esp+A8h] [ebp-20h]
  int v7; // [esp+B8h] [ebp-10h]
  char v8; // [esp+C0h] [ebp-8h]

  v8 = 0;
  if ( !byte_E37FC )
    return;
  if ( !byte_E37B8 )
  {
    sub_90F60();
    sub_9D3F0(sub_83CD0);
    v3 = sub_9D420((int (__cdecl *)(int))sub_83E80);
    ((void (__fastcall *)(int (__cdecl *)(int)))loc_917D0)(v3);
    byte_E37B8 = 1;
  }
  sub_91A80(11, 120);
  sub_91A80(12, 1);
  sub_91A80(13, 127);
  sub_91A80(14, 1);
  sub_91A80(15, 0);
  sub_91A80(16, 12);
  if ( !byte_E379B )
    sub_91A80(17, 0);
  if ( !strcmp(&unk_181B50, &aD_2[2]) )
    sprintf(&v4, aCSsoundSample, dword_181BE0 + 64, &unk_181B50);
  else
    sprintf(&v4, aCSSoundSample, dword_181BE0 + 64, &unk_181B50);
  sub_96AE0((int)&v4);
  if ( (char)sub_90EE0() == -1 )
  {
    byte_E37FC = 0;
    byte_E37FD = 0;
    if ( byte_E3798 && byte_E379A )
    {
      sub_99C10();
    }
    else
    {
      byte_E3798 = 0;
      byte_E3799 = 0;
      sub_919C0();
    }
    return;
  }
  v7 = getenv(aMdmusic);
  if ( v7 )
  {
    sscanf(v7, aSXDDD_0, (unsigned int)&v6);
    dword_180C7C = (int)sub_95850(a3, (int)&v6, &v5);
    if ( !dword_180C7C )
    {
      if ( !byte_E3798 )
        sub_919C0();
      sub_90F20();
      byte_E37FC = 0;
      byte_E37FD = 0;
      return;
    }
    sprintf(&unk_180BE0, &aMS[1], &v6);
    v8 = 1;
  }
  else
  {
    if ( sub_92190((int)&unk_180B60, (int)aMdiIni) )
    {
      if ( !stricmp(&unk_180BE0, aNone_0) )
      {
        if ( !byte_E3798 )
          sub_919C0();
        sub_90F20();
        byte_E37FC = 0;
        byte_E37FD = 0;
        return;
      }
      if ( !sub_95710(a3, (int **)&dword_180C7C) )
        v8 = 1;
    }
    if ( !v8 )
    {
      if ( !byte_E3798 )
        sub_919C0();
      sub_90F20();
      byte_E37FC = 0;
      byte_E37FD = 0;
      return;
    }
    sub_90F20();
  }
  sub_90F20();
  dword_180C78 = (int)sub_95A30(dword_180C7C);
  if ( !stricmp(&unk_180BE0, aAdlibMdi) )
  {
    sprintf(&byte_180C84, &aT32f[3]);
LABEL_69:
    if ( byte_E37FC && sub_8EAD0((unsigned __int8)byte_E3814) )
    {
      if ( byte_E3815 == 1 )
      {
        sub_9FA80();
        byte_E3815 = 0;
      }
      sub_959A0((unsigned int *)dword_180C7C);
      if ( !byte_E3798 )
        sub_919C0();
      byte_E37FC = 0;
      byte_E37FD = 0;
      printf(aErrorOpeningMu);
    }
    else
    {
      byte_E37FE = 1;
      sub_8E410((_DWORD *)dword_E37F8);
    }
    return;
  }
  if ( !stricmp(&unk_180BE0, aAdlibgMdi) )
  {
    sprintf(&byte_180C84, &aT32f[3]);
    goto LABEL_69;
  }
  if ( !stricmp(&unk_180BE0, aOpl3Mdi) )
  {
    sprintf(&byte_180C84, &aT32f[3]);
    goto LABEL_69;
  }
  if ( !stricmp(&unk_180BE0, aPasMdi) )
  {
    sprintf(&byte_180C84, &aT32f[3]);
    goto LABEL_69;
  }
  if ( !stricmp(&unk_180BE0, aPasplusMdi) )
  {
    sprintf(&byte_180C84, &aT32f[3]);
    goto LABEL_69;
  }
  if ( !stricmp(&unk_180BE0, aSblasterMdi) )
  {
    sprintf(&byte_180C84, &aT32f[3]);
    goto LABEL_69;
  }
  if ( !stricmp(&unk_180BE0, aSbpro1Mdi) )
  {
    sprintf(&byte_180C84, &aT32f[3]);
    goto LABEL_69;
  }
  if ( !stricmp(&unk_180BE0, aSbpro2Mdi) )
  {
    sprintf(&byte_180C84, &aT32f[3]);
    goto LABEL_69;
  }
  if ( !stricmp(&unk_180BE0, aEsfmMdi) )
  {
    sprintf(&byte_180C84, &aT32f[3]);
    goto LABEL_69;
  }
  if ( !stricmp(&unk_180BE0, aSbawe32Mdi) )
  {
    sprintf(&byte_180C84, &aApew[3]);
    sub_9F740((int)aBullfrog);
    if ( !byte_E3815 )
      sprintf(&byte_180C84, &aDig[2]);
    goto LABEL_69;
  }
  if ( !stricmp(&unk_180BE0, aMpu401Mdi) )
  {
    sprintf(&byte_180C84, &aDig[2]);
    goto LABEL_69;
  }
  if ( !stricmp(&unk_180BE0, aSndscapeMdi) )
  {
    sprintf(&byte_180C84, &aDig[2]);
    goto LABEL_69;
  }
  if ( !stricmp(&unk_180BE0, aMt32mpuMdi) )
  {
    sprintf(&byte_180C84, &aOpr[2]);
    goto LABEL_69;
  }
  if ( !sub_969A0((_DWORD *)dword_180C7C) )
  {
    sprintf(&byte_180C84, &aDig[2]);
    goto LABEL_69;
  }
  if ( sub_969A0((_DWORD *)dword_180C7C) == 1 || sub_969A0((_DWORD *)dword_180C7C) == 2 )
  {
    sprintf(&byte_180C84, &aT32f[3]);
    goto LABEL_69;
  }
  sub_959A0((unsigned int *)dword_180C7C);
  if ( !byte_E3798 )
    sub_919C0();
  byte_E37FC = 0;
  byte_E37FD = 0;
  printf(aErrorDriverNot);
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// 99E33: using guessed type _DWORD __cdecl getenv(_DWORD);
// 9A050: using guessed type _DWORD __cdecl strcmp(_DWORD, _DWORD);
// 9E187: using guessed type _DWORD __cdecl sscanf(_DWORD, _DWORD, char);
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E379A: using guessed type char byte_E379A;
// E379B: using guessed type char byte_E379B;
// E37B8: using guessed type char byte_E37B8;
// E37F8: using guessed type int dword_E37F8;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E37FE: using guessed type char byte_E37FE;
// E3814: using guessed type char byte_E3814;
// E3815: using guessed type char byte_E3815;
// 180C78: using guessed type int dword_180C78;
// 180C7C: using guessed type int dword_180C7C;
// 180C84: using guessed type char byte_180C84;
// 181BE0: using guessed type int dword_181BE0;

//----- (0008E020) --------------------------------------------------------
void sub_8E020()
{
  if ( byte_E37FC && byte_E37FD && word_E3802 )
  {
    if ( byte_E3818 )
      sub_92DC0(dword_180C80);
    byte_E3819 = 0;
    byte_E3818 = 0;
    byte_E3817 = 1;
    byte_E3816 = 0;
    byte_E381A = -1;
    if ( sub_96170(dword_180C78) != 2 )
    {
      sub_95DE0((int *)dword_180C78);
      sub_95F00(dword_180C78);
    }
    word_E3802 = 0;
  }
}
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E3802: using guessed type __int16 word_E3802;
// E3816: using guessed type char byte_E3816;
// E3817: using guessed type char byte_E3817;
// E3818: using guessed type char byte_E3818;
// E3819: using guessed type char byte_E3819;
// E381A: using guessed type char byte_E381A;
// 180C78: using guessed type int dword_180C78;
// 180C80: using guessed type int dword_180C80;

//----- (0008E160) --------------------------------------------------------
void __cdecl sub_8E160(__int16 a1, unsigned __int8 a2)
{
  unsigned __int8 i; // [esp+0h] [ebp-4h]

  if ( byte_E37FC && byte_E37FD && a1 <= (signed int)(unsigned __int16)word_E3804 && (unsigned __int16)word_E3802 != a1 )
  {
    if ( byte_E3818 )
      sub_92DC0(dword_180C80);
    byte_E3819 = 0;
    byte_E3818 = 0;
    byte_E3817 = 1;
    byte_E3816 = 0;
    byte_E381A = -1;
    if ( word_E3802 )
    {
      if ( sub_96170(dword_180C78) != 2 )
      {
        sub_95DE0((int *)dword_180C78);
        sub_95F00(dword_180C78);
      }
      word_E3802 = 0;
    }
    sub_95C00((int *)dword_180C78, *(_DWORD *)(dword_E3808 + 32 * a1 + 18), 0);
    sub_97670(dword_180C78, (int)sub_8E0D0);
    for ( i = 0; i < 0x10u; ++i )
    {
      byte_180C90[i] = 0;
      sub_98360((_DWORD *)dword_180C7C, dword_180C78, i | 0xB0, 0, 0);
      sub_98360((_DWORD *)dword_180C7C, dword_180C78, i | 0xB0, 7u, 0);
      sub_98360((_DWORD *)dword_180C7C, dword_180C78, i | 0xE0, 0, 64);
      sub_98360((_DWORD *)dword_180C7C, dword_180C78, i | 0xB0, 0xBu, 127);
      sub_98360((_DWORD *)dword_180C7C, dword_180C78, i | 0xB0, 1u, 0);
      sub_98360((_DWORD *)dword_180C7C, dword_180C78, i | 0xB0, 0x5Bu, 0);
      sub_98360((_DWORD *)dword_180C7C, dword_180C78, i | 0xB0, 0x5Du, 0);
    }
    if ( a2 < 0x7Fu )
      sub_96030((_DWORD *)dword_180C78, a2, 0);
    sub_95D50((int *)dword_180C78);
    word_E3800 = 100;
    word_E3802 = a1;
  }
}
// 8E0D0: using guessed type int sub_8E0D0();
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E3800: using guessed type __int16 word_E3800;
// E3802: using guessed type __int16 word_E3802;
// E3804: using guessed type __int16 word_E3804;
// E3808: using guessed type int dword_E3808;
// E3816: using guessed type char byte_E3816;
// E3817: using guessed type char byte_E3817;
// E3818: using guessed type char byte_E3818;
// E3819: using guessed type char byte_E3819;
// E381A: using guessed type char byte_E381A;
// 180C78: using guessed type int dword_180C78;
// 180C7C: using guessed type int dword_180C7C;
// 180C80: using guessed type int dword_180C80;

//----- (0008E410) --------------------------------------------------------
_DWORD *__cdecl sub_8E410(_DWORD *a1)
{
  _DWORD *result; // eax

  if ( byte_E37FC )
  {
    if ( byte_E37FE )
    {
      result = a1;
      if ( a1 != (_DWORD *)dword_E37F8 && (signed int)a1 <= 127 && (signed int)a1 >= 0 )
      {
        sub_96670((_DWORD *)dword_180C7C, a1);
        result = a1;
        dword_E37F8 = (int)a1;
      }
    }
  }
  return result;
}
// E37F8: using guessed type int dword_E37F8;
// E37FC: using guessed type char byte_E37FC;
// E37FE: using guessed type char byte_E37FE;
// 180C7C: using guessed type int dword_180C7C;

//----- (0008E470) --------------------------------------------------------
int __cdecl sub_8E470(int a1)
{
  int result; // eax

  if ( byte_E3798 )
  {
    if ( byte_E379A )
    {
      result = a1;
      if ( a1 != dword_E37B0 && a1 <= 127 && a1 >= 0 )
      {
        sub_94650((_DWORD *)dword_180B48, a1);
        result = a1;
        dword_E37B0 = a1;
      }
    }
  }
  return result;
}
// E3798: using guessed type char byte_E3798;
// E379A: using guessed type char byte_E379A;
// E37B0: using guessed type int dword_E37B0;
// 180B48: using guessed type int dword_180B48;

//----- (0008E673) --------------------------------------------------------
__int16 sub_8E673()
{
  __int16 result; // ax

  sub_8F023(dword_E3840, (int)&word_E3828, 2u);
  sub_8F023(dword_E3840, dword_E9C38, 8u);
  while ( 1 )
  {
    result = word_E3828;
    if ( !word_E3828 )
      break;
    --word_E3828;
    sub_8F023(dword_E3840, (int)&dword_E3824, 4u);
    sub_8F023(dword_E3840, (int)&word_E381C, 2u);
    switch ( word_E381C )
    {
      case 7:
        sub_8E871();
        break;
      case 12:
        sub_8E948();
        break;
      case 4:
        sub_8E7D5();
        break;
      case 15:
        sub_8E9EF();
        break;
      case 16:
        sub_8E799();
        break;
      default:
        sub_8E7B7();
        break;
    }
  }
  return result;
}
// E381C: using guessed type __int16 word_E381C;
// E3824: using guessed type int dword_E3824;
// E3828: using guessed type __int16 word_E3828;
// E3840: using guessed type int dword_E3840;
// E9C38: using guessed type int dword_E9C38;

//----- (0008E736) --------------------------------------------------------
__int16 sub_8E736()
{
  __int16 result; // ax

  sub_8F023(dword_E3840, dword_E9C38, dword_E3824 - 6);
  word_E381E = *(_WORD *)dword_E9C38;
  word_E3820 = *(_WORD *)(dword_E9C38 + 2);
  result = *(_WORD *)(dword_E9C38 + 4);
  word_E3822 = *(_WORD *)(dword_E9C38 + 4);
  return result;
}
// E381E: using guessed type __int16 word_E381E;
// E3820: using guessed type __int16 word_E3820;
// E3822: using guessed type __int16 word_E3822;
// E3824: using guessed type int dword_E3824;
// E3840: using guessed type int dword_E3840;
// E9C38: using guessed type int dword_E9C38;

//----- (0008E799) --------------------------------------------------------
int sub_8E799()
{
  return sub_8F023(dword_E3840, dword_180628, dword_E3824 - 6);
}
// E3824: using guessed type int dword_E3824;
// E3840: using guessed type int dword_E3840;
// 180628: using guessed type int dword_180628;

//----- (0008E7B7) --------------------------------------------------------
int sub_8E7B7()
{
  return sub_8F023(dword_E3840, dword_E9C38, dword_E3824 - 6);
}
// E3824: using guessed type int dword_E3824;
// E3840: using guessed type int dword_E3840;
// E9C38: using guessed type int dword_E9C38;

//----- (0008E7D5) --------------------------------------------------------
int sub_8E7D5()
{
  int result; // eax

  result = sub_8F023(dword_E3840, dword_EA3C8, dword_E3824 - 6);
  word_E387A = 1;
  return result;
}
// E3824: using guessed type int dword_E3824;
// E3840: using guessed type int dword_E3840;
// E387A: using guessed type __int16 word_E387A;
// EA3C8: using guessed type int dword_EA3C8;

//----- (0008E7FC) --------------------------------------------------------
void sub_8E7FC()
{
  __int16 v0; // ax
  char *v1; // edi
  _BYTE *v2; // esi
  int v3; // ecx
  char *v4; // edi
  char v5; // dl
  char v6; // al
  char *v7; // edi
  _BYTE *v8; // esi
  char v9; // al
  char v10; // al
  __int16 v11; // [esp-2h] [ebp-6h]

  word_E387A = 0;
  if ( dword_E383C == 1 )
  {
    v0 = *(_WORD *)dword_EA3C8;
    v1 = (char *)(dword_EA3C8 + 2);
    v2 = (_BYTE *)dword_EA3B8;
    do
    {
      v11 = v0;
      v3 = (unsigned __int8)*v1;
      v4 = v1 + 1;
      v2 += v3 + v3 + v3;
      v5 = *v4;
      v1 = v4 + 1;
      do
      {
        v6 = *v1;
        v7 = v1 + 1;
        *v2 = v6;
        v8 = v2 + 1;
        v9 = *v7++;
        *v8++ = v9;
        v10 = *v7;
        v1 = v7 + 1;
        *v8 = v10;
        v2 = v8 + 1;
        --v5;
      }
      while ( v5 );
      v0 = v11 - 1;
    }
    while ( v11 != 1 );
    sub_41A90((unsigned __int8 *)dword_EA3B8);
  }
}
// E383C: using guessed type int dword_E383C;
// E387A: using guessed type __int16 word_E387A;
// EA3B8: using guessed type int dword_EA3B8;
// EA3C8: using guessed type int dword_EA3C8;

//----- (0008E871) --------------------------------------------------------
__int16 sub_8E871()
{
  _WORD *v0; // esi
  _WORD *v1; // edi
  __int16 result; // ax
  unsigned __int8 v3; // bl
  _BYTE *v4; // edi
  char v5; // dl
  __int16 v6; // bx
  __int16 v7; // bx
  _WORD *v8; // [esp+0h] [ebp-10h]
  __int16 i; // [esp+6h] [ebp-Ah]
  __int16 v10; // [esp+8h] [ebp-8h]
  int v11; // [esp+Ch] [ebp-4h]

  v11 = (unsigned __int16)word_E3820;
  sub_8F023(dword_E3840, dword_E9C38, dword_E3824 - 6);
  v0 = (_WORD *)dword_180628;
  v10 = *(_WORD *)dword_E9C38;
  v1 = (_WORD *)(dword_E9C38 + 2);
  do
  {
    while ( 1 )
    {
      result = *v1;
      ++v1;
      v8 = v0;
      if ( result >= 0 )
        goto LABEL_6;
      if ( !(result & 0x4000) )
        break;
      v0 = (_WORD *)((char *)v0 + v11 * -result);
    }
    *((_BYTE *)v0 + v11 - 1) = result;
LABEL_6:
    for ( i = result; i; --i )
    {
      while ( 1 )
      {
        v3 = *(_BYTE *)v1;
        v4 = (char *)v1 + 1;
        v0 = (_WORD *)((char *)v0 + v3);
        v5 = *v4;
        v1 = v4 + 1;
        if ( v5 > 0 )
          break;
        v6 = *v1;
        ++v1;
        do
        {
          *v0 = v6;
          ++v0;
          ++v5;
        }
        while ( v5 );
        if ( !--i )
          goto LABEL_14;
      }
      do
      {
        v7 = *v1;
        ++v1;
        *v0 = v7;
        ++v0;
        --v5;
      }
      while ( v5 );
    }
LABEL_14:
    v0 = (_WORD *)((char *)v8 + v11);
    --v10;
  }
  while ( v10 );
  return result;
}
// E3820: using guessed type __int16 word_E3820;
// E3824: using guessed type int dword_E3824;
// E3840: using guessed type int dword_E3840;
// E9C38: using guessed type int dword_E9C38;
// 180628: using guessed type int dword_180628;

//----- (0008E948) --------------------------------------------------------
int sub_8E948()
{
  int v0; // ST1C_4
  int v1; // eax
  char *v2; // esi
  int v3; // edi
  __int16 v4; // ax
  int v5; // eax
  _BYTE *v6; // esi
  char *v7; // edi
  unsigned __int8 v8; // al
  char *v9; // esi
  unsigned int v10; // ecx
  char v11; // al
  int result; // eax
  int v13; // [esp+0h] [ebp-10h]
  __int16 i; // [esp+6h] [ebp-Ah]
  __int16 v15; // [esp+8h] [ebp-8h]

  v0 = (unsigned __int16)word_E3820;
  v1 = sub_8F023(dword_E3840, dword_E9C38, dword_E3824 - 6);
  LOWORD(v1) = *(_WORD *)dword_E9C38;
  v13 = v0 * v1 + dword_180628;
  v2 = (char *)(dword_E9C38 + 4);
  v15 = *(_WORD *)(dword_E9C38 + 2);
  do
  {
    v3 = v13;
    v4 = (unsigned __int8)*v2++;
    for ( i = v4; i; --i )
    {
      v5 = (unsigned __int8)*v2;
      v6 = v2 + 1;
      v7 = (char *)(v5 + v3);
      v8 = *v6;
      v9 = v6 + 1;
      if ( (v8 & 0x80u) != 0 )
      {
        v10 = (unsigned __int8)-v8;
        v11 = *v9;
        v2 = v9 + 1;
        memset(v7, v11, v10);
        v3 = (int)&v7[v10];
      }
      else
      {
        qmemcpy(v7, v9, v8);
        v2 = &v9[v8];
        v3 = (int)&v7[v8];
      }
    }
    result = (unsigned __int16)word_E3820;
    v13 += (unsigned __int16)word_E3820;
    --v15;
  }
  while ( v15 );
  return result;
}
// E3820: using guessed type __int16 word_E3820;
// E3824: using guessed type int dword_E3824;
// E3840: using guessed type int dword_E3840;
// E9C38: using guessed type int dword_E9C38;
// 180628: using guessed type int dword_180628;

//----- (0008E9EF) --------------------------------------------------------
char sub_8E9EF()
{
  __int16 v0; // ST0C_2
  _BYTE *v1; // esi
  char *v2; // edi
  __int16 v3; // bx
  __int16 v4; // cx
  unsigned __int8 v5; // dl
  __int16 v6; // ax
  char v7; // dh
  char v8; // dh
  __int16 v10; // [esp+2h] [ebp-2h]

  v10 = word_E3820;
  v0 = word_E3822;
  sub_8F023(dword_E3840, dword_E9C38, dword_E3824 - 6);
  v1 = (_BYTE *)dword_180628;
  v2 = (char *)dword_E9C38;
  v3 = v0;
  do
  {
    ++v2;
    v4 = v10;
    do
    {
      v5 = *v2++;
      if ( (char)v5 > 0 )
      {
        LOBYTE(v6) = v5;
        v4 -= v5;
      }
      else
      {
        HIBYTE(v6) = -1;
        LOBYTE(v6) = v5;
        v4 += v6;
      }
      if ( (char)v5 > 0 )
      {
        v8 = *v2++;
        do
        {
          *v1++ = v8;
          --v5;
        }
        while ( v5 );
      }
      else
      {
        do
        {
          v7 = *v2++;
          *v1++ = v7;
          ++v5;
        }
        while ( v5 );
      }
    }
    while ( v4 );
    --v3;
  }
  while ( v3 );
  return v6;
}
// E3820: using guessed type __int16 word_E3820;
// E3822: using guessed type __int16 word_E3822;
// E3824: using guessed type int dword_E3824;
// E3840: using guessed type int dword_E3840;
// E9C38: using guessed type int dword_E9C38;
// 180628: using guessed type int dword_180628;

//----- (0008EA7B) --------------------------------------------------------
void __fastcall sub_8EA7B(int a1, unsigned __int16 a2)
{
  __int16 v2; // dx
  __int16 v3; // cx

  if ( dword_E3844 )
  {
    do
    {
      do
      {
        __asm { int     21h; DOS - GET CURRENT TIME }
        v2 = 100 * HIBYTE(a2) + (unsigned __int8)a2;
        v3 = v2;
        a2 = v2 - word_E3834;
      }
      while ( !a2 );
      if ( (signed __int16)a2 <= 0 )
        a2 += 6000;
    }
    while ( a2 < dword_E3844 );
    word_E3834 = v3;
  }
}
// E3834: using guessed type __int16 word_E3834;
// E3844: using guessed type int dword_E3844;

//----- (0008EAD0) --------------------------------------------------------
signed int __cdecl sub_8EAD0(int a1)
{
  char v2[8]; // [esp+44h] [ebp-1Ch]
  int v4; // [esp+50h] [ebp-10h]
  int v5; // [esp+54h] [ebp-Ch]
  int v6; // [esp+58h] [ebp-8h]
  int v7; // [esp+5Ch] [ebp-4h]
  int v8; // [esp+74h] [ebp+14h]

  if ( !byte_E37FC )
    return 0;
  sub_8E020();
  v4 = sub_98817((int)aSoundMusicDat, 512);
  if ( !v4 )
    return 0;
  sub_9891E(v4, 0, 2);
  v7 = tell(v4);
  sub_9891E(v4, v7 - 4, 0);
  sub_988A7(v4, (int)&v5, 4);
  sub_9891E(v4, v5, 0);
  sub_988A7(v4, (int)v2, 8);
  v8 = a1 + 1;
  if ( (unsigned __int8)byte_180C84 < 0x57u )
  {
    if ( (unsigned __int8)byte_180C84 >= 0x47u )
    {
      if ( (unsigned __int8)byte_180C84 > 0x47u )
      {
        if ( byte_180C84 == 82 )
          goto LABEL_21;
        goto LABEL_24;
      }
LABEL_20:
      v6 = 0;
      goto LABEL_24;
    }
    if ( byte_180C84 != 70 )
      goto LABEL_24;
LABEL_22:
    v6 = 2;
    goto LABEL_24;
  }
  if ( (unsigned __int8)byte_180C84 <= 0x57u )
    goto LABEL_23;
  if ( (unsigned __int8)byte_180C84 < 0x67u )
  {
    if ( byte_180C84 != 102 )
      goto LABEL_24;
    goto LABEL_22;
  }
  if ( (unsigned __int8)byte_180C84 <= 0x67u )
    goto LABEL_20;
  if ( (unsigned __int8)byte_180C84 >= 0x72u )
  {
    if ( (unsigned __int8)byte_180C84 > 0x72u )
    {
      if ( byte_180C84 != 119 )
        goto LABEL_24;
LABEL_23:
      v6 = 3;
      goto LABEL_24;
    }
LABEL_21:
    v6 = 1;
  }
LABEL_24:
  if ( (unsigned __int16)v8 <= *(_WORD *)&v2[2 * v6] )
  {
    sub_9891E(v4, (unsigned __int16)(v8 - 1) << 6, 1);
    if ( !sub_8ED00(v4, v6) )
    {
      sub_98882(v4);
      return 1;
    }
    sub_98882(v4);
    return 0;
  }
  sub_98882(v4);
  return 1;
}
// 9A510: using guessed type _DWORD __cdecl tell(_DWORD);
// E37FC: using guessed type char byte_E37FC;
// 180C84: using guessed type char byte_180C84;
// 8EAD0: using guessed type char var_1C[8];

//----- (0008EC90) --------------------------------------------------------
unsigned int sub_8EC90()
{
  unsigned int result; // eax
  unsigned int v1; // [esp+0h] [ebp-4h]

  if ( dword_E3808 && dword_E3810 )
  {
    v1 = dword_E3808 + 32;
    for ( word_E3804 = 0; ; ++word_E3804 )
    {
      result = v1;
      if ( v1 >= dword_E380C )
        break;
      *(_DWORD *)(v1 + 18) += dword_E3810;
      v1 += 32;
    }
  }
  return result;
}
// E3804: using guessed type __int16 word_E3804;
// E3808: using guessed type int dword_E3808;
// E380C: using guessed type int dword_E380C;
// E3810: using guessed type int dword_E3810;

//----- (0008ED00) --------------------------------------------------------
char __cdecl sub_8ED00(int a1, unsigned __int8 a2)
{
  char v3[64]; // [esp+0h] [ebp-5Ch]
  char v4[64]; // [esp+4h] [ebp-58h]
  char v5[64]; // [esp+8h] [ebp-54h]
  char v6[64]; // [esp+Ch] [ebp-50h]
  char *v7; // [esp+40h] [ebp-1Ch]
  int v8; // [esp+44h] [ebp-18h]
  char *v9; // [esp+4Ch] [ebp-10h]
  int v10; // [esp+50h] [ebp-Ch]
  unsigned __int8 i; // [esp+58h] [ebp-4h]

  v8 = tell(a1);
  sub_988A7(a1, (int)v3, 64);
  if ( *(_DWORD *)&v4[16 * a2] == -1 )
    return 0;
  if ( dword_E3810 )
  {
    sub_83E80(dword_E3810);
    byte_E37FC = 0;
  }
  if ( dword_E3808 )
  {
    sub_83E80(dword_E3808);
    byte_E37FC = 0;
  }
  dword_E3810 = sub_83CD0(*(_DWORD *)&v6[16 * a2]);
  if ( !dword_E3810 )
    return 0;
  dword_E3808 = sub_83CD0(*(_DWORD *)&v5[16 * a2]);
  if ( !dword_E3808 )
  {
    sub_83E80(dword_E3810);
    return 0;
  }
  v7 = (char *)dword_E3810;
  v9 = (char *)dword_E3808;
  dword_E380C = *(_DWORD *)&v5[16 * a2] + dword_E3808;
  sub_9891E(a1, *(_DWORD *)&v4[16 * a2], 0);
  sub_988A7(a1, (int)v7, 8);
  if ( *v7 == 82 && v7[1] == 78 && v7[2] == 67 )
  {
    v10 = (unsigned __int8)v7[4];
    v10 <<= 8;
    v10 += (unsigned __int8)v7[5];
    v10 <<= 8;
    v10 += (unsigned __int8)v7[6];
    v10 <<= 8;
    v10 += (unsigned __int8)v7[7];
    sub_988A7(a1, dword_E3810 + 8, v10 - 8);
    sub_9894C((int)v7, v7);
  }
  else
  {
    sub_988A7(a1, dword_E3810 + 8, *(_DWORD *)&v6[16 * a2] - 8);
  }
  sub_9891E(a1, *(_DWORD *)&v3[16 * a2], 0);
  sub_988A7(a1, (int)v9, 8);
  if ( *v9 == 82 && v9[1] == 78 && v9[2] == 67 )
  {
    v10 = (unsigned __int8)v9[4];
    v10 <<= 8;
    v10 += (unsigned __int8)v9[5];
    v10 <<= 8;
    v10 += (unsigned __int8)v9[6];
    v10 <<= 8;
    v10 += (unsigned __int8)v9[7];
    sub_988A7(a1, dword_E3808 + 8, v10 - 8);
    sub_9894C((int)v9, v9);
  }
  else
  {
    sub_988A7(a1, dword_E3808 + 8, *(_DWORD *)&v5[16 * a2] - 8);
  }
  sub_8EC90();
  for ( i = 1; i <= (signed int)(unsigned __int16)word_E3804; ++i )
    sub_95C00((int *)dword_180C78, *(_DWORD *)(dword_E3808 + 32 * i + 18), 0);
  byte_E37FC = 1;
  return 1;
}
// 9A510: using guessed type _DWORD __cdecl tell(_DWORD);
// E37FC: using guessed type char byte_E37FC;
// E3804: using guessed type __int16 word_E3804;
// E3808: using guessed type int dword_E3808;
// E380C: using guessed type int dword_E380C;
// E3810: using guessed type int dword_E3810;
// 180C78: using guessed type int dword_180C78;
// 8ED00: using guessed type char var_5C[64];

//----- (0008F023) --------------------------------------------------------
int __cdecl sub_8F023(int a1, int a2, unsigned int a3)
{
  _BYTE *v3; // eax
  _BYTE *v4; // edx
  unsigned int i; // [esp+4h] [ebp-4h]

  if ( !dword_E387C )
    return sub_988A7(a1, a2, a3);
  for ( i = 0; i < a3 && dword_E3888 + i < dword_E3884; ++i )
  {
    v3 = (_BYTE *)dword_E3880++;
    v4 = (_BYTE *)a2++;
    *v4 = *v3;
  }
  dword_E3888 += a3;
  return i;
}
// E387C: using guessed type int dword_E387C;
// E3880: using guessed type int dword_E3880;
// E3884: using guessed type int dword_E3884;
// E3888: using guessed type int dword_E3888;

//----- (0008F0AB) --------------------------------------------------------
int __cdecl sub_8F0AB(int a1, int a2, int a3)
{
  int result; // eax

  result = read(a1, dword_E387C, a3);
  dword_E3880 = dword_E387C;
  dword_E3884 = result;
  dword_E3888 = 0;
  return result;
}
// A0863: using guessed type _DWORD __cdecl read(_DWORD, _DWORD, _DWORD);
// E387C: using guessed type int dword_E387C;
// E3880: using guessed type int dword_E3880;
// E3884: using guessed type int dword_E3884;
// E3888: using guessed type int dword_E3888;

//----- (0008F100) --------------------------------------------------------
int **__cdecl sub_8F100(int *a1, __int16 a2, int a3, int a4, unsigned __int16 a5, char a6, unsigned __int8 a7)
{
  char v8; // [esp+0h] [ebp-18h]
  int *i; // [esp+8h] [ebp-10h]
  char *j; // [esp+8h] [ebp-10h]
  int *k; // [esp+8h] [ebp-10h]
  int **l; // [esp+8h] [ebp-10h]
  int *m; // [esp+8h] [ebp-10h]
  int **v14; // [esp+Ch] [ebp-Ch]
  char *v15; // [esp+10h] [ebp-8h]

  if ( !byte_E3798
    || !byte_E3799
    || a2 > (signed int)(unsigned __int16)word_180B50
    || !stricmp(32 * a2 + dword_E37A0, aNullWav) )
  {
    return 0;
  }
  v8 = 0;
  if ( a7 < 2u )
  {
    if ( a7 == 1 )
    {
      v14 = 0;
      for ( i = (int *)&unk_180750; (unsigned int)i < dword_180B4C; i = (int *)((char *)i + 23) )
      {
        if ( sub_94010(*i) == 2 )
        {
          v14 = (int **)i;
          v15 = 0;
          break;
        }
      }
    }
  }
  else if ( a7 <= 2u )
  {
    v15 = 0;
    for ( j = (char *)&unk_180750; (unsigned int)j < dword_180B4C; j += 23 )
    {
      if ( *(int **)(j + 14) == a1 && *((_WORD *)j + 9) == a2 && sub_94010(*(_DWORD *)j) != 2 )
      {
        v15 = j;
        break;
      }
    }
    if ( !v15 )
    {
      v14 = 0;
      for ( k = (int *)&unk_180750; (unsigned int)k < dword_180B4C; k = (int *)((char *)k + 23) )
      {
        if ( sub_94010(*k) == 2 )
        {
          v14 = (int **)k;
          break;
        }
      }
    }
  }
  else if ( a7 == 3 )
  {
    v8 = 0;
    for ( l = (int **)&unk_180750; (unsigned int)l < dword_180B4C; l = (int **)((char *)l + 23) )
    {
      if ( *(int **)((char *)l + 14) == a1 && *((_WORD *)l + 9) == a2 )
      {
        v14 = l;
        v15 = 0;
        v8 = 1;
        break;
      }
    }
    if ( !v8 )
    {
      v14 = 0;
      for ( m = (int *)&unk_180750; (unsigned int)m < dword_180B4C; m = (int *)((char *)m + 23) )
      {
        if ( sub_94010(*m) == 2 )
        {
          v14 = (int **)m;
          v15 = 0;
          break;
        }
      }
    }
  }
  if ( !v14 || v15 )
    return 0;
  if ( !v8 )
  {
    sub_93830(*v14);
    sub_938C0(*v14, *(_DWORD *)(dword_E37A0 + 32 * a2 + 18), 1);
  }
  sub_93E30(*v14, a3);
  sub_93ED0(*v14, a4);
  sub_93D90((int)*v14, dword_E37BC * (unsigned int)a5 / 0x64);
  sub_93F70((int)*v14, a6 + 1);
  sub_93B50(*v14);
  *(int **)((char *)v14 + 14) = a1;
  *((_WORD *)v14 + 9) = a2;
  v14[1] = (int *)a3;
  *((_WORD *)v14 + 5) = a4;
  *((_WORD *)v14 + 4) = a5;
  *((_BYTE *)v14 + 20) = 0;
  *((_BYTE *)v14 + 21) = 0;
  return v14;
}
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E37A0: using guessed type int dword_E37A0;
// E37BC: using guessed type int dword_E37BC;
// 180B4C: using guessed type int dword_180B4C;
// 180B50: using guessed type __int16 word_180B50;

//----- (0008F420) --------------------------------------------------------
void __cdecl sub_8F420(int a1, __int16 a2)
{
  int *i; // [esp+0h] [ebp-4h]

  if ( byte_E3798 && byte_E3799 )
  {
    for ( i = (int *)&unk_180750; (unsigned int)i < dword_180B4C; i = (int *)((char *)i + 23) )
    {
      if ( *(int *)((char *)i + 14) == a1 && *((_WORD *)i + 9) == a2 && sub_94010(*i) != 2 )
      {
        sub_93D00(*i);
        return;
      }
    }
  }
}
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// 180B4C: using guessed type int dword_180B4C;

//----- (0008F710) --------------------------------------------------------
void __cdecl sub_8F710(int a1, __int16 a2, signed int a3, unsigned __int8 a4, char a5)
{
  char *i; // [esp+0h] [ebp-4h]

  if ( byte_E3798 && byte_E3799 && a2 <= (signed int)(unsigned __int16)word_180B50 )
  {
    for ( i = (char *)&unk_180750; (unsigned int)i < dword_180B4C; i += 23 )
    {
      if ( *(_DWORD *)(i + 14) == a1 && *((_WORD *)i + 9) == a2 && sub_94010(*(_DWORD *)i) != 2 )
      {
        if ( (unsigned __int16)a3 > 0x7Fu )
          a3 = 127;
        if ( (unsigned __int16)a3 != *((_DWORD *)i + 1) )
        {
          i[20] = 0;
          *((_WORD *)i + 6) = a3;
          i[21] = a5;
          if ( (signed int)(unsigned __int16)a3 > *((_DWORD *)i + 1) )
            i[20] = 1;
          else
            i[20] = 2;
          if ( !byte_E388D )
          {
            byte_E388D = 1;
            if ( a4 <= 4u )
            {
              dword_180CA0[0] = sub_92600((int)sub_8F4B0);
              sub_92930(dword_180CA0[0], 30 * a4);
              sub_92BA0(dword_180CA0[0]);
            }
          }
        }
        return;
      }
    }
  }
}
// 8F4B0: using guessed type int sub_8F4B0();
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E388D: using guessed type char byte_E388D;
// 180B4C: using guessed type int dword_180B4C;
// 180B50: using guessed type __int16 word_180B50;
// 180CA0: using guessed type int dword_180CA0[];

//----- (0008F850) --------------------------------------------------------
char *sub_8F850()
{
  char *result; // eax
  char *i; // [esp+0h] [ebp-4h]

  if ( byte_E388D )
  {
    sub_92DC0(dword_180CA0[0]);
    byte_E388D = 0;
    for ( i = (char *)&unk_180750; ; i += 23 )
    {
      result = i;
      if ( (unsigned int)i >= dword_180B4C )
        break;
      i[20] = 0;
      i[21] = 0;
    }
  }
  return result;
}
// E388D: using guessed type char byte_E388D;
// 180B4C: using guessed type int dword_180B4C;
// 180CA0: using guessed type int dword_180CA0[];

//----- (0008F8B0) --------------------------------------------------------
int __cdecl sub_8F8B0(__int16 a1, __int16 a2, int a3)
{
  int v4; // [esp+4h] [ebp-4h]

  sub_8F935(*(_WORD *)(a3 + 4), a2, a1, *(char **)a3, 0, 0);
  return v4;
}
// 180628: using guessed type int dword_180628;

//----- (0008F8E8) --------------------------------------------------------
int __cdecl sub_8F8E8(__int16 a1, __int16 a2, int a3)
{
  int v4; // [esp+4h] [ebp-4h]

  sub_8F935(*(_WORD *)(a3 + 4), a2, a1, *(char **)a3, 0, 0);
  return v4;
}
// 180628: using guessed type int dword_180628;

//----- (0008F920) --------------------------------------------------------
void __usercall sub_8F920(__int16 a1@<dx>, signed int a2@<ecx>, int a3@<ebx>, char *a4@<esi>, unsigned __int8 a5, char a6)
{
  sub_8F935(a1, a2, a3, a4, a5, a6);
}

//----- (0008F935) --------------------------------------------------------
void __usercall sub_8F935(__int16 a1@<dx>, signed int a2@<ecx>, int a3@<ebx>, char *a4@<esi>, unsigned __int8 a5, char a6)
{
  int v6; // edi
  _BYTE *v7; // edi
  int v8; // ecx
  signed int v9; // eax
  _BYTE *v10; // ebx
  char v11; // al
  char v12; // al
  char v13; // al
  _BYTE *v14; // edi
  int v15; // ecx
  signed int v16; // eax
  _BYTE *v17; // ebx
  char v18; // al
  char v19; // al
  char v20; // al
  char *v21; // edi
  unsigned int v22; // ecx
  signed int v23; // eax
  char *v24; // ebx
  char *v25; // edi
  char v26; // al
  char *v27; // esi
  char *v28; // edi
  unsigned int v29; // ecx
  signed int v30; // eax
  char *v31; // ebx
  char *v32; // edi
  char v33; // al
  char *v34; // esi
  int v35; // ebp
  _BYTE *v36; // edi
  int v37; // ecx
  _BYTE *v38; // ebx
  unsigned __int8 v39; // al
  int v40; // eax
  _BYTE *v41; // edi
  int v42; // ecx
  unsigned __int8 i; // dl
  char v44; // al
  char v45; // al
  unsigned __int8 v46; // of
  char v47; // dl
  unsigned __int8 v48; // al
  char *v49; // edi
  char v50; // al
  char v51; // dl
  char v52; // al
  char v53; // dl
  unsigned int v54; // ebx
  const void *v55; // esi
  char *v56; // edi
  unsigned int v57; // ecx
  signed int v58; // eax
  char *v59; // ebx
  char *v60; // edi
  char *v61; // edi
  unsigned int v62; // ecx
  signed int v63; // eax
  char *v64; // ebx
  char *v65; // edi
  char v66; // al
  char *v67; // esi
  int v68; // edi
  int v69; // ebx
  _BYTE *v70; // edi
  _BYTE *v71; // edx
  int v72; // ecx
  char v73; // al
  char v74; // al
  _BOOL1 v75; // zf
  _BOOL1 v76; // sf
  char v77; // al
  char v78; // al
  int v79; // ebx
  _BYTE *v80; // edi
  int v81; // ecx
  signed int v82; // eax
  _BYTE *v83; // ebx
  char v84; // al
  int v85; // ebx
  _BYTE *v86; // edi
  int v87; // ecx
  signed int v88; // eax
  _BYTE *v89; // ebx
  char v90; // al
  _BYTE *v91; // edi
  int v92; // ecx
  int v93; // ebx
  signed int v94; // eax
  _BYTE *v95; // ebx
  char v96; // al
  unsigned int v97; // ebx
  _BYTE *v98; // edi
  _BYTE *v99; // edx
  int v100; // ecx
  char v101; // al
  char v102; // al
  char v103; // al
  char v104; // al
  _BYTE *v105; // edi
  int v106; // ecx
  int v107; // ebx
  _BYTE *v108; // ebx
  signed int v109; // eax
  char v110; // al
  _BYTE *v111; // edi
  int v112; // ecx
  int v113; // ebx
  _BYTE *v114; // ebx
  signed int v115; // eax
  char v116; // al
  unsigned int v117; // ebx
  _BYTE *v118; // edi
  _BYTE *v119; // edx
  int v120; // ecx
  char v121; // al
  char v122; // al
  char v123; // al
  char v124; // al
  int v125; // eax
  int v126; // edi
  int v127; // eax
  int v128; // eax
  int v129; // eax
  int v130; // eax
  char *v131; // [esp-4h] [ebp-Ch]
  unsigned __int8 v132; // [esp+2h] [ebp-6h]
  unsigned __int8 v133; // [esp+2h] [ebp-6h]
  unsigned __int8 v134; // [esp+2h] [ebp-6h]
  unsigned __int8 v135; // [esp+2h] [ebp-6h]
  unsigned __int8 v136; // [esp+2h] [ebp-6h]
  unsigned __int8 v137; // [esp+2h] [ebp-6h]
  unsigned __int8 v138; // [esp+2h] [ebp-6h]
  unsigned __int8 v139; // [esp+2h] [ebp-6h]
  char v140; // [esp+3h] [ebp-5h]
  char v141; // [esp+3h] [ebp-5h]
  _BYTE *v142; // [esp+4h] [ebp-4h]
  _BYTE *v143; // [esp+4h] [ebp-4h]

  if ( !HIBYTE(a1) )
    return;
  v6 = dword_180628 + dword_18063C + dword_18062C * dword_180650;
  if ( word_180660 & 1 )
  {
    LOBYTE(a1) = (unsigned __int8)a1 >> 1;
    HIBYTE(a1) >>= 1;
    a3 >>= 1;
    a2 >>= 1;
  }
  if ( a2 < 0 )
  {
    if ( word_E36D4 & 2 )
    {
      v128 = a2 + HIBYTE(a1);
      v46 = __OFADD__(1, v128);
      v129 = v128 + 1;
      if ( (unsigned __int8)((v129 < 0) ^ v46) | (v129 == 0) )
        return;
      a2 = -1;
      HIBYTE(a1) = v129;
    }
    else
    {
      v130 = a2 + HIBYTE(a1);
      if ( (unsigned __int8)((a2 + HIBYTE(a1) < 0) ^ __OFADD__(a2, HIBYTE(a1))) | (a2 + HIBYTE(a1) == 0) )
        return;
      HIBYTE(a1) += a2;
      BYTE1(v130) = 0;
      do
      {
        while ( 1 )
        {
          LOBYTE(v130) = *a4++;
          if ( !(_BYTE)v130 )
            break;
          if ( (v130 & 0x80u) == 0 )
            a4 += v130;
        }
        ++a2;
      }
      while ( a2 );
    }
  }
  else if ( a2 + HIBYTE(a1) >= dword_180644 )
  {
    if ( word_E36D4 & 2 )
    {
      if ( a2 + 1 >= dword_180644 )
        return;
      v125 = HIBYTE(a1) + a2 + 1 - dword_180644;
      HIBYTE(a1) = dword_180644 - (a2 + 1);
      v126 = v125;
      v127 = 0;
      do
      {
        while ( 1 )
        {
          LOBYTE(v127) = *a4++;
          if ( !(_BYTE)v127 )
            break;
          if ( (v127 & 0x80u) == 0 )
            a4 += v127;
        }
        --v126;
      }
      while ( v126 );
      v6 = dword_180628;
    }
    else
    {
      if ( dword_180644 <= a2 )
        return;
      HIBYTE(a1) = dword_180644 - a2;
    }
  }
  if ( a3 >= 0 )
  {
    if ( a3 + (unsigned __int8)a1 >= dword_180648 )
    {
      if ( word_E36D4 )
      {
        if ( word_E36D4 & 1 )
        {
          if ( word_E36D4 & 2 )
          {
            if ( dword_180634 - a3 >= 0 )
            {
              v79 = (unsigned __int8)a1 + a3;
              v80 = (_BYTE *)(dword_18062C * (HIBYTE(a1) + a2) + v79 + v6);
              v81 = 0;
              LOBYTE(v79) = dword_180634 - v79 - 2;
              LOBYTE(a1) = v79;
              v133 = v79;
              v82 = -1;
              v83 = v80;
              do
              {
                while ( 1 )
                {
                  while ( 1 )
                  {
                    LOBYTE(v82) = *a4++;
                    if ( (v82 & 0x80u) == 0 )
                      break;
                    v80 += v82;
                    LOBYTE(a1) = a1 - v82;
                  }
                  if ( !(_BYTE)v82 )
                    break;
                  LOBYTE(v81) = v82;
                  do
                  {
                    v84 = *a4++;
                    LOBYTE(a1) = a1 + 1;
                    if ( (a1 & 0x80u) == 0 )
                      *v80 = v84;
                    --v80;
                    --v81;
                  }
                  while ( v81 );
                }
                v83 -= dword_18062C;
                v80 = v83;
                a1 = __PAIR__(HIBYTE(a1), v133) - 256;
              }
              while ( HIBYTE(a1) );
            }
          }
          else if ( dword_180634 - a3 >= 0 )
          {
            v85 = (unsigned __int8)a1 + a3;
            v86 = (_BYTE *)(dword_18062C * a2 + v85 + v6);
            v87 = 0;
            LOBYTE(v85) = dword_180634 - v85 - 2;
            LOBYTE(a1) = v85;
            v134 = v85;
            v88 = -1;
            v89 = v86;
            do
            {
              while ( 1 )
              {
                while ( 1 )
                {
                  LOBYTE(v88) = *a4++;
                  if ( (v88 & 0x80u) == 0 )
                    break;
                  v86 += v88;
                  LOBYTE(a1) = a1 - v88;
                }
                if ( !(_BYTE)v88 )
                  break;
                LOBYTE(v87) = v88;
                do
                {
                  v90 = *a4++;
                  LOBYTE(a1) = a1 + 1;
                  if ( (a1 & 0x80u) == 0 )
                    *v86 = v90;
                  --v86;
                  --v87;
                }
                while ( v87 );
              }
              v89 += dword_18062C;
              v86 = v89;
              a1 = __PAIR__(HIBYTE(a1), v134) - 256;
            }
            while ( HIBYTE(a1) );
          }
        }
        else if ( word_E36D4 & 2 )
        {
          v91 = (_BYTE *)(dword_18062C * (HIBYTE(a1) + a2) + a3 + v6);
          v92 = 0;
          v93 = dword_180634 - a3;
          if ( v93 >= 0 )
          {
            LOBYTE(a1) = v93;
            v135 = v93;
            v94 = -1;
            v95 = v91;
            do
            {
              while ( 1 )
              {
                while ( 1 )
                {
                  LOBYTE(v94) = *a4++;
                  if ( (v94 & 0x80u) == 0 )
                    break;
                  v91 -= v94;
                  LOBYTE(a1) = v94 + a1;
                }
                if ( !(_BYTE)v94 )
                  break;
                LOBYTE(v92) = v94;
                do
                {
                  v96 = *a4++;
                  LOBYTE(a1) = a1 - 1;
                  if ( (a1 & 0x80u) == 0 )
                    *v91++ = v96;
                  --v92;
                }
                while ( v92 );
              }
              v95 -= dword_18062C;
              v91 = v95;
              a1 = __PAIR__(HIBYTE(a1), v135) - 256;
            }
            while ( HIBYTE(a1) );
          }
        }
      }
      else
      {
        v68 = a3 + v6;
        v69 = dword_180634 - a3;
        if ( v69 >= 0 )
        {
          v70 = (_BYTE *)(dword_18062C * a2 + v68);
          BYTE1(v69) = HIBYTE(a1);
          v132 = v69;
          v71 = v70;
          v72 = 0;
          do
          {
            while ( 1 )
            {
              while ( 1 )
              {
                v73 = *a4++;
                if ( v73 >= 0 )
                  break;
                v46 = __OFADD__(v73, (_BYTE)v69);
                v75 = v73 + (_BYTE)v69 == 0;
                v76 = (char)(v73 + v69) < 0;
                LOBYTE(v69) = v73 + v69;
                if ( !((unsigned __int8)(v76 ^ v46) | (unsigned __int8)v75) )
                {
                  v70 -= v73;
                  v77 = *a4++;
                  LOBYTE(v72) = v77;
                  do
                  {
                    v78 = *a4++;
                    LOBYTE(v69) = v69 - 1;
                    if ( (v69 & 0x80u) == 0 )
                      *v70++ = v78;
                    --v72;
                  }
                  while ( v72 );
                }
              }
              if ( !v73 )
                break;
              LOBYTE(v72) = v73;
              do
              {
                v74 = *a4++;
                LOBYTE(v69) = v69 - 1;
                if ( (v69 & 0x80u) == 0 )
                  *v70++ = v74;
                --v72;
              }
              while ( v72 );
            }
            v71 += dword_18062C;
            v70 = v71;
            LOWORD(v69) = __PAIR__(BYTE1(v69), v132) - 256;
          }
          while ( BYTE1(v69) );
        }
      }
    }
    else if ( word_E36D4 & 1 )
    {
      if ( word_E36D4 & 2 )
      {
        v7 = (_BYTE *)(dword_18062C * (HIBYTE(a1) + a2) + (unsigned __int8)a1 + a3 + v6);
        v8 = 0;
        v9 = -1;
        v10 = v7;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              LOBYTE(v9) = *a4++;
              if ( (v9 & 0x80u) == 0 )
                break;
              v7 += v9;
              v12 = *a4++;
              LOBYTE(v8) = v12;
              do
              {
                v13 = *a4++;
                *v7-- = v13;
                --v8;
              }
              while ( v8 );
            }
            if ( !(_BYTE)v9 )
              break;
            LOBYTE(v8) = v9;
            do
            {
              v11 = *a4++;
              *v7-- = v11;
              --v8;
            }
            while ( v8 );
          }
          v10 -= dword_18062C;
          v7 = v10;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
      else
      {
        v14 = (_BYTE *)(dword_18062C * a2 + (unsigned __int8)a1 + a3 + v6);
        v15 = 0;
        v16 = -1;
        v17 = v14;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              LOBYTE(v16) = *a4++;
              if ( (v16 & 0x80u) == 0 )
                break;
              v14 += v16;
              v19 = *a4++;
              LOBYTE(v15) = v19;
              do
              {
                v20 = *a4++;
                *v14-- = v20;
                --v15;
              }
              while ( v15 );
            }
            if ( !(_BYTE)v16 )
              break;
            LOBYTE(v15) = v16;
            do
            {
              v18 = *a4++;
              *v14-- = v18;
              --v15;
            }
            while ( v15 );
          }
          v17 += dword_18062C;
          v14 = v17;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
    }
    else if ( word_E36D4 )
    {
      if ( word_E36D4 & 2 )
      {
        v28 = (char *)(dword_18062C * (HIBYTE(a1) + a2) + a3 + v6);
        v29 = 0;
        v30 = -1;
        v31 = v28;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              LOBYTE(v30) = *a4++;
              if ( (v30 & 0x80u) == 0 )
                break;
              v32 = &v28[-v30];
              v33 = *a4;
              v34 = a4 + 1;
              LOBYTE(v29) = v33;
              qmemcpy(v32, v34, v29);
              a4 = &v34[v29];
              v28 = &v32[v29];
              v29 = 0;
            }
            if ( !(_BYTE)v30 )
              break;
            LOBYTE(v29) = v30;
            qmemcpy(v28, a4, v29);
            a4 += v29;
            v28 += v29;
            v29 = 0;
          }
          v31 -= dword_18062C;
          v28 = v31;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
      else if ( word_E36D4 & 4 )
      {
        v35 = dword_E3890;
        v36 = (_BYTE *)(dword_18062C * a2 + a3 + v6);
        v37 = 0;
        v38 = v36;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              v39 = *a4++;
              if ( (v39 & 0x80u) == 0 )
                break;
              v36 -= (char)v39;
            }
            if ( !v39 )
              break;
            LOBYTE(v37) = v39;
            v40 = v39;
            do
            {
              LOBYTE(v40) = *a4++;
              BYTE1(v40) = *v36;
              *v36++ = *(_BYTE *)(v40 + v35);
              --v37;
            }
            while ( v37 );
          }
          v38 += dword_18062C;
          v36 = v38;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
      else if ( word_E36D4 & 8 )
      {
        v41 = (_BYTE *)(dword_18062C * a2 + a3 + v6);
        v42 = 0;
        v142 = v41;
        v140 = HIBYTE(a1);
        for ( i = a5; ; i = a5 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              v44 = *a4++;
              if ( v44 >= 0 )
                break;
              v42 = (unsigned __int8)-v44;
              do
              {
                v46 = __OFSUB__(i--, 1);
                if ( ((i & 0x80u) != 0) ^ v46 )
                {
                  i = a5;
                  ++v41;
                }
                --v42;
              }
              while ( v42 );
            }
            if ( !v44 )
              break;
            LOBYTE(v42) = v44;
            do
            {
              v45 = *a4++;
              v46 = __OFSUB__(i--, 1);
              if ( ((i & 0x80u) != 0) ^ v46 )
              {
                i = a5;
                *v41++ = v45;
              }
              --v42;
            }
            while ( v42 );
          }
          if ( !--v140 )
            break;
          v47 = a6;
          while ( --v47 >= 0 )
          {
            while ( 1 )
            {
              do
                v48 = *a4++;
              while ( (v48 & 0x80u) != 0 );
              if ( !v48 )
                break;
              a4 += v48;
            }
          }
          v142 += dword_18062C;
          v41 = v142;
        }
      }
      else if ( word_E36D4 & 0x20 )
      {
        v49 = (char *)(dword_18062C * a2 + a3 + v6);
        v143 = v49;
        v141 = HIBYTE(a1);
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              v50 = *a4++;
              if ( v50 >= 0 )
                break;
              v49 += (unsigned __int16)(a5 * (unsigned __int8)-v50);
            }
            if ( !v50 )
              break;
            v51 = v50;
            do
            {
              v52 = *a4++;
              memset(v49, v52, a5);
              v49 += a5;
              v46 = __OFSUB__(v51--, 1);
            }
            while ( !((unsigned __int8)((v51 < 0) ^ v46) | (v51 == 0)) );
          }
          v53 = a6 - 1;
          if ( a6 > 1 )
          {
            v131 = a4;
            v54 = v49 - v143;
            do
            {
              v55 = v143;
              v143 += dword_18062C;
              qmemcpy(v143, v55, v54);
              v46 = __OFSUB__(v53--, 1);
            }
            while ( !((unsigned __int8)((v53 < 0) ^ v46) | (v53 == 0)) );
            a4 = v131;
          }
          v143 += dword_18062C;
          v49 = v143;
          --v141;
        }
        while ( v141 );
      }
      else if ( word_E36D4 & 0x40 )
      {
        v56 = (char *)(dword_18062C * a2 + a3 + v6);
        v57 = 0;
        v58 = -1;
        v59 = v56;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              LOBYTE(v58) = *a4++;
              if ( (v58 & 0x80u) == 0 )
                break;
              v60 = &v56[-v58];
              LOBYTE(v57) = *a4;
              a4 += v57 + 1;
              memset(v60, a5, v57);
              v56 = &v60[v57];
              v57 = 0;
            }
            if ( !(_BYTE)v58 )
              break;
            LOBYTE(v57) = v58;
            a4 += v57;
            memset(v56, a5, v57);
            v56 += v57;
            v57 = 0;
          }
          v59 += dword_18062C;
          v56 = v59;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
      else
      {
        v61 = (char *)(dword_18062C * a2 + a3 + v6);
        v62 = 0;
        v63 = -1;
        v64 = v61;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              LOBYTE(v63) = *a4++;
              if ( (v63 & 0x80u) == 0 )
                break;
              v65 = &v61[-v63];
              v66 = *a4;
              v67 = a4 + 1;
              LOBYTE(v62) = v66;
              qmemcpy(v65, v67, v62);
              a4 = &v67[v62];
              v61 = &v65[v62];
              v62 = 0;
            }
            if ( !(_BYTE)v63 )
              break;
            LOBYTE(v62) = v63;
            qmemcpy(v61, a4, v62);
            a4 += v62;
            v61 += v62;
            v62 = 0;
          }
          v64 += dword_18062C;
          v61 = v64;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
    }
    else
    {
      v21 = (char *)(dword_18062C * a2 + a3 + v6);
      v22 = 0;
      v23 = -1;
      v24 = v21;
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            LOBYTE(v23) = *a4++;
            if ( (v23 & 0x80u) == 0 )
              break;
            v25 = &v21[-v23];
            v26 = *a4;
            v27 = a4 + 1;
            LOBYTE(v22) = v26;
            qmemcpy(v25, v27, v22);
            a4 = &v27[v22];
            v21 = &v25[v22];
            v22 = 0;
          }
          if ( !(_BYTE)v23 )
            break;
          LOBYTE(v22) = v23;
          qmemcpy(v21, a4, v22);
          a4 += v22;
          v21 += v22;
          v22 = 0;
        }
        v24 += dword_18062C;
        v21 = v24;
        --HIBYTE(a1);
      }
      while ( HIBYTE(a1) );
    }
    return;
  }
  if ( !word_E36D4 )
  {
    v97 = -a3;
    if ( (unsigned __int8)a1 <= v97 )
      return;
    v98 = (_BYTE *)(dword_18062C * a2 + v6);
    BYTE1(v97) = HIBYTE(a1);
    v99 = v98;
    v136 = v97;
    v100 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v101 = *a4++;
          if ( v101 < 0 )
            break;
          if ( v101 )
          {
            LOBYTE(v100) = v101;
            do
            {
              v102 = *a4++;
              LOBYTE(v97) = v97 - 1;
              if ( (v97 & 0x80u) != 0 )
                *v98++ = v102;
              --v100;
            }
            while ( v100 );
          }
          else
          {
            v99 += dword_18062C;
            v98 = v99;
            LOWORD(v97) = __PAIR__(BYTE1(v97), v136) - 256;
            if ( !BYTE1(v97) )
              return;
          }
        }
        if ( (char)v97 > 0 )
          break;
LABEL_179:
        v98 -= v101;
        v103 = *a4++;
        LOBYTE(v100) = v103;
        do
        {
          v104 = *a4++;
          LOBYTE(v97) = v97 - 1;
          if ( (v97 & 0x80u) != 0 )
            *v98++ = v104;
          --v100;
        }
        while ( v100 );
      }
      LOBYTE(v97) = v101 + v97;
      if ( (v97 & 0x80u) != 0 )
      {
        v101 = v97;
        goto LABEL_179;
      }
    }
  }
  if ( !(word_E36D4 & 1) )
  {
    if ( !(word_E36D4 & 2) )
      return;
    v117 = -a3;
    if ( (unsigned __int8)a1 <= v117 )
      return;
    v118 = (_BYTE *)(dword_18062C * (HIBYTE(a1) + a2) + v6);
    BYTE1(v117) = HIBYTE(a1);
    v119 = v118;
    v139 = v117;
    v120 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v121 = *a4++;
          if ( v121 < 0 )
            break;
          if ( v121 )
          {
            LOBYTE(v120) = v121;
            do
            {
              v122 = *a4++;
              LOBYTE(v117) = v117 - 1;
              if ( (v117 & 0x80u) != 0 )
                *v118++ = v122;
              --v120;
            }
            while ( v120 );
          }
          else
          {
            v119 -= dword_18062C;
            v118 = v119;
            LOWORD(v117) = __PAIR__(BYTE1(v117), v139) - 256;
            if ( !BYTE1(v117) )
              return;
          }
        }
        if ( (char)v117 > 0 )
          break;
LABEL_225:
        v118 -= v121;
        v123 = *a4++;
        LOBYTE(v120) = v123;
        do
        {
          v124 = *a4++;
          LOBYTE(v117) = v117 - 1;
          if ( (v117 & 0x80u) != 0 )
            *v118++ = v124;
          --v120;
        }
        while ( v120 );
      }
      LOBYTE(v117) = v121 + v117;
      if ( (v117 & 0x80u) != 0 )
      {
        v121 = v117;
        goto LABEL_225;
      }
    }
  }
  if ( word_E36D4 & 2 )
  {
    v105 = (_BYTE *)(dword_18062C * (HIBYTE(a1) + a2) + (unsigned __int8)a1 + a3 + v6);
    v106 = 0;
    v107 = (unsigned __int8)a1 + a3 + 1;
    if ( v107 >= 0 )
    {
      LOBYTE(a1) = v107;
      v137 = v107;
      v108 = v105;
      v109 = -1;
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            LOBYTE(v109) = *a4++;
            if ( (v109 & 0x80u) == 0 )
              break;
            v105 += v109;
            LOBYTE(a1) = v109 + a1;
          }
          if ( !(_BYTE)v109 )
            break;
          LOBYTE(v106) = v109;
          do
          {
            v110 = *a4++;
            LOBYTE(a1) = a1 - 1;
            if ( (a1 & 0x80u) == 0 )
              *v105 = v110;
            --v105;
            --v106;
          }
          while ( v106 );
        }
        v108 -= dword_18062C;
        v105 = v108;
        a1 = __PAIR__(HIBYTE(a1), v137) - 256;
      }
      while ( HIBYTE(a1) );
    }
  }
  else
  {
    v111 = (_BYTE *)(dword_18062C * a2 + (unsigned __int8)a1 + a3 + v6);
    v112 = 0;
    v113 = (unsigned __int8)a1 + a3 + 1;
    if ( v113 >= 0 )
    {
      LOBYTE(a1) = v113;
      v138 = v113;
      v114 = v111;
      v115 = -1;
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            LOBYTE(v115) = *a4++;
            if ( (v115 & 0x80u) == 0 )
              break;
            v111 += v115;
            LOBYTE(a1) = v115 + a1;
          }
          if ( !(_BYTE)v115 )
            break;
          LOBYTE(v112) = v115;
          do
          {
            v116 = *a4++;
            LOBYTE(a1) = a1 - 1;
            if ( (a1 & 0x80u) == 0 )
              *v111 = v116;
            --v111;
            --v112;
          }
          while ( v112 );
        }
        v114 += dword_18062C;
        v111 = v114;
        a1 = __PAIR__(HIBYTE(a1), v138) - 256;
      }
      while ( HIBYTE(a1) );
    }
  }
}
// E36D4: using guessed type __int16 word_E36D4;
// E3890: using guessed type int dword_E3890;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180634: using guessed type int dword_180634;
// 18063C: using guessed type int dword_18063C;
// 180644: using guessed type int dword_180644;
// 180648: using guessed type int dword_180648;
// 180650: using guessed type int dword_180650;
// 180660: using guessed type __int16 word_180660;

//----- (00090164) --------------------------------------------------------
void __cdecl sub_90164(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, unsigned __int16 a5)
{
  _BYTE *v5; // edi
  __int16 v6; // dx
  int v7; // ebx
  int v8; // esi
  int v9; // ecx
  int v10; // [esp+0h] [ebp-4h]
  unsigned __int16 v11; // [esp+14h] [ebp+10h]

  v5 = (_BYTE *)(320 * ((unsigned int)a2 >> 1) + dword_180628 + ((unsigned int)a1 >> 1));
  v6 = a4 >> 1;
  v11 = a3 >> 1;
  v10 = (unsigned __int16)(320 - v11);
  if ( word_E36D4 & 4 )
  {
    v7 = a5;
    v8 = dword_E3890;
    do
    {
      v9 = v11;
      do
      {
        BYTE1(v7) = *v5;
        *v5++ = *(_BYTE *)(v7 + v8);
        --v9;
      }
      while ( v9 );
      v5 += v10;
      --v6;
    }
    while ( v6 );
  }
  else
  {
    do
    {
      memset(v5, a5, v11);
      v5 += v10 + v11;
      --v6;
    }
    while ( v6 );
  }
}
// E36D4: using guessed type __int16 word_E36D4;
// E3890: using guessed type int dword_E3890;
// 180628: using guessed type int dword_180628;

//----- (000901E4) --------------------------------------------------------
void __cdecl sub_901E4(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, unsigned __int16 a5)
{
  _BYTE *v5; // edi
  __int16 v6; // dx
  int v7; // ebx
  int v8; // esi
  int v9; // ecx
  int v10; // [esp+0h] [ebp-4h]

  v5 = (_BYTE *)(640 * a2 + dword_180628 + a1);
  v6 = a4;
  v10 = (unsigned __int16)(640 - a3);
  if ( word_E36D4 & 4 )
  {
    v7 = a5;
    v8 = dword_E3890;
    do
    {
      v9 = a3;
      do
      {
        BYTE1(v7) = *v5;
        *v5++ = *(_BYTE *)(v7 + v8);
        --v9;
      }
      while ( v9 );
      v5 += v10;
      --v6;
    }
    while ( v6 );
  }
  else
  {
    do
    {
      memset(v5, a5, a3);
      v5 += v10 + a3;
      --v6;
    }
    while ( v6 );
  }
}
// E36D4: using guessed type __int16 word_E36D4;
// E3890: using guessed type int dword_E3890;
// 180628: using guessed type int dword_180628;

//----- (0009025C) --------------------------------------------------------
int __cdecl sub_9025C(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6)
{
  __int16 v6; // bx
  __int16 v7; // cx
  __int16 v8; // dx
  _BYTE *v10; // edi
  int v11; // eax
  unsigned int v12; // ecx
  int v13; // ecx
  int v14; // esi
  int v15; // esi
  int v16; // [esp+4h] [ebp-4h]

  v6 = 2 * dword_180634;
  v7 = 2 * dword_180650;
  v8 = 2 * dword_180630;
  if ( a1 < (signed __int16)(2 * dword_18063C) )
    a1 = 2 * dword_18063C;
  if ( a3 < (signed __int16)(2 * dword_18063C) )
    return v16;
  if ( a1 >= v6 )
    return v16;
  if ( a3 >= v6 )
    a3 = 2 * dword_180634;
  if ( a2 < v7 )
    a2 = 2 * dword_180650;
  if ( a4 < v7 )
    return v16;
  if ( a2 >= v8 )
    return v16;
  if ( a4 >= v8 )
    a4 = 2 * dword_180630;
  v10 = (_BYTE *)(320 * ((unsigned int)(unsigned __int16)a2 >> 1)
                + dword_180628
                + ((unsigned int)(unsigned __int16)a1 >> 1));
  v11 = a5;
  v12 = (unsigned __int16)a3;
  if ( a3 == a1 )
  {
    v13 = (unsigned __int16)a4;
    LOWORD(v13) = (unsigned __int16)(a4 - a2) >> 1;
    if ( a6 & 4 )
    {
      v14 = dword_E3890;
      do
      {
        BYTE1(v11) = *v10;
        *v10 = *(_BYTE *)(v11 + v14);
        v10 += 320;
        --v13;
      }
      while ( v13 );
    }
    else
    {
      do
      {
        *v10 = a5;
        v10 += 320;
        --v13;
      }
      while ( v13 );
    }
  }
  else
  {
    LOWORD(v12) = (unsigned __int16)(a3 - a1) >> 1;
    if ( a6 & 4 )
    {
      v15 = dword_E3890;
      do
      {
        BYTE1(v11) = *v10;
        *v10++ = *(_BYTE *)(v11 + v15);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      memset(v10, a5, v12);
    }
  }
  return v16;
}
// E3890: using guessed type int dword_E3890;
// 180628: using guessed type int dword_180628;
// 180630: using guessed type int dword_180630;
// 180634: using guessed type int dword_180634;
// 18063C: using guessed type int dword_18063C;
// 180650: using guessed type int dword_180650;

//----- (00090374) --------------------------------------------------------
int __cdecl sub_90374(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6)
{
  _BYTE *v7; // edi
  int v8; // eax
  unsigned int v9; // ecx
  int v10; // ecx
  int v11; // esi
  int v12; // esi
  int v13; // [esp+4h] [ebp-4h]

  if ( a1 < (signed __int16)dword_18063C )
    a1 = dword_18063C;
  if ( a3 < (signed __int16)dword_18063C )
    return v13;
  if ( a1 >= (signed __int16)dword_180634 )
    return v13;
  if ( a3 >= (signed __int16)dword_180634 )
    a3 = dword_180634;
  if ( a2 < (signed __int16)dword_180650 )
    a2 = dword_180650;
  if ( a4 < (signed __int16)dword_180650 )
    return v13;
  if ( a2 >= (signed __int16)dword_180630 )
    return v13;
  if ( a4 >= (signed __int16)dword_180630 )
    a4 = dword_180630;
  v7 = (_BYTE *)(640 * (unsigned __int16)a2 + dword_180628 + (unsigned __int16)a1);
  v8 = a5;
  v9 = (unsigned __int16)a3;
  LOWORD(v9) = a3 - a1;
  if ( a3 == a1 )
  {
    v10 = (unsigned __int16)a4;
    LOWORD(v10) = a4 - a2;
    if ( a6 & 4 )
    {
      v11 = dword_E3890;
      do
      {
        BYTE1(v8) = *v7;
        *v7 = *(_BYTE *)(v8 + v11);
        v7 += 640;
        --v10;
      }
      while ( v10 );
    }
    else
    {
      do
      {
        *v7 = a5;
        v7 += 640;
        --v10;
      }
      while ( v10 );
    }
  }
  else if ( a6 & 4 )
  {
    v12 = dword_E3890;
    do
    {
      BYTE1(v8) = *v7;
      *v7++ = *(_BYTE *)(v8 + v12);
      --v9;
    }
    while ( v9 );
  }
  else
  {
    memset(v7, a5, v9);
  }
  return v13;
}
// E3890: using guessed type int dword_E3890;
// 180628: using guessed type int dword_180628;
// 180630: using guessed type int dword_180630;
// 180634: using guessed type int dword_180634;
// 18063C: using guessed type int dword_18063C;
// 180650: using guessed type int dword_180650;

//----- (00090478) --------------------------------------------------------
void sub_90478()
{
  if ( !byte_E3766 )
    sub_8CACD();
  qmemcpy(&loc_A0000, (const void *)dword_180628, 0xFA00u);
  if ( !byte_E3766 )
    sub_8CB1F();
}
// E3766: using guessed type char byte_E3766;
// 180628: using guessed type int dword_180628;

//----- (000904C0) --------------------------------------------------------
char __cdecl sub_904C0(float a1)
{
  double v1; // st7
  int v2; // eax
  char result; // al
  int v4; // edx
  signed int v5; // ecx

  if ( a1 < dbl_D220C )
    a1 = 0.0099999998;
  v1 = a1;
  do
  {
    IF_DPOW(v1, 1.0 / v1);
    v1 = v1 * dbl_D2218 + dbl_D2220;
    result = (signed int)_CHP(v2);
    byte_181504[v4] = result;
  }
  while ( v5 < 64 );
  return result;
}
// 9B4F6: using guessed type double __fastcall _CHP(_DWORD);
// A097C: using guessed type double __usercall IF_DPOW@<st0>(double@<st0>, double@<st1>);
// D220C: using guessed type double dbl_D220C;
// D2218: using guessed type double dbl_D2218;
// D2220: using guessed type double dbl_D2220;

//----- (00090530) --------------------------------------------------------
unsigned __int8 __cdecl sub_90530(int a1, int a2, float a3)
{
  int v3; // esi
  unsigned __int8 result; // al
  int v5; // ecx
  _DWORD *v6; // ebx
  int v7; // eax

  v3 = a2;
  sub_904C0(a3);
  if ( a2 > 256 )
    v3 = 256;
  result = 0;
  __outbyte(0x3C8u, 0);
  v5 = 0;
  if ( v3 > 0 )
  {
    v6 = (_DWORD *)a1;
    do
    {
      __outbyte(0x3C9u, byte_181504[*(unsigned __int8 *)v6]);
      __outbyte(0x3C9u, byte_181504[(*v6 >> 8) & 0xFF]);
      v7 = (*v6 >> 16) & 0xFF;
      ++v6;
      result = byte_181504[v7];
      ++v5;
      __outbyte(0x3C9u, result);
    }
    while ( v5 < v3 );
  }
  return result;
}

//----- (000905EC) --------------------------------------------------------
int __cdecl sub_905EC(char a1)
{
  char v2; // [esp+0h] [ebp-1Ch]
  char v3; // [esp+1h] [ebp-1Bh]

  word_E3908 = MEMORY[0x449];
  v2 = a1;
  v3 = 0;
  return int386(16, &v2, &v2);
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E3908: using guessed type __int16 word_E3908;

//----- (00090668) --------------------------------------------------------
signed int __cdecl sub_90668(int a1)
{
  int v1; // edx
  signed int result; // eax
  int v3; // edx
  int v4; // ebx
  int v5; // ebx

  v1 = a1;
  if ( a1 )
  {
    result = 0;
    v3 = 0;
    v4 = 0;
    do
    {
      ++result;
      word_1811E4[v3] = v4;
      ++v3;
      v4 += 160;
    }
    while ( result < 400 );
  }
  else
  {
    result = 0;
    v5 = 80 * a1;
    do
    {
      ++result;
      *(__int16 *)((char *)word_1811E4 + v1) = v5;
      v1 += 2;
      v5 += 80;
    }
    while ( result < 400 );
  }
  return result;
}
// 1811E4: using guessed type __int16 word_1811E4[];

//----- (000906B4) --------------------------------------------------------
int sub_906B4()
{
  char *v0; // edx
  signed int v1; // ebx
  char v2; // cl
  signed int v3; // ebx
  int v4; // ecx
  int v5; // eax
  unsigned __int8 v6; // al
  int result; // eax
  char v8; // [esp+0h] [ebp-30h]
  char v9; // [esp+1h] [ebp-2Fh]
  int v10; // [esp+1Ch] [ebp-14h]

  v8 = 19;
  v9 = 0;
  word_E3908 = MEMORY[0x449];
  int386(16, &v8, &v8);
  sub_A0BB0((int *)&unk_E3894, 25);
  __outword(0x3C4u, 0x604u);
  __outword(0x3D4u, 0x14u);
  __outword(0x3D4u, 0xE317u);
  __outword(0x3CEu, 0xFF08u);
  __outword(0x3C4u, 0xF02u);
  v0 = (char *)&loc_A0000;
  do
  {
    *(_DWORD *)v0 = 0;
    v0 += 4;
  }
  while ( v0 != (char *)&loc_AFFFE + 2 );
  v1 = 0;
  do
  {
    v2 = v1++ & 3;
    byte_1810A3[v1] = 1 << v2;
  }
  while ( v1 < 320 );
  sub_90668(0);
  v3 = 0;
  v4 = 0;
  do
  {
    v10 = 3;
    ++v4;
    v5 = 63 * (v3 & 7) / 7 | (63 * (v3 >> 6) / 3 << 16) | (63 * ((v3 >> 3) & 7) / 7 << 8);
    ++v3;
    dword_180CA0[v4] = v5;
  }
  while ( v3 < 256 );
  sub_90530((int)&unk_180CA4, 256, 1.2);
  v6 = __inbyte(0x3DAu);
  __outbyte(0x3C0u, 0x11u);
  __outbyte(0x3C0u, 0);
  result = 0;
  LOBYTE(result) = __inbyte(0x3DAu);
  LOBYTE(result) = 32;
  __outbyte(0x3C0u, 0x20u);
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E3908: using guessed type __int16 word_E3908;
// 180CA0: using guessed type int dword_180CA0[];

//----- (00090810) --------------------------------------------------------
int sub_90810()
{
  int result; // eax

  if ( word_E3908 )
  {
    result = sub_905EC(word_E3908);
    word_E3908 = 0;
  }
  return result;
}
// E3908: using guessed type __int16 word_E3908;

//----- (00090B27) --------------------------------------------------------
__int16 __cdecl sub_90B27(char *a1, unsigned __int8 a2, char a3)
{
  char *v3; // eax
  int v4; // edx
  char *v5; // eax
  int v6; // edx
  char v8[768]; // [esp+0h] [ebp-30Ch]
  int i; // [esp+300h] [ebp-Ch]
  unsigned __int8 *v10; // [esp+308h] [ebp-4h]

  if ( a3 )
  {
    if ( byte_E390C )
    {
      if ( a2 == ++word_181B44 )
        byte_E390C = 0;
    }
    else
    {
      word_181B44 = 0;
      byte_E390C = 1;
      sub_A0D2C(byte_181544);
      if ( !a1 )
        memset(&unk_181844, 0, 768);
    }
    if ( !a1 )
      a1 = (char *)&unk_181844;
    for ( i = 0; (signed __int16)i < 768; ++i )
    {
      v5 = &a1[(signed __int16)i];
      LOWORD(v5) = (unsigned __int8)*v5;
      v6 = (signed __int16)i;
      LOWORD(v6) = byte_181544[(signed __int16)i];
      v10 = (unsigned __int8 *)&v5[-v6];
      v8[(signed __int16)i] = byte_181544[(signed __int16)i]
                            + (unsigned int)((unk_181B42 >> 16)
                                           * (signed int)(signed __int16)((unsigned __int8)v5 - (unsigned __int8)v6)
                                           / a2);
    }
    sub_9A0FC();
    sub_41A90((unsigned __int8 *)v8);
  }
  else
  {
    sub_A0D2C(byte_181544);
    if ( !a1 )
    {
      a1 = (char *)&unk_181844;
      memset(&unk_181844, 0, 768);
    }
    for ( word_181B44 = 0; a2 >= word_181B44; ++word_181B44 )
    {
      for ( i = 0; (signed __int16)i < 768; ++i )
      {
        v3 = &a1[(signed __int16)i];
        LOWORD(v3) = (unsigned __int8)*v3;
        v4 = (signed __int16)i;
        LOWORD(v4) = byte_181544[(signed __int16)i];
        v10 = (unsigned __int8 *)&v3[-v4];
        v8[(signed __int16)i] = byte_181544[(signed __int16)i]
                              + (unsigned int)((unk_181B42 >> 16)
                                             * (signed int)(signed __int16)((unsigned __int8)v3 - (unsigned __int8)v4)
                                             / a2);
      }
      sub_9A0FC();
      sub_41A90((unsigned __int8 *)v8);
    }
    byte_E390C = 0;
  }
  return word_181B44;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// E390C: using guessed type char byte_E390C;
// 181B44: using guessed type __int16 word_181B44;
// 90B27: using guessed type char var_30C[768];

//----- (00090D27) --------------------------------------------------------
void sub_90D27()
{
  byte_E390C = 0;
}
// E390C: using guessed type char byte_E390C;

//----- (00090D3F) --------------------------------------------------------
int __cdecl sub_90D3F(int a1)
{
  int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( !*(_DWORD *)(a1 + 28) )
      break;
    sub_9A2F5(a1);
    a1 += 44;
  }
  return result;
}

//----- (00090D6E) --------------------------------------------------------
int __cdecl sub_90D6E(unsigned __int8 *a1)
{
  unsigned __int8 v2; // [esp+0h] [ebp-38h]
  int v3; // [esp+1Ch] [ebp-1Ch]

  v3 = 3840;
  int386(16, &v3, &v2);
  if ( !word_180662 )
    word_180662 = v2;
  v3 = 19;
  dword_18062C = 320;
  dword_180624 = 200;
  int386(16, &v3, &v2);
  sub_41A90(a1);
  sub_8D12F();
  return sub_A0D50(0, 0, 320, 200);
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 180624: using guessed type int dword_180624;
// 18062C: using guessed type int dword_18062C;
// 180662: using guessed type __int16 word_180662;

//----- (00090E07) --------------------------------------------------------
int __cdecl sub_90E07(unsigned __int8 *a1)
{
  unsigned __int8 v2; // [esp+0h] [ebp-38h]
  int v3; // [esp+1Ch] [ebp-1Ch]

  v3 = 3840;
  int386(16, &v3, &v2);
  if ( !word_180662 )
    word_180662 = v2;
  dword_18062C = 640;
  dword_180624 = 480;
  sub_994BA(257);
  sub_41A90(a1);
  sub_8D12F();
  return sub_A0D50(0, 0, 640, 480);
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 180624: using guessed type int dword_180624;
// 18062C: using guessed type int dword_18062C;
// 180662: using guessed type __int16 word_180662;

//----- (00090EA0) --------------------------------------------------------
int __cdecl sub_90EA0(int a1, char a2)
{
  int result; // eax

  dword_181BE4 = a1;
  result = sprintf(aSound_2, (const char *)&unk_D2228, a2);
  byte_E39A0 = 1;
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// E39A0: using guessed type char byte_E39A0;
// 181BE4: using guessed type int dword_181BE4;

//----- (00090EE0) --------------------------------------------------------
int sub_90EE0()
{
  char v1; // [esp+0h] [ebp-8h]

  dos_setdrive(dword_181BE4, &v1);
  return chdir(aSound_2);
}
// 8C1CA: using guessed type _DWORD __cdecl dos_setdrive(_DWORD, _DWORD);
// A0DA5: using guessed type _DWORD __cdecl chdir(_DWORD);
// 181BE4: using guessed type int dword_181BE4;

//----- (00090F20) --------------------------------------------------------
int sub_90F20()
{
  char v1; // [esp+0h] [ebp-4h]

  dos_setdrive(dword_181BE0, &v1);
  return chdir(&unk_181B50);
}
// 8C1CA: using guessed type _DWORD __cdecl dos_setdrive(_DWORD, _DWORD);
// A0DA5: using guessed type _DWORD __cdecl chdir(_DWORD);
// 181BE0: using guessed type int dword_181BE0;

//----- (00090F60) --------------------------------------------------------
int sub_90F60()
{
  int v0; // ST0C_4
  int result; // eax

  v0 = getcwd(0, 0);
  sprintf(&unk_181B50, (const char *)&unk_D2228, v0 + 2);
  free(v0);
  result = dos_getdrive(&dword_181BE0);
  if ( !byte_E39A0 )
  {
    result = dword_181BE0;
    dword_181BE4 = dword_181BE0;
  }
  return result;
}
// 8C1B2: using guessed type _DWORD __cdecl dos_getdrive(_DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// A0DC7: using guessed type _DWORD __cdecl getcwd(_DWORD, _DWORD);
// A0E6B: using guessed type _DWORD __cdecl free(_DWORD);
// E39A0: using guessed type char byte_E39A0;
// 181BE0: using guessed type int dword_181BE0;
// 181BE4: using guessed type int dword_181BE4;

//----- (00090FD0) --------------------------------------------------------
__int16 __fastcall sub_90FD0(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // eax

  sub_8D290(a1, a2, a3);
  sub_8D970(v3, v4, a3);
  v5 = stricmp(&unk_180AB0, aSb16Dig);
  if ( !v5 )
    LOWORD(v5) = sub_91010();
  return v5;
}
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);

//----- (00091010) --------------------------------------------------------
__int16 sub_91010()
{
  __int16 result; // ax
  __int16 v1; // [esp+0h] [ebp-4h]

  result = word_180B30;
  v1 = word_180B30;
  if ( word_180B30 == 544 )
  {
    outp(word_180B30 + 4, 48);
    word_E39A4 = inp(v1 + 5) >> 3;
    outp(v1 + 4, 49);
    word_E39A6 = inp(v1 + 5) >> 3;
    outp(v1 + 4, 50);
    word_E39AC = inp(v1 + 5);
    outp(v1 + 5, 8 * word_E39A4 - 32);
    outp(v1 + 4, 51);
    word_E39AE = inp(v1 + 5);
    outp(v1 + 5, 8 * word_E39A6 - 32);
    outp(v1 + 4, 68);
    word_E39B0 = inp(v1 + 5);
    outp(v1 + 5, 96);
    outp(v1 + 4, 69);
    word_E39B2 = inp(v1 + 5);
    outp(v1 + 5, 96);
    outp(v1 + 4, 70);
    word_E39B4 = inp(v1 + 5);
    outp(v1 + 5, 120);
    outp(v1 + 4, 71);
    word_E39B6 = inp(v1 + 5);
    outp(v1 + 5, 120);
    if ( !stricmp(&unk_180BE0, aSbawe32Mdi_0) )
    {
      outp(v1 + 4, 52);
      word_E39A8 = inp(v1 + 5);
      outp(v1 + 5, 8 * word_E39A4 - 24);
      outp(v1 + 4, 53);
      word_E39AA = inp(v1 + 5);
      result = outp(v1 + 5, 8 * word_E39A6 - 24);
    }
    else if ( !stricmp(&unk_180BE0, aMpu401Mdi_0) )
    {
      outp(v1 + 4, 52);
      word_E39A8 = inp(v1 + 5);
      outp(v1 + 5, 8 * word_E39A4 - 24);
      outp(v1 + 4, 53);
      word_E39AA = inp(v1 + 5);
      result = outp(v1 + 5, 8 * word_E39A6 - 24);
    }
    else
    {
      outp(v1 + 4, 52);
      word_E39A8 = inp(v1 + 5);
      outp(v1 + 5, 8 * word_E39A4 - 8);
      outp(v1 + 4, 53);
      word_E39AA = inp(v1 + 5);
      result = outp(v1 + 5, 8 * word_E39A6 - 8);
    }
    byte_E39B8 = 1;
  }
  return result;
}
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);
// E39A4: using guessed type __int16 word_E39A4;
// E39A6: using guessed type __int16 word_E39A6;
// E39A8: using guessed type __int16 word_E39A8;
// E39AA: using guessed type __int16 word_E39AA;
// E39AC: using guessed type __int16 word_E39AC;
// E39AE: using guessed type __int16 word_E39AE;
// E39B0: using guessed type __int16 word_E39B0;
// E39B2: using guessed type __int16 word_E39B2;
// E39B4: using guessed type __int16 word_E39B4;
// E39B6: using guessed type __int16 word_E39B6;
// E39B8: using guessed type char byte_E39B8;
// 180B30: using guessed type __int16 word_180B30;

//----- (00091420) --------------------------------------------------------
int sub_91420()
{
  __int16 v0; // ST08_2

  v0 = word_180B30;
  outp(word_180B30 + 4, 50);
  outp(549, word_E39AC);
  outp(v0 + 4, 51);
  outp(v0 + 5, word_E39AE);
  outp(v0 + 4, 52);
  outp(v0 + 5, word_E39A8);
  outp(v0 + 4, 53);
  outp(v0 + 5, word_E39AA);
  outp(v0 + 4, 68);
  outp(v0 + 5, word_E39B0);
  outp(v0 + 4, 69);
  outp(v0 + 5, word_E39B2);
  outp(v0 + 4, 70);
  outp(v0 + 5, word_E39B4);
  outp(v0 + 4, 71);
  return outp(v0 + 5, word_E39B6);
}
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// E39A8: using guessed type __int16 word_E39A8;
// E39AA: using guessed type __int16 word_E39AA;
// E39AC: using guessed type __int16 word_E39AC;
// E39AE: using guessed type __int16 word_E39AE;
// E39B0: using guessed type __int16 word_E39B0;
// E39B2: using guessed type __int16 word_E39B2;
// E39B4: using guessed type __int16 word_E39B4;
// E39B6: using guessed type __int16 word_E39B6;
// 180B30: using guessed type __int16 word_180B30;

//----- (000915A0) --------------------------------------------------------
bool sub_915A0()
{
  bool result; // eax

  if ( !dword_E39BC )
  {
    sub_9D590((unsigned int)sub_915A0, (unsigned int)sub_986A0);
    sub_9D710((unsigned int)&dword_181BF4, 4);
    sub_9D710((unsigned int)&dword_181BF8, 4);
    sub_9D710((unsigned int)&dword_181BF0, 4);
    sub_9D710((unsigned int)&dword_181BFC, 4);
    sub_9D710((unsigned int)&dword_181C0C, 4);
    sub_9D710((unsigned int)&dword_181C08, 4);
    sub_9D710((unsigned int)&dword_181C10, 4);
    result = sub_9D710((unsigned int)&dword_181C00, 4);
    dword_E39BC = 1;
  }
  return result;
}
// E39BC: using guessed type int dword_E39BC;
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181BFC: using guessed type int dword_181BFC;
// 181C00: using guessed type int dword_181C00;
// 181C08: using guessed type int dword_181C08;
// 181C0C: using guessed type int dword_181C0C;
// 181C10: using guessed type int dword_181C10;

//----- (000916F0) --------------------------------------------------------
signed int sub_916F0()
{
  unsigned int i; // [esp+4h] [ebp-14h]
  unsigned int j; // [esp+4h] [ebp-14h]
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  sub_A0EEC();
  v6 = dword_181BFC;
  v5 = dword_181C0C;
  v4 = dword_181C08;
  v3 = dword_181C10;
  sub_A0EF9();
  if ( dword_181C04 == 1 )
  {
    fprintf(dword_181BF0, a02u02u02u02u, v6, v5, v4, v3);
  }
  else
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
  }
  for ( j = 1; j < dword_181C04; ++j )
    fprintf(dword_181BF0, (const char *)&unk_D2270);
  return 1;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BFC: using guessed type int dword_181BFC;
// 181C04: using guessed type int dword_181C04;
// 181C08: using guessed type int dword_181C08;
// 181C0C: using guessed type int dword_181C0C;
// 181C10: using guessed type int dword_181C10;

//----- (000919C0) --------------------------------------------------------
signed int sub_919C0()
{
  signed int result; // eax
  bool v1; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v1 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v1 )
    fprintf(dword_181BF0, aAilShutdown);
  result = sub_9ED70();
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) )
  {
    result = sub_A16A2();
    if ( !result )
      result = fclose(dword_181BF0);
  }
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// A1E05: using guessed type _DWORD __cdecl fclose(_DWORD);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00091A80) --------------------------------------------------------
int __cdecl sub_91A80(int a1, int a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v5; // [esp+4h] [ebp-Ch]
  int v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v5 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v5 )
    fprintf(dword_181BF0, aAilSetPreferen, a1, a2);
  v6 = sub_9E6E0(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResultD, v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00091BD0) --------------------------------------------------------
void sub_91BD0()
{
  sub_A0EEC();
}

//----- (00091BF0) --------------------------------------------------------
void sub_91BF0()
{
  sub_A0EF9();
}

//----- (00091C10) --------------------------------------------------------
int __usercall sub_91C10@<eax>(__int16 a1@<dx>, int a2@<ecx>, int a3@<ebx>, int a4)
{
  int v4; // eax
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v8; // [esp+4h] [ebp-Ch]
  int v9; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v8 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && (v4 = sub_A16A2(), !v4 && sub_916F0());
  if ( v8 )
    fprintf(dword_181BF0, aAilGetRealVect, a4);
  v9 = sub_A121D(a4, a1, a3, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResult0xX, v9);
  }
  --dword_181C04;
  return v9;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00091D50) --------------------------------------------------------
signed int __cdecl sub_91D50(int a1, int a2)
{
  signed int result; // eax
  bool v3; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v3 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v3 )
    fprintf(dword_181BF0, aAilSetRealVect, a1, a2);
  result = sub_A1249();
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00091E90) --------------------------------------------------------
signed int __cdecl sub_91E90(int a1)
{
  signed int result; // eax
  bool v2; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v2 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v2 )
    fprintf(dword_181BF0, aAilRestoreUse1, a1);
  result = sub_A14DB(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00091F20) --------------------------------------------------------
unsigned int sub_91F20()
{
  return sub_A1520();
}

//----- (00091F50) --------------------------------------------------------
void __cdecl sub_91F50(unsigned int a1)
{
  sub_A1524(a1);
}

//----- (00091F70) --------------------------------------------------------
int __cdecl sub_91F70(int a1, int a2, _WORD *a3, _WORD *a4)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v7; // [esp+4h] [ebp-Ch]
  int v8; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v7 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v7 )
    fprintf(dword_181BF0, aAilCallDriver0, a1, a2, a3, a4);
  v8 = sub_A158B(a1, a2, a3, a4);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResultD, v8);
  }
  --dword_181C04;
  return v8;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000920D0) --------------------------------------------------------
unsigned __int8 __cdecl sub_920D0(int a1)
{
  unsigned __int8 result; // al
  bool v2; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v2 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v2 )
    fprintf(dword_181BF0, aAilDelayD, a1);
  result = sub_A1665(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092160) --------------------------------------------------------
int sub_92160()
{
  return sub_A16A2();
}

//----- (00092190) --------------------------------------------------------
int __cdecl sub_92190(int a1, int a2)
{
  unsigned int i1; // [esp+0h] [ebp-28h]
  unsigned int i2; // [esp+0h] [ebp-28h]
  unsigned int mm; // [esp+4h] [ebp-24h]
  unsigned int nn; // [esp+4h] [ebp-24h]
  unsigned int kk; // [esp+8h] [ebp-20h]
  unsigned int ll; // [esp+8h] [ebp-20h]
  unsigned int ii; // [esp+Ch] [ebp-1Ch]
  unsigned int jj; // [esp+Ch] [ebp-1Ch]
  unsigned int m; // [esp+10h] [ebp-18h]
  unsigned int n; // [esp+10h] [ebp-18h]
  unsigned int k; // [esp+14h] [ebp-14h]
  unsigned int l; // [esp+14h] [ebp-14h]
  unsigned int i; // [esp+18h] [ebp-10h]
  unsigned int j; // [esp+18h] [ebp-10h]
  bool v17; // [esp+1Ch] [ebp-Ch]
  int v18; // [esp+24h] [ebp-4h]

  ++dword_181C04;
  v17 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v17 )
    fprintf(dword_181BF0, aAilApiReadIni0, a1, a2);
  v18 = sub_9E3A0((char *)a1, a2);
  if ( v18 )
  {
    if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
    {
      for ( i = 0; i < 0xE; ++i )
        fprintf(dword_181BF0, (const char *)&unk_D226C);
      for ( j = 1; j < dword_181C04; ++j )
        fprintf(dword_181BF0, (const char *)&unk_D2270);
      fprintf(dword_181BF0, aDriverS, a1 + 128);
      for ( k = 0; k < 0xE; ++k )
        fprintf(dword_181BF0, (const char *)&unk_D226C);
      for ( l = 1; l < dword_181C04; ++l )
        fprintf(dword_181BF0, (const char *)&unk_D2270);
      fprintf(dword_181BF0, aDeviceS, a1);
      for ( m = 0; m < 0xE; ++m )
        fprintf(dword_181BF0, (const char *)&unk_D226C);
      for ( n = 1; n < dword_181C04; ++n )
        fprintf(dword_181BF0, (const char *)&unk_D2270);
      fprintf(dword_181BF0, aIoX, *(signed __int16 *)(a1 + 256));
      for ( ii = 0; ii < 0xE; ++ii )
        fprintf(dword_181BF0, (const char *)&unk_D226C);
      for ( jj = 1; jj < dword_181C04; ++jj )
        fprintf(dword_181BF0, (const char *)&unk_D2270);
      fprintf(dword_181BF0, aIrqD, *(signed __int16 *)(a1 + 258));
      for ( kk = 0; kk < 0xE; ++kk )
        fprintf(dword_181BF0, (const char *)&unk_D226C);
      for ( ll = 1; ll < dword_181C04; ++ll )
        fprintf(dword_181BF0, (const char *)&unk_D2270);
      fprintf(dword_181BF0, aDma8D, *(signed __int16 *)(a1 + 260));
      for ( mm = 0; mm < 0xE; ++mm )
        fprintf(dword_181BF0, (const char *)&unk_D226C);
      for ( nn = 1; nn < dword_181C04; ++nn )
        fprintf(dword_181BF0, (const char *)&unk_D2270);
      fprintf(dword_181BF0, aDma16D, *(signed __int16 *)(a1 + 262));
    }
  }
  else if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i1 = 0; i1 < 0xE; ++i1 )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( i2 = 1; i2 < dword_181C04; ++i2 )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResultU, 0);
  }
  --dword_181C04;
  return v18;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092600) --------------------------------------------------------
unsigned int __cdecl sub_92600(int a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v4; // [esp+4h] [ebp-Ch]
  unsigned int v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v4 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v4 )
    fprintf(dword_181BF0, aAilRegisterTim, a1);
  v5 = sub_A16AE(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResultU, v5);
  }
  --dword_181C04;
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092740) --------------------------------------------------------
signed __int32 __cdecl sub_92740(int a1, signed __int32 a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v5; // [esp+4h] [ebp-Ch]
  signed __int32 v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v5 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v5 )
    fprintf(dword_181BF0, aAilSetTimerUse, a1, a2);
  v6 = sub_A16F5(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResultU, v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092890) --------------------------------------------------------
void __cdecl sub_92890(int a1, int a2)
{
  bool v2; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v2 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v2 )
    fprintf(dword_181BF0, aAilSetTimerPer, a1, a2);
  sub_A1810(a1, a2);
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092930) --------------------------------------------------------
void __cdecl sub_92930(int a1, unsigned int a2)
{
  bool v2; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v2 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v2 )
    fprintf(dword_181BF0, aAilSetTimerFre, a1, a2);
  sub_A1840(a1, a2);
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092BA0) --------------------------------------------------------
void __cdecl sub_92BA0(int a1)
{
  bool v1; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v1 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v1 )
    fprintf(dword_181BF0, aAilStartTimerU, a1);
  sub_A1768(a1);
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092CB0) --------------------------------------------------------
void __cdecl sub_92CB0(int a1)
{
  bool v1; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v1 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v1 )
    fprintf(dword_181BF0, aAilStopTimerU, a1);
  sub_A17BC(a1);
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092DC0) --------------------------------------------------------
void __cdecl sub_92DC0(int a1)
{
  bool v1; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v1 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v1 )
    fprintf(dword_181BF0, aAilReleaseTime, a1);
  sub_A171D(a1);
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092E50) --------------------------------------------------------
void sub_92E50()
{
  bool v0; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v0 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v0 )
    fprintf(dword_181BF0, aAilReleaseAllT);
  sub_A1744();
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092ED0) --------------------------------------------------------
void *__cdecl sub_92ED0(int a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v4; // [esp+4h] [ebp-Ch]
  void *v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v4 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v4 )
    fprintf(dword_181BF0, aAilGetIoEnviro, a1);
  v5 = sub_9EB60(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResult0xX, v5);
  }
  --dword_181C04;
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093010) --------------------------------------------------------
_DWORD *__usercall sub_93010@<eax>(int a1@<ebx>, int a2, int a3)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v6; // [esp+4h] [ebp-Ch]
  _DWORD *v7; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v6 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v6 )
    fprintf(dword_181BF0, aAilInstallDriv, a2, a3);
  v7 = sub_9E720(a1, a2, a3);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResult0xX, v7);
  }
  --dword_181C04;
  return v7;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093160) --------------------------------------------------------
int __cdecl sub_93160(unsigned int a1)
{
  int result; // eax
  bool v2; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v2 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v2 )
    fprintf(dword_181BF0, aAilUninstallDr, a1);
  result = sub_9EA60(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000931F0) --------------------------------------------------------
int __usercall sub_931F0@<eax>(int a1@<ebx>, int **a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v5; // [esp+4h] [ebp-Ch]
  int v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v5 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v5 )
    fprintf(dword_181BF0, aAilInstallDigI, a2);
  v6 = sub_A3720(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResultD, v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093330) --------------------------------------------------------
int *__usercall sub_93330@<eax>(int a1@<ebx>, int a2, const void *a3)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v6; // [esp+4h] [ebp-Ch]
  int *v7; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v6 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v6 )
    fprintf(dword_181BF0, aAilInstallDigD, a2, a3);
  v7 = sub_A3600(a1, a2, a3);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResult0xX, v7);
  }
  --dword_181C04;
  return v7;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093480) --------------------------------------------------------
int __cdecl sub_93480(unsigned int *a1)
{
  int result; // eax
  bool v2; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v2 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v2 )
    fprintf(dword_181BF0, aAilUninstallDi, a1);
  result = sub_A37A0(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093510) --------------------------------------------------------
_DWORD *__cdecl sub_93510(int a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v4; // [esp+4h] [ebp-Ch]
  _DWORD *v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v4 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v4 )
    fprintf(dword_181BF0, aAilAllocateSam, a1);
  v5 = sub_A3820(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResult0xX, v5);
  }
  --dword_181C04;
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000937A0) --------------------------------------------------------
int __cdecl sub_937A0(int a1)
{
  int result; // eax
  bool v2; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v2 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v2 )
    fprintf(dword_181BF0, aAilReleaseSamp, a1);
  result = sub_A38C0(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093830) --------------------------------------------------------
int __cdecl sub_93830(_DWORD *a1)
{
  int result; // eax
  bool v2; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v2 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v2 )
    fprintf(dword_181BF0, aAilInitSample0, (char)a1);
  result = sub_A38E0(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000938C0) --------------------------------------------------------
signed int __cdecl sub_938C0(_DWORD *a1, int a2, int a3)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v6; // [esp+4h] [ebp-Ch]
  signed int v7; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v6 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v6 )
    fprintf(dword_181BF0, aAilSetSampleFi, a1, a2, a3);
  v7 = sub_A4B20(a1, a2, a3);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResultD, v7);
  }
  --dword_181C04;
  return v7;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093A10) --------------------------------------------------------
_DWORD *__cdecl sub_93A10(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax
  bool v4; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v4 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v4 )
    fprintf(dword_181BF0, aAilSetSampleAd, a1, a2, a3);
  result = sub_A3A30(a1, a2, a3);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093AB0) --------------------------------------------------------
int __cdecl sub_93AB0(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  bool v4; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v4 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v4 )
    fprintf(dword_181BF0, aAilSetSampleTy, a1, a2, a3);
  result = sub_A3A70(a1, a2, a3);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093B50) --------------------------------------------------------
int __cdecl sub_93B50(int *a1)
{
  int result; // eax
  bool v2; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v2 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v2 )
    fprintf(dword_181BF0, aAilStartSample, a1);
  result = sub_A3CB0(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093D00) --------------------------------------------------------
int __cdecl sub_93D00(int a1)
{
  int result; // eax
  bool v2; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v2 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v2 )
    fprintf(dword_181BF0, aAilEndSample0x, a1);
  result = sub_A3DA0(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093D90) --------------------------------------------------------
int __cdecl sub_93D90(int a1, int a2)
{
  int result; // eax
  bool v3; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v3 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v3 )
    fprintf(dword_181BF0, aAilSetSamplePl, a1, a2);
  result = sub_A3AF0(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093E30) --------------------------------------------------------
int __cdecl sub_93E30(_DWORD *a1, int a2)
{
  int result; // eax
  bool v3; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v3 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v3 )
    fprintf(dword_181BF0, aAilSetSampleVo, a1, a2);
  result = sub_A3B40(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093ED0) --------------------------------------------------------
int __cdecl sub_93ED0(_DWORD *a1, int a2)
{
  int result; // eax
  bool v3; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v3 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v3 )
    fprintf(dword_181BF0, aAilSetSamplePa, a1, a2);
  result = sub_A3BB0(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093F70) --------------------------------------------------------
int __cdecl sub_93F70(int a1, int a2)
{
  int result; // eax
  bool v3; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v3 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v3 )
    fprintf(dword_181BF0, aAilSetSampleLo, a1, a2);
  result = sub_A3C90(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00094010) --------------------------------------------------------
int __cdecl sub_94010(int a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v4; // [esp+4h] [ebp-Ch]
  int v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v4 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v4 )
    fprintf(dword_181BF0, aAilSampleStatu, a1);
  v5 = sub_A3A00(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResultU, v5);
  }
  --dword_181C04;
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00094650) --------------------------------------------------------
int __cdecl sub_94650(_DWORD *a1, int a2)
{
  int result; // eax
  bool v3; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v3 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v3 )
    fprintf(dword_181BF0, aAilSetDigitalM, a1, a2);
  result = sub_A3F70(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095140) --------------------------------------------------------
int __cdecl sub_95140(int a1, int a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v5; // [esp+4h] [ebp-Ch]
  int v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v5 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v5 )
    fprintf(dword_181BF0, aAilRegisterEos, a1, a2);
  v6 = sub_A3EB0(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResult0xX, v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000953E0) --------------------------------------------------------
int __cdecl sub_953E0(int a1, int a2, int a3)
{
  int result; // eax
  bool v4; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v4 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v4 )
    fprintf(dword_181BF0, aAilSetSampleUs, a1, a2, a3);
  result = sub_A3F00(a1, a2, a3);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095480) --------------------------------------------------------
int __cdecl sub_95480(int a1, int a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v5; // [esp+4h] [ebp-Ch]
  int v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v5 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v5 )
    fprintf(dword_181BF0, aAilSampleUserD, a1, a2);
  v6 = sub_A3F30(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResultD, v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095710) --------------------------------------------------------
int __usercall sub_95710@<eax>(int a1@<ebx>, int **a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v5; // [esp+4h] [ebp-Ch]
  int v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v5 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v5 )
    fprintf(dword_181BF0, aAilInstallMdiI, a2);
  v6 = sub_A78F0(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResultD, v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095850) --------------------------------------------------------
int *__usercall sub_95850@<eax>(int a1@<ebx>, int a2, const void *a3)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v6; // [esp+4h] [ebp-Ch]
  int *v7; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v6 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v6 )
    fprintf(dword_181BF0, aAilInstallMdiD, a2, a3);
  v7 = sub_A77D0(a1, a2, a3);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResult0xX, v7);
  }
  --dword_181C04;
  return v7;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000959A0) --------------------------------------------------------
int __cdecl sub_959A0(unsigned int *a1)
{
  int result; // eax
  bool v2; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v2 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v2 )
    fprintf(dword_181BF0, aAilUninstallMd, a1);
  result = sub_A7970(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095A30) --------------------------------------------------------
_DWORD *__cdecl sub_95A30(int a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v4; // [esp+4h] [ebp-Ch]
  _DWORD *v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v4 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v4 )
    fprintf(dword_181BF0, aAilAllocateSeq, a1);
  v5 = sub_A7B30(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResult0xX, v5);
  }
  --dword_181C04;
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095C00) --------------------------------------------------------
int __cdecl sub_95C00(int *a1, int a2, int a3)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v6; // [esp+4h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v6 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v6 )
    fprintf(dword_181BF0, aAilInitSequenc, a1, a2, a3);
  v7 = sub_A7C20(a1, a2, a3);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResultD, v7);
  }
  --dword_181C04;
  return v7;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095D50) --------------------------------------------------------
int *__cdecl sub_95D50(int *a1)
{
  int *result; // eax
  bool v2; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v2 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v2 )
    fprintf(dword_181BF0, aAilStartSequen, a1);
  result = sub_A8010(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095DE0) --------------------------------------------------------
int __cdecl sub_95DE0(int *a1)
{
  int result; // eax
  bool v2; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v2 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v2 )
    fprintf(dword_181BF0, aAilStopSequenc, a1);
  result = sub_A8050(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095E70) --------------------------------------------------------
void __cdecl sub_95E70(_DWORD *a1)
{
  bool v1; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v1 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v1 )
    fprintf(dword_181BF0, aAilResumeSeque, a1);
  sub_A8180(a1);
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095F00) --------------------------------------------------------
int __cdecl sub_95F00(int a1)
{
  int result; // eax
  bool v2; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v2 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v2 )
    fprintf(dword_181BF0, aAilEndSequence, a1);
  result = sub_A8250(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00096030) --------------------------------------------------------
void __cdecl sub_96030(_DWORD *a1, int a2, int a3)
{
  bool v3; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v3 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v3 )
    fprintf(dword_181BF0, aAilSetSequence_0, a1, a2, a3);
  sub_A8360(a1, a2, a3);
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00096170) --------------------------------------------------------
int __cdecl sub_96170(int a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v4; // [esp+4h] [ebp-Ch]
  int v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v4 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v4 )
    fprintf(dword_181BF0, aAilSequenceSta, a1);
  v5 = sub_A8410(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResultU, v5);
  }
  --dword_181C04;
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00096670) --------------------------------------------------------
_DWORD *__cdecl sub_96670(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax
  bool v3; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v3 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v3 )
    fprintf(dword_181BF0, aAilSetXmidiMas, a1, a2);
  result = sub_A84D0(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000969A0) --------------------------------------------------------
signed int __cdecl sub_969A0(_DWORD *a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v4; // [esp+4h] [ebp-Ch]
  signed int v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v4 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v4 )
    fprintf(dword_181BF0, aAilMdiDriverTy, a1);
  v5 = sub_A7990(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResultD, v5);
  }
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00096AE0) --------------------------------------------------------
int __cdecl sub_96AE0(int a1)
{
  int result; // eax
  bool v2; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v2 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v2 )
    fprintf(dword_181BF0, aAilSetGtlFilen, a1);
  result = sub_A7AA0(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00097330) --------------------------------------------------------
int __cdecl sub_97330(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax
  unsigned int i; // [esp+0h] [ebp-8h]
  unsigned int j; // [esp+0h] [ebp-8h]
  bool v6; // [esp+4h] [ebp-4h]

  ++dword_181C04;
  v6 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v6 )
    fprintf(dword_181BF0, aAilSequencePos, a1, a2, a3);
  result = sub_A8830(a1, a2, a3);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) )
  {
    result = sub_A16A2();
    if ( !result )
    {
      for ( i = 0; i < 0xE; ++i )
        fprintf(dword_181BF0, (const char *)&unk_D226C);
      for ( j = 1; j < dword_181C04; ++j )
        fprintf(dword_181BF0, (const char *)&unk_D2270);
      result = fprintf(dword_181BF0, aResultDD, *a3 + 1, *a2 + 1);
    }
  }
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00097480) --------------------------------------------------------
_DWORD *__cdecl sub_97480(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  bool v3; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v3 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v3 )
    fprintf(dword_181BF0, aAilBranchIndex, a1, a2);
  result = sub_A8900(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00097670) --------------------------------------------------------
int __cdecl sub_97670(int a1, int a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v5; // [esp+4h] [ebp-Ch]
  int v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v5 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v5 )
    fprintf(dword_181BF0, aAilRegisterTri, a1, a2);
  v6 = sub_A8A20(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResult0xX, v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00097A60) --------------------------------------------------------
int __cdecl sub_97A60(int a1, int a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v5; // [esp+4h] [ebp-Ch]
  int v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v5 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v5 )
    fprintf(dword_181BF0, aAilRegisterEve, a1, a2);
  v6 = sub_A8AE0(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResult0xX, v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00097BB0) --------------------------------------------------------
int __cdecl sub_97BB0(int a1, int a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v5; // [esp+4h] [ebp-Ch]
  int v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v5 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v5 )
    fprintf(dword_181BF0, aAilRegisterTim_0, a1, a2);
  v6 = sub_A8B20(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResult0xX, v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00097F90) --------------------------------------------------------
int __cdecl sub_97F90(_DWORD *a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  bool v4; // [esp+4h] [ebp-Ch]
  int v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  v4 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v4 )
    fprintf(dword_181BF0, aAilLockChannel, a1);
  v5 = sub_A8BF0(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, (const char *)&unk_D226C);
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, (const char *)&unk_D2270);
    fprintf(dword_181BF0, aResultD, v5);
  }
  --dword_181C04;
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000980D0) --------------------------------------------------------
int __cdecl sub_980D0(_DWORD *a1, int a2)
{
  int result; // eax
  bool v3; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v3 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v3 )
    fprintf(dword_181BF0, aAilReleaseChan, a1, a2);
  result = sub_A8EA0(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00098170) --------------------------------------------------------
int __cdecl sub_98170(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  bool v4; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v4 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v4 )
    fprintf(dword_181BF0, aAilMapSequence, a1, a2, a3);
  result = sub_A9080(a1, a2, a3);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00098360) --------------------------------------------------------
_DWORD *__cdecl sub_98360(_DWORD *a1, int a2, int a3, unsigned int a4, int a5)
{
  _DWORD *result; // eax
  bool v6; // [esp+0h] [ebp-4h]

  ++dword_181C04;
  v6 = dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0();
  if ( v6 )
    fprintf(dword_181BF0, aAilSendChannel, a1, a2, a3, a4, a5);
  result = sub_A9140(a1, a2, a3, a4, a5);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000986A0) --------------------------------------------------------
bool sub_986A0()
{
  bool result; // eax

  if ( dword_E39BC )
  {
    result = sub_9D650((unsigned int)sub_915A0, (unsigned int)sub_986A0);
    dword_E39BC = 0;
  }
  return result;
}
// E39BC: using guessed type int dword_E39BC;

//----- (000986E0) --------------------------------------------------------
void sub_986E0()
{
  sub_99C90();
  sub_99C10();
  if ( byte_E39B8 )
    sub_91420();
}
// E39B8: using guessed type char byte_E39B8;

//----- (00098709) --------------------------------------------------------
unsigned int __cdecl sub_98709(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( a1 >= a2 )
      break;
    if ( *(_DWORD *)a1 < a3 )
    {
      *(_BYTE *)(a1 + 4) *= 2;
      *(_BYTE *)(a1 + 5) *= 2;
      *(_DWORD *)a1 += a3;
    }
    a1 += 6;
  }
  return result;
}

//----- (0009874D) --------------------------------------------------------
unsigned int *__cdecl sub_9874D(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  unsigned int *result; // eax

  while ( 1 )
  {
    result = a1;
    if ( (unsigned int)a1 >= a2 )
      break;
    if ( *a1 < a3 )
      *a1 += a3;
    a1 = (unsigned int *)((char *)a1 + 6);
  }
  return result;
}

//----- (00098790) --------------------------------------------------------
void __cdecl sub_98790(unsigned __int16 a1, unsigned __int8 a2)
{
  if ( byte_E37FC && byte_E37FD && word_E3802 && a2 <= 0x7Fu && sub_96170(dword_180C78) != 2 )
    sub_96030((_DWORD *)dword_180C78, a2, a1);
}
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E3802: using guessed type __int16 word_E3802;
// 180C78: using guessed type int dword_180C78;

//----- (00098817) --------------------------------------------------------
int __cdecl sub_98817(int a1, int a2)
{
  int v2; // ST10_4

  if ( a2 == 546 )
  {
    v2 = creat(a1, 448);
    setmode(v2, 512);
    close(v2);
  }
  return sopen(a1, a2, 64);
}
// A0855: using guessed type _DWORD __cdecl close(_DWORD);
// AA6DD: using guessed type _DWORD __cdecl creat(_DWORD, _DWORD);
// AA6F4: using guessed type _DWORD __cdecl setmode(_DWORD, _DWORD);

//----- (00098882) --------------------------------------------------------
int __cdecl sub_98882(int a1)
{
  return close(a1);
}
// A0855: using guessed type _DWORD __cdecl close(_DWORD);

//----- (000988A7) --------------------------------------------------------
int __cdecl sub_988A7(int a1, int a2, int a3)
{
  return read(a1, a2, a3);
}
// A0863: using guessed type _DWORD __cdecl read(_DWORD, _DWORD, _DWORD);

//----- (0009891E) --------------------------------------------------------
int __cdecl sub_9891E(int a1, int a2, char a3)
{
  return lseek(a1, a2, a3);
}
// AA7C0: using guessed type _DWORD __cdecl lseek(_DWORD, _DWORD, char);

//----- (0009894C) --------------------------------------------------------
int __cdecl sub_9894C(int a1, char *a2)
{
  int *v2; // esi
  int v3; // eax
  int v4; // eax
  _WORD *v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // ebx
  _DWORD *v8; // esi
  _DWORD *v9; // edi
  unsigned int i; // ecx
  int v11; // esi
  int v12; // edi
  _BYTE *v13; // esi
  _BYTE *v14; // edi
  char *v15; // edi
  unsigned __int16 v16; // cx
  unsigned __int16 v17; // ST02_2
  unsigned int v18; // ecx
  int v19; // eax
  unsigned int v20; // ecx
  __int16 v21; // bx
  __int16 v22; // ax
  __int16 v23; // dx
  __int16 v24; // ax

  if ( *(_WORD *)a1 != 20050 )
    return 0;
  v2 = (int *)(a1 + 4);
  if ( *(_WORD *)(a1 + 2) != 323 )
    return 0;
  LOBYTE(v3) = sub_98AE0(v2);
  dword_E3B40 = v3;
  LOBYTE(v4) = sub_98AE0(v2);
  dword_E3B44 = v4;
  byte_E3B50 = *(_BYTE *)(a1 + 9);
  v5 = (_WORD *)(a1 + 10);
  v6 = v4 + 18 + a1;
  if ( v6 > (unsigned int)a2 )
  {
    v7 = (unsigned int)&a2[dword_E3B40 + *(unsigned __int8 *)(a1 + 16)];
    if ( v7 > v6 )
    {
      v8 = (_DWORD *)(v6 - 4);
      v9 = (_DWORD *)(v7 - 4);
      for ( i = (unsigned int)dword_E3B44 >> 2; i; --i )
      {
        *v9 = *v8;
        --v8;
        --v9;
      }
      v11 = (int)(v8 + 1);
      v12 = (int)(v9 + 1);
      LOWORD(i) = dword_E3B44 & 3;
      if ( dword_E3B44 & 3 )
      {
        v13 = (_BYTE *)(v11 - 1);
        v14 = (_BYTE *)(v12 - 1);
        while ( i )
        {
          *v14-- = *v13--;
          --i;
        }
        v12 = (int)(v14 + 1);
      }
      v5 = (_WORD *)v12;
    }
  }
  v15 = a2;
  byte_E3B51 = 0;
  word_E3B4C = *v5;
  sub_98B2C(2u, (int)v5);
  do
  {
    sub_98BAF((int)v5);
    sub_98BAF((int)v5);
    sub_98BAF((int)v5);
    word_E3B4A = sub_98B2C(0x10u, (int)v5);
    while ( 1 )
    {
      sub_98AE9((__int16 *)&unk_E39C0, (int)v5);
      if ( (_WORD)v20 )
      {
        qmemcpy(v15, v5, v20);
        v5 = (_WORD *)((char *)v5 + v20);
        v15 += v20;
        v21 = *v5;
        v22 = __ROL2__(*v5, byte_E3B51);
        v23 = (1 << byte_E3B51) - 1;
        word_E3B4C &= v23;
        v24 = v22 & v23 | (v5[1] << byte_E3B51);
        word_E3B4C |= v21 << byte_E3B51;
        word_E3B4E = v24;
      }
      if ( !--word_E3B4A )
        break;
      sub_98AE9((__int16 *)&unk_E3A40, (int)v5);
      v17 = v16;
      sub_98AE9((__int16 *)&unk_E3AC0, (int)v5);
      LOWORD(v18) = v18 + 2;
      v19 = v17;
      LOWORD(v19) = v17 + 1;
      qmemcpy(v15, &v15[-v19], v18);
      v15 += v18;
    }
    --byte_E3B50;
  }
  while ( byte_E3B50 );
  return dword_E3B40;
}
// E3B40: using guessed type int dword_E3B40;
// E3B44: using guessed type int dword_E3B44;
// E3B4A: using guessed type __int16 word_E3B4A;
// E3B4C: using guessed type __int16 word_E3B4C;
// E3B4E: using guessed type __int16 word_E3B4E;
// E3B50: using guessed type char byte_E3B50;
// E3B51: using guessed type char byte_E3B51;

//----- (00098AE0) --------------------------------------------------------
char __usercall sub_98AE0@<al>(int *a1@<esi>)
{
  int v1; // eax
  char v2; // t0

  v1 = *a1;
  v2 = BYTE1(v1);
  BYTE1(v1) = *a1;
  LOBYTE(v1) = v2;
  v1 = __ROL4__(v1, 16);
  return BYTE1(v1);
}

//----- (00098AE9) --------------------------------------------------------
__int16 __usercall sub_98AE9@<ax>(__int16 *a1@<edx>, int a2@<esi>)
{
  int v2; // edx
  __int16 *v3; // esi
  __int16 *v4; // et0
  __int16 v5; // ax
  __int16 *v6; // esi
  __int16 v7; // bx
  __int16 v8; // ax
  __int16 v9; // cx
  int v10; // esi
  __int16 result; // ax
  unsigned __int8 v12; // cl
  __int16 v13; // ax
  char v14; // cl

  v4 = a1;
  v2 = a2;
  v3 = v4;
  do
  {
    v5 = *v3;
    v6 = v3 + 1;
    v7 = word_E3B4C & v5;
    v8 = *v6;
    v3 = v6 + 1;
  }
  while ( v8 != v7 );
  v9 = v3[30];
  v10 = v2;
  result = sub_98B2C(HIBYTE(v9), v2);
  if ( v12 >= 2u )
  {
    v13 = sub_98B2C(v12 - 1, v10);
    result = (1 << v14) | v13;
  }
  return result;
}
// E3B4C: using guessed type __int16 word_E3B4C;

//----- (00098B2C) --------------------------------------------------------
__int16 __usercall sub_98B2C@<ax>(unsigned __int8 a1@<al>, int a2@<esi>)
{
  unsigned __int8 v2; // cl
  unsigned __int16 v3; // ax
  unsigned __int16 v4; // bx
  char v5; // ch
  __int16 v7; // [esp-4h] [ebp-4h]

  v2 = a1;
  v3 = word_E3B4E;
  v4 = word_E3B4C;
  v7 = word_E3B4C & ((1 << v2) - 1);
  v5 = byte_E3B51 - v2;
  if ( (unsigned __int8)byte_E3B51 < v2 )
  {
    v4 = __ROR2__(word_E3B4E & ((1 << byte_E3B51) - 1), byte_E3B51) | ((unsigned __int16)word_E3B4C >> byte_E3B51);
    v3 = *(_WORD *)(a2 + 2);
    v2 -= byte_E3B51;
    v5 = 16 - v2;
  }
  word_E3B4E = v3 >> v2;
  word_E3B4C = __ROR2__(v3 & ((1 << v2) - 1), v2) | (v4 >> v2);
  byte_E3B51 = v5;
  return v7;
}
// E3B4C: using guessed type __int16 word_E3B4C;
// E3B4E: using guessed type __int16 word_E3B4E;
// E3B51: using guessed type char byte_E3B51;

//----- (00098BAF) --------------------------------------------------------
char __usercall sub_98BAF@<al>(int a1@<esi>)
{
  int *v1; // edi
  unsigned __int16 v2; // ax
  int v3; // ecx
  int v4; // ecx
  int *v5; // esi
  _WORD *v6; // edi
  unsigned __int16 v7; // bx
  unsigned __int16 v8; // dx
  _WORD *v9; // edi
  __int16 v10; // bx
  unsigned __int8 v11; // cf
  __int16 v12; // ax
  unsigned __int8 v13; // tt
  unsigned __int8 v14; // tt
  __int16 v15; // ax
  __int16 v17; // [esp-24h] [ebp-28h]
  unsigned __int16 v18; // [esp-22h] [ebp-26h]
  unsigned __int16 v19; // [esp-20h] [ebp-24h]
  int *v20; // [esp-1Eh] [ebp-22h]
  __int16 v21; // [esp-1Ah] [ebp-1Eh]
  int v22; // [esp-18h] [ebp-1Ch]
  int v23; // [esp-14h] [ebp-18h]
  _WORD *v24; // [esp-4h] [ebp-8h]

  v1 = &v23;
  v2 = sub_98B2C(5u, a1);
  if ( v2 )
  {
    v22 = v2;
    do
    {
      v2 = sub_98B2C(4u, a1);
      *(_BYTE *)v1 = v2;
      v1 = (int *)((char *)v1 + 1);
    }
    while ( v3 != 1 );
    v4 = v22;
    v22 = a1;
    v5 = &v23;
    v6 = v24;
    LOBYTE(v2) = 1;
    v7 = 0;
    v8 = -32768;
    do
    {
      v21 = v4;
      v20 = v5;
      do
      {
        if ( (_BYTE)v2 == *(_BYTE *)v5 )
        {
          v19 = v2;
          v18 = v7;
          v17 = v4;
          *v6 = (1 << v2) - 1;
          v9 = v6 + 1;
          v10 = v7 >> (16 - v2);
          LOBYTE(v4) = v2;
          v12 = 0;
          v11 = 0;
          do
          {
            v13 = __CFRCR__(v10, v11);
            v10 = __RCR__(v10, v11);
            v11 = v13;
            v14 = __CFRCL__(v12, v13);
            v12 = __RCL__(v12, v11);
            v11 = v14;
            --v4;
          }
          while ( v4 );
          *v9 = v12;
          v6 = v9 + 1;
          LOBYTE(v15) = (char *)v5 - (char *)&v17 - 16;
          HIBYTE(v15) = *(_BYTE *)v5;
          v6[30] = v15;
          LOWORD(v4) = v17;
          v2 = v19;
          v7 = v8 + v18;
        }
        v5 = (int *)((char *)v5 + 1);
        --v4;
      }
      while ( v4 );
      v5 = v20;
      LOWORD(v4) = v21;
      v8 >>= 1;
      LOBYTE(v2) = v2 + 1;
    }
    while ( (_BYTE)v2 != 17 );
  }
  return v2;
}

//----- (00098C48) --------------------------------------------------------
signed int __cdecl sub_98C48(int a1, int a2, int a3)
{
  int v3; // ST14_4
  int v6; // [esp+4h] [ebp-8h]

  v6 = sub_98817(a1, 546);
  if ( v6 == -1 )
    return -1;
  v3 = sub_98CAA(v6, a2, a3);
  sub_98882(v6);
  return v3;
}

//----- (00098CAA) --------------------------------------------------------
int __cdecl sub_98CAA(int a1, int a2, int a3)
{
  return write(a1, a2, a3);
}
// AA80B: using guessed type _DWORD __cdecl write(_DWORD, _DWORD, _DWORD);

//----- (00098FF5) --------------------------------------------------------
int __cdecl sub_98FF5(char *a1)
{
  char *i; // eax
  char v2; // cl
  int v3; // ebx
  int v4; // ebx

  for ( i = a1; IsTable[(unsigned __int8)(*i + 1)] & 2; ++i )
    ;
  v2 = *i;
  if ( *i == 43 || v2 == 45 )
    ++i;
  v3 = 0;
  while ( IsTable[(unsigned __int8)(*i + 1)] & 0x20 )
  {
    v4 = (unsigned __int8)*i++ + 10 * v3;
    v3 = v4 - 48;
  }
  if ( v2 == 45 )
    v3 = -v3;
  return v3;
}

//----- (00099080) --------------------------------------------------------
void __cdecl sub_99080(char a1)
{
  byte_E379B = a1 != 0;
}
// E379B: using guessed type char byte_E379B;

//----- (0009937E) --------------------------------------------------------
int __cdecl sub_9937E(__int16 a1)
{
  int result; // eax
  int v2; // [esp+0h] [ebp-78h]
  int v3; // [esp+18h] [ebp-60h]
  int v4; // [esp+1Ch] [ebp-5Ch]
  __int16 v5; // [esp+22h] [ebp-56h]
  __int16 v6; // [esp+24h] [ebp-54h]
  char v7; // [esp+34h] [ebp-44h]
  int v8; // [esp+50h] [ebp-28h]
  int v9; // [esp+54h] [ebp-24h]
  int *v10; // [esp+64h] [ebp-14h]
  char v11; // [esp+6Ch] [ebp-Ch]

  memset(&v2, 0, 50);
  v5 = (unsigned int)dword_181C40 >> 4;
  v6 = (unsigned int)dword_181C40 >> 4;
  v2 = 0;
  v4 = 20225;
  v3 = a1;
  memset(&v8, 0, 28);
  memset(&v7, 0, 28);
  memset(&v11, 0, 12);
  segread(&v11);
  v8 = 768;
  v9 = 16;
  v10 = &v2;
  int386x(49, &v8, &v7, &v11);
  word_181C44 = *(unsigned __int8 *)(dword_181C40 + 4) + (*(unsigned __int8 *)(dword_181C40 + 5) << 8);
  word_E3BA6 = *(unsigned __int8 *)(dword_181C40 + 16) + (*(unsigned __int8 *)(dword_181C40 + 17) << 8);
  word_E3BA8 = *(unsigned __int8 *)(dword_181C40 + 18) + (*(unsigned __int8 *)(dword_181C40 + 19) << 8);
  HIWORD(result) = HIWORD(dword_181C40);
  LOWORD(result) = *(unsigned __int8 *)(dword_181C40 + 20);
  word_E3BAA = (unsigned __int8)result + (*(unsigned __int8 *)(dword_181C40 + 21) << 8);
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99DE6: using guessed type _DWORD __cdecl segread(_DWORD);
// 99E10: using guessed type _DWORD __cdecl int386x(_DWORD, _DWORD, _DWORD, _DWORD);
// E3BA6: using guessed type __int16 word_E3BA6;
// E3BA8: using guessed type __int16 word_E3BA8;
// E3BAA: using guessed type __int16 word_E3BAA;
// 181C40: using guessed type int dword_181C40;
// 181C44: using guessed type __int16 word_181C44;

//----- (000994BA) --------------------------------------------------------
int __cdecl sub_994BA(__int16 a1)
{
  char v2; // [esp+0h] [ebp-38h]
  char v3; // [esp+1Ch] [ebp-1Ch]
  char v4; // [esp+1Dh] [ebp-1Bh]
  __int16 v5; // [esp+20h] [ebp-18h]

  memset(&v3, 0, 28);
  memset(&v2, 0, 28);
  v4 = 79;
  v3 = 2;
  v5 = a1;
  int386(16, &v3, &v2);
  return sub_9937E(a1);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009951B) --------------------------------------------------------
signed int __cdecl sub_9951B(__int16 a1)
{
  signed int result; // eax

  word_E3BA4 = a1;
  if ( a1 > 5 || a1 < 0 )
  {
    __outbyte(0x3C8u, 0);
    __outbyte(0x3C9u, 0x3Fu);
    __outbyte(0x3C9u, 0);
    __outbyte(0x3C9u, 0);
  }
  __asm { int     10h; - VIDEO - VESA SuperVGA BIOS -  VESA SuperVGA BIOS - CPU VIDEO MEMORY CONTROL }
  result = 20229;
  __asm { int     10h; - VIDEO - VESA SuperVGA BIOS -  VESA SuperVGA BIOS - CPU VIDEO MEMORY CONTROL }
  return result;
}
// E3BA4: using guessed type __int16 word_E3BA4;
// 181C40: using guessed type int dword_181C40;

//----- (000995B0) --------------------------------------------------------
int sub_995B0()
{
  int v1; // [esp+0h] [ebp-7Ch]
  int v2; // [esp+10h] [ebp-6Ch]
  int v3; // [esp+1Ch] [ebp-60h]
  __int16 v4; // [esp+22h] [ebp-5Ah]
  __int16 v5; // [esp+24h] [ebp-58h]
  int v6; // [esp+34h] [ebp-48h]
  int v7; // [esp+38h] [ebp-44h]
  int *v8; // [esp+48h] [ebp-34h]
  char v9; // [esp+50h] [ebp-2Ch]
  char v10; // [esp+6Ch] [ebp-10h]

  memset(&v1, 0, 50);
  v4 = (unsigned int)dword_181C40 >> 4;
  v5 = (unsigned int)dword_181C40 >> 4;
  v1 = 0;
  v3 = 20224;
  v2 = 257;
  memset(&v6, 0, 28);
  memset(&v9, 0, 28);
  memset(&v10, 0, 12);
  segread(&v10);
  v6 = 768;
  v7 = 16;
  v8 = &v1;
  int386x(49, &v6, &v9, &v10);
  return strncmp(dword_181C40, aVesa, 4);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99682: using guessed type _DWORD __cdecl strncmp(_DWORD, _DWORD, _DWORD);
// 99DE6: using guessed type _DWORD __cdecl segread(_DWORD);
// 99E10: using guessed type _DWORD __cdecl int386x(_DWORD, _DWORD, _DWORD, _DWORD);
// 181C40: using guessed type int dword_181C40;

//----- (00099970) --------------------------------------------------------
void __cdecl sub_99970(char a1, unsigned __int8 a2)
{
  if ( byte_E3819 && byte_E37FC && byte_E37FD && word_E3802 && sub_96170(dword_180C78) != 2 && byte_E3817 != a1 )
  {
    if ( byte_E3818 )
      sub_92DC0(dword_180C80);
    byte_E3817 = a1;
    byte_E381A = -byte_E381A;
    byte_E3818 = 1;
    if ( a2 <= 4u && a2 >= 1u )
    {
      dword_180C80 = sub_92600((int)sub_99830);
      sub_92930(dword_180C80, 30 * a2);
      sub_92BA0(dword_180C80);
    }
    else
    {
      dword_180C80 = sub_92600((int)sub_99830);
      sub_92930(dword_180C80, 0x1Eu);
      sub_92BA0(dword_180C80);
    }
  }
}
// 99830: using guessed type int sub_99830();
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E3802: using guessed type __int16 word_E3802;
// E3817: using guessed type char byte_E3817;
// E3818: using guessed type char byte_E3818;
// E3819: using guessed type char byte_E3819;
// E381A: using guessed type char byte_E381A;
// 180C78: using guessed type int dword_180C78;
// 180C80: using guessed type int dword_180C80;

//----- (00099A77) --------------------------------------------------------
unsigned int __cdecl sub_99A77(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( a1 >= a2 )
      break;
    if ( *(_DWORD *)a1 >= a3 )
    {
      *(_BYTE *)(a1 + 4) = *(unsigned __int8 *)(a1 + 4) / 2;
      *(_BYTE *)(a1 + 5) = *(unsigned __int8 *)(a1 + 5) / 2;
      *(_DWORD *)a1 -= a3;
    }
    a1 += 6;
  }
  return result;
}

//----- (00099AEB) --------------------------------------------------------
unsigned int *__cdecl sub_99AEB(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  unsigned int *result; // eax

  while ( 1 )
  {
    result = a1;
    if ( (unsigned int)a1 >= a2 )
      break;
    if ( *a1 >= a3 )
      *a1 -= a3;
    a1 = (unsigned int *)((char *)a1 + 6);
  }
  return result;
}

//----- (00099C10) --------------------------------------------------------
void sub_99C10()
{
  if ( byte_E379A )
  {
    sub_8D8F0();
    if ( !byte_E37FE )
      sub_919C0();
    if ( dword_E37A0 )
    {
      sub_83E80(dword_E37A0);
      dword_E37A4 = 0;
    }
    if ( dword_E37A8 )
      sub_83E80(dword_E37A8);
    byte_E3798 = 0;
    byte_E3799 = 0;
    byte_E379A = 0;
  }
}
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E379A: using guessed type char byte_E379A;
// E37A0: using guessed type int dword_E37A0;
// E37A4: using guessed type int dword_E37A4;
// E37A8: using guessed type int dword_E37A8;
// E37FE: using guessed type char byte_E37FE;

//----- (00099C90) --------------------------------------------------------
void sub_99C90()
{
  if ( byte_E37FE )
  {
    if ( word_E3802 )
    {
      sub_95DE0((int *)dword_180C78);
      sub_95F00(dword_180C78);
      word_E3802 = 0;
    }
    if ( byte_E3815 == 1 )
      sub_9FA80();
    if ( !byte_E379A )
      sub_919C0();
    if ( dword_E3808 )
    {
      sub_83E80(dword_E3808);
      dword_E380C = 0;
    }
    if ( dword_E3810 )
      sub_83E80(dword_E3810);
    byte_E37FC = 0;
    byte_E37FD = 0;
    byte_E37FE = 0;
  }
}
// E379A: using guessed type char byte_E379A;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E37FE: using guessed type char byte_E37FE;
// E3802: using guessed type __int16 word_E3802;
// E3808: using guessed type int dword_E3808;
// E380C: using guessed type int dword_E380C;
// E3810: using guessed type int dword_E3810;
// E3815: using guessed type char byte_E3815;
// 180C78: using guessed type int dword_180C78;

//----- (00099E8E) --------------------------------------------------------
signed int __cdecl sub_99E8E(unsigned __int8 *a1, unsigned __int8 **a2, signed int a3, int a4)
{
  signed int v4; // edi
  unsigned __int8 *i; // ebx
  unsigned __int8 v6; // al
  signed int result; // eax
  unsigned __int8 v8; // cl
  unsigned int v9; // esi
  int v10; // eax
  unsigned int v11; // edx
  unsigned __int8 *v12; // [esp+0h] [ebp-1Ch]
  char v13; // [esp+4h] [ebp-18h]
  unsigned __int8 v14; // [esp+8h] [ebp-14h]

  v4 = a3;
  if ( a2 )
    *a2 = a1;
  for ( i = a1; IsTable[(unsigned __int8)(*i + 1)] & 2; ++i )
    ;
  v14 = *i;
  if ( *i == 43 || *i == 45 )
    ++i;
  if ( !a3 )
  {
    if ( *i != 48 || (v6 = i[1], v6 != 120) && v6 != 88 )
    {
      if ( *i == 48 )
        v4 = 8;
      else
        v4 = 10;
    }
    else
    {
      v4 = 16;
    }
  }
  if ( v4 >= 2 && v4 <= 36 )
  {
    if ( v4 == 16 && *i == 48 )
    {
      v8 = i[1];
      if ( v8 == 120 || v8 == 88 )
        i += 2;
    }
    v12 = i;
    v9 = 0;
    v13 = 0;
    while ( 1 )
    {
      v10 = sub_99FF5(*i);
      if ( v10 >= v4 )
        break;
      v11 = v9;
      v9 = v10 + v4 * v9;
      if ( v9 < v11 )
        v13 = 1;
      ++i;
    }
    if ( i == v12 )
      i = a1;
    if ( a2 )
      *a2 = i;
    if ( a4 == 1 && v9 >= 0x80000000 && (v9 != 0x80000000 || v14 != 45) )
      v13 = 1;
    if ( v13 )
    {
      _set_errno(14);
      if ( a4 )
      {
        if ( v14 == 45 )
          result = 2147483648;
        else
          result = 0x7FFFFFFF;
      }
      else
      {
        result = -1;
      }
    }
    else
    {
      if ( v14 == 45 )
        v9 = -v9;
      result = v9;
    }
  }
  else
  {
    _set_errno(13);
    result = 0;
  }
  return result;
}
// 9D195: using guessed type _DWORD __cdecl _set_errno(_DWORD);

//----- (00099FF0) --------------------------------------------------------
signed int __cdecl sub_99FF0(unsigned __int8 *a1, unsigned __int8 **a2, signed int a3)
{
  return sub_99E8E(a1, a2, a3, 1);
}

//----- (00099FF5) --------------------------------------------------------
int __cdecl sub_99FF5(unsigned __int8 a1)
{
  unsigned __int8 v2; // al

  if ( a1 >= 0x30u && a1 <= 0x39u )
    return a1 - 48;
  v2 = tolower(a1);
  if ( v2 >= 0x61u && v2 <= 0x69u )
    return v2 - 87;
  if ( v2 >= 0x6Au && v2 <= 0x72u || v2 >= 0x73u && v2 <= 0x7Au )
    return v2 - 87;
  return 37;
}
// AB952: using guessed type _DWORD __cdecl tolower(_DWORD);

//----- (0009A0FC) --------------------------------------------------------
unsigned __int8 sub_9A0FC()
{
  unsigned __int8 result; // al

  do
    result = __inbyte(0x3DAu);
  while ( !(result & 8) );
  return result;
}

//----- (0009A10A) --------------------------------------------------------
signed int __fastcall sub_9A10A(signed int result)
{
  if ( dword_E4CA4 )
    return 1;
  __asm { int     21h; DOS - CHECK STANDARD INPUT STATUS }
  return (char)result;
}
// E4CA4: using guessed type int dword_E4CA4;

//----- (0009A128) --------------------------------------------------------
void __cdecl sub_9A128(const void *a1, void *a2, unsigned __int16 a3)
{
  qmemcpy(a2, a1, 320 * a3);
}

//----- (0009A144) --------------------------------------------------------
void __cdecl sub_9A144(const void *a1, void *a2, unsigned __int16 a3)
{
  qmemcpy(a2, a1, 640 * a3);
}

//----- (0009A230) --------------------------------------------------------
int __cdecl sub_9A230(int a1)
{
  int result; // eax

  result = a1;
  if ( (unsigned __int16)a1 < 0x336u )
  {
    if ( (unsigned __int16)a1 < 0x320u )
    {
      if ( !(_WORD)a1 )
        word_E37B4 = 0;
    }
    else if ( (unsigned __int16)a1 <= 0x320u )
    {
      word_E37B4 = 800;
    }
    else if ( (_WORD)a1 == 811 )
    {
      word_E37B4 = 811;
    }
  }
  else if ( (unsigned __int16)a1 <= 0x336u )
  {
    word_E37B4 = 822;
  }
  else if ( (unsigned __int16)a1 < 0x656u )
  {
    if ( (_WORD)a1 == 1611 )
      word_E37B4 = 1611;
  }
  else if ( (unsigned __int16)a1 <= 0x656u )
  {
    word_E37B4 = 1622;
  }
  else if ( (_WORD)a1 == 1644 )
  {
    word_E37B4 = 1644;
  }
  return result;
}
// E37B4: using guessed type __int16 word_E37B4;

//----- (0009A2F5) --------------------------------------------------------
_DWORD *__cdecl sub_9A2F5(int a1)
{
  _DWORD *result; // eax

  result = *(_DWORD **)(a1 + 28);
  if ( *result )
  {
    sub_83E80(**(_DWORD **)(a1 + 28));
    result = *(_DWORD **)(a1 + 28);
    *result = 0;
  }
  return result;
}

//----- (0009A32D) --------------------------------------------------------
signed int __cdecl sub_9A32D(int a1)
{
  int v1; // edx
  int *v2; // eax
  int v3; // edx
  int *v4; // eax
  int (__cdecl *v6)(int); // [esp+0h] [ebp-8h]

  sub_85070();
  if ( *(_BYTE *)(a1 + 40) & 1 )
    v6 = sub_83D70;
  else
    v6 = sub_83CD0;
  sub_9A2F5(a1);
  if ( *(_BYTE *)a1 == 42 )
  {
    v1 = v6(*(_DWORD *)(a1 + 36));
    v2 = *(int **)(a1 + 28);
    *v2 = v1;
    if ( !*v2 )
      return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 36) = sub_AB9E1(a1);
    if ( *(_DWORD *)(a1 + 36) <= 0 )
      return 0;
    v3 = v6(*(_DWORD *)(a1 + 36));
    v4 = *(int **)(a1 + 28);
    *v4 = v3;
    if ( !*v4 )
      return -1;
    if ( sub_53E60(a1, **(char ***)(a1 + 28)) != *(_DWORD *)(a1 + 36) )
    {
      **(_DWORD **)(a1 + 28) = 0;
      **(_DWORD **)(a1 + 32) = 0;
      *(_DWORD *)(a1 + 36) = 0;
      return 0;
    }
  }
  if ( *(_DWORD *)(a1 + 32) )
    **(_DWORD **)(a1 + 32) = *(_DWORD *)(a1 + 36) + **(_DWORD **)(a1 + 28);
  return 1;
}

//----- (0009AD16) --------------------------------------------------------
int __cdecl sub_9AD16(unsigned __int16 a1)
{
  int result; // eax
  char v2; // [esp+0h] [ebp-38h]
  int v3; // [esp+1Ch] [ebp-1Ch]
  int v4; // [esp+28h] [ebp-10h]

  if ( a1 )
  {
    v3 = 257;
    v4 = a1;
    result = int386(49, &v3, &v2);
  }
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009AD9C) --------------------------------------------------------
int __cdecl sub_9AD9C(int a1)
{
  return 100 * a1;
}

//----- (0009ADB4) --------------------------------------------------------
int __cdecl sub_9ADB4(int a1)
{
  return 100 * a1 / 10;
}

//----- (0009AE04) --------------------------------------------------------
bool __usercall sub_9AE04@<eax>(int eax0@<eax>, int edx0@<edx>, int a3@<ebx>, int a1, int a2)
{
  return j___clock(eax0, edx0, a3) - a1 >= a2;
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);

//----- (0009AE90) --------------------------------------------------------
char __usercall sub_9AE90@<al>(int eax0@<eax>, int edx0@<edx>, int ebx0@<ebx>, int *a1, _BYTE *a2, int a3, int a4)
{
  _BYTE *v7; // esi
  int v8; // ebp
  int v9; // ebx
  int v10; // eax

  v7 = a2;
  v8 = j_j___clock(eax0, edx0, ebx0);
  v9 = 0;
  do
  {
    v10 = sub_9C9D0(*a1);
    if ( !v10 )
    {
      ++v9;
      *v7 = sub_9C938((_DWORD *)*a1);
      v10 = a3;
      ++v7;
      if ( v9 == a3 )
        return 0;
    }
  }
  while ( !sub_9AE04(v10, a4, v9, v8, a4) );
  return 3;
}
// 9ADFC: using guessed type int __fastcall j_j___clock(_DWORD, _DWORD, _DWORD);

//----- (0009AEEC) --------------------------------------------------------
void __cdecl sub_9AEEC(_DWORD **a1, char *a2)
{
  char *v2; // ebx
  char v3; // ST04_1

  v2 = a2;
  if ( dword_E3DE8 )
    printf(aWritingS);
  while ( 1 )
  {
    JUMPOUT(*v2, 0, &loc_9AEE8);
    v3 = *v2++;
    sub_9C810(*a1, v3);
  }
}
// E3DE8: using guessed type int dword_E3DE8;

//----- (0009AFC4) --------------------------------------------------------
char __usercall sub_9AFC4@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, int *a4, int a5)
{
  int v5; // edi
  int v6; // eax
  int v7; // edx

  v5 = j_j___clock(a1, a2, a3);
  do
  {
    v6 = sub_9C9D0(*a4);
    if ( !v6 )
    {
      v6 = sub_9C938((_DWORD *)*a4);
      a3 = v6;
      if ( dword_E3DE8 )
        v6 = printf(aResponseC);
      if ( a3 == 79 )
        return 0;
      if ( a3 == 69 )
        return 8;
    }
  }
  while ( !sub_9AE04(v6, v7, a3, v5, a5) );
  return 3;
}
// 9ADFC: using guessed type int __fastcall j_j___clock(_DWORD, _DWORD, _DWORD);
// E3DE8: using guessed type int dword_E3DE8;

//----- (0009B038) --------------------------------------------------------
char __cdecl sub_9B038(int *a1, char *a2, int a3)
{
  int v3; // eax
  int v4; // edx

  sub_9AEEC((_DWORD **)a1, a2);
  return sub_9AFC4(v3, v4, (int)a1, a1, a3);
}

//----- (0009B234) --------------------------------------------------------
int __cdecl sub_9B234(int *a1)
{
  int result; // eax

  if ( *a1 )
  {
    sub_9C58C(*a1);
    result = free(*a1);
    *a1 = 0;
  }
  return result;
}
// A0E6B: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0009B260) --------------------------------------------------------
signed int __cdecl sub_9B260(_DWORD **a1)
{
  return sub_9C810(*a1, 83);
}

//----- (0009B274) --------------------------------------------------------
char __cdecl sub_9B274(int *a1, int a2)
{
  char result; // al
  int v3; // ebp
  int v4; // esi
  char v5; // dl
  int v6; // edi
  signed int v7; // eax
  char v8; // dh
  char v9; // [esp+0h] [ebp-44h]
  unsigned __int8 v10; // [esp+1h] [ebp-43h]
  unsigned __int8 v11; // [esp+2h] [ebp-42h]
  unsigned __int8 v12; // [esp+3h] [ebp-41h]
  unsigned __int8 v13; // [esp+4h] [ebp-40h]
  unsigned __int8 v14; // [esp+5h] [ebp-3Fh]
  unsigned __int8 v15; // [esp+6h] [ebp-3Eh]
  unsigned __int8 v16; // [esp+7h] [ebp-3Dh]
  unsigned __int8 v17; // [esp+8h] [ebp-3Ch]
  unsigned __int8 v18; // [esp+9h] [ebp-3Bh]
  unsigned __int8 v19; // [esp+Ah] [ebp-3Ah]
  char v20; // [esp+Bh] [ebp-39h]
  int v21; // [esp+20h] [ebp-24h]
  int v22; // [esp+24h] [ebp-20h]
  int v23; // [esp+28h] [ebp-1Ch]
  int v24; // [esp+2Ch] [ebp-18h]
  int v25; // [esp+30h] [ebp-14h]

  if ( sub_9AE90((int)&v9, a2, (int)a1, a1, &v9, 12, a2) )
  {
    sub_9CBBC((_DWORD *)*a1);
    result = 3;
  }
  else
  {
    v3 = (signed __int16)(v10 << 8) | v11;
    v24 = v13 | (signed __int16)(v12 << 8);
    v25 = v15 | (signed __int16)(v14 << 8);
    v4 = v17 | (signed __int16)(v16 << 8);
    v5 = 0;
    v6 = (signed __int16)(v18 << 8) | v19;
    v7 = 0;
    do
    {
      v8 = *(&v9 + v7++);
      v5 += v8;
    }
    while ( v7 < 11 );
    if ( v5 == v20 )
    {
      sub_AC250(
        (signed __int16)(v10 << 8) | v11,
        v24,
        v25,
        v17 | (signed __int16)(v16 << 8),
        (signed __int16)(v18 << 8) | v19,
        &v23,
        &v22,
        &v21);
      a1[1] = v3;
      a1[4] = v4;
      a1[5] = v6;
      a1[2] = v24;
      a1[3] = v25;
      a1[6] = v22;
      a1[7] = v23;
      a1[8] = v21;
      result = 0;
    }
    else
    {
      sub_9CBBC((_DWORD *)*a1);
      result = 4;
    }
  }
  return result;
}

//----- (0009B498) --------------------------------------------------------
char *__cdecl sub_9B498(char a1)
{
  char *result; // eax

  switch ( a1 )
  {
    case 0:
      result = aTrackerInitial;
      break;
    case 1:
      result = aNoSerialPort;
      break;
    case 2:
      result = aTrackerNotPres;
      break;
    case 3:
      result = aTrackerIsNotRe;
      break;
    case 4:
      result = aTrackerDataIsI;
      break;
    case 5:
      result = aTrackerHeaderD;
      break;
    case 6:
      result = aAVerifiedWrite;
      break;
    case 7:
      result = aInvalidParamet;
      break;
    case 8:
      result = aTrackerCommand;
      break;
    case 9:
      result = aAMemoryAllocat;
      break;
    case 10:
      result = aTrackerVersion;
      break;
    default:
      result = aUndefined;
      break;
  }
  return result;
}

//----- (0009B540) --------------------------------------------------------
bool __cdecl sub_9B540(unsigned int a1, unsigned int a2)
{
  int v3; // [esp+4h] [ebp-20h]
  unsigned int v4; // [esp+8h] [ebp-1Ch]
  int v5; // [esp+Ch] [ebp-18h]
  unsigned int v6; // [esp+14h] [ebp-10h]
  int v7; // [esp+18h] [ebp-Ch]
  int v8; // [esp+1Ch] [ebp-8h]

  v3 = 1536;
  v4 = a1 >> 16;
  v5 = (unsigned __int16)a1;
  v6 = a2 >> 16;
  v7 = (unsigned __int16)a2;
  int386(49, &v3, &v3);
  return v8 == 0;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009B5B4) --------------------------------------------------------
bool __cdecl sub_9B5B4(unsigned int a1, unsigned int a2)
{
  int v3; // [esp+4h] [ebp-20h]
  unsigned int v4; // [esp+8h] [ebp-1Ch]
  int v5; // [esp+Ch] [ebp-18h]
  unsigned int v6; // [esp+14h] [ebp-10h]
  int v7; // [esp+18h] [ebp-Ch]
  int v8; // [esp+1Ch] [ebp-8h]

  v3 = 1537;
  v4 = a1 >> 16;
  v5 = (unsigned __int16)a1;
  v6 = a2 >> 16;
  v7 = (unsigned __int16)a2;
  int386(49, &v3, &v3);
  return v8 == 0;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009B628) --------------------------------------------------------
void sub_9B628()
{
  ;
}

//----- (0009B63C) --------------------------------------------------------
int __cdecl sub_9B63C(int a1)
{
  return inp(a1);
}
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);

//----- (0009B688) --------------------------------------------------------
_WORD *__cdecl sub_9B688(int a1)
{
  _WORD *result; // eax
  __int16 v2; // dx
  __int16 v3; // t1
  signed int v4; // [esp+10h] [ebp-34h]
  _WORD *v5; // [esp+30h] [ebp-14h]
  _WORD *v6; // [esp+34h] [ebp-10h]
  unsigned __int8 i; // [esp+38h] [ebp-Ch]
  char v8; // [esp+40h] [ebp-4h]

  result = (_WORD *)a1;
  if ( *(_DWORD *)(a1 + 28) )
  {
    if ( *(_DWORD *)(a1 + 20) )
    {
      v6 = *(_WORD **)(a1 + 44);
      if ( !(inp(*(_DWORD *)(a1 + 28) + 6) & 0x10) )
      {
        result = v6;
        result[2] |= 2u;
        return result;
      }
      v6[2] &= 0xFFFDu;
    }
    result = (_WORD *)inp(*(_DWORD *)(a1 + 28) + 5);
    if ( (unsigned __int8)result & 0x20 )
    {
      if ( *(_DWORD *)(a1 + 24) )
        v4 = 16;
      else
        v4 = 1;
      v5 = *(_WORD **)a1;
      for ( i = 0; ; ++i )
      {
        result = v5;
        if ( v5[2] <= 0 )
          break;
        result = (_WORD *)i;
        if ( i >= v4 )
          break;
        v2 = (*v5)++;
        v8 = *(_BYTE *)(v2 + *(_DWORD *)(a1 + 4));
        if ( *v5 == v5[3] )
          *v5 = 0;
        v3 = v5[2]--;
        outp(*(_DWORD *)(a1 + 28), v8);
      }
    }
  }
  return result;
}
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);

//----- (0009B7E8) --------------------------------------------------------
int __cdecl sub_9B7E8(int a1)
{
  char v4; // [esp+44h] [ebp-1Ch]

  if ( *(_DWORD *)(a1 + 28) )
  {
    *(_WORD *)(*(_DWORD *)(a1 + 44) + 4) |= 0x10u;
    while ( 1 )
    {
      v4 = inp(*(_DWORD *)(a1 + 28) + 2);
      if ( v4 & 1 )
        break;
      if ( (v4 & 7u) <= 6 )
        JUMPOUT(__CS__, *(&off_9B844 + (v4 & 7)));
    }
  }
  return outp(32, 32);
}
// 9B844: using guessed type void *off_9B844;
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);

//----- (0009BA00) --------------------------------------------------------
void __usercall __noreturn sub_9BA00(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>)
{
  int _0; // [esp+0h] [ebp+0h]

  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, int, int, int, int, int *, int, int, int))_GETDS)(
    (unsigned __int16)__GS__,
    (unsigned __int16)__FS__,
    (unsigned __int16)__ES__,
    (unsigned __int16)__DS__,
    a1,
    a2,
    a3,
    a4,
    &_0,
    a5,
    a6,
    a7);
}

//----- (0009BA2C) --------------------------------------------------------
void __usercall __noreturn sub_9BA2C(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>)
{
  int _0; // [esp+0h] [ebp+0h]

  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, int, int, int, int, int *, int, int, int))_GETDS)(
    (unsigned __int16)__GS__,
    (unsigned __int16)__FS__,
    (unsigned __int16)__ES__,
    (unsigned __int16)__DS__,
    a1,
    a2,
    a3,
    a4,
    &_0,
    a5,
    a6,
    a7);
}

//----- (0009BA58) --------------------------------------------------------
void __usercall __noreturn sub_9BA58(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>)
{
  int _0; // [esp+0h] [ebp+0h]

  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, int, int, int, int, int *, int, int, int))_GETDS)(
    (unsigned __int16)__GS__,
    (unsigned __int16)__FS__,
    (unsigned __int16)__ES__,
    (unsigned __int16)__DS__,
    a1,
    a2,
    a3,
    a4,
    &_0,
    a5,
    a6,
    a7);
}

//----- (0009BA84) --------------------------------------------------------
void __usercall __noreturn sub_9BA84(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>)
{
  int _0; // [esp+0h] [ebp+0h]

  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, int, int, int, int, int *, int, int, int))_GETDS)(
    (unsigned __int16)__GS__,
    (unsigned __int16)__FS__,
    (unsigned __int16)__ES__,
    (unsigned __int16)__DS__,
    a1,
    a2,
    a3,
    a4,
    &_0,
    a5,
    a6,
    a7);
}

//----- (0009BAB0) --------------------------------------------------------
void sub_9BAB0()
{
  ;
}

//----- (0009BAC4) --------------------------------------------------------
int __cdecl sub_9BAC4(int a1, signed int a2)
{
  int v2; // ST50_4

  if ( !*(_DWORD *)(a1 + 28) )
    return 0;
  if ( a2 >= 300 )
  {
    if ( a2 > 115200 )
      a2 = 115200;
  }
  else
  {
    a2 = 300;
  }
  v2 = 115200 / a2;
  sub_AC449();
  outp(*(_DWORD *)(a1 + 28) + 3, 131);
  outp(*(_DWORD *)(a1 + 28) + 1, SBYTE1(v2));
  outp(*(_DWORD *)(a1 + 28), 115200 / a2);
  outp(*(_DWORD *)(a1 + 28) + 3, 3);
  sub_AC44B();
  return 115200 / (115200 / a2);
}
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);

//----- (0009BBFC) --------------------------------------------------------
int __cdecl sub_9BBFC(int a1)
{
  int v2; // [esp+0h] [ebp-1Ch]
  __int16 v3; // [esp+Ch] [ebp-10h]

  if ( *(_DWORD *)(a1 + 4) )
  {
    v2 = 257;
    v3 = *(_WORD *)(a1 + 8);
    int386(49, &v2, &v2);
    sub_9B5B4(*(_DWORD *)(a1 + 4), *(_DWORD *)(*(_DWORD *)a1 + 4) >> 16);
  }
  return memset(a1, 0, 10);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009BC68) --------------------------------------------------------
signed int __cdecl sub_9BC68(_WORD *a1, int a2, unsigned int a3)
{
  int v4; // [esp+0h] [ebp-20h]
  int v5; // [esp+4h] [ebp-1Ch]
  int v6; // [esp+Ch] [ebp-14h]
  int v7; // [esp+18h] [ebp-8h]

  *(_DWORD *)a2 = a1;
  if ( *(_DWORD *)(a2 + 4) )
    goto LABEL_5;
  v4 = 256;
  v5 = (signed int)(a3 + 15) >> 4;
  int386(49, &v4, &v4);
  if ( !v7 )
  {
    *(_DWORD *)(a2 + 4) = 16 * (unsigned __int16)v4;
    *(_WORD *)(a2 + 8) = v6;
    a1[4] = v4;
    sub_9B540(*(_DWORD *)(a2 + 4), a3);
LABEL_5:
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    a1[3] = a3;
    return 1;
  }
  return 0;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009BD28) --------------------------------------------------------
signed int __cdecl sub_9BD28(int a1)
{
  int v2; // [esp+0h] [ebp-28h]
  unsigned int v3; // [esp+4h] [ebp-24h]
  int v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+18h] [ebp-10h]
  unsigned int v7; // [esp+20h] [ebp-8h]
  unsigned int v8; // [esp+24h] [ebp-4h]

  v8 = byte_C0134 - (char *)sub_C0000;
  v2 = 256;
  v3 = (unsigned int)(byte_C0134 - (char *)sub_C0000 + 15) >> 4;
  int386(49, &v2, &v2);
  if ( v5 )
    return 0;
  *(_DWORD *)(a1 + 44) = 16 * (unsigned __int16)v2;
  v7 = *(_DWORD *)(a1 + 44);
  *(_WORD *)(a1 + 48) = v4;
  memcpy(v7, sub_C0000, v8);
  sub_9B540(v7, v8);
  *(_WORD *)(v7 + 2) = *(_WORD *)(a1 + 28);
  *(_WORD *)(v7 + 4) = 0;
  memset(v7 + 6, 0, 10);
  memset(v7 + 16, 0, 10);
  return 1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 99DBD: using guessed type _DWORD __cdecl memcpy(_DWORD, _DWORD, _DWORD);
// C0000: using guessed type int __far sub_C0000();

//----- (0009BE18) --------------------------------------------------------
int __cdecl sub_9BE18(int a1, int a2, char a3, unsigned int a4, unsigned int a5)
{
  char v5; // STFC_1
  int v6; // eax
  __int16 v7; // dx
  char v8; // ST4C_1
  int v10; // [esp+114h] [ebp-30h]
  int v11; // [esp+118h] [ebp-2Ch]
  int v12; // [esp+11Ch] [ebp-28h]
  int v13; // [esp+120h] [ebp-24h]
  int v14; // [esp+130h] [ebp-14h]
  __int64 v15; // [esp+134h] [ebp-10h]
  int v16; // [esp+13Ch] [ebp-8h]
  int v17; // [esp+140h] [ebp-4h]

  sub_9C58C(a1);
  if ( a2 && a2 != 2 )
  {
    if ( a2 != 1 && a2 != 3 )
    {
      *(_DWORD *)(a1 + 28) = 0;
    }
    else
    {
      *(_DWORD *)(a1 + 36) = 11;
      *(_DWORD *)(a1 + 40) = 8;
      *(_DWORD *)(a1 + 28) = *(unsigned __int16 *)(2 * a2 + dword_E3DF8);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 36) = 12;
    *(_DWORD *)(a1 + 40) = 16;
    *(_DWORD *)(a1 + 28) = *(unsigned __int16 *)(2 * a2 + dword_E3DF8);
  }
  if ( *(_DWORD *)(a1 + 28) && !dword_E3DFC[a2] )
  {
    *(_DWORD *)(a1 + 32) = a2;
    dword_E3DFC[a2] = a1;
    if ( sub_9BD28(a1)
      && sub_9BC68((_WORD *)(*(_DWORD *)(a1 + 44) + 16), a1, a4)
      && sub_9BC68((_WORD *)(*(_DWORD *)(a1 + 44) + 6), a1 + 10, a5) )
    {
      sub_AC449();
      v16 = inp(*(_DWORD *)(a1 + 28) + 3);
      *(_DWORD *)(a1 + 66) = v16;
      v16 |= 0x80u;
      outp(*(_DWORD *)(a1 + 28) + 3, v16);
      LODWORD(v15) = inp(*(_DWORD *)(a1 + 28) + 1);
      HIDWORD(v15) = inp(*(_DWORD *)(a1 + 28));
      if ( v15 )
        *(_DWORD *)(a1 + 86) = 115200 / (((_DWORD)v15 << 8) | HIDWORD(v15));
      else
        *(_DWORD *)(a1 + 86) = 1200;
      v16 &= 0xFFFFFF7F;
      outp(*(_DWORD *)(a1 + 28) + 3, v16);
      *(_DWORD *)(a1 + 70) = inp(*(_DWORD *)(a1 + 28) + 4);
      *(_DWORD *)(a1 + 74) = inp(33);
      *(_DWORD *)(a1 + 78) = inp(*(_DWORD *)(a1 + 28) + 1);
      *(_DWORD *)(a1 + 82) = inp(*(_DWORD *)(a1 + 28) + 2);
      v5 = inp(33);
      outp(33, *(_BYTE *)(a1 + 40) | v5);
      outp(*(_DWORD *)(a1 + 28) + 4, 0);
      outp(*(_DWORD *)(a1 + 28) + 1, 0);
      outp(*(_DWORD *)(a1 + 28) + 2, 0);
      v10 = 512;
      v11 = *(_DWORD *)(a1 + 36);
      int386(49, &v10, &v10);
      *(_WORD *)(a1 + 50) = v12;
      *(_WORD *)(a1 + 52) = v13;
      v6 = dos_getvect(*(_DWORD *)(a1 + 36));
      *(_WORD *)(a1 + 64) = v7;
      *(_DWORD *)(a1 + 60) = v6;
      dos_setvect(
        *(_DWORD *)(a1 + 36),
        *(void (__noreturn **)())((char *)&off_E3E10 + 6 * a2),
        (unsigned __int16)seg_E3E14[3 * a2]);
      v10 = 513;
      v11 = *(_DWORD *)(a1 + 36);
      v12 = (*(_DWORD *)(a1 + 44) >> 4) & 0xFFFF;
      v13 = *(_DWORD *)(a1 + 44) & 0xF;
      int386(49, &v10, &v10);
      sub_9B540((unsigned int)sub_9B628, (char *)sub_9BAB0 - (char *)sub_9B628);
      if ( a3 & 1 )
      {
        outp(*(_DWORD *)(a1 + 28) + 2, 193);
        v17 = inp(*(_DWORD *)(a1 + 28) + 2);
        if ( (v17 & 0xF8) == 192 )
        {
          *(_DWORD *)(a1 + 24) = 1;
          *(_WORD *)(*(_DWORD *)(a1 + 44) + 4) |= 8u;
          outp(*(_DWORD *)(a1 + 28) + 2, 65);
        }
        else
        {
          outp(*(_DWORD *)(a1 + 28) + 2, 0);
        }
      }
      outp(*(_DWORD *)(a1 + 28) + 1, 11);
      outp(*(_DWORD *)(a1 + 28) + 4, 11);
      v8 = inp(33);
      outp(33, ~*(_BYTE *)(a1 + 40) & v8);
      inp(*(_DWORD *)(a1 + 28) + 2);
      inp(*(_DWORD *)(a1 + 28));
      inp(*(_DWORD *)(a1 + 28) + 5);
      inp(*(_DWORD *)(a1 + 28) + 6);
      sub_AC44B();
      sub_9CD9C(a1, 1);
      sub_9CCF8(a1, 1);
      v14 = 0;
    }
    else
    {
      sub_9C58C(a1);
      v14 = -2;
    }
  }
  else
  {
    sub_9C58C(a1);
    v14 = -1;
  }
  return v14;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 99BA7: using guessed type _DWORD __cdecl dos_getvect(_DWORD);
// 99BDB: using guessed type _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD);
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);
// E3DF8: using guessed type int dword_E3DF8;
// E3DFC: using guessed type int dword_E3DFC[];
// E3E10: using guessed type void (__noreturn *off_E3E10)();
// E3E14: using guessed type __int16 seg_E3E14[];

//----- (0009C58C) --------------------------------------------------------
int __cdecl sub_9C58C(int a1)
{
  int result; // eax
  char v2; // ST4C_1
  int v3; // [esp+5Ch] [ebp-1Ch]
  char v4; // [esp+60h] [ebp-18h]
  int v5; // [esp+64h] [ebp-14h]
  int v6; // [esp+68h] [ebp-10h]

  result = a1;
  if ( *(_DWORD *)(a1 + 28) )
  {
    sub_AC449();
    if ( *(_DWORD *)(a1 + 60) || *(_WORD *)(a1 + 64) )
      dos_setvect(*(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 60), *(unsigned __int16 *)(a1 + 64));
    sub_9B5B4((unsigned int)sub_9B628, (char *)sub_9BAB0 - (char *)sub_9B628);
    if ( *(_DWORD *)(a1 + 44) )
    {
      v3 = 513;
      v4 = *(_BYTE *)(a1 + 36);
      v5 = *(unsigned __int16 *)(a1 + 50);
      v6 = *(unsigned __int16 *)(a1 + 52);
      int386(49, &v3, &v3);
    }
    if ( *(_WORD *)(a1 + 48) )
    {
      v3 = 257;
      LOWORD(v6) = *(_WORD *)(a1 + 48);
      int386(49, &v3, &v3);
      sub_9B5B4(*(_DWORD *)(a1 + 44), byte_C0134 - (char *)sub_C0000);
    }
    outp(*(_DWORD *)(a1 + 28) + 4, *(_DWORD *)(a1 + 70));
    if ( *(_DWORD *)(a1 + 74) & *(_DWORD *)(a1 + 40) )
    {
      v2 = inp(33);
      outp(33, *(_BYTE *)(a1 + 40) | v2);
    }
    outp(*(_DWORD *)(a1 + 28) + 1, *(_DWORD *)(a1 + 78));
    if ( (*(_DWORD *)(a1 + 82) & 0xF8) != 192 )
    {
      if ( *(_DWORD *)(a1 + 24) )
        outp(*(_DWORD *)(a1 + 28) + 2, 0);
    }
    sub_9BAC4(a1, *(_DWORD *)(a1 + 86));
    outp(*(_DWORD *)(a1 + 28) + 3, *(_DWORD *)(a1 + 66));
    sub_AC44B();
    sub_9BBFC(a1);
    sub_9BBFC(a1 + 10);
    dword_E3DFC[*(_DWORD *)(a1 + 32)] = 0;
    result = memset(a1, 0, 90);
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 99BDB: using guessed type _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD);
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);
// C0000: using guessed type int __far sub_C0000();
// E3DFC: using guessed type int dword_E3DFC[];

//----- (0009C810) --------------------------------------------------------
signed int __cdecl sub_9C810(_DWORD *a1, char a2)
{
  __int16 v2; // dx
  __int16 v3; // t1
  _WORD *v5; // [esp+0h] [ebp-8h]

  if ( !a1[7] )
    return 1;
  v5 = (_WORD *)*a1;
  if ( *(_WORD *)(*a1 + 4) != *(_WORD *)(*a1 + 6) )
  {
    sub_AC449();
    v2 = v5[1]++;
    *(_BYTE *)(a1[1] + v2) = a2;
    if ( v5[1] == v5[3] )
      v5[1] = 0;
    v3 = v5[2]++;
    sub_9B688((int)a1);
    sub_AC44B();
    return 1;
  }
  return 0;
}

//----- (0009C938) --------------------------------------------------------
signed int __cdecl sub_9C938(_DWORD *a1)
{
  __int16 v1; // dx
  __int16 v2; // t1
  _WORD *v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]

  if ( !a1[7] )
    return -1;
  v5 = *(_WORD **)((char *)a1 + 10);
  if ( v5[2] <= 0 )
    return -1;
  sub_AC449();
  v1 = (*v5)++;
  v6 = *(unsigned __int8 *)(*(_DWORD *)((char *)a1 + 14) + v1);
  if ( *v5 == v5[3] )
    *v5 = 0;
  v2 = v5[2]--;
  sub_AC44B();
  return v6;
}

//----- (0009C9D0) --------------------------------------------------------
bool __cdecl sub_9C9D0(int a1)
{
  bool v2; // [esp+4h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 28) )
    v2 = *(_WORD *)(*(_DWORD *)(a1 + 10) + 4) == 0;
  else
    v2 = 1;
  return v2;
}

//----- (0009CBBC) --------------------------------------------------------
void __cdecl sub_9CBBC(_DWORD *a1)
{
  if ( a1[7] )
  {
    sub_AC449();
    *(_WORD *)(*a1 + 4) = 0;
    *(_WORD *)*a1 = 0;
    *(_WORD *)(*a1 + 2) = 0;
    *(_WORD *)(*(_DWORD *)((char *)a1 + 10) + 4) = 0;
    **(_WORD **)((char *)a1 + 10) = 0;
    *(_WORD *)(*(_DWORD *)((char *)a1 + 10) + 2) = 0;
    *(_WORD *)(a1[11] + 4) &= 0xFFFDu;
    inp(a1[7] + 5);
    inp(a1[7] + 6);
    inp(a1[7] + 2);
    inp(a1[7]);
    sub_AC44B();
  }
}
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);

//----- (0009CCB4) --------------------------------------------------------
int __cdecl sub_9CCB4(int a1, int a2)
{
  int result; // eax

  if ( a2 )
  {
    *(_DWORD *)(a1 + 20) = 1;
    result = *(_DWORD *)(a1 + 44);
    *(_WORD *)(result + 4) |= 1u;
  }
  else
  {
    *(_DWORD *)(a1 + 20) = 0;
    result = *(_DWORD *)(a1 + 44);
    *(_WORD *)(result + 4) &= 0xFFFEu;
  }
  return result;
}

//----- (0009CCF8) --------------------------------------------------------
int __cdecl sub_9CCF8(int a1, int a2)
{
  int result; // eax
  int v3; // ST18_4
  char v4; // al
  int v5; // ST08_4
  char v6; // al

  result = a1;
  if ( *(_DWORD *)(a1 + 28) )
  {
    if ( a2 )
    {
      v3 = *(_DWORD *)(a1 + 28) + 4;
      v4 = sub_9B63C(v3) | 1;
      result = outp(v3, v4);
    }
    else
    {
      v5 = *(_DWORD *)(a1 + 28) + 4;
      v6 = sub_9B63C(v5) & 0xFE;
      result = outp(v5, v6);
    }
  }
  return result;
}
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);

//----- (0009CD9C) --------------------------------------------------------
int __cdecl sub_9CD9C(int a1, int a2)
{
  int result; // eax
  int v3; // ST18_4
  char v4; // al
  int v5; // ST08_4
  char v6; // al

  result = a1;
  if ( *(_DWORD *)(a1 + 28) )
  {
    if ( a2 )
    {
      v3 = *(_DWORD *)(a1 + 28) + 4;
      v4 = sub_9B63C(v3) | 2;
      result = outp(v3, v4);
    }
    else
    {
      v5 = *(_DWORD *)(a1 + 28) + 4;
      v6 = sub_9B63C(v5) & 0xFD;
      result = outp(v5, v6);
    }
  }
  return result;
}
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);

//----- (0009D31C) --------------------------------------------------------
__int16 __fastcall sub_9D31C(__int16 result)
{
  _BOOL1 v1; // zf

  __asm { int     16h; KEYBOARD - GET ENHANCED SHIFT FLAGS (AT model 339,XT2,XT286,PS) }
  byte_1806E5 = 0;
  if ( result & 3 )
    byte_1806E5 = 1;
  if ( result & 4 )
    byte_1806E5 |= 2u;
  v1 = (result & 8) == 0;
  if ( result & 8 )
  {
    v1 = ((unsigned __int8)byte_1806E5 | 4) == 0;
    byte_1806E5 |= 4u;
  }
  byte_1806E4 = 0;
  __asm { int     16h; KEYBOARD - CHECK ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS) }
  if ( !v1 )
  {
    __asm { int     16h; KEYBOARD - GET ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS) }
    byte_1806E4 = 16;
  }
  return result;
}
// 1806E4: using guessed type char byte_1806E4;
// 1806E5: using guessed type char byte_1806E5;

//----- (0009D380) --------------------------------------------------------
int __cdecl sub_9D380(int a1, int a2, char a3, int a4, int a5)
{
  if ( a3 & 1 )
  {
    memcpy(a4, a2 + a1, a5);
  }
  else
  {
    lseek(a1, a2, 0);
    read(a1, a4, a5);
  }
  return a5 + a2;
}
// 99DBD: using guessed type _DWORD __cdecl memcpy(_DWORD, _DWORD, _DWORD);
// A0863: using guessed type _DWORD __cdecl read(_DWORD, _DWORD, _DWORD);
// AA7C0: using guessed type _DWORD __cdecl lseek(_DWORD, _DWORD, char);

//----- (0009D3F0) --------------------------------------------------------
int (__cdecl *__cdecl sub_9D3F0(int (__cdecl *a1)(int)))(int)
{
  int (__cdecl *v1)(_DWORD); // ST04_4

  v1 = off_E3E30;
  off_E3E30 = a1;
  return v1;
}
// E3E30: using guessed type int (__cdecl *off_E3E30)(_DWORD);

//----- (0009D420) --------------------------------------------------------
int (__cdecl *__cdecl sub_9D420(int (__cdecl *a1)(int)))(int)
{
  int (__cdecl *v1)(int); // ST04_4

  v1 = off_E3E34;
  off_E3E34 = a1;
  return v1;
}
// E3E34: using guessed type int (__cdecl *off_E3E34)(int);

//----- (0009D450) --------------------------------------------------------
unsigned int __cdecl sub_9D450(int a1)
{
  unsigned int v2; // [esp+4h] [ebp-4h]

  v2 = off_E3E30(a1);
  if ( v2 )
    sub_9D710(v2, a1);
  return v2;
}
// E3E30: invalid function type has been ignored
// E3E30: using guessed type int (__cdecl *off_E3E30)(_DWORD);

//----- (0009D490) --------------------------------------------------------
int __cdecl sub_9D490(unsigned int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    sub_9D740(a1, a2);
    result = off_E3E34(a1);
  }
  return result;
}
// E3E34: using guessed type int (__cdecl *off_E3E34)(int);

//----- (0009D4D0) --------------------------------------------------------
signed int __cdecl sub_9D4D0(int a1, unsigned int *a2, _DWORD *a3, _DWORD *a4)
{
  unsigned int v6; // [esp+Ch] [ebp-4h]

  v6 = sub_83D70(16 * a1);
  if ( !v6 )
    return 0;
  *a3 = v6 >> 4 << 16;
  *a2 = v6;
  *a4 = 1232;
  sub_9D590(*a3 >> 12, (*a3 >> 12) + 16 * a1 - 1);
  return 1;
}

//----- (0009D560) --------------------------------------------------------
void __cdecl sub_9D560(int a1)
{
  sub_83E80(a1);
}

//----- (0009D590) --------------------------------------------------------
bool __cdecl sub_9D590(unsigned int a1, unsigned int a2)
{
  unsigned int v3; // [esp+0h] [ebp-54h]
  unsigned int v4; // [esp+4h] [ebp-50h]
  int v5; // [esp+Ch] [ebp-48h]
  unsigned int v6; // [esp+10h] [ebp-44h]
  int v7; // [esp+14h] [ebp-40h]
  unsigned int v8; // [esp+1Ch] [ebp-38h]
  int v9; // [esp+20h] [ebp-34h]
  char v10; // [esp+28h] [ebp-2Ch]
  int v11; // [esp+40h] [ebp-14h]
  unsigned int v12; // [esp+48h] [ebp-Ch]
  unsigned int v13; // [esp+4Ch] [ebp-8h]
  int v14; // [esp+50h] [ebp-4h]

  v14 = 0;
  if ( a1 >= a2 )
    v3 = a2;
  else
    v3 = a1;
  v13 = v3;
  if ( a1 < a2 )
    v4 = a2;
  else
    v4 = a1;
  v12 = v4 - v13 + 1;
  v5 = 1536;
  v6 = v13 >> 16;
  v7 = (unsigned __int16)v13;
  v8 = v12 >> 16;
  v9 = (unsigned __int16)(v4 - v13 + 1);
  int386(49, &v5, &v10);
  return v11 == 0;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009D650) --------------------------------------------------------
bool __cdecl sub_9D650(unsigned int a1, unsigned int a2)
{
  unsigned int v3; // [esp+0h] [ebp-54h]
  unsigned int v4; // [esp+4h] [ebp-50h]
  int v5; // [esp+Ch] [ebp-48h]
  unsigned int v6; // [esp+10h] [ebp-44h]
  int v7; // [esp+14h] [ebp-40h]
  unsigned int v8; // [esp+1Ch] [ebp-38h]
  int v9; // [esp+20h] [ebp-34h]
  char v10; // [esp+28h] [ebp-2Ch]
  int v11; // [esp+40h] [ebp-14h]
  unsigned int v12; // [esp+48h] [ebp-Ch]
  unsigned int v13; // [esp+4Ch] [ebp-8h]
  int v14; // [esp+50h] [ebp-4h]

  v14 = 0;
  if ( a1 >= a2 )
    v3 = a2;
  else
    v3 = a1;
  v13 = v3;
  if ( a1 < a2 )
    v4 = a2;
  else
    v4 = a1;
  v12 = v4 - v13 + 1;
  v5 = 1537;
  v6 = v13 >> 16;
  v7 = (unsigned __int16)v13;
  v8 = v12 >> 16;
  v9 = (unsigned __int16)(v4 - v13 + 1);
  int386(49, &v5, &v10);
  return v11 == 0;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009D710) --------------------------------------------------------
bool __cdecl sub_9D710(unsigned int a1, int a2)
{
  return sub_9D590(a1, a2 + a1);
}

//----- (0009D740) --------------------------------------------------------
bool __cdecl sub_9D740(unsigned int a1, int a2)
{
  return sub_9D650(a1, a2 + a1);
}

//----- (0009D770) --------------------------------------------------------
int __cdecl sub_9D770(int a1, char a2)
{
  char v3; // [esp+0h] [ebp-E0h]
  int v4; // [esp+40h] [ebp-A0h]
  unsigned int v5; // [esp+44h] [ebp-9Ch]
  int v6; // [esp+ACh] [ebp-34h]
  int v7; // [esp+C4h] [ebp-1Ch]
  int v8; // [esp+C8h] [ebp-18h]
  unsigned int i; // [esp+CCh] [ebp-14h]
  int v10; // [esp+D0h] [ebp-10h]
  int v11; // [esp+D4h] [ebp-Ch]
  int v12; // [esp+D8h] [ebp-8h]
  int v13; // [esp+DCh] [ebp-4h]

  v13 = 8224;
  v7 = 0;
  if ( a2 & 1 )
  {
    v10 = a1;
  }
  else
  {
    v10 = open(a1, 512);
    if ( v10 == -1 )
      return 0;
  }
  v12 = sub_9D380(v10, 60, a2, (int)&v8, 4);
  v12 = sub_9D380(v10, v8, a2, (int)&v13, 2);
  if ( !strcmp(&v13, aLx) )
  {
    sub_9D380(v10, v8, a2, (int)&v3, 172);
    v12 = v4 + v8;
    for ( i = 0; i < v5; ++i )
    {
      v12 = sub_9D380(v10, v12, a2, (int)&v6, 24);
      v7 += v6;
    }
    if ( !(a2 & 1) )
      close(v10);
    v7 += 15 * v5;
    v11 = v7;
  }
  else
  {
    close(v10);
    v11 = 0;
  }
  return v11;
}
// 9A050: using guessed type _DWORD __cdecl strcmp(_DWORD, _DWORD);
// A0855: using guessed type _DWORD __cdecl close(_DWORD);

//----- (0009DE20) --------------------------------------------------------
signed int __cdecl sub_9DE20(int a1)
{
  signed int v2; // [esp+0h] [ebp-Ch]
  signed int v3; // [esp+4h] [ebp-8h]
  int v4; // [esp+8h] [ebp-4h]

  dword_E3E2C = 0;
  v4 = open(a1, 512);
  if ( v4 == -1 )
  {
    dword_E3E2C = 3;
    v2 = -1;
  }
  else
  {
    v3 = filelength(v4);
    if ( v3 == -1 )
      dword_E3E2C = 5;
    close(v4);
    v2 = v3;
  }
  return v2;
}
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// A0855: using guessed type _DWORD __cdecl close(_DWORD);
// E3E2C: using guessed type int dword_E3E2C;

//----- (0009DEA0) --------------------------------------------------------
int __cdecl sub_9DEA0(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-1Ch]
  int v4; // [esp+4h] [ebp-18h]
  signed int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]

  dword_E3E2C = 0;
  v5 = sub_9DE20(a1);
  if ( v5 == -1 )
  {
    dword_E3E2C = 3;
    v4 = 0;
  }
  else
  {
    if ( a2 )
      v3 = a2;
    else
      v3 = off_E3E30(v5);
    if ( v3 )
    {
      v6 = open(a1, 512);
      if ( v6 == -1 )
      {
        off_E3E34(v3);
        dword_E3E2C = 3;
        v4 = 0;
      }
      else if ( read(v6, v3, v5) == v5 )
      {
        close(v6);
        v4 = v3;
      }
      else
      {
        off_E3E34(v3);
        dword_E3E2C = 5;
        v4 = 0;
      }
    }
    else
    {
      dword_E3E2C = 2;
      v4 = 0;
    }
  }
  return v4;
}
// A0855: using guessed type _DWORD __cdecl close(_DWORD);
// A0863: using guessed type _DWORD __cdecl read(_DWORD, _DWORD, _DWORD);
// E3E2C: using guessed type int dword_E3E2C;
// E3E30: using guessed type int (__cdecl *off_E3E30)(_DWORD);
// E3E34: using guessed type int (__cdecl *off_E3E34)(int);

//----- (0009E1B0) --------------------------------------------------------
bool sub_9E1B0()
{
  bool result; // eax

  if ( !dword_E3E3C )
  {
    sub_9D590((unsigned int)sub_9E1B0, (unsigned int)sub_9EDD0);
    sub_9D710((unsigned int)dword_181C50, 64);
    sub_9D710((unsigned int)dword_181DAC, 76);
    sub_9D710((unsigned int)&byte_181C90, 256);
    sub_9D710((unsigned int)&unk_181D90, 24);
    sub_9D710((unsigned int)&dword_E3E38, 4);
    result = sub_9D710((unsigned int)&dword_181DA8, 4);
    dword_E3E3C = 1;
  }
  return result;
}
// E3E38: using guessed type int dword_E3E38;
// E3E3C: using guessed type int dword_E3E3C;
// 181C90: using guessed type char byte_181C90;
// 181DA8: using guessed type int dword_181DA8;
// 181DAC: using guessed type int dword_181DAC[];

//----- (0009E2B0) --------------------------------------------------------
int __cdecl sub_9E2B0(int a1, int a2, _DWORD *a3)
{
  int v3; // ebx
  int v5; // [esp+4h] [ebp-10h]
  int v6; // [esp+8h] [ebp-Ch]
  int j; // [esp+Ch] [ebp-8h]
  unsigned int i; // [esp+10h] [ebp-4h]

  v6 = 0;
  v5 = 1;
  for ( i = 0; strlen(a1) > i; ++i )
  {
    if ( *(_BYTE *)(i + a1) == 45 )
    {
      v5 = -v5;
    }
    else if ( !(IsTable[(unsigned __int8)(*(_BYTE *)(i + a1) + 1)] & 2) )
    {
      for ( j = 0; j < a2; ++j )
      {
        v3 = (unsigned __int8)byte_D3450[j];
        if ( toupper(*(unsigned __int8 *)(i + a1)) == v3 )
        {
          v6 = a2 * v6 + j;
          break;
        }
      }
      if ( j == a2 )
        break;
    }
  }
  if ( a3 )
    *a3 = i + a1;
  return v5 * v6;
}
// 98805: using guessed type _DWORD __cdecl toupper(_DWORD);
// 99D6B: using guessed type _DWORD __cdecl strlen(_DWORD);

//----- (0009E3A0) --------------------------------------------------------
int __cdecl sub_9E3A0(char *a1, int a2)
{
  unsigned int v2; // eax
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // eax
  char v7; // [esp+0h] [ebp-180h]
  char v8; // [esp+80h] [ebp-100h]
  __int16 v9; // [esp+100h] [ebp-80h]
  __int16 v10; // [esp+102h] [ebp-7Eh]
  __int16 v11; // [esp+104h] [ebp-7Ch]
  __int16 v12; // [esp+106h] [ebp-7Ah]
  char v13[80]; // [esp+118h] [ebp-68h]
  char *v14; // [esp+168h] [ebp-18h]
  char *v15; // [esp+16Ch] [ebp-14h]
  char *v16; // [esp+170h] [ebp-10h]
  unsigned int i; // [esp+174h] [ebp-Ch]
  int v18; // [esp+178h] [ebp-8h]
  int v19; // [esp+17Ch] [ebp-4h]

  memset(&v7, 0, 280);
  memset(&v9, -1, 24);
  v19 = fopen(a2, &aRt[1]);
  if ( !v19 )
    return 0;
  while ( fgets(v13, 80, v19) && !(*(_BYTE *)(v19 + 12) & 0x10) )
  {
    for ( i = strlen(v13) - 1; (i & 0x80000000) == 0 && IsTable[(unsigned __int8)(v13[i] + 1)] & 2; --i )
      v13[i] = 0;
    for ( i = 0; ; ++i )
    {
      v2 = strlen(v13);
      if ( v2 <= i || !(IsTable[(unsigned __int8)(v13[i] + 1)] & 2) )
        break;
    }
    v15 = &v13[i];
    while ( 1 )
    {
      v3 = strlen(v13);
      if ( v3 <= i || IsTable[(unsigned __int8)(v13[i] + 1)] & 2 )
        break;
      ++i;
    }
    v14 = &v13[i];
    while ( 1 )
    {
      v4 = strlen(v13);
      if ( v4 <= i || !(IsTable[(unsigned __int8)(v13[i] + 1)] & 2) )
        break;
      ++i;
    }
    v16 = &v13[i];
    v5 = strlen(v13);
    if ( v5 > i )
    {
      *v14 = 0;
      if ( *v15 != 59 )
      {
        if ( !strnicmp(v15, aDriver, 7) )
        {
          strcpy(&v8, v16);
        }
        else if ( !strnicmp(v15, aDevice, 7) )
        {
          strcpy(&v7, v16);
        }
        else if ( !strnicmp(v15, aIoAddr, 8) )
        {
          v9 = sub_9E2B0((int)v16, 16, 0);
        }
        else if ( !strnicmp(v15, aIrq, 4) )
        {
          v10 = sub_9E2B0((int)v16, 10, 0);
        }
        else if ( !strnicmp(v15, aDma8Bit, 10) )
        {
          v11 = sub_9E2B0((int)v16, 10, 0);
        }
        else if ( !strnicmp(v15, aDma16Bit, 11) )
        {
          v12 = sub_9E2B0((int)v16, 10, 0);
        }
      }
    }
  }
  fclose(v19);
  if ( strlen(&v8) && strlen(&v7) )
  {
    qmemcpy(a1, &v7, 0x118u);
    v18 = 1;
  }
  else
  {
    qmemcpy(&byte_181C90, aCorruptedIniFi, 0x15u);
    v18 = 0;
  }
  return v18;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99B23: using guessed type _DWORD __cdecl strnicmp(_DWORD, _DWORD, _DWORD);
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// 99D6B: using guessed type _DWORD __cdecl strlen(_DWORD);
// A1AF0: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// A1E05: using guessed type _DWORD __cdecl fclose(_DWORD);
// AD7AA: using guessed type _DWORD __cdecl fgets(_DWORD, _DWORD, _DWORD);
// 181C90: using guessed type char byte_181C90;
// 9E3A0: using guessed type char var_68[80];

//----- (0009E6E0) --------------------------------------------------------
int __cdecl sub_9E6E0(int a1, int a2)
{
  int v2; // ST04_4

  v2 = dword_181DAC[a1];
  dword_181DAC[a1] = a2;
  return v2;
}
// 181DAC: using guessed type int dword_181DAC[];

//----- (0009E720) --------------------------------------------------------
_DWORD *__usercall sub_9E720@<eax>(int a1@<ebx>, int a2, int a3)
{
  int v3; // edx
  int v4; // ecx
  int v5; // ST0C_4
  int v6; // ST08_4
  int v7; // ST0C_4
  int v8; // ST08_4
  int v9; // ST0C_4
  int v10; // ST08_4
  int v12; // [esp+0h] [ebp-Ch]
  unsigned int i; // [esp+4h] [ebp-8h]
  _DWORD *v14; // [esp+8h] [ebp-4h]

  v14 = (_DWORD *)sub_9D450(44);
  if ( v14 )
  {
    v14[3] = a3;
    if ( sub_9D4D0((unsigned int)(a3 + 15) >> 4, v14 + 2, v14, v14 + 1) )
    {
      memmove(v14[2], a2, a3);
      v14[4] = v14[2];
      if ( !strnicmp(v14[4], aAil3dig, 7) )
      {
        v14[5] = 0;
      }
      else
      {
        if ( strnicmp(v14[4], aAil3mdi, 7) )
        {
          qmemcpy(&byte_181C90, aInvalidDriverT, 0x15u);
          v5 = v14[1];
          v6 = *v14;
          sub_9D560(v14[2]);
          sub_9D490((unsigned int)v14, 44);
          return 0;
        }
        v14[5] = 1;
      }
      for ( i = 0; i < 0x10; ++i )
      {
        if ( !dword_181C50[i] )
        {
          dword_181C50[i] = (int)v14;
          v3 = v14[4];
          *(_WORD *)(v3 + 50) = i;
          break;
        }
      }
      if ( i != 16 )
      {
        *(_WORD *)(v14[4] + 48) = 0;
        v14[6] = 0;
        v14[7] = -1;
        *(_DWORD *)(v14[4] + 54) = sub_91C10(v3, v4, a1, 102);
        sub_91D50(102, *v14 + *(unsigned __int16 *)(v14[4] + 52));
        v14[9] = 0;
        v14[10] = 0;
        sub_91F70((int)v14, 768, 0, 0);
        if ( *(_WORD *)(v14[4] + 46) > 0 )
        {
          v14[8] = sub_92600((int)sub_9E250);
          if ( v14[8] == -1 )
          {
            qmemcpy(&byte_181C90, aOutOfTimerHand, 0x16u);
            sub_91D50(102, *(_DWORD *)(v14[4] + 54));
            v9 = v14[1];
            v10 = *v14;
            sub_9D560(v14[2]);
            sub_9D490((unsigned int)v14, 44);
            return 0;
          }
          sub_92740(v14[8], (signed __int32)v14);
          sub_92930(v14[8], *(signed __int16 *)(v14[4] + 46));
          sub_92BA0(v14[8]);
        }
        else
        {
          v14[8] = -1;
        }
        return v14;
      }
      qmemcpy(&byte_181C90, aOutOfDriverHan, 0x17u);
      v7 = v14[1];
      v8 = *v14;
      sub_9D560(v14[2]);
      sub_9D490((unsigned int)v14, 44);
      v12 = 0;
    }
    else
    {
      qmemcpy(&byte_181C90, aInsufficientLo, 0x19u);
      sub_9D490((unsigned int)v14, 44);
      v12 = 0;
    }
  }
  else
  {
    strcpy(&byte_181C90, "Insufficient memory for driver descriptor\n");
    v12 = 0;
  }
  return (_DWORD *)v12;
}
// 99B23: using guessed type _DWORD __cdecl strnicmp(_DWORD, _DWORD, _DWORD);
// 9E250: using guessed type int sub_9E250();
// AD81F: using guessed type _DWORD __cdecl memmove(_DWORD, _DWORD, _DWORD);
// 181C90: using guessed type char byte_181C90;

//----- (0009EA60) --------------------------------------------------------
int __cdecl sub_9EA60(unsigned int a1)
{
  int v1; // ST0C_4
  int v2; // ST08_4
  int result; // eax
  signed int i; // [esp+0h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 36) )
    (*(void (__cdecl **)(_DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40));
  if ( *(_DWORD *)(a1 + 32) != -1 )
    sub_92DC0(*(_DWORD *)(a1 + 32));
  if ( *(_DWORD *)(a1 + 24) )
  {
    if ( *(_DWORD *)(a1 + 28) != -1 )
      sub_91E90(*(_DWORD *)(a1 + 28));
    sub_91F70(a1, 774, 0, 0);
  }
  sub_91D50(102, *(_DWORD *)(*(_DWORD *)(a1 + 16) + 54));
  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)a1;
  sub_9D560(*(_DWORD *)(a1 + 8));
  result = sub_9D490(a1, 44);
  for ( i = 0; i < 16; ++i )
  {
    if ( dword_181C50[i] == a1 )
      dword_181C50[i] = 0;
    result = i;
  }
  return result;
}

//----- (0009EB60) --------------------------------------------------------
void *__cdecl sub_9EB60(int a1)
{
  int v3; // [esp+4h] [ebp-8h]
  int v4; // [esp+8h] [ebp-4h]

  v4 = (*(_DWORD *)(*(_DWORD *)(a1 + 16) + 18) & 0xFFFF) + 16 * (*(_DWORD *)(*(_DWORD *)(a1 + 16) + 18) >> 16);
  if ( !v4 )
    return 0;
  v3 = getenv(v4);
  if ( !v3 )
    return 0;
  strncpy(*(_DWORD *)(a1 + 16) + 58, v3, 128);
  if ( sub_91F70(a1, 771, 0, 0) == -1 )
    return 0;
  qmemcpy(&unk_181DF8, (const void *)(*(_DWORD *)(a1 + 16) + 22), 0x18u);
  return &unk_181DF8;
}
// 99E33: using guessed type _DWORD __cdecl getenv(_DWORD);
// AD871: using guessed type _DWORD __cdecl strncpy(_DWORD, _DWORD, _DWORD);

//----- (0009EC30) --------------------------------------------------------
void sub_9EC30()
{
  signed int i; // [esp+0h] [ebp-4h]

  sub_9E1B0();
  sub_91A80(0, 200);
  sub_91A80(1, 1);
  sub_91A80(2, 0x8000);
  sub_91A80(3, 100);
  sub_91A80(4, 16);
  sub_91A80(5, 100);
  sub_91A80(6, 655);
  sub_91A80(7, 0);
  sub_91A80(8, 0);
  sub_91A80(9, 1);
  sub_91A80(10, 0);
  sub_91A80(11, 120);
  sub_91A80(12, 8);
  sub_91A80(13, 127);
  sub_91A80(14, 1);
  sub_91A80(15, 0);
  sub_91A80(16, 2);
  sub_91A80(17, 1);
  sub_91A80(18, 1);
  for ( i = 0; i < 16; ++i )
    dword_181C50[i] = 0;
  byte_181C90 = 0;
  sub_A10F4();
}
// 181C90: using guessed type char byte_181C90;

//----- (0009ED70) --------------------------------------------------------
signed int sub_9ED70()
{
  signed int i; // [esp+0h] [ebp-8h]
  unsigned int v2; // [esp+4h] [ebp-4h]

  for ( i = 15; i >= 0; --i )
  {
    v2 = dword_181C50[i];
    if ( v2 )
      sub_93160(v2);
  }
  sub_92E50();
  return sub_A11E2();
}

//----- (0009EDD0) --------------------------------------------------------
bool sub_9EDD0()
{
  bool result; // eax

  if ( dword_E3E3C )
  {
    sub_9D650((unsigned int)sub_9E1B0, (unsigned int)sub_9EDD0);
    sub_9D740((unsigned int)dword_181C50, 64);
    sub_9D740((unsigned int)dword_181DAC, 76);
    sub_9D740((unsigned int)&byte_181C90, 256);
    sub_9D740((unsigned int)&unk_181D90, 24);
    sub_9D740((unsigned int)&dword_E3E38, 4);
    result = sub_9D740((unsigned int)&dword_181DA8, 4);
    dword_E3E3C = 0;
  }
  return result;
}
// E3E38: using guessed type int dword_E3E38;
// E3E3C: using guessed type int dword_E3E3C;
// 181C90: using guessed type char byte_181C90;
// 181DA8: using guessed type int dword_181DA8;
// 181DAC: using guessed type int dword_181DAC[];

//----- (0009EE70) --------------------------------------------------------
int sub_9EE70()
{
  int v0; // eax

  if ( !byte_E3E45 && sub_95480(dword_181E10, dword_E3E40) && (unsigned int)dword_E3E40 < 8 )
  {
    sub_93830((_DWORD *)dword_181E10);
    sub_95140(dword_181E10, (int)sub_9EE70);
    v0 = sub_95480(dword_181E10, dword_E3E40);
    sub_938C0((_DWORD *)dword_181E10, *(_DWORD *)(dword_E37A0 + 32 * v0 + 18), 1);
    ++dword_E3E40;
    sub_93B50((int *)dword_181E10);
  }
  return 0;
}
// 9EE70: using guessed type int sub_9EE70();
// E37A0: using guessed type int dword_E37A0;
// E3E40: using guessed type int dword_E3E40;
// E3E45: using guessed type char byte_E3E45;
// 181E10: using guessed type int dword_181E10;

//----- (0009F040) --------------------------------------------------------
int sub_9F040()
{
  int result; // eax

  if ( byte_E3E44 )
  {
    byte_E3E45 = 1;
    sub_93D00(dword_181E10);
    sub_953E0(dword_181E10, 0, 0);
    sub_953E0(dword_181E10, 1, 0);
    sub_953E0(dword_181E10, 2, 0);
    sub_953E0(dword_181E10, 3, 0);
    sub_953E0(dword_181E10, 4, 0);
    sub_953E0(dword_181E10, 5, 0);
    sub_953E0(dword_181E10, 6, 0);
    result = sub_953E0(dword_181E10, 7, 0);
  }
  return result;
}
// E3E44: using guessed type char byte_E3E44;
// E3E45: using guessed type char byte_E3E45;
// 181E10: using guessed type int dword_181E10;

//----- (0009F110) --------------------------------------------------------
signed __int64 __cdecl sub_9F110(int a1)
{
  int v2; // [esp+0h] [ebp-24h]
  int v3; // [esp+4h] [ebp-20h]
  int v4; // [esp+Ch] [ebp-18h]
  int v5; // [esp+18h] [ebp-Ch]
  unsigned int v6; // [esp+20h] [ebp-4h]

  v2 = 256;
  v3 = (a1 + 15) >> 4;
  int386(49, &v2, &v2);
  if ( v5 )
    LOWORD(v6) = 0;
  else
    LOWORD(v6) = v4;
  return __PAIR__(v6, 0);
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009F170) --------------------------------------------------------
int __cdecl sub_9F170(int a1, unsigned __int16 a2)
{
  int v3; // [esp+0h] [ebp-20h]
  int v4; // [esp+Ch] [ebp-14h]
  int v5; // [esp+18h] [ebp-8h]
  int v6; // [esp+1Ch] [ebp-4h]

  v3 = 257;
  v4 = a2;
  int386(49, &v3, &v3);
  if ( v5 )
    v6 = -1;
  else
    v6 = 0;
  return v6;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009F1D0) --------------------------------------------------------
int __cdecl sub_9F1D0(int a1)
{
  int v2; // [esp+0h] [ebp-20h]
  int v3; // [esp+4h] [ebp-1Ch]
  int v4; // [esp+18h] [ebp-8h]
  int v5; // [esp+1Ch] [ebp-4h]

  v2 = 2;
  v3 = a1;
  int386(49, &v2, &v2);
  if ( v4 )
    v5 = -1;
  else
    v5 = (unsigned __int16)v2;
  return v5;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009F220) --------------------------------------------------------
int __cdecl sub_9F220(int a1)
{
  int v2; // [esp+0h] [ebp-20h]
  int v3; // [esp+4h] [ebp-1Ch]
  unsigned __int16 v4; // [esp+8h] [ebp-18h]
  unsigned __int16 v5; // [esp+Ch] [ebp-14h]
  int v6; // [esp+18h] [ebp-8h]
  int v7; // [esp+1Ch] [ebp-4h]

  v2 = 6;
  v3 = a1;
  int386(49, &v2, &v2);
  if ( v6 )
    v7 = -1;
  else
    v7 = ((signed int)v5 >> 4) + (v4 << 12);
  return v7;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009F280) --------------------------------------------------------
int __cdecl sub_9F280(int *a1)
{
  __int16 v2; // [esp+0h] [ebp-10h]
  __int16 v3; // [esp+4h] [ebp-Ch]
  __int16 v4; // [esp+6h] [ebp-Ah]
  __int16 v5; // [esp+8h] [ebp-8h]
  int v6; // [esp+Ch] [ebp-4h]

  v3 = 16;
  sub_91F70(*a1, 1286, &v2, &v2);
  if ( v2 )
    v6 = -1;
  else
    v6 = v4 << (v5 + 16);
  return v6;
}

//----- (0009F2E0) --------------------------------------------------------
signed int __cdecl sub_9F2E0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  signed __int64 v4; // rax
  unsigned __int16 v5; // ax
  __int16 v7; // [esp+0h] [ebp-10h]
  __int16 v8; // [esp+4h] [ebp-Ch]
  __int16 v9; // [esp+6h] [ebp-Ah]
  __int16 v10; // [esp+8h] [ebp-8h]

  if ( !*(_DWORD *)byte_E3E54 && !*(_WORD *)&byte_E3E54[4] )
  {
    v4 = sub_9F110(4);
    *(_WORD *)&byte_E3E54[4] = WORD2(v4);
    *(_DWORD *)byte_E3E54 = v4;
    if ( !(_DWORD)v4 && !*(_WORD *)&byte_E3E54[4] )
      return -1;
  }
  __GS__ = *(_WORD *)&byte_E3E54[4];
  __writegsword(*(unsigned int *)byte_E3E54, a4);
  v5 = sub_9F220(a3);
  __GS__ = *(_WORD *)&byte_E3E54[4];
  __writegsword(*(_DWORD *)byte_E3E54 + 2, v5);
  v8 = 17;
  v9 = sub_9F220(*(unsigned __int16 *)&byte_E3E54[4]);
  v10 = 0;
  sub_91F70(*a1, 1286, &v7, &v7);
  return v7;
}

//----- (0009F3D0) --------------------------------------------------------
__int64 __cdecl sub_9F3D0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  signed __int64 v4; // rax
  unsigned __int16 v5; // ax
  int v6; // ebx
  __int16 v8; // [esp+0h] [ebp-14h]
  __int16 v9; // [esp+4h] [ebp-10h]
  __int16 v10; // [esp+6h] [ebp-Eh]
  __int16 v11; // [esp+8h] [ebp-Ch]
  __int64 v12; // [esp+Ch] [ebp-8h]

  if ( *(_DWORD *)byte_E3E54
    || *(_WORD *)&byte_E3E54[4]
    || (v4 = sub_9F110(4), *(_WORD *)&byte_E3E54[4] = WORD2(v4), (*(_DWORD *)byte_E3E54 = v4) != 0)
    || *(_WORD *)&byte_E3E54[4] )
  {
    __GS__ = *(_WORD *)&byte_E3E54[4];
    __writegsword(*(unsigned int *)byte_E3E54, a4);
    v5 = sub_9F220(a3);
    __GS__ = *(_WORD *)&byte_E3E54[4];
    __writegsword(*(_DWORD *)byte_E3E54 + 2, v5);
    v9 = 23;
    v10 = sub_9F220(*(unsigned __int16 *)&byte_E3E54[4]);
    v11 = 0;
    sub_91F70(*a1, 1286, &v8, &v8);
    if ( v8 )
    {
      WORD2(v12) = 0;
      LODWORD(v12) = 0;
    }
    else
    {
      v6 = v11;
      WORD2(v12) = sub_9F1D0(v10);
      LODWORD(v12) = v6;
    }
  }
  else
  {
    WORD2(v12) = 0;
    LODWORD(v12) = 0;
  }
  return v12;
}

//----- (0009F4F0) --------------------------------------------------------
signed int __cdecl sub_9F4F0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  signed __int64 v4; // rax
  unsigned __int16 v5; // ax
  __int16 v7; // [esp+0h] [ebp-10h]
  __int16 v8; // [esp+4h] [ebp-Ch]
  __int16 v9; // [esp+6h] [ebp-Ah]
  __int16 v10; // [esp+8h] [ebp-8h]

  if ( !*(_DWORD *)byte_E3E54 && !*(_WORD *)&byte_E3E54[4] )
  {
    v4 = sub_9F110(4);
    *(_WORD *)&byte_E3E54[4] = WORD2(v4);
    *(_DWORD *)byte_E3E54 = v4;
    if ( !(_DWORD)v4 && !*(_WORD *)&byte_E3E54[4] )
      return -1;
  }
  __GS__ = *(_WORD *)&byte_E3E54[4];
  __writegsword(*(unsigned int *)byte_E3E54, a4);
  v5 = sub_9F220(a3);
  __GS__ = *(_WORD *)&byte_E3E54[4];
  __writegsword(*(_DWORD *)byte_E3E54 + 2, v5);
  v8 = 24;
  v9 = sub_9F220(*(unsigned __int16 *)&byte_E3E54[4]);
  v10 = 0;
  sub_91F70(*a1, 1286, &v7, &v7);
  return v7;
}

//----- (0009F5E0) --------------------------------------------------------
signed int __cdecl sub_9F5E0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  signed __int64 v4; // rax
  unsigned __int16 v5; // ax
  __int16 v7; // [esp+0h] [ebp-10h]
  __int16 v8; // [esp+4h] [ebp-Ch]
  __int16 v9; // [esp+6h] [ebp-Ah]
  __int16 v10; // [esp+8h] [ebp-8h]

  if ( !*(_DWORD *)byte_E3E54 && !*(_WORD *)&byte_E3E54[4] )
  {
    v4 = sub_9F110(4);
    *(_WORD *)&byte_E3E54[4] = WORD2(v4);
    *(_DWORD *)byte_E3E54 = v4;
    if ( !(_DWORD)v4 && !*(_WORD *)&byte_E3E54[4] )
      return -1;
  }
  __GS__ = *(_WORD *)&byte_E3E54[4];
  __writegsword(*(unsigned int *)byte_E3E54, a4);
  v5 = sub_9F220(a3);
  __GS__ = *(_WORD *)&byte_E3E54[4];
  __writegsword(*(_DWORD *)byte_E3E54 + 2, v5);
  v8 = 25;
  v9 = sub_9F220(*(unsigned __int16 *)&byte_E3E54[4]);
  v10 = 0;
  sub_91F70(*a1, 1286, &v7, &v7);
  return v7;
}

//----- (0009F6D0) --------------------------------------------------------
int __cdecl sub_9F6D0(int *a1, __int16 a2)
{
  __int16 v3; // [esp+0h] [ebp-10h]
  __int16 v4; // [esp+4h] [ebp-Ch]
  __int16 v5; // [esp+6h] [ebp-Ah]

  sub_9F170(*(int *)byte_E3E54, *(unsigned __int16 *)&byte_E3E54[4]);
  *(_WORD *)&byte_E3E54[4] = 0;
  *(_DWORD *)byte_E3E54 = 0;
  v4 = 18;
  v5 = a2;
  sub_91F70(*a1, 1286, &v3, &v3);
  return v3;
}

//----- (0009F740) --------------------------------------------------------
void __cdecl sub_9F740(int a1)
{
  signed __int64 v1; // rax
  __int64 v2; // rax
  signed __int64 v3; // rax
  char v4; // [esp+0h] [ebp-34h]
  char v5[6]; // [esp+14h] [ebp-20h]
  char v6[6]; // [esp+1Ch] [ebp-18h]
  unsigned int v7; // [esp+24h] [ebp-10h]
  char v8; // [esp+28h] [ebp-Ch]
  int v9; // [esp+2Ch] [ebp-8h]
  int i; // [esp+30h] [ebp-4h]

  if ( byte_E37FC && !stricmp(&unk_180BE0, aSbawe32Mdi_1) && !stricmp(&byte_180C84, aW) )
  {
    if ( byte_E3815 == 1 )
    {
      sub_9FA80();
      byte_E3815 = 0;
    }
    strcpy(aBullfrog, a1);
    sprintf(&v4, aSoundSSbk, aBullfrog);
    dword_181E20 = sub_98817((int)&v4, 512);
    if ( dword_181E20 != -1 )
    {
      v7 = filelength(dword_181E20);
      v1 = sub_9F110(512);
      word_181E30 = WORD2(v1);
      dword_181E2C = v1;
      if ( (_DWORD)v1 || word_181E30 )
      {
        v9 = sub_9F280((int *)dword_180C7C);
        if ( v9 != -1 )
        {
          *(_WORD *)&v5[4] = word_181E30;
          *(_DWORD *)v5 = dword_181E2C;
          __writegsdword(dword_181E2C, 0);
          __writegsdword(*(_DWORD *)v5 + 4, v7);
          if ( !sub_9F2E0((int *)dword_180C7C, *(int *)v5, *(unsigned __int16 *)&v5[4], 2u)
            && !dos_read(dword_181E20, dword_181E2C, (unsigned __int16)word_181E30, 512, &v8) )
          {
            v2 = sub_9F3D0((int *)dword_180C7C, dword_181E2C, word_181E30, 1u);
            *(_WORD *)&v6[4] = WORD2(v2);
            *(_DWORD *)v6 = v2;
            if ( (_DWORD)v2 || *(_WORD *)&v6[4] )
            {
              lseek(dword_181E20, __readgsdword(*(_DWORD *)v6 + 2), 0);
              for ( i = 0; (signed __int16)__readgsword(*(unsigned int *)v6) > i; ++i )
              {
                if ( dos_read(dword_181E20, dword_181E2C, (unsigned __int16)word_181E30, 512, &v8)
                  || sub_9F4F0((int *)dword_180C7C, dword_181E2C, word_181E30, 1u) )
                {
                  return;
                }
              }
              v3 = sub_9F110(__readgsdword(*(_DWORD *)v6 + 10));
              word_181E2A = WORD2(v3);
              dword_181E26 = v3;
              if ( (_DWORD)v3 || word_181E2A )
              {
                lseek(dword_181E20, __readgsdword(*(_DWORD *)v6 + 6), 0);
                if ( !dos_read(
                        dword_181E20,
                        dword_181E26,
                        (unsigned __int16)word_181E2A,
                        __readgsdword(*(_DWORD *)v6 + 10),
                        &v8)
                  && !sub_9F5E0((int *)dword_180C7C, dword_181E26, word_181E2A, 1u) )
                {
                  byte_E3815 = 1;
                  sub_98882(dword_181E20);
                }
              }
            }
          }
        }
      }
    }
  }
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// AA7C0: using guessed type _DWORD __cdecl lseek(_DWORD, _DWORD, char);
// AD8A2: using guessed type _DWORD __cdecl dos_read(_DWORD, char, _DWORD, _DWORD, _DWORD);
// E37FC: using guessed type char byte_E37FC;
// E3815: using guessed type char byte_E3815;
// 180C7C: using guessed type int dword_180C7C;
// 180C84: using guessed type char byte_180C84;
// 181E20: using guessed type int dword_181E20;
// 181E26: using guessed type int dword_181E26;
// 181E2A: using guessed type __int16 word_181E2A;
// 181E2C: using guessed type int dword_181E2C;
// 181E30: using guessed type __int16 word_181E30;

//----- (0009FA80) --------------------------------------------------------
void sub_9FA80()
{
  if ( byte_E37FC && !stricmp(&unk_180BE0, aSbawe32Mdi_1) && !stricmp(&byte_180C84, aW) )
  {
    sub_9F6D0((int *)dword_180C7C, 1);
    sub_9F170(dword_181E2C, word_181E30);
    sub_9F170(dword_181E26, word_181E2A);
    byte_E3815 = 0;
  }
}
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// E37FC: using guessed type char byte_E37FC;
// E3815: using guessed type char byte_E3815;
// 180C7C: using guessed type int dword_180C7C;
// 180C84: using guessed type char byte_180C84;
// 181E26: using guessed type int dword_181E26;
// 181E2A: using guessed type __int16 word_181E2A;
// 181E2C: using guessed type int dword_181E2C;
// 181E30: using guessed type __int16 word_181E30;

//----- (000A0B24) --------------------------------------------------------
int __cdecl sub_A0B24(int a1)
{
  if ( (unsigned __int16)a1 < 0x3C4u && (unsigned __int16)a1 >= 0x3C0u )
  {
    if ( (unsigned __int16)a1 <= 0x3C0u )
    {
      inp(986);
      outp(960, BYTE2(a1) | 0x20);
      return outp(960, SHIBYTE(a1));
    }
    if ( (unsigned __int16)a1 >= 0x3C2u )
      return outp((unsigned __int16)a1, SHIBYTE(a1));
  }
  outp((unsigned __int16)a1, SBYTE2(a1));
  return outp((unsigned __int16)a1 + 1, SHIBYTE(a1));
}
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);

//----- (000A0BB0) --------------------------------------------------------
int __cdecl sub_A0BB0(int *a1, int a2)
{
  int *v2; // ebx
  int v3; // esi
  char v4; // di
  int result; // eax
  int v6; // ST04_4

  v2 = a1;
  v3 = a2;
  outp(980, 17);
  v4 = inp(981);
  outp(980, 17);
  for ( result = outp(981, v4 & 0x7F); --v3 != -1; result = sub_A0B24(v6) )
  {
    v6 = *v2;
    ++v2;
  }
  return result;
}
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);

//----- (000A0D2C) --------------------------------------------------------
int __cdecl sub_A0D2C(unsigned __int8 *a1)
{
  int v2; // [esp+4h] [ebp-4h]

  __outbyte(0x3C7u, 0);
  __inbytestring(0x3C9u, a1, 0x300u);
  return v2;
}

//----- (000A0D50) --------------------------------------------------------
int __cdecl sub_A0D50(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  int result; // eax

  dword_18063C = a1;
  dword_180650 = a2;
  dword_180648 = a3;
  dword_180644 = a4;
  dword_180634 = a3 + a1;
  result = a4;
  dword_180630 = a4 + a2;
  return result;
}
// 180630: using guessed type int dword_180630;
// 180634: using guessed type int dword_180634;
// 18063C: using guessed type int dword_18063C;
// 180644: using guessed type int dword_180644;
// 180648: using guessed type int dword_180648;
// 180650: using guessed type int dword_180650;

//----- (000A0EEC) --------------------------------------------------------
void sub_A0EEC()
{
  ++dword_E3FF2;
}
// E3FF2: using guessed type int dword_E3FF2;

//----- (000A0EF9) --------------------------------------------------------
void sub_A0EF9()
{
  --dword_E3FF2;
}
// E3FF2: using guessed type int dword_E3FF2;

//----- (000A0F06) --------------------------------------------------------
int __usercall sub_A0F06@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>)
{
  int v7; // edx
  unsigned int v8; // edi
  unsigned int v9; // eax
  unsigned int v10; // edi
  signed __int32 v11; // eax
  signed __int32 v12; // ecx
  signed __int32 v13; // eax
  int v15; // eax
  int v16; // [esp-30h] [ebp-30h]
  int v17; // [esp-2Ch] [ebp-2Ch]
  int v18; // [esp-28h] [ebp-28h]
  int v19; // [esp-24h] [ebp-24h]
  int v20; // [esp-20h] [ebp-20h]
  int v21; // [esp-1Ch] [ebp-1Ch]
  int v22; // [esp-18h] [ebp-18h]
  int v23; // [esp-14h] [ebp-14h]
  void **v24; // [esp-10h] [ebp-10h]
  int v25; // [esp-Ch] [ebp-Ch]
  int v26; // [esp-8h] [ebp-8h]
  int v27; // [esp-4h] [ebp-4h]
  void *retaddr[2]; // [esp+0h] [ebp+0h]

  if ( dword_E3FEE )
  {
    v27 = a1;
    __outbyte(0x20u, 0x20u);
    __asm { iret }
  }
  v27 = a7;
  v26 = a6;
  v25 = a5;
  v24 = retaddr;
  v23 = a4;
  v22 = a3;
  v21 = a2;
  v20 = a1;
  v19 = (unsigned __int16)__DS__;
  v18 = (unsigned __int16)__ES__;
  v17 = (unsigned __int16)__FS__;
  v16 = (unsigned __int16)__GS__;
  __DS__ = word_E3FF6;
  ++dword_E3FEE;
  word_E4A04 = __SS__;
  dword_E4A08 = (int)&v16;
  v7 = dword_E3FEA;
  v8 = 0;
  do
  {
    if ( dword_E3E9C[v8] == 2 )
    {
      v9 = v7 + dword_E3EDC[v8];
      if ( v9 >= dword_E3F1C[v8] )
      {
        v9 -= dword_E3F1C[v8];
        ++dword_E3F5C[v8];
      }
      dword_E3EDC[v8] = v9;
    }
    ++v8;
  }
  while ( v8 < 16 );
  __outbyte(0x20u, 0x20u);
  _enable();
  if ( dword_E3FF2 <= 0 )
  {
    v10 = 0;
    do
    {
      while ( dword_E3F5C[v10] )
      {
        --dword_E3F5C[v10];
        ((void (__fastcall *)(int, int, int))dword_E3E5C[v10])(dword_E3F9C[v10], v7, a4);
      }
      ++v10;
    }
    while ( v10 < 15 );
  }
  if ( !dword_E3F98 )
  {
    --dword_E3FEE;
    v15 = *MK_FP(word_E4A04, &v20);
    __asm { iret }
  }
  --dword_E3F98;
  --dword_E3FEE;
  v11 = (unsigned __int16)word_E3FE0;
  v12 = _InterlockedExchange(&v26, dword_E3FDC);
  v13 = _InterlockedExchange(&v27, v11);
  return MK_FP(retaddr[0], retaddr[0])(v13, v27, v26, v12);
}
// A0F06: could not find valid save-restore pair for ebp
// A0F06: could not find valid save-restore pair for edi
// A0F06: could not find valid save-restore pair for esi
// E3E5C: using guessed type int dword_E3E5C[];
// E3E9C: using guessed type int dword_E3E9C[];
// E3EDC: using guessed type int dword_E3EDC[];
// E3F1C: using guessed type int dword_E3F1C[];
// E3F5C: using guessed type int dword_E3F5C[];
// E3F98: using guessed type int dword_E3F98;
// E3F9C: using guessed type int dword_E3F9C[];
// E3FDC: using guessed type int dword_E3FDC;
// E3FE0: using guessed type __int16 word_E3FE0;
// E3FEA: using guessed type int dword_E3FEA;
// E3FEE: using guessed type int dword_E3FEE;
// E3FF2: using guessed type int dword_E3FF2;
// E3FF6: using guessed type __int16 word_E3FF6;
// E4A04: using guessed type __int16 word_E4A04;
// E4A08: using guessed type int dword_E4A08;

//----- (000A102C) --------------------------------------------------------
char __cdecl sub_A102C(int a1)
{
  unsigned int v1; // et0
  char result; // al
  unsigned int v3; // [esp-4h] [ebp-10h]
  void *retaddr; // [esp+10h] [ebp+4h]

  v1 = __readeflags();
  v3 = v1;
  _disable();
  __outbyte(0x43u, 0x36u);
  dword_E3FE6 = a1;
  __outbyte(0x40u, a1);
  result = BYTE1(a1);
  __outbyte(0x40u, BYTE1(a1));
  _disable();
  if ( BYTE1(retaddr) & 2 )
    _enable();
  __writeeflags(v3);
  return result;
}
// E3FE6: using guessed type int dword_E3FE6;

//----- (000A105C) --------------------------------------------------------
char __cdecl sub_A105C(unsigned int a1)
{
  int v1; // eax

  v1 = 0;
  if ( a1 < 0xD68D )
    v1 = 10000 * (unsigned __int64)a1 / 0x20BC;
  return sub_A102C(v1);
}

//----- (000A108F) --------------------------------------------------------
void sub_A108F()
{
  unsigned int v0; // ecx
  unsigned int v1; // edi

  sub_91BD0();
  v0 = -1;
  v1 = 0;
  do
  {
    if ( dword_E3E9C[v1] && dword_E3F1C[v1] < v0 )
      v0 = dword_E3F1C[v1];
    ++v1;
  }
  while ( v1 < 16 );
  if ( v0 != dword_E3FEA )
  {
    dword_E3FEA = v0;
    sub_A105C(v0);
    memset(dword_E3EDC, 0, 0x40u);
  }
  sub_91BF0();
}
// E3E9C: using guessed type int dword_E3E9C[];
// E3EDC: using guessed type int dword_E3EDC[];
// E3F1C: using guessed type int dword_E3F1C[];
// E3FEA: using guessed type int dword_E3FEA;

//----- (000A10F4) --------------------------------------------------------
void sub_A10F4()
{
  unsigned int v0; // et0
  unsigned __int16 v1; // dx
  unsigned int v2; // [esp-8h] [ebp-14h]

  v0 = __readeflags();
  v2 = v0;
  _disable();
  word_E3FF6 = __DS__;
  sub_A18BE();
  dword_E3FEE = 0;
  dword_E3FF2 = 0;
  dword_E3FEA = -1;
  dword_E3FF8 = -1;
  memset(dword_E3E9C, 0, 0x40u);
  memset(dword_E3EDC, 0, 0x40u);
  memset(dword_E3F1C, 0, 0x40u);
  memset(dword_E3F5C, 0, 0x40u);
  __asm
  {
    int     31h; DPMI Services   ax=func xxxxh
    int     21h; DOS - 2+ - GET INTERRUPT VECTOR
  }
  dword_E3FDC = 8;
  word_E3FE0 = __DS__;
  dword_E3FE2 = v1;
  __asm { int     21h; DOS - SET INTERRUPT VECTOR }
  dword_E3ED8 = 2;
  sub_92890(60, 54925);
  _disable();
  if ( v2 & 0x200 )
    _enable();
  __writeeflags(v2);
}
// E3E9C: using guessed type int dword_E3E9C[];
// E3ED8: using guessed type int dword_E3ED8;
// E3EDC: using guessed type int dword_E3EDC[];
// E3F1C: using guessed type int dword_E3F1C[];
// E3F5C: using guessed type int dword_E3F5C[];
// E3FDC: using guessed type int dword_E3FDC;
// E3FE0: using guessed type __int16 word_E3FE0;
// E3FE2: using guessed type int dword_E3FE2;
// E3FEA: using guessed type int dword_E3FEA;
// E3FEE: using guessed type int dword_E3FEE;
// E3FF2: using guessed type int dword_E3FF2;
// E3FF6: using guessed type __int16 word_E3FF6;
// E3FF8: using guessed type int dword_E3FF8;

//----- (000A11E2) --------------------------------------------------------
signed int sub_A11E2()
{
  unsigned int v0; // et0
  signed int result; // eax
  unsigned int v2; // [esp-4h] [ebp-10h]

  v0 = __readeflags();
  v2 = v0;
  _disable();
  sub_A102C(0);
  result = 9480;
  __asm { int     21h; DOS - SET INTERRUPT VECTOR }
  _disable();
  if ( v2 & 0x200 )
    _enable();
  __writeeflags(v2);
  return result;
}
// E3FDC: using guessed type int dword_E3FDC;
// E3FE0: using guessed type __int16 word_E3FE0;

//----- (000A121D) --------------------------------------------------------
int __fastcall sub_A121D(int a1, __int16 a2, int a3, int a4)
{
  int v4; // ecx

  __asm { int     31h; DPMI Services   ax=func xxxxh }
  v4 = a4 << 16;
  LOWORD(v4) = a2;
  __asm { int     21h; DOS - 2+ - GET INTERRUPT VECTOR }
  return v4;
}

//----- (000A1249) --------------------------------------------------------
signed int sub_A1249()
{
  signed int result; // eax

  result = 513;
  __asm { int     31h; DPMI Services   ax=func xxxxh }
  return result;
}

//----- (000A12C5) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed int __cdecl sub_A12C5(int a1, int a2, __int16 a3)
{
  signed int result; // eax

  if ( dword_E3FF8 == -1 )
  {
    __asm
    {
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      lar     ecx, edx
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      lar     ecx, edx
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      lar     ecx, edx
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      lar     ecx, edx
      int     31h; DPMI Services   ax=func xxxxh
    }
    dword_A128C = (int)((char *)&unk_E4004 - ((unsigned int)&unk_E4004 & 0xFFFFFFF0) + 512);
    word_A1286 = 0;
    word_A1277 = 0;
    word_A12AC = 0;
    word_A12B3 = a3;
    word_A12A2 = (__int16)((char *)&dword_A1270 - ((unsigned int)&dword_A1270 & 0xFFFFFFF0) + 74);
    dword_E3FF8 = a1;
    __asm { int     31h; DPMI Services   ax=func xxxxh }
    dword_E3FFC = 49407;
    dword_E4000 = __DS__;
    result = 517;
    __asm { int     31h; DPMI Services   ax=func xxxxh }
  }
  return result;
}
// A1462: write access to const memory at A128C has been detected
// A146A: write access to const memory at A1286 has been detected
// A1473: write access to const memory at A1277 has been detected
// A147C: write access to const memory at A12AC has been detected
// A1485: write access to const memory at A12B3 has been detected
// A1493: write access to const memory at A12A2 has been detected
// A1270: using guessed type int dword_A1270;
// A1277: using guessed type __int16 word_A1277;
// A1286: using guessed type __int16 word_A1286;
// A128C: using guessed type int dword_A128C;
// A12A2: using guessed type __int16 word_A12A2;
// A12AC: using guessed type __int16 word_A12AC;
// A12B3: using guessed type __int16 word_A12B3;
// E3FF8: using guessed type int dword_E3FF8;
// E3FFC: using guessed type int dword_E3FFC;
// E4000: using guessed type int dword_E4000;

//----- (000A14DB) --------------------------------------------------------
signed int __cdecl sub_A14DB(int a1)
{
  signed int result; // eax

  if ( a1 != -1 && a1 == dword_E3FF8 )
  {
    result = 517;
    __asm { int     31h; DPMI Services   ax=func xxxxh }
    dword_E3FF8 = -1;
  }
  return result;
}
// E3FF8: using guessed type int dword_E3FF8;
// E3FFC: using guessed type int dword_E3FFC;
// E4000: using guessed type int dword_E4000;

//----- (000A1520) --------------------------------------------------------
unsigned int sub_A1520()
{
  unsigned int v0; // et0
  unsigned int result; // eax

  v0 = __getcallerseflags();
  result = v0;
  _disable();
  return result;
}

//----- (000A1524) --------------------------------------------------------
void __cdecl sub_A1524(unsigned int a1)
{
  void *retaddr; // [esp+4h] [ebp+4h]

  _disable();
  if ( BYTE1(retaddr) & 2 )
    _enable();
  __writeeflags(a1);
}

//----- (000A158B) --------------------------------------------------------
int __cdecl sub_A158B(int a1, __int16 a2, _WORD *a3, _WORD *a4)
{
  __int16 v8; // dx
  __int16 v9; // si
  __int16 v10; // di
  __int16 v11; // cx
  __int16 v12; // dx
  __int16 v13; // si
  __int16 v14; // di
  int v15; // ST00_4
  __int16 v17; // [esp+Eh] [ebp-3Ah]
  int v18; // [esp+10h] [ebp-38h]
  __int16 v19; // [esp+1Eh] [ebp-2Ah]
  __int16 v20; // [esp+22h] [ebp-26h]
  __int16 v21; // [esp+26h] [ebp-22h]
  __int16 v22; // [esp+2Ah] [ebp-1Eh]
  __int16 v23; // [esp+2Eh] [ebp-1Ah]
  __int16 v24; // [esp+30h] [ebp-18h]
  __int16 v25; // [esp+32h] [ebp-16h]

  sub_91BD0();
  memset(&v17, 0, sizeof(v17));
  _CF = __CFSHR__(50, 2);
  _ZF = 0;
  _SF = 0;
  memset(&v18, 0, 0x30u);
  v25 = 0;
  v24 = 0;
  __asm { pushfw }
  v23 = 0;
  v22 = a2;
  if ( a3 )
  {
    v8 = a3[3];
    v9 = a3[4];
    v10 = a3[5];
    v21 = a3[2];
    v20 = v8;
    HIWORD(v18) = v9;
    v17 = v10;
  }
  v19 = *(_WORD *)(*(_DWORD *)(a1 + 8) + 50);
  __asm { int     31h; DPMI Services   ax=func xxxxh }
  if ( a4 )
  {
    v11 = v21;
    v12 = v20;
    v13 = HIWORD(v18);
    v14 = v17;
    *a4 = v22;
    a4[2] = v11;
    a4[3] = v12;
    a4[4] = v13;
    a4[5] = v14;
    a4[1] = v19;
  }
  v15 = v22;
  sub_91BF0();
  return v15;
}

//----- (000A1665) --------------------------------------------------------
unsigned __int8 __cdecl sub_A1665(int a1)
{
  unsigned __int8 result; // al
  unsigned __int16 v2; // dx
  int i; // ecx
  unsigned __int8 v4; // al

  result = MEMORY[0x463];
  v2 = MEMORY[0x463] + 6;
  for ( i = a1; i; --i )
  {
    do
      v4 = __inbyte(v2);
    while ( !(v4 & 8) );
    do
      result = __inbyte(v2);
    while ( result & 8 );
  }
  return result;
}

//----- (000A16A2) --------------------------------------------------------
int sub_A16A2()
{
  return dword_E3FEE;
}
// E3FEE: using guessed type int dword_E3FEE;

//----- (000A16AE) --------------------------------------------------------
unsigned int __cdecl sub_A16AE(int a1)
{
  unsigned int v1; // eax
  unsigned int v2; // ST00_4

  sub_91BD0();
  v1 = 0;
  while ( *(int *)((char *)dword_E3E9C + v1) )
  {
    v1 += 4;
    if ( v1 >= 0x3C )
    {
      v1 = -1;
      goto LABEL_6;
    }
  }
  *(int *)((char *)dword_E3E9C + v1) = 1;
  *(int *)((char *)dword_E3E5C + v1) = a1;
LABEL_6:
  v2 = v1;
  sub_91BF0();
  return v2;
}
// E3E5C: using guessed type int dword_E3E5C[];
// E3E9C: using guessed type int dword_E3E9C[];

//----- (000A16F5) --------------------------------------------------------
signed __int32 __cdecl sub_A16F5(int a1, signed __int32 a2)
{
  signed __int32 v2; // eax
  signed __int32 v3; // ST00_4

  sub_91BD0();
  if ( a1 != -1 )
    v2 = _InterlockedExchange((int *)((char *)dword_E3F9C + a1), a2);
  v3 = v2;
  sub_91BF0();
  return v3;
}
// E3F9C: using guessed type int dword_E3F9C[];

//----- (000A171D) --------------------------------------------------------
void __cdecl sub_A171D(int a1)
{
  sub_91BD0();
  if ( a1 != -1 )
    *(int *)((char *)dword_E3E9C + a1) = 0;
  sub_91BF0();
}
// E3E9C: using guessed type int dword_E3E9C[];

//----- (000A1744) --------------------------------------------------------
void sub_A1744()
{
  int v0; // esi
  unsigned __int8 v1; // of

  sub_91BD0();
  v0 = 56;
  do
  {
    sub_92DC0(v0);
    v1 = __OFSUB__(v0, 4);
    v0 -= 4;
  }
  while ( !((v0 < 0) ^ v1) );
  sub_91BF0();
}

//----- (000A1768) --------------------------------------------------------
void __cdecl sub_A1768(int a1)
{
  sub_91BD0();
  if ( a1 != -1 && *(int *)((char *)dword_E3E9C + a1) == 1 )
    *(int *)((char *)dword_E3E9C + a1) = 2;
  sub_91BF0();
}
// E3E9C: using guessed type int dword_E3E9C[];

//----- (000A1798) --------------------------------------------------------
void sub_A1798()
{
  int v0; // esi
  unsigned __int8 v1; // of

  sub_91BD0();
  v0 = 56;
  do
  {
    sub_92BA0(v0);
    v1 = __OFSUB__(v0, 4);
    v0 -= 4;
  }
  while ( !((v0 < 0) ^ v1) );
  sub_91BF0();
}

//----- (000A17BC) --------------------------------------------------------
void __cdecl sub_A17BC(int a1)
{
  sub_91BD0();
  if ( a1 != -1 && *(int *)((char *)dword_E3E9C + a1) == 2 )
    *(int *)((char *)dword_E3E9C + a1) = 1;
  sub_91BF0();
}
// E3E9C: using guessed type int dword_E3E9C[];

//----- (000A17EC) --------------------------------------------------------
void sub_A17EC()
{
  int v0; // esi
  unsigned __int8 v1; // of

  sub_91BD0();
  v0 = 56;
  do
  {
    sub_92CB0(v0);
    v1 = __OFSUB__(v0, 4);
    v0 -= 4;
  }
  while ( !((v0 < 0) ^ v1) );
  sub_91BF0();
}

//----- (000A1810) --------------------------------------------------------
void __cdecl sub_A1810(int a1, int a2)
{
  sub_91BD0();
  *(int *)((char *)dword_E3F1C + a1) = a2;
  *(int *)((char *)dword_E3EDC + a1) = 0;
  sub_A108F();
  sub_91BF0();
}
// E3EDC: using guessed type int dword_E3EDC[];
// E3F1C: using guessed type int dword_E3F1C[];

//----- (000A1840) --------------------------------------------------------
void __cdecl sub_A1840(int a1, unsigned int a2)
{
  sub_91BD0();
  sub_92890(a1, (unsigned int)&unk_F4240 / a2);
  sub_91BF0();
}

//----- (000A1870) --------------------------------------------------------
void __cdecl sub_A1870(int a1, unsigned int a2)
{
  int v2; // eax

  sub_91BD0();
  if ( a2 )
    v2 = 10000 * (unsigned __int64)a2 / 0x2E9C;
  else
    v2 = 54925;
  sub_92890(a1, v2);
  sub_91BF0();
}

//----- (000A18B2) --------------------------------------------------------
int sub_A18B2()
{
  return dword_E3FE6;
}
// E3FE6: using guessed type int dword_E3FE6;

//----- (000A18BE) --------------------------------------------------------
bool sub_A18BE()
{
  sub_9D590((unsigned int)dword_E3E5C, (unsigned int)byte_E4A0C);
  return sub_9D590((unsigned int)sub_A0EEC, (unsigned int)sub_A18BE);
}
// E3E5C: using guessed type int dword_E3E5C[];

//----- (000A1F90) --------------------------------------------------------
bool sub_A1F90()
{
  bool result; // eax

  if ( !dword_E4A90 )
  {
    sub_9D590((unsigned int)sub_A1F90, (unsigned int)sub_A4260);
    sub_9D710((unsigned int)byte_E4A0C, 128);
    sub_9D710((unsigned int)&dword_E4A8C, 4);
    sub_9D710((unsigned int)&dword_181E94, 4);
    sub_9D710((unsigned int)&unk_181E80, 12);
    sub_9D710((unsigned int)&dword_181E9C, 4);
    sub_9D710((unsigned int)&dword_181EA0, 4);
    sub_9D710((unsigned int)&dword_181E90, 4);
    sub_9D710((unsigned int)&dword_181E98, 4);
    sub_9D710((unsigned int)&dword_181E8C, 4);
    result = sub_B0C46();
    dword_E4A90 = 1;
  }
  return result;
}
// E4A8C: using guessed type int dword_E4A8C;
// E4A90: using guessed type int dword_E4A90;
// 181E8C: using guessed type int dword_181E8C;
// 181E90: using guessed type int dword_181E90;
// 181E94: using guessed type int dword_181E94;
// 181E98: using guessed type int dword_181E98;
// 181E9C: using guessed type int dword_181E9C;
// 181EA0: using guessed type int dword_181EA0;

//----- (000A2070) --------------------------------------------------------
int __cdecl sub_A2070(int a1)
{
  int result; // eax
  char v2; // [esp+0h] [ebp-Ch]
  __int16 v3; // [esp+4h] [ebp-8h]
  __int16 v4; // [esp+6h] [ebp-6h]

  result = a1;
  if ( !*(_DWORD *)(a1 + 84) )
  {
    v4 = *(_WORD *)(a1 + 24);
    v3 = *(_WORD *)(a1 + 20);
    sub_91F70(*(_DWORD *)a1, 1025, &v2, 0);
    result = a1;
    *(_DWORD *)(a1 + 84) = 1;
  }
  return result;
}

//----- (000A20D0) --------------------------------------------------------
int *__cdecl sub_A20D0(int *a1)
{
  int *result; // eax

  result = a1;
  if ( a1[21] )
  {
    sub_91F70(*a1, 1026, 0, 0);
    result = a1;
    a1[21] = 0;
  }
  return result;
}

//----- (000A2110) --------------------------------------------------------
int __cdecl sub_A2110(_DWORD *a1)
{
  int result; // eax
  int *v2; // edx
  int *v3; // edx
  int *v4; // edx
  int *v5; // edx
  int *v6; // edx
  int *v7; // edx
  int *v8; // edx
  int *v9; // edx
  int *v10; // edx
  int v11; // [esp+0h] [ebp-24h]
  int v12; // [esp+4h] [ebp-20h]
  int v13; // [esp+8h] [ebp-1Ch]
  int v14; // [esp+Ch] [ebp-18h]
  int v15; // [esp+14h] [ebp-10h]
  int v16; // [esp+18h] [ebp-Ch]
  int v17; // [esp+1Ch] [ebp-8h]
  signed int l; // [esp+20h] [ebp-4h]
  signed int m; // [esp+20h] [ebp-4h]
  signed int n; // [esp+20h] [ebp-4h]
  signed int i; // [esp+20h] [ebp-4h]
  signed int j; // [esp+20h] [ebp-4h]
  signed int k; // [esp+20h] [ebp-4h]

  if ( a1[16] <= 127 )
  {
    if ( a1[16] < 0 )
      a1[16] = 0;
  }
  else
  {
    a1[16] = 127;
  }
  if ( a1[17] <= 127 )
  {
    if ( a1[17] < 0 )
      a1[17] = 0;
  }
  else
  {
    a1[17] = 127;
  }
  v14 = a1[17];
  v17 = *(_DWORD *)(*a1 + 104) * a1[16] / 127;
  if ( v17 < 0 )
    v17 = 0;
  if ( v17 > 127 )
    v17 = 127;
  if ( a1[13] != 1 && a1[13] != 3 )
  {
    if ( v17 )
      ++v17;
    if ( *(_DWORD *)(*a1 + 24) != 2
      && *(_DWORD *)(*a1 + 24) != 3
      && (*(_DWORD *)(*a1 + 24) && *(_DWORD *)(*a1 + 24) != 1 || a1[13] != 2 && a1[13] != 3) )
    {
      v11 = (int)(a1 + 18);
      result = (int)a1;
      if ( a1[14] & 1 )
      {
        for ( i = 0; i < 0x8000; i += 256 )
        {
          result = v17 * i >> 7;
          v8 = (int *)v11;
          v11 += 4;
          *v8 = result;
        }
        for ( j = -32768; j < 0; j += 256 )
        {
          result = v17 * j >> 7;
          v9 = (int *)v11;
          v11 += 4;
          *v9 = result;
        }
      }
      else
      {
        for ( k = -32768; k < 0x8000; k += 256 )
        {
          result = v17 * k >> 7;
          v10 = (int *)v11;
          v11 += 4;
          *v10 = result;
        }
      }
    }
    else
    {
      v13 = (int)(a1 + 18);
      v12 = (int)(a1 + 274);
      v16 = (unsigned __int8)byte_E4A0C[127 - v14];
      v15 = (unsigned __int8)byte_E4A0C[v14];
      result = (int)a1;
      if ( a1[14] & 1 )
      {
        for ( l = 0; l < 0x8000; l += 256 )
        {
          v2 = (int *)v13;
          v13 += 4;
          *v2 = v16 * (v17 * l >> 7) >> 7;
          result = v15 * (v17 * l >> 7) >> 7;
          v3 = (int *)v12;
          v12 += 4;
          *v3 = result;
        }
        for ( m = -32768; m < 0; m += 256 )
        {
          v4 = (int *)v13;
          v13 += 4;
          *v4 = v16 * (v17 * m >> 7) >> 7;
          result = v15 * (v17 * m >> 7) >> 7;
          v5 = (int *)v12;
          v12 += 4;
          *v5 = result;
        }
      }
      else
      {
        for ( n = -32768; n < 0x8000; n += 256 )
        {
          v6 = (int *)v13;
          v13 += 4;
          *v6 = v16 * (v17 * n >> 7) >> 7;
          result = v15 * (v17 * n >> 7) >> 7;
          v7 = (int *)v12;
          v12 += 4;
          *v7 = result;
        }
      }
    }
  }
  else
  {
    a1[18] = v17 * (unsigned __int8)byte_E4A0C[127 - v14] / 127;
    result = v17 * (unsigned __int8)byte_E4A0C[v14] / 127;
    a1[274] = result;
  }
  return result;
}

//----- (000A2650) --------------------------------------------------------
int __cdecl sub_A2650(int a1)
{
  int v1; // eax
  int v2; // eax
  unsigned int v4; // [esp+0h] [ebp-44h]
  unsigned int v5; // [esp+8h] [ebp-3Ch]
  int v6; // [esp+Ch] [ebp-38h]
  int v7; // [esp+10h] [ebp-34h]
  int v8; // [esp+14h] [ebp-30h]
  int v9; // [esp+18h] [ebp-2Ch]
  int v10; // [esp+1Ch] [ebp-28h]
  int v11; // [esp+20h] [ebp-24h]
  unsigned int v12; // [esp+24h] [ebp-20h]
  int v13; // [esp+28h] [ebp-1Ch]
  int v14; // [esp+2Ch] [ebp-18h]
  int j; // [esp+30h] [ebp-14h]
  int v16; // [esp+34h] [ebp-10h]
  int v17; // [esp+38h] [ebp-Ch]
  int v18; // [esp+3Ch] [ebp-8h]
  int i; // [esp+40h] [ebp-4h]

  v11 = *(_DWORD *)(a1 + 84);
  if ( v11 )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 96); ++i )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 92) + 2196 * i + 2192) = *(_DWORD *)(*(_DWORD *)(a1 + 92) + 2196 * i + 4);
      if ( *(_DWORD *)(2196 * i + *(_DWORD *)(a1 + 92) + 4) == 4 )
        *(_DWORD *)(2196 * i + *(_DWORD *)(a1 + 92) + 4) = 8;
    }
    sub_A20D0((int *)a1);
    sub_B0C1A(a1);
    sub_B0B87((_DWORD *)a1, 0);
    sub_B0B87((_DWORD *)a1, 1);
  }
  v5 = 2 * dword_181DC8 | dword_181DCC;
  if ( v5 <= 3 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = 0;
        v7 = 1;
        v8 = 2;
        v9 = 3;
        break;
      case 1u:
        v6 = 1;
        v7 = 0;
        v8 = 3;
        v9 = 2;
        break;
      case 2u:
        v6 = 2;
        v7 = 3;
        v8 = 0;
        v9 = 1;
        break;
      case 3u:
        v6 = 3;
        v7 = 2;
        v8 = 1;
        v9 = 0;
        break;
    }
  }
  for ( i = 0; i < 4; ++i )
  {
    if ( *(_BYTE *)(*(&v6 + i) + *(_DWORD *)(a1 + 4)) )
    {
      *(_DWORD *)(a1 + 24) = *(&v6 + i);
      break;
    }
  }
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 26);
  if ( (unsigned int)dword_181DB0 < 1 )
  {
    if ( !dword_181DB0 )
    {
      *(_DWORD *)(a1 + 20) = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 16);
      goto LABEL_33;
    }
  }
  else
  {
    if ( (unsigned int)dword_181DB0 <= 1 )
    {
      *(_DWORD *)(a1 + 20) = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 18);
      goto LABEL_33;
    }
    if ( dword_181DB0 == 2 )
    {
      *(_DWORD *)(a1 + 20) = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 20);
      goto LABEL_33;
    }
  }
  j = dword_181DB0;
  v6 = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 16);
  v7 = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 18);
  v8 = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 20);
  v13 = 0x7FFFFFFF;
  for ( i = 0; i < 3; ++i )
  {
    v1 = abs(j - *(&v6 + i));
    if ( v1 <= v13 )
    {
      v13 = abs(j - *(&v6 + i));
      v14 = i;
    }
  }
  *(_DWORD *)(a1 + 20) = *(&v6 + v14);
LABEL_33:
  v4 = *(_DWORD *)(a1 + 24);
  if ( v4 <= 3 )
  {
    switch ( v4 )
    {
      case 0u:
        *(_DWORD *)(a1 + 60) = 1;
        *(_DWORD *)(a1 + 64) = 1;
        break;
      case 1u:
        *(_DWORD *)(a1 + 60) = 1;
        *(_DWORD *)(a1 + 64) = 2;
        break;
      case 2u:
        *(_DWORD *)(a1 + 60) = 2;
        *(_DWORD *)(a1 + 64) = 1;
        break;
      case 3u:
        *(_DWORD *)(a1 + 60) = 2;
        *(_DWORD *)(a1 + 64) = 2;
        break;
    }
  }
  v16 = dword_181DB8 * *(_DWORD *)(a1 + 20) / 1000;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 60) * *(_DWORD *)(a1 + 64) * v16;
  v18 = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 22);
  v17 = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 24);
  if ( !dword_181DF4 )
    goto LABEL_64;
  if ( v17 > 2048 )
    v17 = 2048;
  if ( v18 > 2048 )
  {
    strcpy(&byte_181C90, "Minimum DMA buffer size too large for VDM\n");
    v10 = 0;
  }
  else
  {
LABEL_64:
    v13 = 0x7FFFFFFF;
    for ( j = 8; dword_181DB4 / 2 >= j; j *= 2 )
    {
      v2 = abs(j - *(_DWORD *)(a1 + 16));
      if ( v2 <= v13 )
      {
        v13 = abs(j - *(_DWORD *)(a1 + 16));
        v14 = j;
      }
    }
    *(_DWORD *)(a1 + 16) = v14;
    if ( *(_DWORD *)(a1 + 16) < v18 )
      *(_DWORD *)(a1 + 16) = v18;
    if ( *(_DWORD *)(a1 + 16) > v17 )
      *(_DWORD *)(a1 + 16) = v17;
    v12 = *(_DWORD *)(a1 + 32);
    if ( dword_181DF4 )
    {
      v12 >>= 12;
      v12 += 4095;
      v12 &= (unsigned int)&unk_FF000;
      v12 <<= 12;
    }
    **(_DWORD **)(a1 + 8) = v12;
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) = *(_DWORD *)(a1 + 16) + v12;
    *(_DWORD *)(a1 + 44) = (**(_DWORD **)(a1 + 8) & 0xFFFF) + 16 * (**(_DWORD **)(a1 + 8) >> 16);
    *(_DWORD *)(a1 + 48) = (*(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) & 0xFFFF)
                         + 16 * (*(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) >> 16);
    if ( v11 )
    {
      for ( i = 0; i < *(_DWORD *)(a1 + 96); ++i )
        *(_DWORD *)(*(_DWORD *)(a1 + 92) + 2196 * i + 4) = *(_DWORD *)(*(_DWORD *)(a1 + 92) + 2196 * i + 2192);
      sub_B0C1A(a1);
      sub_B0B87((_DWORD *)a1, 0);
      sub_B0B87((_DWORD *)a1, 1);
      sub_A2070(a1);
    }
    v10 = 1;
  }
  return v10;
}
// A0D1F: using guessed type _DWORD __cdecl abs(_DWORD);
// 181C90: using guessed type char byte_181C90;
// 181DB0: using guessed type int dword_181DB0;
// 181DB4: using guessed type int dword_181DB4;
// 181DB8: using guessed type int dword_181DB8;
// 181DC8: using guessed type int dword_181DC8;
// 181DCC: using guessed type int dword_181DCC;
// 181DF4: using guessed type int dword_181DF4;

//----- (000A2C80) --------------------------------------------------------
int __cdecl sub_A2C80(int *a1, const void *a2)
{
  __int16 v3; // [esp+0h] [ebp-30h]
  __int16 v4; // [esp+2h] [ebp-2Eh]
  __int16 v5; // [esp+4h] [ebp-2Ch]
  __int16 v6; // [esp+6h] [ebp-2Ah]
  int v7; // [esp+8h] [ebp-28h]
  char v8; // [esp+18h] [ebp-18h]
  __int16 v9; // [esp+1Eh] [ebp-12h]
  unsigned int i; // [esp+24h] [ebp-Ch]
  __int16 *v11; // [esp+28h] [ebp-8h]

  qmemcpy(&v3, a2, 0x18u);
  if ( *(_WORD *)(*(_DWORD *)(*a1 + 16) + 16) )
  {
    v11 = (__int16 *)((*(_DWORD *)(*(_DWORD *)(*a1 + 16) + 12) & 0xFFFF)
                    + 16 * (*(_DWORD *)(*(_DWORD *)(*a1 + 16) + 12) >> 16));
    if ( v3 < 0 )
      v3 = *v11;
    if ( v4 < 0 )
      v4 = v11[1];
    if ( v5 < 0 )
      v5 = v11[2];
    if ( v6 < 0 )
      v6 = v11[3];
    for ( i = 0; i < 4; ++i )
    {
      if ( *(&v7 + i) < 0 )
        *(&v7 + i) = *(_DWORD *)&v11[2 * i + 4];
    }
  }
  qmemcpy((void *)(*(_DWORD *)(*a1 + 16) + 22), &v3, 0x18u);
  if ( dword_181DD0 )
    v9 = 3;
  else
    v9 = 1;
  return sub_91F70(*a1, 772, &v8, 0);
}
// 181DD0: using guessed type int dword_181DD0;

//----- (000A2EA0) --------------------------------------------------------
int *__cdecl sub_A2EA0(int a1, const void *a2)
{
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // ST0C_4
  int v5; // ST08_4
  unsigned int v6; // eax
  int v7; // ST0C_4
  int v8; // ST08_4
  int v9; // ST0C_4
  int v10; // ST08_4
  unsigned int v11; // eax
  int v12; // ST0C_4
  int v13; // ST08_4
  char v15; // [esp+0h] [ebp-50h]
  unsigned __int16 v16; // [esp+18h] [ebp-38h]
  unsigned __int16 v17; // [esp+1Ah] [ebp-36h]
  unsigned __int16 v18; // [esp+1Ch] [ebp-34h]
  unsigned __int16 v19; // [esp+1Eh] [ebp-32h]
  int *v20; // [esp+24h] [ebp-2Ch]
  int v21; // [esp+28h] [ebp-28h]
  unsigned int v22; // [esp+2Ch] [ebp-24h]
  unsigned int v23; // [esp+30h] [ebp-20h]
  unsigned int v24; // [esp+34h] [ebp-1Ch]
  int v25; // [esp+38h] [ebp-18h]
  int *v26; // [esp+3Ch] [ebp-14h]
  unsigned int v27; // [esp+40h] [ebp-10h]
  int v28; // [esp+44h] [ebp-Ch]
  int i; // [esp+48h] [ebp-8h]
  int v30; // [esp+4Ch] [ebp-4h]
  void *v31; // [esp+64h] [ebp+14h]
  const void *v32; // [esp+64h] [ebp+14h]

  sub_A1F90();
  v26 = (int *)sub_9D450(140);
  if ( v26 )
  {
    *v26 = a1;
    if ( *(_DWORD *)(*v26 + 20) )
    {
      qmemcpy(&byte_181C90, aDigDriverRequi, 0x16u);
      sub_9D490((unsigned int)v26, 140);
      v20 = 0;
    }
    else
    {
      sub_91F70(*v26, 769, 0, &v16);
      v26[1] = v16 + 16 * v19;
      v26[2] = v17 + 16 * v18;
      v26[13] = v26[2] + 8;
      v26[14] = -1;
      v26[21] = 0;
      v26[22] = 0;
      v26[25] = 0;
      v26[26] = 127;
      memset(&unk_181D90, -1, 24);
      v28 = 0;
      if ( a2 )
      {
        qmemcpy(&unk_181D90, a2, 0x18u);
        if ( sub_A2C80(v26, a2) )
        {
          v28 = 1;
          qmemcpy(&v15, a2, 0x18u);
        }
      }
      if ( !v28 )
      {
        v31 = sub_92ED0(*v26);
        if ( v31 )
        {
          qmemcpy(&unk_181D90, v31, 0x18u);
          if ( sub_A2C80(v26, v31) )
          {
            v28 = 1;
            qmemcpy(&v15, v31, 0x18u);
          }
        }
      }
      if ( !v28 && dword_181DF0 == 1 )
      {
        for ( i = 0; *(unsigned __int16 *)(*(_DWORD *)(*v26 + 16) + 16) > i; ++i )
        {
          v32 = (const void *)(24 * i
                             + (*(_DWORD *)(*(_DWORD *)(*v26 + 16) + 12) & 0xFFFF)
                             + 16 * (*(_DWORD *)(*(_DWORD *)(*v26 + 16) + 12) >> 16));
          if ( !i )
            qmemcpy(&unk_181D90, v32, 0x18u);
          if ( sub_A2C80(v26, v32) )
          {
            v28 = 1;
            qmemcpy(&v15, v32, 0x18u);
            break;
          }
        }
      }
      if ( v28 )
      {
        qmemcpy(&unk_181D90, &v15, 0x18u);
        if ( dword_181DF4 )
          v25 = 0x2000;
        else
          v25 = dword_181DB4;
        v26[10] = 0;
        do
        {
          if ( !sub_9D4D0(
                  (v25 + 15 - (__CFSHL__((v25 + 15) >> 31, 4) + 16 * ((v25 + 15) >> 31))) >> 4,
                  (unsigned int *)&v30,
                  &v22,
                  &v21) )
          {
            qmemcpy(&byte_181C90, aCouldNotAlloca_0, 0x20u);
            sub_9D490((unsigned int)v26, 140);
            return 0;
          }
          if ( v26[10] )
          {
            v2 = v26[9];
            v3 = v26[8];
            sub_9D560(v26[10]);
          }
          v26[10] = v30;
          v26[8] = v22;
          v26[9] = v21;
          v27 = v22 >> 12;
          v24 = (unsigned int)&unk_F0000 & (v22 >> 12);
          v23 = (unsigned int)&unk_F0000 & (v25 + (v22 >> 12) - 1);
        }
        while ( ((unsigned int)&unk_F0000 & (v22 >> 12)) != v23 );
        if ( sub_A2650((int)v26) )
        {
          sub_91F70(*v26, 773, 0, 0);
          *(_DWORD *)(*v26 + 24) = 1;
          v26[18] = v26[4] / (v26[16] * v26[15]);
          v26[17] = v26[4] / v26[16];
          v26[19] = 4 * v26[17];
          v6 = sub_9D450(v26[19]);
          v26[20] = v6;
          if ( v26[20] )
          {
            v26[24] = dword_181DBC;
            v26[23] = sub_9D450(2196 * v26[24]);
            if ( v26[23] )
            {
              for ( i = 0; i < v26[24]; ++i )
              {
                *(_DWORD *)(2196 * i + v26[23] + 4) = 1;
                *(_DWORD *)(v26[23] + 2196 * i) = v26;
              }
              v11 = sub_92600((int)sub_A2450);
              v26[3] = v11;
              if ( v26[3] == -1 )
              {
                qmemcpy(&byte_181C90, aOutOfTimerHand_0, 0x16u);
                if ( *(_DWORD *)(a1 + 28) != -1 )
                  sub_91E90(*(_DWORD *)(a1 + 28));
                sub_91F70(*v26, 774, 0, 0);
                *(_DWORD *)(*v26 + 24) = 0;
                v12 = v26[9];
                v13 = v26[8];
                sub_9D560(v26[10]);
                sub_9D490(v26[23], 2196 * v26[24]);
                sub_9D490(v26[20], v26[19]);
                sub_9D490((unsigned int)v26, 140);
                v20 = 0;
              }
              else
              {
                sub_92740(v26[3], (signed __int32)v26);
                sub_92930(v26[3], dword_181DAC[0]);
                sub_92BA0(v26[3]);
                *(_DWORD *)(*v26 + 36) = sub_A2DE0;
                *(_DWORD *)(*v26 + 40) = v26;
                sub_B0C1A((int)v26);
                sub_B0B87(v26, 0);
                sub_B0B87(v26, 1);
                v20 = v26;
              }
            }
            else
            {
              qmemcpy(&byte_181C90, aCouldNotAlloca_2, 0x26u);
              if ( *(_DWORD *)(a1 + 28) != -1 )
                sub_91E90(*(_DWORD *)(a1 + 28));
              sub_91F70(*v26, 774, 0, 0);
              *(_DWORD *)(*v26 + 24) = 0;
              v9 = v26[9];
              v10 = v26[8];
              sub_9D560(v26[10]);
              sub_9D490(v26[20], v26[19]);
              sub_9D490((unsigned int)v26, 140);
              v20 = 0;
            }
          }
          else
          {
            qmemcpy(&byte_181C90, aCouldNotAlloca_1, 0x21u);
            if ( *(_DWORD *)(a1 + 28) != -1 )
              sub_91E90(*(_DWORD *)(a1 + 28));
            sub_91F70(*v26, 774, 0, 0);
            *(_DWORD *)(*v26 + 24) = 0;
            v7 = v26[9];
            v8 = v26[8];
            sub_9D560(v26[10]);
            sub_9D490((unsigned int)v26, 140);
            v20 = 0;
          }
        }
        else
        {
          v4 = v26[9];
          v5 = v26[8];
          sub_9D560(v26[10]);
          sub_9D490((unsigned int)v26, 140);
          v20 = 0;
        }
      }
      else
      {
        qmemcpy(&byte_181C90, aDigitalSoundHa, 0x22u);
        sub_9D490((unsigned int)v26, 140);
        v20 = 0;
      }
    }
  }
  else
  {
    qmemcpy(&byte_181C90, aCouldNotAlloca, 0x26u);
    v20 = 0;
  }
  return v20;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// A2450: using guessed type int sub_A2450();
// A2DE0: using guessed type int sub_A2DE0();
// 181C90: using guessed type char byte_181C90;
// 181DAC: using guessed type int dword_181DAC[];
// 181DB4: using guessed type int dword_181DB4;
// 181DBC: using guessed type int dword_181DBC;
// 181DF0: using guessed type int dword_181DF0;
// 181DF4: using guessed type int dword_181DF4;

//----- (000A3600) --------------------------------------------------------
int *__usercall sub_A3600@<eax>(int a1@<ebx>, int a2, const void *a3)
{
  int v3; // eax
  int *v5; // [esp+0h] [ebp-10h]
  int v6; // [esp+4h] [ebp-Ch]
  int *v7; // [esp+8h] [ebp-8h]
  _DWORD *v8; // [esp+Ch] [ebp-4h]

  v6 = sub_9DEA0(a2, 0);
  if ( v6 )
  {
    v3 = sub_9DE20(a2);
    v8 = sub_93010(a1, v6, v3);
    off_E3E34(v6);
    if ( v8 )
    {
      v7 = sub_A2EA0((int)v8, a3);
      if ( !v7 )
        sub_93160((unsigned int)v8);
      v5 = v7;
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    strcpy(&byte_181C90, "Driver file not found\n");
    v5 = 0;
  }
  return v5;
}
// E3E34: using guessed type int (__cdecl *off_E3E34)(int);
// 181C90: using guessed type char byte_181C90;

//----- (000A36B0) --------------------------------------------------------
int *__usercall sub_A36B0@<eax>(int a1@<ebx>, int a2, int a3, const void *a4)
{
  int *v6; // [esp+4h] [ebp-8h]
  _DWORD *v7; // [esp+8h] [ebp-4h]

  v7 = sub_93010(a1, a2, a3);
  if ( !v7 )
    return 0;
  v6 = sub_A2EA0((int)v7, a4);
  if ( !v6 )
    sub_93160((unsigned int)v7);
  return v6;
}

//----- (000A3720) --------------------------------------------------------
int __usercall sub_A3720@<eax>(int a1@<ebx>, int **a2)
{
  char v3; // [esp+0h] [ebp-11Ch]
  char v4; // [esp+80h] [ebp-9Ch]
  char v5; // [esp+100h] [ebp-1Ch]
  int v6; // [esp+118h] [ebp-4h]

  if ( sub_92190((int)&v3, (int)aDigIni_0) )
  {
    *a2 = sub_93330(a1, (int)&v4, &v5);
    if ( *a2 )
      v6 = 0;
    else
      v6 = 2;
  }
  else
  {
    qmemcpy(&byte_181C90, aUnableToOpenFi, 0x1Du);
    v6 = 1;
  }
  return v6;
}
// 181C90: using guessed type char byte_181C90;

//----- (000A37A0) --------------------------------------------------------
int __cdecl sub_A37A0(unsigned int *a1)
{
  return sub_93160(*a1);
}

//----- (000A37C0) --------------------------------------------------------
int __cdecl sub_A37C0(int a1)
{
  int v2; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h]

  v2 = 0;
  for ( i = 0; i < *(_DWORD *)(a1 + 96); ++i )
  {
    if ( *(_DWORD *)(2196 * i + *(_DWORD *)(a1 + 92) + 4) == 4 )
      ++v2;
  }
  return v2;
}

//----- (000A3820) --------------------------------------------------------
_DWORD *__cdecl sub_A3820(int a1)
{
  _DWORD *v1; // ST08_4
  _DWORD *v3; // [esp+0h] [ebp-Ch]
  int i; // [esp+8h] [ebp-4h]

  sub_91BD0();
  for ( i = 0; i < *(_DWORD *)(a1 + 96) && *(_DWORD *)(2196 * i + *(_DWORD *)(a1 + 92) + 4) != 1; ++i )
    ;
  if ( i == *(_DWORD *)(a1 + 96) )
  {
    qmemcpy(&byte_181C90, aOutOfSampleHan, 0x17u);
    sub_91BF0();
    v3 = 0;
  }
  else
  {
    v1 = (_DWORD *)(2196 * i + *(_DWORD *)(a1 + 92));
    sub_93830(v1);
    sub_91BF0();
    v3 = v1;
  }
  return v3;
}
// 181C90: using guessed type char byte_181C90;

//----- (000A38C0) --------------------------------------------------------
int __cdecl sub_A38C0(int a1)
{
  int result; // eax

  if ( a1 )
  {
    result = a1;
    *(_DWORD *)(a1 + 4) = 1;
  }
  return result;
}

//----- (000A38E0) --------------------------------------------------------
int __cdecl sub_A38E0(_DWORD *a1)
{
  int result; // eax

  if ( a1 )
  {
    a1[1] = 2;
    a1[2] = 0;
    a1[4] = 0;
    a1[6] = 0;
    a1[8] = 0;
    a1[3] = 0;
    a1[5] = 0;
    a1[7] = 0;
    a1[9] = 1;
    a1[10] = 0;
    a1[11] = -2;
    a1[12] = 1;
    a1[13] = 0;
    a1[14] = 0;
    a1[15] = 11025;
    a1[16] = dword_181DC0;
    if ( *(_DWORD *)(*a1 + 24) && *(_DWORD *)(*a1 + 24) != 1 )
      a1[17] = 64;
    else
      a1[17] = 0;
    a1[530] = 0;
    a1[531] = 0;
    a1[532] = 0;
    result = sub_A2110(a1);
  }
  return result;
}
// 181DC0: using guessed type int dword_181DC0;

//----- (000A3A00) --------------------------------------------------------
int __cdecl sub_A3A00(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( a1 )
    v2 = *(_DWORD *)(a1 + 4);
  else
    v2 = 0;
  return v2;
}

//----- (000A3A30) --------------------------------------------------------
_DWORD *__cdecl sub_A3A30(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax

  if ( a1 )
  {
    a1[2] = a2;
    a1[4] = a3;
    a1[3] = 0;
    result = a1;
    a1[5] = 0;
  }
  return result;
}

//----- (000A3A70) --------------------------------------------------------
int __cdecl sub_A3A70(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  if ( a1 )
  {
    if ( a2 != a1[13] || (result = a3, a3 != a1[14]) )
    {
      a1[13] = a2;
      a1[14] = a3;
      result = sub_A2110(a1);
    }
  }
  return result;
}

//----- (000A3AC0) --------------------------------------------------------
int __cdecl sub_A3AC0(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( a1 )
    v2 = *(_DWORD *)(a1 + 60);
  else
    v2 = 0;
  return v2;
}

//----- (000A3AF0) --------------------------------------------------------
int __cdecl sub_A3AF0(int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    result = a2;
    *(_DWORD *)(a1 + 60) = a2;
  }
  return result;
}

//----- (000A3B10) --------------------------------------------------------
int __cdecl sub_A3B10(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( a1 )
    v2 = *(_DWORD *)(a1 + 64);
  else
    v2 = 0;
  return v2;
}

//----- (000A3B40) --------------------------------------------------------
int __cdecl sub_A3B40(_DWORD *a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    result = a2;
    if ( a2 != a1[16] )
    {
      a1[16] = a2;
      result = sub_A2110(a1);
    }
  }
  return result;
}

//----- (000A3B80) --------------------------------------------------------
int __cdecl sub_A3B80(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( a1 )
    v2 = *(_DWORD *)(a1 + 68);
  else
    v2 = 0;
  return v2;
}

//----- (000A3BB0) --------------------------------------------------------
int __cdecl sub_A3BB0(_DWORD *a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    result = a2;
    if ( a2 != a1[17] )
    {
      a1[17] = a2;
      result = sub_A2110(a1);
    }
  }
  return result;
}

//----- (000A3BF0) --------------------------------------------------------
int __cdecl sub_A3BF0(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( a1 )
    v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 40) + 24);
  else
    v2 = 0;
  return v2;
}

//----- (000A3C30) --------------------------------------------------------
int __cdecl sub_A3C30(int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    result = a2;
    *(_DWORD *)(4 * *(_DWORD *)(a1 + 40) + a1 + 24) = a2;
  }
  return result;
}

//----- (000A3C60) --------------------------------------------------------
signed int __cdecl sub_A3C60(int a1)
{
  signed int v2; // [esp+0h] [ebp-4h]

  if ( a1 )
    v2 = *(_DWORD *)(a1 + 48);
  else
    v2 = -1;
  return v2;
}

//----- (000A3C90) --------------------------------------------------------
int __cdecl sub_A3C90(int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    result = a2;
    *(_DWORD *)(a1 + 48) = a2;
  }
  return result;
}

//----- (000A3CB0) --------------------------------------------------------
int __cdecl sub_A3CB0(int *a1)
{
  int result; // eax

  if ( a1 )
  {
    result = (int)a1;
    if ( a1[1] != 1 )
    {
      result = (int)&a1[a1[10]];
      if ( *(_DWORD *)(result + 16) )
      {
        result = (int)&a1[a1[10]];
        if ( *(_DWORD *)(result + 8) )
        {
          a1[a1[10] + 6] = 0;
          a1[1] = 4;
          result = sub_A2070(*a1);
        }
      }
    }
  }
  return result;
}

//----- (000A3D30) --------------------------------------------------------
int __cdecl sub_A3D30(int a1)
{
  int result; // eax

  if ( a1 )
  {
    result = a1;
    if ( *(_DWORD *)(a1 + 4) == 4 )
    {
      result = a1;
      *(_DWORD *)(a1 + 4) = 8;
    }
  }
  return result;
}

//----- (000A3D60) --------------------------------------------------------
int __cdecl sub_A3D60(int *a1)
{
  int result; // eax

  if ( a1 )
  {
    result = (int)a1;
    if ( a1[1] == 8 )
    {
      a1[1] = 4;
      result = sub_A2070(*a1);
    }
  }
  return result;
}

//----- (000A3DA0) --------------------------------------------------------
int __cdecl sub_A3DA0(int a1)
{
  int result; // eax

  if ( a1 )
  {
    result = a1;
    if ( *(_DWORD *)(a1 + 4) != 1 )
    {
      result = a1;
      if ( *(_DWORD *)(a1 + 4) != 2 )
      {
        *(_DWORD *)(a1 + 4) = 2;
        if ( *(_DWORD *)(a1 + 2124) )
          (*(void (__cdecl **)(int))(a1 + 2124))(a1);
        result = a1;
        if ( *(_DWORD *)(a1 + 2128) )
          result = (*(int (__cdecl **)(int))(a1 + 2128))(a1);
      }
    }
  }
  return result;
}

//----- (000A3E10) --------------------------------------------------------
int __cdecl sub_A3E10(int a1, int a2)
{
  int v2; // ST04_4

  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 2120);
  *(_DWORD *)(a1 + 2120) = a2;
  return v2;
}

//----- (000A3E60) --------------------------------------------------------
int __cdecl sub_A3E60(int a1, int a2)
{
  int v2; // ST04_4

  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 2124);
  *(_DWORD *)(a1 + 2124) = a2;
  return v2;
}

//----- (000A3EB0) --------------------------------------------------------
int __cdecl sub_A3EB0(int a1, int a2)
{
  int v2; // ST04_4

  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 2128);
  *(_DWORD *)(a1 + 2128) = a2;
  return v2;
}

//----- (000A3F00) --------------------------------------------------------
int __cdecl sub_A3F00(int a1, int a2, int a3)
{
  int result; // eax

  if ( a1 )
  {
    result = a3;
    *(_DWORD *)(4 * a2 + a1 + 2132) = a3;
  }
  return result;
}

//----- (000A3F30) --------------------------------------------------------
int __cdecl sub_A3F30(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-4h]

  if ( a1 )
    v3 = *(_DWORD *)(a1 + 4 * a2 + 2132);
  else
    v3 = 0;
  return v3;
}

//----- (000A3F70) --------------------------------------------------------
int __cdecl sub_A3F70(_DWORD *a1, int a2)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  a1[26] = a2;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a1[24] )
      break;
    if ( *(_DWORD *)(2196 * i + a1[23] + 4) != 1 )
      sub_A2110((_DWORD *)(2196 * i + a1[23]));
  }
  return result;
}

//----- (000A3FE0) --------------------------------------------------------
int __cdecl sub_A3FE0(int a1)
{
  return *(_DWORD *)(a1 + 104);
}

//----- (000A4000) --------------------------------------------------------
char __cdecl sub_A4000(_DWORD *a1, int a2, unsigned int a3)
{
  int v3; // ST04_4
  signed int v5; // [esp+Ch] [ebp-4h]

  if ( a3 <= 3 )
  {
    switch ( a3 )
    {
      case 0u:
        v5 = 1;
        break;
      case 1u:
        v5 = 2;
        break;
      case 2u:
        v5 = 2;
        break;
      case 3u:
        v5 = 4;
        break;
    }
  }
  v3 = a2 * (v5 * a1[4] / (a1[16] * a1[15])) / a1[5];
  if ( a1[5] != a2 && 2 * a2 != a1[5] )
    a1[5];
  return 0;
}

//----- (000A4100) --------------------------------------------------------
int __cdecl sub_A4100(int *a1, int a2, int a3, int a4)
{
  int result; // eax

  if ( a1 )
  {
    a1[a2 + 8] = a4 == 0;
    a1[a2 + 2] = a3;
    a1[a2 + 4] = a4;
    result = (int)&a1[a2];
    *(_DWORD *)(result + 24) = 0;
    if ( a4 )
    {
      result = (int)a1;
      if ( a1[1] != 4 )
      {
        a1[1] = 4;
        result = sub_A2070(*a1);
      }
    }
  }
  return result;
}

//----- (000A41B0) --------------------------------------------------------
signed int __cdecl sub_A41B0(_DWORD *a1)
{
  int v1; // eax
  unsigned int v3; // [esp+0h] [ebp-8h]

  if ( !a1 )
    return -1;
  v3 = a1[11];
  if ( v3 >= 0xFFFFFFFE )
  {
    if ( v3 <= 0xFFFFFFFE )
    {
      a1[9] = 0;
      a1[11] = -1;
      return 0;
    }
    if ( v3 == -1 )
    {
      a1[11] = a1[10];
      return 1;
    }
  }
  if ( a1[11] == a1[10] )
    return -1;
  a1[11] = a1[10];
  v1 = a1[10];
  LOBYTE(v1) = v1 ^ 1;
  return v1;
}

//----- (000A4260) --------------------------------------------------------
bool sub_A4260()
{
  bool result; // eax

  if ( dword_E4A90 )
  {
    sub_9D650((unsigned int)sub_A1F90, (unsigned int)sub_A4260);
    sub_9D740((unsigned int)byte_E4A0C, 128);
    sub_9D740((unsigned int)&dword_E4A8C, 4);
    sub_9D740((unsigned int)&dword_181E94, 4);
    sub_9D740((unsigned int)&unk_181E80, 12);
    sub_9D740((unsigned int)&dword_181E9C, 4);
    sub_9D740((unsigned int)&dword_181EA0, 4);
    sub_9D740((unsigned int)&dword_181E90, 4);
    sub_9D740((unsigned int)&dword_181E98, 4);
    result = sub_9D740((unsigned int)&dword_181E8C, 4);
    dword_E4A90 = 0;
  }
  return result;
}
// E4A8C: using guessed type int dword_E4A8C;
// E4A90: using guessed type int dword_E4A90;
// 181E8C: using guessed type int dword_181E8C;
// 181E90: using guessed type int dword_181E90;
// 181E94: using guessed type int dword_181E94;
// 181E98: using guessed type int dword_181E98;
// 181E9C: using guessed type int dword_181E9C;
// 181EA0: using guessed type int dword_181EA0;

//----- (000A4330) --------------------------------------------------------
bool sub_A4330()
{
  bool result; // eax

  if ( !dword_E4A94 )
  {
    result = sub_9D590((unsigned int)sub_A4330, (unsigned int)sub_A4CB0);
    dword_E4A94 = 1;
  }
  return result;
}
// E4A94: using guessed type int dword_E4A94;

//----- (000A4370) --------------------------------------------------------
int __cdecl sub_A4370(_DWORD *a1)
{
  return *a1 >> 8;
}

//----- (000A4390) --------------------------------------------------------
int __cdecl sub_A4390(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 2164) )
    (*(void (__cdecl **)(int))(a1 + 2164))(a1);
  if ( *(_DWORD *)(a1 + 2188) > 0 )
    sub_937A0(a1);
  result = a1;
  *(_DWORD *)(a1 + 2188) = -1;
  return result;
}

//----- (000A43E0) --------------------------------------------------------
void __cdecl sub_A43E0(int a1)
{
  _DWORD *v1; // [esp+4h] [ebp-8h]

  while ( 1 )
  {
    v1 = *(_DWORD **)(a1 + 2168);
    if ( *(_BYTE *)v1 <= 9u )
      break;
    *(_DWORD *)(a1 + 2168) = (char *)v1 + sub_A4370(v1) + 4;
  }
  JUMPOUT(__CS__, *(&off_A4400 + *(unsigned __int8 *)v1));
}
// A4400: using guessed type void *off_A4400;

//----- (000A47C0) --------------------------------------------------------
_DWORD *__cdecl sub_A47C0(int a1, _DWORD *a2)
{
  int i; // eax
  int j; // eax
  int v5; // [esp+0h] [ebp-8h]
  int v6; // [esp+4h] [ebp-4h]

  v6 = a1 + 12;
  for ( i = strnicmp(a1 + 12, aFmt, 4); i; i = strnicmp(v6, aFmt, 4) )
    v6 += (*(_DWORD *)(v6 + 4) & 1) + *(_DWORD *)(v6 + 4) + 8;
  if ( *(_WORD *)(v6 + 10) == 1 && *(_WORD *)(v6 + 22) == 8 )
  {
    sub_93AB0(a2, 0, 0);
  }
  else if ( *(_WORD *)(v6 + 10) == 2 && *(_WORD *)(v6 + 22) == 8 )
  {
    sub_93AB0(a2, 2, 0);
  }
  else if ( *(_WORD *)(v6 + 10) == 1 && *(_WORD *)(v6 + 22) == 16 )
  {
    sub_93AB0(a2, 1, 1);
  }
  else if ( *(_WORD *)(v6 + 10) == 2 && *(_WORD *)(v6 + 22) == 16 )
  {
    sub_93AB0(a2, 3, 1);
  }
  sub_93D90((int)a2, *(_DWORD *)(v6 + 12));
  v5 = a1 + 12;
  for ( j = strnicmp(a1 + 12, aData_0, 4); j; j = strnicmp(v5, aData_0, 4) )
    v5 += (*(_DWORD *)(v5 + 4) & 1) + *(_DWORD *)(v5 + 4) + 8;
  return sub_93A10(a2, v5 + 8, *(_DWORD *)(v5 + 4));
}
// 99B23: using guessed type _DWORD __cdecl strnicmp(_DWORD, _DWORD, _DWORD);

//----- (000A4970) --------------------------------------------------------
_DWORD *__cdecl sub_A4970(int a1, int a2, int a3)
{
  signed int v5; // [esp+8h] [ebp-8h]
  _DWORD *v6; // [esp+Ch] [ebp-4h]

  sub_A4330();
  if ( !strnicmp(a2, aCreative, 8) )
  {
    v5 = 0;
  }
  else
  {
    if ( strnicmp(a2 + 8, aWave, 4) )
    {
      qmemcpy(&byte_181C90, aUnrecognizedDi, 0x26u);
      return 0;
    }
    v5 = 1;
  }
  v6 = sub_93510(a1);
  if ( !v6 )
    return 0;
  sub_93830(v6);
  v6[541] = 0;
  if ( v5 )
  {
    if ( v5 == 1 )
    {
      v6[547] = 1;
      sub_95140((int)v6, (int)sub_A4920);
      sub_A47C0(a2, v6);
    }
  }
  else
  {
    v6[542] = *(unsigned __int16 *)(a2 + 20) + a2;
    v6[545] = a3;
    v6[546] = a3 == -1;
    v6[547] = 1;
    sub_95140((int)v6, (int)sub_A47A0);
    sub_A43E0((int)v6);
  }
  if ( v6[547] != -1 )
    return v6;
  strcpy(&byte_181C90, "Invalid or missing data block\n");
  return 0;
}
// 99B23: using guessed type _DWORD __cdecl strnicmp(_DWORD, _DWORD, _DWORD);
// A47A0: using guessed type int sub_A47A0();
// A4920: using guessed type int sub_A4920();
// 181C90: using guessed type char byte_181C90;

//----- (000A4B20) --------------------------------------------------------
signed int __cdecl sub_A4B20(_DWORD *a1, int a2, int a3)
{
  signed int v5; // [esp+8h] [ebp-4h]

  if ( !strnicmp(a2, aCreative, 8) )
  {
    v5 = 0;
  }
  else
  {
    if ( strnicmp(a2 + 8, aWave, 4) )
    {
      qmemcpy(&byte_181C90, aUnrecognizedDi_0, 0x26u);
      return 0;
    }
    v5 = 1;
  }
  if ( v5 )
  {
    if ( v5 == 1 )
    {
      a1[547] = 0;
      sub_A47C0(a2, a1);
    }
  }
  else
  {
    a1[542] = *(unsigned __int16 *)(a2 + 20) + a2;
    a1[545] = a3;
    a1[546] = a3 == -1;
    a1[547] = 0;
    sub_A43E0((int)a1);
  }
  if ( a1[547] != -1 )
    return 1;
  strcpy(&byte_181C90, "Invalid or missing data block\n");
  return 0;
}
// 99B23: using guessed type _DWORD __cdecl strnicmp(_DWORD, _DWORD, _DWORD);
// 181C90: using guessed type char byte_181C90;

//----- (000A4C60) --------------------------------------------------------
int __cdecl sub_A4C60(int a1, int a2)
{
  int v2; // ST04_4

  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 2164);
  *(_DWORD *)(a1 + 2164) = a2;
  return v2;
}

//----- (000A4CB0) --------------------------------------------------------
bool sub_A4CB0()
{
  bool result; // eax

  if ( dword_E4A94 )
  {
    result = sub_9D650((unsigned int)sub_A4330, (unsigned int)sub_A4CB0);
    dword_E4A94 = 0;
  }
  return result;
}
// E4A94: using guessed type int dword_E4A94;

//----- (000A4CF0) --------------------------------------------------------
bool sub_A4CF0()
{
  bool result; // eax

  if ( !dword_E4B1C )
  {
    sub_9D590((unsigned int)sub_A4CF0, (unsigned int)sub_A9280);
    sub_9D710((unsigned int)aSample, 128);
    sub_9D710((unsigned int)&dword_E4B18, 4);
    sub_9D710((unsigned int)&dword_181EB8, 4);
    sub_9D710((unsigned int)&dword_181EBC, 4);
    sub_9D710((unsigned int)&dword_181EC0, 4);
    sub_9D710((unsigned int)&dword_181EC4, 4);
    sub_9D710((unsigned int)&dword_181ED4, 4);
    sub_9D710((unsigned int)&dword_181EC8, 4);
    sub_9D710((unsigned int)&dword_181ECC, 4);
    sub_9D710((unsigned int)&dword_181EB4, 4);
    sub_9D710((unsigned int)&dword_181ED0, 4);
    sub_9D710((unsigned int)&dword_181EDC, 4);
    sub_9D710((unsigned int)&dword_181ED8, 4);
    result = sub_9D710((unsigned int)&dword_181EB0, 4);
    dword_E4B1C = 1;
  }
  return result;
}
// E4B18: using guessed type int dword_E4B18;
// E4B1C: using guessed type int dword_E4B1C;
// 181EB0: using guessed type int dword_181EB0;
// 181EB4: using guessed type int dword_181EB4;
// 181EB8: using guessed type int dword_181EB8;
// 181EBC: using guessed type int dword_181EBC;
// 181EC0: using guessed type int dword_181EC0;
// 181EC4: using guessed type int dword_181EC4;
// 181EC8: using guessed type int dword_181EC8;
// 181ECC: using guessed type int dword_181ECC;
// 181ED0: using guessed type int dword_181ED0;
// 181ED4: using guessed type int dword_181ED4;
// 181ED8: using guessed type int dword_181ED8;
// 181EDC: using guessed type int dword_181EDC;

//----- (000A4E10) --------------------------------------------------------
signed int __cdecl sub_A4E10(char a1)
{
  unsigned int v2; // [esp+0h] [ebp-8h]

  v2 = a1 & 0xF0;
  if ( v2 < 0xB0 )
  {
    if ( v2 < 0x90 )
    {
      if ( v2 != 128 )
        return 0;
    }
    else if ( v2 > 0x90 && v2 != 160 )
    {
      return 0;
    }
    return 3;
  }
  if ( v2 > 0xB0 )
  {
    if ( v2 < 0xD0 )
    {
      if ( v2 != 192 )
        return 0;
    }
    else if ( v2 > 0xD0 )
    {
      if ( v2 != 224 )
        return 0;
      return 3;
    }
    return 2;
  }
  return 3;
}

//----- (000A4EB0) --------------------------------------------------------
int __cdecl sub_A4EB0(int a1)
{
  int result; // eax
  char v2; // [esp+0h] [ebp-Ch]
  __int16 v3; // [esp+4h] [ebp-8h]

  result = a1;
  if ( *(_DWORD *)(a1 + 424) > 0 )
  {
    v3 = *(_WORD *)(a1 + 424);
    sub_91F70(*(_DWORD *)a1, 1282, &v2, 0);
    *(_DWORD *)(a1 + 424) = 0;
    result = a1;
    *(_DWORD *)(a1 + 428) = 0;
  }
  return result;
}

//----- (000A4F10) --------------------------------------------------------
int __cdecl sub_A4F10(int a1, char a2, char a3, char a4)
{
  int v4; // ebx
  int v5; // edx
  int v6; // ebx
  int v7; // edx
  int v8; // ebx
  int v9; // edx
  int result; // eax
  signed int v11; // [esp+0h] [ebp-4h]

  v11 = sub_A4E10(a2);
  if ( (unsigned int)(v11 + *(_DWORD *)(a1 + 428)) > 0x200 )
    sub_A4EB0(a1);
  v4 = *(_DWORD *)(a1 + 8);
  v5 = (*(_DWORD *)(a1 + 428))++;
  *(_BYTE *)(v4 + v5 + 256) = a2;
  v6 = *(_DWORD *)(a1 + 8);
  v7 = (*(_DWORD *)(a1 + 428))++;
  *(_BYTE *)(v6 + v7 + 256) = a3;
  if ( v11 == 3 )
  {
    v8 = *(_DWORD *)(a1 + 8);
    v9 = (*(_DWORD *)(a1 + 428))++;
    *(_BYTE *)(v8 + v9 + 256) = a4;
  }
  result = a1;
  ++*(_DWORD *)(result + 424);
  return result;
}

//----- (000A4FD0) --------------------------------------------------------
int __cdecl sub_A4FD0(int a1, int a2, unsigned int a3)
{
  sub_A4EB0(a1);
  if ( a3 <= 0x200 )
    memmove(*(_DWORD *)(a1 + 8) + 256, a2, a3);
  else
    memmove(*(_DWORD *)(a1 + 8) + 256, a2, 512);
  ++*(_DWORD *)(a1 + 424);
  return sub_A4EB0(a1);
}
// AD81F: using guessed type _DWORD __cdecl memmove(_DWORD, _DWORD, _DWORD);

//----- (000A5040) --------------------------------------------------------
int __cdecl sub_A5040(_DWORD *a1)
{
  char v1; // ST08_1
  signed int v3; // [esp+4h] [ebp-Ch]
  int v4; // [esp+Ch] [ebp-4h]

  v4 = 0;
  v3 = 4;
  do
  {
    v1 = *(_BYTE *)(*a1)++;
    v4 = v1 & 0x7F | (v4 << 7);
    if ( !(v1 & 0x80) )
      break;
    --v3;
  }
  while ( v3 );
  return v4;
}

//----- (000A50A0) --------------------------------------------------------
unsigned int __cdecl sub_A50A0(int a1)
{
  return ((a1 & 0xFF000000) >> 24)
       + ((a1 & 0xFF0000u) >> 8)
       + ((unsigned __int16)(a1 & 0xFF00) << 8)
       + ((unsigned __int8)a1 << 24);
}

//----- (000A50F0) --------------------------------------------------------
unsigned int __cdecl sub_A50F0(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch]
  unsigned int v4; // [esp+4h] [ebp-8h]
  unsigned int v5; // [esp+8h] [ebp-4h]
  unsigned int i; // [esp+1Ch] [ebp+10h]

  v5 = 0;
  do
  {
    a1 += v5;
    if ( strncmp(a1, aForm, 4) && strncmp(a1, aCat, 4) )
      return 0;
    v5 = sub_A50A0(*(_DWORD *)(a1 + 4)) + 8;
  }
  while ( strncmp(a1 + 8, aXmid, 4) );
  if ( !strncmp(a1, aForm, 4) )
  {
    if ( a2 )
      v3 = 0;
    else
      v3 = a1;
  }
  else
  {
    v4 = v5 + a1;
    for ( i = a1 + 12; i < v4; i += sub_A50A0(*(_DWORD *)(i + 4)) + 8 )
    {
      if ( !strncmp(i + 8, aXmid, 4) && --a2 == -1 )
        return i;
    }
    v3 = 0;
  }
  return v3;
}
// 99682: using guessed type _DWORD __cdecl strncmp(_DWORD, _DWORD, _DWORD);

//----- (000A5210) --------------------------------------------------------
int __cdecl sub_A5210(int a1, char a2, unsigned int a3)
{
  int v4; // [esp+0h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-8h]
  unsigned int v6; // [esp+8h] [ebp-4h]

  v6 = a2 & 0xF0;
  v5 = a2 & 0xF;
  if ( v6 < 0xC0 )
  {
    if ( v6 != 176 )
      return -1;
    if ( a3 < 0x5D )
    {
      if ( a3 < 0xA )
      {
        if ( a3 < 6 )
        {
          if ( a3 == 1 )
            return *(_DWORD *)(a1 + 4 * v5 + 640);
        }
        else
        {
          if ( a3 <= 6 )
            return *(_DWORD *)(a1 + 4 * v5 + 1088);
          if ( a3 == 7 )
            return *(_DWORD *)(a1 + 4 * v5 + 704);
        }
      }
      else
      {
        if ( a3 <= 0xA )
          return *(_DWORD *)(a1 + 4 * v5 + 768);
        if ( a3 < 0x40 )
        {
          if ( a3 == 11 )
            return *(_DWORD *)(a1 + 4 * v5 + 832);
        }
        else
        {
          if ( a3 <= 0x40 )
            return *(_DWORD *)(a1 + 4 * v5 + 896);
          if ( a3 == 91 )
            return *(_DWORD *)(a1 + 4 * v5 + 960);
        }
      }
    }
    else
    {
      if ( a3 <= 0x5D )
        return *(_DWORD *)(a1 + 4 * v5 + 1024);
      if ( a3 < 0x70 )
      {
        if ( a3 >= 0x6E )
        {
          if ( a3 <= 0x6E )
            v4 = *(_DWORD *)(a1 + 4 * v5 + 192);
          else
            v4 = *(_DWORD *)(a1 + 4 * v5 + 256);
          return v4;
        }
        if ( a3 == 107 )
          return *(_DWORD *)(a1 + 4 * v5 + 320);
      }
      else
      {
        if ( a3 <= 0x70 )
          return *(_DWORD *)(a1 + 4 * v5 + 384);
        if ( a3 < 0x73 )
        {
          if ( a3 == 114 )
            return *(_DWORD *)(a1 + 4 * v5 + 448);
        }
        else
        {
          if ( a3 <= 0x73 )
            return *(_DWORD *)(a1 + 4 * v5 + 512);
          if ( a3 == 119 )
            return *(_DWORD *)(a1 + 4 * v5 + 576);
        }
      }
    }
    return -1;
  }
  if ( v6 <= 0xC0 )
    return *(_DWORD *)(a1 + 4 * v5);
  if ( v6 != 224 )
    return -1;
  return (*(_DWORD *)(a1 + 4 * v5 + 128) << 7) | *(_DWORD *)(a1 + 4 * v5 + 64);
}

//----- (000A5530) --------------------------------------------------------
_DWORD *__cdecl sub_A5530(int a1, char a2, unsigned int a3, unsigned __int8 a4)
{
  _DWORD *result; // eax
  int v5; // [esp+0h] [ebp-8h]
  unsigned int v6; // [esp+4h] [ebp-4h]

  v6 = a2 & 0xF0;
  result = (_DWORD *)(a2 & 0xF);
  v5 = a2 & 0xF;
  if ( v6 < 0xC0 )
  {
    if ( v6 == 176 )
    {
      if ( a3 < 0x5D )
      {
        if ( a3 < 0xA )
        {
          if ( a3 < 6 )
          {
            if ( a3 == 1 )
            {
              result = (_DWORD *)(a1 + 4 * v5);
              result[160] = a4;
            }
          }
          else if ( a3 <= 6 )
          {
            result = (_DWORD *)(a1 + 4 * v5);
            result[272] = a4;
          }
          else if ( a3 == 7 )
          {
            result = (_DWORD *)(a1 + 4 * v5);
            result[176] = a4;
          }
        }
        else if ( a3 <= 0xA )
        {
          result = (_DWORD *)(a1 + 4 * v5);
          result[192] = a4;
        }
        else if ( a3 < 0x40 )
        {
          if ( a3 == 11 )
          {
            result = (_DWORD *)(a1 + 4 * v5);
            result[208] = a4;
          }
        }
        else if ( a3 <= 0x40 )
        {
          result = (_DWORD *)(a1 + 4 * v5);
          result[224] = a4;
        }
        else if ( a3 == 91 )
        {
          result = (_DWORD *)(a1 + 4 * v5);
          result[240] = a4;
        }
      }
      else if ( a3 <= 0x5D )
      {
        result = (_DWORD *)(a1 + 4 * v5);
        result[256] = a4;
      }
      else if ( a3 < 0x70 )
      {
        if ( a3 < 0x6E )
        {
          if ( a3 == 107 )
          {
            result = (_DWORD *)(a1 + 4 * v5);
            result[80] = a4;
          }
        }
        else if ( a3 <= 0x6E )
        {
          result = (_DWORD *)(a1 + 4 * v5);
          result[48] = a4;
        }
        else
        {
          result = (_DWORD *)(a1 + 4 * v5);
          result[64] = a4;
        }
      }
      else if ( a3 <= 0x70 )
      {
        result = (_DWORD *)(a1 + 4 * v5);
        result[96] = a4;
      }
      else if ( a3 < 0x73 )
      {
        if ( a3 == 114 )
        {
          result = (_DWORD *)(a1 + 4 * v5);
          result[112] = a4;
        }
      }
      else if ( a3 <= 0x73 )
      {
        result = (_DWORD *)(a1 + 4 * v5);
        result[128] = a4;
      }
      else if ( a3 == 119 )
      {
        result = (_DWORD *)(a1 + 4 * v5);
        result[144] = a4;
      }
    }
  }
  else if ( v6 <= 0xC0 )
  {
    result = (_DWORD *)(a1 + 4 * v5);
    *result = (unsigned __int8)a3;
  }
  else if ( v6 == 224 )
  {
    *(_DWORD *)(a1 + 4 * v5 + 64) = (unsigned __int8)a3;
    result = (_DWORD *)(a1 + 4 * v5);
    result[32] = a4;
  }
  return result;
}

//----- (000A5850) --------------------------------------------------------
_DWORD *__cdecl sub_A5850(int a1, char a2, unsigned int a3, signed int a4, int a5)
{
  _DWORD *result; // eax
  int v6; // eax
  _DWORD *v7; // [esp+0h] [ebp-14h]
  int v8; // [esp+4h] [ebp-10h]
  int v9; // [esp+8h] [ebp-Ch]
  signed int i; // [esp+Ch] [ebp-8h]
  signed int j; // [esp+Ch] [ebp-8h]
  _DWORD *v12; // [esp+Ch] [ebp-8h]
  int v13; // [esp+10h] [ebp-4h]

  v7 = *(_DWORD **)a1;
  v13 = a2 & 0xF0;
  v8 = a2 & 0xF;
  result = *(_DWORD **)(a1 + 4 * v8 + 148);
  v9 = *(_DWORD *)(a1 + 4 * v8 + 148);
  if ( v13 == 176 || v13 == 192 || v13 == 224 )
    result = sub_A5530(a1 + 212, v8 | v13, a3, a4);
  if ( v13 != 176 )
    goto LABEL_79;
  if ( a5 )
  {
    result = (_DWORD *)(a1 + 4 * v8);
    if ( result[181] != -1 )
    {
      a4 = *(_DWORD *)(a1 + 4 * v8 + 724);
      result = (_DWORD *)(a1 + 4 * v8);
      result[181] = -1;
    }
  }
  if ( a3 < 0x6F )
  {
    if ( a3 < 0x6C )
    {
      if ( a3 >= 6 )
      {
        if ( a3 <= 6 )
        {
          sub_A5850(a1, v8 | 0xB0, 0x64u, 0, 0);
          sub_A5850(a1, v8 | 0xB0, 0x65u, 0, 0);
          sub_A5850(a1, v8 | 0xB0, 0x26u, 0, 0);
        }
        else if ( a3 == 7 )
        {
          a4 = *(_DWORD *)(a1 + 56) * a4 * v7[108] / 16129;
          if ( a4 > 127 )
            a4 = 127;
          if ( a4 < 0 )
            a4 = 0;
        }
      }
      goto LABEL_79;
    }
    if ( a3 <= 0x6C )
    {
      if ( *(_DWORD *)(a1 + 28) )
        *(_DWORD *)(a1 + 4 * v8 + 724) = (*(int (__cdecl **)(int, int, signed int))(a1 + 28))(a1, v8, a4);
      goto LABEL_79;
    }
    if ( a3 <= 0x6D )
    {
      result = sub_97480((_DWORD *)a1, a4);
    }
    else if ( a4 < 64 )
    {
      result = &v7[v9];
      if ( result[8] == 1 )
      {
        sub_A5F30((int *)a1, v8);
        sub_980D0(v7, v9 + 1);
        result = (_DWORD *)sub_98170((_DWORD *)a1, v8 + 1, v8 + 1);
      }
    }
    else
    {
      result = &v7[v9];
      if ( result[8] != 1 )
      {
        result = (_DWORD *)sub_97F90(v7);
        v12 = result;
        if ( result )
        {
          sub_98170((_DWORD *)a1, v8 + 1, (int)result);
          result = (_DWORD *)a1;
          v7[(_DWORD)v12 + 23] = a1;
        }
      }
    }
  }
  else if ( a3 <= 0x6F )
  {
    result = &v7[v9];
    if ( result[8] != 1 )
    {
      if ( a4 >= 64 )
      {
        result = &v7[v9];
        result[8] = 2;
      }
      else
      {
        result = &v7[v9];
        result[8] = 0;
      }
    }
  }
  else if ( a3 < 0x75 )
  {
    if ( a3 < 0x73 )
      goto LABEL_79;
    if ( a3 <= 0x73 )
    {
      *(_DWORD *)(a1 + 4 * v8 + 724) = *(unsigned __int8 *)(a4 + *(_DWORD *)(a1 + 24));
LABEL_79:
      if ( v7[v9 + 8] != 1 || (result = (_DWORD *)v7[v9 + 24], result == (_DWORD *)a1) )
      {
        if ( v13 == 144 )
        {
          ++v7[v9 + 88];
        }
        else if ( v13 == 128 )
        {
          --v7[v9 + 88];
        }
        v7[v9 + 56] = a1;
        if ( v13 != 144 || (result = (_DWORD *)(a1 + 4 * v8), result[133] < 64) )
        {
          if ( !v7[104]
            || (result = (_DWORD *)((int (__cdecl *)(_DWORD *, int, int, unsigned int, signed int))v7[104])(
                                     v7,
                                     a1,
                                     v9 | v13,
                                     a3,
                                     a4)) == 0 )
          {
            result = (_DWORD *)sub_A4F10((int)v7, v9 | v13, a3, a4);
          }
        }
      }
      return result;
    }
    for ( i = 0; i < 4; ++i )
    {
      result = (_DWORD *)(a1 + 4 * i);
      if ( result[33] == -1 )
        break;
      result = (_DWORD *)i;
    }
    if ( i != 4 )
    {
      *(_DWORD *)(4 * i + a1 + 132) = a4;
      result = *(_DWORD **)(a1 + 20);
      *(_DWORD *)(4 * i + a1 + 116) = result;
    }
  }
  else if ( a3 <= 0x75 )
  {
    if ( a4 >= 64 )
    {
      for ( j = 3; j >= 0; --j )
      {
        result = (_DWORD *)(a1 + 4 * j);
        if ( result[33] != -1 )
          break;
        result = (_DWORD *)j;
      }
      if ( j != -1 )
      {
        if ( *(_DWORD *)(a1 + 4 * j + 132) )
        {
          v6 = a1 + 4 * j;
          if ( --*(_DWORD *)(v6 + 132) )
          {
            result = (_DWORD *)a1;
            *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 4 * j + 116);
          }
          else
          {
            result = (_DWORD *)(a1 + 4 * j);
            result[33] = -1;
          }
        }
        else
        {
          result = (_DWORD *)a1;
          *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 4 * j + 116);
        }
      }
    }
  }
  else if ( a3 <= 0x76 )
  {
    *(_DWORD *)(a1 + 92) = 0;
    *(_DWORD *)(a1 + 96) = 0;
    *(_DWORD *)(a1 + 108) = 0;
    *(_DWORD *)(a1 + 108) -= *(_DWORD *)(a1 + 104);
    result = (_DWORD *)a1;
    if ( *(_DWORD *)(a1 + 36) )
      result = (_DWORD *)(*(int (__cdecl **)(_DWORD *, int, _DWORD, _DWORD))(a1 + 36))(v7, a1, 0, 0);
  }
  else
  {
    if ( a3 != 119 )
      goto LABEL_79;
    result = (_DWORD *)a1;
    if ( *(_DWORD *)(a1 + 32) )
      result = (_DWORD *)(*(int (__cdecl **)(int, int, signed int))(a1 + 32))(a1, v8, a4);
  }
  return result;
}

//----- (000A5E50) --------------------------------------------------------
char __cdecl sub_A5E50(int *a1)
{
  int v1; // eax
  int v3; // [esp+0h] [ebp-8h]
  signed int i; // [esp+4h] [ebp-4h]

  v3 = 0;
  for ( i = 0; i < 32; ++i )
  {
    if ( a1[i + 342] != -1 )
    {
      sub_A5850((int)a1, a1[i + 342] | 0x80, a1[i + 374], 0, 0);
      a1[i + 342] = -1;
      ++v3;
    }
  }
  a1[341] = 0;
  LOBYTE(v1) = sub_A4EB0(*a1);
  if ( v3 )
  {
    v1 = sub_92160();
    if ( !v1 )
      LOBYTE(v1) = sub_920D0(3);
  }
  return v1;
}

//----- (000A5F30) --------------------------------------------------------
int __cdecl sub_A5F30(int *a1, int a2)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 32; ++i )
  {
    if ( a1[i + 342] == a2 )
    {
      sub_A5850((int)a1, a1[i + 342] | 0x80, a1[i + 374], 0, 0);
      a1[i + 342] = -1;
    }
  }
  return sub_A4EB0(*a1);
}

//----- (000A5FD0) --------------------------------------------------------
_DWORD *__cdecl sub_A5FD0(int a1, int a2)
{
  _DWORD *result; // eax

  if ( *(_DWORD *)(a1 + 4 * a2 + 660) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0x72u, *(_DWORD *)(a1 + 4 * a2 + 660), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 212) != -1 )
    sub_A5850(a1, a2 | 0xC0, *(_DWORD *)(a1 + 4 * a2 + 212), 0, 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 340) != -1 )
    sub_A5850(a1, a2 | 0xE0, *(_DWORD *)(a1 + 4 * a2 + 276), *(_DWORD *)(a1 + 4 * a2 + 340), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 532) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0x6Bu, *(_DWORD *)(a1 + 4 * a2 + 532), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 468) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0x6Fu, *(_DWORD *)(a1 + 4 * a2 + 468), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 596) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0x70u, *(_DWORD *)(a1 + 4 * a2 + 596), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 852) != -1 )
    sub_A5850(a1, a2 | 0xB0, 1u, *(_DWORD *)(a1 + 4 * a2 + 852), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 916) != -1 )
    sub_A5850(a1, a2 | 0xB0, 7u, *(_DWORD *)(a1 + 4 * a2 + 916), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 980) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0xAu, *(_DWORD *)(a1 + 4 * a2 + 980), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 1044) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0xBu, *(_DWORD *)(a1 + 4 * a2 + 1044), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 1108) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0x40u, *(_DWORD *)(a1 + 4 * a2 + 1108), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 1172) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0x5Bu, *(_DWORD *)(a1 + 4 * a2 + 1172), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 1236) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0x5Du, *(_DWORD *)(a1 + 4 * a2 + 1236), 0);
  result = (_DWORD *)(a1 + 4 * a2);
  if ( result[325] != -1 )
    result = sub_A5850(a1, a2 | 0xB0, 6u, *(_DWORD *)(a1 + 4 * a2 + 1300), 0);
  return result;
}

//----- (000A6370) --------------------------------------------------------
_DWORD *__cdecl sub_A6370(_DWORD *a1)
{
  _DWORD *result; // eax
  signed int i; // [esp+0h] [ebp-4h]
  signed int j; // [esp+0h] [ebp-4h]
  signed int k; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 16; ++i )
    a1[i + 37] = i;
  memset(a1 + 53, -1, 1152);
  for ( j = 0; j < 4; ++j )
    a1[j + 33] = -1;
  for ( k = 0; k < 32; ++k )
    a1[k + 342] = -1;
  a1[341] = 0;
  a1[12] = 0;
  a1[23] = 0;
  a1[24] = -1;
  a1[27] = 0;
  a1[26] = 0;
  a1[25] = 4;
  a1[28] = 8000000;
  result = a1;
  a1[13] = 0;
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);

//----- (000A6490) --------------------------------------------------------
_DWORD *__cdecl sub_A6490(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_A6370(a1);
  result = a1;
  a1[5] = a1[4] + 8;
  return result;
}

//----- (000A64C0) --------------------------------------------------------
signed int __cdecl sub_A64C0(int a1)
{
  signed int result; // eax
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 16; ++i )
  {
    if ( *(_DWORD *)(a1 + 4 * i + 916) != -1 )
      sub_A5850(a1, i | 0xB0, 7u, *(_DWORD *)(a1 + 4 * i + 916), 0);
    result = i;
  }
  return result;
}

//----- (000A6E00) --------------------------------------------------------
int __cdecl sub_A6E00(int *a1, const void *a2)
{
  __int16 v3; // [esp+0h] [ebp-24h]
  __int16 v4; // [esp+2h] [ebp-22h]
  __int16 v5; // [esp+4h] [ebp-20h]
  __int16 v6; // [esp+6h] [ebp-1Eh]
  int v7; // [esp+8h] [ebp-1Ch]
  unsigned int i; // [esp+1Ch] [ebp-8h]
  __int16 *v9; // [esp+20h] [ebp-4h]

  qmemcpy(&v3, a2, 0x18u);
  if ( *(_WORD *)(*(_DWORD *)(*a1 + 16) + 16) )
  {
    v9 = (__int16 *)((*(_DWORD *)(*(_DWORD *)(*a1 + 16) + 12) & 0xFFFF)
                   + 16 * (*(_DWORD *)(*(_DWORD *)(*a1 + 16) + 12) >> 16));
    if ( v3 < 1 )
      v3 = *v9;
    if ( v4 < 1 )
      v4 = v9[1];
    if ( v5 < 1 )
      v5 = v9[2];
    if ( v6 < 1 )
      v6 = v9[3];
    for ( i = 0; i < 4; ++i )
    {
      if ( *(&v7 + i) < 1 )
        *(&v7 + i) = *(_DWORD *)&v9[2 * i + 4];
    }
  }
  qmemcpy((void *)(*(_DWORD *)(*a1 + 16) + 22), &v3, 0x18u);
  return sub_91F70(*a1, 772, 0, 0);
}

//----- (000A6FB0) --------------------------------------------------------
int *__cdecl sub_A6FB0(int a1, const void *a2)
{
  __int64 v2; // rtt
  unsigned int v3; // eax
  char v5; // [esp+0h] [ebp-3Ch]
  unsigned __int16 v6; // [esp+18h] [ebp-24h]
  unsigned __int16 v7; // [esp+1Ah] [ebp-22h]
  unsigned __int16 v8; // [esp+1Ch] [ebp-20h]
  unsigned __int16 v9; // [esp+1Eh] [ebp-1Eh]
  int *v10; // [esp+24h] [ebp-18h]
  _BYTE *v11; // [esp+28h] [ebp-14h]
  int *v12; // [esp+2Ch] [ebp-10h]
  int v13; // [esp+30h] [ebp-Ch]
  int i; // [esp+34h] [ebp-8h]
  _BYTE *v15; // [esp+38h] [ebp-4h]
  void *v16; // [esp+50h] [ebp+14h]
  const void *v17; // [esp+50h] [ebp+14h]

  sub_A4CF0();
  v12 = (int *)sub_9D450(468);
  if ( v12 )
  {
    *v12 = a1;
    if ( *(_DWORD *)(*v12 + 20) == 1 )
    {
      sub_91F70(*v12, 769, 0, &v6);
      v12[1] = v6 + 16 * v9;
      v12[2] = v7 + 16 * v8;
      v11 = (_BYTE *)((*(_DWORD *)v12[1] & 0xFFFF) + 16 * (*(_DWORD *)v12[1] >> 16));
      if ( v11 )
      {
        if ( *v11 )
        {
          v15 = (_BYTE *)getenv(v11);
          if ( v15 )
          {
            if ( *v15 )
              strncpy(v12[2], v15, 128);
          }
        }
      }
      v11 = (_BYTE *)((*(_DWORD *)(v12[1] + 4) & 0xFFFF) + 16 * (*(_DWORD *)(v12[1] + 4) >> 16));
      if ( v11 && *v11 )
      {
        strcpy(v12[2] + 128, aSample);
        strcat(v12[2] + 128, v11);
      }
      else
      {
        *(_BYTE *)(v12[2] + 128) = 0;
      }
      memset(&unk_181D90, -1, 24);
      v13 = 0;
      if ( a2 )
      {
        qmemcpy(&unk_181D90, a2, 0x18u);
        if ( sub_A6E00(v12, a2) )
        {
          v13 = 1;
          qmemcpy(&v5, a2, 0x18u);
        }
      }
      if ( !v13 )
      {
        v16 = sub_92ED0(*v12);
        if ( v16 )
        {
          qmemcpy(&unk_181D90, v16, 0x18u);
          if ( sub_A6E00(v12, v16) )
          {
            v13 = 1;
            qmemcpy(&v5, v16, 0x18u);
          }
        }
      }
      if ( !v13 && dword_181DF0 == 1 )
      {
        for ( i = 0; *(unsigned __int16 *)(*(_DWORD *)(*v12 + 16) + 16) > i; ++i )
        {
          v17 = (const void *)(24 * i
                             + (*(_DWORD *)(*(_DWORD *)(*v12 + 16) + 12) & 0xFFFF)
                             + 16 * (*(_DWORD *)(*(_DWORD *)(*v12 + 16) + 12) >> 16));
          if ( !i )
            qmemcpy(&unk_181D90, v17, 0x18u);
          if ( sub_A6E00(v12, v17) )
          {
            v13 = 1;
            qmemcpy(&v5, v17, 0x18u);
            break;
          }
        }
      }
      if ( v13 )
      {
        qmemcpy(&unk_181D90, &v5, 0x18u);
        sub_91F70(*v12, 773, 0, 0);
        *(_DWORD *)(*v12 + 24) = 1;
        sub_91F70(*v12, 1281, 0, &v6);
        if ( v6 )
        {
          v12[7] = dword_181DDC;
          v12[6] = sub_9D450(1816 * v12[7]);
          if ( v12[6] )
          {
            for ( i = 0; i < v12[7]; ++i )
            {
              *(_DWORD *)(1816 * i + v12[6] + 4) = 1;
              *(_DWORD *)(v12[6] + 1816 * i) = v12;
            }
            v12[104] = 0;
            v12[105] = 0;
            v12[106] = 0;
            v12[107] = 0;
            LODWORD(v2) = &unk_F4240;
            HIDWORD(v2) = (signed int)&unk_F4240 >> 31;
            v12[4] = v2 / dword_181DD8;
            v12[5] = 0;
            v12[108] = 127;
            for ( i = 0; i < 16; ++i )
            {
              v12[i + 8] = 0;
              v12[i + 24] = 0;
              v12[i + 40] = 0;
              v12[i + 56] = 0;
              v12[i + 72] = 0;
              v12[i + 88] = 0;
            }
            v3 = sub_92600((int)sub_A6530);
            v12[3] = v3;
            if ( v12[3] == -1 )
            {
              qmemcpy(&byte_181C90, aOutOfTimerHand_1, 0x16u);
              sub_91F70(*v12, 774, 0, 0);
              *(_DWORD *)(*v12 + 24) = 0;
              sub_9D490(v12[6], 1816 * v12[7]);
              sub_9D490((unsigned int)v12, 468);
              v10 = 0;
            }
            else
            {
              sub_92740(v12[3], (signed __int32)v12);
              *(_DWORD *)(*v12 + 36) = sub_A6F30;
              *(_DWORD *)(*v12 + 40) = v12;
              for ( i = 0; i < 16; ++i )
              {
                sub_A4F10((int)v12, i | 0xB0, 114, 0);
                sub_A4F10((int)v12, i | 0xC0, 0, 0);
                sub_A4F10((int)v12, i | 0xE0, 0, 64);
                sub_A4F10((int)v12, i | 0xB0, 112, 0);
                sub_A4F10((int)v12, i | 0xB0, 1, 0);
                sub_A4F10((int)v12, i | 0xB0, 7, dword_181DE0);
                sub_A4F10((int)v12, i | 0xB0, 10, 64);
                sub_A4F10((int)v12, i | 0xB0, 11, 127);
                sub_A4F10((int)v12, i | 0xB0, 64, 0);
                sub_A4F10((int)v12, i | 0xB0, 91, 40);
                sub_A4F10((int)v12, i | 0xB0, 93, 0);
                sub_A4F10((int)v12, i | 0xB0, 100, 0);
                sub_A4F10((int)v12, i | 0xB0, 101, 0);
                sub_A4F10((int)v12, i | 0xB0, 38, 0);
                sub_A4F10((int)v12, i | 0xB0, 6, dword_181DEC);
                sub_A4EB0((int)v12);
                if ( !(i & 3) )
                  sub_920D0(3);
              }
              sub_92930(v12[3], dword_181DD8);
              sub_92BA0(v12[3]);
              v10 = v12;
            }
          }
          else
          {
            qmemcpy(&byte_181C90, aCouldNotAlloca_4, 0x28u);
            sub_91F70(*v12, 774, 0, 0);
            *(_DWORD *)(*v12 + 24) = 0;
            sub_9D490((unsigned int)v12, 468);
            v10 = 0;
          }
        }
        else
        {
          qmemcpy(&byte_181C90, aCouldNotInitia, 0x29u);
          sub_91F70(*v12, 774, 0, 0);
          *(_DWORD *)(*v12 + 24) = 0;
          sub_9D490((unsigned int)v12, 468);
          v10 = 0;
        }
      }
      else
      {
        qmemcpy(&byte_181C90, aXmidiSoundHard, 0x20u);
        sub_9D490((unsigned int)v12, 468);
        v10 = 0;
      }
    }
    else
    {
      qmemcpy(&byte_181C90, aMdiDriverRequi, 0x16u);
      sub_9D490((unsigned int)v12, 468);
      v10 = 0;
    }
  }
  else
  {
    qmemcpy(&byte_181C90, aCouldNotAlloca_3, 0x26u);
    v10 = 0;
  }
  return v10;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// 99D84: using guessed type _DWORD __cdecl strcat(_DWORD, _DWORD);
// 99E33: using guessed type _DWORD __cdecl getenv(_DWORD);
// A6530: using guessed type int sub_A6530();
// A6F30: using guessed type int sub_A6F30();
// AD871: using guessed type _DWORD __cdecl strncpy(_DWORD, _DWORD, _DWORD);
// 181C90: using guessed type char byte_181C90;
// 181DD8: using guessed type int dword_181DD8;
// 181DDC: using guessed type int dword_181DDC;
// 181DE0: using guessed type int dword_181DE0;
// 181DEC: using guessed type int dword_181DEC;
// 181DF0: using guessed type int dword_181DF0;

//----- (000A77D0) --------------------------------------------------------
int *__usercall sub_A77D0@<eax>(int a1@<ebx>, int a2, const void *a3)
{
  int v3; // eax
  int *v5; // [esp+0h] [ebp-10h]
  int v6; // [esp+4h] [ebp-Ch]
  int *v7; // [esp+8h] [ebp-8h]
  _DWORD *v8; // [esp+Ch] [ebp-4h]

  v6 = sub_9DEA0(a2, 0);
  if ( v6 )
  {
    v3 = sub_9DE20(a2);
    v8 = sub_93010(a1, v6, v3);
    off_E3E34(v6);
    if ( v8 )
    {
      v7 = sub_A6FB0((int)v8, a3);
      if ( !v7 )
        sub_93160((unsigned int)v8);
      v5 = v7;
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    strcpy(&byte_181C90, "Driver file not found\n");
    v5 = 0;
  }
  return v5;
}
// E3E34: using guessed type int (__cdecl *off_E3E34)(int);
// 181C90: using guessed type char byte_181C90;

//----- (000A7880) --------------------------------------------------------
int *__usercall sub_A7880@<eax>(int a1@<ebx>, int a2, int a3, const void *a4)
{
  int *v6; // [esp+4h] [ebp-8h]
  _DWORD *v7; // [esp+8h] [ebp-4h]

  v7 = sub_93010(a1, a2, a3);
  if ( !v7 )
    return 0;
  v6 = sub_A6FB0((int)v7, a4);
  if ( !v6 )
    sub_93160((unsigned int)v7);
  return v6;
}

//----- (000A78F0) --------------------------------------------------------
int __usercall sub_A78F0@<eax>(int a1@<ebx>, int **a2)
{
  char v3; // [esp+0h] [ebp-11Ch]
  char v4; // [esp+80h] [ebp-9Ch]
  char v5; // [esp+100h] [ebp-1Ch]
  int v6; // [esp+118h] [ebp-4h]

  if ( sub_92190((int)&v3, (int)aMdiIni_0) )
  {
    *a2 = sub_95850(a1, (int)&v4, &v5);
    if ( *a2 )
      v6 = 0;
    else
      v6 = 2;
  }
  else
  {
    qmemcpy(&byte_181C90, aUnableToOpenFi_0, 0x1Du);
    v6 = 1;
  }
  return v6;
}
// 181C90: using guessed type char byte_181C90;

//----- (000A7970) --------------------------------------------------------
int __cdecl sub_A7970(unsigned int *a1)
{
  return sub_93160(*a1);
}

//----- (000A7990) --------------------------------------------------------
signed int __cdecl sub_A7990(_DWORD *a1)
{
  int v3; // [esp+4h] [ebp-4h]
  _BYTE *v4; // [esp+4h] [ebp-4h]

  if ( *(_DWORD *)(*(_DWORD *)(*a1 + 16) + 8) >= 0x112u )
  {
    v3 = *(_DWORD *)(*a1 + 16) + 186;
    if ( !stricmp(v3, aTandy3VoiceMus) )
      return 3;
    if ( !stricmp(v3, aIbmInternalSpe) )
      return 3;
  }
  v4 = (_BYTE *)((*(_DWORD *)(a1[1] + 4) & 0xFFFF) + 16 * (*(_DWORD *)(a1[1] + 4) >> 16));
  if ( !v4 || !*v4 )
    return 0;
  if ( !stricmp(v4, &aMAd[1]) )
    return *(_DWORD *)(*a1 + 12) <= 0x5000u;
  if ( !stricmp(v4, aOpl) )
    return 2;
  return 0;
}
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);

//----- (000A7AA0) --------------------------------------------------------
int __cdecl sub_A7AA0(int a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  strcpy(aSample, a1);
  result = strlen(aSample) - 1;
  for ( i = result; i; --i )
  {
    if ( aSample[i] == 92 )
    {
      result = strlen(aSample) - 1;
      if ( result == i )
      {
        result = i;
        aSample[i] = 0;
      }
      return result;
    }
    if ( aSample[i] == 46 )
    {
      result = i;
      aSample[i] = 0;
      return result;
    }
    result = i;
  }
  return result;
}
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// 99D6B: using guessed type _DWORD __cdecl strlen(_DWORD);

//----- (000A7B30) --------------------------------------------------------
_DWORD *__cdecl sub_A7B30(int a1)
{
  _DWORD *v1; // ST08_4
  _DWORD *v3; // [esp+0h] [ebp-Ch]
  int i; // [esp+8h] [ebp-4h]

  sub_91BD0();
  for ( i = 0; i < *(_DWORD *)(a1 + 28) && *(_DWORD *)(1816 * i + *(_DWORD *)(a1 + 24) + 4) != 1; ++i )
    ;
  if ( i == *(_DWORD *)(a1 + 28) )
  {
    qmemcpy(&byte_181C90, aOutOfSequenceH, 0x19u);
    sub_91BF0();
    v3 = 0;
  }
  else
  {
    v1 = (_DWORD *)(1816 * i + *(_DWORD *)(a1 + 24));
    v1[1] = 2;
    sub_A6370(v1);
    v1[10] = 0;
    sub_91BF0();
    v3 = v1;
  }
  return v3;
}
// 181C90: using guessed type char byte_181C90;

//----- (000A7BF0) --------------------------------------------------------
int *__cdecl sub_A7BF0(int *a1)
{
  int *result; // eax

  if ( a1 )
  {
    sub_95DE0(a1);
    result = a1;
    a1[1] = 1;
  }
  return result;
}

//----- (000A7C20) --------------------------------------------------------
int __cdecl sub_A7C20(int *a1, int a2, int a3)
{
  __int16 v4; // [esp+0h] [ebp-30h]
  int v5; // [esp+2h] [ebp-2Eh]
  int v6; // [esp+Ch] [ebp-24h]
  int v7; // [esp+10h] [ebp-20h]
  unsigned int v8; // [esp+14h] [ebp-1Ch]
  _WORD *v9; // [esp+18h] [ebp-18h]
  unsigned int v10; // [esp+1Ch] [ebp-14h]
  unsigned int i; // [esp+20h] [ebp-10h]
  unsigned int v12; // [esp+24h] [ebp-Ch]
  unsigned int v13; // [esp+28h] [ebp-8h]
  unsigned int v14; // [esp+2Ch] [ebp-4h]

  if ( !a1 )
    return 0;
  a1[1] = 2;
  v14 = sub_A50F0(a2, a3);
  if ( v14 )
  {
    v10 = sub_A50A0(*(_DWORD *)(v14 + 4)) + 8;
    v13 = v10 + v14;
    v14 += 12;
    a1[2] = 0;
    a1[3] = 0;
    a1[4] = 0;
    while ( v14 < v13 )
    {
      if ( !strncmp(v14, aTimb, 4) )
        a1[2] = v14;
      if ( !strncmp(v14, aRbrn, 4) )
        a1[3] = v14;
      if ( !strncmp(v14, aEvnt, 4) )
        a1[4] = v14;
      v14 += sub_A50A0(*(_DWORD *)(v14 + 4)) + 8;
    }
    if ( a1[4] )
    {
      a1[6] = 0;
      a1[7] = 0;
      a1[8] = 0;
      a1[9] = 0;
      a1[10] = 0;
      a1[11] = 1;
      sub_A6490(a1);
      a1[14] = dword_181DE0;
      a1[15] = dword_181DE0;
      a1[17] = 0;
      a1[16] = 0;
      a1[18] = 100;
      a1[19] = 100;
      a1[21] = 0;
      a1[20] = 0;
      a1[22] = 0;
      if ( a1[2] )
      {
        memmove(&unk_181EE0, a1[2], 512);
        v9 = &unk_181EE0;
        if ( *(_DWORD *)(*a1 + 420) )
        {
          v12 = 0;
          while ( (unsigned __int16)v9[4] > v12 )
          {
            v7 = v9[v12 + 5] & 0xFF;
            v8 = (v9[v12 + 5] & 0xFF00u) >> 8;
            if ( (*(int (__cdecl **)(int, unsigned int, int))(*a1 + 420))(*a1, v8, v7) )
            {
              for ( i = v12 + 1; (unsigned __int16)v9[4] > i; ++i )
                v9[i + 4] = v9[i + 5];
              --v9[4];
              if ( *((_BYTE *)v9 + 5) >= 2u )
              {
                *((_BYTE *)v9 + 5) -= 2;
              }
              else
              {
                *((_BYTE *)v9 + 5) -= 2;
                --*((_BYTE *)v9 + 4);
              }
            }
            else
            {
              ++v12;
            }
          }
        }
        if ( v9[4] )
        {
          if ( sub_92160() )
          {
            strcpy(&byte_181C90, "No timbres loaded\n");
            v6 = -1;
          }
          else
          {
            ++*(_DWORD *)(*a1 + 20);
            sub_A4EB0(*a1);
            memmove(*(_DWORD *)(*a1 + 8) + 256, v9, 512);
            sub_91F70(*(_DWORD *)*a1, 1283, 0, &v4);
            --*(_DWORD *)(*a1 + 20);
            if ( v4 )
            {
              v6 = 1;
            }
            else
            {
              sprintf(&byte_181C90, aDriverCouldNot, (signed __int16)v5 >> 8, (unsigned __int8)v5);
              v6 = -1;
            }
          }
        }
        else
        {
          v6 = 1;
        }
      }
      else
      {
        v6 = 1;
      }
    }
    else
    {
      qmemcpy(&byte_181C90, aInvalidXmidiSe, 0x18u);
      v6 = 0;
    }
  }
  else
  {
    qmemcpy(&byte_181C90, aInvalidXmidiSe, 0x18u);
    v6 = 0;
  }
  return v6;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 99682: using guessed type _DWORD __cdecl strncmp(_DWORD, _DWORD, _DWORD);
// AD81F: using guessed type _DWORD __cdecl memmove(_DWORD, _DWORD, _DWORD);
// 181C90: using guessed type char byte_181C90;
// 181DE0: using guessed type int dword_181DE0;

//----- (000A8010) --------------------------------------------------------
int *__cdecl sub_A8010(int *a1)
{
  int *result; // eax

  if ( a1 )
  {
    result = a1;
    if ( a1[1] != 1 )
    {
      sub_95DE0(a1);
      sub_A6490(a1);
      result = a1;
      a1[1] = 4;
    }
  }
  return result;
}

//----- (000A8050) --------------------------------------------------------
int __cdecl sub_A8050(int *a1)
{
  int result; // eax
  int v2; // [esp+0h] [ebp-Ch]
  signed int i; // [esp+4h] [ebp-8h]
  _DWORD *v4; // [esp+8h] [ebp-4h]

  if ( a1 )
  {
    result = (int)a1;
    if ( a1[1] == 4 )
    {
      a1[1] = 8;
      sub_A5E50(a1);
      result = *a1;
      v4 = (_DWORD *)*a1;
      for ( i = 0; i < 16; ++i )
      {
        v2 = a1[i + 37];
        if ( a1[i + 277] >= 64 )
          sub_A4F10((int)v4, v2 | 0xB0, 64, 0);
        if ( a1[i + 117] >= 64 )
          v4[v2 + 8] = 0;
        if ( a1[i + 149] >= 64 )
          sub_A4F10((int)v4, v2 | 0xB0, 112, 0);
        if ( a1[i + 101] >= 64 )
          sub_980D0(v4, v2 + 1);
        result = i;
      }
    }
  }
  return result;
}

//----- (000A8180) --------------------------------------------------------
void __cdecl sub_A8180(_DWORD *a1)
{
  signed int v1; // [esp+0h] [ebp-10h]
  int v2; // [esp+4h] [ebp-Ch]
  signed int i; // [esp+8h] [ebp-8h]
  int j; // [esp+8h] [ebp-8h]
  _DWORD *v5; // [esp+Ch] [ebp-4h]

  if ( a1 && a1[1] == 8 )
  {
    v5 = (_DWORD *)*a1;
    for ( i = 0; i < 16; ++i )
    {
      if ( a1[i + 101] >= 64 )
      {
        v2 = sub_97F90(v5) - 1;
        if ( v2 == -1 )
          v1 = i;
        else
          v1 = v2;
        a1[i + 37] = v1;
      }
    }
    for ( j = 0; j < 16; ++j )
      sub_A5FD0((int)a1, j);
    a1[1] = 4;
  }
}

//----- (000A8250) --------------------------------------------------------
int __cdecl sub_A8250(int a1)
{
  int result; // eax

  if ( a1 )
  {
    result = a1;
    if ( *(_DWORD *)(a1 + 4) != 1 )
    {
      sub_95DE0((int *)a1);
      *(_DWORD *)(a1 + 4) = 2;
      result = a1;
      if ( *(_DWORD *)(a1 + 40) )
        result = (*(int (__cdecl **)(int))(a1 + 40))(a1);
    }
  }
  return result;
}

//----- (000A82A0) --------------------------------------------------------
int __cdecl sub_A82A0(int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    result = a2;
    *(_DWORD *)(a1 + 44) = a2;
  }
  return result;
}

//----- (000A82C0) --------------------------------------------------------
void __cdecl sub_A82C0(_DWORD *a1, int a2, int a3)
{
  if ( a1 )
  {
    ++*(_DWORD *)(*a1 + 20);
    a1[19] = a2;
    if ( a1[18] == a1[19] )
    {
      --*(_DWORD *)(*a1 + 20);
    }
    else
    {
      if ( a3 )
      {
        a1[21] = 1000 * a3 / abs(a1[18] - a1[19]);
        a1[20] = 0;
      }
      else
      {
        a1[18] = a1[19];
      }
      --*(_DWORD *)(*a1 + 20);
    }
  }
}
// A0D1F: using guessed type _DWORD __cdecl abs(_DWORD);

//----- (000A8360) --------------------------------------------------------
void __cdecl sub_A8360(_DWORD *a1, int a2, int a3)
{
  if ( a1 )
  {
    ++*(_DWORD *)(*a1 + 20);
    a1[15] = a2;
    if ( a1[14] == a1[15] )
    {
      --*(_DWORD *)(*a1 + 20);
    }
    else
    {
      if ( a3 )
      {
        a1[17] = 1000 * a3 / abs(a1[14] - a1[15]);
        a1[16] = 0;
      }
      else
      {
        a1[14] = a1[15];
      }
      sub_A64C0((int)a1);
      --*(_DWORD *)(*a1 + 20);
    }
  }
}
// A0D1F: using guessed type _DWORD __cdecl abs(_DWORD);

//----- (000A8410) --------------------------------------------------------
int __cdecl sub_A8410(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( a1 )
    v2 = *(_DWORD *)(a1 + 4);
  else
    v2 = 0;
  return v2;
}

//----- (000A8440) --------------------------------------------------------
signed int __cdecl sub_A8440(int a1)
{
  signed int v2; // [esp+0h] [ebp-4h]

  if ( a1 )
    v2 = *(_DWORD *)(a1 + 44);
  else
    v2 = -1;
  return v2;
}

//----- (000A8470) --------------------------------------------------------
int __cdecl sub_A8470(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( a1 )
    v2 = *(_DWORD *)(a1 + 72);
  else
    v2 = 0;
  return v2;
}

//----- (000A84A0) --------------------------------------------------------
int __cdecl sub_A84A0(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( a1 )
    v2 = *(_DWORD *)(a1 + 56);
  else
    v2 = 0;
  return v2;
}

//----- (000A84D0) --------------------------------------------------------
_DWORD *__cdecl sub_A84D0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  result = (_DWORD *)a1[108];
  if ( result != a2 )
  {
    a1[108] = a2;
    ++a1[5];
    v3 = a1[7];
    v4 = a1[6];
    while ( v3 )
    {
      if ( *(_DWORD *)(v4 + 4) == 4 )
        sub_A64C0(v4);
      --v3;
      v4 += 1816;
    }
    result = a1;
    --result[5];
  }
  return result;
}

//----- (000A8550) --------------------------------------------------------
int __cdecl sub_A8550(int a1)
{
  return *(_DWORD *)(a1 + 432);
}

//----- (000A8570) --------------------------------------------------------
int __cdecl sub_A8570(int *a1, __int16 a2, __int16 a3)
{
  char v4; // [esp+0h] [ebp-10h]
  __int16 v5; // [esp+4h] [ebp-Ch]

  v5 = (a2 << 8) | a3;
  return sub_91F70(*a1, 1284, &v4, 0);
}

//----- (000A85B0) --------------------------------------------------------
signed int __cdecl sub_A85B0(int *a1, int a2, int a3)
{
  __int16 v4; // [esp+0h] [ebp-10h]
  int v5; // [esp+2h] [ebp-Eh]

  if ( a1[105] && ((int (__cdecl *)(int *, int, int))a1[105])(a1, a2, a3) )
    return 1;
  byte_E4B2A = a3;
  byte_E4B2B = a2;
  ++a1[5];
  sub_A4EB0((int)a1);
  memmove(a1[2] + 256, aTimb_0, 12);
  sub_91F70(*a1, 1283, 0, &v4);
  --a1[5];
  if ( !v4 )
    sprintf(&byte_181C90, aDriverCouldNot_0, (signed __int16)v5 >> 8, (unsigned __int8)v5);
  return v4;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// AD81F: using guessed type _DWORD __cdecl memmove(_DWORD, _DWORD, _DWORD);
// E4B2A: using guessed type char byte_E4B2A;
// E4B2B: using guessed type char byte_E4B2B;
// 181C90: using guessed type char byte_181C90;

//----- (000A8690) --------------------------------------------------------
int __cdecl sub_A8690(int *a1, __int16 a2, __int16 a3)
{
  char v4; // [esp+0h] [ebp-Ch]
  __int16 v5; // [esp+4h] [ebp-8h]
  __int16 v6; // [esp+6h] [ebp-6h]

  v5 = (a2 << 8) | a3;
  v6 = 1;
  return sub_91F70(*a1, 1285, &v4, 0);
}

//----- (000A86D0) --------------------------------------------------------
int __cdecl sub_A86D0(int *a1, __int16 a2, __int16 a3)
{
  char v4; // [esp+0h] [ebp-Ch]
  __int16 v5; // [esp+4h] [ebp-8h]
  __int16 v6; // [esp+6h] [ebp-6h]

  v5 = (a2 << 8) | a3;
  v6 = 0;
  return sub_91F70(*a1, 1285, &v4, 0);
}

//----- (000A8710) --------------------------------------------------------
int __cdecl sub_A8710(int a1)
{
  int v2; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h]

  v2 = 0;
  for ( i = 0; i < *(_DWORD *)(a1 + 28); ++i )
  {
    if ( *(_DWORD *)(1816 * i + *(_DWORD *)(a1 + 24) + 4) == 4 )
      ++v2;
  }
  return v2;
}

//----- (000A8770) --------------------------------------------------------
int __cdecl sub_A8770(int a1, char a2, unsigned int a3)
{
  int v4; // [esp+0h] [ebp-4h]

  if ( a1 )
    v4 = sub_A5210(a1 + 212, (a2 - 1) | 0xB0, a3);
  else
    v4 = -1;
  return v4;
}

//----- (000A87C0) --------------------------------------------------------
int __cdecl sub_A87C0(int a1, int a2)
{
  int v4; // [esp+4h] [ebp-8h]
  signed int i; // [esp+8h] [ebp-4h]

  if ( !a1 )
    return 0;
  v4 = 0;
  for ( i = 0; i < 16; ++i )
  {
    if ( a2 - 1 == *(_DWORD *)(4 * i + a1 + 1368) )
      ++v4;
  }
  return v4;
}

//----- (000A8830) --------------------------------------------------------
int __cdecl sub_A8830(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-10h]
  int i; // [esp+4h] [ebp-Ch]
  int v6; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  if ( a1 )
  {
    ++*(_DWORD *)(*a1 + 20);
    v7 = a1[23];
    v6 = a1[24];
    v4 = a1[27];
    for ( i = 0; i < dword_181DE4; ++i )
    {
      v4 += a1[26];
      if ( v4 >= a1[28] )
      {
        v4 -= a1[28];
        if ( ++v7 >= a1[25] )
        {
          v7 = 0;
          ++v6;
        }
      }
    }
    if ( v6 < 0 )
      v6 = 0;
    if ( a3 )
      *a3 = v6;
    if ( a2 )
      *a2 = v7;
    result = *a1;
    --*(_DWORD *)(result + 20);
  }
  return result;
}
// 181DE4: using guessed type int dword_181DE4;

//----- (000A8900) --------------------------------------------------------
_DWORD *__cdecl sub_A8900(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int v3; // [esp+0h] [ebp-Ch]
  signed int i; // [esp+4h] [ebp-8h]
  signed int v5; // [esp+8h] [ebp-4h]
  signed int j; // [esp+8h] [ebp-4h]

  if ( a1 )
  {
    result = a1;
    if ( a1[3] )
    {
      v5 = *(signed __int16 *)(a1[3] + 8);
      v3 = a1[3] + 10;
      for ( i = 0; i < v5 && *(unsigned __int16 *)(v3 + 6 * i) != a2; ++i )
        ;
      result = (_DWORD *)i;
      if ( i != v5 )
      {
        a1[5] = *(_DWORD *)(6 * i + v3 + 2) + a1[4] + 8;
        result = a1;
        a1[12] = 0;
        if ( !dword_181DE8 )
        {
          for ( j = 0; j < 4; ++j )
          {
            a1[j + 33] = -1;
            result = (_DWORD *)j;
          }
        }
      }
    }
  }
  return result;
}
// 181DE8: using guessed type int dword_181DE8;

//----- (000A89E0) --------------------------------------------------------
int __cdecl sub_A89E0(int a1, int a2)
{
  int v2; // ST04_4

  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 28) = a2;
  return v2;
}

//----- (000A8A20) --------------------------------------------------------
int __cdecl sub_A8A20(int a1, int a2)
{
  int v2; // ST04_4

  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 32) = a2;
  return v2;
}

//----- (000A8A60) --------------------------------------------------------
int __cdecl sub_A8A60(int a1, int a2)
{
  int v2; // ST04_4

  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 40) = a2;
  return v2;
}

//----- (000A8AA0) --------------------------------------------------------
int __cdecl sub_A8AA0(int a1, int a2)
{
  int v2; // ST04_4

  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = a2;
  return v2;
}

//----- (000A8AE0) --------------------------------------------------------
int __cdecl sub_A8AE0(int a1, int a2)
{
  int v2; // ST04_4

  v2 = *(_DWORD *)(a1 + 416);
  *(_DWORD *)(a1 + 416) = a2;
  return v2;
}

//----- (000A8B20) --------------------------------------------------------
int __cdecl sub_A8B20(int a1, int a2)
{
  int v2; // ST04_4

  v2 = *(_DWORD *)(a1 + 420);
  *(_DWORD *)(a1 + 420) = a2;
  return v2;
}

//----- (000A8B60) --------------------------------------------------------
int __cdecl sub_A8B60(int a1, int a2, int a3)
{
  int result; // eax

  if ( a1 )
  {
    result = a3;
    *(_DWORD *)(4 * a2 + a1 + 1752) = a3;
  }
  return result;
}

//----- (000A8B90) --------------------------------------------------------
int __cdecl sub_A8B90(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-4h]

  if ( a1 )
    v3 = *(_DWORD *)(a1 + 4 * a2 + 1752);
  else
    v3 = 0;
  return v3;
}

//----- (000A8BD0) --------------------------------------------------------
int __cdecl sub_A8BD0(int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    result = a2;
    *(_DWORD *)(a1 + 24) = a2;
  }
  return result;
}

//----- (000A8BF0) --------------------------------------------------------
int __cdecl sub_A8BF0(_DWORD *a1)
{
  int v2; // [esp+0h] [ebp-18h]
  int v3; // [esp+4h] [ebp-14h]
  signed int v4; // [esp+8h] [ebp-10h]
  signed int v5; // [esp+Ch] [ebp-Ch]
  signed int k; // [esp+10h] [ebp-8h]
  signed int i; // [esp+14h] [ebp-4h]
  signed int j; // [esp+14h] [ebp-4h]
  int v9; // [esp+14h] [ebp-4h]

  ++a1[5];
  v5 = -1;
  v4 = 0x7FFFFFFF;
  for ( i = 8; i >= 1; --i )
  {
    if ( i != 9 && a1[i + 8] != 1 && a1[i + 8] != 2 && a1[i + 88] < v4 )
    {
      v4 = a1[i + 88];
      v5 = i;
    }
  }
  if ( v5 == -1 )
  {
    for ( j = 8; j >= 1; --j )
    {
      if ( j != 9 && a1[j + 8] != 1 && a1[j + 88] < v4 )
      {
        v4 = a1[j + 88];
        v5 = j;
      }
    }
  }
  if ( v5 == -1 )
  {
    --a1[5];
    v2 = 0;
  }
  else
  {
    sub_A4F10((int)a1, v5 | 0xB0, 64, 0);
    v9 = a1[7];
    v3 = a1[6];
    while ( v9 )
    {
      if ( *(_DWORD *)(v3 + 4) != 1 )
      {
        for ( k = 0; k < 32; ++k )
        {
          if ( *(_DWORD *)(v3 + 4 * k + 1368) != -1 && *(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 4 * k + 1368) + 148) == v5 )
          {
            sub_A5850(v3, *(unsigned int *)(v3 + 4 * k + 1368) | 0x80, *(_DWORD *)(v3 + 4 * k + 1496), 0, 0);
            *(_DWORD *)(v3 + 4 * k + 1368) = -1;
          }
        }
      }
      --v9;
      v3 += 1816;
    }
    a1[v5 + 72] = a1[v5 + 8];
    a1[v5 + 8] = 1;
    a1[v5 + 24] = 0;
    a1[v5 + 40] = a1[v5 + 56];
    --a1[5];
    v2 = v5 + 1;
  }
  return v2;
}

//----- (000A8EA0) --------------------------------------------------------
int __cdecl sub_A8EA0(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-10h]
  int v4; // [esp+4h] [ebp-Ch]
  signed int i; // [esp+8h] [ebp-8h]
  int v6; // [esp+Ch] [ebp-4h]

  v4 = a2 - 1;
  result = (int)&a1[a2 - 1];
  if ( *(_DWORD *)(result + 32) == 1 )
  {
    ++a1[5];
    a1[v4 + 8] = a1[v4 + 72];
    a1[v4 + 56] = a1[v4 + 40];
    sub_A4F10((int)a1, v4 | 0xB0, 64, 0);
    v6 = a1[7];
    v3 = a1[6];
    while ( v6 )
    {
      if ( *(_DWORD *)(v3 + 4) != 1 )
      {
        for ( i = 0; i < 32; ++i )
        {
          if ( *(_DWORD *)(v3 + 4 * i + 1368) != -1 && *(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 4 * i + 1368) + 148) == v4 )
          {
            sub_A5850(v3, *(unsigned int *)(v3 + 4 * i + 1368) | 0x80, *(_DWORD *)(v3 + 4 * i + 1496), 0, 0);
            *(_DWORD *)(v3 + 4 * i + 1368) = -1;
          }
        }
      }
      --v6;
      v3 += 1816;
    }
    if ( a1[v4 + 40] )
    {
      if ( *(_DWORD *)(a1[v4 + 40] + 4) != 1 )
        sub_A5FD0(a1[v4 + 40], v4);
    }
    result = (int)a1;
    --*(_DWORD *)(result + 20);
  }
  return result;
}

//----- (000A9080) --------------------------------------------------------
int __cdecl sub_A9080(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  if ( a1 )
  {
    a1[a2 + 36] = a3 - 1;
    result = 4 * a3 + *a1;
    if ( *(_DWORD *)(result + 28) == 1 )
    {
      result = *(_DWORD *)(4 * a3 + *a1 + 92);
      if ( (_DWORD *)result != a1 )
      {
        result = (int)a1;
        *(_DWORD *)(*a1 + 4 * a3 + 92) = a1;
      }
    }
  }
  return result;
}

//----- (000A9100) --------------------------------------------------------
int __cdecl sub_A9100(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-4h]

  if ( a1 )
    v3 = *(_DWORD *)(a1 + 4 * a2 + 144) + 1;
  else
    v3 = 0;
  return v3;
}

//----- (000A9140) --------------------------------------------------------
_DWORD *__cdecl sub_A9140(_DWORD *a1, int a2, int a3, unsigned int a4, int a5)
{
  _DWORD *result; // eax

  ++a1[5];
  if ( a2 )
  {
    sub_A5850(a2, a3, a4, a5, 0);
  }
  else
  {
    if ( (a3 & 0xF0) == 176 && a4 == 7 )
    {
      a5 = a1[108] * a5 / 127;
      if ( a5 > 127 )
        a5 = 127;
      if ( a5 < 0 )
        a5 = 0;
    }
    if ( !a1[104] || !((int (__cdecl *)(_DWORD *, _DWORD, int, unsigned int, int))a1[104])(a1, 0, a3, a4, a5) )
      sub_A4F10((int)a1, a3, a4, a5);
  }
  sub_A4EB0((int)a1);
  result = a1;
  --result[5];
  return result;
}

//----- (000A9230) --------------------------------------------------------
int __cdecl sub_A9230(int a1, int a2)
{
  int v2; // eax
  int result; // eax
  int v4; // [esp+4h] [ebp-4h]

  ++*(_DWORD *)(a1 + 20);
  v4 = a2 + 1;
  v2 = sub_A5040(&v4);
  sub_A4FD0(a1, a2, v4 - a2 + v2);
  result = a1;
  --*(_DWORD *)(result + 20);
  return result;
}

//----- (000A9280) --------------------------------------------------------
bool sub_A9280()
{
  bool result; // eax

  if ( dword_E4B1C )
  {
    sub_9D650((unsigned int)sub_A4CF0, (unsigned int)sub_A9280);
    sub_9D740((unsigned int)aSample, 128);
    sub_9D740((unsigned int)&dword_E4B18, 4);
    sub_9D740((unsigned int)&dword_181EB8, 4);
    sub_9D740((unsigned int)&dword_181EBC, 4);
    sub_9D740((unsigned int)&dword_181EC4, 4);
    sub_9D740((unsigned int)&dword_181ED4, 4);
    sub_9D740((unsigned int)&dword_181EC8, 4);
    sub_9D740((unsigned int)&dword_181ECC, 4);
    sub_9D740((unsigned int)&dword_181EB4, 4);
    sub_9D740((unsigned int)&dword_181ED0, 4);
    sub_9D740((unsigned int)&dword_181EDC, 4);
    sub_9D740((unsigned int)&dword_181ED8, 4);
    result = sub_9D740((unsigned int)&dword_181EB0, 4);
    dword_E4B1C = 0;
  }
  return result;
}
// E4B18: using guessed type int dword_E4B18;
// E4B1C: using guessed type int dword_E4B1C;
// 181EB0: using guessed type int dword_181EB0;
// 181EB4: using guessed type int dword_181EB4;
// 181EB8: using guessed type int dword_181EB8;
// 181EBC: using guessed type int dword_181EBC;
// 181EC4: using guessed type int dword_181EC4;
// 181EC8: using guessed type int dword_181EC8;
// 181ECC: using guessed type int dword_181ECC;
// 181ED0: using guessed type int dword_181ED0;
// 181ED4: using guessed type int dword_181ED4;
// 181ED8: using guessed type int dword_181ED8;
// 181EDC: using guessed type int dword_181EDC;

//----- (000A9590) --------------------------------------------------------
bool sub_A9590()
{
  bool result; // eax

  if ( !dword_E4B2C )
  {
    result = sub_9D590((unsigned int)sub_A9590, (unsigned int)sub_AA620);
    dword_E4B2C = 1;
  }
  return result;
}
// E4B2C: using guessed type int dword_E4B2C;

//----- (000A95D0) --------------------------------------------------------
_DWORD *__cdecl sub_A95D0(int a1, char a2, unsigned int a3, unsigned __int8 a4)
{
  _DWORD *result; // eax
  int v5; // [esp+0h] [ebp-8h]
  unsigned int v6; // [esp+4h] [ebp-4h]

  v6 = a2 & 0xF0;
  result = (_DWORD *)(a2 & 0xF);
  v5 = a2 & 0xF;
  if ( v6 < 0xC0 )
  {
    if ( v6 == 176 )
    {
      if ( a3 < 0x5B )
      {
        if ( a3 < 7 )
        {
          if ( a3 >= 1 )
          {
            if ( a3 <= 1 )
            {
              result = (_DWORD *)(a1 + 4 * v5);
              result[160] = a4;
            }
            else if ( a3 == 6 )
            {
              result = (_DWORD *)(a1 + 4 * v5);
              result[272] = a4;
            }
          }
        }
        else if ( a3 <= 7 )
        {
          result = (_DWORD *)(a1 + 4 * v5);
          result[176] = a4;
        }
        else if ( a3 < 0xB )
        {
          if ( a3 == 10 )
          {
            result = (_DWORD *)(a1 + 4 * v5);
            result[192] = a4;
          }
        }
        else if ( a3 <= 0xB )
        {
          result = (_DWORD *)(a1 + 4 * v5);
          result[208] = a4;
        }
        else if ( a3 == 64 )
        {
          result = (_DWORD *)(a1 + 4 * v5);
          result[224] = a4;
        }
      }
      else if ( a3 <= 0x5B )
      {
        result = (_DWORD *)(a1 + 4 * v5);
        result[240] = a4;
      }
      else if ( a3 < 0x70 )
      {
        if ( a3 < 0x6E )
        {
          if ( a3 == 93 )
          {
            result = (_DWORD *)(a1 + 4 * v5);
            result[256] = a4;
          }
        }
        else if ( a3 <= 0x6E )
        {
          result = (_DWORD *)(a1 + 4 * v5);
          result[48] = a4;
        }
        else
        {
          result = (_DWORD *)(a1 + 4 * v5);
          result[64] = a4;
        }
      }
      else if ( a3 <= 0x70 )
      {
        result = (_DWORD *)(a1 + 4 * v5);
        result[96] = a4;
      }
      else if ( a3 < 0x73 )
      {
        if ( a3 == 114 )
        {
          result = (_DWORD *)(a1 + 4 * v5);
          result[112] = a4;
        }
      }
      else if ( a3 <= 0x73 )
      {
        result = (_DWORD *)(a1 + 4 * v5);
        result[128] = a4;
      }
      else if ( a3 == 119 )
      {
        result = (_DWORD *)(a1 + 4 * v5);
        result[144] = a4;
      }
    }
  }
  else if ( v6 <= 0xC0 )
  {
    result = (_DWORD *)(a1 + 4 * v5);
    *result = (unsigned __int8)a3;
  }
  else if ( v6 == 224 )
  {
    *(_DWORD *)(a1 + 4 * v5 + 64) = (unsigned __int8)a3;
    result = (_DWORD *)(a1 + 4 * v5);
    result[32] = a4;
  }
  return result;
}

//----- (000A98D0) --------------------------------------------------------
_DWORD *__cdecl sub_A98D0(_DWORD *a1, int a2, int a3)
{
  signed int v5; // [esp+4h] [ebp-8h]
  _DWORD *v6; // [esp+8h] [ebp-4h]

  v6 = a1;
  v5 = 0;
  while ( 1 )
  {
    if ( v5 >= 512 )
      return 0;
    if ( *v6 == -1 )
      return 0;
    if ( *v6 == a2 && v6[1] == a3 )
      break;
    ++v5;
    v6 += 8;
  }
  return v6;
}

//----- (000A9950) --------------------------------------------------------
int __cdecl sub_A9950(int a1, int a2)
{
  int v2; // ST0C_4

  v2 = *(_DWORD *)(a1 + 4 * a2 + 1304);
  sub_93E30(
    *(_DWORD **)(a1 + 4 * a2 + 1236),
    *(_DWORD *)(a1 + 4 * a2 + 1560) * (*(_DWORD *)(a1 + 4 * v2 + 852) * *(_DWORD *)(4 * v2 + a1 + 724) / 127) / 127);
  return sub_93ED0(*(_DWORD **)(a1 + 4 * a2 + 1236), *(_DWORD *)(a1 + 4 * v2 + 788));
}

//----- (000A9A30) --------------------------------------------------------
int __cdecl sub_A9A30(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-2Ch]
  int v4; // [esp+0h] [ebp-2Ch]
  signed int v5; // [esp+4h] [ebp-28h]
  int v6; // [esp+10h] [ebp-1Ch]
  int v7; // [esp+14h] [ebp-18h]
  int v8; // [esp+18h] [ebp-14h]
  int v9; // [esp+18h] [ebp-14h]
  int v10; // [esp+1Ch] [ebp-10h]
  int v11; // [esp+20h] [ebp-Ch]
  int v12; // [esp+28h] [ebp-4h]

  v12 = *(_DWORD *)(a1 + 4 * a2 + 1304);
  v8 = *(_DWORD *)(a1 + 4 * a2 + 1496);
  v11 = *(_DWORD *)(a1 + 4 * a2 + 1368);
  v3 = (*(_DWORD *)(a1 + 4 * v12 + 148) << 7) | *(_DWORD *)(a1 + 4 * v12 + 84);
  if ( v3 <= 0x2000 )
  {
    if ( v3 >= 0x2000 )
    {
      v4 = 0;
      v5 = 0;
    }
    else
    {
      v4 = 0x2000 - v3;
      v5 = -1;
    }
  }
  else
  {
    v4 = v3 - 0x1FFF;
    v5 = 1;
  }
  v10 = v5 * *(_DWORD *)(a1 + 4 * v12 + 1108) + v11;
  if ( v10 < 0 )
    v10 = 0;
  if ( v10 > 127 )
    v10 = 127;
  v7 = dword_A9390[v11];
  v6 = ((v4 * (dword_A9390[v10] - v7)
       - (__CFSHL__(v4 * (dword_A9390[v10] - v7) >> 31, 13)
        + (v4 * (dword_A9390[v10] - v7) >> 31 << 13))) >> 13)
     + v7;
  if ( v12 == 9 )
    v9 = v6 * v8 / v7;
  else
    v9 = v6 * (v7 * v8 / dword_A9390[*(_DWORD *)(a1 + 4 * a2 + 1432)]) / v7;
  return sub_93D90(*(_DWORD *)(a1 + 4 * a2 + 1236), v9);
}
// A9390: using guessed type int dword_A9390[];

//----- (000AA310) --------------------------------------------------------
_DWORD *__cdecl sub_AA310(int a1, int a2, int a3, signed int a4)
{
  signed int v5; // [esp+0h] [ebp-10h]
  _DWORD *v6; // [esp+4h] [ebp-Ch]
  signed int i; // [esp+8h] [ebp-8h]
  signed int j; // [esp+8h] [ebp-8h]
  int k; // [esp+8h] [ebp-8h]
  _DWORD *v10; // [esp+Ch] [ebp-4h]

  sub_A9590();
  v10 = (_DWORD *)sub_9D450(1692);
  if ( v10 )
  {
    v10[1] = a1;
    *v10 = a2;
    v10[2] = a3;
    v10[3] = sub_97A60(a2, (int)sub_A9C50);
    v10[4] = sub_97BB0(a2, (int)sub_A9C00);
    *(_DWORD *)(a2 + 436) = v10;
    for ( i = 0; i < 16; ++i )
    {
      v10[i + 5] = 0;
      v10[i + 21] = 0;
      v10[i + 37] = 64;
      v10[i + 117] = 0;
      v10[i + 181] = 127;
      v10[i + 197] = 64;
      v10[i + 213] = 127;
      v10[i + 277] = dword_181DEC;
    }
    for ( v10[325] = 0; ; ++v10[325] )
    {
      v5 = a4 <= 16 ? a4 : 16;
      if ( v10[325] >= v5 )
        break;
      v10[v10[325] + 309] = sub_93510(v10[1]);
      if ( !v10[v10[325] + 309] )
        break;
    }
    for ( j = 0; j < 16; ++j )
      v10[j + 293] = 0;
    for ( k = 0; k < v10[325]; ++k )
      v10[k + 326] = -1;
    v10[422] = 0;
    v6 = v10;
  }
  else
  {
    qmemcpy(&byte_181C90, aInsufficientMe_0, 0x2Au);
    v6 = 0;
  }
  return v6;
}
// A9C00: using guessed type int sub_A9C00();
// A9C50: using guessed type int sub_A9C50();
// 181C90: using guessed type char byte_181C90;
// 181DEC: using guessed type int dword_181DEC;

//----- (000AA590) --------------------------------------------------------
int __cdecl sub_AA590(int *a1)
{
  int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < a1[325]; ++i )
    sub_937A0(a1[i + 309]);
  sub_97A60(*a1, a1[3]);
  sub_97BB0(*a1, a1[4]);
  return sub_9D490((unsigned int)a1, 1692);
}

//----- (000AA620) --------------------------------------------------------
bool sub_AA620()
{
  bool result; // eax

  if ( dword_E4B2C )
  {
    result = sub_9D650((unsigned int)sub_A9590, (unsigned int)sub_AA620);
    dword_E4B2C = 0;
  }
  return result;
}
// E4B2C: using guessed type int dword_E4B2C;

//----- (000AB610) --------------------------------------------------------
int __fastcall sub_AB610(int a1, _DWORD *a2)
{
  _DWORD *v2; // ebx
  int v3; // ST00_4
  int result; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // esi
  int v8; // edi
  int v9; // ebp
  int v10; // ebx

  v2 = a2;
  v3 = a2[7];
  result = *a2;
  v5 = a2[2];
  v6 = a2[3];
  v7 = v2[5];
  v8 = v2[6];
  v9 = v2[4];
  __ES__ = *((_WORD *)v2 + 15);
  __FS__ = *((_WORD *)v2 + 16);
  __GS__ = *((_WORD *)v2 + 17);
  v10 = v2[1];
  return result;
}

//----- (000AB9E1) --------------------------------------------------------
signed int __cdecl sub_AB9E1(int a1)
{
  char v2; // [esp+0h] [ebp-1Ch]
  unsigned __int8 v3; // [esp+4h] [ebp-18h]
  unsigned __int8 v4; // [esp+5h] [ebp-17h]
  unsigned __int8 v5; // [esp+6h] [ebp-16h]
  unsigned __int8 v6; // [esp+7h] [ebp-15h]
  char v7; // [esp+8h] [ebp-14h]
  char v8; // [esp+9h] [ebp-13h]
  char v9; // [esp+Ah] [ebp-12h]
  char v10; // [esp+Bh] [ebp-11h]
  char v11; // [esp+Ch] [ebp-10h]
  int v13; // [esp+14h] [ebp-8h]
  int v14; // [esp+18h] [ebp-4h]

  v13 = -1;
  v7 = 82;
  v8 = 78;
  v9 = 67;
  v10 = 1;
  v11 = 0;
  v14 = sub_98817(a1, 512);
  if ( v14 <= 0 )
    return -1;
  sub_988A7(v14, (int)&v2, 8);
  if ( !strncmp(&v2, &v7, 4) )
  {
    v13 = v3 << 8;
    v13 += v4;
    v13 <<= 8;
    v13 += v5;
    v13 <<= 8;
    v13 += v6;
  }
  else
  {
    v13 = filelength(v14);
  }
  sub_98882(v14);
  return v13;
}
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// 99682: using guessed type _DWORD __cdecl strncmp(_DWORD, _DWORD, _DWORD);

//----- (000AC24B) --------------------------------------------------------
int sub_AC24B()
{
  return 0;
}

//----- (000AC250) --------------------------------------------------------
signed int __cdecl sub_AC250(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, _DWORD *a7, signed int *a8)
{
  signed int result; // eax
  int v9; // ebx
  int v10; // esi
  int v11; // ebp
  int v12; // edi
  int v13; // ecx
  int v14; // eax
  int v15; // [esp+Ch] [ebp-24h]
  int v16; // [esp+10h] [ebp-20h]
  int v17; // [esp+14h] [ebp-1Ch]
  int v18; // [esp+18h] [ebp-18h]
  int v19; // [esp+1Ch] [ebp-14h]

  if ( dword_E4CCC )
    goto LABEL_8;
  result = sub_B1138(dword_182188, 3);
  if ( result )
  {
    result = sub_B1138(dword_1821A0, 3);
    if ( result )
    {
      result = sub_B1138(dword_1821B8, 3);
      if ( result )
      {
        result = sub_B1138(dword_1821D0, 6);
        if ( result )
        {
          result = sub_B1138(dword_1821E8, 6);
          if ( result )
          {
            dword_E4CCC = 1;
LABEL_8:
            v19 = sub_B11E8(dword_182188, a1);
            v9 = sub_B11E8(dword_1821A0, a2);
            v10 = sub_B11E8(dword_1821B8, a3);
            v11 = sub_B11E8(
                    dword_1821D0,
                    ((unsigned __int64)(51471i64 * a4) >> 32 != 0) + ((unsigned __int64)(51471i64 * a4) >> 14));
            v12 = sub_B11E8(
                    dword_1821E8,
                    ((unsigned __int64)(51471i64 * a5) >> 32 != 0) + ((unsigned __int64)(51471i64 * a5) >> 14));
            sub_B14F8(&v17, v11);
            sub_B14F8(&v15, v12);
            v13 = ((unsigned __int64)(v9 * (signed __int64)v18) >> 32 != 0)
                + ((unsigned __int64)(v9 * (signed __int64)v18) >> 14)
                - (((unsigned __int64)(v10 * (signed __int64)v17) >> 32 != 0)
                 + ((unsigned __int64)(v10 * (signed __int64)v17) >> 14));
            v14 = sub_B1304(
                    ((unsigned __int64)(v10 * (signed __int64)v18) >> 32 != 0)
                  + ((unsigned __int64)(v10 * (signed __int64)v18) >> 14)
                  + ((unsigned __int64)(v9 * (signed __int64)v17) >> 32 != 0)
                  + ((unsigned __int64)(v9 * (signed __int64)v17) >> 14),
                    ((unsigned __int64)(v19 * (signed __int64)v16) >> 32 != 0)
                  + ((unsigned __int64)(v19 * (signed __int64)v16) >> 14)
                  - (((unsigned __int64)(v13 * (signed __int64)v15) >> 32 != 0)
                   + ((unsigned __int64)(v13 * (signed __int64)v15) >> 14)));
            *a6 = ((unsigned __int64)((signed int)&unk_E52EE * (signed __int64)v14) >> 32 != 0)
                + ((unsigned __int64)((signed int)&unk_E52EE * (signed __int64)v14) >> 14);
            *a7 = ((unsigned __int64)((signed int)&unk_E52EE * (signed __int64)v11) >> 32 != 0)
                + ((unsigned __int64)((signed int)&unk_E52EE * (signed __int64)v11) >> 14);
            result = ((unsigned __int64)((signed int)&unk_E52EE * (signed __int64)v12) >> 32 != 0)
                   + ((unsigned __int64)((signed int)&unk_E52EE * (signed __int64)v12) >> 14);
            *a8 = result;
            return result;
          }
        }
      }
    }
  }
  return result;
}
// E4CCC: using guessed type int dword_E4CCC;

//----- (000AC449) --------------------------------------------------------
void sub_AC449()
{
  _disable();
}

//----- (000AC44B) --------------------------------------------------------
void sub_AC44B()
{
  _enable();
}

//----- (000AC70E) --------------------------------------------------------
__int16 sub_AC70E()
{
  _DWORD *v0; // ebx
  int v1; // edx
  int v2; // ecx
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  _DWORD v8[2]; // [esp+0h] [ebp-8h]

  byte_E3E28 = 3;
  byte_E4D18 = 1;
  __asm { smsw    word_E4D16 }
  word_E4D16 &= 6u;
  __sidt(v8);
  v0 = (_DWORD *)(*(_DWORD *)((char *)v8 + 2) + 56);
  if ( byte_E4CB4 )
  {
    sub_AC7D9();
    __ES__ = word_E3B9A;
    *MK_FP(word_E3B9A, v0) = v1;
    v0[1] = v2;
    LOWORD(v3) = sub_AC843();
  }
  else if ( byte_E4CB2 )
  {
    if ( byte_E4CB2 == 9 )
    {
      sub_AC7D9();
      *v0 = v4;
      v0[1] = v5;
      LOWORD(v3) = (*(int (__fastcall **)(signed int, int, signed int))(dword_E3B94 + 48))(3586, v4, 4);
    }
    else if ( byte_E4CB2 == 1 )
    {
      LOWORD(v3) = _hook387(0, word_E3B98, v0);
    }
    else
    {
      v3 = _hook387(0, 0, v0);
      if ( (_BYTE)v3 != 1 )
        LOWORD(v3) = sub_AC7F6(v3, v6, (int)v0);
    }
  }
  else
  {
    v8[1] = (unsigned __int16)__DS__;
    __asm { int     21h; DOS - SET INTERRUPT VECTOR }
    LOWORD(v3) = -3324;
    __asm { int     21h; DOS - Novell Advanced NetWare 2.0+ - FILE SERVER FILE COPY }
  }
  return v3;
}
// B4A72: using guessed type int __fastcall _hook387(_DWORD, _DWORD, _DWORD);
// E3B94: using guessed type int dword_E3B94;
// E3B98: using guessed type __int16 word_E3B98;
// E3B9A: using guessed type __int16 word_E3B9A;
// E3E28: using guessed type char byte_E3E28;
// E4CB2: using guessed type char byte_E4CB2;
// E4CB4: using guessed type char byte_E4CB4;
// E4D16: using guessed type __int16 word_E4D16;
// E4D18: using guessed type char byte_E4D18;

//----- (000AC7D9) --------------------------------------------------------
void sub_AC7D9()
{
  ;
}

//----- (000AC7F6) --------------------------------------------------------
signed __int16 __fastcall sub_AC7F6(int a1, int a2, int a3)
{
  signed __int16 result; // ax
  unsigned __int32 v4; // ecx

  __asm { int     21h; DOS - SET INTERRUPT VECTOR }
  dword_E4D10 = a3;
  word_E4D14 = __ES__;
  result = 9476;
  if ( byte_E4CB2 < 3 )
  {
    __asm { int     21h; DOS - }
    v4 = __readcr0();
    __writecr0((v4 | 4) & 0xFFFFFFFD);
  }
  else
  {
    __asm { int     21h; DOS - SET INTERRUPT VECTOR }
    result = sub_AC843();
  }
  return result;
}
// E4CB2: using guessed type char byte_E4CB2;
// E4D10: using guessed type int dword_E4D10;
// E4D14: using guessed type __int16 word_E4D14;

//----- (000AC843) --------------------------------------------------------
signed __int16 sub_AC843()
{
  signed __int16 result; // ax

  result = 9525;
  __asm { int     21h; DOS - SET INTERRUPT VECTOR }
  dword_E4CD0 |= 4u;
  dword_E4CD0 &= 0xFFFFFFFD;
  __asm { int     21h; DOS - }
  return result;
}
// E4CD0: using guessed type int dword_E4CD0;

//----- (000AC8DD) --------------------------------------------------------
signed __int16 sub_AC8DD()
{
  signed __int16 result; // ax
  unsigned __int32 v1; // ecx

  result = 9476;
  __asm { int     21h; DOS - SET INTERRUPT VECTOR }
  if ( byte_E4CB2 >= 3 )
    return sub_AC918();
  v1 = __readcr0();
  v1 &= 0xFFFFFFF9;
  LOWORD(v1) = word_E4D16 | v1;
  __writecr0(v1);
  return result;
}
// E4CB2: using guessed type char byte_E4CB2;
// E4D10: using guessed type int dword_E4D10;
// E4D14: using guessed type __int16 word_E4D14;
// E4D16: using guessed type __int16 word_E4D16;

//----- (000AC918) --------------------------------------------------------
signed __int16 sub_AC918()
{
  signed __int16 result; // ax

  result = 9525;
  __asm { int     21h; DOS - SET INTERRUPT VECTOR }
  dword_E4CD0 = (unsigned __int16)word_E4D16;
  __asm { int     21h; DOS - }
  return result;
}
// E4CD0: using guessed type int dword_E4CD0;
// E4D16: using guessed type __int16 word_E4D16;

//----- (000AC9C3) --------------------------------------------------------
void *sub_AC9C3()
{
  return &unk_182204;
}

//----- (000AC9C9) --------------------------------------------------------
void *sub_AC9C9()
{
  return &unk_182200;
}

//----- (000ACB61) --------------------------------------------------------
signed int __cdecl sub_ACB61(int a1, unsigned __int8 *a2, int *a3)
{
  int *v3; // edi
  int v4; // ebp
  unsigned __int8 *v5; // ebx
  unsigned __int8 *v6; // ecx
  int v7; // ebx
  int v8; // eax
  unsigned __int8 *v9; // eax
  unsigned int v10; // ebx
  int v11; // eax
  signed int result; // eax
  int v13; // [esp-4h] [ebp-18h]
  signed int v14; // [esp+0h] [ebp-14h]

  v3 = a3;
  v4 = 0;
  v14 = 0;
  *(_BYTE *)(a1 + 16) &= 0xFDu;
  while ( 1 )
  {
    v5 = a2;
    v6 = a2++ + 1;
    v7 = *v5;
    if ( !v7 )
      break;
    if ( IsTable[(unsigned __int8)(v7 + 1)] & 2 )
    {
      v4 += sub_ACE56(a1);
    }
    else if ( v7 == 37 )
    {
      v9 = sub_ACD79(v6, a1);
      a2 = v9;
      v10 = *v9;
      if ( *v9 )
        a2 = v9 + 1;
      if ( v10 < 0x65 )
      {
        if ( v10 < 0x58 )
        {
          if ( v10 < 0x45 )
          {
            if ( v10 == 37 )
            {
              v8 = (*(int (__cdecl **)(int))a1)(a1);
              if ( v8 != 37 )
              {
LABEL_7:
                if ( !(*(_BYTE *)(a1 + 16) & 2) )
                  (*(void (__cdecl **)(int, int))(a1 + 4))(v8, a1);
                break;
              }
            }
          }
          else if ( v10 <= 0x45 || v10 == 71 )
          {
LABEL_45:
            sub_AD1E8(a1, v3);
            goto LABEL_50;
          }
        }
        else
        {
          if ( v10 <= 0x58 )
          {
LABEL_44:
            sub_AD52B(a1, v3, 16, 1);
            goto LABEL_50;
          }
          if ( v10 >= 0x63 )
          {
            if ( v10 > 0x63 )
            {
              v13 = 1;
              goto LABEL_40;
            }
            v11 = sub_ACE8D((_WORD *)a1, a1, v3);
LABEL_50:
            if ( v11 <= 0 )
              break;
            v4 += v11;
            if ( *(_BYTE *)(a1 + 16) & 1 )
              ++v14;
            goto LABEL_55;
          }
          if ( v10 == 91 )
          {
            sub_AD0E2((_BYTE *)a1, a1, v3, &a2);
            goto LABEL_50;
          }
        }
      }
      else
      {
        if ( v10 <= 0x67 )
          goto LABEL_45;
        if ( v10 < 0x70 )
        {
          if ( v10 < 0x6E )
          {
            if ( v10 == 105 )
            {
              sub_AD52B(a1, v3, 0, 1);
              goto LABEL_50;
            }
          }
          else
          {
            if ( v10 > 0x6E )
            {
              sub_AD52B(a1, v3, 8, 1);
              goto LABEL_50;
            }
            sub_AD033(a1, v3, v4);
          }
        }
        else
        {
          if ( v10 <= 0x70 )
            goto LABEL_44;
          if ( v10 < 0x75 )
          {
            if ( v10 == 115 )
            {
              sub_ACF1A((_BYTE *)a1, a1, v3);
              goto LABEL_50;
            }
          }
          else
          {
            if ( v10 <= 0x75 )
            {
              v13 = 0;
LABEL_40:
              sub_AD52B(a1, v3, 10, v13);
              goto LABEL_50;
            }
            if ( v10 == 120 )
              goto LABEL_44;
          }
        }
      }
    }
    else
    {
      v8 = (*(int (__cdecl **)(int))a1)(a1);
      if ( v8 != v7 )
        goto LABEL_7;
      ++v4;
    }
LABEL_55:
    if ( *(_BYTE *)(a1 + 16) & 2 )
    {
      if ( *a2 == 37 )
      {
        ++a2;
        a2 = sub_ACD79(a2, a1);
        if ( *a2 == 110 )
          sub_AD033(a1, v3, v4);
      }
      break;
    }
  }
  if ( v14 || !(*(_BYTE *)(a1 + 16) & 2) )
    result = v14;
  else
    result = -1;
  return result;
}

//----- (000ACD79) --------------------------------------------------------
unsigned __int8 *__cdecl sub_ACD79(unsigned __int8 *a1, int a2)
{
  unsigned __int8 *result; // eax
  char v3; // dl
  int v4; // edx
  unsigned __int8 v5; // cl
  int v6; // [esp+0h] [ebp-Ch]

  result = a1;
  v3 = *(_BYTE *)(a2 + 16) | 1;
  *(_DWORD *)(a2 + 12) = -1;
  *(_BYTE *)(a2 + 16) = v3;
  *(_BYTE *)(a2 + 16) = v3 & 3;
  if ( *a1 == 42 )
  {
    result = a1 + 1;
    *(_BYTE *)(a2 + 16) &= 0xFEu;
  }
  v6 = *result;
  if ( IsTable[(unsigned __int8)(v6 + 1)] & 0x20 )
  {
    v4 = 0;
    do
    {
      ++result;
      v4 = v6 - 48 + 10 * v4;
      v6 = *result;
    }
    while ( IsTable[(unsigned __int8)(v6 + 1)] & 0x20 );
    *(_DWORD *)(a2 + 12) = v4;
  }
  if ( *result == 78 )
  {
    *(_BYTE *)(a2 + 16) |= 8u;
  }
  else
  {
    if ( *result != 70 )
      goto LABEL_12;
    *(_BYTE *)(a2 + 16) |= 4u;
  }
  ++result;
LABEL_12:
  v5 = *result;
  if ( *result < 0x68u )
  {
    if ( v5 == 76 )
    {
      ++result;
      *(_BYTE *)(a2 + 16) |= 0x40u;
    }
  }
  else if ( *result <= 0x68u )
  {
    ++result;
    *(_BYTE *)(a2 + 16) |= 0x10u;
  }
  else if ( v5 >= 0x6Cu && (v5 <= 0x6Cu || v5 == 119) )
  {
    ++result;
    *(_BYTE *)(a2 + 16) |= 0x20u;
  }
  return result;
}

//----- (000ACE56) --------------------------------------------------------
int __cdecl sub_ACE56(int a1)
{
  int i; // esi
  int v2; // eax

  for ( i = 0; ; ++i )
  {
    v2 = (*(int (__cdecl **)(int))a1)(a1);
    if ( !(IsTable[(unsigned __int8)(v2 + 1)] & 2) )
      break;
  }
  if ( !(*(_BYTE *)(a1 + 16) & 2) )
    (*(void (__cdecl **)(int, int))(a1 + 4))(v2, a1);
  return i;
}

//----- (000ACE8D) --------------------------------------------------------
int __usercall sub_ACE8D@<eax>(_WORD *a1@<esi>, int a2, int *a3)
{
  char v3; // dl
  int v4; // esi
  int v5; // eoff
  int v6; // ecx
  int v7; // edx
  signed int v8; // edi
  int v9; // ebp
  __int16 v10; // ax
  char v11; // ch

  v3 = *(_BYTE *)(a2 + 16);
  if ( v3 & 1 )
  {
    if ( v3 & 4 )
    {
      v4 = *a3 + 8;
      *a3 = v4;
      v5 = v4 - 8;
      a1 = *(_WORD **)(v4 - 8);
      __ES__ = *(_WORD *)(v5 + 4);
    }
    else if ( v3 & 8 )
    {
      v6 = *a3 + 4;
      *a3 = v6;
      __ES__ = __DS__;
      a1 = *(_WORD **)(v6 - 4);
    }
    else
    {
      v7 = *a3 + 4;
      *a3 = v7;
      __ES__ = __DS__;
      a1 = *(_WORD **)(v7 - 4);
    }
  }
  v8 = *(_DWORD *)(a2 + 12);
  v9 = 0;
  if ( v8 == -1 )
    v8 = 1;
  while ( v8 > 0 )
  {
    v10 = (*(int (__cdecl **)(int))a2)(a2);
    v11 = *(_BYTE *)(a2 + 16);
    if ( v11 & 2 )
      break;
    ++v9;
    --v8;
    if ( v11 & 1 )
    {
      if ( v11 & 0x20 )
      {
        *a1 = v10;
        ++a1;
      }
      else
      {
        *(_BYTE *)a1 = v10;
        a1 = (_WORD *)((char *)a1 + 1);
      }
    }
  }
  return v9;
}

//----- (000ACF1A) --------------------------------------------------------
void __usercall sub_ACF1A(_BYTE *a1@<esi>, int a2, int *a3)
{
  char v3; // dh
  int v4; // esi
  int v5; // eoff
  int v6; // ecx
  int v7; // edx
  int i; // edi
  int v9; // eax
  int v10; // [esp+0h] [ebp-1Ch]
  unsigned __int8 v11; // [esp+4h] [ebp-18h]

  if ( *(_BYTE *)(a2 + 16) & 0x20 )
    v11 = 2;
  else
    v11 = 1;
  v3 = *(_BYTE *)(a2 + 16);
  if ( v3 & 1 )
  {
    if ( v3 & 4 )
    {
      v4 = *a3 + 8;
      *a3 = v4;
      v5 = v4 - 8;
      a1 = *(_BYTE **)(v4 - 8);
      __ES__ = *(_WORD *)(v5 + 4);
    }
    else if ( v3 & 8 )
    {
      v6 = *a3 + 4;
      *a3 = v6;
      __ES__ = __DS__;
      a1 = *(_BYTE **)(v6 - 4);
    }
    else
    {
      v7 = *a3 + 4;
      *a3 = v7;
      __ES__ = __DS__;
      a1 = *(_BYTE **)(v7 - 4);
    }
  }
  for ( i = 0; ; ++i )
  {
    v10 = (*(int (__cdecl **)(int))a2)(a2);
    if ( !(IsTable[(unsigned __int8)(v10 + 1)] & 2) )
      break;
  }
  if ( *(_BYTE *)(a2 + 16) & 2 )
  {
    i = 0;
  }
  else
  {
    v9 = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 12) = v9 - 1;
    if ( v9 )
    {
      while ( 1 )
      {
        ++i;
        if ( *(_BYTE *)(a2 + 16) & 1 )
        {
          if ( v11 == 1 )
            *a1 = v10;
          else
            *(_WORD *)a1 = v10;
          a1 += v11;
        }
        v10 = sub_AD783(a2);
        if ( v10 == -1 )
          break;
        if ( IsTable[(unsigned __int8)(v10 + 1)] & 2 )
          goto LABEL_23;
      }
    }
    else
    {
LABEL_23:
      (*(void (__cdecl **)(int, int))(a2 + 4))(v10, a2);
    }
  }
  if ( *(_BYTE *)(a2 + 16) & 1 && i > 0 )
  {
    if ( v11 == 1 )
      *a1 = 0;
    else
      *(_WORD *)a1 = 0;
  }
  JUMPOUT(&loc_ACF14);
}

//----- (000AD033) --------------------------------------------------------
int *__cdecl sub_AD033(int a1, int *a2, int a3)
{
  int *result; // eax
  char v4; // bl
  int v5; // esi
  int v6; // ecx
  int v7; // ebx

  result = a2;
  v4 = *(_BYTE *)(a1 + 16);
  if ( v4 & 1 )
  {
    if ( v4 & 4 )
    {
      v5 = *a2 + 8;
      *a2 = v5;
      result = *(int **)(v5 - 8);
      __ES__ = *(_WORD *)(v5 - 8 + 4);
    }
    else if ( v4 & 8 )
    {
      v6 = *a2 + 4;
      *a2 = v6;
      __ES__ = __DS__;
      result = *(int **)(v6 - 4);
    }
    else
    {
      v7 = *a2 + 4;
      *a2 = v7;
      __ES__ = __DS__;
      result = *(int **)(v7 - 4);
    }
    if ( *(_BYTE *)(a1 + 16) & 0x10 )
      *(_WORD *)result = a3;
    else
      *result = a3;
  }
  return result;
}

//----- (000AD09E) --------------------------------------------------------
_BYTE *__cdecl sub_AD09E(_BYTE *a1, int a2)
{
  int v2; // eax
  _BYTE *v3; // ebx

  memset(a2, 0, 32);
  v2 = (unsigned __int8)*a1;
  v3 = a1 + 1;
  if ( *a1 )
  {
    do
    {
      *(_BYTE *)((v2 >> 3) + a2) |= byte_D3EA0[v2 & 7];
      v2 = (unsigned __int8)*v3;
      if ( !*v3 )
        break;
      ++v3;
    }
    while ( v2 != 93 );
  }
  return v3;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);

//----- (000AD0E2) --------------------------------------------------------
void __usercall sub_AD0E2(_BYTE *a1@<esi>, int a2, int *a3, _BYTE **a4)
{
  _BYTE *v4; // eax
  _BOOL1 v5; // zf
  char v6; // cl
  int v7; // ebp
  int v8; // esi
  int v9; // ecx
  int v10; // edi
  int v11; // ebp
  int v12; // eax
  char v13; // dl
  char v14[32]; // [esp+0h] [ebp-40h]
  int v15; // [esp+20h] [ebp-20h]
  bool v16; // [esp+24h] [ebp-1Ch]
  int v17; // [esp+28h] [ebp-18h]

  v4 = *a4;
  v5 = **a4 != 94;
  v16 = **a4 == 94;
  if ( !v5 )
    *a4 = v4 + 1;
  *a4 = sub_AD09E(*a4, (int)v14);
  v6 = *(_BYTE *)(a2 + 16);
  if ( v6 & 1 )
  {
    if ( v6 & 4 )
    {
      v7 = *a3 + 8;
      *a3 = v7;
      a1 = *(_BYTE **)(v7 - 8);
      __ES__ = *(_WORD *)(v7 - 8 + 4);
    }
    else if ( v6 & 8 )
    {
      v8 = *a3 + 4;
      *a3 = v8;
      __ES__ = __DS__;
      a1 = *(_BYTE **)(v8 - 4);
    }
    else
    {
      v9 = *a3 + 4;
      *a3 = v9;
      __ES__ = __DS__;
      a1 = *(_BYTE **)(v9 - 4);
    }
  }
  v10 = *(_DWORD *)(a2 + 12);
  v11 = 0;
  while ( 1 )
  {
    if ( !v10 )
      goto LABEL_16;
    v12 = (*(int (__cdecl **)(int))a2)(a2);
    v13 = *(_BYTE *)(a2 + 16);
    v17 = v12;
    if ( v13 & 2 )
      goto LABEL_16;
    v15 = (unsigned __int8)v14[v12 >> 3];
    if ( ((unsigned __int8)(v15 & byte_D3EA0[v12 & 7]) == 0) != v16 )
      break;
    ++v11;
    --v10;
    if ( *(_BYTE *)(a2 + 16) & 1 )
      *a1++ = v17;
  }
  (*(void (__cdecl **)(int, int))(a2 + 4))(v12, a2);
LABEL_16:
  if ( *(_BYTE *)(a2 + 16) & 1 )
  {
    if ( v11 > 0 )
      *a1 = 0;
  }
  JUMPOUT(&loc_ACF14);
}
// AD0E2: using guessed type char var_40[32];

//----- (000AD1E8) --------------------------------------------------------
void __cdecl sub_AD1E8(int a1, int *a2)
{
  char *v2; // ebx
  int v3; // edi
  int i; // ebp
  int v5; // eax
  int v6; // ecx
  char *v7; // ecx
  char v8; // al
  int v9; // eax
  char v10; // ah
  int v11; // ecx
  int *v12; // ebx
  int v13; // ebx
  int v14; // edx
  char v15; // dh
  int v16; // eax
  char v17; // [esp+0h] [ebp-80h]
  _BYTE v18[3]; // [esp+1h] [ebp-7Fh]
  int v19; // [esp+50h] [ebp-30h]
  int v20; // [esp+54h] [ebp-2Ch]
  int v21; // [esp+58h] [ebp-28h]
  unsigned int j; // [esp+5Ch] [ebp-24h]
  int v23; // [esp+60h] [ebp-20h]
  int v24; // [esp+64h] [ebp-1Ch]
  int v25; // [esp+68h] [ebp-18h]

  v2 = &v17;
  v3 = 0;
  for ( i = 0; ; ++i )
  {
    v5 = (*(int (__cdecl **)(int))a1)(a1);
    v23 = v5;
    if ( !(IsTable[(unsigned __int8)(v5 + 1)] & 2) )
      break;
  }
  if ( *(_BYTE *)(a1 + 16) & 2 )
    goto LABEL_42;
  v6 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v6 - 1;
  if ( v6 )
  {
    if ( v5 == 43 || v5 == 45 )
    {
      v17 = v23;
      v2 = v18;
      v23 = sub_AD783(a1);
      if ( v23 == -1 )
        goto LABEL_42;
    }
    if ( IsTable[(unsigned __int8)(v23 + 1)] & 0x20 || v23 == 46 )
    {
      v21 = 0;
      v24 = 0;
      if ( IsTable[(unsigned __int8)(v23 + 1)] & 0x20 )
      {
        v24 = 1;
        while ( 1 )
        {
          *v2++ = v23;
          if ( *(_BYTE *)(a1 + 16) & 0x10 )
            HIWORD(v21) = v23 + 10 * HIWORD(v21) - 48;
          ++v3;
          v23 = sub_AD783(a1);
          if ( v23 == -1 )
            break;
          if ( !(IsTable[(unsigned __int8)(v23 + 1)] & 0x20) )
            goto LABEL_17;
        }
LABEL_42:
        if ( v3 > 0 && *(_BYTE *)(a1 + 16) & 1 )
        {
          *v2 = 0;
          if ( *(_BYTE *)(a1 + 16) & 0x10 )
          {
            if ( v17 == 45 )
              v21 = -v21;
          }
          else
          {
            off_E4D20(&v17, &v19);
          }
          v10 = *(_BYTE *)(a1 + 16);
          if ( v10 & 4 )
          {
            v11 = *a2 + 8;
            *a2 = v11;
            v12 = *(int **)(v11 - 8);
            __ES__ = *(_WORD *)(v11 - 8 + 4);
          }
          else if ( v10 & 8 )
          {
            v13 = *a2 + 4;
            *a2 = v13;
            __ES__ = __DS__;
            v12 = *(int **)(v13 - 4);
          }
          else
          {
            v14 = *a2 + 4;
            *a2 = v14;
            __ES__ = __DS__;
            v12 = *(int **)(v14 - 4);
          }
          v15 = *(_BYTE *)(a1 + 16);
          if ( v15 & 0x10 )
          {
            v16 = v21;
          }
          else
          {
            if ( v15 & 0x20 || v15 & 0x40 )
            {
              *v12 = v19;
              v12[1] = v20;
              goto LABEL_60;
            }
            v16 = _FDFS();
          }
          *v12 = v16;
        }
LABEL_60:
        JUMPOUT(&loc_ACF14);
      }
LABEL_17:
      if ( v23 == 46 )
      {
        *v2++ = 46;
        v23 = sub_AD783(a1);
        if ( v23 == -1 )
          goto LABEL_42;
        if ( !v24 && !(IsTable[(unsigned __int8)(v23 + 1)] & 0x20) )
          goto LABEL_41;
        ++v3;
        do
        {
          if ( !(IsTable[(unsigned __int8)(v23 + 1)] & 0x20) )
            break;
          ++v3;
          *v2++ = v23;
          v23 = sub_AD783(a1);
        }
        while ( v23 != -1 );
        if ( *(_BYTE *)(a1 + 16) & 0x10 )
        {
          v7 = v2;
          for ( j = 0; ; j /= 0xAu )
          {
            v8 = *--v7;
            if ( *v7 == 46 )
              break;
            v25 = 10;
            BYTE2(j) = v8 - 48;
          }
          LOWORD(v21) = j;
        }
        if ( v23 == -1 )
          goto LABEL_42;
      }
      if ( !(*(_BYTE *)(a1 + 16) & 0x10) && (v23 == 101 || v23 == 69) )
      {
        ++v3;
        *v2 = v23;
        v9 = sub_AD783(a1);
        ++v2;
        v23 = v9;
        if ( v9 == -1 )
          goto LABEL_42;
        if ( v9 == 43 || v9 == 45 )
        {
          ++v3;
          *v2++ = v23;
          v23 = sub_AD783(a1);
          if ( v23 == -1 )
            goto LABEL_42;
        }
        if ( IsTable[(unsigned __int8)(v23 + 1)] & 0x20 )
        {
          while ( 1 )
          {
            ++v3;
            *v2++ = v23;
            v23 = sub_AD783(a1);
            if ( v23 == -1 )
              goto LABEL_42;
            if ( !(IsTable[(unsigned __int8)(v23 + 1)] & 0x20) )
              goto LABEL_41;
          }
        }
        v3 = 0;
      }
    }
  }
LABEL_41:
  (*(void (__cdecl **)(int, int))(a1 + 4))(v23, a1);
  goto LABEL_42;
}
// B4C3A: using guessed type int _FDFS(void);
// E4D20: using guessed type int (__cdecl *off_E4D20)(_DWORD, _DWORD);

//----- (000AD52B) --------------------------------------------------------
void __cdecl sub_AD52B(int a1, int *a2, signed int a3, int a4)
{
  signed int v4; // ebp
  int v5; // edi
  signed int v6; // esi
  int v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  char v15; // ah
  int v16; // edx
  _WORD *v17; // eax
  int v18; // ebp
  int v19; // ecx
  signed int v20; // [esp+0h] [ebp-20h]
  int v21; // [esp+4h] [ebp-1Ch]
  int i; // [esp+8h] [ebp-18h]

  v4 = a3;
  v5 = 0;
  v6 = 0;
  for ( i = 0; ; ++i )
  {
    v7 = (*(int (__cdecl **)(int))a1)(a1);
    v21 = v7;
    if ( !(IsTable[(unsigned __int8)(v7 + 1)] & 2) )
      break;
  }
  if ( *(_BYTE *)(a1 + 16) & 2 )
    goto LABEL_34;
  v8 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v8 - 1;
  if ( v8 )
  {
    v20 = 43;
    if ( a4 && (v7 == 43 || v7 == 45) )
    {
      v20 = v7;
      v21 = sub_AD783(a1);
      if ( v21 == -1 )
        goto LABEL_34;
    }
    if ( !a3 )
    {
      if ( v21 != 48 )
      {
        v4 = 10;
        goto LABEL_26;
      }
      v9 = sub_AD783(a1);
      v6 = 1;
      v21 = v9;
      if ( v9 != -1 )
      {
        if ( v9 != 120 && v9 != 88 )
        {
          v4 = 8;
          goto LABEL_26;
        }
        v6 = 0;
        v21 = sub_AD783(a1);
        if ( v21 != -1 )
        {
          v4 = 16;
          goto LABEL_26;
        }
      }
      goto LABEL_34;
    }
    if ( a3 != 16 || v21 != 48 )
      goto LABEL_26;
    v10 = sub_AD783(a1);
    v6 = 1;
    v21 = v10;
    if ( v10 == -1 )
    {
LABEL_34:
      if ( v20 == 45 )
        v5 = -v5;
      if ( v6 > 0 )
      {
        v15 = *(_BYTE *)(a1 + 16);
        if ( v15 & 1 )
        {
          if ( v15 & 4 )
          {
            v16 = *a2 + 8;
            *a2 = v16;
            v17 = *(_WORD **)(v16 - 8);
            __ES__ = *(_WORD *)(v16 - 8 + 4);
          }
          else if ( v15 & 8 )
          {
            v18 = *a2 + 4;
            *a2 = v18;
            __ES__ = __DS__;
            v17 = *(_WORD **)(v18 - 4);
          }
          else
          {
            v19 = *a2 + 4;
            *a2 = v19;
            __ES__ = __DS__;
            v17 = *(_WORD **)(v19 - 4);
          }
          if ( *(_BYTE *)(a1 + 16) & 0x10 )
            *v17 = v5;
          else
            *(_DWORD *)v17 = v5;
        }
      }
      JUMPOUT(&loc_ACF14);
    }
    if ( v10 == 120 || v10 == 88 )
    {
      v11 = sub_AD783(a1);
      v6 = 0;
      goto LABEL_25;
    }
LABEL_26:
    while ( 1 )
    {
      v12 = sub_AD754(v21);
      if ( v12 >= v4 )
        break;
      v5 = v12 + v4 * v5;
      v11 = sub_AD783(a1);
      ++v6;
LABEL_25:
      v21 = v11;
      if ( v11 == -1 )
        goto LABEL_34;
    }
    if ( v21 == 58 && *(_BYTE *)(a1 + 16) < 0 )
    {
      while ( 1 )
      {
        v13 = sub_AD783(a1);
        ++v6;
        v21 = v13;
        if ( v13 == -1 )
          goto LABEL_34;
        v14 = sub_AD754(v13);
        if ( v14 >= v4 )
          break;
        v5 = v14 + v4 * v5;
      }
    }
  }
  (*(void (__cdecl **)(int, int))(a1 + 4))(v21, a1);
  goto LABEL_34;
}

//----- (000AD754) --------------------------------------------------------
int __cdecl sub_AD754(signed int a1)
{
  int result; // eax
  signed int v2; // eax

  if ( a1 >= 48 && a1 <= 57 )
    return a1 - 48;
  v2 = tolower(a1);
  if ( v2 < 97 || v2 > 102 )
    result = 16;
  else
    result = v2 - 87;
  return result;
}
// AB952: using guessed type _DWORD __cdecl tolower(_DWORD);

//----- (000AD783) --------------------------------------------------------
int __cdecl sub_AD783(int a1)
{
  int v1; // eax
  int result; // eax

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( !v1 || (result = (*(int (__cdecl **)(int))a1)(a1), *(_BYTE *)(a1 + 16) & 2) )
    result = -1;
  return result;
}

//----- (000ADC52) --------------------------------------------------------
int __cdecl sub_ADC52(_BYTE *a1)
{
  _DWORD *v1; // eax
  int v2; // eax

  if ( a1 && *a1 )
  {
    fputs(a1, &unk_E3BE0);
    fputs(asc_D3A8C, &unk_E3BE0);
  }
  v1 = sub_AC9C3();
  v2 = strerror(*v1);
  fputs(v2, &unk_E3BE0);
  return fputc(10, &unk_E3BE0);
}
// AC9CF: using guessed type _DWORD __cdecl fputc(_DWORD, _DWORD);
// B4E49: using guessed type _DWORD __cdecl fputs(_DWORD, _DWORD);
// B4EDE: using guessed type _DWORD __cdecl strerror(_DWORD);

//----- (000AEAF5) --------------------------------------------------------
int sub_AEAF5()
{
  return dword_E4C90;
}
// E4C90: using guessed type int dword_E4C90;

//----- (000AEF40) --------------------------------------------------------
int __usercall sub_AEF40@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int result; // eax

  do
  {
    v3 = *a3;
    ++a3;
    result = v3 ^ 0x8000;
    *a2++ = BYTE1(result);
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AEF51) --------------------------------------------------------
int __usercall sub_AEF51@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>)
{
  int result; // eax

  do
  {
    result = *a3;
    ++a3;
    *a2++ = BYTE1(result);
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AEF5D) --------------------------------------------------------
int __usercall sub_AEF5D@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    result = v3 ^ 0x8000;
    BYTE1(v4) ^= 0x80u;
    LOBYTE(v4) = BYTE1(result);
    *a2 = v4;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AEF7C) --------------------------------------------------------
int __usercall sub_AEF7C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax
  int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    LOBYTE(v4) = BYTE1(result);
    *a2 = v4;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AEF90) --------------------------------------------------------
char __usercall sub_AEF90@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  __int16 v5; // ax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    HIBYTE(v5) = BYTE1(v3) ^ 0x80;
    LOBYTE(v5) = BYTE1(v4) ^ 0x80;
    *a2 = v5;
    ++a2;
    --a1;
  }
  while ( a1 );
  return v5;
}

//----- (000AEFAF) --------------------------------------------------------
char __usercall sub_AEFAF@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // edx
  int v4; // eax

  do
  {
    v4 = *a3;
    v3 = a3[1];
    a3 += 2;
    LOBYTE(v4) = BYTE1(v3);
    *a2 = v4;
    ++a2;
    --a1;
  }
  while ( a1 );
  return v4;
}

//----- (000AEFC3) --------------------------------------------------------
int __usercall sub_AEFC3@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    *a3 = BYTE1(result);
    *a2 = BYTE1(v5) ^ 0x80;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AEFE0) --------------------------------------------------------
int __usercall sub_AEFE0@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    *a3 = BYTE1(result);
    *a2 = BYTE1(v5);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AEFF2) --------------------------------------------------------
int __usercall sub_AEFF2@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    *a3 = BYTE1(v5) ^ 0x80;
    *a2 = BYTE1(result);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF00F) --------------------------------------------------------
int __usercall sub_AF00F@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    *a3 = BYTE1(v5);
    *a2 = BYTE1(result);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF021) --------------------------------------------------------
int __usercall sub_AF021@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int result; // eax

  do
  {
    v3 = *a3;
    ++a3;
    result = v3 ^ 0x8000;
    *a2 = result;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF035) --------------------------------------------------------
int __usercall sub_AF035@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax

  do
  {
    result = *a3;
    ++a3;
    *a2 = result;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF044) --------------------------------------------------------
__int16 __usercall sub_AF044@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  __int16 result; // ax
  char v5; // t0

  do
  {
    v3 = *a3;
    ++a3;
    LOWORD(v3) = v3 ^ 0x8000;
    v5 = v3;
    LOBYTE(result) = BYTE1(v3);
    HIBYTE(result) = v5;
    *a2 = result;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF05A) --------------------------------------------------------
__int16 __usercall sub_AF05A@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  __int16 result; // ax
  char v5; // t0

  do
  {
    v3 = *a3;
    ++a3;
    v5 = v3;
    LOBYTE(result) = BYTE1(v3);
    HIBYTE(result) = v5;
    *a2 = result;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF06B) --------------------------------------------------------
int __usercall sub_AF06B@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    result = v3 ^ 0x8000;
    *a2 = result;
    a2[1] = v4 ^ 0x8000;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF08C) --------------------------------------------------------
int __usercall sub_AF08C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax
  int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    *a2 = result;
    a2[1] = v4;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF0A2) --------------------------------------------------------
int __usercall sub_AF0A2@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    result = v3 ^ 0x8000;
    *a2 = v4 ^ 0x8000;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF0C3) --------------------------------------------------------
int __usercall sub_AF0C3@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax
  int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    *a2 = v4;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF0D9) --------------------------------------------------------
int __usercall sub_AF0D9@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax
  char v6; // t0
  char v7; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    result = v3 ^ 0x8000;
    LOWORD(v4) = v4 ^ 0x8000;
    v6 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v6;
    v7 = v4;
    LOBYTE(v4) = BYTE1(v4);
    BYTE1(v4) = v7;
    *a2 = result;
    a2[1] = v4;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF0FE) --------------------------------------------------------
int __usercall sub_AF0FE@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // edx
  int result; // eax
  char v5; // t0
  char v6; // t1

  do
  {
    result = *a3;
    v3 = a3[1];
    a3 += 2;
    v5 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v5;
    v6 = v3;
    LOBYTE(v3) = BYTE1(v3);
    BYTE1(v3) = v6;
    *a2 = result;
    a2[1] = v3;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF118) --------------------------------------------------------
int __usercall sub_AF118@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax
  char v6; // t0
  char v7; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    result = v3 ^ 0x8000;
    LOWORD(v4) = v4 ^ 0x8000;
    v6 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v6;
    v7 = v4;
    LOBYTE(v4) = BYTE1(v4);
    BYTE1(v4) = v7;
    *a2 = v4;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF13D) --------------------------------------------------------
int __usercall sub_AF13D@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // edx
  int result; // eax
  char v5; // t0
  char v6; // t1

  do
  {
    result = *a3;
    v3 = a3[1];
    a3 += 2;
    v5 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v5;
    v6 = v3;
    LOBYTE(v3) = BYTE1(v3);
    BYTE1(v3) = v6;
    *a2 = v3;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF157) --------------------------------------------------------
int __usercall sub_AF157@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    *a3 = result;
    *a2 = v5 ^ 0x8000;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF17A) --------------------------------------------------------
int __usercall sub_AF17A@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    *a3 = result;
    *a2 = v5;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF192) --------------------------------------------------------
int __usercall sub_AF192@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    *a3 = v5 ^ 0x8000;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF1B5) --------------------------------------------------------
int __usercall sub_AF1B5@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    *a3 = v5;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF1CD) --------------------------------------------------------
int __usercall sub_AF1CD@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax
  char v7; // t0
  char v8; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    LOWORD(v5) = v5 ^ 0x8000;
    v7 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v7;
    v8 = v5;
    LOBYTE(v5) = BYTE1(v5);
    BYTE1(v5) = v8;
    *a3 = result;
    *a2 = v5;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF1F4) --------------------------------------------------------
int __usercall sub_AF1F4@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // edx
  int result; // eax
  char v6; // t0
  char v7; // t1

  do
  {
    result = *a4;
    v4 = a4[1];
    a4 += 2;
    v6 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v6;
    v7 = v4;
    LOBYTE(v4) = BYTE1(v4);
    BYTE1(v4) = v7;
    *a3 = result;
    *a2 = v4;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF210) --------------------------------------------------------
int __usercall sub_AF210@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax
  char v7; // t0
  char v8; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    LOWORD(v5) = v5 ^ 0x8000;
    v7 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v7;
    v8 = v5;
    LOBYTE(v5) = BYTE1(v5);
    BYTE1(v5) = v8;
    *a3 = v5;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF237) --------------------------------------------------------
int __usercall sub_AF237@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // edx
  int result; // eax
  char v6; // t0
  char v7; // t1

  do
  {
    result = *a4;
    v4 = a4[1];
    a4 += 2;
    v6 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v6;
    v7 = v4;
    LOBYTE(v4) = BYTE1(v4);
    BYTE1(v4) = v7;
    *a3 = v4;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF253) --------------------------------------------------------
int __usercall sub_AF253@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, signed int *a3@<esi>)
{
  signed int v3; // eax
  int result; // eax

  do
  {
    v3 = *a3;
    ++a3;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      v3 = -32768;
    }
    result = v3 ^ 0x8000;
    *a2++ = BYTE1(result);
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF280) --------------------------------------------------------
signed int __usercall sub_AF280@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, signed int *a3@<esi>)
{
  signed int result; // eax

  do
  {
    result = *a3;
    ++a3;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    *a2++ = BYTE1(result);
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF2A8) --------------------------------------------------------
int __usercall sub_AF2A8@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int v3; // eax
  signed int v4; // edx
  int result; // eax
  __int16 v6; // dx

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      v3 = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      BYTE1(v4) = 127;
    }
    else if ( v4 < -32768 )
    {
      BYTE1(v4) = -128;
    }
    result = v3 ^ 0x8000;
    HIBYTE(v6) = BYTE1(v4) ^ 0x80;
    LOBYTE(v6) = BYTE1(result);
    *a2 = v6;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF301) --------------------------------------------------------
signed int __usercall sub_AF301@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int result; // eax
  signed int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      BYTE1(v4) = 127;
    }
    else if ( v4 < -32768 )
    {
      BYTE1(v4) = -128;
    }
    LOBYTE(v4) = BYTE1(result);
    *a2 = v4;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF34F) --------------------------------------------------------
char __usercall sub_AF34F@<al>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int v3; // eax
  signed int v4; // edx
  __int16 v5; // ax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      BYTE1(v3) = 127;
    }
    else if ( v3 < -32768 )
    {
      BYTE1(v3) = -128;
    }
    if ( v4 > 0x7FFF )
    {
      BYTE1(v4) = 127;
    }
    else if ( v4 < -32768 )
    {
      BYTE1(v4) = -128;
    }
    HIBYTE(v5) = BYTE1(v3) ^ 0x80;
    LOBYTE(v5) = BYTE1(v4) ^ 0x80;
    *a2 = v5;
    ++a2;
    --a1;
  }
  while ( a1 );
  return v5;
}

//----- (000AF3A8) --------------------------------------------------------
char __usercall sub_AF3A8@<al>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int v3; // eax
  signed int v4; // edx

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      BYTE1(v3) = 127;
    }
    else if ( v3 < -32768 )
    {
      BYTE1(v3) = -128;
    }
    if ( v4 > 0x7FFF )
    {
      BYTE1(v4) = 127;
    }
    else if ( v4 < -32768 )
    {
      BYTE1(v4) = -128;
    }
    LOBYTE(v3) = BYTE1(v4);
    *a2 = v3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return v3;
}

//----- (000AF3F6) --------------------------------------------------------
int __usercall sub_AF3F6@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, signed int *a4@<esi>)
{
  signed int v4; // eax
  signed int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      v4 = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      BYTE1(v5) = 127;
    }
    else if ( v5 < -32768 )
    {
      BYTE1(v5) = -128;
    }
    result = v4 ^ 0x8000;
    *a3 = BYTE1(result);
    *a2 = BYTE1(v5) ^ 0x80;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF44D) --------------------------------------------------------
signed int __usercall sub_AF44D@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, signed int *a4@<esi>)
{
  signed int result; // eax
  signed int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      BYTE1(v5) = 127;
    }
    else if ( v5 < -32768 )
    {
      BYTE1(v5) = -128;
    }
    *a3 = BYTE1(result);
    *a2 = BYTE1(v5);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF499) --------------------------------------------------------
int __usercall sub_AF499@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, signed int *a4@<esi>)
{
  signed int v4; // eax
  signed int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      v4 = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      BYTE1(v5) = 127;
    }
    else if ( v5 < -32768 )
    {
      BYTE1(v5) = -128;
    }
    result = v4 ^ 0x8000;
    *a3 = BYTE1(v5) ^ 0x80;
    *a2 = BYTE1(result);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF4F0) --------------------------------------------------------
signed int __usercall sub_AF4F0@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, signed int *a4@<esi>)
{
  signed int result; // eax
  signed int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      BYTE1(v5) = 127;
    }
    else if ( v5 < -32768 )
    {
      BYTE1(v5) = -128;
    }
    *a3 = BYTE1(v5);
    *a2 = BYTE1(result);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF53C) --------------------------------------------------------
int __usercall sub_AF53C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int v3; // eax
  int result; // eax

  do
  {
    v3 = *a3;
    ++a3;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      v3 = -32768;
    }
    result = v3 ^ 0x8000;
    *a2 = result;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF56C) --------------------------------------------------------
signed int __usercall sub_AF56C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int result; // eax

  do
  {
    result = *a3;
    ++a3;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    *a2 = result;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF597) --------------------------------------------------------
__int16 __usercall sub_AF597@<ax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int v3; // eax
  __int16 v4; // ax
  __int16 result; // ax
  char v6; // t0

  do
  {
    v3 = *a3;
    ++a3;
    if ( v3 > 0x7FFF )
    {
      LOWORD(v3) = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      LOWORD(v3) = -32768;
    }
    v4 = v3 ^ 0x8000;
    v6 = v4;
    LOBYTE(result) = HIBYTE(v4);
    HIBYTE(result) = v6;
    *a2 = result;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF5C9) --------------------------------------------------------
__int16 __usercall sub_AF5C9@<ax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int v3; // eax
  __int16 result; // ax
  char v5; // t0

  do
  {
    v3 = *a3;
    ++a3;
    if ( v3 > 0x7FFF )
    {
      LOWORD(v3) = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      LOWORD(v3) = -32768;
    }
    v5 = v3;
    LOBYTE(result) = BYTE1(v3);
    HIBYTE(result) = v5;
    *a2 = result;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF5F6) --------------------------------------------------------
int __usercall sub_AF5F6@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int v3; // eax
  signed int v4; // edx
  int result; // eax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      v3 = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = -32768;
    }
    result = v3 ^ 0x8000;
    *a2 = result;
    a2[1] = v4 ^ 0x8000;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF651) --------------------------------------------------------
signed int __usercall sub_AF651@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int result; // eax
  signed int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = -32768;
    }
    *a2 = result;
    a2[1] = v4;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF6A1) --------------------------------------------------------
int __usercall sub_AF6A1@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int v3; // eax
  signed int v4; // edx
  int result; // eax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      v3 = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = -32768;
    }
    result = v3 ^ 0x8000;
    *a2 = v4 ^ 0x8000;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF6FC) --------------------------------------------------------
signed int __usercall sub_AF6FC@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int result; // eax
  signed int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = -32768;
    }
    *a2 = v4;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF74C) --------------------------------------------------------
int __usercall sub_AF74C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int v3; // eax
  signed int v4; // edx
  __int16 v5; // dx
  int result; // eax
  char v7; // t0
  char v8; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      v3 = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = -32768;
    }
    result = v3 ^ 0x8000;
    v5 = v4 ^ 0x8000;
    v7 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v7;
    v8 = v5;
    LOBYTE(v5) = HIBYTE(v5);
    HIBYTE(v5) = v8;
    *a2 = result;
    a2[1] = v5;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF7AB) --------------------------------------------------------
__int16 __usercall sub_AF7AB@<ax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int v3; // eax
  signed int v4; // edx
  __int16 result; // ax
  char v6; // t0
  __int16 v7; // dx
  char v8; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      LOWORD(v3) = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      LOWORD(v3) = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = -32768;
    }
    v6 = v3;
    LOBYTE(result) = BYTE1(v3);
    HIBYTE(result) = v6;
    v8 = v4;
    LOBYTE(v7) = BYTE1(v4);
    HIBYTE(v7) = v8;
    *a2 = result;
    a2[1] = v7;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF7FF) --------------------------------------------------------
int __usercall sub_AF7FF@<eax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int v3; // eax
  signed int v4; // edx
  __int16 v5; // dx
  int result; // eax
  char v7; // t0
  char v8; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      v3 = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = -32768;
    }
    result = v3 ^ 0x8000;
    v5 = v4 ^ 0x8000;
    v7 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v7;
    v8 = v5;
    LOBYTE(v5) = HIBYTE(v5);
    HIBYTE(v5) = v8;
    *a2 = v5;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF85E) --------------------------------------------------------
__int16 __usercall sub_AF85E@<ax>(int a1@<ecx>, _WORD *a2@<edi>, signed int *a3@<esi>)
{
  signed int v3; // eax
  signed int v4; // edx
  __int16 result; // ax
  char v6; // t0
  __int16 v7; // dx
  char v8; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      LOWORD(v3) = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      LOWORD(v3) = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = -32768;
    }
    v6 = v3;
    LOBYTE(result) = BYTE1(v3);
    HIBYTE(result) = v6;
    v8 = v4;
    LOBYTE(v7) = BYTE1(v4);
    HIBYTE(v7) = v8;
    *a2 = v7;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF8B2) --------------------------------------------------------
int __usercall sub_AF8B2@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>)
{
  signed int v4; // eax
  signed int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      v4 = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = -32768;
    }
    result = v4 ^ 0x8000;
    *a3 = result;
    *a2 = v5 ^ 0x8000;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF90F) --------------------------------------------------------
signed int __usercall sub_AF90F@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>)
{
  signed int result; // eax
  signed int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = -32768;
    }
    *a3 = result;
    *a2 = v5;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF961) --------------------------------------------------------
int __usercall sub_AF961@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>)
{
  signed int v4; // eax
  signed int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      v4 = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = -32768;
    }
    result = v4 ^ 0x8000;
    *a3 = v5 ^ 0x8000;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF9BE) --------------------------------------------------------
signed int __usercall sub_AF9BE@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>)
{
  signed int result; // eax
  signed int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = -32768;
    }
    *a3 = v5;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AFA10) --------------------------------------------------------
int __usercall sub_AFA10@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>)
{
  signed int v4; // eax
  signed int v5; // edx
  __int16 v6; // dx
  int result; // eax
  char v8; // t0
  char v9; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      v4 = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = -32768;
    }
    result = v4 ^ 0x8000;
    v6 = v5 ^ 0x8000;
    v8 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v8;
    v9 = v6;
    LOBYTE(v6) = HIBYTE(v6);
    HIBYTE(v6) = v9;
    *a3 = result;
    *a2 = v6;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AFA71) --------------------------------------------------------
__int16 __usercall sub_AFA71@<ax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>)
{
  signed int v4; // eax
  signed int v5; // edx
  __int16 result; // ax
  char v7; // t0
  __int16 v8; // dx
  char v9; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = -32768;
    }
    v7 = v4;
    LOBYTE(result) = BYTE1(v4);
    HIBYTE(result) = v7;
    v9 = v5;
    LOBYTE(v8) = BYTE1(v5);
    HIBYTE(v8) = v9;
    *a3 = result;
    *a2 = v8;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AFAC7) --------------------------------------------------------
int __usercall sub_AFAC7@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>)
{
  signed int v4; // eax
  signed int v5; // edx
  __int16 v6; // dx
  int result; // eax
  char v8; // t0
  char v9; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      v4 = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = -32768;
    }
    result = v4 ^ 0x8000;
    v6 = v5 ^ 0x8000;
    v8 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v8;
    v9 = v6;
    LOBYTE(v6) = HIBYTE(v6);
    HIBYTE(v6) = v9;
    *a3 = v6;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AFB28) --------------------------------------------------------
__int16 __usercall sub_AFB28@<ax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, signed int *a4@<esi>)
{
  signed int v4; // eax
  signed int v5; // edx
  __int16 result; // ax
  char v7; // t0
  __int16 v8; // dx
  char v9; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = -32768;
    }
    v7 = v4;
    LOBYTE(result) = BYTE1(v4);
    HIBYTE(result) = v7;
    v9 = v5;
    LOBYTE(v8) = BYTE1(v5);
    HIBYTE(v8) = v9;
    *a3 = v8;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AFB7E) --------------------------------------------------------
int __usercall sub_AFB7E@<eax>(int result@<eax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>)
{
  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    BYTE1(result) = *a3;
    result ^= 0x8000u;
    ++a3;
    *a2 += (signed __int16)result;
    ++a2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFB9F) --------------------------------------------------------
int __usercall sub_AFB9F@<eax>(int result@<eax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>)
{
  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    BYTE1(result) = *a3;
    result ^= 0x8000u;
    ++a3;
    *a2 += (signed __int16)result;
    a2[1] += (signed __int16)result;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFBC3) --------------------------------------------------------
int __usercall sub_AFBC3@<eax>(int result@<eax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    BYTE1(result) = *a4;
    HIBYTE(a2) = a4[1];
    result ^= 0x8000u;
    a2 ^= 0x8000u;
    a4 += 2;
    *a3 += (signed __int16)result;
    a3[1] += a2;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFBF5) --------------------------------------------------------
int __usercall sub_AFBF5@<eax>(int result@<eax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    HIBYTE(a2) = *a4;
    BYTE1(result) = a4[1];
    result ^= 0x8000u;
    a2 ^= 0x8000u;
    a4 += 2;
    *a3 += (signed __int16)result;
    a3[1] += a2;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFC27) --------------------------------------------------------
__int16 __usercall sub_AFC27@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    result = *a2 ^ 0x8000;
    ++a2;
    *a1 += result;
    ++a1;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFC4B) --------------------------------------------------------
__int16 __usercall sub_AFC4B@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    result = *a2 ^ 0x8000;
    ++a2;
    *a1 += result;
    a1[1] += result;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFC72) --------------------------------------------------------
__int16 __usercall sub_AFC72@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>)
{
  __int16 result; // ax
  __int16 v3; // bx

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    result = *a2 ^ 0x8000;
    v3 = a2[1] ^ 0x8000;
    a2 += 2;
    *a1 += result;
    a1[1] += v3;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFCA6) --------------------------------------------------------
__int16 __usercall sub_AFCA6@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>)
{
  __int16 result; // ax
  __int16 v3; // bx

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    result = a2[1] ^ 0x8000;
    v3 = *a2 ^ 0x8000;
    a2 += 2;
    *a1 += result;
    a1[1] += v3;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFCDA) --------------------------------------------------------
__int16 __usercall sub_AFCDA@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>)
{
  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    HIBYTE(result) = *a3++;
    *a2 += result;
    ++a2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFCF6) --------------------------------------------------------
__int16 __usercall sub_AFCF6@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>)
{
  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    HIBYTE(result) = *a3++;
    *a2 += result;
    a2[1] += result;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFD15) --------------------------------------------------------
__int16 __usercall sub_AFD15@<ax>(__int16 result@<ax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    HIBYTE(result) = *a4;
    HIBYTE(a2) = a4[1];
    a4 += 2;
    *a3 += result;
    a3[1] += a2;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFD3C) --------------------------------------------------------
__int16 __usercall sub_AFD3C@<ax>(__int16 result@<ax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    HIBYTE(a2) = *a4;
    HIBYTE(result) = a4[1];
    a4 += 2;
    *a3 += result;
    a3[1] += a2;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFD63) --------------------------------------------------------
__int16 __usercall sub_AFD63@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    result = *a2;
    ++a2;
    *a1 += result;
    ++a1;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFD82) --------------------------------------------------------
__int16 __usercall sub_AFD82@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    result = *a2;
    ++a2;
    *a1 += result;
    a1[1] += result;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFDA4) --------------------------------------------------------
__int16 __usercall sub_AFDA4@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>)
{
  __int16 result; // ax
  __int16 v3; // bx

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    result = *a2;
    v3 = a2[1];
    a2 += 2;
    *a1 += result;
    a1[1] += v3;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFDCD) --------------------------------------------------------
__int16 __usercall sub_AFDCD@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>)
{
  __int16 v2; // bx
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    v2 = *a2;
    result = a2[1];
    a2 += 2;
    *a1 += result;
    a1[1] += v2;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFDF6) --------------------------------------------------------
int __usercall sub_AFDF6@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    BYTE1(result) = *a4;
    result ^= 0x8000u;
    a4 = (_BYTE *)((qword_E4E30 + __PAIR__((unsigned int)a4, a2)) >> 32);
    a2 += qword_E4E30;
    *a3 += (signed __int16)result;
    ++a3;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFE22) --------------------------------------------------------
int __usercall sub_AFE22@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    BYTE1(result) = *a4;
    result ^= 0x8000u;
    a4 = (_BYTE *)((qword_E4E30 + __PAIR__((unsigned int)a4, a2)) >> 32);
    a2 += qword_E4E30;
    *a3 += (signed __int16)result;
    a3[1] += (signed __int16)result;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFE51) --------------------------------------------------------
int __usercall sub_AFE51@<eax>(int result@<eax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    BYTE1(result) = *a5;
    HIBYTE(a3) = a5[1];
    result ^= 0x8000u;
    a3 ^= 0x8000u;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a5 += *((_DWORD *)&qword_E4E30 + v5 + 1);
    *a4 += (signed __int16)result;
    a4[1] += a3;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFE91) --------------------------------------------------------
int __usercall sub_AFE91@<eax>(int result@<eax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    HIBYTE(a3) = *a5;
    BYTE1(result) = a5[1];
    result ^= 0x8000u;
    a3 ^= 0x8000u;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a5 += *((_DWORD *)&qword_E4E30 + v5 + 1);
    *a4 += (signed __int16)result;
    a4[1] += a3;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFED1) --------------------------------------------------------
__int16 __usercall sub_AFED1@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3 ^ 0x8000;
    v4 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (_WORD *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v4 + 1));
    *a2 += result;
    ++a2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFF03) --------------------------------------------------------
__int16 __usercall sub_AFF03@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3 ^ 0x8000;
    v4 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (_WORD *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v4 + 1));
    *a2 += result;
    a2[1] += result;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFF38) --------------------------------------------------------
__int16 __usercall sub_AFF38@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>)
{
  __int16 result; // ax
  __int16 v4; // bx
  int v5; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3 ^ 0x8000;
    v4 = a3[1] ^ 0x8000;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (_WORD *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a2 += result;
    a2[1] += v4;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFF7A) --------------------------------------------------------
__int16 __usercall sub_AFF7A@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>)
{
  __int16 result; // ax
  __int16 v4; // bx
  int v5; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = a3[1] ^ 0x8000;
    v4 = *a3 ^ 0x8000;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (_WORD *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a2 += result;
    a2[1] += v4;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFFBC) --------------------------------------------------------
__int16 __usercall sub_AFFBC@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    HIBYTE(result) = *a4;
    a4 = (_BYTE *)((qword_E4E30 + __PAIR__((unsigned int)a4, a2)) >> 32);
    a2 += qword_E4E30;
    *a3 += result;
    ++a3;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFFE3) --------------------------------------------------------
__int16 __usercall sub_AFFE3@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    HIBYTE(result) = *a4;
    a4 = (_BYTE *)((qword_E4E30 + __PAIR__((unsigned int)a4, a2)) >> 32);
    a2 += qword_E4E30;
    *a3 += result;
    a3[1] += result;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B000D) --------------------------------------------------------
__int16 __usercall sub_B000D@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    HIBYTE(result) = *a5;
    HIBYTE(a3) = a5[1];
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a5 += *((_DWORD *)&qword_E4E30 + v5 + 1);
    *a4 += result;
    a4[1] += a3;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0042) --------------------------------------------------------
__int16 __usercall sub_B0042@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    HIBYTE(a3) = *a5;
    HIBYTE(result) = a5[1];
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a5 += *((_DWORD *)&qword_E4E30 + v5 + 1);
    *a4 += result;
    a4[1] += a3;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0077) --------------------------------------------------------
__int16 __usercall sub_B0077@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3;
    v4 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (__int16 *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v4 + 1));
    *a2 += result;
    ++a2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B00A4) --------------------------------------------------------
__int16 __usercall sub_B00A4@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3;
    v4 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (__int16 *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v4 + 1));
    *a2 += result;
    a2[1] += result;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B00D4) --------------------------------------------------------
__int16 __usercall sub_B00D4@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax
  __int16 v4; // bx
  int v5; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3;
    v4 = a3[1];
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (__int16 *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a2 += result;
    a2[1] += v4;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B010B) --------------------------------------------------------
__int16 __usercall sub_B010B@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 v3; // bx
  __int16 result; // ax
  int v5; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    v3 = *a3;
    result = a3[1];
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (__int16 *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a2 += result;
    a2[1] += v3;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0142) --------------------------------------------------------
char __usercall sub_B0142@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a4++;
    *a3 += *(_DWORD *)(a2 + 4 * a1);
    ++a3;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B015E) --------------------------------------------------------
char __usercall sub_B015E@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a4++;
    *a3 += *(_DWORD *)(a2 + 4 * a1);
    a3[1] += *(_DWORD *)(a2 + 4 * a1 + 1024);
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B0184) --------------------------------------------------------
char __usercall sub_B0184@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a5;
    LOBYTE(a3) = a5[1];
    a5 += 2;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    *a4 += *(_DWORD *)(a2 + 4 * a3 + 1024);
    ++a4;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B01AE) --------------------------------------------------------
char __usercall sub_B01AE@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a5;
    LOBYTE(a3) = a5[1];
    a5 += 2;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    a4[1] += *(_DWORD *)(a2 + 4 * a3 + 1024);
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B01D9) --------------------------------------------------------
char __usercall sub_B01D9@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOBYTE(a3) = *a5;
    LOBYTE(a1) = a5[1];
    a5 += 2;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    *a4 += *(_DWORD *)(a2 + 4 * a3 + 1024);
    ++a4;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B0203) --------------------------------------------------------
char __usercall sub_B0203@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOBYTE(a3) = *a5;
    LOBYTE(a1) = a5[1];
    a5 += 2;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    a4[1] += *(_DWORD *)(a2 + 4 * a3 + 1024);
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B022E) --------------------------------------------------------
int __usercall sub_B022E@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOWORD(result) = *a4;
    result ^= 0x8000u;
    ++a4;
    *a3 += *a2 * (signed int)(signed __int16)result >> 7;
    ++a3;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B0258) --------------------------------------------------------
int __usercall sub_B0258@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOWORD(result) = *a4;
    result ^= 0x8000u;
    ++a4;
    *a3 += *a2 * (signed int)(signed __int16)result >> 7;
    a3[1] += a2[256] * (signed int)(signed __int16)result >> 7;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B0292) --------------------------------------------------------
int __usercall sub_B0292@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>)
{
  __int16 v4; // bx

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOWORD(result) = *a4;
    result ^= 0x8000u;
    v4 = a4[1] ^ 0x8000;
    a4 += 2;
    *a3 += *a2 * (signed int)(signed __int16)result >> 7;
    *a3 += a2[256] * (signed int)v4 >> 7;
    ++a3;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B02D5) --------------------------------------------------------
int __usercall sub_B02D5@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>)
{
  __int16 v4; // bx

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOWORD(result) = *a4;
    result ^= 0x8000u;
    v4 = a4[1] ^ 0x8000;
    a4 += 2;
    *a3 += *a2 * (signed int)(signed __int16)result >> 7;
    a3[1] += a2[256] * (signed int)v4 >> 7;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B0319) --------------------------------------------------------
int __usercall sub_B0319@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>)
{
  __int16 v4; // bx

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOWORD(result) = a4[1];
    result ^= 0x8000u;
    v4 = *a4 ^ 0x8000;
    a4 += 2;
    *a3 += *a2 * (signed int)(signed __int16)result >> 7;
    *a3 += a2[256] * (signed int)v4 >> 7;
    ++a3;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B035C) --------------------------------------------------------
int __usercall sub_B035C@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>)
{
  __int16 v4; // bx

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOWORD(result) = a4[1];
    result ^= 0x8000u;
    v4 = *a4 ^ 0x8000;
    a4 += 2;
    *a3 += *a2 * (signed int)(signed __int16)result >> 7;
    a3[1] += a2[256] * (signed int)v4 >> 7;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B03A0) --------------------------------------------------------
__int16 __usercall sub_B03A0@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3;
    ++a3;
    *a2 += *a1 * (signed int)result >> 7;
    ++a2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B03C5) --------------------------------------------------------
__int16 __usercall sub_B03C5@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3;
    ++a3;
    *a2 += *a1 * (signed int)result >> 7;
    a2[1] += a1[256] * (signed int)result >> 7;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B03FA) --------------------------------------------------------
__int16 __usercall sub_B03FA@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax
  __int16 v4; // bx

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    *a2 += *a1 * (signed int)result >> 7;
    *a2 += a1[256] * (signed int)v4 >> 7;
    ++a2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B0432) --------------------------------------------------------
__int16 __usercall sub_B0432@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax
  __int16 v4; // bx

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    *a2 += *a1 * (signed int)result >> 7;
    a2[1] += a1[256] * (signed int)v4 >> 7;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B046B) --------------------------------------------------------
__int16 __usercall sub_B046B@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 v3; // bx
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    v3 = *a3;
    result = a3[1];
    a3 += 2;
    *a2 += *a1 * (signed int)result >> 7;
    *a2 += a1[256] * (signed int)v3 >> 7;
    ++a2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B04A3) --------------------------------------------------------
__int16 __usercall sub_B04A3@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 v3; // bx
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    v3 = *a3;
    result = a3[1];
    a3 += 2;
    *a2 += *a1 * (signed int)result >> 7;
    a2[1] += a1[256] * (signed int)v3 >> 7;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B04DC) --------------------------------------------------------
char __usercall sub_B04DC@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a5;
    a5 = (_BYTE *)((qword_E4E30 + __PAIR__((unsigned int)a5, a3)) >> 32);
    a3 += qword_E4E30;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    ++a4;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0503) --------------------------------------------------------
char __usercall sub_B0503@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a5;
    a5 = (_BYTE *)((qword_E4E30 + __PAIR__((unsigned int)a5, a3)) >> 32);
    a3 += qword_E4E30;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    a4[1] += *(_DWORD *)(a2 + 4 * a1 + 1024);
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0534) --------------------------------------------------------
char __usercall sub_B0534@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, _BYTE *a6@<esi>)
{
  int v6; // ebp

  do
  {
    if ( (unsigned int)a6 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a6;
    LOBYTE(a4) = a6[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a6 += *((_DWORD *)&qword_E4E30 + v6 + 1);
    *a5 += *(_DWORD *)(a2 + 4 * a1);
    *a5 += *(_DWORD *)(a2 + 4 * a4 + 1024);
    ++a5;
  }
  while ( (unsigned int)a5 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B056C) --------------------------------------------------------
char __usercall sub_B056C@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, _BYTE *a6@<esi>)
{
  int v6; // ebp

  do
  {
    if ( (unsigned int)a6 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a6;
    LOBYTE(a4) = a6[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a6 += *((_DWORD *)&qword_E4E30 + v6 + 1);
    *a5 += *(_DWORD *)(a2 + 4 * a1);
    a5[1] += *(_DWORD *)(a2 + 4 * a4 + 1024);
    a5 += 2;
  }
  while ( (unsigned int)a5 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B05A5) --------------------------------------------------------
char __usercall sub_B05A5@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, _BYTE *a6@<esi>)
{
  int v6; // ebp

  do
  {
    if ( (unsigned int)a6 >= dword_E4E24 )
      break;
    LOBYTE(a4) = *a6;
    LOBYTE(a1) = a6[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a6 += *((_DWORD *)&qword_E4E30 + v6 + 1);
    *a5 += *(_DWORD *)(a2 + 4 * a1);
    *a5 += *(_DWORD *)(a2 + 4 * a4 + 1024);
    ++a5;
  }
  while ( (unsigned int)a5 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B05DD) --------------------------------------------------------
char __usercall sub_B05DD@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, _BYTE *a6@<esi>)
{
  int v6; // ebp

  do
  {
    if ( (unsigned int)a6 >= dword_E4E24 )
      break;
    LOBYTE(a4) = *a6;
    LOBYTE(a1) = a6[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a6 += *((_DWORD *)&qword_E4E30 + v6 + 1);
    *a5 += *(_DWORD *)(a2 + 4 * a1);
    a5[1] += *(_DWORD *)(a2 + 4 * a4 + 1024);
    a5 += 2;
  }
  while ( (unsigned int)a5 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0616) --------------------------------------------------------
int __usercall sub_B0616@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOWORD(result) = *a5;
    result ^= 0x8000u;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a5 = (_WORD *)((char *)a5 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a4 += *a2 * (signed int)(signed __int16)result >> 7;
    ++a4;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B064E) --------------------------------------------------------
int __usercall sub_B064E@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOWORD(result) = *a5;
    result ^= 0x8000u;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a5 = (_WORD *)((char *)a5 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a4 += *a2 * (signed int)(signed __int16)result >> 7;
    a4[1] += a2[256] * (signed int)(signed __int16)result >> 7;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0696) --------------------------------------------------------
int __usercall sub_B0696@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>)
{
  __int16 v5; // bx
  int v6; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOWORD(result) = *a5;
    result ^= 0x8000u;
    v5 = a5[1] ^ 0x8000;
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a5 = (_WORD *)((char *)a5 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a4 += *a2 * (signed int)(signed __int16)result >> 7;
    *a4 += a2[256] * (signed int)v5 >> 7;
    ++a4;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B06E7) --------------------------------------------------------
int __usercall sub_B06E7@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>)
{
  __int16 v5; // bx
  int v6; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOWORD(result) = *a5;
    result ^= 0x8000u;
    v5 = a5[1] ^ 0x8000;
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a5 = (_WORD *)((char *)a5 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a4 += *a2 * (signed int)(signed __int16)result >> 7;
    a4[1] += a2[256] * (signed int)v5 >> 7;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0739) --------------------------------------------------------
int __usercall sub_B0739@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>)
{
  __int16 v5; // bx
  int v6; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOWORD(result) = a5[1];
    result ^= 0x8000u;
    v5 = *a5 ^ 0x8000;
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a5 = (_WORD *)((char *)a5 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a4 += *a2 * (signed int)(signed __int16)result >> 7;
    *a4 += a2[256] * (signed int)v5 >> 7;
    ++a4;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B078A) --------------------------------------------------------
int __usercall sub_B078A@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>)
{
  __int16 v5; // bx
  int v6; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOWORD(result) = a5[1];
    result ^= 0x8000u;
    v5 = *a5 ^ 0x8000;
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a5 = (_WORD *)((char *)a5 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a4 += *a2 * (signed int)(signed __int16)result >> 7;
    a4[1] += a2[256] * (signed int)v5 >> 7;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B07DC) --------------------------------------------------------
__int16 __usercall sub_B07DC@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>)
{
  __int16 result; // ax
  int v5; // ebp

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    result = *a4;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a4 = (__int16 *)((char *)a4 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a3 += *a1 * (signed int)result >> 7;
    ++a3;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B080F) --------------------------------------------------------
__int16 __usercall sub_B080F@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>)
{
  __int16 result; // ax
  int v5; // ebp

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    result = *a4;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a4 = (__int16 *)((char *)a4 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a3 += *a1 * (signed int)result >> 7;
    a3[1] += a1[256] * (signed int)result >> 7;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0852) --------------------------------------------------------
__int16 __usercall sub_B0852@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>)
{
  __int16 result; // ax
  __int16 v5; // bx
  int v6; // ebp

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    result = *a4;
    v5 = a4[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a4 = (__int16 *)((char *)a4 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a3 += *a1 * (signed int)result >> 7;
    *a3 += a1[256] * (signed int)v5 >> 7;
    ++a3;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0898) --------------------------------------------------------
__int16 __usercall sub_B0898@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>)
{
  __int16 result; // ax
  __int16 v5; // bx
  int v6; // ebp

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    result = *a4;
    v5 = a4[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a4 = (__int16 *)((char *)a4 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a3 += *a1 * (signed int)result >> 7;
    a3[1] += a1[256] * (signed int)v5 >> 7;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B08DF) --------------------------------------------------------
__int16 __usercall sub_B08DF@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>)
{
  __int16 v4; // bx
  __int16 result; // ax
  int v6; // ebp

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    v4 = *a4;
    result = a4[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a4 = (__int16 *)((char *)a4 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a3 += *a1 * (signed int)result >> 7;
    *a3 += a1[256] * (signed int)v4 >> 7;
    ++a3;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0925) --------------------------------------------------------
__int16 __usercall sub_B0925@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>)
{
  __int16 v4; // bx
  __int16 result; // ax
  int v6; // ebp

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    v4 = *a4;
    result = a4[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a4 = (__int16 *)((char *)a4 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a3 += *a1 * (signed int)result >> 7;
    a3[1] += a1[256] * (signed int)v4 >> 7;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B096C) --------------------------------------------------------
int __cdecl sub_B096C(int *a1)
{
  int *v1; // ebp
  int *v2; // ecx
  _DWORD *v3; // edi
  signed int v4; // eax
  unsigned __int64 v5; // rax
  signed int v6; // eax
  char *v7; // edx
  unsigned int v8; // eax
  int v9; // ebx
  _DWORD *v10; // edi
  int v11; // ebx
  unsigned int v12; // esi
  int v13; // ebx
  int result; // eax
  int v15; // ebx
  int *v16; // [esp-Ch] [ebp-18h]
  int v17; // [esp-8h] [ebp-14h]
  int v18; // [esp-4h] [ebp-10h]
  int savedregs; // [esp+Ch] [ebp+0h]

  v1 = &savedregs;
  v18 = (unsigned __int16)__DS__;
  v17 = (unsigned __int16)__ES__;
  v2 = a1;
  v3 = (_DWORD *)*a1;
  v4 = 0;
  if ( *(_DWORD *)(*a1 + 24) == 2 || v3[6] == 3 )
    v4 = 1;
  if ( a1[13] == 2 || a1[13] == 3 )
  {
    v4 |= 2u;
    if ( a1[14] & 2 )
      v4 |= 4u;
  }
  if ( a1[13] == 1 || a1[13] == 3 )
    v4 |= 8u;
  if ( (!(v4 & 2) || v4 & 1) && a1[16] == 127 && v3[26] == 127 && a1[17] == 64 || (v4 |= 0x40u, v4 & 8) )
  {
    if ( a1[14] & 1 )
      v4 |= 0x10u;
  }
  dword_E4E1C = v4;
  LODWORD(v5) = 0;
  HIDWORD(v5) = a1[15];
  if ( SHIDWORD(v5) <= 0 )
    HIDWORD(v5) = 1;
  v6 = v5 / (unsigned int)(v3[5] << 16);
  v7 = (char *)(v6 - (_DWORD)sub_10000);
  if ( v6 <= (signed int)sub_10000 )
    v7 = (char *)sub_10000 - v6;
  if ( (unsigned int)v7 > dword_181DC4 )
  {
    LODWORD(qword_E4E30) = v6 << 16;
    v8 = (unsigned int)v6 >> 16;
    v9 = v8 + 1;
    if ( dword_E4E1C & 2 )
    {
      v8 *= 2;
      v9 *= 2;
    }
    if ( dword_E4E1C & 8 )
    {
      v8 *= 2;
      v9 *= 2;
    }
    HIDWORD(qword_E4E30) = v8;
    dword_E4E38 = v9;
    dword_E4E1C |= 0x20u;
  }
  dword_E4E28 = v3[20];
  dword_E4E2C = v3[19] + dword_E4E28;
  v10 = (_DWORD *)dword_E4E28;
  do
  {
    v11 = v2[10];
    dword_E4E20 = v2[v11 + 6] + v2[v11 + 2];
    dword_E4E24 = v2[v11 + 4] + v2[v11 + 2];
    if ( v2[530] )
    {
      v16 = v2;
      ((void (__stdcall *)(int *))v2[530])(v2);
    }
    v12 = dword_E4E20;
    v16 = v1;
    ((void (__usercall *)(int@<eax>, _DWORD *@<edi>, _BYTE *@<esi>))off_AED40[dword_E4E1C])(
      0,
      v10,
      (_BYTE *)dword_E4E20);
    v1 = v16;
    v2 = (int *)v16[2];
    v13 = v2[10];
    result = v12 - v2[v13 + 2];
    v2[v13 + 6] = result;
    if ( v12 < dword_E4E24 )
      break;
    if ( v2[531] )
    {
      v16 = v2;
      result = ((int (__stdcall *)(int *))v2[531])(v2);
      v2 = v16;
    }
    if ( v2[12] )
    {
      if ( v2[12] == 1 )
      {
        v15 = v2[10] ^ 1;
        if ( v2[v15 + 8] )
        {
          v2[1] = 2;
          if ( v2[532] )
          {
            v16 = v2;
            result = ((int (__stdcall *)(int *))v2[532])(v2);
          }
          return result;
        }
        if ( !v2[v15 + 4] || v2[v15 + 6] )
          return result;
        v2[10] = v15;
      }
      else
      {
        --v2[12];
      }
    }
    v2[v2[10] + 6] = 0;
  }
  while ( (unsigned int)v10 < dword_E4E2C );
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// AED40: using guessed type int (*off_AED40[2])();
// E4E1C: using guessed type int dword_E4E1C;
// E4E20: using guessed type int dword_E4E20;
// E4E24: using guessed type int dword_E4E24;
// E4E28: using guessed type int dword_E4E28;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;
// E4E38: using guessed type int dword_E4E38;
// 181DC4: using guessed type int dword_181DC4;

//----- (000B0B87) --------------------------------------------------------
int __cdecl sub_B0B87(_DWORD *a1, int a2)
{
  int v2; // eax
  int *v3; // esi
  int v4; // ecx
  _BYTE *v5; // edi
  int v6; // eax

  v2 = a1[7] & 0xF;
  if ( a1[6] == 2 || a1[6] == 3 )
    v2 |= 0x10u;
  if ( a1[6] == 1 || a1[6] == 3 )
    v2 |= 0x20u;
  if ( a1[25] > 1u )
    v2 |= 0x40u;
  dword_E4E1C = v2;
  v3 = (int *)a1[20];
  v4 = a1[18];
  if ( a1[7] & 0x20 )
  {
    dword_E4E1C |= 8u;
    v5 = (_BYTE *)(a2 * (a1[4] >> 1) + a1[11]);
  }
  else
  {
    v5 = (_BYTE *)a1[a2 + 11];
    if ( a1[7] & 8 )
      v6 = a1[4];
  }
  return ((int (__usercall *)@<eax>(int@<ecx>, _BYTE *@<edi>, int *@<esi>))off_AEB40[dword_E4E1C])(v4, v5, v3);
}
// AEB40: using guessed type int (*off_AEB40[2])();
// E4E1C: using guessed type int dword_E4E1C;

//----- (000B0C1A) --------------------------------------------------------
int __cdecl sub_B0C1A(int a1)
{
  char *v1; // edi
  int result; // eax
  unsigned int v3; // ST00_4

  v1 = *(char **)(a1 + 80);
  result = 0;
  v3 = *(_DWORD *)(a1 + 76);
  memset(v1, 0, *(_DWORD *)(a1 + 76) & 3);
  memset(&v1[v3 & 3], 0, 4 * (v3 >> 2));
  return result;
}

//----- (000B0C46) --------------------------------------------------------
bool sub_B0C46()
{
  sub_9D590((unsigned int)&dword_E4E1C, (unsigned int)&word_E4E3C);
  return sub_9D590((unsigned int)off_AEB40, (unsigned int)sub_B0C46);
}
// AEB40: using guessed type int (*off_AEB40[2])();
// E4E1C: using guessed type int dword_E4E1C;
// E4E3C: using guessed type __int16 word_E4E3C;

//----- (000B0CC8) --------------------------------------------------------
char *sub_B0CC8()
{
  void *retaddr; // [esp+0h] [ebp+0h]

  return (char *)&retaddr - dword_E4C94;
}
// E4C94: using guessed type int dword_E4C94;

//----- (000B0CD2) --------------------------------------------------------
void sub_B0CD2()
{
  word_E4E3C = __SS__;
}
// E4E3C: using guessed type __int16 word_E4E3C;

//----- (000B0D52) --------------------------------------------------------
void sub_B0D52()
{
  JUMPOUT(off_E3B90, sub_B4FA3, sub_B5000);
  off_E4CBD = (int (__fastcall *)(_DWORD))_sigfpe_handler;
  sub_B4F46();
  off_E3B90 = (int (*)())sub_B4FA3;
  sub_B5000();
}
// 98D8B: using guessed type int _sigfpe_handler();
// E3B90: using guessed type int (*off_E3B90)();
// E4CBD: using guessed type int (__fastcall *off_E4CBD)(_DWORD);

//----- (000B0D80) --------------------------------------------------------
void sub_B0D80()
{
  dword_E731C = 0x8000;
}
// E731C: using guessed type int dword_E731C;

//----- (000B1138) --------------------------------------------------------
signed int __cdecl sub_B1138(signed int *a1, signed int a2)
{
  signed int result; // eax
  signed int v3; // eax
  int v4; // edx
  signed int v5; // eax

  result = calloc(a2, 4);
  *a1 = result;
  if ( result )
  {
    result = calloc(a2, 4);
    a1[1] = result;
    if ( result )
    {
      a1[2] = a2;
      v3 = 0;
      if ( a1[2] > 0 )
      {
        v4 = 0;
        do
        {
          *(_DWORD *)(*a1 + v4) = 0x4000;
          ++v3;
          v4 += 4;
        }
        while ( v3 < a1[2] );
      }
      a1[3] = *a1;
      v5 = *a1;
      a1[4] = 4 * (a1[2] - 1) + *a1;
      a1[5] = v5 - 4;
      result = 1;
    }
  }
  return result;
}
// 9B513: using guessed type _DWORD __cdecl calloc(_DWORD, _DWORD);

//----- (000B11E8) --------------------------------------------------------
int __cdecl sub_B11E8(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  int v4; // edx
  _DWORD *v5; // ecx

  v2 = (_DWORD *)a1[3];
  v3 = v2;
  a1[3] = v2 + 1;
  *v2 = a2;
  if ( *a1 + 4 * a1[2] == a1[3] )
    a1[3] = *a1;
  v4 = 0;
  do
  {
    v5 = v2;
    --v2;
    v4 += *v5;
    if ( v2 == (_DWORD *)a1[5] )
      v2 = (_DWORD *)a1[4];
  }
  while ( v2 != v3 );
  return v4 / a1[2];
}

//----- (000B12A4) --------------------------------------------------------
int __cdecl sub_B12A4(int a1)
{
  int v1; // edx
  int v2; // eax
  int v3; // eax
  int v4; // ecx
  unsigned __int64 v5; // rax
  int result; // eax

  if ( a1 >= 0 )
    v1 = a1;
  else
    v1 = -a1;
  v2 = v1 >> 6;
  if ( v1 >> 6 < 256 )
  {
    v4 = dword_E7724[v2];
    v5 = (v1 & 0x3F) * (signed __int64)((char *)off_E7728[v2] - v4);
    v3 = v4 + (HIDWORD(v5) != 0) + (v5 >> 6);
  }
  else
  {
    v3 = dword_E7B24;
  }
  result = v3 >> 14;
  if ( a1 < 0 )
    result = -result;
  return result;
}
// E7724: using guessed type int dword_E7724[];
// E7B24: using guessed type int dword_E7B24;

//----- (000B1304) --------------------------------------------------------
int __cdecl sub_B1304(int a1, int a2)
{
  int result; // eax
  unsigned int v3; // edx
  int v4; // ecx
  int v5; // esi

  result = a1;
  if ( a1 || a2 )
  {
    if ( a1 >= 0 )
    {
      v4 = a1;
      v3 = 0;
    }
    else
    {
      v3 = 1;
      v4 = -a1;
    }
    if ( a2 >= 0 )
    {
      v5 = a2;
    }
    else
    {
      LOBYTE(v3) = v3 | 2;
      v5 = -a2;
    }
    if ( v4 >= v5 )
    {
      switch ( v3 )
      {
        case 0u:
        case 2u:
          result = 25735 - sub_B12A4(((signed __int64)a2 << 14) / a1);
          break;
        case 1u:
        case 3u:
          result = -25735 - sub_B12A4(((signed __int64)a2 << 14) / a1);
          break;
        default:
          result = 0;
          break;
      }
    }
    else if ( v3 < 2 )
    {
      result = sub_B12A4(((signed __int64)a1 << 14) / a2);
    }
    else if ( v3 <= 2 )
    {
      result = sub_B12A4(((signed __int64)a1 << 14) / a2) + 51471;
    }
    else if ( v3 == 3 )
    {
      result = sub_B12A4(((signed __int64)a1 << 14) / a2) - 51471;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (000B1414) --------------------------------------------------------
int __cdecl sub_B1414(int a1)
{
  int v1; // edx
  int v2; // eax
  int v3; // eax
  int v4; // ecx
  unsigned __int64 v5; // rax
  int result; // eax

  if ( a1 >= 0 )
    v1 = ((signed __int64)a1 << 14) / 25735;
  else
    v1 = -(signed int)(((signed __int64)a1 << 14) / 25735);
  v2 = v1 >> 6;
  if ( v1 >> 6 < 256 )
  {
    v4 = dword_E7320[v2];
    v5 = (v1 & 0x3F) * (signed __int64)(dword_E7324[v2] - v4);
    v3 = v4 + (HIDWORD(v5) != 0) + (v5 >> 6);
  }
  else
  {
    v3 = dword_E7720;
  }
  result = v3 >> 14;
  if ( a1 < 0 )
    result = -result;
  return result;
}
// E7320: using guessed type int dword_E7320[];
// E7720: using guessed type int dword_E7720;

//----- (000B148C) --------------------------------------------------------
int __cdecl sub_B148C(int a1)
{
  signed int v1; // edx
  int v3; // eax

  v1 = a1 % 102943;
  if ( a1 % 102943 < 0 )
    v1 += 102943;
  if ( v1 <= 25735 )
    return sub_B1414(v1);
  if ( v1 <= 51471 )
    return sub_B1414(51471 - v1);
  if ( v1 > 77207 )
    v3 = sub_B1414(102943 - v1);
  else
    v3 = sub_B1414(v1 - 51471);
  return -v3;
}

//----- (000B14F8) --------------------------------------------------------
int __cdecl sub_B14F8(int *a1, int a2)
{
  int result; // eax

  *a1 = sub_B148C(a2);
  result = sub_B148C(a2 + 25735);
  a1[1] = result;
  return result;
}

//----- (000B1C58) --------------------------------------------------------
char __usercall sub_B1C58@<al>(__int16 a1@<bx>, int a2, __int16 a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, __int16 a16)
{
  int v16; // esi
  __int16 v17; // dx
  __int16 v18; // cx
  char result; // al
  _BOOL1 i; // zf
  __int16 v21; // ax
  __int16 v22; // bx
  int v23; // ebx
  int v24; // eax
  int v25; // edx
  void *retaddr; // [esp+0h] [ebp+0h]

  v16 = a15;
  v17 = HIWORD(a2);
  v18 = a2;
  result = *MK_FP(a16, a15);
  for ( i = *MK_FP(a16, a15) == -101; *MK_FP(a16, v16) <= 0x9Bu; i = *MK_FP(a16, v16) == -101 )
  {
    if ( !i )
    {
      switch ( result )
      {
        case 38:
          v18 = a3;
          v17 = a3;
          ++v16;
          goto LABEL_6;
        case 46:
          v18 = a16;
          v17 = a16;
          ++v16;
          goto LABEL_6;
        case 54:
          v18 = HIWORD(a2);
          v17 = HIWORD(a2);
          ++v16;
          goto LABEL_6;
        case 62:
          v18 = a2;
          v17 = a2;
          ++v16;
          goto LABEL_6;
        case 100:
          v18 = __FS__;
          v17 = __FS__;
          ++v16;
          goto LABEL_6;
        case 101:
          v18 = __GS__;
          v17 = __GS__;
          ++v16;
          goto LABEL_6;
      }
      if ( result != 102 && result != 103 )
        break;
    }
    ++v16;
LABEL_6:
    result = *MK_FP(a16, v16);
  }
  LOBYTE(a1) = result & 0xF8;
  if ( (result & 0xF8) == -40 )
  {
    HIBYTE(v21) = *MK_FP(a16, v16 + 1);
    LOBYTE(v21) = result & 7;
    if ( HIBYTE(v21) < 0xC0u )
    {
      LOBYTE(v22) = *MK_FP(a16, v16 + 1);
      HIBYTE(v22) = HIBYTE(v21) >> 3;
      v23 = v22 & 0x1807;
      LOWORD(v23) = (unsigned __int8)(BYTE1(v23) | v23);
      ((void (__usercall *)(int@<ebp>))off_B1904[v23])((int)&retaddr);
      ((void (__fastcall *)(int, int, int))_GETDS)(v24, v25, (unsigned __int8)v24 | BYTE1(v24) & 0x38);
    }
    ((void (__fastcall *)(__int16, __int16, __int16, __int16))_GETDS)(v21, v17, a1, v18);
  }
  return result;
}
// B1904: using guessed type int (*off_B1904[57])();

//----- (000B1D8C) --------------------------------------------------------
char __usercall sub_B1D8C@<al>(int a1@<ebp>, int a2@<edi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  _DWORD *v17; // ebx
  signed int v18; // edx
  int v19; // eax
  unsigned __int8 v20; // cf
  int v21; // eax

  v17 = (_DWORD *)(a2 + a1 + 28);
  v18 = -256;
  v19 = *(_DWORD *)(a2 + a1 + 32);
  v20 = __CFSHL__(v19, 25);
  v21 = v19 << 25;
  if ( v20 )
  {
    if ( !v21 && !*v17 )
      v18 = -512;
    v20 = __CFADD__(*(_DWORD *)(a2 + a1 + 32), 256);
    *(_DWORD *)(a2 + a1 + 32) += 256;
    if ( v20 )
    {
      *(_DWORD *)(a2 + a1 + 32) = 2147483648;
      ++*(_WORD *)(a2 + a1 + 36);
    }
  }
  *(_DWORD *)(a2 + a1 + 32) &= v18;
  *v17 = 0;
  return sub_B1C58((__int16)v17, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B1E11) --------------------------------------------------------
char __usercall sub_B1E11@<al>(int a1@<ebp>, int a2@<edi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  __int16 v17; // bx

  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v17 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v17;
  return sub_B1C58(v17, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B1E68) --------------------------------------------------------
int __usercall sub_B1E68@<eax>(int result@<eax>, int a2@<ecx>, _BYTE *a3@<ebp>)
{
  int v3; // [esp-80h] [ebp-80h]
  int v4; // [esp-14h] [ebp-14h]
  int v5; // [esp-10h] [ebp-10h]
  int v6; // [esp-Ch] [ebp-Ch]

  a3[4] |= result;
  if ( !((unsigned __int8)result & *a3) )
  {
    v6 = a2;
    v5 = (unsigned __int16)__ES__;
    v4 = (unsigned __int16)__DS__;
    qmemcpy(&v3, a3, 0x6Cu);
    result = off_E4CBD(BYTE1(result));
    qmemcpy(a3, &v3, 0x6Cu);
  }
  return result;
}
// E4CBD: using guessed type int (__fastcall *off_E4CBD)(_DWORD);

//----- (000B1EB6) --------------------------------------------------------
void __usercall sub_B1EB6(int a1@<ebp>)
{
  int v1; // ebx

  v1 = *(_DWORD *)(a1 + 40);
}

//----- (000B1EBC) --------------------------------------------------------
void __usercall sub_B1EBC(int a1@<ebp>)
{
  int v1; // ebx

  v1 = *(_DWORD *)(a1 + 36);
}

//----- (000B1EC2) --------------------------------------------------------
void __usercall sub_B1EC2(int a1@<ebp>)
{
  int v1; // ebx

  v1 = *(_DWORD *)(a1 + 32);
}

//----- (000B1EC8) --------------------------------------------------------
void __usercall sub_B1EC8(int a1@<ebp>)
{
  int v1; // ebx

  v1 = *(_DWORD *)(a1 + 28);
}

//----- (000B1ECE) --------------------------------------------------------
void __usercall sub_B1ECE(int a1@<ebp>)
{
  int v1; // ebx

  v1 = *(_DWORD *)(a1 + 24);
}

//----- (000B1ED6) --------------------------------------------------------
void __usercall sub_B1ED6(int *a1@<esi>)
{
  int v1; // ebx

  v1 = *a1;
}

//----- (000B1EDC) --------------------------------------------------------
void __usercall sub_B1EDC(int a1@<ebp>)
{
  int v1; // ebx

  v1 = *(_DWORD *)(a1 + 16);
}

//----- (000B1EE2) --------------------------------------------------------
void __usercall sub_B1EE2(int a1@<ebp>)
{
  int v1; // ebx

  v1 = *(_DWORD *)(a1 + 12);
}

//----- (000B1EE8) --------------------------------------------------------
void __usercall sub_B1EE8(int a1@<ebp>, char *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 40) + *a2;
}

//----- (000B1EF0) --------------------------------------------------------
void __usercall sub_B1EF0(int a1@<ebp>, char *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 36) + *a2;
}

//----- (000B1EF8) --------------------------------------------------------
void __usercall sub_B1EF8(int a1@<ebp>, char *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 32) + *a2;
}

//----- (000B1F00) --------------------------------------------------------
void __usercall sub_B1F00(int a1@<ebp>, char *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 28) + *a2;
}

//----- (000B1F08) --------------------------------------------------------
void __usercall sub_B1F08(int a1@<ebp>, char *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 24) + *a2;
}

//----- (000B1F12) --------------------------------------------------------
void __usercall sub_B1F12(int a1@<ebp>, char *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 20) + *a2;
}

//----- (000B1F1C) --------------------------------------------------------
void __usercall sub_B1F1C(int a1@<ebp>, char *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 16) + *a2;
}

//----- (000B1F24) --------------------------------------------------------
void __usercall sub_B1F24(int a1@<ebp>, char *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 12) + *a2;
}

//----- (000B1F2C) --------------------------------------------------------
void __usercall sub_B1F2C(int a1@<ebp>, _DWORD *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 40) + *a2;
}

//----- (000B1F35) --------------------------------------------------------
void __usercall sub_B1F35(int a1@<ebp>, _DWORD *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 36) + *a2;
}

//----- (000B1F3E) --------------------------------------------------------
void __usercall sub_B1F3E(int a1@<ebp>, _DWORD *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 32) + *a2;
}

//----- (000B1F47) --------------------------------------------------------
void __usercall sub_B1F47(int a1@<ebp>, _DWORD *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 28) + *a2;
}

//----- (000B1F50) --------------------------------------------------------
void __usercall sub_B1F50(int a1@<ebp>, _DWORD *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 24) + *a2;
}

//----- (000B1F5B) --------------------------------------------------------
void __usercall sub_B1F5B(int a1@<ebp>, _DWORD *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 20) + *a2;
}

//----- (000B1F66) --------------------------------------------------------
void __usercall sub_B1F66(int a1@<ebp>, _DWORD *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 16) + *a2;
}

//----- (000B1F6F) --------------------------------------------------------
void __usercall sub_B1F6F(int a1@<ebp>, _DWORD *a2@<esi>)
{
  int v2; // ebx

  v2 = *(_DWORD *)(a1 + 12) + *a2;
}

//----- (000B1F78) --------------------------------------------------------
int __usercall sub_B1F78@<eax>(unsigned __int8 a1@<ah>, unsigned int a2@<ebx>, int a3@<ebp>, _BYTE *a4@<esi>)
{
  int result; // eax
  unsigned int v5; // edx
  int v6; // ebx
  unsigned int v7; // [esp-4h] [ebp-4h]

  LOBYTE(a2) = *a4;
  v7 = a2;
  LOWORD(a2) = (a1 >> 3) & 0x18 | *a4 & 7;
  ((void (__usercall *)(int@<ebp>))off_B1964[a2])(a3);
  v5 = v7;
  if ( (v7 & 0x38) != 32 )
  {
    LOBYTE(v5) = v7 & 0x38;
    v6 = (*(_DWORD *)(a3 - (v5 >> 1) + 40) << ((unsigned __int8)v7 >> 6)) + a2;
  }
  return result;
}
// B1964: using guessed type int (*off_B1964[33])();

//----- (000B1FB5) --------------------------------------------------------
int __usercall sub_B1FB5@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B3BA6(*a3, a1 + 108);
  v3 = sub_B337C(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B1FD4) --------------------------------------------------------
int __usercall sub_B1FD4@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B3BA6(*a3, a1 + 108);
  v3 = sub_B37B0(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B1FF3) --------------------------------------------------------
char __usercall sub_B1FF3@<al>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>, __int16 bx0@<bx>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  __int16 v19; // dx
  int v21; // eax

  sub_B3BA6(*a3, a1 + 108);
  v21 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v19 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v19) |= *((_BYTE *)&dword_B1860[37] + v21 + 3);
  *(_WORD *)(a1 + 4) = v19;
  return sub_B1C58(bx0, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1860: using guessed type int dword_B1860[41];

//----- (000B200F) --------------------------------------------------------
char __usercall sub_B200F@<al>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>, int _4, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  __int16 v18; // dx
  int v20; // eax

  sub_B3BA6(*a3, a1 + 108);
  v20 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_B1860[37] + v20 + 3);
  *(_WORD *)(a1 + 4) = v18;
  return sub_B1E11(a1, a2, _4, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int dword_B1860[41];

//----- (000B202B) --------------------------------------------------------
int __usercall sub_B202B@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B3BA6(*a3, a1 + 108);
  sub_B336E(a2 + a1 + 28, a1 + 108);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B204A) --------------------------------------------------------
int __usercall sub_B204A@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B3BA6(*a3, a1 + 108);
  sub_B336E(a1 + 108, a2 + a1 + 28);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2069) --------------------------------------------------------
int __usercall sub_B2069@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B3BA6(*a3, a1 + 108);
  v3 = sub_B35DB(a2 + a1 + 28, a1 + 108, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2088) --------------------------------------------------------
int __usercall sub_B2088@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B3BA6(*a3, a1 + 108);
  v3 = sub_B35DB(a1 + 108, a2 + a1 + 28, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B20A7) --------------------------------------------------------
char __usercall sub_B20A7@<al>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx
  __int16 v20; // bx

  v18 = *(unsigned __int16 *)((char *)dword_B1858 + a2);
  v19 = *(_WORD *)((char *)dword_B1858 + v18 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  v20 = *(_WORD *)((char *)&dword_B1860[17] + v18 + 2);
  *(_WORD *)(a1 + 8) &= v20;
  sub_B3BA6(*a3, v18 + a1 + 28);
  return sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B20E1) --------------------------------------------------------
char __usercall sub_B20E1@<al>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>, __int16 bx0@<bx>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  *a3 = sub_B3A60(a2 + a1 + 28);
  return sub_B1C58(bx0, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}

//----- (000B20F2) --------------------------------------------------------
char __usercall sub_B20F2@<al>(int a1@<ebp>, int a2@<edi>, int *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  *esi0 = sub_B3A60(a2 + a1 + 28);
  return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B2103) --------------------------------------------------------
char __usercall sub_B2103@<al>(void *a1@<ebp>, const void *a2@<esi>, __int16 bx0@<bx>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  qmemcpy(a1, a2, 0x1Cu);
  return sub_B1C58(bx0, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B2121) --------------------------------------------------------
char __usercall sub_B2121@<al>(int a1@<ebp>, __int16 *a2@<esi>, __int16 bx0@<bx>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  __int16 v18; // ax
  __int16 v19; // ax

  v18 = *a2;
  *(_WORD *)a1 = *a2;
  v19 = v18 & 0x300;
  if ( v19 == 768 )
  {
    *(_DWORD *)(a1 + 118) = sub_B1C58;
  }
  else if ( v19 == 512 )
  {
    *(_DWORD *)(a1 + 118) = sub_B1DC8;
  }
  else
  {
    *(_DWORD *)(a1 + 118) = sub_B1D8C;
  }
  return sub_B1C58(bx0, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1DC8: using guessed type int sub_B1DC8();

//----- (000B2161) --------------------------------------------------------
char __usercall sub_B2161@<al>(const void *a1@<ebp>, void *a2@<esi>, __int16 di0@<di>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  qmemcpy(a2, a1, 0x1Cu);
  return sub_B1C58(di0, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B2175) --------------------------------------------------------
char __usercall sub_B2175@<al>(_WORD *a1@<ebp>, _WORD *a2@<esi>, __int16 bx0@<bx>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  *a2 = *a1;
  return sub_B1C58(bx0, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B2183) --------------------------------------------------------
int __usercall sub_B2183@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B399A(*a3, a1 + 108);
  v3 = sub_B337C(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B21A2) --------------------------------------------------------
int __usercall sub_B21A2@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B399A(*a3, a1 + 108);
  v3 = sub_B37B0(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B21C1) --------------------------------------------------------
char __usercall sub_B21C1@<al>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>, __int16 bx0@<bx>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  __int16 v19; // dx
  int v21; // eax

  sub_B399A(*a3, a1 + 108);
  v21 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v19 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v19) |= *((_BYTE *)&dword_B1860[37] + v21 + 3);
  *(_WORD *)(a1 + 4) = v19;
  return sub_B1C58(bx0, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1860: using guessed type int dword_B1860[41];

//----- (000B21DD) --------------------------------------------------------
char __usercall sub_B21DD@<al>(int a1@<ebp>, int a2@<edi>, int *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  __int16 v18; // dx
  int v20; // eax

  sub_B399A(*esi0, a1 + 108);
  v20 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_B1860[37] + v20 + 3);
  *(_WORD *)(a1 + 4) = v18;
  return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int dword_B1860[41];

//----- (000B21F9) --------------------------------------------------------
int __usercall sub_B21F9@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B399A(*a3, a1 + 108);
  sub_B336E(a2 + a1 + 28, a1 + 108);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2218) --------------------------------------------------------
int __usercall sub_B2218@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B399A(*a3, a1 + 108);
  sub_B336E(a1 + 108, a2 + a1 + 28);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2237) --------------------------------------------------------
int __usercall sub_B2237@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B399A(*a3, a1 + 108);
  v3 = sub_B35DB(a2 + a1 + 28, a1 + 108, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2256) --------------------------------------------------------
int __usercall sub_B2256@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B399A(*a3, a1 + 108);
  v3 = sub_B35DB(a1 + 108, a2 + a1 + 28, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2275) --------------------------------------------------------
char __usercall sub_B2275@<al>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx
  __int16 v20; // bx

  v18 = *(unsigned __int16 *)((char *)dword_B1858 + a2);
  v19 = *(_WORD *)((char *)dword_B1858 + v18 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  v20 = *(_WORD *)((char *)&dword_B1860[17] + v18 + 2);
  *(_WORD *)(a1 + 8) &= v20;
  sub_B399A(*a3, v18 + a1 + 28);
  return sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B22AF) --------------------------------------------------------
char __usercall sub_B22AF@<al>(_WORD *a1@<ebp>, int a2@<edi>, _DWORD *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  int v18; // ST08_4
  int v19; // ST04_4
  int v20; // ST00_4
  int v21; // eax
  _DWORD *v22; // ebx

  v18 = *(_DWORD *)((char *)a1 + a2 + 28);
  v19 = *(_DWORD *)((char *)a1 + a2 + 32);
  v20 = *(_DWORD *)((char *)a1 + a2 + 34);
  sub_B3C6B((unsigned int)a1 + a2 + 28, *a1 & 0xC00);
  sub_B392B();
  *a3 = v21;
  v22 = (_DWORD *)((char *)a1 + a2 + 28);
  *(_DWORD *)((char *)v22 + 6) = v20;
  v22[1] = v19;
  *v22 = v18;
  return sub_B1C58((__int16)v22, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}

//----- (000B22EB) --------------------------------------------------------
char __usercall sub_B22EB@<al>(int a1@<ebp>, int a2@<edi>, _DWORD *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  int v18; // eax

  sub_B3C6B(a2 + a1 + 28, *(_WORD *)a1 & 0xC00);
  sub_B392B();
  *esi0 = v18;
  return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B230F) --------------------------------------------------------
int __usercall sub_B230F@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B39E0(*a3, a1 + 108, (_BYTE *)a1);
  v3 = sub_B337C(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2332) --------------------------------------------------------
int __usercall sub_B2332@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B39E0(*a3, a1 + 108, (_BYTE *)a1);
  v3 = sub_B37B0(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2355) --------------------------------------------------------
char __usercall sub_B2355@<al>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  __int16 v18; // dx
  int v20; // eax

  sub_B39E0(*a3, a1 + 108, (_BYTE *)a1);
  v20 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_B1860[37] + v20 + 3);
  *(_WORD *)(a1 + 4) = v18;
  return sub_B1C58(a1 + 108, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1860: using guessed type int dword_B1860[41];

//----- (000B2375) --------------------------------------------------------
char __usercall sub_B2375@<al>(int a1@<ebp>, int a2@<edi>, __int64 *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  __int16 v18; // dx
  int v20; // eax

  sub_B39E0(*esi0, a1 + 108, (_BYTE *)a1);
  v20 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_B1860[37] + v20 + 3);
  *(_WORD *)(a1 + 4) = v18;
  return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int dword_B1860[41];

//----- (000B2395) --------------------------------------------------------
int __usercall sub_B2395@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B39E0(*a3, a1 + 108, (_BYTE *)a1);
  sub_B336E(a2 + a1 + 28, a1 + 108);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B23B8) --------------------------------------------------------
int __usercall sub_B23B8@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B39E0(*a3, a1 + 108, (_BYTE *)a1);
  sub_B336E(a1 + 108, a2 + a1 + 28);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B23DB) --------------------------------------------------------
int __usercall sub_B23DB@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B39E0(*a3, a1 + 108, (_BYTE *)a1);
  v3 = sub_B35DB(a2 + a1 + 28, a1 + 108, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B23FE) --------------------------------------------------------
int __usercall sub_B23FE@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B39E0(*a3, a1 + 108, (_BYTE *)a1);
  v3 = sub_B35DB(a1 + 108, a2 + a1 + 28, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2421) --------------------------------------------------------
char __usercall sub_B2421@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx
  __int16 v20; // bx

  v18 = *(unsigned __int16 *)((char *)dword_B1858 + a2);
  v19 = *(_WORD *)((char *)dword_B1858 + v18 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  v20 = *(_WORD *)((char *)&dword_B1860[17] + v18 + 2);
  *(_WORD *)(a1 + 8) &= v20;
  *(_DWORD *)(v18 + a1 + 28) = *(_DWORD *)a3;
  *(_DWORD *)(v18 + a1 + 32) = *(_DWORD *)(a3 + 4);
  *(_WORD *)(v18 + a1 + 36) = *(_WORD *)(a3 + 8);
  return sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B2468) --------------------------------------------------------
char __usercall sub_B2468@<al>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx
  int v20; // ebx

  v18 = *(unsigned __int16 *)((char *)dword_B1858 + a2);
  v19 = *(_WORD *)((char *)dword_B1858 + v18 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v18 + 2);
  v20 = v18 + a1 + 28;
  sub_B39E0(*a3, v20, (_BYTE *)a1);
  return sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B24A6) --------------------------------------------------------
char __usercall sub_B24A6@<al>(_BYTE *a1@<ebp>, int a2@<edi>, int *a3@<esi>, __int16 bx0@<bx>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  int v19; // edx

  *a3 = sub_B3ADF((__int64 *)&a1[a2 + 28], a1);
  a3[1] = v19;
  return sub_B1C58(bx0, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}

//----- (000B24BB) --------------------------------------------------------
char __usercall sub_B24BB@<al>(int a1@<ebp>, int a2@<edi>, int esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  *(_DWORD *)esi0 = *(_DWORD *)(a2 + a1 + 28);
  *(_DWORD *)(esi0 + 4) = *(_DWORD *)(a2 + a1 + 32);
  *(_WORD *)(esi0 + 8) = *(_WORD *)(a2 + a1 + 36);
  return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B24D9) --------------------------------------------------------
char __usercall sub_B24D9@<al>(int a1@<ebp>, int a2@<edi>, int *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  int v18; // edx

  *esi0 = sub_B3ADF((__int64 *)(a2 + a1 + 28), (_BYTE *)a1);
  esi0[1] = v18;
  return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B24EE) --------------------------------------------------------
char __usercall sub_B24EE@<al>(_DWORD *a1@<ebp>, _DWORD *a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  _DWORD *v17; // esi
  unsigned int v18; // ebx
  signed int v19; // ecx
  _DWORD *v20; // esi

  qmemcpy(a1, a2, 0x1Cu);
  v17 = a2 + 7;
  v18 = 10 * ((a1[1] & 0x3800u) >> 11);
  v19 = 8;
  do
  {
    *(_DWORD *)((char *)a1 + v18 + 28) = *v17;
    v20 = v17 + 1;
    *(_DWORD *)((char *)a1 + v18 + 32) = *v20;
    ++v20;
    *(_WORD *)((char *)a1 + v18 + 36) = *(_WORD *)v20;
    v17 = (_DWORD *)((char *)v20 + 2);
    v18 = *(unsigned __int16 *)((char *)&off_B1854 + v18 + 2);
    --v19;
  }
  while ( v19 );
  return sub_B1C58(v18, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1854: using guessed type void *off_B1854;

//----- (000B2535) --------------------------------------------------------
void __usercall sub_B2535(char *a1@<ebp>, int a2@<edi>, _DWORD *a3@<esi>)
{
  int v3; // ebx
  _DWORD *v4; // edi
  signed int v5; // ecx
  _DWORD *v6; // edi

  v3 = a2;
  qmemcpy(a3, a1, 0x1Cu);
  v4 = a3 + 7;
  v5 = 8;
  do
  {
    *v4 = *(_DWORD *)&a1[v3 + 28];
    v6 = v4 + 1;
    *v6 = *(_DWORD *)&a1[v3 + 32];
    ++v6;
    *(_WORD *)v6 = *(_WORD *)&a1[v3 + 36];
    v4 = (_DWORD *)((char *)v6 + 2);
    v3 = *(unsigned __int16 *)((char *)&off_B1854 + v3 + 2);
    --v5;
  }
  while ( v5 );
  JUMPOUT(&loc_B2E4B);
}
// B1854: using guessed type void *off_B1854;

//----- (000B2560) --------------------------------------------------------
char __usercall sub_B2560@<al>(int a1@<ebp>, _WORD *a2@<esi>, __int16 bx0@<bx>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  *a2 = *(_WORD *)(a1 + 4);
  return sub_B1C58(bx0, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B256E) --------------------------------------------------------
int __usercall sub_B256E@<eax>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B399A(*a3, a1 + 108);
  v3 = sub_B337C(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B258F) --------------------------------------------------------
int __usercall sub_B258F@<eax>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B399A(*a3, a1 + 108);
  v3 = sub_B37B0(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B25B0) --------------------------------------------------------
char __usercall sub_B25B0@<al>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>, __int16 bx0@<bx>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  __int16 v19; // dx
  int v21; // eax

  sub_B399A(*a3, a1 + 108);
  v21 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v19 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v19) |= *((_BYTE *)&dword_B1860[37] + v21 + 3);
  *(_WORD *)(a1 + 4) = v19;
  return sub_B1C58(bx0, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1860: using guessed type int dword_B1860[41];

//----- (000B25CE) --------------------------------------------------------
char __usercall sub_B25CE@<al>(int a1@<ebp>, int a2@<edi>, signed __int16 *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  __int16 v18; // dx
  int v20; // eax

  sub_B399A(*esi0, a1 + 108);
  v20 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_B1860[37] + v20 + 3);
  *(_WORD *)(a1 + 4) = v18;
  return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int dword_B1860[41];

//----- (000B25EC) --------------------------------------------------------
int __usercall sub_B25EC@<eax>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B399A(*a3, a1 + 108);
  sub_B336E(a2 + a1 + 28, a1 + 108);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B260D) --------------------------------------------------------
int __usercall sub_B260D@<eax>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B399A(*a3, a1 + 108);
  sub_B336E(a1 + 108, a2 + a1 + 28);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B262E) --------------------------------------------------------
int __usercall sub_B262E@<eax>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B399A(*a3, a1 + 108);
  v3 = sub_B35DB(a2 + a1 + 28, a1 + 108, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B264F) --------------------------------------------------------
int __usercall sub_B264F@<eax>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B399A(*a3, a1 + 108);
  v3 = sub_B35DB(a1 + 108, a2 + a1 + 28, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2670) --------------------------------------------------------
char __usercall sub_B2670@<al>(int a1@<ebp>, int a2@<edi>, signed __int16 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx
  __int16 v20; // bx

  v18 = *(unsigned __int16 *)((char *)dword_B1858 + a2);
  v19 = *(_WORD *)((char *)dword_B1858 + v18 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  v20 = *(_WORD *)((char *)&dword_B1860[17] + v18 + 2);
  *(_WORD *)(a1 + 8) &= v20;
  sub_B399A(*a3, v18 + a1 + 28);
  return sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B26AC) --------------------------------------------------------
char __usercall sub_B26AC@<al>(_WORD *a1@<ebp>, int a2@<edi>, _WORD *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  int v18; // eax
  _DWORD *v19; // ebx
  int v21; // [esp-Ch] [ebp-Ch]
  int v22; // [esp-8h] [ebp-8h]
  int v23; // [esp-4h] [ebp-4h]

  v23 = *(_DWORD *)((char *)a1 + a2 + 28);
  v22 = *(_DWORD *)((char *)a1 + a2 + 32);
  v21 = *(_DWORD *)((char *)a1 + a2 + 34);
  sub_B3C6B((unsigned int)a1 + a2 + 28, *a1 & 0xC00);
  sub_B392B();
  if ( (signed __int16)v18 != v18 )
    LOWORD(v18) = -32768;
  *a3 = v18;
  v19 = (_DWORD *)((char *)a1 + a2 + 28);
  *(_DWORD *)((char *)v19 + 6) = v21;
  v19[1] = v22;
  *v19 = v23;
  return sub_B1C58((__int16)v19, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}

//----- (000B26F4) --------------------------------------------------------
char __usercall sub_B26F4@<al>(int a1@<ebp>, int a2@<edi>, _WORD *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  int v18; // eax

  sub_B3C6B(a2 + a1 + 28, *(_WORD *)a1 & 0xC00);
  sub_B392B();
  if ( (signed __int16)v18 != v18 )
    LOWORD(v18) = -32768;
  *esi0 = v18;
  return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B2729) --------------------------------------------------------
char __usercall sub_B2729@<al>(int a1@<ebp>, int a2@<edi>, unsigned int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx
  __int16 v20; // bx

  v18 = *(unsigned __int16 *)((char *)dword_B1858 + a2);
  v19 = *(_WORD *)((char *)dword_B1858 + v18 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  v20 = *(_WORD *)((char *)&dword_B1860[17] + v18 + 2);
  *(_WORD *)(a1 + 8) &= v20;
  sub_B39AB(*a3, v18 + a1 + 28);
  return sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B2768) --------------------------------------------------------
char __usercall sub_B2768@<al>(int a1@<ebp>, int a2@<edi>, int *esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  sub_B3C6B(a2 + a1 + 28, *(_WORD *)a1 & 0xC00);
  *esi0 = sub_B3930((int *)(a2 + a1 + 28));
  return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B2791) --------------------------------------------------------
void sub_B2791()
{
  JUMPOUT(&loc_B27B9);
}

//----- (000B27BE) --------------------------------------------------------
int __usercall sub_B27BE@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  v3 = sub_B337C(a2 + a1 + 28, a3 + a1 + 28, a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B27D3) --------------------------------------------------------
int __usercall sub_B27D3@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  v3 = sub_B37B0(a2 + a1 + 28, a3 + a1 + 28, a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B27E8) --------------------------------------------------------
char __usercall sub_B27E8@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, __int16 bx0@<bx>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  __int16 v19; // dx
  int v21; // eax

  v21 = sub_B3542(a2 + a1 + 28, a3 + a1 + 28);
  v19 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v19) |= *((_BYTE *)&dword_B1860[37] + v21 + 3);
  *(_WORD *)(a1 + 4) = v19;
  return sub_B1C58(bx0, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1860: using guessed type int dword_B1860[41];

//----- (000B27FA) --------------------------------------------------------
char __usercall sub_B27FA@<al>(int a1@<ebp>, int a2@<edi>, int esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  __int16 v18; // dx
  int v20; // eax

  v20 = sub_B3542(a2 + a1 + 28, esi0 + a1 + 28);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_B1860[37] + v20 + 3);
  *(_WORD *)(a1 + 4) = v18;
  return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int dword_B1860[41];

//----- (000B280C) --------------------------------------------------------
int __usercall sub_B280C@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B336E(a2 + a1 + 28, a3 + a1 + 28);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2821) --------------------------------------------------------
int __usercall sub_B2821@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B336E(a3 + a1 + 28, a2 + a1 + 28);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2836) --------------------------------------------------------
int __usercall sub_B2836@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  v3 = sub_B35DB(a2 + a1 + 28, a3 + a1 + 28, (_BYTE *)a1, a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B284B) --------------------------------------------------------
int __usercall sub_B284B@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  v3 = sub_B35DB(a3 + a1 + 28, a2 + a1 + 28, (_BYTE *)a1, a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2860) --------------------------------------------------------
char __usercall sub_B2860@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx
  __int16 v20; // bx

  v18 = *(unsigned __int16 *)((char *)dword_B1858 + a2);
  v19 = *(_WORD *)((char *)dword_B1858 + v18 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  v20 = *(_WORD *)((char *)&dword_B1860[17] + v18 + 2);
  *(_WORD *)(a1 + 8) &= v20;
  *(_DWORD *)(v18 + a1 + 28) = *(_DWORD *)(a3 + a1 + 28);
  *(_DWORD *)(v18 + a1 + 32) = *(_DWORD *)(a3 + a1 + 32);
  *(_WORD *)(v18 + a1 + 36) = *(_WORD *)(a3 + a1 + 36);
  return sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B28A8) --------------------------------------------------------
char __usercall sub_B28A8@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  int v18; // ebx
  int v19; // esi
  __int16 v20; // ax

  v18 = a2 + a1 + 28;
  v19 = a3 + a1 + 28;
  *(_DWORD *)v19 = _InterlockedExchange((volatile signed __int32 *)v18, *(_DWORD *)v19);
  *(_DWORD *)(v19 + 4) = _InterlockedExchange((volatile signed __int32 *)(a2 + a1 + 32), *(_DWORD *)(v19 + 4));
  v20 = *(_WORD *)(a2 + a1 + 36);
  *(_WORD *)(v18 + 8) = *(_WORD *)(v19 + 8);
  *(_WORD *)(v19 + 8) = v20;
  return sub_B1C58(v18, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}

//----- (000B2912) --------------------------------------------------------
char __usercall sub_B2912@<al>(int a1@<ebp>, int a2@<edi>, __int16 bx0@<bx>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  __int16 v18; // dx
  int v20; // eax

  *(_DWORD *)(a1 + 108) = dword_B184C[0];
  *(_DWORD *)(a1 + 112) = dword_B184C[1];
  *(_WORD *)(a1 + 116) = (_WORD)off_B1854;
  v20 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_B1860[37] + v20 + 3);
  *(_WORD *)(a1 + 4) = v18;
  return sub_B1C58(bx0, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B184C: using guessed type int dword_B184C[2];
// B1854: using guessed type void *off_B1854;
// B1860: using guessed type int dword_B1860[41];

//----- (000B2951) --------------------------------------------------------
char __usercall sub_B2951@<al>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx
  __int16 v20; // bx
  int v21; // esi
  char result; // al
  int v23; // edi
  __int16 v24; // bx
  __int16 v25; // bx
  int v26; // esi
  int v27; // edi
  __int16 v28; // bx
  __int16 v29; // bx
  int v30; // esi
  int v31; // edi
  __int16 v32; // bx
  __int16 v33; // bx
  int v34; // esi
  int v35; // edi
  __int16 v36; // bx
  __int16 v37; // bx
  int v38; // esi
  int v39; // edi
  __int16 v40; // bx
  __int16 v41; // bx
  int v42; // esi
  int v43; // edi
  __int16 v44; // bx
  int v45; // esi
  __int16 v46; // bx

  switch ( a1 )
  {
    case 0:
      v18 = *(unsigned __int16 *)((char *)dword_B1858 + a3);
      v19 = *(_WORD *)((char *)dword_B1858 + v18 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v19;
      v20 = *(_WORD *)((char *)&dword_B1860[17] + v18 + 2);
      *(_WORD *)(a2 + 8) &= v20;
      v21 = v18 + a2 + 28;
      *(_DWORD *)v21 = 0;
      *(_DWORD *)(v21 + 4) = 2147483648;
      *(_WORD *)(v21 + 8) = 0x3FFF;
      result = sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 1:
      v23 = *(unsigned __int16 *)((char *)dword_B1858 + a3);
      v24 = *(_WORD *)((char *)dword_B1858 + v23 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v24;
      v25 = *(_WORD *)((char *)&dword_B1860[17] + v23 + 2);
      *(_WORD *)(a2 + 8) &= v25;
      v26 = v23 + a2 + 28;
      *(_DWORD *)v26 = -853832962;
      *(_DWORD *)(v26 + 4) = -728074165;
      *(_WORD *)(v26 + 8) = 0x4000;
      result = sub_B1C58(v25, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 2:
      v27 = *(unsigned __int16 *)((char *)dword_B1858 + a3);
      v28 = *(_WORD *)((char *)dword_B1858 + v27 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v28;
      v29 = *(_WORD *)((char *)&dword_B1860[17] + v27 + 2);
      *(_WORD *)(a2 + 8) &= v29;
      v30 = v27 + a2 + 28;
      *(_DWORD *)v30 = 1545072828;
      *(_DWORD *)(v30 + 4) = -1196803287;
      *(_WORD *)(v30 + 8) = 0x3FFF;
      result = sub_B1C58(v29, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 3:
      v31 = *(unsigned __int16 *)((char *)dword_B1858 + a3);
      v32 = *(_WORD *)((char *)dword_B1858 + v31 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v32;
      v33 = *(_WORD *)((char *)&dword_B1860[17] + v31 + 2);
      *(_WORD *)(a2 + 8) &= v33;
      v34 = v31 + a2 + 28;
      *(_DWORD *)v34 = 560513589;
      *(_DWORD *)(v34 + 4) = -922690910;
      *(_WORD *)(v34 + 8) = 0x4000;
      result = sub_B1C58(v33, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 4:
      v35 = *(unsigned __int16 *)((char *)dword_B1858 + a3);
      v36 = *(_WORD *)((char *)dword_B1858 + v35 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v36;
      v37 = *(_WORD *)((char *)&dword_B1860[17] + v35 + 2);
      *(_WORD *)(a2 + 8) &= v37;
      v38 = v35 + a2 + 28;
      *(_DWORD *)v38 = -70256743;
      *(_DWORD *)(v38 + 4) = -1709139324;
      *(_WORD *)(v38 + 8) = 16381;
      result = sub_B1C58(v37, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 5:
      v39 = *(unsigned __int16 *)((char *)dword_B1858 + a3);
      v40 = *(_WORD *)((char *)dword_B1858 + v39 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v40;
      v41 = *(_WORD *)((char *)&dword_B1860[17] + v39 + 2);
      *(_WORD *)(a2 + 8) &= v41;
      v42 = v39 + a2 + 28;
      *(_DWORD *)v42 = -774932052;
      *(_DWORD *)(v42 + 4) = -1317922825;
      *(_WORD *)(v42 + 8) = 16382;
      result = sub_B1C58(v41, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 6:
      v43 = *(unsigned __int16 *)((char *)dword_B1858 + a3);
      v44 = *(_WORD *)((char *)dword_B1858 + v43 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v44;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v43 + 2);
      v45 = v43 + a2 + 28;
      *(_DWORD *)v45 = 0;
      *(_DWORD *)(v45 + 4) = 0;
      *(_WORD *)(v45 + 8) = 0;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v43 + 2);
      v46 = *(_WORD *)((char *)&dword_B1860[18] + v43);
      *(_WORD *)(a2 + 8) |= v46;
      result = sub_B1C58(v46, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
  }
  return result;
}
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B2B6C) --------------------------------------------------------
char __usercall sub_B2B6C@<al>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4@<ebp>, int a5@<edi>, int a6@<esi>, int a7, __int16 a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, __int16 a21)
{
  int v21; // eax
  char result; // al
  __int16 v23; // bx
  int v24; // eax
  int v25; // edi
  __int16 v26; // bx
  __int16 v27; // bx
  int v28; // esi

  switch ( a3 )
  {
    case 0:
      v21 = sub_B4718(a5 + a4 + 28, a1, a3, a2);
      result = (*(int (__fastcall **)(int))(a4 + 118))(v21);
      break;
    case 1:
      *(_WORD *)(a4 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a5 + 2);
      *(_WORD *)(a4 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a5 + 2);
      v23 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a5 + 2) + 2);
      *(_WORD *)(a4 + 4) &= 0xC7FFu;
      *(_WORD *)(a4 + 4) |= v23;
      v24 = sub_B41F9(a5 + a4 + 28, (_BYTE *)a4, a6);
      result = (*(int (__fastcall **)(int))(a4 + 118))(v24);
      break;
    case 2:
      sub_B46E2(a5 + a4 + 28);
      v25 = *(unsigned __int16 *)((char *)dword_B1858 + a5);
      v26 = *(_WORD *)((char *)dword_B1858 + v25 + 2);
      *(_WORD *)(a4 + 4) &= 0xC7FFu;
      *(_WORD *)(a4 + 4) |= v26;
      v27 = *(_WORD *)((char *)&dword_B1860[17] + v25 + 2);
      *(_WORD *)(a4 + 8) &= v27;
      v28 = v25 + a4 + 28;
      *(_DWORD *)v28 = 0;
      *(_DWORD *)(v28 + 4) = 2147483648;
      *(_WORD *)(v28 + 8) = 0x3FFF;
      result = sub_B1C58(v27, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21);
      break;
  }
  return result;
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B2C76) --------------------------------------------------------
#error "B2D13: call analysis failed (funcsize=50)"

//----- (000B2D8E) --------------------------------------------------------
void __fastcall sub_B2D8E(int a1, int a2, int a3)
{
  JUMPOUT(__CS__, *(&off_B2D96 + a3));
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B2D96: using guessed type int (__cdecl *off_B2D96)(__int16, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16);

//----- (000B2E17) --------------------------------------------------------
void __fastcall sub_B2E17(int a1, int a2, int a3)
{
  JUMPOUT(__CS__, off_B2E1F[a3]);
}
// B2E1F: using guessed type int (__cdecl *off_B2E1F[2])(__int16, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16);

//----- (000B2E71) --------------------------------------------------------
int __usercall sub_B2E71@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  v3 = sub_B337C(a3 + a1 + 28, a2 + a1 + 28, a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a3 + a1 + 28);
}

//----- (000B2E86) --------------------------------------------------------
int __usercall sub_B2E86@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  v3 = sub_B37B0(a3 + a1 + 28, a2 + a1 + 28, a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a3 + a1 + 28);
}

//----- (000B2E9B) --------------------------------------------------------
int __usercall sub_B2E9B@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B336E(a2 + a1 + 28, a3 + a1 + 28);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a3 + a1 + 28);
}

//----- (000B2EB0) --------------------------------------------------------
int __usercall sub_B2EB0@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  sub_B336E(a3 + a1 + 28, a2 + a1 + 28);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a3 + a1 + 28);
}

//----- (000B2EC5) --------------------------------------------------------
int __usercall sub_B2EC5@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  v3 = sub_B35DB(a2 + a1 + 28, a3 + a1 + 28, (_BYTE *)a1, a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a3 + a1 + 28);
}

//----- (000B2EDA) --------------------------------------------------------
int __usercall sub_B2EDA@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  v3 = sub_B35DB(a3 + a1 + 28, a2 + a1 + 28, (_BYTE *)a1, a3);
  return (*(int (__fastcall **)(int, int, int))(a1 + 118))(v3, v4, a3 + a1 + 28);
}

//----- (000B2EEF) --------------------------------------------------------
char __usercall sub_B2EEF@<al>(int a1@<ebp>, int a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  __int16 v17; // bx

  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  v17 = *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  *(_WORD *)(a1 + 8) |= v17;
  return sub_B1C58(v17, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int dword_B1860[41];

//----- (000B2F0E) --------------------------------------------------------
char __usercall sub_B2F0E@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  __int16 v18; // bx

  *(_DWORD *)(a3 + a1 + 28) = *(_DWORD *)(a2 + a1 + 28);
  *(_DWORD *)(a3 + a1 + 32) = *(_DWORD *)(a2 + a1 + 32);
  *(_WORD *)(a3 + a1 + 36) = *(_WORD *)(a2 + a1 + 36);
  v18 = *(_WORD *)((char *)&dword_B1860[17] + a3 + 2);
  *(_WORD *)(a1 + 8) &= v18;
  return sub_B1C58(v18, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1860: using guessed type int dword_B1860[41];

//----- (000B2F3A) --------------------------------------------------------
char __usercall sub_B2F3A@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, __int16 bx0@<bx>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
  __int16 v19; // dx
  int v21; // eax

  v21 = sub_B3542(a2 + a1 + 28, a3 + a1 + 28);
  v19 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v19) |= *((_BYTE *)&dword_B1860[37] + v21 + 3);
  *(_WORD *)(a1 + 4) = v19;
  return sub_B1C58(bx0, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1860: using guessed type int dword_B1860[41];

//----- (000B2F4C) --------------------------------------------------------
char __usercall sub_B2F4C@<al>(int a1@<ebp>, int a2@<edi>, int esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  __int16 v18; // dx
  int v20; // eax

  v20 = sub_B3542(a2 + a1 + 28, esi0 + a1 + 28);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_B1860[37] + v20 + 3);
  *(_WORD *)(a1 + 4) = v18;
  return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int dword_B1860[41];

//----- (000B2F5E) --------------------------------------------------------
char __usercall sub_B2F5E@<al>(int a1@<ebp>, int a2@<edi>, int esi0@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
  *(_DWORD *)(esi0 + a1 + 28) = *(_DWORD *)(a2 + a1 + 28);
  *(_DWORD *)(esi0 + a1 + 32) = *(_DWORD *)(a2 + a1 + 32);
  *(_WORD *)(esi0 + a1 + 36) = *(_WORD *)(a2 + a1 + 36);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + esi0 + 2);
  return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int dword_B1860[41];

//----- (000B2F8A) --------------------------------------------------------
int __usercall sub_B2F8A@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  __int16 v4; // bx

  v3 = sub_B337C(a3 + a1 + 28, a2 + a1 + 28, a3);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v4 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v4;
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B2FD5) --------------------------------------------------------
int __usercall sub_B2FD5@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  __int16 v4; // bx

  v3 = sub_B37B0(a3 + a1 + 28, a2 + a1 + 28, a3);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v4 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v4;
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B3020) --------------------------------------------------------
void __fastcall sub_B3020(int a1, int a2, int a3)
{
  JUMPOUT(__CS__, *(&off_B3028 + a3));
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B3028: using guessed type int (__cdecl *off_B3028)(__int16, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16);

//----- (000B30A9) --------------------------------------------------------
int __usercall sub_B30A9@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  __int16 v3; // bx

  sub_B336E(a2 + a1 + 28, a3 + a1 + 28);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v3 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v3;
  return (*(int (**)(void))(a1 + 118))();
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B30F4) --------------------------------------------------------
int __usercall sub_B30F4@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  __int16 v3; // bx

  sub_B336E(a3 + a1 + 28, a2 + a1 + 28);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v3 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v3;
  return (*(int (**)(void))(a1 + 118))();
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B313F) --------------------------------------------------------
int __usercall sub_B313F@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  __int16 v4; // bx

  v3 = sub_B35DB(a2 + a1 + 28, a3 + a1 + 28, (_BYTE *)a1, a3);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v4 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v4;
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B318A) --------------------------------------------------------
int __usercall sub_B318A@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  __int16 v4; // bx

  v3 = sub_B35DB(a3 + a1 + 28, a2 + a1 + 28, (_BYTE *)a1, a3);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v4 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v4;
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B31D5) --------------------------------------------------------
void sub_B31D5()
{
  JUMPOUT(&loc_B335E);
}

//----- (000B336E) --------------------------------------------------------
void __fastcall sub_B336E(int a1, int a2)
{
  __int16 v2; // si

  v2 = *(_WORD *)(a2 + 8) ^ 0x8000;
  JUMPOUT(&loc_B3383);
}

//----- (000B337C) --------------------------------------------------------
int __usercall sub_B337C@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>)
{
  int v3; // ebx
  int v4; // esi
  int result; // eax
  int v6; // edx

  LOWORD(a3) = *(_WORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v4 = a3 << 16;
  LOWORD(v4) = *(_WORD *)(a1 + 8);
  result = sub_B33D6(*(_QWORD *)a1, *(_DWORD *)(a2 + 4), *(_DWORD *)a2, v4);
  *(_DWORD *)v3 = result;
  *(_DWORD *)(v3 + 4) = v6;
  *(_WORD *)(v3 + 8) = v4;
  return result;
}

//----- (000B33A6) --------------------------------------------------------
int __userpurge sub_B33A6@<eax>(int a1@<eax>, int a2@<esi>, int a3, int a4, __int16 a5)
{
  int v5; // esi
  int result; // eax
  int v7; // edx

  LOWORD(a2) = a5;
  v5 = a2 << 16;
  LOWORD(v5) = *(_WORD *)(a1 + 8);
  result = sub_B33D6(*(_QWORD *)a1, a4, a3, v5);
  *(_DWORD *)a3 = result;
  *(_DWORD *)(a3 + 4) = v7;
  *(_WORD *)(a3 + 8) = v5;
  return result;
}

//----- (000B33D6) --------------------------------------------------------
int __usercall sub_B33D6@<eax>(unsigned __int64 a1@<edx:eax>, int a2@<ecx>, int a3@<ebx>, int a4@<esi>)
{
  unsigned __int8 v4; // cf
  __int16 v5; // si
  int v6; // ecx
  int v7; // esi
  int v8; // et0
  int v9; // edi
  unsigned int v10; // ecx
  __int16 v11; // bp
  int v12; // edi
  int v13; // edi
  _BOOL1 v14; // cf
  int v15; // ecx
  int v16; // et1
  int v17; // et2
  int v18; // edi
  int v19; // ebx
  char v20; // ch
  int v21; // ebx
  int v22; // edi
  unsigned __int8 v23; // cf
  unsigned __int8 v24; // tt
  int v25; // ett
  int v26; // ett
  __int16 v27; // bp
  unsigned __int8 v28; // tt
  unsigned __int8 v29; // tt
  unsigned __int8 v30; // cf
  int v31; // eax
  unsigned __int8 v32; // tt
  int v33; // ett
  unsigned __int8 v34; // cf
  int v35; // ett
  int v37; // [esp-Ch] [ebp-Ch]

  if ( !a1 )
  {
    v4 = __CFADD__((_WORD)a4, (_WORD)a4);
    v5 = 2 * a4;
    if ( !v5 )
    {
      LODWORD(a1) = a3;
      return a1;
    }
    LOWORD(a4) = __RCR__(v5, v4);
  }
  if ( a2 || a3 || a4 & 0x7FFF0000 )
  {
    v8 = a2;
    v6 = a4;
    v7 = v8;
    v9 = __ROL4__(v6, 16) >> 16;
    v10 = (v6 >> 16) & 0x80007FFF;
    v11 = v10;
    v12 = __ROL4__(v9 & 0x80007FFF, 16);
    v10 = __ROL4__(v10, 16);
    LOWORD(v10) = v12 + v10;
    v13 = __ROL4__(v12, 16);
    v15 = __ROL4__(v10, 16);
    v14 = (unsigned __int16)v15 < (unsigned __int16)v13;
    LOWORD(v15) = v15 - v13;
    if ( !(_WORD)v15 )
      goto LABEL_42;
    if ( v14 )
    {
      v11 = v13;
      LOWORD(v15) = -(signed __int16)v15;
      v16 = a1;
      LODWORD(a1) = a3;
      a3 = v16;
      v17 = HIDWORD(a1);
      HIDWORD(a1) = v7;
      v7 = v17;
    }
    if ( (unsigned __int16)v15 > 0x40u )
    {
      LODWORD(a1) = a3;
    }
    else
    {
LABEL_42:
      BYTE1(v15) = 0;
      if ( v15 < 0 )
      {
        BYTE1(v15) = -1;
        a3 = -a3;
        v7 = -v7 - (a3 != 0);
      }
      v18 = 0;
      if ( (_BYTE)v15 )
      {
        v37 = a3;
        v19 = 0;
        if ( (unsigned __int8)v15 >= 0x20u )
        {
          LOBYTE(v19) = (_DWORD)a1 != 0;
          v18 = v19;
          if ( (_BYTE)v15 == 64 )
          {
            v18 = HIDWORD(a1) | v19;
            HIDWORD(a1) = 0;
          }
          a1 = HIDWORD(a1);
        }
        v18 |= __PAIR__(a1, 0) >> v15;
        LODWORD(a1) = a1 >> v15;
        HIDWORD(a1) = (unsigned __int64)HIDWORD(a1) >> v15;
        a3 = v37;
      }
      v4 = __CFADD__(__PAIR__(v7, a3), a1);
      a1 += __PAIR__(v7, a3);
      v20 = v4 + BYTE1(v15);
      if ( v20 < 0 )
      {
        if ( (_BYTE)v15 == 64 )
          a1 += (v18 & 0x7FFFFFFF) != 0;
        LODWORD(a1) = -(signed int)a1;
        HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);
        v20 = 0;
      }
      v21 = a1;
      LOBYTE(v21) = v20 | a1;
      if ( HIDWORD(a1) | v21 && v11 )
      {
        if ( v20 )
        {
LABEL_31:
          v27 = v11 + 1;
          if ( v27 == 0x7FFF )
            goto LABEL_43;
          v28 = __CFRCR__(HIDWORD(a1), 1);
          HIDWORD(a1) = __RCR__(HIDWORD(a1), 1);
          v4 = v28;
          v29 = __CFRCR__(a1, v28);
          LODWORD(a1) = __RCR__(a1, v4);
          if ( v29 )
          {
            v30 = __CFADD__(v18, v18);
            if ( !(2 * v18) )
            {
              v31 = __ROR4__(a1, 1);
              v32 = __CFSHL__(v31, 1);
              LODWORD(a1) = __ROL4__(v31, 1);
              v30 = v32;
            }
            v33 = v30;
            v4 = __CFADD__(v30, (_DWORD)a1);
            LODWORD(a1) = v33 + a1;
            v35 = v4;
            v34 = __CFADD__(v4, HIDWORD(a1));
            HIDWORD(a1) += v35;
            if ( v34 )
            {
              LODWORD(a1) = __RCR__(a1, __CFRCR__(HIDWORD(a1), v34));
              if ( v27 == 0x7FFE )
LABEL_43:
                LODWORD(a1) = 0;
            }
          }
        }
        else
        {
          v22 = __ROL4__(v18, 1);
          v24 = v22 & 1;
          v18 = __ROR4__(v22, 1);
          v23 = v24;
          while ( --v11 )
          {
            v25 = v23 + (_DWORD)a1;
            v4 = __CFADD__(v23, (_DWORD)a1) | __CFADD__((_DWORD)a1, v25);
            LODWORD(a1) = a1 + v25;
            v26 = v4 + HIDWORD(a1);
            v23 = __CFADD__(v4, HIDWORD(a1)) | __CFADD__(HIDWORD(a1), v26);
            HIDWORD(a1) += v26;
            if ( v23 )
              goto LABEL_31;
          }
        }
      }
    }
  }
  return a1;
}

//----- (000B3542) --------------------------------------------------------
int __fastcall sub_B3542(int a1, int a2)
{
  int v2; // esi
  _BOOL1 v3; // cf
  _BOOL1 v4; // zf
  int v5; // edi
  int v6; // eax
  int result; // eax
  int v8; // edi
  int v9; // eax

  if ( (*(_WORD *)(a1 + 8) | 0x8000) == -1 && *(_DWORD *)a1 | 2 * *(_DWORD *)(a1 + 4)
    || (*(_WORD *)(a2 + 8) | 0x8000) == -1 && *(_DWORD *)a2 | 2 * *(_DWORD *)(a2 + 4) )
  {
    return 2;
  }
  v2 = *(_DWORD *)(a1 + 6);
  if ( (v2 ^ *(_DWORD *)(a2 + 6)) >= 0 )
  {
    LOWORD(v2) = *(_WORD *)(a1 + 8);
    v3 = (unsigned __int16)v2 < *(_WORD *)(a2 + 8);
    v4 = (_WORD)v2 == *(_WORD *)(a2 + 8);
    if ( (_WORD)v2 == *(_WORD *)(a2 + 8) )
    {
      v3 = *(_QWORD *)a1 < *(_QWORD *)a2;
      v4 = *(_QWORD *)a1 == *(_QWORD *)a2;
    }
    v5 = 0;
    if ( v4 )
      return v5;
    v6 = __RCR__(a1, v3);
    v2 ^= v6;
    return -2 * __CFADD__(v2, v2) + 1;
  }
  v8 = *(_DWORD *)(a2 + 4) | *(_DWORD *)(a1 + 4) | *(_DWORD *)a2 | *(_DWORD *)a1;
  LOWORD(a1) = *(_WORD *)(a1 + 8);
  v9 = a1 << 16;
  LOWORD(v9) = *(_WORD *)(a2 + 8);
  result = v8 | v9 & 0x7FFF7FFF;
  if ( result )
    return -2 * __CFADD__(v2, v2) + 1;
  return result;
}

//----- (000B35DB) --------------------------------------------------------
int __usercall sub_B35DB@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebp>, int a4@<esi>)
{
  unsigned int v4; // ebx
  int v5; // esi
  int result; // eax
  int v7; // edx

  LOWORD(a4) = *(_WORD *)(a2 + 8);
  v4 = *(_DWORD *)a2;
  v5 = a4 << 16;
  LOWORD(v5) = *(_WORD *)(a1 + 8);
  result = sub_B3605(*(_QWORD *)a1, *(_DWORD *)(a2 + 4), *(_DWORD *)a2, a3, v5);
  *(_DWORD *)v4 = result;
  *(_DWORD *)(v4 + 4) = v7;
  *(_WORD *)(v4 + 8) = v5;
  return result;
}

//----- (000B3605) --------------------------------------------------------
int __usercall sub_B3605@<eax>(unsigned __int64 a1@<edx:eax>, int a2@<ecx>, unsigned int a3@<ebx>, _BYTE *a4@<ebp>, int a5@<esi>)
{
  _BOOL1 v5; // cf
  __int16 v6; // si
  int v7; // ecx
  signed int v8; // esi
  int v9; // et0
  int v10; // edi
  int v11; // ecx
  int v12; // edi
  int v13; // ecx
  unsigned __int16 v14; // di
  unsigned int v15; // ecx
  unsigned int v16; // edi
  unsigned int v17; // esi
  unsigned int v18; // ebx
  unsigned __int64 v19; // rax
  int v20; // ecx
  int v21; // et2
  unsigned __int64 v22; // rax
  int v23; // ecx
  int v24; // edi
  unsigned int i; // esi
  unsigned int v26; // edi
  int v27; // esi
  unsigned int v28; // eax
  unsigned __int64 v29; // rax
  int v30; // et1
  unsigned __int64 v31; // rax
  int v32; // ecx
  int v33; // edi
  unsigned int j; // esi
  unsigned __int16 v35; // di
  char v36; // cl
  _BYTE v38[12]; // [esp-20h] [ebp-20h]
  unsigned __int64 v39; // [esp-14h] [ebp-14h]
  unsigned __int16 v40; // [esp-Ch] [ebp-Ch]

  if ( a2 || a3 || a5 & 0x7FFF0000 )
  {
    if ( !a1 )
    {
      v5 = __CFADD__((_WORD)a5, (_WORD)a5);
      v6 = 2 * a5;
      if ( !v6 )
        return a1;
      LOWORD(a5) = __RCR__(v6, v5);
    }
    v9 = a2;
    v7 = a5;
    v8 = v9;
    v10 = __ROL4__((__ROL4__(v7, 16) >> 16) & 0x80007FFF, 16);
    v11 = __ROL4__((v7 >> 16) & 0x80007FFF, 16);
    LOWORD(v10) = v11 + v10;
    v12 = __ROL4__(v10, 16);
    v13 = __ROL4__(v11, 16);
    if ( !(_WORD)v12 )
    {
      do
      {
        a1 *= 2i64;
        LOWORD(v12) = v12 - 1;
      }
      while ( (a1 & 0x8000000000000000i64) == 0i64 );
    }
    if ( !(_WORD)v13 )
    {
      do
      {
        v8 = __PAIR__((unsigned int)v8, a3) >> 31;
        a3 *= 2;
        LOWORD(v13) = v13 - 1;
      }
      while ( v8 >= 0 );
    }
    v14 = v12 - v13 + 0x3FFF;
    if ( (v14 & 0x8000u) != 0 || v14 < 0x7FFFu )
    {
      if ( (signed __int16)v14 >= -64 )
      {
        v40 = v14;
        v39 = __PAIR__(v8, a3);
        v15 = v8;
        v16 = HIDWORD(a1);
        v17 = a1;
        LODWORD(a1) = 0;
        if ( v15 <= HIDWORD(a1) )
        {
          HIDWORD(a1) -= v15;
          LODWORD(a1) = 1;
        }
        *(_DWORD *)&v38[8] = a1;
        *(_DWORD *)&v38[4] = __PAIR__(HIDWORD(a1), v17) / v15;
        LODWORD(a1) = a3;
        v18 = __PAIR__(HIDWORD(a1), v17) / v15;
        v19 = v18 * (unsigned __int64)(unsigned int)a1;
        v21 = v19;
        LODWORD(v19) = v15;
        v20 = v21;
        v22 = HIDWORD(v19) + v18 * (unsigned __int64)(unsigned int)v19;
        if ( v38[8] & 1 )
          v22 += v39;
        v23 = -v20;
        v24 = (__PAIR__(v16, v17) - __PAIR__(HIDWORD(v22), (v23 != 0) + (unsigned int)v22)) >> 32;
        for ( i = v17 - ((v23 != 0) + v22); v24; v24 += (unsigned __int8)v5 )
        {
          --*(_QWORD *)&v38[4];
          v5 = __CFADD__(v39, __PAIR__(i, v23));
          i = (v39 + __PAIR__(i, v23)) >> 32;
          v23 += v39;
        }
        v26 = i;
        v27 = v23;
        if ( HIDWORD(v39) <= v26 )
        {
          v26 -= HIDWORD(v39);
          ++*(_QWORD *)&v38[4];
        }
        v28 = __PAIR__(v26, v23) / HIDWORD(v39);
        *(_DWORD *)v38 = v28;
        if ( v28 )
        {
          v29 = v28 * (unsigned __int64)(unsigned int)v39;
          v30 = v29;
          v31 = HIDWORD(v29) + (unsigned int)(__PAIR__(v26, v23) / HIDWORD(v39)) * (unsigned __int64)HIDWORD(v39);
          v32 = -v30;
          v33 = (__PAIR__(v26, v27) - __PAIR__(HIDWORD(v31), (v30 != 0) + (unsigned int)v31)) >> 32;
          for ( j = v27 - ((v30 != 0) + v31); v33; v33 += (unsigned __int8)v5 )
          {
            v5 = (*(_QWORD *)v38)-- < 1ui64;
            v38[8] -= v5;
            v5 = __CFADD__(v39, __PAIR__(j, v32));
            j = (v39 + __PAIR__(j, v32)) >> 32;
            v32 += v39;
          }
        }
        a1 = *(_QWORD *)v38;
        v35 = v40 - 1;
        if ( v38[8] & 1 )
        {
          HIDWORD(a1) = __RCR__(*(_DWORD *)&v38[4], v38[8] & 1);
          LODWORD(a1) = __RCR__(*(_DWORD *)v38, __CFRCR__(*(_DWORD *)&v38[4], v38[8] & 1));
          v35 = v40;
        }
        if ( (signed __int16)v35 <= 0 )
        {
          if ( v35 )
            v36 = -(char)v35;
          else
            v36 = 1;
          LODWORD(a1) = a1 >> v36;
        }
      }
      else
      {
        LODWORD(a1) = 0;
      }
    }
    else
    {
      LODWORD(a1) = 0;
    }
  }
  else if ( a1 || (WORD1(a1) = HIWORD(a5), 2 * (_WORD)a5) )
  {
    LOWORD(a1) = -31996;
    sub_B1E68(a1, 0, a4);
    LODWORD(a1) = 0;
  }
  else
  {
    LOWORD(a1) = -32511;
    sub_B1E68(a1, 0, a4);
    LODWORD(a1) = 0;
  }
  return a1;
}

//----- (000B37B0) --------------------------------------------------------
int __usercall sub_B37B0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>)
{
  unsigned int v3; // ebx
  int v4; // esi
  int result; // eax
  int v6; // edx

  LOWORD(a3) = *(_WORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v4 = a3 << 16;
  LOWORD(v4) = *(_WORD *)(a1 + 8);
  result = sub_B37DA(*(_QWORD *)a1, *(_DWORD *)(a2 + 4), *(_DWORD *)a2, v4);
  *(_DWORD *)v3 = result;
  *(_DWORD *)(v3 + 4) = v6;
  *(_WORD *)(v3 + 8) = v4;
  return result;
}

//----- (000B37DA) --------------------------------------------------------
int __usercall sub_B37DA@<eax>(unsigned __int64 a1@<edx:eax>, unsigned int a2@<ecx>, unsigned int a3@<ebx>, int a4@<esi>)
{
  _BOOL1 v4; // cf
  __int16 v5; // si
  int v6; // ecx
  unsigned int v7; // esi
  unsigned int v8; // et0
  unsigned int v9; // ecx
  unsigned __int16 v10; // cx
  unsigned int v11; // ST08_4
  unsigned __int64 v12; // ST00_8
  unsigned __int64 v13; // rax
  int v14; // esi
  int v15; // et1
  unsigned int v16; // ecx
  unsigned __int64 v17; // rax
  unsigned int v18; // ecx
  unsigned int v19; // edi
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // kr08_8
  int v22; // ebx
  unsigned __int16 v23; // cx
  _BOOL1 v24; // cf
  int v25; // ett
  unsigned __int8 v26; // cf
  int v27; // ett
  unsigned __int8 v28; // tt
  __int16 v29; // cx
  unsigned __int16 v31; // [esp-Ch] [ebp-Ch]

  if ( !a1 )
  {
    v4 = __CFADD__((_WORD)a4, (_WORD)a4);
    v5 = 2 * a4;
    if ( !v5 )
      return a1;
    LOWORD(a4) = __RCR__(v5, v4);
  }
  if ( a2 || a3 || a4 & 0x7FFF0000 )
  {
    v8 = a2;
    v6 = a4;
    v7 = v8;
    v9 = ((__ROL4__(v6, 16) >> 16) & 0x80007FFF) + ((v6 >> 16) & 0x80007FFF);
    v4 = (unsigned __int16)v9 < 0x3FFEu;
    v10 = v9 - 16382;
    if ( !v4 && v10 >= 0x7FFFu )
      goto LABEL_30;
    if ( (signed __int16)v10 < -64 )
    {
      LODWORD(a1) = 0;
      return a1;
    }
    v31 = v10;
    v11 = v7;
    v12 = a1;
    v13 = a3 * (unsigned __int64)(unsigned int)a1;
    v15 = v13;
    LODWORD(v13) = v7;
    v14 = v15;
    v16 = HIDWORD(v13);
    v17 = (unsigned int)v12 * (unsigned __int64)(unsigned int)v13;
    v4 = __CFADD__((unsigned int)v17, __PAIR__(HIDWORD(v17), v16));
    v19 = (v17 + v16) >> 32;
    v18 = v17 + v16;
    v20 = HIDWORD(v12) * (unsigned __int64)a3;
    v21 = v20 + __PAIR__(v19, v18);
    a1 = __PAIR__(
           __CFADD__(v20, __PAIR__(v19, v18)) + (unsigned int)(unsigned __int8)v4,
           (v20 + __PAIR__(v19, v18)) >> 32)
       + v11 * (unsigned __int64)HIDWORD(v12);
    v22 = v21;
    v23 = v31;
    if ( (a1 & 0x8000000000000000i64) == 0i64 )
    {
      v4 = __CFADD__(__PAIR__(a1, (unsigned int)v21), __PAIR__(a1, (unsigned int)v21));
      LODWORD(a1) = __PAIR__(a1, (unsigned int)v21) >> 31;
      v22 = 2 * v21;
      HIDWORD(a1) += (unsigned __int8)v4 + HIDWORD(a1);
      v23 = v31 - 1;
    }
    v24 = __CFADD__(v22, v22);
    if ( __CFADD__(v22, v22) )
    {
      if ( !(2 * v22) )
      {
        v24 = v14 != 0;
        if ( !v14 )
          v24 = a1 & 1;
      }
      v25 = (unsigned __int8)v24;
      v4 = __CFADD__((unsigned __int8)v24, (_DWORD)a1);
      LODWORD(a1) = v25 + a1;
      v27 = (unsigned __int8)v4;
      v26 = __CFADD__((unsigned __int8)v4, HIDWORD(a1));
      HIDWORD(a1) += v27;
      if ( v26 )
      {
        v28 = __CFRCR__(HIDWORD(a1), v26);
        HIDWORD(a1) = __RCR__(HIDWORD(a1), v26);
        LODWORD(a1) = __RCR__(a1, v28);
        if ( ++v23 == 0x7FFF )
        {
LABEL_30:
          LODWORD(a1) = 0;
          return a1;
        }
      }
    }
    if ( (signed __int16)v23 <= 0 )
    {
      if ( v23 )
        v29 = -v23;
      else
        LOBYTE(v29) = 1;
      LODWORD(a1) = a1 >> v29;
    }
  }
  else
  {
    LODWORD(a1) = 0;
  }
  return a1;
}

//----- (000B392B) --------------------------------------------------------
void sub_B392B()
{
  JUMPOUT(&loc_B3933);
}

//----- (000B3930) --------------------------------------------------------
int __fastcall sub_B3930(int *a1)
{
  __int16 v1; // cx
  unsigned __int8 v2; // of
  __int16 v3; // cx
  int v4; // ebx
  unsigned int v5; // eax
  unsigned __int8 v6; // cf
  char v7; // ch
  char v8; // cl
  char v9; // ch
  int result; // eax

  v1 = a1[2] & 0x7FFF;
  v2 = __OFSUB__(v1, 16382);
  v3 = v1 - 16382;
  if ( (v3 < 0) ^ v2 )
    return 0;
  if ( v3 > 32 || (char)v3 > 32 )
    return 2147483648;
  HIBYTE(v3) = (*((_BYTE *)a1 + 9) >> 1) | 0x20;
  v4 = *a1;
  v5 = a1[1];
  HIBYTE(v3) = __RCR__(HIBYTE(v3), __CFADD__(v4, v4));
  if ( (_BYTE)v3 == 32 )
  {
    v6 = __CFADD__(HIBYTE(v3), HIBYTE(v3));
    v7 = 2 * HIBYTE(v3);
  }
  else
  {
    v7 = 2 * HIBYTE(v3);
    v6 = __CFADD__(v5 << v3, v5 << v3);
    v5 = (unsigned __int64)v5 << v3 >> 32;
  }
  v8 = __RCR__(-1, v6);
  v9 = v8 & v7;
  result = __CFADD__(v9, v9) + v5;
  if ( __CFADD__(2 * v9, 2 * v9) )
    result = -result;
  return result;
}

//----- (000B399A) --------------------------------------------------------
int __fastcall sub_B399A(int a1, int a2)
{
  if ( a1 < 0 )
    JUMPOUT(&loc_B39B3);
  return sub_B39AB(a1, a2);
}

//----- (000B39AB) --------------------------------------------------------
int __fastcall sub_B39AB(unsigned int a1, int a2)
{
  int v2; // ebx
  int v3; // ecx
  unsigned int v4; // eax
  __int16 v5; // cx
  unsigned int v6; // edx
  int result; // eax

  v2 = a2;
  if ( a1 )
  {
    _BitScanReverse((unsigned int *)&v3, a1);
    v4 = a1 << (31 - v3);
    v5 = (unsigned __int8)v3 + 0x3FFF;
    v6 = v4;
  }
  else
  {
    v6 = 0;
    v5 = 0;
  }
  result = 0;
  *(_DWORD *)v2 = 0;
  *(_DWORD *)(v2 + 4) = v6;
  *(_WORD *)(v2 + 8) = v5;
  return result;
}

//----- (000B39E0) --------------------------------------------------------
int __usercall sub_B39E0@<eax>(__int64 a1@<edx:eax>, int a2@<ebx>, _BYTE *a3@<ebp>)
{
  int v3; // ecx
  signed __int64 v4; // rax
  int v5; // ecx
  _BOOL1 v6; // zf
  unsigned int v7; // ST00_4
  unsigned int v8; // edx
  int v9; // et0
  __int16 v10; // cx

  v3 = HIDWORD(a1);
  v4 = a1 << 11;
  v5 = v3 >> 20;
  LOWORD(v5) = v5 & 0x7FF;
  if ( (_WORD)v5 )
  {
    if ( (_WORD)v5 == 2047 )
    {
      LOWORD(v5) = 0x7FFF;
      v6 = (v4 & 0x7FFFFFFF00000000i64) == 0;
      if ( !(v4 & 0x7FFFFFFF00000000i64) )
        v6 = (_DWORD)v4 == 0;
      if ( !v6 )
      {
        v7 = v4;
        LOWORD(v4) = -32511;
        sub_B1E68(v4, v5, a3);
        v4 = __PAIR__(v8, v7) | 0x4000000000000000i64;
      }
    }
    else
    {
      LOWORD(v5) = v5 + 15360;
    }
    HIDWORD(v4) |= 0x80000000;
  }
  else if ( v4 )
  {
    LOWORD(v5) = 15361;
    if ( !HIDWORD(v4) )
    {
      v9 = v4;
      LODWORD(v4) = 0;
      HIDWORD(v4) = v9;
      LOWORD(v5) = 15329;
    }
    while ( v4 >= 0 )
    {
      v4 *= 2i64;
      LOWORD(v5) = v5 - 1;
    }
  }
  else
  {
    v5 = 0;
  }
  *(_QWORD *)a2 = v4;
  v10 = __RCR__(2 * v5, __CFADD__(v5, v5));
  *(_WORD *)(a2 + 8) = v10;
  return v4;
}

//----- (000B3A60) --------------------------------------------------------
int __fastcall sub_B3A60(int a1)
{
  int v1; // ebx
  signed int v2; // edx
  unsigned int v3; // eax
  unsigned int v4; // ecx
  unsigned __int8 v5; // cf
  int result; // eax
  __int16 v7; // bx
  __int16 v8; // cx
  unsigned __int64 v9; // rt0

  v1 = a1;
  v2 = -256;
  v3 = *(_DWORD *)(a1 + 4);
  v4 = v3 << 25;
  LOWORD(v4) = *(_WORD *)(v1 + 8);
  if ( __CFSHL__(v3, 25) )
  {
    if ( !(v3 << 25) && !*(_DWORD *)v1 )
      v2 = -512;
    v5 = __CFADD__(v3, 256);
    v3 += 256;
    if ( v5 )
    {
      v3 = 2147483648;
      LOWORD(v4) = v4 + 1;
    }
  }
  result = v2 & v3;
  v7 = v4;
  v8 = v4 & 0x7FFF;
  if ( v8 )
  {
    if ( v8 == 0x7FFF )
    {
      result = __RCR__(((unsigned int)(2 * result) >> 8) | 0xFF000000, __CFADD__(v7, v7));
    }
    else
    {
      LOWORD(v4) = v8 - 16256;
      if ( (v4 & 0x8000u) == 0 )
      {
        if ( (signed __int16)v4 < 255 )
        {
          LODWORD(v9) = 2 * result;
          HIDWORD(v9) = v4;
          result = __RCR__(v9 >> 8, __CFADD__(v7, v7));
        }
        else
        {
          result = __RCR__(-16777216, __CFADD__(v7, v7));
        }
      }
      else
      {
        result = 0;
      }
    }
  }
  return result;
}

//----- (000B3ADF) --------------------------------------------------------
int __usercall sub_B3ADF@<eax>(__int64 *a1@<eax>, _BYTE *a2@<ebp>)
{
  __int16 v2; // cx
  unsigned __int64 v3; // rax
  signed int v4; // esi
  unsigned __int8 v5; // cf
  unsigned __int16 v6; // cx
  int result; // eax
  unsigned __int8 v8; // cl
  int v9; // ST00_4

  v2 = *((_WORD *)a1 + 4);
  v3 = *a1;
  v4 = -2048;
  if ( __CFSHL__(v3, 22) )
  {
    if ( !((_DWORD)v3 << 22) )
      v4 = -4096;
    v5 = __CFADD__(v3, 2048i64);
    v3 += 2048i64;
    if ( v5 )
    {
      HIDWORD(v3) = 2147483648;
      ++v2;
    }
  }
  LODWORD(v3) = v4 & v3;
  v6 = (v2 & 0x7FFF) - 15360;
  if ( v6 >= 0x7FFu )
  {
    if ( v6 < 0xC400u )
    {
      result = v3 >> 11;
      if ( v6 != 17407 )
      {
        v9 = result;
        LOWORD(result) = -31736;
        sub_B1E68(result, v6, a2);
        result = v9;
      }
    }
    else if ( (signed __int16)v6 < -52 )
    {
      result = 0;
    }
    else
    {
      v8 = 12 - v6;
      if ( v8 >= 0x20u )
      {
        v8 -= 32;
        v4 = v3;
        v3 = HIDWORD(v3);
      }
      result = ((unsigned int)(__PAIR__(v3, v4) >> v8)
              + __PAIR__(v3 >> (v8 & 0x1F), (unsigned int)(__PAIR__(v3, v4) >> v8))) >> 32;
    }
  }
  else if ( v6 )
  {
    result = v3 >> 11;
  }
  else
  {
    result = v3 >> 12;
  }
  return result;
}

//----- (000B3BA6) --------------------------------------------------------
signed int __fastcall sub_B3BA6(signed int result, int a2)
{
  signed int v2; // ecx
  signed int v3; // eax

  v2 = result >> 23;
  LOWORD(v2) = (unsigned __int8)(result >> 23);
  if ( (unsigned __int8)(result >> 23) )
  {
    v3 = result << 8;
    if ( (_BYTE)v2 == -1 )
    {
      LOWORD(v2) = -1;
      v3 &= 0x7FFFFFFFu;
      if ( v3 )
        v3 |= 0x40000000u;
    }
    else
    {
      LOWORD(v2) = v2 + 16256;
    }
    LOWORD(v2) = __RCR__(2 * v2, __CFADD__(v2, v2));
    result = v3 | 0x80000000;
  }
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = result;
  *(_WORD *)(a2 + 8) = v2;
  return result;
}

//----- (000B3C6B) --------------------------------------------------------
unsigned int __fastcall sub_B3C6B(unsigned int result, signed __int16 a2)
{
  unsigned int v2; // edi
  int v3; // ebx
  _BOOL1 v4; // zf
  __int16 v5; // bx
  unsigned __int8 v6; // of
  __int16 v7; // bx
  int v8; // ecx
  _BOOL1 v9; // sf
  int v10; // eax
  unsigned int v11; // ecx
  unsigned __int8 v12; // tt
  _BOOL1 v13; // zf
  unsigned __int8 v14; // cf
  int v15; // et0
  int v16; // esi
  int v17; // eax
  unsigned int v18; // esi
  unsigned __int8 v19; // tt
  _BOOL1 v20; // zf
  unsigned __int8 v21; // cf
  int v22; // et0

  v2 = result;
  v3 = *(unsigned __int16 *)(result + 8);
  v4 = a2 == 1024;
  if ( a2 != 1024 )
    v4 = a2 == 2048;
  if ( v4 && (v3 & 0x8000) != 0 )
    a2 ^= 0xC00u;
  if ( a2 == 3072 )
    a2 = 1024;
  v5 = v3 & 0x7FFF;
  v6 = __OFSUB__(v5, 16447);
  v7 = v5 - 16447;
  if ( (v7 < 0) ^ v6 )
  {
    v8 = *(_DWORD *)result;
    v6 = __OFADD__(32, v7);
    v9 = (signed __int16)(v7 + 32) < 0;
    LOWORD(v3) = v7 + 32;
    if ( !((unsigned __int8)v9 ^ v6) )
    {
      v10 = dword_B3BEB[v3];
      v11 = v10 & v8;
      *(_DWORD *)v2 ^= v11;
      result = v10 + 1;
      if ( a2 == 1024 )
        return result;
      if ( !a2 )
      {
        v11 *= 2;
        if ( result > v11 )
          return result;
        if ( result == v11 )
        {
          v12 = __CFSHL__(result, 1);
          result = __ROL4__(result, 1);
          if ( v12 )
            v13 = (result & *(_DWORD *)(v2 + 4)) == 0;
          else
            v13 = (result & *(_DWORD *)v2) == 0;
          if ( v13 )
            return result;
          result = __ROR4__(result, 1);
        }
      }
      if ( v11 )
      {
        v14 = __CFADD__(result, *(_QWORD *)v2);
        *(_QWORD *)v2 += result;
        if ( v14 )
        {
          v15 = __RCR__(*(_DWORD *)(v2 + 4), v14);
          *(_DWORD *)(v2 + 4) = v15;
          ++*(_WORD *)(v2 + 8);
        }
      }
      return result;
    }
    *(_DWORD *)result = 0;
    v16 = *(_DWORD *)(result + 4);
    v6 = __OFADD__(32, (_WORD)v3);
    v9 = (signed __int16)(v3 + 32) < 0;
    LOWORD(v3) = v3 + 32;
    if ( (unsigned __int8)v9 ^ v6 )
    {
      if ( a2 != 1024 && (a2 || (_WORD)v3 == -1 && (v16 != 0x80000000 || v8)) )
      {
        *(_DWORD *)(result + 4) = 2147483648;
        *(_WORD *)(result + 8) |= 0x3FFFu;
      }
      else
      {
        result = 0;
        *(_DWORD *)(v2 + 4) = 0;
        *(_WORD *)(v2 + 8) = 0;
      }
      return result;
    }
    v17 = dword_B3BEB[v3];
    v18 = v17 & v16;
    *(_DWORD *)(v2 + 4) ^= v18;
    result = v17 + 1;
    if ( a2 == 1024 )
      return result;
    if ( !a2 )
    {
      v19 = __CFSHL__(v8, 1);
      v8 = __ROL4__(v8, 1);
      v18 += v19 + v18;
      if ( result > v18 )
        return result;
      if ( result == v18 )
      {
        if ( v8 )
        {
LABEL_35:
          v21 = __CFADD__(result, *(_DWORD *)(v2 + 4));
          *(_DWORD *)(v2 + 4) += result;
          if ( v21 )
          {
            v22 = __RCR__(*(_DWORD *)(v2 + 4), v21);
            *(_DWORD *)(v2 + 4) = v22;
            ++*(_WORD *)(v2 + 8);
          }
          return result;
        }
        v14 = __CFADD__(result, result);
        v20 = 2 * result == 0;
        result *= 2;
        if ( !v14 )
          v20 = (result & *(_DWORD *)(v2 + 4)) == 0;
        if ( v20 )
          return result;
        result >>= 1;
      }
    }
    if ( !(v18 | v8) )
      return result;
    goto LABEL_35;
  }
  return result;
}
// B3BEB: using guessed type int dword_B3BEB[];

//----- (000B3DF8) --------------------------------------------------------
__int16 __usercall sub_B3DF8@<ax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _BYTE *a4@<ebp>, int a5@<esi>)
{
  char v5; // ch
  char v6; // dl
  char v7; // ch

  if ( 2 * *(_WORD *)(a1 + 8) )
  {
    if ( 2 * *(_WORD *)(a2 + 8) )
    {
      v5 = *(_BYTE *)(a1 + 9);
      sub_B35DB(a1, a2, a4, a5);
      LOWORD(a1) = sub_B3EAE(a3, a4, a5);
      v6 = *(_BYTE *)(a3 + 9);
      if ( v7 < 0 )
      {
        if ( v6 > 0 )
          LOWORD(a1) = sub_B33A6(a3, a5, 560513589, -921707870, 49152);
      }
      else if ( v6 < 0 )
      {
        LOWORD(a1) = sub_B33A6(a3, a5, 560513589, -921707870, 0x4000);
      }
    }
    else
    {
      LOWORD(a1) = *(_WORD *)(a1 + 8) & 0x8000 | 0x3FFF;
      *(_WORD *)(a3 + 8) = a1;
      *(_DWORD *)(a3 + 4) = -921707870;
      *(_DWORD *)a3 = 560513589;
    }
  }
  else if ( *(_BYTE *)(a2 + 9) >= 0 )
  {
    *(_WORD *)(a3 + 8) = 0;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)a3 = 0;
  }
  else
  {
    *(_WORD *)(a3 + 8) = 0x4000;
    *(_DWORD *)(a3 + 4) = -921707870;
    *(_DWORD *)a3 = 560513589;
  }
  return a1;
}

//----- (000B3EAE) --------------------------------------------------------
__int16 __usercall __spoils<ecx> sub_B3EAE@<ax>(int a1@<eax>, _BYTE *a2@<ebp>, int a3@<esi>)
{
  int v3; // edi
  char v4; // cl
  __int16 result; // ax
  int v6; // edx
  unsigned __int16 v7; // ax
  unsigned __int8 v8; // cf
  _BOOL1 v9; // zf
  unsigned int v10; // eax
  int v11; // esi
  int v12; // edx
  int v13; // ST08_4
  int v14; // ST04_4
  int v15; // ST00_4
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rax
  int v18; // ebx
  int v19; // edx
  char v20; // cl
  unsigned __int8 v21; // ch
  char v22; // ch

  v3 = a1;
  v4 = *(_BYTE *)(a1 + 9);
  *(_BYTE *)(v3 + 9) &= 0x7Fu;
  if ( *(_WORD *)(a1 + 8) != 0x3FFF || *(_DWORD *)(a1 + 4) != 0x80000000 || *(_DWORD *)a1 )
  {
    if ( *(_WORD *)(a1 + 8) >= 0x3FFF )
    {
      LOWORD(a3) = *(_WORD *)(a1 + 8);
      a3 <<= 16;
      LOWORD(a3) = 0x3FFF;
      *(_DWORD *)a1 = sub_B3605(0x8000000000000000i64, *(_DWORD *)(a1 + 4), *(_DWORD *)a1, a2, a3);
      *(_DWORD *)(v3 + 4) = v6;
      *(_WORD *)(v3 + 8) = 0x3FFF;
    }
    v7 = *(_WORD *)(v3 + 8);
    v8 = v7 < 0x3FFDu;
    v9 = v7 == 16381;
    if ( v7 == 16381 )
    {
      v10 = *(_DWORD *)(v3 + 4);
      v8 = v10 < 0x8930A2F4;
      v9 = v10 == -1993301260;
      if ( v10 == -1993301260 )
      {
        v8 = *(_DWORD *)v3 < 0xF66AB09B;
        v9 = *(_DWORD *)v3 == -160780133;
      }
    }
    if ( !(v8 | (unsigned __int8)v9) )
    {
      HIWORD(v11) = 0x3FFF;
      LOWORD(v11) = *(_WORD *)(v3 + 8);
      v13 = sub_B33D6(*(_QWORD *)v3, -575416510, -1033546850, v11);
      v14 = v12;
      v15 = v11;
      HIWORD(v11) = 0x3FFF;
      LOWORD(v11) = *(_WORD *)(v3 + 8);
      LODWORD(v16) = sub_B37DA(*(_QWORD *)v3, 0xDDB3D742, 0xC265539E, v11);
      v11 = __ROL4__(v11, 16);
      LOWORD(v11) = -16385;
      v11 = __ROL4__(v11, 16);
      LODWORD(v17) = sub_B33D6(v16, 2147483648, 0, v11);
      v18 = v15 << 16;
      LOWORD(v18) = v11;
      a3 = v18;
      *(_DWORD *)v3 = sub_B3605(v17, v14, v13, a2, v18);
      *(_DWORD *)(v3 + 4) = v19;
      *(_WORD *)(v3 + 8) = v18;
    }
    result = sub_B4A2A((int *)v3, (int)&word_B3D9E, a3);
    v8 = v21 & 1;
    v22 = v21 >> 1;
    if ( v8 )
      result = sub_B33A6(v3, a3, 1805331491, -2046127679, 16382);
    if ( v22 & 1 )
    {
      result = sub_B33A6(v3, a3, 560513589, -921707870, 49151);
      *(_BYTE *)(v3 + 9) ^= 0x80u;
    }
    if ( v20 < 0 )
      *(_BYTE *)(v3 + 9) ^= 0x80u;
  }
  else
  {
    *(_DWORD *)a1 = 560513589;
    *(_DWORD *)(a1 + 4) = -921707870;
    LOBYTE(result) = -2;
    HIBYTE(result) = v4 & 0x80 | 0x3F;
    *(_WORD *)(v3 + 8) = result;
  }
  return result;
}
// B3D9E: using guessed type __int16 word_B3D9E;

//----- (000B4011) --------------------------------------------------------
int __usercall sub_B4011@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>)
{
  int result; // eax
  int v4; // ST00_4
  __int16 v5; // si
  int v6; // edx

  if ( !*(_WORD *)(a1 + 8) && !*(_DWORD *)(a1 + 4) && !*(_DWORD *)a1 )
    return 0;
  if ( *(_WORD *)(a2 + 8) || *(_DWORD *)(a2 + 4) || *(_DWORD *)a2 )
  {
    v4 = a1;
    v5 = *(_WORD *)(a1 + 8);
    LOWORD(a3) = *(_WORD *)(a2 + 8);
    *(_DWORD *)a1 = sub_B4077(*(_QWORD *)a1, *(_DWORD *)(a2 + 4), *(_DWORD *)a2, a3, v5);
    *(_DWORD *)(v4 + 4) = v6;
    *(_WORD *)(v4 + 8) = v5;
    result = a3;
  }
  else
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_WORD *)(a1 + 8) = 0;
    result = 0;
  }
  return result;
}

//----- (000B4077) --------------------------------------------------------
int __usercall sub_B4077@<eax>(__int64 a1@<edx:eax>, unsigned int a2@<ecx>, unsigned int a3@<ebx>, __int16 a4@<di>, __int16 a5@<si>)
{
  int v5; // esi
  int v6; // edi
  unsigned __int8 v7; // of
  int v8; // esi
  int v9; // edi
  _BOOL1 v10; // cf
  int v11; // esi
  int v12; // ett

  v5 = a5 & 0x7FFF;
  v6 = a4 & 0x7FFF;
  v7 = __OFSUB__(v5, v6);
  v8 = v5 - v6;
  if ( !((v8 < 0) ^ v7) )
  {
    v9 = 0;
LABEL_3:
    v10 = a2 < HIDWORD(a1);
    if ( a2 == HIDWORD(a1) && (v10 = a3 < (unsigned int)a1, a3 == (_DWORD)a1) || v10 )
    {
LABEL_6:
      a1 -= __PAIR__(a2, a3);
      v10 = 1;
    }
    while ( 1 )
    {
      v9 += (unsigned __int8)v10 + v9;
      v7 = __OFSUB__(v8--, 1);
      if ( (v8 < 0) ^ v7 )
        break;
      v10 = __CFADD__(a1, a1);
      a1 *= 2i64;
      if ( v10 )
        goto LABEL_6;
      v10 = 0;
      if ( a1 < 0 )
        goto LABEL_3;
    }
    v11 = 0;
    if ( a1 )
    {
      while ( a1 >= 0 )
      {
        v12 = (a1 + (unsigned __int64)(unsigned int)a1) >> 32;
        LODWORD(a1) = 2 * a1;
        HIDWORD(a1) += v12;
        --v11;
      }
    }
  }
  return a1;
}

//----- (000B41E0) --------------------------------------------------------
int __usercall sub_B41E0@<eax>(int a1@<eax>, _BYTE *a2@<ebp>, int a3@<esi>)
{
  int v3; // ST0C_4

  v3 = a1;
  sub_B33A6(a1, a3, 0, 2147483648, 0x3FFF);
  return sub_B41F9(v3, a2, a3);
}

//----- (000B41F9) --------------------------------------------------------
int __usercall sub_B41F9@<eax>(int a1@<eax>, _BYTE *a2@<ebp>, int a3@<esi>)
{
  int v3; // ST00_4
  int v4; // eax
  int v5; // edx
  int v6; // ST00_4
  int v7; // esi
  int result; // eax
  int v9; // edx

  v3 = a1;
  sub_B423C(a1, a2);
  v4 = v3;
  v6 = v5;
  sub_B37B0(v4, v5, a3);
  LOWORD(a3) = *(_WORD *)(v6 + 8);
  v7 = a3 << 16;
  LOWORD(v7) = 0x3FFF;
  result = sub_B37DA(0xB8AA3B295C17F0BDi64, *(_DWORD *)(v6 + 4), *(_DWORD *)v6, v7);
  *(_DWORD *)v6 = result;
  *(_DWORD *)(v6 + 4) = v9;
  *(_WORD *)(v6 + 8) = 0x3FFF;
  return result;
}

//----- (000B423C) --------------------------------------------------------
int __usercall sub_B423C@<eax>(int a1@<eax>, _BYTE *a2@<ebp>)
{
  int v2; // edi
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rax
  _BOOL1 v5; // cf
  _BOOL1 v6; // zf
  unsigned __int64 v7; // kr00_8
  int v8; // esi
  int v9; // eax
  int v10; // edx
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // kr08_8
  int v13; // edx
  unsigned int v14; // eax
  int v15; // edx
  unsigned int v16; // ST08_4
  int v17; // ST04_4
  int v18; // eax
  int v19; // edx
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // rax
  int v24; // esi
  int result; // eax
  int v26; // edx
  int v27; // ecx
  int v28; // ST18_4
  int v29; // ST14_4
  __int16 v30; // ST10_2
  int v31; // esi
  unsigned __int64 v32; // rax
  int v33; // edx
  int v34; // ST18_4
  int v35; // ST14_4
  __int16 v36; // ST10_2
  int v37; // esi
  unsigned __int64 v38; // rax
  int v39; // [esp+Ch] [ebp-18h]

  v2 = a1;
  v39 = *(unsigned __int16 *)(a1 + 8) - 16382;
  *(_WORD *)(a1 + 8) = 16382;
  LODWORD(v3) = *(_DWORD *)a1;
  HIDWORD(v3) = *(_DWORD *)(v2 + 4);
  LODWORD(v4) = sub_B33D6(v3, 2147483648, 0, -1073856514);
  v5 = *(_WORD *)(v2 + 8) < 0x3FFEu;
  v6 = *(_WORD *)(v2 + 8) == 16382;
  if ( *(_WORD *)(v2 + 8) == 16382 )
  {
    v5 = *(_DWORD *)(v2 + 4) < 0xB504F333;
    v6 = *(_DWORD *)(v2 + 4) == -1257966797;
    if ( *(_DWORD *)(v2 + 4) == -1257966797 )
    {
      v5 = *(_DWORD *)v2 < 0xF9DE6484;
      v6 = *(_DWORD *)v2 == -102865788;
    }
  }
  if ( (unsigned __int8)v5 | (unsigned __int8)v6 )
  {
    *(_QWORD *)v2 = v4;
    *(_WORD *)(v2 + 8) = 16382;
    --v39;
  }
  else
  {
    LODWORD(v4) = sub_B33D6(v4, 2147483648, 0, -1073856514);
  }
  v7 = v4;
  v8 = (unsigned __int16)(*(_WORD *)(v2 + 8) - 1) | 0x3FFE0000;
  v9 = sub_B33D6(*(_QWORD *)v2, 2147483648, 0, v8);
  v8 <<= 16;
  LOWORD(v8) = 16382;
  LODWORD(v11) = sub_B3605(v7, v10, v9, a2, v8);
  v12 = v11;
  v8 <<= 16;
  LOWORD(v8) = 16382;
  *(_DWORD *)v2 = sub_B37DA(v11, HIDWORD(v11), v11, v8);
  *(_DWORD *)(v2 + 4) = v13;
  *(_WORD *)(v2 + 8) = 16382;
  sub_B49D8((int)&dword_B41B8, v8);
  v16 = v14;
  v17 = v15;
  v18 = *(_DWORD *)v2;
  v19 = *(_DWORD *)(v2 + 4);
  LOWORD(v8) = *(_WORD *)(v2 + 8);
  sub_B49D8((int)&word_B419A, v8);
  v8 = __ROL4__(v8, 16);
  LOWORD(v8) = 16382;
  v8 = __ROL4__(v8, 16);
  LODWORD(v21) = sub_B3605(v20, v17, v16, a2, v8);
  v8 = __ROL4__(v8, 16);
  LOWORD(v8) = *(_WORD *)(v2 + 8);
  v8 = __ROL4__(v8, 16);
  LODWORD(v22) = sub_B37DA(v21, *(_DWORD *)(v2 + 4), *(_DWORD *)v2, v8);
  v8 = __ROL4__(v8, 16);
  LOWORD(v8) = 16382;
  v8 = __ROL4__(v8, 16);
  LODWORD(v23) = sub_B37DA(v22, HIDWORD(v12), v12, v8);
  v8 = __ROL4__(v8, 16);
  LOWORD(v8) = 16382;
  v24 = __ROL4__(v8, 16);
  result = sub_B33D6(v23, SHIDWORD(v12), v12, v24);
  v27 = v39;
  if ( v39 )
  {
    v28 = result;
    v29 = v26;
    v30 = v24;
    sub_B399A(v27, v2);
    v31 = *(unsigned __int16 *)(v2 + 8) | 0xBFF20000;
    LODWORD(v32) = sub_B37DA(*(_QWORD *)v2, 0xDE8082E3, 0x865435Cu, v31);
    v31 = __ROL4__(v31, 16);
    LOWORD(v31) = v30;
    v31 = __ROL4__(v31, 16);
    v34 = sub_B33D6(v32, v29, v28, v31);
    v35 = v33;
    v36 = v31;
    v37 = *(unsigned __int16 *)(v2 + 8) | 0x3FFE0000;
    LODWORD(v38) = sub_B37DA(*(_QWORD *)v2, 0xB1800000, 0, v37);
    v37 = __ROL4__(v37, 16);
    LOWORD(v37) = v36;
    v24 = __ROL4__(v37, 16);
    result = sub_B33D6(v38, v35, v34, v24);
  }
  *(_DWORD *)v2 = result;
  *(_DWORD *)(v2 + 4) = v26;
  *(_WORD *)(v2 + 8) = v24;
  return result;
}
// B419A: using guessed type __int16 word_B419A;
// B41B8: using guessed type int dword_B41B8;

//----- (000B44D4) --------------------------------------------------------
int __usercall sub_B44D4@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // ST10_4
  __int16 v3; // si
  int v4; // edx
  char v5; // al
  int v6; // edi
  int v7; // esi
  __int16 v8; // ax
  int v9; // ecx
  __int16 v10; // ax
  __int16 v11; // ST04_2
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rax
  int v14; // esi
  char v15; // cl
  _BOOL1 v16; // zf
  int v17; // ecx
  unsigned int v18; // ebx
  int v20; // [esp+0h] [ebp-18h]
  int v21; // [esp+0h] [ebp-18h]
  int v22; // [esp+4h] [ebp-14h]
  __int16 v23; // [esp+4h] [ebp-14h]
  unsigned __int64 v24; // [esp+Ch] [ebp-Ch]
  signed __int16 v25; // [esp+14h] [ebp-4h]
  _BYTE savedregs[20]; // [esp+18h] [ebp+0h]

  v2 = (unsigned __int16)((*(_WORD *)(a1 + 8) & 0x7FFF) - 16382);
  v22 = a2;
  v20 = a1;
  v3 = *(_WORD *)(a1 + 8);
  *(_DWORD *)a1 = sub_B4077(*(_QWORD *)a1, 0xC90FDAA2, 0x2168C235u, 16382, v3);
  *(_DWORD *)(v20 + 4) = v4;
  *(_WORD *)(v20 + 8) = v3;
  v5 = -2;
  v6 = v20;
  v7 = v22;
  if ( *(_BYTE *)(v20 + 9) < 0 )
  {
    sub_B33A6(v20, v22, 560513589, -921707870, 16382);
    v5 = -3;
  }
  HIBYTE(v8) = v22;
  LOBYTE(v8) = ((v22 & 2) + v5) & 7;
  v23 = v8;
  if ( v8 & 1 )
  {
    sub_B33A6(v6, v7, 560513589, -921707870, 49150);
    *(_BYTE *)(v6 + 9) ^= 0x80u;
  }
  v9 = (unsigned __int16)(*(_WORD *)(v6 + 8) - 16382);
  if ( (signed __int16)v9 >= -32 )
  {
    if ( (v9 & 0x8000u) == 0 )
      LOWORD(v9) = 0;
    LOWORD(v9) = -(signed __int16)v9;
    if ( (signed __int16)v9 > 8 )
      LOWORD(v9) = 8;
    LOWORD(v9) = word_B44C2[v9];
    v21 = v9;
    HIBYTE(v10) = HIBYTE(v23);
    LOBYTE(v10) = (v23 + 1) & 2;
    if ( (_BYTE)v10 || HIBYTE(v23) == 1 )
    {
      v11 = v10;
      LOWORD(v7) = *(_WORD *)(v6 + 8);
      v7 <<= 16;
      LOWORD(v7) = *(_WORD *)(v6 + 8);
      sub_B37DA(*(_QWORD *)v6, *(_DWORD *)(v6 + 4), *(_DWORD *)v6, v7);
      sub_B49D8((int)dword_B4468 + 10 * v21, v7);
      v24 = v12;
      v25 = v7;
      v10 = v11;
    }
    if ( !(_BYTE)v10 || HIBYTE(v10) == 1 )
      sub_B4A2A((int *)v6, (int)&word_B440E[5 * v21], v7);
  }
  else
  {
    v24 = 0x8000000000000000i64;
    v25 = 0x3FFF;
  }
  if ( ((_BYTE)v23 + 1) & 2 )
  {
    v13 = v24;
    LOWORD(v7) = v25;
  }
  else
  {
    v13 = *(_QWORD *)v6;
    LOWORD(v7) = *(_WORD *)(v6 + 8);
  }
  if ( v23 & 4 )
    LOWORD(v7) = v7 ^ 0x8000;
  if ( HIBYTE(v23) == 1 )
  {
    v14 = __ROL4__(v7, 16);
    v15 = v23 + 2;
    if ( ((_BYTE)v23 + 3) & 2 )
    {
      v16 = (v15 & 4) == 0;
      v17 = HIDWORD(v24);
      v18 = v24;
      LOWORD(v14) = v25;
    }
    else
    {
      v16 = (v15 & 4) == 0;
      v18 = *(_DWORD *)v6;
      v17 = *(_DWORD *)(v6 + 4);
      LOWORD(v14) = *(_WORD *)(v6 + 8);
    }
    if ( !v16 )
      v14 ^= 0x8000u;
    v7 = __ROL4__(v14, 16);
    if ( v18 || v17 || v7 & 0x7FFF0000 )
    {
      LODWORD(v13) = sub_B3605(v13, v17, v18, savedregs, v7);
    }
    else
    {
      v13 = 0x8000000000000000i64;
      LOWORD(v7) = v7 | 0x7FFF;
    }
  }
  *(_QWORD *)v6 = v13;
  *(_WORD *)(v6 + 8) = v7;
  return v13;
}
// B440E: using guessed type __int16 word_B440E[];
// B4468: using guessed type int dword_B4468[19];
// B44C2: using guessed type __int16 word_B44C2[];

//----- (000B46CB) --------------------------------------------------------
int __fastcall sub_B46CB(int a1)
{
  return sub_B44D4(a1, 0);
}

//----- (000B46D5) --------------------------------------------------------
int __fastcall sub_B46D5(int a1)
{
  return sub_B44D4(a1, 2);
}

//----- (000B46E2) --------------------------------------------------------
int __fastcall sub_B46E2(int a1)
{
  return sub_B44D4(a1, 1);
}

//----- (000B4718) --------------------------------------------------------
int __fastcall sub_B4718(int a1, int a2, int a3, int a4)
{
  int v4; // edi
  signed int v5; // esi
  __int16 v6; // cx
  _BOOL1 v7; // zf
  unsigned __int16 v8; // bx
  int v9; // ecx
  signed __int64 v10; // rax
  unsigned __int8 v11; // cf
  __int16 v12; // bx
  int v13; // esi
  unsigned __int64 v14; // rax
  int v15; // esi
  unsigned __int64 v16; // rax
  signed __int32 v17; // edx
  int v18; // esi
  unsigned __int64 v19; // rax
  int v20; // esi
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // rax
  int v23; // esi
  unsigned __int64 v24; // rax
  signed __int32 v25; // edx
  int v26; // esi
  unsigned __int64 v27; // rax
  int v28; // eax
  int v29; // edx
  unsigned int v30; // ecx
  int (*v31)(); // esi
  int v32; // eax
  unsigned __int64 v33; // rax
  int v34; // et0
  int v35; // edx
  int v36; // esi
  int v38; // [esp-2Ch] [ebp-38h]
  int v39; // [esp-28h] [ebp-34h]
  unsigned int v40; // [esp-24h] [ebp-30h]
  int v41; // [esp-20h] [ebp-2Ch]
  int v42; // [esp-1Ch] [ebp-28h]
  int v43; // [esp-18h] [ebp-24h]
  int v44; // [esp-14h] [ebp-20h]
  int v45; // [esp-10h] [ebp-1Ch]
  int v46; // [esp-8h] [ebp-14h]

  v46 = a4;
  v4 = a1;
  v5 = 0;
  v6 = *(_WORD *)(a1 + 8);
  *(_BYTE *)(v4 + 9) &= 0x7Fu;
  v7 = *(_WORD *)(a1 + 8) == 0;
  if ( !*(_WORD *)(a1 + 8) )
    v7 = *(_QWORD *)a1 == 0i64;
  if ( v7 )
  {
    v9 = 0;
  }
  else
  {
    if ( v6 < 0 )
    {
      v5 = -1;
      sub_B33A6(a1, -1, 0, 2147483648, 49151);
      *(_BYTE *)(v4 + 9) ^= 0x80u;
    }
    v8 = *(_WORD *)(v4 + 8) + 4;
    v9 = 0;
    v10 = *(_QWORD *)v4;
    while ( v8 >= 0x3FFFu )
    {
      v11 = __CFADD__(v10, v10);
      v10 *= 2i64;
      v9 += v11 + v9;
      --v8;
    }
    if ( v10 )
    {
      while ( v10 >= 0 )
      {
        v10 *= 2i64;
        --v8;
      }
      v12 = v8 - 4;
    }
    else
    {
      v12 = 0;
    }
    *(_QWORD *)v4 = v10;
    *(_WORD *)(v4 + 8) = v12;
  }
  v45 = v5;
  v44 = v9;
  LOWORD(v5) = *(_WORD *)(v4 + 8);
  v13 = v5 << 16;
  LOWORD(v13) = *(_WORD *)(v4 + 8);
  LODWORD(v14) = sub_B37DA(*(_QWORD *)v4, *(_DWORD *)(v4 + 4), *(_DWORD *)v4, v13);
  v42 = HIDWORD(v14);
  v43 = v14;
  v41 = v13;
  v15 = (unsigned __int16)v13 | 0x40030000;
  LODWORD(v16) = _InterlockedExchange(&v43, sub_B33D6(v14, -1501390215, 468852620, v15));
  HIDWORD(v16) = _InterlockedExchange(&v42, v17);
  v18 = (unsigned __int16)_InterlockedExchange(&v41, v15) | 0x3FFA0000;
  LODWORD(v19) = sub_B37DA(v16, 0xEC96F0D6, 0x9D7BFDBu, v18);
  v20 = (unsigned __int16)v18 | 0x40010000;
  LODWORD(v21) = sub_B33D6(v19, -422247142, -449388153, v20);
  v20 = __ROL4__(v20, 16);
  LOWORD(v20) = *(_WORD *)(v4 + 8);
  v20 = __ROL4__(v20, 16);
  LODWORD(v22) = sub_B37DA(v21, *(_DWORD *)(v4 + 4), *(_DWORD *)v4, v20);
  v39 = HIDWORD(v22);
  v40 = v22;
  v38 = v20;
  v23 = __ROL4__(v20 ^ 0x8000, 16);
  LOWORD(v23) = v41;
  v23 = __ROL4__(v23, 16);
  LODWORD(v24) = _InterlockedExchange((volatile signed __int32 *)&v40, sub_B33D6(v22, v42, v43, v23));
  HIDWORD(v24) = _InterlockedExchange(&v39, v25);
  v26 = __ROL4__(_InterlockedExchange(&v38, v23), 16);
  LOWORD(v26) = v41;
  v26 = __ROL4__(v26, 16);
  LODWORD(v27) = sub_B33D6(v24, v42, v43, v26);
  v26 = __ROL4__(v26, 16);
  LOWORD(v26) = v38;
  v26 = __ROL4__(v26, 16);
  v28 = sub_B3605(v27, v39, v40, &v41, v26);
  *(_DWORD *)v4 = v28;
  *(_DWORD *)(v4 + 4) = v29;
  *(_WORD *)(v4 + 8) = v26;
  v30 = v44;
  v31 = sub_B46F0;
  while ( v30 )
  {
    v11 = v30 & 1;
    v30 >>= 1;
    if ( v11 )
    {
      v44 = v30;
      v43 = (int)v31;
      LOWORD(v28) = *(_WORD *)(v4 + 8);
      v32 = v28 << 16;
      LOWORD(v32) = *((_WORD *)v31 + 4);
      HIDWORD(v33) = *((_DWORD *)v31 + 1);
      v34 = v32;
      LODWORD(v33) = *(_DWORD *)v31;
      v28 = sub_B37DA(v33, *(_DWORD *)(v4 + 4), *(_DWORD *)v4, v34);
      *(_DWORD *)v4 = v28;
      *(_DWORD *)(v4 + 4) = v35;
      *(_WORD *)(v4 + 8) = v34;
      v31 = (int (*)())v43;
      v30 = v44;
    }
    v31 = (int (*)())((char *)v31 + 10);
  }
  v36 = v45;
  *(_WORD *)(v4 + 8) += v45;
  return sub_B33A6(v4, v36, 0, 2147483648, 49151);
}
// B46F0: using guessed type int sub_B46F0();

//----- (000B48EC) --------------------------------------------------------
int __fastcall sub_B48EC(unsigned __int64 a1)
{
  __int16 v1; // cx
  unsigned int v2; // ebx
  unsigned __int16 v3; // cx
  __int16 v4; // cx
  unsigned int v5; // edi
  __int16 v6; // cx
  __int16 v7; // cx
  unsigned __int8 v8; // tt
  unsigned int v9; // ecx
  unsigned int v10; // esi
  unsigned int v11; // eax
  unsigned int v12; // edx
  unsigned __int64 v13; // rt2
  unsigned int v14; // esi
  int v15; // esi
  unsigned int v16; // ecx
  int v17; // eax
  unsigned __int8 v18; // cf
  unsigned __int8 v19; // tt
  int v20; // eax
  unsigned __int8 v21; // tt
  _DWORD *v23; // [esp-10h] [ebp-18h]

  v1 = *(_WORD *)(a1 + 8);
  v2 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
    goto LABEL_7;
  if ( *(_DWORD *)(a1 + 4) )
  {
    if ( v1 == 0x7FFF )
      return a1;
LABEL_7:
    if ( (v1 & 0x7FFF) == 0x7FFF )
      goto LABEL_5;
    v18 = __CFADD__(v1, v1);
    v3 = 2 * v1;
    if ( v18 )
      goto LABEL_5;
    v4 = v3 >> 1;
    if ( v4 && !__CFADD__(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 4)) )
    {
LABEL_4:
      *(_WORD *)(a1 + 8) = -1;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = 0;
LABEL_5:
      *(_BYTE *)(a1 + 7) |= 0xC0u;
      return a1;
    }
    HIDWORD(a1) = *(_DWORD *)(a1 + 4);
    v5 = 0;
    v23 = (_DWORD *)a1;
    v6 = v4 - 0x3FFF;
    v18 = v6 & 1;
    v7 = v6 >> 1;
    if ( !v18 )
    {
      v18 = BYTE4(a1) & 1;
      HIDWORD(a1) >>= 1;
      v8 = __CFRCR__(v2, v18);
      v2 = __RCR__(v2, v18);
      v5 = __RCR__(0, v8);
    }
    *(_WORD *)(a1 + 8) = v7 + 0x3FFF;
    v9 = HIDWORD(a1);
    LODWORD(a1) = v2;
    v10 = __RCR__(HIDWORD(a1)++, 1);
    if ( HIDWORD(a1) )
    {
      --HIDWORD(a1);
      while ( 1 )
      {
        v13 = a1 % v10;
        v11 = a1 / v10;
        v12 = v13;
        v14 = v10 - 1;
        if ( v14 <= v11 )
          break;
        v10 = __RCR__(v11 + v14 + 1, __CFADD__(v11, v14 + 1));
        a1 = __PAIR__(v9, v2);
      }
      v15 = v14 + 1;
      v16 = v11;
      v17 = __PAIR__(v12, v5) / (unsigned int)v15;
      v10 = v16 + v15;
    }
    else
    {
      v18 = v2 < v10;
      if ( v2 == v10 )
      {
LABEL_21:
        *v23 = a1;
        v23[1] = v10 + v18;
        return a1;
      }
      v17 = __PAIR__(v2, v5) / v10;
    }
    v19 = __CFRCR__(v10, 1);
    v10 = __RCR__(v10, 1);
    v18 = v19;
    v21 = __CFRCR__(v17, v19);
    v20 = __RCR__(v17, v18);
    v18 = __CFADD__(v21, v20);
    LODWORD(a1) = v21 + v20;
    goto LABEL_21;
  }
  if ( 2 * v1 )
    goto LABEL_4;
  return a1;
}

//----- (000B49D8) --------------------------------------------------------
void __usercall sub_B49D8(int a1@<ecx>, int a2@<esi>)
{
  int v2; // edi
  unsigned __int64 v3; // rax
  int v4; // esi
  unsigned __int64 v5; // rax
  unsigned int vars0; // [esp+0h] [ebp+0h]
  unsigned int vars4; // [esp+4h] [ebp+4h]
  __int16 vars8; // [esp+8h] [ebp+8h]
  int varsC; // [esp+Ch] [ebp+Ch]

  v2 = a1;
  v3 = *(_QWORD *)a1;
  LOWORD(a2) = *(_WORD *)(a1 + 8);
  do
  {
    v4 = __ROL4__(a2, 16);
    LOWORD(v4) = vars8;
    v4 = __ROL4__(v4, 16);
    LODWORD(v5) = sub_B37DA(v3, vars4, vars0, v4);
    v2 += 10;
    v4 = __ROL4__(v4, 16);
    LOWORD(v4) = *(_WORD *)(v2 + 8);
    a2 = __ROL4__(v4, 16);
    LODWORD(v3) = sub_B33D6(v5, *(_DWORD *)(v2 + 4), *(_DWORD *)v2, a2);
    --varsC;
  }
  while ( varsC );
}

//----- (000B4A2A) --------------------------------------------------------
int __usercall sub_B4A2A@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<esi>)
{
  int v3; // ST00_4
  int *v4; // edi
  unsigned __int64 v5; // rax
  int v6; // esi
  unsigned __int64 v7; // rax
  int result; // eax
  int v9; // edx

  v3 = a2;
  v4 = a1;
  LODWORD(v5) = *a1;
  HIDWORD(v5) = v4[1];
  LOWORD(a3) = *((_WORD *)v4 + 4);
  v6 = a3 << 16;
  LOWORD(v6) = *((_WORD *)v4 + 4);
  sub_B37DA(v5, v4[1], v5, v6);
  sub_B49D8(v3, v6);
  v6 = __ROL4__(v6, 16);
  LOWORD(v6) = *((_WORD *)v4 + 4);
  v6 = __ROL4__(v6, 16);
  result = sub_B37DA(v7, v4[1], *v4, v6);
  *v4 = result;
  v4[1] = v9;
  *((_WORD *)v4 + 4) = v6;
  return result;
}

//----- (000B4F46) --------------------------------------------------------
void __spoils<edx,ecx> sub_B4F46()
{
  if ( !word_E7C58 && byte_E3E28 )
  {
    if ( byte_E4CB2 )
    {
      if ( byte_E4CB2 == 1 )
      {
        _DOS4G_hook_init();
      }
      else if ( byte_E4CB2 == 9 )
      {
        _Intel_hook_init();
      }
      else
      {
        _Phar_hook_init();
      }
    }
    else
    {
      _Ergo_hook_init((unsigned __int16)__DS__, (unsigned __int16)__ES__);
    }
    sub_B5000();
  }
}
// B56EA: using guessed type int _Phar_hook_init(void);
// B57DA: using guessed type int _DOS4G_hook_init(void);
// B5820: using guessed type int __cdecl _Ergo_hook_init(_DWORD, _DWORD);
// B5878: using guessed type int _Intel_hook_init(void);
// E3E28: using guessed type char byte_E3E28;
// E4CB2: using guessed type char byte_E4CB2;
// E7C58: using guessed type __int16 word_E7C58;

//----- (000B4FA3) --------------------------------------------------------
void __spoils<edx,ecx> sub_B4FA3()
{
  if ( word_E7C58 )
  {
    if ( byte_E4CB2 )
    {
      if ( byte_E4CB2 == 1 )
      {
        _DOS4G_hook_fini();
      }
      else if ( byte_E4CB2 == 9 )
      {
        _Intel_hook_fini();
      }
      else
      {
        _Phar_hook_fini();
      }
    }
    else
    {
      _Ergo_hook_fini((unsigned __int16)__DS__);
    }
  }
}
// B57AD: using guessed type int _Phar_hook_fini(void);
// B5807: using guessed type int _DOS4G_hook_fini(void);
// B585E: using guessed type int __cdecl _Ergo_hook_fini(_DWORD);
// B58D0: using guessed type int _Intel_hook_fini(void);
// E4CB2: using guessed type char byte_E4CB2;
// E7C58: using guessed type __int16 word_E7C58;

//----- (000B5000) --------------------------------------------------------
void sub_B5000()
{
  ;
}

//----- (000B5015) --------------------------------------------------------
void __noreturn sub_B5015()
{
  __outbyte(0x20u, 0x20u);
  __outbyte(0xA0u, 0x20u);
  __outbyte(0xF0u, 0);
  sub_B5022();
}

//----- (000B5022) --------------------------------------------------------
void __noreturn sub_B5022()
{
  int v1; // [esp-24h] [ebp-40h]
  int v2; // [esp-8h] [ebp-24h]
  int v3; // [esp-4h] [ebp-20h]

  v3 = (unsigned __int16)__DS__;
  v2 = (unsigned __int16)__ES__;
  _EBP = &v1;
  __asm
  {
    fnstenv byte ptr [ebp+0]
    fclex
    fdisi
  }
  _enable();
  ((void (*)(void))_GETDS)();
}

//----- (000B5128) --------------------------------------------------------
void __usercall sub_B5128(__int16 a1@<bx>, int a2@<ebp>, double *a3@<edi>, double a4@<st0>)
{
  _BOOL1 v4; // zf

  if ( a1 != -9734 && a1 != -9743 )
  {
    v4 = a1 == -9736;
    if ( a1 != -9736 )
      v4 = a1 == -9739;
    if ( !v4 && (a1 & 0x310) != 784 )
    {
      if ( (a1 & 0x110) == 272 )
      {
        __asm
        {
          fstp    st
          fldz
        }
        if ( (a1 & 0xC0) != -64 )
          sub_B5250(a1, a3, a4);
        if ( a1 & 8 )
          __asm { fstp    st }
      }
      else if ( (a1 & 0x130) == 48 )
      {
        *(_WORD *)(a2 + 8);
      }
    }
  }
}
// B516D: inconsistent fpu stack

//----- (000B51B3) --------------------------------------------------------
void __usercall sub_B51B3(__int16 a1@<bx>, int a2@<ebp>, double *a3@<edi>, __int16 a4@<fpstat>, double a5@<st0>)
{
  __int16 v5; // dx
  double v6; // st7

  if ( a1 != -9731 )
  {
    if ( (a1 & 0x110) == 272 )
    {
      v6 = sub_B5205(SHIBYTE(a1), a2, a4, a5);
      if ( (a1 & 0xC0) != -64 )
        sub_B5250(a1, a3, v6);
      if ( a1 & 8 )
        __asm { fstp    st }
    }
    else if ( (a1 & 0xC0) == -64 )
    {
      HIBYTE(v5) = HIBYTE(a1) & 1;
      LOBYTE(v5) = a1 & 0xC0;
      sub_B522B(v5, a1, (int)&unk_E7C64);
    }
    else
    {
      sub_B5205(SHIBYTE(a1), a2, a4, a5);
    }
  }
}
// B51CB: inconsistent fpu stack

//----- (000B5205) --------------------------------------------------------
double __usercall sub_B5205@<st0>(char a1@<bh>, int a2@<ebp>, __int16 a3@<fpstat>, double a4@<st0>)
{
  _BOOL1 v4; // c0
  char v5; // c2
  _BOOL1 v6; // c3
  double result; // st7

  v4 = a4 < 0.0;
  v5 = 0;
  v6 = a4 == 0.0;
  *(_WORD *)(a2 + 20) = a3;
  if ( a1 & 4 )
    result = dbl_E7C6E;
  else
    result = flt_E7C76;
  if ( *(_WORD *)(a2 + 20) & 0x100 )
    result = -result;
  return result;
}
// E7C6E: using guessed type double dbl_E7C6E;
// E7C76: using guessed type float flt_E7C76;

//----- (000B522B) --------------------------------------------------------
__int64 __usercall sub_B522B@<edx:eax>(int a1@<edx>, __int16 a2@<bx>, int _ESI@<esi>)
{
  unsigned __int8 v3; // of
  __int64 result; // rax
  int v5; // [esp-4h] [ebp-4h]

  if ( a2 & 0x400 )
    LOBYTE(a1) = a2 & 7;
  else
    LOBYTE(a1) = 0;
  v5 = a1;
  while ( 1 )
  {
    v3 = __OFSUB__((_BYTE)a1, 1);
    LOBYTE(a1) = a1 - 1;
    if ( ((a1 & 0x80u) != 0) ^ v3 )
      break;
    __asm { fincstp }
  }
  __asm
  {
    fstp    st
    fld     tbyte ptr [esi]
  }
  HIDWORD(result) = v5;
  while ( 1 )
  {
    v3 = __OFSUB__(BYTE4(result)--, 1);
    if ( ((result & 0x8000000000i64) != 0) ^ v3 )
      break;
    __asm { fdecstp }
  }
  return result;
}
// B523E: inconsistent fpu stack

//----- (000B5250) --------------------------------------------------------
double __usercall sub_B5250@<st0>(char a1@<bl>, double *a2@<edi>, double result@<st0>)
{
  if ( a1 & 4 )
    *a2 = result;
  else
    *(float *)a2 = result;
  return result;
}

//----- (000B5C5B) --------------------------------------------------------
int sub_B5C5B()
{
  return 0;
}

//----- (000B5C60) --------------------------------------------------------
int __cdecl sub_B5C60(__int16 a1, __int16 a2)
{
  int v2; // ebx
  int v3; // edx
  int v4; // eax
  int v5; // esi
  int v6; // esi
  int result; // eax
  int v8; // esi
  int v9; // eax
  int v10; // esi
  int v11; // esi
  int v12; // edi

  v2 = HIBYTE(a1);
  BYTE1(v2) = HIBYTE(a2);
  v3 = (unsigned __int8)a2;
  if ( (HIBYTE(a1) + HIBYTE(a2)) & 1 )
  {
    if ( __CFADD__((_BYTE)v3, (_BYTE)a1) )
    {
      BYTE1(v2) = HIBYTE(a2) + 1;
      v4 = (unsigned __int8)byte_11B4E0[v2];
      LOBYTE(v2) = v2 + 1;
      v8 = (unsigned __int8)byte_11B4E0[v2];
      LOBYTE(v3) = ~(_BYTE)a2;
      BYTE1(v2) = HIBYTE(a2);
      v6 = v3 * ((unsigned __int8)byte_11B4E0[v2] - v8) + (unsigned __int8)a1 * (v8 - v4);
    }
    else
    {
      v4 = (unsigned __int8)byte_11B4E0[v2];
      LOBYTE(v2) = v2 + 1;
      v5 = (unsigned __int8)a1 * ((unsigned __int8)byte_11B4E0[v2] - v4);
      LOBYTE(v2) = v2 - 1;
      BYTE1(v2) = HIBYTE(a2) + 1;
      v6 = (unsigned __int8)a2 * ((unsigned __int8)byte_11B4E0[v2] - v4) + v5;
    }
    result = (v6 >> 3) + 32 * v4;
  }
  else
  {
    if ( (unsigned __int8)a1 <= (unsigned __int8)v3 )
    {
      v9 = (unsigned __int8)byte_11B4E0[v2];
      BYTE1(v2) = HIBYTE(a2) + 1;
      v12 = (unsigned __int8)byte_11B4E0[v2];
      LOBYTE(v2) = v2 + 1;
      v11 = (unsigned __int8)a2 * (v12 - v9) + (unsigned __int8)a1 * ((unsigned __int8)byte_11B4E0[v2] - v12);
    }
    else
    {
      v9 = (unsigned __int8)byte_11B4E0[v2];
      LOBYTE(v2) = v2 + 1;
      v10 = (unsigned __int8)byte_11B4E0[v2];
      BYTE1(v2) = HIBYTE(a2) + 1;
      v11 = (unsigned __int8)a2 * ((unsigned __int8)byte_11B4E0[v2] - v10) + (unsigned __int8)a1 * (v10 - v9);
    }
    result = (v11 >> 3) + 32 * v9;
  }
  return result;
}

//----- (000B5D68) --------------------------------------------------------
int __cdecl sub_B5D68(__int16 a1, __int16 a2)
{
  int v2; // ebx
  int v3; // edx
  int v4; // eax
  int v5; // esi
  int v6; // esi
  int result; // eax
  int v8; // esi
  int v9; // eax
  int v10; // esi
  int v11; // esi
  int v12; // edi

  v2 = HIBYTE(a1);
  BYTE1(v2) = HIBYTE(a2);
  v3 = (unsigned __int8)a2;
  if ( (HIBYTE(a1) + HIBYTE(a2)) & 1 )
  {
    if ( __CFADD__((_BYTE)v3, (_BYTE)a1) )
    {
      BYTE1(v2) = HIBYTE(a2) + 1;
      v4 = (unsigned __int8)byte_14B4E0[v2];
      LOBYTE(v2) = v2 + 1;
      v8 = (unsigned __int8)byte_14B4E0[v2];
      LOBYTE(v3) = ~(_BYTE)a2;
      BYTE1(v2) = HIBYTE(a2);
      v6 = v3 * ((unsigned __int8)byte_14B4E0[v2] - v8) + (unsigned __int8)a1 * (v8 - v4);
    }
    else
    {
      v4 = (unsigned __int8)byte_14B4E0[v2];
      LOBYTE(v2) = v2 + 1;
      v5 = (unsigned __int8)a1 * ((unsigned __int8)byte_14B4E0[v2] - v4);
      LOBYTE(v2) = v2 - 1;
      BYTE1(v2) = HIBYTE(a2) + 1;
      v6 = (unsigned __int8)a2 * ((unsigned __int8)byte_14B4E0[v2] - v4) + v5;
    }
    result = (v6 >> 3) + 32 * v4;
  }
  else
  {
    if ( (unsigned __int8)a1 <= (unsigned __int8)v3 )
    {
      v9 = (unsigned __int8)byte_14B4E0[v2];
      BYTE1(v2) = HIBYTE(a2) + 1;
      v12 = (unsigned __int8)byte_14B4E0[v2];
      LOBYTE(v2) = v2 + 1;
      v11 = (unsigned __int8)a2 * (v12 - v9) + (unsigned __int8)a1 * ((unsigned __int8)byte_14B4E0[v2] - v12);
    }
    else
    {
      v9 = (unsigned __int8)byte_14B4E0[v2];
      LOBYTE(v2) = v2 + 1;
      v10 = (unsigned __int8)byte_14B4E0[v2];
      BYTE1(v2) = HIBYTE(a2) + 1;
      v11 = (unsigned __int8)a2 * ((unsigned __int8)byte_14B4E0[v2] - v10) + (unsigned __int8)a1 * (v10 - v9);
    }
    result = (v11 >> 3) + 32 * v9;
  }
  return result;
}

//----- (000B5E70) --------------------------------------------------------
void __cdecl __spoils<ecx> sub_B5E70(__int16 a1, unsigned __int16 a2, __int16 a3)
{
  int v3; // ebx
  __int16 v4; // cx
  _BOOL1 v5; // sf
  unsigned __int8 v6; // of
  char v7; // [esp+1h] [ebp-3h]
  char v8; // [esp+1h] [ebp-3h]
  char v9; // [esp+2h] [ebp-2h]
  char v10; // [esp+2h] [ebp-2h]
  char v11; // [esp+3h] [ebp-1h]
  int savedregs; // [esp+4h] [ebp+0h]

  word_15B4E0[a2] = a3;
  v11 = 7;
  do
  {
    v3 = a2;
    v4 = (unsigned __int8)(1 << v11);
    v7 = 1 << (7 - v11);
    do
    {
      v9 = 1 << (7 - v11);
      do
      {
        sub_B5EFA(v4, v3, (int)&savedregs, a1);
        --v9;
      }
      while ( v9 );
      BYTE1(v3) += v4 + v4;
      --v7;
    }
    while ( v7 );
    v8 = 1 << (7 - v11);
    do
    {
      v10 = 1 << (7 - v11);
      do
      {
        sub_B5F8F(v4, v3, (int)&savedregs, a1);
        --v10;
      }
      while ( v10 );
      BYTE1(v3) += v4 + v4;
      --v8;
    }
    while ( v8 );
    v6 = __OFSUB__(v11, 1);
    v5 = (char)(v11-- - 1) < 0;
  }
  while ( !((unsigned __int8)v5 ^ v6) );
}

//----- (000B5EFA) --------------------------------------------------------
__int16 __usercall sub_B5EFA@<ax>(__int16 a1@<cx>, int a2@<ebx>, int a3@<ebp>, __int16 a4@<si>)
{
  __int16 v4; // di
  __int16 v5; // di
  __int16 v6; // di
  __int16 v7; // di
  __int16 v8; // di
  __int16 result; // ax

  v4 = word_15B4E0[a2];
  LOBYTE(a2) = a1 + a1 + a2;
  v5 = word_15B4E0[a2] + v4;
  BYTE1(a2) += a1 + a1;
  v6 = word_15B4E0[a2] + v5;
  LOBYTE(a2) = a2 - a1 - a1;
  v7 = word_15B4E0[a2] + v6;
  LOBYTE(a2) = a1 + a2;
  BYTE1(a2) -= a1;
  v8 = (unsigned __int16)(9377 * a4 + 9439) % (unsigned __int16)(2 * *(_WORD *)(a3 + 20) + 1)
     + (unsigned __int16)(9377 * a4 + 9439) % (unsigned __int16)((a1 << 6) + 1)
     + (v7 >> 2)
     - 32 * a1
     - *(_WORD *)(a3 + 20);
  result = v8;
  if ( !word_15B4E0[a2] )
    word_15B4E0[a2] = v8;
  return result;
}

//----- (000B5F8F) --------------------------------------------------------
__int16 __usercall sub_B5F8F@<ax>(__int16 a1@<cx>, int a2@<ebx>, int a3@<ebp>, __int16 a4@<si>)
{
  __int16 v4; // di
  __int16 v5; // di
  __int16 v6; // di
  unsigned __int16 v7; // si
  __int16 v8; // ax
  __int16 v9; // di
  __int16 v10; // di
  __int16 v11; // di
  __int16 v12; // di
  __int16 result; // ax
  __int16 v14; // [esp-2h] [ebp-2h]

  v4 = word_15B4E0[a2];
  v14 = v4;
  LOBYTE(a2) = a1 + a2;
  BYTE1(a2) -= a1;
  v5 = word_15B4E0[a2] + v4;
  LOBYTE(a2) = a1 + a2;
  BYTE1(a2) += a1;
  v6 = word_15B4E0[a2] + v5;
  LOBYTE(a2) = a2 - a1;
  BYTE1(a2) += a1;
  v7 = 9377 * a4 + 9439;
  v8 = v7 % (unsigned __int16)(2 * *(_WORD *)(a3 + 20) + 1)
     + v7 % (unsigned __int16)((a1 << 6) + 1)
     + ((signed __int16)(word_15B4E0[a2] + v6) >> 2)
     - 32 * a1
     - *(_WORD *)(a3 + 20);
  v9 = word_15B4E0[a2];
  BYTE1(a2) -= a1;
  if ( !word_15B4E0[a2] )
    word_15B4E0[a2] = v8;
  LOBYTE(a2) = a2 - a1 - a1;
  BYTE1(a2) += a1;
  v10 = word_15B4E0[a2] + v14 + v9;
  LOBYTE(a2) = a1 + a2;
  BYTE1(a2) += a1;
  v11 = word_15B4E0[a2] + v10;
  BYTE1(a2) -= a1;
  v12 = (unsigned __int16)(9377 * v7 + 9439) % (unsigned __int16)(2 * *(_WORD *)(a3 + 20) + 1)
      + (unsigned __int16)(9377 * v7 + 9439) % (unsigned __int16)((a1 << 6) + 1)
      + (v11 >> 2)
      - 32 * a1
      - *(_WORD *)(a3 + 20);
  result = v12;
  if ( !word_15B4E0[a2] )
    word_15B4E0[a2] = v12;
  return result;
}

//----- (000B6253) --------------------------------------------------------
void __cdecl __spoils<ecx> sub_B6253(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // esi
  _DWORD *v4; // edi
  _DWORD *v5; // ecx
  int v6; // eax
  int v7; // ebx
  int v8; // edx
  int v9; // eax
  int v10; // ebx
  int v11; // ebx
  int v12; // ebx
  int v13; // ebx
  int v14; // eax
  int v15; // ebx
  _BOOL1 v16; // zf
  _BOOL1 v17; // sf
  unsigned __int8 v18; // of
  int v19; // ebx
  int v20; // ebx
  int v21; // eax
  int v22; // ebx
  int v23; // ecx
  int v24; // edx
  int v25; // esi
  int v26; // ST48_4
  int v27; // ebx
  _DWORD *v28; // edi
  int v29; // edi
  int v30; // edi
  unsigned int v31; // eax
  int v32; // eax
  int v33; // ebx
  _BOOL1 v34; // zf
  int v35; // ebx
  int v36; // ebx
  int v37; // eax
  int v38; // ebx
  int v39; // ecx
  int v40; // edx
  int v41; // ST48_4
  int v42; // ebx
  _DWORD *v43; // edi
  int v44; // edi
  int v45; // edi
  int v46; // eax
  int v47; // ebx
  _BOOL1 v48; // zf
  int v49; // ebx
  int v50; // eax
  int v51; // ebx
  int v52; // esi
  int v53; // ST48_4
  int v54; // ebx
  _DWORD *v55; // edi
  int v56; // edi
  int v57; // edi
  int v58; // eax
  int v59; // ebx
  int v60; // ST48_4
  int v61; // ebx
  _DWORD *v62; // edi
  int v63; // edi
  int v64; // edi
  int v65; // eax
  int v66; // ebx
  int v67; // ebx
  int v68; // ebx
  int v69; // eax
  int v70; // ebx
  _BOOL1 v71; // zf
  int v72; // ebx
  int v73; // ebx
  int v74; // eax
  int v75; // ebx
  int v76; // ecx
  int v77; // edx
  int v78; // esi
  int v79; // ST48_4
  int v80; // eax
  int *v81; // edi
  int v82; // edi
  int v83; // edi
  int v84; // eax
  int v85; // ebx
  _BOOL1 v86; // zf
  int v87; // ebx
  int v88; // ebx
  int v89; // eax
  int v90; // ebx
  int v91; // ecx
  int v92; // edx
  int v93; // ST48_4
  int v94; // eax
  int *v95; // edi
  int v96; // edi
  int v97; // edi
  int v98; // eax
  int v99; // ebx
  _BOOL1 v100; // zf
  int v101; // ebx
  int v102; // eax
  int v103; // ebx
  int v104; // esi
  int v105; // ST48_4
  int v106; // eax
  int *v107; // edi
  int v108; // edi
  int v109; // edi
  int v110; // eax
  int v111; // ebx
  int v112; // ST48_4
  int v113; // eax
  int *v114; // edi
  int v115; // edi
  int v116; // edi
  int v117; // eax
  int v118; // ebx
  int v119; // ebx
  int v120; // eax
  int v121; // ebx
  int v122; // ecx
  int v123; // edx
  int v124; // esi
  int v125; // edi
  _DWORD *v126; // edi
  int v127; // ebx
  int v128; // eax
  int v129; // ebx
  int v130; // ecx
  int v131; // edx
  int v132; // edi
  _DWORD *v133; // edi
  int v134; // eax
  int v135; // ebx
  int v136; // esi
  int v137; // edi
  _DWORD *v138; // edi
  int v139; // eax
  int v140; // ebx
  int v141; // edi
  _DWORD *v142; // edi
  int v143; // eax
  int v144; // ebx
  int v145; // ebx
  int v146; // eax
  int v147; // ebx
  int v148; // ecx
  int v149; // edx
  int v150; // esi
  int v151; // edi
  _DWORD *v152; // edi
  int v153; // ebx
  int v154; // eax
  int v155; // ebx
  int v156; // ecx
  int v157; // edx
  int v158; // edi
  _DWORD *v159; // edi
  int v160; // eax
  int v161; // ebx
  int v162; // esi
  int v163; // edi
  _DWORD *v164; // edi
  int v165; // eax
  int v166; // ebx
  int v167; // edi
  _DWORD *v168; // edi
  unsigned __int16 *v169; // esi
  char *v170; // edx
  char v171; // al
  int v172; // ebx
  signed int v173; // ecx
  char *v174; // edi
  unsigned __int16 *v175; // esi
  int v176; // ecx
  _BYTE *v177; // edi
  unsigned int v178; // eax
  __int16 v179; // bx
  unsigned __int8 v180; // cf
  unsigned __int16 v181; // bx
  __int16 v182; // bx
  char v183; // ah
  __int16 v184; // cx
  __int16 v185; // bx
  char v186; // ah
  __int16 v187; // cx
  __int16 v188; // bx
  char v189; // ah
  __int16 v190; // cx
  __int16 v191; // bx
  char v192; // ah
  __int16 v193; // cx
  __int16 v194; // bx
  char v195; // ah
  __int16 v196; // cx
  __int16 v197; // bx
  char v198; // ah
  __int16 v199; // cx
  __int16 v200; // bx
  char v201; // ah
  __int16 v202; // cx
  __int16 v203; // bx
  char v204; // ah
  __int16 v205; // cx
  __int16 v206; // bx
  char v207; // ah
  __int16 v208; // cx
  __int16 v209; // bx
  char v210; // ah
  __int16 v211; // cx
  __int16 v212; // bx
  char v213; // ah
  __int16 v214; // cx
  __int16 v215; // bx
  char v216; // ah
  __int16 v217; // cx
  __int16 v218; // bx
  char v219; // ah
  __int16 v220; // cx
  __int16 v221; // bx
  char v222; // ah
  __int16 v223; // cx
  __int16 v224; // bx
  char v225; // ah
  __int16 v226; // cx
  unsigned __int16 *v227; // esi
  int v228; // eax
  int v229; // ebx
  int v230; // ecx
  _BYTE *v231; // edi
  int v232; // eax
  unsigned int v233; // eax
  int v234; // edx
  unsigned int v235; // eax
  int v236; // esi
  char v237; // al
  int v238; // edx
  __int16 v239; // cx
  char v240; // al
  int v241; // edx
  __int16 v242; // cx
  char v243; // al
  int v244; // edx
  __int16 v245; // cx
  char v246; // al
  int v247; // edx
  __int16 v248; // cx
  char v249; // al
  int v250; // edx
  __int16 v251; // cx
  char v252; // al
  int v253; // edx
  __int16 v254; // cx
  char v255; // al
  int v256; // edx
  __int16 v257; // cx
  char v258; // al
  int v259; // edx
  __int16 v260; // cx
  char v261; // al
  int v262; // edx
  __int16 v263; // cx
  char v264; // al
  int v265; // edx
  __int16 v266; // cx
  char v267; // al
  int v268; // edx
  __int16 v269; // cx
  char v270; // al
  int v271; // edx
  __int16 v272; // cx
  char v273; // al
  int v274; // edx
  __int16 v275; // cx
  char v276; // al
  int v277; // edx
  __int16 v278; // cx
  char v279; // al
  int v280; // edx
  __int16 v281; // cx
  char v282; // al
  unsigned __int16 *v283; // esi
  int v284; // eax
  int v285; // ebx
  int v286; // ecx
  _BYTE *v287; // edi
  int v288; // eax
  unsigned int v289; // eax
  int v290; // edx
  unsigned int v291; // eax
  int v292; // esi
  char v293; // al
  int v294; // edx
  __int16 v295; // cx
  char v296; // al
  int v297; // edx
  __int16 v298; // cx
  char v299; // al
  int v300; // edx
  __int16 v301; // cx
  char v302; // al
  int v303; // edx
  __int16 v304; // cx
  char v305; // al
  int v306; // edx
  __int16 v307; // cx
  char v308; // al
  int v309; // edx
  __int16 v310; // cx
  char v311; // al
  int v312; // edx
  __int16 v313; // cx
  char v314; // al
  int v315; // edx
  __int16 v316; // cx
  char v317; // al
  int v318; // edx
  __int16 v319; // cx
  char v320; // al
  int v321; // edx
  __int16 v322; // cx
  char v323; // al
  int v324; // edx
  __int16 v325; // cx
  char v326; // al
  int v327; // edx
  __int16 v328; // cx
  char v329; // al
  int v330; // edx
  __int16 v331; // cx
  char v332; // al
  int v333; // edx
  __int16 v334; // cx
  char v335; // al
  int v336; // edx
  __int16 v337; // cx
  char v338; // al
  unsigned __int16 *v339; // esi
  int v340; // ecx
  _BYTE *v341; // edi
  unsigned int v342; // eax
  __int16 v343; // bx
  unsigned __int16 v344; // bx
  __int16 v345; // bx
  __int16 v346; // cx
  __int16 v347; // bx
  __int16 v348; // cx
  __int16 v349; // bx
  __int16 v350; // cx
  __int16 v351; // bx
  __int16 v352; // cx
  __int16 v353; // bx
  __int16 v354; // cx
  __int16 v355; // bx
  __int16 v356; // cx
  __int16 v357; // bx
  __int16 v358; // cx
  __int16 v359; // bx
  __int16 v360; // cx
  __int16 v361; // bx
  __int16 v362; // cx
  __int16 v363; // bx
  __int16 v364; // cx
  __int16 v365; // bx
  __int16 v366; // cx
  __int16 v367; // bx
  __int16 v368; // cx
  __int16 v369; // bx
  __int16 v370; // cx
  __int16 v371; // bx
  __int16 v372; // cx
  __int16 v373; // bx
  __int16 v374; // cx
  unsigned int v375; // eax
  int v376; // ebx
  char *v377; // esi
  int v378; // ecx
  int v379; // edi
  int v380; // eax
  int v381; // ecx
  unsigned int v382; // eax
  int v383; // edx
  int v384; // ecx
  __int16 v385; // cx
  __int16 v386; // bp
  int v387; // esi
  _BYTE *v388; // edi
  int v389; // ebp
  unsigned int v390; // eax
  int v391; // ebx
  char *v392; // esi
  int v393; // ecx
  int v394; // edi
  int v395; // eax
  int v396; // ecx
  unsigned int v397; // eax
  int v398; // edx
  int v399; // ecx
  __int16 v400; // cx
  __int16 v401; // bp
  int v402; // esi
  _BYTE *v403; // edi
  int v404; // ebp
  unsigned __int16 *v405; // esi
  int v406; // eax
  int v407; // ebx
  int v408; // ecx
  _BYTE *v409; // edi
  int v410; // eax
  unsigned int v411; // eax
  int v412; // edx
  unsigned int v413; // eax
  int v414; // esi
  int v415; // edx
  __int16 v416; // cx
  int v417; // edx
  __int16 v418; // cx
  int v419; // edx
  __int16 v420; // cx
  int v421; // edx
  __int16 v422; // cx
  int v423; // edx
  __int16 v424; // cx
  int v425; // edx
  __int16 v426; // cx
  int v427; // edx
  __int16 v428; // cx
  int v429; // edx
  __int16 v430; // cx
  int v431; // edx
  __int16 v432; // cx
  int v433; // edx
  __int16 v434; // cx
  int v435; // edx
  __int16 v436; // cx
  int v437; // edx
  __int16 v438; // cx
  int v439; // edx
  __int16 v440; // cx
  int v441; // edx
  __int16 v442; // cx
  int v443; // edx
  __int16 v444; // cx
  unsigned __int16 *v445; // esi
  int v446; // eax
  int v447; // ebx
  int v448; // ecx
  _BYTE *v449; // edi
  int v450; // eax
  unsigned int v451; // eax
  int v452; // edx
  unsigned int v453; // eax
  int v454; // esi
  int v455; // edx
  __int16 v456; // cx
  int v457; // edx
  __int16 v458; // cx
  int v459; // edx
  __int16 v460; // cx
  int v461; // edx
  __int16 v462; // cx
  int v463; // edx
  __int16 v464; // cx
  int v465; // edx
  __int16 v466; // cx
  int v467; // edx
  __int16 v468; // cx
  int v469; // edx
  __int16 v470; // cx
  int v471; // edx
  __int16 v472; // cx
  int v473; // edx
  __int16 v474; // cx
  int v475; // edx
  __int16 v476; // cx
  int v477; // edx
  __int16 v478; // cx
  int v479; // edx
  __int16 v480; // cx
  int v481; // edx
  __int16 v482; // cx
  int v483; // edx
  __int16 v484; // cx
  unsigned __int16 *v485; // esi
  int v486; // eax
  int v487; // ebx
  int v488; // ecx
  _BYTE *v489; // edi
  int v490; // eax
  unsigned int v491; // eax
  int v492; // edx
  unsigned int v493; // eax
  int v494; // esi
  int v495; // edx
  __int16 v496; // cx
  int v497; // edx
  __int16 v498; // cx
  int v499; // edx
  __int16 v500; // cx
  int v501; // edx
  __int16 v502; // cx
  int v503; // edx
  __int16 v504; // cx
  int v505; // edx
  __int16 v506; // cx
  int v507; // edx
  __int16 v508; // cx
  int v509; // edx
  __int16 v510; // cx
  int v511; // edx
  __int16 v512; // cx
  int v513; // edx
  __int16 v514; // cx
  int v515; // edx
  __int16 v516; // cx
  int v517; // edx
  __int16 v518; // cx
  int v519; // edx
  __int16 v520; // cx
  int v521; // edx
  __int16 v522; // cx
  int v523; // edx
  __int16 v524; // cx
  unsigned __int16 *v525; // esi
  int v526; // eax
  int v527; // ebx
  int v528; // ecx
  _BYTE *v529; // edi
  int v530; // eax
  unsigned int v531; // eax
  int v532; // edx
  unsigned int v533; // eax
  int v534; // esi
  int v535; // edx
  __int16 v536; // cx
  int v537; // edx
  __int16 v538; // cx
  int v539; // edx
  __int16 v540; // cx
  int v541; // edx
  __int16 v542; // cx
  int v543; // edx
  __int16 v544; // cx
  int v545; // edx
  __int16 v546; // cx
  int v547; // edx
  __int16 v548; // cx
  int v549; // edx
  __int16 v550; // cx
  int v551; // edx
  __int16 v552; // cx
  int v553; // edx
  __int16 v554; // cx
  int v555; // edx
  __int16 v556; // cx
  int v557; // edx
  __int16 v558; // cx
  int v559; // edx
  __int16 v560; // cx
  int v561; // edx
  __int16 v562; // cx
  int v563; // edx
  __int16 v564; // cx
  unsigned __int16 *v565; // esi
  int v566; // eax
  int v567; // ebx
  int v568; // ecx
  _BYTE *v569; // edi
  int v570; // eax
  unsigned int v571; // eax
  int v572; // edx
  unsigned int v573; // eax
  int v574; // esi
  int v575; // edx
  __int16 v576; // cx
  int v577; // edx
  __int16 v578; // cx
  int v579; // edx
  __int16 v580; // cx
  int v581; // edx
  __int16 v582; // cx
  int v583; // edx
  __int16 v584; // cx
  int v585; // edx
  __int16 v586; // cx
  int v587; // edx
  __int16 v588; // cx
  int v589; // edx
  __int16 v590; // cx
  int v591; // edx
  __int16 v592; // cx
  int v593; // edx
  __int16 v594; // cx
  int v595; // edx
  __int16 v596; // cx
  int v597; // edx
  __int16 v598; // cx
  int v599; // edx
  __int16 v600; // cx
  int v601; // edx
  __int16 v602; // cx
  int v603; // edx
  __int16 v604; // cx
  unsigned __int16 *v605; // esi
  _BYTE *v606; // edx
  int v607; // eax
  int v608; // ebx
  int v609; // ecx
  _BYTE *i; // edi
  __int16 v611; // cx
  __int16 v612; // cx
  __int16 v613; // cx
  __int16 v614; // cx
  __int16 v615; // cx
  __int16 v616; // cx
  __int16 v617; // cx
  __int16 v618; // cx
  __int16 v619; // cx
  __int16 v620; // cx
  __int16 v621; // cx
  __int16 v622; // cx
  __int16 v623; // cx
  __int16 v624; // cx
  __int16 v625; // cx
  unsigned __int16 *v626; // esi
  _BYTE *v627; // edx
  int v628; // eax
  int v629; // ebx
  int v630; // ecx
  _BYTE *j; // edi
  __int16 v632; // cx
  __int16 v633; // cx
  __int16 v634; // cx
  __int16 v635; // cx
  __int16 v636; // cx
  __int16 v637; // cx
  __int16 v638; // cx
  __int16 v639; // cx
  __int16 v640; // cx
  __int16 v641; // cx
  __int16 v642; // cx
  __int16 v643; // cx
  __int16 v644; // cx
  __int16 v645; // cx
  __int16 v646; // cx
  unsigned __int16 *v647; // esi
  int v648; // edx
  int v649; // ecx
  _BYTE *v650; // edi
  unsigned int v651; // eax
  __int16 v652; // bx
  unsigned __int16 v653; // bx
  __int16 v654; // bx
  __int16 v655; // cx
  __int16 v656; // bx
  __int16 v657; // cx
  __int16 v658; // bx
  __int16 v659; // cx
  __int16 v660; // bx
  __int16 v661; // cx
  __int16 v662; // bx
  __int16 v663; // cx
  __int16 v664; // bx
  __int16 v665; // cx
  __int16 v666; // bx
  __int16 v667; // cx
  __int16 v668; // bx
  __int16 v669; // cx
  __int16 v670; // bx
  __int16 v671; // cx
  __int16 v672; // bx
  __int16 v673; // cx
  __int16 v674; // bx
  __int16 v675; // cx
  __int16 v676; // bx
  __int16 v677; // cx
  __int16 v678; // bx
  __int16 v679; // cx
  __int16 v680; // bx
  __int16 v681; // cx
  __int16 v682; // bx
  __int16 v683; // cx
  unsigned __int16 *v684; // esi
  int v685; // edx
  int v686; // ecx
  _BYTE *v687; // edi
  unsigned int v688; // eax
  __int16 v689; // bx
  unsigned __int16 v690; // bx
  __int16 v691; // bx
  __int16 v692; // cx
  __int16 v693; // bx
  __int16 v694; // cx
  __int16 v695; // bx
  __int16 v696; // cx
  __int16 v697; // bx
  __int16 v698; // cx
  __int16 v699; // bx
  __int16 v700; // cx
  __int16 v701; // bx
  __int16 v702; // cx
  __int16 v703; // bx
  __int16 v704; // cx
  __int16 v705; // bx
  __int16 v706; // cx
  __int16 v707; // bx
  __int16 v708; // cx
  __int16 v709; // bx
  __int16 v710; // cx
  __int16 v711; // bx
  __int16 v712; // cx
  __int16 v713; // bx
  __int16 v714; // cx
  __int16 v715; // bx
  __int16 v716; // cx
  __int16 v717; // bx
  __int16 v718; // cx
  __int16 v719; // bx
  __int16 v720; // cx
  unsigned __int16 *v721; // esi
  int v722; // eax
  int v723; // ebx
  int v724; // ecx
  _BYTE *v725; // edi
  int v726; // eax
  unsigned int v727; // eax
  int v728; // edx
  unsigned int v729; // eax
  int v730; // esi
  int v731; // edx
  __int16 v732; // cx
  int v733; // edx
  __int16 v734; // cx
  int v735; // edx
  __int16 v736; // cx
  int v737; // edx
  __int16 v738; // cx
  int v739; // edx
  __int16 v740; // cx
  int v741; // edx
  __int16 v742; // cx
  int v743; // edx
  __int16 v744; // cx
  int v745; // edx
  __int16 v746; // cx
  int v747; // edx
  __int16 v748; // cx
  int v749; // edx
  __int16 v750; // cx
  int v751; // edx
  __int16 v752; // cx
  int v753; // edx
  __int16 v754; // cx
  int v755; // edx
  __int16 v756; // cx
  int v757; // edx
  __int16 v758; // cx
  int v759; // edx
  __int16 v760; // cx
  unsigned __int16 *v761; // esi
  int v762; // eax
  int v763; // ebx
  int v764; // ecx
  _BYTE *v765; // edi
  int v766; // eax
  unsigned int v767; // eax
  int v768; // edx
  unsigned int v769; // eax
  int v770; // esi
  int v771; // edx
  __int16 v772; // cx
  int v773; // edx
  __int16 v774; // cx
  int v775; // edx
  __int16 v776; // cx
  int v777; // edx
  __int16 v778; // cx
  int v779; // edx
  __int16 v780; // cx
  int v781; // edx
  __int16 v782; // cx
  int v783; // edx
  __int16 v784; // cx
  int v785; // edx
  __int16 v786; // cx
  int v787; // edx
  __int16 v788; // cx
  int v789; // edx
  __int16 v790; // cx
  int v791; // edx
  __int16 v792; // cx
  int v793; // edx
  __int16 v794; // cx
  int v795; // edx
  __int16 v796; // cx
  int v797; // edx
  __int16 v798; // cx
  int v799; // edx
  __int16 v800; // cx
  unsigned __int16 *v801; // esi
  unsigned int v802; // eax
  int v803; // ebx
  int v804; // ecx
  _BYTE *v805; // edi
  int v806; // eax
  int v807; // ecx
  unsigned int v808; // eax
  int v809; // edx
  int v810; // ecx
  int v811; // esi
  int v812; // edx
  int v813; // ecx
  int v814; // edx
  int v815; // ecx
  int v816; // edx
  int v817; // ecx
  int v818; // edx
  int v819; // ecx
  int v820; // edx
  int v821; // ecx
  int v822; // edx
  int v823; // ecx
  int v824; // edx
  int v825; // ecx
  int v826; // edx
  int v827; // ecx
  int v828; // edx
  int v829; // ecx
  int v830; // edx
  int v831; // ecx
  int v832; // edx
  int v833; // ecx
  int v834; // edx
  int v835; // ecx
  int v836; // edx
  int v837; // ecx
  int v838; // edx
  int v839; // ecx
  int v840; // edx
  int v841; // ecx
  unsigned __int16 *v842; // esi
  unsigned int v843; // eax
  int v844; // ebx
  int v845; // ecx
  _BYTE *v846; // edi
  int v847; // eax
  int v848; // ecx
  unsigned int v849; // eax
  int v850; // edx
  int v851; // ecx
  int v852; // esi
  int v853; // edx
  int v854; // ecx
  int v855; // edx
  int v856; // ecx
  int v857; // edx
  int v858; // ecx
  int v859; // edx
  int v860; // ecx
  int v861; // edx
  int v862; // ecx
  int v863; // edx
  int v864; // ecx
  int v865; // edx
  int v866; // ecx
  int v867; // edx
  int v868; // ecx
  int v869; // edx
  int v870; // ecx
  int v871; // edx
  int v872; // ecx
  int v873; // edx
  int v874; // ecx
  int v875; // edx
  int v876; // ecx
  int v877; // edx
  int v878; // ecx
  int v879; // edx
  int v880; // ecx
  int v881; // edx
  int v882; // ecx
  unsigned __int16 *v883; // esi
  int v884; // eax
  int v885; // ebx
  int v886; // ecx
  _BYTE *v887; // edi
  int v888; // eax
  unsigned int v889; // eax
  int v890; // edx
  unsigned int v891; // eax
  int v892; // esi
  int v893; // edx
  __int16 v894; // cx
  int v895; // edx
  __int16 v896; // cx
  int v897; // edx
  __int16 v898; // cx
  int v899; // edx
  __int16 v900; // cx
  int v901; // edx
  __int16 v902; // cx
  int v903; // edx
  __int16 v904; // cx
  int v905; // edx
  __int16 v906; // cx
  int v907; // edx
  __int16 v908; // cx
  int v909; // edx
  __int16 v910; // cx
  int v911; // edx
  __int16 v912; // cx
  int v913; // edx
  __int16 v914; // cx
  int v915; // edx
  __int16 v916; // cx
  int v917; // edx
  __int16 v918; // cx
  int v919; // edx
  __int16 v920; // cx
  int v921; // edx
  __int16 v922; // cx
  unsigned __int16 *v923; // esi
  int v924; // eax
  int v925; // ebx
  int v926; // ecx
  _BYTE *v927; // edi
  int v928; // eax
  unsigned int v929; // eax
  int v930; // edx
  unsigned int v931; // eax
  int v932; // esi
  int v933; // edx
  __int16 v934; // cx
  int v935; // edx
  __int16 v936; // cx
  int v937; // edx
  __int16 v938; // cx
  int v939; // edx
  __int16 v940; // cx
  int v941; // edx
  __int16 v942; // cx
  int v943; // edx
  __int16 v944; // cx
  int v945; // edx
  __int16 v946; // cx
  int v947; // edx
  __int16 v948; // cx
  int v949; // edx
  __int16 v950; // cx
  int v951; // edx
  __int16 v952; // cx
  int v953; // edx
  __int16 v954; // cx
  int v955; // edx
  __int16 v956; // cx
  int v957; // edx
  __int16 v958; // cx
  int v959; // edx
  __int16 v960; // cx
  int v961; // edx
  __int16 v962; // cx
  unsigned __int16 *v963; // esi
  unsigned int v964; // eax
  int v965; // ebx
  int v966; // ecx
  _BYTE *v967; // edi
  int v968; // eax
  int v969; // ecx
  unsigned int v970; // eax
  int v971; // edx
  int v972; // ecx
  int v973; // esi
  int v974; // edx
  int v975; // ecx
  int v976; // edx
  int v977; // ecx
  int v978; // edx
  int v979; // ecx
  int v980; // edx
  int v981; // ecx
  int v982; // edx
  int v983; // ecx
  int v984; // edx
  int v985; // ecx
  int v986; // edx
  int v987; // ecx
  int v988; // edx
  int v989; // ecx
  int v990; // edx
  int v991; // ecx
  int v992; // edx
  int v993; // ecx
  int v994; // edx
  int v995; // ecx
  int v996; // edx
  int v997; // ecx
  int v998; // edx
  int v999; // ecx
  int v1000; // edx
  int v1001; // ecx
  int v1002; // edx
  int v1003; // ecx
  unsigned __int16 *v1004; // esi
  unsigned int v1005; // eax
  int v1006; // ebx
  int v1007; // ecx
  _BYTE *v1008; // edi
  int v1009; // eax
  int v1010; // ecx
  unsigned int v1011; // eax
  int v1012; // edx
  int v1013; // ecx
  int v1014; // esi
  int v1015; // edx
  int v1016; // ecx
  int v1017; // edx
  int v1018; // ecx
  int v1019; // edx
  int v1020; // ecx
  int v1021; // edx
  int v1022; // ecx
  int v1023; // edx
  int v1024; // ecx
  int v1025; // edx
  int v1026; // ecx
  int v1027; // edx
  int v1028; // ecx
  int v1029; // edx
  int v1030; // ecx
  int v1031; // edx
  int v1032; // ecx
  int v1033; // edx
  int v1034; // ecx
  int v1035; // edx
  int v1036; // ecx
  int v1037; // edx
  int v1038; // ecx
  int v1039; // edx
  int v1040; // ecx
  int v1041; // edx
  int v1042; // ecx
  int v1043; // edx
  int v1044; // ecx
  unsigned __int16 *v1045; // esi
  unsigned int v1046; // eax
  int v1047; // ebx
  int v1048; // ecx
  char *v1049; // edi
  int v1050; // eax
  int v1051; // ecx
  unsigned int v1052; // eax
  int v1053; // edx
  int v1054; // ecx
  int v1055; // esi
  char v1056; // al
  int v1057; // edx
  int v1058; // ecx
  char v1059; // al
  int v1060; // edx
  int v1061; // ecx
  char v1062; // al
  int v1063; // edx
  int v1064; // ecx
  char v1065; // al
  int v1066; // edx
  int v1067; // ecx
  char v1068; // al
  int v1069; // edx
  int v1070; // ecx
  char v1071; // al
  int v1072; // edx
  int v1073; // ecx
  char v1074; // al
  int v1075; // edx
  int v1076; // ecx
  char v1077; // al
  int v1078; // edx
  int v1079; // ecx
  char v1080; // al
  int v1081; // edx
  int v1082; // ecx
  char v1083; // al
  int v1084; // edx
  int v1085; // ecx
  char v1086; // al
  int v1087; // edx
  int v1088; // ecx
  char v1089; // al
  int v1090; // edx
  int v1091; // ecx
  char v1092; // al
  int v1093; // edx
  int v1094; // ecx
  char v1095; // al
  int v1096; // edx
  int v1097; // ecx
  char v1098; // al
  int v1099; // edx
  int v1100; // ecx
  char v1101; // al
  int v1102; // [esp+0h] [ebp-88h]
  int v1103; // [esp+4h] [ebp-84h]
  int v1104; // [esp+4h] [ebp-84h]
  int v1105; // [esp+4h] [ebp-84h]
  int v1106; // [esp+4h] [ebp-84h]
  int v1107; // [esp+8h] [ebp-80h]
  int v1108; // [esp+8h] [ebp-80h]
  int v1109; // [esp+8h] [ebp-80h]
  int v1110; // [esp+8h] [ebp-80h]
  int v1111; // [esp+Ch] [ebp-7Ch]
  int v1112; // [esp+Ch] [ebp-7Ch]
  int v1113; // [esp+10h] [ebp-78h]
  int v1114; // [esp+10h] [ebp-78h]
  int v1115; // [esp+10h] [ebp-78h]
  int v1116; // [esp+10h] [ebp-78h]
  int v1117; // [esp+14h] [ebp-74h]
  int v1118; // [esp+14h] [ebp-74h]
  int v1119; // [esp+18h] [ebp-70h]
  int v1120; // [esp+18h] [ebp-70h]
  int v1121; // [esp+1Ch] [ebp-6Ch]
  int v1122; // [esp+1Ch] [ebp-6Ch]
  int v1123; // [esp+20h] [ebp-68h]
  int v1124; // [esp+24h] [ebp-64h]
  int v1125; // [esp+28h] [ebp-60h]
  int v1126; // [esp+28h] [ebp-60h]
  int v1127; // [esp+28h] [ebp-60h]
  int v1128; // [esp+28h] [ebp-60h]
  int v1129; // [esp+28h] [ebp-60h]
  int v1130; // [esp+28h] [ebp-60h]
  int v1131; // [esp+28h] [ebp-60h]
  int v1132; // [esp+28h] [ebp-60h]
  int v1133; // [esp+2Ch] [ebp-5Ch]
  int v1134; // [esp+2Ch] [ebp-5Ch]
  int v1135; // [esp+30h] [ebp-58h]
  int v1136; // [esp+34h] [ebp-54h]
  int v1137; // [esp+34h] [ebp-54h]
  int v1138; // [esp+34h] [ebp-54h]
  int v1139; // [esp+34h] [ebp-54h]
  int v1140; // [esp+34h] [ebp-54h]
  int v1141; // [esp+34h] [ebp-54h]
  int v1142; // [esp+34h] [ebp-54h]
  int v1143; // [esp+34h] [ebp-54h]
  int v1144; // [esp+38h] [ebp-50h]
  int v1145; // [esp+38h] [ebp-50h]
  int v1146; // [esp+3Ch] [ebp-4Ch]
  int v1147; // [esp+40h] [ebp-48h]
  int v1148; // [esp+40h] [ebp-48h]
  int v1149; // [esp+40h] [ebp-48h]
  int v1150; // [esp+40h] [ebp-48h]
  int v1151; // [esp+40h] [ebp-48h]
  int v1152; // [esp+40h] [ebp-48h]
  int v1153; // [esp+40h] [ebp-48h]
  int v1154; // [esp+40h] [ebp-48h]
  int v1155; // [esp+44h] [ebp-44h]
  int v1156; // [esp+44h] [ebp-44h]
  int v1157; // [esp+48h] [ebp-40h]
  int v1158; // [esp+48h] [ebp-40h]
  int v1159; // [esp+48h] [ebp-40h]
  int v1160; // [esp+48h] [ebp-40h]
  int v1161; // [esp+48h] [ebp-40h]
  int v1162; // [esp+48h] [ebp-40h]
  int v1163; // [esp+48h] [ebp-40h]
  int v1164; // [esp+48h] [ebp-40h]
  int v1165; // [esp+4Ch] [ebp-3Ch]
  int v1166; // [esp+4Ch] [ebp-3Ch]
  int v1167; // [esp+4Ch] [ebp-3Ch]
  int v1168; // [esp+4Ch] [ebp-3Ch]
  int v1169; // [esp+4Ch] [ebp-3Ch]
  int v1170; // [esp+4Ch] [ebp-3Ch]
  int v1171; // [esp+4Ch] [ebp-3Ch]
  int v1172; // [esp+4Ch] [ebp-3Ch]
  int v1173; // [esp+4Ch] [ebp-3Ch]
  int v1174; // [esp+4Ch] [ebp-3Ch]
  int v1175; // [esp+4Ch] [ebp-3Ch]
  int v1176; // [esp+4Ch] [ebp-3Ch]
  int v1177; // [esp+4Ch] [ebp-3Ch]
  int v1178; // [esp+4Ch] [ebp-3Ch]
  int v1179; // [esp+4Ch] [ebp-3Ch]
  int v1180; // [esp+4Ch] [ebp-3Ch]
  int v1181; // [esp+4Ch] [ebp-3Ch]
  int v1182; // [esp+4Ch] [ebp-3Ch]
  int v1183; // [esp+50h] [ebp-38h]
  int v1184; // [esp+50h] [ebp-38h]
  int v1185; // [esp+50h] [ebp-38h]
  int v1186; // [esp+50h] [ebp-38h]
  int v1187; // [esp+50h] [ebp-38h]
  int v1188; // [esp+50h] [ebp-38h]
  int v1189; // [esp+50h] [ebp-38h]
  int v1190; // [esp+54h] [ebp-34h]
  int v1191; // [esp+54h] [ebp-34h]
  int v1192; // [esp+54h] [ebp-34h]
  int v1193; // [esp+54h] [ebp-34h]
  int v1194; // [esp+58h] [ebp-30h]
  int v1195; // [esp+58h] [ebp-30h]
  int v1196; // [esp+58h] [ebp-30h]
  int v1197; // [esp+58h] [ebp-30h]
  int v1198; // [esp+58h] [ebp-30h]
  int v1199; // [esp+58h] [ebp-30h]
  int v1200; // [esp+58h] [ebp-30h]
  int v1201; // [esp+58h] [ebp-30h]
  int v1202; // [esp+58h] [ebp-30h]
  int v1203; // [esp+58h] [ebp-30h]
  int v1204; // [esp+58h] [ebp-30h]
  int v1205; // [esp+58h] [ebp-30h]
  int v1206; // [esp+58h] [ebp-30h]
  int v1207; // [esp+58h] [ebp-30h]
  int v1208; // [esp+58h] [ebp-30h]
  int v1209; // [esp+58h] [ebp-30h]
  int v1210; // [esp+58h] [ebp-30h]
  int v1211; // [esp+58h] [ebp-30h]
  int v1212; // [esp+58h] [ebp-30h]
  int v1213; // [esp+58h] [ebp-30h]
  int v1214; // [esp+58h] [ebp-30h]
  int v1215; // [esp+58h] [ebp-30h]
  int v1216; // [esp+58h] [ebp-30h]
  int v1217; // [esp+58h] [ebp-30h]
  int v1218; // [esp+58h] [ebp-30h]
  int v1219; // [esp+58h] [ebp-30h]
  int v1220; // [esp+58h] [ebp-30h]
  int v1221; // [esp+58h] [ebp-30h]
  int v1222; // [esp+58h] [ebp-30h]
  int v1223; // [esp+58h] [ebp-30h]
  int v1224; // [esp+58h] [ebp-30h]
  int v1225; // [esp+58h] [ebp-30h]
  int v1226; // [esp+58h] [ebp-30h]
  int v1227; // [esp+58h] [ebp-30h]
  int v1228; // [esp+58h] [ebp-30h]
  int v1229; // [esp+58h] [ebp-30h]
  int v1230; // [esp+58h] [ebp-30h]
  int v1231; // [esp+58h] [ebp-30h]
  int v1232; // [esp+58h] [ebp-30h]
  int v1233; // [esp+58h] [ebp-30h]
  int v1234; // [esp+58h] [ebp-30h]
  int v1235; // [esp+58h] [ebp-30h]
  int v1236; // [esp+58h] [ebp-30h]
  int v1237; // [esp+58h] [ebp-30h]
  int v1238; // [esp+58h] [ebp-30h]
  int v1239; // [esp+58h] [ebp-30h]
  int v1240; // [esp+58h] [ebp-30h]
  int v1241; // [esp+58h] [ebp-30h]
  int v1242; // [esp+58h] [ebp-30h]
  int v1243; // [esp+58h] [ebp-30h]
  int v1244; // [esp+58h] [ebp-30h]
  int v1245; // [esp+58h] [ebp-30h]
  int v1246; // [esp+58h] [ebp-30h]
  int v1247; // [esp+58h] [ebp-30h]
  int v1248; // [esp+58h] [ebp-30h]
  int v1249; // [esp+58h] [ebp-30h]
  int v1250; // [esp+58h] [ebp-30h]
  int v1251; // [esp+58h] [ebp-30h]
  int v1252; // [esp+58h] [ebp-30h]
  int v1253; // [esp+58h] [ebp-30h]
  int v1254; // [esp+58h] [ebp-30h]
  int v1255; // [esp+58h] [ebp-30h]
  int v1256; // [esp+58h] [ebp-30h]
  int v1257; // [esp+58h] [ebp-30h]
  int v1258; // [esp+58h] [ebp-30h]
  int v1259; // [esp+58h] [ebp-30h]
  int v1260; // [esp+58h] [ebp-30h]
  int v1261; // [esp+58h] [ebp-30h]
  int v1262; // [esp+58h] [ebp-30h]
  int v1263; // [esp+58h] [ebp-30h]
  int v1264; // [esp+58h] [ebp-30h]
  int v1265; // [esp+58h] [ebp-30h]
  int v1266; // [esp+58h] [ebp-30h]
  int v1267; // [esp+58h] [ebp-30h]
  int v1268; // [esp+58h] [ebp-30h]
  int v1269; // [esp+58h] [ebp-30h]
  int v1270; // [esp+58h] [ebp-30h]
  int v1271; // [esp+58h] [ebp-30h]
  int v1272; // [esp+58h] [ebp-30h]
  int v1273; // [esp+58h] [ebp-30h]
  unsigned __int16 *v1274; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1275; // [esp+5Ch] [ebp-2Ch]
  char *v1276; // [esp+5Ch] [ebp-2Ch]
  char *v1277; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1278; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1279; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1280; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1281; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1282; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1283; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1284; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1285; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1286; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1287; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1288; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1289; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1290; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1291; // [esp+5Ch] [ebp-2Ch]
  char v1292; // [esp+62h] [ebp-26h]
  char v1293; // [esp+62h] [ebp-26h]
  char v1294; // [esp+62h] [ebp-26h]
  char v1295; // [esp+62h] [ebp-26h]
  char v1296; // [esp+63h] [ebp-25h]
  char v1297; // [esp+63h] [ebp-25h]
  _BOOL1 v1298; // [esp+63h] [ebp-25h]
  _BOOL1 v1299; // [esp+63h] [ebp-25h]
  _BOOL1 v1300; // [esp+64h] [ebp-24h]
  _BOOL1 v1301; // [esp+64h] [ebp-24h]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = a1[1];
  v7 = a2[1];
  v8 = a3[1];
  if ( v6 == v7 )
  {
    if ( v6 == v8 )
      return;
    if ( v6 >= v8 )
    {
      if ( *a1 <= *a2 )
        return;
      v3 = a3;
      v4 = a1;
      v5 = a2;
      goto LABEL_234;
    }
    if ( *a2 <= *a1 )
      return;
    goto LABEL_277;
  }
  if ( v6 <= v7 )
  {
    if ( v6 != v8 )
    {
      if ( v6 >= v8 )
      {
        v3 = a3;
        v4 = a1;
        v5 = a2;
LABEL_24:
        v9 = v3[1];
        v1190 = v9;
        if ( v9 >= 0 )
        {
          if ( v9 >= dword_DE568 )
            return;
          v1102 = dword_DE554 + dword_DE560 * v9;
          v1292 = 0;
        }
        else
        {
          v1102 = dword_DE554;
          v1292 = 1;
        }
        v10 = v5[1];
        v1300 = v10 > dword_DE568;
        v11 = v10 - v9;
        v1113 = v11;
        v1123 = v11;
        v12 = v4[1];
        v1296 = v12 > dword_DE568;
        v13 = v12 - v9;
        v1117 = v13;
        v1103 = ((*v5 - *v3) << 16) / v1113;
        if ( ((*v4 - *v3) << 16) / v13 > v1103 )
        {
          v1107 = ((*v4 - *v3) << 16) / v13;
          v1111 = ((*v5 - *v4) << 16) / (v5[1] - v4[1]);
          v1119 = v5[1] - v4[1];
          v1121 = *v4 << 16;
          switch ( byte_E126D )
          {
            case 0:
            case 0xE:
            case 0xF:
              v58 = *v3 << 16;
              v59 = *v3 << 16;
              if ( !v1292 )
              {
                if ( v1300 )
                {
                  v63 = dword_DE568 - v1190;
                  v1123 = dword_DE568 - v1190;
                  if ( v1296 )
                  {
                    v1117 = dword_DE568 - v1190;
                  }
                  else
                  {
                    v18 = __OFSUB__(v63, v1117);
                    v64 = v63 - v1117;
                    v1296 = (v64 < 0) ^ v18 | (v64 == 0);
                    v1119 = v64;
                  }
                }
                goto LABEL_121;
              }
              v18 = __OFSUB__(v1123, -v1190);
              v16 = v1123 == -v1190;
              v17 = v1123 + v1190 < 0;
              v1123 += v1190;
              if ( !((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16) )
              {
                v1160 = -v1190;
                if ( -v1190 - v1117 >= 0 )
                {
                  v1119 -= v1160 - v1117;
                  v60 = v1160 - v1117;
                  v58 += v1103 * v60 + v1117 * v1103;
                  v61 = v1111 * v60 + v1121;
                  if ( v1300 )
                  {
                    v1119 = dword_DE568;
                    v1123 = dword_DE568;
                  }
                  v62 = &unk_DE56C;
                  goto LABEL_124;
                }
                v1117 += v1190;
                v58 += v1103 * v1160;
                v59 += v1160 * v1107;
                if ( v1300 )
                {
                  v1123 = dword_DE568;
                  if ( v1296 )
                  {
                    v1117 = dword_DE568;
                  }
                  else
                  {
                    v1296 = dword_DE568 <= v1117;
                    v1119 = dword_DE568 - v1117;
                  }
                }
LABEL_121:
                v62 = &unk_DE56C;
                do
                {
                  *v62 = v58;
                  v58 += v1103;
                  v62[1] = v59;
                  v59 += v1107;
                  v62 += 5;
                  --v1117;
                }
                while ( v1117 );
                v61 = v1121;
LABEL_124:
                if ( v1296 )
                {
                  v31 = (unsigned __int8)byte_E126D;
                }
                else
                {
                  do
                  {
                    *v62 = v58;
                    v58 += v1103;
                    v62[1] = v61;
                    v61 += v1111;
                    v62 += 5;
                    --v1119;
                  }
                  while ( v1119 );
                  v31 = (unsigned __int8)byte_E126D;
                }
                goto LABEL_53;
              }
              return;
            case 1:
            case 4:
            case 0x10:
            case 0x11:
              v46 = v13 * (signed __int64)(*v3 - *v5) / v1113;
              v47 = *v4 - *v3;
              v18 = __OFADD__(v46, v47);
              v48 = v46 + v47 == 0;
              v17 = v46 + v47 < 0;
              v49 = v46 + v47;
              if ( (unsigned __int8)v17 ^ v18 )
                return;
              if ( !v48 )
                v1146 = (signed int)(v4[4] + (unsigned __int64)(v1117 * (signed __int64)(v3[4] - v5[4]) / v1113) - v3[4])
                      / (v49 + 1);
              v1148 = (v5[4] - v3[4]) / v1113;
              v50 = *v3 << 16;
              v51 = *v3 << 16;
              v52 = v3[4];
              if ( v1292 )
              {
                v18 = __OFSUB__(v1123, -v1190);
                v16 = v1123 == -v1190;
                v17 = v1123 + v1190 < 0;
                v1123 += v1190;
                if ( (unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16 )
                  return;
                v1159 = -v1190;
                if ( -v1190 - v1117 >= 0 )
                {
                  v1119 -= v1159 - v1117;
                  v53 = v1159 - v1117;
                  v50 += v1103 * v53 + v1117 * v1103;
                  v54 = v1111 * v53 + v1121;
                  v52 += v53 * v1148 + v1117 * v1148;
                  if ( v1300 )
                  {
                    v1119 = dword_DE568;
                    v1123 = dword_DE568;
                  }
                  v55 = &unk_DE56C;
LABEL_102:
                  if ( v1296 )
                  {
                    v31 = (unsigned __int8)byte_E126D;
                  }
                  else
                  {
                    do
                    {
                      *v55 = v50;
                      v50 += v1103;
                      v55[1] = v54;
                      v54 += v1111;
                      v55[4] = v52;
                      v52 += v1148;
                      v55 += 5;
                      --v1119;
                    }
                    while ( v1119 );
                    v31 = (unsigned __int8)byte_E126D;
                  }
                  goto LABEL_53;
                }
                v1117 += v1190;
                v50 += v1103 * v1159;
                v51 += v1159 * v1107;
                v52 += v1159 * v1148;
                if ( v1300 )
                {
                  v1123 = dword_DE568;
                  if ( v1296 )
                  {
                    v1117 = dword_DE568;
                  }
                  else
                  {
                    v1296 = dword_DE568 <= v1117;
                    v1119 = dword_DE568 - v1117;
                  }
                }
              }
              else if ( v1300 )
              {
                v56 = dword_DE568 - v1190;
                v1123 = dword_DE568 - v1190;
                if ( v1296 )
                {
                  v1117 = dword_DE568 - v1190;
                }
                else
                {
                  v18 = __OFSUB__(v56, v1117);
                  v57 = v56 - v1117;
                  v1296 = (v57 < 0) ^ v18 | (v57 == 0);
                  v1119 = v57;
                }
              }
              v55 = &unk_DE56C;
              do
              {
                *v55 = v50;
                v50 += v1103;
                v55[1] = v51;
                v51 += v1107;
                v55[4] = v52;
                v52 += v1148;
                v55 += 5;
                --v1117;
              }
              while ( v1117 );
              v54 = v1121;
              goto LABEL_102;
            case 2:
            case 3:
            case 7:
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
            case 0xD:
            case 0x12:
            case 0x13:
            case 0x16:
            case 0x17:
              v32 = v13 * (signed __int64)(*v3 - *v5) / v1113;
              v33 = *v4 - *v3;
              v18 = __OFADD__(v32, v33);
              v34 = v32 + v33 == 0;
              v17 = v32 + v33 < 0;
              v35 = v32 + v33;
              if ( (unsigned __int8)v17 ^ v18 )
                return;
              if ( !v34 )
              {
                v36 = v35 + 1;
                v1124 = (signed int)(v4[2] + (unsigned __int64)(v1117 * (signed __int64)(v3[2] - v5[2]) / v1113) - v3[2])
                      / v36;
                v1135 = (signed int)(v4[3] + (unsigned __int64)(v1117 * (signed __int64)(v3[3] - v5[3]) / v1113) - v3[3])
                      / v36;
              }
              v1126 = (v5[2] - v3[2]) / v1113;
              v1137 = (v5[3] - v3[3]) / v1113;
              v37 = *v3 << 16;
              v38 = *v3 << 16;
              v39 = v3[2];
              v40 = v3[3];
              if ( v1292 )
              {
                v18 = __OFSUB__(v1123, -v1190);
                v16 = v1123 == -v1190;
                v17 = v1123 + v1190 < 0;
                v1123 += v1190;
                if ( (unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16 )
                  return;
                v1158 = -v1190;
                if ( -v1190 - v1117 >= 0 )
                {
                  v1119 -= v1158 - v1117;
                  v41 = v1158 - v1117;
                  v37 += v1103 * v41 + v1117 * v1103;
                  v42 = v1111 * v41 + v1121;
                  v39 += v41 * v1126 + v1117 * v1126;
                  v40 += v41 * v1137 + v1117 * v1137;
                  if ( v1300 )
                  {
                    v1119 = dword_DE568;
                    v1123 = dword_DE568;
                  }
                  v43 = &unk_DE56C;
LABEL_77:
                  if ( v1296 )
                  {
                    v31 = (unsigned __int8)byte_E126D;
                  }
                  else
                  {
                    do
                    {
                      *v43 = v37;
                      v37 += v1103;
                      v43[1] = v42;
                      v42 += v1111;
                      v43[2] = v39;
                      v39 += v1126;
                      v43[3] = v40;
                      v40 += v1137;
                      v43 += 5;
                      --v1119;
                    }
                    while ( v1119 );
                    v31 = (unsigned __int8)byte_E126D;
                  }
                  goto LABEL_53;
                }
                v1117 += v1190;
                v37 += v1103 * v1158;
                v38 += v1158 * v1107;
                v39 += v1158 * v1126;
                v40 += v1158 * v1137;
                if ( v1300 )
                {
                  v1123 = dword_DE568;
                  if ( v1296 )
                  {
                    v1117 = dword_DE568;
                  }
                  else
                  {
                    v1296 = dword_DE568 <= v1117;
                    v1119 = dword_DE568 - v1117;
                  }
                }
              }
              else if ( v1300 )
              {
                v44 = dword_DE568 - v1190;
                v1123 = dword_DE568 - v1190;
                if ( v1296 )
                {
                  v1117 = dword_DE568 - v1190;
                }
                else
                {
                  v18 = __OFSUB__(v44, v1117);
                  v45 = v44 - v1117;
                  v1296 = (v45 < 0) ^ v18 | (v45 == 0);
                  v1119 = v45;
                }
              }
              v43 = &unk_DE56C;
              do
              {
                *v43 = v37;
                v37 += v1103;
                v43[1] = v38;
                v38 += v1107;
                v43[2] = v39;
                v39 += v1126;
                v43[3] = v40;
                v40 += v1137;
                v43 += 5;
                --v1117;
              }
              while ( v1117 );
              v42 = v1121;
              goto LABEL_77;
            case 5:
            case 6:
            case 0x14:
            case 0x15:
            case 0x18:
            case 0x19:
            case 0x1A:
              v14 = v13 * (signed __int64)(*v3 - *v5) / v1113;
              v15 = *v4 - *v3;
              v18 = __OFADD__(v14, v15);
              v16 = v14 + v15 == 0;
              v17 = v14 + v15 < 0;
              v19 = v14 + v15;
              if ( (unsigned __int8)v17 ^ v18 )
                return;
              if ( !v16 )
              {
                v20 = v19 + 1;
                v1124 = (signed int)(v4[2] + (unsigned __int64)(v1117 * (signed __int64)(v3[2] - v5[2]) / v1113) - v3[2])
                      / v20;
                v1135 = (signed int)(v4[3] + (unsigned __int64)(v1117 * (signed __int64)(v3[3] - v5[3]) / v1113) - v3[3])
                      / v20;
                v1146 = (signed int)(v4[4] + (unsigned __int64)(v1117 * (signed __int64)(v3[4] - v5[4]) / v1113) - v3[4])
                      / v20;
              }
              v1125 = (v5[2] - v3[2]) / v1113;
              v1136 = (v5[3] - v3[3]) / v1113;
              v1147 = (v5[4] - v3[4]) / v1113;
              v21 = *v3 << 16;
              v22 = *v3 << 16;
              v23 = v3[2];
              v24 = v3[3];
              v25 = v3[4];
              if ( v1292 )
              {
                v18 = __OFSUB__(v1123, -v1190);
                v16 = v1123 == -v1190;
                v17 = v1123 + v1190 < 0;
                v1123 += v1190;
                if ( (unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16 )
                  return;
                v1157 = -v1190;
                if ( -v1190 - v1117 >= 0 )
                {
                  v1119 -= v1157 - v1117;
                  v26 = v1157 - v1117;
                  v21 += v1103 * v26 + v1117 * v1103;
                  v27 = v1111 * v26 + v1121;
                  v23 += v26 * v1125 + v1117 * v1125;
                  v24 += v26 * v1136 + v1117 * v1136;
                  v25 += v26 * v1147 + v1117 * v1147;
                  if ( v1300 )
                  {
                    v1119 = dword_DE568;
                    v1123 = dword_DE568;
                  }
                  v28 = &unk_DE56C;
LABEL_51:
                  if ( v1296 )
                  {
                    v31 = (unsigned __int8)byte_E126D;
                  }
                  else
                  {
                    do
                    {
                      *v28 = v21;
                      v21 += v1103;
                      v28[1] = v27;
                      v27 += v1111;
                      v28[2] = v23;
                      v23 += v1125;
                      v28[3] = v24;
                      v24 += v1136;
                      v28[4] = v25;
                      v25 += v1147;
                      v28 += 5;
                      --v1119;
                    }
                    while ( v1119 );
                    v31 = (unsigned __int8)byte_E126D;
                  }
                  goto LABEL_53;
                }
                v1117 += v1190;
                v21 += v1103 * v1157;
                v22 += v1157 * v1107;
                v23 += v1157 * v1125;
                v24 += v1157 * v1136;
                v25 += v1157 * v1147;
                if ( v1300 )
                {
                  v1123 = dword_DE568;
                  if ( v1296 )
                  {
                    v1117 = dword_DE568;
                  }
                  else
                  {
                    v1296 = dword_DE568 <= v1117;
                    v1119 = dword_DE568 - v1117;
                  }
                }
              }
              else if ( v1300 )
              {
                v29 = dword_DE568 - v1190;
                v1123 = dword_DE568 - v1190;
                if ( v1296 )
                {
                  v1117 = dword_DE568 - v1190;
                }
                else
                {
                  v18 = __OFSUB__(v29, v1117);
                  v30 = v29 - v1117;
                  v1296 = (v30 < 0) ^ v18 | (v30 == 0);
                  v1119 = v30;
                }
              }
              v28 = &unk_DE56C;
              do
              {
                *v28 = v21;
                v21 += v1103;
                v28[1] = v22;
                v22 += v1107;
                v28[2] = v23;
                v23 += v1125;
                v28[3] = v24;
                v24 += v1136;
                v28[4] = v25;
                v25 += v1147;
                v28 += 5;
                --v1117;
              }
              while ( v1117 );
              v27 = v1121;
              goto LABEL_51;
          }
        }
        return;
      }
      if ( v7 != v8 )
      {
        if ( v7 <= v8 )
          goto LABEL_24;
        goto LABEL_129;
      }
      if ( *a2 <= *a3 )
        return;
LABEL_234:
      v117 = v3[1];
      v1192 = v117;
      if ( v117 >= 0 )
      {
        if ( v117 >= dword_DE568 )
          return;
        v1102 = dword_DE554 + dword_DE560 * v117;
        v1294 = 0;
      }
      else
      {
        v1102 = dword_DE554;
        v1294 = 1;
      }
      v118 = v5[1];
      v1298 = v118 > dword_DE568;
      v1115 = v118 - v117;
      v1123 = v118 - v117;
      v1105 = ((*v5 - *v3) << 16) / (v118 - v117);
      v1109 = ((*v4 - *v3) << 16) / (v118 - v117);
      switch ( byte_E126D )
      {
        case 0:
        case 0xE:
        case 0xF:
          v139 = *v3 << 16;
          v140 = *v3 << 16;
          if ( v1294 )
          {
            v141 = -v1192;
            v1115 += v1192;
            v18 = __OFSUB__(v1123, -v1192);
            v16 = v1123 == -v1192;
            v17 = v1123 + v1192 < 0;
            v1123 += v1192;
            if ( (unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16 )
              return;
            v139 += v1105 * v141;
            v140 += v141 * v1109;
            if ( v1298 )
            {
              v1123 = dword_DE568;
              v1115 = dword_DE568;
            }
          }
          else if ( v1298 )
          {
            v1123 = dword_DE568 - v1192;
            v1115 = dword_DE568 - v1192;
          }
          v142 = &unk_DE56C;
          do
          {
            *v142 = v139;
            v139 += v1105;
            v142[1] = v140;
            v140 += v1109;
            v142 += 5;
            --v1115;
          }
          while ( v1115 );
          v31 = (unsigned __int8)byte_E126D;
          goto LABEL_53;
        case 1:
        case 4:
        case 0x10:
        case 0x11:
          v1146 = (v4[4] - v5[4]) / (*v4 - *v5);
          v1152 = (v5[4] - v3[4]) / v1123;
          v134 = *v3 << 16;
          v135 = *v3 << 16;
          v136 = v3[4];
          if ( v1294 )
          {
            v137 = -v1192;
            v1115 += v1192;
            v18 = __OFSUB__(v1123, -v1192);
            v16 = v1123 == -v1192;
            v17 = v1123 + v1192 < 0;
            v1123 += v1192;
            if ( (unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16 )
              return;
            v134 += v1105 * v137;
            v135 += v137 * v1109;
            v136 += v137 * v1152;
            if ( v1298 )
            {
              v1123 = dword_DE568;
              v1115 = dword_DE568;
            }
          }
          else if ( v1298 )
          {
            v1123 = dword_DE568 - v1192;
            v1115 = dword_DE568 - v1192;
          }
          v138 = &unk_DE56C;
          do
          {
            *v138 = v134;
            v134 += v1105;
            v138[1] = v135;
            v135 += v1109;
            v138[4] = v136;
            v136 += v1152;
            v138 += 5;
            --v1115;
          }
          while ( v1115 );
          v31 = (unsigned __int8)byte_E126D;
          goto LABEL_53;
        case 2:
        case 3:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xD:
        case 0x12:
        case 0x13:
        case 0x16:
        case 0x17:
          v127 = *v4 - *v5;
          v1124 = (v4[2] - v5[2]) / v127;
          v1135 = (v4[3] - v5[3]) / v127;
          v1130 = (v5[2] - v3[2]) / v1123;
          v1141 = (v5[3] - v3[3]) / v1123;
          v128 = *v3 << 16;
          v129 = *v3 << 16;
          v130 = v3[2];
          v131 = v3[3];
          if ( v1294 )
          {
            v132 = -v1192;
            v1115 += v1192;
            v18 = __OFSUB__(v1123, -v1192);
            v16 = v1123 == -v1192;
            v17 = v1123 + v1192 < 0;
            v1123 += v1192;
            if ( (unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16 )
              return;
            v128 += v1105 * v132;
            v129 += v132 * v1109;
            v130 += v132 * v1130;
            v131 += v132 * v1141;
            if ( v1298 )
            {
              v1123 = dword_DE568;
              v1115 = dword_DE568;
            }
          }
          else if ( v1298 )
          {
            v1123 = dword_DE568 - v1192;
            v1115 = dword_DE568 - v1192;
          }
          v133 = &unk_DE56C;
          do
          {
            *v133 = v128;
            v128 += v1105;
            v133[1] = v129;
            v129 += v1109;
            v133[2] = v130;
            v130 += v1130;
            v133[3] = v131;
            v131 += v1141;
            v133 += 5;
            --v1115;
          }
          while ( v1115 );
          v31 = (unsigned __int8)byte_E126D;
          goto LABEL_53;
        case 5:
        case 6:
        case 0x14:
        case 0x15:
        case 0x18:
        case 0x19:
        case 0x1A:
          v119 = *v4 - *v5;
          v1124 = (v4[2] - v5[2]) / v119;
          v1135 = (v4[3] - v5[3]) / v119;
          v1146 = (v4[4] - v5[4]) / v119;
          v1129 = (v5[2] - v3[2]) / v1123;
          v1140 = (v5[3] - v3[3]) / v1123;
          v1151 = (v5[4] - v3[4]) / v1123;
          v120 = *v3 << 16;
          v121 = *v3 << 16;
          v122 = v3[2];
          v123 = v3[3];
          v124 = v3[4];
          if ( v1294 )
          {
            v125 = -v1192;
            v1115 += v1192;
            v18 = __OFSUB__(v1123, -v1192);
            v16 = v1123 == -v1192;
            v17 = v1123 + v1192 < 0;
            v1123 += v1192;
            if ( (unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16 )
              return;
            v120 += v1105 * v125;
            v121 += v125 * v1109;
            v122 += v125 * v1129;
            v123 += v125 * v1140;
            v124 += v125 * v1151;
            if ( v1298 )
            {
              v1123 = dword_DE568;
              v1115 = dword_DE568;
            }
          }
          else if ( v1298 )
          {
            v1123 = dword_DE568 - v1192;
            v1115 = dword_DE568 - v1192;
          }
          v126 = &unk_DE56C;
          do
          {
            *v126 = v120;
            v120 += v1105;
            v126[1] = v121;
            v121 += v1109;
            v126[2] = v122;
            v122 += v1129;
            v126[3] = v123;
            v123 += v1140;
            v126[4] = v124;
            v124 += v1151;
            v126 += 5;
            --v1115;
          }
          while ( v1115 );
          v31 = (unsigned __int8)byte_E126D;
          goto LABEL_53;
      }
    }
    if ( *a1 <= *a3 )
      return;
    v3 = a3;
    v4 = a1;
    v5 = a2;
LABEL_277:
    v143 = v3[1];
    v1193 = v143;
    if ( v143 >= 0 )
    {
      if ( v143 >= dword_DE568 )
        return;
      v1102 = dword_DE554 + dword_DE560 * v143;
      v1295 = 0;
    }
    else
    {
      v1102 = dword_DE554;
      v1295 = 1;
    }
    v144 = v5[1];
    v1299 = v144 > dword_DE568;
    v1116 = v144 - v143;
    v1123 = v144 - v143;
    v1106 = ((*v5 - *v3) << 16) / (v144 - v143);
    v1110 = ((*v5 - *v4) << 16) / (v144 - v143);
    switch ( byte_E126D )
    {
      case 0:
      case 0xE:
      case 0xF:
        v165 = *v3 << 16;
        v166 = *v4 << 16;
        if ( v1295 )
        {
          v167 = -v1193;
          v1116 += v1193;
          v18 = __OFSUB__(v1123, -v1193);
          v16 = v1123 == -v1193;
          v17 = v1123 + v1193 < 0;
          v1123 += v1193;
          if ( (unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16 )
            return;
          v165 += v1106 * v167;
          v166 += v167 * v1110;
          if ( v1299 )
          {
            v1123 = dword_DE568;
            v1116 = dword_DE568;
          }
        }
        else if ( v1299 )
        {
          v1123 = dword_DE568 - v1193;
          v1116 = dword_DE568 - v1193;
        }
        v168 = &unk_DE56C;
        do
        {
          *v168 = v165;
          v165 += v1106;
          v168[1] = v166;
          v166 += v1110;
          v168 += 5;
          --v1116;
        }
        while ( v1116 );
        v31 = (unsigned __int8)byte_E126D;
        goto LABEL_53;
      case 1:
      case 4:
      case 0x10:
      case 0x11:
        v1146 = (v4[4] - v3[4]) / (*v4 - *v3);
        v1154 = (v5[4] - v3[4]) / v1123;
        v160 = *v3 << 16;
        v161 = *v4 << 16;
        v162 = v3[4];
        if ( v1295 )
        {
          v163 = -v1193;
          v1116 += v1193;
          v18 = __OFSUB__(v1123, -v1193);
          v16 = v1123 == -v1193;
          v17 = v1123 + v1193 < 0;
          v1123 += v1193;
          if ( (unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16 )
            return;
          v160 += v1106 * v163;
          v161 += v163 * v1110;
          v162 += v163 * v1154;
          if ( v1299 )
          {
            v1123 = dword_DE568;
            v1116 = dword_DE568;
          }
        }
        else if ( v1299 )
        {
          v1123 = dword_DE568 - v1193;
          v1116 = dword_DE568 - v1193;
        }
        v164 = &unk_DE56C;
        do
        {
          *v164 = v160;
          v160 += v1106;
          v164[1] = v161;
          v161 += v1110;
          v164[4] = v162;
          v162 += v1154;
          v164 += 5;
          --v1116;
        }
        while ( v1116 );
        v31 = (unsigned __int8)byte_E126D;
        goto LABEL_53;
      case 2:
      case 3:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
      case 0x12:
      case 0x13:
      case 0x16:
      case 0x17:
        v153 = *v4 - *v3;
        v1124 = (v4[2] - v3[2]) / v153;
        v1135 = (v4[3] - v3[3]) / v153;
        v1132 = (v5[2] - v3[2]) / v1123;
        v1143 = (v5[3] - v3[3]) / v1123;
        v154 = *v3 << 16;
        v155 = *v4 << 16;
        v156 = v3[2];
        v157 = v3[3];
        if ( v1295 )
        {
          v158 = -v1193;
          v1116 += v1193;
          v18 = __OFSUB__(v1123, -v1193);
          v16 = v1123 == -v1193;
          v17 = v1123 + v1193 < 0;
          v1123 += v1193;
          if ( (unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16 )
            return;
          v154 += v1106 * v158;
          v155 += v158 * v1110;
          v156 += v158 * v1132;
          v157 += v158 * v1143;
          if ( v1299 )
          {
            v1123 = dword_DE568;
            v1116 = dword_DE568;
          }
        }
        else if ( v1299 )
        {
          v1123 = dword_DE568 - v1193;
          v1116 = dword_DE568 - v1193;
        }
        v159 = &unk_DE56C;
        do
        {
          *v159 = v154;
          v154 += v1106;
          v159[1] = v155;
          v155 += v1110;
          v159[2] = v156;
          v156 += v1132;
          v159[3] = v157;
          v157 += v1143;
          v159 += 5;
          --v1116;
        }
        while ( v1116 );
        v31 = (unsigned __int8)byte_E126D;
        goto LABEL_53;
      case 5:
      case 6:
      case 0x14:
      case 0x15:
      case 0x18:
      case 0x19:
      case 0x1A:
        v145 = *v4 - *v3;
        v1124 = (v4[2] - v3[2]) / v145;
        v1135 = (v4[3] - v3[3]) / v145;
        v1146 = (v4[4] - v3[4]) / v145;
        v1131 = (v5[2] - v3[2]) / v1123;
        v1142 = (v5[3] - v3[3]) / v1123;
        v1153 = (v5[4] - v3[4]) / v1123;
        v146 = *v3 << 16;
        v147 = *v4 << 16;
        v148 = v3[2];
        v149 = v3[3];
        v150 = v3[4];
        if ( v1295 )
        {
          v151 = -v1193;
          v1116 += v1193;
          v18 = __OFSUB__(v1123, -v1193);
          v16 = v1123 == -v1193;
          v17 = v1123 + v1193 < 0;
          v1123 += v1193;
          if ( (unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16 )
            return;
          v146 += v1106 * v151;
          v147 += v151 * v1110;
          v148 += v151 * v1131;
          v149 += v151 * v1142;
          v150 += v151 * v1153;
          if ( v1299 )
          {
            v1123 = dword_DE568;
            v1116 = dword_DE568;
          }
        }
        else if ( v1299 )
        {
          v1123 = dword_DE568 - v1193;
          v1116 = dword_DE568 - v1193;
        }
        v152 = &unk_DE56C;
        do
        {
          *v152 = v146;
          v146 += v1106;
          v152[1] = v147;
          v147 += v1110;
          v152[2] = v148;
          v148 += v1131;
          v152[3] = v149;
          v149 += v1142;
          v152[4] = v150;
          v150 += v1153;
          v152 += 5;
          --v1116;
        }
        while ( v1116 );
        v31 = (unsigned __int8)byte_E126D;
        goto LABEL_53;
    }
  }
  if ( v6 == v8 )
  {
    if ( *a3 <= *a1 )
      return;
    v3 = a2;
    v4 = a3;
    v5 = a1;
    goto LABEL_234;
  }
  if ( v6 < v8 )
  {
    v3 = a2;
    v4 = a3;
    v5 = a1;
    goto LABEL_129;
  }
  if ( v7 == v8 )
  {
    if ( *a3 <= *a2 )
      return;
    v3 = a2;
    v4 = a3;
    v5 = a1;
    goto LABEL_277;
  }
  if ( v7 < v8 )
  {
    v3 = a2;
    v4 = a3;
    v5 = a1;
    goto LABEL_24;
  }
  v3 = a3;
  v4 = a1;
  v5 = a2;
LABEL_129:
  v65 = v3[1];
  v1191 = v65;
  if ( v65 >= 0 )
  {
    if ( v65 >= dword_DE568 )
      return;
    v1102 = dword_DE554 + dword_DE560 * v65;
    v1293 = 0;
  }
  else
  {
    v1102 = dword_DE554;
    v1293 = 1;
  }
  v66 = v5[1];
  v1297 = v66 > dword_DE568;
  v1114 = v66 - v65;
  v67 = v4[1];
  v1301 = v67 > dword_DE568;
  v68 = v67 - v65;
  v1118 = v68;
  v1123 = v68;
  v1104 = ((*v5 - *v3) << 16) / v1114;
  if ( ((*v4 - *v3) << 16) / v68 > v1104 )
  {
    v1108 = ((*v4 - *v3) << 16) / v68;
    v1112 = ((*v4 - *v5) << 16) / (v4[1] - v5[1]);
    v1120 = v4[1] - v5[1];
    v1122 = *v5 << 16;
    switch ( byte_E126D )
    {
      case 0:
      case 0xE:
      case 0xF:
        v110 = *v3 << 16;
        v111 = *v3 << 16;
        if ( v1293 )
        {
          v18 = __OFSUB__(v1123, -v1191);
          v16 = v1123 == -v1191;
          v17 = v1123 + v1191 < 0;
          v1123 += v1191;
          if ( (unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16 )
            return;
          v1164 = -v1191;
          if ( -v1191 - v1114 >= 0 )
          {
            v112 = v1164 - v1114;
            v1120 -= v112;
            v113 = v1112 * v112 + v1122;
            v111 += v112 * v1108 + v1114 * v1108;
            if ( v1301 )
            {
              v1120 = dword_DE568;
              v1123 = dword_DE568;
            }
            v114 = (int *)&unk_DE56C;
            goto LABEL_228;
          }
          v1114 += v1191;
          v110 += v1104 * v1164;
          v111 += v1164 * v1108;
          if ( v1301 )
          {
            v1123 = dword_DE568;
            if ( v1297 )
            {
              v1114 = dword_DE568;
            }
            else
            {
              v1297 = dword_DE568 <= v1114;
              v1120 = dword_DE568 - v1114;
            }
          }
        }
        else if ( v1301 )
        {
          v115 = dword_DE568 - v1191;
          v1123 = dword_DE568 - v1191;
          if ( v1297 )
          {
            v1114 = dword_DE568 - v1191;
          }
          else
          {
            v18 = __OFSUB__(v115, v1114);
            v116 = v115 - v1114;
            v1297 = (v116 < 0) ^ v18 | (v116 == 0);
            v1120 = v116;
          }
        }
        v114 = (int *)&unk_DE56C;
        do
        {
          *v114 = v110;
          v110 += v1104;
          v114[1] = v111;
          v111 += v1108;
          v114 += 5;
          --v1114;
        }
        while ( v1114 );
        v113 = v1122;
LABEL_228:
        if ( v1297 )
        {
          v31 = (unsigned __int8)byte_E126D;
        }
        else
        {
          do
          {
            *v114 = v113;
            v113 += v1112;
            v114[1] = v111;
            v111 += v1108;
            v114 += 5;
            --v1120;
          }
          while ( v1120 );
          v31 = (unsigned __int8)byte_E126D;
        }
        goto LABEL_53;
      case 1:
      case 4:
      case 0x10:
      case 0x11:
        v98 = v1114 * (signed __int64)(*v4 - *v3) / v68;
        v99 = *v3 - *v5;
        v18 = __OFADD__(v98, v99);
        v100 = v98 + v99 == 0;
        v17 = v98 + v99 < 0;
        v101 = v98 + v99;
        if ( (unsigned __int8)v17 ^ v18 )
          return;
        if ( !v100 )
          v1146 = (signed int)(v3[4] + (unsigned __int64)(v1114 * (signed __int64)(v4[4] - v3[4]) / v1118) - v5[4])
                / (v101 + 1);
        v1150 = (v5[4] - v3[4]) / v1114;
        v1156 = (v4[4] - v5[4]) / v1120;
        v102 = *v3 << 16;
        v103 = *v3 << 16;
        v104 = v3[4];
        if ( v1293 )
        {
          v18 = __OFSUB__(v1123, -v1191);
          v16 = v1123 == -v1191;
          v17 = v1123 + v1191 < 0;
          v1123 += v1191;
          if ( (unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16 )
            return;
          v1163 = -v1191;
          if ( -v1191 - v1114 >= 0 )
          {
            v105 = v1163 - v1114;
            v1120 -= v105;
            v106 = v1112 * v105 + v1122;
            v103 += v105 * v1108 + v1114 * v1108;
            v104 += v105 * v1156 + v1114 * v1150;
            if ( v1301 )
            {
              v1120 = dword_DE568;
              v1123 = dword_DE568;
            }
            v107 = (int *)&unk_DE56C;
LABEL_206:
            if ( v1297 )
            {
              v31 = (unsigned __int8)byte_E126D;
            }
            else
            {
              do
              {
                *v107 = v106;
                v106 += v1112;
                v107[1] = v103;
                v103 += v1108;
                v107[4] = v104;
                v104 += v1156;
                v107 += 5;
                --v1120;
              }
              while ( v1120 );
              v31 = (unsigned __int8)byte_E126D;
            }
            goto LABEL_53;
          }
          v1114 += v1191;
          v102 += v1104 * v1163;
          v103 += v1163 * v1108;
          v104 += v1163 * v1150;
          if ( v1301 )
          {
            v1123 = dword_DE568;
            if ( v1297 )
            {
              v1114 = dword_DE568;
            }
            else
            {
              v1297 = dword_DE568 <= v1114;
              v1120 = dword_DE568 - v1114;
            }
          }
        }
        else if ( v1301 )
        {
          v108 = dword_DE568 - v1191;
          v1123 = dword_DE568 - v1191;
          if ( v1297 )
          {
            v1114 = dword_DE568 - v1191;
          }
          else
          {
            v18 = __OFSUB__(v108, v1114);
            v109 = v108 - v1114;
            v1297 = (v109 < 0) ^ v18 | (v109 == 0);
            v1120 = v109;
          }
        }
        v107 = (int *)&unk_DE56C;
        do
        {
          *v107 = v102;
          v102 += v1104;
          v107[1] = v103;
          v103 += v1108;
          v107[4] = v104;
          v104 += v1150;
          v107 += 5;
          --v1114;
        }
        while ( v1114 );
        v106 = v1122;
        goto LABEL_206;
      case 2:
      case 3:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
      case 0x12:
      case 0x13:
      case 0x16:
      case 0x17:
        v84 = v1114 * (signed __int64)(*v4 - *v3) / v68;
        v85 = *v3 - *v5;
        v18 = __OFADD__(v84, v85);
        v86 = v84 + v85 == 0;
        v17 = v84 + v85 < 0;
        v87 = v84 + v85;
        if ( (unsigned __int8)v17 ^ v18 )
          return;
        if ( !v86 )
        {
          v88 = v87 + 1;
          v1124 = (signed int)(v3[2] + (unsigned __int64)(v1114 * (signed __int64)(v4[2] - v3[2]) / v1118) - v5[2])
                / v88;
          v1135 = (signed int)(v3[3] + (unsigned __int64)(v1114 * (signed __int64)(v4[3] - v3[3]) / v1118) - v5[3])
                / v88;
        }
        v1128 = (v5[2] - v3[2]) / v1114;
        v1139 = (v5[3] - v3[3]) / v1114;
        v1134 = (v4[2] - v5[2]) / v1120;
        v1145 = (v4[3] - v5[3]) / v1120;
        v89 = *v3 << 16;
        v90 = *v3 << 16;
        v91 = v3[2];
        v92 = v3[3];
        if ( v1293 )
        {
          v18 = __OFSUB__(v1123, -v1191);
          v16 = v1123 == -v1191;
          v17 = v1123 + v1191 < 0;
          v1123 += v1191;
          if ( (unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16 )
            return;
          v1162 = -v1191;
          if ( -v1191 - v1114 >= 0 )
          {
            v93 = v1162 - v1114;
            v1120 -= v93;
            v94 = v1112 * v93 + v1122;
            v90 += v93 * v1108 + v1114 * v1108;
            v91 += v93 * v1134 + v1114 * v1128;
            v92 += v93 * v1145 + v1114 * v1139;
            if ( v1301 )
            {
              v1120 = dword_DE568;
              v1123 = dword_DE568;
            }
            v95 = (int *)&unk_DE56C;
LABEL_181:
            if ( v1297 )
            {
              v31 = (unsigned __int8)byte_E126D;
            }
            else
            {
              do
              {
                *v95 = v94;
                v94 += v1112;
                v95[1] = v90;
                v90 += v1108;
                v95[2] = v91;
                v91 += v1134;
                v95[3] = v92;
                v92 += v1145;
                v95 += 5;
                --v1120;
              }
              while ( v1120 );
              v31 = (unsigned __int8)byte_E126D;
            }
            goto LABEL_53;
          }
          v1114 += v1191;
          v89 += v1104 * v1162;
          v90 += v1162 * v1108;
          v91 += v1162 * v1128;
          v92 += v1162 * v1139;
          if ( v1301 )
          {
            v1123 = dword_DE568;
            if ( v1297 )
            {
              v1114 = dword_DE568;
            }
            else
            {
              v1297 = dword_DE568 <= v1114;
              v1120 = dword_DE568 - v1114;
            }
          }
        }
        else if ( v1301 )
        {
          v96 = dword_DE568 - v1191;
          v1123 = dword_DE568 - v1191;
          if ( v1297 )
          {
            v1114 = dword_DE568 - v1191;
          }
          else
          {
            v18 = __OFSUB__(v96, v1114);
            v97 = v96 - v1114;
            v1297 = (v97 < 0) ^ v18 | (v97 == 0);
            v1120 = v97;
          }
        }
        v95 = (int *)&unk_DE56C;
        do
        {
          *v95 = v89;
          v89 += v1104;
          v95[1] = v90;
          v90 += v1108;
          v95[2] = v91;
          v91 += v1128;
          v95[3] = v92;
          v92 += v1139;
          v95 += 5;
          --v1114;
        }
        while ( v1114 );
        v94 = v1122;
        goto LABEL_181;
      case 5:
      case 6:
      case 0x14:
      case 0x15:
      case 0x18:
      case 0x19:
      case 0x1A:
        v69 = v1114 * (signed __int64)(*v4 - *v3) / v68;
        v70 = *v3 - *v5;
        v18 = __OFADD__(v69, v70);
        v71 = v69 + v70 == 0;
        v17 = v69 + v70 < 0;
        v72 = v69 + v70;
        if ( (unsigned __int8)v17 ^ v18 )
          return;
        if ( !v71 )
        {
          v73 = v72 + 1;
          v1124 = (signed int)(v3[2] + (unsigned __int64)(v1114 * (signed __int64)(v4[2] - v3[2]) / v1118) - v5[2])
                / v73;
          v1135 = (signed int)(v3[3] + (unsigned __int64)(v1114 * (signed __int64)(v4[3] - v3[3]) / v1118) - v5[3])
                / v73;
          v69 = (signed int)(v3[4] + (unsigned __int64)(v1114 * (signed __int64)(v4[4] - v3[4]) / v1118) - v5[4]) / v73;
        }
        v1146 = v69;
        v1127 = (v5[2] - v3[2]) / v1114;
        v1138 = (v5[3] - v3[3]) / v1114;
        v1149 = (v5[4] - v3[4]) / v1114;
        v1133 = (v4[2] - v5[2]) / v1120;
        v1144 = (v4[3] - v5[3]) / v1120;
        v1155 = (v4[4] - v5[4]) / v1120;
        v74 = *v3 << 16;
        v75 = *v3 << 16;
        v76 = v3[2];
        v77 = v3[3];
        v78 = v3[4];
        if ( v1293 )
        {
          v18 = __OFSUB__(v1123, -v1191);
          v16 = v1123 == -v1191;
          v17 = v1123 + v1191 < 0;
          v1123 += v1191;
          if ( (unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16 )
            return;
          v1161 = -v1191;
          if ( -v1191 - v1114 >= 0 )
          {
            v79 = v1161 - v1114;
            v1120 -= v79;
            v80 = v1112 * v79 + v1122;
            v75 += v79 * v1108 + v1114 * v1108;
            v76 += v79 * v1133 + v1114 * v1127;
            v77 += v79 * v1144 + v1114 * v1138;
            v78 += v79 * v1155 + v1114 * v1149;
            if ( v1301 )
            {
              v1120 = dword_DE568;
              v1123 = dword_DE568;
            }
            v81 = (int *)&unk_DE56C;
LABEL_156:
            if ( v1297 )
            {
              v31 = (unsigned __int8)byte_E126D;
            }
            else
            {
              do
              {
                *v81 = v80;
                v80 += v1112;
                v81[1] = v75;
                v75 += v1108;
                v81[2] = v76;
                v76 += v1133;
                v81[3] = v77;
                v77 += v1144;
                v81[4] = v78;
                v78 += v1155;
                v81 += 5;
                --v1120;
              }
              while ( v1120 );
              v31 = (unsigned __int8)byte_E126D;
            }
LABEL_53:
            switch ( byte_E126D )
            {
              case 0:
                v169 = (unsigned __int16 *)&unk_DE56C;
                v170 = (char *)v1102;
                v171 = byte_E126C;
                HIWORD(v172) = 0;
                while ( 1 )
                {
                  LOWORD(v172) = v169[1];
                  v173 = v169[3];
                  v170 += dword_DE560;
                  if ( (v172 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v173 > 0 )
                  {
                    if ( v173 > dword_DE564 )
                      v173 = dword_DE564;
                    v174 = v170;
LABEL_328:
                    memset(v174, v171, v173);
                  }
LABEL_329:
                  v169 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v173 > dword_DE564 )
                  v173 = dword_DE564;
                v18 = __OFSUB__((_WORD)v173, (_WORD)v172);
                LOWORD(v173) = v173 - v172;
                if ( (unsigned __int8)(((v173 & 0x8000u) != 0) ^ v18) | ((_WORD)v173 == 0) )
                  goto LABEL_329;
                v174 = &v170[v172];
                goto LABEL_328;
              case 1:
                v175 = (unsigned __int16 *)&unk_DE56C;
                while ( 1 )
                {
                  LOWORD(v31) = v175[1];
                  v176 = v175[3];
                  v177 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v31 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v176 > 0 )
                  {
                    v178 = v1146 * (unsigned __int16)-(signed __int16)v31;
                    v179 = v178;
                    v31 = v178 >> 8;
                    v180 = __CFADD__(v175[8], v179);
                    v181 = v175[8] + v179;
                    BYTE1(v31) += *((_BYTE *)v175 + 18) + v180;
                    if ( v176 > dword_DE564 )
                      LOWORD(v176) = dword_DE564;
                    v31 = (unsigned __int16)v31;
LABEL_341:
                    while ( 1 )
                    {
                      *v177 = BYTE1(v31);
                      v180 = __CFADD__((_WORD)v1146, v181);
                      v182 = v1146 + v181;
                      v183 = BYTE2(v1146) + v180 + BYTE1(v31);
                      v184 = v176 - 1;
                      if ( !v184 )
                        break;
                      v177[1] = v183;
                      v180 = __CFADD__((_WORD)v1146, v182);
                      v185 = v1146 + v182;
                      v186 = BYTE2(v1146) + v180 + v183;
                      v187 = v184 - 1;
                      if ( !v187 )
                        break;
                      v177[2] = v186;
                      v180 = __CFADD__((_WORD)v1146, v185);
                      v188 = v1146 + v185;
                      v189 = BYTE2(v1146) + v180 + v186;
                      v190 = v187 - 1;
                      if ( !v190 )
                        break;
                      v177[3] = v189;
                      v180 = __CFADD__((_WORD)v1146, v188);
                      v191 = v1146 + v188;
                      v192 = BYTE2(v1146) + v180 + v189;
                      v193 = v190 - 1;
                      if ( !v193 )
                        break;
                      v177[4] = v192;
                      v180 = __CFADD__((_WORD)v1146, v191);
                      v194 = v1146 + v191;
                      v195 = BYTE2(v1146) + v180 + v192;
                      v196 = v193 - 1;
                      if ( !v196 )
                        break;
                      v177[5] = v195;
                      v180 = __CFADD__((_WORD)v1146, v194);
                      v197 = v1146 + v194;
                      v198 = BYTE2(v1146) + v180 + v195;
                      v199 = v196 - 1;
                      if ( !v199 )
                        break;
                      v177[6] = v198;
                      v180 = __CFADD__((_WORD)v1146, v197);
                      v200 = v1146 + v197;
                      v201 = BYTE2(v1146) + v180 + v198;
                      v202 = v199 - 1;
                      if ( !v202 )
                        break;
                      v177[7] = v201;
                      v180 = __CFADD__((_WORD)v1146, v200);
                      v203 = v1146 + v200;
                      v204 = BYTE2(v1146) + v180 + v201;
                      v205 = v202 - 1;
                      if ( !v205 )
                        break;
                      v177[8] = v204;
                      v180 = __CFADD__((_WORD)v1146, v203);
                      v206 = v1146 + v203;
                      v207 = BYTE2(v1146) + v180 + v204;
                      v208 = v205 - 1;
                      if ( !v208 )
                        break;
                      v177[9] = v207;
                      v180 = __CFADD__((_WORD)v1146, v206);
                      v209 = v1146 + v206;
                      v210 = BYTE2(v1146) + v180 + v207;
                      v211 = v208 - 1;
                      if ( !v211 )
                        break;
                      v177[10] = v210;
                      v180 = __CFADD__((_WORD)v1146, v209);
                      v212 = v1146 + v209;
                      v213 = BYTE2(v1146) + v180 + v210;
                      v214 = v211 - 1;
                      if ( !v214 )
                        break;
                      v177[11] = v213;
                      v180 = __CFADD__((_WORD)v1146, v212);
                      v215 = v1146 + v212;
                      v216 = BYTE2(v1146) + v180 + v213;
                      v217 = v214 - 1;
                      if ( !v217 )
                        break;
                      v177[12] = v216;
                      v180 = __CFADD__((_WORD)v1146, v215);
                      v218 = v1146 + v215;
                      v219 = BYTE2(v1146) + v180 + v216;
                      v220 = v217 - 1;
                      if ( !v220 )
                        break;
                      v177[13] = v219;
                      v180 = __CFADD__((_WORD)v1146, v218);
                      v221 = v1146 + v218;
                      v222 = BYTE2(v1146) + v180 + v219;
                      v223 = v220 - 1;
                      if ( !v223 )
                        break;
                      v177[14] = v222;
                      v180 = __CFADD__((_WORD)v1146, v221);
                      v224 = v1146 + v221;
                      v225 = BYTE2(v1146) + v180 + v222;
                      v226 = v223 - 1;
                      if ( !v226 )
                        break;
                      v177[15] = v225;
                      v180 = __CFADD__((_WORD)v1146, v224);
                      v181 = v1146 + v224;
                      BYTE1(v31) = BYTE2(v1146) + v180 + v225;
                      LOWORD(v176) = v226 - 1;
                      if ( !(_WORD)v176 )
                        break;
                      v177 += 16;
                    }
                  }
LABEL_358:
                  v175 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v176 > dword_DE564 )
                  LOWORD(v176) = dword_DE564;
                v18 = __OFSUB__((_WORD)v176, (_WORD)v31);
                LOWORD(v176) = v176 - v31;
                if ( (unsigned __int8)(((v176 & 0x8000u) != 0) ^ v18) | ((_WORD)v176 == 0) )
                  goto LABEL_358;
                v177 += v31;
                v31 = (unsigned __int8)byte_E126C;
                v181 = v175[8];
                BYTE1(v31) = *((_BYTE *)v175 + 18);
                goto LABEL_341;
              case 2:
                v227 = (unsigned __int16 *)&unk_DE56C;
                v1165 = v1135 << 16;
                HIWORD(v228) = 0;
                HIWORD(v229) = 0;
                while ( 1 )
                {
                  LOWORD(v228) = v227[1];
                  v230 = v227[3];
                  v231 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v228 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v230 > 0 )
                  {
                    v232 = (unsigned __int16)-(signed __int16)v228;
                    v234 = __ROL4__(*((_DWORD *)v227 + 3) + v1135 * v232, 16);
                    BYTE1(v229) = v234;
                    v233 = *((_DWORD *)v227 + 2) + v1124 * v232;
                    LOWORD(v234) = v233;
                    v235 = v233 >> 8;
                    LOBYTE(v229) = BYTE1(v235);
                    if ( v230 > dword_DE564 )
                      LOWORD(v230) = dword_DE564;
                    v228 = (unsigned __int16)v235;
LABEL_370:
                    v1274 = v227;
                    v236 = dword_DE55C;
                    while ( 1 )
                    {
                      v237 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v234);
                      LOWORD(v234) = v1124 + v234;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      *v231 = v237;
                      v180 = __CFADD__(v1165, v234);
                      v238 = v1165 + v234;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      v239 = v230 - 1;
                      if ( !v239 )
                        break;
                      v240 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v238);
                      LOWORD(v238) = v1124 + v238;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      v231[1] = v240;
                      v180 = __CFADD__(v1165, v238);
                      v241 = v1165 + v238;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      v242 = v239 - 1;
                      if ( !v242 )
                        break;
                      v243 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v241);
                      LOWORD(v241) = v1124 + v241;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      v231[2] = v243;
                      v180 = __CFADD__(v1165, v241);
                      v244 = v1165 + v241;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      v245 = v242 - 1;
                      if ( !v245 )
                        break;
                      v246 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v244);
                      LOWORD(v244) = v1124 + v244;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      v231[3] = v246;
                      v180 = __CFADD__(v1165, v244);
                      v247 = v1165 + v244;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      v248 = v245 - 1;
                      if ( !v248 )
                        break;
                      v249 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v247);
                      LOWORD(v247) = v1124 + v247;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      v231[4] = v249;
                      v180 = __CFADD__(v1165, v247);
                      v250 = v1165 + v247;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      v251 = v248 - 1;
                      if ( !v251 )
                        break;
                      v252 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v250);
                      LOWORD(v250) = v1124 + v250;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      v231[5] = v252;
                      v180 = __CFADD__(v1165, v250);
                      v253 = v1165 + v250;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      v254 = v251 - 1;
                      if ( !v254 )
                        break;
                      v255 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v253);
                      LOWORD(v253) = v1124 + v253;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      v231[6] = v255;
                      v180 = __CFADD__(v1165, v253);
                      v256 = v1165 + v253;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      v257 = v254 - 1;
                      if ( !v257 )
                        break;
                      v258 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v256);
                      LOWORD(v256) = v1124 + v256;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      v231[7] = v258;
                      v180 = __CFADD__(v1165, v256);
                      v259 = v1165 + v256;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      v260 = v257 - 1;
                      if ( !v260 )
                        break;
                      v261 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v259);
                      LOWORD(v259) = v1124 + v259;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      v231[8] = v261;
                      v180 = __CFADD__(v1165, v259);
                      v262 = v1165 + v259;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      v263 = v260 - 1;
                      if ( !v263 )
                        break;
                      v264 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v262);
                      LOWORD(v262) = v1124 + v262;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      v231[9] = v264;
                      v180 = __CFADD__(v1165, v262);
                      v265 = v1165 + v262;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      v266 = v263 - 1;
                      if ( !v266 )
                        break;
                      v267 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v265);
                      LOWORD(v265) = v1124 + v265;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      v231[10] = v267;
                      v180 = __CFADD__(v1165, v265);
                      v268 = v1165 + v265;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      v269 = v266 - 1;
                      if ( !v269 )
                        break;
                      v270 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v268);
                      LOWORD(v268) = v1124 + v268;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      v231[11] = v270;
                      v180 = __CFADD__(v1165, v268);
                      v271 = v1165 + v268;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      v272 = v269 - 1;
                      if ( !v272 )
                        break;
                      v273 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v271);
                      LOWORD(v271) = v1124 + v271;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      v231[12] = v273;
                      v180 = __CFADD__(v1165, v271);
                      v274 = v1165 + v271;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      v275 = v272 - 1;
                      if ( !v275 )
                        break;
                      v276 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v274);
                      LOWORD(v274) = v1124 + v274;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      v231[13] = v276;
                      v180 = __CFADD__(v1165, v274);
                      v277 = v1165 + v274;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      v278 = v275 - 1;
                      if ( !v278 )
                        break;
                      v279 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v277);
                      LOWORD(v277) = v1124 + v277;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      v231[14] = v279;
                      v180 = __CFADD__(v1165, v277);
                      v280 = v1165 + v277;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      v281 = v278 - 1;
                      if ( !v281 )
                        break;
                      v282 = *(_BYTE *)(v229 + v236);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v280);
                      LOWORD(v280) = v1124 + v280;
                      LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
                      v231[15] = v282;
                      v180 = __CFADD__(v1165, v280);
                      v234 = v1165 + v280;
                      BYTE1(v229) += BYTE2(v1135) + v180;
                      LOWORD(v230) = v281 - 1;
                      if ( !(_WORD)v230 )
                        break;
                      v231 += 16;
                    }
                    v227 = v1274;
                  }
LABEL_389:
                  v227 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v230 > dword_DE564 )
                  LOWORD(v230) = dword_DE564;
                v18 = __OFSUB__((_WORD)v230, (_WORD)v228);
                LOWORD(v230) = v230 - v228;
                if ( (unsigned __int8)(((v230 & 0x8000u) != 0) ^ v18) | ((_WORD)v230 == 0) )
                  goto LABEL_389;
                v231 += v228;
                v234 = __ROL4__(*((_DWORD *)v227 + 3), 16);
                BYTE1(v229) = v234;
                LOWORD(v234) = v227[4];
                LOBYTE(v229) = *((_BYTE *)v227 + 10);
                goto LABEL_370;
              case 3:
                v283 = (unsigned __int16 *)&unk_DE56C;
                v1166 = v1135 << 16;
                HIWORD(v284) = 0;
                HIWORD(v285) = 0;
                while ( 1 )
                {
                  LOWORD(v284) = v283[1];
                  v286 = v283[3];
                  v287 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v284 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v286 > 0 )
                  {
                    v288 = (unsigned __int16)-(signed __int16)v284;
                    v290 = __ROL4__(*((_DWORD *)v283 + 3) + v1135 * v288, 16);
                    BYTE1(v285) = v290;
                    v289 = *((_DWORD *)v283 + 2) + v1124 * v288;
                    LOWORD(v290) = v289;
                    v291 = v289 >> 8;
                    LOBYTE(v285) = BYTE1(v291);
                    if ( v286 > dword_DE564 )
                      LOWORD(v286) = dword_DE564;
                    v284 = (unsigned __int16)v291;
LABEL_401:
                    v1275 = v283;
                    v292 = dword_DE55C;
                    while ( 1 )
                    {
                      v293 = *(_BYTE *)(v285 + v292);
                      if ( v293 )
                        *v287 = v293;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v290);
                      LOWORD(v290) = v1124 + v290;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v290);
                      v294 = v1166 + v290;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      v295 = v286 - 1;
                      if ( !v295 )
                        break;
                      v296 = *(_BYTE *)(v285 + v292);
                      if ( v296 )
                        v287[1] = v296;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v294);
                      LOWORD(v294) = v1124 + v294;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v294);
                      v297 = v1166 + v294;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      v298 = v295 - 1;
                      if ( !v298 )
                        break;
                      v299 = *(_BYTE *)(v285 + v292);
                      if ( v299 )
                        v287[2] = v299;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v297);
                      LOWORD(v297) = v1124 + v297;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v297);
                      v300 = v1166 + v297;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      v301 = v298 - 1;
                      if ( !v301 )
                        break;
                      v302 = *(_BYTE *)(v285 + v292);
                      if ( v302 )
                        v287[3] = v302;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v300);
                      LOWORD(v300) = v1124 + v300;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v300);
                      v303 = v1166 + v300;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      v304 = v301 - 1;
                      if ( !v304 )
                        break;
                      v305 = *(_BYTE *)(v285 + v292);
                      if ( v305 )
                        v287[4] = v305;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v303);
                      LOWORD(v303) = v1124 + v303;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v303);
                      v306 = v1166 + v303;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      v307 = v304 - 1;
                      if ( !v307 )
                        break;
                      v308 = *(_BYTE *)(v285 + v292);
                      if ( v308 )
                        v287[5] = v308;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v306);
                      LOWORD(v306) = v1124 + v306;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v306);
                      v309 = v1166 + v306;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      v310 = v307 - 1;
                      if ( !v310 )
                        break;
                      v311 = *(_BYTE *)(v285 + v292);
                      if ( v311 )
                        v287[6] = v311;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v309);
                      LOWORD(v309) = v1124 + v309;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v309);
                      v312 = v1166 + v309;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      v313 = v310 - 1;
                      if ( !v313 )
                        break;
                      v314 = *(_BYTE *)(v285 + v292);
                      if ( v314 )
                        v287[7] = v314;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v312);
                      LOWORD(v312) = v1124 + v312;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v312);
                      v315 = v1166 + v312;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      v316 = v313 - 1;
                      if ( !v316 )
                        break;
                      v317 = *(_BYTE *)(v285 + v292);
                      if ( v317 )
                        v287[8] = v317;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v315);
                      LOWORD(v315) = v1124 + v315;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v315);
                      v318 = v1166 + v315;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      v319 = v316 - 1;
                      if ( !v319 )
                        break;
                      v320 = *(_BYTE *)(v285 + v292);
                      if ( v320 )
                        v287[9] = v320;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v318);
                      LOWORD(v318) = v1124 + v318;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v318);
                      v321 = v1166 + v318;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      v322 = v319 - 1;
                      if ( !v322 )
                        break;
                      v323 = *(_BYTE *)(v285 + v292);
                      if ( v323 )
                        v287[10] = v323;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v321);
                      LOWORD(v321) = v1124 + v321;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v321);
                      v324 = v1166 + v321;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      v325 = v322 - 1;
                      if ( !v325 )
                        break;
                      v326 = *(_BYTE *)(v285 + v292);
                      if ( v326 )
                        v287[11] = v326;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v324);
                      LOWORD(v324) = v1124 + v324;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v324);
                      v327 = v1166 + v324;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      v328 = v325 - 1;
                      if ( !v328 )
                        break;
                      v329 = *(_BYTE *)(v285 + v292);
                      if ( v329 )
                        v287[12] = v329;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v327);
                      LOWORD(v327) = v1124 + v327;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v327);
                      v330 = v1166 + v327;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      v331 = v328 - 1;
                      if ( !v331 )
                        break;
                      v332 = *(_BYTE *)(v285 + v292);
                      if ( v332 )
                        v287[13] = v332;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v330);
                      LOWORD(v330) = v1124 + v330;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v330);
                      v333 = v1166 + v330;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      v334 = v331 - 1;
                      if ( !v334 )
                        break;
                      v335 = *(_BYTE *)(v285 + v292);
                      if ( v335 )
                        v287[14] = v335;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v333);
                      LOWORD(v333) = v1124 + v333;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v333);
                      v336 = v1166 + v333;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      v337 = v334 - 1;
                      if ( !v337 )
                        break;
                      v338 = *(_BYTE *)(v285 + v292);
                      if ( v338 )
                        v287[15] = v338;
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v336);
                      LOWORD(v336) = v1124 + v336;
                      LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
                      v180 = __CFADD__(v1166, v336);
                      v290 = v1166 + v336;
                      BYTE1(v285) += BYTE2(v1135) + v180;
                      LOWORD(v286) = v337 - 1;
                      if ( !(_WORD)v286 )
                        break;
                      v287 += 16;
                    }
                    v283 = v1275;
                  }
LABEL_452:
                  v283 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v286 > dword_DE564 )
                  LOWORD(v286) = dword_DE564;
                v18 = __OFSUB__((_WORD)v286, (_WORD)v284);
                LOWORD(v286) = v286 - v284;
                if ( (unsigned __int8)(((v286 & 0x8000u) != 0) ^ v18) | ((_WORD)v286 == 0) )
                  goto LABEL_452;
                v287 += v284;
                v290 = __ROL4__(*((_DWORD *)v283 + 3), 16);
                BYTE1(v285) = v290;
                LOWORD(v290) = v283[4];
                LOBYTE(v285) = *((_BYTE *)v283 + 10);
                goto LABEL_401;
              case 4:
                v339 = (unsigned __int16 *)&unk_DE56C;
                while ( 1 )
                {
                  LOWORD(v31) = v339[1];
                  v340 = v339[3];
                  v341 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v31 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v340 > 0 )
                  {
                    v342 = v1146 * (unsigned __int16)-(signed __int16)v31;
                    v343 = v342;
                    v31 = v342 >> 8;
                    v180 = __CFADD__(v339[8], v343);
                    v344 = v339[8] + v343;
                    BYTE1(v31) += *((_BYTE *)v339 + 18) + v180;
                    if ( v340 > dword_DE564 )
                      LOWORD(v340) = dword_DE564;
                    v31 = (unsigned __int16)v31;
                    LOBYTE(v31) = byte_E126C;
LABEL_464:
                    while ( 1 )
                    {
                      *v341 = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v344);
                      v345 = v1146 + v344;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v346 = v340 - 1;
                      if ( !v346 )
                        break;
                      v341[1] = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v345);
                      v347 = v1146 + v345;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v348 = v346 - 1;
                      if ( !v348 )
                        break;
                      v341[2] = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v347);
                      v349 = v1146 + v347;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v350 = v348 - 1;
                      if ( !v350 )
                        break;
                      v341[3] = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v349);
                      v351 = v1146 + v349;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v352 = v350 - 1;
                      if ( !v352 )
                        break;
                      v341[4] = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v351);
                      v353 = v1146 + v351;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v354 = v352 - 1;
                      if ( !v354 )
                        break;
                      v341[5] = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v353);
                      v355 = v1146 + v353;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v356 = v354 - 1;
                      if ( !v356 )
                        break;
                      v341[6] = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v355);
                      v357 = v1146 + v355;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v358 = v356 - 1;
                      if ( !v358 )
                        break;
                      v341[7] = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v357);
                      v359 = v1146 + v357;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v360 = v358 - 1;
                      if ( !v360 )
                        break;
                      v341[8] = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v359);
                      v361 = v1146 + v359;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v362 = v360 - 1;
                      if ( !v362 )
                        break;
                      v341[9] = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v361);
                      v363 = v1146 + v361;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v364 = v362 - 1;
                      if ( !v364 )
                        break;
                      v341[10] = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v363);
                      v365 = v1146 + v363;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v366 = v364 - 1;
                      if ( !v366 )
                        break;
                      v341[11] = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v365);
                      v367 = v1146 + v365;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v368 = v366 - 1;
                      if ( !v368 )
                        break;
                      v341[12] = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v367);
                      v369 = v1146 + v367;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v370 = v368 - 1;
                      if ( !v370 )
                        break;
                      v341[13] = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v369);
                      v371 = v1146 + v369;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v372 = v370 - 1;
                      if ( !v372 )
                        break;
                      v341[14] = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v371);
                      v373 = v1146 + v371;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v374 = v372 - 1;
                      if ( !v374 )
                        break;
                      v341[15] = byte_F6EE0[v31];
                      v180 = __CFADD__((_WORD)v1146, v373);
                      v344 = v1146 + v373;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      LOWORD(v340) = v374 - 1;
                      if ( !(_WORD)v340 )
                        break;
                      v341 += 16;
                    }
                  }
LABEL_481:
                  v339 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v340 > dword_DE564 )
                  LOWORD(v340) = dword_DE564;
                v18 = __OFSUB__((_WORD)v340, (_WORD)v31);
                LOWORD(v340) = v340 - v31;
                if ( (unsigned __int8)(((v340 & 0x8000u) != 0) ^ v18) | ((_WORD)v340 == 0) )
                  goto LABEL_481;
                v341 += v31;
                v31 = (unsigned __int8)byte_E126C;
                v344 = v339[8];
                BYTE1(v31) = *((_BYTE *)v339 + 18);
                goto LABEL_464;
              case 5:
                v1276 = (char *)&unk_DE56C;
                v1167 = v1135 << 16;
                v1183 = v1146 << 16;
                HIWORD(v375) = 0;
                HIWORD(v376) = 0;
                while ( 1 )
                {
                  v377 = v1276;
                  v1276 += 20;
                  LOWORD(v375) = *((_WORD *)v377 + 1);
                  v378 = *((unsigned __int16 *)v377 + 3);
                  v379 = dword_DE560 + v1102;
                  v1102 += dword_DE560;
                  if ( (v375 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v378 > 0 )
                  {
                    v380 = (unsigned __int16)-(signed __int16)v375;
                    v381 = v380;
                    v383 = __ROL4__(*((_DWORD *)v377 + 3) + v1135 * v380, 16);
                    BYTE1(v376) = v383;
                    v382 = *((_DWORD *)v377 + 2) + v1124 * v380;
                    LOWORD(v383) = v382;
                    v375 = v382 >> 8;
                    LOBYTE(v376) = BYTE1(v375);
                    v384 = __ROL4__(*((_DWORD *)v377 + 4) + v1146 * v381, 16);
                    BYTE1(v375) = v384;
                    LOWORD(v384) = *((_WORD *)v377 + 3);
                    v375 = (unsigned __int16)v375;
                    if ( (signed __int16)v384 > (signed __int16)dword_DE564 )
                      LOWORD(v384) = dword_DE564;
LABEL_493:
                    v387 = v384 & 0xF;
                    v388 = (_BYTE *)(dword_B8845[v387] + v379);
                    v389 = dword_DE55C;
                    switch ( v387 )
                    {
                      case 0:
                        goto LABEL_494;
                      case 1:
                        goto LABEL_509;
                      case 2:
                        goto LABEL_508;
                      case 3:
                        goto LABEL_507;
                      case 4:
                        goto LABEL_506;
                      case 5:
                        goto LABEL_505;
                      case 6:
                        goto LABEL_504;
                      case 7:
                        goto LABEL_503;
                      case 8:
                        goto LABEL_502;
                      case 9:
                        goto LABEL_501;
                      case 10:
                        goto LABEL_500;
                      case 11:
                        goto LABEL_499;
                      case 12:
                        goto LABEL_498;
                      case 13:
                        goto LABEL_497;
                      case 14:
                        goto LABEL_496;
                      case 15:
                        while ( 1 )
                        {
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          v388[1] = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
LABEL_496:
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          v388[2] = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
LABEL_497:
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          v388[3] = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
LABEL_498:
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          v388[4] = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
LABEL_499:
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          v388[5] = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
LABEL_500:
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          v388[6] = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
LABEL_501:
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          v388[7] = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
LABEL_502:
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          v388[8] = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
LABEL_503:
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          v388[9] = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
LABEL_504:
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          v388[10] = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
LABEL_505:
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          v388[11] = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
LABEL_506:
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          v388[12] = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
LABEL_507:
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          v388[13] = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
LABEL_508:
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          v388[14] = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
LABEL_509:
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          v388[15] = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
                          v388 += 16;
                          v18 = __OFSUB__((_WORD)v384, 16);
                          LOWORD(v384) = v384 - 16;
                          if ( (unsigned __int8)(((v384 & 0x8000u) != 0) ^ v18) | ((_WORD)v384 == 0) )
                            break;
LABEL_494:
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v383);
                          LOWORD(v383) = v1124 + v383;
                          LOBYTE(v375) = *(_BYTE *)(v376 + v389);
                          LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
                          v180 = __CFADD__(v1167, v383);
                          v383 += v1167;
                          BYTE1(v376) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1183, v384);
                          v384 += v1183;
                          *v388 = byte_F6EE0[v375];
                          BYTE1(v375) += BYTE2(v1146) + v180;
                        }
                        break;
                    }
                  }
LABEL_510:
                  if ( !--v1123 )
                    return;
                }
                if ( v378 > dword_DE564 )
                  LOWORD(v378) = dword_DE564;
                v18 = __OFSUB__((_WORD)v378, (_WORD)v375);
                v385 = v378 - v375;
                if ( (unsigned __int8)((v385 < 0) ^ v18) | (v385 == 0) )
                  goto LABEL_510;
                v379 += v375;
                LOBYTE(v376) = v377[10];
                v383 = __ROL4__(*((_DWORD *)v377 + 3), 16);
                v386 = v385;
                BYTE1(v376) = v383;
                LOWORD(v383) = *((_WORD *)v377 + 4);
                v384 = __ROL4__(*((_DWORD *)v377 + 4), 16);
                BYTE1(v375) = v384;
                LOWORD(v384) = v386;
                goto LABEL_493;
              case 6:
                v1277 = (char *)&unk_DE56C;
                v1168 = v1135 << 16;
                v1184 = v1146 << 16;
                HIWORD(v390) = 0;
                HIWORD(v391) = 0;
                while ( 1 )
                {
                  v392 = v1277;
                  v1277 += 20;
                  LOWORD(v390) = *((_WORD *)v392 + 1);
                  v393 = *((unsigned __int16 *)v392 + 3);
                  v394 = dword_DE560 + v1102;
                  v1102 += dword_DE560;
                  if ( (v390 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v393 > 0 )
                  {
                    v395 = (unsigned __int16)-(signed __int16)v390;
                    v396 = v395;
                    v398 = __ROL4__(*((_DWORD *)v392 + 3) + v1135 * v395, 16);
                    BYTE1(v391) = v398;
                    v397 = *((_DWORD *)v392 + 2) + v1124 * v395;
                    LOWORD(v398) = v397;
                    v390 = v397 >> 8;
                    LOBYTE(v391) = BYTE1(v390);
                    v399 = __ROL4__(*((_DWORD *)v392 + 4) + v1146 * v396, 16);
                    BYTE1(v390) = v399;
                    LOWORD(v399) = *((_WORD *)v392 + 3);
                    v390 = (unsigned __int16)v390;
                    if ( (signed __int16)v399 > (signed __int16)dword_DE564 )
                      LOWORD(v399) = dword_DE564;
LABEL_522:
                    v402 = v399 & 0xF;
                    v403 = (_BYTE *)(dword_B8845[v402] + v394);
                    v404 = dword_DE55C;
                    switch ( v402 )
                    {
                      case 0:
                        goto LABEL_523;
                      case 1:
                        goto LABEL_568;
                      case 2:
                        goto LABEL_565;
                      case 3:
                        goto LABEL_562;
                      case 4:
                        goto LABEL_559;
                      case 5:
                        goto LABEL_556;
                      case 6:
                        goto LABEL_553;
                      case 7:
                        goto LABEL_550;
                      case 8:
                        goto LABEL_547;
                      case 9:
                        goto LABEL_544;
                      case 10:
                        goto LABEL_541;
                      case 11:
                        goto LABEL_538;
                      case 12:
                        goto LABEL_535;
                      case 13:
                        goto LABEL_532;
                      case 14:
                        goto LABEL_529;
                      case 15:
                        while ( 1 )
                        {
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            v403[1] = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
LABEL_529:
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            v403[2] = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
LABEL_532:
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            v403[3] = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
LABEL_535:
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            v403[4] = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
LABEL_538:
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            v403[5] = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
LABEL_541:
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            v403[6] = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
LABEL_544:
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            v403[7] = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
LABEL_547:
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            v403[8] = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
LABEL_550:
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            v403[9] = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
LABEL_553:
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            v403[10] = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
LABEL_556:
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            v403[11] = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
LABEL_559:
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            v403[12] = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
LABEL_562:
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            v403[13] = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
LABEL_565:
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            v403[14] = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
LABEL_568:
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            v403[15] = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
                          v403 += 16;
                          v18 = __OFSUB__((_WORD)v399, 16);
                          LOWORD(v399) = v399 - 16;
                          if ( (unsigned __int8)(((v399 & 0x8000u) != 0) ^ v18) | ((_WORD)v399 == 0) )
                            break;
LABEL_523:
                          LOBYTE(v390) = *(_BYTE *)(v391 + v404);
                          if ( (_BYTE)v390 )
                            *v403 = byte_F6EE0[v390];
                          v180 = __CFADD__((_WORD)v1124, (_WORD)v398);
                          LOWORD(v398) = v1124 + v398;
                          LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
                          v180 = __CFADD__(v1168, v398);
                          v398 += v1168;
                          BYTE1(v391) += BYTE2(v1135) + v180;
                          v180 = __CFADD__(v1184, v399);
                          v399 += v1184;
                          BYTE1(v390) += BYTE2(v1146) + v180;
                        }
                        break;
                    }
                  }
LABEL_571:
                  if ( !--v1123 )
                    return;
                }
                if ( v393 > dword_DE564 )
                  LOWORD(v393) = dword_DE564;
                v18 = __OFSUB__((_WORD)v393, (_WORD)v390);
                v400 = v393 - v390;
                if ( (unsigned __int8)((v400 < 0) ^ v18) | (v400 == 0) )
                  goto LABEL_571;
                v394 += v390;
                LOBYTE(v391) = v392[10];
                v398 = __ROL4__(*((_DWORD *)v392 + 3), 16);
                v401 = v400;
                BYTE1(v391) = v398;
                LOWORD(v398) = *((_WORD *)v392 + 4);
                v399 = __ROL4__(*((_DWORD *)v392 + 4), 16);
                BYTE1(v390) = v399;
                LOWORD(v399) = v401;
                goto LABEL_522;
              case 7:
              case 0xB:
                v405 = (unsigned __int16 *)&unk_DE56C;
                v1169 = v1135 << 16;
                HIWORD(v406) = 0;
                HIWORD(v407) = 0;
                while ( 1 )
                {
                  LOWORD(v406) = v405[1];
                  v408 = v405[3];
                  v409 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v406 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v408 > 0 )
                  {
                    v410 = (unsigned __int16)-(signed __int16)v406;
                    v412 = __ROL4__(*((_DWORD *)v405 + 3) + v1135 * v410, 16);
                    BYTE1(v407) = v412;
                    v411 = *((_DWORD *)v405 + 2) + v1124 * v410;
                    LOWORD(v412) = v411;
                    v413 = v411 >> 8;
                    LOBYTE(v407) = BYTE1(v413);
                    if ( v408 > dword_DE564 )
                      LOWORD(v408) = dword_DE564;
                    v406 = (unsigned __int16)v413;
LABEL_583:
                    v1278 = v405;
                    v414 = dword_DE55C;
                    BYTE1(v406) = byte_E126C;
                    while ( 1 )
                    {
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v412);
                      LOWORD(v412) = v1124 + v412;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v412);
                      v415 = v1169 + v412;
                      *v409 = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      v416 = v408 - 1;
                      if ( !v416 )
                        break;
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v415);
                      LOWORD(v415) = v1124 + v415;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v415);
                      v417 = v1169 + v415;
                      v409[1] = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      v418 = v416 - 1;
                      if ( !v418 )
                        break;
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v417);
                      LOWORD(v417) = v1124 + v417;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v417);
                      v419 = v1169 + v417;
                      v409[2] = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      v420 = v418 - 1;
                      if ( !v420 )
                        break;
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v419);
                      LOWORD(v419) = v1124 + v419;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v419);
                      v421 = v1169 + v419;
                      v409[3] = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      v422 = v420 - 1;
                      if ( !v422 )
                        break;
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v421);
                      LOWORD(v421) = v1124 + v421;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v421);
                      v423 = v1169 + v421;
                      v409[4] = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      v424 = v422 - 1;
                      if ( !v424 )
                        break;
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v423);
                      LOWORD(v423) = v1124 + v423;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v423);
                      v425 = v1169 + v423;
                      v409[5] = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      v426 = v424 - 1;
                      if ( !v426 )
                        break;
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v425);
                      LOWORD(v425) = v1124 + v425;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v425);
                      v427 = v1169 + v425;
                      v409[6] = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      v428 = v426 - 1;
                      if ( !v428 )
                        break;
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v427);
                      LOWORD(v427) = v1124 + v427;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v427);
                      v429 = v1169 + v427;
                      v409[7] = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      v430 = v428 - 1;
                      if ( !v430 )
                        break;
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v429);
                      LOWORD(v429) = v1124 + v429;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v429);
                      v431 = v1169 + v429;
                      v409[8] = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      v432 = v430 - 1;
                      if ( !v432 )
                        break;
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v431);
                      LOWORD(v431) = v1124 + v431;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v431);
                      v433 = v1169 + v431;
                      v409[9] = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      v434 = v432 - 1;
                      if ( !v434 )
                        break;
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v433);
                      LOWORD(v433) = v1124 + v433;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v433);
                      v435 = v1169 + v433;
                      v409[10] = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      v436 = v434 - 1;
                      if ( !v436 )
                        break;
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v435);
                      LOWORD(v435) = v1124 + v435;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v435);
                      v437 = v1169 + v435;
                      v409[11] = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      v438 = v436 - 1;
                      if ( !v438 )
                        break;
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v437);
                      LOWORD(v437) = v1124 + v437;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v437);
                      v439 = v1169 + v437;
                      v409[12] = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      v440 = v438 - 1;
                      if ( !v440 )
                        break;
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v439);
                      LOWORD(v439) = v1124 + v439;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v439);
                      v441 = v1169 + v439;
                      v409[13] = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      v442 = v440 - 1;
                      if ( !v442 )
                        break;
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v441);
                      LOWORD(v441) = v1124 + v441;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v441);
                      v443 = v1169 + v441;
                      v409[14] = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      v444 = v442 - 1;
                      if ( !v444 )
                        break;
                      LOBYTE(v406) = *(_BYTE *)(v407 + v414);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v443);
                      LOWORD(v443) = v1124 + v443;
                      LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
                      v180 = __CFADD__(v1169, v443);
                      v412 = v1169 + v443;
                      v409[15] = byte_F6EE0[v406];
                      BYTE1(v407) += BYTE2(v1135) + v180;
                      LOWORD(v408) = v444 - 1;
                      if ( !(_WORD)v408 )
                        break;
                      v409 += 16;
                    }
                    v405 = v1278;
                  }
LABEL_602:
                  v405 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v408 > dword_DE564 )
                  LOWORD(v408) = dword_DE564;
                v18 = __OFSUB__((_WORD)v408, (_WORD)v406);
                LOWORD(v408) = v408 - v406;
                if ( (unsigned __int8)(((v408 & 0x8000u) != 0) ^ v18) | ((_WORD)v408 == 0) )
                  goto LABEL_602;
                v409 += v406;
                v412 = __ROL4__(*((_DWORD *)v405 + 3), 16);
                BYTE1(v407) = v412;
                LOWORD(v412) = v405[4];
                LOBYTE(v407) = *((_BYTE *)v405 + 10);
                goto LABEL_583;
              case 8:
                v445 = (unsigned __int16 *)&unk_DE56C;
                v1170 = v1135 << 16;
                HIWORD(v446) = 0;
                HIWORD(v447) = 0;
                while ( 1 )
                {
                  LOWORD(v446) = v445[1];
                  v448 = v445[3];
                  v449 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v446 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v448 > 0 )
                  {
                    v450 = (unsigned __int16)-(signed __int16)v446;
                    v452 = __ROL4__(*((_DWORD *)v445 + 3) + v1135 * v450, 16);
                    BYTE1(v447) = v452;
                    v451 = *((_DWORD *)v445 + 2) + v1124 * v450;
                    LOWORD(v452) = v451;
                    v453 = v451 >> 8;
                    LOBYTE(v447) = BYTE1(v453);
                    if ( v448 > dword_DE564 )
                      LOWORD(v448) = dword_DE564;
                    v446 = (unsigned __int16)v453;
LABEL_614:
                    v1279 = v445;
                    v454 = dword_DE55C;
                    BYTE1(v446) = byte_E126C;
                    while ( 1 )
                    {
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v452);
                      LOWORD(v452) = v1124 + v452;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        *v449 = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v452);
                      v455 = v1170 + v452;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      v456 = v448 - 1;
                      if ( !v456 )
                        break;
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v455);
                      LOWORD(v455) = v1124 + v455;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        v449[1] = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v455);
                      v457 = v1170 + v455;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      v458 = v456 - 1;
                      if ( !v458 )
                        break;
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v457);
                      LOWORD(v457) = v1124 + v457;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        v449[2] = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v457);
                      v459 = v1170 + v457;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      v460 = v458 - 1;
                      if ( !v460 )
                        break;
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v459);
                      LOWORD(v459) = v1124 + v459;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        v449[3] = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v459);
                      v461 = v1170 + v459;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      v462 = v460 - 1;
                      if ( !v462 )
                        break;
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v461);
                      LOWORD(v461) = v1124 + v461;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        v449[4] = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v461);
                      v463 = v1170 + v461;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      v464 = v462 - 1;
                      if ( !v464 )
                        break;
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v463);
                      LOWORD(v463) = v1124 + v463;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        v449[5] = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v463);
                      v465 = v1170 + v463;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      v466 = v464 - 1;
                      if ( !v466 )
                        break;
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v465);
                      LOWORD(v465) = v1124 + v465;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        v449[6] = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v465);
                      v467 = v1170 + v465;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      v468 = v466 - 1;
                      if ( !v468 )
                        break;
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v467);
                      LOWORD(v467) = v1124 + v467;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        v449[7] = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v467);
                      v469 = v1170 + v467;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      v470 = v468 - 1;
                      if ( !v470 )
                        break;
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v469);
                      LOWORD(v469) = v1124 + v469;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        v449[8] = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v469);
                      v471 = v1170 + v469;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      v472 = v470 - 1;
                      if ( !v472 )
                        break;
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v471);
                      LOWORD(v471) = v1124 + v471;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        v449[9] = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v471);
                      v473 = v1170 + v471;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      v474 = v472 - 1;
                      if ( !v474 )
                        break;
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v473);
                      LOWORD(v473) = v1124 + v473;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        v449[10] = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v473);
                      v475 = v1170 + v473;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      v476 = v474 - 1;
                      if ( !v476 )
                        break;
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v475);
                      LOWORD(v475) = v1124 + v475;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        v449[11] = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v475);
                      v477 = v1170 + v475;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      v478 = v476 - 1;
                      if ( !v478 )
                        break;
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v477);
                      LOWORD(v477) = v1124 + v477;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        v449[12] = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v477);
                      v479 = v1170 + v477;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      v480 = v478 - 1;
                      if ( !v480 )
                        break;
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v479);
                      LOWORD(v479) = v1124 + v479;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        v449[13] = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v479);
                      v481 = v1170 + v479;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      v482 = v480 - 1;
                      if ( !v482 )
                        break;
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v481);
                      LOWORD(v481) = v1124 + v481;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        v449[14] = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v481);
                      v483 = v1170 + v481;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      v484 = v482 - 1;
                      if ( !v484 )
                        break;
                      LOBYTE(v446) = *(_BYTE *)(v447 + v454);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v483);
                      LOWORD(v483) = v1124 + v483;
                      LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
                      if ( (_BYTE)v446 )
                        v449[15] = byte_F6EE0[v446];
                      v180 = __CFADD__(v1170, v483);
                      v452 = v1170 + v483;
                      BYTE1(v447) += BYTE2(v1135) + v180;
                      LOWORD(v448) = v484 - 1;
                      if ( !(_WORD)v448 )
                        break;
                      v449 += 16;
                    }
                    v445 = v1279;
                  }
LABEL_665:
                  v445 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v448 > dword_DE564 )
                  LOWORD(v448) = dword_DE564;
                v18 = __OFSUB__((_WORD)v448, (_WORD)v446);
                LOWORD(v448) = v448 - v446;
                if ( (unsigned __int8)(((v448 & 0x8000u) != 0) ^ v18) | ((_WORD)v448 == 0) )
                  goto LABEL_665;
                v449 += v446;
                v452 = __ROL4__(*((_DWORD *)v445 + 3), 16);
                BYTE1(v447) = v452;
                LOWORD(v452) = v445[4];
                LOBYTE(v447) = *((_BYTE *)v445 + 10);
                goto LABEL_614;
              case 9:
              case 0xA:
                v485 = (unsigned __int16 *)&unk_DE56C;
                v1171 = v1135 << 16;
                HIWORD(v486) = 0;
                HIWORD(v487) = 0;
                while ( 1 )
                {
                  LOWORD(v486) = v485[1];
                  v488 = v485[3];
                  v489 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v486 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v488 > 0 )
                  {
                    v490 = (unsigned __int16)-(signed __int16)v486;
                    v492 = __ROL4__(*((_DWORD *)v485 + 3) + v1135 * v490, 16);
                    BYTE1(v487) = v492;
                    v491 = *((_DWORD *)v485 + 2) + v1124 * v490;
                    LOWORD(v492) = v491;
                    v493 = v491 >> 8;
                    LOBYTE(v487) = BYTE1(v493);
                    if ( v488 > dword_DE564 )
                      LOWORD(v488) = dword_DE564;
                    v486 = (unsigned __int16)v493;
LABEL_677:
                    v1280 = v485;
                    v494 = dword_DE55C;
                    while ( 1 )
                    {
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v492);
                      LOWORD(v492) = v1124 + v492;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = *v489;
                        *v489 = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v492);
                      v495 = v1171 + v492;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      v496 = v488 - 1;
                      if ( !v496 )
                        break;
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v495);
                      LOWORD(v495) = v1124 + v495;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = v489[1];
                        v489[1] = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v495);
                      v497 = v1171 + v495;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      v498 = v496 - 1;
                      if ( !v498 )
                        break;
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v497);
                      LOWORD(v497) = v1124 + v497;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = v489[2];
                        v489[2] = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v497);
                      v499 = v1171 + v497;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      v500 = v498 - 1;
                      if ( !v500 )
                        break;
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v499);
                      LOWORD(v499) = v1124 + v499;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = v489[3];
                        v489[3] = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v499);
                      v501 = v1171 + v499;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      v502 = v500 - 1;
                      if ( !v502 )
                        break;
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v501);
                      LOWORD(v501) = v1124 + v501;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = v489[4];
                        v489[4] = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v501);
                      v503 = v1171 + v501;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      v504 = v502 - 1;
                      if ( !v504 )
                        break;
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v503);
                      LOWORD(v503) = v1124 + v503;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = v489[5];
                        v489[5] = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v503);
                      v505 = v1171 + v503;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      v506 = v504 - 1;
                      if ( !v506 )
                        break;
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v505);
                      LOWORD(v505) = v1124 + v505;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = v489[6];
                        v489[6] = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v505);
                      v507 = v1171 + v505;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      v508 = v506 - 1;
                      if ( !v508 )
                        break;
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v507);
                      LOWORD(v507) = v1124 + v507;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = v489[7];
                        v489[7] = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v507);
                      v509 = v1171 + v507;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      v510 = v508 - 1;
                      if ( !v510 )
                        break;
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v509);
                      LOWORD(v509) = v1124 + v509;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = v489[8];
                        v489[8] = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v509);
                      v511 = v1171 + v509;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      v512 = v510 - 1;
                      if ( !v512 )
                        break;
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v511);
                      LOWORD(v511) = v1124 + v511;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = v489[9];
                        v489[9] = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v511);
                      v513 = v1171 + v511;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      v514 = v512 - 1;
                      if ( !v514 )
                        break;
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v513);
                      LOWORD(v513) = v1124 + v513;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = v489[10];
                        v489[10] = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v513);
                      v515 = v1171 + v513;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      v516 = v514 - 1;
                      if ( !v516 )
                        break;
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v515);
                      LOWORD(v515) = v1124 + v515;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = v489[11];
                        v489[11] = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v515);
                      v517 = v1171 + v515;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      v518 = v516 - 1;
                      if ( !v518 )
                        break;
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v517);
                      LOWORD(v517) = v1124 + v517;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = v489[12];
                        v489[12] = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v517);
                      v519 = v1171 + v517;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      v520 = v518 - 1;
                      if ( !v520 )
                        break;
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v519);
                      LOWORD(v519) = v1124 + v519;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = v489[13];
                        v489[13] = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v519);
                      v521 = v1171 + v519;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      v522 = v520 - 1;
                      if ( !v522 )
                        break;
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v521);
                      LOWORD(v521) = v1124 + v521;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = v489[14];
                        v489[14] = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v521);
                      v523 = v1171 + v521;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      v524 = v522 - 1;
                      if ( !v524 )
                        break;
                      BYTE1(v486) = *(_BYTE *)(v487 + v494);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v523);
                      LOWORD(v523) = v1124 + v523;
                      LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
                      if ( BYTE1(v486) )
                      {
                        LOBYTE(v486) = v489[15];
                        v489[15] = byte_F6EE0[v486];
                      }
                      v180 = __CFADD__(v1171, v523);
                      v492 = v1171 + v523;
                      BYTE1(v487) += BYTE2(v1135) + v180;
                      LOWORD(v488) = v524 - 1;
                      if ( !(_WORD)v488 )
                        break;
                      v489 += 16;
                    }
                    v485 = v1280;
                  }
LABEL_728:
                  v485 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v488 > dword_DE564 )
                  LOWORD(v488) = dword_DE564;
                v18 = __OFSUB__((_WORD)v488, (_WORD)v486);
                LOWORD(v488) = v488 - v486;
                if ( (unsigned __int8)(((v488 & 0x8000u) != 0) ^ v18) | ((_WORD)v488 == 0) )
                  goto LABEL_728;
                v489 += v486;
                v492 = __ROL4__(*((_DWORD *)v485 + 3), 16);
                BYTE1(v487) = v492;
                LOWORD(v492) = v485[4];
                LOBYTE(v487) = *((_BYTE *)v485 + 10);
                goto LABEL_677;
              case 0xC:
                v525 = (unsigned __int16 *)&unk_DE56C;
                v1172 = v1135 << 16;
                HIWORD(v526) = 0;
                HIWORD(v527) = 0;
                while ( 1 )
                {
                  LOWORD(v526) = v525[1];
                  v528 = v525[3];
                  v529 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v526 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v528 > 0 )
                  {
                    v530 = (unsigned __int16)-(signed __int16)v526;
                    v532 = __ROL4__(*((_DWORD *)v525 + 3) + v1135 * v530, 16);
                    BYTE1(v527) = v532;
                    v531 = *((_DWORD *)v525 + 2) + v1124 * v530;
                    LOWORD(v532) = v531;
                    v533 = v531 >> 8;
                    LOBYTE(v527) = BYTE1(v533);
                    if ( v528 > dword_DE564 )
                      LOWORD(v528) = dword_DE564;
                    v526 = (unsigned __int16)v533;
LABEL_740:
                    v1281 = v525;
                    v534 = dword_DE55C;
                    LOBYTE(v526) = byte_E126C;
                    while ( 1 )
                    {
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v532);
                      LOWORD(v532) = v1124 + v532;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v532);
                      v535 = v1172 + v532;
                      *v529 = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      v536 = v528 - 1;
                      if ( !v536 )
                        break;
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v535);
                      LOWORD(v535) = v1124 + v535;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v535);
                      v537 = v1172 + v535;
                      v529[1] = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      v538 = v536 - 1;
                      if ( !v538 )
                        break;
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v537);
                      LOWORD(v537) = v1124 + v537;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v537);
                      v539 = v1172 + v537;
                      v529[2] = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      v540 = v538 - 1;
                      if ( !v540 )
                        break;
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v539);
                      LOWORD(v539) = v1124 + v539;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v539);
                      v541 = v1172 + v539;
                      v529[3] = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      v542 = v540 - 1;
                      if ( !v542 )
                        break;
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v541);
                      LOWORD(v541) = v1124 + v541;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v541);
                      v543 = v1172 + v541;
                      v529[4] = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      v544 = v542 - 1;
                      if ( !v544 )
                        break;
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v543);
                      LOWORD(v543) = v1124 + v543;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v543);
                      v545 = v1172 + v543;
                      v529[5] = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      v546 = v544 - 1;
                      if ( !v546 )
                        break;
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v545);
                      LOWORD(v545) = v1124 + v545;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v545);
                      v547 = v1172 + v545;
                      v529[6] = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      v548 = v546 - 1;
                      if ( !v548 )
                        break;
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v547);
                      LOWORD(v547) = v1124 + v547;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v547);
                      v549 = v1172 + v547;
                      v529[7] = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      v550 = v548 - 1;
                      if ( !v550 )
                        break;
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v549);
                      LOWORD(v549) = v1124 + v549;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v549);
                      v551 = v1172 + v549;
                      v529[8] = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      v552 = v550 - 1;
                      if ( !v552 )
                        break;
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v551);
                      LOWORD(v551) = v1124 + v551;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v551);
                      v553 = v1172 + v551;
                      v529[9] = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      v554 = v552 - 1;
                      if ( !v554 )
                        break;
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v553);
                      LOWORD(v553) = v1124 + v553;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v553);
                      v555 = v1172 + v553;
                      v529[10] = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      v556 = v554 - 1;
                      if ( !v556 )
                        break;
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v555);
                      LOWORD(v555) = v1124 + v555;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v555);
                      v557 = v1172 + v555;
                      v529[11] = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      v558 = v556 - 1;
                      if ( !v558 )
                        break;
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v557);
                      LOWORD(v557) = v1124 + v557;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v557);
                      v559 = v1172 + v557;
                      v529[12] = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      v560 = v558 - 1;
                      if ( !v560 )
                        break;
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v559);
                      LOWORD(v559) = v1124 + v559;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v559);
                      v561 = v1172 + v559;
                      v529[13] = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      v562 = v560 - 1;
                      if ( !v562 )
                        break;
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v561);
                      LOWORD(v561) = v1124 + v561;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v561);
                      v563 = v1172 + v561;
                      v529[14] = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      v564 = v562 - 1;
                      if ( !v564 )
                        break;
                      BYTE1(v526) = *(_BYTE *)(v527 + v534);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v563);
                      LOWORD(v563) = v1124 + v563;
                      LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
                      v180 = __CFADD__(v1172, v563);
                      v532 = v1172 + v563;
                      v529[15] = byte_FAEE0[v526];
                      BYTE1(v527) += BYTE2(v1135) + v180;
                      LOWORD(v528) = v564 - 1;
                      if ( !(_WORD)v528 )
                        break;
                      v529 += 16;
                    }
                    v525 = v1281;
                  }
LABEL_759:
                  v525 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v528 > dword_DE564 )
                  LOWORD(v528) = dword_DE564;
                v18 = __OFSUB__((_WORD)v528, (_WORD)v526);
                LOWORD(v528) = v528 - v526;
                if ( (unsigned __int8)(((v528 & 0x8000u) != 0) ^ v18) | ((_WORD)v528 == 0) )
                  goto LABEL_759;
                v529 += v526;
                v532 = __ROL4__(*((_DWORD *)v525 + 3), 16);
                BYTE1(v527) = v532;
                LOWORD(v532) = v525[4];
                LOBYTE(v527) = *((_BYTE *)v525 + 10);
                goto LABEL_740;
              case 0xD:
                v565 = (unsigned __int16 *)&unk_DE56C;
                v1173 = v1135 << 16;
                HIWORD(v566) = 0;
                HIWORD(v567) = 0;
                while ( 1 )
                {
                  LOWORD(v566) = v565[1];
                  v568 = v565[3];
                  v569 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v566 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v568 > 0 )
                  {
                    v570 = (unsigned __int16)-(signed __int16)v566;
                    v572 = __ROL4__(*((_DWORD *)v565 + 3) + v1135 * v570, 16);
                    BYTE1(v567) = v572;
                    v571 = *((_DWORD *)v565 + 2) + v1124 * v570;
                    LOWORD(v572) = v571;
                    v573 = v571 >> 8;
                    LOBYTE(v567) = BYTE1(v573);
                    if ( v568 > dword_DE564 )
                      LOWORD(v568) = dword_DE564;
                    v566 = (unsigned __int16)v573;
LABEL_771:
                    v1282 = v565;
                    v574 = dword_DE55C;
                    BYTE1(v566) = byte_E126C;
                    while ( 1 )
                    {
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v572);
                      LOWORD(v572) = v1124 + v572;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v572);
                      v575 = v1173 + v572;
                      *v569 = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      v576 = v568 - 1;
                      if ( !v576 )
                        break;
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v575);
                      LOWORD(v575) = v1124 + v575;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v575);
                      v577 = v1173 + v575;
                      v569[1] = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      v578 = v576 - 1;
                      if ( !v578 )
                        break;
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v577);
                      LOWORD(v577) = v1124 + v577;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v577);
                      v579 = v1173 + v577;
                      v569[2] = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      v580 = v578 - 1;
                      if ( !v580 )
                        break;
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v579);
                      LOWORD(v579) = v1124 + v579;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v579);
                      v581 = v1173 + v579;
                      v569[3] = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      v582 = v580 - 1;
                      if ( !v582 )
                        break;
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v581);
                      LOWORD(v581) = v1124 + v581;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v581);
                      v583 = v1173 + v581;
                      v569[4] = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      v584 = v582 - 1;
                      if ( !v584 )
                        break;
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v583);
                      LOWORD(v583) = v1124 + v583;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v583);
                      v585 = v1173 + v583;
                      v569[5] = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      v586 = v584 - 1;
                      if ( !v586 )
                        break;
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v585);
                      LOWORD(v585) = v1124 + v585;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v585);
                      v587 = v1173 + v585;
                      v569[6] = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      v588 = v586 - 1;
                      if ( !v588 )
                        break;
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v587);
                      LOWORD(v587) = v1124 + v587;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v587);
                      v589 = v1173 + v587;
                      v569[7] = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      v590 = v588 - 1;
                      if ( !v590 )
                        break;
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v589);
                      LOWORD(v589) = v1124 + v589;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v589);
                      v591 = v1173 + v589;
                      v569[8] = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      v592 = v590 - 1;
                      if ( !v592 )
                        break;
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v591);
                      LOWORD(v591) = v1124 + v591;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v591);
                      v593 = v1173 + v591;
                      v569[9] = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      v594 = v592 - 1;
                      if ( !v594 )
                        break;
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v593);
                      LOWORD(v593) = v1124 + v593;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v593);
                      v595 = v1173 + v593;
                      v569[10] = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      v596 = v594 - 1;
                      if ( !v596 )
                        break;
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v595);
                      LOWORD(v595) = v1124 + v595;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v595);
                      v597 = v1173 + v595;
                      v569[11] = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      v598 = v596 - 1;
                      if ( !v598 )
                        break;
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v597);
                      LOWORD(v597) = v1124 + v597;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v597);
                      v599 = v1173 + v597;
                      v569[12] = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      v600 = v598 - 1;
                      if ( !v600 )
                        break;
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v599);
                      LOWORD(v599) = v1124 + v599;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v599);
                      v601 = v1173 + v599;
                      v569[13] = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      v602 = v600 - 1;
                      if ( !v602 )
                        break;
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v601);
                      LOWORD(v601) = v1124 + v601;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v601);
                      v603 = v1173 + v601;
                      v569[14] = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      v604 = v602 - 1;
                      if ( !v604 )
                        break;
                      LOBYTE(v566) = *(_BYTE *)(v567 + v574);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v603);
                      LOWORD(v603) = v1124 + v603;
                      LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
                      v180 = __CFADD__(v1173, v603);
                      v572 = v1173 + v603;
                      v569[15] = byte_FAEE0[v566];
                      BYTE1(v567) += BYTE2(v1135) + v180;
                      LOWORD(v568) = v604 - 1;
                      if ( !(_WORD)v568 )
                        break;
                      v569 += 16;
                    }
                    v565 = v1282;
                  }
LABEL_790:
                  v565 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v568 > dword_DE564 )
                  LOWORD(v568) = dword_DE564;
                v18 = __OFSUB__((_WORD)v568, (_WORD)v566);
                LOWORD(v568) = v568 - v566;
                if ( (unsigned __int8)(((v568 & 0x8000u) != 0) ^ v18) | ((_WORD)v568 == 0) )
                  goto LABEL_790;
                v569 += v566;
                v572 = __ROL4__(*((_DWORD *)v565 + 3), 16);
                BYTE1(v567) = v572;
                LOWORD(v572) = v565[4];
                LOBYTE(v567) = *((_BYTE *)v565 + 10);
                goto LABEL_771;
              case 0xE:
                v605 = (unsigned __int16 *)&unk_DE56C;
                v606 = (_BYTE *)v1102;
                HIWORD(v607) = 0;
                BYTE1(v607) = byte_E126C;
                HIWORD(v608) = 0;
                while ( 1 )
                {
                  LOWORD(v608) = v605[1];
                  v609 = v605[3];
                  v606 += dword_DE560;
                  if ( (v608 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v609 > 0 )
                  {
                    if ( v609 > dword_DE564 )
                      LOWORD(v609) = dword_DE564;
LABEL_802:
                    for ( i = v606; ; i += 16 )
                    {
                      LOBYTE(v607) = *i;
                      *i = byte_FAEE0[v607];
                      v611 = v609 - 1;
                      if ( !v611 )
                        break;
                      LOBYTE(v607) = i[1];
                      i[1] = byte_FAEE0[v607];
                      v612 = v611 - 1;
                      if ( !v612 )
                        break;
                      LOBYTE(v607) = i[2];
                      i[2] = byte_FAEE0[v607];
                      v613 = v612 - 1;
                      if ( !v613 )
                        break;
                      LOBYTE(v607) = i[3];
                      i[3] = byte_FAEE0[v607];
                      v614 = v613 - 1;
                      if ( !v614 )
                        break;
                      LOBYTE(v607) = i[4];
                      i[4] = byte_FAEE0[v607];
                      v615 = v614 - 1;
                      if ( !v615 )
                        break;
                      LOBYTE(v607) = i[5];
                      i[5] = byte_FAEE0[v607];
                      v616 = v615 - 1;
                      if ( !v616 )
                        break;
                      LOBYTE(v607) = i[6];
                      i[6] = byte_FAEE0[v607];
                      v617 = v616 - 1;
                      if ( !v617 )
                        break;
                      LOBYTE(v607) = i[7];
                      i[7] = byte_FAEE0[v607];
                      v618 = v617 - 1;
                      if ( !v618 )
                        break;
                      LOBYTE(v607) = i[8];
                      i[8] = byte_FAEE0[v607];
                      v619 = v618 - 1;
                      if ( !v619 )
                        break;
                      LOBYTE(v607) = i[9];
                      i[9] = byte_FAEE0[v607];
                      v620 = v619 - 1;
                      if ( !v620 )
                        break;
                      LOBYTE(v607) = i[10];
                      i[10] = byte_FAEE0[v607];
                      v621 = v620 - 1;
                      if ( !v621 )
                        break;
                      LOBYTE(v607) = i[11];
                      i[11] = byte_FAEE0[v607];
                      v622 = v621 - 1;
                      if ( !v622 )
                        break;
                      LOBYTE(v607) = i[12];
                      i[12] = byte_FAEE0[v607];
                      v623 = v622 - 1;
                      if ( !v623 )
                        break;
                      LOBYTE(v607) = i[13];
                      i[13] = byte_FAEE0[v607];
                      v624 = v623 - 1;
                      if ( !v624 )
                        break;
                      LOBYTE(v607) = i[14];
                      i[14] = byte_FAEE0[v607];
                      v625 = v624 - 1;
                      if ( !v625 )
                        break;
                      LOBYTE(v607) = i[15];
                      i[15] = byte_FAEE0[v607];
                      LOWORD(v609) = v625 - 1;
                      if ( !(_WORD)v609 )
                        break;
                    }
                  }
LABEL_819:
                  v605 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v609 > dword_DE564 )
                  LOWORD(v609) = dword_DE564;
                v18 = __OFSUB__((_WORD)v609, (_WORD)v608);
                LOWORD(v609) = v609 - v608;
                if ( (unsigned __int8)(((v609 & 0x8000u) != 0) ^ v18) | ((_WORD)v609 == 0) )
                  goto LABEL_819;
                i = &v606[v608];
                goto LABEL_802;
              case 0xF:
                v626 = (unsigned __int16 *)&unk_DE56C;
                v627 = (_BYTE *)v1102;
                v628 = (unsigned __int8)byte_E126C;
                HIWORD(v629) = 0;
                while ( 1 )
                {
                  LOWORD(v629) = v626[1];
                  v630 = v626[3];
                  v627 += dword_DE560;
                  if ( (v629 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v630 > 0 )
                  {
                    if ( v630 > dword_DE564 )
                      LOWORD(v630) = dword_DE564;
LABEL_831:
                    for ( j = v627; ; j += 16 )
                    {
                      BYTE1(v628) = *j;
                      *j = byte_FAEE0[v628];
                      v632 = v630 - 1;
                      if ( !v632 )
                        break;
                      BYTE1(v628) = j[1];
                      j[1] = byte_FAEE0[v628];
                      v633 = v632 - 1;
                      if ( !v633 )
                        break;
                      BYTE1(v628) = j[2];
                      j[2] = byte_FAEE0[v628];
                      v634 = v633 - 1;
                      if ( !v634 )
                        break;
                      BYTE1(v628) = j[3];
                      j[3] = byte_FAEE0[v628];
                      v635 = v634 - 1;
                      if ( !v635 )
                        break;
                      BYTE1(v628) = j[4];
                      j[4] = byte_FAEE0[v628];
                      v636 = v635 - 1;
                      if ( !v636 )
                        break;
                      BYTE1(v628) = j[5];
                      j[5] = byte_FAEE0[v628];
                      v637 = v636 - 1;
                      if ( !v637 )
                        break;
                      BYTE1(v628) = j[6];
                      j[6] = byte_FAEE0[v628];
                      v638 = v637 - 1;
                      if ( !v638 )
                        break;
                      BYTE1(v628) = j[7];
                      j[7] = byte_FAEE0[v628];
                      v639 = v638 - 1;
                      if ( !v639 )
                        break;
                      BYTE1(v628) = j[8];
                      j[8] = byte_FAEE0[v628];
                      v640 = v639 - 1;
                      if ( !v640 )
                        break;
                      BYTE1(v628) = j[9];
                      j[9] = byte_FAEE0[v628];
                      v641 = v640 - 1;
                      if ( !v641 )
                        break;
                      BYTE1(v628) = j[10];
                      j[10] = byte_FAEE0[v628];
                      v642 = v641 - 1;
                      if ( !v642 )
                        break;
                      BYTE1(v628) = j[11];
                      j[11] = byte_FAEE0[v628];
                      v643 = v642 - 1;
                      if ( !v643 )
                        break;
                      BYTE1(v628) = j[12];
                      j[12] = byte_FAEE0[v628];
                      v644 = v643 - 1;
                      if ( !v644 )
                        break;
                      BYTE1(v628) = j[13];
                      j[13] = byte_FAEE0[v628];
                      v645 = v644 - 1;
                      if ( !v645 )
                        break;
                      BYTE1(v628) = j[14];
                      j[14] = byte_FAEE0[v628];
                      v646 = v645 - 1;
                      if ( !v646 )
                        break;
                      BYTE1(v628) = j[15];
                      j[15] = byte_FAEE0[v628];
                      LOWORD(v630) = v646 - 1;
                      if ( !(_WORD)v630 )
                        break;
                    }
                  }
LABEL_848:
                  v626 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v630 > dword_DE564 )
                  LOWORD(v630) = dword_DE564;
                v18 = __OFSUB__((_WORD)v630, (_WORD)v629);
                LOWORD(v630) = v630 - v629;
                if ( (unsigned __int8)(((v630 & 0x8000u) != 0) ^ v18) | ((_WORD)v630 == 0) )
                  goto LABEL_848;
                j = &v627[v629];
                goto LABEL_831;
              case 0x10:
                v647 = (unsigned __int16 *)&unk_DE56C;
                HIWORD(v648) = 0;
                while ( 1 )
                {
                  LOWORD(v31) = v647[1];
                  v649 = v647[3];
                  v650 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v31 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v649 > 0 )
                  {
                    v651 = v1146 * (unsigned __int16)-(signed __int16)v31;
                    v652 = v651;
                    v31 = v651 >> 8;
                    v180 = __CFADD__(v647[8], v652);
                    v653 = v647[8] + v652;
                    BYTE1(v31) += *((_BYTE *)v647 + 18) + v180;
                    if ( v649 > dword_DE564 )
                      LOWORD(v649) = dword_DE564;
                    v31 = (unsigned __int16)v31;
                    LOBYTE(v31) = byte_E126C;
LABEL_860:
                    while ( 1 )
                    {
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = *v650;
                      *v650 = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v653);
                      v654 = v1146 + v653;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v655 = v649 - 1;
                      if ( !v655 )
                        break;
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = v650[1];
                      v650[1] = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v654);
                      v656 = v1146 + v654;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v657 = v655 - 1;
                      if ( !v657 )
                        break;
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = v650[2];
                      v650[2] = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v656);
                      v658 = v1146 + v656;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v659 = v657 - 1;
                      if ( !v659 )
                        break;
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = v650[3];
                      v650[3] = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v658);
                      v660 = v1146 + v658;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v661 = v659 - 1;
                      if ( !v661 )
                        break;
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = v650[4];
                      v650[4] = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v660);
                      v662 = v1146 + v660;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v663 = v661 - 1;
                      if ( !v663 )
                        break;
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = v650[5];
                      v650[5] = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v662);
                      v664 = v1146 + v662;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v665 = v663 - 1;
                      if ( !v665 )
                        break;
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = v650[6];
                      v650[6] = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v664);
                      v666 = v1146 + v664;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v667 = v665 - 1;
                      if ( !v667 )
                        break;
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = v650[7];
                      v650[7] = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v666);
                      v668 = v1146 + v666;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v669 = v667 - 1;
                      if ( !v669 )
                        break;
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = v650[8];
                      v650[8] = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v668);
                      v670 = v1146 + v668;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v671 = v669 - 1;
                      if ( !v671 )
                        break;
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = v650[9];
                      v650[9] = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v670);
                      v672 = v1146 + v670;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v673 = v671 - 1;
                      if ( !v673 )
                        break;
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = v650[10];
                      v650[10] = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v672);
                      v674 = v1146 + v672;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v675 = v673 - 1;
                      if ( !v675 )
                        break;
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = v650[11];
                      v650[11] = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v674);
                      v676 = v1146 + v674;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v677 = v675 - 1;
                      if ( !v677 )
                        break;
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = v650[12];
                      v650[12] = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v676);
                      v678 = v1146 + v676;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v679 = v677 - 1;
                      if ( !v679 )
                        break;
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = v650[13];
                      v650[13] = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v678);
                      v680 = v1146 + v678;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v681 = v679 - 1;
                      if ( !v681 )
                        break;
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = v650[14];
                      v650[14] = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v680);
                      v682 = v1146 + v680;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v683 = v681 - 1;
                      if ( !v683 )
                        break;
                      BYTE1(v648) = byte_F6EE0[v31];
                      LOBYTE(v648) = v650[15];
                      v650[15] = byte_FAEE0[v648];
                      v180 = __CFADD__((_WORD)v1146, v682);
                      v653 = v1146 + v682;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      LOWORD(v649) = v683 - 1;
                      if ( !(_WORD)v649 )
                        break;
                      v650 += 16;
                    }
                  }
LABEL_877:
                  v647 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v649 > dword_DE564 )
                  LOWORD(v649) = dword_DE564;
                v18 = __OFSUB__((_WORD)v649, (_WORD)v31);
                LOWORD(v649) = v649 - v31;
                if ( (unsigned __int8)(((v649 & 0x8000u) != 0) ^ v18) | ((_WORD)v649 == 0) )
                  goto LABEL_877;
                v650 += v31;
                v31 = (unsigned __int8)byte_E126C;
                v653 = v647[8];
                BYTE1(v31) = *((_BYTE *)v647 + 18);
                goto LABEL_860;
              case 0x11:
                v684 = (unsigned __int16 *)&unk_DE56C;
                HIWORD(v685) = 0;
                while ( 1 )
                {
                  LOWORD(v31) = v684[1];
                  v686 = v684[3];
                  v687 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v31 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v686 > 0 )
                  {
                    v688 = v1146 * (unsigned __int16)-(signed __int16)v31;
                    v689 = v688;
                    v31 = v688 >> 8;
                    v180 = __CFADD__(v684[8], v689);
                    v690 = v684[8] + v689;
                    BYTE1(v31) += *((_BYTE *)v684 + 18) + v180;
                    if ( v686 > dword_DE564 )
                      LOWORD(v686) = dword_DE564;
                    v31 = (unsigned __int16)v31;
                    LOBYTE(v31) = byte_E126C;
LABEL_889:
                    while ( 1 )
                    {
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = *v687;
                      *v687 = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v690);
                      v691 = v1146 + v690;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v692 = v686 - 1;
                      if ( !v692 )
                        break;
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = v687[1];
                      v687[1] = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v691);
                      v693 = v1146 + v691;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v694 = v692 - 1;
                      if ( !v694 )
                        break;
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = v687[2];
                      v687[2] = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v693);
                      v695 = v1146 + v693;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v696 = v694 - 1;
                      if ( !v696 )
                        break;
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = v687[3];
                      v687[3] = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v695);
                      v697 = v1146 + v695;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v698 = v696 - 1;
                      if ( !v698 )
                        break;
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = v687[4];
                      v687[4] = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v697);
                      v699 = v1146 + v697;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v700 = v698 - 1;
                      if ( !v700 )
                        break;
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = v687[5];
                      v687[5] = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v699);
                      v701 = v1146 + v699;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v702 = v700 - 1;
                      if ( !v702 )
                        break;
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = v687[6];
                      v687[6] = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v701);
                      v703 = v1146 + v701;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v704 = v702 - 1;
                      if ( !v704 )
                        break;
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = v687[7];
                      v687[7] = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v703);
                      v705 = v1146 + v703;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v706 = v704 - 1;
                      if ( !v706 )
                        break;
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = v687[8];
                      v687[8] = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v705);
                      v707 = v1146 + v705;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v708 = v706 - 1;
                      if ( !v708 )
                        break;
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = v687[9];
                      v687[9] = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v707);
                      v709 = v1146 + v707;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v710 = v708 - 1;
                      if ( !v710 )
                        break;
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = v687[10];
                      v687[10] = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v709);
                      v711 = v1146 + v709;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v712 = v710 - 1;
                      if ( !v712 )
                        break;
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = v687[11];
                      v687[11] = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v711);
                      v713 = v1146 + v711;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v714 = v712 - 1;
                      if ( !v714 )
                        break;
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = v687[12];
                      v687[12] = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v713);
                      v715 = v1146 + v713;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v716 = v714 - 1;
                      if ( !v716 )
                        break;
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = v687[13];
                      v687[13] = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v715);
                      v717 = v1146 + v715;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v718 = v716 - 1;
                      if ( !v718 )
                        break;
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = v687[14];
                      v687[14] = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v717);
                      v719 = v1146 + v717;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      v720 = v718 - 1;
                      if ( !v720 )
                        break;
                      LOBYTE(v685) = byte_F6EE0[v31];
                      BYTE1(v685) = v687[15];
                      v687[15] = byte_FAEE0[v685];
                      v180 = __CFADD__((_WORD)v1146, v719);
                      v690 = v1146 + v719;
                      BYTE1(v31) += BYTE2(v1146) + v180;
                      LOWORD(v686) = v720 - 1;
                      if ( !(_WORD)v686 )
                        break;
                      v687 += 16;
                    }
                  }
LABEL_906:
                  v684 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v686 > dword_DE564 )
                  LOWORD(v686) = dword_DE564;
                v18 = __OFSUB__((_WORD)v686, (_WORD)v31);
                LOWORD(v686) = v686 - v31;
                if ( (unsigned __int8)(((v686 & 0x8000u) != 0) ^ v18) | ((_WORD)v686 == 0) )
                  goto LABEL_906;
                v687 += v31;
                v31 = (unsigned __int8)byte_E126C;
                v690 = v684[8];
                BYTE1(v31) = *((_BYTE *)v684 + 18);
                goto LABEL_889;
              case 0x12:
                v721 = (unsigned __int16 *)&unk_DE56C;
                v1174 = v1135 << 16;
                HIWORD(v722) = 0;
                HIWORD(v723) = 0;
                while ( 1 )
                {
                  LOWORD(v722) = v721[1];
                  v724 = v721[3];
                  v725 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v722 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v724 > 0 )
                  {
                    v726 = (unsigned __int16)-(signed __int16)v722;
                    v728 = __ROL4__(*((_DWORD *)v721 + 3) + v1135 * v726, 16);
                    BYTE1(v723) = v728;
                    v727 = *((_DWORD *)v721 + 2) + v1124 * v726;
                    LOWORD(v728) = v727;
                    v729 = v727 >> 8;
                    LOBYTE(v723) = BYTE1(v729);
                    if ( v724 > dword_DE564 )
                      LOWORD(v724) = dword_DE564;
                    v722 = (unsigned __int16)v729;
LABEL_918:
                    v1283 = v721;
                    v730 = dword_DE55C;
                    while ( 1 )
                    {
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v728);
                      LOWORD(v728) = v1124 + v728;
                      LOBYTE(v722) = *v725;
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v728);
                      v731 = v1174 + v728;
                      *v725 = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      v732 = v724 - 1;
                      if ( !v732 )
                        break;
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v731);
                      LOWORD(v731) = v1124 + v731;
                      LOBYTE(v722) = v725[1];
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v731);
                      v733 = v1174 + v731;
                      v725[1] = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      v734 = v732 - 1;
                      if ( !v734 )
                        break;
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v733);
                      LOWORD(v733) = v1124 + v733;
                      LOBYTE(v722) = v725[2];
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v733);
                      v735 = v1174 + v733;
                      v725[2] = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      v736 = v734 - 1;
                      if ( !v736 )
                        break;
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v735);
                      LOWORD(v735) = v1124 + v735;
                      LOBYTE(v722) = v725[3];
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v735);
                      v737 = v1174 + v735;
                      v725[3] = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      v738 = v736 - 1;
                      if ( !v738 )
                        break;
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v737);
                      LOWORD(v737) = v1124 + v737;
                      LOBYTE(v722) = v725[4];
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v737);
                      v739 = v1174 + v737;
                      v725[4] = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      v740 = v738 - 1;
                      if ( !v740 )
                        break;
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v739);
                      LOWORD(v739) = v1124 + v739;
                      LOBYTE(v722) = v725[5];
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v739);
                      v741 = v1174 + v739;
                      v725[5] = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      v742 = v740 - 1;
                      if ( !v742 )
                        break;
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v741);
                      LOWORD(v741) = v1124 + v741;
                      LOBYTE(v722) = v725[6];
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v741);
                      v743 = v1174 + v741;
                      v725[6] = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      v744 = v742 - 1;
                      if ( !v744 )
                        break;
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v743);
                      LOWORD(v743) = v1124 + v743;
                      LOBYTE(v722) = v725[7];
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v743);
                      v745 = v1174 + v743;
                      v725[7] = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      v746 = v744 - 1;
                      if ( !v746 )
                        break;
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v745);
                      LOWORD(v745) = v1124 + v745;
                      LOBYTE(v722) = v725[8];
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v745);
                      v747 = v1174 + v745;
                      v725[8] = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      v748 = v746 - 1;
                      if ( !v748 )
                        break;
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v747);
                      LOWORD(v747) = v1124 + v747;
                      LOBYTE(v722) = v725[9];
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v747);
                      v749 = v1174 + v747;
                      v725[9] = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      v750 = v748 - 1;
                      if ( !v750 )
                        break;
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v749);
                      LOWORD(v749) = v1124 + v749;
                      LOBYTE(v722) = v725[10];
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v749);
                      v751 = v1174 + v749;
                      v725[10] = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      v752 = v750 - 1;
                      if ( !v752 )
                        break;
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v751);
                      LOWORD(v751) = v1124 + v751;
                      LOBYTE(v722) = v725[11];
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v751);
                      v753 = v1174 + v751;
                      v725[11] = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      v754 = v752 - 1;
                      if ( !v754 )
                        break;
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v753);
                      LOWORD(v753) = v1124 + v753;
                      LOBYTE(v722) = v725[12];
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v753);
                      v755 = v1174 + v753;
                      v725[12] = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      v756 = v754 - 1;
                      if ( !v756 )
                        break;
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v755);
                      LOWORD(v755) = v1124 + v755;
                      LOBYTE(v722) = v725[13];
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v755);
                      v757 = v1174 + v755;
                      v725[13] = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      v758 = v756 - 1;
                      if ( !v758 )
                        break;
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v757);
                      LOWORD(v757) = v1124 + v757;
                      LOBYTE(v722) = v725[14];
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v757);
                      v759 = v1174 + v757;
                      v725[14] = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      v760 = v758 - 1;
                      if ( !v760 )
                        break;
                      BYTE1(v722) = *(_BYTE *)(v723 + v730);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v759);
                      LOWORD(v759) = v1124 + v759;
                      LOBYTE(v722) = v725[15];
                      LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
                      v180 = __CFADD__(v1174, v759);
                      v728 = v1174 + v759;
                      v725[15] = byte_FAEE0[v722];
                      BYTE1(v723) += BYTE2(v1135) + v180;
                      LOWORD(v724) = v760 - 1;
                      if ( !(_WORD)v724 )
                        break;
                      v725 += 16;
                    }
                    v721 = v1283;
                  }
LABEL_937:
                  v721 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v724 > dword_DE564 )
                  LOWORD(v724) = dword_DE564;
                v18 = __OFSUB__((_WORD)v724, (_WORD)v722);
                LOWORD(v724) = v724 - v722;
                if ( (unsigned __int8)(((v724 & 0x8000u) != 0) ^ v18) | ((_WORD)v724 == 0) )
                  goto LABEL_937;
                v725 += v722;
                v728 = __ROL4__(*((_DWORD *)v721 + 3), 16);
                BYTE1(v723) = v728;
                LOWORD(v728) = v721[4];
                LOBYTE(v723) = *((_BYTE *)v721 + 10);
                goto LABEL_918;
              case 0x13:
                v761 = (unsigned __int16 *)&unk_DE56C;
                v1175 = v1135 << 16;
                HIWORD(v762) = 0;
                HIWORD(v763) = 0;
                while ( 1 )
                {
                  LOWORD(v762) = v761[1];
                  v764 = v761[3];
                  v765 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v762 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v764 > 0 )
                  {
                    v766 = (unsigned __int16)-(signed __int16)v762;
                    v768 = __ROL4__(*((_DWORD *)v761 + 3) + v1135 * v766, 16);
                    BYTE1(v763) = v768;
                    v767 = *((_DWORD *)v761 + 2) + v1124 * v766;
                    LOWORD(v768) = v767;
                    v769 = v767 >> 8;
                    LOBYTE(v763) = BYTE1(v769);
                    if ( v764 > dword_DE564 )
                      LOWORD(v764) = dword_DE564;
                    v762 = (unsigned __int16)v769;
LABEL_949:
                    v1284 = v761;
                    v770 = dword_DE55C;
                    while ( 1 )
                    {
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v768);
                      LOWORD(v768) = v1124 + v768;
                      BYTE1(v762) = *v765;
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v768);
                      v771 = v1175 + v768;
                      *v765 = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      v772 = v764 - 1;
                      if ( !v772 )
                        break;
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v771);
                      LOWORD(v771) = v1124 + v771;
                      BYTE1(v762) = v765[1];
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v771);
                      v773 = v1175 + v771;
                      v765[1] = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      v774 = v772 - 1;
                      if ( !v774 )
                        break;
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v773);
                      LOWORD(v773) = v1124 + v773;
                      BYTE1(v762) = v765[2];
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v773);
                      v775 = v1175 + v773;
                      v765[2] = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      v776 = v774 - 1;
                      if ( !v776 )
                        break;
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v775);
                      LOWORD(v775) = v1124 + v775;
                      BYTE1(v762) = v765[3];
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v775);
                      v777 = v1175 + v775;
                      v765[3] = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      v778 = v776 - 1;
                      if ( !v778 )
                        break;
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v777);
                      LOWORD(v777) = v1124 + v777;
                      BYTE1(v762) = v765[4];
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v777);
                      v779 = v1175 + v777;
                      v765[4] = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      v780 = v778 - 1;
                      if ( !v780 )
                        break;
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v779);
                      LOWORD(v779) = v1124 + v779;
                      BYTE1(v762) = v765[5];
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v779);
                      v781 = v1175 + v779;
                      v765[5] = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      v782 = v780 - 1;
                      if ( !v782 )
                        break;
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v781);
                      LOWORD(v781) = v1124 + v781;
                      BYTE1(v762) = v765[6];
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v781);
                      v783 = v1175 + v781;
                      v765[6] = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      v784 = v782 - 1;
                      if ( !v784 )
                        break;
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v783);
                      LOWORD(v783) = v1124 + v783;
                      BYTE1(v762) = v765[7];
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v783);
                      v785 = v1175 + v783;
                      v765[7] = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      v786 = v784 - 1;
                      if ( !v786 )
                        break;
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v785);
                      LOWORD(v785) = v1124 + v785;
                      BYTE1(v762) = v765[8];
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v785);
                      v787 = v1175 + v785;
                      v765[8] = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      v788 = v786 - 1;
                      if ( !v788 )
                        break;
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v787);
                      LOWORD(v787) = v1124 + v787;
                      BYTE1(v762) = v765[9];
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v787);
                      v789 = v1175 + v787;
                      v765[9] = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      v790 = v788 - 1;
                      if ( !v790 )
                        break;
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v789);
                      LOWORD(v789) = v1124 + v789;
                      BYTE1(v762) = v765[10];
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v789);
                      v791 = v1175 + v789;
                      v765[10] = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      v792 = v790 - 1;
                      if ( !v792 )
                        break;
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v791);
                      LOWORD(v791) = v1124 + v791;
                      BYTE1(v762) = v765[11];
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v791);
                      v793 = v1175 + v791;
                      v765[11] = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      v794 = v792 - 1;
                      if ( !v794 )
                        break;
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v793);
                      LOWORD(v793) = v1124 + v793;
                      BYTE1(v762) = v765[12];
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v793);
                      v795 = v1175 + v793;
                      v765[12] = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      v796 = v794 - 1;
                      if ( !v796 )
                        break;
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v795);
                      LOWORD(v795) = v1124 + v795;
                      BYTE1(v762) = v765[13];
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v795);
                      v797 = v1175 + v795;
                      v765[13] = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      v798 = v796 - 1;
                      if ( !v798 )
                        break;
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v797);
                      LOWORD(v797) = v1124 + v797;
                      BYTE1(v762) = v765[14];
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v797);
                      v799 = v1175 + v797;
                      v765[14] = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      v800 = v798 - 1;
                      if ( !v800 )
                        break;
                      LOBYTE(v762) = *(_BYTE *)(v763 + v770);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v799);
                      LOWORD(v799) = v1124 + v799;
                      BYTE1(v762) = v765[15];
                      LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
                      v180 = __CFADD__(v1175, v799);
                      v768 = v1175 + v799;
                      v765[15] = byte_FAEE0[v762];
                      BYTE1(v763) += BYTE2(v1135) + v180;
                      LOWORD(v764) = v800 - 1;
                      if ( !(_WORD)v764 )
                        break;
                      v765 += 16;
                    }
                    v761 = v1284;
                  }
LABEL_968:
                  v761 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v764 > dword_DE564 )
                  LOWORD(v764) = dword_DE564;
                v18 = __OFSUB__((_WORD)v764, (_WORD)v762);
                LOWORD(v764) = v764 - v762;
                if ( (unsigned __int8)(((v764 & 0x8000u) != 0) ^ v18) | ((_WORD)v764 == 0) )
                  goto LABEL_968;
                v765 += v762;
                v768 = __ROL4__(*((_DWORD *)v761 + 3), 16);
                BYTE1(v763) = v768;
                LOWORD(v768) = v761[4];
                LOBYTE(v763) = *((_BYTE *)v761 + 10);
                goto LABEL_949;
              case 0x14:
                v801 = (unsigned __int16 *)&unk_DE56C;
                v1176 = v1135 << 16;
                v1185 = v1146 << 16;
                HIWORD(v802) = 0;
                HIWORD(v803) = 0;
                while ( 1 )
                {
                  LOWORD(v802) = v801[1];
                  v804 = v801[3];
                  v805 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v802 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v804 > 0 )
                  {
                    if ( v804 > dword_DE564 )
                      v804 = dword_DE564;
                    v1194 = v804;
                    v806 = (unsigned __int16)-(signed __int16)v802;
                    v807 = v806;
                    v809 = __ROL4__(*((_DWORD *)v801 + 3) + v1135 * v806, 16);
                    BYTE1(v803) = v809;
                    v808 = *((_DWORD *)v801 + 2) + v1124 * v806;
                    LOWORD(v809) = v808;
                    v802 = v808 >> 8;
                    LOBYTE(v803) = BYTE1(v802);
                    v810 = __ROL4__(*((_DWORD *)v801 + 4) + v1146 * v807, 16);
                    v802 = (unsigned __int16)v802;
LABEL_980:
                    v1285 = v801;
                    v811 = dword_DE55C;
                    while ( 1 )
                    {
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v809);
                      LOWORD(v809) = v1124 + v809;
                      BYTE1(v802) = v810;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v809);
                      v812 = v1176 + v809;
                      LOBYTE(v802) = *v805;
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v810);
                      v813 = v1185 + v810;
                      *v805 = byte_FAEE0[v802];
                      LOBYTE(v813) = BYTE2(v1146) + v180 + v813;
                      v1195 = v1194 - 1;
                      if ( !v1195 )
                        break;
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v812);
                      LOWORD(v812) = v1124 + v812;
                      BYTE1(v802) = v813;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v812);
                      v814 = v1176 + v812;
                      LOBYTE(v802) = v805[1];
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v813);
                      v815 = v1185 + v813;
                      v805[1] = byte_FAEE0[v802];
                      LOBYTE(v815) = BYTE2(v1146) + v180 + v815;
                      v1196 = v1195 - 1;
                      if ( !v1196 )
                        break;
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v814);
                      LOWORD(v814) = v1124 + v814;
                      BYTE1(v802) = v815;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v814);
                      v816 = v1176 + v814;
                      LOBYTE(v802) = v805[2];
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v815);
                      v817 = v1185 + v815;
                      v805[2] = byte_FAEE0[v802];
                      LOBYTE(v817) = BYTE2(v1146) + v180 + v817;
                      v1197 = v1196 - 1;
                      if ( !v1197 )
                        break;
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v816);
                      LOWORD(v816) = v1124 + v816;
                      BYTE1(v802) = v817;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v816);
                      v818 = v1176 + v816;
                      LOBYTE(v802) = v805[3];
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v817);
                      v819 = v1185 + v817;
                      v805[3] = byte_FAEE0[v802];
                      LOBYTE(v819) = BYTE2(v1146) + v180 + v819;
                      v1198 = v1197 - 1;
                      if ( !v1198 )
                        break;
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v818);
                      LOWORD(v818) = v1124 + v818;
                      BYTE1(v802) = v819;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v818);
                      v820 = v1176 + v818;
                      LOBYTE(v802) = v805[4];
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v819);
                      v821 = v1185 + v819;
                      v805[4] = byte_FAEE0[v802];
                      LOBYTE(v821) = BYTE2(v1146) + v180 + v821;
                      v1199 = v1198 - 1;
                      if ( !v1199 )
                        break;
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v820);
                      LOWORD(v820) = v1124 + v820;
                      BYTE1(v802) = v821;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v820);
                      v822 = v1176 + v820;
                      LOBYTE(v802) = v805[5];
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v821);
                      v823 = v1185 + v821;
                      v805[5] = byte_FAEE0[v802];
                      LOBYTE(v823) = BYTE2(v1146) + v180 + v823;
                      v1200 = v1199 - 1;
                      if ( !v1200 )
                        break;
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v822);
                      LOWORD(v822) = v1124 + v822;
                      BYTE1(v802) = v823;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v822);
                      v824 = v1176 + v822;
                      LOBYTE(v802) = v805[6];
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v823);
                      v825 = v1185 + v823;
                      v805[6] = byte_FAEE0[v802];
                      LOBYTE(v825) = BYTE2(v1146) + v180 + v825;
                      v1201 = v1200 - 1;
                      if ( !v1201 )
                        break;
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v824);
                      LOWORD(v824) = v1124 + v824;
                      BYTE1(v802) = v825;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v824);
                      v826 = v1176 + v824;
                      LOBYTE(v802) = v805[7];
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v825);
                      v827 = v1185 + v825;
                      v805[7] = byte_FAEE0[v802];
                      LOBYTE(v827) = BYTE2(v1146) + v180 + v827;
                      v1202 = v1201 - 1;
                      if ( !v1202 )
                        break;
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v826);
                      LOWORD(v826) = v1124 + v826;
                      BYTE1(v802) = v827;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v826);
                      v828 = v1176 + v826;
                      LOBYTE(v802) = v805[8];
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v827);
                      v829 = v1185 + v827;
                      v805[8] = byte_FAEE0[v802];
                      LOBYTE(v829) = BYTE2(v1146) + v180 + v829;
                      v1203 = v1202 - 1;
                      if ( !v1203 )
                        break;
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v828);
                      LOWORD(v828) = v1124 + v828;
                      BYTE1(v802) = v829;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v828);
                      v830 = v1176 + v828;
                      LOBYTE(v802) = v805[9];
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v829);
                      v831 = v1185 + v829;
                      v805[9] = byte_FAEE0[v802];
                      LOBYTE(v831) = BYTE2(v1146) + v180 + v831;
                      v1204 = v1203 - 1;
                      if ( !v1204 )
                        break;
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v830);
                      LOWORD(v830) = v1124 + v830;
                      BYTE1(v802) = v831;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v830);
                      v832 = v1176 + v830;
                      LOBYTE(v802) = v805[10];
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v831);
                      v833 = v1185 + v831;
                      v805[10] = byte_FAEE0[v802];
                      LOBYTE(v833) = BYTE2(v1146) + v180 + v833;
                      v1205 = v1204 - 1;
                      if ( !v1205 )
                        break;
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v832);
                      LOWORD(v832) = v1124 + v832;
                      BYTE1(v802) = v833;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v832);
                      v834 = v1176 + v832;
                      LOBYTE(v802) = v805[11];
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v833);
                      v835 = v1185 + v833;
                      v805[11] = byte_FAEE0[v802];
                      LOBYTE(v835) = BYTE2(v1146) + v180 + v835;
                      v1206 = v1205 - 1;
                      if ( !v1206 )
                        break;
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v834);
                      LOWORD(v834) = v1124 + v834;
                      BYTE1(v802) = v835;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v834);
                      v836 = v1176 + v834;
                      LOBYTE(v802) = v805[12];
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v835);
                      v837 = v1185 + v835;
                      v805[12] = byte_FAEE0[v802];
                      LOBYTE(v837) = BYTE2(v1146) + v180 + v837;
                      v1207 = v1206 - 1;
                      if ( !v1207 )
                        break;
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v836);
                      LOWORD(v836) = v1124 + v836;
                      BYTE1(v802) = v837;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v836);
                      v838 = v1176 + v836;
                      LOBYTE(v802) = v805[13];
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v837);
                      v839 = v1185 + v837;
                      v805[13] = byte_FAEE0[v802];
                      LOBYTE(v839) = BYTE2(v1146) + v180 + v839;
                      v1208 = v1207 - 1;
                      if ( !v1208 )
                        break;
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v838);
                      LOWORD(v838) = v1124 + v838;
                      BYTE1(v802) = v839;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v838);
                      v840 = v1176 + v838;
                      LOBYTE(v802) = v805[14];
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v839);
                      v841 = v1185 + v839;
                      v805[14] = byte_FAEE0[v802];
                      LOBYTE(v841) = BYTE2(v1146) + v180 + v841;
                      v1209 = v1208 - 1;
                      if ( !v1209 )
                        break;
                      LOBYTE(v802) = *(_BYTE *)(v803 + v811);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v840);
                      LOWORD(v840) = v1124 + v840;
                      BYTE1(v802) = v841;
                      LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
                      BYTE1(v802) = byte_F6EE0[v802];
                      v180 = __CFADD__(v1176, v840);
                      v809 = v1176 + v840;
                      LOBYTE(v802) = v805[15];
                      BYTE1(v803) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1185, v841);
                      v810 = v1185 + v841;
                      v805[15] = byte_FAEE0[v802];
                      LOBYTE(v810) = BYTE2(v1146) + v180 + v810;
                      v1194 = v1209 - 1;
                      if ( !v1194 )
                        break;
                      v805 += 16;
                    }
                    v801 = v1285;
                  }
LABEL_999:
                  v801 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v804 > dword_DE564 )
                  v804 = dword_DE564;
                v18 = __OFSUB__((_WORD)v804, (_WORD)v802);
                LOWORD(v804) = v804 - v802;
                if ( (unsigned __int8)(((v804 & 0x8000u) != 0) ^ v18) | ((_WORD)v804 == 0) )
                  goto LABEL_999;
                v805 += v802;
                v809 = __ROL4__(*((_DWORD *)v801 + 3), 16);
                BYTE1(v803) = v809;
                LOWORD(v809) = v801[4];
                LOBYTE(v803) = *((_BYTE *)v801 + 10);
                v1194 = v804;
                v810 = __ROL4__(*((_DWORD *)v801 + 4), 16);
                goto LABEL_980;
              case 0x15:
                v842 = (unsigned __int16 *)&unk_DE56C;
                v1177 = v1135 << 16;
                v1186 = v1146 << 16;
                HIWORD(v843) = 0;
                HIWORD(v844) = 0;
                while ( 1 )
                {
                  LOWORD(v843) = v842[1];
                  v845 = v842[3];
                  v846 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v843 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v845 > 0 )
                  {
                    if ( v845 > dword_DE564 )
                      v845 = dword_DE564;
                    v1210 = v845;
                    v847 = (unsigned __int16)-(signed __int16)v843;
                    v848 = v847;
                    v850 = __ROL4__(*((_DWORD *)v842 + 3) + v1135 * v847, 16);
                    BYTE1(v844) = v850;
                    v849 = *((_DWORD *)v842 + 2) + v1124 * v847;
                    LOWORD(v850) = v849;
                    v843 = v849 >> 8;
                    LOBYTE(v844) = BYTE1(v843);
                    v851 = __ROL4__(*((_DWORD *)v842 + 4) + v1146 * v848, 16);
                    v843 = (unsigned __int16)v843;
LABEL_1011:
                    v1286 = v842;
                    v852 = dword_DE55C;
                    while ( 1 )
                    {
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v850);
                      LOWORD(v850) = v1124 + v850;
                      BYTE1(v843) = v851;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v850);
                      v853 = v1177 + v850;
                      BYTE1(v843) = *v846;
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v851);
                      v854 = v1186 + v851;
                      *v846 = byte_FAEE0[v843];
                      LOBYTE(v854) = BYTE2(v1146) + v180 + v854;
                      v1211 = v1210 - 1;
                      if ( !v1211 )
                        break;
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v853);
                      LOWORD(v853) = v1124 + v853;
                      BYTE1(v843) = v854;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v853);
                      v855 = v1177 + v853;
                      BYTE1(v843) = v846[1];
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v854);
                      v856 = v1186 + v854;
                      v846[1] = byte_FAEE0[v843];
                      LOBYTE(v856) = BYTE2(v1146) + v180 + v856;
                      v1212 = v1211 - 1;
                      if ( !v1212 )
                        break;
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v855);
                      LOWORD(v855) = v1124 + v855;
                      BYTE1(v843) = v856;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v855);
                      v857 = v1177 + v855;
                      BYTE1(v843) = v846[2];
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v856);
                      v858 = v1186 + v856;
                      v846[2] = byte_FAEE0[v843];
                      LOBYTE(v858) = BYTE2(v1146) + v180 + v858;
                      v1213 = v1212 - 1;
                      if ( !v1213 )
                        break;
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v857);
                      LOWORD(v857) = v1124 + v857;
                      BYTE1(v843) = v858;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v857);
                      v859 = v1177 + v857;
                      BYTE1(v843) = v846[3];
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v858);
                      v860 = v1186 + v858;
                      v846[3] = byte_FAEE0[v843];
                      LOBYTE(v860) = BYTE2(v1146) + v180 + v860;
                      v1214 = v1213 - 1;
                      if ( !v1214 )
                        break;
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v859);
                      LOWORD(v859) = v1124 + v859;
                      BYTE1(v843) = v860;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v859);
                      v861 = v1177 + v859;
                      BYTE1(v843) = v846[4];
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v860);
                      v862 = v1186 + v860;
                      v846[4] = byte_FAEE0[v843];
                      LOBYTE(v862) = BYTE2(v1146) + v180 + v862;
                      v1215 = v1214 - 1;
                      if ( !v1215 )
                        break;
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v861);
                      LOWORD(v861) = v1124 + v861;
                      BYTE1(v843) = v862;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v861);
                      v863 = v1177 + v861;
                      BYTE1(v843) = v846[5];
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v862);
                      v864 = v1186 + v862;
                      v846[5] = byte_FAEE0[v843];
                      LOBYTE(v864) = BYTE2(v1146) + v180 + v864;
                      v1216 = v1215 - 1;
                      if ( !v1216 )
                        break;
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v863);
                      LOWORD(v863) = v1124 + v863;
                      BYTE1(v843) = v864;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v863);
                      v865 = v1177 + v863;
                      BYTE1(v843) = v846[6];
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v864);
                      v866 = v1186 + v864;
                      v846[6] = byte_FAEE0[v843];
                      LOBYTE(v866) = BYTE2(v1146) + v180 + v866;
                      v1217 = v1216 - 1;
                      if ( !v1217 )
                        break;
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v865);
                      LOWORD(v865) = v1124 + v865;
                      BYTE1(v843) = v866;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v865);
                      v867 = v1177 + v865;
                      BYTE1(v843) = v846[7];
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v866);
                      v868 = v1186 + v866;
                      v846[7] = byte_FAEE0[v843];
                      LOBYTE(v868) = BYTE2(v1146) + v180 + v868;
                      v1218 = v1217 - 1;
                      if ( !v1218 )
                        break;
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v867);
                      LOWORD(v867) = v1124 + v867;
                      BYTE1(v843) = v868;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v867);
                      v869 = v1177 + v867;
                      BYTE1(v843) = v846[8];
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v868);
                      v870 = v1186 + v868;
                      v846[8] = byte_FAEE0[v843];
                      LOBYTE(v870) = BYTE2(v1146) + v180 + v870;
                      v1219 = v1218 - 1;
                      if ( !v1219 )
                        break;
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v869);
                      LOWORD(v869) = v1124 + v869;
                      BYTE1(v843) = v870;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v869);
                      v871 = v1177 + v869;
                      BYTE1(v843) = v846[9];
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v870);
                      v872 = v1186 + v870;
                      v846[9] = byte_FAEE0[v843];
                      LOBYTE(v872) = BYTE2(v1146) + v180 + v872;
                      v1220 = v1219 - 1;
                      if ( !v1220 )
                        break;
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v871);
                      LOWORD(v871) = v1124 + v871;
                      BYTE1(v843) = v872;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v871);
                      v873 = v1177 + v871;
                      BYTE1(v843) = v846[10];
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v872);
                      v874 = v1186 + v872;
                      v846[10] = byte_FAEE0[v843];
                      LOBYTE(v874) = BYTE2(v1146) + v180 + v874;
                      v1221 = v1220 - 1;
                      if ( !v1221 )
                        break;
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v873);
                      LOWORD(v873) = v1124 + v873;
                      BYTE1(v843) = v874;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v873);
                      v875 = v1177 + v873;
                      BYTE1(v843) = v846[11];
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v874);
                      v876 = v1186 + v874;
                      v846[11] = byte_FAEE0[v843];
                      LOBYTE(v876) = BYTE2(v1146) + v180 + v876;
                      v1222 = v1221 - 1;
                      if ( !v1222 )
                        break;
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v875);
                      LOWORD(v875) = v1124 + v875;
                      BYTE1(v843) = v876;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v875);
                      v877 = v1177 + v875;
                      BYTE1(v843) = v846[12];
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v876);
                      v878 = v1186 + v876;
                      v846[12] = byte_FAEE0[v843];
                      LOBYTE(v878) = BYTE2(v1146) + v180 + v878;
                      v1223 = v1222 - 1;
                      if ( !v1223 )
                        break;
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v877);
                      LOWORD(v877) = v1124 + v877;
                      BYTE1(v843) = v878;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v877);
                      v879 = v1177 + v877;
                      BYTE1(v843) = v846[13];
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v878);
                      v880 = v1186 + v878;
                      v846[13] = byte_FAEE0[v843];
                      LOBYTE(v880) = BYTE2(v1146) + v180 + v880;
                      v1224 = v1223 - 1;
                      if ( !v1224 )
                        break;
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v879);
                      LOWORD(v879) = v1124 + v879;
                      BYTE1(v843) = v880;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v879);
                      v881 = v1177 + v879;
                      BYTE1(v843) = v846[14];
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v880);
                      v882 = v1186 + v880;
                      v846[14] = byte_FAEE0[v843];
                      LOBYTE(v882) = BYTE2(v1146) + v180 + v882;
                      v1225 = v1224 - 1;
                      if ( !v1225 )
                        break;
                      LOBYTE(v843) = *(_BYTE *)(v844 + v852);
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v881);
                      LOWORD(v881) = v1124 + v881;
                      BYTE1(v843) = v882;
                      LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
                      LOBYTE(v843) = byte_F6EE0[v843];
                      v180 = __CFADD__(v1177, v881);
                      v850 = v1177 + v881;
                      BYTE1(v843) = v846[15];
                      BYTE1(v844) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1186, v882);
                      v851 = v1186 + v882;
                      v846[15] = byte_FAEE0[v843];
                      LOBYTE(v851) = BYTE2(v1146) + v180 + v851;
                      v1210 = v1225 - 1;
                      if ( !v1210 )
                        break;
                      v846 += 16;
                    }
                    v842 = v1286;
                  }
LABEL_1030:
                  v842 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v845 > dword_DE564 )
                  v845 = dword_DE564;
                v18 = __OFSUB__((_WORD)v845, (_WORD)v843);
                LOWORD(v845) = v845 - v843;
                if ( (unsigned __int8)(((v845 & 0x8000u) != 0) ^ v18) | ((_WORD)v845 == 0) )
                  goto LABEL_1030;
                v846 += v843;
                v850 = __ROL4__(*((_DWORD *)v842 + 3), 16);
                BYTE1(v844) = v850;
                LOWORD(v850) = v842[4];
                LOBYTE(v844) = *((_BYTE *)v842 + 10);
                v1210 = v845;
                v851 = __ROL4__(*((_DWORD *)v842 + 4), 16);
                goto LABEL_1011;
              case 0x16:
                v883 = (unsigned __int16 *)&unk_DE56C;
                v1178 = v1135 << 16;
                HIWORD(v884) = 0;
                HIWORD(v885) = 0;
                while ( 1 )
                {
                  LOWORD(v884) = v883[1];
                  v886 = v883[3];
                  v887 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v884 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v886 > 0 )
                  {
                    v888 = (unsigned __int16)-(signed __int16)v884;
                    v890 = __ROL4__(*((_DWORD *)v883 + 3) + v1135 * v888, 16);
                    BYTE1(v885) = v890;
                    v889 = *((_DWORD *)v883 + 2) + v1124 * v888;
                    LOWORD(v890) = v889;
                    v891 = v889 >> 8;
                    LOBYTE(v885) = BYTE1(v891);
                    if ( v886 > dword_DE564 )
                      LOWORD(v886) = dword_DE564;
                    v884 = (unsigned __int16)v891;
LABEL_1042:
                    v1287 = v883;
                    v892 = dword_DE55C;
                    while ( 1 )
                    {
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = *v887;
                        *v887 = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v890);
                      LOWORD(v890) = v1124 + v890;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v890);
                      v893 = v1178 + v890;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      v894 = v886 - 1;
                      if ( !v894 )
                        break;
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = v887[1];
                        v887[1] = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v893);
                      LOWORD(v893) = v1124 + v893;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v893);
                      v895 = v1178 + v893;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      v896 = v894 - 1;
                      if ( !v896 )
                        break;
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = v887[2];
                        v887[2] = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v895);
                      LOWORD(v895) = v1124 + v895;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v895);
                      v897 = v1178 + v895;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      v898 = v896 - 1;
                      if ( !v898 )
                        break;
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = v887[3];
                        v887[3] = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v897);
                      LOWORD(v897) = v1124 + v897;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v897);
                      v899 = v1178 + v897;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      v900 = v898 - 1;
                      if ( !v900 )
                        break;
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = v887[4];
                        v887[4] = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v899);
                      LOWORD(v899) = v1124 + v899;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v899);
                      v901 = v1178 + v899;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      v902 = v900 - 1;
                      if ( !v902 )
                        break;
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = v887[5];
                        v887[5] = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v901);
                      LOWORD(v901) = v1124 + v901;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v901);
                      v903 = v1178 + v901;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      v904 = v902 - 1;
                      if ( !v904 )
                        break;
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = v887[6];
                        v887[6] = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v903);
                      LOWORD(v903) = v1124 + v903;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v903);
                      v905 = v1178 + v903;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      v906 = v904 - 1;
                      if ( !v906 )
                        break;
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = v887[7];
                        v887[7] = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v905);
                      LOWORD(v905) = v1124 + v905;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v905);
                      v907 = v1178 + v905;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      v908 = v906 - 1;
                      if ( !v908 )
                        break;
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = v887[8];
                        v887[8] = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v907);
                      LOWORD(v907) = v1124 + v907;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v907);
                      v909 = v1178 + v907;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      v910 = v908 - 1;
                      if ( !v910 )
                        break;
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = v887[9];
                        v887[9] = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v909);
                      LOWORD(v909) = v1124 + v909;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v909);
                      v911 = v1178 + v909;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      v912 = v910 - 1;
                      if ( !v912 )
                        break;
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = v887[10];
                        v887[10] = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v911);
                      LOWORD(v911) = v1124 + v911;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v911);
                      v913 = v1178 + v911;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      v914 = v912 - 1;
                      if ( !v914 )
                        break;
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = v887[11];
                        v887[11] = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v913);
                      LOWORD(v913) = v1124 + v913;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v913);
                      v915 = v1178 + v913;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      v916 = v914 - 1;
                      if ( !v916 )
                        break;
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = v887[12];
                        v887[12] = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v915);
                      LOWORD(v915) = v1124 + v915;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v915);
                      v917 = v1178 + v915;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      v918 = v916 - 1;
                      if ( !v918 )
                        break;
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = v887[13];
                        v887[13] = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v917);
                      LOWORD(v917) = v1124 + v917;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v917);
                      v919 = v1178 + v917;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      v920 = v918 - 1;
                      if ( !v920 )
                        break;
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = v887[14];
                        v887[14] = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v919);
                      LOWORD(v919) = v1124 + v919;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v919);
                      v921 = v1178 + v919;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      v922 = v920 - 1;
                      if ( !v922 )
                        break;
                      BYTE1(v884) = *(_BYTE *)(v885 + v892);
                      if ( BYTE1(v884) )
                      {
                        LOBYTE(v884) = v887[15];
                        v887[15] = byte_FAEE0[v884];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v921);
                      LOWORD(v921) = v1124 + v921;
                      LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
                      v180 = __CFADD__(v1178, v921);
                      v890 = v1178 + v921;
                      BYTE1(v885) += BYTE2(v1135) + v180;
                      LOWORD(v886) = v922 - 1;
                      if ( !(_WORD)v886 )
                        break;
                      v887 += 16;
                    }
                    v883 = v1287;
                  }
LABEL_1093:
                  v883 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v886 > dword_DE564 )
                  LOWORD(v886) = dword_DE564;
                v18 = __OFSUB__((_WORD)v886, (_WORD)v884);
                LOWORD(v886) = v886 - v884;
                if ( (unsigned __int8)(((v886 & 0x8000u) != 0) ^ v18) | ((_WORD)v886 == 0) )
                  goto LABEL_1093;
                v887 += v884;
                v890 = __ROL4__(*((_DWORD *)v883 + 3), 16);
                BYTE1(v885) = v890;
                LOWORD(v890) = v883[4];
                LOBYTE(v885) = *((_BYTE *)v883 + 10);
                goto LABEL_1042;
              case 0x17:
                v923 = (unsigned __int16 *)&unk_DE56C;
                v1179 = v1135 << 16;
                HIWORD(v924) = 0;
                HIWORD(v925) = 0;
                while ( 1 )
                {
                  LOWORD(v924) = v923[1];
                  v926 = v923[3];
                  v927 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v924 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v926 > 0 )
                  {
                    v928 = (unsigned __int16)-(signed __int16)v924;
                    v930 = __ROL4__(*((_DWORD *)v923 + 3) + v1135 * v928, 16);
                    BYTE1(v925) = v930;
                    v929 = *((_DWORD *)v923 + 2) + v1124 * v928;
                    LOWORD(v930) = v929;
                    v931 = v929 >> 8;
                    LOBYTE(v925) = BYTE1(v931);
                    if ( v926 > dword_DE564 )
                      LOWORD(v926) = dword_DE564;
                    v924 = (unsigned __int16)v931;
LABEL_1105:
                    v1288 = v923;
                    v932 = dword_DE55C;
                    while ( 1 )
                    {
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = *v927;
                        *v927 = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v930);
                      LOWORD(v930) = v1124 + v930;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v930);
                      v933 = v1179 + v930;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      v934 = v926 - 1;
                      if ( !v934 )
                        break;
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = v927[1];
                        v927[1] = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v933);
                      LOWORD(v933) = v1124 + v933;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v933);
                      v935 = v1179 + v933;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      v936 = v934 - 1;
                      if ( !v936 )
                        break;
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = v927[2];
                        v927[2] = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v935);
                      LOWORD(v935) = v1124 + v935;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v935);
                      v937 = v1179 + v935;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      v938 = v936 - 1;
                      if ( !v938 )
                        break;
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = v927[3];
                        v927[3] = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v937);
                      LOWORD(v937) = v1124 + v937;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v937);
                      v939 = v1179 + v937;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      v940 = v938 - 1;
                      if ( !v940 )
                        break;
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = v927[4];
                        v927[4] = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v939);
                      LOWORD(v939) = v1124 + v939;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v939);
                      v941 = v1179 + v939;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      v942 = v940 - 1;
                      if ( !v942 )
                        break;
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = v927[5];
                        v927[5] = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v941);
                      LOWORD(v941) = v1124 + v941;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v941);
                      v943 = v1179 + v941;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      v944 = v942 - 1;
                      if ( !v944 )
                        break;
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = v927[6];
                        v927[6] = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v943);
                      LOWORD(v943) = v1124 + v943;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v943);
                      v945 = v1179 + v943;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      v946 = v944 - 1;
                      if ( !v946 )
                        break;
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = v927[7];
                        v927[7] = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v945);
                      LOWORD(v945) = v1124 + v945;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v945);
                      v947 = v1179 + v945;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      v948 = v946 - 1;
                      if ( !v948 )
                        break;
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = v927[8];
                        v927[8] = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v947);
                      LOWORD(v947) = v1124 + v947;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v947);
                      v949 = v1179 + v947;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      v950 = v948 - 1;
                      if ( !v950 )
                        break;
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = v927[9];
                        v927[9] = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v949);
                      LOWORD(v949) = v1124 + v949;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v949);
                      v951 = v1179 + v949;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      v952 = v950 - 1;
                      if ( !v952 )
                        break;
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = v927[10];
                        v927[10] = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v951);
                      LOWORD(v951) = v1124 + v951;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v951);
                      v953 = v1179 + v951;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      v954 = v952 - 1;
                      if ( !v954 )
                        break;
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = v927[11];
                        v927[11] = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v953);
                      LOWORD(v953) = v1124 + v953;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v953);
                      v955 = v1179 + v953;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      v956 = v954 - 1;
                      if ( !v956 )
                        break;
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = v927[12];
                        v927[12] = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v955);
                      LOWORD(v955) = v1124 + v955;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v955);
                      v957 = v1179 + v955;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      v958 = v956 - 1;
                      if ( !v958 )
                        break;
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = v927[13];
                        v927[13] = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v957);
                      LOWORD(v957) = v1124 + v957;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v957);
                      v959 = v1179 + v957;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      v960 = v958 - 1;
                      if ( !v960 )
                        break;
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = v927[14];
                        v927[14] = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v959);
                      LOWORD(v959) = v1124 + v959;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v959);
                      v961 = v1179 + v959;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      v962 = v960 - 1;
                      if ( !v962 )
                        break;
                      LOBYTE(v924) = *(_BYTE *)(v925 + v932);
                      if ( (_BYTE)v924 )
                      {
                        BYTE1(v924) = v927[15];
                        v927[15] = byte_FAEE0[v924];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v961);
                      LOWORD(v961) = v1124 + v961;
                      LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
                      v180 = __CFADD__(v1179, v961);
                      v930 = v1179 + v961;
                      BYTE1(v925) += BYTE2(v1135) + v180;
                      LOWORD(v926) = v962 - 1;
                      if ( !(_WORD)v926 )
                        break;
                      v927 += 16;
                    }
                    v923 = v1288;
                  }
LABEL_1156:
                  v923 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v926 > dword_DE564 )
                  LOWORD(v926) = dword_DE564;
                v18 = __OFSUB__((_WORD)v926, (_WORD)v924);
                LOWORD(v926) = v926 - v924;
                if ( (unsigned __int8)(((v926 & 0x8000u) != 0) ^ v18) | ((_WORD)v926 == 0) )
                  goto LABEL_1156;
                v927 += v924;
                v930 = __ROL4__(*((_DWORD *)v923 + 3), 16);
                BYTE1(v925) = v930;
                LOWORD(v930) = v923[4];
                LOBYTE(v925) = *((_BYTE *)v923 + 10);
                goto LABEL_1105;
              case 0x18:
                v963 = (unsigned __int16 *)&unk_DE56C;
                v1180 = v1135 << 16;
                v1187 = v1146 << 16;
                HIWORD(v964) = 0;
                HIWORD(v965) = 0;
                while ( 1 )
                {
                  LOWORD(v964) = v963[1];
                  v966 = v963[3];
                  v967 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v964 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v966 > 0 )
                  {
                    if ( v966 > dword_DE564 )
                      v966 = dword_DE564;
                    v1226 = v966;
                    v968 = (unsigned __int16)-(signed __int16)v964;
                    v969 = v968;
                    v971 = __ROL4__(*((_DWORD *)v963 + 3) + v1135 * v968, 16);
                    BYTE1(v965) = v971;
                    v970 = *((_DWORD *)v963 + 2) + v1124 * v968;
                    LOWORD(v971) = v970;
                    v964 = v970 >> 8;
                    LOBYTE(v965) = BYTE1(v964);
                    v972 = __ROL4__(*((_DWORD *)v963 + 4) + v1146 * v969, 16);
                    v964 = (unsigned __int16)v964;
LABEL_1168:
                    v1289 = v963;
                    v973 = dword_DE55C;
                    while ( 1 )
                    {
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v972;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = *v967;
                        *v967 = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v971);
                      LOWORD(v971) = v1124 + v971;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v971);
                      v974 = v1180 + v971;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v972);
                      v975 = v1187 + v972;
                      LOBYTE(v975) = BYTE2(v1146) + v180 + v975;
                      v1227 = v1226 - 1;
                      if ( !v1227 )
                        break;
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v975;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = v967[1];
                        v967[1] = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v974);
                      LOWORD(v974) = v1124 + v974;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v974);
                      v976 = v1180 + v974;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v975);
                      v977 = v1187 + v975;
                      LOBYTE(v977) = BYTE2(v1146) + v180 + v977;
                      v1228 = v1227 - 1;
                      if ( !v1228 )
                        break;
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v977;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = v967[2];
                        v967[2] = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v976);
                      LOWORD(v976) = v1124 + v976;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v976);
                      v978 = v1180 + v976;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v977);
                      v979 = v1187 + v977;
                      LOBYTE(v979) = BYTE2(v1146) + v180 + v979;
                      v1229 = v1228 - 1;
                      if ( !v1229 )
                        break;
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v979;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = v967[3];
                        v967[3] = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v978);
                      LOWORD(v978) = v1124 + v978;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v978);
                      v980 = v1180 + v978;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v979);
                      v981 = v1187 + v979;
                      LOBYTE(v981) = BYTE2(v1146) + v180 + v981;
                      v1230 = v1229 - 1;
                      if ( !v1230 )
                        break;
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v981;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = v967[4];
                        v967[4] = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v980);
                      LOWORD(v980) = v1124 + v980;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v980);
                      v982 = v1180 + v980;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v981);
                      v983 = v1187 + v981;
                      LOBYTE(v983) = BYTE2(v1146) + v180 + v983;
                      v1231 = v1230 - 1;
                      if ( !v1231 )
                        break;
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v983;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = v967[5];
                        v967[5] = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v982);
                      LOWORD(v982) = v1124 + v982;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v982);
                      v984 = v1180 + v982;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v983);
                      v985 = v1187 + v983;
                      LOBYTE(v985) = BYTE2(v1146) + v180 + v985;
                      v1232 = v1231 - 1;
                      if ( !v1232 )
                        break;
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v985;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = v967[6];
                        v967[6] = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v984);
                      LOWORD(v984) = v1124 + v984;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v984);
                      v986 = v1180 + v984;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v985);
                      v987 = v1187 + v985;
                      LOBYTE(v987) = BYTE2(v1146) + v180 + v987;
                      v1233 = v1232 - 1;
                      if ( !v1233 )
                        break;
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v987;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = v967[7];
                        v967[7] = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v986);
                      LOWORD(v986) = v1124 + v986;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v986);
                      v988 = v1180 + v986;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v987);
                      v989 = v1187 + v987;
                      LOBYTE(v989) = BYTE2(v1146) + v180 + v989;
                      v1234 = v1233 - 1;
                      if ( !v1234 )
                        break;
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v989;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = v967[8];
                        v967[8] = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v988);
                      LOWORD(v988) = v1124 + v988;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v988);
                      v990 = v1180 + v988;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v989);
                      v991 = v1187 + v989;
                      LOBYTE(v991) = BYTE2(v1146) + v180 + v991;
                      v1235 = v1234 - 1;
                      if ( !v1235 )
                        break;
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v991;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = v967[9];
                        v967[9] = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v990);
                      LOWORD(v990) = v1124 + v990;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v990);
                      v992 = v1180 + v990;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v991);
                      v993 = v1187 + v991;
                      LOBYTE(v993) = BYTE2(v1146) + v180 + v993;
                      v1236 = v1235 - 1;
                      if ( !v1236 )
                        break;
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v993;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = v967[10];
                        v967[10] = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v992);
                      LOWORD(v992) = v1124 + v992;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v992);
                      v994 = v1180 + v992;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v993);
                      v995 = v1187 + v993;
                      LOBYTE(v995) = BYTE2(v1146) + v180 + v995;
                      v1237 = v1236 - 1;
                      if ( !v1237 )
                        break;
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v995;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = v967[11];
                        v967[11] = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v994);
                      LOWORD(v994) = v1124 + v994;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v994);
                      v996 = v1180 + v994;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v995);
                      v997 = v1187 + v995;
                      LOBYTE(v997) = BYTE2(v1146) + v180 + v997;
                      v1238 = v1237 - 1;
                      if ( !v1238 )
                        break;
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v997;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = v967[12];
                        v967[12] = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v996);
                      LOWORD(v996) = v1124 + v996;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v996);
                      v998 = v1180 + v996;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v997);
                      v999 = v1187 + v997;
                      LOBYTE(v999) = BYTE2(v1146) + v180 + v999;
                      v1239 = v1238 - 1;
                      if ( !v1239 )
                        break;
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v999;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = v967[13];
                        v967[13] = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v998);
                      LOWORD(v998) = v1124 + v998;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v998);
                      v1000 = v1180 + v998;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v999);
                      v1001 = v1187 + v999;
                      LOBYTE(v1001) = BYTE2(v1146) + v180 + v1001;
                      v1240 = v1239 - 1;
                      if ( !v1240 )
                        break;
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v1001;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = v967[14];
                        v967[14] = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1000);
                      LOWORD(v1000) = v1124 + v1000;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v1000);
                      v1002 = v1180 + v1000;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v1001);
                      v1003 = v1187 + v1001;
                      LOBYTE(v1003) = BYTE2(v1146) + v180 + v1003;
                      v1241 = v1240 - 1;
                      if ( !v1241 )
                        break;
                      LOBYTE(v964) = *(_BYTE *)(v965 + v973);
                      if ( (_BYTE)v964 )
                      {
                        BYTE1(v964) = v1003;
                        BYTE1(v964) = byte_F6EE0[v964];
                        LOBYTE(v964) = v967[15];
                        v967[15] = byte_FAEE0[v964];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1002);
                      LOWORD(v1002) = v1124 + v1002;
                      LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
                      v180 = __CFADD__(v1180, v1002);
                      v971 = v1180 + v1002;
                      BYTE1(v965) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1187, v1003);
                      v972 = v1187 + v1003;
                      LOBYTE(v972) = BYTE2(v1146) + v180 + v972;
                      v1226 = v1241 - 1;
                      if ( !v1226 )
                        break;
                      v967 += 16;
                    }
                    v963 = v1289;
                  }
LABEL_1219:
                  v963 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v966 > dword_DE564 )
                  v966 = dword_DE564;
                v18 = __OFSUB__((_WORD)v966, (_WORD)v964);
                LOWORD(v966) = v966 - v964;
                if ( (unsigned __int8)(((v966 & 0x8000u) != 0) ^ v18) | ((_WORD)v966 == 0) )
                  goto LABEL_1219;
                v967 += v964;
                v971 = __ROL4__(*((_DWORD *)v963 + 3), 16);
                BYTE1(v965) = v971;
                LOWORD(v971) = v963[4];
                LOBYTE(v965) = *((_BYTE *)v963 + 10);
                v1226 = v966;
                v972 = __ROL4__(*((_DWORD *)v963 + 4), 16);
                goto LABEL_1168;
              case 0x19:
                v1004 = (unsigned __int16 *)&unk_DE56C;
                v1181 = v1135 << 16;
                v1188 = v1146 << 16;
                HIWORD(v1005) = 0;
                HIWORD(v1006) = 0;
                while ( 1 )
                {
                  LOWORD(v1005) = v1004[1];
                  v1007 = v1004[3];
                  v1008 = (_BYTE *)(dword_DE560 + v1102);
                  v1102 += dword_DE560;
                  if ( (v1005 & 0x8000u) == 0 )
                    break;
                  if ( (signed __int16)v1007 > 0 )
                  {
                    if ( v1007 > dword_DE564 )
                      v1007 = dword_DE564;
                    v1242 = v1007;
                    v1009 = (unsigned __int16)-(signed __int16)v1005;
                    v1010 = v1009;
                    v1012 = __ROL4__(*((_DWORD *)v1004 + 3) + v1135 * v1009, 16);
                    BYTE1(v1006) = v1012;
                    v1011 = *((_DWORD *)v1004 + 2) + v1124 * v1009;
                    LOWORD(v1012) = v1011;
                    v1005 = v1011 >> 8;
                    LOBYTE(v1006) = BYTE1(v1005);
                    v1013 = __ROL4__(*((_DWORD *)v1004 + 4) + v1146 * v1010, 16);
                    v1005 = (unsigned __int16)v1005;
LABEL_1231:
                    v1290 = v1004;
                    v1014 = dword_DE55C;
                    while ( 1 )
                    {
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1013;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = *v1008;
                        *v1008 = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1012);
                      LOWORD(v1012) = v1124 + v1012;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1012);
                      v1015 = v1181 + v1012;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1013);
                      v1016 = v1188 + v1013;
                      LOBYTE(v1016) = BYTE2(v1146) + v180 + v1016;
                      v1243 = v1242 - 1;
                      if ( !v1243 )
                        break;
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1016;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = v1008[1];
                        v1008[1] = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1015);
                      LOWORD(v1015) = v1124 + v1015;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1015);
                      v1017 = v1181 + v1015;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1016);
                      v1018 = v1188 + v1016;
                      LOBYTE(v1018) = BYTE2(v1146) + v180 + v1018;
                      v1244 = v1243 - 1;
                      if ( !v1244 )
                        break;
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1018;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = v1008[2];
                        v1008[2] = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1017);
                      LOWORD(v1017) = v1124 + v1017;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1017);
                      v1019 = v1181 + v1017;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1018);
                      v1020 = v1188 + v1018;
                      LOBYTE(v1020) = BYTE2(v1146) + v180 + v1020;
                      v1245 = v1244 - 1;
                      if ( !v1245 )
                        break;
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1020;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = v1008[3];
                        v1008[3] = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1019);
                      LOWORD(v1019) = v1124 + v1019;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1019);
                      v1021 = v1181 + v1019;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1020);
                      v1022 = v1188 + v1020;
                      LOBYTE(v1022) = BYTE2(v1146) + v180 + v1022;
                      v1246 = v1245 - 1;
                      if ( !v1246 )
                        break;
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1022;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = v1008[4];
                        v1008[4] = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1021);
                      LOWORD(v1021) = v1124 + v1021;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1021);
                      v1023 = v1181 + v1021;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1022);
                      v1024 = v1188 + v1022;
                      LOBYTE(v1024) = BYTE2(v1146) + v180 + v1024;
                      v1247 = v1246 - 1;
                      if ( !v1247 )
                        break;
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1024;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = v1008[5];
                        v1008[5] = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1023);
                      LOWORD(v1023) = v1124 + v1023;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1023);
                      v1025 = v1181 + v1023;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1024);
                      v1026 = v1188 + v1024;
                      LOBYTE(v1026) = BYTE2(v1146) + v180 + v1026;
                      v1248 = v1247 - 1;
                      if ( !v1248 )
                        break;
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1026;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = v1008[6];
                        v1008[6] = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1025);
                      LOWORD(v1025) = v1124 + v1025;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1025);
                      v1027 = v1181 + v1025;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1026);
                      v1028 = v1188 + v1026;
                      LOBYTE(v1028) = BYTE2(v1146) + v180 + v1028;
                      v1249 = v1248 - 1;
                      if ( !v1249 )
                        break;
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1028;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = v1008[7];
                        v1008[7] = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1027);
                      LOWORD(v1027) = v1124 + v1027;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1027);
                      v1029 = v1181 + v1027;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1028);
                      v1030 = v1188 + v1028;
                      LOBYTE(v1030) = BYTE2(v1146) + v180 + v1030;
                      v1250 = v1249 - 1;
                      if ( !v1250 )
                        break;
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1030;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = v1008[8];
                        v1008[8] = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1029);
                      LOWORD(v1029) = v1124 + v1029;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1029);
                      v1031 = v1181 + v1029;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1030);
                      v1032 = v1188 + v1030;
                      LOBYTE(v1032) = BYTE2(v1146) + v180 + v1032;
                      v1251 = v1250 - 1;
                      if ( !v1251 )
                        break;
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1032;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = v1008[9];
                        v1008[9] = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1031);
                      LOWORD(v1031) = v1124 + v1031;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1031);
                      v1033 = v1181 + v1031;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1032);
                      v1034 = v1188 + v1032;
                      LOBYTE(v1034) = BYTE2(v1146) + v180 + v1034;
                      v1252 = v1251 - 1;
                      if ( !v1252 )
                        break;
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1034;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = v1008[10];
                        v1008[10] = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1033);
                      LOWORD(v1033) = v1124 + v1033;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1033);
                      v1035 = v1181 + v1033;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1034);
                      v1036 = v1188 + v1034;
                      LOBYTE(v1036) = BYTE2(v1146) + v180 + v1036;
                      v1253 = v1252 - 1;
                      if ( !v1253 )
                        break;
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1036;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = v1008[11];
                        v1008[11] = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1035);
                      LOWORD(v1035) = v1124 + v1035;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1035);
                      v1037 = v1181 + v1035;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1036);
                      v1038 = v1188 + v1036;
                      LOBYTE(v1038) = BYTE2(v1146) + v180 + v1038;
                      v1254 = v1253 - 1;
                      if ( !v1254 )
                        break;
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1038;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = v1008[12];
                        v1008[12] = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1037);
                      LOWORD(v1037) = v1124 + v1037;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1037);
                      v1039 = v1181 + v1037;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1038);
                      v1040 = v1188 + v1038;
                      LOBYTE(v1040) = BYTE2(v1146) + v180 + v1040;
                      v1255 = v1254 - 1;
                      if ( !v1255 )
                        break;
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1040;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = v1008[13];
                        v1008[13] = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1039);
                      LOWORD(v1039) = v1124 + v1039;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1039);
                      v1041 = v1181 + v1039;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1040);
                      v1042 = v1188 + v1040;
                      LOBYTE(v1042) = BYTE2(v1146) + v180 + v1042;
                      v1256 = v1255 - 1;
                      if ( !v1256 )
                        break;
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1042;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = v1008[14];
                        v1008[14] = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1041);
                      LOWORD(v1041) = v1124 + v1041;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1041);
                      v1043 = v1181 + v1041;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1042);
                      v1044 = v1188 + v1042;
                      LOBYTE(v1044) = BYTE2(v1146) + v180 + v1044;
                      v1257 = v1256 - 1;
                      if ( !v1257 )
                        break;
                      LOBYTE(v1005) = *(_BYTE *)(v1006 + v1014);
                      if ( (_BYTE)v1005 )
                      {
                        BYTE1(v1005) = v1044;
                        LOBYTE(v1005) = byte_F6EE0[v1005];
                        BYTE1(v1005) = v1008[15];
                        v1008[15] = byte_FAEE0[v1005];
                      }
                      v180 = __CFADD__((_WORD)v1124, (_WORD)v1043);
                      LOWORD(v1043) = v1124 + v1043;
                      LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
                      v180 = __CFADD__(v1181, v1043);
                      v1012 = v1181 + v1043;
                      BYTE1(v1006) += BYTE2(v1135) + v180;
                      v180 = __CFADD__(v1188, v1044);
                      v1013 = v1188 + v1044;
                      LOBYTE(v1013) = BYTE2(v1146) + v180 + v1013;
                      v1242 = v1257 - 1;
                      if ( !v1242 )
                        break;
                      v1008 += 16;
                    }
                    v1004 = v1290;
                  }
LABEL_1282:
                  v1004 += 10;
                  if ( !--v1123 )
                    return;
                }
                if ( v1007 > dword_DE564 )
                  v1007 = dword_DE564;
                v18 = __OFSUB__((_WORD)v1007, (_WORD)v1005);
                LOWORD(v1007) = v1007 - v1005;
                if ( (unsigned __int8)(((v1007 & 0x8000u) != 0) ^ v18) | ((_WORD)v1007 == 0) )
                  goto LABEL_1282;
                v1008 += v1005;
                v1012 = __ROL4__(*((_DWORD *)v1004 + 3), 16);
                BYTE1(v1006) = v1012;
                LOWORD(v1012) = v1004[4];
                LOBYTE(v1006) = *((_BYTE *)v1004 + 10);
                v1242 = v1007;
                v1013 = __ROL4__(*((_DWORD *)v1004 + 4), 16);
                goto LABEL_1231;
              case 0x1A:
                v1045 = (unsigned __int16 *)&unk_DE56C;
                v1182 = v1135 << 16;
                v1189 = v1146 << 16;
                HIWORD(v1046) = 0;
                HIWORD(v1047) = 0;
                break;
            }
            while ( 1 )
            {
              LOWORD(v1046) = v1045[1];
              v1048 = v1045[3];
              v1049 = (char *)(dword_DE560 + v1102);
              v1102 += dword_DE560;
              if ( (v1046 & 0x8000u) == 0 )
                break;
              if ( (signed __int16)v1048 > 0 )
              {
                if ( v1048 > dword_DE564 )
                  v1048 = dword_DE564;
                v1258 = v1048;
                v1050 = (unsigned __int16)-(signed __int16)v1046;
                v1051 = v1050;
                v1053 = __ROL4__(*((_DWORD *)v1045 + 3) + v1135 * v1050, 16);
                BYTE1(v1047) = v1053;
                v1052 = *((_DWORD *)v1045 + 2) + v1124 * v1050;
                LOWORD(v1053) = v1052;
                v1046 = v1052 >> 8;
                LOBYTE(v1047) = BYTE1(v1046);
                v1054 = __ROL4__(*((_DWORD *)v1045 + 4) + v1146 * v1051, 16);
                v1046 = (unsigned __int16)v1046;
LABEL_1294:
                v1291 = v1045;
                v1055 = dword_DE55C;
                while ( 1 )
                {
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1053);
                  LOWORD(v1053) = v1124 + v1053;
                  BYTE1(v1046) = v1054;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1056 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = *v1049;
                    v1056 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1053);
                  v1057 = v1182 + v1053;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1054);
                  v1058 = v1189 + v1054;
                  *v1049 = v1056;
                  LOBYTE(v1058) = BYTE2(v1146) + v180 + v1058;
                  v1259 = v1258 - 1;
                  if ( !v1259 )
                    break;
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1057);
                  LOWORD(v1057) = v1124 + v1057;
                  BYTE1(v1046) = v1058;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1059 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = v1049[1];
                    v1059 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1057);
                  v1060 = v1182 + v1057;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1058);
                  v1061 = v1189 + v1058;
                  v1049[1] = v1059;
                  LOBYTE(v1061) = BYTE2(v1146) + v180 + v1061;
                  v1260 = v1259 - 1;
                  if ( !v1260 )
                    break;
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1060);
                  LOWORD(v1060) = v1124 + v1060;
                  BYTE1(v1046) = v1061;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1062 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = v1049[2];
                    v1062 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1060);
                  v1063 = v1182 + v1060;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1061);
                  v1064 = v1189 + v1061;
                  v1049[2] = v1062;
                  LOBYTE(v1064) = BYTE2(v1146) + v180 + v1064;
                  v1261 = v1260 - 1;
                  if ( !v1261 )
                    break;
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1063);
                  LOWORD(v1063) = v1124 + v1063;
                  BYTE1(v1046) = v1064;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1065 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = v1049[3];
                    v1065 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1063);
                  v1066 = v1182 + v1063;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1064);
                  v1067 = v1189 + v1064;
                  v1049[3] = v1065;
                  LOBYTE(v1067) = BYTE2(v1146) + v180 + v1067;
                  v1262 = v1261 - 1;
                  if ( !v1262 )
                    break;
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1066);
                  LOWORD(v1066) = v1124 + v1066;
                  BYTE1(v1046) = v1067;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1068 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = v1049[4];
                    v1068 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1066);
                  v1069 = v1182 + v1066;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1067);
                  v1070 = v1189 + v1067;
                  v1049[4] = v1068;
                  LOBYTE(v1070) = BYTE2(v1146) + v180 + v1070;
                  v1263 = v1262 - 1;
                  if ( !v1263 )
                    break;
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1069);
                  LOWORD(v1069) = v1124 + v1069;
                  BYTE1(v1046) = v1070;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1071 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = v1049[5];
                    v1071 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1069);
                  v1072 = v1182 + v1069;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1070);
                  v1073 = v1189 + v1070;
                  v1049[5] = v1071;
                  LOBYTE(v1073) = BYTE2(v1146) + v180 + v1073;
                  v1264 = v1263 - 1;
                  if ( !v1264 )
                    break;
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1072);
                  LOWORD(v1072) = v1124 + v1072;
                  BYTE1(v1046) = v1073;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1074 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = v1049[6];
                    v1074 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1072);
                  v1075 = v1182 + v1072;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1073);
                  v1076 = v1189 + v1073;
                  v1049[6] = v1074;
                  LOBYTE(v1076) = BYTE2(v1146) + v180 + v1076;
                  v1265 = v1264 - 1;
                  if ( !v1265 )
                    break;
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1075);
                  LOWORD(v1075) = v1124 + v1075;
                  BYTE1(v1046) = v1076;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1077 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = v1049[7];
                    v1077 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1075);
                  v1078 = v1182 + v1075;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1076);
                  v1079 = v1189 + v1076;
                  v1049[7] = v1077;
                  LOBYTE(v1079) = BYTE2(v1146) + v180 + v1079;
                  v1266 = v1265 - 1;
                  if ( !v1266 )
                    break;
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1078);
                  LOWORD(v1078) = v1124 + v1078;
                  BYTE1(v1046) = v1079;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1080 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = v1049[8];
                    v1080 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1078);
                  v1081 = v1182 + v1078;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1079);
                  v1082 = v1189 + v1079;
                  v1049[8] = v1080;
                  LOBYTE(v1082) = BYTE2(v1146) + v180 + v1082;
                  v1267 = v1266 - 1;
                  if ( !v1267 )
                    break;
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1081);
                  LOWORD(v1081) = v1124 + v1081;
                  BYTE1(v1046) = v1082;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1083 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = v1049[9];
                    v1083 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1081);
                  v1084 = v1182 + v1081;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1082);
                  v1085 = v1189 + v1082;
                  v1049[9] = v1083;
                  LOBYTE(v1085) = BYTE2(v1146) + v180 + v1085;
                  v1268 = v1267 - 1;
                  if ( !v1268 )
                    break;
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1084);
                  LOWORD(v1084) = v1124 + v1084;
                  BYTE1(v1046) = v1085;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1086 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = v1049[10];
                    v1086 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1084);
                  v1087 = v1182 + v1084;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1085);
                  v1088 = v1189 + v1085;
                  v1049[10] = v1086;
                  LOBYTE(v1088) = BYTE2(v1146) + v180 + v1088;
                  v1269 = v1268 - 1;
                  if ( !v1269 )
                    break;
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1087);
                  LOWORD(v1087) = v1124 + v1087;
                  BYTE1(v1046) = v1088;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1089 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = v1049[11];
                    v1089 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1087);
                  v1090 = v1182 + v1087;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1088);
                  v1091 = v1189 + v1088;
                  v1049[11] = v1089;
                  LOBYTE(v1091) = BYTE2(v1146) + v180 + v1091;
                  v1270 = v1269 - 1;
                  if ( !v1270 )
                    break;
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1090);
                  LOWORD(v1090) = v1124 + v1090;
                  BYTE1(v1046) = v1091;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1092 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = v1049[12];
                    v1092 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1090);
                  v1093 = v1182 + v1090;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1091);
                  v1094 = v1189 + v1091;
                  v1049[12] = v1092;
                  LOBYTE(v1094) = BYTE2(v1146) + v180 + v1094;
                  v1271 = v1270 - 1;
                  if ( !v1271 )
                    break;
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1093);
                  LOWORD(v1093) = v1124 + v1093;
                  BYTE1(v1046) = v1094;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1095 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = v1049[13];
                    v1095 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1093);
                  v1096 = v1182 + v1093;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1094);
                  v1097 = v1189 + v1094;
                  v1049[13] = v1095;
                  LOBYTE(v1097) = BYTE2(v1146) + v180 + v1097;
                  v1272 = v1271 - 1;
                  if ( !v1272 )
                    break;
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1096);
                  LOWORD(v1096) = v1124 + v1096;
                  BYTE1(v1046) = v1097;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1098 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = v1049[14];
                    v1098 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1096);
                  v1099 = v1182 + v1096;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1097);
                  v1100 = v1189 + v1097;
                  v1049[14] = v1098;
                  LOBYTE(v1100) = BYTE2(v1146) + v180 + v1100;
                  v1273 = v1272 - 1;
                  if ( !v1273 )
                    break;
                  LOBYTE(v1046) = *(_BYTE *)(v1047 + v1055);
                  v180 = __CFADD__((_WORD)v1124, (_WORD)v1099);
                  LOWORD(v1099) = v1124 + v1099;
                  BYTE1(v1046) = v1100;
                  LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
                  if ( (unsigned __int8)v1046 >= 0xCu )
                  {
                    v1101 = byte_F6EE0[v1046];
                  }
                  else
                  {
                    LOBYTE(v1046) = byte_F6EE0[v1046];
                    BYTE1(v1046) = v1049[15];
                    v1101 = byte_FAEE0[v1046];
                  }
                  v180 = __CFADD__(v1182, v1099);
                  v1053 = v1182 + v1099;
                  BYTE1(v1047) += BYTE2(v1135) + v180;
                  v180 = __CFADD__(v1189, v1100);
                  v1054 = v1189 + v1100;
                  v1049[15] = v1101;
                  LOBYTE(v1054) = BYTE2(v1146) + v180 + v1054;
                  v1258 = v1273 - 1;
                  if ( !v1258 )
                    break;
                  v1049 += 16;
                }
                v1045 = v1291;
              }
LABEL_1361:
              v1045 += 10;
              if ( !--v1123 )
                return;
            }
            if ( v1048 > dword_DE564 )
              v1048 = dword_DE564;
            v18 = __OFSUB__((_WORD)v1048, (_WORD)v1046);
            LOWORD(v1048) = v1048 - v1046;
            if ( (unsigned __int8)(((v1048 & 0x8000u) != 0) ^ v18) | ((_WORD)v1048 == 0) )
              goto LABEL_1361;
            v1049 += v1046;
            v1053 = __ROL4__(*((_DWORD *)v1045 + 3), 16);
            BYTE1(v1047) = v1053;
            LOWORD(v1053) = v1045[4];
            LOBYTE(v1047) = *((_BYTE *)v1045 + 10);
            v1258 = v1048;
            v1054 = __ROL4__(*((_DWORD *)v1045 + 4), 16);
            goto LABEL_1294;
          }
          v1114 += v1191;
          v74 += v1104 * v1161;
          v75 += v1161 * v1108;
          v76 += v1161 * v1127;
          v77 += v1161 * v1138;
          v78 += v1161 * v1149;
          if ( v1301 )
          {
            v1123 = dword_DE568;
            if ( v1297 )
            {
              v1114 = dword_DE568;
            }
            else
            {
              v1297 = dword_DE568 <= v1114;
              v1120 = dword_DE568 - v1114;
            }
          }
        }
        else if ( v1301 )
        {
          v82 = dword_DE568 - v1191;
          v1123 = dword_DE568 - v1191;
          if ( v1297 )
          {
            v1114 = dword_DE568 - v1191;
          }
          else
          {
            v18 = __OFSUB__(v82, v1114);
            v83 = v82 - v1114;
            v1297 = (v83 < 0) ^ v18 | (v83 == 0);
            v1120 = v83;
          }
        }
        v81 = (int *)&unk_DE56C;
        do
        {
          *v81 = v74;
          v74 += v1104;
          v81[1] = v75;
          v75 += v1108;
          v81[2] = v76;
          v76 += v1127;
          v81[3] = v77;
          v77 += v1138;
          v81[4] = v78;
          v78 += v1149;
          v81 += 5;
          --v1114;
        }
        while ( v1114 );
        v80 = v1122;
        goto LABEL_156;
    }
  }
}
// B8845: using guessed type int dword_B8845[];
// DE554: using guessed type int dword_DE554;
// DE55C: using guessed type int dword_DE55C;
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;
// E126C: using guessed type char byte_E126C;
// E126D: using guessed type char byte_E126D;

//----- (000BCD45) --------------------------------------------------------
void __cdecl __spoils<> sub_BCD45(int a1, int a2, int a3, int a4, int a5)
{
  if ( a3 )
    dword_DE560 = a3;
  if ( a1 )
  {
    dword_DE558 = a1;
    dword_DE554 = a1 - dword_DE560;
  }
  if ( a2 )
    dword_DE55C = a2;
  if ( a5 )
    dword_DE568 = a5;
  if ( a4 )
    dword_DE564 = a4;
}
// DE554: using guessed type int dword_DE554;
// DE558: using guessed type int dword_DE558;
// DE55C: using guessed type int dword_DE55C;
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;

//----- (000BD1B6) --------------------------------------------------------
void __cdecl __spoils<ecx> sub_BD1B6(int a1)
{
  int v1; // ecx
  int v2; // eax
  _BYTE *v3; // edx
  _BYTE *v4; // ecx
  int v5; // ST04_4
  _BYTE *v6; // ST08_4
  _BYTE *v7; // ST0C_4
  int v8; // eax
  _BYTE *v9; // edx
  _BYTE *v10; // ecx
  int v11; // ST04_4
  _BYTE *v12; // ST08_4
  _BYTE *v13; // ST0C_4
  int v14; // eax
  _BYTE *v15; // edx
  _BYTE *v16; // ecx
  int v17; // ST04_4
  _BYTE *v18; // ST08_4
  _BYTE *v19; // ST0C_4
  int v20; // eax
  _BYTE *v21; // edx
  _BYTE *v22; // ecx
  int v23; // ST04_4
  _BYTE *v24; // ST08_4
  _BYTE *v25; // ST0C_4
  int v26; // eax
  _BYTE *v27; // edx
  _BYTE *v28; // ecx
  int v29; // ST04_4
  _BYTE *v30; // ST08_4
  _BYTE *v31; // ST0C_4
  int v32; // eax
  _BYTE *v33; // edx
  _BYTE *v34; // ecx
  int v35; // ST04_4
  _BYTE *v36; // ST08_4
  _BYTE *v37; // ST0C_4
  int v38; // eax
  _BYTE *v39; // edx
  _BYTE *v40; // ecx
  int v41; // ST04_4
  _BYTE *v42; // ST08_4
  _BYTE *v43; // ST0C_4
  int v44; // eax
  _BYTE *v45; // edx
  _BYTE *v46; // ecx
  int v47; // ST04_4
  _BYTE *v48; // ST08_4
  _BYTE *v49; // ST0C_4
  int v50; // eax
  _BYTE *v51; // edx
  _BYTE *v52; // ecx
  int v53; // ST04_4
  _BYTE *v54; // ST08_4
  _BYTE *v55; // ST0C_4
  int v56; // [esp-Ch] [ebp-18h]
  int v57; // [esp+8h] [ebp-4h]
  int savedregs; // [esp+Ch] [ebp+0h]

  v56 = v1;
  sub_9951B(0);
  v57 = 4096;
  v2 = sub_BD320(0, (_BYTE *)dword_180628, (_BYTE *)dword_E9C3C, 0, (int)&savedregs, a1);
  v7 = v4;
  v6 = v3;
  v5 = v2;
  sub_9951B(1);
  v57 = 4096;
  v8 = sub_BD320(v5, v6, v7, 0, (int)&savedregs, a1);
  v13 = v10;
  v12 = v9;
  v11 = v8;
  sub_9951B(2);
  v57 = 4096;
  v14 = sub_BD320(v11, v12, v13, 0, (int)&savedregs, a1);
  v19 = v16;
  v18 = v15;
  v17 = v14;
  sub_9951B(3);
  v57 = 4096;
  v20 = sub_BD320(v17, v18, v19, 0, (int)&savedregs, a1);
  v25 = v22;
  v24 = v21;
  v23 = v20;
  sub_9951B(4);
  v57 = 4096;
  v26 = sub_BD320(v23, v24, v25, 0, (int)&savedregs, a1);
  v31 = v28;
  v30 = v27;
  v29 = v26;
  sub_9951B(5);
  v57 = 4096;
  v32 = sub_BD320(v29, v30, v31, 0, (int)&savedregs, a1);
  v37 = v34;
  v36 = v33;
  v35 = v32;
  sub_9951B(6);
  v57 = 4096;
  v38 = sub_BD320(v35, v36, v37, 0, (int)&savedregs, a1);
  v43 = v40;
  v42 = v39;
  v41 = v38;
  sub_9951B(7);
  v57 = 4096;
  v44 = sub_BD320(v41, v42, v43, 0, (int)&savedregs, a1);
  v49 = v46;
  v48 = v45;
  v47 = v44;
  sub_9951B(8);
  v57 = 4096;
  v50 = sub_BD320(v47, v48, v49, 0, (int)&savedregs, a1);
  v55 = v52;
  v54 = v51;
  v53 = v50;
  sub_9951B(9);
  v57 = 1536;
  sub_BD320(v53, v54, v55, 0, (int)&savedregs, a1);
}
// E9C3C: using guessed type int dword_E9C3C;
// 180628: using guessed type int dword_180628;

//----- (000BD2CB) --------------------------------------------------------
void __cdecl __spoils<ecx> sub_BD2CB(int a1)
{
  int v1; // ecx
  int v2; // eax
  _BYTE *v3; // edx
  _BYTE *v4; // ecx
  int v5; // ST04_4
  _BYTE *v6; // ST08_4
  _BYTE *v7; // ST0C_4
  int v8; // [esp-Ch] [ebp-18h]
  int v9; // [esp+8h] [ebp-4h]
  int savedregs; // [esp+Ch] [ebp+0h]

  v8 = v1;
  sub_9951B(0);
  v9 = 4096;
  v2 = sub_BD320(0, (_BYTE *)dword_180628, (_BYTE *)dword_E9C3C, 0, (int)&savedregs, a1);
  v7 = v4;
  v6 = v3;
  v5 = v2;
  sub_9951B(1);
  v9 = 3904;
  sub_BD320(v5, v6, v7, 0, (int)&savedregs, a1);
}
// E9C3C: using guessed type int dword_E9C3C;
// 180628: using guessed type int dword_180628;

//----- (000BD320) --------------------------------------------------------
int __usercall sub_BD320@<eax>(int result@<eax>, _BYTE *a2@<edx>, _BYTE *a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<esi>)
{
  int *v6; // edi
  int v7; // eax

  v6 = (int *)&loc_A0000;
  do
  {
    LOBYTE(a4) = a3[1];
    LOWORD(result) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[1];
    LOWORD(result) = *(_WORD *)(a6 + 2 * a4 + 512) + result;
    v7 = result << 16;
    LOBYTE(a4) = *a3;
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = *a2;
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    *v6 = v7;
    LOBYTE(a4) = a3[3];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[3];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    v7 <<= 16;
    LOBYTE(a4) = a3[2];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[2];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    v6[1] = v7;
    LOBYTE(a4) = a3[5];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[5];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    v7 <<= 16;
    LOBYTE(a4) = a3[4];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[4];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    v6[2] = v7;
    LOBYTE(a4) = a3[7];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[7];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    result = v7 << 16;
    LOBYTE(a4) = a3[6];
    LOWORD(result) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[6];
    LOWORD(result) = *(_WORD *)(a6 + 2 * a4 + 512) + result;
    v6[3] = result;
    a3 += 8;
    a2 += 8;
    v6 += 4;
  }
  while ( (*(_DWORD *)(a5 - 4))-- != 1 );
  return result;
}

//----- (000BD3DD) --------------------------------------------------------
void sub_BD3DD()
{
  char *v0; // edi
  char *v1; // esi
  signed int v2; // edx
  char *v3; // esi
  char *v4; // esi
  char *v5; // edi
  signed int v6; // edx
  char *v7; // esi
  char *v8; // esi
  char *v9; // edi
  signed int v10; // edx
  char *v11; // edi
  signed int v12; // edx
  char *v13; // edi
  signed int v14; // edx

  if ( !byte_E3766 )
    sub_8CACD();
  sub_9951B(0);
  v0 = (char *)&loc_A0000 + 51200;
  v1 = (char *)dword_180628;
  v2 = 11;
  do
  {
    qmemcpy(v0, v1, 0x280u);
    v1 += 1280;
    v0 += 1280;
    --v2;
  }
  while ( v2 );
  qmemcpy(v0, v1, 0x100u);
  v3 = v1 + 256;
  sub_9951B(1);
  qmemcpy(&loc_A0000, v3, 0x180u);
  v4 = v3 + 1024;
  v5 = (char *)&loc_A0000 + 1024;
  v6 = 50;
  do
  {
    qmemcpy(v5, v4, 0x280u);
    v4 += 1280;
    v5 += 1280;
    --v6;
  }
  while ( v6 );
  qmemcpy(v5, v4, 0x200u);
  v7 = v4 + 512;
  sub_9951B(2);
  qmemcpy(&loc_A0000, v7, 0x80u);
  v8 = v7 + 768;
  v9 = (char *)&loc_A0000 + 768;
  v10 = 51;
  do
  {
    qmemcpy(v9, v8, 0x280u);
    v8 += 1280;
    v9 += 1280;
    --v10;
  }
  while ( v10 );
  sub_9951B(3);
  v11 = (char *)&loc_A0000 + 512;
  v12 = 51;
  do
  {
    qmemcpy(v11, v8, 0x280u);
    v8 += 1280;
    v11 += 1280;
    --v12;
  }
  while ( v12 );
  sub_9951B(4);
  v13 = (char *)&loc_A0000 + 256;
  v14 = 34;
  do
  {
    qmemcpy(v13, v8, 0x280u);
    v8 += 1280;
    v13 += 1280;
    --v14;
  }
  while ( v14 );
  if ( !byte_E3766 )
    sub_8CB1F();
}
// E3766: using guessed type char byte_E3766;
// 180628: using guessed type int dword_180628;

//----- (000BD524) --------------------------------------------------------
void __cdecl sub_BD524(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  JUMPOUT(&loc_BD550);
}

//----- (000BD542) --------------------------------------------------------
void __cdecl __spoils<ecx> sub_BD542(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, char a5)
{
  signed __int16 v5; // bx
  unsigned __int16 v6; // cx
  unsigned __int16 v7; // cx
  unsigned __int16 v8; // ax
  unsigned __int16 v9; // ax
  _BYTE *v10; // edi
  int v11; // esi
  unsigned __int16 v12; // ax
  unsigned __int16 v13; // cx
  unsigned __int16 v14; // si
  __int16 v15; // dx
  __int16 v16; // bx
  __int16 v17; // cx
  int v18; // edi
  unsigned int v19; // ecx
  unsigned __int16 v20; // ax
  int v21; // eax
  int v22; // ecx
  __int16 v23; // cx
  _BYTE *v24; // edi
  int v25; // [esp+0h] [ebp-Ch]
  signed int v26; // [esp+4h] [ebp-8h]
  int v27; // [esp+8h] [ebp-4h]

  v27 = dword_180628 + dword_18063C + dword_18062C * dword_180650;
  v5 = a2;
  if ( (a2 & 0x8000u) == 0 )
  {
    v7 = a4;
    if ( (a4 & 0x8000u) == 0 )
    {
      if ( a2 == a4 )
      {
        if ( (signed __int16)a2 >= (signed __int16)dword_180644 )
          return;
        v18 = a1;
        v19 = a3;
        if ( a3 < a1 )
        {
          LOWORD(v19) = a1;
          LOWORD(v18) = a3;
        }
        v20 = dword_180648 - 1;
        if ( (v18 & 0x8000u) == 0 )
        {
          if ( (signed __int16)v18 > (signed __int16)v20 )
            return;
          if ( (unsigned __int16)v19 > v20 )
            LOWORD(v19) = dword_180648 - 1;
        }
        else
        {
          if ( (signed __int16)v19 <= 0 )
            return;
          LOWORD(v18) = 0;
          if ( (unsigned __int16)v19 > v20 )
            LOWORD(v19) = dword_180648 - 1;
        }
        LOWORD(v19) = v19 - v18;
        goto LABEL_54;
      }
      if ( (signed __int16)(a2 - a4) < 0 )
      {
        if ( (signed __int16)a2 >= (signed __int16)dword_180644 )
          return;
        if ( (signed __int16)a4 >= (signed __int16)dword_180644 )
          goto LABEL_5;
      }
      else
      {
        if ( (signed __int16)a4 >= (signed __int16)dword_180644 )
          return;
        a4 = a2;
        a2 = v7;
        v9 = a1;
        a1 = a3;
        a3 = v9;
        if ( v5 >= (signed __int16)dword_180644 )
          goto LABEL_5;
      }
      goto LABEL_15;
    }
    a4 = a2;
    v5 = v7;
    v6 = a2;
    v8 = a1;
    a1 = a3;
    a3 = v8;
  }
  else
  {
    v6 = a4;
  }
  if ( (v6 & 0x8000u) != 0 )
    return;
  a1 += (signed __int16)-v5 * (signed __int16)(a3 - a1) / (signed __int16)(v6 - v5);
  a2 = 0;
  if ( (signed __int16)(a4 - dword_180644) >= 0 )
  {
LABEL_5:
    a3 = a1
       + (unsigned int)((signed __int16)(dword_180644 - a2) * (signed __int16)(a3 - a1) / (signed __int16)(a4 - a2));
    a4 = dword_180644 - 1;
  }
LABEL_15:
  if ( (a1 & 0x8000u) == 0 )
  {
    if ( (signed __int16)(a1 - dword_180648) < 0 )
    {
      if ( (a3 & 0x8000u) == 0 )
      {
        if ( (signed __int16)(a3 - dword_180648) < 0 )
        {
          v26 = 1;
          if ( a1 == a3 )
          {
            v21 = a2;
            v22 = a4;
            if ( a4 >= a2 )
            {
              v23 = a4 - a2;
            }
            else
            {
              LOWORD(v21) = a4;
              v23 = a2 - a4;
            }
            v24 = (_BYTE *)(v27 + dword_18062C * v21 + a1);
            LOWORD(v22) = v23 + 1;
            do
            {
              *v24 = a5;
              v24 += dword_18062C;
              --v22;
            }
            while ( v22 );
            return;
          }
          if ( (signed __int16)(a1 - a3) >= 0 )
            v26 = -1;
        }
        else
        {
          v26 = 1;
          a4 = a2
             + (unsigned int)((signed __int16)(dword_180648 - a1) * (signed __int16)(a4 - a2) / (signed __int16)(a3 - a1));
          a3 = dword_180648 - 1;
        }
      }
      else
      {
        v26 = -1;
        a4 = a2 + (unsigned int)((signed __int16)a1 * (signed __int16)(a4 - a2) / (signed __int16)(a1 - a3));
        a3 = 0;
      }
    }
    else
    {
      if ( (signed __int16)a3 >= (signed __int16)dword_180648 )
        return;
      v26 = -1;
      a2 += (signed __int16)(a1 - dword_180648) * (signed __int16)(a4 - a2) / (signed __int16)(a1 - a3);
      a1 = dword_180648 - 1;
      if ( (a3 & 0x8000u) != 0 )
      {
        a4 -= (signed __int16)-a3 * (signed __int16)(a4 - a2) / (signed __int16)(a1 - a3);
        a3 = 0;
      }
    }
  }
  else
  {
    if ( (a3 & 0x8000u) != 0 )
      return;
    v26 = 1;
    a2 += (signed __int16)-a1 * (signed __int16)(a4 - a2) / (signed __int16)(a3 - a1);
    a1 = 0;
    if ( (signed __int16)(a3 - dword_180648) >= 0 )
    {
      a4 = a2 + (unsigned int)((signed __int16)dword_180648 * (signed __int16)(a4 - a2) / (signed __int16)a3);
      a3 = dword_180648 - 1;
    }
  }
  v10 = (_BYTE *)(v27 + dword_18062C * a2 + a1);
  v11 = v26;
  v12 = v26 * (a3 - a1);
  v13 = a4 - a2;
  if ( a4 == a2 )
  {
    v18 = a1;
    v19 = a3;
    if ( a3 >= a1 )
    {
      LOWORD(v19) = a3 - a1;
    }
    else
    {
      LOWORD(v18) = a3;
      LOWORD(v19) = a1 - a3;
    }
LABEL_54:
    LOWORD(v19) = v19 + 1;
    memset((void *)(v27 + dword_18062C * a2 + v18), a5, v19);
    return;
  }
  if ( v13 <= v12 )
  {
    v25 = dword_18062C;
  }
  else
  {
    v12 = a4 - a2;
    v13 = v26 * (a3 - a1);
    v26 = dword_18062C;
    v25 = v11;
  }
  v14 = v12;
  v15 = 2 * v13;
  v16 = 2 * v13 - v12;
  v17 = 2 * (v13 - v12);
  *v10 = a5;
  do
  {
    while ( 1 )
    {
      v10 += v26;
      if ( v16 >= 0 )
        break;
      v16 += v15;
      *v10 = a5;
      if ( !--v14 )
        return;
    }
    v10 += v25;
    v16 += v17;
    *v10 = a5;
    --v14;
  }
  while ( v14 );
}
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 18063C: using guessed type int dword_18063C;
// 180644: using guessed type int dword_180644;
// 180648: using guessed type int dword_180648;
// 180650: using guessed type int dword_180650;

//----- (000BF123) --------------------------------------------------------
int sub_BF123()
{
  return dword_E4C94;
}
// E4C94: using guessed type int dword_E4C94;

//----- (000C0113) --------------------------------------------------------
#error "C0113: only 32bit functions can be decompiled (funcsize=0)"

//----- (000C0117) --------------------------------------------------------
#error "C0117: only 32bit functions can be decompiled (funcsize=0)"

#error "There were 12 decompilation failure(s) on 2390 function(s)"
