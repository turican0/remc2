\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename SDL_mixer_ext.info
@settitle SDL Mixer X
@c @setchapternewpage odd
@setcontentsaftertitlepage
@syncodeindex fn cp
@syncodeindex vr cp
@syncodeindex tp cp
@c %**end of header
@exampleindent 0
@ifinfo
This is an unofficial document for the SDL_mixer library API
and official for SDL Mixer X.

Copyright @copyright{} 2009 Jonathan Atkins (original documentation)
Copyright @copyright{} 2017 Vitaliy Novichkov (SDL Mixer X specific updates)

Permission is granted to distribute freely, or in a distribution of any kind.
All distributions of this file must be in an unaltered state, except for corrections.

The latest copy of original document can be found at @url{http://www.jonatkins.org/SDL_mixer}
@end ifinfo

@titlepage
@sp 10
@title SDL Mixer X (a fork of SDL_mixer)

@subtitle @today{}

@author Jonathan Atkins
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2009 Jonathan Atkins (original documentation)
Copyright @copyright{} 2017 Vitaliy Novichkov (SDL Mixer X specific updates)

Permission is granted to distribute freely, or in a distribution of any kind.
All distributions of this file must be in an unaltered state, except for corrections.

The latest copy of this document can be found at @url{http://www.jonatkins.org/SDL_mixer}
@end titlepage

@c @ifinfo
@c =============================================================================
@node    Top
@top SDL Mixer X

@menu
* Overview::         The README from the SDL_mixer  SDL Mixer X distribution

* SDL Mixer X::      About SDL Mixer X fork

* Getting Started::  Using SDL_mixer

* Conflicts::        Conflicts with SDL Audio functions

* Functions::        Functions supported by the SDL_mixer API
* Types::            Types used with the SDL_mixer API
* Defines::          Defined values/macros in the SDL_mixer API

* Glossary::         Terms used in this document

* Index::            Index of selected words
@end menu
@c @end ifinfo

@c =============================================================================
@page
@node    Overview
@chapter Overview

@center @b{A Little Bit About Me (author of original manual)}

I am currently, as I write this document, a programmer for Raytheon.
There I do all sorts of communications, network, GUI, and other general
programming tasks in C/C++ on the Solaris and sometimes Linux Operating Systems.
I have been programming sound code in my free time for only a little while now.
Sound is an integral part to any game.  The human senses are mostly starved
during video game play.  there's only some tactile feedback on some controlers,
and of course the eyes are in use but only for about 30% of their viewing area.
So to add more we do need sound to help the game player feel more in the action,
and to set certain moods as the game progresses.  Sound ends up accounting
for perhaps 50% or more of a gamers experience.  Music and sound effects
are all integral parts of the gaming experience.  While this document
doesn't explain how to get music and samples to use, it will explain how
to use them with SDL_mixer.

@noindent
Feel free to contact me: @email{JonathanCAtkins@@gmail.com}@*

@noindent
I am also usually on IRC at irc.freenode.net in the #SDL channel as LIM

@page
@cindex README

@noindent
This is the README in the SDL_mixer source archive.

@cartouche
SDL Mixer X

The latest version of this library is available from:@*
@uref{https://github.com/WohlSoft/SDL-Mixer-X,SDL Mixer X GitHub repository}

Due to popular demand, here is a simple multi-channel audio mixer.
It supports 8 or more channels of 16 bit stereo audio, plus a single channel
of music, mixed by the popular MikMod MOD, Timidity MIDI and SMPEG MP3
libraries.

See the header file SDL_mixer_ext.h and the examples playwave.c and playmus.c
for documentation on this mixer library.

The mixer can currently load Microsoft WAVE files and Creative Labs VOC
files as audio samples, and can load MIDI files via Timidity and the
following music formats via MikMod:  .MOD .S3M .IT .XM. It can load
Ogg Vorbis streams as music if built with the Ogg Vorbis libraries,
and finally it can load MP3 music using the SMPEG library.

The process of mixing MIDI files to wave output is very CPU intensive,
so if playing regular WAVE files sound great, but playing MIDI files
sound choppy, try using 8-bit audio, mono audio, or lower frequencies.

To play MIDI files, you'll need to get a complete set of GUS patches
from:
@uref{http://www.libsdl.org/projects/mixer/timidity/timidity.tar.gz,Timidity GUS Patches}
and unpack them in /usr/local/lib under UNIX, and C:\ under Win32.

The SDL_mixer 1.x library is available under the GNU Library General Public License,
see the file "COPYING" for details.

The SDL_mixer 2.x and SDL Mixer X fork library is available under
the ZLib License, see the file "COPYING" for details.
@end cartouche

@c =============================================================================
@page
@node    SDL Mixer X
@chapter SDL Mixer X

It's an extended fork made by Vitaly Novichkov "Wohlstand" in 13 January 2015.
SDL_mixer is a quick and stable high-quality audio library, however, it has own
bunch of deffects such as broken resampling, incorrect playback of WAV files,
inability to choose MIDI backend in runtime, inability to customize Timidty
patches path, No support for cross-fade and parallel streams playing (has only
one musical stream. Using of very long Chunks is ineffectively), etc. The goal
of this fork is resolving those issues, providing more extended functionality
than was originally, and providing support for more supported audio formats.

In this documentation, new-added functions, definitions, and enums in this fork
will be marked by @b{[Mixer X]} label. That means those functions are existing only
in SDL Mixer X fork and wasn't existed in original SDL_mixer library.

This fork is based on SDL_mixer 2.x unlike original documentation which is
created for SDL_mixer 1.2. Some functions would be marked by @b{[Mixer X]} label
which means those functions are not available in SDL_mixer 1.x, but available in
SDL_mixer 2.0 and SDL Mixer X fork.

@b{IMPORTANT}: The licenses for libADLMIDI, libOPNMIDI, and libGME  are LGPL2+
and GPL2+. Using of those modules makes this library licensed under LGPL2+ and
you must use it dynamically, or your application must also be GPL!

@b{IMPORTANT}: The license for libMAD is GPL which means that in order to use
it your application must also be GPL!

@c =============================================================================
@page
@node Getting Started
@chapter Getting Started

This assumes you have gotten SDL Mixer X and installed it on your system.
SDL_mixer has an INSTALL document in the source distribution to help you
get it compiled and installed.

@noindent
Generally, installation consists of:

@cartouche
@example
mkdir build
cd build
cmake ..
make
@end example
@end cartouche

@noindent
SDL Mixer X supports playing music and sound samples from the following formats:@*
- WAVE/RIFF (.wav)@*
- AIFF (.aiff)@*
- VOC (.voc)@*
- MOD (.mod .xm .s3m .669 .it .med and more) requiring libmikmod or libmodplug @b{[Mixer 2.0]} built in package@*
- MIDI (.mid) using timidity, FluidSynth @b{[Mixer 2.0]}, ADLMIDI @b{[Mixer X]}, OPNMIDI @b{[Mixer X]} or native midi hardware@*
- OggVorbis (.ogg) requiring ogg/vorbis libraries built in package@*
- MP3 (.mp3) requiring MAD or SMPEG libraries built in package@*
- FLAC (.flac) requiring the FLAC library built in package@*
- GME (.spc .nsf .hes .vgm and more) emulated chiptunes from various console games @b{[Mixer X]} @*
- also any command-line player, which is not mixed by SDL Mixer X...@*

@noindent
You may also want to look at some demonstration code which may be downloaded from:@*
@url{http://www.jonatkins.org/SDL_mixer/}

@menu
* Includes::    The include files to use for SDL_mixer
* Compiling::   Using the SDL_mixer library and header file.
@end menu

@c -----------------------------------------------------------------------------
@page
@node Includes
@section Includes

To use SDL_mixer functions in a C/C++ source code file, you must use the
SDL_mixer_ext.h include file:

@cartouche
@code{  #include "SDL_mixer_ext.h"}
@end cartouche

@c -----------------------------------------------------------------------------
@page
@node Compiling
@section Compiling
@cindex sdl-config

To link with SDL Mixer X you should use sdl-config to get the required SDL
compilation options.  After that, compiling with SDL Mixer X is quite easy.@*
@b{Note}: Some systems may not have the SDL_mixer library and include file in the same place as the SDL library and includes are located, in that case you will need to add more -I and -L paths to these command lines.

@cartouche
Simple Example for compiling an object file:

@code{  cc -c `sdl-config --cflags` mysource.c}

Simple Example for compiling an object file:

@code{  cc -o myprogram mysource.o `sdl-config --libs` -lSDL_mixer_ext -lvorbis -lFLAC -logg -lmad -lADLMIDI -lOPNMIDI -ltimidity -lmodplug -lgme -lzlib}
@end cartouche

Now @command{myprogram} is ready to run.

@c -----------------------------------------------------------------------------
@page
@c =============================================================================
@node Conflicts
@chapter Conflicts
@findex SDL_OpenAudio
@findex SDL_CloseAudio
@findex SDL_LockAudio
@findex SDL_UnlockAudio
@findex SDL_AudioDriverName
@findex SDL_GetAudioStatus
@findex SDL_PauseAudio

When using SDL_mixer functions you need to avoid the following functions from SDL:

@table @code
@item SDL_OpenAudio
Use @code{Mix_OpenAudio} instead.
@item SDL_CloseAudio
Use @code{Mix_CloseAudio} instead.
@item SDL_PauseAudio
Use @code{Mix_Pause(-1)} and @code{Mix_PauseMusic} instead, to pause.@*
Use @code{Mix_Resume(-1)} and @code{Mix_ResumeMusic} instead, to unpause.
@item SDL_LockAudio
Use @code{Mix_LockAudio} instead.
@item SDL_UnlockAudio
Use @code{Mix_UnlockAudio} instead.
@end table

You may call the following functions freely:

@table @code
@item SDL_AudioDriverName
This will still work as usual.
@item SDL_GetAudioStatus
This will still work, though it will likely return @b{SDL_AUDIO_PLAYING}
even though SDL_mixer is just playing silence.
@end table

It is also a BAD idea to call SDL_mixer and SDL audio functions from a callback.
Callbacks include Effects functions and other SDL_mixer audio hooks.

@c -----------------------------------------------------------------------------
@page
@c =============================================================================
@node Functions
@chapter Functions

These are the functions in the SDL_mixer API.

@menu
* General::   API activation
* Samples::   Loading sounds from files or memory
* Channels::  Sound effect channels
* Groups::    Sound effect channel grouping
* Music::     Music playing
* Effects::   Special effects processing
@end menu

@c -----------------------------------------------------------------------------
@page
@node General
@section General

These functions are useful, as they are the only/best ways to work with SDL_mixer.

@menu
@b{Info}
* Mix_Linked_Version::    Get version number

@b{Activation}
* Mix_Init::                    Initialize SDL_mixer
* Mix_Quit::                    Cleanup SDL_mixer
* Mix_OpenAudio::               Open sound mixer
* Mix_CloseAudio::              Close sound mixer

@b{Errors}
* Mix_SetError::                Set the current error string
* Mix_GetError::                Get the current error string

@b{Settings}
* Mix_QuerySpec::               Get output format
* Mix_Timidity_addToPathList::  Append extra Timidity patches search path. Must be ran before initialization!  @b{[Mixer X]}
@end menu

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_Linked_Version
@subsection Mix_Linked_Version
@findex Mix_Linked_Version
@findex SDL_MIXER_VERSION

@noindent
@code{const SDL_version *@b{Mix_Linked_Version}()}@*
@code{void @b{SDL_MIXER_VERSION}(SDL_version *compile_version)}

@noindent
This works similar to @code{SDL_Linked_Version} and @b{SDL_VERSION}.@*
Using these you can compare the runtime version to the version that you compiled with.

@cartouche
@example
SDL_version compile_version;
const SDL_version *link_version=Mix_Linked_Version();
SDL_MIXER_VERSION(&compile_version);
printf("compiled with SDL_mixer version: %d.%d.%d\n",
        compile_version.major,
        compile_version.minor,
        compile_version.patch);
printf("running with SDL_mixer version: %d.%d.%d\n",
        link_version->major,
        link_version->minor,
        link_version->patch);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_OpenAudio},
@ref{Mix_QuerySpec}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_Init
@subsection Mix_Init
@findex Mix_Init

@noindent
@code{int @b{Mix_Init}(int @var{flags})}

@table @var
@item flags
bitwise OR'd set of sample/music formats to support by loading a library now.  The values you may OR together to pass in are:@*
@b{MIX_INIT_FLAC}@*
@b{MIX_INIT_MOD}@*
@b{MIX_INIT_MP3}@*
@b{MIX_INIT_OGG}
@end table

@noindent
Initialize by loading support as indicated by the @var{flags}, or at least return success if support is already loaded.  You may call this multiple times, which will actually require you to call @code{Mix_Quit} just once to clean up.  You may call this function with a 0 to retrieve whether support was built-in or not loaded yet.@*
@b{Note}: you can call @code{Mix_Init} with the right @b{MIX_INIT_*} flags OR'd together before you program gets busy, to prevent a later hiccup while it loads and unloads the library, and to check that you do have the support that you need before you try and use it.@*
@b{Note}: this function does @i{not} always set the error string, so do not depend on @code{Mix_GetError} being meaningful all the time.

@noindent
@b{Returns}: a bitmask of all the currently initted sample/music loaders.

@cartouche
@example
// load support for the OGG and MOD sample/music formats
int flags=MIX_INIT_OGG|MIX_INIT_MOD;
int initted=Mix_Init(flags);
if(initted&flags != flags) @{
    printf("Mix_Init: Failed to init required ogg and mod support!\n");
    printf("Mix_Init: %s\n", Mix_GetError());
    // handle error
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Quit}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_Quit
@subsection Mix_Quit
@findex Mix_Quit

@noindent
@code{void @b{Mix_Quit}()}

@noindent
This function cleans up all dynamically loaded library handles, freeing memory.  If support is required again it will be initialized again, either by @code{Mix_Init} or loading a sample or some music with dynamic support required.  You may call this function when Mix_Load functions are no longer needed for the @b{MIX_INIT_}* formats.  You should call this function for each time @code{Mix_Init} was called, otherwise it may not free all the dynamic library resources until the program ends.  This is done so that multiple unrelated modules of a program may call @code{Mix_Init} and @code{Mix_Quit} without affecting the others performance and needs.

@cartouche
@example
// indicate that we are ready to unload the dynamically loaded libraries
Mix_Quit();
@end example
@end cartouche


@noindent
@b{NOTE}: Since each call to @code{Mix_Init} may set different flags, there is no way, currently, to request how many times each one was initted.  In other words, the only way to quit for sure is to do a loop like so:@*
@cartouche
@example
// force a quit
while(Mix_Init(0))
    Mix_Quit();
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Init}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_OpenAudio
@subsection Mix_OpenAudio
@findex Mix_OpenAudio

@noindent
@code{int @b{Mix_OpenAudio}(int @var{frequency}, Uint16 @var{format}, int @var{channels}, int @var{chunksize})}

@table @var
@item frequency
Output sampling frequency in samples per second (Hz).@*
you might use @b{MIX_DEFAULT_FREQUENCY}(44100) since that is a good value for most games.
@item format
Output sample format.@*
@item channels
Number of sound channels in output.@*
Set to 2 for stereo, 1 for mono.
This has nothing to do with mixing channels.
@item chunksize
Bytes used per output sample.
@end table

@noindent
Initialize the mixer API.@*
This must be called before using other functions in this library.@*
SDL must be initialized with @b{SDL_INIT_AUDIO} before this call.
@var{frequency} would be 44100 for 44.1KHz, which is CD audio rate.  Most games use 22050, because 44100 requires too much CPU power on older computers.
@var{chunksize} is the size of each mixed sample.  The smaller this is the more your hooks will be called.  If make this too small on a slow system, sound may skip.  If made to large, sound effects will lag behind the action more.  You want a happy medium for your target computer.  You also may make this 4096, or larger, if you are just playing music.
@b{MIX_CHANNELS}(8) mixing channels will be allocated by default.
You may call this function multiple times, however you will have to call @code{Mix_CloseAudio} just as many times for the device to actually close.  The format will not changed on subsequent calls until fully closed.  So you will have to close all the way before trying to open with different format parameters.

@noindent
@var{format} is based on SDL audio support, see SDL_audio.h.
Here are the values listed there:@*
@table @b
@item AUDIO_U8
Unsigned 8-bit samples@*
@item AUDIO_S8
Signed 8-bit samples@*
@item AUDIO_U16LSB
Unsigned 16-bit samples, in little-endian byte order@*
@item AUDIO_S16LSB
Signed 16-bit samples, in little-endian byte order@*
@item AUDIO_U16MSB
Unsigned 16-bit samples, in big-endian byte order@*
@item AUDIO_S16MSB
Signed 16-bit samples, in big-endian byte order@*
@item AUDIO_U16
same as @b{AUDIO_U16LSB} (for backwards compatability probably)@*
@item AUDIO_S16
same as @b{AUDIO_S16LSB} (for backwards compatability probably)@*
@item AUDIO_U16SYS
Unsigned 16-bit samples, in system byte order@*
@item AUDIO_S16SYS
Signed 16-bit samples, in system byte order@*
@end table
@*
@b{MIX_DEFAULT_FORMAT} is the same as @b{AUDIO_S16SYS}.

@noindent
@b{Returns}: 0 on success, -1 on errors

@cartouche
@example
// start SDL with audio support
if(SDL_Init(SDL_INIT_AUDIO)==-1) @{
    printf("SDL_Init: %s\n", SDL_GetError());
    exit(1);
@}
// open 44.1KHz, signed 16bit, system byte order,
//      stereo audio, using 1024 byte chunks
if(Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 1024)==-1) @{
    printf("Mix_OpenAudio: %s\n", Mix_GetError());
    exit(2);
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_CloseAudio},
@ref{Mix_QuerySpec},
@ref{Mix_AllocateChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_CloseAudio
@subsection Mix_CloseAudio
@findex Mix_CloseAudio

@noindent
@code{void @b{Mix_CloseAudio}()}

@noindent
Shutdown and cleanup the mixer API.@*
After calling this all audio is stopped, the device is closed,
and the SDL_mixer functions should not be used.
You may, of course, use Mix_OpenAudio to start the functionality again.@*
@b{Note}: This function doesn't do anything until you have called it the same
number of times that you called Mix_OpenAudio.
You may use @code{Mix_QuerySpec} to find out how many times @code{Mix_CloseAudio}
needs to be called before the device is actually closed.

@cartouche
@example
Mix_CloseAudio();
// you could SDL_Quit(); here...or not.
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_OpenAudio},
@ref{Mix_QuerySpec}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_SetError
@subsection Mix_SetError
@findex Mix_SetError

@noindent
@code{void @b{Mix_SetError}(const char *@var{fmt}, ...)}

@noindent
This is the same as SDL_SetError, which sets the error string which may be fetched with Mix_GetError (or SDL_GetError).
This functions acts like printf, except that it is limited to @b{SDL_ERRBUFIZE}(1024) chars in length.  It only accepts the following format types: @code{%s, %d, %f, %p}.  No variations are supported, like @code{%.2f} would not work. For any more specifics read the SDL docs.

@cartouche
@example
int mymixfunc(int i) @{
    Mix_SetError("mymixfunc is not implemented! %d was passed in.",i);
    return(-1);
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GetError}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetError
@subsection Mix_GetError
@findex Mix_GetError

@noindent
@code{char *@b{Mix_GetError}()}

@noindent
This is the same as SDL_GetError, which returns the last error set as a string
which you may use to tell the user what happened when an error status has been returned
from an SDL_mixer function call.

@noindent
@b{Returns}: a char pointer (string) containing a humam readble version or the reason for the last error that occured.

@cartouche
@example
printf("Oh My Goodness, an error : %s", Mix_GetError());
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_SetError}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_QuerySpec
@subsection Mix_QuerySpec
@findex Mix_QuerySpec

@noindent
@code{int @b{Mix_QuerySpec}(int *@var{frequency}, Uint16 *@var{format}, int *@var{channels})}

@table @var
@item frequency
A pointer to an int where the frequency actually used by the opened audio device will be stored.
@item format
A pointer to a Uint16 where the output format actually being used by the audio device will be stored.
@item channels
A pointer to an int where the number of audio channels will be stored.@*
2 will mean stereo, 1 will mean mono.
@end table

@noindent
Get the actual audio format in use by the opened audio device.  This may or may not match the parameters you passed to @b{Mix_OpenAudio}.

@noindent
@b{Returns}: 0 on error. If the device was open the number of times it was opened will be returned.  The values of the arguments variables are not set on an error.

@cartouche
@example
// get and print the audio format in use
int numtimesopened, frequency, channels;
Uint16 format;
numtimesopened=Mix_QuerySpec(&frequency, &format, &channels);
if(!numtimesopened) @{
    printf("Mix_QuerySpec: %s\n",Mix_GetError());
@}
else @{
    char *format_str="Unknown";
    switch(format) @{
        case AUDIO_U8: format_str="U8"; break;
        case AUDIO_S8: format_str="S8"; break;
        case AUDIO_U16LSB: format_str="U16LSB"; break;
        case AUDIO_S16LSB: format_str="S16LSB"; break;
        case AUDIO_U16MSB: format_str="U16MSB"; break;
        case AUDIO_S16MSB: format_str="S16MSB"; break;
    @}
    printf("opened=%d times  frequency=%dHz  format=%s  channels=%d",
            numtimesopened, frequency, format_str, channels);
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_OpenAudio}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_Timidity_addToPathList
@subsection Mix_Timidity_addToPathList
@findex Mix_Timidity_addToPathList

@noindent
@code{void @b{Mix_Timidity_addToPathList}(const char *@var{path})}

@table @var
@item path
An absolute or relative path to timidity config is presented
@end table

@noindent
Allows you to set a custom path for Timidify patches if you don't want limit
to use standard paths only

@cartouche
@example
sprintf(mypath "%s/timidity/", getMyDataPath());
Mix_Timidity_addToPathList(mypath);
@end example
@end cartouche

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@c -----------------------------------------------------------------------------
@node Samples
@section Samples
@tindex Mix_Chunk

These functions work with @t{Mix_Chunk} samples.

@menu
@b{Loading}
* Mix_GetNumChunkDecoders::  Number of sample format types that can be decoded
* Mix_GetChunkDecoder::      Name of enumerated sample format type decoder
* Mix_LoadWAV::              From a file
* Mix_LoadWAV_RW::           Using RWops
* Mix_QuickLoad_WAV::        From memory, in output format already
* Mix_QuickLoad_RAW::        From memory, in output format already

@b{Settings}
* Mix_VolumeChunk::          Set mix volume

@b{Freeing}
* Mix_FreeChunk::            Free sample
@end menu

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetNumChunkDecoders
@subsection Mix_GetNumChunkDecoders
@findex Mix_GetNumChunkDecoders

@noindent
@code{int @b{Mix_GetNumChunkDecoders}()}

@noindent
Get the number of sample chunk decoders available from the @code{Mix_GetChunkDecoder} function.  This number can be different for each run of a program, due to the change in availability of shared libraries that support each format.

@noindent
@b{Returns}: The number of sample chunk decoders available.

@cartouche
@example
// print the number of sample chunk decoders available
printf("There are %d sample chunk deocoders available\n", Mix_GetNumChunkDecoders());
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GetNumMusicDecoders},
@ref{Mix_GetChunkDecoder},
@ref{Mix_LoadWAV}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetChunkDecoder
@subsection Mix_GetChunkDecoder
@findex Mix_GetChunkDecoder

@noindent
@code{const char *@b{Mix_GetChunkDecoder}(int @var{index})}

@table @var
@item index
The index number of sample chunk decoder to get.@*
In the range from 0(zero) to Mix_GetNumChunkDecoders()-1, inclusive.
@end table

@noindent
Get the name of the @var{index}ed sample chunk decoder.
You need to get the number of sample chunk decoders available using the @code{Mix_GetNumChunkDecoders} function.

@noindent
@b{Returns}: The name of the @var{index}ed sample chunk decoder.  This string is owned by the SDL_mixer library, do not modify or free it.  It is valid until you call @code{Mix_CloseAudio} the final time.

@cartouche
@example
// print sample chunk decoders available
int i,max=Mix_GetNumChunkDecoders();
for(i=0; i<max; ++i)
	printf("Sample chunk decoder %d is for %s",Mix_GetChunkDecoder(i));
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GetNumChunkDecoders},
@ref{Mix_GetMusicDecoder},
@ref{Mix_LoadWAV}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_LoadWAV
@subsection Mix_LoadWAV
@findex Mix_LoadWAV

@noindent
@code{Mix_Chunk *@b{Mix_LoadWAV}(char *@var{file})}

@table @var
@item file
File name to load sample from.
@end table

@noindent
Load @var{file} for use as a sample.  This is actually @code{Mix_LoadWAV_RW(SDL_RWFromFile(@var{file}, "rb"), 1)}.  This can load WAVE, AIFF, RIFF, OGG, FLAC, MP3, and VOC files.@*
@b{Note:} You must call SDL_OpenAudio before this. It must know the output characteristics so it can convert the sample for playback, it does this conversion at load time.

@noindent
@b{Returns}: a pointer to the sample as a @code{Mix_Chunk}.  @b{NULL} is returned on errors.

@cartouche
@example
// load sample.wav in to sample
Mix_Chunk *sample;
sample=Mix_LoadWAV("sample.wav");
if(!sample) @{
    printf("Mix_LoadWAV: %s\n", Mix_GetError());
    // handle error
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_LoadWAV_RW},
@ref{Mix_QuickLoad_WAV},
@ref{Mix_FreeChunk}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_LoadWAV_RW
@subsection Mix_LoadWAV_RW
@findex Mix_LoadWAV_RW

@noindent
@code{Mix_Chunk *@b{Mix_LoadWAV_RW}(SDL_RWops *@var{src}, int @var{freesrc})}

@table @var
@item src
The source SDL_RWops as a pointer.  The sample is loaded from this.
@item freesrc
A non-zero value mean is will automatically close/free the @var{src} for you.
@end table

@noindent
Load @var{src} for use as a sample.  This can load WAVE, AIFF, RIFF, OGG, FLAC, MP3, and VOC formats.
Using @code{SDL_RWops} is not covered here, but they enable you to load from almost any source.
@b{Note:} You must call SDL_OpenAudio before this. It must know the output characteristics so it can convert the sample for playback, it does this conversion at load time.

@noindent
@b{Returns}: a pointer to the sample as a @code{Mix_Chunk}.  @b{NULL} is returned on errors.

@cartouche
@example
// load sample.wav in to sample
Mix_Chunk *sample;
sample=Mix_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1);
if(!sample) @{
    printf("Mix_LoadWAV_RW: %s\n", Mix_GetError());
    // handle error
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_LoadWAV},
@ref{Mix_QuickLoad_WAV},
@ref{Mix_FreeChunk}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_QuickLoad_WAV
@subsection Mix_QuickLoad_WAV
@findex Mix_QuickLoad_WAV

@noindent
@code{Mix_Chunk *@b{Mix_QuickLoad_WAV}(Uint8 *@var{mem})}

@table @var
@item mem
Memory buffer containing a WAVE file in output format.
@end table

@noindent
Load @var{mem} as a WAVE/RIFF file into a new sample.  The WAVE in @var{mem} must be already in the output format.  It would be better to use @code{Mix_LoadWAV_RW} if you aren't sure.@*
@b{Note}: This function does very little checking.  If the format mismatches the output format, or if the buffer is not a WAVE, it will not return an error.  This is probably a dangerous function to use.

@noindent
@b{Returns}: a pointer to the sample as a @code{Mix_Chunk}.  @b{NULL} is returned on errors.

@cartouche
@example
// quick-load a wave from memory
// Uint8 *wave; // I assume you have the wave loaded raw,
                // or compiled in the program...
Mix_Chunk *wave_chunk;
if(!(wave_chunk=Mix_QuickLoad_WAV(wave))) @{
    printf("Mix_QuickLoad_WAV: %s\n", Mix_GetError());
    // handle error
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_LoadWAV},
@ref{Mix_QuickLoad_RAW},
@ref{Mix_FreeChunk}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_QuickLoad_RAW
@subsection Mix_QuickLoad_RAW
@findex Mix_QuickLoad_RAW

@noindent
@code{Mix_Chunk *@b{Mix_QuickLoad_RAW}(Uint8 *@var{mem})}

@table @var
@item mem
Memory buffer containing a WAVE file in output format.
@end table

@noindent
Load @var{mem} as a raw sample.  The data in @var{mem} must be already in the output format.  If you aren't sure what you are doing, this is not a good function for you!@*
@b{Note}: This function does very little checking.  If the format mismatches the output format it will not return an error.  This is probably a dangerous function to use.

@noindent
@b{Returns}: a pointer to the sample as a @code{Mix_Chunk}.  @b{NULL} is returned on errors, such as when out of memory.

@cartouche
@example
// quick-load a raw sample from memory
// Uint8 *raw; // I assume you have the raw data here,
                // or compiled in the program...
Mix_Chunk *raw_chunk;
if(!(raw_chunk=Mix_QuickLoad_RAW(raw))) @{
    printf("Mix_QuickLoad_RAW: %s\n", Mix_GetError());
    // handle error
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_LoadWAV},
@ref{Mix_QuickLoad_WAV},
@ref{Mix_FreeChunk}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_VolumeChunk
@subsection Mix_VolumeChunk
@findex Mix_VolumeChunk

@noindent
@code{int @b{Mix_VolumeChunk}(Mix_Chunk *@var{chunk}, int @var{volume})}

@table @var
@item chunk
Pointer to the Mix_Chunk to set the volume in.
@item volume
The volume to use from 0 to @b{MIX_MAX_VOLUME}(128).@*
If greater than @b{MIX_MAX_VOLUME},@* then it will be set to @b{MIX_MAX_VOLUME}.@*
If less than 0 then @var{chunk}->volume will not be set.
@end table

@noindent
Set @var{chunk}->volume to @var{volume}.@*
The volume setting will take effect when the chunk is used on a channel, being mixed into the output.

@noindent
@b{Returns}: previous @var{chunk}->volume setting.  if you passed a negative value for @var{volume} then this volume is still the current volume for the @var{chunk}.

@cartouche
@example
// set the sample's volume to 1/2
// Mix_Chunk *sample;
int previous_volume;
previous_volume=Mix_VolumeChunk(sample, MIX_MAX_VOLUME/2);
printf("previous_volume: %d\n", previous_volume);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Chunk}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_FreeChunk
@subsection Mix_FreeChunk
@findex Mix_FreeChunk

@noindent
@code{void @b{Mix_FreeChunk}(Mix_Chunk *@var{chunk})}

@table @var
@item chunk
Pointer to the Mix_Chunk to free.
@end table

@noindent
Free the memory used in @var{chunk}, and free @var{chunk} itself as well.
Do not use @var{chunk} after this without loading a new sample to it.
@b{Note}: It's a bad idea to free a chunk that is still being played...

@cartouche
@example
// free the sample
// Mix_Chunk *sample;
Mix_FreeChunk(sample);
sample=NULL; // to be safe...
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_LoadWAV},
@ref{Mix_LoadWAV_RW},
@ref{Mix_QuickLoad_WAV},

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@c -----------------------------------------------------------------------------
@node Channels
@section Channels

These functions work with sound effect mixer channels.  Music is not affected by these functions.

@menu
@b{Setup}
* Mix_AllocateChannels::   Set the number of channels to mix
* Mix_Volume::             Set the mix volume of a channel

@b{Playing}
* Mix_PlayChannel::                 Play loop
* Mix_PlayChannelTimed::            Play loop and limit by time
* Mix_PlayChannelVol::              Play loop with seting of initial volume @b{[Mixer X]}
* Mix_PlayChannelTimedVolume::      Play loop with seting of initial volume and limit by time @b{[Mixer X]}
* Mix_FadeInChannel::               Play loop with fade in
* Mix_FadeInChannelTimed::          Play loop with fade in and limit by time
* Mix_FadeInChannelVolume::         Play loop with seting of initial volume and fade in @b{[Mixer X]}
* Mix_FadeInChannelTimedVolume::    Play loop with seting of initial volume and fade in and limit by time @b{[Mixer X]}

@b{Pausing}
* Mix_Pause::              Pause a channel
* Mix_Resume::             Resume a paused channel

@b{Stopping}
* Mix_HaltChannel::        Stop playing on a channel
* Mix_ExpireChannel::      Change the timed stoppage of a channel
* Mix_FadeOutChannel::     Stop playing channel after timed fade out
* Mix_ChannelFinished::    Set callback for when channel finishes playing

@b{Info}
* Mix_Playing::            Get the active playing status of a channel
* Mix_Paused::             Get the pause status of a channel
* Mix_FadingChannel::      Get the fade status of a channel
* Mix_GetChunk::           Get the sample playing on a channel
@end menu

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_AllocateChannels
@subsection Mix_AllocateChannels
@findex Mix_AllocateChannels

@noindent
@code{int @b{Mix_AllocateChannels}(int @var{numchans})}

@table @var
@item numchans
Number of channels to allocate for mixing.@*
A negative number will not do anything, it will tell you how many channels are currently allocated.
@end table

@noindent
Set the number of channels being mixed.  This can be called multiple times, even with sounds playing.  If @var{numchans} is less than the current number of channels, then the higher channels will be stopped, freed, and therefore not mixed any longer.  It's probably not a good idea to change the size 1000 times a second though.@*
If any channels are deallocated, any callback set by @code{Mix_ChannelFinished} will be called when each channel is halted to be freed.
@b{Note}: passing in zero WILL free all mixing channels, however music will still play.

@noindent
@b{Returns}: The number of channels allocated.  Never fails...but a high number of channels can segfault if you run out of memory.  We're talking REALLY high!

@cartouche
@example
// allocate 16 mixing channels
Mix_AllocateChannels(16);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_OpenAudio}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_Volume
@subsection Mix_Volume
@findex Mix_Volume

@noindent
@code{int @b{Mix_Volume}(int @var{channel}, int @var{volume})}

@table @var
@item channel
Channel to set mix volume for.@*
@code{-1} will set the volume for all allocated channels.
@item volume
The volume to use from 0 to @b{MIX_MAX_VOLUME}(128).@*
If greater than @b{MIX_MAX_VOLUME},@* then it will be set to @b{MIX_MAX_VOLUME}.@*
If less than 0 then the volume will not be set.
@end table

@noindent
Set the volume for any allocated channel.  If @var{channel} is @code{-1} then all channels at are set at once.  The @var{volume} is applied during the final mix, along with the sample volume.  So setting this volume to 64 will halve the output of all samples played on the specified channel.  All channels default to a volume of 128, which is the max.  Newly allocated channels will have the max volume set, so setting all channels volumes does not affect subsequent channel allocations.

@noindent
@b{Returns}: current volume of the channel. If channel is -1, the average volume is returned.

@cartouche
@example
// set channel 1 to half volume
Mix_Volume(1,MIX_MAX_VOLUME/2);

// print the average volume
printf("Average volume is %d\n",Mix_Volume(-1,-1));
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_VolumeChunk},
@ref{Mix_VolumeMusic}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_PlayChannel
@subsection Mix_PlayChannel
@findex Mix_PlayChannel

@noindent
@code{int @b{Mix_PlayChannel}(int @var{channel}, Mix_Chunk *@var{chunk}, int @var{loops})}

@table @var
@item channel
Channel to play on, or -1 for the first free unreserved channel.
@item chunk
Sample to play.
@item loops
Number of loops, -1 is infinite loops.@*
Passing one here plays the sample twice (1 loop).
@end table

@noindent
Play @var{chunk} on @var{channel}, or if @var{channel} is -1, pick the first free unreserved channel.
The sample will play for @var{loops}+1 number of times, unless stopped by halt, or fade out, or setting a new expiration time of less time than it would have originally taken to play the loops, or closing the mixer.@*
@b{Note}: this just calls @code{Mix_PlayChannelTimed()} with @var{ticks} set to -1.

@noindent
@b{Returns}: the channel the sample is played on.  On any errors, -1 is returned.

@cartouche
@example
// play sample on first free unreserved channel
// play it exactly once through
// Mix_Chunk *sample; //previously loaded
if(Mix_PlayChannel(-1, sample, 0)==-1) @{
    printf("Mix_PlayChannel: %s\n",Mix_GetError());
    // may be critical error, or maybe just no channels were free.
    // you could allocated another channel in that case...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_PlayChannelTimed},
@ref{Mix_PlayChannelVol},
@ref{Mix_PlayChannelTimedVolume},
@ref{Mix_FadeInChannel},
@ref{Mix_FadeInChannelTimed},
@ref{Mix_FadeInChannelVolume},
@ref{Mix_FadeInChannelTimedVolume},
@ref{Mix_HaltChannel},
@ref{Mix_ExpireChannel},
@ref{Mix_ReserveChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_PlayChannelTimed
@subsection Mix_PlayChannelTimed
@findex Mix_PlayChannelTimed

@noindent
@code{int @b{Mix_PlayChannelTimed}(int @var{channel}, Mix_Chunk *@var{chunk},
int @var{loops}, int @var{ticks})}

@table @var
@item channel
Channel to play on, or -1 for the first free unreserved channel.
@item chunk
Sample to play.
@item loops
Number of loops, -1 is infinite loops.@*
Passing one here plays the sample twice (1 loop).
@item ticks
Millisecond limit to play sample, at most.@*
If not enough @var{loops} or the sample @var{chunk} is not long enough, then the sample may stop before this timeout occurs.@*
-1 means play forever.
@end table

@noindent
If the sample is long enough and has enough loops then the sample will stop after @var{ticks} milliseconds.
Otherwise this function is the same as @ref{Mix_PlayChannel}.

@noindent
@b{Returns}: the channel the sample is played on.  On any errors, -1 is returned.

@cartouche
@example
// play sample on first free unreserved channel
// play it for half a second
// Mix_Chunk *sample; //previously loaded
if(Mix_PlayChannelTimed(-1, sample, -1 , 500)==-1) @{
    printf("Mix_PlayChannel: %s\n",Mix_GetError());
    // may be critical error, or maybe just no channels were free.
    // you could allocated another channel in that case...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_PlayChannel},
@ref{Mix_PlayChannelVol},
@ref{Mix_PlayChannelTimedVolume},
@ref{Mix_FadeInChannelTimed},
@ref{Mix_FadeInChannelVolume},
@ref{Mix_FadeInChannelTimedVolume},
@ref{Mix_FadeOutChannel},
@ref{Mix_ReserveChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_PlayChannelVol
@subsection Mix_PlayChannelVol
@findex Mix_PlayChannelVol

@noindent
@code{int @b{Mix_PlayChannelVol}(int @var{channel}, Mix_Chunk *@var{chunk}, int @var{loops}, int @var{vol})}

@table @var
@item channel
Channel to play on, or -1 for the first free unreserved channel.
@item chunk
Sample to play.
@item loops
Number of loops, -1 is infinite loops.@*
Passing one here plays the sample twice (1 loop).
@item vol
Initial volume level between 0 and @b{MIX_MAX_VOLUME}
@end table

@noindent
Play @var{chunk} on @var{channel}, or if @var{channel} is -1, pick the first free unreserved channel.
The @var{vol} will set initial channel volume.
The sample will play for @var{loops}+1 number of times, unless stopped by halt, or fade out, or setting a new expiration time of less time than it would have originally taken to play the loops, or closing the mixer.@*
@b{Note}: this just calls @code{Mix_PlayChannelTimed()} with @var{ticks} set to -1.

@noindent
@b{Returns}: the channel the sample is played on.  On any errors, -1 is returned.

@cartouche
@example
// play sample on first free unreserved channel
// play it exactly once through
// Mix_Chunk *sample; //previously loaded
if(Mix_PlayChannelVol(-1, sample, 0, 56)==-1) @{
    printf("Mix_PlayChannelVol: %s\n",Mix_GetError());
    // may be critical error, or maybe just no channels were free.
    // you could allocated another channel in that case...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_PlayChannel},
@ref{Mix_PlayChannelTimed},
@ref{Mix_PlayChannelTimedVolume},
@ref{Mix_FadeInChannel},
@ref{Mix_FadeInChannelTimed},
@ref{Mix_FadeInChannelVolume},
@ref{Mix_FadeInChannelTimedVolume},
@ref{Mix_HaltChannel},
@ref{Mix_ExpireChannel},
@ref{Mix_ReserveChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_PlayChannelTimedVolume
@subsection Mix_PlayChannelTimedVolume
@findex Mix_PlayChannelTimedVolume

@noindent
@code{int @b{Mix_PlayChannelTimedVolume}(int @var{channel}, Mix_Chunk *@var{chunk},
int @var{loops}, int @var{ticks})}

@table @var
@item channel
Channel to play on, or -1 for the first free unreserved channel.
@item chunk
Sample to play.
@item loops
Number of loops, -1 is infinite loops.@*
Passing one here plays the sample twice (1 loop).
@item ticks
Millisecond limit to play sample, at most.@*
If not enough @var{loops} or the sample @var{chunk} is not long enough, then the sample may stop before this timeout occurs.@*
-1 means play forever.
@item vol
Initial volume level between 0 and @b{MIX_MAX_VOLUME}
@end table

@noindent
If the sample is long enough and has enough loops then the sample will stop after @var{ticks} milliseconds.
Otherwise this function is the same as @ref{Mix_PlayChannelVol}.

@noindent
@b{Returns}: the channel the sample is played on.  On any errors, -1 is returned.

@cartouche
@example
// play sample on first free unreserved channel
// play it for half a second
// Mix_Chunk *sample; //previously loaded
if(Mix_PlayChannelTimedVolume(-1, sample, -1 , 500, 80)==-1) @{
    printf("Mix_PlayChannel: %s\n",Mix_GetError());
    // may be critical error, or maybe just no channels were free.
    // you could allocated another channel in that case...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_PlayChannel},
@ref{Mix_PlayChannelVol},
@ref{Mix_FadeInChannelTimed},
@ref{Mix_FadeInChannelVolume},
@ref{Mix_FadeInChannelTimedVolume},
@ref{Mix_FadeOutChannel},
@ref{Mix_ReserveChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_FadeInChannel
@subsection Mix_FadeInChannel
@findex Mix_FadeInChannel

@noindent
@code{int @b{Mix_FadeInChannel}(int @var{channel}, Mix_Chunk *@var{chunk},
int @var{loops}, int @var{ms})}

@table @var
@item channel
Channel to play on, or -1 for the first free unreserved channel.
@item chunk
Sample to play.
@item loops
Number of loops, -1 is infinite loops.@*
Passing one here plays the sample twice (1 loop).
@item ms
Milliseconds of time that the fade-in effect should take to go from silence to full volume.
@end table

@noindent
Play @var{chunk} on @var{channel}, or if @var{channel} is -1, pick the first free unreserved channel.@*
The channel volume starts at 0 and fades up to full volume over @var{ms} milliseconds of time.  The sample may end before the fade-in is complete if it is too short or doesn't have enough loops.
The sample will play for @var{loops}+1 number of times, unless stopped by halt, or fade out, or setting a new expiration time of less time than it would have originally taken to play the loops, or closing the mixer.@*
@b{Note}: this just calls @code{Mix_FadeInChannelTimed()} with @var{ticks} set to -1.

@noindent
@b{Returns}: the channel the sample is played on.  On any errors, -1 is returned.

@cartouche
@example
// play sample on first free unreserved channel
// play it exactly 3 times through
// fade in over one second
// Mix_Chunk *sample; //previously loaded
if(Mix_FadeInChannel(-1, sample, 2, 1000)==-1) @{
    printf("Mix_FadeInChannel: %s\n",Mix_GetError());
    // may be critical error, or maybe just no channels were free.
    // you could allocated another channel in that case...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_PlayChannel},
@ref{Mix_PlayChannelVol},
@ref{Mix_PlayChannelTimedVolume},
@ref{Mix_FadeInChannelTimed},
@ref{Mix_FadeInChannelVolume},
@ref{Mix_FadeInChannelTimedVolume},
@ref{Mix_FadingChannel},
@ref{Mix_FadeOutChannel},
@ref{Mix_ReserveChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_FadeInChannelTimed
@subsection Mix_FadeInChannelTimed
@findex Mix_FadeInChannelTimed

@example
int @b{Mix_FadeInChannelTimed}(int @var{channel}, Mix_Chunk *@var{chunk},
                           int @var{loops}, int @var{ms}, int @var{ticks})
@end example

@table @var
@item channel
Channel to play on, or -1 for the first free unreserved channel.
@item chunk
Sample to play.
@item loops
Number of loops, -1 is infinite loops.@*
Passing one here plays the sample twice (1 loop).
@item ms
Milliseconds of time that the fade-in effect should take to go from silence to full volume.
@item ticks
Millisecond limit to play sample, at most.@*
If not enough @var{loops} or the sample @var{chunk} is not long enough, then the sample may stop before this timeout occurs.@*
-1 means play forever.
@end table

@noindent
If the sample is long enough and has enough loops then the sample will stop after @var{ticks} milliseconds.
Otherwise this function is the same as @ref{Mix_FadeInChannel}.

@noindent
@b{Returns}: the channel the sample is played on.  On any errors, -1 is returned.

@cartouche
@example
// play sample on first free unreserved channel
// play it for half a second
// Mix_Chunk *sample; //previously loaded
if(Mix_PlayChannelTimed(-1, sample, -1 , 500)==-1) @{
    printf("Mix_PlayChannel: %s\n",Mix_GetError());
    // may be critical error, or maybe just no channels were free.
    // you could allocated another channel in that case...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_PlayChannelTimed},
@ref{Mix_PlayChannelVol},
@ref{Mix_PlayChannelTimedVolume},
@ref{Mix_FadeInChannel},
@ref{Mix_FadeInChannelVolume},
@ref{Mix_FadeInChannelTimedVolume},
@ref{Mix_FadingChannel},
@ref{Mix_HaltChannel},
@ref{Mix_ExpireChannel},
@ref{Mix_ReserveChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_FadeInChannelVolume
@subsection Mix_FadeInChannelVolume
@findex Mix_FadeInChannelVolume

@noindent
@code{int @b{Mix_FadeInChannelVolume}(int @var{channel}, Mix_Chunk *@var{chunk},
int @var{loops}, int @var{ms}, int @var{vol})}

@table @var
@item channel
Channel to play on, or -1 for the first free unreserved channel.
@item chunk
Sample to play.
@item loops
Number of loops, -1 is infinite loops.@*
Passing one here plays the sample twice (1 loop).
@item ms
Milliseconds of time that the fade-in effect should take to go from silence to full volume.
@item vol
Initial volume level between 0 and @b{MIX_MAX_VOLUME}
@end table

@noindent
Play @var{chunk} on @var{channel}, or if @var{channel} is -1, pick the first free unreserved channel.@*
The channel volume starts at 0 and fades up to full volume over @var{ms} milliseconds of time.  The sample may end before the fade-in is complete if it is too short or doesn't have enough loops.
The sample will play for @var{loops}+1 number of times, unless stopped by halt, or fade out, or setting a new expiration time of less time than it would have originally taken to play the loops, or closing the mixer.@*
The @var{vol} will set initial channel volume.
@b{Note}: this just calls @code{Mix_FadeInChannelTimed()} with @var{ticks} set to -1.

@noindent
@b{Returns}: the channel the sample is played on.  On any errors, -1 is returned.

@cartouche
@example
// play sample on first free unreserved channel
// play it exactly 3 times through
// fade in over one second
// Mix_Chunk *sample; //previously loaded
if(Mix_FadeInChannelVolume(-1, sample, 2, 1000, 70)==-1) @{
    printf("Mix_FadeInChannel: %s\n",Mix_GetError());
    // may be critical error, or maybe just no channels were free.
    // you could allocated another channel in that case...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_PlayChannel},
@ref{Mix_PlayChannelVol},
@ref{Mix_PlayChannelTimedVolume},
@ref{Mix_FadeInChannelTimed},
@ref{Mix_FadeInChannelTimedVolume},
@ref{Mix_FadingChannel},
@ref{Mix_FadeOutChannel},
@ref{Mix_ReserveChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_FadeInChannelTimedVolume
@subsection Mix_FadeInChannelTimedVolume
@findex Mix_FadeInChannelTimedVolume

@example
int @b{Mix_FadeInChannelTimedVolume}(int @var{channel}, Mix_Chunk *@var{chunk},
                           int @var{loops}, int @var{ms}, int @var{ticks}, int @var{vol})
@end example

@table @var
@item channel
Channel to play on, or -1 for the first free unreserved channel.
@item chunk
Sample to play.
@item loops
Number of loops, -1 is infinite loops.@*
Passing one here plays the sample twice (1 loop).
@item ms
Milliseconds of time that the fade-in effect should take to go from silence to full volume.
@item ticks
Millisecond limit to play sample, at most.@*
If not enough @var{loops} or the sample @var{chunk} is not long enough, then the sample may stop before this timeout occurs.@*
-1 means play forever.
@item vol
Initial volume level between 0 and @b{MIX_MAX_VOLUME}
@end table

@noindent
If the sample is long enough and has enough loops then the sample will stop after @var{ticks} milliseconds.
Otherwise this function is the same as @ref{Mix_FadeInChannelVolume}.

@noindent
@b{Returns}: the channel the sample is played on.  On any errors, -1 is returned.

@cartouche
@example
// play sample on first free unreserved channel
// play it for half a second
// Mix_Chunk *sample; //previously loaded
if(Mix_FadeInChannelTimedVolume(-1, sample, -1 , 500, 78)==-1) @{
    printf("Mix_PlayChannel: %s\n",Mix_GetError());
    // may be critical error, or maybe just no channels were free.
    // you could allocated another channel in that case...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_PlayChannelTimed},
@ref{Mix_PlayChannelVol},
@ref{Mix_PlayChannelTimedVolume},
@ref{Mix_FadeInChannel},
@ref{Mix_FadeInChannelTimed},
@ref{Mix_FadeInChannelVolume},
@ref{Mix_FadingChannel},
@ref{Mix_HaltChannel},
@ref{Mix_ExpireChannel},
@ref{Mix_ReserveChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_Pause
@subsection Mix_Pause
@findex Mix_Pause

@noindent
@code{void @b{Mix_Pause}(int @var{channel})}

@table @var
@item channel
Channel to pause on, or -1 for all channels.
@end table

@noindent
Pause @var{channel}, or all playing channels if -1 is passed in.  You may still halt a paused channel.@*
@b{Note}: Only channels which are actively playing will be paused.

@cartouche
@example
// pause all sample playback
Mix_Pause(-1);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Resume},
@ref{Mix_Paused},
@ref{Mix_HaltChannel}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_Resume
@subsection Mix_Resume
@findex Mix_Resume

@noindent
@code{void @b{Mix_Resume}(int @var{channel})}

@table @var
@item channel
Channel to resume playing, or -1 for all channels.
@end table

@noindent
Unpause @var{channel}, or all playing and paused channels if -1 is passed in.

@cartouche
@example
// resume playback on all previously active channels
Mix_Resume(-1);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Pause},
@ref{Mix_Paused}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_HaltChannel
@subsection Mix_HaltChannel
@findex Mix_HaltChannel

@noindent
@code{int @b{Mix_HaltChannel}(int @var{channel})}

@table @var
@item channel
Channel to stop playing, or -1 for all channels.
@end table

@noindent
Halt @var{channel} playback, or all channels if -1 is passed in.@*
Any callback set by @code{Mix_ChannelFinished} will be called.

@noindent
@b{Returns}: always returns zero. (kinda silly)

@cartouche
@example
// halt playback on all channels
Mix_HaltChannel(-1);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_ExpireChannel},
@ref{Mix_FadeOutChannel},
@ref{Mix_ChannelFinished}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ExpireChannel
@subsection Mix_ExpireChannel
@findex Mix_ExpireChannel

@noindent
@code{int @b{Mix_ExpireChannel}(int @var{channel}, int @var{ticks})}

@table @var
@item channel
Channel to stop playing, or -1 for all channels.
@item ticks
Millisecons until channel(s) halt playback.
@end table

@noindent
Halt @var{channel} playback, or all channels if -1 is passed in, after @var{ticks} milliseconds.
Any callback set by @code{Mix_ChannelFinished} will be called when the channel expires.

@noindent
@b{Returns}: Number of channels set to expire.  Whether or not they are active.

@cartouche
@example
// halt playback on all channels in 2 seconds
Mix_ExpireChannel(-1, 2000);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_HaltChannel},
@ref{Mix_FadeOutChannel},
@ref{Mix_ChannelFinished}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_FadeOutChannel
@subsection Mix_FadeOutChannel
@findex Mix_FadeOutChannel

@noindent
@code{int @b{Mix_FadeOutChannel}(int @var{channel}, int @var{ms})}

@table @var
@item channel
Channel to fade out, or -1 to fade all channels out.
@item ms
Milliseconds of time that the fade-out effect should take to go to silence, starting now.
@end table

@noindent
Gradually fade out @var{which} channel over @var{ms} milliseconds starting from now.
The channel will be halted after the fade out is completed.  Only channels that are playing are set to fade out, including paused channels.
Any callback set by @code{Mix_ChannelFinished} will be called when the channel finishes fading out.

@noindent
@b{Returns}: The number of channels set to fade out.

@cartouche
@example
// fade out all channels to finish 3 seconds from now
printf("starting fade out of %d channels\n", Mix_FadeOutChannel(-1, 3000));
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_FadeInChannel},
@ref{Mix_FadeInChannelTimed},
@ref{Mix_FadingChannel},
@ref{Mix_ChannelFinished}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ChannelFinished
@subsection Mix_ChannelFinished
@findex Mix_ChannelFinished

@noindent
@code{void @b{Mix_ChannelFinished}(void (*@var{channel_finished})(int channel))}

@table @var
@item channel_finished
Function to call when any channel finishes playback.
@end table

@noindent
When @var{channel} playback is halted, then the specified @var{channel_finished} function is called.  The @code{channel} parameter will contain the channel number that has finished.@*
@b{NOTE}: NEVER call SDL_Mixer functions, nor @code{SDL_LockAudio}, from a callback function.

@cartouche
@example
// a simple channel_finished function
void channelDone(int channel) @{
    printf("channel %d finished playback.\n",channel);
@}
@end example
@end cartouche

@cartouche
@example
// make a channelDone function
void channelDone(int channel)
@{
    printf("channel %d finished playing.\n", channel);
@}
...
// set the callback for when a channel stops playing
Mix_ChannelFinished(channelDone);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_HaltChannel},
@ref{Mix_ExpireChannel}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_Playing
@subsection Mix_Playing
@findex Mix_Playing

@noindent
@code{int @b{Mix_Playing}(int @var{channel})}

@table @var
@item channel
Channel to test whether it is playing or not.@*
-1 will tell you how many channels are playing.
@end table

@noindent
Tells you if @var{channel} is playing, or not.@*
@b{Note}: Does not check if the channel has been paused.

@noindent
@b{Returns}: Zero if the channel is not playing.  Otherwise if you passed in -1, the number of channels playing is returned.  If you passed in a specific channel, then 1 is returned if it is playing.

@cartouche
@example
// check how many channels are playing samples
printf("%d channels are playing\n", Mix_Playing(-1));
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Paused},
@ref{Mix_Fading},
@ref{Mix_PlayChannel},
@ref{Mix_Pause},

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_Paused
@subsection Mix_Paused
@findex Mix_Paused

@noindent
@code{int @b{Mix_Paused}(int @var{channel})}

@table @var
@item channel
Channel to test whether it is paused or not.@*
-1 will tell you how many channels are paused.
@end table

@noindent
Tells you if @var{channel} is paused, or not.@*
@b{Note}: Does not check if the channel has been halted after it was paused, which may seem a little weird.

@noindent
@b{Returns}: Zero if the channel is not paused.  Otherwise if you passed in -1, the number of paused channels is returned.  If you passed in a specific channel, then 1 is returned if it is paused.

@cartouche
@example
// check the pause status on all channels
printf("%d channels are paused\n", Mix_Paused(-1));
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Playing},
@ref{Mix_Pause},
@ref{Mix_Resume}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_FadingChannel
@subsection Mix_FadingChannel
@findex Mix_FadingChannel

@noindent
@code{Mix_Fading @b{Mix_FadingChannel}(int @var{which})}

@table @var
@item which
Channel to get the fade activity status from.@*
-1 is not valid, and will probably crash the program.
@end table

@noindent
Tells you if @var{which} channel is fading in, out, or not.  Does not tell you if the channel is playing anything, or paused, so you'd need to test that separately.

@noindent
@b{Returns}: the fading status.  Never returns an error.

@cartouche
@example
// check the fade status on channel 0
switch(Mix_FadingChannel(0)) @{
    case MIX_NO_FADING:
        printf("Not fading.\n");
        break;
    case MIX_FADING_OUT:
        printf("Fading out.\n");
        break;
    case MIX_FADING_IN:
        printf("Fading in.\n");
        break;
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Fading},
@ref{Mix_Playing},
@ref{Mix_Paused},
@ref{Mix_FadeInChannel},
@ref{Mix_FadeInChannelTimed},
@ref{Mix_FadeOutChannel}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetChunk
@subsection Mix_GetChunk
@findex Mix_GetChunk

@noindent
@code{Mix_Chunk *@b{Mix_GetChunk}(int @var{channel})}

@table @var
@item channel
Channel to get the current Mix_Chunk playing.@*
-1 is not valid, but will not crash the program.
@end table

@noindent
Get the most recent sample chunk pointer played on @var{channel}.  This pointer may be currently playing, or just the last used.@*
@b{Note}: The actual chunk may have been freed, so this pointer may not be valid anymore.

@noindent
@b{Returns}: Pointer to the Mix_Chunk.  NULL is returned if the channel is not allocated, or if the channel has not played any samples yet.

@cartouche
@example
// get the last chunk used by channel 0
printf("Mix_Chunk* last in use on channel 0 was: %08p\n", Mix_GetChunk(0));
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Chunk},
@ref{Mix_Playing}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@c -----------------------------------------------------------------------------
@node Groups
@section Groups

These functions work with groupings of mixer channels.

The default group tag number of -1, which refers to ALL channels.

@menu
@b{Setup}
* Mix_ReserveChannels::   Prevent channels from being used in default group

@b{TODO}
* Mix_GroupChannel::      Add/remove channel to/from group
* Mix_GroupChannels::     Add/remove segment of channels to/from group

@b{Info}
* Mix_GroupCount::        Get number of channels in group
* Mix_GroupAvailable::    Get first inactive channel in group
* Mix_GroupOldest::       Get oldest busy channel in group
* Mix_GroupNewer::        Get youngest busy channel in group

@b{Stopping}
* Mix_FadeOutGroup::      Fade out a group over time
* Mix_HaltGroup::         Stop a group
@end menu

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ReserveChannels
@subsection Mix_ReserveChannels
@findex Mix_ReserveChannels
@findex Mix_PlayChannel
@findex Mix_PlayChannelTimed
@findex Mix_FadeInChannel
@findex Mix_FadeInChannelTimed

@noindent
@code{int @b{Mix_ReserveChannels}(int @var{num})}

@table @var
@item num
Number of channels to reserve from default mixing.@*
Zero removes all reservations.
@end table

@noindent
Reserve @var{num} channels from being used when playing samples when passing in -1 as a channel number to playback functions.
The channels are reserved starting from channel 0 to @var{num}-1.
Passing in zero will unreserve all channels.
Normally SDL_mixer starts without any channels reserved.

@noindent
The following functions are affected by this setting:@*
@ref{Mix_PlayChannel}@*
@ref{Mix_PlayChannelTimed}@*
@ref{Mix_FadeInChannel}@*
@ref{Mix_FadeInChannelTimed}@*

@noindent
@b{Returns}: The number of channels reserved.  Never fails, but may return less channels than you ask for, depending on the number of channels previously allocated.

@cartouche
@example
// reserve the first 8 mixing channels
int reserved_count;
reserved_count=Mix_ReserveChannels(8);
if(reserved_count!=8) @{
    printf("reserved %d channels from default mixing.\n",reserved_count);
    printf("8 channels were not reserved!\n");
    // this might be a critical error...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_AllocateChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GroupChannel
@subsection Mix_GroupChannel
@findex Mix_GroupChannel

@noindent
@code{int @b{Mix_GroupChannel}(int @var{which}, int @var{tag})}

@table @var
@item which
Channel number of channels to assign @var{tag} to.
@item tag
A group number Any positive numbers (including zero).@*
-1 is the default group.  Use -1 to remove a group tag essentially.
@end table

@noindent
Add @var{which} channel to group @var{tag},
or reset it's group to the default group tag (-1).

@noindent
@b{Returns}: True(1) on success. False(0) is returned when the channel specified is invalid.

@cartouche
@example
// add channel 0 to group 1
if(!Mix_GroupChannel(0,1)) @{
    // bad channel, apparently channel 1 isn't allocated
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GroupChannels},
@ref{Mix_AllocateChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GroupChannels
@subsection Mix_GroupChannels
@findex Mix_GroupChannels

@noindent
@code{int @b{Mix_GroupChannels}(int @var{from}, int @var{to}, int @var{tag})}

@table @var
@item from
First Channel number of channels to assign @var{tag} to.  Must be less or equal to @var{to}.
@item to
Last Channel number of channels to assign @var{tag} to.  Must be greater or equal to @var{from}.
@item tag
A group number.  Any positive numbers (including zero).@*
-1 is the default group.  Use -1 to remove a group tag essentially.
@end table

@noindent
Add channels starting at @var{from} up through @var{to} to group @var{tag},
or reset it's group to the default group tag (-1).

@noindent
@b{Returns}: The number of tagged channels on success. If that number is less than @var{to}-@var{from}+1 then some channels were no tagged because they didn't exist.

@cartouche
@example
// add channels 0 through 7 to group 1
if(Mix_GroupChannels(0,7,1)!=8) @{
    // some bad channels, apparently some channels aren't allocated
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GroupChannel},
@ref{Mix_AllocateChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GroupCount
@subsection Mix_GroupCount
@findex Mix_GroupCount

@noindent
@code{int @b{Mix_GroupCount}(int @var{tag})}

@table @var
@item tag
A group number Any positive numbers (including zero).@*
-1 will count ALL channels.
@end table

@noindent
Count the number of channels in group @var{tag}.

@noindent
@b{Returns}: The number of channels found in the group.  This function never fails.

@cartouche
@example
// count the number of channels in group 1
printf("There are %d channels in group 1\n", Mix_GroupCount(1));
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GroupChannel},
@ref{Mix_GroupChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GroupAvailable
@subsection Mix_GroupAvailable
@findex Mix_GroupAvailable

@noindent
@code{int @b{Mix_GroupAvailable}(int @var{tag})}

@table @var
@item tag
A group number Any positive numbers (including zero).@*
-1 will search ALL channels.
@end table

@noindent
Find the first available (not playing) channel in group @var{tag}.

@noindent
@b{Returns}: The channel found on success. -1 is returned when no channels in the group are available.

@cartouche
@example
// find the first available channel in group 1
int channel;
channel=Mix_GroupAvailable(1);
if (channel==-1) @{
    // no channel available...
    // perhaps search for oldest or newest channel in use...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GroupOldest},
@ref{Mix_GroupNewer},
@ref{Mix_GroupChannel},
@ref{Mix_GroupChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GroupOldest
@subsection Mix_GroupOldest
@findex Mix_GroupOldest

@noindent
@code{int @b{Mix_GroupOldest}(int @var{tag})}

@table @var
@item tag
A group number Any positive numbers (including zero).@*
-1 will search ALL channels.
@end table

@noindent
Find the oldest actively playing channel in group @var{tag}.

@noindent
@b{Returns}: The channel found on success. -1 is returned when no channels in the group are playing or the group is empty.

@cartouche
@example
// find the oldest playing channel in group 1
int channel;
channel=Mix_GroupOldest(1);
if (channel==-1) @{
    // no channel playing or allocated...
    // perhaps just search for an available channel...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GroupNewer},
@ref{Mix_GroupAvailable},
@ref{Mix_GroupChannel},
@ref{Mix_GroupChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GroupNewer
@subsection Mix_GroupNewer
@findex Mix_GroupNewer

@noindent
@code{int @b{Mix_GroupNewer}(int @var{tag})}

@table @var
@item tag
A group number Any positive numbers (including zero).@*
-1 will search ALL channels.
@end table

@noindent
Find the newest, most recently started, actively playing channel in group @var{tag}.

@noindent
@b{Returns}: The channel found on success. -1 is returned when no channels in the group are playing or the group is empty.

@cartouche
@example
// find the newest playing channel in group 1
int channel;
channel=Mix_GroupNewer(1);
if (channel==-1) @{
    // no channel playing or allocated...
    // perhaps just search for an available channel...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GroupOldest},
@ref{Mix_GroupAvailable},
@ref{Mix_GroupChannel},
@ref{Mix_GroupChannels}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_FadeOutGroup
@subsection Mix_FadeOutGroup
@findex Mix_FadeOutGroup

@noindent
@code{int @b{Mix_FadeOutGroup}(int @var{tag}, int @var{ms})}

@table @var
@item tag
Group to fade out.@*
@b{NOTE}: -1 will @b{NOT} fade all channels out.  Use @code{Mix_FadeOutChannel(-1)} for that instead.
@item ms
Milliseconds of time that the fade-out effect should take to go to silence, starting now.
@end table

@noindent
Gradually fade out channels in group @var{tag} over @var{ms} milliseconds starting from now.
The channels will be halted after the fade out is completed.  Only channels that are playing are set to fade out, including paused channels.
Any callback set by @code{Mix_ChannelFinished} will be called when each channel finishes fading out.

@noindent
@b{Returns}: The number of channels set to fade out.

@cartouche
@example
// fade out all channels in group 1 to finish 3 seconds from now
printf("starting fade out of %d channels\n", Mix_FadeOutGroup(1, 3000));
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_HaltGroup},
@ref{Mix_FadeOutChannel},
@ref{Mix_FadingChannel},
@ref{Mix_ChannelFinished}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_HaltGroup
@subsection Mix_HaltGroup
@findex Mix_HaltGroup

@noindent
@code{int @b{Mix_HaltGroup}(int @var{tag})}

@table @var
@item tag
Group to fade out.@*
@b{NOTE}: -1 will @b{NOT} halt all channels.  Use @code{Mix_HaltChannel(-1)} for that instead.
@end table

@noindent
Halt playback on all channels in group @var{tag}.@*
Any callback set by @code{Mix_ChannelFinished} will be called once for each channel that stops.

@noindent
@b{Returns}: always returns zero. (more silly than @var{Mix_HaltChannel})

@cartouche
@example
// halt playback on all channels in group 1
Mix_HaltGroup(1);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_FadeOutGroup},
@ref{Mix_HaltChannel},
@ref{Mix_ChannelFinished}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@c -----------------------------------------------------------------------------
@node Music
@section Music

These functions work with music.  Music is not played on a normal mixer channel.
Music is therefore manipulated separately, except in post-processing hooks.

@menu
@b{Loading}
* Mix_GetNumMusicDecoders::  Number of music format types that can be decoded
* Mix_GetMusicDecoder::      Name of enumerated music format type decoder
* Mix_LoadMUS::              Load a music file into a Mix_Music
* Mix_LoadMUS_RW::           Load Music through SDL RWops
* Mix_LoadMUS_RW_ARG::       Load music through SDL RWops with passing of extra arguments string @b{[Mixer X]}
* Mix_LoadMUS_RW_GME::       Load music through SDL RWops with passing of GME track number @b{[Mixer X]}
* Mix_LoadMUSType_RW::       Load a music file from an SDL RWops object assuming a specific format
* Mix_LoadMUSType_RW_ARG::   Load a music file from an SDL RWops object assuming a specific format with passing of extra arguments string @b{[Mixer X]}

@b{Free}
* Mix_FreeMusic::            Free a Mix_Music

@b{Playing}
* Mix_PlayMusic::            Play music, with looping
* Mix_FadeInMusic::          Play music, with looping, and fade in
* Mix_FadeInMusicPos::       Play music from a start point, with looping, and fade in
* Mix_HookMusic::            Hook for a custom music player

@b{Settings}
* Mix_VolumeMusic::             Set music volume
* Mix_PauseMusic::              Pause music
* Mix_ResumeMusic::             Resume paused music
* Mix_RewindMusic::             Rewind music to beginning
* Mix_SetMusicPosition::        Set position of playback in stream
* Mix_GetMusicPosition::        Get the time current position of music stream @b{[Mixer X]}
* Mix_GetMusicTotalTime::       Get the total time length of music stream @b{[Mixer X]}
* Mix_GetMusicLoopStartTime::   Get the loop start time position of music stream @b{[Mixer X]}
* Mix_GetMusicLoopEndTime::     Get the loop end time position of music stream @b{[Mixer X]}
* Mix_GetMusicLoopLengthTime::  Get the loop time length of music stream @b{[Mixer X]}
* Mix_SetMusicCMD::             Use external program for music playback
@c Mix_SetSynchroValue::          seems useless! (return -1;)

@b{MIDI settings}
* Mix_GetMidiDevice::        Get type of MIDI device currently in use @b{[Mixer X]}
* Mix_GetNextMidiDevice::    Get type of MIDI device prepared for next opening of MIDI file @b{[Mixer X]}
* Mix_SetMidiDevice::        Set a MIDI sequencer to play MIDI music @b{[Mixer X]}
* Mix_SetLockMIDIArgs::      Enable ignoring of MIDI arguments and locking of current MIDI setup @b{[Mixer X]}

@b{Stopping}
* Mix_HaltMusic::            Stop music playback
* Mix_FadeOutMusic::         Stop music, with fade out
* Mix_HookMusicFinished::    Set a callback for when music stops

@b{Info}
* Mix_GetMusicType::         Get the music encoding type
* Mix_PlayingMusic::         Test whether music is playing
* Mix_PausedMusic::          Test whether music is paused
* Mix_FadingMusic::          Get status of current music fade activity
* Mix_GetMusicHookData::     Retrieve the Mix_HookMusic @var{arg}
@c Mix_GetSynchroValue::      seems useless! (return -1;)

@b{Meta-Tags}
* Mix_GetMusicTitle::        Retrieve the title meta-tag of currently playing @var{music} @b{[Mixer X]}
* Mix_GetMusicTitleTag::     Retrieve the title meta-tag of currently playing @var{music} @b{[Mixer X]}
* Mix_GetMusicArtistTag::    Retrieve the artist meta-tag of currently playing @var{music} @b{[Mixer X]}
* Mix_GetMusicAlbumTag::     Retrieve the album meta-tag of currently playing @var{music} @b{[Mixer X]}
* Mix_GetMusicCopyrightTag:: Retrieve the copyright meta-tag of currently playing @var{music} @b{[Mixer X]}

@b{FluidSynth Extra Settings}
* Mix_SetSoundFonts::        Set SoundFonts paths to use by supported FluidSynth MIDI backend @b{[Mixer 2.0]}
* Mix_GetSoundFonts::        Get SoundFonts paths to use by supported FluidSynth MIDI backend @b{[Mixer 2.0]}
* Mix_EachSoundFont::        Iterate SoundFonts paths to use by supported FluidSynth MIDI backend @b{[Mixer 2.0]}

@b{libADLMIDI Extra Settings}
* Mix_ADLMIDI_getTotalBanks::               Get total count of available embedded banks @b{[Mixer X]}
* Mix_ADLMIDI_getBankNames::                Get array of embedded bank titles @b{[Mixer X]}
* Mix_ADLMIDI_getBankID::                   Get ID of currently set bank @b{[Mixer X]}
* Mix_ADLMIDI_setBankID::                   Change current bank. Applying on MIDI file reopen. @b{[Mixer X]}
* Mix_ADLMIDI_getTremolo::                  Get current state of "Deep Tremolo" OPL3 flag @b{[Mixer X]}
* Mix_ADLMIDI_setTremolo::                  Set state of "Deep Tremolo" OPL3 flag. Applying on MIDI file reopen. @b{[Mixer X]}
* Mix_ADLMIDI_getVibrato::                  Get current state of "Deep Vibrato" OPL3 flag @b{[Mixer X]}
* Mix_ADLMIDI_setVibrato::                  Set state of "Deep Vibrato" OPL3 flag. Applying on MIDI file reopen. @b{[Mixer X]}
* Mix_ADLMIDI_getScaleMod::                 Get current state of "Scalable modulation mode" flag @b{[Mixer X]}
* Mix_ADLMIDI_setScaleMod::                 Turn on/off scalable modulation mode flag. Applying on MIDI file reopen. @b{[Mixer X]}
* Mix_ADLMIDI_getAdLibMode::                Get current state of "Rythm Mode" OPL flag @b{[Mixer X]}
* Mix_ADLMIDI_setAdLibMode::                Set state of "Rythm Mode" OPL flag. Applying on MIDI file reopen. @b{[Mixer X]}
* Mix_ADLMIDI_getLogarithmicVolumes::       Get current state of "Logarithmic volumes" flag @b{[Mixer X]}
* Mix_ADLMIDI_setLogarithmicVolumes::       Set state of "logarithmic volumes" flag. Applying on MIDI file reopen. @b{[Mixer X]}
* Mix_ADLMIDI_getVolumeModel::              Get ID of current volumes model @b{[Mixer X]}
* Mix_ADLMIDI_setVolumeModel::              Change current volume model. Applying on MIDI file reopen. @b{[Mixer X]}
* Mix_ADLMIDI_getFullRangeBrightness::      Get full range mode for CC74-Brightness controller
* Mix_ADLMIDI_setFullRangeBrightness::      Set full range mode for CC74-Brightness controller
* Mix_ADLMIDI_getEmulator::                 Get the OPL3 Emulator for ADLMIDI
* Mix_ADLMIDI_setEmulator::                 Select the OPL3 Emulator for ADLMIDI
* Mix_ADLMIDI_setSetDefaults::              Reset ADLMIDI settings to default state. Applying on MIDI file reopen. @b{[Mixer X]}
* Mix_ADLMIDI_setCustomBankFile::           Path to custom WOPL bank file. Applying on MIDI file reopen. @b{[Mixer X]}

@b{libOPNMIDI Extra Settings}
* Mix_OPNMIDI_getFullRangeBrightness::      Get full range mode for CC74-Brightness controller
* Mix_OPNMIDI_setFullRangeBrightness::      Set full range mode for CC74-Brightness controller
* Mix_OPNMIDI_getEmulator::                 Get the OPN2 Emulator for OPNMIDI
* Mix_OPNMIDI_setEmulator::                 Select the OPN2 Emulator for OPNMIDI
* Mix_OPNMIDI_setSetDefaults::              Reset OPNMIDI settings to default state. Applying on MIDI file reopen. @b{[Mixer X]}
* Mix_OPNMIDI_setCustomBankFile::           Path to custom WOPN bank file. Applying on MIDI file reopen. @b{[Mixer X]}

@end menu

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetNumMusicDecoders
@subsection Mix_GetNumMusicDecoders
@findex Mix_GetNumMusicDecoders

@noindent
@code{int @b{Mix_GetNumMusicDecoders}()}

@noindent
Get the number of music decoders available from the @code{Mix_GetMusicDecoder} function.  This number can be different for each run of a program, due to the change in availability of shared libraries that support each format.

@noindent
@b{Returns}: The number of music decoders available.

@cartouche
@example
// print the number of music decoders available
printf("There are %d music deocoders available\n", Mix_GetNumMusicDecoders());
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GetNumChunkDecoders},
@ref{Mix_GetMusicDecoder},
@ref{Mix_LoadMUS}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetMusicDecoder
@subsection Mix_GetMusicDecoder
@findex Mix_GetMusicDecoder

@noindent
@code{const char *@b{Mix_GetMusicDecoder}(int @var{index})}

@table @var
@item index
The index number of music decoder to get.@*
In the range from 0(zero) to Mix_GetNumMusicDecoders()-1, inclusive.
@end table

@noindent
Get the name of the @var{index}ed music decoder.
You need to get the number of music decoders available using the @code{Mix_GetNumMusicDecoders} function.

@noindent
@b{Returns}: The name of the @var{index}ed music decoder.  This string is owned by the SDL_mixer library, do not modify or free it.  It is valid until you call @code{Mix_CloseAudio} the final time.

@cartouche
@example
// print music decoders available
int i,max=Mix_GetNumMusicDecoders();
for(i=0; i<max; ++i)
	printf("Music decoder %d is for %s",Mix_GetMusicDecoder(i));
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GetNumMusicDecoders},
@ref{Mix_GetChunkDecoder},
@ref{Mix_LoadWAV}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_LoadMUS
@subsection Mix_LoadMUS
@findex Mix_LoadMUS

@noindent
@code{Mix_Music *@b{Mix_LoadMUS}(const char *@var{file})}

@table @var
@item file
Name of music file to use.
@end table

@noindent
Load music file to use.  This can load WAVE, MOD, MIDI, OGG, MP3, FLAC, and any file that you use a command to play with.@*
If you are using an external command to play the music, you must call @code{Mix_SetMusicCMD} before this, otherwise the internal players will be used.  Alternatively, if you have set an external command up and don't want to use it, you must call @code{Mix_SetMusicCMD(NULL)} to use the built-in players again.

@noindent
@b{Returns}: A pointer to a Mix_Music.  NULL is returned on errors.

@cartouche
@example
// load the MP3 file "music.mp3" to play as music
Mix_Music *music;
music=Mix_LoadMUS("music.mp3");
if(!music) @{
    printf("Mix_LoadMUS(\"music.mp3\"): %s\n", Mix_GetError());
    // this might be a critical error...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Music},
@ref{Mix_SetMusicCMD},
@ref{Mix_PlayMusic},
@ref{Mix_FadeInMusic},
@ref{Mix_FadeInMusicPos}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_LoadMUS_RW
@subsection Mix_LoadMUS_RW
@findex Mix_LoadMUS_RW

@noindent
@code{Mix_Music *@b{Mix_LoadMUS_RW}(SDL_RWops *@var{src}, int @var{freesrc})}

@table @var
@item src
SDL RWops instance of music file / memory
@item freesrc
Automatically close SDL_RWops instance on complete loading of music
@end table

@noindent
Load a music file from an SDL_RWop object

@noindent
@b{Returns}: A pointer to a Mix_Music.  NULL is returned on errors.

@cartouche
@example
SDL_RWops *file = SDL_RWopen("music.mp3", "rb");
// load the MP3 file "music.mp3" to play as music
Mix_Music *music;
music = Mix_LoadMUS_RW(file, 0);
if(!music) @{
    printf("Mix_LoadMUS_RW(file, 0): %s\n", Mix_GetError());
    // this might be a critical error...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Music},
@ref{Mix_LoadMUS_RW_ARG},
@ref{Mix_LoadMUS_RW_GME},
@ref{Mix_LoadMUSType_RW},
@ref{Mix_LoadMUSType_RW_ARG},
@ref{Mix_SetMusicCMD},
@ref{Mix_PlayMusic},
@ref{Mix_FadeInMusic},
@ref{Mix_FadeInMusicPos}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_LoadMUS_RW_ARG
@subsection Mix_LoadMUS_RW_ARG
@findex Mix_LoadMUS_RW_ARG

@noindent
@code{Mix_Music *@b{Mix_LoadMUS_RW_ARG}(SDL_RWops *@var{src}, int @var{freesrc}, const char *@var{args})}

@table @var
@item src
SDL RWops instance of music file / memory
@item freesrc
Automatically close SDL_RWops instance on complete loading of music
@item args
An arguments string supported by specific library
@end table

@noindent
Load a music file from an SDL_RWop object with custom arguments

@noindent
@b{Returns}: A pointer to a Mix_Music.  NULL is returned on errors.

@cartouche
@example
// load the MIDI file "music.mid" to play as music with ADLMIDI synthesizer
Mix_Music *music;
SDL_RWops *file = SDL_RWopen("music.mid", "rb");
music = Mix_LoadMUS_RW_ARG(file, 1, "s0;t1;v1;b68;");
if(!music) @{
    printf("Mix_LoadMUS_RW_ARG(file, 1, \"s0;t1;v1;b68;\"): %s\n", Mix_GetError());
    // this might be a critical error...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Music},
@ref{Mix_LoadMUS_RW},
@ref{Mix_LoadMUS_RW_GME},
@ref{Mix_LoadMUSType_RW},
@ref{Mix_LoadMUSType_RW_ARG},
@ref{Mix_SetMusicCMD},
@ref{Mix_PlayMusic},
@ref{Mix_FadeInMusic},
@ref{Mix_FadeInMusicPos}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_LoadMUS_RW_GME
@subsection Mix_LoadMUS_RW_GME
@findex Mix_LoadMUS_RW_GME

@noindent
@code{Mix_Music *@b{Mix_LoadMUS_RW_GME}(SDL_RWops *@var{src}, int @var{freesrc}, int @var{trackID})}

@table @var
@item src
SDL RWops instance of music file / memory
@item freesrc
Automatically close SDL_RWops instance on complete loading of music
@item trackID
ID of GME file track
@end table

@noindent
Load music file to use.

@noindent
@b{Returns}: A pointer to a Mix_Music.  NULL is returned on errors.

@cartouche
@example
// load the PC Engine chiptune file "music.hes" to play as music with GME library
Mix_Music *music;
SDL_RWops *file = SDL_RWopen("music.hes", "rb");
music = Mix_LoadMUS_RW_GME(file, 1, 4);
if(!music) @{
    printf("Mix_LoadMUS_RW_GME(file, 1, 4): %s\n", Mix_GetError());
    // this might be a critical error...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Music},
@ref{Mix_LoadMUS_RW},
@ref{Mix_LoadMUS_RW_ARG},
@ref{Mix_LoadMUSType_RW},
@ref{Mix_LoadMUSType_RW_ARG},
@ref{Mix_SetMusicCMD},
@ref{Mix_PlayMusic},
@ref{Mix_FadeInMusic},
@ref{Mix_FadeInMusicPos}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_LoadMUSType_RW
@subsection Mix_LoadMUSType_RW
@findex Mix_LoadMUSType_RW

@noindent
@code{Mix_Music *@b{Mix_LoadMUSType_RW}(SDL_RWops *@var{src}, Mix_MusicType @var{type}, int @var{freesrc})}

@table @var
@item src
SDL RWops instance of music file / memory
@item type
A music type identificator
@item freesrc
Automatically close SDL_RWops instance on complete loading of music
@end table

@noindent
Load a music file from an SDL_RWop object assuming a specific format

@noindent
@b{Returns}: A pointer to a Mix_Music.  NULL is returned on errors.

@cartouche
@example
// load the MIDI file "music.mid" to play as music with ADLMIDI synthesizer
Mix_Music *music;
SDL_RWops *file = SDL_RWopen("music.mid", "rb");
music = Mix_LoadMUSType_RW(file, MUS_MID, 1);
if(!music) @{
    printf("Mix_LoadMUSType_RW(file, MUS_MID, 1): %s\n", Mix_GetError());
    // this might be a critical error...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Music},
@ref{Mix_LoadMUS_RW},
@ref{Mix_LoadMUS_RW_GME},
@ref{Mix_LoadMUSType_RW_ARG},
@ref{Mix_SetMusicCMD},
@ref{Mix_PlayMusic},
@ref{Mix_FadeInMusic},
@ref{Mix_FadeInMusicPos}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_LoadMUSType_RW_ARG
@subsection Mix_LoadMUSType_RW_ARG
@findex Mix_LoadMUSType_RW_ARG

@noindent
@code{Mix_Music *@b{Mix_LoadMUSType_RW_ARG}(SDL_RWops *@var{src}, Mix_MusicType @var{type}, int @var{freesrc})}

@table @var
@item src
SDL RWops instance of music file / memory
@item type
A music type identificator
@item freesrc
Automatically close SDL_RWops instance on complete loading of music
@item args
An arguments string supported by specific library
@end table

@noindent
Load a music file from an SDL_RWop object assuming a specific format with custom arguments (trackID for GME or settings for a MIDI playing)

@noindent
@b{Returns}: A pointer to a Mix_Music.  NULL is returned on errors.

@cartouche
@example
// load the MIDI file "music.mid" to play as music with ADLMIDI synthesizer
Mix_Music *music;
SDL_RWops *file = SDL_RWopen("music.mid", "rb");
music = Mix_LoadMUSType_RW_ARG(file, MUS_MID, 1, "s0;t1;v1;b68;");
if(!music) @{
    printf("Mix_LoadMUSType_RW_ARG(file, MUS_MID, 1, \"s0;t1;v1;b68;\"): %s\n", Mix_GetError());
    // this might be a critical error...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Music},
@ref{Mix_LoadMUS_RW},
@ref{Mix_LoadMUS_RW_GME},
@ref{Mix_LoadMUSType_RW},
@ref{Mix_SetMusicCMD},
@ref{Mix_PlayMusic},
@ref{Mix_FadeInMusic},
@ref{Mix_FadeInMusicPos}



@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_FreeMusic
@subsection Mix_FreeMusic
@findex Mix_FreeMusic

@noindent
@code{void @b{Mix_FreeMusic}(Mix_Music *@var{music})}

@table @var
@item music
Pointer to Mix_Music to free.
@end table

@noindent
Free the loaded @var{music}.  If @var{music} is playing it will be halted.  If @var{music} is fading out, then this function will wait (blocking) until the fade out is complete.

@cartouche
@example
// free music
Mix_Music *music;
Mix_FreeMusic(music);
music=NULL; // so we know we freed it...
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_LoadMUS}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_PlayMusic
@subsection Mix_PlayMusic
@findex Mix_PlayMusic

@noindent
@code{int @b{Mix_PlayMusic}(Mix_Music *@var{music}, int @var{loops})}

@table @var
@item music
Pointer to Mix_Music to play.
@item loops
number of times to play through the music.@*
0 plays the music zero times...@*
-1 plays the music forever (or as close as it can get to that)
@end table

@noindent
Play the loaded @var{music} @var{loop} times through from start to finish.  The previous music will be halted, or if fading out it waits (blocking) for that to finish.

@noindent
@b{Returns}: 0 on success, or -1 on errors.

@cartouche
@example
// play music forever
// Mix_Music *music; // I assume this has been loaded already
if(Mix_PlayMusic(music, -1)==-1) @{
    printf("Mix_PlayMusic: %s\n", Mix_GetError());
    // well, there's no music, but most games don't break without music...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_FadeInMusic}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_FadeInMusic
@subsection Mix_FadeInMusic
@findex Mix_FadeInMusic

@noindent
@code{int @b{Mix_FadeInMusic}(Mix_Music *@var{music}, int @var{loops}, int @var{ms})}

@table @var
@item music
Pointer to Mix_Music to play.
@item loops
number of times to play through the music.@*
0 plays the music zero times...@*
-1 plays the music forever (or as close as it can get to that)
@item ms
Milliseconds for the fade-in effect to complete.
@end table

@noindent
Fade in over @var{ms} milliseconds of time, the loaded @var{music}, playing it @var{loop} times through from start to finish.@*
The fade in effect only applies to the first loop.@*
Any previous music will be halted, or if it is fading out it will wait (blocking) for the fade to complete.@*
This function is the same as @code{Mix_FadeInMusicPos(@var{music}, @var{loops}, @var{ms}, 0)}.

@noindent
@b{Returns}: 0 on success, or -1 on errors.

@cartouche
@example
// play music forever, fading in over 2 seconds
// Mix_Music *music; // I assume this has been loaded already
if(Mix_FadeInMusic(music, -1, 2000)==-1) @{
    printf("Mix_FadeInMusic: %s\n", Mix_GetError());
    // well, there's no music, but most games don't break without music...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_PlayMusic},
@ref{Mix_FadeInMusicPos}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_FadeInMusicPos
@subsection Mix_FadeInMusicPos
@findex Mix_FadeInMusicPos

@noindent
@code{int @b{Mix_FadeInMusicPos}(Mix_Music *@var{music}, int @var{loops}, int @var{ms}, double @var{position})}

@table @var
@item music
Pointer to Mix_Music to play.
@item loops
number of times to play through the music.@*
0 plays the music zero times...@*
-1 plays the music forever (or as close as it can get to that)
@item ms
Milliseconds for the fade-in effect to complete.
@item position
Posistion to play from, see @code{Mix_SetMusicPosition} for meaning.
@end table

@noindent
Fade in over @var{ms} milliseconds of time, the loaded @var{music}, playing it @var{loop} times through from start to finish.@*
The fade in effect only applies to the first loop.@*
The first time the music is played, it posistion will be set to @var{posistion}, which means different things for different types of music files, see @code{Mix_SetMusicPosition} for more info on that.@*
Any previous music will be halted, or if it is fading out it will wait (blocking) for the fade to complete.@*

@noindent
@b{Returns}: 0 on success, or -1 on errors.

@cartouche
@example
// play music forever, fading in over 2 seconds
// Mix_Music *music; // I assume this has been loaded already
if(Mix_FadeInMusicPos(music, -1, 2000)==-1) @{
    printf("Mix_FadeInMusic: %s\n", Mix_GetError());
    // well, there's no music, but most games don't break without music...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_PlayMusic},
@ref{Mix_FadeInMusic},
@ref{Mix_SetMusicPosition}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_HookMusic
@subsection Mix_HookMusic
@findex Mix_HookMusic

@example
void @b{Mix_HookMusic}(void (*@var{mix_func})(void *udata, Uint8 *stream, int len),
                   void *@var{arg})
@end example

@table @var
@item mix_func
Function pointer to a music player mixer function.@*
NULL will stop the use of the music player, returning the mixer to using the internal music players like usual.
@item arg
This is passed to the @var{mix_func}'s @code{udata} parameter when it is called.
@end table

@noindent
This sets up a custom music player function.  The function will be called with @var{arg} passed into the @code{udata} parameter when the @var{mix_func} is called.  The @code{stream} parameter passes in the audio stream buffer to be filled with @code{len} bytes of music.  The music player will then be called automatically when the mixer needs it.  Music playing will start as soon as this is called.  All the music playing and stopping functions have no effect on music after this.  Pause and resume will work.  Using a custom music player and the internal music player is not possible, the custom music player takes priority.  To stop the custom music player call @code{Mix_HookMusic(NULL, NULL)}.@*
@b{NOTE}: NEVER call SDL_Mixer functions, nor @code{SDL_LockAudio}, from a callback function.

@cartouche
@example
// make a music play function
// it expects udata to be a pointer to an int
void myMusicPlayer(void *udata, Uint8 *stream, int len)
@{
    int i, pos=*(int*)udata;

    // fill buffer with...uh...music...
    for(i=0; i<len; i++)
        stream[i]=(i+pos)&ff;

    // set udata for next time
    pos+=len;
    *(int*)udata=pos;
@}
...
// use myMusicPlayer for playing...uh...music
int music_pos=0;
Mix_HookMusic(myMusicPlayer, &music_pos);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_SetMusicCMD},
@ref{Mix_GetMusicHookData}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_VolumeMusic
@subsection Mix_VolumeMusic
@findex Mix_VolumeMusic

@noindent
@code{int @b{Mix_VolumeMusic}(int @var{volume})}

@table @var
@item volume
Music volume, from 0 to @b{MIX_MAX_VOLUME}(128).@*
Values greater than @b{MIX_MAX_VOLUME} will use @b{MIX_MAX_VOLUME}.@*
-1 does not set the volume, but does return the current volume setting.
@end table

@noindent
Set the volume to @var{volume}, if it is 0 or greater, and return the previous volume setting.  Setting the volume during a fade will not work, the faders use this function to perform their effect!  Setting volume while using an external music player set by @code{Mix_SetMusicCMD} will have no effect, and @code{Mix_GetError} will show the reason why not.

@noindent
@b{Returns}: The previous volume setting.

@cartouche
@example
// set the music volume to 1/2 maximum, and then check it
printf("volume was    : %d\n", Mix_VolumeMusic(MIX_MAX_VOLUME/2));
printf("volume is now : %d\n", Mix_VolumeMusic(-1));
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_FadeInMusic},
@ref{Mix_FadeOutMusic},
@ref{Mix_SetMusicCMD}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_PauseMusic
@subsection Mix_PauseMusic
@findex Mix_PauseMusic

@noindent
@code{void @b{Mix_PauseMusic}()}

@noindent
Pause the music playback.  You may halt paused music.@*
@b{Note}: Music can only be paused if it is actively playing.

@cartouche
@example
// pause music playback
Mix_PauseMusic();
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_ResumeMusic},
@ref{Mix_PausedMusic},
@ref{Mix_HaltMusic}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ResumeMusic
@subsection Mix_ResumeMusic
@findex Mix_ResumeMusic

@noindent
@code{void @b{Mix_ResumeMusic}()}

@noindent
Unpause the music.  This is safe to use on halted, paused, and already playing music.

@cartouche
@example
// resume music playback
Mix_ResumeMusic();
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_PauseMusic},
@ref{Mix_PausedMusic}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_RewindMusic
@subsection Mix_RewindMusic
@findex Mix_RewindMusic

@noindent
@code{void @b{Mix_RewindMusic}()}

@noindent
Rewind the music to the start.  This is safe to use on halted, paused, and already playing music.  It is not useful to rewind the music immediately after starting playback, because it starts at the beginning by default.

@noindent
This function only works for these streams: MOD, OGG, MP3, Native MIDI.

@cartouche
@example
// rewind music playback to the start
Mix_RewindMusic();
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_PlayMusic}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_SetMusicPosition
@subsection Mix_SetMusicPosition
@findex Mix_SetMusicPosition

@noindent
@code{int @b{Mix_SetMusicPosition}(double @var{position})}

@table @var
@item position
Posistion to play from.
@end table

@noindent
Set the position of the currently playing music.  The @var{position} takes different meanings for different music sources.  It only works on the music sources listed below.

@table @b
@item WAV
Jumps to @var{position} seconds from the beginning of the song.
@item MOD
ModPlug: Jumps to @var{position} seconds from the beginning of the song.
Mikmod: The double is cast to Uint16 and used for a pattern number in the module.@*
Passing zero is similar to rewinding the song.
@item OGG
Jumps to @var{position} seconds from the beginning of the song.
@item MP3
Jumps to @var{position} seconds from the current position in the stream.@*
So you may want to call @code{Mix_RewindMusic} before this.@*
Does not go in reverse...negative values do nothing.
@end table

@noindent
@b{Returns}: 0 on success, or -1 if the codec doesn't support this function.

@cartouche
@example
// skip one minute into the song, from the start
// this assumes you are playing an MP3
Mix_RewindMusic();
if(Mix_SetMusicPosition(60.0)==-1) @{
    printf("Mix_SetMusicPosition: %s\n", Mix_GetError());
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_FadeInMusicPos}
@ref{Mix_GetMusicPosition}
@ref{Mix_GetMusicTotalTime}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetMusicPosition
@subsection Mix_GetMusicPosition
@findex Mix_GetMusicPosition

@noindent
@code{double @b{Mix_GetMusicPosition}(Mix_Music *@var{music})}

@table @var
@item music
A pointer to current music stream
@end table

@noindent
Get the time current position of music stream. It only works on some of music sources listed in table shown in description of @ref{Mix_SetMusicPosition} function.

@noindent
@b{Returns}: seconds value of current music position or -1.0 if this feature is not supported for some codec

@noindent
@b{See Also}:@*
@ref{Mix_FadeInMusicPos}
@ref{Mix_SetMusicPosition}
@ref{Mix_GetMusicTotalTime}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetMusicTotalTime
@subsection Mix_GetMusicTotalTime
@findex Mix_GetMusicTotalTime

@noindent
@code{double @b{Mix_GetMusicTotalTime}(Mix_Music *@var{music})}

@table @var
@item music
A pointer to current music stream
@end table

@noindent
Get the time current position of music stream. It only works on some of music sources listed in table shown in description of @ref{Mix_SetMusicPosition} function.

@noindent
@b{Returns}: seconds value of current music total length or -1.0 if this feature is not supported for some codec

@noindent
@b{See Also}:@*
@ref{Mix_FadeInMusicPos}
@ref{Mix_GetMusicPosition}
@ref{Mix_SetMusicPosition}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetMusicLoopStartTime
@subsection Mix_GetMusicLoopStartTime
@findex Mix_GetMusicLoopStartTime

@noindent
@code{double @b{Mix_GetMusicLoopStartTime}(Mix_Music *@var{music})}

@table @var
@item music
A pointer to current music stream
@end table

@noindent
A part of loop points feature. Get the loop start time position of music stream. It only works on some of music sources.

@noindent
@b{Returns}: seconds value of current music loop start position or -1.0 if this feature is not supported for some codec

@noindent
@b{See Also}:@*
@ref{Mix_GetMusicLoopEndTime}
@ref{Mix_GetMusicLoopLengthTime}


@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetMusicLoopEndTime
@subsection Mix_GetMusicLoopEndTime
@findex Mix_GetMusicLoopEndTime

@noindent
@code{double @b{Mix_GetMusicLoopEndTime}(Mix_Music *@var{music})}

@table @var
@item music
A pointer to current music stream
@end table

@noindent
A part of loop points feature. Get the loop time length of music stream. It only works on some of music sources.

@noindent
@b{Returns}: seconds value of current music loop end position or -1.0 if this feature is not supported for some codec

@noindent
@b{See Also}:@*
@ref{Mix_GetMusicLoopStartTime}
@ref{Mix_GetMusicLoopLengthTime}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetMusicLoopLengthTime
@subsection Mix_GetMusicLoopLengthTime
@findex Mix_GetMusicLoopLengthTime

@noindent
@code{double @b{Mix_GetMusicLoopEndTime}(Mix_Music *@var{music})}

@table @var
@item music
A pointer to current music stream
@end table

@noindent
A part of loop points feature. Get the loop time length of music stream. It only works on some of music sources.

@noindent
@b{Returns}: seconds value of current music loop length time or -1.0 if this feature is not supported for some codec

@noindent
@b{See Also}:@*
@ref{Mix_GetMusicLoopStartTime}
@ref{Mix_GetMusicLoopEndTime}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_SetMusicCMD
@subsection Mix_SetMusicCMD
@findex Mix_SetMusicCMD

@noindent
@code{int @b{Mix_SetMusicCMD}(const char *@var{command})}

@table @var
@item command
System command to play the music.  Should be a complete command, as if typed in to the command line, but it should expect the filename to be added as the last argument.@*
@b{NULL} will turn off using an external command for music, returning to the internal music playing functionality.
@end table

@noindent
Setup a command line music player to use to play music.  Any music playing will be halted.
The music file to play is set by calling @code{Mix_LoadMUS(filename)}, and the filename is appended as the last argument on the commandline.  This allows you to reuse the music command to play multiple files.  The command will be sent signals @b{SIGTERM} to halt, @b{SIGSTOP} to pause, and @b{SIGCONT} to resume.  The command program should react correctly to those signals for it to function properly with SDL_Mixer.  @code{Mix_VolumeMusic} has no effect when using an external music player, and @code{Mix_GetError} will have an error code set.  You should set the music volume in the music player's command if the music player supports that.  Looping music works, by calling the command again when the previous music player process has ended.  Playing music through a command uses a forked process to execute the music command.@*
To use the internal music players set the @var{command} to @b{NULL}.@*
@b{NOTE}: External music is not mixed by SDL_mixer, so no post-processing hooks will be for music.@*
@b{NOTE}: Playing music through an external command may not work if the sound driver does not support multiple openings of the audio device, since SDL_Mixer already has the audio device open for playing samples through channels.@*
@b{NOTE}: Commands are not totally portable, so be careful.

@noindent
@b{Returns}: 0 on success, or -1 on any errors, such as running out of memory.

@cartouche
@example
// use mpg123 to play music
Mix_Music *music=NULL;
if(Mix_SetMusicCMD("mpg123 -q")==-1) @{
    perror("Mix_SetMusicCMD");
@} else @{
    // play some mp3 file
    music=Mix_LoadMUS("music.mp3");
    if(music) @{
        Mix_PlayMusic(music,1);
    @}
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_PlayMusic},
@ref{Mix_VolumeMusic}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetMidiDevice
@subsection Mix_GetMidiDevice
@findex Mix_GetMidiDevice

@noindent
@code{int @b{Mix_GetMidiDevice}()}

@noindent
Tells currently using MIDI sequencer to play MIDI files.

@noindent
@b{Returns}: The type of currently using MIDI device.

@cartouche
@example
// print the type of music currently playing
switch(Mix_GetMidiDevice())
@{
    MIDI_ADLMIDI:
        printf("ADLMIDI is active.\n");
        break;
    MIDI_Native:
        printf("Operating system native MIDI is active.\n");
        break;
    MIDI_Timidity:
        printf("Timidity is active.\n");
        break;
    MIDI_OPNMIDI:
        printf("OPNMIDI is active.\n");
        break;
    MIDI_Fluidsynth:
        printf("FluidSynth is active.\n");
        break;
    default:
        printf("Unknown MIDI device is using.\n");
        break;
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_SetMidiDevice}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetNextMidiDevice
@subsection Mix_GetNextMidiDevice
@findex Mix_GetNextMidiDevice

@noindent
@code{int @b{Mix_GetNextMidiDevice}()}

@noindent
Tells MIDI sequencer recently choosen by @ref{Mix_SetMidiDevice} which will be use in next open of MIDI file.

@noindent
@b{Returns}: The type of currently using MIDI device.

@cartouche
@example
// print the type of music currently playing
switch(Mix_GetNextMidiDevice())
@{
    MIDI_ADLMIDI:
        printf("ADLMIDI is next.\n");
        break;
    MIDI_Native:
        printf("Operating system native MIDI is next.\n");
        break;
    MIDI_Timidity:
        printf("Timidity is next.\n");
        break;
    MIDI_OPNMIDI:
        printf("OPNMIDI is next.\n");
        break;
    MIDI_Fluidsynth:
        printf("FluidSynth is next.\n");
        break;
    default:
        printf("Unknown MIDI device is next.\n");
        break;
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GetMidiDevice},
@ref{Mix_SetMidiDevice}


@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_SetMidiDevice
@subsection Mix_SetMidiDevice
@findex Mix_SetMidiDevice

@noindent
@code{int @b{Mix_SetMidiDevice}(int @var{device})}

@table @var
@item device
A @b{MIDI_*} enum value which identifies MIDI sequencer you want to use
@end table

@noindent
Allows to choose a MIDI sequencer to play MIDI files.
@b{NOTE}: new choosen MIDI device begins to work on  MIDI music file reopen

@noindent
@b{Returns}: 0 on success, or -1 on any errors, such as MIDI sequencer is unknown or does not built with this library assembly.
@cartouche
@example
//Set libOPNMIDI as MIDI playing sequencer
Mix_SetMidiDevice(MIDI_OPNMIDI);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_SetLockMIDIArgs}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_SetLockMIDIArgs
@subsection Mix_SetLockMIDIArgs
@findex Mix_SetLockMIDIArgs

@noindent
@code{void @b{Mix_SetLockMIDIArgs}(int @var{lock_midiargs})}

@table @var
@item lock_midiargs
0 to disable locking or 1 to enable locking of MIDI arguments passed through @code{Mix_LoadMUS(filename)} function
@end table

@noindent
Allows to don't reset MIDI arguments to default when is no arguments passed through @code{Mix_LoadMUS(filename)} function, or different arguments was passed.

@cartouche
@example
//Turn on ignoring of MIDI arguments
Mix_SetLockMIDIArgs(1);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_SetMidiDevice}


@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_HaltMusic
@subsection Mix_HaltMusic
@findex Mix_HaltMusic

@noindent
@code{int @b{Mix_HaltMusic}()}

@noindent
Halt playback of music. This interrupts music fader effects.
Any callback set by @code{Mix_HookMusicFinished} will be called when the music stops.

@noindent
@b{Returns}: always returns zero. (even more silly than @var{Mix_HaltGroup})

@cartouche
@example
// halt music playback
Mix_HaltMusic();
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_FadeOutMusic},
@ref{Mix_HookMusicFinished}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_FadeOutMusic
@subsection Mix_FadeOutMusic
@findex Mix_FadeOutMusic

@noindent
@code{int @b{Mix_FadeOutMusic}(int @var{ms})}

@table @var
@item ms
Milliseconds of time that the fade-out effect should take to go to silence, starting now.
@end table

@noindent
Gradually fade out the music over @var{ms} milliseconds starting from now.
The music will be halted after the fade out is completed.  Only when music is playing and not fading already are set to fade out, including paused channels.
Any callback set by @code{Mix_HookMusicFinished} will be called when the music finishes fading out.

@noindent
@b{Returns}: 1 on success, 0 on failure.

@cartouche
@example
// fade out music to finish 3 seconds from now
while(!Mix_FadeOutMusic(3000) && Mix_PlayingMusic()) @{
    // wait for any fades to complete
    SDL_Delay(100);
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_HaltMusic},
@ref{Mix_FadingMusic},
@ref{Mix_PlayingMusic},
@ref{Mix_HookMusicFinished}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_HookMusicFinished
@subsection Mix_HookMusicFinished
@findex Mix_HookMusicFinished

@noindent
@code{void @b{Mix_HookMusicFinished}(void (*@var{music_finished})())}

@table @var
@item music_finished
Function pointer to a @code{void function()}.@*
@b{NULL} will remove the hook.
@end table

@noindent
This sets up a function to be called when music playback is halted.  Any time music stops, the @var{music_finished} function will be called.  Call with @b{NULL} to remove the callback.@*
@b{NOTE}: NEVER call SDL_Mixer functions, nor @code{SDL_LockAudio}, from a callback function.

@cartouche
@example
// make a music finished function
void musicFinished()
@{
    printf("Music stopped.\n");
@}
...
// use musicFinished for when music stops
Mix_HookMusicFinished(musicFinished);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_HaltMusic},
@ref{Mix_FadeOutMusic}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetMusicType
@subsection Mix_GetMusicType
@findex Mix_GetMusicType

@noindent
@code{Mix_MusicType @b{Mix_GetMusicType}(const Mix_Music *@var{music})}

@table @var
@item music
The music to get the type of.@*
@b{NULL} will get the currently playing music type.
@end table

@noindent
Tells you the file format encoding of the music.  This may be handy when used
with @code{Mix_SetMusicPosition}, and other music functions that vary based on
the type of music being played.  If you want to know the type of music currently
being played, pass in @b{NULL} to @var{music}.

@noindent
@b{Returns}: The type of @var{music} or if @var{music} is @b{NULL} then the currently playing music type, otherwise @b{MUS_NONE} if no music is playing.

@cartouche
@example
// print the type of music currently playing
switch(Mix_GetMusicType(NULL))
@{
    case MUS_NONE:
    MUS_CMD:
        printf("Command based music is playing.\n");
        break;
    MUS_WAV:
        printf("WAVE/RIFF music is playing.\n");
        break;
    MUS_MOD:
        printf("MOD (MikMod) music is playing.\n");
        break;
    MUS_MODPLUG: // [Mixer 2.0]
        printf("MOD (ModPlug) music is playing.\n");
        break;
    MUS_MID:
        printf("MIDI music is playing.\n");
        break;
    MUS_OGG:
        printf("OGG music is playing.\n");
        break;
    MUS_MP3:
        printf("MP3 (SMPEG) music is playing.\n");
        break;
    MUS_MP3_MAD: // [Mixer 2.0]
        printf("MP3 (libMAD) music is playing.\n");
        break;
    MUS_GME: // [Mixer X]
        printf("Game Music Emulators music is playing.\n");
        break;
    default:
        printf("Unknown music is playing.\n");
        break;
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_MusicType},
@ref{Mix_SetPosition}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_PlayingMusic
@subsection Mix_PlayingMusic
@findex Mix_PlayingMusic

@noindent
@code{int @b{Mix_PlayingMusic}()}

@noindent
Tells you if music is actively playing, or not.@*
@b{Note}: Does not check if the channel has been paused.

@noindent
@b{Returns}: Zero if the music is not playing, or 1 if it is playing.

@cartouche
@example
// check if music is playing
printf("music is%s playing.\n", Mix_PlayingMusic()?"":" not");
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_PausedMusic},
@ref{Mix_FadingMusic},
@ref{Mix_PlayMusic}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_PausedMusic
@subsection Mix_PausedMusic
@findex Mix_PausedMusic

@noindent
@code{int @b{Mix_PausedMusic}()}

@noindent
Tells you if music is paused, or not.@*
@b{Note}: Does not check if the music was been halted after it was paused, which may seem a little weird.

@noindent
@b{Returns}: Zero if music is not paused.  1 if it is paused.

@cartouche
@example
// check the music pause status
printf("music is%s paused\n", Mix_PausedMusic()?"":" not");
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_PlayingMusic},
@ref{Mix_PauseMusic},
@ref{Mix_ResumeMusic}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_FadingMusic
@subsection Mix_FadingMusic
@findex Mix_FadingMusic

@noindent
@code{Mix_Fading @b{Mix_FadingMusic}()}

@noindent
Tells you if music is fading in, out, or not at all.  Does not tell you if the channel is playing anything, or paused, so you'd need to test that separately.

@noindent
@b{Returns}: the fading status.  Never returns an error.

@cartouche
@example
// check the music fade status
switch(Mix_FadingMusic()) @{
    case MIX_NO_FADING:
        printf("Not fading music.\n");
        break;
    case MIX_FADING_OUT:
        printf("Fading out music.\n");
        break;
    case MIX_FADING_IN:
        printf("Fading in music.\n");
        break;
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_Fading},
@ref{Mix_PausedMusic},
@ref{Mix_PlayingMusic},
@ref{Mix_FadeInMusicPos},
@ref{Mix_FadeOutMusic}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetMusicHookData
@subsection Mix_GetMusicHookData
@findex Mix_GetMusicHookData

@noindent
@code{void *@b{Mix_GetMusicHookData}()}

@noindent
Get the @var{arg} passed into @code{Mix_HookMusic}.

@noindent
@b{Returns}: the @var{arg} pointer.

@cartouche
@example
// retrieve the music hook data pointer
void *data;
data=Mix_GetMusicHookData();
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_HookMusic}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetMusicTitle
@subsection Mix_GetMusicTitle
@findex Mix_GetMusicTitle

@noindent
@code{const char *@b{Mix_GetMusicTitle}(const Mix_Music *music)}

@noindent
Get music title from meta-tag if possible. If title tag is empty, filename will be returned

@noindent
@b{Returns}: the @var{music} title string pointer.

@cartouche
@example
// retrieve the music title meta-tag
void *title;
title=Mix_GetMusicTitle(myMusic);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GetMusicTitleTag},
@ref{Mix_GetMusicArtistTag},
@ref{Mix_GetMusicAlbumTag},
@ref{Mix_GetMusicCopyrightTag}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetMusicTitleTag
@subsection Mix_GetMusicTitleTag
@findex Mix_GetMusicTitleTag

@noindent
@code{const char *@b{Mix_GetMusicTitleTag}(const Mix_Music *music)}

@noindent
Get music title from meta-tag if possible. If title tag is empty, returns NULL

@noindent
@b{Returns}: the @var{music} title string pointer or NULL.

@cartouche
@example
// retrieve the music title meta-tag
void *title;
title=Mix_GetMusicTitleTag(myMusic);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GetMusicTitle},
@ref{Mix_GetMusicArtistTag},
@ref{Mix_GetMusicAlbumTag},
@ref{Mix_GetMusicCopyrightTag}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetMusicArtistTag
@subsection Mix_GetMusicArtistTag
@findex Mix_GetMusicArtistTag

@noindent
@code{const char *@b{Mix_GetMusicArtistTag}(const Mix_Music *music)}

@noindent
Get music artist from meta-tag if possible. If artist tag is empty, returns NULL

@noindent
@b{Returns}: the @var{music} artist string pointer or NULL.

@cartouche
@example
// retrieve the music artist meta-tag
void *title;
title=Mix_GetMusicArtistTag(myMusic);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GetMusicTitle},
@ref{Mix_GetMusicTitleTag},
@ref{Mix_GetMusicAlbumTag},
@ref{Mix_GetMusicCopyrightTag}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetMusicAlbumTag
@subsection Mix_GetMusicAlbumTag
@findex Mix_GetMusicAlbumTag

@noindent
@code{const char *@b{Mix_GetMusicAlbumTag}(const Mix_Music *music)}

@noindent
Get music album from meta-tag if possible. If album tag is empty, returns NULL

@noindent
@b{Returns}: the @var{music} album string pointer or NULL.

@cartouche
@example
// retrieve the music album meta-tag
void *title;
title=Mix_GetMusicAlbumTag(myMusic);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GetMusicTitle},
@ref{Mix_GetMusicTitleTag},
@ref{Mix_GetMusicArtistTag},
@ref{Mix_GetMusicCopyrightTag}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetMusicCopyrightTag
@subsection Mix_GetMusicCopyrightTag
@findex Mix_GetMusicCopyrightTag

@noindent
@code{const char *@b{Mix_GetMusicCopyrightTag}(const Mix_Music *music)}

@noindent
Get music copyright from meta-tag if possible. If copyright tag is empty, returns NULL

@noindent
@b{Returns}: the @var{music} copyright string pointer or NULL.

@cartouche
@example
// retrieve the music copyright meta-tag
void *title;
title=Mix_GetMusicCopyrightTag(myMusic);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GetMusicTitle},
@ref{Mix_GetMusicTitleTag},
@ref{Mix_GetMusicArtistTag},
@ref{Mix_GetMusicAlbumTag}


@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_SetSoundFonts
@subsection Mix_SetSoundFonts
@findex Mix_SetSoundFonts

@noindent
@code{int @b{Mix_SetSoundFonts}(const char *@var{paths})}

@table @var
@item paths
Semicolon separated paths to sound font files.@*
@b{NULL} to use default sound font paths from environment.
@end table

@noindent
Set the paths list to sound font files will be used by FluidSynth MIDI backend.

@noindent
@b{Returns}: 1 if path successfully set, or 0 if error has occouped.

@cartouche
@example
if(Mix_SetSoundFonts("./myfonts/melodic.sf2;myfonts/drups.sf2")==0) @{
    printf("Mix_SetSoundFonts: %s\n", Mix_GetError());
    // this might be a critical error...
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_GetSoundFonts},
@ref{Mix_EachSoundFont}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_GetSoundFonts
@subsection Mix_GetSoundFonts
@findex Mix_GetSoundFonts

@noindent
@code{const char *@b{Mix_GetSoundFonts}()}

@table @var
@item paths
Semicolon separated paths to sound font files.@*
@b{NULL} to use default sound font paths from environment.
@end table

@noindent
Get the current set of paths list to sound font files will be used by
FluidSynth MIDI backend. If there are wasn't set by @ref{Mix_SetSoundFonts}
function, there are will be tooken from @b{SDL_SOUNDFONTS} or
@b{SDL_FORCE_SOUNDFONTS} environment variables.

@noindent
@b{Returns}: Semicolon-separated sound font paths.

@cartouche
@example
//Print list of available sound fonts
char *context, *path = NULL;
char *fonts = Mix_GetSoundFonts();
printf("Available sound fonts:\n");
for(path = strtok_r(fonts, ";", &context); path; path = strtok_r(NULL, ";", &context)) @{
    printf(" - %s\n", path);
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_SetSoundFonts},
@ref{Mix_EachSoundFont}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_EachSoundFont
@subsection Mix_EachSoundFont
@findex Mix_EachSoundFont

@noindent
@code{const char *@b{Mix_EachSoundFont}(int (*@var{function})(const char *, void *), void *@var{data})}

@table @var
@item function
The callback function will be called for each sound font
listed in the paths. Has arguments @var{path} and @var{data}.
@item data
User data passed to the callback
@end table

@noindent
Iterate the current set of paths list to sound font files will be used by
FluidSynth MIDI backend. If there are wasn't set by @ref{Mix_SetSoundFonts}
function, there are will be tooken from @b{SDL_SOUNDFONTS} or
@b{SDL_FORCE_SOUNDFONTS} environment variables.

@noindent
@b{Returns}: 1 if function successfully completed, or 0 if error has occouped.

@cartouche
@example
int print_sound_font(const char *path, void *data) @{
    printf(" - %s\n", path);
    return 1;
@}

//...

//Print list of available sound fonts
char *fonts = Mix_GetSoundFonts();
printf("Available sound fonts:\n");
for(!Mix_EachSoundFont(print_sound_font, NULL)) @{
    printf(" - %s\n", path);
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_SetSoundFonts},
@ref{Mix_GetSoundFonts}





@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_getTotalBanks
@subsection Mix_ADLMIDI_getTotalBanks
@findex Mix_ADLMIDI_getTotalBanks

@noindent
@code{int @b{Mix_ADLMIDI_getTotalBanks}()}

@noindent
@b{Returns}: Total count of embedded ADLMIDI banks.

@noindent
Get total count of available embedded banks.

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_getBankNames
@subsection Mix_ADLMIDI_getBankNames
@findex Mix_ADLMIDI_getBankNames

@noindent
@code{const char *const * @b{Mix_ADLMIDI_getBankNames}()}

@noindent
@b{Returns}: array of strings are names of embedded ADLMIDI banks.

@noindent
Get array of embedded bank titles.


@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_getBankID
@subsection Mix_ADLMIDI_getBankID
@findex Mix_ADLMIDI_getBankID

@noindent
@code{int @b{Mix_ADLMIDI_getBankID}()}

@noindent
@b{Returns}: currently using ID of embedded ADLMIDI bank.

@noindent
Get currently using ID of embedded ADLMIDI bank.


@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_setBankID
@subsection Mix_ADLMIDI_setBankID
@findex Mix_ADLMIDI_setBankID

@noindent
@code{void @b{Mix_ADLMIDI_setBankID}(int @var{bnk})}

@table @var
@item bnk
Embedded ADLMIDI bank ID
@end table

@noindent
Change current embedded ADLMIDI bank.
@b{NOTE}: Applies on MIDI file reopen

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_getTremolo
@subsection Mix_ADLMIDI_getTremolo
@findex Mix_ADLMIDI_getTremolo

@noindent
@code{int @b{Mix_ADLMIDI_getTremolo}()}

@noindent
@b{Returns}: 0 if Deep Tremolo is inactive, or 1 if Deep Tremolo is activated.

@noindent
Get current state of "Deep Tremolo" OPL3 flag in ADLMIDI.


@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_setTremolo
@subsection Mix_ADLMIDI_setTremolo
@findex Mix_ADLMIDI_setTremolo

@noindent
@code{void @b{Mix_ADLMIDI_setTremolo}(int @var{tr})}

@table @var
@item tr
State of Deep Tremolo flag:
0 if Deep Tremolo is inactive, or 1 if Deep Tremolo is activated
@end table

@noindent
Set state of "Deep Tremolo" OPL3 flag.
@b{NOTE}: Applies on MIDI file reopen

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_getVibrato
@subsection Mix_ADLMIDI_getVibrato
@findex Mix_ADLMIDI_getVibrato

@noindent
@code{int @b{Mix_ADLMIDI_getVibrato}()}

@noindent
@b{Returns}: 0 if Deep Vibrato is inactive, or 1 if Deep Vibrato is activated.

@noindent
Get current state of "Deep Vibrato" OPL3 flag in ADLMIDI.


@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_setVibrato
@subsection Mix_ADLMIDI_setVibrato
@findex Mix_ADLMIDI_setVibrato

@noindent
@code{void @b{Mix_ADLMIDI_setVibrato}(int @var{vib})}

@table @var
@item vib
State of Deep Vibrato flag:
0 if Deep Vibrato is inactive, or 1 if Deep Vibrato is activated
@end table

@noindent
Set state of "Deep Vibrato" OPL3 flag.
@b{NOTE}: Applies on MIDI file reopen

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_getScaleMod
@subsection Mix_ADLMIDI_getScaleMod
@findex Mix_ADLMIDI_getScaleMod

@noindent
@code{int @b{Mix_ADLMIDI_getScaleMod}()}

@noindent
@b{Returns}: 0 if Scalable Modulation is inactive, or 1 if Scalable Modulation is activated.

@noindent
Get current state of "Scalable modulation mode" flag


@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_setScaleMod
@subsection Mix_ADLMIDI_setScaleMod
@findex Mix_ADLMIDI_setScaleMod

@noindent
@code{void @b{Mix_ADLMIDI_setScaleMod}(int @var{sc})}

@table @var
@item sc
State of Scalable Modulation flag:
0 if Scalable Modulation is inactive, or 1 if Scalable Modulation is activated
@end table

@noindent
Turn on/off scalable modulation mode flag.
@b{NOTE}: Applies on MIDI file reopen

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_getAdLibMode
@subsection Mix_ADLMIDI_getAdLibMode
@findex Mix_ADLMIDI_getAdLibMode

@noindent
@code{int @b{Mix_ADLMIDI_getAdLibMode}()}

@noindent
@b{Returns}: 0 if OPL2 Rythm Mode is inactive, or 1 if OPL2 Rythm Mode is activated.

@noindent
Get current state of OPL2 Rythm Mode flag


@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_setAdLibMode
@subsection Mix_ADLMIDI_setAdLibMode
@findex Mix_ADLMIDI_setAdLibMode

@noindent
@code{void @b{Mix_ADLMIDI_setAdLibMode}(int @var{al})}

@table @var
@item al
State of flag:
0 if OPL2 Rythm Mode is inactive, or 1 if OPL2 Rythm Mode is activated
@end table

@noindent
Set state of OPL2 Rythm Mode mode.
@b{NOTE}: Applies on MIDI file reopen

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_getLogarithmicVolumes
@subsection Mix_ADLMIDI_getLogarithmicVolumes
@findex Mix_ADLMIDI_getLogarithmicVolumes

@noindent
@code{int @b{Mix_ADLMIDI_getLogarithmicVolumes}()}

@noindent
@b{Returns}: 0 if Logarithmic volumes is inactive, or 1 if Logarithmic volumes is activated.

@noindent
Get current state of Logarithmic volumes flag


@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_setLogarithmicVolumes
@subsection Mix_ADLMIDI_setLogarithmicVolumes
@findex Mix_ADLMIDI_setLogarithmicVolumes

@noindent
@code{void @b{Mix_ADLMIDI_setLogarithmicVolumes}(int @var{lv})}

@table @var
@item lv
State of Logarithmic volumes flag:
0 if Logarithmic volumes are inactive, or 1 if Logarithmic volumes are activated
@end table

@noindent
Set state of Logarithmic volumes flag.
@b{NOTE}: Affects only when @b{ADLMIDI_VM_GENERIC} or @b{ADLMIDI_VM_CMF} volume models are active.
@b{NOTE}: Applies on MIDI file reopen.

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_getVolumeModel
@subsection Mix_ADLMIDI_getVolumeModel
@findex Mix_ADLMIDI_getVolumeModel

@noindent
@code{int @b{Mix_ADLMIDI_getVolumeModel}()}

@noindent
@b{Returns}: value of @b{Mix_ADLMIDI_VolumeModel} enum which a current volume model.

@noindent
Get ID of current volumes model of ADLMIDI


@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_setVolumeModel
@subsection Mix_ADLMIDI_setVolumeModel
@findex Mix_ADLMIDI_setVolumeModel

@noindent
@code{void @b{Mix_ADLMIDI_setVolumeModel}(int @var{vm})}

@table @var
@item vm
Value of @b{Mix_ADLMIDI_VolumeModel} enum.
@end table

@noindent
Change current volume model.
@b{NOTE}: Applies on MIDI file reopen

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_getFullRangeBrightness
@subsection Mix_ADLMIDI_getFullRangeBrightness
@findex Mix_ADLMIDI_getFullRangeBrightness

@noindent
@code{int @b{Mix_ADLMIDI_getFullRangeBrightness}()}

@noindent
@b{Returns}: 0 when full-ranged CC74 is disabled, or 1 when full-ranged mode of CC74 is enabled

@noindent
Get full range mode for CC74-Brightness controller

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_setFullRangeBrightness
@subsection Mix_ADLMIDI_setFullRangeBrightness
@findex Mix_ADLMIDI_setFullRangeBrightness

@noindent
@code{void @b{Mix_ADLMIDI_setFullRangeBrightness}(int @var{frb})}

@table @var
@item frb
0 to disable full-ranged CC74, or 1 to enable full-ranged mode of CC74
@end table

@noindent
Set full range mode for CC74-Brightness controller
@b{NOTE}: Applies on MIDI file reopen

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_getEmulator
@subsection Mix_ADLMIDI_getEmulator
@findex Mix_ADLMIDI_getEmulator

@noindent
@code{int @b{Mix_ADLMIDI_getEmulator}()}

@noindent
@b{Returns}: value of @b{Mix_ADLMIDI_Emulator} enum which a current OPL3 emulator.

@noindent
Get ID of current OPL3 emulator of ADLMIDI


@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_setEmulator
@subsection Mix_ADLMIDI_setEmulator
@findex Mix_ADLMIDI_setEmulator

@noindent
@code{void @b{Mix_ADLMIDI_setVolumeModel}(int @var{emu})}

@table @var
@item emu
Value of @b{Mix_ADLMIDI_Emulator} enum.
@end table

@noindent
Select the OPL3 Emulator for ADLMIDI
@b{NOTE}: Applies on MIDI file reopen

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_setSetDefaults
@subsection Mix_ADLMIDI_setSetDefaults
@findex Mix_ADLMIDI_setSetDefaults

@noindent
@code{void @b{Mix_ADLMIDI_setSetDefaults}()}

@noindent
Resets all settings of ADLMIDI into default state.
@b{NOTE}: Applies on MIDI file reopen

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_ADLMIDI_setCustomBankFile
@subsection Mix_ADLMIDI_setCustomBankFile
@findex Mix_ADLMIDI_setCustomBankFile

@noindent
@code{void @b{Mix_ADLMIDI_setCustomBankFile}(const char *@var{bank_wonl_path})}

@table @var
@item bank_wonl_path
Path to custom WOPL bank or NULL to use embedded banks.
@end table

@noindent
Sets path to custom WOPL bank file.
@b{NOTE}: Applies on MIDI file reopen

@cartouche
@example
//Set custom ADLMIDI bank
Mix_ADLMIDI_setCustomBankFile("./music/my-gm-bank.wonl");
@end example
@end cartouche

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_OPNMIDI_getFullRangeBrightness
@subsection Mix_OPNMIDI_getFullRangeBrightness
@findex Mix_OPNMIDI_getFullRangeBrightness

@noindent
@code{int @b{Mix_OPNMIDI_getFullRangeBrightness}()}

@noindent
@b{Returns}: 0 when full-ranged CC74 is disabled, or 1 when full-ranged mode of CC74 is enabled

@noindent
Get full range mode for CC74-Brightness controller

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_OPNMIDI_setFullRangeBrightness
@subsection Mix_OPNMIDI_setFullRangeBrightness
@findex Mix_OPNMIDI_setFullRangeBrightness

@noindent
@code{void @b{Mix_OPNMIDI_setFullRangeBrightness}(int @var{frb})}

@table @var
@item frb
0 to disable full-ranged CC74, or 1 to enable full-ranged mode of CC74
@end table

@noindent
Set full range mode for CC74-Brightness controller
@b{NOTE}: Applies on MIDI file reopen

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_OPNMIDI_getEmulator
@subsection Mix_OPNMIDI_getEmulator
@findex Mix_OPNMIDI_getEmulator

@noindent
@code{int @b{Mix_OPNMIDI_getEmulator}()}

@noindent
@b{Returns}: value of @b{Mix_OPNMIDI_Emulator} enum which a current OPN2 emulator.

@noindent
Get ID of current OPN2 emulator of OPNMIDI

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_OPNMIDI_setEmulator
@subsection Mix_OPNMIDI_setEmulator
@findex Mix_OPNMIDI_setEmulator

@noindent
@code{void @b{Mix_OPNMIDI_setVolumeModel}(int @var{emu})}

@table @var
@item emu
Value of @b{Mix_OPNMIDI_Emulator} enum.
@end table

@noindent
Select the OPN2 Emulator for OPNMIDI
@b{NOTE}: Applies on MIDI file reopen

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_OPNMIDI_setSetDefaults
@subsection Mix_OPNMIDI_setSetDefaults
@findex Mix_OPNMIDI_setSetDefaults

@noindent
@code{void @b{Mix_OPNMIDI_setSetDefaults}()}

@noindent
Resets all settings of OPNMIDI into default state.
@b{NOTE}: Applies on MIDI file reopen

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_OPNMIDI_setCustomBankFile
@subsection Mix_OPNMIDI_setCustomBankFile
@findex Mix_OPNMIDI_setCustomBankFile

@noindent
@code{void @b{Mix_OPNMIDI_setCustomBankFile}(const char *@var{bank_wonp_path})}

@table @var
@item bank_wonp_path
Path to custom WOPN bank or NULL to use default bank.
@end table

@noindent
Sets path to custom WOPN bank file.
@b{NOTE}: Applies on MIDI file reopen

@cartouche
@example
//Set custom OPNMIDI bank
Mix_OPNMIDI_setCustomBankFile("./music/my-gm-bank.wonp");
@end example
@end cartouche



@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@c -----------------------------------------------------------------------------
@node Effects
@section Effects

These functions are for special effects processing.
Not all effects are all that special.
All effects are post processing routines that are either built-in to SDL_mixer or
created by you.  Effects can be applied to individual channels, or to the final
mixed stream which contains all the channels including music.

@menu
@b{Registration}
* Mix_RegisterEffect::             Hook a processor to a channel
* Mix_UnregisterEffect::           Unhook a processor from a channel
* Mix_UnregisterAllEffects::       Unhook all processors from a channel
* Mix_SetPostMix::                 Hook in a postmix processor

@b{Built-in Processors}
* Mix_SetPanning::                 Stereo panning
* Mix_SetDistance::                Distance attenuation (volume)
* Mix_SetPosition::                Panning(angular) and distance
* Mix_SetReverseStereo::           Swap stereo left and right
@c Mix_SetReverb::                non-functional, yet
@end menu

The built-in processors: @code{Mix_SetPanning, Mix_SetPosition, Mix_SetDistance, and@*
Mix_SetReverseStereo}, all look for an environment variable, @b{MIX_EFFECTSMAXSPEED} to be
defined.
If the environment variable is defined these processors may use more memory or reduce the quality of the effects, all for better speed.

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_RegisterEffect
@subsection Mix_RegisterEffect
@findex Mix_RegisterEffect

@example
int @b{Mix_RegisterEffect}(int @var{chan}, Mix_EffectFunc_t @var{f}, Mix_EffectDone_t @var{d},
                       void *@var{arg})
@end example

@table @var
@item chan
channel number to register @var{f} and @var{d} on.@*
Use @b{MIX_CHANNEL_POST} to process the postmix stream.
@item f
The function pointer for the effects processor.
@item d
The function pointer for any cleanup routine to be called when the channel is done playing a sample.@*
This may be @b{NULL} for any processors that don't need to clean up any memory or other dynamic data.
@item arg
A pointer to data to pass into the @var{f}'s and @var{d}'s @code{udata} parameter.  It is a good place to keep the state data for the processor, especially if the processor is made to handle multiple channels at the same time.@*
This may be @b{NULL}, depending on the processor.
@end table

@noindent
Hook a processor function @var{f} into a channel for post processing effects.  You may just be reading the data and displaying it, or you may be altering the stream to add an echo.  Most processors also have state data that they allocate as they are in use, this would be stored in the @var{arg} pointer data space.  When a processor is finished being used, any function passed into @var{d} will be called, which is when your processor should clean up the data in the @var{arg} data space.@*
The effects are put into a linked list, and always appended to the end, meaning they always work on previously registered effects output.  Effects may be added multiple times in a row.  Effects are cumulative this way.

@noindent
@b{Returns}: Zero on errors, such as a nonexisting channel.

@cartouche
@example
// make a passthru processor function that does nothing...
void noEffect(int chan, void *stream, int len, void *udata)
@{
    // you could work with stream here...
@}
...
// register noEffect as a postmix processor
if(!Mix_RegisterEffect(MIX_CHANNEL_POST, noEffect, NULL, NULL)) @{
    printf("Mix_RegisterEffect: %s\n", Mix_GetError());
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_UnregisterEffect},
@ref{Mix_UnregisterAllEffects}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_UnregisterEffect
@subsection Mix_UnregisterEffect
@findex Mix_UnregisterEffect

@noindent
@code{int @b{Mix_UnregisterEffect}(int @var{channel}, Mix_EffectFunc_t @var{f})}

@table @var
@item channel
Channel number to remove @var{f} from as a post processor.@*
Use @b{MIX_CHANNEL_POST} for the postmix stream.
@item f
The function to remove from @var{channel}.
@end table

@noindent
Remove the oldest (first found) registered effect function @var{f} from the effect list for @var{channel}.  This only removes the first found occurance of that function, so it may need to be called multiple times if you added the same function multiple times, just stop removing when @code{Mix_UnregisterEffect} returns an error, to remove all occurances of @var{f} from a channel.@*
If the channel is active the registered effect will have its @code{Mix_EffectDone_t} function called, if it was specified in @code{Mix_RegisterEffect}.

@noindent
@b{Returns}: Zero on errors, such as invalid channel, or effect function not registered on channel.

@cartouche
@example
// unregister the noEffect from the postmix effects
// this removes all occurances of noEffect registered to the postmix
while(Mix_UnregisterEffect(MIX_CHANNEL_POST, noEffect));
// you may print Mix_GetError() if you want to check it.
// it should say "No such effect registered" after this loop.
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_UnregisterAllEffects},
@ref{Mix_RegisterEffect}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_UnregisterAllEffects
@subsection Mix_UnregisterAllEffects
@findex Mix_UnregisterAllEffects

@noindent
@code{int @b{Mix_UnregisterAllEffects}(int @var{channel})}

@table @var
@item channel
Channel to remove all effects from.@*
Use @b{MIX_CHANNEL_POST} for the postmix stream.
@end table

@noindent
This removes all effects registered to @var{channel}.
If the channel is active all the registered effects will have their @code{Mix_EffectDone_t} functions called, if they were specified in @code{Mix_RegisterEffect}.

@noindent
@b{Returns}: Zero on errors, such as @var{channel} not existing.

@cartouche
@example
// remove all effects from channel 0
if(!Mix_UnregisterAllEffects(0)) @{
    printf("Mix_UnregisterAllEffects: %s\n", Mix_GetError());
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_UnregisterEffect},
@ref{Mix_RegisterEffect}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_SetPostMix
@subsection Mix_SetPostMix
@findex Mix_SetPostMix

@example
void @b{Mix_SetPostMix}(void (*@var{mix_func})(void *udata, Uint8 *stream, int len),
                    void *@var{arg})
@end example

@table @var
@item mix_func
The function pointer for the postmix processor.@*
@b{NULL} unregisters the current postmixer.
@item arg
A pointer to data to pass into the @var{mix_func}'s @code{udata} parameter.  It is a good place to keep the state data for the processor, especially if the processor is made to handle multiple channels at the same time.@*
This may be @b{NULL}, depending on the processor.
@end table

@noindent
Hook a processor function @var{mix_func} to the postmix stream for post processing effects.  You may just be reading the data and displaying it, or you may be altering the stream to add an echo.  Most processors also have state data that they allocate as they are in use, this would be stored in the @var{arg} pointer data space.
This processor is never really finished, until the audio device is closed, or you pass @b{NULL} as the @var{mix_func}.@*
There can only be one postmix function used at a time through this method.  Use @code{Mix_RegisterEffect(MIX_CHANNEL_POST, mix_func, NULL, arg)} to use multiple postmix processors.@*
This postmix processor is run AFTER all the registered postmixers set up by @code{Mix_RegisterEffect}.

@cartouche
@example
// make a passthru processor function that does nothing...
void noEffect(void *udata, Uint8 *stream, int len)
@{
    // you could work with stream here...
@}
...
// register noEffect as a postmix processor
Mix_SetPostMix(noEffect, NULL);
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_RegisterEffect}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_SetPanning
@subsection Mix_SetPanning
@findex Mix_SetPanning

@noindent
@code{int @b{Mix_SetPanning}(int @var{channel}, Uint8 @var{left}, Uint8 @var{right})}

@table @var
@item channel
Channel number to register this effect on.@*
Use @b{MIX_CHANNEL_POST} to process the postmix stream.
@item left
Volume for the left channel, range is 0(silence) to 255(loud)
@item right
Volume for the left channel, range is 0(silence) to 255(loud)
@end table

@noindent
This effect will only work on stereo audio.  Meaning you called @code{Mix_OpenAudio}
with 2 channels (@b{MIX_DEFAULT_CHANNELS}).  The easiest way to do true panning is to call
@code{Mix_SetPanning(channel, left, 254 - left);} so that the total volume is correct,
if you consider the maximum volume to be 127 per channel for center, or 254 max for left, this works, but about halves the effective volume.@*
This Function registers the effect for you, so don't try to @code{Mix_RegisterEffect} it yourself.@*
@b{NOTE}: Setting both @var{left} and @var{right} to 255 will unregister the effect from
@var{channel}.  You cannot unregister it any other way, unless you use
@code{Mix_UnregisterAllEffects} on the @var{channel}.@*
@b{NOTE}: Using this function on a mono audio device will not register the effect, nor will it return an error status.


@noindent
@b{Returns}: Zero on errors, such as bad channel, or if @code{Mix_RegisterEffect} failed.

@cartouche
@example
// pan channel 1 halfway to the left
if(!Mix_SetPanning(1, 255, 127)) @{
    printf("Mix_SetPanning: %s\n", Mix_GetError());
    // no panning, is it ok?
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_SetPosition},
@ref{Mix_UnregisterAllEffects}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_SetDistance
@subsection Mix_SetDistance
@findex Mix_SetDistance

@noindent
@code{int @b{Mix_SetDistance}(int @var{channel}, Uint8 @var{distance})}

@table @var
@item channel
Channel number to register this effect on.@*
Use @b{MIX_CHANNEL_POST} to process the postmix stream.
@item distance
Specify the distance from the listener, from 0(close/loud) to 255(far/quiet).
@end table

@noindent
This effect simulates a simple attenuation of volume due to distance.  The volume never quite reaches silence, even at max distance.@*
@b{NOTE}: Using a @var{distance} of 0 will cause the effect to unregister itself from @var{channel}.  You cannot unregister it any other way, unless you use @code{Mix_UnregisterAllEffects} on the @var{channel}.

@noindent
@b{Returns}: Zero on errors, such as an invalid channel, or if @code{Mix_RegisterEffect} failed.

@cartouche
@example
// distance channel 1 to be farthest away
if(!Mix_SetDistance(1, 255)) @{
    printf("Mix_SetDistance: %s\n", Mix_GetError());
    // no distance, is it ok?
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_SetPosition},
@ref{Mix_UnregisterAllEffects}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_SetPosition
@subsection Mix_SetPosition
@findex Mix_SetPosition

@noindent
@code{int @b{Mix_SetPosition}(int @var{channel}, Sint16 @var{angle}, Uint8 @var{distance})}

@table @var
@item channel
Channel number to register this effect on.@*
Use @b{MIX_CHANNEL_POST} to process the postmix stream.
@item angle
Direction in relation to forward from 0 to 360 degrees.  Larger angles will be reduced to this range using @code{@var{angles} % 360}.@*
0 = directly in front.@*
90 = directly to the right.@*
180 = directly behind.@*
270 = directly to the left.@*
So you can see it goes clockwise starting at directly in front.@*
This ends up being similar in effect to @code{Mix_SetPanning}.
@item distance
The distance from the listener, from 0(near/loud) to 255(far/quiet).@*
This is the same as the @code{Mix_SetDistance} effect.
@end table

@noindent
This effect emulates a simple 3D audio effect.  It's not all that realistic, but it can help improve some level of realism.  By giving it the angle and distance from the camera's point of view, the effect pans and attenuates volumes.  If you are looking for better positional audio, using @b{OpenAL} is suggested.@*
@b{NOTE}: Using @var{angle} and @var{distance} of 0, will cause the effect to unregister itself from @var{channel}.  You cannot unregister it any other way, unless you use @code{Mix_UnregisterAllEffects} on the @var{channel}.

@noindent
@b{Returns}: Zero on errors, such as an invalid channel, or if @code{Mix_RegisterEffect} failed.

@cartouche
@example
// set channel 2 to be behind and right, and 100 units away
if(!Mix_SetPosition(2, 135, 100)) @{
    printf("Mix_SetPosition: %s\n", Mix_GetError());
    // no position effect, is it ok?
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_SetPanning},
@ref{Mix_SetDistance},
@ref{Mix_UnregisterAllEffects}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@node Mix_SetReverseStereo
@subsection Mix_SetReverseStereo
@findex Mix_SetReverseStereo

@noindent
@code{int @b{Mix_SetReverseStereo}(int @var{channel}, int @var{flip})}

@table @var
@item channel
Channel number to register this effect on.@*
Use @b{MIX_CHANNEL_POST} to process the postmix stream.
@item flip
Must be non-zero to work, means nothing to the effect processor itself.@*
set to zero to unregister the effect from @var{channel}.
@end table

@noindent
Simple reverse stereo, swaps left and right channel sound.@*
@b{NOTE}: Using a @var{flip} of 0, will cause the effect to unregister itself from @var{channel}.  You cannot unregister it any other way, unless you use @code{Mix_UnregisterAllEffects} on the @var{channel}.

@noindent
@b{Returns}: Zero on errors, such as an invalid channel, or if @code{Mix_RegisterEffect} failed.

@cartouche
@example
// set the total mixer output to be reverse stereo
if(!Mix_SetReverseStereo(MIX_CHANNEL_POST, 1)) @{
    printf("Mix_SetReverseStereo: %s\n", Mix_GetError());
    // no reverse stereo, is it ok?
@}
@end example
@end cartouche

@noindent
@b{See Also}:@*
@ref{Mix_UnregisterAllEffects}

@c - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@page
@c =============================================================================
@node Types
@chapter Types

These types are defined and used by the SDL_mixer API.

@menu
* Mix_Chunk::               The internal format for an audio chunk
* Mix_Music::               The internal format for a music chunk
* Mix_MusicType::           Music type enumerations
* Mix_MIDI_Device::         MIDI sequencer type enumerations @b{[Mixer X]}
* Mix_ADLMIDI_VolumeModel:: Volume model of libADLMIDI MIDI sequencer @b{[Mixer X]}
* Mix_ADLMIDI_Emulator::    OPL3 chip emulators used by ADLMIDI @b{[Mixer X]}
* Mix_OPNMIDI_Emulator::    OPN2 chip emulators used by OPNMIDI @b{[Mixer X]}
* Mix_Fading::              Fader effect type enumerations
* Mix_EffectFunc_t::        Special effect callback function pointer
* Mix_EffectDone_t::        Special effect done callback function pointer
@end menu

@c -----------------------------------------------------------------------------
@page
@node Mix_Chunk
@section Mix_Chunk
@tindex Mix_Chunk

@cartouche
@example
typedef struct Mix_Chunk @{
    int @var{allocated};
    Uint8 *@var{abuf};
    Uint32 @var{alen};
    Uint8 @var{volume};     /* Per-sample volume, 0-128 */
@} Mix_Chunk;
@end example
@end cartouche

@table @var
@item allocated
a boolean indicating whether to free @var{abuf} when the chunk is freed.@*
0 if the memory was not allocated and thus not owned by this chunk.@*
1 if the memory was allocated and is thus owned by this chunk.
@item abuf
Pointer to the sample data, which is in the output format and sample rate.
@item alen
Length of @var{abuf} in bytes.
@item volume
0 = silent, 128 = max volume.  This takes effect when mixing.
@end table

@noindent
The internal format for an audio chunk.
This stores the sample data, the length in bytes of that data, and the volume to use
when mixing the sample.

@noindent
@b{See Also}:@*
@ref{Mix_VolumeChunk},
@ref{Mix_GetChunk},
@ref{Mix_LoadWAV},
@ref{Mix_LoadWAV_RW},
@ref{Mix_FreeChunk},
@ref{Mix_Music}

@c -----------------------------------------------------------------------------
@page
@node Mix_Music
@section Mix_Music
@tindex Mix_Music

@cartouche
@example
typedef struct _Mix_Music Mix_Music;
@end example
@end cartouche

This is an opaque data type used for Music data.
This should always be used as a pointer.
Who knows why it isn't a pointer in this typedef...

@noindent
@b{See Also}:@*
@ref{Mix_LoadMUS},
@ref{Mix_FreeMusic},
@ref{Mix_Chunk}

@c -----------------------------------------------------------------------------
@page
@node Mix_MusicType
@section Mix_MusicType
@tindex Mix_MusicType

@cartouche
@example
typedef enum @{
    MUS_NONE,
    MUS_CMD,
    MUS_WAV,
    MUS_MOD,
    MUS_MID,
    MUS_OGG,
    MUS_MP3, /* using SMPEG */
    MUS_MP3_MAD,
    MUS_FLAC,
    MUS_MODPLUG,
    MUS_SPC,/* Mixer X */
    MUS_GME = MUS_SPC,/* Mixer X */
    MUS_ADLMIDI,/* Mixer X */
    MUS_KnownCodecs/* Mixer X */
@} Mix_MusicType;
@end example
@end cartouche

Return values from @code{Mix_GetMusicType} are of these enumerated values.@*
If no music is playing then @b{MUS_NONE} is returned.@*
If music is playing via an external command then @b{MUS_CMD} is returned.@*
If music is playing via an Game Music Emulators then @b{MUS_GME} is returned.@*
@b{MUS_SPC} is legacy value added as single SPC playing support before GME was added. Use @b{MUS_GME} instead.@*
@b{MUS_KnownCodecs} is a count of known music codecs. Used internally.@*
Otherwise they are self explanatory.

@noindent
@b{See Also}:@*
@ref{Mix_GetMusicType}

@c -----------------------------------------------------------------------------
@page
@node Mix_MIDI_Device
@section Mix_MIDI_Device
@tindex Mix_MIDI_Device

@cartouche
@example
typedef enum @{
    MIDI_ADLMIDI,
    MIDI_Native,
    MIDI_Timidity,
    MIDI_OPNMIDI,
    MIDI_Fluidsynth,
    MIDI_KnuwnDevices
@} Mix_MIDI_Device;
@end example
@end cartouche

@c Return values from @code{Mix_GetMusicType} are of these enumerated values.@* @cNOT IMPLEMENTED YET
@b{MIDI_KnuwnDevices} is a count of known MIDI sequencers. Used internally.@*
Otherwise they are self explanatory.

@c -----------------------------------------------------------------------------
@page
@node Mix_ADLMIDI_VolumeModel
@section Mix_ADLMIDI_VolumeModel
@tindex Mix_ADLMIDI_VolumeModel

@cartouche
@example
typedef enum @{
    ADLMIDI_VM_AUTO,
    ADLMIDI_VM_GENERIC,
    ADLMIDI_VM_CMF,
    ADLMIDI_VM_DMX,
    ADLMIDI_VM_APOGEE,
    ADLMIDI_VM_9X
@} Mix_ADLMIDI_VolumeModel;
@end example
@end cartouche

@b{ADLMIDI_VM_AUTO} is automatical choice of volume model in dependence from selected bank.@*
Otherwise they are self explanatory.

@c -----------------------------------------------------------------------------
@page
@node Mix_ADLMIDI_Emulator
@section Mix_ADLMIDI_Emulator
@tindex Mix_ADLMIDI_Emulator

@cartouche
@example
typedef enum @{
    ADLMIDI_OPL3_EMU_DEFAULT = -1,
    ADLMIDI_OPL3_EMU_NUKED = 0,
    ADLMIDI_OPL3_EMU_NUKED_1_7_4,
    ADLMIDI_OPL3_EMU_DOSBOX,
@} Mix_ADLMIDI_Emulator;
@end example
@end cartouche

@b{ADLMIDI_OPL3_EMU_NUKED} is a Nuked OPL3 1.8 emulator which a very accurate, but needs a powerful CPU.@*
@b{ADLMIDI_OPL3_EMU_NUKED_1_7_4} is an unofficial optimized Nuked OPL3 1.7.4. Needs a powerful CPU.@*
@b{ADLMIDI_OPL3_EMU_DOSBOX} is a DosBox 0.74 emulator. Fast emulator.

@c -----------------------------------------------------------------------------
@page
@node Mix_OPNMIDI_Emulator
@section Mix_OPNMIDI_Emulator
@tindex Mix_OPNMIDI_Emulator

@cartouche
@example
typedef enum @{
    OPNMIDI_OPN2_EMU_DEFAULT = -1,
    OPNMIDI_OPN2_EMU_MIME = 0,
    OPNMIDI_OPN2_EMU_NUKED,
    OPNMIDI_OPN2_EMU_GENS,
@} Mix_OPNMIDI_Emulator;
@end example
@end cartouche

@b{OPNMIDI_OPN2_EMU_MIME} is a MIME YM2612 emulator, fast and well-accurate.@*
@b{OPNMIDI_OPN2_EMU_NUKED} is a Nuked OPN2 is a very accurate, but needs a VERY powerful CPU. It's much stronger even than Nuked OPL3!@*
@b{OPNMIDI_OPN2_EMU_GENS} is a GENS 2.10 emulator. Very outdated and inaccurate, but fastest.

@c -----------------------------------------------------------------------------
@page
@node Mix_Fading
@section Mix_Fading
@tindex Mix_Fading

@cartouche
@example
typedef enum @{
    MIX_NO_FADING,
    MIX_FADING_OUT,
    MIX_FADING_IN
@} Mix_Fading;
@end example
@end cartouche

Return values from @code{Mix_FadingMusic} and @code{Mix_FadingChannel} are of these enumerated values.
If no fading is taking place on the queried channel or music, then @b{MIX_NO_FADING} is returned.
Otherwise they are self explanatory.

@noindent
@b{See Also}:@*
@ref{Mix_FadingChannel},
@ref{Mix_FadingMusic}

@c -----------------------------------------------------------------------------
@page
@node Mix_EffectFunc_t
@section Mix_EffectFunc_t
@tindex Mix_EffectFunc_t

@cartouche
@example
typedef void (*Mix_EffectFunc_t)(int @var{chan}, void *@var{stream}, int @var{len},
                                 void *@var{udata});
@end example
@end cartouche

@table @var
@item chan
The channel number that this effect is effecting now.@*
@b{MIX_CHANNEL_POST} is passed in for post processing effects over the final mix.
@item stream
The buffer containing the current sample to process.
@item len
The length of @var{stream} in bytes.
@item udata
User data pointer that was passed in to @code{Mix_RegisterEffect} when registering this
effect processor function.
@end table

@noindent
This is the prototype for effect processing functions.
These functions are used to apply effects processing on a sample chunk.
As a channel plays a sample, the registered effect functions are called.
Each effect would then read and perhaps alter the @var{len} bytes of @var{stream}.
It may also be advantageous to keep the effect state in the @var{udata}, with would be setup when registering the effect function on a channel.

@noindent
@b{See Also}:@*
@ref{Mix_RegisterEffect}
@ref{Mix_UnregisterEffect}

@c -----------------------------------------------------------------------------
@page
@node Mix_EffectDone_t
@section Mix_EffectDone_t
@tindex Mix_EffectDone_t

@cartouche
@example
typedef void (*Mix_EffectDone_t)(int @var{chan}, void *@var{udata});
@end example
@end cartouche

@table @var
@item chan
The channel number that this effect is effecting now.@*
@b{MIX_CHANNEL_POST} is passed in for post processing effects over the final mix.
@item udata
User data pointer that was passed in to @code{Mix_RegisterEffect} when registering this
effect processor function.
@end table

@noindent
This is the prototype for effect processing functions.
This is called when a channel has finished playing, or halted, or is deallocated.
This is also called when a processor is unregistered while processing is active.
At that time the effects processing function may want to reset some internal variables
or free some memory.  It should free memory at least, because the processor could be freed after this call.

@noindent
@b{See Also}:@*
@ref{Mix_RegisterEffect}
@ref{Mix_UnregisterEffect}

@c -----------------------------------------------------------------------------
@page
@c =============================================================================
@node Defines
@chapter Defines

@table @b
@cindex MIX_MAJOR_VERSION
@cindex SDL_MIXER_MAJOR_VERSION
@item SDL_MIXER_MAJOR_VERSION
@code{1}@*
SDL_mixer library major number at compilation time
@cindex MIX_MINOR_VERSION
@cindex SDL_MIXER_MINOR_VERSION
@item SDL_MIXER_MINOR_VERSION
@code{2}@*
SDL_mixer library minor number at compilation time
@item SDL_MIXER_PATCHLEVEL
@cindex MIX_PATCHLEVEL
@cindex SDL_MIXER_PATCHLEVEL
@code{9}@*
SDL_mixer library patch level at compilation time
@item MIX_CHANNELS
@cindex MIX_CHANNELS
@code{8}@*
The default mixer has this many simultaneous mixing channels after the first
call to @code{Mix_OpenAudio}.
@item MIX_DEFAULT_FREQUENCY
@cindex MIX_DEFAULT_FREQUENCY
@code{44100}@*
Good default sample rate in Hz (samples per second) for PC sound cards.
@item MIX_DEFAULT_FORMAT
@cindex MIX_DEFAULT_FORMAT
@code{AUDIO_S16SYS}@*
The suggested default is signed 16bit samples in host byte order.
@item MIX_DEFAULT_CHANNELS
@cindex MIX_DEFAULT_CHANNELS
@code{2}@*
Stereo sound is a good default.
@item MIX_MAX_VOLUME
@cindex MIX_MAX_VOLUME
@code{128}@*
Maximum value for any volume setting.@*
This is currently the same as @b{SDL_MIX_MAXVOLUME}.
@item MIX_CHANNEL_POST
@cindex MIX_CHANNEL_POST
@code{-2}@*
This is the channel number used for post processing effects.
@item MIX_EFFECTSMAXSPEED
@cindex MIX_EFFECTSMAXSPEED
@code{"MIX_EFFECTSMAXSPEED"}@*
A convience definition for the string name of the environment variable to define
when you desire the internal effects to sacrifice quality and/or RAM for speed.
The environment variable must be set (else nonexisting) before @code{Mix_OpenAudio}
is called for the setting to take effect.
@end table

@c -----------------------------------------------------------------------------
@page
@c =============================================================================
@node Glossary
@chapter Glossary

@cartouche
@dfn{Byte Order}@*
@cindex Byte Order
@cindex MSB
@cindex LSB
@cindex Big-Endian
@cindex Little-Endian
Also known as @dfn{Big-Endian}.  Which means the most significant byte comes first in storage.  Sparc and Motorola 68k based chips are MSB ordered.@*
(SDL defines this as @b{SDL_BYTEORDER==SDL_BIG_ENDIAN})

@dfn{Little-Endian}(@acronym{LSB}) is stored in the opposite order, with the least significant byte first in memory.  Intel and AMD are two LSB machines.@*
(SDL defines this as @b{SDL_BYTEORDER==SDL_LIL_ENDIAN})
@end cartouche

@c -----------------------------------------------------------------------------
@page
@c =============================================================================
@contents

@c -----------------------------------------------------------------------------
@page
@c =============================================================================
@shortcontents

@c =============================================================================
@page
@node Index
@unnumbered Index

@printindex cp

@bye

