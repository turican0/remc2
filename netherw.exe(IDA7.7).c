/* This file was generated by the Hex-Rays decompiler version 7.7.0.220118.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Watcom C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __noreturn sub_10000(); // weak
__int16 sub_10010();
unsigned int __cdecl sub_10080(int a1, int a2);
int __cdecl sub_10100(int a1);
int __cdecl sub_10130(int a1, _DWORD *a2, _DWORD *a3);
unsigned __int8 sub_101C0();
int __cdecl sub_102D0(int a1, __int16 *a2, char a3);
int __cdecl sub_104A0(int a1);
int __cdecl sub_104D0(__int16 *a1);
int __cdecl sub_10590(char a1);
bool __cdecl sub_10630(_WORD *a1, __int16 *a2, _WORD *a3, __int16 *a4);
bool __cdecl sub_106C0(int a1, int a2);
bool __cdecl sub_106F0(_WORD *a1, int a2, _WORD *a3, int a4);
bool __cdecl sub_10750(int a1, int a2);
int __cdecl sub_10780(int a1);
int __cdecl sub_108B0(int a1);
int __cdecl sub_10A50(int a1);
int __cdecl sub_10B70(unsigned __int16 *a1, char a2, char a3);
int __cdecl sub_10C40(__int16 *a1);
int __cdecl sub_10C60(__int16 *a1);
int __cdecl sub_10C80(int a1, unsigned __int8 a2, unsigned __int16 a3);
int __cdecl sub_112D0(int a1, unsigned __int16 a2);
char __cdecl sub_11400(int a1, char a2, unsigned __int16 a3);
int __cdecl sub_116A0(int a1, char a2, unsigned __int16 a3);
int __cdecl sub_11900(int a1, int a2, unsigned __int8 a3, unsigned __int16 a4);
unsigned int __cdecl sub_11960(_WORD *a1);
char __cdecl sub_11A10(_WORD *a1);
char __cdecl sub_11C80(unsigned __int16 a1);
_BOOL1 __cdecl sub_11CB0(__int16 *a1);
_BOOL1 __cdecl sub_11E20(int a1, __int16 *a2);
_BOOL1 __cdecl sub_11E70(int a1, __int16 *a2);
int __cdecl sub_11EE0(int a1);
__int16 __cdecl sub_12100(int a1, int a2, char a3);
int __cdecl sub_122A0(int a1);
char *__cdecl sub_122C0(__int16 a1);
int __cdecl sub_12330(int a1, __int16 a2);
char __cdecl sub_12410(int a1, char a2);
int __cdecl sub_12470(int a1, char a2);
char __cdecl sub_12500(int a1);
char *sub_12780();
char *sub_12870();
int __cdecl sub_12910(unsigned int a1);
int __cdecl sub_12A70(unsigned int a1);
int __cdecl sub_12E70(int a1);
int __cdecl sub_12FF0(int a1);
// int __cdecl _nmemneed(_DWORD); weak
int __cdecl sub_13100(int a1);
int __cdecl sub_131F0(_WORD *a1);
int __cdecl sub_13270(int a1);
int __cdecl sub_133B0(int a1);
// int __cdecl _nmemneed_0(_DWORD); weak
int __cdecl sub_135C0(int a1);
int __cdecl sub_13710(int a1);
int __cdecl sub_13830(int a1);
int __cdecl sub_13850(int a1);
int __cdecl sub_13870(int a1);
int __fastcall nullsub_1(_DWORD); // weak
int __cdecl sub_13890(int a1);
int __cdecl sub_13B00(int a1);
int __cdecl sub_13C50(int a1);
unsigned int __cdecl sub_13CE0(int a1);
int __cdecl sub_13DC0(int a1);
int __cdecl sub_13E40(int a1);
int __cdecl sub_14030(int a1);
int __cdecl sub_14250(int a1);
int __cdecl sub_14530(int a1);
int __cdecl sub_14630(int a1);
unsigned int __cdecl sub_146C0(int a1, unsigned __int8 a2);
int __cdecl sub_146F0(int a1);
unsigned int __cdecl sub_148E0(int a1);
unsigned int __cdecl sub_14B10(int a1, unsigned __int8 a2);
unsigned int __cdecl sub_14BD0(int a1, int a2);
__int16 __cdecl sub_14C40(int a1);
bool __cdecl sub_14C60(int a1, int a2);
int __cdecl sub_14C90(int a1, int a2, signed int a3, signed int a4);
int __cdecl sub_14E10(int a1, unsigned __int8 a2);
unsigned int __cdecl sub_15170(int a1, unsigned __int8 a2);
int __cdecl sub_155E0(int a1);
bool __cdecl sub_156F0(int a1, unsigned __int8 a2);
bool __cdecl sub_15730(int a1, unsigned __int8 a2);
unsigned int __cdecl sub_15760(int a1, unsigned __int8 a2);
char __cdecl sub_15790(int a1);
char __cdecl sub_15910(_DWORD *a1);
void sub_159E0();
// unsigned int __usercall sub_15CB0@<eax>(unsigned int a1@<edi>, int a2);
int __cdecl sub_15D20(int a1);
// char __usercall sub_15D40@<al>(__int16 a1@<di>, int a2, int a3);
_BOOL1 __cdecl sub_15E60(int a1);
char sub_15EE0();
int __cdecl sub_15F20(int a1, __int16 a2, int a3);
int __cdecl sub_15FC0(_WORD *a1);
int __cdecl sub_161A0(int a1);
_BOOL1 __cdecl sub_164B0(int a1);
int __cdecl sub_16580(int a1);
// int __usercall sub_16730@<eax>(int a1@<edx>, int a2, char a3);
char __cdecl sub_169C0(int a1);
// int __usercall sub_16CA0@<eax>(int a1@<edx>, char *a2, __int16 a3, char a4);
int __cdecl sub_16E70(unsigned __int8 *a1, unsigned __int8 *a2);
unsigned int __cdecl sub_16FC0(int a1, int a2);
__int16 __cdecl sub_17060(__int16 a1, __int16 a2);
char sub_17190();
// char __usercall sub_17A00@<al>(_BYTE *a1@<ebx>, int a2@<edi>, __int16 a3@<si>);
int sub_18AA0();
char sub_18B30();
int sub_18BB0();
char __cdecl sub_18DA0(int a1, char a2, char a3);
char __cdecl sub_18F80(int a1);
char __cdecl sub_191B0(__int16 a1, char a2);
int __cdecl sub_19760(char *a1, unsigned __int8 a2, __int16 a3);
int sub_197F0();
__int64 sub_19A50();
char sub_19A70();
__int64 sub_19AB0();
void __cdecl sub_19CA0(unsigned __int8 a1);
// int __usercall sub_19D60@<eax>(int a1@<ebx>, int a2@<esi>);
char sub_19E00();
int sub_1A030();
// void __usercall sub_1A070(int a1@<edi>, __int16 a2@<si>);
int sub_1A280();
int sub_1A4A0();
int __cdecl sub_1A5B0(int a1, int *a2, int *a3);
int sub_1A7A0();
int sub_1A8A0();
char __cdecl sub_1A970(char a1, int a2, int a3);
int __cdecl sub_1B280(int a1);
int sub_1B5F0();
// __int16 __usercall sub_1B6B0@<ax>(__int16 result@<ax>, int a2);
signed int __cdecl sub_1B7A0(__int16 *a1);
signed int __cdecl sub_1B830(_WORD *a1);
int __cdecl sub_1B8C0(int a1);
int __cdecl sub_1BD90(int a1, char a2);
void __cdecl sub_1BF90(int a1, char a2);
int __cdecl sub_1C310(int a1, char a2, unsigned __int16 (__cdecl *a3)(int, int));
char __cdecl sub_1C560(int a1, unsigned __int16 a2);
int __cdecl sub_1C890(int a1, char a2);
void __cdecl sub_1C930(int a1);
int __cdecl sub_1C980(int a1, char a2);
int __cdecl sub_1CC20(_WORD *a1, unsigned int a2);
int __cdecl sub_1CCE0(_WORD *a1, unsigned int a2);
int __cdecl sub_1CDA0(_WORD *a1, unsigned int a2);
int __cdecl sub_1CE80(int a1, int a2);
int __cdecl sub_1CED0(int a1, int a2);
int __cdecl sub_1CF20(int a1, int a2);
int __cdecl sub_1D0E0(_WORD *a1, unsigned int a2);
int __cdecl sub_1D1A0(_WORD *a1, unsigned int a2);
int __cdecl sub_1D260(int a1, unsigned int a2);
int __cdecl sub_1D460(_WORD *a1, int a2);
void __cdecl sub_1D5D0(int a1, __int16 a2);
void __cdecl sub_1D700(int a1, __int16 a2);
void __cdecl sub_1D7C0(int a1, __int16 a2);
char __cdecl sub_1D880(int a1, __int16 a2);
char __cdecl sub_1D8A0(int a1, __int16 a2);
void __cdecl sub_1D8C0(int a1, __int16 a2);
int __cdecl sub_1DBF0(int a1, unsigned __int16 a2);
char __cdecl sub_1DDA0(int a1, __int16 a2);
char __cdecl sub_1E000(int a1, __int16 a2);
char __cdecl sub_1E020(int a1, __int16 a2);
int __cdecl sub_1E040(int a1, char a2);
char __cdecl sub_1E1C0(int a1, __int16 a2);
char __cdecl sub_1E320(int a1);
int __cdecl sub_1E3E0(int a1);
// int __usercall sub_1E4D0@<eax>(__int16 a1@<ax>, int a2);
void __cdecl sub_1E580(int a1, __int16 a2);
void __cdecl sub_1E700(int a1, char a2);
void __cdecl sub_1E9C0(int a1, __int16 a2);
int __cdecl sub_1ED30(int a1, int a2);
int __cdecl sub_1EEE0(int a1);
int __cdecl sub_1EF20(int a1);
// int __usercall sub_1EF40@<eax>(int a1@<esi>, _WORD *a2);
// int __usercall sub_1EF70@<eax>(int a1@<esi>, _WORD *a2);
// int __usercall sub_1EFD0@<eax>(int a1@<esi>, _WORD *a2);
int __cdecl sub_1F000(int a1);
void __cdecl sub_1F020(int a1);
int __cdecl sub_1F040(_WORD *a1);
// void __usercall sub_1F0C0(int a1@<esi>, int a2);
// int __usercall sub_1F300@<eax>(int a1@<esi>, int a2);
void __cdecl sub_1F340(int a1);
void __cdecl sub_1F3C0(int a1);
void __cdecl sub_1F440(int a1);
void __cdecl sub_1F470(int a1);
int __cdecl sub_1F4F0(int a1);
void __cdecl sub_1F510(int a1);
void __cdecl sub_1F530(int a1);
__int16 __cdecl sub_1F5B0(int a1);
int __cdecl sub_1F630(int a1);
void __cdecl sub_1F660(int a1);
void __cdecl sub_1F6D0(int a1);
char __cdecl sub_1F800(int a1);
int __cdecl sub_1F830(int a1);
void __cdecl sub_1F850(int a1);
void __cdecl sub_1F8A0(int a1);
int __cdecl sub_1F950(int a1);
void __cdecl sub_1F970(int a1);
void __cdecl sub_1F990(int a1);
char __cdecl sub_1F9E0(int a1);
int __cdecl sub_1FA00(int a1);
void __cdecl sub_1FA20(int a1);
void __cdecl sub_1FA50(int a1);
char __cdecl sub_1FA70(int a1);
char __cdecl sub_1FAA0(int a1);
unsigned int __cdecl sub_1FF40(int a1);
char __cdecl sub_1FFE0(int a1);
int __cdecl sub_20010(int a1);
void __cdecl sub_20040(int a1);
char __cdecl sub_20060(int a1);
_WORD *__cdecl sub_200F0(int a1);
void __cdecl sub_20140(int a1);
int __cdecl sub_20370(int a1);
void __cdecl sub_203D0(int a1);
void __cdecl sub_20940(int a1);
void __cdecl sub_20C50(int a1);
char __cdecl sub_20E50(int a1);
int __cdecl sub_20E80(int a1);
void __cdecl sub_20EA0(int a1);
char __cdecl sub_20EC0(int a1);
int __cdecl sub_20F20(int a1);
int __cdecl sub_20F60(int a1);
int __cdecl sub_20F80(int a1);
void __cdecl sub_20FC0(int a1);
__int16 __cdecl sub_21030(int a1);
char __cdecl sub_21490(int a1);
void __cdecl sub_21850(int a1);
void __cdecl sub_21AB0(int a1);
char __cdecl sub_21F60(int a1);
char __cdecl sub_22190(int a1);
char __cdecl sub_221F0(int a1, __int16 a2);
__int16 __cdecl sub_22270(int a1);
__int16 __cdecl sub_222B0(int a1);
unsigned int sub_223E0();
char __cdecl sub_22490(unsigned __int16 *a1);
int __cdecl sub_22530(int a1);
int __cdecl sub_22540(int a1);
int __cdecl sub_22550(int a1);
int __cdecl sub_22560(int a1);
void __cdecl sub_22580(int a1);
int __cdecl sub_225A0(int a1);
int __cdecl sub_225B0(int a1);
_BOOL1 __cdecl sub_22640(_WORD *a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4);
_WORD *__cdecl sub_226D0(unsigned __int16 a1, _WORD *a2, _WORD *a3);
char __cdecl sub_22760(int a1);
char __cdecl sub_22C80(int a1);
char __cdecl sub_22E60(int a1);
char __cdecl sub_23020(int a1);
int __cdecl sub_231E0(int a1);
void __cdecl sub_23200(int a1);
__int16 __cdecl sub_23260(int a1);
char __cdecl sub_232A0(int a1);
char sub_232C0();
char __cdecl sub_23320(int a1);
char __cdecl sub_23340(int a1);
char __cdecl sub_23640(int a1);
char __cdecl sub_23660(int a1);
int __cdecl sub_23680(int a1);
void __cdecl sub_236F0(int a1);
__int16 __cdecl sub_23710(int a1);
__int16 __cdecl sub_23750(int a1);
char __cdecl sub_23790(int a1);
char __cdecl sub_237B0(int a1);
char __cdecl sub_23AC0(int a1);
char __cdecl sub_23AE0(int a1);
int __cdecl sub_23B00(int a1);
void __cdecl sub_23B30(int a1);
__int16 __cdecl sub_23B90(int a1);
__int16 __cdecl sub_23BD0(int a1);
int __cdecl sub_23C20(int a1);
void __cdecl sub_23C40(int a1);
void __cdecl sub_23E60(int a1);
char __cdecl sub_240A0(int a1);
int __cdecl sub_240C0(int a1);
void __cdecl sub_240E0(int a1);
int __cdecl sub_24100(_WORD *a1);
int __cdecl sub_24150(_WORD *a1);
int __cdecl sub_24190(int a1);
void __cdecl sub_24400(int a1);
int __cdecl sub_24420(int a1);
void __cdecl sub_24440(int a1);
__int16 __cdecl sub_24510(int a1);
char __cdecl sub_247D0(int a1);
int __cdecl sub_247F0(int a1);
void __cdecl sub_24810(int a1);
void __cdecl sub_24840(int a1);
unsigned int __cdecl sub_24860(int a1);
void __cdecl sub_248C0(int a1);
__int16 __cdecl sub_24930(int a1);
char __cdecl sub_24D40(int a1);
int __cdecl sub_24DA0(int a1);
void __cdecl sub_24DC0(int a1);
void __cdecl sub_24DF0(int a1);
int __cdecl sub_24E20(int a1);
int __cdecl sub_25050(int a1);
__int16 __cdecl sub_250B0(int a1);
// int __usercall sub_25280@<eax>(int a1@<eax>, int a2);
int __cdecl sub_252A0(int a1);
void __cdecl sub_252C0(int a1);
unsigned int __cdecl sub_252E0(int a1);
// int __usercall sub_253B0@<eax>(int result@<eax>, int a2, unsigned __int8 a3, unsigned __int8 a4);
int __cdecl sub_254E0(int a1, int a2, unsigned __int8 a3);
int __cdecl sub_25550(int a1);
int __cdecl sub_25590(int a1);
void __cdecl sub_255C0(int a1);
void __cdecl sub_25610(int a1);
char __cdecl sub_25CD0(int a1);
int __cdecl sub_25D00(int a1);
void __cdecl sub_25D20(int a1);
void __cdecl sub_25D50(int a1);
unsigned int __cdecl sub_25D80(int a1);
void __cdecl sub_25DE0(int a1);
void __cdecl sub_25E40(int a1);
char __cdecl sub_25F70(int a1);
int __cdecl sub_25FD0(int a1);
void __cdecl sub_25FF0(int a1);
void __cdecl sub_26020(int a1);
int __cdecl sub_26050(int a1);
char __cdecl sub_26070(int a1);
// unsigned int __usercall sub_26220@<eax>(unsigned int a1@<esi>, int a2);
int __cdecl sub_263C0(int a1);
int __cdecl sub_263E0(int a1);
void __cdecl sub_26400(int a1);
int __cdecl sub_26470(_BYTE *a1);
// int __usercall sub_26500@<eax>(int result@<eax>, int a2);
int __cdecl sub_265A0(int a1);
int __cdecl sub_26830(int a1);
int __cdecl sub_268F0(int a1, unsigned __int8 a2);
char __cdecl sub_26930(int a1);
void __cdecl sub_26960(int a1);
int __cdecl sub_26990(int a1);
void __cdecl sub_26AA0(int a1);
void __cdecl sub_26BD0(int a1);
int __cdecl sub_26CA0(int a1);
int __cdecl sub_26CC0(int a1);
int __cdecl sub_26D20(int a1);
int __cdecl sub_26F10(int a1);
__int16 __cdecl sub_26FF0(int a1);
int __cdecl sub_27120(int a1);
int __cdecl sub_271D0(int a1);
char __cdecl sub_272C0(int a1);
int __cdecl sub_273C0(__int16 a1, char a2, __int16 a3, __int16 a4);
int __cdecl sub_27430(int a1);
int __cdecl sub_27470(int a1, __int16 a2);
int __cdecl sub_274C0(int a1, int a2, _WORD *a3, __int16 a4);
// int __usercall sub_27590@<eax>(int a1@<ebx>, int a2);
// int __usercall sub_27610@<eax>(int a1@<ebx>, int a2);
int __cdecl sub_276E0(int a1);
void __cdecl sub_27720(int a1, __int16 a2);
void __cdecl sub_27880(int a1);
int __cdecl sub_278F0(int a1, __int16 a2, __int16 a3);
void __cdecl sub_27930(int a1);
char __cdecl sub_27950(int a1);
char __cdecl sub_27B20(int a1);
char __cdecl sub_27C10(int a1);
char __cdecl sub_27E00(int a1);
int __cdecl sub_27FA0(int a1);
void __cdecl sub_27FC0(int a1);
int __cdecl sub_27FE0(int a1, char a2, char a3, int a4);
unsigned int __cdecl sub_28000(int a1);
char __cdecl sub_28060(int a1);
char __cdecl sub_28110(int a1);
unsigned int __cdecl sub_282D0(int a1);
char __cdecl sub_28390(_WORD *a1, int a2);
int __cdecl sub_28420(int a1);
void __cdecl sub_28470(int a1);
int __cdecl sub_28490(int a1);
int __cdecl sub_28500(int a1);
int __cdecl sub_28570(int a1);
int __cdecl sub_285D0(int a1);
int __cdecl sub_285F0(int a1);
void __cdecl sub_28610(int a1);
int __cdecl sub_28630(int a1);
int __cdecl sub_28660(int a1);
void __cdecl sub_28690(int a1);
int __cdecl sub_287B0(int a1);
__int16 __cdecl sub_28860(int a1);
int __cdecl sub_28C30(int a1);
int __cdecl sub_28C60(int a1);
int __cdecl sub_28CC0(int a1);
int __cdecl sub_28CE0(int a1);
void __cdecl sub_28EC0(int a1);
void __cdecl sub_28F50(int a1);
int __cdecl sub_28F90(int a1);
int __cdecl sub_28FC0(int a1);
int __cdecl sub_28FF0(int a1);
int __cdecl sub_29300(int a1);
int __cdecl sub_29330(int a1);
void __cdecl sub_29350(int a1);
int __cdecl sub_29380(int a1);
int __cdecl sub_293B0(int a1);
int __cdecl sub_293D0(int a1);
unsigned __int16 __cdecl sub_29400(int a1);
unsigned __int16 __cdecl sub_29670(int a1);
unsigned __int16 __cdecl sub_29710(int a1);
unsigned __int16 __cdecl sub_29890(int a1);
int __cdecl sub_298B0(int a1);
int __cdecl sub_298D0(unsigned int a1);
unsigned __int16 __cdecl sub_29930(int a1);
unsigned __int16 __cdecl sub_29A90(int a1);
char __cdecl sub_2A340(int a1, int a2);
int __cdecl sub_2A5B0(int a1, int a2, __int16 a3);
int __cdecl sub_2A660(int a1, int a2);
int __cdecl sub_2A6B0(int a1);
unsigned int __cdecl sub_2A6F0(int a1);
int __cdecl sub_2A7B0(int a1);
void __cdecl sub_2A7F0(int a1, int a2, char a3);
int __cdecl sub_2A940(int a1, int a2);
int __cdecl sub_2A9F0(int a1, int a2);
// unsigned __int16 __usercall sub_2AA90@<ax>(int a1@<ebx>, int a2, int a3);
_WORD *__cdecl sub_2AC50(int a1);
unsigned __int16 __cdecl sub_2AD40(int a1);
int __cdecl sub_2AE30(int a1);
int __cdecl sub_2AE80(unsigned int a1);
char __cdecl sub_2AED0(int a1, int a2);
char __cdecl sub_2AF10(int a1, char a2);
int __cdecl sub_2B1D0(int a1);
void __cdecl sub_2B200(int a1);
char __cdecl sub_2B260(int a1);
int __cdecl sub_2B750(int a1);
int __cdecl sub_2B760(int a1);
void __cdecl sub_2B780(int a1);
void __cdecl sub_2B7B0(int a1);
char __cdecl sub_2B7E0(int a1);
int __cdecl sub_2B840(int a1);
char __cdecl sub_2B860(int a1, unsigned __int8 a2);
int __cdecl sub_2B9A0(int a1);
unsigned __int8 __cdecl sub_2BA50(int a1, unsigned __int8 a2);
// int _wcpp_1_unwind_leave__62(void); weak
int __cdecl sub_2BB40(__int16 a1, __int16 a2, int a3);
int __cdecl sub_2BBB0(__int16 a1, __int16 a2, int a3);
int __cdecl sub_2BC10(_BYTE *a1, __int16 a2, __int16 a3, unsigned __int8 a4);
int __cdecl sub_2BC80(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5);
int __cdecl sub_2BD10(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5);
int sub_2BE30();
int __cdecl sub_2CA60(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
int __cdecl sub_2CA90(__int16 a1);
__int16 __cdecl sub_2CB30(_DWORD *a1, __int16 a2, __int16 a3, __int16 a4);
int __cdecl sub_2CE30(__int16 a1, int a2);
int __cdecl sub_2D190(__int16 a1, __int16 a2, int a3, __int16 a4, int a5, unsigned __int8 a6);
int sub_2D1D0();
int __cdecl sub_2D710(int a1);
char __cdecl sub_2DE80(__int16 a1, __int16 a2, int a3);
char __cdecl sub_2DFD0(__int16 a1, __int16 a2, int a3, unsigned __int8 a4);
void __cdecl sub_2E260(__int16 a1, __int16 a2, unsigned int a3, char a4);
int __cdecl sub_2E790(__int16 a1, int a2, __int16 a3, __int16 a4, unsigned __int8 a5);
int __cdecl sub_2E850(__int16 a1, int a2, __int16 a3, __int16 a4, unsigned __int8 a5);
int sub_2EB40();
int sub_2EB60();
int __cdecl sub_2EBB0(_BYTE *a1);
int sub_2EC30();
int sub_2EC60();
char __cdecl sub_2EC90(char a1);
__int16 sub_2ECC0();
int sub_2F6B0();
char sub_2FD90();
int *__cdecl sub_2FFE0(int *a1, int *a2, _DWORD *a3, _DWORD *a4);
int sub_30050();
// int __usercall sub_303D0@<eax>(int a1@<edi>);
int sub_30630();
char sub_30870();
int __cdecl sub_30A60(__int16 a1, __int16 a2);
_DWORD *__cdecl sub_30BE0(_DWORD *a1, _DWORD *a2);
void __cdecl sub_30D50(int a1);
unsigned int __cdecl sub_30F60(int a1);
int __cdecl sub_31100(int a1);
int __cdecl sub_31120(int a1);
char __cdecl sub_311E0(int a1);
char __cdecl sub_31760(int a1);
int __cdecl sub_31870(int a1);
int __cdecl sub_31890(int a1);
void __cdecl sub_318B0(int a1);
int __cdecl sub_31920(int a1);
char __cdecl sub_31940(int a1);
int __cdecl sub_31E90(__int16 *a1);
int __cdecl sub_31F00(__int16 *a1, __int16 a2, __int16 a3);
void __cdecl sub_31FB0(int a1);
int __cdecl sub_320E0(int a1);
int __cdecl sub_32120(int a1);
int __cdecl sub_32160(int a1);
int __cdecl sub_322A0(int a1);
char __cdecl sub_323E0(int a1);
char __cdecl sub_32400(int a1);
char __cdecl sub_32420(int a1);
int __cdecl sub_32530(int a1);
__int16 __cdecl sub_32600(int a1);
int __cdecl sub_32880(int a1);
void __cdecl sub_32A70(int a1);
void __cdecl sub_32CF0(int a1);
int __cdecl sub_32F40(int a1);
void __cdecl sub_33110(unsigned int a1);
_WORD *__cdecl sub_331A0(int a1);
void __cdecl sub_33340(_WORD *a1);
void __cdecl sub_33710(int a1);
char __cdecl sub_33810(int a1, int a2);
unsigned int __cdecl sub_338D0(unsigned int a1);
char __cdecl sub_339B0(int a1);
int __cdecl sub_33AD0(int a1);
__int16 __cdecl sub_33B20(int a1);
int __cdecl sub_33C00(int a1);
int __cdecl sub_33C70(int a1);
int __cdecl sub_33D40(int a1);
void __cdecl sub_33D80(int a1);
void __cdecl sub_33E20(int a1);
int __cdecl sub_33E80(int a1);
_BOOL1 __cdecl sub_33F70(unsigned __int16 a1);
int __cdecl sub_34000(int a1);
int __cdecl sub_34110(_WORD *a1);
int __cdecl sub_34210(_WORD *a1);
int __cdecl sub_34330(int a1);
int __cdecl sub_34350(int a1);
int __cdecl sub_34390(int a1);
int __cdecl sub_343C0(int a1);
int __cdecl sub_343F0(_WORD *a1);
int __cdecl sub_34480(int a1);
_WORD *__cdecl sub_344A0(int a1);
int __cdecl sub_34520(int a1);
int __cdecl sub_34540(int a1);
int __cdecl sub_34910(int a1);
int __cdecl sub_34B00(char a1, char a2, __int16 a3, __int16 a4);
char __cdecl sub_34C40(int a1);
// void __usercall sub_34EE0(int a1@<edi>, int a2@<esi>, int a3);
int __cdecl sub_352A0(int a1);
_WORD *__cdecl sub_352C0(int a1);
void __cdecl sub_35390(int a1);
unsigned int __cdecl sub_35530(int a1);
int __cdecl sub_35600(int a1);
void __cdecl sub_35640(int a1);
int __cdecl sub_357C0(int a1);
void __cdecl sub_35940(int a1);
int sub_365F8(); // weak
char __cdecl sub_36680(int a1);
void __cdecl sub_36770(_WORD *a1);
char __cdecl sub_36850(int a1);
// __int16 __usercall sub_36920@<ax>(__int16 a1@<bx>, int a2);
// int __usercall sub_369F0@<eax>(int a1@<ebx>, __int16 a2);
// int __usercall sub_36A50@<eax>(int a1@<ebx>, char a2);
int __cdecl sub_36AE0(__int16 *a1);
void __cdecl sub_36BA0(int a1, char a2);
int __cdecl sub_36D50(int a1, int a2);
int __cdecl sub_36F30(int a1, int a2);
char __cdecl sub_36FC0(int a1);
void __cdecl sub_37240(int a1);
char __cdecl sub_37740(int a1);
void __cdecl sub_377A0(int a1);
__int16 __cdecl sub_377F0(int a1);
__int16 __cdecl sub_37BC0(int a1);
int __cdecl sub_38270(int a1);
int __cdecl sub_38330(int a1);
int __cdecl sub_385C0(int a1);
int __cdecl sub_389F0(int a1);
int __cdecl sub_38B00(int a1);
int __cdecl sub_38B90(int a1);
signed int __cdecl sub_38D80(int a1);
int __cdecl sub_38E20(int a1);
int __cdecl sub_38E40(int a1);
int __cdecl sub_38E70(int a1);
int __cdecl sub_38F70(_WORD *a1);
char __cdecl sub_39040(int a1);
int __cdecl sub_396A0(int a1);
unsigned __int8 __cdecl sub_396D0(int a1);
int __cdecl sub_39B60(int a1);
char __cdecl sub_39E40(int a1);
char __cdecl sub_39FA0(int a1, int a2);
void __cdecl sub_3A090(unsigned __int16 *a1);
void __cdecl sub_3A200(int a1, int a2);
void __cdecl sub_3A2D0(int a1);
void __cdecl sub_3A5B0(int a1);
int __cdecl sub_3A630(int a1);
int __cdecl sub_3A650(int a1);
char __cdecl sub_3A7F0(_BYTE *a1);
char __cdecl sub_3A8B0(int a1);
int __cdecl sub_3AF00(int a1);
int *__cdecl sub_3B4D0(int a1);
_DWORD *__cdecl sub_3B560(__int16 a1);
// char __usercall sub_3C080@<al>(int a1@<ebx>, int a2@<esi>, __int16 a3, __int16 a4, __int16 a5, int a6, int a7, __int16 a8, int a9);
// unsigned __int16 __usercall sub_3E360@<ax>(int a1@<esi>, int a2);
// unsigned __int16 __usercall sub_3FD60@<ax>(int a1@<edi>, int a2);
__int16 __cdecl sub_40950(__int16 a1);
int __cdecl sub_40BF0(int a1, int a2, int a3, int a4);
int __cdecl sub_40C50(int a1);
int __fastcall sub_40D10(int a1);
void sub_40F80();
char __cdecl sub_411A0(int a1, int a2, int a3, __int16 a4, int a5, int a6, __int16 a7, int a8);
__int16 sub_417A0();
__int16 sub_417D0();
unsigned __int8 __cdecl sub_41A90(unsigned __int8 *a1);
unsigned __int8 sub_41AF0();
char sub_41B60();
__int64 sub_41BC0();
__int16 __cdecl sub_41BD3(unsigned int a1);
// int __usercall sub_43830@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_43970@<eax>(int a1@<esi>);
// unsigned int __usercall sub_439A0@<eax>(int a1@<esi>, unsigned __int16 a2);
__int16 sub_43B40();
__int16 sub_43BB0();
void __cdecl sub_43C60(unsigned __int8 a1, char a2, int a3, int a4);
unsigned __int16 sub_43D50();
unsigned __int16 sub_43EE0();
unsigned __int16 sub_43FC0();
unsigned __int16 __cdecl sub_440D0(unsigned __int16 a1);
unsigned __int16 sub_44320();
__int16 sub_44580();
int sub_44D00();
int sub_44DB0();
unsigned __int16 __cdecl sub_44E40(int a1, unsigned __int8 a2);
// unsigned __int16 __usercall sub_44EE0@<ax>(int a1@<ebx>, int a2);
unsigned __int8 __cdecl sub_45060(unsigned __int8 a1, unsigned __int8 a2);
char __cdecl sub_45210(unsigned __int8 a1, unsigned __int8 a2);
unsigned __int16 __cdecl sub_454F0(unsigned __int8 a1, unsigned __int8 a2);
unsigned __int16 __cdecl sub_45600(unsigned __int8 a1);
unsigned __int16 sub_45AA0();
// char __usercall sub_45BE0@<al>(char a1@<dl>, char a2@<cl>, unsigned __int16 a3);
// char __usercall sub_45DC0@<al>(char a1@<dl>, char a2@<cl>, unsigned __int16 a3, unsigned __int8 a4);
unsigned __int16 __cdecl sub_46180(unsigned __int16 a1, char a2);
char __cdecl sub_462A0(unsigned __int16 a1, __int16 a2);
char __cdecl sub_46570(unsigned __int16 a1, __int16 a2);
int sub_46820();
// int __usercall sub_46830@<eax>(__int16 *a1@<ebx>, int a2@<edi>, unsigned __int16 a3@<si>);
void sub_46B40();
char __fastcall sub_46DD0(int a1, unsigned __int16 a2, int a3, int a4);
void sub_46F50();
unsigned int *sub_46F80();
void sub_47130();
unsigned int *sub_47160();
// int __usercall sub_47320@<eax>(int a1@<edi>);
int sub_473B0();
int sub_473E0();
// void __usercall sub_47560(_BYTE *a1@<ebx>, int a2@<edi>, __int16 a3@<si>);
int __fastcall sub_47650(int a1, int a2);
char sub_47760();
int __cdecl sub_47FC0(char a1);
char sub_480A0();
char sub_48120();
int sub_48350();
int __cdecl sub_48370(__int16 a1, __int16 a2, __int16 a3);
int __cdecl sub_483A0(__int16 a1, int a2, char a3, char a4);
int __cdecl sub_48400(__int16 a1, int a2, __int16 a3, int a4);
int __cdecl sub_48690(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
int __cdecl sub_487D0(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4, char a5);
int __cdecl sub_48880(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4);
int sub_48930(); // weak
unsigned int __cdecl sub_48990(char a1, char a2, char a3, char a4);
// __int16 __usercall sub_48A20@<ax>(int a1@<edi>, char a2, char a3, int a4, int a5, unsigned __int8 a6);
__int16 __cdecl sub_48B50(unsigned __int8 a1, char a2, int a3, int a4);
__int16 __cdecl sub_48B90(int a1);
__int16 __cdecl sub_48D20(int a1, unsigned __int16 a2);
__int16 __cdecl sub_48DF0(char a1, char a2, char a3, char a4);
int __cdecl sub_48E60(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4);
int __cdecl sub_48E90(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4);
int __cdecl sub_48EC0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4);
int __cdecl sub_48EF0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4);
int __cdecl sub_48F20(char a1, char a2, __int16 a3, unsigned __int16 a4, int a5);
int __cdecl sub_48FD0(char a1, char a2, __int16 a3, unsigned __int16 a4, int a5);
void __cdecl sub_49090(int a1, _WORD *a2);
int __cdecl sub_49270(int a1);
int __cdecl sub_49290(int a1, char a2);
void __cdecl sub_49540(int a1, int a2);
int __cdecl sub_49830(int a1);
int sub_498A0();
int __cdecl sub_49A20(int a1);
__int16 __cdecl sub_49A30(int a1, unsigned __int16 a2);
int __cdecl sub_49C70(int a1);
char __cdecl sub_49C90(int a1, __int16 a2);
int __cdecl sub_49CD0(_WORD *a1, __int16 a2);
int __cdecl sub_49D50(int a1, __int16 a2);
int __cdecl sub_49DA0(_WORD *a1, __int16 a2);
int __cdecl sub_49E10(_WORD *a1, __int16 a2);
_WORD *__cdecl sub_49EA0(_WORD *a1, __int16 a2, __int16 a3);
unsigned int __cdecl sub_49EC0(_WORD *a1, __int16 a2);
int sub_49F30();
int __fastcall sub_49F90(__int16 a1);
int sub_4A050();
int __cdecl sub_4A190(int a1, int a2, int a3);
// int __usercall sub_4A1E0@<eax>(__int16 a1@<ax>, int a2, char a3);
int __cdecl sub_4A310(unsigned __int16 *a1);
int sub_4A810();
int __cdecl sub_4A820(int a1);
int __cdecl sub_4A840(int a1);
int __cdecl sub_4A860(int a1);
int __cdecl sub_4A880(int a1);
int __cdecl sub_4A8A0(int a1);
int __cdecl sub_4A8C0(int a1);
int __cdecl sub_4A8E0(int a1);
int __cdecl sub_4A900(int a1);
_WORD *__cdecl sub_4A920(int a1);
_WORD *__cdecl sub_4A9C0(int a1);
int __cdecl sub_4AA40(int a1);
int __cdecl sub_4ABA0(int a1);
int __cdecl sub_4AC40(int *a1);
_WORD *__cdecl sub_4AD70(int a1);
_WORD *__cdecl sub_4ADF0(int a1);
_WORD *__cdecl sub_4AE80(int a1);
_WORD *__cdecl sub_4AF00(int a1);
_WORD *__cdecl sub_4AF70(int a1);
int __cdecl sub_4AFE0(int *a1);
int __cdecl sub_4B0F0(int *a1);
int __cdecl sub_4B120(int *a1);
int __cdecl sub_4B150(int *a1, char a2, char a3, __int16 a4);
_DWORD *__cdecl sub_4B240(int a1);
int __cdecl sub_4B490(int a1);
int __cdecl sub_4B590(int a1);
int __cdecl sub_4B6F0(int a1);
int __cdecl sub_4BA10(int a1);
int __cdecl sub_4BBB0(int a1);
int __cdecl sub_4BD00(int a1);
int __cdecl sub_4BDF0(int a1);
int __cdecl sub_4C0B0(int a1);
int __cdecl sub_4C1E0(int a1);
int __cdecl sub_4C310(int a1);
int __cdecl sub_4C460(int a1);
int __cdecl sub_4C590(int a1);
int __cdecl sub_4C6B0(int a1);
int __cdecl sub_4C7F0(int a1);
int __cdecl sub_4C8F0(int a1);
int __cdecl sub_4CA00(int a1);
int __cdecl sub_4CB60(int a1);
int __cdecl sub_4CBF0(int a1);
int __cdecl sub_4CCF0(int a1);
int __cdecl sub_4CE00(int a1);
int __cdecl sub_4CF00(int a1);
// unsigned int __usercall sub_4D000@<eax>(unsigned int a1@<esi>, int a2);
int __cdecl sub_4D1D0(int a1);
int __cdecl sub_4D2E0(int a1);
int __cdecl sub_4D380(int a1);
int __cdecl sub_4D3B0(int a1);
int __cdecl sub_4D470(int a1);
int __cdecl sub_4D500(int a1);
int __cdecl sub_4D590(int a1);
int __cdecl sub_4D620(int a1);
int __cdecl sub_4D6B0(int a1);
int __cdecl sub_4D740(int a1);
int __cdecl sub_4D7D0(int a1);
int __cdecl sub_4D860(int a1);
int __cdecl sub_4D900(int a1);
int __cdecl sub_4D990(int a1);
int __cdecl sub_4DA20(int a1);
_WORD *__cdecl sub_4DAB0(int a1);
_WORD *__cdecl sub_4DBC0(int a1);
_WORD *__cdecl sub_4DC40(int a1);
_WORD *__cdecl sub_4DCC0(int a1);
_WORD *__cdecl sub_4DD50(int a1);
int __cdecl sub_4DDD0(int a1);
int __cdecl sub_4DEA0(int a1);
int __cdecl sub_4DF30(int a1);
int __cdecl sub_4DFC0(int a1);
int __cdecl sub_4E050(int a1);
int __cdecl sub_4E0F0(int a1);
int __cdecl sub_4E180(int a1);
int __cdecl sub_4E210(int a1);
int __cdecl sub_4E2A0(int a1);
_WORD *__cdecl sub_4E320(int a1);
_WORD *__cdecl sub_4E3B0(int a1);
int __cdecl sub_4E430(int a1);
int __cdecl sub_4E490(int a1);
int __cdecl sub_4E500(int a1);
int __cdecl sub_4E570(int a1);
int __cdecl sub_4E5F0(__int16 *a1);
int __cdecl sub_4E6A0(__int16 *a1);
int __cdecl sub_4E760(int a1);
_WORD *__cdecl sub_4E7D0(int a1);
int __cdecl sub_4E840(int a1);
int __cdecl sub_4E8C0(int a1);
int __cdecl sub_4E950(int a1);
int __cdecl sub_4E9E0(int a1);
int __cdecl sub_4EA20(int a1);
int __cdecl sub_4EA60(int a1);
int __cdecl sub_4EAA0(int a1, char a2, char a3, __int16 a4, int a5);
int __cdecl sub_4EB50(int a1);
int __cdecl sub_4EC10(int a1);
int __cdecl sub_4ECD0(int a1);
int __cdecl sub_4ED70(int a1);
int __cdecl sub_4EDC0(__int16 *a1);
int __cdecl sub_4EED0(int a1);
int __cdecl sub_4EF30(int a1);
int __cdecl sub_4EF90(int a1);
_WORD *__cdecl sub_4F040(int a1);
unsigned __int16 __cdecl sub_4F1C0(_WORD *a1);
_WORD *__cdecl sub_4F2A0(int a1);
__int16 __cdecl sub_4F440(int a1);
int __cdecl sub_4F5F0(int a1);
_WORD *__cdecl sub_4F6A0(int a1);
_WORD *__cdecl sub_4F720(int a1);
int __cdecl sub_4F7A0(int a1);
int __cdecl sub_4F800(int a1);
int __cdecl sub_4F860(int a1);
int __cdecl sub_4F8B0(int a1);
int __cdecl sub_4F900(int a1);
int __cdecl sub_4F950(int a1);
int __cdecl sub_4F9A0(int a1);
int __cdecl sub_4FA00(int a1);
int __cdecl sub_4FA60(int a1);
int __cdecl sub_4FAC0(int a1);
int __cdecl sub_4FB20(int a1);
int __cdecl sub_4FB80(int a1);
int __cdecl sub_4FBE0(int a1);
int __cdecl sub_4FC30(int a1);
int __cdecl sub_4FCA0(int a1);
int __cdecl sub_4FCD0(int a1);
int __cdecl sub_4FD00(int a1);
int __cdecl sub_4FD70(int a1);
int __cdecl sub_4FDE0(int a1);
_WORD *__cdecl sub_4FE40(int a1);
int sub_4FF20();
_WORD *__cdecl sub_4FF30(int a1);
int __cdecl sub_4FFB0(int a1);
_WORD *__cdecl sub_50020(int a1);
int __cdecl sub_50080(int a1);
int __cdecl sub_500A0(int a1);
int __cdecl sub_500C0(int a1, __int16 a2);
int __cdecl sub_50130(int a1);
_WORD *__cdecl sub_501D0(int a1);
_WORD *__cdecl sub_50250(int a1);
_WORD *__cdecl sub_502B0(int a1);
int __cdecl sub_50320(int a1);
int __cdecl sub_50370(int a1);
_WORD *__cdecl sub_503D0(int a1);
_WORD *__cdecl sub_50430(int a1);
int __cdecl sub_504B0(int a1);
int __cdecl sub_50500(int a1);
int __cdecl sub_505A0(int a1);
int __cdecl sub_505E0(int a1);
int __cdecl sub_50640(int a1);
int __cdecl sub_506E0(int a1);
int __cdecl sub_50780(int a1);
int __cdecl sub_507C0(int a1);
_BYTE *sub_50800();
_WORD *__cdecl sub_50840(int a1);
int __cdecl sub_508E0(int a1);
int __cdecl sub_50960(int a1);
int __cdecl sub_50A20(int a1);
int __cdecl sub_50A90(int a1, char a2, char a3);
int __cdecl sub_50AE0(int a1);
int __cdecl sub_50B00(int a1);
int __cdecl sub_50B20(int a1);
int __cdecl sub_50B40(int a1);
int __cdecl sub_50B60(int a1);
int __cdecl sub_50B80(int a1);
int __cdecl sub_50C10(int a1);
int __cdecl sub_50C30(int a1);
int __cdecl sub_50C50(int a1);
int __cdecl sub_50C70(int a1);
int __cdecl sub_50C90(int a1);
int __cdecl sub_50CB0(int a1);
int __cdecl sub_50CD0(int a1);
int __cdecl sub_50CF0(int a1);
int __cdecl sub_50D10(int a1);
int __cdecl sub_50D30(int a1);
int __cdecl sub_50D50(int a1);
int __cdecl sub_50D70(int a1);
int __cdecl sub_50D90(int a1);
int __cdecl sub_50DB0(int a1);
int __cdecl sub_50DD0(int a1);
int __cdecl sub_50DF0(int a1);
int __cdecl sub_50E10(int a1);
int __cdecl sub_50E30(int a1);
int __cdecl sub_50E50(int a1);
int __cdecl sub_50E70(int a1);
int __cdecl sub_50E90(int a1);
int __cdecl sub_50EB0(int a1);
int __cdecl sub_50ED0(int a1);
int __cdecl sub_50EF0(int a1);
int __cdecl sub_50F10(int a1);
int __cdecl sub_50F30(int a1);
int __cdecl sub_50F50(int a1);
int __cdecl sub_50F70(int a1);
int __cdecl sub_50F90(int a1);
int __cdecl sub_50FB0(int a1);
int __cdecl sub_50FD0(int a1);
int __cdecl sub_50FF0(int a1);
int __cdecl sub_51120(int a1, char a2, char a3);
int __cdecl sub_511A0(int a1);
int __cdecl sub_511C0(int a1);
int __cdecl sub_511E0(int a1);
int __cdecl sub_51200(int a1);
int __cdecl sub_51220(int a1);
int __cdecl sub_51240(int a1);
int __cdecl sub_51260(int a1);
int __cdecl sub_51280(int a1);
int __cdecl sub_512A0(int a1);
int __cdecl sub_512C0(int a1);
int __cdecl sub_512E0(int a1);
int __cdecl sub_51300(int a1);
int __cdecl sub_51320(int a1);
int __cdecl sub_51340(int a1);
int __cdecl sub_51360(int a1);
int __cdecl sub_51380(int a1);
int __cdecl sub_513A0(int a1);
int __cdecl sub_513C0(int a1);
int __cdecl sub_513E0(int a1);
int __cdecl sub_51400(int a1);
int __cdecl sub_51420(int a1);
int __cdecl sub_51440(int a1);
int __cdecl sub_51460(int a1);
int __cdecl sub_51480(int a1);
int __cdecl sub_514A0(int a1);
int __cdecl sub_514C0(int a1);
int __cdecl sub_514E0(int a1, char a2, char a3, __int16 a4);
_WORD *__cdecl sub_51530(int a1);
int __cdecl sub_51570(int a1);
int __cdecl sub_515C0(int a1);
_WORD *__cdecl sub_51610(int a1);
int __cdecl sub_51660(int a1);
int __cdecl sub_516C0(int a1);
int __cdecl sub_51730(int a1);
_BYTE *__cdecl sub_51790(int a1);
_WORD *__cdecl sub_51800(int a1);
_BYTE *__cdecl sub_51A00(int a1);
// int __usercall sub_51BB0@<eax>(int a1@<edi>);
char __cdecl sub_52D70(unsigned __int16 a1, char *a2);
char __cdecl sub_52E90(int a1, int a2, char a3);
char sub_53120();
int sub_53160();
char __cdecl sub_533B0(__int16 a1, void *a2);
int __cdecl sub_53590(int a1);
char __cdecl sub_53770(__int16 a1);
char __cdecl sub_53950(__int16 a1);
char sub_539A0();
void __cdecl sub_53A40(char *a1);
int sub_53C70();
int sub_53CA0();
int sub_53CC0();
int __cdecl sub_53CF0(int a1);
char __cdecl sub_53D10(unsigned __int8 a1, const char *a2, char *a3);
int __cdecl sub_53E60(int a1, char *a2);
int __cdecl sub_53EF0(int a1, int a2);
bool __cdecl sub_53F60(int a1);
char __cdecl sub_53F80(const char *a1, const char *a2, const char *a3);
char sub_54200();
int sub_54600();
__int16 __cdecl sub_54630(__int16 a1);
int __cdecl sub_54660(unsigned __int8 a1, int a2);
unsigned __int8 __cdecl sub_54800(unsigned __int8 a1);
__int16 __cdecl sub_548B0(__int16 *a1);
_WORD *__cdecl sub_548F0(_WORD *a1);
int sub_54960();
int __cdecl sub_549A0(int a1, int a2);
int __cdecl sub_54A50(unsigned __int16 a1, int a2);
char __cdecl sub_54D30(__int16 a1);
char __cdecl sub_54F00(__int16 a1);
char __cdecl sub_55080(unsigned __int8 a1, int a2);
int __cdecl sub_55100(char a1);
char __cdecl sub_55250(unsigned __int8 a1);
char __cdecl sub_55320(unsigned __int8 a1);
char __cdecl sub_55450(unsigned __int8 a1, int a2);
char __cdecl sub_555D0(unsigned __int8 a1, int a2);
char __cdecl sub_55750(unsigned __int8 a1, int a2);
char __cdecl sub_558E0(unsigned __int8 a1);
char __cdecl sub_55A10(unsigned __int8 a1);
int __cdecl sub_55AB0(int a1, int a2);
char __cdecl sub_55C00(__int16 a1);
// unsigned int __usercall sub_55C60@<eax>(int a1@<edi>, int a2@<esi>, int a3);
unsigned int __cdecl sub_55EB0(__int16 a1);
int __cdecl main(int argc, const char **argv, const char **envp);
char sub_560D0();
int __cdecl sub_56210(unsigned __int16 a1, int a2);
int sub_56730();
int sub_567C0();
// char __usercall sub_56A30@<al>(int a1@<esi>);
int __cdecl sub_56C00(int a1);
// char __usercall sub_56D60@<al>(int a1@<esi>, char a2);
_BOOL1 __cdecl sub_56EE0(unsigned __int16 a1);
char __cdecl sub_56F10(__int16 a1, __int16 a2, __int16 a3, char a4);
char __cdecl sub_570F0(__int16 a1, __int16 a2, __int16 a3, char a4, char a5, char a6);
char __cdecl sub_572C0(__int16 *a1, __int16 a2, __int16 a3, __int16 a4, char a5);
unsigned __int8 __cdecl sub_57390(unsigned __int16 a1, unsigned __int16 a2);
_BOOL1 __cdecl sub_57450(unsigned __int8 a1);
_WORD *sub_574A0();
int sub_57570();
char sub_575C0();
char sub_57640();
unsigned int sub_57680();
char sub_57730();
char __cdecl sub_57B20(int a1, int a2);
// int __usercall sub_57CF0@<eax>(__int16 a1@<ax>, int a2, int a3);
// int __usercall sub_57D40@<eax>(__int16 a1@<ax>, int a2, int a3);
int __cdecl sub_57D70(int a1, int a2);
// __int16 __usercall sub_57E50@<ax>(__int16 result@<ax>, int a2);
int __cdecl sub_57F10(int a1);
// int __usercall sub_57F20@<eax>(__int16 a1@<ax>, int a2);
_WORD *__cdecl sub_57FA0(_WORD *a1, unsigned __int16 a2, __int16 a3, __int16 a4);
_WORD *__cdecl sub_58030(int a1, _WORD *a2);
int __cdecl sub_580E0(int a1, int a2, int a3, int a4, __int16 a5);
__int16 __cdecl sub_581E0(_WORD *a1, _WORD *a2);
__int16 __cdecl sub_58210(_WORD *a1, _WORD *a2);
int __cdecl sub_582B0(__int16 a1, __int16 a2);
int __cdecl sub_582F0(int a1, __int16 a2);
int __cdecl sub_58350(unsigned __int16 a1, __int16 a2, int a3, unsigned __int16 a4);
int __cdecl sub_583B0(_WORD *a1, _WORD *a2);
unsigned int __cdecl sub_583F0(_WORD *a1, _WORD *a2);
int __cdecl sub_58440(_WORD *a1, _WORD *a2);
unsigned int __cdecl sub_58490(_WORD *a1, _WORD *a2);
int __cdecl sub_584D0(_WORD *a1, _WORD *a2);
int __cdecl sub_585A0(int a1);
void sub_585D0();
char sub_58630();
int __cdecl sub_58940(int a1);
int __cdecl sub_58DA0(int a1, int a2);
int sub_58F00();
char __cdecl sub_595C0(__int16 a1);
char __cdecl sub_59610(int *a1, __int16 a2);
char __cdecl sub_596C0(_WORD *a1, __int16 a2);
int __cdecl sub_59760(int a1, int a2);
void sub_59820();
int sub_59A50();
int sub_59AF0();
int sub_59B50();
_DWORD *sub_59BF0();
int __cdecl sub_59C40(int a1);
int __cdecl sub_59C60(int a1);
int __cdecl sub_59C80(int a1);
char __cdecl sub_59DC0(_WORD *a1);
void __cdecl sub_59F60(int a1);
unsigned int __cdecl sub_5B070(int a1);
// void __usercall sub_5B100(int a1@<edx>, int a2@<edi>, int a3);
int sub_5B7A0();
// int __cdecl _wcpp_1_unwind_leave__93(_DWORD); weak
int sub_5B840();
int __cdecl sub_5B870(_BYTE *a1, int a2, int a3);
// char __usercall sub_5B8D0@<al>(__int16 a1@<fpstat>);
char sub_5BC20();
int sub_5BCC0();
int __cdecl sub_5BDC0(__int16 a1, __int16 a2);
char __cdecl sub_5BE80(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
char sub_5BF10();
int sub_5BF50();
int sub_5C060();
int sub_5C0A0();
// int __usercall sub_5C1B0@<eax>(__int16 a1@<fpstat>);
void sub_5C330();
int __cdecl sub_5C380(__int16 a1);
int __cdecl sub_5C3D0(int a1, char *a2);
int sub_5C430();
void sub_5C450();
int sub_5C490();
int sub_5C530();
__int16 __cdecl sub_5C800(int a1, char a2);
__int16 __cdecl sub_5C830(int a1, char a2, __int16 a3);
signed int __cdecl sub_5C870(int a1);
signed int __cdecl sub_5C8D0(int a1);
// int __usercall sub_5C950@<eax>(__int16 a1@<ax>, int a2, int a3);
_WORD *__cdecl sub_5CF40(int a1, char a2);
int __cdecl sub_5D0A0(int a1);
// int __cdecl _wcpp_1_unwind_leave__98(_DWORD); weak
void __cdecl sub_5D530(int a1);
int __cdecl sub_5DD50(int a1);
void __cdecl sub_5DE30(int a1);
// int __cdecl _wcpp_1_unwind_leave__99(_DWORD); weak
void __cdecl sub_5E010(unsigned int a1);
int __cdecl sub_5E310(int a1);
int __cdecl sub_5E660(int a1);
__int16 __cdecl sub_5E6C0(int a1);
char __cdecl sub_5E7C0(int a1);
int __cdecl sub_5E8C0(int a1);
unsigned int __cdecl sub_5EF70(unsigned int a1);
int __cdecl sub_5EFA0(unsigned int a1);
char __cdecl sub_5F380(int a1);
char __cdecl sub_5F660(int a1, unsigned int a2, int a3);
unsigned __int8 __cdecl sub_5F7B0(int a1, int a2, int a3);
unsigned __int8 __cdecl sub_5F7E0(int a1, int a2);
unsigned int __cdecl sub_5F810(int a1, int a2, int a3);
char __cdecl sub_5F890(int a1, __int16 a2);
void __cdecl sub_5F8F0(int a1);
char __cdecl sub_5FA70(int a1);
int __cdecl sub_5FBD0(__int16 *a1);
int __cdecl sub_5FC40(int a1);
int __cdecl sub_5FCA0(int a1);
// int __cdecl _wcpp_1_unwind_leave__100(_DWORD, _DWORD); weak
int __cdecl sub_5FD00(int a1);
int __cdecl sub_5FF50(int a1);
_WORD *__cdecl sub_60400(__int16 a1, _WORD *a2, _WORD *a3);
char __cdecl sub_60480(int a1);
char __cdecl sub_605E0(int a1);
int __cdecl sub_60780(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_60810(int a1);
int __cdecl sub_609E0(int a1);
int __cdecl sub_60AB0(int a1);
int __cdecl sub_60D50(__int16 *a1, int a2);
int __cdecl sub_60EA0(int a1);
char sub_60F00();
__int16 __cdecl sub_61000(int a1);
unsigned int __cdecl sub_61050(unsigned int a1);
__int16 __cdecl sub_613D0(int a1);
char __cdecl sub_61620(int a1, int a2);
int __cdecl sub_616D0(unsigned int a1);
int __cdecl sub_61790(int a1);
signed int __cdecl sub_61810(int a1, int a2);
char *__cdecl sub_61880(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8);
char *__cdecl sub_61A00(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8);
char *__cdecl sub_627F0(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8);
char __cdecl sub_63570(int a1, int a2);
int __cdecl sub_63600(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10);
int __cdecl sub_63670(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10);
int __cdecl sub_63C90(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10);
char __cdecl sub_644F0(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8);
char __cdecl sub_64CE0(int a1);
int __cdecl sub_64E20(int a1);
int __cdecl sub_64F60(int a1);
int __cdecl sub_64FF0(_WORD *a1);
int __cdecl sub_65040(int a1);
int __cdecl sub_65080(int a1);
int __cdecl sub_65110(int a1);
int __cdecl sub_651B0(int a1);
int __cdecl sub_65240(int a1);
void __cdecl sub_65280(int a1);
void __cdecl sub_652A0(int a1);
void __cdecl sub_652C0(int a1);
signed int __cdecl sub_654B0(__int16 *a1, int a2);
int __cdecl sub_65580(int a1);
int __cdecl sub_655A0(int a1);
int __cdecl sub_655C0(_WORD *a1, int a2);
int __cdecl sub_65610(int a1, int a2);
__int16 __cdecl sub_656D0(int a1, int a2);
char __cdecl sub_65780(int a1, unsigned int a2, unsigned int a3);
int __cdecl sub_65820(int a1);
int __cdecl sub_65B30(int a1);
int __cdecl sub_65B50(int a1);
int __cdecl sub_65C20(int a1);
__int16 __cdecl sub_65F60(int a1);
int __cdecl sub_66160(int a1);
int __cdecl sub_66180(int a1);
int __cdecl sub_66250(int a1);
int __cdecl sub_66280(int a1);
int __cdecl sub_662A0(int a1);
char __cdecl sub_662C0(int a1);
char __cdecl sub_662E0(int a1);
__int16 __cdecl sub_66610(int a1);
__int16 __cdecl sub_66750(unsigned int a1);
char __cdecl sub_66B30(int a1);
char __cdecl sub_66D00(int a1);
int __cdecl sub_66FB0(int a1);
char __cdecl sub_66FD0(int a1);
char __cdecl sub_672E0(int a1);
int __cdecl sub_67410(int a1);
int __cdecl sub_67430(int a1);
int __cdecl sub_67450(int a1);
int __cdecl sub_67470(int a1);
__int16 __cdecl sub_674C0(int a1);
_WORD *__cdecl sub_676F0(int a1);
int __cdecl sub_67740(int a1);
int __cdecl sub_67760(int a1);
int __cdecl sub_67780(int a1);
int __cdecl sub_677A0(int a1);
int __cdecl sub_677D0(int a1);
int __cdecl sub_67800(int a1);
unsigned int __cdecl sub_67890(int a1);
int __cdecl sub_678E0(int a1);
int __cdecl sub_67910(int a1);
int __cdecl sub_67940(int a1);
// int __usercall sub_67960@<eax>(unsigned int a1@<esi>, int a2);
int __cdecl sub_67CB0(int a1);
int __cdecl sub_68490(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
int __cdecl sub_685D0(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
int __cdecl sub_686D0(int a1, unsigned int a2);
char __cdecl sub_68740(int a1, int a2, unsigned __int16 a3, __int16 a4);
char __cdecl sub_68940(int a1);
char __cdecl sub_68AC0(int a1, int a2);
char __cdecl sub_68BD0(int a1, _BYTE *a2);
int sub_68BF0();
int __cdecl sub_68C70(int a1);
bool __cdecl sub_68D50(int a1, int *a2);
int __cdecl sub_68DE0(int a1, int a2);
int __cdecl sub_68E50(int a1, int a2, int a3);
int __cdecl sub_68FF0(int a1, char a2, char a3);
int __cdecl sub_69250(int a1);
int __cdecl sub_692A0(int a1);
char __cdecl sub_692C0(int a1);
void __cdecl sub_69300(int a1, int a2);
int __cdecl sub_693F0(int a1);
int __cdecl sub_69600(int a1);
int __cdecl sub_69620(int a1);
void __cdecl sub_69640(int a1);
void __cdecl sub_69900(int a1, int a2);
int __cdecl sub_69A70(int a1);
int __cdecl sub_69A90(int a1);
int __cdecl sub_69AB0(int a1);
int __cdecl sub_69D70(int a1);
int __cdecl sub_69D90(int a1);
void __cdecl sub_69DB0(int a1);
int __cdecl sub_69FF0(int a1);
int __cdecl sub_6A010(int a1);
char __cdecl sub_6A030(int a1);
int __cdecl sub_6A2C0(int a1);
int __cdecl sub_6A2E0(int a1);
void __cdecl sub_6A300(int a1);
int __cdecl sub_6A440(int a1);
int __cdecl sub_6A460(int a1);
char __cdecl sub_6A480(int a1);
int __cdecl sub_6A580(int a1);
int __cdecl sub_6A5A0(int a1);
int __cdecl sub_6A5C0(int a1);
int __cdecl sub_6A9C0(int a1);
int __cdecl sub_6A9E0(int a1);
__int16 __cdecl sub_6AA00(int a1);
int __cdecl sub_6AAC0(int a1);
int __cdecl sub_6AAE0(int a1);
int __cdecl sub_6AB00(int a1);
int __cdecl sub_6AD00(int a1);
int __cdecl sub_6AD20(int a1);
void __cdecl sub_6AD60(int a1);
int __cdecl sub_6B180(int a1);
int __cdecl sub_6B1A0(int a1);
void __cdecl sub_6B1C0(int a1);
int __cdecl sub_6B2D0(int a1);
int __cdecl sub_6B2F0(int a1);
__int16 __cdecl sub_6B310(_WORD *a1);
int __cdecl sub_6B3A0(int a1);
int __cdecl sub_6B3C0(int a1);
int __cdecl sub_6B3E0(int a1);
int __cdecl sub_6B5D0(int a1);
int __cdecl sub_6B5F0(int a1);
__int16 __cdecl sub_6B610(int a1);
int __cdecl sub_6B830(int a1);
int __cdecl sub_6B850(int a1);
int __cdecl sub_6B870(int a1);
int __cdecl sub_6BA70(int a1);
int __cdecl sub_6BA90(int a1);
int __cdecl sub_6BAB0(int a1);
int __cdecl sub_6BCB0(int a1);
int __cdecl sub_6BCD0(int a1);
int __cdecl sub_6BCF0(int a1);
int __cdecl sub_6BEF0(int a1);
int __cdecl sub_6BF10(int a1);
int __cdecl sub_6BF30(int a1);
int __cdecl sub_6C130(int a1);
int __cdecl sub_6C150(int a1);
__int16 __cdecl sub_6C170(int a1);
int __cdecl sub_6C3A0(int a1);
int __cdecl sub_6C3C0(int a1);
int __cdecl sub_6C3E0(int a1);
int __cdecl sub_6C5E0(int a1);
int __cdecl sub_6C600(int a1);
int __cdecl sub_6C620(int a1);
int __cdecl sub_6C830(int a1);
int __cdecl sub_6C850(int a1);
__int16 __cdecl sub_6C870(int a1);
int __cdecl sub_6CA80(int a1);
int __cdecl sub_6CAA0(int a1);
int __cdecl sub_6CAC0(int a1);
int __cdecl sub_6CCE0(int a1);
int __cdecl sub_6CD00(int a1);
int __cdecl sub_6CD20(int a1);
int __cdecl sub_6CF60(int a1);
int __cdecl sub_6CF80(int a1);
int __cdecl sub_6CFA0(int a1);
int __cdecl sub_6D1C0(int a1);
int __cdecl sub_6D1E0(int a1);
__int16 __cdecl sub_6D200(int a1);
int __cdecl sub_6D420(__int16 a1, __int16 a2);
char __cdecl sub_6D4C0(int a1);
int __cdecl sub_6D4F0(int a1, __int16 a2);
// int __fastcall _wcpp_1_unwind_leave__120(_DWORD); weak
char __cdecl sub_6D5E0(int a1, char a2);
int __cdecl sub_6D710(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3);
char __cdecl sub_6D830(int a1, char a2);
char __cdecl sub_6D880(int a1);
void __cdecl sub_6D8B0(unsigned __int16 a1, unsigned __int16 a2, __int16 a3);
int __cdecl sub_6D9C0(int a1, unsigned __int8 *a2, __int16 a3, char a4, char a5);
void __cdecl sub_6DAD0(int a1, unsigned __int8 *a2, __int16 a3);
int __cdecl sub_6DB50(char a1, char a2);
void sub_6DBD0();
void __cdecl sub_6DC40(unsigned __int8 a1);
int __cdecl sub_6DCA0(int a1, int a2, unsigned __int16 a3, __int16 *a4, __int16 a5, char a6);
int __cdecl sub_6E020(unsigned __int16 a1);
int __cdecl sub_6E090(int a1, int a2);
int sub_6E0D0();
void sub_6E150();
void __cdecl sub_6E450(__int16 a1, __int16 a2, __int16 a3);
bool __cdecl sub_6EA90(int a1, int a2);
void __cdecl sub_6EAB0(int a1, __int16 a2, __int16 a3);
unsigned int __cdecl sub_6EB90(unsigned int **a1);
unsigned int __cdecl sub_6EBF0(unsigned int **a1);
int sub_6EDB0();
int __cdecl sub_6EDE0(__int16 a1, __int16 a2);
__int16 __cdecl sub_6EF10(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
int __cdecl sub_6F030(int a1);
int __cdecl sub_6F070(int a1);
unsigned int __cdecl sub_6F0B0(int a1);
unsigned int __cdecl sub_6F100(int a1);
unsigned int __cdecl sub_6F150(int a1);
int __cdecl sub_6F1C0(int a1);
_BYTE *__cdecl sub_6F2B0(int a1);
unsigned int __cdecl sub_6F300(int a1, unsigned int a2);
unsigned int __cdecl sub_6F420(int a1);
unsigned int __cdecl sub_6F440(int a1);
unsigned int __cdecl sub_6F460(int a1);
unsigned int __cdecl sub_6F480(int a1);
unsigned int __cdecl sub_6F4A0(int a1);
unsigned int __cdecl sub_6F4C0(int a1);
unsigned int __cdecl sub_6F4E0(int a1);
unsigned int __cdecl sub_6F500(int a1);
unsigned int __cdecl sub_6F520(int a1);
unsigned int __cdecl sub_6F540(int a1);
unsigned int __cdecl sub_6F560(int a1);
unsigned int __cdecl sub_6F580(int a1);
unsigned int __cdecl sub_6F5A0(int a1);
unsigned int __cdecl sub_6F5C0(int a1);
unsigned int __cdecl sub_6F5E0(int a1);
unsigned int __cdecl sub_6F600(int a1);
unsigned int __cdecl sub_6F620(int a1);
unsigned int __cdecl sub_6F640(int a1);
unsigned int __cdecl sub_6F660(int a1);
unsigned int __cdecl sub_6F680(int a1);
unsigned int __cdecl sub_6F6A0(int a1);
unsigned int __cdecl sub_6F6C0(int a1);
unsigned int __cdecl sub_6F6E0(int a1);
unsigned int __cdecl sub_6F700(int a1);
unsigned int __cdecl sub_6F720(int a1);
unsigned int __cdecl sub_6F740(int a1);
unsigned int __cdecl sub_6F760(int a1);
unsigned int __cdecl sub_6F780(int a1);
unsigned int __cdecl sub_6F7A0(int a1);
unsigned int __cdecl sub_6F7C0(int a1);
_BYTE *__cdecl sub_6F7E0(int a1);
unsigned int __cdecl sub_6F850(int a1, int a2);
int __cdecl sub_6F8E0(int a1, int a2);
int __cdecl sub_6F940(_BYTE *a1, int a2, __int16 a3, unsigned __int8 a4);
__int16 sub_6FC10();
__int16 sub_6FC30();
int __cdecl sub_6FC50(__int16 a1);
unsigned int __cdecl sub_6FC80(char *a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5);
// void __usercall __noreturn sub_6FD30(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
int sub_6FDA0();
void sub_6FE20();
// int __fastcall _wcpp_1_unwind_leave__130(_DWORD); weak
int __cdecl sub_6FE90(unsigned __int8 *a1, unsigned int a2);
int sub_6FEC0();
int sub_70890();
int sub_70910();
int sub_70940();
char sub_70A60();
int sub_70BF0();
int __cdecl sub_70C60(unsigned __int16 a1, char *a2);
char __cdecl sub_70D20(unsigned __int16 a1);
char __cdecl sub_70E10(unsigned __int16 a1);
int __cdecl sub_70EF0(unsigned __int16 a1);
int __cdecl sub_70F50(unsigned __int16 a1);
unsigned int __cdecl sub_71090(unsigned int a1);
__int16 sub_712F0();
int sub_713A0();
int sub_71410();
bool __cdecl sub_71520(unsigned __int16 a1);
int sub_715B0();
int sub_716A0();
__int16 *__cdecl sub_716C0(unsigned __int16 a1, unsigned __int16 a2, signed __int16 a3);
int __cdecl sub_71730(unsigned __int16 a1);
char sub_71780();
char sub_71890();
__int16 sub_718F0();
int sub_71930();
char sub_71990();
unsigned __int8 __cdecl sub_71A70(unsigned __int8 a1);
__int16 __cdecl sub_71AB0(__int16 a1, char a2);
int __cdecl sub_71B40(int a1, unsigned __int16 a2, int a3);
int __cdecl sub_71CD0(int a1);
int __cdecl sub_71E60(int a1);
int __cdecl sub_71E70(int a1, unsigned int a2, __int16 a3);
__int16 __cdecl sub_71F20(int a1, int a2);
void __cdecl sub_720C0(int *a1);
int __cdecl sub_72120(unsigned __int16 a1);
int __cdecl sub_721C0(unsigned __int16 *a1, int *a2, __int16 a3);
int __cdecl sub_72350(int a1);
unsigned __int16 __cdecl sub_723B0(int a1, char a2);
_DWORD *__cdecl sub_72410(_DWORD *a1);
int __cdecl sub_724F0(int a1, __int16 a2);
void __cdecl sub_72550(int *a1);
__int16 __cdecl __spoils<> sub_72633(__int16 a1, __int16 a2);
unsigned int __cdecl sub_7277A(unsigned int a1);
void __cdecl __spoils<> sub_727F0(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
// int __usercall sub_72883@<eax>(int a1@<eax>, void *a2, unsigned __int16 a3, char a4);
// int __usercall sub_728A9@<eax>(int a1@<eax>, void *a2, unsigned __int16 a3, char a4);
int __cdecl sub_72C40(__int16 a1, __int16 a2, int a3, unsigned __int8 a4);
int __cdecl sub_72CB0(unsigned __int8 *a1, int a2);
void sub_72D04();
// int __usercall sub_72DDE@<eax>(int a1@<edx>, __int16 *a2@<ebx>, int a3);
int __fastcall sub_72E70(int a1, int a2, __int16 *a3);
int __fastcall sub_72FBB(int a1, int a2, __int16 *a3);
int sub_7302E();
// int __usercall sub_7308F@<eax>(int a1@<edx>, __int16 *a2@<ebx>, int a3, __int16 a4);
int __cdecl sub_73669(__int16 a1);
int __cdecl sub_7373D(__int16 a1);
__int16 __cdecl sub_739AD(__int16 a1);
__int16 __cdecl sub_73AA1(__int16 a1);
__int16 __cdecl sub_73D11(__int16 a1);
unsigned __int16 __cdecl sub_74006(unsigned __int16 a1, int a2, unsigned int a3);
unsigned __int16 __cdecl sub_7404E(unsigned __int16 a1, int a2, unsigned int a3);
__int16 sub_74374();
unsigned __int16 __cdecl sub_7438A(int a1, unsigned int a2);
__int16 sub_7449C();
int sub_74515();
int sub_74536();
int sub_74556();
// int __usercall sub_74767@<eax>(int a1@<edx>, __int16 *a2@<ebx>, _BYTE *a3, int a4);
int __cdecl sub_74809(__int16 a1);
int __cdecl sub_748F7(__int16 a1);
int sub_74A11();
int __cdecl sub_74A86(_BYTE *a1, int a2);
int __cdecl sub_74B19(_BYTE *a1);
int __cdecl sub_74B75(__int16 a1);
int __cdecl sub_74C9D(unsigned int a1, int a2);
int __cdecl sub_74D41(unsigned int a1, int a2, unsigned int a3);
int __cdecl sub_74DD4(unsigned int a1, int a2, unsigned __int16 a3);
int __cdecl sub_74E6D(unsigned int a1, int a2, int a3);
int __cdecl sub_74EF1(unsigned int a1, int a2, unsigned int a3);
__int16 sub_74F76();
int __cdecl sub_74FE1(__int16 a1);
int __cdecl sub_75044(unsigned int a1);
int *__cdecl sub_75110(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5);
int *__cdecl sub_75160(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5);
int *__cdecl sub_751B0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5);
void __cdecl sub_75200(__int16 a1);
// void __usercall __noreturn sub_752C0(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
int __fastcall sub_753D0(int a1, int a2);
int sub_75420();
int sub_75440();
int __cdecl sub_754C0(int a1, _DWORD *a2, int a3);
int __cdecl sub_75540(int a1, int a2);
int __cdecl sub_755B0(int a1, _DWORD *a2, int a3);
int sub_75650();
int sub_75900();
int sub_75910();
int sub_759B0();
unsigned __int8 __cdecl sub_75A10(int a1, unsigned __int8 *a2);
int sub_75AB0();
int __cdecl sub_75AE0(int a1);
int __cdecl sub_75B50(__int16 a1);
int __cdecl sub_75B80(int a1, __int16 *a2, _WORD *a3);
void sub_75C50();
void sub_75CB0();
unsigned int __cdecl sub_75D70(void *a1, unsigned int a2);
int sub_75DB0();
void __fastcall sub_75E70(__int16 a1);
int __cdecl sub_76160(__int16 a1, __int16 a2, int a3);
unsigned int sub_76260();
__int16 sub_76300();
int sub_76430();
int sub_76540();
void __cdecl sub_765FC(__int16 a1, __int16 a2);
int __cdecl sub_76619(int a1, int a2);
__int16 sub_766A4();
__int16 sub_76752();
int sub_7677C();
__int16 sub_7678D();
int sub_76840();
int __fastcall sub_76930(int a1, int a2, __int16 *a3);
int sub_76A40();
void sub_76CF0();
// int _wcpp_1_unwind_leave__131(void); weak
char __cdecl sub_76D10(char a1);
// void __usercall __noreturn sub_76F40(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
int __fastcall sub_76FA0(int a1, int a2, __int16 *a3);
char __cdecl sub_77350(int a1);
char __fastcall sub_77680(int a1, int a2, __int16 *a3);
// char __usercall sub_77980@<al>(int a1@<edx>, int a2);
char __cdecl sub_779E0(int a1);
char __cdecl sub_780F0(int a1);
char __cdecl sub_78730(_WORD *a1);
// char __usercall sub_78E00@<al>(int a1@<eax>, int a2@<ebx>, __int16 *a3);
char __cdecl sub_79160(int a1);
char sub_79610();
int __cdecl sub_79E10(char *a1, char a2);
char sub_7A060();
void __cdecl sub_7A110(char a1, char a2);
int __cdecl sub_7AA70(int a1, char *a2, int a3, int a4);
// int (__cdecl **__usercall sub_7AB00@<eax>(__int16 a1@<ax>, int a2@<edx>, __int16 *a3@<ebx>, unsigned __int8 a4))(int);
int sub_7AC00();
int __cdecl sub_7ADE0(char a1);
bool __cdecl sub_7B200(_WORD *a1, __int16 a2, __int16 a3);
char __fastcall sub_7B250(int a1, int a2, __int16 a3);
void sub_7B5A0();
void sub_7B5D0();
int __cdecl sub_7B660(int a1, __int16 a2, __int16 a3, _WORD *a4, _BYTE *a5, char a6);
int (__cdecl **sub_7BEC0())(int);
// int __usercall sub_7BF20@<eax>(int a1@<edx>, __int16 *a2);
_WORD *__cdecl sub_7C020(_WORD *a1);
int __fastcall sub_7C050(__int16 a1, __int16 a2);
int __cdecl sub_7C120(__int16 a1, __int16 a2, int a3);
int __cdecl sub_7C140(int a1, __int16 a2, int a3, __int16 a4, unsigned __int8 a5);
char __cdecl sub_7C200(unsigned __int8 a1);
int __fastcall sub_7C230(int a1, int a2, __int16 *a3);
int sub_7C390();
void sub_7C710();
int __cdecl sub_7C720(unsigned __int8 a1, _BYTE *a2);
int __cdecl sub_7C7C0(int a1, int a2);
unsigned __int8 __cdecl sub_7C800(__int16 a1);
unsigned __int8 __cdecl sub_7C9D0(__int16 a1);
int sub_7CB10();
char sub_7CBF0();
char sub_7CC40();
int sub_7CCA0();
int sub_7CCF0();
int sub_7CD30();
int sub_7CDA0();
int __cdecl sub_7CDC0(unsigned __int8 a1, unsigned __int8 a2);
int sub_7CE50();
int sub_7D1F0();
int __cdecl sub_7D230(char a1, unsigned __int8 a2, unsigned __int8 a3);
int sub_7D310();
unsigned int sub_7D380();
// int __usercall sub_7D400@<eax>(int a1@<eax>, __int16 a2, __int16 a3, char a4);
int __cdecl sub_7DA70(__int16 a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6);
int sub_7DD70();
// char __usercall sub_7DE80@<al>(int a1@<ebx>, int a2);
int sub_7E0E0();
int sub_7E1F0();
// int __usercall sub_7E320@<eax>(int a1@<edx>, int a2@<edi>);
// int __usercall sub_7E5A0@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3, __int16 a4, int a5, __int16 a6, __int16 a7);
int __cdecl sub_7E620(int a1);
// int __usercall sub_7E640@<eax>(int a1@<edx>, int a2);
char __cdecl sub_7E800(_WORD *a1);
char __cdecl sub_7E820(int a1);
int __cdecl sub_7E840(__int16 *a1, __int16 a2, __int16 a3);
int __cdecl sub_7E8D0(__int16 *a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7);
int __cdecl sub_7E9D0(__int16 *a1, __int16 *a2, _WORD *a3);
int __cdecl sub_7EAE0(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, char *a5, __int16 *a6);
// int __usercall sub_7F6A0@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3, __int16 a4, char *a5, _BYTE *a6, unsigned __int8 a7);
int __cdecl sub_7F7D0(unsigned int *a1, _DWORD *a2, unsigned int a3, const char *a4);
int __cdecl sub_7F960(unsigned int *a1, unsigned int a2, unsigned int a3, const char *a4);
unsigned int __cdecl sub_7FAE0(char *a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5);
int __cdecl sub_7FB90(_BYTE *a1, int a2, __int16 a3, unsigned __int8 a4);
// int __usercall sub_7FCB0@<eax>(int a1@<ebx>, _BYTE *a2, int a3, int a4, int a5, char a6, unsigned __int8 a7, __int16 a8);
void __cdecl sub_80C30(__int16 a1, __int16 a2, __int16 a3);
// int __usercall sub_80D40@<eax>(__int16 a1@<si>, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
// int __usercall sub_81260@<eax>(int a1@<eax>, int a2@<edx>, int a3, __int16 a4, __int16 a5);
int __cdecl sub_812D0(__int16 a1, __int16 a2);
int __cdecl sub_81360(int a1, int a2, int a3, int a4, __int16 a5);
int __fastcall sub_81760(int a1);
// unsigned int __usercall sub_81CA0@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3, __int16 a4, int a5);
int sub_81DB0();
// __int16 __usercall sub_81EE0@<ax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, __int16 a4@<di>, __int16 a5, __int16 a6);
_WORD *__cdecl sub_824B0(__int16 a1);
_WORD *__cdecl sub_824E0(__int16 a1);
// int __usercall sub_82510@<eax>(__int16 a1@<dx>, int *a2);
__int16 sub_82670();
int __cdecl sub_82AB0(unsigned __int8 a1);
// int __usercall sub_82C20@<eax>(int result@<eax>, __int16 a2);
int __cdecl sub_83250(char a1);
void sub_833C0();
int sub_83850();
int sub_83B50();
char __cdecl sub_83CC0(char a1);
int __cdecl sub_83CD0(int a1);
int __cdecl sub_83D70(int a1);
char __cdecl sub_83E00(int a1, int a2);
void __cdecl sub_83E80(int a1);
int __cdecl sub_84000(int a1);
// int __usercall sub_84050@<eax>(__int16 a1@<fpstat>);
// void __usercall sub_840B8(char a1@<cf>, _BOOL1 a2@<zf>, char a3@<sf>, char a4@<of>, __int16 a5@<fpstat>);
// int __usercall sub_840D3@<eax>(char _CF@<cf>, _BOOL1 _ZF@<zf>, char _SF@<sf>, char _OF@<of>);
// void __usercall __spoils<st0> sub_841CE(__int16 a1@<fpstat>);
__int16 __cdecl sub_84250(int a1);
int __cdecl sub_84300(unsigned __int8 a1);
void sub_844A0();
char __cdecl sub_844F0(int a1, unsigned __int8 a2);
int sub_84790();
char __cdecl sub_847D0(int a1, char a2, char a3, char a4);
int __cdecl sub_84880(_BYTE *a1);
char sub_848A0();
int sub_84B80();
int __cdecl sub_84EA0(unsigned __int16 a1, int a2, char a3, __int16 a4);
int __cdecl sub_84FB0(__int16 *a1, __int16 *a2);
int __cdecl sub_85060(int a1);
void sub_85070();
int *sub_85350();
int __cdecl sub_85450(unsigned int a1);
__int16 __cdecl sub_856D0(int a1, int a2, __int16 a3, int a4);
unsigned int *__cdecl sub_85AF0(int a1);
int __cdecl sub_85B20(_BYTE *a1, _WORD *a2, unsigned __int16 a3);
int __cdecl sub_85BF5(_BYTE *a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_85C42(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6);
void __cdecl sub_85C8B(int a1, char *a2, int a3, int a4, int a5, int a6);
// void __usercall __spoils<> sub_85CC3(unsigned int a1@<eax>, int a2@<ebx>, unsigned __int16 *a3);
__int16 sub_85E40();
__int16 __cdecl sub_85EB0(__int16 a1);
__int16 __cdecl sub_85F00(__int16 a1);
int __cdecl sub_85F60(int a1);
bool sub_85FD0();
int sub_86010();
__int16 __cdecl sub_86180(unsigned __int16 a1);
__int16 __cdecl sub_86270(unsigned __int16 a1);
__int16 __cdecl sub_86370(unsigned __int16 a1, char a2);
__int16 __cdecl sub_86460(unsigned __int16 a1);
int sub_86550();
char __cdecl sub_86780(unsigned __int16 a1, int a2, int a3);
char __cdecl sub_86860(unsigned __int16 a1);
char __cdecl sub_86930(unsigned __int16 a1);
char sub_86A00();
char sub_86BD0();
int sub_86EA0();
void __cdecl sub_86EB0(unsigned __int8 a1, unsigned __int8 a2, char a3);
void __cdecl sub_86F20(char a1);
void __cdecl sub_86F70(unsigned __int8 a1, __int16 a2, __int16 a3);
void __cdecl sub_86FF0(unsigned __int8 a1, __int16 a2, __int16 a3);
char sub_87090();
char sub_871E0();
int sub_871F0();
int sub_872A0();
void sub_87580();
char sub_87610();
int sub_87860();
int sub_87970();
int sub_87A30();
int sub_87B30();
_DWORD *sub_87B70();
// int __fastcall _wcpp_1_unwind_leave__132(_DWORD); weak
char *sub_87BE0();
int sub_87C10();
int sub_87CF0();
int sub_88450();
void __cdecl sub_884D0(int a1, __int16 a2, int a3, char a4, char a5);
char *sub_88580();
char __cdecl sub_885E0(int a1, __int16 a2, __int16 a3, unsigned __int16 a4);
void __cdecl sub_88740(int a1, __int16 a2, __int16 a3);
int __cdecl sub_889F0(int a1);
int sub_88B20();
int sub_88B60();
char sub_88BA0();
int sub_88D00();
char sub_88D40();
char sub_89360();
int __cdecl sub_89420(_WORD *a1, const char *a2);
int __cdecl sub_89520(__int16 *a1);
int __cdecl sub_895D0(int a1, const char *a2);
int __cdecl sub_89690(__int16 *a1);
int __cdecl sub_89830(_WORD *a1);
_WORD *__cdecl sub_898A0(_WORD *a1);
int __cdecl sub_89920(_WORD *a1, __int16 a2, int a3);
int __cdecl sub_89980(__int16 *a1);
__int16 __cdecl sub_89A30(_WORD *a1);
int __cdecl sub_89AC0(_BYTE *a1, int a2);
int __cdecl sub_89B60(unsigned __int8 a1);
int sub_89D10();
int sub_8B5A0();
int __cdecl sub_8B600(int a1);
int sub_8B770();
int __cdecl sub_8B790(_DWORD *a1);
char __cdecl sub_8B880(int *a1, char a2, int a3, int a4);
// char __usercall sub_8B980@<al>(int a1@<eax>, int a2@<edx>, int *a3, int a4);
// char __usercall sub_8BA10@<al>(int a1@<eax>, int a2@<edx>, int *a3, char *a4, int a5);
int __cdecl sub_8BB10(int a1);
int __cdecl sub_8BB40(int a1, char a2);
int __cdecl sub_8BBE0(int a1);
void __cdecl sub_8C0E0(unsigned __int8 (__fastcall *a1)(int));
char __cdecl sub_8C140(unsigned __int16 a1, int a2);
// _DWORD __cdecl dos_getdrive(_DWORD); weak
// _DWORD __cdecl dos_setdrive(_DWORD, _DWORD); weak
// _DWORD __cdecl dos_getdiskfree(_DWORD, _DWORD); weak
int sub_8C21F();
// _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD); weak
// int rand(void); weak
// _DWORD __cdecl printf(_DWORD);
void sub_8C2CD();
void sub_8C2DE();
int sub_8C329();
int sub_8C635();
int sub_8C839();
int sub_8CA16();
int sub_8CACD();
void sub_8CB1F();
void __noreturn sub_8CB3A();
int __cdecl sub_8CD27(int a1);
int sub_8CEDF();
int sub_8D12F();
void __fastcall sub_8D290(int a1, unsigned __int16 a2, int a3, int a4);
void sub_8D800();
int sub_8D8F0();
void __fastcall sub_8D970(int a1, unsigned __int16 a2, int a3, int a4);
void sub_8E020();
int sub_8E0D0(); // weak
void __cdecl sub_8E160(__int16 a1, unsigned __int8 a2);
// _DWORD sprintf(_DWORD, const char *, ...); weak
_DWORD *__cdecl sub_8E410(_DWORD *a1);
unsigned int __cdecl sub_8E470(unsigned int a1);
__int16 sub_8E673();
__int16 sub_8E736();
int sub_8E799();
int sub_8E7B7();
int sub_8E7D5();
void sub_8E7FC();
__int16 sub_8E871();
int sub_8E948();
char sub_8E9EF();
void __fastcall sub_8EA7B(int a1, __int16 a2);
int __cdecl sub_8EAD0(__int16 a1);
unsigned int sub_8EC90();
char __cdecl sub_8ED00(int a1, unsigned __int8 a2);
int __cdecl sub_8F023(int a1, int a2, unsigned int a3);
int __cdecl sub_8F0AB(int a1, int a2, int a3);
int *__cdecl sub_8F100(int a1, __int16 a2, int a3, int a4, unsigned __int16 a5, char a6, unsigned __int8 a7);
void __cdecl sub_8F420(int a1, __int16 a2);
int sub_8F4B0(); // weak
void __cdecl sub_8F710(int a1, __int16 a2, unsigned __int16 a3, unsigned __int8 a4, char a5);
char *sub_8F850();
int __cdecl sub_8F8B0(__int16 a1, __int16 a2, int a3);
int __cdecl sub_8F8E8(__int16 a1, __int16 a2, int a3);
// void __usercall sub_8F920(__int16 a1@<dx>, int a2@<ecx>, int a3@<ebx>, char *a4@<esi>, unsigned __int8 a5, char a6);
// void __usercall sub_8F935(__int16 a1@<dx>, int a2@<ecx>, int a3@<ebx>, char *a4@<esi>, unsigned __int8 a5, char a6);
void __cdecl sub_90164(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, unsigned __int16 a5);
void __cdecl sub_901E4(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, unsigned __int16 a5);
int __cdecl sub_9025C(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6);
int __cdecl sub_90374(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6);
void sub_90478();
char __cdecl sub_904C0(float a1);
unsigned __int8 __cdecl sub_90530(_DWORD *a1, int a2, float a3);
int __cdecl sub_905EC(char a1);
int __cdecl sub_90668(int a1);
int sub_906B4();
int sub_90810();
__int16 __cdecl sub_90B27(char *a1, unsigned __int8 a2, char a3);
void sub_90D27();
int __cdecl sub_90D3F(int a1);
int __cdecl sub_90D6E(unsigned __int8 *a1);
int __cdecl sub_90E07(unsigned __int8 *a1);
int __cdecl sub_90EA0(int a1, const char *a2);
int sub_90EE0();
int sub_90F20();
int sub_90F60();
__int16 __fastcall sub_90FD0(int a1, unsigned __int16 a2, int a3, int a4);
__int16 sub_91010();
int sub_91420();
bool sub_915A0();
int sub_91660(); // weak
int sub_916F0();
void __fastcall sub_917D0(int a1, unsigned __int16 a2);
int sub_919C0();
int __cdecl sub_91A80(int a1, int a2);
void sub_91BD0();
void sub_91BF0();
// int __usercall sub_91C10@<eax>(__int16 a1@<dx>, int a2@<ecx>, int a3@<ebx>, int a4);
int __cdecl sub_91D50(int a1, int a2);
int __cdecl sub_91E90(int a1);
unsigned int sub_91F20();
void __cdecl sub_91F50(unsigned int a1);
int __cdecl sub_91F70(int a1, int a2, _WORD *a3, _WORD *a4);
unsigned __int8 __cdecl sub_920D0(int a1);
int sub_92160();
int __cdecl sub_92190(int a1, const char *a2);
unsigned int __cdecl sub_92600(int a1);
__int32 __cdecl sub_92740(int a1, __int32 a2);
void __cdecl sub_92890(int a1, int a2);
void __cdecl sub_92930(int a1, unsigned int a2);
void __cdecl sub_92BA0(int a1);
void __cdecl sub_92CB0(int a1);
void __cdecl sub_92DC0(int a1);
void sub_92E50();
void *__cdecl sub_92ED0(int a1);
// _DWORD *__usercall sub_93010@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4);
int __cdecl sub_93160(unsigned int a1);
// int __usercall sub_931F0@<eax>(int a1@<ecx>, int a2@<ebx>, int **a3);
// int *__usercall sub_93330@<eax>(int a1@<ecx>, int a2@<ebx>, const char *a3, const void *a4);
int __cdecl sub_93480(unsigned int *a1);
int *__cdecl sub_93510(int a1);
int __cdecl sub_937A0(int a1);
int __cdecl sub_93830(int *a1);
int __cdecl sub_938C0(int *a1, int a2, int a3);
_DWORD *__cdecl sub_93A10(_DWORD *a1, int a2, int a3);
int __cdecl sub_93AB0(int *a1, int a2, int a3);
int __cdecl sub_93B50(int *a1);
int __cdecl sub_93D00(int a1);
int __cdecl sub_93D90(int a1, int a2);
int __cdecl sub_93E30(int *a1, int a2);
int __cdecl sub_93ED0(int *a1, int a2);
int __cdecl sub_93F70(int a1, int a2);
int __cdecl sub_94010(int a1);
int __cdecl sub_94650(_DWORD *a1, int a2);
int __cdecl sub_95140(int a1, int a2);
int __cdecl sub_953E0(int a1, int a2, int a3);
int __cdecl sub_95480(int a1, int a2);
// int __usercall sub_95710@<eax>(int a1@<ecx>, int a2@<ebx>, int **a3);
// int *__usercall sub_95850@<eax>(int a1@<ecx>, int a2@<ebx>, const char *a3, const void *a4);
int __cdecl sub_959A0(unsigned int *a1);
_DWORD *__cdecl sub_95A30(int a1);
int __cdecl sub_95C00(int *a1, int a2, int a3);
int *__cdecl sub_95D50(int *a1);
int __cdecl sub_95DE0(int *a1);
void __cdecl sub_95E70(_DWORD *a1);
int __cdecl sub_95F00(int a1);
void __cdecl sub_96030(_DWORD *a1, int a2, int a3);
int __cdecl sub_96170(int a1);
_DWORD *__cdecl sub_96670(_DWORD *a1, _DWORD *a2);
int __cdecl sub_969A0(_DWORD *a1);
int __cdecl sub_96AE0(const char *a1);
int __cdecl sub_97330(_DWORD *a1, _DWORD *a2, int *a3);
_DWORD *__cdecl sub_97480(_DWORD *a1, int a2);
int __cdecl sub_97670(int a1, int a2);
int __cdecl sub_97A60(int a1, int a2);
int __cdecl sub_97BB0(int a1, int a2);
int __cdecl sub_97F90(_DWORD *a1);
_DWORD *__cdecl sub_980D0(_DWORD *a1, int a2);
int __cdecl sub_98170(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl sub_98360(_DWORD *a1, int a2, int a3, unsigned int a4, int a5);
bool sub_986A0();
void sub_986E0();
unsigned int __cdecl sub_98709(unsigned int a1, unsigned int a2, unsigned int a3);
unsigned int *__cdecl sub_9874D(unsigned int *a1, unsigned int a2, unsigned int a3);
__int64 __fastcall j___clock(_DWORD, _DWORD, _DWORD); // weak
void __cdecl sub_98790(unsigned __int16 a1, unsigned __int8 a2);
// _DWORD __cdecl toupper(_DWORD); weak
int __cdecl sub_98817(int a1, int a2);
int __cdecl sub_98882(int a1);
int __cdecl sub_988A7(int a1, int a2, int a3);
// _DWORD __cdecl filelength(_DWORD); weak
int __cdecl sub_9891E(int a1, int a2, char a3);
int __cdecl sub_9894C(int a1, char *a2);
// char __usercall sub_98AE0@<al>(int *a1@<esi>);
// __int16 __usercall sub_98AE9@<ax>(__int16 *a1@<edx>, int a2@<esi>);
// __int16 __usercall sub_98B2C@<ax>(unsigned __int8 a1@<al>, int a2@<esi>);
// char __usercall sub_98BAF@<al>(int a1@<esi>);
int __cdecl sub_98C48(int a1, int a2, int a3);
int __cdecl sub_98CAA(int a1, int a2, int a3);
// _DWORD __cdecl access(_DWORD, _DWORD); weak
// _DWORD __cdecl mkdir(_DWORD); weak
// _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD); weak
// int _sigfpe_handler(); weak
// _DWORD __cdecl signal(_DWORD, _DWORD); weak
// _DWORD __cdecl stricmp(_DWORD, _DWORD); weak
// _DWORD __cdecl unknown_libname_1(_DWORD); weak
int __cdecl sub_98FF5(char *a1);
// void __cdecl __noreturn exit(int status); idb
void __cdecl sub_99080(char a1);
int __cdecl sub_9937E(__int16 a1);
int __cdecl sub_994BA(__int16 a1);
int __cdecl sub_9951B(__int16 a1);
int sub_995B0();
// _DWORD __cdecl strncmp(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl fgetc(_DWORD); weak
int sub_99830(); // weak
void __cdecl sub_99970(char a1, unsigned __int8 a2);
unsigned int __cdecl sub_99A77(unsigned int a1, unsigned int a2, unsigned int a3);
unsigned int *__cdecl sub_99AEB(unsigned int *a1, unsigned int a2, unsigned int a3);
// _DWORD __cdecl strnicmp(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl __far chain_intr(_DWORD); weak
// __int64 __cdecl dos_getvect(_DWORD); weak
// _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD); weak
void sub_99C10();
void sub_99C90();
// _DWORD __cdecl strcpy(_DWORD, _DWORD); weak
// _DWORD __cdecl strlen(_DWORD); weak
// _DWORD __cdecl strcat(_DWORD, _DWORD); weak
// _DWORD __cdecl memcpy(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl segread(_DWORD); weak
// _DWORD __cdecl int386x(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl getenv(_DWORD); weak
int __cdecl sub_99E8E(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4);
int __cdecl sub_99FF0(unsigned __int8 *a1, unsigned __int8 **a2, int a3);
int __cdecl sub_99FF5(unsigned __int8 a1);
// _DWORD __cdecl strcmp(_DWORD, _DWORD); weak
unsigned __int8 sub_9A0FC();
int __fastcall sub_9A10A(int result);
_DWORD __cdecl j___delay(_DWORD); // weak
void __cdecl sub_9A128(const void *a1, void *a2, unsigned __int16 a3);
void __cdecl sub_9A144(const void *a1, void *a2, unsigned __int16 a3);
// _DWORD __cdecl unknown_libname_2(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl unknown_libname_3(_DWORD); weak
// int __cdecl unknown_libname_4(_DWORD); weak
// _DWORD __cdecl strupr(_DWORD); weak
int __cdecl sub_9A230(int a1);
_DWORD *__cdecl sub_9A2F5(int a1);
int __cdecl sub_9A32D(int a1);
// _DWORD __cdecl gets(_DWORD); weak
// _DWORD __cdecl tell(_DWORD); weak
// _DWORD __cdecl malloc(_DWORD); weak
// _DWORD __cdecl expand(_DWORD, _DWORD); weak
// _DWORD __cdecl qsort(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_9AD16(unsigned __int16 a1);
int __cdecl sub_9AD9C(int a1);
int __cdecl sub_9ADB4(int a1);
int __fastcall j_j___clock(_DWORD, _DWORD, _DWORD); // weak
bool __cdecl sub_9AE04(int a1, int a2);
char __cdecl sub_9AE90(int *a1, _BYTE *a2, int a3, int a4);
void __cdecl sub_9AEEC(_DWORD **a1, char *a2);
// char __usercall sub_9AFC4@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, int *a4, int a5);
char __cdecl sub_9B038(int *a1, char *a2, int a3);
int __cdecl sub_9B234(int *a1);
int __cdecl sub_9B260(_DWORD **a1);
char __cdecl sub_9B274(int *a1, int a2);
char *__cdecl sub_9B498(char a1);
// double __fastcall _CHP(_DWORD); weak
// _DWORD __cdecl calloc(_DWORD, _DWORD); weak
bool __cdecl sub_9B540(unsigned int a1, unsigned int a2);
bool __cdecl sub_9B5B4(unsigned int a1, unsigned int a2);
void sub_9B628();
int __cdecl sub_9B63C(int a1);
_WORD *__cdecl sub_9B688(int a1);
int __cdecl sub_9B7E8(_DWORD *a1);
// void __usercall __noreturn sub_9BA00(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
// void __usercall __noreturn sub_9BA2C(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
// void __usercall __noreturn sub_9BA58(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
// void __usercall __noreturn sub_9BA84(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
void sub_9BAB0();
int __cdecl sub_9BAC4(int a1, int a2);
int __cdecl sub_9BBFC(int a1);
int __cdecl sub_9BC68(_WORD *a1, int a2, unsigned int a3);
int __cdecl sub_9BD28(int a1);
int __cdecl sub_9BE18(int a1, int a2, char a3, unsigned int a4, unsigned int a5);
int __cdecl sub_9C58C(int a1);
int __cdecl sub_9C810(_DWORD *a1, char a2);
int __cdecl sub_9C938(_DWORD *a1);
bool __cdecl sub_9C9D0(int a1);
void __cdecl sub_9CBBC(_DWORD *a1);
int __cdecl sub_9CCB4(int a1, int a2);
int __cdecl sub_9CCF8(int a1, int a2);
int __cdecl sub_9CD9C(int a1, int a2);
// __int64 __cdecl strtod(_DWORD, _DWORD); weak
// _DWORD __cdecl _set_errno(_DWORD); weak
__int16 __fastcall sub_9D31C(__int16 result);
int __cdecl sub_9D380(int a1, int a2, char a3, int a4, int a5);
int (__cdecl *__cdecl sub_9D3F0(int (__cdecl *a1)(int)))(int);
int (__cdecl *__cdecl sub_9D420(int (__cdecl *a1)(int)))(int);
unsigned int __cdecl sub_9D450(int a1);
int __cdecl sub_9D490(unsigned int a1, int a2);
int __cdecl sub_9D4D0(int a1, unsigned int *a2, _DWORD *a3, _DWORD *a4);
void __cdecl sub_9D560(int a1);
bool __cdecl sub_9D590(unsigned int a1, unsigned int a2);
bool __cdecl sub_9D650(unsigned int a1, unsigned int a2);
bool __cdecl sub_9D710(unsigned int a1, int a2);
bool __cdecl sub_9D740(unsigned int a1, int a2);
int __cdecl sub_9D770(int a1, char a2);
int __cdecl sub_9DE20(int a1);
int __cdecl sub_9DEA0(int a1, int a2);
// _DWORD sscanf(_DWORD, _DWORD, ...); weak
bool sub_9E1B0();
int sub_9E250(); // weak
int __cdecl sub_9E2B0(int a1, int a2, _DWORD *a3);
int __cdecl sub_9E3A0(__int16 *a1, int a2);
int __cdecl sub_9E6E0(int a1, int a2);
// _DWORD *__usercall sub_9E720@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4);
int __cdecl sub_9EA60(unsigned int a1);
void *__cdecl sub_9EB60(int a1);
void __fastcall sub_9EC30(int a1, unsigned __int16 a2);
int sub_9ED70();
bool sub_9EDD0();
int sub_9EE70();
int sub_9F040();
unsigned __int64 __cdecl sub_9F110(int a1);
int __cdecl sub_9F170(int a1, unsigned __int16 a2);
int __cdecl sub_9F1D0(int a1);
int __cdecl sub_9F220(int a1);
int __cdecl sub_9F280(int *a1);
int __cdecl sub_9F2E0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
__int64 __cdecl sub_9F3D0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
int __cdecl sub_9F4F0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
int __cdecl sub_9F5E0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
int __cdecl sub_9F6D0(int *a1, __int16 a2);
void __cdecl sub_9F740(int a1);
void sub_9FA80();
// _DWORD __cdecl open(_DWORD, _DWORD);
// _DWORD __cdecl sopen(_DWORD, _DWORD, char);
// _DWORD __cdecl close(_DWORD); weak
// _DWORD __cdecl read(_DWORD, _DWORD, _DWORD); weak
// double __usercall IF_DPOW@<st0>(double@<st0>, double@<st1>); weak
int __cdecl sub_A0B24(int a1);
int __cdecl sub_A0BB0(int *a1, int a2);
// _DWORD __cdecl abs(_DWORD); weak
int __cdecl sub_A0D2C(unsigned __int8 *a1);
int __cdecl sub_A0D50(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
// _DWORD __cdecl chdir(_DWORD); weak
// _DWORD __cdecl getcwd(_DWORD, _DWORD); weak
// _DWORD __cdecl free(_DWORD); weak
// _DWORD __cdecl outp(_DWORD, char); weak
// _DWORD __cdecl inp(_DWORD); weak
void sub_A0EEC();
void sub_A0EF9();
// int __usercall sub_A0F06@<eax>(__int32 a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, __int32 a6@<edi>, __int32 a7@<esi>);
char __cdecl sub_A102C(int a1);
char __cdecl sub_A105C(unsigned int a1);
void sub_A108F();
void __fastcall sub_A10F4(int a1, unsigned __int16 a2);
int sub_A11E2();
int __fastcall sub_A121D(int a1, __int16 a2, int a3, int a4);
int sub_A1249();
int __cdecl sub_A12C5(int a1, int a2, __int16 a3);
int __cdecl sub_A14DB(int a1);
unsigned int sub_A1520();
void __cdecl sub_A1524(unsigned int a1);
int __cdecl sub_A158B(int a1, __int16 a2, _WORD *a3, _WORD *a4);
unsigned __int8 __cdecl sub_A1665(int a1);
int sub_A16A2();
unsigned int __cdecl sub_A16AE(int a1);
__int32 __cdecl sub_A16F5(int a1, __int32 a2);
void __cdecl sub_A171D(int a1);
void sub_A1744();
void __cdecl sub_A1768(int a1);
void sub_A1798();
void __cdecl sub_A17BC(int a1);
void sub_A17EC();
void __cdecl sub_A1810(int a1, int a2);
void __cdecl sub_A1840(int a1, unsigned int a2);
void __cdecl sub_A1870(int a1, unsigned int a2);
int sub_A18B2();
bool sub_A18BE();
// _DWORD fprintf(_DWORD, _DWORD, ...); weak
// _DWORD __cdecl fopen(_DWORD, _DWORD); weak
// _DWORD __cdecl isatty(_DWORD); weak
// _DWORD __cdecl setbuf(_DWORD, _DWORD); weak
// _DWORD __cdecl time(_DWORD); weak
// int __cdecl localtime(time_t *timer); idb
// int __cdecl asctime(struct tm *timeptr); idb
// _DWORD __cdecl fclose(_DWORD); weak
bool sub_A1F90();
int __cdecl sub_A2070(int a1);
int *__cdecl sub_A20D0(int *a1);
int __cdecl sub_A2110(int *a1);
int sub_A2450(); // weak
int __cdecl sub_A2650(int a1);
int __cdecl sub_A2C80(int *a1, const void *a2);
int sub_A2DE0(); // weak
int *__cdecl sub_A2EA0(int a1, const void *a2);
// int *__usercall sub_A3600@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, const void *a4);
// int *__usercall sub_A36B0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, const void *a5);
// int __usercall sub_A3720@<eax>(int a1@<ecx>, int a2@<ebx>, int **a3);
int __cdecl sub_A37A0(unsigned int *a1);
int __cdecl sub_A37C0(int a1);
int *__cdecl sub_A3820(int a1);
int __cdecl sub_A38C0(int a1);
int __cdecl sub_A38E0(int *a1);
int __cdecl sub_A3A00(int a1);
_DWORD *__cdecl sub_A3A30(_DWORD *a1, int a2, int a3);
int __cdecl sub_A3A70(int *a1, int a2, int a3);
int __cdecl sub_A3AC0(int a1);
int __cdecl sub_A3AF0(int a1, int a2);
int __cdecl sub_A3B10(int a1);
int __cdecl sub_A3B40(int *a1, int a2);
int __cdecl sub_A3B80(int a1);
int __cdecl sub_A3BB0(int *a1, int a2);
int __cdecl sub_A3BF0(int a1);
int __cdecl sub_A3C30(int a1, int a2);
int __cdecl sub_A3C60(int a1);
int __cdecl sub_A3C90(int a1, int a2);
int __cdecl sub_A3CB0(int *a1);
int __cdecl sub_A3D30(int a1);
int __cdecl sub_A3D60(int *a1);
int __cdecl sub_A3DA0(int a1);
int __cdecl sub_A3E10(int a1, int a2);
int __cdecl sub_A3E60(int a1, int a2);
int __cdecl sub_A3EB0(int a1, int a2);
int __cdecl sub_A3F00(int a1, int a2, int a3);
int __cdecl sub_A3F30(int a1, int a2);
int __cdecl sub_A3F70(_DWORD *a1, int a2);
int __cdecl sub_A3FE0(int a1);
char sub_A4000();
int __cdecl sub_A4100(int *a1, int a2, int a3, int a4);
int __cdecl sub_A41B0(_DWORD *a1);
bool sub_A4260();
bool sub_A4330();
int __cdecl sub_A4370(_DWORD *a1);
int __cdecl sub_A4390(int a1);
void __cdecl sub_A43E0(int *a1, int a2);
int sub_A47A0(); // weak
_DWORD *__cdecl sub_A47C0(int a1, int *a2);
int sub_A4920(); // weak
int *__cdecl sub_A4970(int a1, int a2, int a3);
int __cdecl sub_A4B20(int *a1, int a2, int a3);
int __cdecl sub_A4C60(int a1, int a2);
bool sub_A4CB0();
bool sub_A4CF0();
int __cdecl sub_A4E10(char a1);
int __cdecl sub_A4EB0(int a1);
_DWORD *__cdecl sub_A4F10(_DWORD *a1, char a2, char a3, char a4);
int __cdecl sub_A4FD0(int a1, int a2, unsigned int a3);
int __cdecl sub_A5040(_DWORD *a1);
unsigned int __cdecl sub_A50A0(int a1);
unsigned int __cdecl sub_A50F0(int a1, int a2);
int __cdecl sub_A5210(int a1, char a2, unsigned int a3);
int __cdecl sub_A5530(int a1, char a2, unsigned int a3, unsigned __int8 a4);
_DWORD *__cdecl sub_A5850(int a1, char a2, unsigned int a3, int a4, int a5);
char __cdecl sub_A5E50(int *a1);
int __cdecl sub_A5F30(int *a1, int a2);
_DWORD *__cdecl sub_A5FD0(int a1, int a2);
_DWORD *__cdecl sub_A6370(_DWORD *a1);
_DWORD *__cdecl sub_A6490(_DWORD *a1);
int __cdecl sub_A64C0(int a1);
int sub_A6530(); // weak
int __cdecl sub_A6E00(int *a1, const void *a2);
int sub_A6F30(); // weak
int *__cdecl sub_A6FB0(int a1, const void *a2);
// int *__usercall sub_A77D0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, const void *a4);
// int *__usercall sub_A7880@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, const void *a5);
// int __usercall sub_A78F0@<eax>(int a1@<ecx>, int a2@<ebx>, int **a3);
int __cdecl sub_A7970(unsigned int *a1);
int __cdecl sub_A7990(_DWORD *a1);
int __cdecl sub_A7AA0(int a1);
_DWORD *__cdecl sub_A7B30(int a1);
int *__cdecl sub_A7BF0(int *a1);
int __cdecl sub_A7C20(int *a1, int a2, int a3);
int *__cdecl sub_A8010(int *a1);
int __cdecl sub_A8050(int *a1);
void __cdecl sub_A8180(_DWORD *a1);
int __cdecl sub_A8250(int a1);
int __cdecl sub_A82A0(int a1, int a2);
void __cdecl sub_A82C0(_DWORD *a1, int a2, int a3);
void __cdecl sub_A8360(_DWORD *a1, int a2, int a3);
int __cdecl sub_A8410(int a1);
int __cdecl sub_A8440(int a1);
int __cdecl sub_A8470(int a1);
int __cdecl sub_A84A0(int a1);
_DWORD *__cdecl sub_A84D0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_A8550(int a1);
int __cdecl sub_A8570(int *a1, __int16 a2, __int16 a3);
int __cdecl sub_A85B0(int *a1, int a2, int a3);
int __cdecl sub_A8690(int *a1, __int16 a2, __int16 a3);
int __cdecl sub_A86D0(int *a1, __int16 a2, __int16 a3);
int __cdecl sub_A8710(int a1);
int __cdecl sub_A8770(int a1, char a2, unsigned int a3);
int __cdecl sub_A87C0(int a1, int a2);
int __cdecl sub_A8830(_DWORD *a1, _DWORD *a2, int *a3);
_DWORD *__cdecl sub_A8900(_DWORD *a1, int a2);
int __cdecl sub_A89E0(int a1, int a2);
int __cdecl sub_A8A20(int a1, int a2);
int __cdecl sub_A8A60(int a1, int a2);
int __cdecl sub_A8AA0(int a1, int a2);
int __cdecl sub_A8AE0(int a1, int a2);
int __cdecl sub_A8B20(int a1, int a2);
int __cdecl sub_A8B60(int a1, int a2, int a3);
int __cdecl sub_A8B90(int a1, int a2);
int __cdecl sub_A8BD0(int a1, int a2);
int __cdecl sub_A8BF0(_DWORD *a1);
_DWORD *__cdecl sub_A8EA0(_DWORD *a1, int a2);
int __cdecl sub_A9080(_DWORD *a1, int a2, int a3);
int __cdecl sub_A9100(int a1, int a2);
_DWORD *__cdecl sub_A9140(_DWORD *a1, int a2, int a3, unsigned int a4, int a5);
int __cdecl sub_A9230(int a1, int a2);
bool sub_A9280();
bool sub_A9590();
int __cdecl sub_A95D0(int a1, char a2, unsigned int a3, unsigned __int8 a4);
_DWORD *__cdecl sub_A98D0(_DWORD *a1, int a2, int a3);
int __cdecl sub_A9950(int a1, int a2);
int __cdecl sub_A9A30(int a1, int a2);
int sub_A9C00(); // weak
int sub_A9C50(); // weak
_DWORD *__cdecl sub_AA310(int a1, int a2, int a3, int a4);
int __cdecl sub_AA590(int *a1);
bool sub_AA620();
// _DWORD __cdecl creat(_DWORD, _DWORD); weak
// _DWORD __cdecl setmode(_DWORD, _DWORD); weak
// _DWORD __cdecl lseek(_DWORD, _DWORD, char); weak
// _DWORD __cdecl write(_DWORD, _DWORD, _DWORD); weak
int __fastcall sub_AB610(int a1, int a2);
// _DWORD __cdecl tolower(_DWORD); weak
int __cdecl sub_AB9E1(int a1);
int sub_AC24B();
int __cdecl sub_AC250(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, _DWORD *a7, int *a8);
void sub_AC449();
void sub_AC44B();
__int16 __fastcall sub_AC70E(int a1, int a2, int a3, int a4);
void sub_AC7D9();
__int16 __fastcall sub_AC7F6(int a1, int a2, int a3);
__int16 sub_AC843();
__int16 sub_AC8DD();
__int16 sub_AC918();
void *sub_AC9C3();
void *sub_AC9C9();
// _DWORD __cdecl fputc(_DWORD, _DWORD); weak
int __cdecl sub_ACB61(int a1, unsigned __int8 *a2, int *a3);
unsigned __int8 *__cdecl sub_ACD79(unsigned __int8 *a1, int a2);
int __cdecl sub_ACE56(int a1);
// int __usercall sub_ACE8D@<eax>(_WORD *a1@<esi>, int a2, int *a3);
// void __usercall sub_ACF1A(_BYTE *a1@<esi>, int a2, int *a3);
int *__cdecl sub_AD033(int a1, int *a2, int a3);
_BYTE *__cdecl sub_AD09E(_BYTE *a1, int a2);
// void __usercall sub_AD0E2(_BYTE *a1@<esi>, int a2, int *a3, _BYTE **a4);
void __cdecl sub_AD1E8(int a1, int *a2);
void __cdecl sub_AD52B(int a1, int *a2, int a3, int a4);
int __cdecl sub_AD754(int a1);
int __cdecl sub_AD783(int a1);
// _DWORD __cdecl fgets(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl memmove(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl strncpy(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl dos_read(_DWORD, char, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_ADC52(_BYTE *a1);
int sub_AEAF5();
// int __usercall sub_AEF40@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AEF51@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AEF5D@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AEF7C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// char __usercall sub_AEF90@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// char __usercall sub_AEFAF@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AEFC3@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AEFE0@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AEFF2@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF00F@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF021@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF035@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// __int16 __usercall sub_AF044@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// __int16 __usercall sub_AF05A@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF06B@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF08C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF0A2@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF0C3@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF0D9@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF0FE@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF118@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF13D@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF157@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF17A@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF192@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF1B5@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF1CD@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF1F4@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF210@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF237@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF253@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF280@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF2A8@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF301@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// char __usercall sub_AF34F@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// char __usercall sub_AF3A8@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF3F6@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF44D@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF499@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF4F0@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF53C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF56C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// __int16 __usercall sub_AF597@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// __int16 __usercall sub_AF5C9@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF5F6@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF651@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF6A1@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF6FC@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF74C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// __int16 __usercall sub_AF7AB@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF7FF@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// __int16 __usercall sub_AF85E@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_AF8B2@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF90F@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF961@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AF9BE@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AFA10@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// __int16 __usercall sub_AFA71@<ax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AFAC7@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// __int16 __usercall sub_AFB28@<ax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_AFB7E@<eax>(int result@<eax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>);
// int __usercall sub_AFB9F@<eax>(int result@<eax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>);
// int __usercall sub_AFBC3@<eax>(int result@<eax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// int __usercall sub_AFBF5@<eax>(int result@<eax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_AFC27@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>);
// __int16 __usercall sub_AFC4B@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>);
// __int16 __usercall sub_AFC72@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>);
// __int16 __usercall sub_AFCA6@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>);
// __int16 __usercall sub_AFCDA@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>);
// __int16 __usercall sub_AFCF6@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>);
// __int16 __usercall sub_AFD15@<ax>(__int16 result@<ax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_AFD3C@<ax>(__int16 result@<ax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_AFD63@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>);
// __int16 __usercall sub_AFD82@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>);
// __int16 __usercall sub_AFDA4@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>);
// __int16 __usercall sub_AFDCD@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>);
// int __usercall sub_AFDF6@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// int __usercall sub_AFE22@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// int __usercall sub_AFE51@<eax>(int result@<eax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// int __usercall sub_AFE91@<eax>(int result@<eax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// __int16 __usercall sub_AFED1@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>);
// __int16 __usercall sub_AFF03@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>);
// __int16 __usercall sub_AFF38@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>);
// __int16 __usercall sub_AFF7A@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>);
// __int16 __usercall sub_AFFBC@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_AFFE3@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_B000D@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// __int16 __usercall sub_B0042@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// __int16 __usercall sub_B0077@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B00A4@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B00D4@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B010B@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// char __usercall sub_B0142@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// char __usercall sub_B015E@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// char __usercall sub_B0184@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// char __usercall sub_B01AE@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// char __usercall sub_B01D9@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// char __usercall sub_B0203@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// int __usercall sub_B022E@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>);
// int __usercall sub_B0258@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>);
// int __usercall sub_B0292@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>);
// int __usercall sub_B02D5@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>);
// int __usercall sub_B0319@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>);
// int __usercall sub_B035C@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>);
// __int16 __usercall sub_B03A0@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B03C5@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B03FA@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B0432@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B046B@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_B04A3@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// char __usercall sub_B04DC@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// char __usercall sub_B0503@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// char __usercall sub_B0534@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, _BYTE *a6@<esi>);
// char __usercall sub_B056C@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, _BYTE *a6@<esi>);
// char __usercall sub_B05A5@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, _BYTE *a6@<esi>);
// char __usercall sub_B05DD@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, _BYTE *a6@<esi>);
// int __usercall sub_B0616@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>);
// int __usercall sub_B064E@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>);
// int __usercall sub_B0696@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>);
// int __usercall sub_B06E7@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>);
// int __usercall sub_B0739@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>);
// int __usercall sub_B078A@<eax>(int result@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _WORD *a5@<esi>);
// __int16 __usercall sub_B07DC@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>);
// __int16 __usercall sub_B080F@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>);
// __int16 __usercall sub_B0852@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>);
// __int16 __usercall sub_B0898@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>);
// __int16 __usercall sub_B08DF@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>);
// __int16 __usercall sub_B0925@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>);
int __cdecl sub_B096C(int a1);
int __cdecl sub_B0B87(_DWORD *a1, int a2);
int __cdecl sub_B0C1A(int a1);
bool sub_B0C46();
char *sub_B0CC8();
void sub_B0CD2();
void sub_B0D52();
void sub_B0D80();
int __cdecl sub_B1138(int *a1, int a2);
int __cdecl sub_B11E8(_DWORD *a1, int a2);
int __cdecl sub_B12A4(int a1);
int __cdecl sub_B1304(int a1, int a2);
int __cdecl sub_B1414(int a1);
int __cdecl sub_B148C(int a1);
int __cdecl sub_B14F8(int *a1, int a2);
char __cdecl sub_B1C58(int a1, __int16 a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, __int16 a15);
// int __usercall sub_B1D8C@<eax>(int a1@<ebp>, int a2@<edi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, char a29);
// int __usercall sub_B1DC8@<eax>(int a1@<ebp>, int a2@<edi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, char a29);
// int __usercall sub_B1E68@<eax>(int result@<eax>, int a2@<ecx>, _BYTE *a3@<ebp>);
void sub_B1EB6();
void sub_B1EBC();
void sub_B1EC2();
void sub_B1EC8();
void sub_B1ECE();
void sub_B1ED6();
void sub_B1EDC();
void sub_B1EE2();
void sub_B1EE8();
void sub_B1EF0();
void sub_B1EF8();
void sub_B1F00();
void sub_B1F08();
void sub_B1F12();
void sub_B1F1C();
void sub_B1F24();
void sub_B1F2C();
void sub_B1F35();
void sub_B1F3E();
void sub_B1F47();
void sub_B1F50();
void sub_B1F5B();
void sub_B1F66();
void sub_B1F6F();
// char __usercall sub_B1F78@<al>(unsigned __int8 a1@<ah>, int a2@<ebx>, _BYTE *a3@<esi>);
// int __usercall sub_B1FB5@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_B1FD4@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_B1FF3@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B200F@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B202B@<eax>(int a1@<ebp>, signed int *a2@<esi>);
// int __usercall sub_B204A@<eax>(int a1@<ebp>, signed int *a2@<esi>);
// int __usercall sub_B2069@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_B2088@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_B20A7@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B20E1@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// void __usercall sub_B20F2(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// int __usercall sub_B2103@<eax>(void *a1@<ebp>, const void *a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, char a29);
// int __usercall sub_B2121@<eax>(int a1@<ebp>, __int16 *a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, char a29);
// int __usercall sub_B2161@<eax>(const void *a1@<ebp>, void *a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, char a29);
// int __usercall sub_B2175@<eax>(_WORD *a1@<ebp>, _WORD *a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, char a29);
// int __usercall sub_B2183@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// int __usercall sub_B21A2@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// int __usercall sub_B21C1@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B21DD@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B21F9@<eax>(int a1@<ebp>, int *a2@<esi>);
// int __usercall sub_B2218@<eax>(int a1@<ebp>, int *a2@<esi>);
// int __usercall sub_B2237@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// int __usercall sub_B2256@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// int __usercall sub_B2275@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B22AF@<eax>(_WORD *a1@<ebp>, int a2@<edi>, _DWORD *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// void __usercall sub_B22EB(_WORD *a1@<ebp>, int a2@<edi>, _DWORD *a3@<esi>);
// int __usercall sub_B230F@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>);
// int __usercall sub_B2332@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>);
// int __usercall sub_B2355@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B2375@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B2395@<eax>(int a1@<ebp>, __int64 *a2@<esi>);
// int __usercall sub_B23B8@<eax>(int a1@<ebp>, __int64 *a2@<esi>);
// int __usercall sub_B23DB@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>);
// int __usercall sub_B23FE@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>);
// int __usercall sub_B2421@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B2468@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B24A6@<eax>(int a1@<edx>, _BYTE *a2@<ebp>, int a3@<edi>, int *a4@<esi>, int a5, __int16 a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, __int16 a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, char a31);
// void __usercall sub_B24BB(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// void __usercall sub_B24D9(int a1@<edx>, _BYTE *a2@<ebp>, int a3@<edi>, int *a4@<esi>);
// int __usercall sub_B24EE@<eax>(_DWORD *a1@<ebp>, _DWORD *a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, char a29);
// void __usercall sub_B2535(char *a1@<ebp>, int a2@<edi>, _DWORD *a3@<esi>);
// int __usercall sub_B2560@<eax>(int a1@<ebp>, _WORD *a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, char a29);
// int __usercall sub_B256E@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>);
// int __usercall sub_B258F@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>);
// int __usercall sub_B25B0@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B25CE@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B25EC@<eax>(int a1@<ebp>, __int16 *a2@<esi>);
// int __usercall sub_B260D@<eax>(int a1@<ebp>, __int16 *a2@<esi>);
// int __usercall sub_B262E@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>);
// int __usercall sub_B264F@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>);
// int __usercall sub_B2670@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B26AC@<eax>(_WORD *a1@<ebp>, int a2@<edi>, _WORD *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// void __usercall sub_B26F4(_WORD *a1@<ebp>, int a2@<edi>, _WORD *a3@<esi>);
// int __usercall sub_B2729@<eax>(int a1@<ebp>, int a2@<edi>, unsigned int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// void __usercall sub_B2768(_WORD *a1@<ebp>, int a2@<edi>, int *a3@<esi>);
_DWORD __cdecl sub_B278C(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char); // weak
// int __usercall sub_B2791@<eax>(int a1@<ebx>, int a2, __int16 a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, __int16 a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, char a28);
// int __usercall sub_B27BE@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B27D3@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B27E8@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B27FA@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B280C@<eax>(int a1@<ebp>);
// int __usercall sub_B2821@<eax>(int a1@<ebp>);
// int __usercall sub_B2836@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B284B@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B2860@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B28A8@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B2951@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B2B6C@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4@<ebp>, int a5@<edi>, int a6@<esi>, int a7, __int16 a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, __int16 a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, char a33);
_DWORD sub_B2C76(); // weak
// int __usercall sub_B2D8E@<eax>(int a1@<ebx>, int a2, __int16 a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, __int16 a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, char a28);
// int __usercall sub_B2E17@<eax>(int a1@<ebx>, int a2@<ebp>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, char a29);
// int __usercall sub_B2E71@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B2E86@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B2E9B@<eax>(int a1@<ebp>);
// int __usercall sub_B2EB0@<eax>(int a1@<ebp>);
// int __usercall sub_B2EC5@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B2EDA@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B2EEF@<eax>(int a1@<ebp>, int a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, char a29);
// int __usercall sub_B2F0E@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B2F3A@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// int __usercall sub_B2F4C@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, char a30);
// void __usercall sub_B2F5E(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B2F8A@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B2FD5@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B3020@<eax>(int a1@<ebx>, int a2, __int16 a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, __int16 a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, char a28);
// int __usercall sub_B30A9@<eax>(int a1@<ebp>, int a2@<edi>);
// int __usercall sub_B30F4@<eax>(int a1@<ebp>, int a2@<edi>);
// int __usercall sub_B313F@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B318A@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_B31D5@<eax>(int a1@<ebx>, int a2@<ebp>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, char a29);
void sub_B336E();
// int __usercall sub_B337C@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>);
// int __userpurge sub_B33A6@<eax>(int a1@<eax>, int a2@<esi>, int a3, int a4, __int16 a5);
// int __usercall sub_B33D6@<eax>(__int64 a1@<edx:eax>, int a2@<ecx>, int a3@<ebx>, int a4@<esi>);
int __fastcall sub_B3542(unsigned int a1, int a2);
// int __usercall sub_B35DB@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebp>, int a4@<esi>);
// int __usercall sub_B3605@<eax>(unsigned __int64 a1@<edx:eax>, int a2@<ecx>, unsigned int a3@<ebx>, _BYTE *a4@<ebp>, int a5@<esi>);
// int __usercall sub_B37B0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>);
// int __usercall sub_B37DA@<eax>(unsigned __int64 a1@<edx:eax>, unsigned int a2@<ecx>, unsigned int a3@<ebx>, int a4@<esi>);
void sub_B392B();
int __fastcall sub_B3930(int *a1);
int __fastcall sub_B399A(int a1);
int __fastcall sub_B39AB(unsigned int a1, int a2);
// int __usercall sub_B39E0@<eax>(__int64 a1@<edx:eax>, int a2@<ebx>, _BYTE *a3@<ebp>);
int __fastcall sub_B3A60(int a1);
// int __usercall sub_B3ADF@<eax>(__int64 *a1@<eax>, _BYTE *a2@<ebp>);
signed int __fastcall sub_B3BA6(signed int result, int a2);
unsigned int __fastcall sub_B3C6B(unsigned int result, __int16 a2);
// __int16 __usercall sub_B3DF8@<ax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _BYTE *a4@<ebp>, int a5@<esi>);
// __int16 __usercall __spoils<> sub_B3EAE@<ax>(int a1@<eax>, _BYTE *a2@<ebp>, int a3@<esi>);
// int __usercall sub_B4011@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>);
// int __usercall sub_B4077@<eax>(__int64 a1@<edx:eax>, unsigned int a2@<ecx>, unsigned int a3@<ebx>, __int16 a4@<di>, __int16 a5@<si>);
// int __usercall sub_B41E0@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebp>, int a4@<esi>);
// int __usercall sub_B41F9@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebp>, int a4@<esi>);
// int __usercall sub_B423C@<eax>(int a1@<eax>, _BYTE *a2@<ebp>);
// int __usercall sub_B44D4@<eax>(int a1@<eax>, int a2@<esi>);
int __fastcall sub_B46CB(int a1);
int __fastcall sub_B46D5(int a1);
int __fastcall sub_B46E2(int a1);
int sub_B46F0(); // weak
int __fastcall sub_B4718(int a1, int a2, int a3, int a4);
int __fastcall sub_B48EC(unsigned __int64 a1);
// void __usercall sub_B49D8(int a1@<ecx>, int a2@<esi>);
// int __usercall sub_B4A2A@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>);
// int __fastcall _hook387(_DWORD, _DWORD, _DWORD); weak
// int _FDFS(void); weak
// _DWORD __cdecl fputs(_DWORD, _DWORD); weak
// _DWORD __cdecl strerror(_DWORD); weak
void __spoils<edx> sub_B4F46();
void __spoils<edx> sub_B4FA3();
void sub_B5000();
void __noreturn sub_B5015();
void __noreturn sub_B5022();
// void __usercall sub_B5128(__int16 a1@<bx>, double *a2@<edi>, double a3@<st0>);
// void __usercall sub_B51B3(__int16 a1@<bx>, int a2@<ebp>, double *a3@<edi>, __int16 a4@<fpstat>, double a5@<st0>);
// double __usercall sub_B5205@<st0>(char a1@<bh>, int a2@<ebp>, __int16 a3@<fpstat>, double a4@<st0>);
// __int64 __usercall sub_B522B@<edx:eax>(int a1@<edx>, __int16 a2@<bx>, int _ESI@<esi>);
// double __usercall sub_B5250@<st0>(char a1@<bl>, double *a2@<edi>, double result@<st0>);
// int _Phar_hook_init(void); weak
// int _Phar_hook_fini(void); weak
// int _DOS4G_hook_init(void); weak
// int _DOS4G_hook_fini(void); weak
// int _Ergo_hook_init(void); weak
// int _Ergo_hook_fini(void); weak
// int _Intel_hook_init(void); weak
// int _Intel_hook_fini(void); weak
int sub_B5C5B();
int __cdecl sub_B5C60(__int16 a1, __int16 a2);
int __cdecl sub_B5D68(__int16 a1, __int16 a2);
void __cdecl __spoils<> sub_B5E70(__int16 a1, unsigned __int16 a2, __int16 a3);
// __int16 __usercall sub_B5EFA@<ax>(__int16 a1@<cx>, int a2@<ebx>, int a3@<ebp>, __int16 a4@<si>);
// __int16 __usercall sub_B5F8F@<ax>(__int16 a1@<cx>, int a2@<ebx>, int a3@<ebp>, __int16 a4@<si>);
void __cdecl __spoils<> sub_B6253(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void __cdecl __spoils<> sub_BCD45(int a1, int a2, int a3, int a4, int a5);
void __cdecl __spoils<> sub_BD1B6(int a1);
void __cdecl __spoils<> sub_BD2CB(int a1);
// int __usercall sub_BD320@<eax>(int result@<eax>, _BYTE *a2@<edx>, _BYTE *a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<esi>);
void sub_BD3DD();
void sub_BD524();
void __cdecl __spoils<> sub_BD542(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, char a5);
// int __fastcall gettextposition(_DWORD); weak
// _DWORD __cdecl settextposition(_DWORD, _DWORD); weak
// _DWORD __cdecl outtext(_DWORD); weak
int sub_BF123();
int __far sub_C0000(); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_10001; // weak
_UNKNOWN loc_20000; // weak
char aXX[6] = "X\x1BX\x1B\n"; // weak
_UNKNOWN loc_269F8; // weak
_UNKNOWN loc_2FED1; // weak
_UNKNOWN loc_2FED5; // weak
_UNKNOWN loc_3030E; // weak
_UNKNOWN loc_30325; // weak
_UNKNOWN loc_36479; // weak
_UNKNOWN loc_364D1; // weak
_UNKNOWN loc_3653D; // weak
_UNKNOWN loc_36541; // weak
_UNKNOWN loc_36543; // weak
_UNKNOWN loc_36546; // weak
_UNKNOWN loc_3654B; // weak
_UNKNOWN loc_3654E; // weak
_UNKNOWN loc_36550; // weak
char byte_3659C[] = { 'f' }; // weak
char byte_3659D[] = { '\x89' }; // weak
char byte_3659F[] = { ',' }; // weak
_UNKNOWN loc_365F2; // weak
_UNKNOWN loc_36CAA; // weak
_UNKNOWN loc_36DE9; // weak
_UNKNOWN loc_36DEC; // weak
_UNKNOWN loc_36DFC; // weak
_UNKNOWN loc_36E03; // weak
_UNKNOWN loc_36E09; // weak
_UNKNOWN loc_36F44; // weak
_UNKNOWN loc_3A013; // weak
_UNKNOWN loc_40000; // weak
_UNKNOWN loc_42471; // weak
_UNKNOWN loc_4AFFE; // weak
char algn_4BB85[11] = { '\x8D', '\x80', '\0', '\0', '\0', '\0', '\x8D', 'R', '\0', '\x8B', '\xDB' }; // weak
_UNKNOWN loc_4D54A; // weak
_UNKNOWN loc_568AA; // weak
_UNKNOWN loc_64000; // weak
_UNKNOWN loc_712C2; // weak
__int16 word_727B0[] = { 1 }; // weak
_UNKNOWN loc_783BD; // weak
_UNKNOWN loc_7FFFF; // weak
_UNKNOWN loc_87D80; // weak
_UNKNOWN loc_91856; // weak
_UNKNOWN loc_91C54; // weak
// extern _UNKNOWN _GETDS; weak
// extern _UNKNOWN loc_A0000; weak
int dword_A1270 = 1397753374; // weak
__int16 word_A1277 = -26215; // weak
__int16 word_A1286 = -26215; // weak
int dword_A128C = -1717986919; // weak
__int16 word_A12A2 = -26215; // weak
__int16 word_A12AC = -26215; // weak
__int16 word_A12B3 = -26215; // weak
int dword_A9390[] = { 8 }; // weak
int (*funcs_B0C0B[2])() = { &sub_AEF40, &sub_AEF51 }; // weak
int (*funcs_B0AC1[2])() = { &sub_AFB7E, &sub_AFB9F }; // weak
_UNKNOWN loc_AFFFE; // weak
void *off_B1854 = &loc_A0000; // weak
int dword_B1858[2] = { 70, 0 }; // weak
int dword_B1860[41] =
{
  20,
  67584,
  1966080,
  268435466,
  2,
  1310760,
  202752,
  3276800,
  536870942,
  4,
  2621500,
  337920,
  4587520,
  805306418,
  6,
  3932160,
  473088,
  -262144,
  1,
  196610,
  327667,
  524288,
  -3211252,
  16,
  3145760,
  4259647,
  8388608,
  -50396992,
  256,
  50332160,
  67171327,
  134217728,
  -805368832,
  4096,
  805314560,
  1073758207,
  2147483648,
  1073856512,
  33572096,
  50414144,
  -611892415
}; // weak
int (*funcs_B1CA2[24])() =
{
  &sub_B1EB6,
  &sub_B1EBC,
  &sub_B1EC2,
  &sub_B1EC8,
  &sub_B1F78,
  &sub_B1ED6,
  &sub_B1EDC,
  &sub_B1EE2,
  &sub_B1EE8,
  &sub_B1EF0,
  &sub_B1EF8,
  &sub_B1F00,
  &sub_B1F78,
  &sub_B1F12,
  &sub_B1F1C,
  &sub_B1F24,
  &sub_B1F2C,
  &sub_B1F35,
  &sub_B1F3E,
  &sub_B1F47,
  &sub_B1F78,
  &sub_B1F5B,
  &sub_B1F66,
  &sub_B1F6F
}; // weak
int (*funcs_B1F8B[24])() =
{
  &sub_B1EB6,
  &sub_B1EBC,
  &sub_B1EC2,
  &sub_B1EC8,
  &sub_B1ECE,
  &sub_B1ED6,
  &sub_B1EDC,
  &sub_B1EE2,
  &sub_B1EE8,
  &sub_B1EF0,
  &sub_B1EF8,
  &sub_B1F00,
  &sub_B1F08,
  &sub_B1F12,
  &sub_B1F1C,
  &sub_B1F24,
  &sub_B1F2C,
  &sub_B1F35,
  &sub_B1F3E,
  &sub_B1F47,
  &sub_B1F50,
  &sub_B1F5B,
  &sub_B1F66,
  &sub_B1F6F
}; // weak
void *off_B2947 = &unk_17A6E8; // weak
_UNKNOWN loc_B2C44; // weak
int (__cdecl *funcs_B2D8E[8])(int, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16, int, int, int, int, int, int, int, int, int, int, int, char) =
{
  &sub_B278C,
  &loc_B2DB6,
  &sub_B278C,
  &sub_B278C,
  &sub_B278C,
  &sub_B278C,
  &sub_B278C,
  &sub_B278C
}; // weak
int (__cdecl *funcs_B3020[8])(int, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16, int, int, int, int, int, int, int, int, int, int, int, char) =
{
  &sub_B278C,
  &loc_B3048,
  &sub_B278C,
  &sub_B278C,
  &sub_B278C,
  &sub_B278C,
  &sub_B278C,
  &sub_B278C
}; // weak
int dword_B3BEB[] = { 2147483647 }; // weak
__int16 word_B3D9E = 6222; // weak
__int16 word_B419A = 18153; // weak
int dword_B41B8 = 0; // weak
__int16 word_B440E[] = { 21337 }; // weak
int dword_B4468[19] =
{
  -1648297841,
  -683696327,
  -385531950,
  -1522138140,
  -1076180533,
  -960184918,
  -1888041089,
  -476626974,
  2109457658,
  -1075211278,
  218157069,
  -804454192,
  -1240776721,
  1622543200,
  -1074416117,
  -1431655766,
  -1431655766,
  16378,
  0
}; // weak
__int16 word_B44C2[] = { 0 }; // weak
int dword_B8845[] = { 0 }; // weak
char byte_C0134[3788] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char aDataSearchDat[16] = "data/search.dat"; // weak
char aNoHelpData[13] = "No Help Data"; // weak
char aOk[4] = "@OK"; // weak
char aOk_0[6] = " * OK"; // weak
char aSound[6] = "sound"; // weak
char aNetherw[9] = "/netherw"; // weak
char aErrorNotEnough[37] = "ERROR: NOT ENOUGH MEMORY FOR SOUNDS\n"; // weak
char aDataMwebd00Tab[18] = "data/mwebd0-0.tab"; // weak
char aDataHwebd00Tab[18] = "data/hwebd0-0.tab"; // weak
char aDataMwebn00Tab[18] = "data/mwebn0-0.tab"; // weak
char aDataHwebn00Tab[18] = "data/hwebn0-0.tab"; // weak
char aDataMwebc00Tab[18] = "data/mwebc0-0.tab"; // weak
char aDataHwebc00Tab[18] = "data/hwebc0-0.tab"; // weak
char aDataMsprd00Dat_0[18] = "data/msprd0-0.dat"; // weak
char aDataMsprd00Tab[18] = "data/msprd0-0.tab"; // weak
char aDataHsprd00Dat_0[18] = "data/hsprd0-0.dat"; // weak
char aDataHsprd00Tab[18] = "data/hsprd0-0.tab"; // weak
char aDataMsprn00Dat[18] = "data/msprn0-0.dat"; // weak
char aDataMsprn00Tab[18] = "data/msprn0-0.tab"; // weak
char aDataHsprn00Dat[18] = "data/hsprn0-0.dat"; // weak
char aDataHsprn00Tab[18] = "data/hsprn0-0.tab"; // weak
char aDataMsprc00Dat[18] = "data/msprc0-0.dat"; // weak
char aDataMsprc00Tab[18] = "data/msprc0-0.tab"; // weak
char aDataHsprc00Dat[18] = "data/hsprc0-0.dat"; // weak
char aDataHsprc00Tab[18] = "data/hsprc0-0.tab"; // weak
char aDataPald0Dat[16] = "data/pald-0.dat"; // weak
char aDataClrd0Dat[16] = "data/clrd-0.dat"; // weak
char aDataPalf0Dat[16] = "data/palf-0.dat"; // weak
char aDataPaln0Dat[16] = "data/paln-0.dat"; // weak
char aDataClrn0Dat[16] = "data/clrn-0.dat"; // weak
char aDataPalc0Dat[16] = "data/palc-0.dat"; // weak
char aDataClrc0Dat[16] = "data/clrc-0.dat"; // weak
char aDataSmatitleDa[18] = "data/smatitle.dat"; // weak
char aDataSmatitl2Da[18] = "data/smatitl2.dat"; // weak
char aDataSmatitlePa[18] = "data/smatitle.pal"; // weak
char aDataSmatitl2Pa[18] = "data/smatitl2.pal"; // weak
char aCheatAccessAll[28] = ".. CHEAT: access all spells"; // weak
char aCheatMoreMana[20] = ".. CHEAT: more mana"; // weak
char aCheatDestroyAl[30] = ".. CHEAT: destroy all players"; // weak
char aCheatDestroyAl_0[30] = ".. CHEAT: destroy all castles"; // weak
char aCheatDestroyAl_1[31] = ".. CHEAT: destroy all balloons"; // weak
char aCheatHeal[15] = ".. CHEAT: heal"; // weak
char aCheatKillAllCr[29] = ".. CHEAT: Kill all creatures"; // weak
char aCheatMoreSpell[39] = ".. CHEAT: More Spell Experience Points"; // weak
char aCheatFreeSpell[31] = ".. CHEAT: Free Spell Usage OFF"; // weak
char aCheatFreeSpell_0[30] = ".. CHEAT: Free Spell Usage ON"; // weak
char aCheatInvincabi[27] = ".. CHEAT: Invincability ON"; // weak
char aCheatInvincabi_0[28] = ".. CHEAT: Invincability OFF"; // weak
char aClevels[8] = "clevels"; // weak
char aNetherw_0[9] = "/netherw"; // weak
char aLevelsLevelsDa[18] = "levels/levels.dat"; // weak
char aLevelsLevelsTa[18] = "levels/levels.tab"; // weak
char aErrorDecompres[32] = "ERROR decompressing levels.dat\n"; // weak
char aMovie[6] = "movie"; // weak
char aDataBldgprmDat[17] = "data/bldgprm.dat"; // weak
char aVe[4] = "ve/"; // weak
char aErrorDecompres_0[24] = "ERROR decompressing %s\n"; // weak
char aCheckingSetupV[26] = "Checking Setup Version .."; // weak
char aVersionDat[12] = "version.dat"; // weak
char aCdata[6] = "cdata"; // weak
char asc_D0650[2] = "\n"; // weak
char aTmaps00[9] = "tmaps0-0"; // weak
char aCreatingSetupD[32] = "Creating Setup Directories 1 .."; // weak
char aData[5] = "data"; // weak
char aTmaps10[9] = "tmaps1-0"; // weak
char aCreatingSetupD_0[32] = "Creating Setup Directories 2 .."; // weak
char aTmaps20[9] = "tmaps2-0"; // weak
char aCreatingSetupD_1[32] = "Creating Setup Directories 3 .."; // weak
char aSettingUpLevel[21] = "Setting Up Levels .."; // weak
char aLevels[7] = "levels"; // weak
char aDataBlock16Dat_0[17] = "data/block16.dat"; // weak
char aDataSkyd00Dat[17] = "data/skyd0-0.dat"; // weak
char aDataBlock32Dat_0[17] = "data/block32.dat"; // weak
char aDataTmaps00Tab[18] = "data/tmaps0-0.tab"; // weak
char aDataBl16f00Dat[18] = "data/bl16f0-0.dat"; // weak
char aDataBl16n00Dat[18] = "data/bl16n0-0.dat"; // weak
char aDataSkyn00Dat[17] = "data/skyn0-0.dat"; // weak
char aDataBl32f00Dat[18] = "data/bl32f0-0.dat"; // weak
char aDataBl32n00Dat[18] = "data/bl32n0-0.dat"; // weak
char aDataTmaps10Tab[18] = "data/tmaps1-0.tab"; // weak
char aDataBl16c00Dat[18] = "data/bl16c0-0.dat"; // weak
char aDataBl32c00Dat[18] = "data/bl32c0-0.dat"; // weak
char aDataTmaps20Tab[18] = "data/tmaps2-0.tab"; // weak
char aDataTablesdDat[17] = "data/tablesd.dat"; // weak
char aDataTablesnDat[17] = "data/tablesn.dat"; // weak
char aDataTablescDat[17] = "data/tablesc.dat"; // weak
char aSmap[5] = "SMAP"; // weak
char aSlev[5] = "SLEV"; // weak
char aSave[5] = "save"; // weak
char aSver[5] = "SVER"; // weak
char aDeviceNoneDriv[82] = "DEVICE\t\tNone\r\nDRIVER\t\tNone\r\nIO_ADDR\t\t-1\r\nIRQ\t\t-1\r\nDMA_8_BIT\t\t-1\r\nDMA_16_BIT\t\t-1\r\n"; // weak
char aSound_0[6] = "sound"; // weak
char aNetherw_1[9] = "/netherw"; // weak
char aNetwork[8] = "network"; // weak
char aLevel[6] = "level"; // weak
char aHarddrive[10] = "harddrive"; // weak
char aSkipscreens[12] = "skipscreens"; // weak
char aNocd[5] = "nocd"; // weak
char aShowversion[12] = "showversion"; // weak
char aShowversion2[13] = "showversion2"; // weak
char aDetectoff[10] = "detectoff"; // weak
char aLangcheck[10] = "langcheck"; // weak
char aMavio[6] = "MAvio"; // weak
char aExtern[7] = "extern"; // weak
char aExternalCtrlAt[22] = "External ctrl at %ul\n"; // weak
char aVfx1[5] = "VFX1"; // weak
char aScc[6] = "/%scc"; // weak
char aSpellsedit[11] = "spellsedit"; // weak
char aMusic2[7] = "music2"; // weak
char aErrorCantAlloc[31] = "ERROR: CANT ALLOC TAPE MEMORY."; // weak
char aErrorCantAlloc_0[33] = "ERROR: CANT ALLOC CARPET MEMORY."; // weak
char aDataPald0Dat_0[16] = "data/pald-0.dat"; // weak
char aDataClrd0Dat_0[16] = "data/clrd-0.dat"; // weak
char aSave_0[5] = "save"; // weak
char aNetherw_2[9] = "/netherw"; // weak
char aCdata_0[6] = "cdata"; // weak
char aClevels_0[8] = "clevels"; // weak
char aSound_1[6] = "sound"; // weak
char aLanguage[9] = "language"; // weak
char aShots[6] = "shots"; // weak
char aDataSpellsDat[16] = "data/spells.dat"; // weak
char aErrorMouseDriv[36] = "ERROR : MOUSE DRIVER NOT INSTALLED\n"; // weak
char aErrorCopyingDa[42] = "ERROR COPYING DATA FILES TO LOCAL DRIVE \n"; // weak
char aErrorCreatingS[35] = "Error creating setup directories.\n"; // weak
char aNoVesaDriverDe[25] = "NO VESA DRIVER DETECTED\n"; // weak
char aNotEnoughMemor[19] = "NOT ENOUGH MEMORY\n"; // weak
char aNetherw_3[8] = "NETHERW"; // weak
char byte_D0C18 = '\0'; // weak
char aTa[5] = "ta/\n"; // weak
char asc_D0C20[61] = "***********************************************************\n"; // weak
char aTestersWriteDo[61] = "*   TESTERS: WRITE DOWN THE ABOVE VERSION DATE AND TIME.  *\n"; // weak
char aPressReturnToC[61] = "*   Press RETURN to continue...                           *\n"; // weak
char asc_D0CE0[61] = "***********************************************************\n"; // weak
char aDataGtd2Dat[14] = "data/gtd2.dat"; // weak
char aProductName[13] = "Product name"; // weak
char aMagicCarpet2Ne[30] = "Magic Carpet 2 (Netherworlds)"; // weak
char aVersionNumber[15] = "Version number"; // weak
char aBeta[5] = "Beta"; // weak
char aVersionDate[13] = "Version date"; // weak
char aSep061995[12] = "Sep 06 1995"; // weak
char a034213[9] = "03:42:13"; // weak
char aProgrammer[11] = "Programmer"; // weak
char aBullfrogAlanWr[23] = "Bullfrog, Alan Wright."; // weak
char aSuppliedTo[12] = "Supplied to"; // weak
char aPublic[7] = "PUBLIC"; // weak
char aLevelNumber[13] = "Level Number"; // weak
char aTransferRate[15] = "Transfer rate:"; // weak
char aHfps[5] = "hFPS"; // weak
char aSoundNumber[13] = "Sound Number"; // weak
char aGameTurn[10] = "Game turn"; // weak
char aThing[6] = "Thing"; // weak
char aMemoryUsedFree[19] = "Memory (Used/Free)"; // weak
char aThing_0[6] = "THING"; // weak
char aClassModelStat[22] = "CLASS / MODEL / STATE"; // weak
char aLifeMaxLife[16] = "LIFE / MAX LIFE"; // weak
char aSpeedActualMin[33] = "SPEED ACTUAL / MINIMUM / MAXIMUM"; // weak
char aActualXYZ[17] = "ACTUAL X / Y / Z"; // weak
char aIdWhoOwnsMe[17] = "ID / WHO OWNS ME"; // weak
char aManaActualMaxi[22] = "MANA ACTUAL / MAXIMUM"; // weak
char aCopyrightC1995[46] = "Copyright (c) 1995 Bullfrog Productions Ltd.\n"; // weak
char aAllRightsReser[22] = "All rights reserved.\n"; // weak
char aS_0[5] = "%s \n"; // weak
void *off_D189C = (void *)0xA7325; // weak
char aTmaps00_0[9] = "tmaps0-0"; // weak
char aCdata_1[6] = "cdata"; // weak
char aNetherw_4[9] = "/netherw"; // weak
char aTmaps10_0[9] = "tmaps1-0"; // weak
char aTmaps20_0[9] = "tmaps2-0"; // weak
char aErrorDecompres_1[30] = "ERROR decompressing tmap%03d\n"; // weak
char asc_D1949[2] = " "; // weak
char aVipport[8] = "VIPPORT"; // weak
char aVfx1Cyberpuck[15] = "VFX1 CyberPuck"; // weak
char aErrorUnknownFr[26] = "ERROR UNKNOWN FRAME TYPE\n"; // weak
char aColour256[11] = "COLOUR256 "; // weak
char aSs2[5] = "SS2 "; // weak
char aColour[8] = "COLOUR "; // weak
char aLc[4] = "LC "; // weak
char aBlack[7] = "BLACK "; // weak
char aBrun[6] = "BRUN "; // weak
char aCopy[6] = "COPY "; // weak
char aPstamp[8] = "PSTAMP "; // weak
char aNetherwConfigD[21] = ":/NETHERW/CONFIG.DAT"; // weak
char aNetherwLanguag[19] = ":/NETHERW/LANGUAGE"; // weak
char aDataScreensHsc[26] = "DATA/SCREENS/HSCREEN0.DAT"; // weak
char aIntroIntroDat[16] = "intro\\intro.dat"; // weak
char aIntroIntro2Dat[17] = "intro\\intro2.dat"; // weak
char aLanguageLTxt[16] = "LANGUAGE/L*.TXT"; // weak
char aLanguageDTxt[16] = "LANGUAGE/D*.TXT"; // weak
char aNetherw_5[9] = "/netherw"; // weak
char asc_D1AB3[3] = "/_"; // weak
int dword_D1AE4 = 7629889; // weak
__int16 word_D1B00 = 65; // weak
__int16 word_D1B04 = 66; // weak
__int16 word_D1B08 = 69; // weak
__int16 word_D1B0C = 70; // weak
__int16 word_D1B10 = 71; // weak
__int16 word_D1B14 = 72; // weak
__int16 word_D1B18 = 74; // weak
__int16 word_D1B1C = 75; // weak
__int16 word_D1B20 = 78; // weak
__int16 word_D1B24 = 81; // weak
__int16 word_D1B28 = 84; // weak
__int16 word_D1B2C = 85; // weak
__int16 word_D1B30 = 87; // weak
__int16 word_D1B34 = 88; // weak
__int16 word_D1B38 = 89; // weak
__int16 word_D1B3C = 90; // weak
__int16 word_D1B40 = 45; // weak
__int16 word_D1B44 = 59; // weak
__int16 word_D1B48 = 35; // weak
__int16 word_D1B4C = 44; // weak
__int16 word_D1B50 = 46; // weak
__int16 word_D1B54 = 47; // weak
char aHitAccuracy[13] = "Hit Accuracy"; // weak
char aManaCollected[15] = "Mana Collected"; // weak
char aE[3] = "E!"; // weak
char aError1NotEnoug[41] = "ERROR 1: NOT ENOUGH MEMORY. (%ld / %ld)\n"; // weak
char aErrorAllocatio[23] = "ERROR: Allocation %s.\n"; // weak
char aPressReturnToC_0[26] = "Press return to continue\n"; // weak
char aErrorFileS[17] = "ERROR: File %s.\n"; // weak
char aSoundSoundDat[16] = "SOUND/SOUND.DAT"; // weak
char aFdmErrorFreein[23] = "fdm:error freeing %lx\n"; // weak
char aVfxInitialised[17] = "VFX INITIALISED\n"; // weak
char aS_1[5] = "%s.\n"; // weak
_UNKNOWN unk_D1F0C; // weak
void *off_D1F10 = (void *)0xD5221; // weak
char aM1PB[9] = "!M1,P,B\r"; // weak
char aCouldNotSendIn[32] = "Could not send Info to Tracker\n"; // weak
float flt_D1F40 = 0.000061035156; // weak
char aNoMemoryForSer[28] = "No memory for serial data.\n"; // weak
char aNoSerial[11] = "NO SERIAL\n"; // weak
char aNoMemory[11] = "NO MEMORY\n"; // weak
void *off_D1F78 = &unk_D5621; // weak
double dbl_D1F7C = 1.003; // weak
char aCouldNotLoadAn[37] = "\nCould not load any digital samples\n"; // weak
char aMdsound[8] = "MDSOUND"; // weak
char aDigIni[8] = "DIG.INI"; // weak
char aNone[5] = "None"; // weak
char aCouldNotLoadAn_0[37] = "\nCould not load any digital samples\n"; // weak
char aCouldNotLoadAn_1[37] = "\nCould not load any digital samples\n"; // weak
char aSbawe32Mdi[12] = "SBAWE32.MDI"; // weak
char aSbpro2Mdi[11] = "SBPRO2.MDI"; // weak
char aSbpro1Mdi[11] = "SBPRO1.MDI"; // weak
char aMpu401Mdi[11] = "MPU401.MDI"; // weak
char aMt32mpuMdi[12] = "MT32MPU.MDI"; // weak
char aSndscapeMdi[13] = "SNDSCAPE.MDI"; // weak
char aAdlibgMdi[11] = "ADLIBG.MDI"; // weak
char aPasMdi[8] = "PAS.MDI"; // weak
char aPasplusMdi[12] = "PASPLUS.MDI"; // weak
char aSblasterMdi[13] = "SBLASTER.MDI"; // weak
char aOpl3Mdi[9] = "OPL3.MDI"; // weak
char aAdlibMdi[10] = "ADLIB.MDI"; // weak
char aD_2[4] = "d \\"; // weak
char aMdmusic[8] = "MDMUSIC"; // weak
char aMdiIni[8] = "MDI.INI"; // weak
char aNone_0[5] = "None"; // weak
char aT32f[5] = "T32f"; // weak
char aEsfmMdi[9] = "ESFM.MDI"; // weak
char aApew[5] = "APEw"; // weak
char aDig[4] = "DIg"; // weak
char aOpr[4] = "opr"; // weak
char aErrorDriverNot[29] = "\nError driver not supported\n"; // weak
char aErrorOpeningMu[28] = "\nError opening music files\n"; // weak
char aSoundMusicDat[16] = "SOUND/MUSIC.DAT"; // weak
char aNullWav[9] = "null.wav"; // weak
double dbl_D220C = 0.01; // weak
double dbl_D2218 = 63.0; // weak
double dbl_D2220 = 0.5; // weak
char aSb16Dig[9] = "SB16.DIG"; // weak
char aSbawe32Mdi_0[12] = "SBAWE32.MDI"; // weak
char aMpu401Mdi_0[11] = "MPU401.MDI"; // weak
_UNKNOWN unk_D2270; // weak
char aAilDebug[10] = "AIL_DEBUG"; // weak
char aAilSysDebug[14] = "AIL_SYS_DEBUG"; // weak
char aHawT[6] = "haw+t"; // weak
char a303[5] = "3.03"; // weak
char aVesa[5] = "VESA"; // weak
char aWritingS[12] = "Writing %s\n"; // weak
char aResponseC[14] = "Response: %c\n"; // weak
char aTrackerInitial[23] = "Tracker initialized ok"; // weak
char aNoSerialPort[15] = "No serial port"; // weak
char aTrackerNotPres[20] = "Tracker not present"; // weak
char aTrackerIsNotRe[26] = "Tracker is not responding"; // weak
char aTrackerDataIsI[24] = "Tracker data is invalid"; // weak
char aTrackerHeaderD[31] = "Tracker header data is invalid"; // weak
char aAVerifiedWrite[42] = "A verified write to tracker memory failed"; // weak
char aInvalidParamet[18] = "Invalid parameter"; // weak
char aTrackerCommand[34] = "Tracker command returned an error"; // weak
char aAMemoryAllocat[27] = "A memory allocation failed"; // weak
char aTrackerVersion[34] = "Tracker version string is invalid"; // weak
char aUndefined[10] = "Undefined"; // weak
char aLx[3] = "LX"; // weak
char byte_D3450[] = { '0' }; // weak
char aRt[4] = ",rt"; // weak
char aDriver[7] = "DRIVER"; // weak
char aDevice[7] = "DEVICE"; // weak
char aIoAddr[8] = "IO_ADDR"; // weak
char aIrq[4] = "IRQ"; // weak
char aDma8Bit[10] = "DMA_8_bit"; // weak
char aDma16Bit[11] = "DMA_16_bit"; // weak
char aAil3dig[8] = "AIL3DIG"; // weak
char aAil3mdi[8] = "AIL3MDI"; // weak
char aSbawe32Mdi_1[12] = "SBAWE32.MDI"; // weak
char aW[2] = "w"; // weak
char aDigIni_0[8] = "DIG.INI"; // weak
char aFmt[5] = "fmt "; // weak
char aData_0[5] = "data"; // weak
char aCreative[9] = "Creative"; // weak
char aWave[5] = "WAVE"; // weak
char aForm[5] = "FORM"; // weak
char aCat[5] = "CAT "; // weak
char aXmid[5] = "XMID"; // weak
char aMdiIni_0[8] = "MDI.INI"; // weak
char aTandy3VoiceMus[20] = "Tandy 3-voice music"; // weak
char aIbmInternalSpe[27] = "IBM internal speaker music"; // weak
char aMAd[5] = "m.AD"; // weak
char aOpl[5] = ".OPL"; // weak
char aTimb[5] = "TIMB"; // weak
char aRbrn[5] = "RBRN"; // weak
char aEvnt[5] = "EVNT"; // weak
char asc_D3A8C[3] = ": "; // weak
char IsTable[256] =
{
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\n',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  'X',
  'X',
  'X',
  'X',
  'X',
  'X',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\x98',
  '\x98',
  '\x98',
  '\x98',
  '\x98',
  '\x98',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\f',
  '\f',
  '\f',
  '\f',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_D3EA0[6] = { '\x01', '\x02', '\x04', '\b', '\x10', ' ' }; // weak
char byte_D3F48 = '\0'; // weak
__int16 word_D3F4C[26] =
{
  2,
  10,
  40,
  32,
  300,
  1,
  1,
  1,
  1,
  4,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  400,
  600,
  600,
  400,
  400,
  0,
  0,
  0
}; // weak
_UNKNOWN unk_D3F80; // weak
_UNKNOWN unk_D3F89; // weak
_UNKNOWN unk_D3F91; // weak
char byte_D3F96[14] =
{
  '\0',
  '\xFF',
  '\0',
  '\xFF',
  '\x01',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_D3FA4[] = { '\0' }; // weak
char byte_D3FB2[14] =
{
  '\0',
  '\x01',
  '\0',
  '\0',
  '\xFF',
  '\x01',
  '\xFF',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_D3FC0[] = { '\0' }; // weak
__int16 word_D3FCE[13] = { 0, 1536, 0, 1536, 512, 1536, 0, 0, 1024, 1024, 1536, 1024, 512 }; // weak
__int16 word_D3FE8[14] = { 1024, 512, 1024, 1024, 1536, 512, 1536, 1024, 0, 512, 512, 1024, 0, 0 }; // weak
__int16 word_D4004 = 0; // weak
char byte_D400C[64] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  '\x02',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\x03',
  '\x02',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\x04',
  '\x03',
  '\x03',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\x05',
  '\x04',
  '\x03',
  '\x02',
  '\x01',
  '\0',
  '\0',
  '\a',
  '\x06',
  '\x05',
  '\x04',
  '\x03',
  '\x02',
  '\x01',
  '\0'
}; // weak
void *off_D404C = &unk_140186; // weak
int dword_D40BC[] = { 0 }; // weak
int dword_D40C0[] = { 0 }; // weak
int dword_D4188 = 0; // weak
int dword_D418C = 0; // weak
int dword_D4190 = 0; // weak
int dword_D4198 = 0; // weak
char byte_D419C = '\xFF'; // weak
char byte_D419D = '\x01'; // weak
char byte_D419E = '\0'; // weak
int dword_D41A0 = 0; // weak
int dword_D41A4 = 0; // weak
char *off_D41A8 = &byte_14B4E0; // weak
char byte_D41AD = '\0'; // weak
char byte_D41B4 = '\0'; // weak
char byte_D41B5 = ' '; // weak
char byte_D41B6 = '\x01'; // weak
char byte_D41B7 = ','; // weak
int dword_D41BC = 0; // weak
char byte_D41C0 = '\0'; // weak
char byte_D41C1 = '\0'; // weak
char byte_D41C4 = 'c'; // weak
char byte_D41C6 = '('; // weak
int dword_D41C8 = 0; // weak
char byte_D41CE = '\0'; // weak
int dword_D41D0 = 0; // weak
__int16 word_D41D4 = 1; // weak
char byte_D41D8[] = { '\0' }; // weak
char byte_D427C[164] =
{
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_D4320 = '\0'; // weak
int dword_D4324 = 0; // weak
_UNKNOWN unk_D4328; // weak
_UNKNOWN unk_D4350; // weak
char byte_D4750[] = { '\0' }; // weak
char byte_D4756[] = { '\x01' }; // weak
char byte_D475C[16] =
{
  '\0',
  '\x01',
  '\x01',
  '\x02',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x04',
  '\x03',
  '\x03',
  '\x02',
  '\x02',
  '\x01',
  '\x01',
  '\0'
}; // weak
char byte_D476C[16] =
{
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0'
}; // weak
char byte_D477C[16] =
{
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\f',
  '\f',
  '\f'
}; // weak
char byte_D478C = '\0'; // weak
int dword_D4790 = 20; // weak
int dword_D4794 = 0; // weak
int dword_D4798 = 0; // weak
char byte_D47D8 = '\0'; // weak
char byte_D47D9 = '\0'; // weak
int dword_D47DC = 1; // weak
_UNKNOWN unk_D47E0; // weak
_UNKNOWN unk_D4A30; // weak
_UNKNOWN unk_D4A40; // weak
_UNKNOWN unk_D4A70; // weak
_UNKNOWN unk_D4A80; // weak
_UNKNOWN unk_D4AB0; // weak
char byte_D4B50 = '\0'; // weak
char byte_D4B51 = '\0'; // weak
char byte_D4B78 = '\0'; // weak
char byte_D4B79 = '\0'; // weak
char byte_D4B7A = '\0'; // weak
__int16 word_D4B7C = 254; // weak
__int16 word_D4B7E = 0; // weak
char byte_D4B80 = '\0'; // weak
int dword_D4B84 = 16; // weak
int dword_D4B88 = -80; // weak
int dword_D4B8C = 80; // weak
int dword_D4B90 = -4; // weak
__int16 word_D4BA4 = 16; // weak
int dword_D4BA8 = -80; // weak
int dword_D4BAC = 80; // weak
__int16 word_D4BB0 = -4; // weak
int dword_D4C52 = 0; // weak
int dword_D4C56 = 0; // weak
int (__cdecl *off_D697E)(int) = &sub_4E320; // weak
int (__cdecl *off_D781E)(int) = &sub_511A0; // weak
int (__cdecl *off_D7B7A)(int) = &sub_51530; // weak
_UNKNOWN unk_D7BD6; // weak
_UNKNOWN unk_D83AC; // weak
void *off_D83CE = &unk_160001; // weak
_UNKNOWN unk_D83F0; // weak
void *off_D8412 = &unk_110003; // weak
void *off_D8434 = &loc_B0004; // weak
void *off_D8456 = (void *)0x50005; // weak
_UNKNOWN unk_D8478; // weak
_UNKNOWN unk_D849A; // weak
__int16 word_D84A6 = 256; // weak
_UNKNOWN unk_D84BC; // weak
_UNKNOWN unk_D84DE; // weak
_UNKNOWN unk_D8544; // weak
_UNKNOWN unk_D8588; // weak
_UNKNOWN unk_D85AA; // weak
void *off_D85CC = &unk_160010; // weak
void *off_D8676 = &unk_160015; // weak
void *off_D86DC = &unk_160018; // weak
_UNKNOWN unk_D86FE; // weak
_UNKNOWN unk_D8720; // weak
void *off_D8742 = &unk_16001B; // weak
_UNKNOWN unk_D8764; // weak
_UNKNOWN unk_D8786; // weak
_UNKNOWN unk_D87A8; // weak
_UNKNOWN unk_D87CA; // weak
_UNKNOWN unk_D87EC; // weak
_UNKNOWN unk_D880E; // weak
_UNKNOWN unk_D8830; // weak
_UNKNOWN unk_D8852; // weak
_UNKNOWN unk_D8874; // weak
_UNKNOWN unk_D8896; // weak
void *off_D88B8 = &unk_160026; // weak
_UNKNOWN unk_D88DA; // weak
_UNKNOWN unk_D88FC; // weak
void *off_D891E = &unk_160029; // weak
void *off_D8940 = &unk_16002A; // weak
_UNKNOWN unk_D8962; // weak
void *off_D8984 = &unk_16002C; // weak
_UNKNOWN unk_D89A6; // weak
void *off_D89C8 = &loc_5002E; // weak
void *off_D89EA = &unk_11002F; // weak
char byte_D8A2E[38] =
{
  '\x01',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\0'
}; // weak
char aSearchd[9] = "*SearchD"; // weak
char aDataBuild00Dat[18] = "data/build0-0.dat"; // weak
char aDataBlock16Dat[17] = "data/block16.dat"; // weak
char aDataBlock32Dat[17] = "data/block32.dat"; // weak
char aWscreen[9] = "*WScreen"; // weak
char aDataMsprd00Dat[18] = "data/msprd0-0.dat"; // weak
char aDataMsprd00Tab_0[18] = "data/msprd0-0.tab"; // weak
char aDataHsprd00Dat[18] = "data/hsprd0-0.dat"; // weak
char aDataHsprd00Tab_0[18] = "data/hsprd0-0.tab"; // weak
int *off_D918C = &dword_EB394; // weak
int *off_D91BC[2] = { &dword_EA3DC, &dword_EA3E0 }; // weak
void *off_D91D4 = &unk_E9B2C; // weak
int *off_D91EC = &dword_EA3BC; // weak
char *off_D9204[2] = { "1. Jahwl", "2. Kopahk" }; // weak
char *off_D9208 = "2. Kopahk"; // weak
char *off_D93A0 = "Zanzamar"; // weak
__int16 word_D93C0[] = { 2 }; // weak
char byte_D93C2[] = { '\x03' }; // weak
char byte_D93C3[301] =
{
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0'
}; // weak
char byte_D94F0[] = { '\xAA' }; // weak
char byte_D94F1[] = { '\0' }; // weak
char byte_D94F2[] = { 'c' }; // weak
char byte_D94F3[12] = { '\r', '\0', '3', '\0', '\x11', ';', '\0', '3', '\0', '\x88', ';', '\0' }; // weak
char byte_D94FF[29] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\0',
  '\x03',
  '\0'
}; // weak
__int16 word_D951C[] = { 8 }; // weak
__int16 word_D9522[] = { 0 }; // weak
__int16 word_D9524[] = { 250 }; // weak
char byte_D9528[] = { '\0' }; // weak
__int16 word_D99F2 = 0; // weak
__int16 word_D99F4 = 180; // weak
int dword_D9F50[] = { 16777356 }; // weak
__int16 word_DA076 = 1500; // weak
__int16 word_DA506 = 311; // weak
int dword_DA750[] = { 27918336 }; // weak
__int16 word_DA7CA = 1200; // weak
char byte_DA818[] = { '\x03' }; // weak
char byte_DA819[] = { '\0' }; // weak
int dword_DA81E = 100; // weak
int dword_DA822 = 0; // weak
__int16 word_DA82E[] = { 186 }; // weak
int dword_DA85A[69] =
{
  5000,
  750,
  983228,
  196610,
  10,
  100,
  0,
  0,
  0,
  196797,
  983040,
  16384000,
  0,
  19660800,
  3276800,
  12451840,
  65577,
  20,
  1000,
  1000,
  900,
  150,
  3342527,
  196610,
  0,
  1000,
  0,
  0,
  0,
  6619328,
  0,
  81920000,
  0,
  1638400,
  262144,
  12648448,
  65637,
  1,
  2000,
  0,
  125,
  6,
  6619330,
  67305474,
  2,
  1000,
  0,
  0,
  0,
  19726531,
  196608,
  163840000,
  0,
  9175040,
  983040,
  12845056,
  451,
  4,
  5000,
  0,
  280,
  45,
  32833733,
  67305472,
  100,
  5000,
  20000,
  0,
  0
}; // weak
__int16 word_DA96E = 198; // weak
char byte_DA972[] = { '\x13' }; // weak
_UNKNOWN unk_DAB3A; // weak
_UNKNOWN unk_DAC2A; // weak
_UNKNOWN unk_DAC44; // weak
_UNKNOWN unk_DAC7A; // weak
__int16 word_DAE1E = 244; // weak
char byte_DAE22 = '\x13'; // weak
_UNKNOWN unk_DAF4A; // weak
int dword_DAF50[58] =
{
  1310720000,
  0,
  0,
  16842752,
  47,
  5000,
  12000,
  20000,
  120,
  30,
  4391170,
  655360001,
  1572864000,
  -362807296,
  15728640,
  3932160,
  16973824,
  131159,
  39976963,
  655360000,
  1310720000,
  0,
  0,
  17039360,
  1048619,
  1100,
  18000,
  36000,
  90,
  30,
  2162949,
  177602586,
  1966080000,
  1603272704,
  18350081,
  4587520,
  17170432,
  2097185,
  6553603,
  720896000,
  1245184000,
  0,
  0,
  17235968,
  31,
  130,
  13000,
  38000,
  200,
  40,
  2687240,
  25559041,
  1703936000,
  -624951296,
  26214400,
  7864320,
  17367040,
  131123
}; // weak
char byte_DB038[] = { '\0' }; // weak
char byte_DB039[17] =
{
  '\0',
  '\x01',
  '\0',
  '\x04',
  '\x01',
  '\x04',
  '\x01',
  '\x04',
  '\x05',
  '\x04',
  '\x05',
  '\b',
  '\t',
  '\b',
  '\t',
  '\0',
  '\0'
}; // weak
_UNKNOWN unk_DB04A; // weak
void *off_DB06C = (void *)0xD1130; // weak
char byte_DB080[] = { '\x02' }; // weak
__int16 word_DB082[] = { 0 }; // weak
__int16 word_DB084[] = { 750 }; // weak
int dword_DB350[103] =
{
  29492775,
  19662900,
  29493675,
  24579000,
  0,
  0,
  0,
  0,
  19664250,
  20,
  39322125,
  300,
  0,
  0,
  0,
  0,
  0,
  0,
  63897600,
  1376481,
  54067200,
  34407300,
  34407900,
  0,
  0,
  0,
  0,
  0,
  0,
  29493300,
  22,
  58983225,
  93389250,
  122880375,
  525,
  0,
  0,
  0,
  0,
  162201600,
  1507703,
  73728000,
  14746800,
  34407900,
  0,
  0,
  0,
  0,
  0,
  0,
  29493300,
  24,
  68813775,
  93389100,
  122880375,
  162202125,
  186777900,
  211353900,
  245760450,
  375,
  275251200,
  1638700,
  54067200,
  24576900,
  34407750,
  19662750,
  19663125,
  19663500,
  0,
  0,
  0,
  24579075,
  26,
  1200,
  83558400,
  675,
  0,
  0,
  0,
  0,
  0,
  132710400,
  1771047,
  24576000,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  375,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
char byte_DB4EE[25] =
{
  '0',
  '6',
  '<',
  'B',
  'E',
  'H',
  'M',
  'O',
  'V',
  '\\',
  'a',
  'f',
  'i',
  'n',
  's',
  'v',
  '|',
  '~',
  '\x83',
  '\x85',
  '\x88',
  '\x8C',
  '\x8F',
  '\x97',
  '\x9C'
}; // weak
char byte_DB507[10] = { '5', ';', 'A', 'D', 'G', 'L', 'N', 'U', '[', '`' }; // weak
char byte_DB511 = 'e'; // weak
char byte_DB520[6] = { '0', '3', '?', '=', '\x92', 'q' }; // weak
char byte_DB526 = 'N'; // weak
int dword_DB538[8] = { 256, 512, 1024, 2048, 4096, 9192, 18384, 36768 }; // weak
char *off_DB558[3] = { "Designed By", "Bullfrog Productions Ltd", "!" }; // weak
char byte_DB734 = '\0'; // weak
char byte_DB738 = '\0'; // weak
int dword_DB73C = -1; // weak
int dword_DB740 = -1; // weak
int dword_DB744 = -1; // weak
int dword_DB748 = -1; // weak
char byte_DB74C = '\x01'; // weak
int dword_DB750[256] =
{
  0,
  201,
  402,
  603,
  804,
  1005,
  1206,
  1407,
  1608,
  1809,
  2010,
  2211,
  2412,
  2613,
  2814,
  3015,
  3216,
  3417,
  3617,
  3818,
  4019,
  4219,
  4420,
  4621,
  4821,
  5022,
  5222,
  5422,
  5623,
  5823,
  6023,
  6224,
  6424,
  6624,
  6824,
  7024,
  7224,
  7423,
  7623,
  7823,
  8022,
  8222,
  8421,
  8621,
  8820,
  9019,
  9218,
  9417,
  9616,
  9815,
  10014,
  10212,
  10411,
  10609,
  10808,
  11006,
  11204,
  11402,
  11600,
  11798,
  11996,
  12193,
  12391,
  12588,
  12785,
  12983,
  13180,
  13376,
  13573,
  13770,
  13966,
  14163,
  14359,
  14555,
  14751,
  14947,
  15143,
  15338,
  15534,
  15729,
  15924,
  16119,
  16314,
  16508,
  16703,
  16897,
  17091,
  17285,
  17479,
  17673,
  17867,
  18060,
  18253,
  18446,
  18639,
  18832,
  19024,
  19216,
  19409,
  19600,
  19792,
  19984,
  20175,
  20366,
  20557,
  20748,
  20939,
  21129,
  21320,
  21510,
  21699,
  21889,
  22078,
  22268,
  22457,
  22645,
  22834,
  23022,
  23210,
  23398,
  23586,
  23774,
  23961,
  24148,
  24335,
  24521,
  24708,
  24894,
  25080,
  25265,
  25451,
  25636,
  25821,
  26005,
  26190,
  26374,
  26558,
  26742,
  26925,
  27108,
  27291,
  27474,
  27656,
  27838,
  28020,
  28202,
  28383,
  28564,
  28745,
  28926,
  29106,
  29286,
  29466,
  29645,
  29824,
  30003,
  30182,
  30360,
  30538,
  30716,
  30893,
  31071,
  31248,
  31424,
  31600,
  31776,
  31952,
  32127,
  32303,
  32477,
  32652,
  32826,
  33000,
  33173,
  33347,
  33520,
  33692,
  33865,
  34037,
  34208,
  34380,
  34551,
  34721,
  34892,
  35062,
  35231,
  35401,
  35570,
  35738,
  35907,
  36075,
  36243,
  36410,
  36577,
  36744,
  36910,
  37076,
  37241,
  37407,
  37572,
  37736,
  37900,
  38064,
  38228,
  38391,
  38554,
  38716,
  38878,
  39040,
  39201,
  39362,
  39523,
  39683,
  39843,
  40002,
  40161,
  40320,
  40478,
  40636,
  40794,
  40951,
  41108,
  41264,
  41420,
  41576,
  41731,
  41886,
  42040,
  42194,
  42348,
  42501,
  42654,
  42806,
  42958,
  43110,
  43261,
  43412,
  43562,
  43713,
  43862,
  44011,
  44160,
  44308,
  44456,
  44604,
  44751,
  44898,
  45044,
  45190,
  45335,
  45480,
  45625,
  45769,
  45912,
  46056,
  46199
}; // weak
int dword_DBB50[256] =
{
  46341,
  46483,
  46624,
  46765,
  46906,
  47046,
  47186,
  47325,
  47464,
  47603,
  47741,
  47878,
  48015,
  48152,
  48288,
  48424,
  48559,
  48694,
  48828,
  48962,
  49095,
  49228,
  49361,
  49493,
  49624,
  49756,
  49886,
  50016,
  50146,
  50275,
  50404,
  50532,
  50660,
  50787,
  50914,
  51041,
  51166,
  51292,
  51417,
  51541,
  51665,
  51789,
  51911,
  52034,
  52156,
  52277,
  52398,
  52519,
  52639,
  52759,
  52878,
  52996,
  53114,
  53232,
  53349,
  53465,
  53581,
  53697,
  53812,
  53926,
  54040,
  54154,
  54267,
  54379,
  54491,
  54603,
  54714,
  54824,
  54934,
  55043,
  55152,
  55260,
  55368,
  55476,
  55582,
  55689,
  55794,
  55900,
  56004,
  56108,
  56212,
  56315,
  56418,
  56520,
  56621,
  56722,
  56823,
  56923,
  57022,
  57121,
  57219,
  57317,
  57414,
  57511,
  57607,
  57703,
  57798,
  57892,
  57986,
  58079,
  58172,
  58265,
  58356,
  58448,
  58538,
  58628,
  58718,
  58807,
  58896,
  58983,
  59071,
  59158,
  59244,
  59330,
  59415,
  59499,
  59583,
  59667,
  59750,
  59832,
  59914,
  59995,
  60075,
  60156,
  60235,
  60314,
  60392,
  60470,
  60547,
  60624,
  60700,
  60776,
  60851,
  60925,
  60999,
  61072,
  61145,
  61217,
  61288,
  61359,
  61429,
  61499,
  61568,
  61637,
  61705,
  61772,
  61839,
  61906,
  61971,
  62036,
  62101,
  62165,
  62228,
  62291,
  62353,
  62415,
  62476,
  62536,
  62596,
  62655,
  62714,
  62772,
  62830,
  62886,
  62943,
  62998,
  63054,
  63108,
  63162,
  63215,
  63268,
  63320,
  63372,
  63423,
  63473,
  63523,
  63572,
  63621,
  63668,
  63716,
  63763,
  63809,
  63854,
  63899,
  63944,
  63987,
  64031,
  64073,
  64115,
  64156,
  64197,
  64237,
  64277,
  64316,
  64354,
  64392,
  64429,
  64465,
  64501,
  64536,
  64571,
  64605,
  64639,
  64672,
  64704,
  64735,
  64766,
  64797,
  64827,
  64856,
  64884,
  64912,
  64940,
  64967,
  64993,
  65018,
  65043,
  65067,
  65091,
  65114,
  65137,
  65159,
  65180,
  65200,
  65220,
  65240,
  65259,
  65277,
  65294,
  65311,
  65328,
  65343,
  65358,
  65373,
  65387,
  65400,
  65413,
  65425,
  65436,
  65447,
  65457,
  65467,
  65476,
  65484,
  65492,
  65499,
  65505,
  65511,
  65516,
  65521,
  65525,
  65528,
  65531,
  65533,
  65535,
  65536
}; // weak
void (__noreturn *off_DBF50[2])() = { &sub_10000, &sub_10000 }; // weak
int dword_DDF50[] = { 0 }; // weak
int dword_DDF54 = 32; // weak
__int16 word_DE350[258] =
{
  0,
  1,
  2,
  3,
  5,
  6,
  7,
  8,
  10,
  11,
  12,
  13,
  15,
  16,
  17,
  19,
  20,
  21,
  22,
  24,
  25,
  26,
  27,
  29,
  30,
  31,
  32,
  34,
  35,
  36,
  38,
  39,
  40,
  41,
  43,
  44,
  45,
  46,
  48,
  49,
  50,
  51,
  53,
  54,
  55,
  56,
  57,
  59,
  60,
  61,
  62,
  64,
  65,
  66,
  67,
  68,
  70,
  71,
  72,
  73,
  75,
  76,
  77,
  78,
  79,
  81,
  82,
  83,
  84,
  85,
  87,
  88,
  89,
  90,
  91,
  92,
  94,
  95,
  96,
  97,
  98,
  99,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  118,
  119,
  120,
  121,
  122,
  123,
  124,
  125,
  126,
  127,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  198,
  199,
  200,
  201,
  202,
  203,
  203,
  204,
  205,
  206,
  207,
  208,
  208,
  209,
  210,
  211,
  212,
  212,
  213,
  214,
  215,
  216,
  216,
  217,
  218,
  219,
  220,
  220,
  221,
  222,
  223,
  223,
  224,
  225,
  226,
  226,
  227,
  228,
  229,
  229,
  230,
  231,
  232,
  232,
  233,
  234,
  235,
  235,
  236,
  237,
  237,
  238,
  239,
  239,
  240,
  241,
  242,
  242,
  243,
  244,
  244,
  245,
  246,
  246,
  247,
  248,
  248,
  249,
  250,
  250,
  251,
  252,
  252,
  253,
  254,
  254,
  255,
  256,
  0
}; // weak
int dword_DE554 = 0; // weak
int dword_DE558 = 0; // weak
int dword_DE55C = 0; // weak
int dword_DE560 = 0; // weak
int dword_DE564 = 0; // weak
int dword_DE568 = 0; // weak
_UNKNOWN unk_DE56C; // weak
char byte_E126C = 'p'; // weak
char byte_E126D = '\0'; // weak
char byte_E1274 = '\0'; // weak
char byte_E1275 = '\0'; // weak
__int16 word_E1276 = -1; // weak
__int16 word_E1278 = 0; // weak
__int16 word_E127A = 8; // weak
int dword_E127E = 0; // weak
int dword_E1282 = 0; // weak
int dword_E1286[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
__int16 word_E12A6 = 0; // weak
__int16 word_E12A8 = 0; // weak
int dword_E12AA = 0; // weak
int dword_E12AE[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
char byte_E12CE[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
char aTester[7] = "TESTER"; // weak
char byte_E12EC = '\0'; // weak
char byte_E12ED = '\0'; // weak
int dword_E12F4 = 0; // weak
__int16 word_E12FC = 1; // weak
__int16 word_E12FE = 0; // weak
int dword_E1300 = 0; // weak
int dword_E1304 = 0; // weak
int dword_E1308 = 0; // weak
__int16 word_E130C = 0; // weak
__int16 word_E130E = 0; // weak
__int16 word_E1310 = 0; // weak
__int16 word_E1312 = 0; // weak
__int16 word_E1316 = 0; // weak
__int16 word_E131A = 0; // weak
char byte_E131C[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
char byte_E1324 = '2'; // weak
void *off_E16E0 = &unk_E1328; // weak
char byte_E1711[] = { '6' }; // weak
char byte_E1712[] = { '6' }; // weak
char byte_E1713[25] =
{
  '6',
  '\0',
  '&',
  '\0',
  '-',
  '\0',
  '\0',
  '#',
  '\0',
  '!',
  '?',
  '\x0F',
  '(',
  '\x16',
  '\x0F',
  '\0',
  '\0',
  '\0',
  '\x17',
  '?',
  '\x1F',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_E172C[] = { '\"' }; // weak
char byte_E172D[] = { '\"' }; // weak
char byte_E172E[] = { '\"' }; // weak
_UNKNOWN unk_E1748; // weak
_UNKNOWN unk_E1784; // weak
_UNKNOWN unk_E17CC; // weak
_UNKNOWN unk_E192C; // weak
_UNKNOWN unk_E1960; // weak
__int16 word_E1964[] = { 116 }; // weak
__int16 word_E1966[] = { 478 }; // weak
__int16 word_E196C[] = { 420 }; // weak
__int16 word_E196E[] = { 820 }; // weak
__int16 word_E1970 = 33; // weak
char byte_E1972[500] =
{
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'p',
  '\x01',
  '\xDE',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\x9A',
  '\x02',
  '%',
  '\x03',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '@',
  '\x02',
  '\xDE',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  'q',
  '\x03',
  '\xDE',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '%',
  '\x02',
  'r',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\xC2',
  '\x01',
  '\x8C',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  'b',
  '\x02',
  '\x9A',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\xFB',
  '\x02',
  '\x8C',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\xDC',
  '\x02',
  '.',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\x84',
  '\x02',
  '*',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\x18',
  '\x02',
  '\x1C',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  '2',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '6',
  '\x03',
  '\xC2',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '~',
  '\x02',
  '\xBE',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\xF1',
  '\x03',
  '\x9C',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '~',
  '\x02',
  '\\',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\"',
  '\x04',
  '\f',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xDE',
  '\x01',
  '\\',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\x85',
  '\x03',
  '0',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xDE',
  '\x01',
  '\\',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '1',
  '\x03',
  '\xCA',
  '\0',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xDE',
  '\x01',
  '\\',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\xAC',
  '\x02',
  '\x06',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'z',
  '\0',
  '`',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\x12',
  '\x02',
  '<',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'z',
  '\0',
  '`',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\xAB',
  '\x01',
  '\xCE',
  '\0',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'z',
  '\0',
  '`',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  'B',
  '\x01',
  '\xFE',
  '\0',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '2',
  '\x01',
  '\xC4',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  's',
  '\x02',
  '\xA0',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  'D',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\xB4',
  '\0',
  '\x16',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '(',
  '\x01',
  'D',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  'a',
  '\x02',
  '\xDA',
  '\0',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xE0',
  '\x01',
  '\0',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  'F',
  '\x03',
  '`',
  '\0',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '4',
  '\x01',
  '\0',
  '\0',
  '(',
  '\0',
  '(',
  '\0'
}; // weak
__int16 word_E1B66 = 679; // weak
__int16 word_E1B68 = 126; // weak
char byte_E1B82 = '\x02'; // weak
char byte_E1B9C[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
char byte_E1BA4[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int (__cdecl *off_E1BAC)(int) = &sub_77350; // weak
int (*off_E1D64)() = &sub_7CCF0; // weak
void *off_E1E98 = (void *)0x5BC1E; // weak
__int16 word_E1F70[10] = { 430, 78, 0, 0, 80, 0, 413, 0, 0, 0 }; // weak
_WORD word_E1F84[66] =
{
  0,
  0,
  0,
  0,
  0,
  291,
  205,
  60,
  60,
  0,
  8996,
  257,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  0,
  0,
  0,
  0,
  0,
  288,
  99,
  60,
  60,
  0,
  19788,
  258,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_WORD word_E2008[66] =
{
  0,
  0,
  0,
  0,
  0,
  273,
  10,
  60,
  60,
  0,
  27904,
  257,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  0,
  0,
  0,
  0,
  0,
  283,
  381,
  60,
  60,
  0,
  27648,
  258,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_E208C = 0; // weak
__int16 word_E2094 = 40; // weak
char byte_E2096 = '('; // weak
char byte_E2097 = '1'; // weak
_WORD word_E20A4[414] =
{
  0,
  0,
  0,
  0,
  1,
  37,
  2,
  37,
  3,
  0,
  0,
  384,
  0,
  543,
  960,
  140,
  145,
  140,
  140,
  145,
  50,
  1,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  256,
  9472,
  512,
  9472,
  768,
  0,
  0,
  -29952,
  2561,
  9728,
  -13822,
  -29693,
  -28416,
  -29696,
  -29696,
  -28416,
  12800,
  256,
  768,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  37,
  2,
  37,
  3,
  0,
  0,
  400,
  6,
  555,
  980,
  140,
  145,
  140,
  140,
  145,
  50,
  1,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  256,
  9984,
  512,
  9984,
  768,
  0,
  0,
  256,
  -16896,
  -1024,
  13316,
  -12799,
  -11520,
  -12800,
  -12800,
  -11520,
  10240,
  256,
  768,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  37,
  2,
  37,
  3,
  0,
  0,
  459,
  0,
  1278,
  960,
  146,
  151,
  146,
  146,
  151,
  20,
  1,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  256,
  2304,
  512,
  768,
  768,
  0,
  0,
  21248,
  2,
  14848,
  31746,
  5378,
  7169,
  5377,
  23809,
  26368,
  0,
  512,
  768,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  9,
  2,
  3,
  3,
  0,
  0,
  610,
  114,
  610,
  114,
  297,
  304,
  297,
  297,
  304,
  0,
  3,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  256,
  2304,
  512,
  768,
  768,
  0,
  0,
  25856,
  1,
  7936,
  -28671,
  27394,
  29184,
  27392,
  23808,
  26368,
  3840,
  256,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  9,
  2,
  3,
  3,
  0,
  0,
  939,
  0,
  879,
  614,
  107,
  114,
  107,
  93,
  103,
  15,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  768,
  2304,
  512,
  768,
  768,
  0,
  0,
  -20736,
  1,
  26880,
  1,
  27394,
  29184,
  27392,
  23808,
  26368,
  2816,
  256,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  4,
  9,
  2,
  3,
  3,
  0,
  0,
  455,
  0,
  395,
  114,
  107,
  114,
  107,
  93,
  103,
  18,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int (__cdecl *off_E23E0)(int) = &sub_7E620; // weak
_UNKNOWN unk_E24BC; // weak
__int16 word_E24BE[26] =
{
  40,
  49,
  196,
  38,
  0,
  283,
  106,
  2,
  454,
  298,
  300,
  397,
  298,
  0,
  321,
  236,
  8,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_UNKNOWN unk_E24F2; // weak
_UNKNOWN unk_E2516; // weak
__int16 word_E2518[] = { 303 }; // weak
char byte_E2527[73] =
{
  '\v',
  '\x95',
  '\x01',
  '^',
  '\x01',
  'A',
  '\0',
  '\x11',
  '\x02',
  'R',
  '\0',
  '\0',
  '\0',
  'T',
  '\x02',
  '\x1C',
  '\0',
  '\b',
  '\b',
  '\x96',
  '\x01',
  '~',
  '\0',
  'A',
  '\0',
  '{',
  '\0',
  'R',
  '\0',
  '\0',
  '\0',
  '7',
  '\0',
  '\x1C',
  '\0',
  '\b',
  '\t',
  '\xD3',
  '\x01',
  '\x7F',
  '\0',
  'h',
  '\x01',
  '{',
  '\0',
  'v',
  '\x01',
  '\0',
  '\0',
  '4',
  '\0',
  '\xB0',
  '\x01',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
_UNKNOWN unk_E2570; // weak
__int16 word_E2572[53] =
{
  4,
  184,
  66,
  182,
  0,
  126,
  130,
  0,
  459,
  5,
  360,
  77,
  360,
  0,
  149,
  304,
  0,
  458,
  444,
  362,
  551,
  362,
  0,
  454,
  290,
  0,
  456,
  444,
  168,
  552,
  168,
  0,
  488,
  116,
  0,
  460,
  419,
  13,
  471,
  25,
  0,
  328,
  24,
  8,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_UNKNOWN unk_E25DC; // weak
__int16 word_E25DE[] = { 2 }; // weak
char byte_E25ED[] = { '\x06' }; // weak
_UNKNOWN unk_E2690; // weak
_UNKNOWN unk_E26C8; // weak
_UNKNOWN unk_E28A8; // weak
__int16 word_E28B6 = 1; // weak
_WORD word_E2970[51] =
{
  0,
  0,
  4,
  30,
  287,
  656,
  3,
  270,
  0,
  0,
  1792,
  7936,
  28416,
  26115,
  770,
  3584,
  1,
  0,
  0,
  11,
  32,
  854,
  400,
  3,
  270,
  0,
  0,
  4352,
  8448,
  -29952,
  29185,
  768,
  3584,
  1,
  0,
  0,
  19,
  34,
  365,
  504,
  3,
  270,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_E29D6 = 0; // weak
__int16 word_E29D8 = 0; // weak
__int16 word_E29DA = 0; // weak
__int16 word_E29DC = 0; // weak
char byte_E29DE = '\x01'; // weak
char byte_E29DF = '\0'; // weak
char byte_E29E0 = '\0'; // weak
char byte_E29E1 = '\x01'; // weak
char byte_E29E8 = '\x01'; // weak
char byte_E29EC = '\0'; // weak
char byte_E29ED = '\0'; // weak
char byte_E29EE = '\0'; // weak
char byte_E29EF = '\0'; // weak
char byte_E29F0 = '\0'; // weak
char byte_E29F1 = '\0'; // weak
__int16 word_E29F4 = 0; // weak
int dword_E29F6 = 0; // weak
int dword_E29FA = 0; // weak
int dword_E29FE = 0; // weak
int dword_E2A02 = 0; // weak
char byte_E2A06 = '\0'; // weak
_UNKNOWN unk_E2A08; // weak
__int16 word_E2A14 = 0; // weak
int dword_E2A18 = 0; // weak
int dword_E2A1C = 0; // weak
char byte_E2A20 = '\0'; // weak
__int16 word_E2A24 = 0; // weak
char byte_E2A28 = '\0'; // weak
int dword_E2A6C = 0; // weak
int dword_E2A70 = 0; // weak
__int16 word_E2A74[] = { 0 }; // weak
char byte_E2A76[] = { '\0' }; // weak
__int16 word_E2A78[] = { 0 }; // weak
__int16 word_E2A7A[] = { 0 }; // weak
__int16 word_E2A7C[] = { 0 }; // weak
__int16 word_E2A7E[] = { 0 }; // weak
int dword_E2A80 = 0; // weak
int dword_E2A84 = 0; // weak
int dword_E2A88 = 0; // weak
char byte_E2A90[] = { '\0' }; // weak
char byte_E2A91[] = { '\0' }; // weak
_UNKNOWN unk_E2A92; // weak
__int16 word_E2AB8 = 0; // weak
__int16 word_E2ABA = 0; // weak
char byte_E2ACD = '\0'; // weak
char byte_E2AD0 = '\x04'; // weak
char byte_E2AEE = '$'; // weak
char byte_E2B0C = ' '; // weak
char byte_E2B2A = '\x04'; // weak
char byte_E2B48 = '\x04'; // weak
char byte_E2B66 = '\x04'; // weak
char byte_E2B84 = '\x04'; // weak
char byte_E2BA2 = '$'; // weak
__int16 word_E2BA8 = 320; // weak
__int16 word_E2BAA = 80; // weak
char byte_E2BC0 = '$'; // weak
__int16 word_E2BC6 = 320; // weak
__int16 word_E2BC8 = 80; // weak
char byte_E2BDE = '$'; // weak
__int16 word_E2BE4 = 320; // weak
__int16 word_E2BE6 = 80; // weak
char byte_E2BFC = '\x04'; // weak
char byte_E2C1A = '\x04'; // weak
char byte_E2C38 = '\x04'; // weak
char byte_E2C56 = '\x04'; // weak
char byte_E2C71 = '\0'; // weak
char byte_E2C74 = '$'; // weak
int dword_E2C86 = 0; // weak
__int16 word_E2E96 = 0; // weak
__int16 word_E2E98 = 0; // weak
char byte_E2EEA = ' '; // weak
char byte_E2F08 = ' '; // weak
char byte_E2F26 = ' '; // weak
__int16 word_E2F28 = 328; // weak
__int16 word_E2F2C = 540; // weak
__int16 word_E2F2E = 40; // weak
char byte_E2F44 = ' '; // weak
__int16 word_E2F46 = 329; // weak
__int16 word_E2F4A = 0; // weak
__int16 word_E2F4C = 0; // weak
char byte_E2F5F = '\0'; // weak
char byte_E2F62 = ' '; // weak
__int16 word_E2F64 = 330; // weak
__int16 word_E2F68 = 560; // weak
__int16 word_E2F6A = 16; // weak
__int16 word_E328E = 331; // weak
__int16 word_E3292 = 0; // weak
__int16 word_E32AC = 332; // weak
__int16 word_E32B0 = 0; // weak
__int16 word_E32B2 = 0; // weak
__int16 word_E32CA = 333; // weak
__int16 word_E32CE = 0; // weak
__int16 word_E32D0 = 0; // weak
char byte_E32E6 = '\x04'; // weak
char byte_E3304 = '\x04'; // weak
char byte_E3322 = '\x04'; // weak
char byte_E3340 = '\x04'; // weak
char byte_E335E = '\x04'; // weak
char byte_E337C = '\x04'; // weak
char byte_E339A = '\x04'; // weak
char byte_E33B8 = '\x04'; // weak
char byte_E33D6 = '\x04'; // weak
char byte_E340F = '\0'; // weak
char byte_E3430 = '\x80'; // weak
__int16 word_E3472 = 0; // weak
__int16 word_E3474 = 0; // weak
__int16 word_E3490 = 360; // weak
__int16 word_E3492 = 114; // weak
__int16 word_E34AE = 360; // weak
__int16 word_E34B0 = 146; // weak
__int16 word_E34CC = 310; // weak
__int16 word_E34CE = 176; // weak
__int16 word_E34EA = 360; // weak
__int16 word_E34EC = 176; // weak
__int16 word_E3508 = 360; // weak
__int16 word_E350A = 210; // weak
_UNKNOWN unk_E3522; // weak
__int16 word_E359E = 0; // weak
__int16 word_E35A0 = 0; // weak
__int16 word_E35BC = 0; // weak
__int16 word_E35BE = 0; // weak
int dword_E36C4 = 0; // weak
int dword_E36C8 = 1; // weak
__int16 word_E36CC = 0; // weak
__int16 word_E36CE = 0; // weak
char byte_E36D0 = '\0'; // weak
char byte_E36D1 = '\0'; // weak
__int16 word_E36D4 = 0; // weak
char byte_E36DC[] = { '\0' }; // weak
int dword_E3758 = 0; // weak
__int16 word_E375C = 320; // weak
__int16 word_E375E = 200; // weak
int dword_E3760 = 13107520; // weak
char byte_E3766 = '\0'; // weak
int dword_E3768 = 0; // weak
int dword_E3794 = 10; // weak
char byte_E3798 = '\x01'; // weak
char byte_E3799 = '\x01'; // weak
char byte_E379A = '\0'; // weak
char byte_E379B = '\x01'; // weak
char byte_E379C = '\x01'; // weak
int dword_E37A0 = 0; // weak
int dword_E37A4 = 0; // weak
int dword_E37A8 = 0; // weak
char byte_E37AC = '\0'; // weak
char byte_E37AD = '\xFF'; // weak
char byte_E37AE = '\0'; // weak
int dword_E37B0 = 127; // weak
__int16 word_E37B4 = 1644; // weak
__int16 word_E37B6 = 0; // weak
char byte_E37B8 = '\0'; // weak
int dword_E37BC = 0; // weak
int dword_E37F8 = 127; // weak
char byte_E37FC = '\x01'; // weak
char byte_E37FD = '\x01'; // weak
char byte_E37FE = '\0'; // weak
__int16 word_E3800 = 0; // weak
__int16 word_E3802 = 0; // weak
__int16 word_E3804 = 0; // weak
int dword_E3808 = 0; // weak
int dword_E380C = 0; // weak
int dword_E3810 = 0; // weak
char byte_E3814 = '\0'; // weak
char byte_E3815 = '\0'; // weak
char byte_E3816 = '\0'; // weak
char byte_E3817 = '\x01'; // weak
char byte_E3818 = '\0'; // weak
char byte_E3819 = '\0'; // weak
char byte_E381A = '\xFF'; // weak
__int16 word_E381C = 0; // weak
int dword_E381E = 0; // weak
__int16 word_E3822 = 0; // weak
int dword_E3824 = 0; // weak
__int16 word_E3828 = 0; // weak
__int16 word_E3834 = 0; // weak
int dword_E383C = 0; // weak
int dword_E3840 = 0; // weak
int dword_E3844 = 5; // weak
_UNKNOWN unk_E3848; // weak
__int16 word_E387A = 0; // weak
int dword_E387C = 0; // weak
int dword_E3880 = 0; // weak
int dword_E3884 = 0; // weak
int dword_E3888 = 0; // weak
char byte_E388D = '\0'; // weak
int dword_E3890 = 0; // weak
int dword_E3894[25] =
{
  1660945346,
  1593836500,
  1325466580,
  1342309332,
  -2113731628,
  1409549268,
  -2147154988,
  -1090124844,
  520553428,
  525268,
  1074332628,
  -1676672044,
  -1911487532,
  -1894644780,
  672334804,
  1311700,
  -1777007660,
  -1189739564,
  -485030956,
  16843716,
  100926404,
  1074070478,
  84280270,
  1091568576,
  1246144
}; // weak
__int16 word_E3908 = 0; // weak
char byte_E390C = '\0'; // weak
char aSound_2[6] = "SOUND"; // weak
char byte_E39A0 = '\0'; // weak
__int16 word_E39A4 = 0; // weak
__int16 word_E39A6 = 0; // weak
__int16 word_E39A8 = 0; // weak
__int16 word_E39AA = 0; // weak
__int16 word_E39AC = 0; // weak
__int16 word_E39AE = 0; // weak
__int16 word_E39B0 = 0; // weak
__int16 word_E39B2 = 0; // weak
__int16 word_E39B4 = 0; // weak
__int16 word_E39B6 = 0; // weak
char byte_E39B8 = '\0'; // weak
int dword_E39BC = 0; // weak
__int16 word_E39C0[64] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_E3A40[64] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_E3AC0[64] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_E3B40 = 0; // weak
int dword_E3B44 = 0; // weak
__int16 word_E3B4A = 0; // weak
__int16 word_E3B4C = 0; // weak
__int16 word_E3B4E = 0; // weak
char byte_E3B50 = '\0'; // weak
char byte_E3B51 = '\0'; // weak
int (*off_E3B90)() = &_null_int23_exit; // weak
int dword_E3B94 = 0; // weak
__int16 word_E3B98 = 32; // weak
__int16 word_E3B9A = 0; // weak
__int16 word_E3BA4 = 0; // weak
__int16 word_E3BA6 = 0; // weak
__int16 word_E3BA8 = 0; // weak
__int16 word_E3BAA = 0; // weak
int dword_E3BAC = 0; // weak
int dword_E3BB0 = 0; // weak
int dword_E3BB8 = 1; // weak
_UNKNOWN unk_E3BE0; // weak
int dword_E3DE8 = 0; // weak
int dword_E3DF8 = 1024; // weak
int dword_E3DFC[] = { 0 }; // weak
void (__noreturn *off_E3E10)() = &sub_9BA00; // weak
__int16 seg_E3E14[] = { 1 }; // weak
char byte_E3E28 = '\0'; // weak
int dword_E3E2C = 0; // weak
int (__cdecl *off_E3E30)(_DWORD) = &malloc; // weak
int (__cdecl *off_E3E34)(int) = &free; // weak
int dword_E3E38 = 0; // weak
int dword_E3E3C = 0; // weak
int dword_E3E40 = 0; // weak
char byte_E3E44 = '\0'; // weak
char byte_E3E45 = '\x01'; // weak
char aBullfrog[9] = "Bullfrog"; // weak
char byte_E3E54[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_E3E5C[] = { 0 }; // weak
int dword_E3E9C[] = { 0 }; // weak
int dword_E3ED8 = 0; // weak
int dword_E3EDC[] = { 0 }; // weak
int dword_E3F1C[] = { 0 }; // weak
int dword_E3F5C[] = { 0 }; // weak
int dword_E3F98 = 0; // weak
int dword_E3F9C[] = { 0 }; // weak
int dword_E3FDC = 0; // weak
__int16 word_E3FE0 = 0; // weak
int dword_E3FE2 = 0; // weak
int dword_E3FE6 = 0; // weak
int dword_E3FEA = 0; // weak
int dword_E3FEE = 0; // weak
int dword_E3FF2 = 0; // weak
__int16 word_E3FF6 = 0; // weak
int dword_E3FF8 = 0; // weak
int dword_E3FFC = 0; // weak
int dword_E4000 = 0; // weak
_UNKNOWN unk_E4004; // weak
__int16 word_E4A04 = 0; // weak
int dword_E4A08 = 0; // weak
char byte_E4A0C[128] =
{
  '\0',
  '\x02',
  '\x04',
  '\x06',
  '\b',
  '\n',
  '\f',
  '\x0E',
  '\x10',
  '\x12',
  '\x14',
  '\x16',
  '\x18',
  '\x1A',
  '\x1C',
  '\x1E',
  ' ',
  '\"',
  '$',
  '&',
  '(',
  '*',
  ',',
  '.',
  '0',
  '2',
  '4',
  '6',
  '8',
  ':',
  '<',
  '>',
  '@',
  'B',
  'D',
  'F',
  'H',
  'J',
  'L',
  'N',
  'P',
  'R',
  'T',
  'V',
  'X',
  'Z',
  '\\',
  '^',
  '`',
  'b',
  'd',
  'f',
  'h',
  'j',
  'l',
  'n',
  'p',
  'r',
  't',
  'v',
  'x',
  'z',
  '|',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80'
}; // weak
int dword_E4A8C = 0; // weak
int dword_E4A90 = 0; // weak
int dword_E4A94 = 0; // weak
char aSample[7] = "SAMPLE"; // weak
int dword_E4B18 = 0; // weak
int dword_E4B1C = 0; // weak
char aTimb_0[5] = "TIMB"; // weak
char byte_E4B2A = '\xFF'; // weak
char byte_E4B2B = '\xFF'; // weak
int dword_E4B2C = 0; // weak
int dword_E4C90 = 0; // weak
int dword_E4C94 = 0; // weak
int dword_E4CA4 = 0; // weak
char byte_E4CB2 = '\0'; // weak
char byte_E4CB4 = '\0'; // weak
int (__fastcall *off_E4CBD)(_DWORD) = &nullsub_3; // weak
int dword_E4CCC = 0; // weak
int dword_E4CD0 = 0; // weak
int dword_E4D10 = 0; // weak
__int16 word_E4D14 = 0; // weak
__int16 word_E4D16 = 0; // weak
char byte_E4D18 = '\0'; // weak
int (__cdecl *off_E4D20)(_DWORD, _DWORD) = &_no_support_loaded; // weak
int dword_E4E1C = 0; // weak
int dword_E4E20 = 0; // weak
int dword_E4E24 = 0; // weak
int dword_E4E28 = 0; // weak
int dword_E4E2C = 0; // weak
__int64 qword_E4E30 = 0i64; // weak
int dword_E4E38 = 0; // weak
__int16 word_E4E3C = 0; // weak
_UNKNOWN unk_E52EE; // weak
int dword_E731C = 16; // weak
int dword_E7320[] = { 0 }; // weak
int dword_E7324[255] =
{
  1647088,
  3294115,
  4941018,
  6587735,
  8234204,
  9880363,
  11526150,
  13171503,
  14816360,
  16460659,
  18104339,
  19747337,
  21389591,
  23031040,
  24671622,
  26311275,
  27949938,
  29587548,
  31224044,
  32859365,
  34493448,
  36126233,
  37757658,
  39387661,
  41016182,
  42643158,
  44268528,
  45892232,
  47514208,
  49134395,
  50752733,
  52369159,
  53983614,
  55596036,
  57206365,
  58814541,
  60420502,
  62024188,
  63625539,
  65224495,
  66820995,
  68414979,
  70006387,
  71595160,
  73181237,
  74764559,
  76345066,
  77922699,
  79497398,
  81069104,
  82637758,
  84203301,
  85765673,
  87324816,
  88880672,
  90433181,
  91982285,
  93527927,
  95070047,
  96608588,
  98143491,
  99674700,
  101202156,
  102725801,
  104245579,
  105761432,
  107273304,
  108781136,
  110284873,
  111784458,
  113279835,
  114770946,
  116257736,
  117740150,
  119218130,
  120691622,
  122160570,
  123624918,
  125084613,
  126539598,
  127989818,
  129435220,
  130875749,
  132311350,
  133741970,
  135167555,
  136588051,
  138003404,
  139413562,
  140818470,
  142218077,
  143612330,
  145001175,
  146384561,
  147762436,
  149134748,
  150501445,
  151862476,
  153217789,
  154567334,
  155911059,
  157248914,
  158580849,
  159906814,
  161226758,
  162540632,
  163848386,
  165149972,
  166445340,
  167734441,
  169017227,
  170293650,
  171563661,
  172827213,
  174084258,
  175334749,
  176578639,
  177815881,
  179046428,
  180270234,
  181487253,
  182697439,
  183900746,
  185097130,
  186286545,
  187468946,
  188644290,
  189812531,
  190973625,
  192127530,
  193274201,
  194413595,
  195545670,
  196670383,
  197787691,
  198897553,
  199999926,
  201094769,
  202182041,
  203261701,
  204333709,
  205398023,
  206454605,
  207503413,
  208544409,
  209577553,
  210602807,
  211620132,
  212629490,
  213630842,
  214624151,
  215609379,
  216586490,
  217555447,
  218516213,
  219468752,
  220413028,
  221349005,
  222276649,
  223195924,
  224106796,
  225009231,
  225903194,
  226788652,
  227665571,
  228533919,
  229393663,
  230244770,
  231087209,
  231920947,
  232745954,
  233562198,
  234369648,
  235168275,
  235958047,
  236738936,
  237510912,
  238273946,
  239028009,
  239773072,
  240509108,
  241236089,
  241953988,
  242662778,
  243362431,
  244052922,
  244734224,
  245406312,
  246069161,
  246722745,
  247367041,
  248002023,
  248627668,
  249243953,
  249850853,
  250448347,
  251036411,
  251615025,
  252184165,
  252743810,
  253293940,
  253834533,
  254365570,
  254887030,
  255398893,
  255901141,
  256393755,
  256876715,
  257350004,
  257813604,
  258267497,
  258711667,
  259146097,
  259570769,
  259985670,
  260390781,
  260786089,
  261171579,
  261547236,
  261913046,
  262268994,
  262615069,
  262951256,
  263277543,
  263593918,
  263900369,
  264196884,
  264483453,
  264760063,
  265026706,
  265283370,
  265530047,
  265766727,
  265993400,
  266210059,
  266416696,
  266613302,
  266799870,
  266976394,
  267142865,
  267299279,
  267445630,
  267581911,
  267708118,
  267824246,
  267930290,
  268026247,
  268112113,
  268187885,
  268253559,
  268309134,
  268354608,
  268389978,
  268415243,
  268430402
}; // weak
int dword_E7720 = 268435456; // weak
int dword_E7724[] = { 0 }; // weak
void *off_E7728 = &unk_FFFFA; // weak
int dword_E7B24 = 210828714; // weak
__int16 word_E7C58 = 0; // weak
_UNKNOWN unk_E7C64; // weak
double dbl_E7C6E = 1.797693134862316e308; // weak
float flt_E7C76 = 3.4028235e38; // weak
int dword_E7EE0[] = { 0 }; // weak
int dword_E7EE4[] = { 0 }; // weak
int dword_E7EE8[] = { 0 }; // weak
int dword_E7EEC[] = { 0 }; // weak
int dword_E7EF0[] = { 0 }; // weak
int dword_E7EF4[595] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  
}; // weak
int dword_E8840; // weak
char byte_E88E0[]; // weak
char byte_E88E1[]; // weak
char byte_E88E2[]; // weak
char byte_E88E3; // weak
char byte_E88E4; // weak
char byte_E88E5; // weak
char byte_E88E6; // weak
char byte_E88E7; // weak
char byte_E88E8; // weak
char byte_E88E9; // weak
char byte_E88EA; // weak
char byte_E88EB; // weak
char byte_E88EC; // weak
char byte_E88ED; // weak
char byte_E88EE; // weak
char byte_E88EF; // weak
char byte_E88F0; // weak
char byte_E88F1; // weak
char byte_E88F2; // weak
char byte_E88F3; // weak
char byte_E88F4; // weak
char byte_E88F5; // weak
char byte_E88F6; // weak
char byte_E88F7; // weak
char byte_E8900[]; // weak
char byte_E890F; // weak
char byte_E8988; // weak
char byte_E89F0; // weak
char byte_E89FF; // weak
char byte_E9188; // weak
char byte_E9800; // weak
char byte_E980F; // weak
char byte_E98F0; // weak
char byte_E98FF; // weak
int dword_E9980; // weak
__int16 word_E9984[134]; // weak
int dword_E9B20[]; // weak
int dword_E9B90; // weak
int dword_E9BA8; // weak
int dword_E9C08; // weak
int dword_E9C14; // weak
int dword_E9C18; // weak
int dword_E9C1C; // weak
int dword_E9C20; // weak
int dword_E9C24; // weak
int dword_E9C28; // weak
int dword_E9C2C; // weak
int dword_E9C30; // weak
int dword_E9C38; // weak
int dword_E9C3C; // weak
int dword_E9C4C[]; // weak
int dword_E9C54; // weak
int dword_E9C84; // weak
int dword_E9CA8[136]; // weak
int dword_E9EC8; // weak
int dword_E9ECC[123]; // weak
int dword_EA0B8; // weak
int dword_EA1D0; // weak
int dword_EA224; // weak
int dword_EA230; // weak
int dword_EA234; // weak
int dword_EA238; // weak
int dword_EA240; // weak
int dword_EA244; // weak
int dword_EA248; // weak
int dword_EA24C; // weak
int dword_EA250; // weak
int dword_EA254; // weak
int dword_EA26C; // weak
int dword_EA270; // weak
int dword_EA274; // weak
int dword_EA2C4; // weak
int dword_EA2E8; // weak
int dword_EA2EC; // weak
int dword_EA2F0; // weak
int dword_EA300; // weak
int dword_EA304; // weak
int dword_EA308; // weak
int dword_EA3B4; // weak
int dword_EA3B8; // weak
int dword_EA3BC; // weak
int dword_EA3C0; // weak
int dword_EA3C4; // weak
int dword_EA3C8; // weak
int dword_EA3CC; // weak
int dword_EA3D0; // weak
int dword_EA3D4; // weak
int dword_EA3D8; // weak
int dword_EA3DC; // weak
int dword_EA3E0[]; // weak
int dword_EA3E4[]; // weak
int dword_EA3E8; // weak
int dword_EB384; // weak
int dword_EB394; // weak
__int16 word_EB398; // weak
__int16 word_EB39A; // weak
__int16 word_EB39C; // weak
char byte_EB39E; // weak
char byte_EB39F; // weak
char byte_EB3A0; // weak
char byte_EB3A1; // weak
char byte_EB3A2; // weak
char byte_EB3A3; // weak
char byte_EB3A4; // weak
char byte_EB3A5; // weak
char byte_EB3A6; // weak
char byte_EB3A7; // weak
char byte_EB3A8; // weak
char byte_EB3B6; // weak
_UNKNOWN unk_F0000; // weak
int dword_F01E4; // weak
int (__cdecl *dword_F01E8)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_F01EC)(_DWORD, _DWORD, _DWORD); // weak
__int16 word_F01F4; // weak
char byte_F01FE[]; // weak
char byte_F01FF[]; // weak
char byte_F0200[31]; // weak
char byte_F021F; // weak
char byte_F0220[256]; // weak
char byte_F0320[256]; // weak
char byte_F0420[256]; // weak
char byte_F0520[256]; // weak
char byte_F0620[256]; // weak
char byte_F0720[256]; // weak
char byte_F0820[256]; // weak
char byte_F0920[256]; // weak
_UNKNOWN unk_F0A20; // weak
_UNKNOWN unk_F0E20; // weak
int dword_F2C20; // weak
int dword_F2C24; // weak
int dword_F2C28; // weak
int dword_F2C2C; // weak
int dword_F2C30; // weak
int dword_F2C34; // weak
int dword_F2C38; // weak
int dword_F2C3C; // weak
int dword_F2C40; // weak
int dword_F2C44; // weak
int dword_F2C48; // weak
int dword_F2C4C; // weak
int dword_F2C50; // weak
int dword_F2C54; // weak
int dword_F2C58; // weak
int dword_F2C5C; // weak
int dword_F2C60; // weak
int dword_F2C64; // weak
int dword_F2C68; // weak
int dword_F2C6C; // weak
int dword_F2C70; // weak
int dword_F2C74; // weak
int dword_F2C78; // weak
int dword_F2C7C; // weak
int dword_F2C80; // weak
int dword_F2C84; // weak
int dword_F2C88; // weak
int dword_F2C8C; // weak
int dword_F2C90; // weak
int dword_F2C94; // weak
int dword_F2C98; // weak
int dword_F2C9C; // weak
int dword_F2CA0; // weak
int dword_F2CA4; // weak
int dword_F2CA8; // weak
int dword_F2CAC; // weak
int dword_F2CB0; // weak
int dword_F2CB4; // weak
int dword_F2CB8; // weak
int dword_F2CBC; // weak
__int16 word_F2CC0; // weak
__int16 word_F2CC2; // weak
__int16 word_F2CC4; // weak
char byte_F2CC6; // weak
char byte_F2CC7; // weak
char byte_F2CD0[]; // weak
char byte_F2CD1[4815]; // weak
char byte_F3FA0[]; // weak
char byte_F3FA1[]; // weak
char byte_F3FA2[670]; // weak
_UNKNOWN unk_F4240; // weak
int dword_F42A0; // weak
int dword_F42A4; // weak
__int16 word_F42A8; // weak
__int16 word_F42AE; // weak
_UNKNOWN unk_F42B0; // weak
int dword_F4720; // weak
int dword_F4940; // weak
__int16 word_F4960[]; // weak
__int16 word_F4962[831]; // weak
__int16 word_F4FE0[]; // weak
__int16 word_F4FE2[]; // weak
__int16 word_F4FE4[]; // weak
__int16 word_F4FE6[]; // weak
__int16 word_F4FE8[]; // weak
__int16 word_F4FEA[419]; // weak
int dword_F5330; // weak
__int16 word_F5334; // weak
char byte_F5340[504]; // weak
char byte_F5538[504]; // weak
int dword_F5730[504]; // weak
int dword_F5F10[504]; // weak
int dword_F66F0[504]; // weak
int dword_F6ED0; // weak
char byte_F6EE0[16384]; // weak
char byte_FAEE0[16672]; // weak
_UNKNOWN unk_FF000; // weak
_UNKNOWN unk_100000; // weak
_UNKNOWN unk_100001; // weak
char byte_10AEE0[768]; // weak
char byte_10B1E0[511]; // weak
char byte_10B3DF[]; // weak
char byte_10B3E0[255]; // weak
char byte_10B4DF[]; // weak
char byte_10B4E0[19235]; // weak
char byte_11B4E0[65536]; // weak
char byte_12B4E0[]; // weak
_UNKNOWN unk_12C000; // weak
_UNKNOWN unk_13A9CA; // weak
_UNKNOWN unk_13ACCA; // weak
_UNKNOWN unk_13B194; // weak
_UNKNOWN unk_13B3B8; // weak
char byte_13B4E0[6464]; // weak
_UNKNOWN unk_13CE20; // weak
_UNKNOWN unk_141E85; // weak
_UNKNOWN unk_145210; // weak
char byte_14B4E0[65536]; // weak
__int16 word_15B4E0[9616]; // weak
_UNKNOWN unk_163EFC; // weak
_UNKNOWN unk_1641FC; // weak
_UNKNOWN unk_1646BA; // weak
_UNKNOWN unk_164907; // weak
_UNKNOWN unk_164DAE; // weak
_UNKNOWN unk_164FCD; // weak
_UNKNOWN unk_165329; // weak
_UNKNOWN unk_16554D; // weak
_UNKNOWN unk_178B5F; // weak
_UNKNOWN unk_178E5F; // weak
__int16 word_17B4E0; // weak
_UNKNOWN unk_17C118; // weak
int dword_17D430; // weak
__int16 word_17D434; // weak
char byte_17D440[]; // weak
char byte_17D441[255]; // weak
_UNKNOWN unk_17D540; // weak
int dword_17D640; // weak
int dword_17D644; // weak
int dword_17D648; // weak
char byte_17D650[6]; // weak
char byte_17D674[6]; // weak
int dword_17D698; // weak
int dword_17D6A0; // weak
int dword_17D6A4; // weak
int dword_17D6A8; // weak
int dword_17D6AC; // weak
int dword_17D6B0; // weak
int dword_17D6B8; // weak
int dword_17D6BC; // weak
int dword_17D6C0; // weak
int dword_17D6C4; // weak
int dword_17D6C8; // weak
__int16 word_17D6CC; // weak
__int16 word_17D6CE; // weak
__int16 word_17D6D0; // weak
_UNKNOWN unk_17D6D4; // weak
int dword_17D6E4; // weak
int dword_17D6E8; // weak
int dword_17D6EC; // weak
int dword_17D6F0; // weak
__int16 word_17D6F6; // weak
__int16 word_17D706; // weak
__int16 word_17D708; // weak
__int16 word_17D70A; // weak
__int16 word_17D70C; // weak
__int16 word_17D70E; // weak
char byte_17D710; // weak
char byte_17D711; // weak
int dword_17D720; // weak
__int16 word_17D724; // weak
__int16 word_17D726; // weak
int dword_17D730; // weak
char byte_17D738[256]; // weak
unsigned __int8 byte_17D838[768]; // weak
int dword_17DB38; // weak
int (__fastcall *dword_17DB3C)(_DWORD); // weak
_UNKNOWN unk_17DB40; // weak
__int16 word_17DB46; // weak
__int16 word_17DB48; // weak
__int16 word_17DB4A; // weak
int dword_17DB50; // weak
int dword_17DB54; // weak
__int16 word_17DB58; // weak
__int16 word_17DB5A; // weak
__int16 word_17DB5C; // weak
__int16 word_17DB60; // weak
int dword_17DB70; // weak
__int16 word_17DB74; // weak
__int16 word_17DB76; // weak
__int16 word_17DB78[3]; // weak
__int16 word_17DB7E; // weak
__int16 word_17DB80; // weak
__int16 word_17DB82; // weak
__int16 word_17DB84; // weak
__int16 word_17DB86; // weak
__int16 word_17DB88; // weak
__int16 word_17DB8A; // weak
__int16 word_17DB8C; // weak
char byte_17DB8E; // weak
char byte_17DB8F; // weak
__int16 word_17DB90[12]; // weak
int dword_17DBA8[3]; // weak
char byte_17DBB6; // weak
int dword_17DBB8; // weak
int dword_17DBBC; // weak
__int16 word_17DBC4; // weak
char byte_17DBC6; // weak
int dword_17DBC8[]; // weak
int dword_17DBCC[]; // weak
int dword_17DBD0[]; // weak
int dword_17DBD4[]; // weak
int dword_17DBD8[121]; // weak
int dword_17DDBC[]; // weak
int dword_17DDC0[]; // weak
int dword_17DDC4[]; // weak
int dword_17DDC8[]; // weak
int dword_17DDCC[21]; // weak
int dword_17DE22; // weak
__int16 word_17DE26; // weak
int dword_17DE28; // weak
int dword_17DE2C; // weak
__int16 word_17DE30; // weak
__int16 word_17DE32; // weak
char byte_17DE34; // weak
int dword_17DE38; // weak
int dword_17DE3C; // weak
int dword_17DE40; // weak
int dword_17DE44; // weak
int dword_17DE48; // weak
int dword_17DE4C; // weak
int dword_17DE50; // weak
int dword_17DE54; // weak
int dword_17DE58; // weak
int dword_17DE5C; // weak
int dword_17DE60; // weak
int dword_17DE64; // weak
char byte_17DE68[]; // weak
char byte_17DE69[]; // weak
char byte_17DE71[]; // weak
char byte_17DE72[78]; // weak
int dword_17DEC0; // weak
int dword_17DEC4; // weak
int dword_17DEC8; // weak
int dword_17DECC; // weak
int dword_17DED0; // weak
int dword_17DED4; // weak
int dword_17DED8; // weak
int dword_17DEDC; // weak
int dword_17DEE0; // weak
int dword_17DEE4; // weak
__int16 word_17DEEC; // weak
__int16 word_17DEEE; // weak
__int16 word_17DEF0; // weak
__int16 word_17DEF2; // weak
__int16 word_17DEF4; // weak
__int16 word_17DEF6; // weak
__int16 word_17DEF8; // weak
__int16 word_17DEFA; // weak
__int16 word_17DEFC; // weak
__int16 word_17DEFE; // weak
__int16 word_17DF00; // weak
__int16 word_17DF02; // weak
__int16 word_17DF04; // weak
__int16 word_17DF06; // weak
__int16 word_17DF08; // weak
__int16 word_17DF0A; // weak
__int16 word_17DF0C; // weak
__int16 word_17DF0E; // weak
char byte_17DF10; // weak
char byte_17DF11; // weak
char byte_17DF13; // weak
_BYTE byte_17DF14[40]; // weak
char byte_17DF3C[]; // weak
char byte_17DF3D[]; // weak
char byte_17DF3E[302]; // weak
__int16 word_17E06C; // weak
__int16 word_17E06E; // weak
__int16 word_17E070; // weak
__int16 word_17E072; // weak
__int16 word_17E074; // weak
__int16 word_17E076; // weak
_UNKNOWN unk_17E078; // weak
__int16 word_17E07C; // weak
__int16 word_17E07E; // weak
__int16 word_17E080; // weak
char byte_17E082; // weak
char byte_17E083; // weak
__int16 word_17E084[12]; // weak
char byte_17E09C; // weak
char byte_17E09D; // weak
int dword_17E0A0[]; // weak
int dword_17E0A4[]; // weak
int dword_17E0A8[766]; // weak
int dword_17ECA0; // weak
int dword_17ECA4; // weak
int dword_17ECA8; // weak
int dword_17ECAC; // weak
char byte_17ECB0[]; // weak
char byte_17ECB1[4591]; // weak
int dword_17FEA0; // weak
int dword_17FEA4; // weak
int dword_17FEA8; // weak
int dword_17FEAC; // weak
int dword_17FEB0; // weak
int dword_17FEC0; // weak
int dword_17FEC4; // weak
int dword_17FEC8; // weak
int dword_17FECC; // weak
int dword_17FF0C; // weak
int dword_17FF10; // weak
int dword_17FF14; // weak
__int16 word_17FF18; // weak
int dword_17FF20; // weak
int dword_17FF24; // weak
_UNKNOWN unk_17FF28; // weak
int dword_17FF38; // weak
int dword_17FF40; // weak
int dword_17FF44; // weak
__int16 word_17FF4A; // weak
__int16 word_17FF56; // weak
__int16 word_17FF58; // weak
__int16 word_17FF5A; // weak
int dword_180078; // weak
int dword_180084[]; // weak
int dword_180088[99]; // weak
int dword_180214[101]; // weak
_UNKNOWN unk_1803A8; // weak
__int16 word_1803AB; // weak
_UNKNOWN unk_1803C0; // weak
__int16 word_1803C3; // weak
__int16 word_1803E8; // weak
__int16 word_1803EA; // weak
__int16 word_1803EC; // weak
char byte_1803EE[100]; // weak
_UNKNOWN unk_180452; // weak
__int16 word_180455; // weak
_UNKNOWN unk_180460; // weak
__int16 word_180463; // weak
_UNKNOWN unk_180470; // weak
char byte_180471; // weak
char byte_180472; // weak
int dword_180473; // weak
_UNKNOWN unk_180484; // weak
int dword_180486; // weak
char byte_18048A; // weak
_UNKNOWN unk_18048B; // weak
_UNKNOWN unk_180498; // weak
char byte_18049E; // weak
char byte_1804A1; // weak
_UNKNOWN unk_1804B0; // weak
__int16 word_1804BE; // weak
__int16 word_1804C0; // weak
__int16 word_1804C2; // weak
__int16 word_1804C4; // weak
__int16 word_1804C6; // weak
__int16 word_1804C8; // weak
__int16 word_1804CA; // weak
__int16 word_1804E3[6]; // weak
__int16 word_1804EF; // weak
__int16 word_1804F7; // weak
__int16 word_1804F9; // weak
__int16 word_1804FB; // weak
__int16 word_1804FD; // weak
__int16 word_1804FF; // weak
__int16 word_180501; // weak
__int16 word_180507; // weak
__int16 word_180509; // weak
__int16 word_18050B; // weak
__int16 word_18050D; // weak
char byte_180513; // weak
char byte_180514; // weak
int dword_180516; // weak
int dword_18051A; // weak
int dword_18051E; // weak
int dword_180522; // weak
int dword_180526; // weak
int dword_18052A; // weak
int dword_180532; // weak
__int16 word_180536; // weak
__int16 word_180538; // weak
int dword_18053A; // weak
__int16 word_18053E[4]; // weak
__int16 word_180546; // weak
__int16 word_180548; // weak
__int16 word_18054A; // weak
__int16 word_18054C; // weak
__int16 word_18054E; // weak
char byte_180550; // weak
char byte_180551; // weak
char byte_180552; // weak
char byte_180553; // weak
char byte_180554; // weak
char byte_180555; // weak
char byte_180556; // weak
char byte_180557; // weak
char byte_180558; // weak
char byte_180559; // weak
char byte_18055A; // weak
_UNKNOWN unk_180560; // weak
char byte_180584; // weak
char byte_180586; // weak
char byte_180587; // weak
char byte_180588; // weak
char byte_180589; // weak
_DWORD dword_18058C; // weak
int dword_180590; // weak
int dword_180594; // weak
int dword_180598; // weak
int dword_18059C; // weak
int dword_1805A0; // weak
int dword_1805A4; // weak
int dword_1805A8; // weak
int dword_1805AC; // weak
int dword_1805B0; // weak
int dword_1805B4; // weak
int dword_1805B8; // weak
int dword_1805BC; // weak
__int16 word_1805C0; // weak
__int16 word_1805C2; // weak
__int16 word_1805C4; // weak
__int16 word_1805C6; // weak
__int16 word_1805C8; // weak
int dword_1805CE[21]; // weak
int dword_180624; // weak
int dword_180628; // weak
int dword_18062C; // weak
int dword_180630; // weak
int dword_180634; // weak
int dword_180638; // weak
int dword_18063C; // weak
int dword_180640; // weak
int dword_180644; // weak
int dword_180648; // weak
int dword_18064C; // weak
int dword_180650; // weak
int dword_180654; // weak
int dword_180658; // weak
int dword_18065C; // weak
__int16 word_180660; // weak
__int16 word_180662; // weak
char byte_180664[24]; // weak
char byte_18067C; // weak
char byte_18068E; // weak
char byte_180693; // weak
char byte_180696; // weak
char byte_18069A; // weak
char byte_18069C; // weak
char byte_1806E4; // weak
char byte_1806E5; // weak
_UNKNOWN unk_1806E6; // weak
int dword_1806E8; // weak
_UNKNOWN unk_1806EC; // weak
__int16 word_1806EE; // weak
int dword_1806F0; // weak
int dword_1806F4; // weak
int dword_1806F8; // weak
int dword_1806FC; // weak
int dword_180700; // weak
int dword_180704; // weak
int dword_180708; // weak
int dword_18070C; // weak
int dword_180714; // weak
int dword_180718; // weak
int dword_180720; // weak
__int16 word_18072C; // weak
__int16 word_18072E; // weak
int dword_180730; // weak
int dword_180734; // weak
__int16 word_180738; // weak
int dword_18073A; // weak
__int16 word_180744; // weak
__int16 word_180746; // weak
__int16 word_18074A; // weak
__int16 word_18074C; // weak
_UNKNOWN unk_180750; // weak
_UNKNOWN unk_180A30; // weak
char byte_180AB0[128]; // weak
__int16 word_180B30; // weak
int dword_180B48; // weak
int dword_180B4C; // weak
__int16 word_180B50; // weak
_UNKNOWN unk_180B60; // weak
_UNKNOWN unk_180BE0; // weak
int dword_180C78; // weak
int dword_180C7C; // weak
int dword_180C80; // weak
char byte_180C84; // weak
char byte_180C90[]; // weak
int dword_180CA0[]; // weak
_DWORD dword_180CA4[255]; // weak
char byte_1810A3[]; // weak
__int16 word_1811E4[]; // weak
char byte_181504[64]; // weak
char byte_181544[768]; // weak
_UNKNOWN unk_181844; // weak
_UNKNOWN unk_181B42; // weak
__int16 word_181B44; // weak
char byte_181B50[144]; // weak
int dword_181BE0; // weak
int dword_181BE4; // weak
int dword_181BF0; // weak
int dword_181BF4; // weak
int dword_181BF8; // weak
int dword_181BFC; // weak
int dword_181C00; // weak
int dword_181C04; // weak
int dword_181C08; // weak
int dword_181C0C; // weak
int dword_181C10; // weak
char byte_181C14[24]; // weak
char byte_181C2C; // weak
int dword_181C40; // weak
__int16 word_181C44; // weak
int dword_181C50[16]; // weak
char byte_181C90; // weak
_UNKNOWN unk_181D90; // weak
int dword_181DA8; // weak
int dword_181DAC[]; // weak
int dword_181DB0; // weak
int dword_181DB4; // weak
int dword_181DB8; // weak
int dword_181DBC; // weak
int dword_181DC0; // weak
int dword_181DC4; // weak
int dword_181DC8; // weak
int dword_181DCC; // weak
int dword_181DD0; // weak
int dword_181DD8; // weak
int dword_181DDC; // weak
int dword_181DE0; // weak
int dword_181DE4; // weak
int dword_181DE8; // weak
int dword_181DEC; // weak
int dword_181DF0; // weak
int dword_181DF4; // weak
_UNKNOWN unk_181DF8; // weak
int dword_181E10; // weak
int dword_181E20; // weak
int dword_181E26; // weak
__int16 word_181E2A; // weak
int dword_181E2C; // weak
__int16 word_181E30; // weak
_UNKNOWN unk_181E80; // weak
int dword_181E8C; // weak
int dword_181E90; // weak
int dword_181E94; // weak
int dword_181E98; // weak
int dword_181E9C; // weak
int dword_181EA0; // weak
int dword_181EB0; // weak
int dword_181EB4; // weak
int dword_181EB8; // weak
int dword_181EBC; // weak
int dword_181EC0; // weak
int dword_181EC4; // weak
int dword_181EC8; // weak
int dword_181ECC; // weak
int dword_181ED0; // weak
int dword_181ED4; // weak
int dword_181ED8; // weak
int dword_181EDC; // weak
_UNKNOWN unk_181EE0; // weak
int dword_182188[6]; // weak
int dword_1821A0[6]; // weak
int dword_1821B8[6]; // weak
int dword_1821D0[6]; // weak
int dword_1821E8[6]; // weak
_UNKNOWN unk_182200; // weak
_UNKNOWN unk_182204; // weak


//----- (00010010) --------------------------------------------------------
__int16 sub_10010()
{
  __int16 v0; // bx
  __int16 v2[2]; // [esp+0h] [ebp-Ch] BYREF
  int v3; // [esp+4h] [ebp-8h]
  int v4; // [esp+8h] [ebp-4h] BYREF

  v0 = 0;
  if ( byte_D3F48 )
    return 1;
  dos_getdrive(&v4);
  if ( !dos_getdiskfree(v4, v2) && v2[0] == -1 && !v2[1] && v3 == 134217729 )
  {
    v0 = 1;
    byte_D3F48 = 1;
  }
  return v0;
}
// 8C1B2: using guessed type _DWORD __cdecl dos_getdrive(_DWORD);
// 8C1E8: using guessed type _DWORD __cdecl dos_getdiskfree(_DWORD, _DWORD);
// D3F48: using guessed type char byte_D3F48;

//----- (00010080) --------------------------------------------------------
unsigned int __cdecl sub_10080(int a1, int a2)
{
  unsigned int i; // edx
  int v3; // eax
  int v4; // ecx
  int *v5; // ebx

  for ( i = 1; i < 0x64 && dword_E7EE8[6 * i] != -1; ++i )
    ;
  v3 = 3 * i;
  dword_E7EE0[2 * v3] = a1;
  dword_E7EE8[2 * v3] = a1;
  dword_E7EEC[2 * v3] = 0;
  v4 = dword_E7EE8[6 * i];
  dword_E7EE4[2 * v3] = a2;
  v5 = (int *)((char *)&dword_E9980 + 6 * v4);
  dword_E7EF0[2 * v3] = (int)v5;
  dword_E7EF4[2 * v3] = *v5;
  return i;
}
// E7EE0: using guessed type int dword_E7EE0[];
// E7EE4: using guessed type int dword_E7EE4[];
// E7EE8: using guessed type int dword_E7EE8[];
// E7EEC: using guessed type int dword_E7EEC[];
// E7EF0: using guessed type int dword_E7EF0[];
// E7EF4: using guessed type int dword_E7EF4[595];
// E9980: using guessed type int dword_E9980;

//----- (00010100) --------------------------------------------------------
int __cdecl sub_10100(int a1)
{
  dword_E7EE8[6 * a1] = -1;
  return 1;
}
// E7EE8: using guessed type int dword_E7EE8[];

//----- (00010130) --------------------------------------------------------
int __cdecl sub_10130(int a1, _DWORD *a2, _DWORD *a3)
{
  int *v3; // eax
  char *v4; // edx
  int v5; // ecx
  int v6; // ebx
  int v7; // esi
  int v8; // edi
  int v9; // ebx

  v3 = &dword_E7EE0[6 * a1];
  v4 = (char *)v3[5];
  v5 = v3[4];
  *a2 = *v4;
  *a3 = v4[1];
  v6 = v3[3] + 1;
  v3[5] += 4;
  v3[3] = v6;
  if ( *(unsigned __int16 *)(v5 + 4) > v6 )
    return 1;
  v7 = v3[4];
  v3[3] = 0;
  v8 = v3[2];
  v3[4] = v7 + 6;
  ++v8;
  v9 = v3[1];
  v3[2] = v8;
  if ( v8 <= v9 )
    return 1;
  else
    return 2;
}
// E7EE0: using guessed type int dword_E7EE0[];

//----- (000101C0) --------------------------------------------------------
unsigned __int8 sub_101C0()
{
  int v0; // esi
  unsigned int i; // edx
  int v2; // eax
  _BYTE *v3; // edx
  unsigned __int8 result; // al
  int v5; // ebx
  __int16 j; // cx
  char v7; // ah
  char v8; // [esp+4h] [ebp-Ch]
  char v9; // [esp+8h] [ebp-8h]
  __int16 v10; // [esp+Ch] [ebp-4h]

  v0 = dword_180628;
  sub_53E60((int)aDataSearchDat, (char *)dword_180628);
  for ( i = 1; i < 0x64; ++i )
  {
    v2 = 3 * i;
    dword_E7EE8[2 * v2] = -1;
  }
  v3 = (_BYTE *)dword_E9C30;
  for ( result = 0; result < 0x20u; ++result )
  {
    v5 = 3 * result;
    *(int *)((char *)&dword_E9980 + 2 * v5) = (int)v3;
    v10 = 0;
    word_E9984[v5] = 0;
    while ( v10 < 32 )
    {
      for ( j = 0; j < 32; ++j )
      {
        v7 = *(_BYTE *)(v0 + j + 32 * v10);
        if ( result == v7 )
        {
          if ( !v7 && v3 == (_BYTE *)dword_E9C30 )
          {
            v8 = j;
            v9 = v10;
          }
          *v3 = j - v8;
          v3[1] = v10 - v9;
          v3[2] = result;
          v3 += 4;
          ++word_E9984[3 * result];
        }
      }
      ++v10;
    }
  }
  return result;
}
// 1026C: variable 'v8' is possibly undefined
// 10276: variable 'v9' is possibly undefined
// E7EE8: using guessed type int dword_E7EE8[];
// E9980: using guessed type int dword_E9980;
// E9984: using guessed type __int16 word_E9984[134];
// E9C30: using guessed type int dword_E9C30;
// 180628: using guessed type int dword_180628;

//----- (000102D0) --------------------------------------------------------
int __cdecl sub_102D0(int a1, __int16 *a2, char a3)
{
  int v3; // esi
  int result; // eax
  int v5; // esi
  __int16 v6; // ax
  int v7; // edi
  int i; // esi
  int v9; // eax
  unsigned __int16 v10; // ax
  __int16 v11; // si
  __int16 v12; // ax
  int v13; // ebx
  int v14; // ebx
  int v15; // [esp+0h] [ebp-Ch] BYREF
  __int16 v16; // [esp+4h] [ebp-8h]
  int v17; // [esp+8h] [ebp-4h]

  if ( (a3 & 2) != 0 )
  {
    v3 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 12);
    if ( a2[2] < v3 + (__int16)sub_10C40(a2) )
      return 1;
    v5 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 10);
    if ( a2[2] > (__int16)sub_10C40(a2) + v5 )
      return 1;
  }
  if ( (a3 & 1) != 0 )
  {
    v15 = *(_DWORD *)a2;
    v16 = a2[2];
    v6 = *(_WORD *)(a1 + 84);
    if ( v6 <= *(__int16 *)(a1 + 86) )
      v6 = *(_WORD *)(a1 + 86);
    v7 = v6;
    for ( i = 0; i <= v7; i += 256 )
    {
      v17 = ~*(_DWORD *)(*(_DWORD *)(a1 + 160) + 20);
      v9 = sub_104D0((__int16 *)&v15);
      result = v17 & v9;
      if ( result )
        return result;
      if ( byte_D41B6 )
      {
        LOBYTE(v10) = BYTE1(v15);
        HIBYTE(v10) = HIBYTE(v15);
        if ( (byte_13B4E0[v10] & 8) != 0 )
          return 1;
        if ( sub_11E70(a1, (__int16 *)&v15) )
          return 1;
      }
      sub_57FA0(&v15, *(_WORD *)(a1 + 28), 0, 256);
    }
  }
  if ( (a3 & 4) != 0 )
  {
    v11 = sub_58210((_WORD *)(a1 + 76), a2);
    v12 = sub_582F0(0, v11);
    if ( v12 < 0 )
    {
      if ( v12 == -1 )
      {
        v14 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 16);
        if ( (unsigned __int16)sub_582B0(0, v11) > v14 )
          return 1;
      }
    }
    else if ( v12 > 0 && v12 == 1 )
    {
      v13 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 18);
      if ( (unsigned __int16)sub_582B0(0, v11) > v13 )
        return 1;
    }
  }
  return 0;
}
// D41B6: using guessed type char byte_D41B6;

//----- (000104A0) --------------------------------------------------------
int __cdecl sub_104A0(int a1)
{
  unsigned __int16 v1; // ax

  LOBYTE(v1) = *(_BYTE *)(a1 + 1);
  HIBYTE(v1) = *(_BYTE *)(a1 + 3);
  return 1 << (byte_13B4E0[v1] & 0xF);
}

//----- (000104D0) --------------------------------------------------------
int __cdecl sub_104D0(__int16 *a1)
{
  int v1; // eax

  v1 = *a1 >> 8;
  BYTE1(v1) = HIBYTE(a1[1]);
  return sub_10590(byte_10B4E0[(unsigned __int16)v1]);
}

//----- (00010590) --------------------------------------------------------
int __cdecl sub_10590(char a1)
{
  int result; // eax

  result = 0;
  switch ( a1 )
  {
    case 0:
      result = 1;
      break;
    case 1:
      result = 2;
      break;
    case 2:
      result = 4;
      break;
    case 3:
      result = 8;
      break;
    case 4:
      result = 16;
      break;
    case 5:
      result = 32;
      break;
    case 8:
      result = 256;
      break;
    case 9:
      result = 512;
      break;
    case 10:
      result = (int)&unk_100000;
      break;
    case 11:
      result = 0x200000;
      break;
    case 12:
      result = 0x400000;
      break;
    case 13:
    case 14:
      return result;
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
      result = 1024;
      break;
    case 21:
    case 22:
    case 24:
      result = (int)&loc_20000;
      break;
    case 23:
      result = (int)&loc_40000;
      break;
    case 25:
    case 27:
      result = (int)&loc_7FFFF + 1;
      break;
    case 26:
      result = (int)sub_10000;
      break;
    default:
      result = 0x800000;
      break;
  }
  return result;
}
// 10000: using guessed type int sub_10000();

//----- (00010630) --------------------------------------------------------
bool __cdecl sub_10630(_WORD *a1, __int16 *a2, _WORD *a3, __int16 *a4)
{
  __int64 v4; // rax
  bool result; // eax

  result = 0;
  if ( abs16(*a3 - *a1) < a2[1] + a4[1] )
  {
    v4 = (__int16)(a3[1] - a1[1]);
    if ( (int)((HIDWORD(v4) ^ v4) - HIDWORD(v4)) < a2[2] + a4[2]
      && (int)abs32((__int16)a1[2] + *a2 - ((__int16)a3[2] + *a4)) < a2[3] + a4[3] )
    {
      return 1;
    }
  }
  return result;
}

//----- (000106C0) --------------------------------------------------------
bool __cdecl sub_106C0(int a1, int a2)
{
  return sub_10630((_WORD *)(a1 + 76), (__int16 *)(a1 + 82), (_WORD *)(a2 + 76), (__int16 *)(a2 + 82));
}

//----- (000106F0) --------------------------------------------------------
bool __cdecl sub_106F0(_WORD *a1, int a2, _WORD *a3, int a4)
{
  __int64 v4; // rax
  bool result; // eax

  result = 0;
  if ( abs16(*a3 - *a1) < *(__int16 *)(a2 + 2) + *(__int16 *)(a4 + 2) )
  {
    v4 = (__int16)(a3[1] - a1[1]);
    if ( (int)((HIDWORD(v4) ^ v4) - HIDWORD(v4)) < *(__int16 *)(a2 + 4) + *(__int16 *)(a4 + 4) )
      return 1;
  }
  return result;
}

//----- (00010750) --------------------------------------------------------
bool __cdecl sub_10750(int a1, int a2)
{
  return sub_106F0((_WORD *)(a1 + 76), a1 + 82, (_WORD *)(a2 + 76), a2 + 82);
}

//----- (00010780) --------------------------------------------------------
int __cdecl sub_10780(int a1)
{
  int v1; // edx
  int v2; // edi
  int i; // eax
  int v5; // ebx
  int v6; // [esp+0h] [ebp-10h] BYREF
  int v7; // [esp+4h] [ebp-Ch] BYREF
  int v8; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  v8 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
  v1 = *(__int16 *)(a1 + 84) + 255;
  v9 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
  v2 = sub_10080(0, (v1 - (__CFSHL__(v1 >> 31, 8) + (v1 >> 31 << 8))) >> 8);
  if ( v2 )
  {
    while ( sub_10130(v2, &v7, &v6) == 1 )
    {
      for ( i = word_15B4E0[256 * (unsigned __int8)(v9 + v6) + (unsigned __int8)(v7 + v8)];
            ;
            i = *(unsigned __int16 *)(v5 + 22) )
      {
        v5 = dword_EA3E4[i];
        if ( v5 == dword_EA3E4[0] )
          break;
        if ( (*(_BYTE *)(v5 + 12) & 8) != 0
          && (*(char *)(a1 + 65) == -1
           || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v5 + 63) && *(char *)(a1 + 66) == -1
           || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v5 + 63) && *(_BYTE *)(a1 + 66) == *(_BYTE *)(v5 + 64))
          && *(_WORD *)(a1 + 26) != *(_WORD *)(v5 + 26)
          && sub_106C0(a1, v5) )
        {
          sub_10100(v2);
          return v5;
        }
      }
    }
    sub_10100(v2);
  }
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (000108B0) --------------------------------------------------------
int __cdecl sub_108B0(int a1)
{
  int v1; // edx
  int v2; // edi
  int i; // eax
  unsigned __int8 v4; // al
  unsigned __int8 v5; // al
  __int16 v6; // ax
  int v8; // ebx
  int v9; // [esp+0h] [ebp-14h] BYREF
  int v10; // [esp+4h] [ebp-10h] BYREF
  int v11; // [esp+8h] [ebp-Ch]
  int v12; // [esp+Ch] [ebp-8h]
  char v13; // [esp+10h] [ebp-4h]

  v11 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
  v1 = *(__int16 *)(a1 + 84) + 255;
  v12 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
  v2 = sub_10080(0, (v1 - (__CFSHL__(v1 >> 31, 8) + (v1 >> 31 << 8))) >> 8);
  if ( v2 )
  {
LABEL_29:
    if ( sub_10130(v2, &v10, &v9) != 1 )
    {
      sub_10100(v2);
      return 0;
    }
    for ( i = word_15B4E0[256 * (unsigned __int8)(v12 + v9) + (unsigned __int8)(v10 + v11)];
          ;
          i = *(unsigned __int16 *)(v8 + 22) )
    {
      v8 = dword_EA3E4[i];
      if ( v8 == dword_EA3E4[0] )
        goto LABEL_29;
      if ( (*(_BYTE *)(v8 + 12) & 8) != 0 )
        break;
LABEL_27:
      ;
    }
    v4 = *(_BYTE *)(v8 + 63);
    v13 = 0;
    if ( v4 >= 5u )
    {
      if ( v4 <= 5u )
      {
        if ( *(_BYTE *)(v8 + 64) != 22 )
          goto LABEL_22;
      }
      else
      {
        if ( v4 != 10 )
          goto LABEL_22;
        v5 = *(_BYTE *)(v8 + 64);
        if ( v5 < 0x2Du )
        {
          if ( v5 < 0x27u || v5 > 0x28u )
            goto LABEL_22;
        }
        else
        {
          if ( v5 > 0x2Du )
          {
            if ( v5 == 57 && *(unsigned __int16 *)(v8 + 40) != *(__int16 *)(a1 + 26) && sub_106C0(a1, v8) )
            {
              sub_10100(v2);
              return v8;
            }
            goto LABEL_22;
          }
          if ( (byte_D93C2[4 * *(char *)(v8 + 70)] & 8) != 0 )
            goto LABEL_22;
        }
      }
      v13 = 1;
    }
LABEL_22:
    if ( v13 )
    {
      v6 = *(_WORD *)(a1 + 26);
      if ( v6 != *(_WORD *)(v8 + 26) && v6 != *(unsigned __int16 *)(v8 + 148) && sub_106C0(a1, v8) )
      {
        sub_10100(v2);
        return v8;
      }
    }
    goto LABEL_27;
  }
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00010A50) --------------------------------------------------------
int __cdecl sub_10A50(int a1)
{
  int v1; // edx
  int v2; // edi
  int i; // eax
  int v5; // ebx
  int v6; // [esp+0h] [ebp-10h] BYREF
  int v7; // [esp+4h] [ebp-Ch] BYREF
  int v8; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  v8 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
  v1 = *(__int16 *)(a1 + 84) + 255;
  v9 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
  v2 = sub_10080(0, (v1 - (__CFSHL__(v1 >> 31, 8) + (v1 >> 31 << 8))) >> 8);
  if ( v2 )
  {
    while ( sub_10130(v2, &v7, &v6) == 1 )
    {
      for ( i = word_15B4E0[256 * (unsigned __int8)(v9 + v6) + (unsigned __int8)(v7 + v8)];
            ;
            i = *(unsigned __int16 *)(v5 + 22) )
      {
        v5 = dword_EA3E4[i];
        if ( v5 == dword_EA3E4[0] )
          break;
        if ( (*(char *)(a1 + 65) == -1
           || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v5 + 63) && *(char *)(a1 + 66) == -1
           || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v5 + 63) && *(_BYTE *)(a1 + 66) == *(_BYTE *)(v5 + 64))
          && *(_WORD *)(a1 + 26) != *(_WORD *)(v5 + 26)
          && sub_106C0(a1, v5) )
        {
          sub_10100(v2);
          return v5;
        }
      }
    }
    sub_10100(v2);
  }
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00010B70) --------------------------------------------------------
int __cdecl sub_10B70(unsigned __int16 *a1, char a2, char a3)
{
  __int16 v3; // si
  __int16 i; // di
  unsigned int j; // ebx
  int v8; // [esp+0h] [ebp-8h]
  int v9; // [esp+4h] [ebp-4h]

  v9 = (*a1 - 128) >> 8;
  v3 = 0;
  v8 = (a1[1] - 128) >> 8;
  while ( v3 < 2 )
  {
    for ( i = 0; i < 2; ++i )
    {
      for ( j = dword_EA3E4[word_15B4E0[256 * (unsigned __int8)(v8 + v3) + (unsigned __int8)(v9 + i)]];
            j > dword_EA3E4[0];
            j = dword_EA3E4[*(unsigned __int16 *)(j + 22)] )
      {
        if ( *(_BYTE *)(j + 63) == a2 && a3 == *(_BYTE *)(j + 64) && sub_583F0(a1, (_WORD *)(j + 76)) <= 0x80 )
          return 1;
      }
    }
    ++v3;
  }
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00010C40) --------------------------------------------------------
int __cdecl sub_10C40(__int16 *a1)
{
  return sub_B5C60(*a1, a1[1]);
}

//----- (00010C60) --------------------------------------------------------
int __cdecl sub_10C60(__int16 *a1)
{
  return sub_B5D68(*a1, a1[1]);
}

//----- (00010C80) --------------------------------------------------------
int __cdecl sub_10C80(int a1, unsigned __int8 a2, unsigned __int16 a3)
{
  int v3; // edi
  unsigned int jj; // esi
  unsigned int kk; // esi
  int v6; // ecx
  int nn; // eax
  int v8; // esi
  int ii; // esi
  int v11; // eax
  int k; // esi
  int v13; // eax
  int v14; // [esp+0h] [ebp-5Ch]
  int v15; // [esp+4h] [ebp-58h]
  int v16; // [esp+8h] [ebp-54h]
  int v17; // [esp+Ch] [ebp-50h]
  int v18; // [esp+10h] [ebp-4Ch]
  int v19; // [esp+1Ch] [ebp-40h]
  int v20; // [esp+20h] [ebp-3Ch]
  int v21; // [esp+24h] [ebp-38h]
  int v22; // [esp+28h] [ebp-34h]
  int n; // [esp+2Ch] [ebp-30h]
  int v24; // [esp+30h] [ebp-2Ch]
  int j; // [esp+34h] [ebp-28h]
  int m; // [esp+38h] [ebp-24h]
  int v27; // [esp+3Ch] [ebp-20h]
  int v28; // [esp+40h] [ebp-1Ch]
  int i; // [esp+44h] [ebp-18h]
  int mm; // [esp+48h] [ebp-14h]
  int v31; // [esp+4Ch] [ebp-10h]
  int v32; // [esp+54h] [ebp-8h]

  v3 = 0;
  v32 = 1 << a2;
  if ( a2 )
  {
    if ( a2 < 3u || a2 > 4u )
    {
      v17 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
      v14 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
      v27 = (*(__int16 *)(a1 + 84)
           + 255
           - (__CFSHL__((*(__int16 *)(a1 + 84) + 255) >> 31, 8)
            + ((*(__int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
      for ( i = -v27; i <= v27; ++i )
      {
        for ( j = -v27; j <= v27; ++j )
        {
          for ( k = dword_EA3E4[word_15B4E0[256 * (unsigned __int8)(i + v14) + (unsigned __int8)(j + v17)]];
                k != dword_EA3E4[0];
                k = dword_EA3E4[*(unsigned __int16 *)(k + 22)] )
          {
            if ( *(_WORD *)(a1 + 26) != *(_WORD *)(k + 26)
              && *(_BYTE *)(k + 63)
              && (*(_BYTE *)(k + 12) & 8) != 0
              && ((unsigned __int8)v32 & *(_BYTE *)(k + 56)) != 0
              && (*(char *)(a1 + 65) == -1
               || *(_BYTE *)(a1 + 65) == *(_BYTE *)(k + 63) && *(char *)(a1 + 66) == -1
               || *(_BYTE *)(a1 + 65) == *(_BYTE *)(k + 63) && *(_BYTE *)(a1 + 66) == *(_BYTE *)(k + 64))
              && sub_106C0(a1, k) )
            {
              v13 = k + 6 * a2;
              if ( *(_WORD *)(v13 + 98) )
                *(_DWORD *)(v13 + 94) += a3;
              else
                *(_DWORD *)(v13 + 94) = a3;
              ++v3;
              *(_WORD *)(k + 6 * a2 + 98) = *(_WORD *)(a1 + 26);
            }
          }
        }
      }
      return v3;
    }
    v18 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
    v15 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
    v28 = (*(__int16 *)(a1 + 84)
         + 255
         - (__CFSHL__((*(__int16 *)(a1 + 84) + 255) >> 31, 8)
          + ((*(__int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
    for ( m = -v28; m <= v28; ++m )
    {
      for ( n = -v28; n <= v28; ++n )
      {
        for ( ii = dword_EA3E4[word_15B4E0[256 * (unsigned __int8)(m + v15) + (unsigned __int8)(n + v18)]];
              ii != dword_EA3E4[0];
              ii = dword_EA3E4[*(unsigned __int16 *)(ii + 22)] )
        {
          if ( *(_WORD *)(a1 + 26) != *(_WORD *)(ii + 26) && *(_BYTE *)(ii + 63) == 3 && sub_106C0(a1, ii) )
          {
            v11 = ii + 6 * a2;
            if ( !*(_WORD *)(v11 + 98) )
            {
              *(_DWORD *)(v11 + 94) = a3;
              ++v3;
              *(_WORD *)(v11 + 98) = *(_WORD *)(a1 + 26);
            }
          }
        }
      }
    }
    return v3;
  }
  else
  {
    for ( jj = *(_DWORD *)(dword_D41A4 + 38519); jj > dword_EA3E4[0]; jj = *(_DWORD *)jj )
    {
      if ( *(_BYTE *)(jj + 64) == 2 && *(_WORD *)(jj + 26) != *(_WORD *)(a1 + 26) && sub_106C0(a1, jj) )
      {
        if ( *(_WORD *)(jj + 98) )
          *(_DWORD *)(jj + 94) += a3;
        else
          *(_DWORD *)(jj + 94) = a3;
        ++v3;
        *(_WORD *)(jj + 98) = *(_WORD *)(a1 + 26);
      }
    }
    for ( kk = *(_DWORD *)(dword_D41A4 + 38527); kk > dword_EA3E4[0]; kk = *(_DWORD *)kk )
    {
      if ( sub_10750(a1, kk) )
      {
        v6 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(kk + 70) + 4);
        v21 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(kk + 70) + 5);
        if ( word_180660 == 1 )
        {
          v6 >>= 1;
          v21 >>= 1;
        }
        v22 = (*(__int16 *)(a1 + 76) >> 8) - (v6 >> 1);
        v20 = (*(__int16 *)(a1 + 78) >> 8) - (v21 >> 1);
        if ( (v20 + v22) % 2 )
          ++v22;
        if ( *(_BYTE *)(*(_DWORD *)(dword_EA3BC + 6 * *(char *)(kk + 70))
                      + 2 * ((*(__int16 *)(a1 + 76) >> 8) - v22 + ((*(__int16 *)(a1 + 78) >> 8) - v20) * v6)) != 0xFF )
        {
          if ( *(_WORD *)(kk + 98) )
            *(_DWORD *)(kk + 94) += a3;
          else
            *(_DWORD *)(kk + 94) = a3;
          ++v3;
          *(_WORD *)(kk + 98) = *(_WORD *)(a1 + 26);
        }
      }
    }
    v19 = (*(unsigned __int16 *)(a1 + 76)
         + 128
         - (__CFSHL__((*(unsigned __int16 *)(a1 + 76) + 128) >> 31, 8)
          + ((*(unsigned __int16 *)(a1 + 76) + 128) >> 31 << 8))) >> 8;
    v16 = (*(unsigned __int16 *)(a1 + 78)
         + 128
         - (__CFSHL__((*(unsigned __int16 *)(a1 + 78) + 128) >> 31, 8)
          + ((*(unsigned __int16 *)(a1 + 78) + 128) >> 31 << 8))) >> 8;
    v24 = (*(__int16 *)(a1 + 84)
         + 255
         - (__CFSHL__((*(__int16 *)(a1 + 84) + 255) >> 31, 8)
          + ((*(__int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
    v31 = -v24;
    if ( -v24 > v24 )
      return v3;
    do
    {
      for ( mm = -v24; mm <= v24; ++mm )
      {
        for ( nn = word_15B4E0[256 * (unsigned __int8)(v16 + v31) + (unsigned __int8)(mm + v19)];
              ;
              nn = *(unsigned __int16 *)(v8 + 22) )
        {
          v8 = dword_EA3E4[nn];
          if ( v8 == dword_EA3E4[0] )
            break;
          if ( *(_WORD *)(a1 + 26) != *(_WORD *)(v8 + 26)
            && (*(_BYTE *)(v8 + 63) != 3 || *(_BYTE *)(v8 + 64) != 2)
            && ((unsigned __int8)v32 & *(_BYTE *)(v8 + 56)) != 0
            && (*(_BYTE *)(v8 + 12) & 8) != 0
            && (*(_BYTE *)(v8 + 63) != 10 || *(_BYTE *)(v8 + 64) != 45)
            && sub_106C0(a1, v8)
            && (*(char *)(a1 + 65) == -1
             || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v8 + 63) && *(char *)(a1 + 66) == -1
             || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v8 + 63) && *(_BYTE *)(a1 + 66) == *(_BYTE *)(v8 + 64)) )
          {
            if ( *(_WORD *)(v8 + 98) )
              *(_DWORD *)(v8 + 94) += a3;
            else
              *(_DWORD *)(v8 + 94) = a3;
            ++v3;
            *(_WORD *)(v8 + 98) = *(_WORD *)(a1 + 26);
          }
        }
      }
      ++v31;
    }
    while ( v31 <= v24 );
    return v3;
  }
}
// D41A4: using guessed type int dword_D41A4;
// EA3BC: using guessed type int dword_EA3BC;
// EA3E4: using guessed type int dword_EA3E4[];
// 15B4E0: using guessed type __int16 word_15B4E0[9616];
// 180660: using guessed type __int16 word_180660;

//----- (000112D0) --------------------------------------------------------
int __cdecl sub_112D0(int a1, unsigned __int16 a2)
{
  int v2; // edi
  int result; // eax
  int v4; // ebx
  int v5; // [esp+0h] [ebp-10h]
  int v6; // [esp+4h] [ebp-Ch]
  int v7; // [esp+8h] [ebp-8h]
  int i; // [esp+Ch] [ebp-4h]

  v5 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
  v6 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
  v2 = (*(__int16 *)(a1 + 84)
      + 255
      - (__CFSHL__((*(__int16 *)(a1 + 84) + 255) >> 31, 8)
       + ((*(__int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
  result = -v2;
  v7 = -v2;
  if ( ((v2 & 0x40000000) != 0) == __OFSUB__(v2, -v2) )
  {
    do
    {
      result = -v2;
      for ( i = -v2; v2 >= i; ++i )
      {
        for ( result = word_15B4E0[256 * (unsigned __int8)(v6 + v7) + (unsigned __int8)(i + v5)];
              ;
              result = *(unsigned __int16 *)(v4 + 22) )
        {
          v4 = dword_EA3E4[result];
          if ( v4 == dword_EA3E4[0] )
            break;
          if ( *(_WORD *)(a1 + 26) != *(_WORD *)(v4 + 26)
            && *(_BYTE *)(v4 + 63)
            && (*(_BYTE *)(v4 + 12) & 8) != 0
            && (*(_BYTE *)(v4 + 56) & 2) != 0
            && (*(char *)(a1 + 65) == -1
             || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v4 + 63) && *(char *)(a1 + 66) == -1
             || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v4 + 63) && *(_BYTE *)(a1 + 66) == *(_BYTE *)(v4 + 64))
            && sub_106C0(a1, v4) )
          {
            *(_WORD *)(v4 + 104) = *(_WORD *)(a1 + 26);
            *(_DWORD *)(v4 + 100) = a2;
          }
        }
      }
      ++v7;
    }
    while ( v2 >= v7 );
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00011400) --------------------------------------------------------
char __cdecl sub_11400(int a1, char a2, unsigned __int16 a3)
{
  int v3; // eax
  unsigned int i; // ebx
  int v5; // edi
  int k; // ebx
  int v7; // ebx
  int v9; // [esp+0h] [ebp-18h]
  int v10; // [esp+4h] [ebp-14h]
  int v11; // [esp+8h] [ebp-10h]
  int j; // [esp+Ch] [ebp-Ch]

  v3 = 1 << a2;
  if ( !a2 )
  {
    for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(_BYTE *)(i + 64) == 2 && *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) && sub_106C0(a1, i) )
      {
        if ( *(_WORD *)(i + 98) )
          *(_DWORD *)(i + 94) += a3;
        else
          *(_DWORD *)(i + 94) = a3;
        *(_WORD *)(i + 98) = *(_WORD *)(a1 + 26);
      }
    }
    v9 = (*(unsigned __int16 *)(a1 + 76)
        + 128
        - (__CFSHL__((*(unsigned __int16 *)(a1 + 76) + 128) >> 31, 8)
         + ((*(unsigned __int16 *)(a1 + 76) + 128) >> 31 << 8))) >> 8;
    v10 = (*(unsigned __int16 *)(a1 + 78)
         + 128
         - (__CFSHL__((*(unsigned __int16 *)(a1 + 78) + 128) >> 31, 8)
          + ((*(unsigned __int16 *)(a1 + 78) + 128) >> 31 << 8))) >> 8;
    v5 = (*(__int16 *)(a1 + 84)
        + 255
        - (__CFSHL__((*(__int16 *)(a1 + 84) + 255) >> 31, 8)
         + ((*(__int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
    v3 = -v5;
    v11 = -v5;
    if ( ((v5 & 0x40000000) != 0) == __OFSUB__(v5, -v5) )
    {
      do
      {
        v3 = -v5;
        for ( j = -v5; v5 >= j; ++j )
        {
          v3 = ((unsigned __int8)(v10 + v11) << 8) + (unsigned __int8)(j + v9);
          for ( k = word_15B4E0[v3]; ; k = *(unsigned __int16 *)(v7 + 22) )
          {
            v7 = dword_EA3E4[k];
            if ( v7 == dword_EA3E4[0] )
              break;
            LOWORD(v3) = *(_WORD *)(a1 + 26);
            if ( (_WORD)v3 != *(_WORD *)(v7 + 26) )
            {
              v3 = sub_106C0(a1, v7);
              if ( v3 )
              {
                LOBYTE(v3) = 1 << a2;
                if ( ((unsigned __int8)v3 & *(_BYTE *)(v7 + 56)) != 0
                  && (*(_BYTE *)(v7 + 12) & 8) != 0
                  && (*(_BYTE *)(v7 + 63) != 3 || *(_BYTE *)(v7 + 64) != 2) )
                {
                  if ( *(char *)(a1 + 65) == -1
                    || *(_BYTE *)(a1 + 65) == *(_BYTE *)(v7 + 63) && *(char *)(a1 + 66) == -1
                    || (LOBYTE(v3) = *(_BYTE *)(a1 + 65), (_BYTE)v3 == *(_BYTE *)(v7 + 63))
                    && (LOBYTE(v3) = *(_BYTE *)(a1 + 66), (_BYTE)v3 == *(_BYTE *)(v7 + 64)) )
                  {
                    if ( *(_BYTE *)(v7 + 63) != 2 || *(_BYTE *)(v7 + 64) )
                    {
                      if ( *(_WORD *)(v7 + 98) )
                        *(_DWORD *)(v7 + 94) += a3;
                      else
                        *(_DWORD *)(v7 + 94) = a3;
                    }
                    else if ( *(_WORD *)(v7 + 98) )
                    {
                      *(_DWORD *)(v7 + 94) += a3 / 10;
                    }
                    else
                    {
                      *(_DWORD *)(v7 + 94) = a3 / 10;
                    }
                    LOBYTE(v3) = 0;
                    *(_WORD *)(v7 + 98) = *(_WORD *)(a1 + 26);
                  }
                }
              }
            }
          }
        }
        ++v11;
      }
      while ( v5 >= v11 );
    }
  }
  return v3;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (000116A0) --------------------------------------------------------
int __cdecl sub_116A0(int a1, char a2, unsigned __int16 a3)
{
  int v3; // edi
  unsigned int i; // ebx
  int m; // ebx
  int v7; // [esp+0h] [ebp-1Ch]
  int v8; // [esp+4h] [ebp-18h]
  int k; // [esp+8h] [ebp-14h]
  int v10; // [esp+Ch] [ebp-10h]
  int j; // [esp+10h] [ebp-Ch]

  v3 = 0;
  if ( !a2 )
  {
    for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(_BYTE *)(i + 64) == 2 && sub_106C0(a1, i) )
      {
        *(_WORD *)(i + 48) = 30;
        if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) )
        {
          if ( *(_WORD *)(i + 98) )
            *(_DWORD *)(i + 94) += a3;
          else
            *(_DWORD *)(i + 94) = a3;
          ++v3;
          *(_WORD *)(i + 98) = *(_WORD *)(a1 + 26);
        }
      }
    }
    v7 = (*(unsigned __int16 *)(a1 + 76)
        + 128
        - (__CFSHL__((*(unsigned __int16 *)(a1 + 76) + 128) >> 31, 8)
         + ((*(unsigned __int16 *)(a1 + 76) + 128) >> 31 << 8))) >> 8;
    v8 = (*(unsigned __int16 *)(a1 + 78)
        + 128
        - (__CFSHL__((*(unsigned __int16 *)(a1 + 78) + 128) >> 31, 8)
         + ((*(unsigned __int16 *)(a1 + 78) + 128) >> 31 << 8))) >> 8;
    v10 = (*(__int16 *)(a1 + 84)
         + 255
         - (__CFSHL__((*(__int16 *)(a1 + 84) + 255) >> 31, 8)
          + ((*(__int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
    for ( j = -v10; j <= v10; ++j )
    {
      for ( k = -v10; k <= v10; ++k )
      {
        for ( m = dword_EA3E4[word_15B4E0[256 * (unsigned __int8)(v8 + j) + (unsigned __int8)(k + v7)]];
              m != dword_EA3E4[0];
              m = dword_EA3E4[*(unsigned __int16 *)(m + 22)] )
        {
          if ( *(_WORD *)(a1 + 26) != *(_WORD *)(m + 26)
            && sub_106C0(a1, m)
            && ((unsigned __int8)(1 << a2) & *(_BYTE *)(m + 56)) != 0
            && (*(_BYTE *)(m + 12) & 8) != 0
            && (*(_BYTE *)(m + 63) != 3 || *(_BYTE *)(m + 64) != 2)
            && (*(char *)(a1 + 65) == -1
             || *(_BYTE *)(a1 + 65) == *(_BYTE *)(m + 63) && *(char *)(a1 + 66) == -1
             || *(_BYTE *)(a1 + 65) == *(_BYTE *)(m + 63) && *(_BYTE *)(a1 + 66) == *(_BYTE *)(m + 64)) )
          {
            if ( *(_WORD *)(m + 98) )
              *(_DWORD *)(m + 94) += a3;
            else
              *(_DWORD *)(m + 94) = a3;
            ++v3;
            *(_WORD *)(m + 98) = *(_WORD *)(a1 + 26);
          }
        }
      }
    }
  }
  return v3;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00011900) --------------------------------------------------------
int __cdecl sub_11900(int a1, int a2, unsigned __int8 a3, unsigned __int16 a4)
{
  int v4; // eax
  int result; // eax

  v4 = a2 + 6 * a3;
  if ( *(_WORD *)(v4 + 98) )
    *(_DWORD *)(v4 + 94) = a4;
  else
    *(_DWORD *)(v4 + 94) += a4;
  result = 3 * a3;
  *(_WORD *)(a2 + 6 * a3 + 98) = *(_WORD *)(a1 + 26);
  return result;
}

//----- (00011960) --------------------------------------------------------
unsigned int __cdecl sub_11960(_WORD *a1)
{
  __int16 v1; // di
  unsigned int v2; // ebx
  __int16 v4; // [esp+0h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]

  sub_49EC0(a1, a1[8] + 1);
  v6 = (__int16)a1[42];
  v1 = a1[38];
  v5 = (__int16)a1[43];
  v2 = *(_DWORD *)(dword_D41A4 + 38527);
  v4 = a1[39];
  while ( v2 > dword_EA3E4[0] )
  {
    if ( abs16(*(_WORD *)(v2 + 76) - v1) <= *(__int16 *)(v2 + 84) + v6
      && abs16(*(_WORD *)(v2 + 78) - v4) <= *(__int16 *)(v2 + 86) + v5 )
    {
      *(_DWORD *)(v2 + 8) = -1;
      *(_BYTE *)(v2 + 61) = 0;
    }
    v2 = *(_DWORD *)v2;
  }
  return sub_49EC0(a1, a1[8]);
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00011A10) --------------------------------------------------------
char __cdecl sub_11A10(_WORD *a1)
{
  unsigned int i; // ebx
  unsigned __int16 v3; // bx
  __int16 j; // di
  __int16 v5; // di
  unsigned __int16 v6; // bx
  __int16 v7; // di
  unsigned __int16 v8; // bx
  int v9; // eax
  __int16 v10; // di
  unsigned __int16 v11; // bx
  __int16 v12; // [esp+0h] [ebp-24h]
  int v13; // [esp+4h] [ebp-20h]
  __int16 n; // [esp+8h] [ebp-1Ch]
  __int16 k; // [esp+Ch] [ebp-18h]
  __int16 m; // [esp+10h] [ebp-14h]
  int v17; // [esp+14h] [ebp-10h]
  __int16 v18; // [esp+14h] [ebp-10h]
  __int16 v19; // [esp+18h] [ebp-Ch]
  __int16 v20; // [esp+1Ch] [ebp-8h]
  __int16 v21; // [esp+20h] [ebp-4h]
  __int16 v22; // [esp+20h] [ebp-4h]

  v18 = (__int16)a1[42] >> 8;
  v21 = (__int16)a1[43] >> 8;
  sub_49EC0(a1, a1[8] + 1);
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(_BYTE *)(i + 64) == 2 && (_WORD *)i != a1 && sub_106C0(i, (int)a1) )
    {
LABEL_5:
      sub_49EC0(a1, a1[8]);
      return 0;
    }
  }
  v19 = (__int16)a1[42] >> 8;
  v12 = (__int16)a1[43] >> 8;
  LOBYTE(v20) = ((unsigned __int16)(a1[38] + 128) >> 8) - v19;
  HIBYTE(v20) = ((unsigned __int16)(a1[39] + 128) >> 8) - v12;
  LOWORD(v17) = v19 - v18;
  v3 = v20;
  v22 = v12 - v21;
  for ( j = v22; j; --j )
  {
    for ( k = 2 * v19; k; --k )
    {
      if ( !sub_11C80(v3) )
        goto LABEL_5;
      LOBYTE(v3) = v3 + 1;
    }
    v3 = __PAIR16__(HIBYTE(v3), v20) + 256;
  }
  LOBYTE(v6) = v20;
  v5 = v22;
  HIBYTE(v6) = 2 * v12 + HIBYTE(v20) - v22;
  while ( v5 )
  {
    for ( m = 2 * v19; m; --m )
    {
      if ( !sub_11C80(v6) )
        goto LABEL_5;
      LOBYTE(v6) = v6 + 1;
    }
    --v5;
    v6 = __PAIR16__(HIBYTE(v6), v20) + 256;
  }
  LOBYTE(v8) = v20;
  v7 = v22;
  HIBYTE(v8) = v22 + HIBYTE(v20);
  while ( v7 )
  {
    v9 = v17;
    while ( 1 )
    {
      v13 = v9;
      if ( !(_WORD)v9 )
        break;
      if ( !sub_11C80(v8) )
        goto LABEL_5;
      v9 = v13 - 1;
      LOBYTE(v8) = v8 + 1;
    }
    --v7;
    v8 = __PAIR16__(HIBYTE(v8), v20) + 256;
  }
  LOBYTE(v11) = v19 + v20 - v17;
  v10 = v22;
  HIBYTE(v11) = v22 + HIBYTE(v20);
  while ( v10 )
  {
    for ( n = v17; n; --n )
    {
      if ( !sub_11C80(v11) )
        goto LABEL_5;
      LOBYTE(v11) = v11 + 1;
    }
    --v10;
    v11 = __PAIR16__(HIBYTE(v11), v20) + 256;
  }
  sub_49EC0(a1, a1[8]);
  return 1;
}
// 11BAB: variable 'v17' is possibly undefined
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00011C80) --------------------------------------------------------
char __cdecl sub_11C80(unsigned __int16 a1)
{
  char result; // al
  char v2; // ah

  result = 1;
  v2 = byte_13B4E0[a1];
  if ( v2 < 0 || byte_D41B6 && (v2 & 8) != 0 )
    return 0;
  return result;
}
// D41B6: using guessed type char byte_D41B6;

//----- (00011CB0) --------------------------------------------------------
_BOOL1 __cdecl sub_11CB0(__int16 *a1)
{
  __int16 v1; // cx
  unsigned int v2; // ebx
  unsigned int i; // ebx
  __int16 v4; // di
  unsigned __int16 v5; // bx
  __int16 j; // si
  __int16 v8; // [esp+8h] [ebp-10h]
  __int16 v9; // [esp+Ch] [ebp-Ch]
  _BOOL1 v10; // [esp+14h] [ebp-4h]

  v1 = a1[1];
  v10 = 0;
  v2 = *(_DWORD *)(dword_D41A4 + 38519);
  v8 = *a1;
  while ( !v10 && v2 > dword_EA3E4[0] )
  {
    if ( *(_BYTE *)(v2 + 64) == 2
      && abs16(*(_WORD *)(v2 + 76) - v8) <= *(__int16 *)(v2 + 84) + 2560
      && abs16(*(_WORD *)(v2 + 78) - v1) <= *(__int16 *)(v2 + 86) + 2560 )
    {
      v10 = 1;
    }
    v2 = *(_DWORD *)v2;
  }
  if ( !v10 )
  {
    for ( i = *(_DWORD *)(dword_D41A4 + 38527); !v10 && i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( abs16(*(_WORD *)(i + 76) - v8) <= *(__int16 *)(i + 84) + 2560
        && abs16(*(_WORD *)(i + 78) - v1) <= *(__int16 *)(i + 86) + 2560 )
      {
        v10 = 1;
      }
    }
  }
  if ( !v10 )
  {
    LOBYTE(v9) = HIBYTE(*a1) - 8;
    HIBYTE(v9) = HIBYTE(a1[1]) - 8;
    v4 = 8;
    v5 = v9;
    while ( v4 && !v10 )
    {
      for ( j = 8; j && !v10; --j )
      {
        v10 = sub_11C80(v5) == 0;
        LOBYTE(v5) = v5 + 1;
      }
      --v4;
      v5 = __PAIR16__(HIBYTE(v5), v9) + 256;
    }
  }
  return !v10;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00011E20) --------------------------------------------------------
_BOOL1 __cdecl sub_11E20(int a1, __int16 *a2)
{
  int v2; // ebx
  int v3; // ebx

  v2 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 12);
  v3 = (__int16)sub_10C40(a2) + v2 + *(__int16 *)(a1 + 88);
  return v3 > (__int16)sub_10C60(a2) - 384;
}

//----- (00011E70) --------------------------------------------------------
_BOOL1 __cdecl sub_11E70(int a1, __int16 *a2)
{
  int v2; // ebx
  int v3; // ebx

  v2 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 12);
  v3 = *(__int16 *)(a1 + 88) + (__int16)sub_10C40(a2) + v2;
  return v3 > (__int16)sub_10C60(a2);
}

//----- (00011EE0) --------------------------------------------------------
int __cdecl sub_11EE0(int a1)
{
  __int16 v1; // ax
  int v2; // esi
  int result; // eax
  int v4; // edx
  int v5; // edi
  int v6; // edx
  int v7; // edx
  int v8; // edx
  int v9; // edx
  int v10; // edx
  int v11; // ecx
  __int16 v12; // di
  int v13; // edx
  int v14; // ecx
  char v15; // dl
  char *v16; // [esp-Ch] [ebp-18h]
  char v17; // [esp+8h] [ebp-4h]

  v16 = (char *)&loc_365F2 + dword_D41A0 + 2;
  *((_BYTE *)&loc_36DFC + dword_D41A0 + 4) = 0;
  memset(v16, 0, 88);
  v1 = 10;
  v2 = dword_D41A0;
  while ( v1 > 0 && (*(_BYTE *)(a1 + 8 * v1 + 26028) & 0xF) == 0 )
    --v1;
  *((_BYTE *)&loc_36DFC + dword_D41A0 + 4) = v1;
  for ( result = 1; (__int16)result <= *((unsigned __int8 *)&loc_36DFC + v2 + 4); ++result )
  {
    v4 = 8 * (__int16)result;
    v5 = a1 + v4;
    v17 = *(_BYTE *)(a1 + v4 + 26028) & 0xF;
    v6 = v2 + v4;
    *((_BYTE *)&loc_365F2 + v6 + 2) = v17;
    if ( v17 )
    {
      if ( *(char *)(v5 + 26028) < 0 )
        *(_BYTE *)(v6 + 222709) |= 1u;
      v7 = 8 * (__int16)result;
      if ( (*(_BYTE *)(v7 + a1 + 26028) & 0x40) != 0 )
        *(_BYTE *)(v2 + v7 + 222709) |= 2u;
      v8 = 8 * (__int16)result;
      if ( (*(_BYTE *)(v8 + a1 + 26028) & 0x10) != 0 )
        *(_BYTE *)(v2 + v8 + 222709) |= 0x20u;
      v9 = 8 * (__int16)result;
      if ( (*(_BYTE *)(v9 + a1 + 26028) & 0x20) != 0 )
        *(_BYTE *)(v2 + v9 + 222709) |= 0x40u;
      switch ( *((_BYTE *)&loc_365F2 + 8 * (__int16)result + v2 + 2) )
      {
        case 1:
        case 2:
          v10 = 8 * (__int16)result;
          v11 = a1 + v10;
          v12 = *(_WORD *)(a1 + v10 + 26032);
          v13 = v2 + v10;
          *(_WORD *)((char *)sub_365F8 + v13) = v12 << 8;
          *(_WORD *)((char *)sub_365F8 + v13 + 2) = *(_WORD *)(v11 + 26034) << 8;
          break;
        case 3:
        case 4:
        case 5:
        case 8:
        case 9:
          v14 = v2 + 8 * (__int16)result;
          v15 = *(_BYTE *)(v14 + 222709);
          *(_DWORD *)((char *)sub_365F8 + v14) = 0;
          if ( (v15 & 2) != 0 )
            *(_WORD *)((char *)sub_365F8 + v14) = *(_WORD *)((char *)&loc_3030E
                                                           + 20 * *(unsigned __int16 *)((char *)&loc_36479 + v14 + 5)
                                                           + v2
                                                           + 5);
          break;
        case 6:
        case 7:
          *(_DWORD *)((char *)sub_365F8 + 8 * (__int16)result + v2) = *(_DWORD *)(a1 + 8 * (__int16)result + 26032);
          break;
        default:
          break;
      }
      *(_BYTE *)(v2 + 8 * (__int16)result + 222710) = *(_BYTE *)(8 * (__int16)result + a1 + 26029);
    }
  }
  dword_D41A0 = v2;
  return result;
}
// 365F8: using guessed type int sub_365F8();
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;

//----- (00012100) --------------------------------------------------------
__int16 __cdecl sub_12100(int a1, int a2, char a3)
{
  __int16 v3; // bx
  unsigned __int8 v4; // cl
  char *v5; // esi
  __int16 v6; // bx
  char *v7; // edx
  __int16 v8; // bx
  char *i; // ecx
  __int16 result; // ax

  v3 = 1;
  v4 = 0;
  v5 = (char *)sub_365F8 + dword_D41A0 + 4;
  while ( v3 <= *((unsigned __int8 *)&loc_36DFC + dword_D41A0 + 4) && !v4 )
  {
    if ( *v5
      && (v5[1] & 1) == 0
      && (a1 - ((int)&loc_3030E + dword_D41A0 + 3)) / 20 == *(unsigned __int16 *)((char *)&loc_36479
                                                                                + 8 * v3
                                                                                + dword_D41A0
                                                                                + 3) )
    {
      v4 = v3;
    }
    ++v3;
    v5 += 8;
  }
  if ( !v4 )
  {
    v6 = 1;
    v7 = (char *)sub_365F8 + dword_D41A0 + 4;
    while ( v6 <= *((unsigned __int8 *)&loc_36DFC + dword_D41A0 + 4) && !v4 )
    {
      if ( *v7
        && (v7[1] & 1) != 0
        && *(_WORD *)((char *)&loc_3030E
                    + 20 * *(unsigned __int16 *)((char *)&loc_36479 + 8 * v6 + dword_D41A0 + 3)
                    + dword_D41A0
                    + 5) == *(_WORD *)(a1 + 2) )
      {
        v4 = v6;
      }
      ++v6;
      v7 += 8;
    }
  }
  if ( v4 )
  {
    if ( a3 )
      *(_WORD *)(a2 + 74) = v4;
    else
      sub_12330(a2, v4);
  }
  v8 = 1;
  for ( i = (char *)sub_365F8 + dword_D41A0 + 4; ; i += 8 )
  {
    result = *((unsigned __int8 *)&loc_36DFC + dword_D41A0 + 4);
    if ( v8 > (unsigned __int8)result )
      break;
    if ( *i )
    {
      switch ( *i )
      {
        case 3:
        case 4:
        case 5:
        case 8:
        case 9:
          if ( (i[1] & 2) == 0
            && *(unsigned __int16 *)((char *)&loc_36479 + 8 * v8 + dword_D41A0 + 5) == (a1
                                                                                      - ((int)&loc_3030E
                                                                                       + dword_D41A0
                                                                                       + 3))
                                                                                     / 20 )
          {
            *((_DWORD *)i + 1) = a2;
            i[1] &= ~4u;
          }
          break;
        default:
          break;
      }
    }
    ++v8;
  }
  return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;

//----- (000122A0) --------------------------------------------------------
int __cdecl sub_122A0(int a1)
{
  __int16 v1; // bx
  int result; // eax

  v1 = *(_WORD *)(a1 + 74);
  if ( v1 )
    return sub_12330(a1, v1);
  return result;
}

//----- (000122C0) --------------------------------------------------------
char *__cdecl sub_122C0(__int16 a1)
{
  __int16 v1; // dx
  char *result; // eax

  v1 = 1;
  result = (char *)sub_365F8 + dword_D41A0 + 4;
  while ( v1 <= *((unsigned __int8 *)&loc_36DFC + dword_D41A0 + 4) )
  {
    if ( *result == 7 && a1 == *((_WORD *)result + 2) )
      result[1] |= 0x18u;
    ++v1;
    result += 8;
  }
  return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;

//----- (00012330) --------------------------------------------------------
int __cdecl sub_12330(int a1, __int16 a2)
{
  int result; // eax
  char v3; // dl
  int v4; // ebx
  char v5; // cl
  unsigned __int8 v6; // dh
  char v7; // cl
  _BOOL1 v8; // zf
  int v9; // edx
  char v10; // bl

  result = a1;
  v3 = 1;
  if ( !a2 )
  {
LABEL_12:
    v3 = 0;
    goto LABEL_13;
  }
  v4 = 8 * a2 + dword_D41A0;
  v5 = *(_BYTE *)(v4 + 222711);
  *(_BYTE *)(v4 + 222711) = v5 + 1;
  v6 = *(_BYTE *)(v4 + 222709) & 0x60;
  v7 = v5 & 3;
  if ( v6 < 0x40u )
  {
    if ( v6 != 32 || v7 != 3 )
      goto LABEL_13;
    goto LABEL_12;
  }
  if ( v6 <= 0x40u )
  {
    v8 = (v7 & 1) == 0;
    goto LABEL_11;
  }
  if ( v6 == 96 )
  {
    v8 = (v7 & 3) == 0;
LABEL_11:
    if ( v8 )
      goto LABEL_13;
    goto LABEL_12;
  }
LABEL_13:
  if ( !v3 )
    return sub_12470(a1, 8 * *(_BYTE *)(a1 + 64) + 1);
  *(_BYTE *)(a1 + 69) = 8 * *(_BYTE *)(a1 + 64) + 7;
  *(_BYTE *)(a1 + 72) = a2;
  v9 = 8 * a2 + dword_D41A0;
  *(_WORD *)(a1 + 74) = 0;
  v10 = *((_BYTE *)&loc_365F2 + v9 + 2);
  *(_BYTE *)(a1 + 73) = v10;
  if ( v10 == 6 )
    *(_WORD *)(a1 + 74) = *(_WORD *)((char *)sub_365F8 + v9);
  return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;

//----- (00012410) --------------------------------------------------------
char __cdecl sub_12410(int a1, char a2)
{
  int v2; // edx
  char v3; // bh

  v2 = 8 * *(unsigned __int8 *)(a1 + 72);
  v3 = 0;
  if ( *(_BYTE *)(v2 + dword_D41A0 + 222710) )
    sub_12330(a1, *(unsigned __int8 *)(v2 + dword_D41A0 + 222710));
  else
    v3 = 1;
  if ( v3 )
    sub_12470(a1, a2);
  return 0;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00012470) --------------------------------------------------------
int __cdecl sub_12470(int a1, char a2)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 73) = 0;
  *(_BYTE *)(a1 + 72) = 0;
  *(_WORD *)(a1 + 74) = 0;
  *(_BYTE *)(a1 + 69) = a2;
  return result;
}

//----- (00012500) --------------------------------------------------------
char __cdecl sub_12500(int a1)
{
  int v1; // eax
  __int16 v2; // di
  __int16 v3; // si
  char *v4; // ecx
  __int64 v5; // rax
  __int64 v6; // rax
  __int16 v7; // si
  char v8; // dl
  __int16 v9; // dx
  int v10; // esi
  __int64 v11; // rax
  __int64 v12; // rax
  __int16 v13; // cx
  __int16 v15; // [esp+0h] [ebp-4h]

  LOBYTE(v1) = *(_BYTE *)(a1 + 69) & 7;
  v2 = 0;
  v3 = (unsigned __int8)v1;
  v15 = 1;
  if ( (unsigned __int8)v1 < 4u || (unsigned __int8)v1 > 5u )
  {
    LOBYTE(v1) = *(_BYTE *)(a1 + 73) - 1;
    switch ( *(_BYTE *)(a1 + 73) )
    {
      case 0xA:
        v15 = 0;
        if ( v3 != 2 && v3 != 6 )
          goto LABEL_6;
        break;
      case 0xD:
      case 0xE:
      case 0x10:
      case 0x11:
        v15 = 0;
        if ( v3 != 2 && v3 != 6 )
        {
          LOBYTE(v1) = 8 * *(_BYTE *)(a1 + 64) + 7;
          *(_BYTE *)(a1 + 69) = v1;
        }
        break;
      case 0xF:
        LOBYTE(v1) = 0;
        v15 = 0;
        if ( v3 )
LABEL_6:
          LOBYTE(v1) = sub_12330(a1, *(unsigned __int8 *)(a1 + 72));
        break;
      default:
        break;
    }
    if ( v15 )
    {
      v4 = (char *)&loc_365F2 + 8 * *(unsigned __int8 *)(a1 + 72) + dword_D41A0 + 2;
      LOBYTE(v1) = *v4 - 1;
      switch ( *v4 )
      {
        case 1:
          v5 = *((__int16 *)v4 + 2) - *(__int16 *)(a1 + 76);
          v1 = (HIDWORD(v5) ^ v5) - HIDWORD(v5);
          if ( v1 <= 2048 )
          {
            v6 = *((__int16 *)v4 + 3) - *(__int16 *)(a1 + 78);
            v1 = (HIDWORD(v6) ^ v6) - HIDWORD(v6);
            if ( v1 <= 2048 )
              goto LABEL_44;
          }
          goto LABEL_45;
        case 3:
          LOBYTE(v1) = v4[1];
          if ( (v1 & 4) != 0 )
          {
            *(_WORD *)(a1 + 74) = 0;
            if ( v3 != 2 && v3 != 6 )
              goto LABEL_44;
          }
          else if ( (v1 & 2) != 0 )
          {
            v13 = *(_WORD *)(a1 + 74);
            if ( v13 )
            {
              v1 = dword_EA3E4[v13];
              if ( *(int *)(v1 + 8) < 0 || (*(_BYTE *)(v1 + 13) & 4) != 0 )
                *(_WORD *)(a1 + 74) = 0;
            }
          }
          goto LABEL_45;
        case 4:
        case 5:
        case 8:
        case 9:
          v8 = v4[1];
          if ( (v8 & 4) != 0 )
          {
            v2 = 1;
          }
          else
          {
            if ( (v8 & 2) == 0 )
            {
              LOBYTE(v1) = *v4;
              if ( *v4 == 9 )
              {
                v10 = *((_DWORD *)v4 + 1);
                if ( v10 )
                {
                  v11 = *(__int16 *)(v10 + 76) - *(__int16 *)(a1 + 76);
                  v1 = (HIDWORD(v11) ^ v11) - HIDWORD(v11);
                  if ( v1 <= 3072 )
                  {
                    v12 = *(__int16 *)(*((_DWORD *)v4 + 1) + 78) - *(__int16 *)(a1 + 78);
                    v1 = (HIDWORD(v12) ^ v12) - HIDWORD(v12);
                    if ( v1 <= 3072 )
                      goto LABEL_44;
                  }
                }
              }
              goto LABEL_45;
            }
            LOBYTE(v1) = *v4;
            if ( (unsigned __int8)*v4 < 4u
              || (unsigned __int8)v1 > 5u
              || (v9 = *(_WORD *)(a1 + 74)) == 0
              || (v1 = dword_EA3E4[v9], *(int *)(v1 + 8) >= 0) && (*(_BYTE *)(v1 + 13) & 4) == 0 )
            {
LABEL_45:
              if ( v2 )
                LOBYTE(v1) = sub_12410(a1, 8 * *(_BYTE *)(a1 + 64) + 1);
              return v1;
            }
          }
          *(_WORD *)(a1 + 74) = 0;
          goto LABEL_45;
        case 6:
          v7 = *(_WORD *)(a1 + 74) - 1;
          *(_WORD *)(a1 + 74) = v7;
          if ( !v7 )
            goto LABEL_44;
          goto LABEL_45;
        case 7:
          if ( (v4[1] & 0x18) != 0 )
          {
            LOBYTE(v1) = (unsigned __int8)sub_12870();
LABEL_44:
            v2 = 1;
          }
          goto LABEL_45;
        default:
          goto LABEL_45;
      }
    }
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00012780) --------------------------------------------------------
char *sub_12780()
{
  __int16 v0; // bx
  char *result; // eax
  __int16 v2; // dx
  char v3; // cl
  int v4; // ecx
  char v5; // dh

  v0 = 1;
  result = (char *)sub_365F8 + dword_D41A0 + 4;
  while ( v0 <= *((unsigned __int8 *)&loc_36DFC + dword_D41A0 + 4) )
  {
    if ( !*result )
      goto LABEL_18;
    v2 = 0;
    switch ( *result )
    {
      case 3:
      case 4:
      case 5:
      case 8:
      case 9:
        v3 = result[1];
        if ( (v3 & 4) != 0 )
          goto LABEL_11;
        if ( (v3 & 2) != 0 )
        {
          if ( *(_DWORD *)(dword_D41A4 + 4 * *((unsigned __int16 *)result + 2) + 38403) )
            goto LABEL_12;
LABEL_11:
          v2 = 1;
          goto LABEL_12;
        }
        v4 = *((_DWORD *)result + 1);
        if ( v4 && (*(int *)(v4 + 8) < 0 || (*(_BYTE *)(v4 + 13) & 4) != 0) )
          goto LABEL_11;
LABEL_12:
        if ( v2 )
          result[1] |= 4u;
LABEL_18:
        ++v0;
        result += 8;
        break;
      case 7:
        v5 = result[1];
        if ( (v5 & 0x18) != 0 )
        {
          if ( (v5 & 0x10) != 0 )
            result[1] = v5 & 0xEF;
          else
            result[1] = v5 & 0xF7;
        }
        goto LABEL_18;
      default:
        goto LABEL_18;
    }
  }
  return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00012870) --------------------------------------------------------
char *sub_12870()
{
  __int16 v0; // dx
  char *result; // eax
  char v2; // bh

  v0 = 1;
  result = (char *)sub_365F8 + dword_D41A0 + 4;
  while ( v0 <= *((unsigned __int8 *)&loc_36DFC + dword_D41A0 + 4) )
  {
    if ( *result )
    {
      switch ( *result )
      {
        case 3:
        case 4:
        case 5:
        case 8:
        case 9:
          v2 = result[1];
          if ( (v2 & 4) != 0 && (v2 & 2) != 0 )
            result[1] = v2 & 0xFB;
          break;
        default:
          break;
      }
    }
    ++v0;
    result += 8;
  }
  return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;

//----- (00012910) --------------------------------------------------------
int __cdecl sub_12910(unsigned int a1)
{
  int result; // eax

  sub_12A70(a1);
  switch ( *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) )
  {
    case 0:
      sub_12E70(a1);
      result = sub_12E70(a1);
      break;
    case 1:
      sub_12FF0(a1);
      result = sub_12E70(a1);
      break;
    case 2:
      _nmemneed(a1);
      result = sub_12E70(a1);
      break;
    case 3:
      sub_13100(a1);
      result = sub_12E70(a1);
      break;
    case 4:
      sub_131F0((_WORD *)a1);
      result = sub_12E70(a1);
      break;
    case 5:
      _nmemneed_0(a1);
      result = sub_12E70(a1);
      break;
    case 6:
      sub_135C0(a1);
      result = sub_12E70(a1);
      break;
    case 7:
      sub_13710(a1);
      result = sub_12E70(a1);
      break;
    case 8:
      sub_13830(a1);
      result = sub_12E70(a1);
      break;
    case 9:
      sub_13870(a1);
      result = sub_12E70(a1);
      break;
    case 0xB:
      sub_133B0(a1);
      result = sub_12E70(a1);
      break;
    case 0xC:
      sub_13270(a1);
      result = sub_12E70(a1);
      break;
    case 0xD:
      sub_13850(a1);
      result = sub_12E70(a1);
      break;
    case 0xE:
      sub_161A0(a1);
      goto LABEL_16;
    default:
LABEL_16:
      result = sub_12E70(a1);
      break;
  }
  return result;
}
// 130F0: using guessed type int __cdecl _nmemneed(_DWORD);
// 135B0: using guessed type int __cdecl _nmemneed_0(_DWORD);

//----- (00012A70) --------------------------------------------------------
int __cdecl sub_12A70(unsigned int a1)
{
  int v1; // edx
  unsigned int v2; // edi
  __int16 v3; // cx
  __int16 i; // dx
  int v5; // esi
  __int16 v6; // ax
  __int16 j; // dx
  int v8; // eax
  unsigned __int16 v9; // cx
  int v10; // eax
  int v11; // eax
  int v12; // esi
  int v13; // eax
  unsigned __int16 v14; // dx
  int v16; // edx
  unsigned __int8 v17; // ah
  int v18; // ecx
  int v19; // edx
  int v20; // edx
  int v21; // ecx
  int v22; // ecx
  int v23; // eax
  int v24; // esi
  __int16 k; // si
  int v26; // edx
  int v27; // eax
  int v28; // eax
  int v30; // [esp+0h] [ebp-4h]

  sub_15EE0();
  v1 = *(_DWORD *)(a1 + 164);
  v2 = 0;
  v3 = *(_WORD *)(v1 + 418);
  if ( v3 < 0 )
    *(_WORD *)(v1 + 418) = v3 + 1;
  for ( i = 0; i < 26; ++i )
  {
    v5 = 2 * i + *(_DWORD *)(a1 + 164);
    v6 = *(_WORD *)(v5 + 871);
    if ( v6 > 0 )
      *(_WORD *)(v5 + 871) = v6 - 1;
  }
  for ( j = 0; j < 8; ++j )
  {
    v8 = *(_DWORD *)(a1 + 164);
    v30 = 8 * j;
    v9 = *(_WORD *)(v30 + v8 + 516);
    if ( v9 < 0x601Fu )
    {
      *(_WORD *)(v30 + v8 + 516) = *(_WORD *)(v8 + 578) + 1 + v9;
      v10 = v30 + *(_DWORD *)(a1 + 164);
      if ( *(_WORD *)(v10 + 516) > 0x601Fu )
        *(_WORD *)(v10 + 516) = 24607;
    }
    v11 = *(_DWORD *)(a1 + 164);
    v12 = v11 + 8 * j;
    if ( *(_WORD *)(v12 + 516) > 0x601Fu )
    {
      if ( !*(_WORD *)(v12 + 518) )
        *(_WORD *)(v12 + 516) -= 256 - *(_WORD *)(v11 + 578);
      v13 = *(_DWORD *)(a1 + 164) + 8 * j;
      if ( *(_WORD *)(v13 + 516) < 0x601Fu )
        *(_WORD *)(v13 + 516) = 24607;
    }
  }
  _wcpp_1_unwind_leave__99(a1);
  v14 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 58);
  if ( v14 && sub_106C0(a1, dword_EA3E4[v14]) )
    v2 = 1;
  if ( (_WORD)v2 )
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 345) = 2;
  if ( *(_WORD *)(*(_DWORD *)(a1 + 164) + 345) )
  {
    memset(a1 + 94, 0, 36);
    --*(_WORD *)(*(_DWORD *)(a1 + 164) + 345);
  }
  else if ( sub_5EFA0(a1) == 2 )
  {
    *(_BYTE *)(a1 + 69) = 2;
    return 0;
  }
  sub_146F0(a1);
  v16 = *(_DWORD *)(a1 + 164);
  v17 = *(_BYTE *)(v16 + 340);
  if ( v17 < 0xC8u )
    *(_BYTE *)(v16 + 340) = v17 + 1;
  *(_DWORD *)(a1 + 144) += *(_DWORD *)(a1 + 136);
  v18 = *(__int16 *)(*(_DWORD *)(a1 + 164) + 355) + *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v18;
  if ( v18 < -1 )
    *(_DWORD *)(a1 + 8) = -1;
  v19 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(a1 + 8) > v19 )
    *(_DWORD *)(a1 + 8) = v19;
  v20 = *(_DWORD *)(a1 + 164);
  v21 = *(_DWORD *)(v20 + 365);
  if ( v21 )
    *(_DWORD *)(v20 + 365) = v21 - 1;
  if ( (_WORD)v2 || (*(_BYTE *)(a1 + 13) & 0x10) != 0 )
  {
    *(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 140) / 200;
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 355) = *(_DWORD *)(a1 + 4) / 200;
    if ( *(int *)(a1 + 136) < 1000 )
      *(_DWORD *)(a1 + 136) = 1000;
    *(_BYTE *)(a1 + 13) &= ~0x10u;
  }
  else
  {
    *(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 140) / 2000;
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 355) = *(_DWORD *)(a1 + 4) / 500;
    if ( *(int *)(a1 + 136) < 100 )
      *(_DWORD *)(a1 + 136) = 100;
  }
  if ( *(int *)(a1 + 144) < 0 )
    *(_DWORD *)(a1 + 144) = 0;
  v22 = *(_DWORD *)(a1 + 140);
  if ( *(_DWORD *)(a1 + 144) > v22 )
    *(_DWORD *)(a1 + 144) = v22;
  v23 = *(__int16 *)(*(_DWORD *)(a1 + 164) + 582);
  if ( !(*(unsigned __int8 *)(a1 + 62) % (64 - ((v23 - (__CFSHL__(v23 >> 31, 2) + 4 * (v23 >> 31))) >> 2))) )
  {
    v24 = sub_15CB0(v2, a1);
    if ( v24 )
    {
      sub_15D20(a1);
      sub_15D40(v2, a1, v24);
    }
    if ( *(_DWORD *)(a1 + 8) < *(_DWORD *)(a1 + 4) )
    {
      for ( k = *(char *)(*(_DWORD *)(a1 + 164) + 1058); k >= 0; --k )
      {
        if ( (unsigned __int16)sub_15F20(a1, k, 5) == 5 )
        {
          sub_14E10(a1, 5u);
          break;
        }
      }
    }
  }
  v26 = (__int16)sub_10C40((__int16 *)(a1 + 76));
  v27 = *(_DWORD *)(a1 + 160);
  if ( *(__int16 *)(a1 + 80) > v26 + *(__int16 *)(v27 + 10) )
    *(_WORD *)(a1 + 80) = *(_WORD *)(v27 + 10) + v26;
  v28 = *(_DWORD *)(a1 + 160);
  if ( *(__int16 *)(a1 + 80) < v26 + *(__int16 *)(v28 + 12) )
    *(_WORD *)(a1 + 80) = *(_WORD *)(v28 + 12) + v26;
  return 1;
}
// 5E000: using guessed type int __cdecl _wcpp_1_unwind_leave__99(_DWORD);
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00012E70) --------------------------------------------------------
int __cdecl sub_12E70(int a1)
{
  int v2; // eax

  if ( sub_13B00(a1) )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 3;
  }
  else
  {
    if ( sub_13DC0(a1) )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 11;
      return 1;
    }
    v2 = *(__int16 *)(*(_DWORD *)(a1 + 164) + 582);
    if ( !(*(unsigned __int8 *)(a1 + 62) % (64 - ((v2 - (__CFSHL__(v2 >> 31, 2) + 4 * (v2 >> 31))) >> 2))) )
    {
      if ( sub_13C50(a1) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 1;
        return 1;
      }
      if ( sub_13E40(a1) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 7;
        return 1;
      }
      if ( sub_14030(a1) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 8;
        return 1;
      }
      if ( sub_14250(a1) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 9;
        return 1;
      }
      if ( (unsigned __int16)sub_15FC0((_WORD *)a1) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 14;
        return 1;
      }
      if ( sub_13CE0(a1) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 6;
        return 1;
      }
      if ( sub_14530(a1) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 13;
        return 1;
      }
      sub_14630(a1);
    }
  }
  return 1;
}

//----- (00012FF0) --------------------------------------------------------
int __cdecl sub_12FF0(int a1)
{
  int v1; // esi
  __int16 i; // di
  int v3; // eax

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  if ( !sub_14C60(a1, v1) )
    goto LABEL_14;
  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
  if ( sub_14C90(a1, v1, 512, 2048) )
  {
    for ( i = *(char *)(*(_DWORD *)(a1 + 164) + 1055); i >= 0 && (unsigned __int16)sub_15F20(a1, i, 2) != 2; --i )
      ;
    if ( !sub_14E10(a1, 2u) )
    {
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
      v3 = *(__int16 *)(a1 + 80) - (*(__int16 *)(v1 + 80) + 512);
      if ( v3 )
      {
        if ( v3 <= 0 )
          LOWORD(v3) = -1;
        else
          LOWORD(v3) = 1;
      }
      *(_WORD *)(a1 + 80) += *(_WORD *)(*(_DWORD *)(a1 + 160) + 14) * v3;
      goto LABEL_13;
    }
LABEL_14:
    sub_16580(a1);
    return 0;
  }
LABEL_13:
  sub_16580(a1);
  return 1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013100) --------------------------------------------------------
int __cdecl sub_13100(int a1)
{
  __int16 i; // si
  __int16 v2; // ax
  int v3; // ebx

  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a1 + 154));
  if ( !sub_14C90(a1, 0, 2048, 4096) )
    goto LABEL_12;
  for ( i = *(char *)(*(_DWORD *)(a1 + 164) + 1055); i >= 0 && (unsigned __int16)sub_15F20(a1, i, 2) != 2; --i )
    ;
  if ( sub_14E10(a1, 2u) )
  {
LABEL_12:
    sub_16580(a1);
    return 0;
  }
  else
  {
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
    v2 = *(_WORD *)(a1 + 80) - (*(_WORD *)(a1 + 158) + 512);
    if ( *(__int16 *)(a1 + 80) != *(__int16 *)(a1 + 158) + 512 )
    {
      if ( *(__int16 *)(a1 + 80) - (*(__int16 *)(a1 + 158) + 512) <= 0 )
        v2 = -1;
      else
        v2 = 1;
    }
    v3 = 1;
    *(_WORD *)(a1 + 80) += v2 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
    sub_16580(a1);
  }
  return v3;
}

//----- (000131F0) --------------------------------------------------------
int __cdecl sub_131F0(_WORD *a1)
{
  int v1; // esi

  v1 = dword_EA3E4[(unsigned __int16)a1[75]];
  if ( !sub_14C60((int)a1, v1) || (a1[16] = sub_581E0(a1 + 38, (_WORD *)(v1 + 76)), sub_14C90((int)a1, v1, 256, 2048)) )
  {
    sub_16580((int)a1);
    return 0;
  }
  else
  {
    sub_16580((int)a1);
    return 1;
  }
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013270) --------------------------------------------------------
int __cdecl sub_13270(int a1)
{
  int v1; // edi
  __int16 v2; // si
  int v3; // edx
  unsigned __int16 v4; // cx
  __int16 v5; // di
  __int16 i; // si
  unsigned int v9; // eax

  v1 = *(__int16 *)(*(_DWORD *)(a1 + 164) + 580);
  v2 = 0;
  if ( rand() % 255 < v1 )
  {
    v3 = *(_DWORD *)(a1 + 164);
    v4 = *(_WORD *)(v3 + 58);
    v5 = *(char *)(v3 + 1075);
    if ( v4 && sub_106C0(a1, dword_EA3E4[v4]) )
      v2 = 1;
    if ( !v2 )
    {
      for ( i = v5; i >= 0; --i )
      {
        if ( (unsigned __int16)sub_15F20(a1, v5, 22) == 22 )
        {
          sub_14E10(a1, 0x16u);
          sub_16580(a1);
          return 1;
        }
      }
    }
  }
  if ( sub_15170(a1, 3u) )
  {
    if ( !sub_156F0(a1, 3u) )
      sub_14E10(a1, 3u);
    sub_16580(a1);
    return 1;
  }
  else
  {
    sub_16580(a1);
    v9 = sub_146C0(a1, 3u);
    if ( v9 && *(__int16 *)(v9 + 46) > 0 )
    {
      return 1;
    }
    else
    {
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = *(_WORD *)(a1 + 132);
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
      return 0;
    }
  }
}
// 8C278: using guessed type int rand(void);
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000133B0) --------------------------------------------------------
int __cdecl sub_133B0(int a1)
{
  int v1; // eax
  unsigned int v2; // esi
  __int16 k; // di
  __int16 m; // di
  __int16 i; // si
  __int16 j; // si
  unsigned int v9; // eax

  v1 = *(_DWORD *)(a1 + 164);
  v2 = dword_EA3E4[*(unsigned __int16 *)(v1 + 58)];
  if ( v2 <= dword_EA3E4[0] )
  {
    for ( i = *(char *)(v1 + 1064); i >= 0; --i )
    {
      if ( (unsigned __int16)sub_15F20(a1, i, 11) == 11 )
      {
        sub_14E10(a1, 0xBu);
        break;
      }
    }
    for ( j = *(char *)(*(_DWORD *)(a1 + 164) + 1056); j >= 0; --j )
    {
      if ( (unsigned __int16)sub_15F20(a1, j, 3) == 3 )
      {
        sub_14E10(a1, 3u);
        sub_16580(a1);
        return 1;
      }
    }
    v9 = sub_146C0(a1, 3u);
    if ( v9 && *(__int16 *)(v9 + 46) > 0 )
    {
      sub_16580(a1);
      return 1;
    }
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = *(_WORD *)(a1 + 132);
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
  }
  else
  {
    if ( (unsigned int)sub_584D0((_WORD *)(a1 + 76), (_WORD *)(v2 + 76)) > 0x6400000 )
    {
      for ( k = *(char *)(*(_DWORD *)(a1 + 164) + 1054); k >= 0; --k )
      {
        if ( (unsigned __int16)sub_15F20(a1, k, 1) == 1 && sub_14E10(a1, 1u) )
          goto LABEL_6;
      }
    }
    for ( m = *(char *)(*(_DWORD *)(a1 + 164) + 1064); m >= 0; --m )
    {
      if ( (unsigned __int16)sub_15F20(a1, m, 11) == 11 )
      {
        sub_14E10(a1, 0xBu);
        break;
      }
    }
    if ( sub_14C60(a1, v2) )
    {
      *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v2 + 76));
      if ( sub_14C90(a1, v2, 256, 2048) )
      {
        sub_16580(a1);
        return 0;
      }
LABEL_6:
      sub_16580(a1);
      return 1;
    }
  }
  sub_16580(a1);
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000135C0) --------------------------------------------------------
int __cdecl sub_135C0(int a1)
{
  _WORD *v1; // esi
  __int16 i; // di
  __int16 v3; // ax
  int v4; // esi
  __int16 v7; // [esp+0h] [ebp-4h]

  v1 = (_WORD *)dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  if ( !sub_14C60(a1, (int)v1) )
  {
LABEL_17:
    sub_16580(a1);
    return 0;
  }
  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), v1 + 38);
  if ( sub_14C90(a1, (int)v1, 1024, 3072) )
  {
    for ( i = *(char *)(*(_DWORD *)(a1 + 164) + 1054); i >= 0; --i )
    {
      v7 = sub_15F20(a1, i, 1);
      if ( v7 == 1 )
        break;
    }
    if ( v7 == 1 && sub_14E10(a1, 1u) )
    {
      v3 = sub_581E0((_WORD *)(a1 + 76), v1 + 38);
      if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v3) < 0x1Cu )
        v1[74] = *(_WORD *)(a1 + 26);
      goto LABEL_17;
    }
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
    v4 = *(__int16 *)(a1 + 80) - ((__int16)v1[40] + 512);
    if ( v4 )
    {
      if ( v4 <= 0 )
        LOWORD(v4) = -1;
      else
        LOWORD(v4) = 1;
    }
    *(_WORD *)(a1 + 80) += v4 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
  }
  sub_16580(a1);
  return 1;
}
// 13651: variable 'v7' is possibly undefined
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013710) --------------------------------------------------------
int __cdecl sub_13710(int a1)
{
  int v1; // esi
  int v2; // eax
  signed __int8 v3; // al
  int v4; // edx

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  if ( !sub_14C60(a1, v1) )
    goto LABEL_12;
  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
  if ( sub_14C90(a1, v1, 2048, 3584) )
  {
    v2 = *(__int16 *)(*(_DWORD *)(a1 + 164) + 582);
    if ( !(*(unsigned __int8 *)(a1 + 62) % (64 - ((v2 - (__CFSHL__(v2 >> 31, 2) + 4 * (v2 >> 31))) >> 2))) )
    {
      v3 = sub_15910((_DWORD *)a1);
      if ( v3 == -1 || !sub_14E10(a1, v3) )
      {
        *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
        v4 = *(__int16 *)(a1 + 80) - (*(__int16 *)(v1 + 80) + 512);
        if ( v4 )
        {
          if ( v4 <= 0 )
            LOWORD(v4) = -1;
          else
            LOWORD(v4) = 1;
        }
        *(_WORD *)(a1 + 80) += v4 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
        goto LABEL_11;
      }
LABEL_12:
      sub_16580(a1);
      return 0;
    }
  }
LABEL_11:
  sub_16580(a1);
  return 1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013830) --------------------------------------------------------
int __cdecl sub_13830(int a1)
{
  return sub_13890(a1);
}

//----- (00013850) --------------------------------------------------------
int __cdecl sub_13850(int a1)
{
  return sub_13890(a1);
}

//----- (00013870) --------------------------------------------------------
int __cdecl sub_13870(int a1)
{
  int v1; // eax

  v1 = sub_13890(a1);
  return nullsub_1(v1);
}
// 13880: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00013890) --------------------------------------------------------
int __cdecl sub_13890(int a1)
{
  int v1; // esi
  signed __int8 v2; // al
  unsigned __int8 v3; // di
  int v4; // eax
  char v5; // ch
  int v6; // eax
  char v7; // cl
  int v8; // eax
  char v9; // dh
  __int16 v10; // ax

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  if ( !sub_14C60(a1, v1) )
    goto LABEL_34;
  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
  if ( !sub_14C90(a1, v1, 3328, 4608) || *(__int16 *)(*(_DWORD *)(a1 + 164) + 418) < 0 )
  {
LABEL_33:
    sub_16580(a1);
    return 1;
  }
  v2 = sub_15790(a1);
  if ( v2 == -1 || (v3 = v2, !sub_15170(a1, v2)) || !sub_14E10(a1, v3) )
  {
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
    if ( *(_BYTE *)(v1 + 64) <= 1u )
    {
      v4 = *(_DWORD *)(a1 + 164);
      v5 = *(_BYTE *)(v4 + 1117);
      if ( v5 < 3 || v5 >= 5 )
      {
        v6 = *(_DWORD *)(a1 + 164);
        v7 = *(_BYTE *)(v6 + 1117);
        if ( v7 < 5 || v7 >= 20 )
        {
          v8 = *(_DWORD *)(a1 + 164);
          v9 = *(_BYTE *)(v8 + 1117);
          if ( v9 < 20 )
          {
            if ( v9 )
            {
              if ( *(_BYTE *)(v8 + 1116) == 1 )
                *(_WORD *)(a1 + 32) -= 512;
              else
                *(_BYTE *)(a1 + 33) += 2;
              *(_BYTE *)(a1 + 33) &= 7u;
              *(_WORD *)(a1 + 130) = 3 * *(__int16 *)(a1 + 132) * *(__int16 *)(*(_DWORD *)(a1 + 164) + 582) / 255;
              *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
            }
            else
            {
              *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
              if ( (int)(*(unsigned __int16 *)(a1 + 20) % 0xFFu) >= 127 )
              {
                *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1116) = 2;
                *(_BYTE *)(a1 + 29) += 2;
              }
              else
              {
                *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1116) = 1;
                *(_WORD *)(a1 + 28) -= 512;
              }
              *(_BYTE *)(a1 + 29) &= 7u;
            }
            ++*(_BYTE *)(*(_DWORD *)(a1 + 164) + 1117);
          }
          else
          {
            *(_BYTE *)(v8 + 1117) = 0;
          }
        }
        else
        {
          *(_BYTE *)(v6 + 1117) = v7 + 1;
        }
      }
      else
      {
        *(_BYTE *)(v4 + 1117) = v5 + 1;
      }
    }
    v10 = *(_WORD *)(a1 + 80) - (*(_WORD *)(v1 + 80) + 512);
    if ( *(__int16 *)(a1 + 80) != *(__int16 *)(v1 + 80) + 512 )
    {
      if ( *(__int16 *)(a1 + 80) - (*(__int16 *)(v1 + 80) + 512) <= 0 )
        v10 = -1;
      else
        v10 = 1;
    }
    *(_WORD *)(a1 + 80) += v10 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
    goto LABEL_33;
  }
  if ( *(_BYTE *)(v1 + 64) <= 1u )
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 8 * *(__int16 *)(*(_DWORD *)(v1 + 164) + 56) + 518) = 0;
LABEL_34:
  sub_16580(a1);
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013B00) --------------------------------------------------------
int __cdecl sub_13B00(int a1)
{
  _WORD *v1; // esi
  __int16 v2; // bx
  unsigned int v3; // eax
  _WORD *v4; // esi
  unsigned int v6; // eax
  _WORD *v7; // esi
  int v9; // [esp+4h] [ebp-Ch]
  __int16 i; // [esp+8h] [ebp-8h]
  int v11; // [esp+Ch] [ebp-4h]

  v1 = (_WORD *)dword_EA3E4[0];
  if ( !*(_WORD *)(*(_DWORD *)(a1 + 164) + 58) && sub_146C0(a1, 2u) && sub_15730(a1, 2u) )
  {
    v1[13] = *(_WORD *)(a1 + 26);
    v11 = (int)(*(__int16 *)(a1 + 76)
              - (__CFSHL__((unsigned __int64)*(__int16 *)(a1 + 76) >> 32, 14)
               + ((unsigned __int64)*(__int16 *)(a1 + 76) >> 32 << 14))) >> 14;
    v2 = 0;
    v9 = (int)(*(__int16 *)(a1 + 78)
             - (__CFSHL__((unsigned __int64)*(__int16 *)(a1 + 78) >> 32, 14)
              + ((unsigned __int64)*(__int16 *)(a1 + 78) >> 32 << 14))) >> 14;
    while ( v2 < 4 )
    {
      for ( i = 0; i < 4; ++i )
      {
        v1[38] = (((_BYTE)v11 + (_BYTE)i) & 3) << 14;
        v1[39] = (((_BYTE)v2 + (_BYTE)v9) & 3) << 14;
        v3 = sub_14B10((int)v1, 2u);
        if ( !v3 || (unsigned int)sub_583B0((_WORD *)(v3 + 76), v1 + 38) > 0x3000 )
        {
          v4 = v1 + 38;
          *(_DWORD *)(a1 + 154) = *(_DWORD *)v4;
          *(_WORD *)(a1 + 158) = v4[2];
          return 1;
        }
        v6 = sub_14B10((int)v1, 2u);
        if ( !v6 || (unsigned int)sub_583B0((_WORD *)(v6 + 76), v1 + 38) > 0x3000 )
        {
          v7 = v1 + 38;
          *(_DWORD *)(a1 + 154) = *(_DWORD *)v7;
          *(_WORD *)(a1 + 158) = v7[2];
          return 1;
        }
      }
      ++v2;
    }
  }
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013C50) --------------------------------------------------------
int __cdecl sub_13C50(int a1)
{
  unsigned int v1; // ebx

  v1 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)];
  if ( v1 <= dword_EA3E4[0] || *(_BYTE *)(v1 + 69) != 4 || *(_WORD *)(v1 + 48) || !sub_155E0(a1) )
    return 0;
  *(_WORD *)(a1 + 150) = (int)(v1 - (dword_D41A0 + 28302)) / 168;
  *(_WORD *)(a1 + 152) = sub_14C40(v1);
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013CE0) --------------------------------------------------------
unsigned int __cdecl sub_13CE0(int a1)
{
  unsigned int result; // eax
  unsigned int v2; // eax
  unsigned int v3; // eax
  int v4; // ecx

  result = sub_146C0(a1, 1u);
  if ( result )
  {
    v2 = sub_146C0(a1, 2u);
    if ( v2 )
    {
      if ( *(_DWORD *)(a1 + 140) <= *(_DWORD *)(v2 + 140) )
      {
        v3 = sub_148E0(a1);
        v4 = v3;
        if ( v3 )
          goto LABEL_5;
      }
    }
    else
    {
      v3 = sub_148E0(a1);
      v4 = v3;
      if ( v3 )
      {
LABEL_5:
        *(_WORD *)(a1 + 150) = (int)(v3 - (dword_D41A0 + 28302)) / 168;
        *(_WORD *)(a1 + 152) = sub_14C40(v4);
        return 1;
      }
    }
    return 0;
  }
  return result;
}
// 13D69: conditional instruction was optimized away because eax.4==0
// D41A0: using guessed type int dword_D41A0;

//----- (00013DC0) --------------------------------------------------------
int __cdecl sub_13DC0(int a1)
{
  unsigned int v1; // ecx
  int v3; // [esp-4h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 4) / 2 <= *(_DWORD *)(a1 + 8) )
    return 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)];
  if ( v1 <= dword_EA3E4[0] )
    return 0;
  v3 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)];
  *(_WORD *)(a1 + 150) = (int)(v1 - (dword_D41A0 + 28302)) / 168;
  *(_WORD *)(a1 + 152) = sub_14C40(v3);
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00013E40) --------------------------------------------------------
int __cdecl sub_13E40(int a1)
{
  int v1; // edi
  unsigned int i; // ebx
  int v3; // ecx
  unsigned int v4; // eax
  int v5; // ebx
  int v6; // ebx
  unsigned int v8; // [esp+8h] [ebp-8h]

  v8 = -1;
  if ( !sub_164B0(a1) || !*(_WORD *)(*(_DWORD *)(a1 + 164) + 58) && sub_146C0(a1, 2u) )
    return 0;
  v1 = 0;
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) && *(_BYTE *)(i + 64) == 2 )
    {
      if ( (v3 = dword_EA3E4[*(__int16 *)(i + 26)],
            50000 - *(__int16 *)(*(_DWORD *)(a1 + 164) + 578) * (*(_DWORD *)(v3 + 140) / 10) / 255 < *(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 8 * *(__int16 *)(*(_DWORD *)(v3 + 164) + 56) + 516))
        && (unsigned int)sub_584D0((_WORD *)(v3 + 76), (_WORD *)(i + 76)) > 0x3840000
        && !sub_106C0(dword_EA3E4[*(__int16 *)(i + 26)], i)
        || *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)] + 144) > 640
                                                                                             * (255
                                                                                              - *(__int16 *)(*(_DWORD *)(a1 + 164) + 578))
                                                                                             + *(_DWORD *)(i + 144) )
      {
        v4 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
        if ( v4 < v8 )
        {
          v1 = i;
          v8 = v4;
        }
      }
    }
  }
  if ( !v1 )
    return 0;
  v5 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
  if ( sub_584D0((_WORD *)(v1 + 76), (_WORD *)(a1 + 76)) >= (unsigned int)(v5 * v5) )
    return 0;
  v6 = 1;
  *(_WORD *)(a1 + 150) = (v1 - (dword_D41A0 + 28302)) / 168;
  *(_WORD *)(a1 + 152) = sub_14C40(v1);
  return v6;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00014030) --------------------------------------------------------
int __cdecl sub_14030(int a1)
{
  int v1; // edi
  unsigned int i; // ebx
  int v3; // ecx
  int v4; // eax
  unsigned int v6; // eax
  int v7; // ebx
  unsigned int v8; // [esp+0h] [ebp-14h]

  v8 = -1;
  if ( !sub_15E60(a1) || !*(_WORD *)(*(_DWORD *)(a1 + 164) + 58) && sub_146C0(a1, 2u) )
    return 0;
  v1 = 0;
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) && *(_BYTE *)(i + 64) <= 1u && !sub_15760(i, 0xBu) )
    {
      v3 = *(_DWORD *)(i + 164);
      v4 = *(_DWORD *)(a1 + 164) + 8 * *(__int16 *)(v3 + 56);
      if ( *(_WORD *)(v4 + 518) == 1 )
      {
        *(_WORD *)(a1 + 150) = (int)(i - (dword_D41A0 + 28302)) / 168;
        *(_WORD *)(a1 + 152) = sub_14C40(i);
        return 1;
      }
      if ( 50000 - *(_DWORD *)(i + 140) / 10 * *(__int16 *)(*(_DWORD *)(a1 + 164) + 578) / 255 <= *(unsigned __int16 *)(v4 + 516)
        || !*(_WORD *)(v3 + 58)
        && sub_146C0(i, 2u)
        && *(_DWORD *)(i + 144) + 32 * (255 - *(__int16 *)(*(_DWORD *)(a1 + 164) + 578)) < *(_DWORD *)(a1 + 144) )
      {
        v6 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
        if ( v6 < v8 )
        {
          v1 = i;
          v8 = v6;
        }
      }
    }
  }
  if ( !v1 )
    return 0;
  v7 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28) + 10;
  if ( sub_584D0((_WORD *)(v1 + 76), (_WORD *)(a1 + 76)) >= (unsigned int)(v7 * v7) )
    return 0;
  *(_WORD *)(a1 + 150) = (v1 - (dword_D41A0 + 28302)) / 168;
  *(_WORD *)(a1 + 152) = sub_14C40(v1);
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00014250) --------------------------------------------------------
int __cdecl sub_14250(int a1)
{
  int v1; // esi
  unsigned int i; // ebx
  int v3; // edx
  unsigned int v4; // eax
  int v5; // ebx
  int v7; // [esp+Ch] [ebp-Ch]
  int v8; // [esp+10h] [ebp-8h]
  unsigned int v9; // [esp+14h] [ebp-4h]

  v9 = -1;
  if ( !sub_15E60(a1) )
    return 0;
  v1 = 0;
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) && *(_BYTE *)(i + 64) == 3 )
    {
      v3 = dword_EA3E4[*(__int16 *)(i + 26)];
      v8 = *(_DWORD *)(v3 + 164);
      v7 = *(__int16 *)(*(_DWORD *)(a1 + 164) + 578);
      if ( 50000 - *(_DWORD *)(v3 + 140) / 10 * v7 / 255 < *(unsigned __int16 *)(*(_DWORD *)(a1 + 164)
                                                                               + 8 * *(__int16 *)(v8 + 56)
                                                                               + 516)
        && 10 * (275 - v7) < *(_DWORD *)(i + 144)
        && !sub_106C0(i, dword_EA3E4[*(unsigned __int16 *)(v8 + 58)]) )
      {
        v4 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
        if ( v4 < v9 )
        {
          v1 = i;
          v9 = v4;
        }
      }
    }
  }
  if ( !v1 )
    return 0;
  v5 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
  if ( sub_584D0((_WORD *)(v1 + 76), (_WORD *)(a1 + 76)) >= (unsigned int)(v5 * v5) )
    return 0;
  *(_WORD *)(a1 + 150) = (v1 - (dword_D41A0 + 28302)) / 168;
  *(_WORD *)(a1 + 152) = sub_14C40(v1);
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00014530) --------------------------------------------------------
int __cdecl sub_14530(int a1)
{
  int v1; // esi
  int i; // edi
  unsigned int j; // ebx
  unsigned int v4; // eax
  unsigned int v6; // [esp+0h] [ebp-8h]
  int v7; // [esp+4h] [ebp-4h]

  v1 = 0;
  v6 = -1;
  if ( !sub_15E60(a1) )
    return 0;
  v7 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)];
  if ( v7 == dword_EA3E4[0] )
    v7 = a1;
  for ( i = 0; i < 29; ++i )
  {
    for ( j = *(_DWORD *)(dword_D41A4 + 4 * i + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
    {
      if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26) && *(int *)(j + 144) > 0 )
      {
        v4 = sub_584D0((_WORD *)(v7 + 76), (_WORD *)(j + 76));
        if ( v4 < v6 )
        {
          v1 = j;
          v6 = v4;
        }
      }
    }
  }
  if ( !v1 )
    return 0;
  *(_WORD *)(a1 + 150) = (v1 - (dword_D41A0 + 28302)) / 168;
  *(_WORD *)(a1 + 152) = sub_14C40(v1);
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00014630) --------------------------------------------------------
int __cdecl sub_14630(int a1)
{
  unsigned int v1; // ecx

  if ( *(_DWORD *)(a1 + 8) >= *(_DWORD *)(a1 + 4)
    || (v1 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)], v1 <= dword_EA3E4[0]) )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 12;
  }
  else
  {
    *(_WORD *)(a1 + 150) = (int)(v1 - (dword_D41A0 + 28302)) / 168;
    *(_WORD *)(a1 + 152) = sub_14C40(v1);
    *(_BYTE *)(*(_DWORD *)(a1 + 164) + 449) = 11;
  }
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000146C0) --------------------------------------------------------
unsigned int __cdecl sub_146C0(int a1, unsigned __int8 a2)
{
  unsigned int result; // eax

  result = dword_EA3E4[*(__int16 *)(*(_DWORD *)(a1 + 164) + 2 * a2 + 819)];
  if ( result <= dword_EA3E4[0] )
    return 0;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000146F0) --------------------------------------------------------
int __cdecl sub_146F0(int a1)
{
  char v1; // ah
  __int16 *v2; // edx
  __int16 v3; // ax
  unsigned __int16 v4; // ax
  int v5; // edx
  __int16 v6; // cx
  _WORD *v7; // eax
  __int16 v8; // dx
  int v9; // edx
  __int16 v10; // ax
  __int16 v11; // ax
  unsigned __int16 v12; // si
  __int64 v13; // rax
  int v14; // eax
  int v15; // edx
  __int16 v16; // si
  __int16 v17; // si
  unsigned int v18; // eax
  unsigned __int16 v19; // si
  unsigned __int16 v20; // dx
  int v22; // [esp-Ch] [ebp-Ch]
  int v23; // [esp-8h] [ebp-8h]
  __int16 v24; // [esp-4h] [ebp-4h]

  v1 = *(_BYTE *)(a1 + 13);
  if ( (v1 & 8) != 0 )
  {
    *(_BYTE *)(a1 + 13) = v1 & 0xF7;
  }
  else
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v2 = *(__int16 **)(a1 + 160);
    v24 = v2[7];
    v23 = v2[5];
    v22 = v2[6];
    v3 = sub_10C40(&word_EB398);
    sub_580E0((int)&word_EB398, v3, v22, v23, v24);
    sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
    v4 = *(_WORD *)(a1 + 28);
    HIBYTE(v4) += 2;
    sub_57FA0(&word_EB398, v4, 0, *(_WORD *)(*(_DWORD *)(a1 + 164) + 16));
    v5 = *(_DWORD *)(a1 + 164);
    v6 = *(_WORD *)(v5 + 16);
    v7 = (_WORD *)(v5 + 16);
    if ( v6 )
    {
      if ( v6 <= 0 )
        v8 = -1;
      else
        v8 = 1;
    }
    else
    {
      v8 = 0;
    }
    *v7 -= 4 * v8;
    sub_57CF0((__int16)v7, a1, (int)&word_EB398);
    v9 = *(__int16 *)(*(_DWORD *)(a1 + 164) + 12) - *(__int16 *)(a1 + 130);
    v10 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) - *(_WORD *)(a1 + 130);
    if ( v9 )
    {
      if ( v9 <= 0 )
        v10 = -1;
      else
        v10 = 1;
    }
    *(_WORD *)(a1 + 130) += 16 * v10;
    v11 = *(_WORD *)(a1 + 32);
    HIBYTE(v11) &= 7u;
    v12 = sub_582B0(*(_WORD *)(a1 + 28), v11);
    v13 = 255 - *(__int16 *)(*(_DWORD *)(a1 + 164) + 582);
    v14 = v12 / (int)(unsigned __int16)(((int)(v13 - (__CFSHL__(HIDWORD(v13), 4) + 16 * HIDWORD(v13))) >> 4) + 8);
    v15 = *(_DWORD *)(a1 + 160);
    v16 = v14;
    if ( (__int16)v14 <= *(__int16 *)(v15 + 2) )
    {
      if ( (__int16)v14 < *(__int16 *)(v15 + 4) )
        v16 = *(_WORD *)(v15 + 4);
    }
    else
    {
      v16 = *(_WORD *)(v15 + 2);
    }
    v17 = sub_582F0(*(unsigned __int16 *)(a1 + 28), *(_WORD *)(a1 + 32)) * v16;
    v18 = *(unsigned __int16 *)(a1 + 28);
    v19 = (v18 + v17) & 0x7FF;
    v20 = *(_WORD *)(a1 + 32);
    *(_WORD *)(a1 + 28) = v19;
    if ( (unsigned __int16)v18 < (unsigned int)v20 && v19 > v20
      || (v20 = *(_WORD *)(a1 + 32), v18 > v20) && v20 > *(_WORD *)(a1 + 28) )
    {
      *(_WORD *)(a1 + 28) = v20;
    }
  }
  return 1;
}
// EB398: using guessed type __int16 word_EB398;

//----- (000148E0) --------------------------------------------------------
unsigned int __cdecl sub_148E0(int a1)
{
  unsigned int v1; // edi
  unsigned int v2; // ebx
  int v3; // eax
  int v4; // edx
  unsigned int v5; // eax
  unsigned int v6; // eax
  unsigned int i; // ebx
  unsigned int v8; // eax
  int v10; // [esp+0h] [ebp-1Ch]
  unsigned int v11; // [esp+8h] [ebp-14h]
  _WORD *v12; // [esp+Ch] [ebp-10h]
  int v13; // [esp+10h] [ebp-Ch]
  unsigned int v14; // [esp+14h] [ebp-8h]
  unsigned int v15; // [esp+18h] [ebp-4h]

  v1 = -1;
  v15 = 0;
  v2 = *(_DWORD *)(dword_D41A4 + 38523);
  v14 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)];
  while ( v2 > dword_EA3E4[0] )
  {
    if ( a1 == dword_EA3E4[*(unsigned __int16 *)(v2 + 148)] )
      goto LABEL_21;
    if ( *(_BYTE *)(v2 + 64) == 57 )
    {
      v10 = *(__int16 *)(*(_DWORD *)(a1 + 164) + 580);
      if ( rand() % 255 < v10 )
        break;
    }
    v3 = *(unsigned __int16 *)(v2 + 148);
    v4 = dword_EA3E4[(unsigned __int16)v3];
    v12 = (_WORD *)(v2 + 76);
    if ( *(_BYTE *)(v4 + 63) == 3 )
    {
      if ( v3 == *(__int16 *)(a1 + 26) )
        goto LABEL_21;
      if ( 50000 - *(_DWORD *)(v4 + 140) / 10 * *(__int16 *)(*(_DWORD *)(a1 + 164) + 578) / 255 >= *(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 8 * *(__int16 *)(*(_DWORD *)(v4 + 164) + 56) + 516) )
      {
        v11 = sub_16FC0(v2, a1);
        if ( !v11 )
          goto LABEL_21;
        v6 = v14 <= dword_EA3E4[0] ? sub_14B10(v2, 2u) : sub_14BD0(v2, v14);
        v13 = v6;
        if ( *(_WORD *)(a1 + 26) != *(_WORD *)(v11 + 26)
          && (unsigned int)sub_584D0((_WORD *)(v2 + 76), (_WORD *)(v11 + 76)) <= 0x1900000 )
        {
          goto LABEL_21;
        }
        if ( v13 && sub_106C0(v2, v13) )
          goto LABEL_21;
        v5 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(v2 + 76));
      }
      else
      {
        v5 = sub_584D0((_WORD *)(v14 + 76), v12);
      }
    }
    else
    {
      v5 = sub_584D0((_WORD *)(a1 + 76), v12);
    }
    if ( v5 < v1 )
    {
      v15 = v2;
      v1 = v5;
    }
LABEL_21:
    v2 = *(_DWORD *)v2;
  }
  if ( !v15 )
  {
    for ( i = *(_DWORD *)(dword_D41A4 + 38491); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(_BYTE *)(i + 64) != 57 && *(unsigned __int16 *)(i + 148) != *(__int16 *)(a1 + 26) )
      {
        v8 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
        if ( v8 < v1 )
        {
          v15 = i;
          v1 = v8;
        }
      }
    }
  }
  return v15;
}
// 14A83: conditional instruction was optimized away because cl.1!=3
// 8C278: using guessed type int rand(void);
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00014B10) --------------------------------------------------------
unsigned int __cdecl sub_14B10(int a1, unsigned __int8 a2)
{
  unsigned int v2; // edi
  unsigned int v3; // esi
  unsigned int i; // ebx
  unsigned int v5; // eax
  unsigned int j; // ebx
  unsigned int v7; // eax

  v2 = -1;
  v3 = 0;
  if ( a2 < 2u )
  {
    if ( a2 )
      return v3;
  }
  else if ( a2 > 3u )
  {
    if ( a2 == 0xFF )
    {
      for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
      {
        if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) )
        {
          v5 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
          if ( v5 < v2 )
          {
            v3 = i;
            v2 = v5;
          }
        }
      }
    }
    return v3;
  }
  for ( j = *(_DWORD *)(dword_D41A4 + 38519); j > dword_EA3E4[0]; j = *(_DWORD *)j )
  {
    if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26) && *(char *)(j + 64) == a2 )
    {
      v7 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(j + 76));
      if ( v7 < v2 )
      {
        v3 = j;
        v2 = v7;
      }
    }
  }
  return v3;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00014BD0) --------------------------------------------------------
unsigned int __cdecl sub_14BD0(int a1, int a2)
{
  unsigned int v2; // edi
  unsigned int v3; // esi
  unsigned int v4; // ebx
  __int16 v6; // ax
  unsigned int v7; // eax

  v2 = -1;
  v3 = 0;
  v4 = *(_DWORD *)(dword_D41A4 + 38519);
  if ( v4 <= dword_EA3E4[0] )
    return 0;
  do
  {
    v6 = *(_WORD *)(v4 + 26);
    if ( v6 != *(_WORD *)(a1 + 26) && v6 != *(_WORD *)(a2 + 26) && *(_BYTE *)(v4 + 64) == 2 )
    {
      v7 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(v4 + 76));
      if ( v7 < v2 )
      {
        v3 = v4;
        v2 = v7;
      }
    }
    v4 = *(_DWORD *)v4;
  }
  while ( v4 > dword_EA3E4[0] );
  return v3;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00014C40) --------------------------------------------------------
__int16 __cdecl sub_14C40(int a1)
{
  return *(_WORD *)(a1 + 26) + *(char *)(a1 + 64) + (*(char *)(a1 + 63) << 7);
}

//----- (00014C60) --------------------------------------------------------
bool __cdecl sub_14C60(int a1, int a2)
{
  return sub_14C40(a2) == *(_WORD *)(a1 + 152);
}

//----- (00014C90) --------------------------------------------------------
int __cdecl sub_14C90(int a1, int a2, signed int a3, signed int a4)
{
  signed int v4; // eax
  signed int v6; // eax

  *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 0;
  if ( !a2 )
  {
    v4 = sub_58490((_WORD *)(a1 + 76), (_WORD *)(a1 + 154));
    if ( v4 > a3 )
    {
      if ( v4 > a4 && sub_15170(a1, 3u) )
      {
        if ( !sub_156F0(a1, 3u) )
          sub_14E10(a1, 3u);
      }
      else
      {
        *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = *(_WORD *)(a1 + 132);
        *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
      }
      return 0;
    }
LABEL_16:
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
    return 1;
  }
  v6 = sub_58490((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
  if ( v6 <= a3 )
    goto LABEL_16;
  if ( v6 > a4 && sub_15170(a1, 3u) )
  {
    if ( !sub_156F0(a1, 3u) )
      sub_14E10(a1, 3u);
  }
  else
  {
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = *(_WORD *)(a1 + 132);
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
  }
  return 0;
}

//----- (00014E10) --------------------------------------------------------
int __cdecl sub_14E10(int a1, unsigned __int8 a2)
{
  unsigned int v2; // eax
  int result; // eax
  int v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // edi
  int v7; // esi
  unsigned int v8; // esi
  unsigned int v9; // eax

  if ( !sub_15170(a1, a2) )
    return 0;
  *(_BYTE *)(a1 + 13) &= ~1u;
  switch ( a2 )
  {
    case 0u:
    case 1u:
    case 7u:
    case 0x16u:
      v6 = sub_146C0(a1, a2);
      if ( !v6
        || *(__int16 *)(*(_DWORD *)(a1 + 164) + 418) < 0
        || (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32)) >= 0xAAu )
      {
        return 0;
      }
      *(_WORD *)(a1 + 30) = sub_58210((_WORD *)(a1 + 76), (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 76));
      ++*(_WORD *)(*(_DWORD *)(a1 + 164) + 418);
      v7 = *(_DWORD *)(a1 + 164);
      if ( *(__int16 *)(v7 + 418) >= 8 )
        *(_WORD *)(v7 + 418) = ((*(__int16 *)(v7 + 582)
                               - 255
                               - (__CFSHL__((*(__int16 *)(v7 + 582) - 255) >> 31, 3)
                                + 8 * ((*(__int16 *)(v7 + 582) - 255) >> 31))) >> 3)
                             - 1;
      if ( sub_5F660(a1, v6, 0) != 1 )
        return 0;
      *(_WORD *)(2 * a2 + *(_DWORD *)(a1 + 164) + 871) = word_D3F4C[a2];
      return 1;
    case 2u:
      v2 = sub_146C0(a1, a2);
      if ( !v2 )
        return 0;
      if ( *(_WORD *)(*(_DWORD *)(a1 + 164) + 58) )
      {
        if ( sub_5F660(a1, v2, 0) != 1 )
          return 0;
        *(_WORD *)(*(_DWORD *)(a1 + 164) + 2 * a2 + 871) = word_D3F4C[a2];
        result = 1;
      }
      else
      {
        v4 = sub_4A190(a1 + 154, 3, 2);
        if ( v4 )
        {
          *(_WORD *)(v4 + 26) = *(_WORD *)(a1 + 26);
          *(_WORD *)(*(_DWORD *)(a1 + 164) + 58) = (v4 - (dword_D41A0 + 28302)) / 168;
        }
        result = 1;
      }
      break;
    case 3u:
      v5 = sub_146C0(a1, a2);
      if ( !v5 || sub_5F660(a1, v5, 0) != 1 )
        return 0;
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 2 * a2 + 871) = word_D3F4C[a2];
      return 1;
    case 4u:
    case 9u:
    case 0xDu:
    case 0xEu:
    case 0x12u:
    case 0x13u:
    case 0x15u:
      v8 = sub_146C0(a1, a2);
      if ( !v8 )
        return 0;
      if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32)) >= 0xE3u )
        return 0;
      *(_WORD *)(a1 + 30) = sub_58210((_WORD *)(a1 + 76), (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 76));
      if ( sub_5F660(a1, v8, 0) != 1 )
        return 0;
      *(_WORD *)(2 * a2 + *(_DWORD *)(a1 + 164) + 871) = word_D3F4C[a2];
      return 1;
    case 5u:
    case 6u:
    case 8u:
    case 0xAu:
    case 0xBu:
    case 0xCu:
    case 0x10u:
    case 0x11u:
    case 0x14u:
      v9 = sub_146C0(a1, a2);
      if ( !v9 || sub_5F660(a1, v9, 0) != 1 )
        return 0;
      *(_WORD *)(2 * a2 + *(_DWORD *)(a1 + 164) + 871) = word_D3F4C[a2];
      return 1;
    default:
      return 0;
  }
  return result;
}
// D3F4C: using guessed type __int16 word_D3F4C[26];
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00015170) --------------------------------------------------------
unsigned int __cdecl sub_15170(int a1, unsigned __int8 a2)
{
  unsigned int v2; // eax
  unsigned int v3; // esi
  int v4; // eax
  int v5; // edx
  unsigned int result; // eax
  unsigned int v7; // eax
  unsigned int v8; // esi
  int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // esi
  int v12; // eax
  int v13; // eax
  int v14; // edi
  unsigned int v15; // eax
  unsigned int v16; // esi
  int v17; // eax
  int v18; // eax
  int v19; // edx
  __int64 v20; // rax
  unsigned int v21; // eax
  unsigned int v22; // esi
  int v23; // eax
  int v24; // eax
  int v25; // edi
  unsigned int v26; // eax
  unsigned int v27; // esi
  int v28; // eax
  int v29; // edx

  switch ( a2 )
  {
    case 0u:
    case 7u:
    case 0xDu:
    case 0xEu:
    case 0x16u:
      v21 = sub_146C0(a1, a2);
      v22 = v21;
      if ( !v21 )
        goto LABEL_49;
      v23 = 80 * a2 + 26 * *(char *)(v21 + 70);
      if ( *(_DWORD *)(a1 + 140) < *(int *)((char *)&dword_DA822 + v23) )
        goto LABEL_49;
      if ( *(_DWORD *)(a1 + 144) < *(int *)((char *)&dword_DA81E + v23) )
        goto LABEL_49;
      v24 = *(_DWORD *)(a1 + 164);
      if ( *(_WORD *)(v24 + 2 * a2 + 871) )
        goto LABEL_49;
      if ( *(_DWORD *)(a1 + 144) < *(_DWORD *)(v22 + 140) )
        goto LABEL_49;
      v25 = ((((255
              - *(__int16 *)(v24 + 580)
              - (__CFSHL__((255 - *(__int16 *)(v24 + 580)) >> 31, 2)
               + 4 * ((255 - *(__int16 *)(v24 + 580)) >> 31))) >> 2)
            + 20) << 11)
          / 360;
      if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32)) >= v25 )
        goto LABEL_49;
      result = v22;
      break;
    case 1u:
    case 9u:
    case 0x10u:
    case 0x12u:
    case 0x13u:
    case 0x15u:
      v10 = sub_146C0(a1, a2);
      v11 = v10;
      if ( !v10 )
        goto LABEL_49;
      v12 = 26 * *(char *)(v10 + 70) + 80 * a2;
      if ( *(_DWORD *)(a1 + 140) < *(int *)((char *)&dword_DA822 + v12) )
        goto LABEL_49;
      if ( *(_DWORD *)(a1 + 144) < *(int *)((char *)&dword_DA81E + v12) )
        goto LABEL_49;
      if ( *(_WORD *)(v11 + 46) )
        goto LABEL_49;
      v13 = *(_DWORD *)(a1 + 164);
      if ( *(_WORD *)(v13 + 2 * a2 + 871) )
        goto LABEL_49;
      if ( *(_DWORD *)(a1 + 144) < *(_DWORD *)(v11 + 140) )
        goto LABEL_49;
      v14 = ((((255
              - *(__int16 *)(v13 + 580)
              - (__CFSHL__((255 - *(__int16 *)(v13 + 580)) >> 31, 2)
               + 4 * ((255 - *(__int16 *)(v13 + 580)) >> 31))) >> 2)
            + 20) << 11)
          / 360;
      if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32)) >= v14 )
        goto LABEL_49;
      result = v11;
      break;
    case 2u:
      v15 = sub_146C0(a1, a2);
      v16 = v15;
      if ( !v15 )
        goto LABEL_49;
      v17 = 80 * a2 + 26 * *(char *)(v15 + 70);
      if ( *(_DWORD *)(a1 + 140) < *(int *)((char *)&dword_DA822 + v17)
        || *(_DWORD *)(a1 + 144) < *(int *)((char *)&dword_DA81E + v17) )
      {
        goto LABEL_49;
      }
      v18 = *(_DWORD *)(a1 + 164);
      v19 = v18 + 2 * a2;
      if ( *(_WORD *)(v18 + 58) )
      {
        if ( *(_WORD *)(v16 + 46) )
          goto LABEL_49;
        if ( *(_WORD *)(v19 + 871) )
          goto LABEL_49;
        if ( !sub_11A10((_WORD *)dword_EA3E4[*(unsigned __int16 *)(v18 + 58)]) )
          goto LABEL_49;
        if ( *(_DWORD *)(a1 + 144) < *(_DWORD *)(v16 + 140) )
          goto LABEL_49;
        v20 = 255 - *(__int16 *)(*(_DWORD *)(a1 + 164) + 580);
        if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32)) >= ((((int)(v20
                                                                                             - (__CFSHL__(
                                                                                                  HIDWORD(v20),
                                                                                                  2)
                                                                                              + 4 * HIDWORD(v20))) >> 2)
                                                                                      + 20) << 11)
                                                                                    / 360 )
          goto LABEL_49;
        result = v16;
      }
      else
      {
        if ( *(_WORD *)(v19 + 871) || *(_DWORD *)(a1 + 144) < *(_DWORD *)(v16 + 140) )
          goto LABEL_49;
        result = v16;
      }
      break;
    case 3u:
      v2 = sub_146C0(a1, a2);
      v3 = v2;
      if ( !v2 )
        goto LABEL_49;
      v4 = 80 * a2 + 26 * *(char *)(v2 + 70);
      if ( *(_DWORD *)(a1 + 140) < *(int *)((char *)&dword_DA822 + v4) )
        goto LABEL_49;
      v5 = *(_DWORD *)(a1 + 144);
      if ( v5 < *(int *)((char *)&dword_DA81E + v4) || v5 < *(_DWORD *)(v3 + 140) )
        goto LABEL_49;
      result = v3;
      break;
    case 4u:
    case 6u:
    case 8u:
    case 0xBu:
      v7 = sub_146C0(a1, a2);
      v8 = v7;
      if ( !v7 )
        goto LABEL_49;
      v9 = 26 * *(char *)(v7 + 70) + 80 * a2;
      if ( *(_DWORD *)(a1 + 140) < *(int *)((char *)&dword_DA822 + v9)
        || *(_DWORD *)(a1 + 144) < *(int *)((char *)&dword_DA81E + v9)
        || *(_WORD *)(v8 + 46)
        || *(_WORD *)(*(_DWORD *)(a1 + 164) + 2 * a2 + 871)
        || *(_DWORD *)(a1 + 144) < *(_DWORD *)(v8 + 140) )
      {
        goto LABEL_49;
      }
      result = v8;
      break;
    default:
      if ( a2 >= 0x1Au
        || (v26 = sub_146C0(a1, a2), (v27 = v26) == 0)
        || (v28 = 80 * a2 + 26 * *(char *)(v26 + 70), *(_DWORD *)(a1 + 140) < *(int *)((char *)&dword_DA822 + v28))
        || (v29 = *(_DWORD *)(a1 + 144), v29 < *(int *)((char *)&dword_DA81E + v28))
        || *(_WORD *)(*(_DWORD *)(a1 + 164) + 2 * a2 + 871)
        || v29 < *(_DWORD *)(v27 + 140) )
      {
LABEL_49:
        result = 0;
      }
      else
      {
        result = v27;
      }
      break;
  }
  return result;
}
// DA81E: using guessed type int dword_DA81E;
// DA822: using guessed type int dword_DA822;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000155E0) --------------------------------------------------------
int __cdecl sub_155E0(int a1)
{
  unsigned int v1; // ebx
  int v2; // eax
  __int64 v4; // rax

  v1 = sub_146C0(a1, 2u);
  if ( v1 )
  {
    v2 = *(_DWORD *)(a1 + 164);
    if ( *(_WORD *)(v2 + 58) )
    {
      if ( !*(_WORD *)(v1 + 46) && !*(_WORD *)(v2 + 875) )
      {
        if ( sub_11A10((_WORD *)dword_EA3E4[*(unsigned __int16 *)(v2 + 58)]) )
        {
          if ( *(_DWORD *)(a1 + 140) >= *(_DWORD *)(v1 + 140) )
          {
            v4 = 255 - *(__int16 *)(*(_DWORD *)(a1 + 164) + 580);
            if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32)) < ((((int)(v4
                                                                                                - (__CFSHL__(
                                                                                                     HIDWORD(v4),
                                                                                                     2)
                                                                                                 + 4 * HIDWORD(v4))) >> 2)
                                                                                         + 20) << 11)
                                                                                       / 360 )
              return 1;
          }
        }
      }
    }
    else if ( !*(_WORD *)(v2 + 875) && *(_DWORD *)(a1 + 140) >= *(_DWORD *)(v1 + 140) )
    {
      return 1;
    }
  }
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000156F0) --------------------------------------------------------
bool __cdecl sub_156F0(int a1, unsigned __int8 a2)
{
  unsigned int v2; // eax
  bool result; // eax

  result = 0;
  if ( a2 < 0x1Au )
  {
    v2 = sub_146C0(a1, a2);
    if ( v2 )
    {
      if ( *(__int16 *)(v2 + 46) > 0 )
        return 1;
    }
  }
  return result;
}

//----- (00015730) --------------------------------------------------------
bool __cdecl sub_15730(int a1, unsigned __int8 a2)
{
  return *(_DWORD *)(a1 + 140) >= *(_DWORD *)(sub_146C0(a1, a2) + 140);
}

//----- (00015760) --------------------------------------------------------
unsigned int __cdecl sub_15760(int a1, unsigned __int8 a2)
{
  unsigned int result; // eax

  result = sub_146C0(a1, a2);
  if ( !result || *(__int16 *)(result + 46) <= 0 )
    return 0;
  return result;
}

//----- (00015790) --------------------------------------------------------
char __cdecl sub_15790(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // eax
  int v4; // ecx
  int v5; // edi
  int i; // edi
  char *j; // esi
  int k; // edi
  int v10; // edi
  int v11; // [esp+0h] [ebp-4h]

  v11 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v1 = (*(_DWORD *)(a1 + 140) - (__CFSHL__(*(int *)(a1 + 140) >> 31, 2) + 4 * (*(int *)(a1 + 140) >> 31))) >> 2;
  if ( v1 <= *(_DWORD *)(a1 + 144) )
  {
    v2 = *(_DWORD *)(a1 + 164);
    if ( *(_WORD *)(v2 + 420) )
    {
      v3 = v1 + 6000;
      v4 = *(_DWORD *)(a1 + 140);
      if ( v3 >= v4 )
        v3 = v4 / 2;
      if ( v3 <= *(_DWORD *)(a1 + 144) )
        *(_WORD *)(v2 + 420) = 0;
    }
  }
  else
  {
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 420) = 1;
  }
  if ( !*(_WORD *)(*(_DWORD *)(a1 + 164) + 420) )
  {
    if ( sub_15760(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)], 8u) )
    {
      v5 = *(__int16 *)(*(_DWORD *)(a1 + 164) + 580);
      if ( rand() % 255 < v5 )
      {
        for ( i = *(char *)(*(_DWORD *)(a1 + 164) + 1060); i >= 0; --i )
        {
          if ( (__int16)sub_15F20(a1, i, 7) == 7 )
            return 7;
        }
      }
    }
    for ( j = (char *)&unk_D3F80; ; ++j )
    {
      v10 = *j;
      if ( v10 == -1 )
        break;
      for ( k = *(char *)(v10 + *(_DWORD *)(a1 + 164) + 1053); k >= 0; --k )
      {
        if ( (__int16)sub_15F20(a1, k, *j) == *j )
        {
          if ( *j == 19 && *(_BYTE *)(v11 + 64) <= 1u )
            return *j;
          if ( *j != 19 )
            return *j;
        }
      }
    }
  }
  return -1;
}
// 8C278: using guessed type int rand(void);
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00015910) --------------------------------------------------------
char __cdecl sub_15910(_DWORD *a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // eax
  int v4; // ecx
  unsigned __int8 *i; // esi
  __int16 j; // di
  __int16 v7; // ax

  v1 = (a1[35] - (__CFSHL__((int)a1[35] >> 31, 2) + 4 * ((int)a1[35] >> 31))) >> 2;
  if ( v1 <= a1[36] )
  {
    v2 = a1[41];
    if ( *(_WORD *)(v2 + 420) )
    {
      v3 = v1 + 6000;
      v4 = a1[35];
      if ( v3 >= v4 )
        v3 = v4 / 2;
      if ( v3 <= a1[36] )
        *(_WORD *)(v2 + 420) = 0;
    }
  }
  else
  {
    *(_WORD *)(a1[41] + 420) = 1;
  }
  if ( !*(_WORD *)(a1[41] + 420) )
  {
    for ( i = (unsigned __int8 *)&unk_D3F89; ; ++i )
    {
      for ( j = *(char *)(a1[41] + *i + 1053); j >= 0; --j )
      {
        v7 = sub_15F20((int)a1, j, *i);
        if ( v7 == *i )
          return v7;
      }
    }
  }
  LOBYTE(v7) = -1;
  return v7;
}
// 159D1: conditional instruction was optimized away because eax.4<100u

//----- (000159E0) --------------------------------------------------------
void sub_159E0()
{
  unsigned int v0; // edi
  unsigned int v1; // esi
  unsigned int v2; // ecx
  unsigned __int8 v3; // al
  int v4; // ebx
  unsigned __int8 v5; // al
  int v6; // ebx
  unsigned __int8 v7; // al
  int v8; // edx
  int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // [esp+4h] [ebp-8h]

  v0 = *(_DWORD *)(dword_D41A4 + 38531);
  if ( v0 > dword_EA3E4[0] )
  {
    while ( 1 )
    {
      if ( (*(_BYTE *)(v0 + 13) & 0x20) != 0 )
        goto LABEL_48;
      v1 = dword_EA3E4[*(__int16 *)(v0 + 26)];
      if ( v1 <= dword_EA3E4[0] )
        goto LABEL_48;
      if ( *(_BYTE *)(v1 + 63) != 3 )
        goto LABEL_48;
      v2 = dword_EA3E4[*(unsigned __int16 *)(v0 + 150)];
      if ( v2 <= dword_EA3E4[0] )
        goto LABEL_48;
      *(_BYTE *)(v0 + 13) |= 0x20u;
      v3 = *(_BYTE *)(v2 + 63);
      if ( v3 < 3u )
        goto LABEL_48;
      if ( v3 <= 3u )
        break;
      if ( v3 != 10 )
        goto LABEL_48;
      if ( *(_BYTE *)(v0 + 64) != 1 )
        goto LABEL_48;
      if ( *(_BYTE *)(v2 + 64) != 39 )
        goto LABEL_48;
      v10 = dword_EA3E4[*(unsigned __int16 *)(v2 + 148)];
      v11 = v10;
      if ( v10 <= dword_EA3E4[0] || *(_BYTE *)(v10 + 63) != 3 )
        goto LABEL_48;
      v6 = ((*(_DWORD *)(v2 + 144) - (__CFSHL__(*(int *)(v2 + 144) >> 31, 2) + 4 * (*(int *)(v2 + 144) >> 31))) >> 2)
         + *(unsigned __int16 *)(8 * *(__int16 *)(*(_DWORD *)(v1 + 164) + 56) + *(_DWORD *)(v10 + 164) + 516);
      if ( v6 < 0 )
        v6 = 0;
      if ( v6 > 0xFFFF )
        LOWORD(v6) = -1;
      v9 = *(__int16 *)(*(_DWORD *)(v1 + 164) + 56);
      v8 = *(_DWORD *)(v11 + 164);
LABEL_47:
      *(_WORD *)(v8 + 8 * v9 + 516) = v6;
LABEL_48:
      v0 = *(_DWORD *)v0;
      if ( v0 <= dword_EA3E4[0] )
        return;
    }
    if ( *(_BYTE *)(v2 + 64) == 2 )
    {
      v4 = *(unsigned __int16 *)(*(_DWORD *)(dword_EA3E4[*(__int16 *)(v2 + 26)] + 164)
                               + 8 * *(__int16 *)(*(_DWORD *)(v1 + 164) + 56)
                               + 516);
      v5 = *(_BYTE *)(v0 + 64);
      if ( v5 < 0xAu )
      {
        if ( v5 >= 3u && v5 <= 4u )
          goto LABEL_17;
LABEL_18:
        v4 += 1000;
      }
      else if ( v5 > 0xAu )
      {
        if ( v5 != 11 )
          goto LABEL_18;
LABEL_17:
        v4 += 5000;
      }
      if ( v4 < 0 )
        v4 = 0;
      if ( v4 > 0xFFFF )
        v4 = 0xFFFF;
      *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(__int16 *)(v2 + 26)] + 164)
               + 8 * *(__int16 *)(*(_DWORD *)(v1 + 164) + 56)
               + 516) = v4;
      if ( v4 > 50000 - *(_DWORD *)(v1 + 140) / 10 * *(__int16 *)(*(_DWORD *)(v2 + 164) + 578) / 255 )
        *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(__int16 *)(v2 + 26)] + 164)
                 + 8 * *(__int16 *)(*(_DWORD *)(v1 + 164) + 56)
                 + 518) = 1;
      goto LABEL_48;
    }
    v6 = *(unsigned __int16 *)(*(_DWORD *)(dword_EA3E4[*(__int16 *)(v2 + 26)] + 164)
                             + 8 * *(__int16 *)(*(_DWORD *)(v1 + 164) + 56)
                             + 516);
    v7 = *(_BYTE *)(v0 + 64);
    if ( v7 < 0xAu )
    {
      if ( v7 < 3u || v7 > 4u )
        goto LABEL_32;
    }
    else
    {
      if ( v7 <= 0xAu )
      {
LABEL_33:
        if ( v6 < 0 )
          v6 = 0;
        if ( v6 > 0xFFFF )
          LOWORD(v6) = -1;
        v8 = *(_DWORD *)(dword_EA3E4[*(__int16 *)(v2 + 26)] + 164);
        v9 = *(__int16 *)(*(_DWORD *)(v1 + 164) + 56);
        goto LABEL_47;
      }
      if ( v7 != 11 )
      {
LABEL_32:
        v6 += 500;
        goto LABEL_33;
      }
    }
    v6 += 3000;
    goto LABEL_33;
  }
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00015CB0) --------------------------------------------------------
unsigned int __usercall sub_15CB0@<eax>(unsigned int a1@<edi>, int a2)
{
  unsigned int v2; // esi
  unsigned int i; // ebx
  unsigned int v4; // eax

  v2 = -1;
  for ( i = *(_DWORD *)(dword_D41A4 + 38531); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(unsigned __int16 *)(i + 150) == *(__int16 *)(a2 + 26) )
    {
      v4 = sub_584D0((_WORD *)(a2 + 76), (_WORD *)(i + 76));
      if ( v4 < v2 )
      {
        v2 = v4;
        a1 = i;
      }
    }
  }
  if ( v2 >= 0x1900000 )
    return 0;
  else
    return a1;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00015D20) --------------------------------------------------------
int __cdecl sub_15D20(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 164);
  if ( !*(_BYTE *)(result + 1118) )
    *(_WORD *)(result + 16) = 80;
  return result;
}

//----- (00015D40) --------------------------------------------------------
char __usercall sub_15D40@<al>(__int16 a1@<di>, int a2, int a3)
{
  unsigned int v3; // eax
  __int16 i; // si
  __int16 v5; // si
  __int16 v6; // si

  v3 = sub_584D0((_WORD *)(a2 + 76), (_WORD *)(a3 + 76));
  if ( v3 >= (unsigned int)&unk_100000 )
    return v3;
  LOBYTE(v3) = *(_BYTE *)(a3 + 64);
  if ( (unsigned __int8)v3 < 3u )
  {
    if ( (_BYTE)v3 )
      return v3;
  }
  else if ( (unsigned __int8)v3 > 3u )
  {
    if ( (_BYTE)v3 == 4 )
    {
      v3 = *(_DWORD *)(a2 + 164);
      v6 = *(char *)(v3 + 1059);
      if ( v6 >= 0 )
      {
        while ( 1 )
        {
          LOWORD(v3) = sub_15F20(a2, v6, 6);
          if ( (_WORD)v3 == 6 )
            break;
          if ( --v6 < 0 )
            return v3;
        }
LABEL_15:
        LOBYTE(v3) = sub_14E10(a2, 6u);
        return v3;
      }
    }
    return v3;
  }
  v3 = *(_DWORD *)(a2 + 164);
  for ( i = *(char *)(v3 + 1061); i >= 0; --i )
  {
    LOWORD(v3) = sub_15F20(a2, i, 8);
    a1 = v3;
    if ( (_WORD)v3 == 8 )
    {
      LOBYTE(v3) = sub_14E10(a2, 8u);
      break;
    }
  }
  if ( a1 != 8 )
  {
    v3 = *(_DWORD *)(a2 + 164);
    v5 = *(char *)(v3 + 1059);
    if ( v5 >= 0 )
    {
      while ( 1 )
      {
        LOWORD(v3) = sub_15F20(a2, v5, 6);
        if ( (_WORD)v3 == 6 )
          break;
        if ( --v5 < 0 )
          return v3;
      }
      goto LABEL_15;
    }
  }
  return v3;
}

//----- (00015E60) --------------------------------------------------------
_BOOL1 __cdecl sub_15E60(int a1)
{
  return sub_146C0(a1, 0)
      || sub_146C0(a1, 7u)
      || sub_146C0(a1, 0x12u)
      || sub_146C0(a1, 0x10u)
      || sub_146C0(a1, 0x14u)
      || sub_146C0(a1, 0x15u)
      || sub_146C0(a1, 9u);
}

//----- (00015EE0) --------------------------------------------------------
char sub_15EE0()
{
  unsigned int v0; // eax

  v0 = *(_DWORD *)(dword_D41A4 + 38519);
  if ( v0 <= dword_EA3E4[0] )
    return 1;
  do
  {
    if ( !*(_BYTE *)(v0 + 64) )
      dword_E8840 = v0;
    v0 = *(_DWORD *)v0;
  }
  while ( v0 > dword_EA3E4[0] );
  return 1;
}
// D41A4: using guessed type int dword_D41A4;
// E8840: using guessed type int dword_E8840;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00015F20) --------------------------------------------------------
int __cdecl sub_15F20(int a1, __int16 a2, int a3)
{
  int v3; // ebx
  int v4; // eax
  int v5; // ebx

  v3 = 80 * (__int16)a3;
  if ( (unsigned __int8)byte_DA818[v3] <= a2 )
    return 0;
  v4 = sub_146C0(a1, a3);
  if ( !v4 )
    return 0;
  sub_6D5E0(v4, a2);
  if ( !sub_15170(a1, a3) )
    return 0;
  v5 = 26 * a2 + v3;
  if ( *(_DWORD *)(a1 + 140) < *(int *)((char *)&dword_DA822 + v5)
    || *(_DWORD *)(a1 + 144) < *(int *)((char *)&dword_DA81E + v5) )
  {
    return -1;
  }
  else
  {
    return a3;
  }
}
// DA81E: using guessed type int dword_DA81E;
// DA822: using guessed type int dword_DA822;

//----- (00015FC0) --------------------------------------------------------
int __cdecl sub_15FC0(_WORD *a1)
{
  unsigned __int8 v1; // bl
  int v2; // esi
  unsigned int i; // esi
  unsigned int v5; // eax
  unsigned int k; // esi
  unsigned int v7; // eax
  int v8; // eax
  unsigned int v10; // [esp+0h] [ebp-18h]
  int v11; // [esp+4h] [ebp-14h]
  unsigned int v12; // [esp+8h] [ebp-10h]
  unsigned int v13; // [esp+Ch] [ebp-Ch]
  char *j; // [esp+10h] [ebp-8h]
  int v15; // [esp+14h] [ebp-4h]

  v10 = 0;
  v15 = 0;
  v12 = -1;
  v13 = -1;
  v1 = 0;
  v2 = dword_EA3E4[(unsigned __int16)a1[75]];
  if ( !sub_156F0((int)a1, 4u) || !sub_14C60((int)a1, v2) )
  {
    v11 = sub_146C0((int)a1, 4u);
    if ( !v11 )
      return 0;
    for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(_WORD *)(i + 26) != a1[13] && *(_BYTE *)(i + 64) <= 1u )
      {
        v5 = sub_583F0(a1 + 38, (_WORD *)(i + 76));
        if ( v5 < v13 )
        {
          v10 = i;
          v13 = v5;
        }
      }
    }
    if ( v13 > 0x1400 )
      v10 = 0;
    if ( !v10 )
      return 0;
    for ( j = (char *)&unk_D3F91; ; ++j )
    {
      v8 = *j;
      if ( v8 == -1 )
        break;
      for ( k = *(_DWORD *)(dword_D41A4 + 4 * v8 + 38403); k > dword_EA3E4[0]; k = *(_DWORD *)k )
      {
        if ( *(_WORD *)(k + 26) != a1[13] )
        {
          v7 = sub_583F0((_WORD *)(v10 + 76), (_WORD *)(k + 76));
          if ( v7 < v12 )
          {
            v15 = k;
            v12 = v7;
            v1 = *j;
          }
        }
      }
    }
    if ( !v15 || v12 >= 0x1400 || !v1 )
      return 0;
    if ( v1 < 0x10u )
    {
      if ( v1 == 2 )
LABEL_34:
        sub_6D5E0(v11, 0);
    }
    else
    {
      if ( v1 <= 0x10u )
      {
        sub_6D5E0(v11, 2);
        goto LABEL_37;
      }
      if ( v1 >= 0x13u )
      {
        if ( v1 > 0x13u )
        {
          if ( v1 == 25 )
            sub_6D5E0(v11, 1);
          goto LABEL_37;
        }
        goto LABEL_34;
      }
    }
LABEL_37:
    a1[75] = (v15 - (dword_D41A0 + 28302)) / 168;
    a1[76] = sub_14C40(v15);
    return 1;
  }
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000161A0) --------------------------------------------------------
int __cdecl sub_161A0(int a1)
{
  int v1; // esi
  int v2; // eax
  __int16 v3; // ax
  unsigned int v4; // eax
  __int16 v5; // di
  int v6; // edi
  unsigned int i; // esi
  unsigned int v8; // eax
  signed __int8 v9; // al
  __int16 v11; // ax
  __int16 v12; // ax
  unsigned int v13; // [esp+4h] [ebp-8h]
  unsigned int v14; // [esp+8h] [ebp-4h]

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v14 = -1;
  if ( sub_14C60(a1, v1) )
  {
    sub_14E10(a1, 4u);
    sub_584D0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
    v2 = *(__int16 *)(a1 + 80) - (*(__int16 *)(v1 + 80) + 512);
    if ( v2 )
    {
      if ( v2 <= 0 )
        LOWORD(v2) = -1;
      else
        LOWORD(v2) = 1;
    }
    *(_WORD *)(a1 + 80) += v2 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
    v3 = *(_WORD *)(a1 + 80) - (*(_WORD *)(v1 + 80) + 512);
    if ( *(__int16 *)(a1 + 80) != *(__int16 *)(v1 + 80) + 512 )
    {
      if ( *(__int16 *)(a1 + 80) - (*(__int16 *)(v1 + 80) + 512) <= 0 )
        v3 = -1;
      else
        v3 = 1;
    }
    *(_WORD *)(a1 + 80) += v3 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
    v4 = sub_146C0(a1, 4u);
    v13 = v4;
    if ( v4 && !*(_BYTE *)(v4 + 70) )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v5 = 2 * (*(unsigned __int16 *)(a1 + 20) % 0x9Du / 79i64);
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      *(_WORD *)(a1 + 32) += (v5 - 1) * (*(_WORD *)(a1 + 20) % 0x55u);
      *(_BYTE *)(a1 + 33) &= 7u;
    }
    v6 = 0;
    for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) && *(_BYTE *)(i + 64) <= 1u )
      {
        v8 = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
        if ( v8 < v14 )
        {
          v6 = i;
          v14 = v8;
        }
      }
    }
    if ( v6 && v14 < 0x1400 && v14 > 0xA00 )
    {
      *(_WORD *)(a1 + 150) = (v6 - (dword_D41A0 + 28302)) / 168;
      *(_WORD *)(a1 + 152) = sub_14C40(v6);
      v9 = sub_15790(a1);
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
      if ( v9 != -1 && sub_14E10(a1, v9) )
      {
LABEL_25:
        sub_16580(a1);
        return 1;
      }
    }
    else
    {
      *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v6 + 76));
      v11 = *(_WORD *)(a1 + 80) - (*(_WORD *)(v6 + 80) + 512);
      if ( *(__int16 *)(a1 + 80) != *(__int16 *)(v6 + 80) + 512 )
      {
        if ( *(__int16 *)(a1 + 80) - (*(__int16 *)(v6 + 80) + 512) <= 0 )
          v11 = -1;
        else
          v11 = 1;
      }
      *(_WORD *)(a1 + 80) += v11 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
    }
    if ( v13 )
    {
      if ( *(_BYTE *)(v13 + 70) )
        v12 = *(_WORD *)(a1 + 132);
      else
        v12 = 3 * *(_WORD *)(a1 + 132);
      *(_WORD *)(a1 + 130) = v12;
    }
    goto LABEL_25;
  }
  sub_16580(a1);
  return 0;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000164B0) --------------------------------------------------------
_BOOL1 __cdecl sub_164B0(int a1)
{
  return sub_146C0(a1, 0x11u)
      || sub_146C0(a1, 0x10u)
      || sub_146C0(a1, 0x12u)
      || sub_146C0(a1, 7u)
      || sub_146C0(a1, 9u)
      || sub_146C0(a1, 0x14u)
      || sub_146C0(a1, 0x13u)
      || sub_146C0(a1, 0x15u)
      || sub_146C0(a1, 0);
}

//----- (00016580) --------------------------------------------------------
int __cdecl sub_16580(int a1)
{
  __int16 v1; // di
  __int16 v2; // dx
  int v3; // esi
  __int16 v4; // ax
  int result; // eax
  int v6; // eax
  int v7; // eax
  unsigned __int8 v8; // [esp+0h] [ebp-4h]

  LOBYTE(v2) = 0;
  v8 = 0;
  v1 = *(_WORD *)(a1 + 28);
  HIBYTE(v2) = *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1118);
  v3 = 0;
  if ( SHIBYTE(v2) <= 2 || SHIBYTE(v2) >= 8 )
  {
    if ( *(char *)(*(_DWORD *)(a1 + 164) + 1118) <= 7 )
      v4 = (unsigned __int8)sub_169C0(a1);
    else
      v4 = 0;
  }
  else
  {
    v4 = 3;
  }
  switch ( v4 )
  {
    case 0:
      *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1118) = 0;
      return 0;
    case 1:
      v8 = sub_16730(v2, a1, 0);
      if ( v8 )
        *(_WORD *)(a1 + 28) = word_D3FCE[v8];
      goto LABEL_11;
    case 2:
      v8 = sub_16730(v2, a1, 1);
      if ( v8 )
        *(_WORD *)(a1 + 28) = word_D3FE8[v8];
      goto LABEL_11;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      result = 0;
      ++*(_BYTE *)(*(_DWORD *)(a1 + 164) + 1118);
      return result;
    default:
LABEL_11:
      if ( v8 )
      {
        v6 = *(_DWORD *)(a1 + 164);
        v3 = 1;
        if ( *(char *)(v6 + 1119) != v8 )
          *(_BYTE *)(v6 + 1119) = v8;
        if ( v1 != *(_WORD *)(a1 + 28) )
        {
          v7 = *(_DWORD *)(a1 + 164);
          *(_WORD *)(a1 + 130) = 0;
          *(_WORD *)(v7 + 12) = 0;
          *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
        }
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 28);
      }
      return v3;
  }
}
// D3FCE: using guessed type __int16 word_D3FCE[13];
// D3FE8: using guessed type __int16 word_D3FE8[14];

//----- (00016730) --------------------------------------------------------
int __usercall sub_16730@<eax>(int a1@<edx>, int a2, char a3)
{
  int v3; // eax
  int v4; // eax
  int result; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // [esp+0h] [ebp-8h]
  int v14; // [esp+4h] [ebp-4h]

  v14 = *(__int16 *)(a2 + 78) >> 8;
  v3 = *(__int16 *)(a2 + 76) >> 8;
  BYTE1(v3) = v14 - 1;
  LOWORD(a1) = 0;
  if ( byte_10B4E0[(unsigned __int16)v3] == 8 )
  {
    LOBYTE(a1) = 1;
  }
  else
  {
    BYTE1(v3) = v14 + 1;
    if ( byte_10B4E0[(unsigned __int16)v3] == 8 )
      LOBYTE(a1) = 4;
  }
  BYTE1(v3) = HIBYTE(*(_WORD *)(a2 + 78));
  if ( a3 )
    LOBYTE(v3) = v3 + 1;
  else
    LOBYTE(v3) = v3 - 1;
  if ( byte_10B4E0[(unsigned __int16)v3] == 8 )
  {
    if ( a3 )
    {
      LOBYTE(a1) = a1 | 2;
      goto LABEL_18;
    }
LABEL_17:
    LOBYTE(a1) = a1 | 8;
    goto LABEL_18;
  }
  v13 = *(__int16 *)(a2 + 76) >> 8;
  if ( a3 )
    LOBYTE(v3) = v13 - 1;
  else
    LOBYTE(v3) = v13 + 1;
  if ( byte_10B4E0[(unsigned __int16)v3] == 8 )
  {
    if ( !a3 )
    {
      LOBYTE(a1) = a1 | 2;
      goto LABEL_18;
    }
    goto LABEL_17;
  }
LABEL_18:
  if ( (_BYTE)a1 )
    return a1;
  if ( a3 )
  {
    switch ( *(_BYTE *)(*(_DWORD *)(a2 + 164) + 1119) )
    {
      case 1:
      case 9:
        v9 = *(__int16 *)(a2 + 76) >> 8;
        BYTE1(v9) = HIBYTE(*(_WORD *)(a2 + 78)) - 1;
        LOBYTE(v9) = v9 - 1;
        if ( byte_10B4E0[(unsigned __int16)v9] != 8 )
          return a1;
        LOWORD(a1) = 1544;
        result = a1;
        break;
      case 2:
      case 3:
        v10 = *(__int16 *)(a2 + 76) >> 8;
        BYTE1(v10) = HIBYTE(*(_WORD *)(a2 + 78)) - 1;
        LOBYTE(v10) = v10 + 1;
        if ( byte_10B4E0[(unsigned __int16)v10] != 8 )
          return a1;
        LOWORD(a1) = 3073;
        result = a1;
        break;
      case 4:
      case 6:
        v11 = *(__int16 *)(a2 + 76) >> 8;
        BYTE1(v11) = HIBYTE(*(_WORD *)(a2 + 78)) + 1;
        LOBYTE(v11) = v11 + 1;
        if ( byte_10B4E0[(unsigned __int16)v11] != 8 )
          return a1;
        LOWORD(a1) = 2306;
        result = a1;
        break;
      case 8:
      case 0xC:
        v12 = *(__int16 *)(a2 + 76) >> 8;
        BYTE1(v12) = HIBYTE(*(_WORD *)(a2 + 78)) + 1;
        LOBYTE(v12) = v12 - 1;
        if ( byte_10B4E0[(unsigned __int16)v12] == 8 )
          LOWORD(a1) = 772;
        return a1;
      default:
        return a1;
    }
  }
  else
  {
    switch ( *(_BYTE *)(*(_DWORD *)(a2 + 164) + 1119) )
    {
      case 1:
      case 3:
        v4 = *(__int16 *)(a2 + 76) >> 8;
        BYTE1(v4) = HIBYTE(*(_WORD *)(a2 + 78)) - 1;
        LOBYTE(v4) = v4 + 1;
        if ( byte_10B4E0[(unsigned __int16)v4] != 8 )
          return a1;
        LOWORD(a1) = 770;
        result = a1;
        break;
      case 2:
      case 6:
        v6 = *(__int16 *)(a2 + 76) >> 8;
        BYTE1(v6) = HIBYTE(*(_WORD *)(a2 + 78)) + 1;
        LOBYTE(v6) = v6 + 1;
        if ( byte_10B4E0[(unsigned __int16)v6] != 8 )
          return a1;
        LOWORD(a1) = 1540;
        result = a1;
        break;
      case 4:
        v7 = *(__int16 *)(a2 + 76) >> 8;
        BYTE1(v7) = HIBYTE(*(_WORD *)(a2 + 78)) + 1;
        LOBYTE(v7) = v7 - 1;
        if ( byte_10B4E0[(unsigned __int16)v7] != 8 )
          return a1;
        LOWORD(a1) = 3080;
        result = a1;
        break;
      case 8:
      case 9:
        v8 = *(__int16 *)(a2 + 76) >> 8;
        BYTE1(v8) = HIBYTE(*(_WORD *)(a2 + 78)) - 1;
        LOBYTE(v8) = v8 - 1;
        if ( byte_10B4E0[(unsigned __int16)v8] != 8 )
          return a1;
        LOWORD(a1) = 2305;
        result = a1;
        break;
      default:
        return a1;
    }
  }
  return result;
}

//----- (000169C0) --------------------------------------------------------
char __cdecl sub_169C0(int a1)
{
  int v1; // eax
  __int16 v2; // dx
  unsigned __int16 i; // si
  unsigned __int16 j; // si
  int v6; // eax
  char v7; // dl
  unsigned __int8 v8; // [esp+0h] [ebp-1Ch] BYREF
  unsigned __int8 v9; // [esp+1h] [ebp-1Bh]
  int v10; // [esp+4h] [ebp-18h] BYREF
  int v11; // [esp+8h] [ebp-14h] BYREF
  __int16 v12; // [esp+Ch] [ebp-10h]
  __int16 v13; // [esp+10h] [ebp-Ch]
  __int16 v14; // [esp+14h] [ebp-8h]
  __int16 v15; // [esp+18h] [ebp-4h]

  LOBYTE(v11) = HIBYTE(*(_WORD *)(a1 + 76));
  BYTE1(v11) = HIBYTE(*(_WORD *)(a1 + 78));
  LOWORD(v10) = v11;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v12 = 0;
  v15 = 0;
  v8 = HIBYTE(*(_WORD *)(v1 + 76));
  v9 = HIBYTE(*(_WORD *)(v1 + 78));
  LOBYTE(v2) = 0;
  HIBYTE(v2) = *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1118);
  switch ( HIBYTE(v2) )
  {
    case 0:
      v14 = sub_16730(v2, a1, 0);
      v13 = sub_16730(v2, a1, 1);
      if ( !(_BYTE)v13 && !(_BYTE)v14 )
        return 0;
      if ( (_BYTE)v14 )
      {
        for ( i = 0; i < 0x28u; ++i )
        {
          LOBYTE(v11) = byte_D3F96[(unsigned __int8)v14] + v11;
          BYTE1(v11) += byte_D3FA4[(unsigned __int8)v14];
          v15 = v11;
          v14 = sub_16CA0((unsigned __int8)v14, (char *)&v11, (unsigned __int8)v14, 0);
        }
      }
      if ( (_BYTE)v13 )
      {
        for ( j = 0; j < 0x28u; ++j )
        {
          LOBYTE(v10) = byte_D3FB2[(unsigned __int8)v13] + v10;
          BYTE1(v10) += byte_D3FC0[(unsigned __int8)v13];
          v12 = v10;
          v13 = sub_16CA0((unsigned __int8)v13, (char *)&v10, (unsigned __int8)v13, 1);
        }
      }
      if ( (_BYTE)v14 && (_BYTE)v13 )
      {
        v6 = *(_DWORD *)(a1 + 164);
        if ( (int)(abs32(v9 - HIBYTE(v15)) * abs32(v8 - (unsigned __int8)v15)) > (int)(abs32(v8 - (unsigned __int8)v12)
                                                                                     * abs32(v9 - HIBYTE(v12))) )
          v7 = 2;
        else
          v7 = 1;
        goto LABEL_21;
      }
      if ( !(_BYTE)v14 )
      {
        v6 = *(_DWORD *)(a1 + 164);
        v7 = 2;
LABEL_21:
        *(_BYTE *)(v6 + 1118) = v7;
        return v7;
      }
      LOBYTE(v2) = 1;
      *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1118) = 1;
      return v2;
    case 1:
      v14 = sub_16730(v2, a1, 0);
      if ( !HIBYTE(v14) || (unsigned __int16)sub_16E70((unsigned __int8 *)&v11, &v8) )
      {
        return 1;
      }
      else
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1118) = 3;
        return 3;
      }
    case 2:
      v13 = sub_16730(v2, a1, 1);
      if ( !HIBYTE(v13) || (unsigned __int16)sub_16E70((unsigned __int8 *)&v11, &v8) )
      {
        return 2;
      }
      else
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1118) = 3;
        return 3;
      }
    default:
      return v2;
  }
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00016CA0) --------------------------------------------------------
int __usercall sub_16CA0@<eax>(int a1@<edx>, char *a2, __int16 a3, char a4)
{
  unsigned __int16 v4; // ax
  char v5; // al
  unsigned __int16 v6; // ax
  char v7; // al
  unsigned __int16 v8; // ax
  char v9; // al
  char v10; // ah
  unsigned __int16 v11; // ax
  int result; // eax
  unsigned __int16 v13; // ax
  unsigned __int16 v14; // ax
  unsigned __int16 v15; // ax
  char v16; // al
  char v17; // ah
  unsigned __int16 v18; // ax
  unsigned __int16 v19; // ax
  unsigned __int16 v20; // ax
  unsigned __int16 v21; // ax

  v4 = *(_WORD *)a2 - 256;
  LOWORD(a1) = 0;
  if ( byte_10B4E0[v4] == 8 )
  {
    LOBYTE(a1) = 1;
  }
  else
  {
    HIBYTE(v4) = a2[1] + 1;
    if ( byte_10B4E0[v4] == 8 )
      LOBYTE(a1) = 4;
  }
  v5 = *a2;
  if ( a4 )
    LOBYTE(v6) = v5 + 1;
  else
    LOBYTE(v6) = v5 - 1;
  HIBYTE(v6) = a2[1];
  if ( byte_10B4E0[v6] == 8 )
  {
    if ( !a4 )
    {
      LOBYTE(a1) = a1 | 8;
      goto LABEL_18;
    }
    goto LABEL_16;
  }
  v7 = *a2;
  if ( a4 )
    LOBYTE(v8) = v7 - 1;
  else
    LOBYTE(v8) = v7 + 1;
  HIBYTE(v8) = a2[1];
  if ( byte_10B4E0[v8] == 8 )
  {
    if ( !a4 )
    {
LABEL_16:
      LOBYTE(a1) = a1 | 2;
      goto LABEL_18;
    }
    LOBYTE(a1) = a1 | 8;
  }
LABEL_18:
  if ( (_BYTE)a1 )
    return a1;
  if ( a4 )
  {
    v16 = *a2;
    v17 = a2[1];
    switch ( a3 )
    {
      case 1:
      case 9:
        HIBYTE(v18) = v17 - 1;
        LOBYTE(v18) = v16 - 1;
        if ( byte_10B4E0[v18] != 8 )
          return a1;
        LOWORD(a1) = 1544;
        result = a1;
        break;
      case 2:
      case 3:
        HIBYTE(v19) = v17 - 1;
        LOBYTE(v19) = v16 + 1;
        if ( byte_10B4E0[v19] != 8 )
          return a1;
        LOWORD(a1) = 3073;
        result = a1;
        break;
      case 4:
      case 6:
        HIBYTE(v20) = v17 + 1;
        LOBYTE(v20) = v16 + 1;
        if ( byte_10B4E0[v20] != 8 )
          return a1;
        LOWORD(a1) = 2306;
        result = a1;
        break;
      case 8:
      case 12:
        HIBYTE(v21) = v17 + 1;
        LOBYTE(v21) = v16 - 1;
        if ( byte_10B4E0[v21] == 8 )
          LOWORD(a1) = 772;
        return a1;
      default:
        return a1;
    }
  }
  else
  {
    v9 = *a2;
    v10 = a2[1];
    switch ( a3 )
    {
      case 1:
      case 3:
        HIBYTE(v11) = v10 - 1;
        LOBYTE(v11) = v9 + 1;
        if ( byte_10B4E0[v11] != 8 )
          return a1;
        LOWORD(a1) = 770;
        result = a1;
        break;
      case 2:
      case 6:
        HIBYTE(v13) = v10 + 1;
        LOBYTE(v13) = v9 + 1;
        if ( byte_10B4E0[v13] != 8 )
          return a1;
        LOWORD(a1) = 1540;
        result = a1;
        break;
      case 4:
        HIBYTE(v14) = v10 + 1;
        LOBYTE(v14) = v9 - 1;
        if ( byte_10B4E0[v14] != 8 )
          return a1;
        LOWORD(a1) = 3080;
        result = a1;
        break;
      case 8:
      case 9:
        HIBYTE(v15) = v10 - 1;
        LOBYTE(v15) = v9 - 1;
        if ( byte_10B4E0[v15] != 8 )
          return a1;
        LOWORD(a1) = 2305;
        result = a1;
        break;
      default:
        return a1;
    }
  }
  return result;
}

//----- (00016E70) --------------------------------------------------------
int __cdecl sub_16E70(unsigned __int8 *a1, unsigned __int8 *a2)
{
  __int16 v2; // cx
  __int16 v3; // si
  int v4; // ebx
  __int16 v5; // ax
  __int16 v6; // ax
  __int16 v7; // ax
  __int16 v8; // dx
  int j; // ecx
  int i; // ecx
  unsigned __int16 v13; // [esp+0h] [ebp-14h]
  unsigned __int16 v14; // [esp+0h] [ebp-14h]
  __int16 v15; // [esp+4h] [ebp-10h]
  int v16; // [esp+8h] [ebp-Ch]
  int v17; // [esp+Ch] [ebp-8h]
  __int16 v18; // [esp+10h] [ebp-4h]

  v2 = *a2 - *a1;
  v3 = a2[1] - a1[1];
  v17 = 2 * abs16(v2);
  v4 = 0;
  v16 = 2 * abs16(v3);
  if ( v2 >= 0 )
  {
    LOBYTE(v5) = (unsigned __int16)*a2 != (unsigned __int16)*a1;
    HIBYTE(v5) = 0;
    v15 = v5;
  }
  else
  {
    v15 = -1;
  }
  if ( v3 >= 0 )
  {
    LOBYTE(v6) = (unsigned __int16)a2[1] != (unsigned __int16)a1[1];
    HIBYTE(v6) = 0;
    v18 = v6;
  }
  else
  {
    v18 = -1;
  }
  v7 = *a1;
  v8 = a1[1];
  if ( (__int16)v17 <= (__int16)v16 )
  {
    for ( i = (__int16)v17 - ((__int16)v16 >> 1); ; i += v17 )
    {
      LOBYTE(v14) = v7;
      HIBYTE(v14) = v8;
      if ( byte_10B4E0[v14] == 8 )
        return v4 + 1;
      if ( v8 == a2[1] )
        break;
      if ( (i & 0x8000u) == 0 )
      {
        LOBYTE(v7) = v15 + v7;
        i -= v16;
      }
      ++v4;
      v8 += v18;
    }
    return 0;
  }
  else
  {
    for ( j = (__int16)v16 - ((__int16)v17 >> 1); ; j += v16 )
    {
      LOBYTE(v13) = v7;
      HIBYTE(v13) = v8;
      if ( byte_10B4E0[v13] == 8 )
        return v4 + 1;
      if ( v7 == *a2 )
        break;
      if ( (j & 0x8000u) == 0 )
      {
        LOBYTE(v8) = v18 + v8;
        j -= v17;
      }
      ++v4;
      v7 += v15;
    }
    return 0;
  }
}

//----- (00016FC0) --------------------------------------------------------
unsigned int __cdecl sub_16FC0(int a1, int a2)
{
  unsigned int v2; // edi
  unsigned int v3; // esi
  unsigned int v4; // ebx
  __int16 v6; // ax
  unsigned int v7; // eax

  v2 = -1;
  v3 = 0;
  v4 = *(_DWORD *)(dword_D41A4 + 38519);
  if ( v4 <= dword_EA3E4[0] )
    return 0;
  do
  {
    v6 = *(_WORD *)(v4 + 26);
    if ( v6 != *(_WORD *)(a1 + 26) && v6 != *(_WORD *)(a2 + 26) && *(_BYTE *)(v4 + 64) <= 1u )
    {
      v7 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(v4 + 76));
      if ( v7 < v2 )
      {
        v3 = v4;
        v2 = v7;
      }
    }
    v4 = *(_DWORD *)v4;
  }
  while ( v4 > dword_EA3E4[0] );
  return v3;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00017060) --------------------------------------------------------
__int16 __cdecl sub_17060(__int16 a1, __int16 a2)
{
  __int16 result; // ax
  int v3; // ebx
  int v4; // ecx
  int v5; // eax
  int v6; // edx

  result = dword_D41A4;
  if ( !*(_BYTE *)(dword_D41A4 + 178) )
  {
    v3 = ((a1 << 7) - 40960) / 320;
    if ( word_180660 == 1 )
      v4 = (25600 - (a2 << 7)) / 200;
    else
      v4 = ((a2 << 7) - 30720) / -240;
    if ( v3 < -127 )
      v3 = -127;
    if ( v3 > 127 )
      LOBYTE(v3) = 127;
    if ( v4 < -127 )
      v4 = -127;
    if ( v4 > 127 )
      LOBYTE(v4) = 127;
    v5 = dword_D41A0;
    *(_BYTE *)(dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12) + 28225) = v3;
    *(_BYTE *)(v5 + 10 * *(__int16 *)(v5 + 12) + 28226) = v4;
    *(_WORD *)(v5 + 10 * *(__int16 *)(v5 + 12) + 28228) = dword_180590;
    v6 = v5 + 10 * *(__int16 *)(v5 + 12);
    result = dword_180594;
    *(_WORD *)(v6 + 28230) = dword_180594;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 180590: using guessed type int dword_180590;
// 180594: using guessed type int dword_180594;
// 180660: using guessed type __int16 word_180660;

//----- (00017190) --------------------------------------------------------
char sub_17190()
{
  int v0; // eax
  int v1; // ecx
  int v2; // edx
  int v3; // edx
  char v4; // dl
  char v5; // cl
  int v6; // edx
  _BOOL1 v7; // dl
  int v8; // eax

  if ( (*(_BYTE *)(dword_D41A4 + 22) & 4) == 0 || (v0 = sub_473E0()) == 0 )
  {
    v1 = *(__int16 *)(dword_D41A0 + 12);
    LOBYTE(v0) = 5 * v1;
    if ( !*(_BYTE *)(dword_D41A0 + 10 * v1 + 28222) )
    {
      v2 = 2124 * v1 + dword_D41A0;
      if ( (*(_BYTE *)(v2 + 11232) & 0x20) == 0 )
      {
        v3 = dword_EA3E4[*(unsigned __int16 *)(v2 + 11240)];
        if ( byte_18069C )
        {
          LOBYTE(v0) = byte_1806E4;
          if ( (unsigned __int8)byte_1806E4 >= 0x3Cu )
          {
            if ( (unsigned __int8)byte_1806E4 <= 0x3Cu )
            {
              LOBYTE(v0) = sub_191B0(30, 2);
              byte_1806E4 = 0;
            }
            else if ( (unsigned __int8)byte_1806E4 < 0x40u )
            {
              if ( (unsigned __int8)byte_1806E4 < 0x3Eu )
              {
                LOBYTE(v0) = sub_191B0(30, 3);
                byte_1806E4 = 0;
              }
              else
              {
                if ( (unsigned __int8)byte_1806E4 <= 0x3Eu )
                  LOBYTE(v0) = sub_191B0(30, 4);
                else
                  LOBYTE(v0) = sub_191B0(30, 5);
                byte_1806E4 = 0;
              }
            }
            else if ( (unsigned __int8)byte_1806E4 <= 0x40u )
            {
              LOBYTE(v0) = sub_191B0(30, 6);
              byte_1806E4 = 0;
            }
            else if ( (unsigned __int8)byte_1806E4 < 0x42u )
            {
              LOBYTE(v0) = sub_191B0(30, 7);
              byte_1806E4 = 0;
            }
            else if ( (unsigned __int8)byte_1806E4 <= 0x42u )
            {
              LOBYTE(v0) = sub_191B0(30, 8);
              byte_1806E4 = 0;
            }
            else if ( (unsigned __int8)byte_1806E4 <= 0x43u )
            {
              LOBYTE(v0) = sub_191B0(30, 9);
              byte_1806E4 = 0;
            }
            else if ( byte_1806E4 == 68 )
            {
              LOBYTE(v0) = sub_191B0(30, 10);
              byte_1806E4 = 0;
            }
            goto LABEL_161;
          }
          if ( (unsigned __int8)byte_1806E4 >= 0x2Cu )
          {
            if ( (unsigned __int8)byte_1806E4 <= 0x2Cu )
            {
              LOBYTE(v0) = dword_D41A4;
              if ( *(char *)(dword_D41A4 + 23) < 0 )
              {
                v5 = *(_BYTE *)(dword_D41A4 + 25);
                if ( (v5 & 0x20) != 0 )
                  *(_BYTE *)(dword_D41A4 + 25) = v5 & 0xDF;
                else
                  *(_BYTE *)(dword_D41A4 + 25) = v5 | 0x20;
              }
              byte_1806E4 = 0;
              goto LABEL_161;
            }
            if ( (unsigned __int8)byte_1806E4 < 0x31u )
            {
              if ( byte_1806E4 == 47 )
              {
                LOBYTE(v0) = dword_D41A4;
                if ( *(char *)(dword_D41A4 + 23) < 0 )
                  LOBYTE(v0) = sub_191B0(4, 8);
                byte_1806E4 = 0;
              }
              goto LABEL_161;
            }
            if ( (unsigned __int8)byte_1806E4 > 0x31u )
            {
              if ( byte_1806E4 == 59 )
              {
                LOBYTE(v0) = sub_191B0(30, 1);
                byte_1806E4 = 0;
              }
              goto LABEL_161;
            }
            goto LABEL_61;
          }
          if ( (unsigned __int8)byte_1806E4 < 0x20u )
          {
            if ( byte_1806E4 == 20 )
            {
              LOBYTE(v0) = dword_D41A4;
              if ( *(char *)(dword_D41A4 + 23) < 0 )
              {
                if ( byte_18069A )
                  LOBYTE(v0) = sub_70940();
                else
                  LOBYTE(v0) = sub_191B0(4, 64);
              }
              byte_1806E4 = 0;
            }
            goto LABEL_161;
          }
          if ( (unsigned __int8)byte_1806E4 <= 0x20u )
          {
            LOBYTE(v0) = dword_D41A4;
            if ( *(char *)(dword_D41A4 + 23) < 0 )
            {
              sub_5BF10();
              LOBYTE(v0) = dword_D41A4;
              v4 = *(_BYTE *)(dword_D41A4 + 24);
              byte_18069C = 0;
              if ( (v4 & 0x10) != 0 )
                *(_BYTE *)(dword_D41A4 + 24) = v4 & 0xEF;
              else
                *(_BYTE *)(dword_D41A4 + 24) = v4 | 0x10;
            }
            byte_1806E4 = 0;
            goto LABEL_161;
          }
          if ( byte_1806E4 == 35 )
          {
            LOBYTE(v0) = dword_D41A0;
            *(_BYTE *)(dword_D41A0 + 8595) ^= 1u;
LABEL_61:
            byte_1806E4 = 0;
          }
LABEL_161:
          if ( byte_18067C )
          {
            LOBYTE(v0) = dword_D41A0;
            *((_BYTE *)&loc_36E03 + dword_D41A0 + 1) = 2;
          }
          return v0;
        }
        if ( byte_18068E || byte_18069A )
        {
          LOBYTE(v0) = byte_1806E4;
          if ( (unsigned __int8)byte_1806E4 < 0x2Eu )
          {
            if ( (unsigned __int8)byte_1806E4 < 0x20u )
            {
              if ( (unsigned __int8)byte_1806E4 < 0x12u )
              {
                if ( byte_1806E4 == 16 )
                {
                  LOBYTE(v0) = sub_191B0(2, 0);
                  byte_1806E4 = 0;
                }
              }
              else if ( (unsigned __int8)byte_1806E4 <= 0x12u )
              {
                LOBYTE(v0) = dword_D41A4;
                if ( *(char *)(dword_D41A4 + 23) < 0 )
                  LOBYTE(v0) = sub_191B0(26, 0);
                byte_1806E4 = 0;
              }
              else if ( byte_1806E4 == 19 )
              {
                LOBYTE(v0) = dword_D41A4;
                if ( *(char *)(dword_D41A4 + 23) < 0 && (*(_BYTE *)(dword_D41A4 + 22) & 0x10) == 0 )
                {
                  v6 = dword_D41A0;
                  *(_BYTE *)(dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12) + 11232) |= 0xCu;
                  LOBYTE(v0) = dword_D41A0;
                  *(_WORD *)(2124 * *(__int16 *)(v6 + 12) + dword_D41A0 + 12286) = 0;
                }
                byte_1806E4 = 0;
              }
              goto LABEL_161;
            }
            if ( (unsigned __int8)byte_1806E4 <= 0x20u )
            {
              LOBYTE(v0) = dword_D41A4;
              if ( *(char *)(dword_D41A4 + 23) < 0 )
              {
                v0 = 5 * (unsigned __int8)byte_3659D[11 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0];
                *((_BYTE *)&loc_3654B + 2 * v0 + dword_D41A0 + 2) |= 2u;
              }
            }
            else
            {
              if ( (unsigned __int8)byte_1806E4 < 0x22u )
              {
                LOBYTE(v0) = dword_D41A4;
                if ( *(char *)(dword_D41A4 + 23) < 0 )
                {
                  v0 = 2124 * *(__int16 *)(dword_D41A0 + 12);
                  *(_BYTE *)(dword_D41A0 + v0 + 11232) |= 4u;
                }
                byte_1806E4 = 0;
                goto LABEL_161;
              }
              if ( (unsigned __int8)byte_1806E4 > 0x22u )
              {
                if ( (unsigned __int8)byte_1806E4 >= 0x25u )
                {
                  if ( (unsigned __int8)byte_1806E4 <= 0x25u )
                  {
                    if ( (*(_WORD *)(dword_D41A4 + 22) & 0x8010) == 0 )
                      *(_DWORD *)(v3 + 8) = -1;
                    LOBYTE(v0) = 0;
                    byte_1806E4 = 0;
                  }
                  else if ( byte_1806E4 == 38 )
                  {
                    v0 = *(_DWORD *)(v3 + 164);
                    if ( *(_WORD *)(v0 + 58) )
                      LOBYTE(v0) = sub_191B0(42, 0);
                    byte_1806E4 = 0;
                  }
                }
                goto LABEL_161;
              }
            }
          }
          else
          {
            if ( (unsigned __int8)byte_1806E4 <= 0x2Eu )
            {
              LOBYTE(v0) = dword_D41A4;
              if ( *(char *)(dword_D41A4 + 23) < 0 )
              {
                byte_3659C[11 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0] = 1;
                LOBYTE(v0) = sub_191B0(27, 0);
              }
              byte_1806E4 = 0;
              goto LABEL_161;
            }
            if ( (unsigned __int8)byte_1806E4 >= 0x3Eu )
            {
              if ( (unsigned __int8)byte_1806E4 <= 0x3Eu )
              {
                LOBYTE(v0) = sub_1A970(12, 0, 0);
                byte_1806E4 = 0;
              }
              else if ( (unsigned __int8)byte_1806E4 < 0x40u )
              {
                LOBYTE(v0) = sub_1A970(13, 0, 0);
                byte_1806E4 = 0;
              }
              else if ( (unsigned __int8)byte_1806E4 <= 0x40u )
              {
                LOBYTE(v0) = sub_1A970(14, 0, 0);
                byte_1806E4 = 0;
              }
              else if ( (unsigned __int8)byte_1806E4 <= 0x41u )
              {
                LOBYTE(v0) = sub_1A970(15, 0, 0);
                byte_1806E4 = 0;
              }
              else if ( byte_1806E4 == 68 )
              {
                v7 = *(_BYTE *)(dword_D41A4 + 205) == 0;
                v8 = dword_D41A4;
                *(_BYTE *)(dword_D41A4 + 205) = v7;
                *(_BYTE *)(v8 + 206) = v7;
                if ( v7 && (*(_BYTE *)(v8 + 24) & 1) != 0 )
                  sub_8CD27(dword_EB394);
                LOBYTE(v0) = dword_D41A4;
                if ( !*(_BYTE *)(dword_D41A4 + 206) && (*(_BYTE *)(dword_D41A4 + 24) & 1) != 0 )
                  LOBYTE(v0) = sub_8CD27(dword_EB394 + 6 * (unsigned __int8)byte_D419E);
                byte_1806E4 = 0;
              }
              goto LABEL_161;
            }
            if ( (unsigned __int8)byte_1806E4 >= 0x3Cu )
            {
              if ( (unsigned __int8)byte_1806E4 <= 0x3Cu )
              {
                LOBYTE(v0) = sub_1A970(10, 0, 0);
              }
              else
              {
                sub_1A970(11, 0, 0);
                LOBYTE(v0) = 0;
              }
              byte_1806E4 = 0;
              goto LABEL_161;
            }
            if ( byte_1806E4 != 59 )
              goto LABEL_161;
            LOBYTE(v0) = sub_1A970(9, 0, 0);
          }
        }
        else
        {
          if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) == 0 && byte_1806E4 == 25 )
          {
            sub_18BB0();
            byte_1806E4 = 0;
          }
          if ( byte_1806E4 == 19 )
          {
            sub_1A970(16, 0, 0);
            byte_1806E4 = 0;
          }
          if ( byte_1806E4 == 57 )
          {
            sub_191B0(15, 0);
            byte_1806E4 = 0;
          }
          LOBYTE(v0) = byte_1806E4;
          if ( (unsigned __int8)byte_1806E4 >= 0x3Eu )
          {
            if ( (unsigned __int8)byte_1806E4 <= 0x3Eu )
            {
              LOBYTE(v0) = sub_1A970(4, 0, 0);
              byte_1806E4 = 0;
            }
            else if ( (unsigned __int8)byte_1806E4 < 0x40u )
            {
              sub_1A970(2, 0, 0);
              LOBYTE(v0) = 0;
              byte_1806E4 = 0;
            }
            else if ( (unsigned __int8)byte_1806E4 <= 0x40u )
            {
              LOBYTE(v0) = sub_1A970(3, 0, 0);
              byte_1806E4 = 0;
            }
            else if ( (unsigned __int8)byte_1806E4 <= 0x41u )
            {
              LOBYTE(v0) = sub_1A970(6, 0, 0);
              byte_1806E4 = 0;
            }
            else if ( byte_1806E4 == 66 )
            {
              LOBYTE(v0) = sub_1A970(17, 0, 0);
              byte_1806E4 = 0;
            }
            goto LABEL_161;
          }
          if ( (unsigned __int8)byte_1806E4 < 0x3Bu )
          {
            if ( byte_1806E4 != 31 )
              goto LABEL_161;
            LOBYTE(v0) = dword_D41A4;
            if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) == 0
              && (word_180660 & 1) != 0
              && (word_1805C2 == 1 || word_1805C2 == 8 || word_1805C2 == 12) )
            {
              LOBYTE(v0) = sub_1A970(18, 0, 0);
            }
          }
          else
          {
            if ( (unsigned __int8)byte_1806E4 <= 0x3Bu )
            {
              LOBYTE(v0) = sub_1A970(1, 0, 0);
              byte_1806E4 = 0;
              goto LABEL_161;
            }
            if ( (unsigned __int8)byte_1806E4 <= 0x3Cu )
            {
              LOBYTE(v0) = sub_1A970(5, 0, 0);
              byte_1806E4 = 0;
              goto LABEL_161;
            }
            LOBYTE(v0) = sub_1A970(7, 0, 0);
          }
        }
        byte_1806E4 = 0;
        goto LABEL_161;
      }
    }
  }
  return v0;
}
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB394: using guessed type int dword_EB394;
// 1805C2: using guessed type __int16 word_1805C2;
// 180660: using guessed type __int16 word_180660;
// 18067C: using guessed type char byte_18067C;
// 18068E: using guessed type char byte_18068E;
// 18069A: using guessed type char byte_18069A;
// 18069C: using guessed type char byte_18069C;
// 1806E4: using guessed type char byte_1806E4;

//----- (00017A00) --------------------------------------------------------
char __usercall sub_17A00@<al>(_BYTE *a1@<ebx>, int a2@<edi>, __int16 a3@<si>)
{
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // ebx
  char v9; // ch
  char v10; // dl
  char v11; // dh
  int v12; // edi
  int v13; // eax
  int v14; // ebx
  unsigned __int8 v15; // al
  char v16; // al
  int v17; // esi
  char v18; // al
  int v19; // eax
  char v20; // dl
  int v21; // ecx
  char v22; // al
  int v23; // ebx
  unsigned __int8 v24; // al
  char v25; // cl
  char v26; // al
  int v27; // eax
  int v28; // eax
  int v29; // ecx
  char v31; // [esp-4h] [ebp-Ch]
  char v32; // [esp+0h] [ebp-8h]
  char v33; // [esp+4h] [ebp-4h]

  if ( (unsigned __int8)byte_1806E4 >= 0x80u )
    byte_1806E4 = 0;
  v3 = 2124 * *(__int16 *)(dword_D41A0 + 12);
  v4 = v3 + dword_D41A0;
  if ( (*(_BYTE *)(v3 + dword_D41A0 + 11232) & 0x20) == 0 )
  {
    switch ( *(_BYTE *)(v4 + 12221) )
    {
      case 0:
      case 4:
        if ( *(_BYTE *)(dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12) + 28222) )
          goto LABEL_291;
        if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) != 0 )
          sub_197F0();
        sub_17190();
        v5 = dword_D41A0;
        v6 = *(__int16 *)(dword_D41A0 + 12);
        v7 = 5 * v6;
        v8 = dword_EA3E4[*(unsigned __int16 *)(2124 * v6 + dword_D41A0 + 11240)];
        LOBYTE(v6) = dword_18059C;
        *(_BYTE *)(dword_D41A0 + 2 * v7 + 28227) = 0;
        if ( (v6 & 0x10) != 0 )
        {
          if ( *(int *)(v8 + 8) >= 0 )
            sub_191B0(20, 5);
        }
        else if ( byte_18069C || byte_180664[(unsigned __int8)byte_EB3A7] )
        {
          if ( (unsigned __int8)byte_1806E4 < 0x1Fu )
          {
            if ( (unsigned __int8)byte_1806E4 >= 0x13u )
            {
              if ( (unsigned __int8)byte_1806E4 <= 0x13u )
              {
                byte_1806E4 = 0;
              }
              else if ( byte_1806E4 == 25 )
              {
                byte_1806E4 = 0;
              }
            }
          }
          else if ( (unsigned __int8)byte_1806E4 <= 0x1Fu )
          {
            byte_1806E4 = 0;
          }
          else if ( (unsigned __int8)byte_1806E4 >= 0x21u && (unsigned __int8)byte_1806E4 <= 0x21u )
          {
            sub_191B0(4, 32);
            byte_1806E4 = 0;
          }
          if ( (dword_18059C & 1) != 0 )
          {
            sub_18DA0(v8, 1, 1);
            LOBYTE(dword_18059C) = dword_18059C & 0xFE;
          }
          else if ( (dword_18059C & 2) != 0 )
          {
            sub_18DA0(v8, 2, 1);
            LOBYTE(dword_18059C) = dword_18059C & 0xFD;
          }
        }
        else if ( byte_18068E || byte_180664[(unsigned __int8)byte_EB3A6] )
        {
          if ( (dword_18059C & 1) != 0 )
          {
            sub_18DA0(v8, 1, 0);
            LOBYTE(dword_18059C) = dword_18059C & 0xFE;
          }
          else if ( (dword_18059C & 2) != 0 )
          {
            sub_18DA0(v8, 2, 0);
            LOBYTE(dword_18059C) = dword_18059C & 0xFD;
          }
        }
        else
        {
          if ( byte_1806E4 == 26 )
          {
            if ( !*(_BYTE *)(v5 + 8592) )
            {
              v9 = *(_BYTE *)(v5 + 8589);
              if ( v9 < 40 )
              {
                *(_BYTE *)(v5 + 8589) = v9 + 1;
                sub_2CA90((char)(v9 + 1));
              }
            }
            byte_1806E4 = 0;
          }
          if ( byte_1806E4 == 27 )
          {
            if ( !*(_BYTE *)(dword_D41A0 + 8592) )
            {
              v10 = *(_BYTE *)(dword_D41A0 + 8589);
              if ( v10 > 17 )
              {
                *(_BYTE *)(dword_D41A0 + 8589) = v10 - 1;
                sub_2CA90((char)(v10 - 1));
              }
            }
            byte_1806E4 = 0;
          }
          switch ( byte_1806E4 )
          {
            case 23:
              if ( (*(_BYTE *)(dword_D41A4 + 25) & 2) == 0 )
              {
                v11 = *(_BYTE *)(v8 + 69);
                if ( v11 != 2 && v11 != 3 )
                  sub_191B0(16, 0);
              }
              byte_1806E4 = 0;
              goto LABEL_295;
            case 1:
              sub_18B30();
              byte_1806E4 = 0;
              LOBYTE(v3) = sub_1A7A0();
              goto LABEL_305;
            case 57:
              sub_191B0(15, 0);
              byte_1806E4 = 0;
              break;
          }
          if ( (dword_18059C & 1) != 0 && (dword_18059C & 2) != 0 )
          {
            if ( *(int *)(v8 + 8) >= 0 )
              sub_191B0(20, 6);
            LOBYTE(dword_18059C) = dword_18059C & 0xFC;
          }
          if ( byte_1806E4 == byte_EB3A2 )
          {
            if ( *(int *)(v8 + 8) >= 0 )
              sub_191B0(20, 6);
            byte_1806E4 = 0;
          }
          if ( (unsigned __int8)byte_1806E4 >= 2u )
          {
            if ( (unsigned __int8)byte_1806E4 <= 9u )
            {
              sub_191B0(43, byte_1806E4 - 2);
              byte_1806E4 = 0;
            }
            else if ( byte_1806E4 == 32 )
            {
              sub_19A70();
              byte_1806E4 = 0;
            }
          }
          if ( !byte_180693 || *(_BYTE *)(dword_D41A4 + 38543) )
          {
            if ( byte_180696 && !*(_BYTE *)(dword_D41A4 + 38543) )
              sub_19CA0(2u);
          }
          else
          {
            sub_19CA0(1u);
          }
          sub_18F80(v8);
        }
        if ( byte_1806E4 && byte_E36DC[(unsigned __int8)byte_1806E4] == 8 )
        {
          sub_191B0(39, 1);
          byte_1806E4 = 0;
        }
        sub_1A8A0();
        sub_17060(dword_1805B0, dword_1805B4);
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_305;
      case 1:
        sub_17190();
        if ( ((dword_18059C & 1) == 0 || (dword_18059C & 2) == 0) && byte_1806E4 != 28 )
          goto LABEL_295;
        byte_1806E4 = 0;
        LOBYTE(dword_18059C) = dword_18059C & 0xFC;
        sub_191B0(20, 0);
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_305;
      case 3:
        if ( byte_1806E4 <= 0 )
          goto LABEL_215;
        if ( (unsigned __int8)byte_1806E4 < 0x1Cu )
        {
          if ( byte_1806E4 == 1 )
          {
            sub_191B0(18, 0);
            goto LABEL_214;
          }
          goto LABEL_205;
        }
        if ( (unsigned __int8)byte_1806E4 <= 0x1Cu )
        {
          sub_191B0(19, 0);
          goto LABEL_214;
        }
        if ( (unsigned __int8)byte_1806E4 < 0x3Bu )
          goto LABEL_205;
        if ( (unsigned __int8)byte_1806E4 <= 0x42u )
        {
          if ( byte_18068E || byte_18069A )
          {
            sub_191B0(35, byte_1806E4 - 59);
          }
          else if ( byte_1806E4 == 59 )
          {
            sub_18AA0();
          }
          byte_1806E4 = 0;
        }
        else
        {
          if ( byte_1806E4 != 67 )
          {
LABEL_205:
            v26 = byte_E36DC[(unsigned __int8)byte_1806E4];
            if ( (unsigned __int8)v26 >= 0x41u && (unsigned __int8)v26 <= 0x5Au
              || (unsigned __int8)v26 >= 0x61u && (unsigned __int8)v26 <= 0x7Au
              || (unsigned __int8)v26 >= 0x30u && (unsigned __int8)v26 <= 0x39u
              || v26 == 8
              || v26 == 32 )
            {
              sub_191B0(17, byte_E36DC[(unsigned __int8)byte_1806E4]);
            }
            goto LABEL_214;
          }
          v24 = *(_BYTE *)(v4 + 12223) + 1;
          *(_BYTE *)(v4 + 12223) = v24;
          v25 = v24;
          if ( v24 >= 4u )
            v25 = 0;
          sub_191B0(36, v25);
        }
LABEL_214:
        byte_1806E4 = 0;
LABEL_215:
        if ( (word_180660 & 1) != 0 )
          v27 = 400;
        else
          v27 = 480;
        v28 = v27 - 72;
        if ( dword_1805B0 < 4 || dword_1805B0 >= 66 || v28 + 28 > dword_1805B4 || v28 + 66 <= dword_1805B4 )
        {
          if ( dword_1805B0 < 384 || dword_1805B0 >= 654 || v28 + 26 > dword_1805B4 || v28 + 48 <= dword_1805B4 )
          {
            if ( dword_1805B0 < 82 || dword_1805B0 >= 378 || v28 + 32 > dword_1805B4 || v28 + 60 <= dword_1805B4 )
            {
              if ( dword_1805B0 < 384 || dword_1805B0 >= 440 || v28 + 4 > dword_1805B4 || v28 + 22 <= dword_1805B4 )
              {
                if ( dword_1805B0 < 474 || dword_1805B0 >= 530 || v28 + 4 > dword_1805B4 || v28 + 22 <= dword_1805B4 )
                {
                  if ( dword_1805B0 >= 564
                    && dword_1805B0 < 620
                    && v28 + 4 <= dword_1805B4
                    && v28 + 22 > dword_1805B4
                    && (dword_18059C & 1) != 0 )
                  {
                    sub_191B0(18, 0);
                  }
                }
                else if ( (dword_18059C & 1) != 0 )
                {
                  sub_191B0(44, 0);
                }
              }
              else if ( (dword_18059C & 1) != 0 )
              {
                sub_191B0(19, 0);
              }
              goto LABEL_291;
            }
            if ( dword_1805B0 < 82 || dword_1805B0 >= 150 || v28 + 32 > dword_1805B4 || v28 + 60 <= dword_1805B4 )
            {
              if ( dword_1805B0 >= 152 && dword_1805B0 < 220 && v28 + 32 <= dword_1805B4 && v28 + 60 > dword_1805B4 )
              {
                if ( *(_BYTE *)(dword_D41A4 + 10) )
                  byte_180559 = 99;
                if ( (dword_18059C & 1) != 0 )
                  sub_191B0(36, 1);
                goto LABEL_291;
              }
              if ( dword_1805B0 >= 222 && dword_1805B0 < 290 && v28 + 32 <= dword_1805B4 && v28 + 60 > dword_1805B4 )
              {
                if ( *(_BYTE *)(dword_D41A4 + 10) )
                  byte_180559 = 100;
                if ( (dword_18059C & 1) != 0 )
                  sub_191B0(36, 2);
                goto LABEL_291;
              }
              if ( dword_1805B0 < 310 || dword_1805B0 >= 378 || v28 + 32 > dword_1805B4 || v28 + 60 <= dword_1805B4 )
                goto LABEL_291;
              if ( *(_BYTE *)(dword_D41A4 + 10) )
                byte_180559 = 101;
              if ( (dword_18059C & 1) == 0 )
                goto LABEL_291;
              v31 = 3;
            }
            else
            {
              if ( *(_BYTE *)(dword_D41A4 + 10) )
                byte_180559 = 98;
              if ( (dword_18059C & 1) == 0 )
                goto LABEL_291;
              v31 = 0;
            }
            sub_191B0(36, v31);
            goto LABEL_291;
          }
          if ( *(_BYTE *)(dword_D41A4 + 10) )
            byte_180559 = 102;
          if ( (dword_18059C & 1) != 0 )
          {
            v29 = (dword_1805B0 - 384) / 34;
            if ( v29 >= *(__int16 *)(dword_D41A0 + 12) )
              LOBYTE(v29) = v29 + 1;
            sub_191B0(37, v29);
          }
        }
        else
        {
          if ( *(_BYTE *)(dword_D41A4 + 10) )
            byte_180559 = 97;
          if ( (dword_18059C & 1) != 0 )
            sub_191B0(
              35,
              4 * ((dword_1805B4 - (v28 + 28)) / 20)
            + ((dword_1805B0 - 4 - (__CFSHL__((dword_1805B0 - 4) >> 31, 4) + 16 * ((dword_1805B0 - 4) >> 31))) >> 4));
        }
LABEL_291:
        LOBYTE(dword_18059C) = dword_18059C & 0xFC;
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_305;
      case 5:
      case 8:
        v32 = 0;
        v33 = 0;
        v12 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
        LOBYTE(v13) = sub_17190();
        if ( *(int *)(v12 + 8) < 0 )
        {
          v32 = 1;
        }
        else
        {
          v14 = *(_DWORD *)(v12 + 164);
          _wcpp_1_unwind_leave__120(v13);
          v15 = *(_BYTE *)(v14 + 1111);
          a1 = (_BYTE *)(v14 + 611);
          if ( v15 )
          {
            if ( v15 <= 2u )
            {
              if ( (v15 != 1 || (dword_18059C & 4) != 0) && (a1[500] != 2 || (dword_18059C & 8) != 0) )
              {
                v22 = sub_6D4F0((int)a1, dword_1805B0);
                a1[502] = v22;
                sub_191B0(41, v22);
              }
              else
              {
                if ( a1[500] == 1 )
                  *(_BYTE *)(dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12) + 28222) = 31;
                else
                  *(_BYTE *)(dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12) + 28222) = 32;
                v21 = dword_D41A0;
                *(_BYTE *)(dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12) + 28223) = a1[501];
                *(_BYTE *)(v21 + 10 * *(__int16 *)(v21 + 12) + 28224) = a1[502];
                a1[500] = 0;
                sub_6D200(v21 + 11230 + 2124 * *(__int16 *)(v21 + 12));
              }
            }
          }
          else
          {
            v33 = 1;
            v16 = sub_6D420(dword_1805B0, dword_1805B4);
            a1[501] = v16;
            v17 = (unsigned __int8)byte_D94FF[v16];
            v18 = 1;
            if ( !*(_WORD *)&a1[2 * v17 + 208] || !byte_D41B6 && v17 == 25 )
              v18 = 0;
            if ( !v18 )
              goto LABEL_122;
            sub_6D4C0((int)a1);
            if ( (dword_18059C & 1) == 0 && (dword_18059C & 2) == 0 )
              goto LABEL_122;
            if ( byte_18068E || byte_180664[(unsigned __int8)byte_EB3A5] )
            {
              sub_191B0(38, v17);
              v19 = dword_D41A0;
              *(_BYTE *)(dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12) + 28224) = 0;
              v20 = a1[v17 + 338];
              if ( v20 )
              {
                if ( (dword_18059C & 1) != 0 )
                {
                  if ( v20 != 1 )
                    *(_BYTE *)(v19 + 10 * *(__int16 *)(v19 + 12) + 28224) = 1;
                  goto LABEL_122;
                }
                if ( v20 == 2 )
                  goto LABEL_122;
              }
              else if ( (dword_18059C & 1) != 0 )
              {
                *(_BYTE *)(v19 + 10 * *(__int16 *)(v19 + 12) + 28224) = 1;
                goto LABEL_122;
              }
              *(_BYTE *)(v19 + 10 * *(__int16 *)(v19 + 12) + 28224) = 2;
              goto LABEL_122;
            }
            if ( (dword_18059C & 1) != 0 && (dword_18059C & 2) != 0 )
            {
              sub_191B0(6, 64);
              *(_BYTE *)(10 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 28223) = a1[501];
            }
            else
            {
              a1[500] = ((dword_18059C & 1) == 0) + 1;
              sub_6D200(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230);
              sub_191B0(40, a1[501]);
              *(_BYTE *)(10 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 28224) = a1[500];
            }
          }
        }
LABEL_122:
        if ( (dword_18059C & 0x10) == 0 && (dword_18059C & 4) == 0 && (dword_18059C & 8) == 0 )
          v32 = 1;
        if ( v32 )
        {
          if ( *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) == 5 )
            sub_191B0(20, 0);
          else
            sub_191B0(20, 6);
        }
        else
        {
          if ( *(int *)(v12 + 8) >= 0 )
          {
            if ( (word_1805C0 & 1) != 0 )
              sub_191B0(6, 1);
            if ( (word_1805C0 & 2) != 0 )
              sub_191B0(6, 2);
            if ( (word_1805C0 & 4) != 0 )
              sub_191B0(6, 4);
            if ( (word_1805C0 & 8) != 0 )
              sub_191B0(6, 8);
          }
          if ( (*(_BYTE *)(dword_D41A4 + 22) & 2) != 0
            && v33
            && !*(_BYTE *)(dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12) + 28222) )
          {
            sub_191B0(40, a1[501]);
            *(_BYTE *)(dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12) + 28224) = 0;
          }
        }
        sub_17060(*(_WORD *)(*(_DWORD *)(v12 + 164) + 20), *(_WORD *)(*(_DWORD *)(v12 + 164) + 22));
        byte_1806E4 = 0;
        LOBYTE(dword_18059C) = dword_18059C & 0xFC;
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_305;
      case 6:
      case 7:
        v23 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
        if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) != 0 )
          sub_197F0();
        sub_17190();
        if ( (dword_18059C & 1) != 0 && (dword_18059C & 2) != 0 || byte_1806E4 == byte_EB3A2 || *(int *)(v23 + 8) < 0 )
        {
          sub_191B0(20, 0);
        }
        else if ( byte_1806E4 == 1 )
        {
          sub_18B30();
          byte_1806E4 = 0;
        }
        else
        {
          if ( (dword_18059C & 0x10) != 0 )
          {
            sub_191B0(20, 8);
          }
          else if ( byte_18069C || byte_180664[(unsigned __int8)byte_EB3A7] || byte_180664[(unsigned __int8)byte_EB3A4] )
          {
            if ( (dword_18059C & 1) != 0 )
            {
              sub_18DA0(v23, 1, 1);
              LOBYTE(dword_18059C) = dword_18059C & 0xFE;
            }
            else if ( (dword_18059C & 2) != 0 )
            {
              sub_18DA0(v23, 2, 1);
              LOBYTE(dword_18059C) = dword_18059C & 0xFD;
            }
            else if ( *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) != 7 )
            {
              sub_191B0(20, 7);
            }
          }
          else if ( byte_18068E || byte_180664[(unsigned __int8)byte_EB3A6] )
          {
            if ( (dword_18059C & 1) != 0 )
            {
              sub_18DA0(v23, 1, 0);
              LOBYTE(dword_18059C) = dword_18059C & 0xFE;
            }
            else if ( (dword_18059C & 2) != 0 )
            {
              sub_18DA0(v23, 2, 0);
              LOBYTE(dword_18059C) = dword_18059C & 0xFD;
            }
          }
          else if ( *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) != 6 )
          {
            sub_191B0(20, 6);
          }
          sub_18F80(v23);
        }
        if ( byte_1806E4 == 32 )
        {
          sub_19A70();
          byte_1806E4 = 0;
        }
        if ( !byte_180693 || *(_BYTE *)(dword_D41A4 + 38543) )
        {
          if ( byte_180696 && !*(_BYTE *)(dword_D41A4 + 38543) )
            sub_19CA0(2u);
        }
        else
        {
          sub_19CA0(1u);
        }
        if ( byte_1806E4 && byte_E36DC[(unsigned __int8)byte_1806E4] == 8 )
        {
          sub_191B0(39, 1);
          byte_1806E4 = 0;
        }
        sub_1A8A0();
        sub_17060(dword_1805B0, dword_1805B4);
        byte_1806E4 = 0;
        LOBYTE(dword_18059C) = dword_18059C & 0xFC;
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_305;
      case 9:
      case 0xB:
        sub_19AB0();
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_305;
      case 0xA:
      case 0xC:
        sub_1A070(a2, a3);
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_305;
      case 0xD:
      case 0xE:
        sub_19E00();
        goto LABEL_295;
      default:
LABEL_295:
        LOBYTE(v3) = sub_1A7A0();
        goto LABEL_305;
    }
  }
  if ( byte_1806E4 )
  {
    LOBYTE(v3) = byte_1806E4;
    if ( byte_1806E4 )
    {
      if ( (unsigned __int8)byte_1806E4 <= 1u )
      {
        LOBYTE(v3) = sub_18B30();
      }
      else if ( byte_1806E4 == 25 )
      {
        LOBYTE(v3) = dword_D41A4;
        if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) == 0 )
          LOBYTE(v3) = sub_18BB0();
      }
    }
    byte_1806E4 = 0;
  }
LABEL_305:
  if ( (dword_18059C & 1) == 0 )
    word_180746 = 0;
  if ( (dword_18059C & 2) == 0 )
    word_180744 = 0;
  return v3;
}
// 17EC2: variable 'v13' is possibly undefined
// 6D5D0: using guessed type int __fastcall _wcpp_1_unwind_leave__120(_DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB3A2: using guessed type char byte_EB3A2;
// EB3A4: using guessed type char byte_EB3A4;
// EB3A5: using guessed type char byte_EB3A5;
// EB3A6: using guessed type char byte_EB3A6;
// EB3A7: using guessed type char byte_EB3A7;
// 180559: using guessed type char byte_180559;
// 18059C: using guessed type int dword_18059C;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C0: using guessed type __int16 word_1805C0;
// 180660: using guessed type __int16 word_180660;
// 18068E: using guessed type char byte_18068E;
// 180693: using guessed type char byte_180693;
// 180696: using guessed type char byte_180696;
// 18069A: using guessed type char byte_18069A;
// 18069C: using guessed type char byte_18069C;
// 1806E4: using guessed type char byte_1806E4;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;

//----- (00018AA0) --------------------------------------------------------
int sub_18AA0()
{
  int result; // eax
  char v1; // bl
  char v2; // bh

  result = dword_D41A4;
  v1 = 1;
  if ( *(_BYTE *)(dword_D41A4 + 10) )
  {
    *(_BYTE *)(dword_D41A4 + 10) = 0;
  }
  else
  {
    sub_87090();
    if ( byte_180552 )
    {
      result = dword_D41A4;
      *(_BYTE *)(dword_D41A4 + 10) = 1;
    }
    else
    {
      v1 = 0;
      result = sub_19760(aNoHelpData, 3u, 50);
    }
  }
  if ( v1 )
  {
    byte_18055A = -1;
    v2 = *(_BYTE *)(dword_D41A4 + 10);
    *(_BYTE *)(dword_D41A4 + 38402) = 1;
    return sub_19760((char *)dword_E9C4C[(v2 == 0) + 400], 3u, 50);
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// E9C4C: using guessed type int dword_E9C4C[];
// 180552: using guessed type char byte_180552;
// 18055A: using guessed type char byte_18055A;

//----- (00018B30) --------------------------------------------------------
char sub_18B30()
{
  int v0; // eax
  unsigned __int8 v1; // dh

  v0 = 2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0;
  if ( (*(_BYTE *)(v0 + 11232) & 0x20) == 0 )
  {
    v1 = *(_BYTE *)(v0 + 12221);
    if ( v1 == 13 || v1 == 14 )
    {
      sub_191B0(29, 0);
      LOBYTE(v0) = sub_191B0(27, 0);
    }
    else
    {
      if ( v1 < 6u || v1 > 8u && (v1 < 0xBu || v1 > 0xCu) )
        sub_191B0(20, 13);
      else
        sub_191B0(20, 14);
      LOBYTE(v0) = dword_D41A4;
      *(_BYTE *)(dword_D41A4 + 38546) = 1;
    }
  }
  return v0;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00018BB0) --------------------------------------------------------
int sub_18BB0()
{
  int v0; // eax
  char v1; // dl
  char v2; // cl
  int v3; // eax
  int v4; // edx
  int result; // eax

  v0 = dword_D41A4;
  v1 = *(_BYTE *)(dword_D41A4 + 24) ^ 1;
  *(_BYTE *)(dword_D41A4 + 24) = v1;
  if ( (v1 & 1) != 0 )
  {
    if ( (*((_BYTE *)&loc_36E09 + dword_D41A0 + 2) & 2) != 0 )
    {
      *(_BYTE *)(v0 + 24) &= ~1u;
    }
    else
    {
      *((_BYTE *)&loc_36E03 + dword_D41A0 + 1) = 0;
      v2 = *(_BYTE *)(v0 + 206);
      byte_18055A = -1;
      if ( !v2 && (word_1805C2 == 7 || word_1805C2 == 1 || word_1805C2 == 2) )
        sub_8CD27(dword_EB394 + 6 * (unsigned __int8)byte_D419E);
      sub_41AF0();
      if ( !*(_BYTE *)(dword_D41A4 + 206) )
        sub_8CD27(dword_EB394 + 6 * (unsigned __int8)byte_D419E);
      sub_52E90(
        2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230,
        *(unsigned __int8 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221),
        1);
      if ( byte_E3799 )
        sub_8D8F0();
      if ( byte_E37FD )
        sub_8E020();
      if ( *(_BYTE *)(dword_D41A4 + 225) )
        *(_BYTE *)(dword_D41A4 + 225) = 2;
    }
  }
  else
  {
    sub_41B60();
    v3 = dword_D41A4;
    v4 = dword_EB394;
    *(_BYTE *)(dword_D41A4 + 205) = 0;
    *(_BYTE *)(v3 + 206) = 0;
    sub_8CD27(v4);
    sub_52E90(
      2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230,
      *(unsigned __int8 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221),
      1);
    if ( byte_E37FD )
      sub_8E160(*(_WORD *)(dword_D41A0 + 565), 0x7Fu);
    sub_86930(word_1803EC);
    if ( *(_BYTE *)(dword_D41A4 + 225) )
      *(_BYTE *)(dword_D41A4 + 225) = 1;
  }
  LOBYTE(result) = sub_55C00(*(_WORD *)(dword_D41A4 + 43));
  *(_BYTE *)(dword_D41A4 + 208) = result;
  return result;
}
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E3799: using guessed type char byte_E3799;
// E37FD: using guessed type char byte_E37FD;
// EB394: using guessed type int dword_EB394;
// 1803EC: using guessed type __int16 word_1803EC;
// 18055A: using guessed type char byte_18055A;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (00018DA0) --------------------------------------------------------
char __cdecl sub_18DA0(int a1, char a2, char a3)
{
  int v3; // edx
  int v4; // esi
  int v5; // eax
  int v6; // eax
  int v7; // ebx
  int v8; // edi
  int v9; // edx
  int v10; // ebx
  int v11; // esi
  int v12; // eax
  int v13; // ebx
  int v14; // edi
  int v15; // edx
  int v16; // ebx

  v3 = *(_DWORD *)(a1 + 164) + 611;
  if ( a2 == 2 )
  {
    v4 = 0;
    if ( a3 )
      v5 = -1;
    else
      v5 = 1;
    v6 = *(__int16 *)(*(_DWORD *)(a1 + 164) + 1107) + v5;
    while ( 1 )
    {
      if ( a3 || v6 < 26 )
      {
        if ( a3 == 1 && v6 < 0 )
          v6 = 25;
      }
      else
      {
        v6 = 0;
      }
      v7 = (unsigned __int8)byte_D94FF[v6];
      if ( *(_WORD *)(v3 + 2 * v7 + 208) )
      {
        v8 = v3 + v7;
        if ( *(_BYTE *)(v3 + v7 + 338) == 2 )
          break;
      }
      if ( a3 )
        v10 = -1;
      else
        v10 = 1;
      ++v4;
      v6 += v10;
      if ( v4 >= 26 )
        return v6;
    }
    *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1115) = v6;
    v9 = dword_D41A0;
    *(_BYTE *)(dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12) + 28222) = 32;
    *(_BYTE *)(v9 + 10 * *(__int16 *)(v9 + 12) + 28223) = v7;
    LOBYTE(v6) = *(_BYTE *)(v8 + 468);
    *(_BYTE *)(10 * *(__int16 *)(v9 + 12) + v9 + 28224) = v6;
  }
  else
  {
    v11 = 0;
    if ( a3 )
      v12 = -1;
    else
      v12 = 1;
    v6 = *(__int16 *)(*(_DWORD *)(a1 + 164) + 1105) + v12;
    while ( 1 )
    {
      if ( a3 || v6 < 26 )
      {
        if ( a3 == 1 && v6 < 0 )
          v6 = 25;
      }
      else
      {
        v6 = 0;
      }
      v13 = (unsigned __int8)byte_D94FF[v6];
      if ( *(_WORD *)(v3 + 2 * v13 + 208) )
      {
        v14 = v3 + v13;
        if ( *(_BYTE *)(v3 + v13 + 338) == 1 )
          break;
      }
      if ( a3 )
        v16 = -1;
      else
        v16 = 1;
      ++v11;
      v6 += v16;
      if ( v11 >= 26 )
        return v6;
    }
    *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1114) = v6;
    v15 = dword_D41A0;
    *(_BYTE *)(dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12) + 28222) = 31;
    *(_BYTE *)(v15 + 10 * *(__int16 *)(v15 + 12) + 28223) = v13;
    LOBYTE(v6) = *(_BYTE *)(v14 + 468);
    *(_BYTE *)(10 * *(__int16 *)(v15 + 12) + v15 + 28224) = v6;
  }
  return v6;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00018F80) --------------------------------------------------------
char __cdecl sub_18F80(int a1)
{
  int v1; // eax
  int v2; // edx
  int v3; // eax
  int v4; // eax
  int v5; // edx

  if ( (word_1805C0 & 1) != 0 )
    sub_191B0(6, 1);
  if ( (word_1805C0 & 2) != 0 )
    sub_191B0(6, 2);
  if ( (word_1805C0 & 4) != 0 )
    sub_191B0(6, 4);
  if ( (word_1805C0 & 8) != 0 )
    sub_191B0(6, 8);
  v1 = *(_DWORD *)(a1 + 164);
  v2 = *(__int16 *)(v1 + 1105);
  if ( v2 == -1 )
  {
    LOBYTE(dword_18059C) = dword_18059C & 0xFE;
    goto LABEL_18;
  }
  v3 = dword_EA3E4[*(__int16 *)(v1 + 2 * v2 + 819)];
  if ( *(_BYTE *)(v3 + 59) == 1 )
  {
    if ( (dword_18059C & 1) == 0 )
      goto LABEL_18;
    goto LABEL_17;
  }
  if ( (dword_18059C & 1) != 0 || (dword_18059C & 4) != 0 && *(__int16 *)(v3 + 46) > 0 )
  {
LABEL_17:
    sub_191B0(6, 16);
    LOBYTE(dword_18059C) = dword_18059C & 0xFE;
  }
LABEL_18:
  v4 = *(_DWORD *)(a1 + 164);
  v5 = *(__int16 *)(v4 + 1107);
  if ( v5 == -1 )
  {
    LOBYTE(dword_18059C) = dword_18059C & 0xFD;
    return v4;
  }
  v4 = dword_EA3E4[*(__int16 *)(v4 + 2 * v5 + 819)];
  if ( *(_BYTE *)(v4 + 59) == 1 )
  {
    if ( (dword_18059C & 2) == 0 )
      return v4;
LABEL_26:
    LOBYTE(v4) = sub_191B0(6, 32);
    LOBYTE(dword_18059C) = dword_18059C & 0xFD;
    return v4;
  }
  if ( (dword_18059C & 2) != 0 || (dword_18059C & 8) != 0 && *(__int16 *)(v4 + 46) > 0 )
    goto LABEL_26;
  return v4;
}
// EA3E4: using guessed type int dword_EA3E4[];
// 18059C: using guessed type int dword_18059C;
// 1805C0: using guessed type __int16 word_1805C0;

//----- (000191B0) --------------------------------------------------------
char __cdecl sub_191B0(__int16 a1, char a2)
{
  int v2; // edx
  char result; // al
  int v4; // esi
  int v5; // ebx
  int v6; // ebx
  int v7; // esi
  int v8; // ebx
  int v9; // ebx
  int v10; // esi
  int v11; // ecx
  int v12; // esi
  int v13; // esi
  _BYTE *v14; // ebx
  int v15; // ebx
  int v16; // ebx

  v2 = dword_D41A0;
  result = a1;
  switch ( a1 )
  {
    case 0:
    case 1:
    case 2:
    case 26:
      goto LABEL_23;
    case 3:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      goto LABEL_40;
    case 4:
      v4 = dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12);
      if ( *(char *)(v4 + 28222) != a1 && *(_BYTE *)(v4 + 28222) )
        goto LABEL_40;
      *(_BYTE *)(dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12) + 28222) = a1;
      result = a2;
      *(_BYTE *)(v2 + 10 * *(__int16 *)(v2 + 12) + 28223) |= a2;
      dword_D41A0 = v2;
      break;
    case 5:
    case 6:
      v5 = dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12);
      if ( *(char *)(v5 + 28222) != a1 && *(_BYTE *)(v5 + 28222) )
        goto LABEL_40;
      *(_BYTE *)(dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12) + 28222) = a1;
      result = a2;
      *(_BYTE *)(v2 + 10 * *(__int16 *)(v2 + 12) + 28227) |= a2;
      dword_D41A0 = v2;
      break;
    case 12:
    case 13:
    case 14:
    case 16:
    case 18:
    case 19:
    case 29:
    case 42:
    case 44:
      v13 = dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12);
      if ( *(char *)(v13 + 28222) != a1 && *(_BYTE *)(v13 + 28222) )
        goto LABEL_40;
LABEL_23:
      *(_BYTE *)(dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12) + 28222) = a1;
      dword_D41A0 = v2;
      break;
    case 15:
      v6 = dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12);
      if ( *(char *)(v6 + 28222) != a1 && *(_BYTE *)(v6 + 28222) )
        goto LABEL_40;
      v7 = *(__int16 *)(dword_D41A0 + 12);
      v8 = dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 2124 * v7 + 11240)];
      if ( *(int *)(v8 + 8) >= 0 || *(_BYTE *)(v8 + 69) != 3 )
        goto LABEL_40;
      *(_BYTE *)(dword_D41A0 + 10 * v7 + 28222) = a1;
      dword_D41A0 = v2;
      break;
    case 27:
      v9 = dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12);
      if ( *(char *)(v9 + 28222) != a1 && *(_BYTE *)(v9 + 28222) )
        goto LABEL_40;
      v10 = *(__int16 *)(dword_D41A0 + 12);
      if ( (*(_BYTE *)(dword_D41A0 + 2124 * v10 + 11232) & 2) == 0 )
        goto LABEL_40;
      *(_BYTE *)(dword_D41A0 + 10 * v10 + 28222) = a1;
      dword_D41A0 = v2;
      break;
    case 28:
      v11 = dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12);
      if ( *(char *)(v11 + 28222) != a1 && *(_BYTE *)(v11 + 28222) )
        goto LABEL_40;
      v12 = *(__int16 *)(dword_D41A0 + 12);
      if ( (*(_BYTE *)(dword_D41A0 + 2124 * v12 + 11232) & 4) == 0 )
        goto LABEL_40;
      *(_BYTE *)(dword_D41A0 + 10 * v12 + 28222) = a1;
      dword_D41A0 = v2;
      break;
    case 30:
      if ( *(char *)(dword_D41A4 + 23) < 0
        || (v14 = (_BYTE *)(dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12)), v14[12157] == 99)
        && v14[12158] == 104
        && v14[12159] == 114
        && v14[12160] == 111
        && v14[12161] == 110
        && v14[12162] == 105
        && v14[12163] == 99
        && v14[12164] == 108
        && v14[12165] == 101 )
      {
        v15 = dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12);
        if ( *(char *)(v15 + 28222) == a1 || !*(_BYTE *)(v15 + 28222) )
          goto LABEL_39;
      }
      goto LABEL_40;
    case 39:
      goto LABEL_39;
    default:
      v16 = dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12);
      if ( *(char *)(v16 + 28222) == a1 || !*(_BYTE *)(v16 + 28222) )
      {
LABEL_39:
        *(_BYTE *)(dword_D41A0 + 10 * *(__int16 *)(dword_D41A0 + 12) + 28222) = a1;
        result = a2;
        *(_BYTE *)(v2 + 10 * *(__int16 *)(v2 + 12) + 28223) = a2;
      }
LABEL_40:
      dword_D41A0 = v2;
      break;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00019760) --------------------------------------------------------
int __cdecl sub_19760(char *a1, unsigned __int8 a2, __int16 a3)
{
  char *v4; // edi
  char v5; // al
  char v6; // al
  int result; // eax

  v4 = (char *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230 + 28);
  do
  {
    v5 = *a1;
    *v4 = *a1;
    if ( !v5 )
      break;
    v6 = a1[1];
    a1 += 2;
    v4[1] = v6;
    v4 += 2;
  }
  while ( v6 );
  result = dword_D41A0;
  *(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11307) = a3;
  *(_WORD *)(2124 * *(__int16 *)(result + 12) + result + 11309) = a2;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (000197F0) --------------------------------------------------------
int sub_197F0()
{
  int result; // eax
  char v1; // bl
  int v2; // ebx
  int i; // edx
  unsigned __int8 v4; // al
  unsigned __int8 v5; // al
  int v6; // [esp+0h] [ebp-10h] BYREF
  int v7; // [esp+4h] [ebp-Ch] BYREF
  int v8; // [esp+8h] [ebp-8h] BYREF
  int v9; // [esp+Ch] [ebp-4h] BYREF

  result = dword_D41A4;
  if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) != 0 )
  {
    v1 = *(_BYTE *)(dword_D41A4 + 225);
    byte_18055A = -1;
    if ( !v1 && !*(_BYTE *)(dword_D41A4 + 38543) )
    {
      if ( *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) == 7 )
      {
        sub_8CD27(dword_EB394);
      }
      else if ( word_1805C2 == 7 || word_1805C2 == 1 || word_1805C2 == 2 )
      {
        sub_8CD27(dword_EB394 + 6 * (unsigned __int8)byte_D419E);
      }
      if ( *(_BYTE *)(dword_D41A4 + 206) )
        return sub_19A50();
      sub_2FFE0(&v8, &v9, &v6, &v7);
      if ( dword_1805B0 < v8 || v8 + v6 <= dword_1805B0 )
        return sub_19A50();
      v2 = -1;
      for ( i = 0; i < 4 && v2 < 0; ++i )
      {
        if ( v9 <= dword_1805B4 && v9 + v7 > dword_1805B4 )
          v2 = i;
        v9 += v7;
      }
      if ( v2 < 0 )
        return sub_19A50();
      if ( v2 == 2 && v8 + v6 / 2 <= dword_1805B0 )
      {
        v2 = 3;
      }
      else if ( v2 > 2 )
      {
        ++v2;
      }
      byte_18055A = v2;
      if ( (dword_18059C & 1) != 0 || (dword_18059C & 2) != 0 )
      {
        switch ( v2 )
        {
          case 0:
            v4 = *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221);
            if ( v4 < 6u || v4 > 8u )
              sub_191B0(20, 13);
            else
              sub_191B0(20, 14);
            *(_BYTE *)(dword_D41A4 + 38546) = 3;
            result = sub_19A50();
            break;
          case 1:
            if ( !*(_BYTE *)(dword_D41A4 + 208) )
              return sub_19A50();
            v5 = *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221);
            if ( v5 < 6u || v5 > 8u )
              sub_191B0(20, 13);
            else
              sub_191B0(20, 14);
            *(_BYTE *)(dword_D41A4 + 38546) = 2;
            result = sub_19A50();
            break;
          case 2:
            sub_19CA0(1u);
            result = sub_19A50();
            break;
          case 3:
            sub_19CA0(2u);
            result = sub_19A50();
            break;
          case 4:
            sub_19A70();
            return sub_19A50();
          default:
            return sub_19A50();
        }
      }
      else
      {
        return sub_19A50();
      }
    }
  }
  return result;
}
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EB394: using guessed type int dword_EB394;
// 18055A: using guessed type char byte_18055A;
// 18059C: using guessed type int dword_18059C;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (00019A50) --------------------------------------------------------
__int64 sub_19A50()
{
  __int64 result; // rax

  BYTE1(result) = dword_18059C;
  if ( (dword_18059C & 1) != 0 || (dword_18059C & 2) != 0 )
    LOBYTE(dword_18059C) = dword_18059C & 0xFC;
  return result;
}
// 18059C: using guessed type int dword_18059C;

//----- (00019A70) --------------------------------------------------------
char sub_19A70()
{
  unsigned __int8 v0; // al

  v0 = *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221);
  if ( v0 < 6u || v0 > 8u )
    return sub_191B0(20, 9);
  else
    return sub_191B0(20, 11);
}
// D41A0: using guessed type int dword_D41A0;

//----- (00019AB0) --------------------------------------------------------
__int64 sub_19AB0()
{
  int v0; // eax
  __int64 v1; // rax
  int v2; // ebx
  int v3; // edx
  int i; // eax

  if ( word_1805C2 == 7 || word_1805C2 == 1 || word_1805C2 == 2 )
    sub_8CD27(dword_EB394 + 6 * (unsigned __int8)byte_D419E);
  if ( byte_1806E4 == 1 )
  {
    sub_18B30();
    byte_1806E4 = 0;
    return sub_19A50();
  }
  if ( (dword_18059C & 1) == 0 && (dword_18059C & 2) == 0 && byte_1806E4 != 28 && byte_1806E4 != 32 )
    return sub_19A50();
  v0 = (640 - *(__int16 *)(dword_D41A4 + 186)) / 2 + (*(__int16 *)(dword_D41A4 + 186) - 82) / 2;
  if ( v0 <= dword_1805B0 && v0 + 82 > dword_1805B0 && dword_1805B4 >= 377 && dword_1805B4 < 395
    || byte_1806E4 == 28
    || byte_1806E4 == 32 )
  {
    *(_BYTE *)(dword_D41A4 + 225) = 0;
    if ( *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) == 9 )
      sub_191B0(20, 0);
    else
      sub_191B0(20, 6);
    sub_8CD27(dword_EB394);
    byte_1806E4 = 0;
    return sub_19A50();
  }
  v1 = 640 - *(__int16 *)(dword_D41A4 + 186);
  v2 = 0;
  v3 = ((int)v1 - HIDWORD(v1)) >> 1;
  for ( i = 67;
        v3 > dword_1805B0
     || v3 + *(__int16 *)(dword_D41A4 + 186) <= dword_1805B0
     || i > dword_1805B4
     || i + 18 <= dword_1805B4;
        i += 18 )
  {
    if ( ++v2 >= 17 )
      return sub_19A50();
  }
  sub_1A970(v2 + 1, (dword_18059C & 1) == 0, 1);
  sub_1A280();
  return sub_19A50();
}
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EB394: using guessed type int dword_EB394;
// 18059C: using guessed type int dword_18059C;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;
// 1806E4: using guessed type char byte_1806E4;

//----- (00019CA0) --------------------------------------------------------
void __cdecl sub_19CA0(unsigned __int8 a1)
{
  int v1; // edx
  int v2; // eax
  unsigned __int8 v3; // al
  __int16 v4; // [esp-8h] [ebp-8h]

  if ( a1 )
  {
    if ( a1 <= 1u )
    {
      if ( byte_E3798 )
      {
        *(_BYTE *)(dword_D41A4 + 38543) = a1;
        byte_E3799 = 1;
      }
    }
    else if ( a1 == 2 && byte_E37FC )
    {
      *(_BYTE *)(dword_D41A4 + 38543) = 2;
      v4 = *(_WORD *)(dword_D41A0 + 565);
      byte_E37FD = 1;
      sub_8E160(v4, 0x7Fu);
    }
  }
  v1 = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 38543) )
  {
    v2 = dword_D41A0;
    *((_BYTE *)&loc_36E03 + dword_D41A0 + 1) = 0;
    *(_BYTE *)(v1 + 38402) = 1;
    v3 = *(_BYTE *)(2124 * *(__int16 *)(v2 + 12) + v2 + 12221);
    if ( v3 < 6u || v3 > 8u )
      sub_191B0(20, 10);
    else
      sub_191B0(20, 12);
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;

//----- (00019D60) --------------------------------------------------------
int __usercall sub_19D60@<eax>(int a1@<ebx>, int a2@<esi>)
{
  unsigned __int8 v2; // dl
  int v4; // [esp+0h] [ebp-10h] BYREF
  int v5; // [esp+4h] [ebp-Ch] BYREF
  int v6; // [esp+8h] [ebp-8h] BYREF
  int v7; // [esp+Ch] [ebp-4h] BYREF

  v2 = *(_BYTE *)(dword_D41A4 + 38543);
  if ( v2 )
  {
    if ( v2 <= 1u )
    {
      a1 = 127;
      a2 = *(__int16 *)(dword_D41A4 + 6);
    }
    else if ( v2 == 2 )
    {
      a1 = 127;
      a2 = *(__int16 *)(dword_D41A4 + 8);
    }
  }
  sub_2FFE0(&v7, &v6, &v5, &v4);
  return sub_5BDC0(a2 * (v5 - 12) / a1 + 5 + v7, 9 * v4 / 2 + v6);
}
// D41A4: using guessed type int dword_D41A4;

//----- (00019E00) --------------------------------------------------------
char sub_19E00()
{
  char v0; // bl
  char v1; // bh
  int v2; // eax
  unsigned __int8 v3; // dl
  char v5[128]; // [esp+0h] [ebp-Ah] BYREF
  int v6; // [esp+80h] [ebp+76h] BYREF
  int v7; // [esp+84h] [ebp+7Ah] BYREF
  char v8; // [esp+88h] [ebp+7Eh]

  v0 = 0;
  v8 = 0;
  v1 = 0;
  LOBYTE(v2) = (unsigned __int8)sub_30BE0(&v7, &v6);
  if ( byte_1806E4 )
  {
    LOBYTE(v2) = byte_1806E4;
    if ( byte_1806E4 )
    {
      if ( (unsigned __int8)byte_1806E4 <= 1u )
      {
        v8 = 1;
      }
      else if ( byte_1806E4 == 28 )
      {
        v0 = 1;
      }
    }
    byte_1806E4 = 0;
  }
  else if ( (dword_18059C & 1) != 0 || (dword_18059C & 2) != 0 )
  {
    if ( v7 > dword_1805B0 || v7 + 50 <= dword_1805B0 || v6 > dword_1805B4 || v6 + 32 <= dword_1805B4 )
    {
      if ( v7 + 50 <= dword_1805B0 && v7 + 100 > dword_1805B0 && v6 <= dword_1805B4 && v6 + 32 > dword_1805B4 )
        v8 = 1;
    }
    else
    {
      v0 = 1;
    }
    LOBYTE(v2) = sub_19A50();
  }
  if ( !v0 )
    goto LABEL_37;
  LOBYTE(v2) = dword_D41A4;
  v3 = *(_BYTE *)(dword_D41A4 + 38546);
  if ( v3 >= 2u )
  {
    if ( v3 > 2u )
    {
      if ( v3 == 3 )
      {
        if ( sub_55080(0, *(unsigned __int16 *)(dword_D41A4 + 43)) )
          sprintf(v5, "%s:%s.", (const char *)dword_EA2EC, &aOk[1]);
        else
          sprintf(v5, "%s:%s.", (const char *)dword_EA2EC, (const char *)dword_EA300);
        sub_52D70(0, v5);
        LOBYTE(v2) = sub_55C00(*(_WORD *)(dword_D41A4 + 43));
        v1 = 1;
        *(_BYTE *)(dword_D41A4 + 208) = v2;
      }
      goto LABEL_38;
    }
    if ( *(_BYTE *)(dword_D41A4 + 208) )
    {
      if ( sub_555D0(0, *(unsigned __int16 *)(dword_D41A4 + 43)) )
        sprintf(v5, "%s:%s.", (const char *)dword_EA2E8, &aOk[1]);
      else
        sprintf(v5, "%s:%s.", (const char *)dword_EA2E8, (const char *)dword_EA300);
      LOBYTE(v2) = sub_52D70(0, v5);
    }
LABEL_37:
    v1 = 1;
    goto LABEL_38;
  }
  if ( v3 == 1 )
    LOBYTE(v2) = sub_18B30();
LABEL_38:
  if ( v0 || v8 )
  {
    v2 = dword_D41A4;
    *(_BYTE *)(dword_D41A4 + 38546) = 0;
    if ( v1 )
      LOBYTE(v2) = sub_191B0(20, *(_BYTE *)(v2 + 38544));
  }
  return v2;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;
// EA2E8: using guessed type int dword_EA2E8;
// EA2EC: using guessed type int dword_EA2EC;
// EA300: using guessed type int dword_EA300;
// 18059C: using guessed type int dword_18059C;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1806E4: using guessed type char byte_1806E4;

//----- (0001A030) --------------------------------------------------------
int sub_1A030()
{
  int v1; // [esp+0h] [ebp-8h] BYREF
  int v2; // [esp+4h] [ebp-4h] BYREF

  sub_30BE0(&v2, &v1);
  return sub_5BDC0(v2 + 87, v1 + 24);
}

//----- (0001A070) --------------------------------------------------------
void __usercall sub_1A070(int a1@<edi>, __int16 a2@<si>)
{
  unsigned __int8 v2; // al
  int v3; // eax
  int v4; // edx
  int v5; // esi
  int v6; // ebx
  int v7; // ebx
  unsigned __int8 v8; // dl
  int v9; // eax
  int v10; // [esp+0h] [ebp-10h] BYREF
  int v11; // [esp+4h] [ebp-Ch] BYREF
  int v12; // [esp+8h] [ebp-8h] BYREF
  int v13; // [esp+Ch] [ebp-4h] BYREF

  if ( word_1805C2 == 7 || word_1805C2 == 1 || word_1805C2 == 2 )
    sub_8CD27(6 * (unsigned __int8)byte_D419E + dword_EB394);
  sub_2FFE0(&v13, &v12, &v11, &v10);
  v2 = *(_BYTE *)(dword_D41A4 + 38543);
  if ( v2 )
  {
    if ( v2 <= 1u )
    {
      v3 = v11;
      v4 = v11;
    }
    else
    {
      if ( v2 != 2 )
        goto LABEL_12;
      v4 = 3 * v11;
      v3 = 3 * v11;
    }
    a1 = 127;
    a2 = (v3 - (__CFSHL__(v4 >> 31, 2) + 4 * (v4 >> 31))) >> 2;
  }
LABEL_12:
  if ( (dword_18059C & 1) != 0
    || (dword_18059C & 2) != 0
    || (dword_18059C & 4) != 0
    || (dword_18059C & 8) != 0
    || byte_180693
    || byte_180696 )
  {
    v5 = v11 - 12;
    v6 = dword_1805B0 - (v13 + 4);
    if ( v6 < 0 )
      v6 = 0;
    if ( v6 > v5 )
      v6 = v11 - 12;
    v7 = a1 * v6 / v5;
    if ( v7 < 0 )
      v7 = 0;
    if ( v7 > 127 )
      v7 = 127;
    v8 = *(_BYTE *)(dword_D41A4 + 38543);
    if ( v8 )
    {
      if ( v8 <= 1u )
      {
        sub_6E450(
          *(_WORD *)(dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12) + 11240),
          *(_WORD *)(dword_D41A0 + 12),
          8);
        sub_6E150();
        if ( *(__int16 *)(dword_D41A4 + 6) != v7 )
        {
          *(_WORD *)(dword_D41A4 + 6) = v7;
          sub_8E470((__int16)v7);
        }
      }
      else if ( v8 == 2 && *(__int16 *)(dword_D41A4 + 8) != v7 )
      {
        *(_WORD *)(dword_D41A4 + 8) = v7;
        sub_8E410((_DWORD *)(__int16)v7);
      }
    }
    sub_19A50();
  }
  else
  {
    v9 = dword_D41A4;
    *(_BYTE *)(dword_D41A4 + 38543) = byte_180693;
    sub_191B0(20, *(_BYTE *)(v9 + 38544));
    sub_8CD27(dword_EB394);
    sub_5BDC0(v13 + a2, v12 + 5 * v10 / 2);
    if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) != 0 )
    {
      sub_8D8F0();
      sub_8E020();
    }
  }
}
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EB394: using guessed type int dword_EB394;
// 18059C: using guessed type int dword_18059C;
// 1805B0: using guessed type int dword_1805B0;
// 1805C2: using guessed type __int16 word_1805C2;
// 180693: using guessed type char byte_180693;
// 180696: using guessed type char byte_180696;

//----- (0001A280) --------------------------------------------------------
int sub_1A280()
{
  int v0; // edx
  _BYTE *v1; // ebx
  char v2; // cl
  char v3; // ch
  char v4; // cl
  char v5; // ch
  int result; // eax

  v0 = dword_D41A4;
  v1 = (_BYTE *)dword_D41A0;
  *(_DWORD *)(dword_D41A4 + 192) = 0;
  v2 = *(_BYTE *)(v0 + 192) | 1;
  *(_BYTE *)(v0 + 192) = v2;
  if ( byte_E3798 )
    *(_BYTE *)(v0 + 192) = v2 | 2;
  if ( byte_E37FC )
    *(_BYTE *)(v0 + 192) |= 4u;
  if ( byte_E2A28 )
    *(_BYTE *)(v0 + 192) |= 8u;
  *(_BYTE *)(v0 + 192) |= 0xF0u;
  if ( v1[8618] )
    *(_BYTE *)(v0 + 193) |= 1u;
  if ( v1[8619] )
    *(_BYTE *)(v0 + 193) |= 4u;
  if ( v1[8620] )
    *(_BYTE *)(v0 + 193) |= 2u;
  if ( v1[8630] )
    *(_BYTE *)(v0 + 193) |= 8u;
  v3 = *(_BYTE *)(v0 + 193) | 0x10;
  *(_BYTE *)(v0 + 193) = v3;
  if ( v1[8632] )
    *(_BYTE *)(v0 + 193) = v3 | 0x20;
  if ( v1[8633] )
    *(_BYTE *)(v0 + 193) |= 0x40u;
  if ( v1[8628] )
    *(_BYTE *)(v0 + 193) |= 0x80u;
  *(_BYTE *)(v0 + 194) |= 1u;
  v4 = *(_BYTE *)(v0 + 10);
  *(_DWORD *)(v0 + 188) = 0;
  if ( v4 )
    *(_BYTE *)(v0 + 188) |= 1u;
  if ( byte_E3799 )
    *(_BYTE *)(v0 + 188) |= 2u;
  if ( byte_E37FD )
    *(_BYTE *)(v0 + 188) |= 4u;
  if ( (*(_BYTE *)(v0 + 24) & 0x40) != 0 )
    *(_BYTE *)(v0 + 188) |= 8u;
  if ( v1[(_DWORD)&loc_36DE9 + 1] )
    *(_BYTE *)(v0 + 188) |= 0x10u;
  v5 = *(_BYTE *)(v0 + 188) | 0x20;
  *(_BYTE *)(v0 + 188) = v5;
  if ( *(_BYTE *)(v0 + 178) )
    *(_BYTE *)(v0 + 188) = v5 | 0x40;
  *(_BYTE *)(v0 + 188) |= 0x80u;
  if ( v1[8586] )
    *(_BYTE *)(v0 + 189) |= 1u;
  if ( v1[8587] )
    *(_BYTE *)(v0 + 189) |= 4u;
  if ( v1[8588] )
    *(_BYTE *)(v0 + 189) |= 2u;
  if ( v1[8598] )
    *(_BYTE *)(v0 + 189) |= 8u;
  if ( v1[8590] )
    *(_BYTE *)(v0 + 189) |= 0x10u;
  if ( v1[8600] )
    *(_BYTE *)(v0 + 189) |= 0x20u;
  if ( v1[8601] )
    *(_BYTE *)(v0 + 189) |= 0x40u;
  if ( v1[8596] )
    *(_BYTE *)(v0 + 189) |= 0x80u;
  result = v0;
  if ( !*(_BYTE *)(v0 + 207) )
    *(_BYTE *)(v0 + 190) |= 1u;
  dword_D41A0 = (int)v1;
  dword_D41A4 = v0;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E2A28: using guessed type char byte_E2A28;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;

//----- (0001A4A0) --------------------------------------------------------
int sub_1A4A0()
{
  int v0; // ebx
  int i; // esi
  unsigned int v2; // kr04_4
  unsigned int v3; // kr08_4
  int v5; // [esp+0h] [ebp-8h] BYREF
  int v6; // [esp+4h] [ebp-4h] BYREF

  v0 = 0;
  for ( i = 0; i < 17; ++i )
  {
    sub_1A5B0(i + 1, &v6, &v5);
    v2 = strlen((const char *)dword_E9C4C[v6]) + 1;
    if ( (int)(8 * (v2 - 1)) > v0 )
      v0 = 8 * (v2 - 1);
    v3 = strlen((const char *)dword_E9C4C[v5]) + 1;
    if ( (int)(8 * (v3 - 1)) > v0 )
      v0 = 8 * (v3 - 1);
  }
  return 6 * ((v0 - 11) / 6 + 1) + 16;
}
// E9C4C: using guessed type int dword_E9C4C[];

//----- (0001A5B0) --------------------------------------------------------
int __cdecl sub_1A5B0(int a1, int *a2, int *a3)
{
  int result; // eax

  result = (int)a2;
  switch ( a1 )
  {
    case 1:
      *a2 = 400;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 2:
      *a2 = 390;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 3:
      *a2 = 392;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 4:
      *a2 = 469;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 5:
      *a2 = 398;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 6:
      *a2 = 7;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 7:
      *a2 = 382;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 8:
      *a2 = 13;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 9:
      *a2 = 359;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 10:
      *a2 = 363;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 11:
      *a2 = 357;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 12:
      *a2 = 395;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 13:
      *a2 = 365;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 14:
      *a2 = 441;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 15:
      *a2 = 442;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 16:
      *a2 = 468;
      switch ( a1 )
      {
        case 6:
        case 16:
          goto LABEL_20;
        case 7:
          goto LABEL_21;
        case 14:
          goto LABEL_22;
        default:
          goto LABEL_23;
      }
    case 17:
      *a2 = 402;
      break;
    default:
      break;
  }
  switch ( a1 )
  {
    case 6:
    case 16:
LABEL_20:
      result = *a2;
      *a3 = *a2;
      break;
    case 7:
LABEL_21:
      *a3 = 381;
      break;
    case 14:
LABEL_22:
      result = *a2 - 1;
      *a3 = result;
      break;
    default:
LABEL_23:
      result = *a2 + 1;
      *a3 = result;
      break;
  }
  return result;
}

//----- (0001A7A0) --------------------------------------------------------
int sub_1A7A0()
{
  int result; // eax
  int v1; // ebx
  char v2; // cl
  int v3; // edx
  __int16 v4; // dx
  int v5; // eax

  result = dword_D41A0;
  if ( *((_BYTE *)&loc_36DE9 + dword_D41A0 + 1) )
  {
    v1 = *(__int16 *)(dword_D41A0 + 12);
    v2 = *(_BYTE *)(dword_D41A0 + 2124 * v1 + 12221);
    if ( v2 != 5 && v2 != 8 && v2 != 3 && !*(_BYTE *)(dword_D41A4 + 225) )
    {
      if ( *(__int16 *)((char *)&loc_36DEC + dword_D41A0) != dword_1805B8
        || *(__int16 *)((char *)&loc_36DEC + dword_D41A0 + 2) != dword_1805BC
        || (v3 = dword_D41A0 + 10 * v1, *(_BYTE *)(v3 + 28222))
        || *(_BYTE *)(v3 + 28227) )
      {
        v5 = dword_D41A0;
      }
      else
      {
        v4 = *(_WORD *)((char *)&loc_36DEC + dword_D41A0 + 4) + 1;
        *(_WORD *)((char *)&loc_36DEC + dword_D41A0 + 4) = v4;
        if ( v4 <= 48 )
        {
LABEL_14:
          result = dword_D41A0;
          *(_WORD *)((char *)&loc_36DEC + dword_D41A0) = dword_1805B8;
          *(_WORD *)((char *)&loc_36DEC + result + 2) = dword_1805BC;
          return result;
        }
        sub_191B0(39, 0);
        v5 = dword_D41A0;
      }
      *(_WORD *)((char *)&loc_36DEC + v5 + 4) = 0;
      goto LABEL_14;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 1805B8: using guessed type int dword_1805B8;
// 1805BC: using guessed type int dword_1805BC;

//----- (0001A8A0) --------------------------------------------------------
int sub_1A8A0()
{
  char v0; // dh
  int result; // eax
  char v2; // bh
  char v3; // cl

  if ( (word_1805C0 & 4) != 0 && (word_1805C0 & 8) != 0 )
  {
    v0 = *(_BYTE *)(dword_D41A4 + 183);
    if ( (v0 & 1) == 0 && (v0 & 2) == 0 )
      sub_191B0(6, 128);
  }
  result = dword_D41A4;
  v2 = *(_BYTE *)(dword_D41A4 + 183) & 0xFC;
  v3 = word_1805C0;
  *(_BYTE *)(dword_D41A4 + 183) = v2;
  if ( (v3 & 4) != 0 )
    *(_BYTE *)(result + 183) = v2 | 1;
  if ( (word_1805C0 & 8) != 0 )
  {
    result = dword_D41A4;
    *(_BYTE *)(dword_D41A4 + 183) |= 2u;
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// 1805C0: using guessed type __int16 word_1805C0;

//----- (0001A970) --------------------------------------------------------
char __cdecl sub_1A970(char a1, int a2, int a3)
{
  int v3; // edx
  char v4; // cl
  char v6; // cl
  _BOOL1 v7; // zf
  int v8; // eax
  char v9; // cl
  char v10; // bl
  char v11; // ch
  _BOOL1 v12; // dl
  unsigned int v13; // ebx
  unsigned __int8 v14; // al
  char v15; // dl
  unsigned __int8 v16; // bl
  char v17; // bl
  char v18; // cl
  char v19; // bl
  int v20; // ebx
  char v21; // cl
  int v22; // ebx
  char v23; // cl
  _BOOL1 v24; // dl
  int v25; // ebx
  char v26; // ch
  char v27; // cl
  __int16 v28; // [esp-8h] [ebp-Ch]

  v3 = a2;
  switch ( a1 )
  {
    case 1:
      sub_18AA0();
      return 0;
    case 2:
      if ( !byte_E3798 )
        return 0;
      sub_19760((char *)dword_E9C4C[(byte_E3799 != 0) + 390], 3u, 50);
      sub_8D8F0();
      sub_86860(word_1803EC);
      byte_E3799 ^= 1u;
      return 0;
    case 3:
      if ( !byte_E37FC )
        return 0;
      if ( byte_E37FD )
      {
        sub_8E020();
        sub_19760((char *)dword_EA270, 3u, 50);
        byte_E37FD = 0;
      }
      else
      {
        v28 = *(_WORD *)(dword_D41A0 + 565);
        byte_E37FD = 1;
        sub_8E160(v28, 0x7Fu);
        sub_19760((char *)dword_EA26C, 3u, 50);
      }
      return 0;
    case 4:
      if ( !byte_E2A28 )
        return 0;
      v15 = *(_BYTE *)(dword_D41A4 + 24);
      if ( (v15 & 0x40) != 0 )
        *(_BYTE *)(dword_D41A4 + 24) = v15 & 0xBF;
      else
        *(_BYTE *)(dword_D41A4 + 24) = v15 | 0x40;
      sub_19760((char *)dword_E9C4C[((*(_BYTE *)(dword_D41A4 + 24) & 0x40) == 0) + 469], 3u, 50);
      return 0;
    case 5:
      if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
      {
        *((_BYTE *)&loc_36DE9 + dword_D41A0 + 1) = 0;
      }
      else
      {
        v12 = *((_BYTE *)&loc_36DE9 + dword_D41A0 + 1) == 0;
        *((_BYTE *)&loc_36DE9 + dword_D41A0 + 1) = v12;
        sub_19760((char *)dword_E9C4C[!v12 + 398], 3u, 50);
      }
      return 0;
    case 6:
      if ( *(_BYTE *)(dword_D41A4 + 51) < 3u || *(_BYTE *)(dword_D41A4 + 180) )
        return 0;
      *(_BYTE *)(dword_D41A4 + 38402) = 1;
      v16 = *((_BYTE *)&loc_2FED1 + dword_D41A0 + 3);
      if ( !v16 )
      {
        if ( a2 )
        {
          v3 = dword_D41A4;
          v18 = *(_BYTE *)(dword_D41A4 + 11) - 1;
          *(_BYTE *)(dword_D41A4 + 11) = v18;
          if ( v18 >= 0 )
            goto LABEL_84;
          if ( !a3 )
          {
            *(_BYTE *)(v3 + 11) = 4;
            goto LABEL_84;
          }
        }
        else
        {
          v3 = dword_D41A4;
          v17 = *(_BYTE *)(dword_D41A4 + 11) + 1;
          *(_BYTE *)(dword_D41A4 + 11) = v17;
          if ( v17 <= 4 )
            goto LABEL_84;
          if ( a3 )
          {
            *(_BYTE *)(v3 + 11) = 4;
            goto LABEL_84;
          }
        }
        *(_BYTE *)(v3 + 11) = 0;
        goto LABEL_84;
      }
      if ( v16 > 1u )
      {
        if ( v16 != 2 )
          goto LABEL_84;
        if ( a2 )
        {
          v22 = dword_D41A4;
          v23 = *(_BYTE *)(dword_D41A4 + 13) - 1;
          *(_BYTE *)(dword_D41A4 + 13) = v23;
          if ( v23 < 0 )
          {
            if ( !a3 )
            {
              *(_BYTE *)(v22 + 13) = 4;
              sub_47650(0, a2);
              return 0;
            }
            goto LABEL_83;
          }
        }
        else
        {
          v22 = dword_D41A4;
          v3 = (unsigned __int8)(*(_BYTE *)(dword_D41A4 + 13) + 1);
          *(_BYTE *)(dword_D41A4 + 13) = v3;
          if ( (char)v3 > 4 )
          {
            if ( a3 )
            {
              *(_BYTE *)(v22 + 13) = 4;
              sub_47650(a3, v3);
              return 0;
            }
LABEL_83:
            *(_BYTE *)(v22 + 13) = 0;
          }
        }
LABEL_84:
        sub_47650(a3, v3);
        return 0;
      }
      if ( a2 )
      {
        v20 = dword_D41A4;
        v21 = *(_BYTE *)(dword_D41A4 + 12) - 1;
        *(_BYTE *)(dword_D41A4 + 12) = v21;
        if ( v21 >= 0 )
          goto LABEL_84;
        if ( a3 )
        {
          *(_BYTE *)(v20 + 12) = 0;
          sub_47650(a3, a2);
        }
        else
        {
          *(_BYTE *)(v20 + 12) = 4;
          sub_47650(0, a2);
        }
        return 0;
      }
      else
      {
        v3 = dword_D41A4;
        v19 = *(_BYTE *)(dword_D41A4 + 12) + 1;
        *(_BYTE *)(dword_D41A4 + 12) = v19;
        if ( v19 <= 4 )
          goto LABEL_84;
        if ( a3 )
        {
          *(_BYTE *)(v3 + 12) = 4;
          sub_47650(a3, v3);
        }
        else
        {
          *(_BYTE *)(v3 + 12) = 0;
          sub_47650(0, v3);
        }
        return 0;
      }
    case 7:
      if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
        return 0;
      v13 = dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12) + 11240)];
      if ( v13 <= dword_EA3E4[0] || *(int *)(v13 + 8) < 0 )
        return 0;
      if ( *(_BYTE *)(dword_D41A4 + 178) )
        *(_BYTE *)(dword_D41A4 + 178) = 0;
      else
        *(_BYTE *)(dword_D41A4 + 178) = (a2 != 0) + 1;
      v14 = *(_BYTE *)(dword_D41A4 + 178);
      if ( v14 )
      {
        if ( v14 <= 1u )
        {
          sub_19760((char *)dword_EA244, 3u, 50);
        }
        else
        {
          if ( v14 != 2 )
            return 0;
          sub_19760((char *)dword_EA248, 3u, 50);
        }
        *(_WORD *)(*(_DWORD *)(v13 + 164) + 341) = 0;
        *(_WORD *)(*(_DWORD *)(v13 + 164) + 343) = 0;
        return 0;
      }
      else
      {
        sub_19760((char *)dword_EA240, 3u, 50);
        return 0;
      }
    case 8:
      v25 = dword_D41A0;
      if ( *(_BYTE *)(dword_D41A0 + 8592) )
        return 0;
      if ( a2 )
      {
        v26 = *(_BYTE *)(dword_D41A0 + 8589) + 1;
        *(_BYTE *)(dword_D41A0 + 8589) = v26;
        if ( v26 <= 40 )
          goto LABEL_95;
        if ( !a3 )
        {
          *(_BYTE *)(v25 + 8589) = 16;
          goto LABEL_95;
        }
      }
      else
      {
        v27 = *(_BYTE *)(dword_D41A0 + 8589) - 1;
        *(_BYTE *)(dword_D41A0 + 8589) = v27;
        if ( v27 >= 16 )
          goto LABEL_95;
        if ( a3 )
        {
          *(_BYTE *)(v25 + 8589) = 16;
          goto LABEL_95;
        }
      }
      *(_BYTE *)(v25 + 8589) = 40;
LABEL_95:
      sub_2CA90(*(char *)(dword_D41A0 + 8589));
      return 0;
    case 9:
      if ( !*(_BYTE *)(dword_D41A0 + 8618) )
        return 0;
      v4 = *(_BYTE *)(dword_D41A0 + 8586) ^ 1;
      *(_BYTE *)(dword_D41A0 + 8586) = v4;
      sub_19760((char *)dword_E9C4C[(v4 == 0) + 359], 3u, 50);
      return 0;
    case 10:
      if ( !*(_BYTE *)(dword_D41A0 + 8620) || !off_D41A8 )
        return 0;
      *(_BYTE *)(dword_D41A0 + 8588) ^= 1u;
      sub_19760((char *)dword_E9C4C[(*(_BYTE *)(dword_D41A0 + 8588) == 0) + 363], 3u, 50);
      return 0;
    case 11:
      if ( !*(_BYTE *)(dword_D41A0 + 8619) )
        return 0;
      v6 = *(_BYTE *)(dword_D41A0 + 8587) ^ 1;
      *(_BYTE *)(dword_D41A0 + 8587) = v6;
      sub_19760((char *)dword_E9C4C[(v6 == 0) + 357], 3u, 50);
      return 0;
    case 12:
      if ( !*(_BYTE *)(dword_D41A0 + 8630) )
        return 0;
      v7 = *(_BYTE *)(dword_D41A0 + 8598) == 1;
      *(_BYTE *)(dword_D41A0 + 8598) ^= 1u;
      sub_19760((char *)dword_E9C4C[v7 + 395], 3u, 50);
      return 0;
    case 13:
      v8 = dword_D41A0;
      v9 = *(_BYTE *)(dword_D41A0 + 8591) ^ 1;
      *(_BYTE *)(dword_D41A0 + 8590) ^= 1u;
      *(_BYTE *)(v8 + 8591) = v9;
      sub_19760((char *)dword_E9C4C[(*(_BYTE *)(v8 + 8590) == 0) + 365], 3u, 50);
      if ( *(_BYTE *)(dword_D41A0 + 8590) )
        return 0;
      sub_87C10();
      return 0;
    case 14:
      if ( !*(_BYTE *)(dword_D41A0 + 8632) )
        return 0;
      v10 = *(_BYTE *)(dword_D41A0 + 8600) ^ 1;
      *(_BYTE *)(dword_D41A0 + 8600) = v10;
      sub_19760((char *)dword_E9C4C[(v10 != 0) + 440], 3u, 50);
      return 0;
    case 15:
      if ( !*(_BYTE *)(dword_D41A0 + 8633) )
        return 0;
      v11 = *(_BYTE *)(dword_D41A0 + 8601) ^ 1;
      *(_BYTE *)(dword_D41A0 + 8601) = v11;
      sub_19760((char *)dword_E9C4C[(v11 == 0) + 442], 3u, 50);
      return 0;
    case 16:
      if ( !*(_BYTE *)(dword_D41A0 + 8628) || *(_BYTE *)(dword_D41A0 + 8592) )
        return 0;
      sub_41BC0();
      sub_46B40();
      return 0;
    case 17:
      v24 = *(_BYTE *)(dword_D41A4 + 207) == 0;
      *(_BYTE *)(dword_D41A4 + 207) = v24;
      sub_19760((char *)dword_E9C4C[v24 + 402], 3u, 50);
      return 0;
    case 18:
      v7 = *(_BYTE *)(dword_D41A0 + 8592) == 1;
      *(_BYTE *)(dword_D41A0 + 8592) ^= 1u;
      if ( v7 )
      {
        sub_417A0();
        return 0;
      }
      sub_417D0();
      return 0;
    default:
      return 0;
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41A8: using guessed type char *off_D41A8;
// E2A28: using guessed type char byte_E2A28;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E9C4C: using guessed type int dword_E9C4C[];
// EA240: using guessed type int dword_EA240;
// EA244: using guessed type int dword_EA244;
// EA248: using guessed type int dword_EA248;
// EA26C: using guessed type int dword_EA26C;
// EA270: using guessed type int dword_EA270;
// EA3E4: using guessed type int dword_EA3E4[];
// 1803EC: using guessed type __int16 word_1803EC;

//----- (0001B280) --------------------------------------------------------
int __cdecl sub_1B280(int a1)
{
  int result; // eax
  int v2; // edx
  __int16 v3; // bx
  int v4; // eax

  while ( 1 )
  {
    result = 7 * word_D4004;
    v2 = a1 + result;
    if ( word_17DB60 != *(_WORD *)(a1 + result) )
      return result;
    v3 = *(_WORD *)(v2 + 3);
    result = v3;
    if ( v3 == -1 )
      return result;
    switch ( *(_BYTE *)(v2 + 2) )
    {
      case 'A':
      case 'a':
        dword_E3844 = v3;
        ++word_D4004;
        continue;
      case 'B':
      case 'b':
        sub_8E020();
        sub_8EAD0(v3);
        ++word_D4004;
        continue;
      case 'D':
      case 'd':
        sub_8E160(*(_WORD *)(a1 + 7 * word_D4004 + 3), 0x64u);
        ++word_D4004;
        continue;
      case 'E':
      case 'e':
        sub_8D8F0();
        sub_84300(v3);
        ++word_D4004;
        continue;
      case 'F':
      case 'f':
        if ( !byte_E3798 )
          goto LABEL_35;
        sub_8F710(0, *(_WORD *)(a1 + 7 * word_D4004 + 3), 0, 4u, 1);
        ++word_D4004;
        continue;
      case 'H':
      case 'h':
        if ( !byte_E3798 )
          goto LABEL_35;
        sub_8F100(0, *(_WORD *)(a1 + 7 * word_D4004 + 3), 0, 64, 0x64u, -1, 2u);
        ++word_D4004;
        continue;
      case 'K':
      case 'W':
        sub_2EC30();
        ++word_D4004;
        continue;
      case 'L':
      case 'l':
        if ( dword_E387C )
          sub_8F0AB(dword_E3840, dword_E387C, v3);
        goto LABEL_9;
      case 'M':
      case 'Z':
      case 'm':
      case 'z':
LABEL_9:
        sub_8E160(v3, 0x7Fu);
        ++word_D4004;
        continue;
      case 'O':
      case 'o':
        if ( !byte_E3798 )
          goto LABEL_35;
        sub_8F710(0, *(_WORD *)(a1 + 7 * word_D4004 + 3), 0x7Fu, 2u, 0);
        ++word_D4004;
        continue;
      case 'P':
      case 'p':
        if ( !byte_E3798 )
          goto LABEL_35;
        sub_8F710(0, *(_WORD *)(a1 + 7 * word_D4004 + 3), 0x50u, 2u, 0);
        ++word_D4004;
        continue;
      case 'Q':
        sub_2EBB0((_BYTE *)dword_E9C4C[v3]);
        ++word_D4004;
        continue;
      case 'R':
      case 'r':
        if ( !byte_E3798 )
          goto LABEL_35;
        sub_8F100(0, v3, 127, 64, 0x64u, -1, 2u);
        ++word_D4004;
        continue;
      case 'S':
      case 's':
        if ( !byte_E3798 )
          goto LABEL_35;
        v4 = a1 + 7 * word_D4004;
        if ( !*(_DWORD *)(v4 + 3) )
          goto LABEL_17;
        sub_8F100(0, *(_WORD *)(v4 + 3), 127, 64, 0x64u, 0, 2u);
        ++word_D4004;
        break;
      case 'T':
      case 't':
        if ( !byte_E3798 )
          goto LABEL_35;
        if ( v3 )
        {
          sub_8F420(0, v3);
          ++word_D4004;
        }
        else
        {
LABEL_17:
          sub_8D8F0();
          ++word_D4004;
        }
        break;
      case 'U':
        sub_2EBB0((_BYTE *)dword_E9C4C[v3]);
        goto LABEL_35;
      case 'V':
        if ( !byte_D41C0 )
          goto LABEL_35;
        sub_2EB60();
        ++word_D4004;
        break;
      case 'X':
      case 'x':
        sub_8E020();
        ++word_D4004;
        continue;
      case 'Y':
        sub_2EC60();
        ++word_D4004;
        continue;
      default:
LABEL_35:
        ++word_D4004;
        break;
    }
  }
}
// D4004: using guessed type __int16 word_D4004;
// D41C0: using guessed type char byte_D41C0;
// E3798: using guessed type char byte_E3798;
// E3840: using guessed type int dword_E3840;
// E3844: using guessed type int dword_E3844;
// E387C: using guessed type int dword_E387C;
// E9C4C: using guessed type int dword_E9C4C[];
// 17DB60: using guessed type __int16 word_17DB60;

//----- (0001B5F0) --------------------------------------------------------
int sub_1B5F0()
{
  __int16 i; // ax
  unsigned int j; // edx
  __int16 v2; // bx
  unsigned int k; // edx
  __int16 v4; // bx

  for ( i = 0; i < 29; ++i )
  {
    if ( (unsigned __int16)i < 0xAu )
      goto LABEL_9;
    if ( (unsigned __int16)i <= 0xAu )
      continue;
    if ( i == 27 )
    {
      for ( j = *(_DWORD *)(dword_D41A4 + 38511); j > dword_EA3E4[0]; j = *(_DWORD *)j )
      {
        v2 = *(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240);
        *(_BYTE *)(j + 69) = -35;
        *(_WORD *)(j + 36) = v2;
      }
    }
    else
    {
LABEL_9:
      for ( k = *(_DWORD *)(dword_D41A4 + 4 * i + 38403); k > dword_EA3E4[0]; k = *(_DWORD *)k )
      {
        v4 = *(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240);
        *(_DWORD *)(k + 8) = -1;
        *(_WORD *)(k + 36) = v4;
      }
    }
  }
  return 0;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001B6B0) --------------------------------------------------------
__int16 __usercall sub_1B6B0@<ax>(__int16 result@<ax>, int a2)
{
  int v2; // esi
  int v3; // esi
  __int16 v4; // ax
  int v5; // esi
  int v6; // edi

  v2 = dword_EA3E4[*(unsigned __int16 *)(a2 + 50)];
  if ( *(_BYTE *)(v2 + 63) != 5 )
    result = sub_57F10(a2);
  if ( *(_BYTE *)(a2 + 57) )
  {
    *(_WORD *)(a2 + 28) = sub_581E0((_WORD *)(a2 + 76), (_WORD *)(v2 + 76));
    *(_WORD *)(a2 + 30) = sub_58210((_WORD *)(a2 + 76), (_WORD *)(v2 + 76));
    v3 = v2 + 76;
    *(_DWORD *)&word_EB398 = *(_DWORD *)v3;
    *(&word_EB398 + 2) = *(_WORD *)(v3 + 4);
    v4 = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), -*(_WORD *)(a2 + 54));
    result = sub_57CF0(v4, a2, (int)&word_EB398);
    if ( *(_WORD *)(a2 + 98) )
    {
      v5 = *(_DWORD *)(a2 + 94);
      v6 = *(_DWORD *)(a2 + 8);
      result = *(_WORD *)(a2 + 98);
      *(_WORD *)(a2 + 98) = 0;
      *(_WORD *)(a2 + 38) = result;
      *(_DWORD *)(a2 + 8) = v6 - v5;
    }
    else
    {
      *(_WORD *)(a2 + 38) = 0;
    }
  }
  else if ( (*(_BYTE *)(a2 + 62) & 3) == 0 )
  {
    sub_57CF0(result, a2, v2 + 76);
    result = *(_WORD *)(v2 + 28);
    *(_WORD *)(a2 + 28) = result;
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (0001B7A0) --------------------------------------------------------
signed int __cdecl sub_1B7A0(__int16 *a1)
{
  int v1; // eax
  unsigned __int16 v2; // dx
  unsigned __int16 v3; // bx
  unsigned __int8 v4; // cl
  unsigned __int16 v5; // bx
  int v6; // esi
  int v7; // ebx
  signed int v8; // ecx
  signed int v9; // ebx

  v1 = *a1 >> 8;
  BYTE1(v1) = HIBYTE(a1[1]);
  v2 = v1;
  LOBYTE(v1) = v1 + 1;
  v3 = v1;
  ++BYTE1(v1);
  v4 = byte_11B4E0[v3];
  v5 = v1;
  LOBYTE(v2) = byte_11B4E0[v2];
  LOBYTE(v1) = v1 - 1;
  HIBYTE(v2) = byte_11B4E0[v5];
  v6 = (unsigned __int8)byte_11B4E0[(unsigned __int16)v1];
  v7 = (unsigned __int8)v2 + v4 - v6;
  v8 = abs32((unsigned __int8)v2 + v6 - v4 - HIBYTE(v2));
  v9 = abs32(v7 - HIBYTE(v2));
  if ( v8 > v9 )
    return v8;
  return v9;
}

//----- (0001B830) --------------------------------------------------------
signed int __cdecl sub_1B830(_WORD *a1)
{
  unsigned __int16 v1; // ax
  unsigned __int16 v2; // dx
  unsigned __int16 v3; // bx
  unsigned __int8 v4; // cl
  unsigned __int16 v5; // bx
  int v6; // esi
  int v7; // ebx
  signed int v8; // ecx
  signed int v9; // ebx

  LOBYTE(v1) = HIBYTE(*a1) - 1;
  HIBYTE(v1) = HIBYTE(a1[1]) - 1;
  v2 = v1;
  LOBYTE(v1) = v1 + 2;
  v3 = v1;
  HIBYTE(v1) += 2;
  v4 = byte_11B4E0[v3];
  v5 = v1;
  LOBYTE(v2) = byte_11B4E0[v2];
  LOBYTE(v1) = v1 - 2;
  HIBYTE(v2) = byte_11B4E0[v5];
  v6 = (unsigned __int8)byte_11B4E0[v1];
  v7 = (unsigned __int8)v2 + v4 - v6;
  v8 = abs32((unsigned __int8)v2 + v6 - v4 - HIBYTE(v2));
  v9 = abs32(v7 - HIBYTE(v2));
  if ( v8 > v9 )
    return v8;
  return v9;
}

//----- (0001B8C0) --------------------------------------------------------
int __cdecl sub_1B8C0(int a1)
{
  char v1; // ah
  char v2; // dl
  int result; // eax
  __int16 *v4; // eax
  __int16 v5; // ax
  int v6; // eax
  __int16 v7; // ax
  signed int v8; // esi
  signed int v9; // eax
  __int16 v10; // ax
  char v11; // ch
  __int16 v12; // ax
  __int16 *v13; // eax
  __int16 v14; // ax
  signed int v15; // esi
  signed int v16; // eax
  __int16 v17; // ax
  __int16 *v18; // eax
  __int16 v19; // ax
  signed int v20; // esi
  __int16 v21; // ax
  __int16 *v22; // eax
  __int16 v23; // ax
  signed int v24; // esi
  __int16 v25; // ax
  int v26; // ebx
  int v27; // [esp-Ch] [ebp-10h]
  int v28; // [esp-Ch] [ebp-10h]
  int v29; // [esp-Ch] [ebp-10h]
  int v30; // [esp-Ch] [ebp-10h]
  int v31; // [esp-8h] [ebp-Ch]
  int v32; // [esp-8h] [ebp-Ch]
  int v33; // [esp-8h] [ebp-Ch]
  int v34; // [esp-8h] [ebp-Ch]
  __int16 v35; // [esp-4h] [ebp-8h]
  __int16 v36; // [esp-4h] [ebp-8h]
  __int16 v37; // [esp-4h] [ebp-8h]
  __int16 v38; // [esp-4h] [ebp-8h]
  __int16 v39; // [esp+0h] [ebp-4h]

  v1 = *(_BYTE *)(a1 + 13);
  if ( (v1 & 8) != 0 )
  {
    v2 = v1 & 0xF7;
    result = 4;
    *(_BYTE *)(a1 + 13) = v2;
  }
  else if ( *(_BYTE *)(a1 + 64) == 27 )
  {
    return (unsigned __int8)sub_2AF10(a1, 1);
  }
  else
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v4 = *(__int16 **)(a1 + 160);
    v35 = v4[7];
    v31 = v4[5];
    v27 = v4[6];
    v5 = sub_10C40(&word_EB398);
    sub_580E0((int)&word_EB398, v5, v27, v31, v35);
    sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
    if ( *(__int16 *)(a1 + 76) >> 8 == word_EB398 >> 8 && (v6 = word_EB39A >> 8, *(__int16 *)(a1 + 78) >> 8 == v6) )
    {
      sub_57CF0(v6, a1, (int)&word_EB398);
      v7 = *(_WORD *)(a1 + 28)
         + sub_58350(
             *(_WORD *)(a1 + 28),
             *(_WORD *)(a1 + 32),
             *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 4),
             *(_WORD *)(*(_DWORD *)(a1 + 160) + 2));
      HIBYTE(v7) &= 7u;
      *(_BYTE *)(a1 + 14) &= ~4u;
      *(_WORD *)(a1 + 28) = v7;
      return 1;
    }
    else if ( sub_102D0(a1, &word_EB398, 1)
           || (v8 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 16), v9 = sub_1B7A0(&word_EB398), v9 >= v8) )
    {
      *(_BYTE *)(a1 + 14) |= 4u;
      v39 = *(_WORD *)(a1 + 28);
      LOBYTE(v12) = v39 + 85;
      HIBYTE(v12) = ((unsigned __int16)(v39 + 341) >> 8) & 7;
      *(_WORD *)(a1 + 28) = v12;
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      v13 = *(__int16 **)(a1 + 160);
      v36 = v13[7];
      v32 = v13[5];
      v28 = v13[6];
      v14 = sub_10C40(&word_EB398);
      sub_580E0((int)&word_EB398, v14, v28, v32, v36);
      sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
      if ( !sub_102D0(a1, &word_EB398, 1) )
      {
        v15 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 16);
        v16 = sub_1B7A0(&word_EB398);
        if ( v16 < v15 )
          goto LABEL_18;
      }
      LOBYTE(v17) = v39 - 85;
      HIBYTE(v17) = ((unsigned __int16)(v39 - 341) >> 8) & 7;
      *(_WORD *)(a1 + 28) = v17;
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      v18 = *(__int16 **)(a1 + 160);
      v37 = v18[7];
      v33 = v18[5];
      v29 = v18[6];
      v19 = sub_10C40(&word_EB398);
      sub_580E0((int)&word_EB398, v19, v29, v33, v37);
      sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
      if ( !sub_102D0(a1, &word_EB398, 1) )
      {
        v20 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 16);
        v16 = sub_1B7A0(&word_EB398);
        if ( v16 < v20 )
          goto LABEL_18;
      }
      LOBYTE(v21) = v39;
      HIBYTE(v21) = (HIBYTE(v39) + 4) & 7;
      *(_WORD *)(a1 + 28) = v21;
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      v22 = *(__int16 **)(a1 + 160);
      v38 = v22[7];
      v34 = v22[5];
      v30 = v22[6];
      v23 = sub_10C40(&word_EB398);
      sub_580E0((int)&word_EB398, v23, v30, v34, v38);
      sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
      if ( sub_102D0(a1, &word_EB398, 1)
        || (v24 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 16), v16 = sub_1B7A0(&word_EB398), v16 >= v24) )
      {
        if ( (*(_BYTE *)(*(_DWORD *)(a1 + 160) + 32) & 1) != 0 || sub_104D0((__int16 *)(a1 + 76)) == 1 )
          *(_DWORD *)(a1 + 8) = -1;
        if ( *(_DWORD *)(a1 + 8) == -1 )
        {
          v26 = *(_DWORD *)((char *)&loc_364D1 + dword_D41A0 + 1);
          if ( v26 )
            *(_DWORD *)((char *)&loc_364D1 + dword_D41A0 + 1) = v26 - 1;
        }
        return 4;
      }
      else
      {
LABEL_18:
        sub_57CF0(v16, a1, (int)&word_EB398);
        v25 = *(_WORD *)(a1 + 28)
            + sub_58350(
                *(_WORD *)(a1 + 28),
                *(_WORD *)(a1 + 32),
                *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 4),
                *(_WORD *)(*(_DWORD *)(a1 + 160) + 2));
        HIBYTE(v25) &= 7u;
        *(_WORD *)(a1 + 28) = v25;
        return 3;
      }
    }
    else
    {
      sub_57CF0(v9, a1, (int)&word_EB398);
      v10 = *(_WORD *)(a1 + 28)
          + sub_58350(
              *(_WORD *)(a1 + 28),
              *(_WORD *)(a1 + 32),
              *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 4),
              *(_WORD *)(*(_DWORD *)(a1 + 160) + 2));
      HIBYTE(v10) &= 7u;
      v11 = *(_BYTE *)(a1 + 14) & 0xFB;
      *(_WORD *)(a1 + 28) = v10;
      result = 2;
      *(_BYTE *)(a1 + 14) = v11;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;

//----- (0001BD90) --------------------------------------------------------
int __cdecl sub_1BD90(int a1, char a2)
{
  unsigned int v2; // esi
  __int16 v3; // ax
  int i; // eax
  int v5; // edx
  int v6; // eax
  char v7; // al
  int v8; // esi
  unsigned int j; // esi
  int v10; // edi
  unsigned int v11; // edi
  __int16 v12; // ax
  int v14; // [esp+0h] [ebp-10h]
  unsigned int v15; // [esp+4h] [ebp-Ch]
  unsigned int v16; // [esp+8h] [ebp-8h]
  unsigned int v17; // [esp+Ch] [ebp-4h]

  v2 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v3 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v2 = 1;
    *(_WORD *)(a1 + 38) = v3;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        v2 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      if ( (*(_BYTE *)(*(_DWORD *)(a1 + 160) + 32) & 8) != 0 )
        v7 = a2 + 6;
      else
        v7 = a2 + 2;
    }
    else
    {
      v7 = a2 + 4;
    }
    goto LABEL_32;
  }
  v8 = *(_DWORD *)(a1 + 160);
  if ( (*(_BYTE *)(v8 + 32) & 4) == 0 && !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(v8 + 26)) )
  {
    v16 = -1;
    v15 = *(__int16 *)(v8 + 28) * *(__int16 *)(v8 + 28);
    v17 = 0;
    for ( j = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
    {
      if ( !*(_WORD *)(j + 50) && j != a1 )
      {
        v10 = (__int16)(*(_WORD *)(j + 76) - *(_WORD *)(a1 + 76));
        v11 = (__int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78)) * (__int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78))
            + v10 * v10;
        if ( v11 <= v15 )
        {
          v14 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 30);
          v12 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(j + 76));
          if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v12) < v14 && v11 < v16 )
          {
            v17 = j;
            v16 = v11;
          }
        }
      }
    }
    if ( v17 )
    {
      *(_WORD *)(a1 + 50) = (int)(v17 - (dword_D41A0 + 28302)) / 168;
      v7 = a2 + 3;
LABEL_32:
      *(_BYTE *)(a1 + 69) = v7;
    }
  }
  return sub_1EEE0(a1);
}
// 1BE25: conditional instruction was optimized away because esi.4==2
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001BF90) --------------------------------------------------------
void __cdecl sub_1BF90(int a1, char a2)
{
  unsigned int v2; // esi
  __int16 v3; // ax
  int i; // eax
  int v5; // edx
  int v6; // eax
  char v7; // al
  char v8; // al
  unsigned __int16 v9; // ax
  char v10; // cl
  int v11; // eax
  unsigned int v12; // esi
  int v13; // edi
  unsigned int v14; // edi
  __int16 v15; // ax
  int v16; // eax
  unsigned int j; // esi
  int v18; // edi
  unsigned int v19; // edi
  __int16 v20; // ax
  unsigned int v21; // [esp+0h] [ebp-1Ch]
  int v22; // [esp+4h] [ebp-18h]
  int v23; // [esp+4h] [ebp-18h]
  unsigned int v24; // [esp+8h] [ebp-14h]
  unsigned int v25; // [esp+Ch] [ebp-10h]
  unsigned int v26; // [esp+10h] [ebp-Ch]
  unsigned int v27; // [esp+14h] [ebp-8h]
  unsigned int v28; // [esp+18h] [ebp-4h]

  v2 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v3 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v2 = 1;
    *(_WORD *)(a1 + 38) = v3;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        v2 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v2 )
  {
    if ( v2 > 1 )
    {
      v7 = a2 + 4;
LABEL_46:
      *(_BYTE *)(a1 + 69) = v7;
      return;
    }
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
    if ( (*(_BYTE *)(*(_DWORD *)(a1 + 160) + 32) & 8) != 0 )
      v8 = a2 + 6;
    else
      v8 = a2 + 2;
    *(_BYTE *)(a1 + 69) = v8;
    sub_1EEE0(a1);
  }
  else
  {
    sub_1B8C0(a1);
    if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v9 = *(_WORD *)(a1 + 20);
      *(_WORD *)(a1 + 20) = 9377 * v9 + 9439;
      *(_WORD *)(a1 + 32) += ((unsigned __int8)*(_WORD *)(a1 + 20) + 85) * (2 * ((int)(v9 % 0x9Du) / 79) - 1);
      v10 = *(_BYTE *)(a1 + 57);
      *(_BYTE *)(a1 + 33) &= 7u;
      if ( v10 )
      {
        v11 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
        v21 = -1;
        v24 = 0;
        v12 = *(_DWORD *)(dword_D41A4 + 38519);
        v27 = v11 * v11;
        while ( v12 > dword_EA3E4[0] )
        {
          v13 = (__int16)(*(_WORD *)(v12 + 76) - *(_WORD *)(a1 + 76));
          v14 = (__int16)(*(_WORD *)(v12 + 78) - *(_WORD *)(a1 + 78))
              * (__int16)(*(_WORD *)(v12 + 78) - *(_WORD *)(a1 + 78))
              + v13 * v13;
          if ( v14 <= v27 && (*(_BYTE *)(v12 + 12) & 0x20) == 0 )
          {
            v22 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 30);
            v15 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v12 + 76));
            if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v15) < v22 && v14 < v21 )
            {
              v24 = v12;
              v21 = v14;
            }
          }
          v12 = *(_DWORD *)v12;
        }
        if ( v24 )
        {
          *(_WORD *)(a1 + 150) = (int)(v24 - (dword_D41A0 + 28302)) / 168;
          if ( (*(_BYTE *)(*(_DWORD *)(a1 + 160) + 32) & 8) != 0 )
            *(_BYTE *)(a1 + 69) = a2 + 6;
          else
            *(_BYTE *)(a1 + 69) = a2 + 2;
        }
        else
        {
          v16 = *(_DWORD *)(a1 + 160);
          if ( (*(_BYTE *)(v16 + 32) & 4) == 0 )
          {
            v28 = -1;
            v26 = *(__int16 *)(v16 + 28) * *(__int16 *)(v16 + 28);
            v25 = 0;
            for ( j = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
            {
              if ( !*(_WORD *)(j + 50) && j != a1 )
              {
                v18 = (__int16)(*(_WORD *)(j + 76) - *(_WORD *)(a1 + 76));
                v19 = (__int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78))
                    * (__int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78))
                    + v18 * v18;
                if ( v19 <= v26 )
                {
                  v23 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 30);
                  v20 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(j + 76));
                  if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v20) < v23 && v19 < v28 )
                  {
                    v25 = j;
                    v28 = v19;
                  }
                }
              }
            }
            if ( v25 )
            {
              *(_WORD *)(a1 + 50) = (int)(v25 - (dword_D41A0 + 28302)) / 168;
              v7 = a2 + 3;
              goto LABEL_46;
            }
          }
        }
      }
    }
  }
}
// 1C025: conditional instruction was optimized away because esi.4==2
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001C310) --------------------------------------------------------
int __cdecl sub_1C310(int a1, char a2, unsigned __int16 (__cdecl *a3)(int, int))
{
  int v3; // edi
  unsigned int v4; // eax
  __int16 v5; // ax
  int i; // edx
  int v7; // edx
  int v8; // ecx
  int v10; // eax
  int v11; // esi
  __int16 v12; // ax
  int v13; // edx
  unsigned int j; // ecx
  __int64 v15; // rax
  __int64 v16; // rax
  int v17; // ecx
  unsigned int v18; // edx

  v3 = 0;
  v4 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    v5 = *(_WORD *)(a1 + 98);
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    *(_WORD *)(a1 + 38) = v5;
    *(_WORD *)(a1 + 98) = 0;
    v4 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v8 + 52) )
    {
      v8 = dword_EA3E4[i];
      if ( v8 == dword_EA3E4[0] )
        break;
      v7 = *(_DWORD *)(v8 + 8);
      if ( v7 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v7;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v8 + 38);
        v4 = 1;
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v4 = 2;
  }
  if ( v4 )
  {
    if ( v4 <= 1 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      sub_1EEE0(a1);
      return 0;
    }
    *(_BYTE *)(a1 + 69) = a2 + 4;
  }
  else
  {
    sub_1B8C0(a1);
    v10 = sub_1ED30(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
    v11 = v10;
    if ( v10 == dword_EA3E4[0] || *(int *)(v10 + 8) < 0 || (*(_BYTE *)(v10 + 13) & 4) != 0 )
    {
      *(_BYTE *)(a1 + 69) = a2 + 1;
      return 0;
    }
    if ( (*(_BYTE *)(a1 + 62) & 3) == 0 )
    {
      v12 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v10 + 76));
      v13 = dword_D41A4;
      *(_WORD *)(a1 + 32) = v12;
      for ( j = *(_DWORD *)(v13 + 4 * *(char *)(a1 + 64) + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
      {
        if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26) )
        {
          v15 = *(__int16 *)(a1 + 76) - *(__int16 *)(j + 76);
          if ( (int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) < *(__int16 *)(a1 + 84) )
          {
            v16 = *(__int16 *)(a1 + 78) - *(__int16 *)(j + 78);
            if ( (int)((HIDWORD(v16) ^ v16) - HIDWORD(v16)) < *(__int16 *)(a1 + 84) )
            {
              *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
              break;
            }
          }
        }
      }
    }
    v17 = *(_DWORD *)(a1 + 160);
    if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(v17 + 26)) )
    {
      v18 = *(__int16 *)(v17 + 28);
      if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v11 + 76)) >= v18 )
      {
        *(_BYTE *)(a1 + 69) = a2 + 1;
        return 0;
      }
      if ( a3(a1, v11) )
        return 1;
    }
  }
  return v3;
}
// 1C3A7: conditional instruction was optimized away because eax.4==2
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001C560) --------------------------------------------------------
char __cdecl sub_1C560(int a1, unsigned __int16 a2)
{
  unsigned __int16 v2; // dx
  char v3; // al
  int v4; // esi
  __int16 v5; // cx
  __int16 v6; // ax
  int i; // eax
  int v8; // edx
  int v9; // eax
  int v10; // eax
  char v11; // al
  __int16 v12; // ax
  int v13; // eax
  char v14; // al
  int v15; // eax
  char v16; // al
  unsigned int v17; // ecx
  __int64 v18; // rax
  __int64 v19; // rax
  _BOOL1 v21; // [esp+4h] [ebp-4h]

  v2 = *(_WORD *)(a1 + 50);
  if ( !v2 )
  {
    v3 = a2;
LABEL_55:
    LOBYTE(v12) = v3 + 1;
LABEL_56:
    *(_BYTE *)(a1 + 69) = v12;
    return v12;
  }
  v4 = dword_EA3E4[v2];
  v21 = *(int *)(v4 + 8) >= 0
     && (*(_BYTE *)(v4 + 13) & 4) == 0
     && *(_BYTE *)(v4 + 63) == *(_BYTE *)(a1 + 63)
     && *(_BYTE *)(v4 + 64) == *(_BYTE *)(a1 + 64);
  v5 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v6 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v5 = 1;
    *(_WORD *)(a1 + 38) = v6;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v9 + 52) )
    {
      v9 = dword_EA3E4[i];
      if ( v9 == dword_EA3E4[0] )
        break;
      v8 = *(_DWORD *)(v9 + 8);
      if ( v8 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v8;
        v5 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v9 + 38);
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    v5 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v5 )
  {
    if ( (unsigned __int16)v5 > 1u )
    {
      if ( v21 )
      {
        *(_WORD *)(v4 + 150) = *(_WORD *)(a1 + 38);
        v10 = *(_DWORD *)(v4 + 160);
        *(_WORD *)(v4 + 50) = 0;
        if ( (*(_BYTE *)(v10 + 32) & 8) != 0 )
          v11 = a2 + 6;
        else
          v11 = a2 + 2;
        *(_BYTE *)(v4 + 69) = v11;
      }
      *(_WORD *)(a1 + 50) = 0;
      LOBYTE(v12) = a2 + 4;
      goto LABEL_56;
    }
    if ( v21 )
    {
      *(_WORD *)(v4 + 150) = *(_WORD *)(a1 + 38);
      v13 = *(_DWORD *)(v4 + 160);
      *(_WORD *)(v4 + 50) = 0;
      if ( (*(_BYTE *)(v13 + 32) & 8) != 0 )
        v14 = a2 + 6;
      else
        v14 = a2 + 2;
      *(_BYTE *)(v4 + 69) = v14;
    }
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
    v15 = *(_DWORD *)(a1 + 160);
    *(_WORD *)(a1 + 50) = 0;
    if ( (*(_BYTE *)(v15 + 32) & 8) != 0 )
      v16 = a2 + 6;
    else
      v16 = a2 + 2;
    *(_BYTE *)(a1 + 69) = v16;
    LOBYTE(v12) = sub_1EEE0(a1);
  }
  else
  {
    sub_1B8C0(a1);
    if ( !v21 )
    {
      v3 = a2;
      *(_WORD *)(a1 + 50) = 0;
      goto LABEL_55;
    }
    v12 = *(unsigned __int8 *)(a1 + 62) / *(__int16 *)(*(_DWORD *)(a1 + 160) + 26);
    if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
    {
      switch ( *(unsigned __int8 *)(v4 + 69) - a2 )
      {
        case 0:
        case 1:
          goto LABEL_43;
        case 2:
          *(_WORD *)(a1 + 150) = *(_WORD *)(v4 + 150);
          *(_WORD *)(a1 + 50) = 0;
          LOBYTE(v12) = a2 + 2;
          *(_BYTE *)(a1 + 69) = a2 + 2;
          return v12;
        case 3:
          *(_WORD *)(a1 + 50) = *(_WORD *)(v4 + 50);
LABEL_43:
          *(_WORD *)(a1 + 32) = sub_581E0(
                                  (_WORD *)(a1 + 76),
                                  (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 50)] + 76));
          v17 = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403);
          break;
        case 6:
          *(_WORD *)(a1 + 150) = *(_WORD *)(v4 + 150);
          *(_WORD *)(a1 + 50) = 0;
          LOBYTE(v12) = a2 + 6;
          *(_BYTE *)(a1 + 69) = a2 + 6;
          return v12;
        default:
          *(_WORD *)(a1 + 50) = 0;
          LOBYTE(v12) = a2 + 1;
          *(_BYTE *)(a1 + 69) = a2 + 1;
          return v12;
      }
      while ( v17 > dword_EA3E4[0] )
      {
        if ( *(_WORD *)(v17 + 26) != *(_WORD *)(a1 + 26) )
        {
          v18 = *(__int16 *)(a1 + 76) - *(__int16 *)(v17 + 76);
          if ( (int)((HIDWORD(v18) ^ v18) - HIDWORD(v18)) < 256 )
          {
            v19 = *(__int16 *)(a1 + 78) - *(__int16 *)(v17 + 78);
            if ( (int)((HIDWORD(v19) ^ v19) - HIDWORD(v19)) < 256 )
            {
              *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(v17 + 76), (_WORD *)(a1 + 76));
              break;
            }
          }
        }
        v17 = *(_DWORD *)v17;
      }
      v12 = *(_WORD *)(v4 + 134) + *(_WORD *)(v4 + 130);
      *(_WORD *)(a1 + 130) = v12;
    }
  }
  return v12;
}
// 1C63A: conditional instruction was optimized away because cx.2==2
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001C890) --------------------------------------------------------
int __cdecl sub_1C890(int a1, char a2)
{
  int result; // eax
  int i; // edx
  __int16 v4; // bx
  int v5; // edx
  int v6; // edx
  unsigned int v7; // edx
  char v8; // bl

  result = a1;
  for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
  {
    v5 = dword_EA3E4[i];
    if ( v5 == dword_EA3E4[0] )
      break;
    *(_BYTE *)(v5 + 69) = a2 + 5;
    v4 = *(_WORD *)(v5 + 36);
    if ( v4 )
      *(_WORD *)(a1 + 36) = v4;
  }
  HIWORD(v6) = HIWORD(dword_EA3E4[0]) ^ HIWORD(v5);
  LOWORD(v6) = *(_WORD *)(a1 + 36);
  v7 = dword_EA3E4[v6];
  if ( v7 > dword_EA3E4[0]
    && *(_BYTE *)(v7 + 63) == 3
    && !*(_BYTE *)(v7 + 64)
    && *(_WORD *)(a1 + 26) != *(_WORD *)(v7 + 26) )
  {
    v8 = *(_BYTE *)(a1 + 64);
    if ( v8 != 12 && v8 != 13 && v8 != 14 && v8 != 15 && v8 != 9 )
      ++*(_DWORD *)(*(_DWORD *)(v7 + 164) + 373);
  }
  *(_BYTE *)(a1 + 69) = a2 + 5;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001C930) --------------------------------------------------------
void __cdecl sub_1C930(int a1)
{
  int v1; // eax

  if ( (*(_BYTE *)(a1 + 62) & 7) == 0 )
  {
    sub_36BA0(a1, 0);
    if ( (*(_BYTE *)(a1 + 14) & 0x10) == 0 )
    {
      v1 = sub_4A190(a1 + 76, 10, 1);
      if ( v1 )
        *(_WORD *)(v1 + 26) = *(_WORD *)(a1 + 26);
    }
    sub_57F10(a1);
  }
}

//----- (0001C980) --------------------------------------------------------
int __cdecl sub_1C980(int a1, char a2)
{
  unsigned int v2; // ecx
  __int16 v3; // ax
  int i; // eax
  int v5; // edx
  int v6; // eax
  char v7; // al
  unsigned int v9; // eax
  unsigned int v10; // esi
  __int16 v11; // ax
  int v12; // edx
  int v13; // eax
  unsigned int j; // ecx
  __int64 v15; // rax
  __int64 v16; // rax
  int v17; // ecx
  unsigned int v18; // edx

  v2 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    v3 = *(_WORD *)(a1 + 98);
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    *(_WORD *)(a1 + 38) = v3;
    v2 = 1;
    *(_WORD *)(a1 + 98) = 0;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        v2 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      sub_1EEE0(a1);
      return 0;
    }
    v7 = a2 + 4;
  }
  else
  {
    sub_1B8C0(a1);
    v9 = sub_1ED30(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
    v10 = v9;
    if ( v9 > dword_EA3E4[0] && *(int *)(v9 + 8) >= 0 && (*(_BYTE *)(v9 + 13) & 4) == 0 )
    {
      if ( (*(_BYTE *)(a1 + 62) & 3) == 0 )
      {
        v11 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v9 + 76));
        HIBYTE(v11) += 4;
        *(_WORD *)(a1 + 32) = v11;
        v12 = 4 * *(char *)(a1 + 64);
        v13 = dword_D41A4;
        *(_BYTE *)(a1 + 33) &= 7u;
        for ( j = *(_DWORD *)(v12 + v13 + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
        {
          if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26) )
          {
            v15 = *(__int16 *)(a1 + 76) - *(__int16 *)(j + 76);
            if ( (int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) < *(__int16 *)(a1 + 84) )
            {
              v16 = *(__int16 *)(a1 + 78) - *(__int16 *)(j + 78);
              if ( (int)((HIDWORD(v16) ^ v16) - HIDWORD(v16)) < *(__int16 *)(a1 + 84) )
              {
                *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
                break;
              }
            }
          }
        }
      }
      v17 = *(_DWORD *)(a1 + 160);
      if ( *(unsigned __int8 *)(a1 + 62) % *(__int16 *)(v17 + 26) )
        return 0;
      v18 = *(__int16 *)(v17 + 28);
      if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v10 + 76)) < v18 )
        return 0;
    }
    v7 = a2 + 1;
  }
  *(_BYTE *)(a1 + 69) = v7;
  return 0;
}
// 1CA1A: conditional instruction was optimized away because ecx.4==2
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001CC20) --------------------------------------------------------
int __cdecl sub_1CC20(_WORD *a1, unsigned int a2)
{
  _WORD *v2; // esi
  int v3; // edi
  int v4; // eax
  int v5; // ebx
  char v6; // al

  v2 = a1 + 38;
  v3 = 0;
  v4 = sub_4A190((int)(a1 + 38), 9, 0);
  v5 = v4;
  if ( v4 )
  {
    *(_BYTE *)(v4 + 67) = 10;
    *(_BYTE *)(v4 + 68) = 0;
    *(_WORD *)(v4 + 26) = a1[13];
    *(_WORD *)(v4 + 28) = sub_581E0(v2, (_WORD *)(a2 + 76));
    *(_WORD *)(v5 + 30) = sub_58210(v2, (_WORD *)(a2 + 76));
    *(_WORD *)(v5 + 80) += a1[44];
    *(_WORD *)(v5 + 150) = a1[75];
    *(_DWORD *)(v5 + 160) = &unk_D8478;
    *(_BYTE *)(v5 + 66) = *(_BYTE *)(a2 + 64);
    v6 = *(_BYTE *)(a2 + 63);
    *(_WORD *)(v5 + 42) = 500;
    v3 = 1;
    *(_BYTE *)(v5 + 65) = v6;
    sub_5EF70(a2);
  }
  return v3;
}

//----- (0001CCE0) --------------------------------------------------------
int __cdecl sub_1CCE0(_WORD *a1, unsigned int a2)
{
  _WORD *v2; // edi
  int v3; // esi
  int v4; // ebx
  char v5; // al

  v2 = a1 + 38;
  v3 = 0;
  v4 = sub_4A190((int)(a1 + 38), 9, 13);
  if ( v4 )
  {
    *(_WORD *)(v4 + 26) = a1[13];
    *(_WORD *)(v4 + 28) = sub_581E0(v2, (_WORD *)(a2 + 76));
    *(_WORD *)(v4 + 30) = sub_58210(v2, (_WORD *)(a2 + 76));
    *(_WORD *)(v4 + 80) += (__int16)a1[44] / 2;
    *(_WORD *)(v4 + 150) = a1[75];
    *(_BYTE *)(v4 + 66) = *(_BYTE *)(a2 + 64);
    v5 = *(_BYTE *)(a2 + 63);
    *(_WORD *)(v4 + 42) = 250;
    *(_BYTE *)(v4 + 65) = v5;
    sub_49E10((_WORD *)v4, 195);
    v3 = 1;
    sub_5EF70(a2);
  }
  return v3;
}

//----- (0001CDA0) --------------------------------------------------------
int __cdecl sub_1CDA0(_WORD *a1, unsigned int a2)
{
  int v2; // edi
  int v3; // ebx
  _WORD *v5; // [esp+4h] [ebp-4h]

  v2 = 0;
  v5 = a1 + 38;
  v3 = sub_4A190((int)(a1 + 38), 9, 13);
  if ( v3 )
  {
    *(_WORD *)(v3 + 26) = a1[13];
    *(_WORD *)(v3 + 28) = sub_581E0(v5, (_WORD *)(a2 + 76));
    *(_WORD *)(v3 + 30) = sub_58210(v5, (_WORD *)(a2 + 76));
    *(_WORD *)(v3 + 80) += a1[44];
    *(_WORD *)(v3 + 150) = a1[75];
    *(_BYTE *)(v3 + 66) = *(_BYTE *)(a2 + 64);
    *(_BYTE *)(v3 + 65) = *(_BYTE *)(a2 + 63);
    if ( a1[74] )
      *(_WORD *)(v3 + 42) = 600;
    else
      *(_WORD *)(v3 + 42) = 400;
    sub_49E10((_WORD *)v3, 203);
    v2 = 1;
    sub_5EF70(a2);
  }
  return v2;
}

//----- (0001CE80) --------------------------------------------------------
int __cdecl sub_1CE80(int a1, int a2)
{
  int v2; // ebx

  v2 = 0;
  if ( (int)sub_583F0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76)) < 1024 )
  {
    v2 = 1;
    sub_11900(a1, a2, 0, *(_WORD *)(a1 + 42));
  }
  return v2;
}

//----- (0001CED0) --------------------------------------------------------
int __cdecl sub_1CED0(int a1, int a2)
{
  int v2; // ebx

  v2 = 0;
  if ( (int)sub_583F0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76)) < 768 )
  {
    v2 = 1;
    sub_11900(a1, a2, 0, *(_WORD *)(a1 + 42));
  }
  return v2;
}

//----- (0001CF20) --------------------------------------------------------
int __cdecl sub_1CF20(int a1, int a2)
{
  int v2; // ebx

  v2 = 0;
  if ( (int)sub_583F0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76)) < 1536 )
  {
    v2 = 1;
    sub_11900(a1, a2, 0, *(_WORD *)(a1 + 42));
  }
  return v2;
}

//----- (0001D0E0) --------------------------------------------------------
int __cdecl sub_1D0E0(_WORD *a1, unsigned int a2)
{
  _WORD *v2; // esi
  int v3; // edi
  int v4; // eax
  int v5; // ebx
  char v6; // al

  v2 = a1 + 38;
  v3 = 0;
  v4 = sub_4A190((int)(a1 + 38), 9, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_BYTE *)(v4 + 67) = 10;
    *(_BYTE *)(v4 + 68) = 65;
    *(_WORD *)(v4 + 26) = a1[13];
    *(_WORD *)(v4 + 28) = sub_581E0(v2, (_WORD *)(a2 + 76));
    *(_WORD *)(v5 + 30) = sub_58210(v2, (_WORD *)(a2 + 76));
    *(_WORD *)(v5 + 80) += a1[44];
    *(_WORD *)(v5 + 150) = a1[75];
    *(_DWORD *)(v5 + 160) = &unk_D8478;
    *(_BYTE *)(v5 + 66) = *(_BYTE *)(a2 + 64);
    v6 = *(_BYTE *)(a2 + 63);
    *(_WORD *)(v5 + 42) = 780;
    v3 = 1;
    *(_BYTE *)(v5 + 65) = v6;
    sub_5EF70(a2);
  }
  return v3;
}

//----- (0001D1A0) --------------------------------------------------------
int __cdecl sub_1D1A0(_WORD *a1, unsigned int a2)
{
  _WORD *v2; // esi
  int v3; // edi
  int v4; // eax
  int v5; // ebx
  __int16 v6; // ax
  __int16 v7; // dx

  v2 = a1 + 38;
  v3 = 0;
  v4 = sub_4A190((int)(a1 + 38), 9, 21);
  v5 = v4;
  if ( v4 )
  {
    *(_BYTE *)(v4 + 67) = 10;
    *(_BYTE *)(v4 + 68) = 66;
    *(_WORD *)(v4 + 26) = a1[13];
    *(_WORD *)(v4 + 28) = sub_581E0(v2, (_WORD *)(a2 + 76));
    v6 = sub_58210(v2, (_WORD *)(a2 + 76));
    v7 = *(_WORD *)(v5 + 80);
    *(_WORD *)(v5 + 30) = v6;
    *(_WORD *)(v5 + 80) = v7 + 128;
    *(_WORD *)(v5 + 150) = a1[75];
    *(_DWORD *)(v5 + 160) = &unk_D8478;
    *(_BYTE *)(v5 + 66) = *(_BYTE *)(a2 + 64);
    LOBYTE(v6) = *(_BYTE *)(a2 + 63);
    *(_WORD *)(v5 + 42) = 780;
    v3 = 1;
    *(_BYTE *)(v5 + 65) = v6;
    sub_5EF70(a2);
  }
  return v3;
}

//----- (0001D260) --------------------------------------------------------
int __cdecl sub_1D260(int a1, unsigned int a2)
{
  int v2; // eax
  int v3; // ebx
  char v4; // al
  int v6; // [esp+0h] [ebp-4h]

  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  v6 = 0;
  word_EB39C += *(_WORD *)(a1 + 88);
  v2 = sub_4A190((int)&word_EB398, 9, 9);
  v3 = v2;
  if ( v2 )
  {
    *(_BYTE *)(v2 + 67) = 10;
    *(_BYTE *)(v2 + 68) = 23;
    *(_WORD *)(v2 + 26) = *(_WORD *)(a1 + 26);
    *(_WORD *)(v2 + 28) = sub_581E0(&word_EB398, (_WORD *)(a2 + 76));
    *(_WORD *)(v3 + 30) = sub_58210(&word_EB398, (_WORD *)(a2 + 76));
    *(_WORD *)(v3 + 150) = *(_WORD *)(a1 + 150);
    *(_DWORD *)(v3 + 160) = &off_D8456;
    *(_BYTE *)(v3 + 66) = *(_BYTE *)(a2 + 64);
    v4 = *(_BYTE *)(a2 + 63);
    *(_WORD *)(v3 + 42) = 4000;
    *(_BYTE *)(v3 + 65) = v4;
    sub_5EF70(a2);
    return 1;
  }
  return v6;
}
// D8456: using guessed type void *off_D8456;
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0001D460) --------------------------------------------------------
int __cdecl sub_1D460(_WORD *a1, int a2)
{
  unsigned __int16 v2; // si
  __int16 v3; // di
  int v4; // eax
  _WORD *v5; // ebx
  __int16 v6; // ax
  __int16 v7; // cx
  _WORD *v9; // [esp+4h] [ebp-8h]
  int v10; // [esp+8h] [ebp-4h]

  v2 = 0;
  v10 = 0;
  do
  {
    switch ( v2 )
    {
      case 0u:
        v3 = -226;
        break;
      case 1u:
        v3 = -113;
        break;
      case 2u:
        v3 = 0;
        break;
      case 3u:
        v3 = 113;
        break;
      default:
        v3 = 226;
        break;
    }
    v9 = a1 + 38;
    v4 = sub_4A190((int)(a1 + 38), 9, 0);
    v5 = (_WORD *)v4;
    if ( v4 )
    {
      *(_BYTE *)(v4 + 67) = 10;
      *(_BYTE *)(v4 + 68) = 0;
      *(_DWORD *)(v4 + 160) = &unk_D83F0;
      *(_BYTE *)(v4 + 66) = *(_BYTE *)(a2 + 64);
      *(_BYTE *)(v4 + 65) = *(_BYTE *)(a2 + 63);
      *(_WORD *)(v4 + 42) = 800;
      *(_WORD *)(v4 + 26) = a1[13];
      *(_WORD *)(v4 + 28) = v3 + sub_581E0(v9, (_WORD *)(a2 + 76));
      v6 = sub_58210(v9, (_WORD *)(a2 + 76));
      v7 = v5[40];
      v5[15] = v6;
      v5[40] = v7 + 200;
      v10 = 1;
      v5[75] = a1[75];
    }
    ++v2;
  }
  while ( v2 < 5u );
  return v10;
}

//----- (0001D5D0) --------------------------------------------------------
void __cdecl sub_1D5D0(int a1, __int16 a2)
{
  switch ( *(_BYTE *)(a1 + 73) )
  {
    case 1:
      sub_1DDA0(a1, a2);
      break;
    case 2:
      sub_1DBF0(a1, a2);
      break;
    case 3:
      sub_1D7C0(a1, a2);
      break;
    case 4:
      sub_1D700(a1, a2);
      break;
    case 5:
      sub_1D8C0(a1, a2);
      break;
    case 6:
      sub_1E000(a1, a2);
      break;
    case 7:
      sub_1E020(a1, a2);
      break;
    case 8:
      sub_1D880(a1, a2);
      break;
    case 9:
      sub_1D8A0(a1, a2);
      break;
    case 0xA:
      sub_1E040(a1, a2);
      break;
    case 0xC:
      sub_1E4D0(a1, a1);
      break;
    case 0xD:
    case 0x10:
      sub_1E580(a1, a2);
      break;
    case 0xE:
      sub_1E9C0(a1, a2);
      break;
    case 0x11:
      sub_1E320(a1);
      break;
    default:
      return;
  }
}

//----- (0001D700) --------------------------------------------------------
void __cdecl sub_1D700(int a1, __int16 a2)
{
  char *v2; // esi
  unsigned int v3; // esi
  unsigned __int16 v4; // dx
  unsigned int v5; // edi

  sub_1D8C0(a1, a2);
  if ( (*(_BYTE *)(a1 + 62) & 7) == 0 )
  {
    v2 = (char *)&loc_365F2 + 8 * *(unsigned __int8 *)(a1 + 72) + dword_D41A0 + 2;
    if ( (v2[1] & 2) != 0 )
      v3 = dword_EA3E4[*(__int16 *)(a1 + 74)];
    else
      v3 = *((_DWORD *)v2 + 1);
    if ( v3 )
    {
      if ( v3 > dword_EA3E4[0] )
      {
        v4 = *(_WORD *)(v3 + 150);
        if ( v4 )
        {
          v5 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
          if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(dword_EA3E4[v4] + 76)) <= v5 )
          {
            *(_WORD *)(a1 + 150) = *(_WORD *)(v3 + 150);
            *(_BYTE *)(a1 + 73) = 10;
            sub_1E040(a1, a2);
          }
        }
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001D7C0) --------------------------------------------------------
void __cdecl sub_1D7C0(int a1, __int16 a2)
{
  char *v2; // esi
  unsigned int v3; // esi
  unsigned int v4; // edi

  sub_1D8C0(a1, a2);
  if ( (*(_BYTE *)(a1 + 62) & 7) == 0 )
  {
    v2 = (char *)&loc_365F2 + 8 * *(unsigned __int8 *)(a1 + 72) + dword_D41A0 + 2;
    if ( (v2[1] & 2) != 0 )
      v3 = dword_EA3E4[*(__int16 *)(a1 + 74)];
    else
      v3 = *((_DWORD *)v2 + 1);
    if ( v3 && v3 > dword_EA3E4[0] )
    {
      v4 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
      if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76)) <= v4 )
      {
        *(_WORD *)(a1 + 150) = (int)(v3 - (dword_D41A0 + 28302)) / 168;
        *(_BYTE *)(a1 + 73) = 10;
        sub_1E040(a1, a2);
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001D880) --------------------------------------------------------
char __cdecl sub_1D880(int a1, __int16 a2)
{
  return sub_1E1C0(a1, a2);
}

//----- (0001D8A0) --------------------------------------------------------
char __cdecl sub_1D8A0(int a1, __int16 a2)
{
  return sub_1E1C0(a1, a2);
}

//----- (0001D8C0) --------------------------------------------------------
void __cdecl sub_1D8C0(int a1, __int16 a2)
{
  unsigned int v2; // ecx
  __int16 v3; // ax
  int i; // eax
  int v5; // eax
  int v6; // esi
  int v7; // eax
  char v8; // al
  char v9; // cl
  char v10; // al
  int v11; // esi
  _WORD *v12; // esi
  __int16 v13; // ax
  char v14; // dl
  unsigned __int16 v15; // ax
  unsigned int j; // ecx
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax

  v2 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v3 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v2 = 1;
    *(_WORD *)(a1 + 38) = v3;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) && *(_BYTE *)(a1 + 64) != 27 )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        v2 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      v7 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( *(_BYTE *)(v7 + 63) == *(_BYTE *)(a1 + 63) && (v8 = *(_BYTE *)(v7 + 64), v9 = *(_BYTE *)(a1 + 64), v8 == v9) )
        v10 = v9 ^ v8;
      else
        v10 = 1;
      if ( v10 )
      {
        *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
        *(_BYTE *)(a1 + 73) = 10;
        sub_1E040(a1, a2);
      }
      sub_1EEE0(a1);
    }
    else
    {
      *(_BYTE *)(a1 + 69) = a2 + 4;
    }
  }
  else
  {
    sub_1B8C0(a1);
    if ( (*(_BYTE *)(a1 + 62) & 7) == 0 )
    {
      v11 = dword_D41A0 + 8 * *(unsigned __int8 *)(a1 + 72);
      if ( (*(_BYTE *)(v11 + 222709) & 2) != 0 )
      {
        if ( !*(_WORD *)(a1 + 74) )
          *(_WORD *)(a1 + 74) = sub_1E3E0(a1);
        v12 = (_WORD *)dword_EA3E4[*(__int16 *)(a1 + 74)];
      }
      else
      {
        v12 = *(_WORD **)((char *)sub_365F8 + v11);
      }
      if ( v12 && (unsigned int)v12 > dword_EA3E4[0] )
      {
        if ( (*(_BYTE *)(a1 + 14) & 4) == 0 )
        {
          v13 = sub_581E0((_WORD *)(a1 + 76), v12 + 38);
          v14 = *(_BYTE *)(a1 + 62);
          *(_WORD *)(a1 + 32) = v13;
          if ( (v14 & 0x3F) == 0 )
          {
            *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
            v15 = *(_WORD *)(a1 + 20);
            *(_WORD *)(a1 + 20) = 9377 * v15 + 9439;
            *(_WORD *)(a1 + 32) += (2 * (v15 % 0x9Du / 79i64) - 1) * ((unsigned __int8)*(_WORD *)(a1 + 20) + 85);
            *(_BYTE *)(a1 + 33) &= 7u;
          }
        }
        for ( j = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
        {
          if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26) )
          {
            v17 = *(__int16 *)(a1 + 76) - *(__int16 *)(j + 76);
            if ( (int)((HIDWORD(v17) ^ v17) - HIDWORD(v17)) < *(__int16 *)(a1 + 84) )
            {
              v18 = *(__int16 *)(a1 + 78) - *(__int16 *)(j + 78);
              if ( (int)((HIDWORD(v18) ^ v18) - HIDWORD(v18)) < *(__int16 *)(a1 + 84) )
              {
                *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
                break;
              }
            }
          }
        }
        v19 = *(__int16 *)(a1 + 76) - (__int16)v12[38];
        if ( (int)((HIDWORD(v19) ^ v19) - HIDWORD(v19)) < *(__int16 *)(a1 + 84) + (__int16)v12[42] )
        {
          v20 = *(__int16 *)(a1 + 78) - (__int16)v12[39];
          if ( (int)((HIDWORD(v20) ^ v20) - HIDWORD(v20)) < *(__int16 *)(a1 + 84) + (__int16)v12[42] )
            *(_WORD *)(a1 + 32) = sub_581E0(v12 + 38, (_WORD *)(a1 + 76));
        }
      }
      else if ( (*(_BYTE *)(a1 + 62) & 0xF) == 0 && (*(_BYTE *)(a1 + 14) & 4) == 0 )
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        *(_WORD *)(a1 + 32) += *(_WORD *)(a1 + 20) % 0x71u + 142;
        *(_BYTE *)(a1 + 33) &= 7u;
      }
    }
  }
}
// 1D958: conditional instruction was optimized away because ecx.4==2
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001DBF0) --------------------------------------------------------
int __cdecl sub_1DBF0(int a1, unsigned __int16 a2)
{
  char *v2; // esi
  __int64 v3; // rax
  __int64 v4; // rax
  int result; // eax
  int v6; // esi
  unsigned int v7; // edi
  unsigned int v8; // esi
  int v9; // ecx
  __int16 v10; // dx
  __int16 v11; // ax
  int v12; // [esp+0h] [ebp-10h]
  unsigned int v13; // [esp+4h] [ebp-Ch]
  unsigned int v14; // [esp+8h] [ebp-8h]
  unsigned int v15; // [esp+Ch] [ebp-4h]

  v2 = (char *)&loc_365F2 + 8 * *(unsigned __int8 *)(a1 + 72) + dword_D41A0 + 2;
  v3 = *((__int16 *)v2 + 2) - *(__int16 *)(a1 + 76);
  if ( (int)((HIDWORD(v3) ^ v3) - HIDWORD(v3)) > 3072
    || (v4 = *((__int16 *)v2 + 3) - *(__int16 *)(a1 + 78), (int)((HIDWORD(v4) ^ v4) - HIDWORD(v4)) > 3072) )
  {
    sub_1DDA0(a1, a2);
  }
  else
  {
    sub_1E1C0(a1, a2);
  }
  result = a2 + 7;
  if ( *(unsigned __int8 *)(a1 + 69) == result && *(_BYTE *)(a1 + 73) == 2 )
  {
    if ( *(_BYTE *)(a1 + 57) )
    {
      v6 = *(_DWORD *)(a1 + 160);
      result = *(unsigned __int8 *)(a1 + 62) / *(__int16 *)(v6 + 26);
      if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(v6 + 26)) )
      {
        result = *(__int16 *)(v6 + 28) * *(__int16 *)(v6 + 28);
        v7 = 0;
        v14 = -1;
        v8 = *(_DWORD *)(dword_D41A4 + 38519);
        v13 = result;
        while ( v8 > dword_EA3E4[0] )
        {
          v9 = (__int16)(*(_WORD *)(v8 + 76) - *(_WORD *)(a1 + 76));
          v10 = *(_WORD *)(v8 + 78) - *(_WORD *)(a1 + 78);
          v15 = v10 * v10 + v9 * v9;
          result = v15;
          if ( v15 <= v13 && (*(_BYTE *)(v8 + 12) & 0x20) == 0 )
          {
            v12 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 30);
            v11 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v8 + 76));
            result = (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v11);
            if ( result < v12 )
            {
              result = v10 * v10 + v9 * v9;
              if ( v15 < v14 )
              {
                v7 = v8;
                v14 = v10 * v10 + v9 * v9;
              }
            }
          }
          v8 = *(_DWORD *)v8;
        }
        if ( v7 )
        {
          *(_WORD *)(a1 + 150) = (int)(v7 - (dword_D41A0 + 28302)) / 168;
          *(_BYTE *)(a1 + 73) = 10;
          return sub_1E040(a1, a2);
        }
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001DDA0) --------------------------------------------------------
char __cdecl sub_1DDA0(int a1, __int16 a2)
{
  unsigned int v2; // eax
  __int16 v3; // ax
  int i; // edx
  int v5; // edx
  int v6; // ecx
  int v7; // eax
  int v8; // eax
  char v9; // al
  char v10; // cl
  char v11; // al
  unsigned __int16 v12; // ax
  unsigned int j; // ecx
  __int64 v14; // rax
  __int64 v15; // rax
  __int16 v17[4]; // [esp+0h] [ebp-Ch] BYREF
  char v18; // [esp+8h] [ebp-4h]

  v2 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v3 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v3;
    v2 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) && *(_BYTE *)(a1 + 64) != 27 )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        v2 = 1;
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v2 = 2;
  }
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      v8 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( *(_BYTE *)(v8 + 63) == *(_BYTE *)(a1 + 63)
        && (v9 = *(_BYTE *)(v8 + 64), v10 = *(_BYTE *)(a1 + 64), v9 == v10) )
      {
        v11 = v10 ^ v9;
      }
      else
      {
        v11 = 1;
      }
      if ( v11 )
      {
        *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
        *(_BYTE *)(a1 + 73) = 10;
        sub_1E040(a1, a2);
      }
      LOBYTE(v7) = sub_1EEE0(a1);
    }
    else
    {
      LOBYTE(v7) = a2 + 4;
      *(_BYTE *)(a1 + 69) = a2 + 4;
    }
  }
  else
  {
    LOBYTE(v7) = sub_1B8C0(a1);
    if ( (*(_BYTE *)(a1 + 62) & 7) == 0 )
    {
      v17[0] = *(_WORD *)((char *)sub_365F8 + 8 * *(unsigned __int8 *)(a1 + 72) + dword_D41A0);
      v17[1] = *(_WORD *)(dword_D41A0 + 8 * *(unsigned __int8 *)(a1 + 72) + 222714);
      if ( (*(_BYTE *)(a1 + 14) & 4) == 0 )
      {
        *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), v17);
        if ( (*(_BYTE *)(a1 + 62) & 0x3F) == 0 )
        {
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          v12 = *(_WORD *)(a1 + 20);
          *(_WORD *)(a1 + 20) = 9377 * v12 + 9439;
          *(_WORD *)(a1 + 32) += ((unsigned __int8)*(_WORD *)(a1 + 20) + 85) * (2 * (v12 % 0x9Du / 79i64) - 1);
          *(_BYTE *)(a1 + 33) &= 7u;
        }
      }
      v7 = *(char *)(a1 + 64);
      v18 = 0;
      for ( j = *(_DWORD *)(dword_D41A4 + 4 * v7 + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
      {
        LOWORD(v7) = *(_WORD *)(j + 26);
        if ( (_WORD)v7 != *(_WORD *)(a1 + 26) )
        {
          v14 = *(__int16 *)(a1 + 76) - *(__int16 *)(j + 76);
          v7 = (HIDWORD(v14) ^ v14) - HIDWORD(v14);
          if ( v7 < *(__int16 *)(a1 + 84) )
          {
            v15 = *(__int16 *)(a1 + 78) - *(__int16 *)(j + 78);
            v7 = (HIDWORD(v15) ^ v15) - HIDWORD(v15);
            if ( v7 < *(__int16 *)(a1 + 84) )
            {
              LOWORD(v7) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
              *(_WORD *)(a1 + 32) = v7;
              v18 = 1;
              return v7;
            }
          }
        }
      }
    }
  }
  return v7;
}
// 1DE38: conditional instruction was optimized away because eax.4==2
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001E000) --------------------------------------------------------
char __cdecl sub_1E000(int a1, __int16 a2)
{
  return sub_1E1C0(a1, a2);
}

//----- (0001E020) --------------------------------------------------------
char __cdecl sub_1E020(int a1, __int16 a2)
{
  return sub_1E1C0(a1, a2);
}

//----- (0001E040) --------------------------------------------------------
int __cdecl sub_1E040(int a1, char a2)
{
  int result; // eax
  char v3; // bl

  result = *(_DWORD *)(a1 + 160);
  if ( (*(_BYTE *)(result + 32) & 8) != 0 )
    v3 = a2 + 6;
  else
    v3 = a2 + 2;
  *(_BYTE *)(a1 + 69) = v3;
  return result;
}

//----- (0001E1C0) --------------------------------------------------------
char __cdecl sub_1E1C0(int a1, __int16 a2)
{
  unsigned int v2; // eax
  __int16 v3; // ax
  int i; // edx
  int v5; // ecx
  int v6; // edx
  unsigned int v7; // eax
  int v8; // eax
  char v9; // al
  char v10; // cl
  char v11; // al

  v2 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v3 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v3;
    v2 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) && *(_BYTE *)(a1 + 64) != 27 )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        v2 = 1;
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v2 = 2;
  }
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      v8 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( *(_BYTE *)(v8 + 63) == *(_BYTE *)(a1 + 63)
        && (v9 = *(_BYTE *)(v8 + 64), v10 = *(_BYTE *)(a1 + 64), v9 == v10) )
      {
        v11 = v10 ^ v9;
      }
      else
      {
        v11 = 1;
      }
      if ( v11 )
      {
        *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
        *(_BYTE *)(a1 + 73) = 10;
        sub_1E040(a1, a2);
      }
      LOBYTE(v7) = sub_1EEE0(a1);
    }
    else
    {
      LOBYTE(v7) = a2 + 4;
      *(_BYTE *)(a1 + 69) = a2 + 4;
    }
  }
  else
  {
    v7 = *(_DWORD *)(a1 + 160);
    if ( (*(_BYTE *)(v7 + 32) & 2) == 0 )
    {
      sub_1B8C0(a1);
      LOBYTE(v7) = *(_BYTE *)(a1 + 62);
      if ( (v7 & 0xF) == 0 && (*(_BYTE *)(a1 + 14) & 4) == 0 )
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v7 = *(unsigned __int16 *)(a1 + 20) % 0x71u + 142 + *(unsigned __int16 *)(a1 + 32);
        *(_WORD *)(a1 + 32) = v7;
        *(_BYTE *)(a1 + 33) &= 7u;
      }
    }
  }
  return v7;
}
// 1E257: conditional instruction was optimized away because eax.4==2
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001E320) --------------------------------------------------------
char __cdecl sub_1E320(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // dx

  sub_1B8C0(a1);
  if ( *(int *)(a1 + 8) < 0 )
  {
    LOBYTE(v1) = sub_57F10(a1);
    return v1;
  }
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  if ( v1 <= dword_EA3E4[0] || *(int *)(v1 + 8) < 0 || (*(_BYTE *)(v1 + 13) & 4) != 0 )
    goto LABEL_14;
  LOWORD(v1) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
  v2 = *(_WORD *)(a1 + 130);
  *(_WORD *)(a1 + 32) = v1;
  v2 -= 8;
  *(_WORD *)(a1 + 130) = v2;
  if ( v2 <= 16 )
  {
    LOBYTE(v1) = *(_BYTE *)(a1 + 64);
    if ( (unsigned __int8)v1 < 0x13u )
    {
      if ( !(_BYTE)v1 )
        *(_WORD *)(a1 + 130) = 30;
    }
    else if ( (unsigned __int8)v1 <= 0x13u )
    {
      *(_WORD *)(a1 + 130) = 76;
    }
    else if ( (_BYTE)v1 == 21 )
    {
      *(_WORD *)(a1 + 130) = 96;
    }
LABEL_14:
    *(_BYTE *)(a1 + 73) = 16;
  }
  return v1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001E3E0) --------------------------------------------------------
int __cdecl sub_1E3E0(int a1)
{
  unsigned int v1; // edi
  int v2; // ebx
  int v3; // edx
  unsigned int i; // eax
  unsigned int j; // esi
  unsigned int v6; // eax
  unsigned int v8; // [esp+0h] [ebp-4h]

  v8 = -1;
  v1 = 0;
  v2 = 0;
  if ( (*(_BYTE *)(dword_D41A0 + 8 * *(unsigned __int8 *)(a1 + 72) + 222709) & 1) != 0 )
  {
    HIWORD(v3) = HIWORD(dword_D41A4);
    for ( i = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); i > dword_EA3E4[0] && !(_WORD)v2; i = *(_DWORD *)i )
    {
      if ( *(_BYTE *)(i + 72) == *(_BYTE *)(a1 + 72) )
      {
        LOWORD(v3) = *(_WORD *)(i + 74);
        if ( (_WORD)v3 )
          v2 = v3;
      }
    }
  }
  if ( !(_WORD)v2 )
  {
    for ( j = *(_DWORD *)(dword_D41A4
                        + 4 * *(unsigned __int16 *)((char *)sub_365F8 + 8 * *(unsigned __int8 *)(a1 + 72) + dword_D41A0)
                        + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
    {
      v6 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(j + 76));
      if ( v6 < v8 )
      {
        v8 = v6;
        v1 = j;
      }
    }
    if ( v1 )
      return (int)(v1 - (dword_D41A0 + 28302)) / 168;
  }
  return v2;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001E4D0) --------------------------------------------------------
int __usercall sub_1E4D0@<eax>(__int16 a1@<ax>, int a2)
{
  unsigned int v2; // ebx
  int v3; // edx
  int result; // eax

  v2 = dword_EA3E4[*(unsigned __int16 *)(a2 + 40)];
  if ( v2 <= dword_EA3E4[0] || *(int *)(v2 + 8) < 0 )
    return sub_57F10(a2);
  word_EB398 = *(_WORD *)(v2 + 76);
  LOBYTE(a1) = *(_BYTE *)(a2 + 64);
  word_EB39A = *(_WORD *)(v2 + 78);
  v3 = *(__int16 *)(v2 + 80);
  if ( (unsigned __int8)a1 >= 0x10u )
  {
    if ( (unsigned __int8)a1 <= 0x10u )
    {
      v3 -= 896;
    }
    else if ( (unsigned __int8)a1 >= 0x14u && (_BYTE)a1 == 25 )
    {
      v3 -= 512;
    }
  }
  if ( v3 <= 0 )
    LOWORD(v3) = 0;
  word_EB39C = v3;
  result = sub_57CF0(a1, a2, (int)&word_EB398);
  *(_WORD *)(a2 + 32) = *(_WORD *)(v2 + 32);
  *(_WORD *)(a2 + 28) = *(_WORD *)(v2 + 28);
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0001E580) --------------------------------------------------------
void __cdecl sub_1E580(int a1, __int16 a2)
{
  unsigned int v2; // eax
  unsigned int v3; // esi
  unsigned int v4; // edi
  __int16 v5; // si
  char v6; // [esp+0h] [ebp-4h]

  v6 = 0;
  v2 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
  if ( v2 <= dword_EA3E4[0] || *(int *)(v2 + 8) < 0 || (*(_BYTE *)(v2 + 13) & 4) != 0 )
  {
    *(_WORD *)(a1 + 46) = 0;
  }
  else if ( *(_BYTE *)(a1 + 73) == 13 )
  {
    --*(_WORD *)(a1 + 46);
  }
  if ( *(__int16 *)(a1 + 46) <= 0 )
  {
    v6 = 1;
  }
  else
  {
    v3 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v3 > dword_EA3E4[0] && (*(int *)(v3 + 8) <= 0 || (*(_BYTE *)(v3 + 13) & 4) != 0) )
    {
      *(_WORD *)(a1 + 150) = 0;
      v3 = dword_EA3E4[0];
    }
    if ( v3 <= dword_EA3E4[0] && (*(_BYTE *)(a1 + 62) & 7) == 0 )
    {
      v3 = sub_16FC0(v2, v2);
      *(_WORD *)(a1 + 150) = (int)(v3 - (dword_D41A0 + 28302)) / 168;
    }
    if ( v3 <= dword_EA3E4[0] )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 40);
      sub_1E700(a1, a2);
      v5 = *(_WORD *)(a1 + 46);
      *(_WORD *)(a1 + 150) = 0;
      *(_WORD *)(a1 + 46) = v5 - 4;
    }
    else
    {
      sub_1E700(a1, a2);
      if ( (*(_BYTE *)(a1 + 62) & 7) == 0 )
      {
        v4 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
        if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76)) < v4 )
          *(_BYTE *)(a1 + 69) = a2 + 2;
      }
    }
  }
  if ( v6 )
  {
    if ( *(_BYTE *)(a1 + 73) == 13 )
      sub_4A190(a1 + 76, 10, 73);
    sub_4A190(a1 + 76, 10, 0);
    sub_57F10(a1);
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001E700) --------------------------------------------------------
void __cdecl sub_1E700(int a1, char a2)
{
  unsigned int v2; // eax
  __int16 v3; // ax
  int i; // edx
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  char v8; // al
  char v9; // al
  unsigned int v10; // eax
  __int16 v11; // ax
  char v12; // ch
  unsigned __int16 v13; // ax
  unsigned int j; // ecx
  __int64 v15; // rax
  __int64 v16; // rax

  v2 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v3 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v3;
    v2 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) && *(_BYTE *)(a1 + 64) != 27 )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        v2 = 1;
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v2 = 2;
  }
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      sub_1B8C0(a1);
      v7 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      v8 = 1;
      if ( *(_BYTE *)(v7 + 63) == *(_BYTE *)(a1 + 63) && *(_BYTE *)(v7 + 64) == *(_BYTE *)(a1 + 64) )
        v8 = 0;
      if ( *(_WORD *)(a1 + 40) == *(_WORD *)(a1 + 38) )
        v8 = 0;
      if ( v8 )
      {
        *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
        if ( (*(_BYTE *)(*(_DWORD *)(a1 + 160) + 32) & 8) != 0 )
          v9 = a2 + 6;
        else
          v9 = a2 + 2;
        *(_BYTE *)(a1 + 69) = v9;
        sub_6D8B0(*(_WORD *)(a1 + 40), 0x13u, 1);
      }
    }
    else
    {
      *(_WORD *)(a1 + 46) = 1;
    }
  }
  else
  {
    sub_1B8C0(a1);
    if ( (*(_BYTE *)(a1 + 62) & 7) == 0 )
    {
      v10 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
      if ( v10 > dword_EA3E4[0] )
      {
        if ( (*(_BYTE *)(a1 + 14) & 4) == 0 )
        {
          v11 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v10 + 76));
          v12 = *(_BYTE *)(a1 + 62);
          *(_WORD *)(a1 + 32) = v11;
          if ( (v12 & 0x3F) == 0 )
          {
            *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
            v13 = *(_WORD *)(a1 + 20);
            *(_WORD *)(a1 + 20) = 9377 * v13 + 9439;
            *(_WORD *)(a1 + 32) += ((unsigned __int8)*(_WORD *)(a1 + 20) + 85) * (2 * (v13 % 0x9Du / 79i64) - 1);
            *(_BYTE *)(a1 + 33) &= 7u;
          }
        }
        for ( j = *(_DWORD *)(4 * *(char *)(a1 + 64) + dword_D41A4 + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
        {
          if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26) )
          {
            v15 = *(__int16 *)(a1 + 76) - *(__int16 *)(j + 76);
            if ( (int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) < *(__int16 *)(a1 + 84) )
            {
              v16 = *(__int16 *)(a1 + 78) - *(__int16 *)(j + 78);
              if ( (int)((HIDWORD(v16) ^ v16) - HIDWORD(v16)) < *(__int16 *)(a1 + 84) )
              {
                *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
                return;
              }
            }
          }
        }
      }
    }
  }
}
// 1E797: conditional instruction was optimized away because eax.4==2
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001E9C0) --------------------------------------------------------
void __cdecl sub_1E9C0(int a1, __int16 a2)
{
  __int16 v2; // cx
  unsigned int v3; // esi
  char v4; // al
  int i; // eax
  char v6; // dl
  int v7; // eax
  unsigned __int16 v8; // di
  unsigned __int16 v9; // ax
  unsigned int v10; // esi
  unsigned int v11; // edi
  int j; // eax
  int v13; // eax
  __int16 v14; // [esp+0h] [ebp-4h]

  v2 = *(_WORD *)(a1 + 46) - 1;
  v14 = 0;
  *(_WORD *)(a1 + 46) = v2;
  if ( v2 <= 0 )
    goto LABEL_46;
  v3 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
  v4 = 0;
  if ( v2 <= *(__int16 *)(a1 + 48) - 16 && *(__int16 *)(a1 + 46) >= 16 )
  {
    if ( (*(_BYTE *)(a1 + 62) & 0x1C) == 16 )
      v4 = *(_BYTE *)(a1 + 62) & 3;
  }
  else
  {
    v4 = (*(_BYTE *)(a1 + 62) & 1) != 0 ? 0 : 2;
  }
  switch ( v4 )
  {
    case 0:
      *(_BYTE *)(a1 + 15) &= 0xF9u;
      break;
    case 1:
    case 3:
      *(_BYTE *)(a1 + 15) = *(_BYTE *)(a1 + 15) & 0xF9 | 2;
      break;
    case 2:
      *(_BYTE *)(a1 + 15) = *(_BYTE *)(a1 + 15) & 0xF9 | 4;
      break;
    default:
      break;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v7 + 52) )
    {
      v7 = dword_EA3E4[i];
      if ( v7 == dword_EA3E4[0] )
        break;
      v6 = 0;
      if ( *(__int16 *)(a1 + 46) <= *(__int16 *)(a1 + 48) - 16 && *(__int16 *)(a1 + 46) >= 16 )
      {
        if ( (*(_BYTE *)(a1 + 62) & 0x1C) == 16 )
          v6 = *(_BYTE *)(a1 + 62) & 3;
      }
      else if ( (*(_BYTE *)(a1 + 62) & 1) != 0 )
      {
        v6 = 0;
      }
      else
      {
        v6 = 2;
      }
      switch ( v6 )
      {
        case 0:
          *(_BYTE *)(v7 + 15) &= 0xF9u;
          break;
        case 1:
        case 3:
          *(_BYTE *)(v7 + 15) = *(_BYTE *)(v7 + 15) & 0xF9 | 2;
          break;
        case 2:
          *(_BYTE *)(v7 + 15) = *(_BYTE *)(v7 + 15) & 0xF9 | 4;
          break;
        default:
          continue;
      }
    }
  }
  if ( v3 <= dword_EA3E4[0] || *(int *)(v3 + 8) <= 0 )
  {
LABEL_46:
    v14 = 1;
  }
  else
  {
    v8 = *(_WORD *)(a1 + 150);
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 40);
    sub_1E700(a1, a2);
    v9 = *(_WORD *)(v3 + 150);
    if ( !v9 && *(_WORD *)(v3 + 38) )
      v9 = *(_WORD *)(v3 + 38);
    if ( v9 && v8 != v9 )
      v8 = v9;
    *(_WORD *)(a1 + 150) = v8;
    if ( v8 )
    {
      v10 = dword_EA3E4[v8];
      if ( v10 > dword_EA3E4[0]
        && (*(_WORD *)(v10 + 40) == *(_WORD *)(a1 + 40) && *(_BYTE *)(v10 + 73) == 14
         || *(int *)(v10 + 8) <= 0
         || (*(_BYTE *)(v10 + 13) & 4) != 0) )
      {
        *(_WORD *)(a1 + 150) = 0;
        v10 = dword_EA3E4[0];
      }
      if ( v10 > dword_EA3E4[0] )
      {
        v11 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
        if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v10 + 76)) < v11 )
        {
          *(_WORD *)(a1 + 150) = (int)(v10 - (dword_D41A0 + 28302)) / 168;
          *(_BYTE *)(a1 + 69) = a2 + 2;
          sub_6D8B0(*(_WORD *)(a1 + 40), 0x18u, 1);
        }
      }
    }
  }
  if ( v14 )
  {
    *(_BYTE *)(a1 + 73) = 10;
    *(_WORD *)(a1 + 150) = 0;
    *(_WORD *)(a1 + 40) = 0;
    *(_BYTE *)(a1 + 72) = *(_BYTE *)(a1 + 74);
    *(_BYTE *)(a1 + 15) &= 0xF9u;
    if ( *(_WORD *)(a1 + 52) )
    {
      for ( j = *(unsigned __int16 *)(a1 + 52); ; j = *(unsigned __int16 *)(v13 + 52) )
      {
        v13 = dword_EA3E4[j];
        if ( v13 == dword_EA3E4[0] )
          break;
        *(_BYTE *)(v13 + 15) &= 0xF9u;
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001ED30) --------------------------------------------------------
int __cdecl sub_1ED30(int a1, int a2)
{
  int v2; // ebx
  char v3; // dl
  int i; // edx
  char v5; // cl
  char v6; // cl
  int v7; // edx
  __int16 v8; // dx
  unsigned int v9; // eax
  unsigned __int16 v10; // ax

  v2 = a2;
  if ( *(_BYTE *)(a1 + 73) == 14 )
  {
    v3 = 0;
    if ( *(__int16 *)(a1 + 48) - 16 >= *(__int16 *)(a1 + 46) && *(__int16 *)(a1 + 46) >= 16 )
    {
      if ( (*(_BYTE *)(a1 + 62) & 0x1C) == 16 )
        v3 = *(_BYTE *)(a1 + 62) & 3;
    }
    else if ( (*(_BYTE *)(a1 + 62) & 1) != 0 )
    {
      v3 = 0;
    }
    else
    {
      v3 = 2;
    }
    switch ( v3 )
    {
      case 0:
        *(_BYTE *)(a1 + 15) &= 0xF9u;
        break;
      case 1:
      case 3:
        *(_BYTE *)(a1 + 15) = *(_BYTE *)(a1 + 15) & 0xF9 | 2;
        break;
      case 2:
        *(_BYTE *)(a1 + 15) = *(_BYTE *)(a1 + 15) & 0xF9 | 4;
        break;
      default:
        break;
    }
    if ( *(_WORD *)(a1 + 52) )
    {
      for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v7 + 52) )
      {
        v7 = dword_EA3E4[i];
        if ( v7 == dword_EA3E4[0] )
          break;
        v5 = 0;
        if ( *(__int16 *)(a1 + 46) <= *(__int16 *)(a1 + 48) - 16 && *(__int16 *)(a1 + 46) >= 16 )
        {
          if ( (*(_BYTE *)(a1 + 62) & 0x1C) == 16 )
            v5 = *(_BYTE *)(a1 + 62) & 3;
        }
        else if ( (*(_BYTE *)(a1 + 62) & 1) != 0 )
        {
          v5 = 0;
        }
        else
        {
          v5 = 2;
        }
        switch ( v5 )
        {
          case 0:
            *(_BYTE *)(v7 + 15) &= 0xF9u;
            break;
          case 1:
          case 3:
            v6 = *(_BYTE *)(v7 + 15) & 0xF9 | 2;
            goto LABEL_26;
          case 2:
            v6 = *(_BYTE *)(v7 + 15) & 0xF9 | 4;
LABEL_26:
            *(_BYTE *)(v7 + 15) = v6;
            break;
          default:
            continue;
        }
      }
    }
    v8 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v8;
    if ( v8 <= 0 )
      return dword_EA3E4[0];
    v9 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v9 > dword_EA3E4[0] )
    {
      if ( a2 == v9 )
        return dword_EA3E4[0];
      if ( *(_WORD *)(v9 + 150) )
      {
        v10 = *(_WORD *)(v9 + 150);
      }
      else
      {
        if ( !*(_WORD *)(v9 + 38) )
          return v2;
        v10 = *(_WORD *)(v9 + 38);
      }
      if ( dword_EA3E4[v10] != a2 )
        return dword_EA3E4[0];
    }
  }
  return v2;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001EEE0) --------------------------------------------------------
int __cdecl sub_1EEE0(int a1)
{
  __int16 *v1; // eax
  __int16 v2; // ax
  int v4; // [esp-Ch] [ebp-Ch]
  int v5; // [esp-8h] [ebp-8h]
  __int16 v6; // [esp-4h] [ebp-4h]

  v1 = *(__int16 **)(a1 + 160);
  v6 = v1[7];
  v5 = v1[5];
  v4 = v1[6];
  v2 = sub_10C40((__int16 *)(a1 + 76));
  return sub_580E0(a1 + 76, v2, v4, v5, v6);
}

//----- (0001EF20) --------------------------------------------------------
int __cdecl sub_1EF20(int a1)
{
  return sub_1BD90(a1, 0);
}

//----- (0001EF40) --------------------------------------------------------
int __usercall sub_1EF40@<eax>(int a1@<esi>, _WORD *a2)
{
  sub_1BF90((int)a2, 0);
  sub_1F0C0(a1, (int)a2);
  return sub_1F040(a2);
}

//----- (0001EF70) --------------------------------------------------------
int __usercall sub_1EF70@<eax>(int a1@<esi>, _WORD *a2)
{
  if ( (unsigned __int16)sub_1C310((int)a2, 0, (unsigned __int16 (__cdecl *)(int, int))sub_1CC20) )
    sub_6E450(((int)a2 - dword_D41A0 - 28302) / 168, -1, 8);
  sub_1F0C0(a1, (int)a2);
  return sub_1F040(a2);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001EFD0) --------------------------------------------------------
int __usercall sub_1EFD0@<eax>(int a1@<esi>, _WORD *a2)
{
  sub_1C560((int)a2, 0);
  sub_1F0C0(a1, (int)a2);
  return sub_1F040(a2);
}

//----- (0001F000) --------------------------------------------------------
int __cdecl sub_1F000(int a1)
{
  return sub_1C890(a1, 0);
}

//----- (0001F020) --------------------------------------------------------
void __cdecl sub_1F020(int a1)
{
  sub_1C930(a1);
}

//----- (0001F040) --------------------------------------------------------
int __cdecl sub_1F040(_WORD *a1)
{
  __int16 v1; // ax
  int result; // eax

  a1[40] += a1[8];
  v1 = sub_10C40(a1 + 38);
  *((_DWORD *)a1 + 4) -= 5;
  result = v1 + 256;
  if ( (__int16)a1[40] >= result )
  {
    if ( byte_D41B6 )
    {
      result = sub_10C60(a1 + 38);
      if ( (__int16)a1[40] > (__int16)result - 256 )
        *((_DWORD *)a1 + 4) = -150;
    }
  }
  else
  {
    *((_DWORD *)a1 + 4) = 150;
  }
  return result;
}
// D41B6: using guessed type char byte_D41B6;

//----- (0001F0C0) --------------------------------------------------------
void __usercall sub_1F0C0(int a1@<esi>, int a2)
{
  char v2; // ah
  int v3; // edi
  int i; // eax
  int v5; // eax
  char v6; // cl
  unsigned int v7; // esi
  __int16 v8; // ax
  __int16 v9; // ax
  int v10; // [esp+0h] [ebp-14h] BYREF
  int v11; // [esp+4h] [ebp-10h] BYREF
  int v12; // [esp+8h] [ebp-Ch]
  int v13; // [esp+Ch] [ebp-8h]
  char v14; // [esp+10h] [ebp-4h]

  v2 = *(_BYTE *)(a2 + 61);
  if ( v2 )
  {
    *(_BYTE *)(a2 + 61) = v2 - 1;
    if ( *(_BYTE *)(a2 + 70) )
    {
      if ( *(_WORD *)(a2 + 44) )
      {
        v7 = dword_EA3E4[*(unsigned __int16 *)(a2 + 36)];
        if ( v7 <= dword_EA3E4[0] || *(int *)(v7 + 8) < 0 || (*(_BYTE *)(v7 + 13) & 4) != 0 )
        {
          *(_BYTE *)(a2 + 70) = 0;
          *(_WORD *)(a2 + 36) = 0;
        }
        else
        {
          if ( (*(_BYTE *)(a2 + 36) & 1) != 0 )
            v8 = *(_WORD *)(v7 + 28) + 512;
          else
            v8 = *(_WORD *)(v7 + 28) - 512;
          *(_DWORD *)&word_EB398 = *(_DWORD *)(a2 + 76);
          *(&word_EB398 + 2) = *(_WORD *)(a2 + 80);
          v9 = (unsigned __int16)sub_57FA0(&word_EB398, v8 & 0x7FF, 0, 48 * *(_WORD *)(a2 + 44));
          sub_57CF0(v9, a2, (int)&word_EB398);
          --*(_WORD *)(a2 + 44);
        }
      }
      else
      {
        *(_BYTE *)(a2 + 70) = 0;
        *(_WORD *)(a2 + 36) = 0;
      }
    }
    else
    {
      v12 = (*(unsigned __int16 *)(a2 + 76) + 128) >> 8;
      v13 = (*(unsigned __int16 *)(a2 + 78) + 128) >> 8;
      v3 = sub_10080(0, 4);
      if ( v3 )
      {
        v14 = 0;
LABEL_11:
        while ( !v14 && sub_10130(v3, &v11, &v10) == 1 )
        {
          for ( i = word_15B4E0[256 * (unsigned __int8)(v10 + v13) + (unsigned __int8)(v11 + v12)];
                ;
                i = *(unsigned __int16 *)(a1 + 22) )
          {
            a1 = dword_EA3E4[i];
            if ( a1 == dword_EA3E4[0] )
              break;
            if ( *(_BYTE *)(a1 + 63) == 9 && *(unsigned __int16 *)(a1 + 150) == *(__int16 *)(a2 + 26) )
            {
              v14 = 1;
              goto LABEL_11;
            }
          }
        }
        sub_10100(v3);
        if ( v14 )
        {
          v5 = (a1 - (dword_D41A0 + 28302)) / 168;
          v6 = *(_BYTE *)(a2 + 70);
          *(_WORD *)(a2 + 44) = 5;
          *(_BYTE *)(a2 + 70) = v6 + 1;
          *(_WORD *)(a2 + 36) = v5;
        }
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (0001F300) --------------------------------------------------------
int __usercall sub_1F300@<eax>(int a1@<esi>, int a2)
{
  int result; // eax

  sub_1D5D0(a2, 0);
  result = (unsigned __int8)(*(_BYTE *)(a2 + 73) - 1);
  switch ( *(_BYTE *)(a2 + 73) )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xD:
    case 0xE:
    case 0x10:
      sub_1F0C0(a1, a2);
      goto LABEL_3;
    case 0x11:
LABEL_3:
      result = sub_1F040((_WORD *)a2);
      break;
    default:
      return result;
  }
  return result;
}

//----- (0001F340) --------------------------------------------------------
void __cdecl sub_1F340(int a1)
{
  sub_1BD90(a1, 8);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  if ( !(*(unsigned __int16 *)(a1 + 20) % 0x4Du) )
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 46);
  if ( *(_BYTE *)(a1 + 69) == 14 )
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001F3C0) --------------------------------------------------------
void __cdecl sub_1F3C0(int a1)
{
  sub_1BF90(a1, 8);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  if ( !(*(unsigned __int16 *)(a1 + 20) % 0x4Du) )
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 46);
  if ( *(_BYTE *)(a1 + 69) == 14 )
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001F440) --------------------------------------------------------
void __cdecl sub_1F440(int a1)
{
  *(_BYTE *)(a1 + 69) = 14;
  *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
  sub_1F530(a1);
}

//----- (0001F470) --------------------------------------------------------
void __cdecl sub_1F470(int a1)
{
  sub_1C560(a1, 8u);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  if ( !(*(unsigned __int16 *)(a1 + 20) % 0x4Du) )
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 46);
  if ( *(_BYTE *)(a1 + 69) == 14 )
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001F4F0) --------------------------------------------------------
int __cdecl sub_1F4F0(int a1)
{
  return sub_1C890(a1, 8);
}

//----- (0001F510) --------------------------------------------------------
void __cdecl sub_1F510(int a1)
{
  sub_1C930(a1);
}

//----- (0001F530) --------------------------------------------------------
void __cdecl sub_1F530(int a1)
{
  sub_1C980(a1, 8);
  if ( *(_BYTE *)(a1 + 69) != 14 )
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 134);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  if ( !(*(unsigned __int16 *)(a1 + 20) % 0x2Bu) )
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 46);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001F5B0) --------------------------------------------------------
__int16 __cdecl sub_1F5B0(int a1)
{
  __int16 result; // ax

  sub_1D5D0(a1, 8);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  if ( !(*(unsigned __int16 *)(a1 + 20) % 0x4Du) )
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 46);
  if ( *(_BYTE *)(a1 + 69) == 14 )
    result = *(_WORD *)(a1 + 132);
  else
    result = *(_WORD *)(a1 + 134);
  *(_WORD *)(a1 + 130) = result;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001F630) --------------------------------------------------------
int __cdecl sub_1F630(int a1)
{
  int result; // eax

  result = sub_1BD90(a1, 16);
  BYTE1(result) = *(_BYTE *)(a1 + 69);
  if ( BYTE1(result) == 18 )
    *(_DWORD *)(a1 + 16) = 1;
  return result;
}

//----- (0001F660) --------------------------------------------------------
void __cdecl sub_1F660(int a1)
{
  sub_1BF90(a1, 16);
  if ( *(_BYTE *)(a1 + 69) == 18 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, (*(_WORD *)(a1 + 20) & 1) + 12);
    *(_DWORD *)(a1 + 16) = 1;
  }
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001F6D0) --------------------------------------------------------
void __cdecl sub_1F6D0(int a1)
{
  int v1; // edx
  int v2; // eax
  unsigned __int16 v3; // dx
  int v4; // eax

  v1 = *(_DWORD *)(a1 + 16);
  if ( v1 )
  {
    v2 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v1 - 1;
    if ( v2 == 1 )
      *(_WORD *)(a1 + 130) = (5 * *(__int16 *)(a1 + 132)) >> 1;
  }
  v3 = *(_WORD *)(a1 + 150);
  if ( v3 )
  {
    v4 = *(__int16 *)(a1 + 80) - (*(__int16 *)(dword_EA3E4[v3] + 82) + *(__int16 *)(dword_EA3E4[v3] + 80));
    if ( v4 )
    {
      if ( v4 <= 0 )
        LOWORD(v4) = -1;
      else
        LOWORD(v4) = 1;
    }
    *(_WORD *)(a1 + 80) += v4 * *(_WORD *)(*(_DWORD *)(a1 + 160) + 14);
    if ( (unsigned __int16)sub_1C310(a1, 16, (unsigned __int16 (__cdecl *)(int, int))sub_1CE80) )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, (*(_WORD *)(a1 + 20) & 1) + 12);
      *(_WORD *)(a1 + 130) = -*(_WORD *)(a1 + 134);
      *(_DWORD *)(a1 + 16) = 3 * *(__int16 *)(*(_DWORD *)(a1 + 160) + 26);
    }
  }
  else
  {
    *(_BYTE *)(a1 + 69) = 17;
  }
  if ( *(_BYTE *)(a1 + 69) != 18 )
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001F800) --------------------------------------------------------
char __cdecl sub_1F800(int a1)
{
  char result; // al

  result = sub_1C560(a1, 0x10u);
  if ( *(_BYTE *)(a1 + 69) == 18 )
    *(_DWORD *)(a1 + 16) = 1;
  return result;
}

//----- (0001F830) --------------------------------------------------------
int __cdecl sub_1F830(int a1)
{
  return sub_1C890(a1, 16);
}

//----- (0001F850) --------------------------------------------------------
void __cdecl sub_1F850(int a1)
{
  sub_1C930(a1);
}

//----- (0001F8A0) --------------------------------------------------------
void __cdecl sub_1F8A0(int a1)
{
  __int16 v1; // si

  sub_1D5D0(a1, 16);
  if ( (*(_BYTE *)(a1 + 62) & 7) == 0 )
  {
    switch ( *(_BYTE *)(a1 + 73) )
    {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v1 = 2 * (*(unsigned __int16 *)(a1 + 20) % 0x9Du / 79i64);
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        *(_WORD *)(a1 + 32) += *(_WORD *)(a1 + 20) % 0x55u * (v1 - 1);
        *(_BYTE *)(a1 + 33) &= 7u;
        break;
      default:
        break;
    }
  }
  if ( *(_BYTE *)(a1 + 69) == 18 )
    *(_DWORD *)(a1 + 16) = 1;
}

//----- (0001F950) --------------------------------------------------------
int __cdecl sub_1F950(int a1)
{
  return sub_1BD90(a1, 24);
}

//----- (0001F970) --------------------------------------------------------
void __cdecl sub_1F970(int a1)
{
  sub_1BF90(a1, 24);
}

//----- (0001F990) --------------------------------------------------------
void __cdecl sub_1F990(int a1)
{
  if ( (unsigned __int16)sub_1C310(a1, 24, (unsigned __int16 (__cdecl *)(int, int))sub_1CC20) )
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 8);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0001F9E0) --------------------------------------------------------
char __cdecl sub_1F9E0(int a1)
{
  return sub_1C560(a1, 0x18u);
}

//----- (0001FA00) --------------------------------------------------------
int __cdecl sub_1FA00(int a1)
{
  return sub_1C890(a1, 24);
}

//----- (0001FA20) --------------------------------------------------------
void __cdecl sub_1FA20(int a1)
{
  sub_1C930(a1);
}

//----- (0001FA50) --------------------------------------------------------
void __cdecl sub_1FA50(int a1)
{
  sub_1D5D0(a1, 24);
}

//----- (0001FA70) --------------------------------------------------------
char __cdecl sub_1FA70(int a1)
{
  char result; // al

  result = sub_1BD90(a1, 32);
  if ( *(_BYTE *)(a1 + 69) == 34 )
    return sub_20060(a1);
  return result;
}

//----- (0001FAA0) --------------------------------------------------------
char __cdecl sub_1FAA0(int a1)
{
  __int16 v1; // cx
  unsigned int v2; // eax
  __int16 v3; // ax
  int i; // edx
  int v5; // edi
  int v6; // edx
  int j; // eax
  unsigned __int16 v8; // ax
  int v9; // edi
  int v10; // ecx
  unsigned int v11; // esi
  unsigned int v12; // edi
  int v13; // edx
  __int16 v14; // ax
  unsigned int v15; // esi
  int v16; // eax
  unsigned int v17; // esi
  int v18; // edi
  int v19; // edx
  unsigned int v20; // edx
  int v21; // eax
  unsigned int v22; // edi
  unsigned int k; // esi
  int v24; // edx
  __int16 v25; // ax
  int v26; // esi
  unsigned int v28; // [esp+0h] [ebp-28h]
  unsigned int v29; // [esp+4h] [ebp-24h]
  unsigned int v30; // [esp+8h] [ebp-20h]
  int v31; // [esp+Ch] [ebp-1Ch]
  int v32; // [esp+Ch] [ebp-1Ch]
  unsigned int v33; // [esp+14h] [ebp-14h]
  unsigned int v34; // [esp+18h] [ebp-10h]
  unsigned int v35; // [esp+1Ch] [ebp-Ch]
  unsigned int v36; // [esp+20h] [ebp-8h]

  v1 = *(_WORD *)(a1 + 98);
  v2 = 0;
  *(_DWORD *)(a1 + 16) = 0;
  if ( v1 )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v3 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v3;
    v2 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 == dword_EA3E4[0] )
        break;
      v5 = *(_DWORD *)(v6 + 8);
      if ( v5 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v5;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
        v2 = 1;
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v2 = 2;
  }
  if ( v2 )
  {
    if ( v2 <= 1 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      *(_BYTE *)(a1 + 69) = 34;
      LOBYTE(j) = sub_1EEE0(a1);
    }
    else
    {
      LOBYTE(j) = 36;
      *(_BYTE *)(a1 + 69) = 36;
    }
    goto LABEL_64;
  }
  sub_1B8C0(a1);
  LOWORD(j) = *(unsigned __int8 *)(a1 + 62) / *(__int16 *)(*(_DWORD *)(a1 + 160) + 26);
  if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
  {
    if ( *(_WORD *)(a1 + 150) )
    {
      LOWORD(j) = *(_WORD *)(a1 + 150);
      v26 = dword_EA3E4[(unsigned __int16)j];
      if ( *(_BYTE *)(v26 + 63) == 10 && *(_BYTE *)(v26 + 64) == 45 )
      {
        if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v26 + 76)) > 0x1000 )
        {
          LOWORD(j) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v26 + 76));
          *(_WORD *)(a1 + 32) = j;
        }
        else
        {
          *(_DWORD *)(a1 + 16) = 1;
          LOBYTE(j) = 36;
          *(_BYTE *)(a1 + 69) = 36;
          ++*(_DWORD *)(v26 + 16);
        }
      }
      else
      {
        *(_WORD *)(a1 + 150) = 0;
      }
      goto LABEL_64;
    }
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v8 = *(_WORD *)(a1 + 20);
    *(_WORD *)(a1 + 20) = 9377 * v8 + 9439;
    *(_WORD *)(a1 + 32) += ((unsigned __int8)*(_WORD *)(a1 + 20) + 85) * (2 * (v8 % 0x9Du / 79i64) - 1);
    v9 = *(_DWORD *)(a1 + 160);
    *(_BYTE *)(a1 + 33) &= 7u;
    v10 = 4 * *(__int16 *)(v9 + 26);
    j = *(unsigned __int8 *)(a1 + 62) / v10;
    if ( !(*(unsigned __int8 *)(a1 + 62) % v10) )
    {
      j = *(__int16 *)(v9 + 28) * *(__int16 *)(v9 + 28);
      v30 = -1;
      v11 = *(_DWORD *)(dword_D41A4 + 38519);
      v12 = 0;
      v29 = j;
      while ( v11 > dword_EA3E4[0] )
      {
        v13 = (__int16)(*(_WORD *)(v11 + 76) - *(_WORD *)(a1 + 76));
        v35 = (__int16)(*(_WORD *)(v11 + 78) - *(_WORD *)(a1 + 78))
            * (__int16)(*(_WORD *)(v11 + 78) - *(_WORD *)(a1 + 78))
            + v13 * v13;
        LOBYTE(j) = (*(_BYTE *)(v11 + 78) - *(_BYTE *)(a1 + 78)) * (*(_BYTE *)(v11 + 78) - *(_BYTE *)(a1 + 78))
                  + v13 * v13;
        if ( v35 <= v29 && (*(_BYTE *)(v11 + 12) & 0x20) == 0 )
        {
          v31 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 30);
          v14 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v11 + 76));
          j = (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v14);
          if ( j < v31 )
          {
            LOBYTE(j) = v35;
            if ( v35 < v30 )
            {
              v12 = v11;
              v30 = v35;
            }
          }
        }
        v11 = *(_DWORD *)v11;
      }
      v15 = v12;
      if ( v12 )
      {
        if ( v12 <= dword_EA3E4[0] || *(_BYTE *)(v12 + 64) > 1u || (j = *(_DWORD *)(v12 + 164), !*(_WORD *)(j + 584)) )
          v15 = 0;
      }
      if ( !v15 )
      {
        v16 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
        v33 = v16 * v16;
        v17 = -1;
        v18 = 0;
        for ( j = *(_DWORD *)(dword_D41A4 + 38439); (unsigned int)j > dword_EA3E4[0]; j = *(_DWORD *)j )
        {
          v19 = (__int16)(*(_WORD *)(j + 76) - *(_WORD *)(a1 + 76));
          v20 = v19 * v19
              + (__int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78))
              * (__int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78));
          if ( v20 <= v33 && v20 < v17 )
          {
            v18 = j;
            v17 = v20;
          }
        }
        v15 = v18;
      }
      if ( v15 )
      {
        if ( *(_BYTE *)(v15 + 63) != 10 || *(_BYTE *)(v15 + 64) != 45 )
        {
          *(_WORD *)(a1 + 150) = (int)(v15 - (dword_D41A0 + 28302)) / 168;
          LOBYTE(j) = 34;
LABEL_56:
          *(_BYTE *)(a1 + 69) = j;
        }
      }
      else
      {
        v21 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
        v22 = 0;
        v28 = v21 * v21;
        j = *(char *)(a1 + 64);
        v34 = -1;
        for ( k = *(_DWORD *)(dword_D41A4 + 4 * j + 38403); k > dword_EA3E4[0]; k = *(_DWORD *)k )
        {
          if ( !*(_WORD *)(k + 50) && k != a1 )
          {
            v24 = (__int16)(*(_WORD *)(k + 76) - *(_WORD *)(a1 + 76));
            v36 = (__int16)(*(_WORD *)(k + 78) - *(_WORD *)(a1 + 78))
                * (__int16)(*(_WORD *)(k + 78) - *(_WORD *)(a1 + 78))
                + v24 * v24;
            LOBYTE(j) = (*(_BYTE *)(k + 78) - *(_BYTE *)(a1 + 78)) * (*(_BYTE *)(k + 78) - *(_BYTE *)(a1 + 78))
                      + v24 * v24;
            if ( v36 <= v28 )
            {
              v32 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 30);
              v25 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(k + 76));
              j = (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v25);
              if ( j < v32 )
              {
                LOBYTE(j) = v36;
                if ( v36 < v34 )
                {
                  v22 = k;
                  v34 = v36;
                }
              }
            }
          }
        }
        if ( v22 )
        {
          *(_WORD *)(a1 + 50) = (int)(v22 - (dword_D41A0 + 28302)) / 168;
          LOBYTE(j) = 35;
          goto LABEL_56;
        }
      }
    }
  }
LABEL_64:
  if ( *(_BYTE *)(a1 + 69) == 34 )
    LOBYTE(j) = sub_20060(a1);
  return j;
}
// 1FB44: conditional instruction was optimized away because eax.4==2
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001FF40) --------------------------------------------------------
unsigned int __cdecl sub_1FF40(int a1)
{
  unsigned int result; // eax

  sub_1C310(a1, 32, (unsigned __int16 (__cdecl *)(int, int))sub_1CCE0);
  if ( *(_BYTE *)(a1 + 69) != 34 )
    return (unsigned int)sub_200F0(a1);
  result = *(unsigned __int8 *)(a1 + 62) / *(__int16 *)(*(_DWORD *)(a1 + 160) + 26);
  if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
  {
    result = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( result > dword_EA3E4[0] && *(_BYTE *)(result + 64) <= 1u )
    {
      result = *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 164);
      *(_WORD *)(result + 584) = 200;
    }
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0001FFE0) --------------------------------------------------------
char __cdecl sub_1FFE0(int a1)
{
  char result; // al

  result = sub_1C560(a1, 0x20u);
  if ( *(_BYTE *)(a1 + 69) == 34 )
    return sub_20060(a1);
  return result;
}

//----- (00020010) --------------------------------------------------------
int __cdecl sub_20010(int a1)
{
  if ( *(_DWORD *)(a1 + 16) )
    return sub_57F10(a1);
  else
    return sub_1C890(a1, 32);
}

//----- (00020040) --------------------------------------------------------
void __cdecl sub_20040(int a1)
{
  sub_1C930(a1);
}

//----- (00020060) --------------------------------------------------------
char __cdecl sub_20060(int a1)
{
  signed int v1; // edx
  char result; // al

  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  v1 = *(unsigned __int16 *)(a1 + 20) % 0x14u;
  *(_WORD *)(a1 + 130) = 0;
  if ( v1 <= 10 )
    sub_49CD0((_WORD *)a1, 206);
  else
    sub_49CD0((_WORD *)a1, 1);
  sub_49EA0((_WORD *)a1, 128, 256);
  *(_BYTE *)(a1 + 65) = *(_BYTE *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 63);
  result = *(_BYTE *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 64);
  *(_BYTE *)(a1 + 66) = result;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000200F0) --------------------------------------------------------
_WORD *__cdecl sub_200F0(int a1)
{
  _WORD *result; // eax

  *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
  sub_49CD0((_WORD *)a1, 0);
  result = sub_49EA0((_WORD *)a1, 128, 256);
  *(_BYTE *)(a1 + 65) = 3;
  *(_BYTE *)(a1 + 66) = -1;
  return result;
}

//----- (00020140) --------------------------------------------------------
void __cdecl sub_20140(int a1)
{
  *(_DWORD *)(a1 + 16) = 0;
  sub_1D5D0(a1, 32);
  if ( *(_BYTE *)(a1 + 69) == 34 )
    sub_20060(a1);
}

//----- (00020370) --------------------------------------------------------
int __cdecl sub_20370(int a1)
{
  int result; // eax
  int v2; // edx

  result = *(_DWORD *)(a1 + 16);
  v2 = result - 1;
  *(_DWORD *)(a1 + 16) = result - 1;
  if ( result )
  {
    if ( v2 < 16 )
    {
      result = v2 / 2;
      if ( !(v2 % 2) )
        return sub_585A0(a1);
    }
  }
  else
  {
    sub_20F20(a1);
    *(_BYTE *)(a1 + 69) = 73;
    *(_DWORD *)(a1 + 16) = 400;
    *(_BYTE *)(a1 + 70) = 0;
    return sub_122A0(a1);
  }
  return result;
}

//----- (000203D0) --------------------------------------------------------
void __cdecl sub_203D0(int a1)
{
  int v1; // edx
  char v2; // al
  unsigned int v3; // esi
  __int16 v4; // ax
  int i; // eax
  int v6; // edx
  int v7; // eax
  unsigned int v8; // edx
  int v9; // edi
  unsigned int j; // esi
  int v11; // eax
  unsigned int v12; // eax
  unsigned __int16 v13; // ax
  int v14; // eax
  int v15; // edi
  unsigned int v16; // esi
  int v17; // edx
  int v18; // eax
  __int16 v19; // ax
  int v20; // esi
  unsigned int v21; // edx
  unsigned int v22; // edi
  int v23; // esi
  unsigned int n; // eax
  int v25; // edx
  unsigned int v26; // edx
  unsigned int v27; // edi
  unsigned int k; // eax
  int v29; // edx
  unsigned int v30; // edx
  unsigned int v31; // edi
  unsigned int m; // eax
  int v33; // edx
  unsigned int v34; // edx
  int v35; // eax
  unsigned int v36; // [esp+0h] [ebp-24h]
  int v37; // [esp+4h] [ebp-20h]
  unsigned int v38; // [esp+8h] [ebp-1Ch]
  unsigned int v39; // [esp+Ch] [ebp-18h]
  int v40; // [esp+Ch] [ebp-18h]
  unsigned int v41; // [esp+10h] [ebp-14h]
  unsigned int v42; // [esp+14h] [ebp-10h]
  unsigned int v43; // [esp+18h] [ebp-Ch]
  unsigned int v44; // [esp+1Ch] [ebp-8h]

  v1 = *(_DWORD *)(a1 + 16);
  if ( v1 > 0 )
  {
    *(_DWORD *)(a1 + 16) = v1 - 1;
    if ( v1 == 1 )
      sub_20F60(a1);
  }
  v2 = *(_BYTE *)(a1 + 70);
  if ( v2 )
  {
    if ( v2 == 1 )
      sub_20940(a1);
    goto LABEL_81;
  }
  if ( *(_BYTE *)(a1 + 57) )
    *(_DWORD *)(a1 + 16) = 400;
  v3 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v4 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v3 = 1;
    *(_WORD *)(a1 + 38) = v4;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v7 + 52) )
    {
      v7 = dword_EA3E4[i];
      if ( v7 == dword_EA3E4[0] )
        break;
      v6 = *(_DWORD *)(v7 + 8);
      if ( v6 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v6;
        v3 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v7 + 38);
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    v3 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v3 )
  {
    if ( v3 <= 1 )
    {
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      *(_BYTE *)(a1 + 69) = 74;
    }
    else
    {
      *(_BYTE *)(a1 + 69) = 76;
    }
    goto LABEL_81;
  }
  sub_1B8C0(a1);
  if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
  {
    v8 = -1;
    v9 = 0;
    for ( j = *(_DWORD *)(dword_D41A4 + 38519); j > dword_EA3E4[0]; j = *(_DWORD *)j )
    {
      if ( *(_BYTE *)(j + 64) == 2 && *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26) )
      {
        v11 = (__int16)(*(_WORD *)(j + 76) - *(_WORD *)(a1 + 76));
        v12 = v11 * v11
            + (__int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78)) * (__int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78));
        if ( v12 < v8 )
        {
          v9 = j;
          v8 = v12;
        }
      }
    }
    v37 = v9;
    if ( v9 )
    {
      *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v9 + 76));
      v39 = *(__int16 *)(v9 + 84) + *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
      if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v9 + 76)) > v39 )
      {
        v37 = 0;
      }
      else
      {
        *(_WORD *)(a1 + 150) = (v9 - (dword_D41A0 + 28302)) / 168;
        *(_BYTE *)(a1 + 69) = 74;
      }
    }
    else
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v13 = *(_WORD *)(a1 + 20);
      *(_WORD *)(a1 + 20) = 9377 * v13 + 9439;
      *(_WORD *)(a1 + 32) += ((unsigned __int8)*(_WORD *)(a1 + 20) + 85) * (2 * (v13 % 0x9Du / 79i64) - 1);
      *(_BYTE *)(a1 + 33) &= 7u;
    }
    if ( !v37 )
    {
      if ( *(_BYTE *)(a1 + 57) )
      {
        v14 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
        v15 = 0;
        v42 = -1;
        v16 = *(_DWORD *)(dword_D41A4 + 38519);
        v38 = v14 * v14;
        while ( v16 > dword_EA3E4[0] )
        {
          if ( *(_WORD *)(v16 + 26) != *(_WORD *)(a1 + 26) )
          {
            v17 = (__int16)(*(_WORD *)(v16 + 76) - *(_WORD *)(a1 + 76));
            v18 = (__int16)(*(_WORD *)(v16 + 78) - *(_WORD *)(a1 + 78));
            v41 = v18 * v18 + v17 * v17;
            if ( v41 <= v38 && (*(_BYTE *)(v16 + 12) & 0x20) == 0 )
            {
              v40 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 30);
              v19 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v16 + 76));
              if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v19) < v40 && v41 < v42 )
              {
                v15 = v16;
                v42 = v41;
              }
            }
          }
          v16 = *(_DWORD *)v16;
        }
        v37 = v15;
        if ( v15 )
        {
          *(_WORD *)(a1 + 150) = (v15 - (dword_D41A0 + 28302)) / 168;
          *(_BYTE *)(a1 + 69) = 74;
        }
      }
      if ( !v37 )
      {
        v20 = *(_DWORD *)(a1 + 160);
        v21 = *(unsigned __int8 *)(a1 + 62) / *(__int16 *)(v20 + 26) % 3;
        if ( v21 )
        {
          if ( v21 <= 1 )
          {
            v44 = *(__int16 *)(v20 + 28) * *(__int16 *)(v20 + 28);
            v27 = -1;
            v23 = 0;
            for ( k = *(_DWORD *)(dword_D41A4 + 38451); k > dword_EA3E4[0]; k = *(_DWORD *)k )
            {
              v29 = (__int16)(*(_WORD *)(k + 76) - *(_WORD *)(a1 + 76));
              v30 = v29 * v29
                  + (__int16)(*(_WORD *)(k + 78) - *(_WORD *)(a1 + 78))
                  * (__int16)(*(_WORD *)(k + 78) - *(_WORD *)(a1 + 78));
              if ( v30 <= v44 && v30 < v27 )
              {
                v23 = k;
                v27 = v30;
              }
            }
          }
          else
          {
            if ( v21 != 2 )
              goto LABEL_75;
            v36 = *(__int16 *)(v20 + 28) * *(__int16 *)(v20 + 28);
            v31 = -1;
            v23 = 0;
            for ( m = *(_DWORD *)(dword_D41A4 + 38455); m > dword_EA3E4[0]; m = *(_DWORD *)m )
            {
              v33 = (__int16)(*(_WORD *)(m + 76) - *(_WORD *)(a1 + 76));
              v34 = v33 * v33
                  + (__int16)(*(_WORD *)(m + 78) - *(_WORD *)(a1 + 78))
                  * (__int16)(*(_WORD *)(m + 78) - *(_WORD *)(a1 + 78));
              if ( v34 <= v36 && v34 < v31 )
              {
                v23 = m;
                v31 = v34;
              }
            }
          }
        }
        else
        {
          v43 = *(__int16 *)(v20 + 28) * *(__int16 *)(v20 + 28);
          v22 = -1;
          v23 = 0;
          for ( n = *(_DWORD *)(dword_D41A4 + 38419); n > dword_EA3E4[0]; n = *(_DWORD *)n )
          {
            v25 = (__int16)(*(_WORD *)(n + 76) - *(_WORD *)(a1 + 76));
            v26 = v25 * v25
                + (__int16)(*(_WORD *)(n + 78) - *(_WORD *)(a1 + 78))
                * (__int16)(*(_WORD *)(n + 78) - *(_WORD *)(a1 + 78));
            if ( v26 <= v43 && v26 < v22 )
            {
              v23 = n;
              v22 = v26;
            }
          }
        }
        v37 = v23;
LABEL_75:
        if ( v37 )
        {
          if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v37 + 76)) <= 0x600 )
          {
            *(_DWORD *)&word_EB398 = *(_DWORD *)(v37 + 76);
            *(&word_EB398 + 2) = *(_WORD *)(v37 + 80);
            sub_57F10(v37);
            v35 = sub_4A190((int)&word_EB398, 5, 9);
            if ( v35 )
            {
              if ( *(_BYTE *)(dword_EA3E4[*(__int16 *)(a1 + 26)] + 63) == 3 )
                *(_WORD *)(v35 + 26) = *(_WORD *)(a1 + 26);
            }
          }
        }
      }
    }
  }
LABEL_81:
  if ( *(_BYTE *)(a1 + 69) == 74 )
    sub_20EC0(a1);
}
// 204A6: conditional instruction was optimized away because esi.4==2
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00020940) --------------------------------------------------------
void __cdecl sub_20940(int a1)
{
  signed int v1; // ecx
  __int16 v2; // ax
  int i; // eax
  int v4; // edx
  int v5; // eax
  __int16 v6; // ax
  int v7; // edx
  int v8; // esi
  unsigned int v9; // edx
  unsigned int v10; // edi
  unsigned int m; // ecx
  int v12; // eax
  unsigned int v13; // eax
  unsigned int v14; // edi
  unsigned int j; // ecx
  int v16; // eax
  unsigned int v17; // eax
  unsigned int v18; // edi
  unsigned int k; // ecx
  int v20; // eax
  unsigned int v21; // eax
  int v22; // edx
  int v23; // eax
  _WORD *v24; // [esp+10h] [ebp-4h]

  v1 = 0;
  v24 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v1 = 1;
    *(_WORD *)(a1 + 38) = v2;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        v1 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v1 )
  {
    if ( (unsigned int)v1 <= 1 )
    {
      v6 = *(_WORD *)(a1 + 38);
      *(_BYTE *)(a1 + 69) = 74;
      *(_WORD *)(a1 + 150) = v6;
    }
    else
    {
      *(_BYTE *)(a1 + 69) = 76;
    }
    return;
  }
  v7 = *(_DWORD *)(a1 + 16);
  if ( v7 < 0 )
  {
    *(_DWORD *)(a1 + 16) = v7 + 1;
    if ( v7 == -1 )
      sub_20F80(a1);
    return;
  }
  if ( *(_BYTE *)(a1 + 57) )
  {
    *(_DWORD *)(a1 + 16) = -50;
    return;
  }
  LOBYTE(v1) = *(_BYTE *)(a1 + 62);
  v8 = *(_DWORD *)(a1 + 160);
  if ( !(v1 % *(__int16 *)(v8 + 26)) )
  {
    v9 = v1 / *(__int16 *)(v8 + 26) % 3;
    if ( v9 )
    {
      if ( v9 <= 1 )
      {
        v14 = -1;
        v9 = 0;
        for ( j = *(_DWORD *)(dword_D41A4 + 38451); j > dword_EA3E4[0]; j = *(_DWORD *)j )
        {
          v16 = (__int16)(*(_WORD *)(j + 76) - *(_WORD *)(a1 + 76));
          v17 = v16 * v16
              + (__int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78))
              * (__int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78));
          if ( v17 <= *(__int16 *)(v8 + 28) * *(__int16 *)(v8 + 28) && v17 < v14 )
          {
            v9 = j;
            v14 = v17;
          }
        }
      }
      else
      {
        if ( v9 != 2 )
          goto LABEL_46;
        v18 = -1;
        v9 = 0;
        for ( k = *(_DWORD *)(dword_D41A4 + 38455); k > dword_EA3E4[0]; k = *(_DWORD *)k )
        {
          v20 = (__int16)(*(_WORD *)(k + 76) - *(_WORD *)(a1 + 76));
          v21 = v20 * v20
              + (__int16)(*(_WORD *)(k + 78) - *(_WORD *)(a1 + 78))
              * (__int16)(*(_WORD *)(k + 78) - *(_WORD *)(a1 + 78));
          if ( v21 <= *(__int16 *)(v8 + 28) * *(__int16 *)(v8 + 28) && v21 < v18 )
          {
            v9 = k;
            v18 = v21;
          }
        }
      }
    }
    else
    {
      v10 = -1;
      for ( m = *(_DWORD *)(dword_D41A4 + 38419); m > dword_EA3E4[0]; m = *(_DWORD *)m )
      {
        v12 = (__int16)(*(_WORD *)(m + 76) - *(_WORD *)(a1 + 76));
        v13 = v12 * v12
            + (__int16)(*(_WORD *)(m + 78) - *(_WORD *)(a1 + 78)) * (__int16)(*(_WORD *)(m + 78) - *(_WORD *)(a1 + 78));
        if ( v13 <= *(__int16 *)(v8 + 28) * *(__int16 *)(v8 + 28) && v13 < v10 )
        {
          v9 = m;
          v10 = v13;
        }
      }
    }
    v24 = (_WORD *)v9;
LABEL_46:
    if ( v24 )
    {
      v22 = (__int16)(v24[38] - *(_WORD *)(a1 + 76));
      if ( sub_7277A(
             (__int16)(v24[39] - *(_WORD *)(a1 + 78)) * (__int16)(v24[39] - *(_WORD *)(a1 + 78))
           + v22 * v22
           + (__int16)(v24[40] - *(_WORD *)(a1 + 80)) * (__int16)(v24[40] - *(_WORD *)(a1 + 80))) <= 0x600 )
      {
        *(_DWORD *)&word_EB398 = *((_DWORD *)v24 + 19);
        *(&word_EB398 + 2) = v24[40];
        sub_57F10((int)v24);
        v23 = sub_4A190((int)&word_EB398, 5, 9);
        if ( v23 )
          *(_WORD *)(v23 + 26) = *(_WORD *)(a1 + 26);
      }
    }
  }
}
// 209DA: conditional instruction was optimized away because ecx.4==2
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00020C50) --------------------------------------------------------
void __cdecl sub_20C50(int a1)
{
  unsigned int v1; // esi
  __int16 v2; // ax
  int i; // eax
  int v4; // eax
  int v5; // ecx
  unsigned int v6; // eax
  unsigned int v7; // esi
  int v8; // edi
  unsigned int v9; // edi

  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v1 = 1;
    *(_WORD *)(a1 + 38) = v2;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        v1 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v1 )
  {
    if ( v1 <= 1 )
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
    else
      *(_BYTE *)(a1 + 69) = 76;
    goto LABEL_29;
  }
  sub_1B8C0(a1);
  v6 = sub_1ED30(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
  v7 = v6;
  if ( v6 <= dword_EA3E4[0] || *(int *)(v6 + 8) < 0 || (*(_BYTE *)(v6 + 13) & 4) != 0 )
  {
LABEL_28:
    *(_BYTE *)(a1 + 69) = 73;
    goto LABEL_29;
  }
  if ( !(*(unsigned __int8 *)(a1 + 62) % 10) )
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v6 + 76));
  v8 = *(_DWORD *)(a1 + 160);
  if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(v8 + 26)) )
  {
    v9 = *(__int16 *)(v8 + 28);
    if ( *(_BYTE *)(v7 + 63) == 3 && *(_BYTE *)(v7 + 64) == 2 )
      v9 += *(__int16 *)(v7 + 84);
    if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v7 + 76)) < v9 )
    {
      sub_1CDA0((_WORD *)a1, v7);
      goto LABEL_29;
    }
    goto LABEL_28;
  }
LABEL_29:
  if ( *(_BYTE *)(a1 + 69) != 74 )
    sub_20F20(a1);
}
// 20CE2: conditional instruction was optimized away because esi.4==2
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00020E50) --------------------------------------------------------
char __cdecl sub_20E50(int a1)
{
  char result; // al

  result = sub_1C560(a1, 0x48u);
  if ( *(_BYTE *)(a1 + 69) == 74 )
    return sub_20EC0(a1);
  return result;
}

//----- (00020E80) --------------------------------------------------------
int __cdecl sub_20E80(int a1)
{
  return sub_1C890(a1, 72);
}

//----- (00020EA0) --------------------------------------------------------
void __cdecl sub_20EA0(int a1)
{
  sub_1C930(a1);
}

//----- (00020EC0) --------------------------------------------------------
char __cdecl sub_20EC0(int a1)
{
  int v1; // esi
  char result; // al

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  if ( *(_WORD *)(a1 + 26) == *(_WORD *)(v1 + 26) )
  {
    *(_BYTE *)(a1 + 69) = 73;
  }
  else
  {
    *(_WORD *)(a1 + 130) = 0;
    sub_49CD0((_WORD *)a1, 202);
    *(_BYTE *)(a1 + 65) = *(_BYTE *)(v1 + 63);
    result = *(_BYTE *)(v1 + 64);
    *(_BYTE *)(a1 + 66) = result;
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00020F20) --------------------------------------------------------
int __cdecl sub_20F20(int a1)
{
  int result; // eax

  *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
  result = sub_49CD0((_WORD *)a1, 201);
  *(_BYTE *)(a1 + 65) = 3;
  *(_BYTE *)(a1 + 66) = -1;
  *(_DWORD *)(a1 + 16) = 50;
  *(_BYTE *)(a1 + 70) = 0;
  return result;
}

//----- (00020F60) --------------------------------------------------------
int __cdecl sub_20F60(int a1)
{
  int result; // eax

  result = sub_49CD0((_WORD *)a1, 201);
  *(_BYTE *)(a1 + 70) = 1;
  return result;
}

//----- (00020F80) --------------------------------------------------------
int __cdecl sub_20F80(int a1)
{
  *(_BYTE *)(a1 + 70) = 0;
  *(_DWORD *)(a1 + 16) = 400;
  return sub_49CD0((_WORD *)a1, 201);
}

//----- (00020FC0) --------------------------------------------------------
void __cdecl sub_20FC0(int a1)
{
  sub_1D5D0(a1, 72);
  if ( *(_BYTE *)(a1 + 69) == 74 )
    sub_20EC0(a1);
}

//----- (00021030) --------------------------------------------------------
__int16 __cdecl sub_21030(int a1)
{
  int v1; // esi
  unsigned __int8 v2; // al
  int v3; // eax
  char v4; // dh
  int v5; // edx
  int v6; // ecx
  int v7; // edi
  int v8; // eax
  int v9; // edi
  int v10; // edx
  int v11; // esi
  int v12; // eax
  int v13; // eax
  __int16 v14; // dx
  int v15; // ecx
  int v16; // edi
  char v17; // ah
  unsigned int i; // eax
  char v19; // dl
  int v20; // ecx
  int v21; // eax
  __int16 v22; // dx
  char v24; // [esp+0h] [ebp-4h]

  v24 = 0;
  sub_223E0();
  v1 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  if ( sub_21F60(a1) )
    *(_BYTE *)(a1 + 42) |= 1u;
  v2 = *(_BYTE *)(a1 + 70);
  if ( v2 > 1u && (v2 < 0xCu || v2 > 0xFu) && *(int *)(a1 + 8) >= 10 )
    sub_22190(a1);
  switch ( *(_BYTE *)(a1 + 70) )
  {
    case 0:
      v3 = dword_D41A0;
      *(_WORD *)((char *)&loc_36546 + dword_D41A0 + 2) = 1;
      *(_BYTE *)(a1 + 70) = 1;
      *(_WORD *)(a1 + 42) = 8;
      *(_DWORD *)(a1 + 16) = 15;
      LOWORD(v3) = *(_WORD *)(2124 * *(__int16 *)(v3 + 12) + v3 + 11240);
      *(_WORD *)(a1 + 44) = 22;
      *(_WORD *)(a1 + 150) = v3;
      word_DA7CA = 60;
      sub_22490((unsigned __int16 *)a1);
      goto LABEL_10;
    case 1:
LABEL_10:
      if ( sub_21490(a1) )
      {
        v4 = *(_BYTE *)(a1 + 42);
        *(_BYTE *)(a1 + 70) = 4;
        *(_BYTE *)(a1 + 42) = v4 | 0x80;
      }
      goto LABEL_48;
    case 2:
      v5 = 26 * *(_DWORD *)(a1 + 8);
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v6 = *(_DWORD *)(a1 + 4);
      v7 = *(_WORD *)(a1 + 20) & 7;
      *(_BYTE *)(a1 + 70) = 3;
      v8 = v5 / v6 - v7;
      *(_DWORD *)(a1 + 16) = v8;
      if ( v8 < 3 )
        *(_DWORD *)(a1 + 16) = 3;
      if ( *(int *)(a1 + 16) > 26 )
        *(_DWORD *)(a1 + 16) = 26;
      *(_BYTE *)(a1 + 68) = 0;
      *(_WORD *)(a1 + 44) = 22;
      sub_221F0(a1, 341);
      goto LABEL_17;
    case 3:
LABEL_17:
      if ( *(int *)(a1 + 8) < 10 )
      {
        *(_BYTE *)(a1 + 70) = 12;
        goto LABEL_48;
      }
      if ( (*(_BYTE *)(a1 + 42) & 1) != 0 )
        goto LABEL_26;
      --*(_DWORD *)(a1 + 16);
      if ( (int)sub_58490((_WORD *)(v1 + 76), (_WORD *)(a1 + 76)) < 0x2000 && *(int *)(a1 + 16) <= 0 )
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        if ( (int)(*(unsigned __int16 *)(a1 + 20) % 0xCu) < 9 )
        {
          *(_BYTE *)(a1 + 70) = 4;
          goto LABEL_48;
        }
LABEL_26:
        *(_BYTE *)(a1 + 70) = 6;
      }
LABEL_48:
      if ( v24 && (*(_BYTE *)(a1 + 62) & 3) == 0 )
        sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 63);
      return sub_22270(a1);
    case 4:
      *(_BYTE *)(a1 + 70) = 5;
      *(_DWORD *)(a1 + 16) = 6;
      *(_BYTE *)(a1 + 68) = 2;
      *(_WORD *)(a1 + 44) = 113;
      goto LABEL_25;
    case 5:
LABEL_25:
      v9 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v9;
      if ( v9 <= 0 )
        goto LABEL_26;
      goto LABEL_48;
    case 6:
      *(_BYTE *)(a1 + 70) = 7;
      *(_DWORD *)(a1 + 16) = 16;
      *(_BYTE *)(a1 + 68) = 0;
      *(_WORD *)(a1 + 44) = 113;
      sub_221F0(a1, 343);
      goto LABEL_28;
    case 7:
LABEL_28:
      v10 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v10;
      if ( v10 <= 0 )
        *(_BYTE *)(a1 + 70) = 8;
      goto LABEL_48;
    case 8:
      *(_BYTE *)(a1 + 70) = 9;
      *(_DWORD *)(a1 + 16) = 0;
      *(_BYTE *)(a1 + 68) = 3;
      *(_WORD *)(a1 + 44) = 22;
      sub_221F0(a1, 342);
      sub_21850(a1);
      goto LABEL_31;
    case 9:
LABEL_31:
      sub_21AB0(a1);
      v11 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v11;
      if ( v11 <= 0 )
        *(_BYTE *)(a1 + 70) = 10;
      goto LABEL_48;
    case 0xA:
      *(_BYTE *)(a1 + 70) = 11;
      *(_DWORD *)(a1 + 16) = 16;
      *(_WORD *)(a1 + 44) = 22;
      sub_221F0(a1, 344);
      goto LABEL_34;
    case 0xB:
LABEL_34:
      v12 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v12;
      if ( v12 <= 0 )
        *(_BYTE *)(a1 + 70) = 2;
      goto LABEL_48;
    case 0xC:
      *(_BYTE *)(a1 + 70) = 13;
      *(_DWORD *)(a1 + 16) = 32;
      v13 = sub_4A190(a1 + 76, 10, 17);
      if ( v13 )
      {
        v14 = *(_WORD *)(v1 + 26);
        *(_WORD *)(v13 + 80) = 0;
        *(_DWORD *)(v13 + 4) = 70;
        *(_WORD *)(v13 + 26) = v14;
        *(_DWORD *)(v13 + 8) = *(_DWORD *)(v13 + 4);
      }
      goto LABEL_38;
    case 0xD:
LABEL_38:
      v24 = 1;
      v15 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v15;
      if ( v15 <= 0 )
      {
        *(_BYTE *)(a1 + 70) = 14;
        *(_DWORD *)(a1 + 16) = 32;
        sub_221F0(a1, 345);
      }
      goto LABEL_48;
    case 0xE:
      v24 = 1;
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
      v16 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v16;
      if ( v16 <= 0 )
      {
        *(_BYTE *)(a1 + 70) = 15;
        *(_DWORD *)(a1 + 16) = 60;
        v17 = *(_BYTE *)(a1 + 12);
        *(_DWORD *)(a1 + 8) = -1;
        *(_BYTE *)(a1 + 12) = v17 | 1;
        sub_1B5F0();
        for ( i = *(_DWORD *)(dword_D41A4 + 38523); i > dword_EA3E4[0]; i = *(_DWORD *)i )
        {
          v19 = *(_BYTE *)(i + 13);
          *(_DWORD *)(i + 4) = 140;
          *(_BYTE *)(i + 13) = v19 | 0x20;
          *(_DWORD *)(i + 8) = *(_DWORD *)(i + 4);
        }
      }
      goto LABEL_48;
    case 0xF:
      sub_1B5F0();
      v20 = *(_DWORD *)(a1 + 16) - 1;
      v24 = 1;
      *(_DWORD *)(a1 + 16) = v20;
      if ( v20 <= 0 )
      {
        v21 = sub_4A190(a1 + 76, 10, 9);
        if ( v21 )
        {
          v22 = *(_WORD *)(v1 + 26);
          *(_DWORD *)(v21 + 8) = 32;
          *(_DWORD *)(v21 + 4) = 11;
          *(_WORD *)(v21 + 26) = v22;
          *((_BYTE *)&loc_36E03 + dword_D41A0) = 1;
        }
        *(_WORD *)((char *)&loc_36546 + dword_D41A0 + 2) = 0;
        sub_57F10(a1);
      }
      goto LABEL_48;
    default:
      goto LABEL_48;
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// DA7CA: using guessed type __int16 word_DA7CA;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00021490) --------------------------------------------------------
char __cdecl sub_21490(int a1)
{
  char v1; // cl
  int v2; // edx
  int v3; // esi
  int v4; // esi
  unsigned __int16 v5; // ax
  char v6; // ah
  unsigned int v7; // esi
  char v8; // dh
  char v9; // al
  char v10; // dl
  char v11; // cl
  int v12; // edx
  char v13; // ah
  unsigned int i; // esi
  int v15; // eax
  int v16; // eax
  int v18; // [esp+0h] [ebp-30h] BYREF
  __int16 v19; // [esp+4h] [ebp-2Ch]
  int v20; // [esp+8h] [ebp-28h] BYREF
  int v21; // [esp+Ch] [ebp-24h] BYREF
  int v22; // [esp+10h] [ebp-20h]
  int v23; // [esp+14h] [ebp-1Ch]
  int v24; // [esp+18h] [ebp-18h]
  int v25; // [esp+1Ch] [ebp-14h]
  char v26; // [esp+20h] [ebp-10h]
  char v27; // [esp+24h] [ebp-Ch]
  char v28; // [esp+28h] [ebp-8h]
  unsigned __int8 v29; // [esp+2Ch] [ebp-4h]

  v1 = *(_BYTE *)(a1 + 42);
  v27 = 1;
  v29 = 0;
  v26 = 0;
  if ( (v1 & 8) != 0 )
  {
    v25 = (*(__int16 *)(a1 + 76) + 128) >> 8;
    v2 = *(_DWORD *)(a1 + 16);
    v22 = (*(__int16 *)(a1 + 78) + 128) >> 8;
    if ( v2 < 0 )
    {
      v28 = 1;
      v4 = sub_10080(0, 7);
      if ( v4 )
      {
        while ( sub_10130(v4, &v21, &v20) == 1 && v28 )
        {
          LOBYTE(v5) = v21 + v25;
          HIBYTE(v5) = v20 + v22;
          if ( byte_10B4E0[v5] )
            v28 = 0;
        }
        sub_10100(v4);
      }
      if ( v28 )
      {
        v6 = *(_BYTE *)(a1 + 42) | 4;
        *(_DWORD *)(a1 + 16) = 70;
        *(_BYTE *)(a1 + 42) = v6 & 0xF7;
      }
      else
      {
        *(_DWORD *)(a1 + 16) = 15;
      }
    }
    else
    {
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
      v3 = sub_10080(0, 15 - *(_DWORD *)(a1 + 16));
      if ( v3 )
      {
        while ( sub_10130(v3, &v21, &v20) == 1 )
          sub_56F10(v21 + v25, v20 + v22, -1, 0);
        sub_10100(v3);
      }
      --*(_DWORD *)(a1 + 16);
    }
  }
  else if ( (v1 & 4) != 0 )
  {
    sub_1B5F0();
    v7 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v7 - 1;
    if ( v7 < 0x11 )
    {
      if ( v7 )
      {
        if ( v7 == 1 )
          v29 = 3;
      }
      else
      {
        *(_BYTE *)(a1 + 42) = *(_BYTE *)(a1 + 42) & 0xEB | 0x10;
        v8 = *(_BYTE *)(a1 + 12);
        *(_DWORD *)(a1 + 16) = 1;
        *(_BYTE *)(a1 + 12) = v8 & 0xFE;
      }
    }
    else if ( v7 <= 0x11 )
    {
      v29 = 2;
    }
    else if ( v7 >= 0x23 )
    {
      if ( v7 <= 0x23 )
      {
        v29 = 1;
      }
      else if ( v7 == 70 )
      {
        *((_BYTE *)&loc_36DFC + dword_D41A0 + 4) = 0;
      }
    }
  }
  else if ( (v1 & 0x10) != 0 )
  {
    if ( *(_DWORD *)(a1 + 16) == 1 )
    {
      v11 = *(_BYTE *)(a1 + 42);
      *(_DWORD *)(a1 + 16) = 0;
      *(_BYTE *)(a1 + 42) = v11 & 0xBF;
    }
    else if ( (v1 & 0x40) != 0 )
    {
      if ( sub_58490(
             (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)]
                     + 76),
             (_WORD *)(a1 + 76)) >= 0xA00 )
      {
        *(_BYTE *)(a1 + 42) &= ~0x40u;
      }
      else
      {
        v9 = *(_BYTE *)(a1 + 42);
        v10 = *(_BYTE *)(a1 + 14);
        *(_DWORD *)(a1 + 16) = 30;
        v9 |= 0x20u;
        *(_BYTE *)(a1 + 42) = v9;
        *(_BYTE *)(a1 + 14) = v10 & 0x7F;
        *(_BYTE *)(a1 + 42) = v9 & 0xEF;
      }
    }
  }
  else if ( (v1 & 0x20) != 0 )
  {
    if ( *(int *)(a1 + 16) >= 600 )
      v27 = 0;
    v12 = *(_DWORD *)(a1 + 16) + 30;
    *(_DWORD *)(a1 + 16) = v12;
    if ( v12 >= 1200 )
    {
      v13 = *(_BYTE *)(a1 + 42);
      *(_DWORD *)(a1 + 16) = 1200;
      *(_BYTE *)(a1 + 42) = v13 & 0xDF;
    }
    word_DA7CA = *(_WORD *)(a1 + 16);
  }
  else
  {
    v26 = 1;
  }
  if ( v29 )
  {
    for ( i = *(_DWORD *)(dword_D41A4 + 38523); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( v29 < 2u )
      {
        if ( v29 == 1 )
        {
          *(_BYTE *)(i + 15) |= 1u;
          *(_BYTE *)(i + 14) &= ~0x80u;
        }
      }
      else if ( v29 <= 2u )
      {
        *(_BYTE *)(i + 14) |= 0x80u;
        *(_BYTE *)(i + 15) &= ~1u;
      }
      else if ( v29 == 3 )
      {
        sub_57F10(i);
      }
    }
  }
  if ( v27 )
  {
    *(_WORD *)(a1 + 40) += 96;
    *(_BYTE *)(a1 + 41) &= 7u;
    v24 = 0;
    v15 = *(unsigned __int16 *)(a1 + 40);
    while ( 1 )
    {
      v23 = v15;
      if ( v24 >= 4 )
        break;
      v18 = *(_DWORD *)(a1 + 76);
      v19 = *(_WORD *)(a1 + 80);
      sub_57FA0(&v18, v23, 0, 192);
      v16 = sub_4A190((int)&v18, 10, 14);
      if ( v16 )
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        *(_DWORD *)(v16 + 8) = (*(_WORD *)(a1 + 20) & 7) + 8;
      }
      v15 = ((_WORD)v23 + 512) & 0x7FF;
      ++v24;
    }
  }
  return v26;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// DA7CA: using guessed type __int16 word_DA7CA;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00021850) --------------------------------------------------------
void __cdecl sub_21850(int a1)
{
  int v1; // ecx
  char v2; // ah
  int v3; // esi
  signed int v4; // edx
  char v5; // al
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  signed int v10; // edx

  v1 = 0;
  v2 = *(_BYTE *)(a1 + 42) & 0xFD;
  v3 = 0;
  *(_BYTE *)(a1 + 42) = v2;
  if ( (v2 & 1) != 0 )
  {
    *(_BYTE *)(a1 + 42) = v2 & 0xFE;
    if ( *(_BYTE *)(a1 + 57) )
    {
      v3 = 1;
      *(_BYTE *)(a1 + 42) = v2 & 0xFC | 2;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 42) = v2 | 2;
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v4 = *(unsigned __int16 *)(a1 + 20) % 0x46u;
    v5 = *(_BYTE *)(a1 + 42);
    *(_WORD *)(a1 + 20) += *(_WORD *)(dword_D41A4 + 30);
    if ( v5 < 0 )
    {
      v4 = 0;
      *(_BYTE *)(a1 + 42) = v5 & 0x7F;
    }
    if ( v4 < 40 )
    {
      if ( v4 >= 3 && v4 <= 6 )
      {
        v3 = 1;
        goto LABEL_22;
      }
    }
    else if ( v4 > 48 )
    {
      if ( v4 > 58 )
      {
        if ( v4 > 68 )
        {
          *(_DWORD *)(a1 + 16) = 8;
          *(_WORD *)(a1 + 36) = 3;
          v9 = dword_D41A0;
          *(_WORD *)(a1 + 74) = 682;
          if ( *(__int16 *)((char *)&loc_3653D + v9 + 3) < 12 )
          {
            *(_BYTE *)(a1 + 67) = 4;
            goto LABEL_22;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 16) = 8;
          *(_WORD *)(a1 + 36) = 3;
          v8 = dword_D41A0;
          *(_WORD *)(a1 + 74) = 682;
          if ( *(__int16 *)((char *)&loc_36541 + v8 + 1) < 6 )
          {
            *(_BYTE *)(a1 + 67) = 5;
            goto LABEL_22;
          }
        }
      }
      else
      {
        *(_DWORD *)(a1 + 16) = 8;
        *(_WORD *)(a1 + 36) = 3;
        v7 = dword_D41A0;
        *(_WORD *)(a1 + 74) = 682;
        if ( *(__int16 *)((char *)&loc_3653D + v7 + 1) < 4 )
        {
          *(_BYTE *)(a1 + 67) = 3;
          goto LABEL_22;
        }
      }
    }
    else
    {
      *(_DWORD *)(a1 + 16) = 8;
      *(_WORD *)(a1 + 36) = 8;
      v6 = dword_D41A0;
      *(_WORD *)(a1 + 74) = 256;
      if ( *(__int16 *)((char *)&loc_36543 + v6 + 1) < 28 )
      {
        *(_BYTE *)(a1 + 67) = 6;
        goto LABEL_22;
      }
    }
    v1 = 1;
  }
LABEL_22:
  if ( v1 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v10 = *(unsigned __int16 *)(a1 + 20) % 0x1Du;
    *(_WORD *)(a1 + 20) += *(_WORD *)(dword_D41A4 + 30);
    if ( v10 > 7 )
    {
      if ( v10 > 17 )
      {
        if ( v10 > 25 )
        {
          if ( v10 > 27 )
          {
            v3 = 1;
          }
          else
          {
            *(_BYTE *)(a1 + 67) = 8;
            *(_WORD *)(a1 + 36) = 1;
            *(_DWORD *)(a1 + 16) = 5;
          }
        }
        else
        {
          *(_BYTE *)(a1 + 67) = 9;
          *(_WORD *)(a1 + 36) = 1;
          *(_DWORD *)(a1 + 16) = 5;
        }
      }
      else
      {
        *(_BYTE *)(a1 + 67) = 2;
        *(_WORD *)(a1 + 36) = 8;
        *(_DWORD *)(a1 + 16) = 8;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 67) = 1;
      *(_WORD *)(a1 + 36) = 10;
      *(_DWORD *)(a1 + 16) = 10;
    }
  }
  if ( v3 )
  {
    *(_BYTE *)(a1 + 67) = 7;
    *(_WORD *)(a1 + 36) = 24;
    *(_DWORD *)(a1 + 16) = 32;
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00021AB0) --------------------------------------------------------
void __cdecl sub_21AB0(int a1)
{
  int v1; // edx
  unsigned int v2; // eax
  __int16 v3; // dx
  __int16 v4; // ax
  _WORD *v5; // eax
  _WORD *v6; // eax
  _WORD *v7; // eax
  _WORD *v8; // eax
  __int16 v9; // ax
  _DWORD *v10; // eax
  int v11; // eax
  int v12; // esi
  int v13; // edx
  char v14; // cl
  int v15; // eax
  __int16 v16; // si
  unsigned __int16 v17; // ax
  int v18; // edi
  int v19; // esi
  __int16 v20; // ax
  _WORD *v21; // esi
  __int16 v22; // ax
  __int16 v23; // ax
  _WORD *v24; // edx
  _WORD *v25; // [esp-4h] [ebp-24h]
  _WORD *v26; // [esp-4h] [ebp-24h]
  unsigned int v27; // [esp-4h] [ebp-24h]
  int v28; // [esp+0h] [ebp-20h] BYREF
  __int16 v29; // [esp+4h] [ebp-1Ch]
  int v30; // [esp+8h] [ebp-18h]
  unsigned int v31; // [esp+Ch] [ebp-14h]
  int v32; // [esp+10h] [ebp-10h]
  _WORD *v33; // [esp+14h] [ebp-Ch]
  int v34; // [esp+18h] [ebp-8h]
  _DWORD *v35; // [esp+1Ch] [ebp-4h]

  v33 = 0;
  v35 = 0;
  v1 = 2124 * *(__int16 *)(dword_D41A0 + 12);
  v34 = -1;
  v2 = dword_EA3E4[*(unsigned __int16 *)(v1 + dword_D41A0 + 11240)];
  v31 = v2;
  if ( v2 > dword_EA3E4[0] && *(int *)(v2 + 8) >= 0 && (*(_BYTE *)(v2 + 13) & 4) == 0 )
  {
    v3 = *(_WORD *)(a1 + 36);
    if ( v3 )
    {
      *(_WORD *)(a1 + 36) = v3 - 1;
      v28 = *(_DWORD *)(a1 + 76);
      v29 = *(_WORD *)(a1 + 80);
      sub_57FA0(&v28, *(_WORD *)(a1 + 28), 0, 640);
      v4 = *(_WORD *)(a1 + 80);
      HIBYTE(v4) += 3;
      v29 = v4;
      switch ( *(_BYTE *)(a1 + 67) )
      {
        case 1:
          v5 = (_WORD *)sub_4A190((int)&v28, 9, 0);
          v33 = v5;
          if ( v5 )
          {
            *((_BYTE *)v5 + 67) = 10;
            *((_BYTE *)v5 + 68) = 0;
            *((_DWORD *)v5 + 40) = &off_D8412;
            v5[21] = 800;
            v34 = 15;
          }
          break;
        case 2:
          v6 = (_WORD *)sub_4A190((int)&v28, 9, 9);
          v33 = v6;
          if ( v6 )
          {
            *((_BYTE *)v6 + 67) = 10;
            *((_BYTE *)v6 + 68) = 23;
            *((_DWORD *)v6 + 40) = &off_D8412;
            v6[21] = 800;
            v34 = 23;
          }
          break;
        case 3:
        case 4:
        case 5:
        case 6:
          v32 = (*(_WORD *)(a1 + 74) * *(_WORD *)(a1 + 36) + *(_WORD *)(a1 + 28)) & 0x7FF;
          sub_57FA0(&v28, v32, 0, 1792);
          v9 = *(_WORD *)(a1 + 80);
          HIBYTE(v9) += 3;
          v29 = v9;
          switch ( *(_BYTE *)(a1 + 67) )
          {
            case 3:
              v10 = sub_4B240((int)&v28);
              goto LABEL_19;
            case 4:
              v10 = (_DWORD *)sub_4C8F0((int)&v28);
              goto LABEL_19;
            case 5:
              v10 = (_DWORD *)sub_4CE00((int)&v28);
              goto LABEL_19;
            case 6:
              v10 = (_DWORD *)sub_4C6B0((int)&v28);
LABEL_19:
              v35 = v10;
              break;
            default:
              break;
          }
          if ( v35 )
          {
            ++*(_DWORD *)((char *)&loc_364D1 + dword_D41A0 + 1);
            switch ( *(_BYTE *)(a1 + 67) )
            {
              case 3:
                v30 = 7;
                v34 = 8;
                break;
              case 4:
                v30 = 175;
                v34 = 42;
                break;
              case 5:
                v30 = 207;
                v34 = 37;
                break;
              case 6:
                v30 = 159;
                v34 = 44;
                break;
              default:
                break;
            }
            v11 = dword_D41A0;
            v12 = (int)v35;
            *((_WORD *)v35 + 75) = *(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240);
            *(_WORD *)(v12 + 26) = *(_WORD *)(a1 + 26);
            v13 = (int)v35;
            *((_BYTE *)v35 + 73) = 17;
            *(_WORD *)(v13 + 46) = 250;
            *(_WORD *)(v13 + 130) = 320;
            *(_WORD *)(v13 + 40) = (a1 - (v11 + 28302)) / 168;
            LOWORD(v11) = v32;
            *(_WORD *)(v13 + 28) = v32;
            *(_WORD *)(v13 + 32) = v11;
            *(_BYTE *)(v13 + 69) = v30;
          }
          break;
        case 7:
          if ( (*(_BYTE *)(a1 + 42) & 2) != 0 )
          {
            sub_5C800(v31, 6);
            *(_WORD *)((char *)&loc_36546 + dword_D41A0) = 1024;
            v14 = *(_BYTE *)(a1 + 42);
            v34 = 19;
            *(_BYTE *)(a1 + 42) = v14 & 0xFD;
          }
          v15 = dword_D41A0;
          v16 = *(_WORD *)((char *)&loc_36546 + dword_D41A0) - 80;
          *(_WORD *)((char *)&loc_36546 + dword_D41A0) = v16;
          if ( v16 < 10 )
            *(_WORD *)((char *)&loc_36546 + v15) = 10;
          if ( *(__int16 *)((char *)&loc_36546 + dword_D41A0) > 1024 )
            *(_WORD *)((char *)&loc_36546 + dword_D41A0) = 1024;
          v25 = (_WORD *)(v31 + 76);
          *(_DWORD *)&word_EB398 = *(_DWORD *)(v31 + 76);
          *(&word_EB398 + 2) = *(_WORD *)(v31 + 80);
          v17 = sub_581E0((_WORD *)(a1 + 76), v25);
          v32 = v17;
          sub_57FA0(&word_EB398, v17, 0, *(_WORD *)((char *)&loc_36546 + dword_D41A0));
          v18 = v31;
          if ( (unsigned __int16)sub_5D0A0(v31) )
          {
            v19 = *(__int16 *)(*(_DWORD *)(v18 + 160) + 12);
            v20 = sub_10C40(&word_EB398);
            if ( word_EB39C < v20 + v19 )
              word_EB39C = *(_WORD *)(*(_DWORD *)(v18 + 160) + 12) + v20;
            sub_57CF0(v31, v31, (int)&word_EB398);
          }
          break;
        case 8:
          v8 = (_WORD *)sub_4A190((int)&v28, 9, 26);
          v33 = v8;
          if ( v8 )
          {
            *((_BYTE *)v8 + 67) = 10;
            *((_BYTE *)v8 + 68) = 22;
            v8[21] = 20;
            *((_BYTE *)v8 + 70) = 3;
            v34 = 15;
          }
          break;
        case 9:
          v7 = (_WORD *)sub_4A190((int)&v28, 9, 3);
          v33 = v7;
          if ( v7 )
          {
            *((_BYTE *)v7 + 67) = 10;
            *((_BYTE *)v7 + 68) = 17;
            v7[21] = 6000;
            *((_BYTE *)v7 + 70) = 10;
            v34 = 15;
          }
          break;
        default:
          break;
      }
      if ( v33 )
      {
        v21 = (_WORD *)(v31 + 76);
        v26 = (_WORD *)(v31 + 76);
        v33[13] = *(_WORD *)(a1 + 26);
        v22 = sub_581E0((_WORD *)(a1 + 76), v26);
        v33[14] = v22;
        v23 = sub_58210((_WORD *)(a1 + 76), v21);
        v24 = v33;
        v33[15] = v23;
        *((_BYTE *)v24 + 66) = *(_BYTE *)(v31 + 64);
        v27 = v31;
        *((_BYTE *)v24 + 65) = *(_BYTE *)(v31 + 63);
        sub_5EF70(v27);
      }
    }
    if ( v34 >= 0 )
      sub_6E450(*(_WORD *)(a1 + 26), -1, v34);
  }
}
// D41A0: using guessed type int dword_D41A0;
// D8412: using guessed type void *off_D8412;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00021F60) --------------------------------------------------------
char __cdecl sub_21F60(int a1)
{
  unsigned int i; // ebx
  unsigned __int8 v2; // al
  int *v3; // edx
  _WORD *v4; // eax
  unsigned __int16 v5; // si
  int v6; // eax
  int v7; // eax
  __int16 v8; // di
  char *v10; // [esp-4h] [ebp-2Ch]
  int v11; // [esp+0h] [ebp-28h] BYREF
  int v12; // [esp+4h] [ebp-24h]
  char v13[2]; // [esp+8h] [ebp-20h] BYREF
  __int16 v14; // [esp+Ah] [ebp-1Eh]
  __int16 v15; // [esp+Ch] [ebp-1Ch]
  int v16; // [esp+10h] [ebp-18h] BYREF
  __int16 v17; // [esp+14h] [ebp-14h]
  int v18; // [esp+18h] [ebp-10h]
  _BOOL1 v19; // [esp+1Ch] [ebp-Ch]
  char v20; // [esp+20h] [ebp-8h]
  char v21; // [esp+24h] [ebp-4h]

  v21 = 0;
  v18 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v19 = *(_BYTE *)(a1 + 63) != 5 || *(_BYTE *)(a1 + 64) != 10;
  for ( i = *(_DWORD *)(dword_D41A4 + 38531); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    v2 = *(_BYTE *)(i + 64);
    v20 = 0;
    if ( v2 < 0xAu )
    {
      if ( v2 < 2u || v2 > 2u && (v2 < 4u || v2 > 5u) )
        goto LABEL_31;
      goto LABEL_19;
    }
    if ( v2 > 0xAu )
    {
      if ( v2 < 0x19u )
      {
        if ( v2 < 0x16u || v2 > 0x17u )
          goto LABEL_31;
      }
      else if ( v2 > 0x19u && v2 != 30 )
      {
        goto LABEL_31;
      }
LABEL_19:
      v3 = (int *)(i + 76);
      v4 = (_WORD *)(a1 + 76);
      if ( !v19 )
      {
        if ( sub_58490((_WORD *)(a1 + 76), (_WORD *)(i + 76)) <= 0xC00 )
        {
          v21 = 1;
          v20 = 1;
        }
        goto LABEL_31;
      }
      v14 = 5120;
      v15 = 5120;
      v10 = v13;
      goto LABEL_29;
    }
    v14 = 5120;
    v15 = 5120;
    HIWORD(v11) = 5120;
    LOWORD(v12) = 5120;
    v16 = *(_DWORD *)(i + 76);
    v17 = *(_WORD *)(i + 80);
    v5 = *(_WORD *)(*(_DWORD *)(v18 + 164) + 58);
    if ( v5 )
    {
      v6 = dword_EA3E4[v5];
      v16 = *(_DWORD *)(v6 + 76);
      v17 = *(_WORD *)(v6 + 80);
      v11 = *(_DWORD *)(v6 + 82);
      v12 = *(_DWORD *)(v6 + 86);
    }
    v4 = (_WORD *)(a1 + 76);
    if ( v19 )
    {
      v10 = (char *)&v11;
      v3 = &v16;
LABEL_29:
      if ( sub_106F0(v4, a1 + 82, v3, (int)v10) )
        v20 = 1;
      goto LABEL_31;
    }
    if ( sub_106F0((_WORD *)(a1 + 76), (int)v13, &v16, (int)&v11) )
    {
      v21 = 1;
      v20 = 1;
    }
LABEL_31:
    if ( v20 )
    {
      if ( *(_BYTE *)(i + 64) == 10 )
        *(_WORD *)(dword_EA3E4[*(__int16 *)(*(_DWORD *)(v18 + 164) + 823)] + 46) = 0;
      v7 = sub_4A190(i + 76, 10, 0);
      if ( v7 )
        *(_WORD *)(v7 + 26) = *(_WORD *)(a1 + 26);
      sub_57F10(i);
    }
  }
  v8 = *(_WORD *)(*(_DWORD *)(v18 + 164) + 835);
  if ( v8 && *(__int16 *)(dword_EA3E4[v8] + 46) > 0 )
    return 1;
  return v21;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00022190) --------------------------------------------------------
char __cdecl sub_22190(int a1)
{
  char v1; // dl
  int v2; // edx
  __int16 v3; // dx

  v1 = 0;
  if ( *(_BYTE *)(a1 + 57) )
  {
    if ( *(_WORD *)(a1 + 98) )
    {
      v2 = *(_DWORD *)(a1 + 94);
      if ( v2 < 1 )
        v2 = 1;
      if ( v2 > 300 )
        v2 = 300;
      *(_DWORD *)(a1 + 8) -= v2;
      v3 = *(_WORD *)(a1 + 98);
      *(_WORD *)(a1 + 98) = 0;
      *(_WORD *)(a1 + 38) = v3;
      v1 = 1;
    }
    else
    {
      *(_WORD *)(a1 + 38) = 0;
    }
  }
  if ( *(int *)(a1 + 8) < 10 )
  {
    v1 = 2;
    *(_DWORD *)(a1 + 8) = 8;
  }
  return v1;
}

//----- (000221F0) --------------------------------------------------------
char __cdecl sub_221F0(int a1, __int16 a2)
{
  int v2; // eax
  unsigned __int16 v3; // bx

  LOBYTE(v2) = sub_49C90(a1, a2);
  if ( (unsigned __int16)a2 >= 0x157u && (unsigned __int16)a2 <= 0x159u )
  {
    v3 = word_D951C[7 * a2];
    LOBYTE(v2) = sub_71AB0(v3, 1);
    if ( dword_F66F0[v3] )
    {
      v2 = *(unsigned __int16 *)(sub_724F0(dword_E9C08, v3) + 16);
      *(_DWORD *)(a1 + 16) = v2;
    }
  }
  return v2;
}
// D951C: using guessed type __int16 word_D951C[];
// E9C08: using guessed type int dword_E9C08;
// F66F0: using guessed type int dword_F66F0[504];

//----- (00022270) --------------------------------------------------------
__int16 __cdecl sub_22270(int a1)
{
  __int16 result; // ax
  int v2; // edx

  result = sub_10C40((__int16 *)(a1 + 76));
  v2 = *(_DWORD *)(a1 + 8);
  *(_WORD *)(a1 + 80) = result;
  if ( v2 >= 10 )
    return sub_222B0(a1);
  return result;
}

//----- (000222B0) --------------------------------------------------------
__int16 __cdecl sub_222B0(int a1)
{
  int v1; // eax
  unsigned int v2; // edx
  int v3; // esi
  __int16 v4; // dx
  __int16 v5; // ax
  char v6; // ch

  v1 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v2 = (((*(unsigned __int16 *)(a1 + 28) - *(unsigned __int16 *)(v1 + 28)) >> 3) & 0xF0) >> 4;
  v3 = 0;
  if ( v2 <= 2 )
  {
    LOWORD(v1) = *(_WORD *)(v1 + 28) + 384;
    *(_WORD *)(a1 + 28) = v1;
  }
  else if ( v2 >= 0xD && v2 <= 0xF )
  {
    LOWORD(v1) = *(_WORD *)(v1 + 28);
    BYTE1(v1) += 6;
    *(_WORD *)(a1 + 28) = v1;
  }
  else
  {
    switch ( *(_BYTE *)(a1 + 68) )
    {
      case 0:
        v3 = 1;
        LOWORD(v1) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
        goto LABEL_15;
      case 1:
        goto LABEL_13;
      case 2:
        if ( (*(_BYTE *)(dword_D41A4 + 26) & 1) != 0 )
          v4 = 512;
        else
          v4 = -512;
        v5 = *(_WORD *)(v1 + 28);
        HIBYTE(v5) += 4;
        LOWORD(v1) = v4 + v5;
        *(_WORD *)(a1 + 32) = v1;
        v6 = *(_BYTE *)(a1 + 33);
        *(_BYTE *)(a1 + 68) = 1;
        *(_BYTE *)(a1 + 33) = v6 & 7;
LABEL_13:
        v3 = 1;
        break;
      case 3:
        LOWORD(v1) = *(_WORD *)(a1 + 28);
LABEL_15:
        *(_WORD *)(a1 + 32) = v1;
        break;
      default:
        break;
    }
    if ( v3 )
    {
      LOWORD(v1) = sub_58350(
                     *(_WORD *)(a1 + 28),
                     *(_WORD *)(a1 + 32),
                     *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 4),
                     *(_WORD *)(a1 + 44));
      *(_WORD *)(a1 + 28) += v1;
    }
  }
  *(_BYTE *)(a1 + 29) &= 7u;
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000223E0) --------------------------------------------------------
unsigned int sub_223E0()
{
  int v0; // edx
  int v1; // ecx
  _DWORD *i; // eax
  _DWORD *j; // eax
  _DWORD *k; // eax
  unsigned int result; // eax

  v0 = dword_D41A0;
  v1 = dword_D41A4;
  *(_WORD *)((char *)&loc_3653D + dword_D41A0 + 1) = 0;
  for ( i = *(_DWORD **)(v1 + 38403); (unsigned int)i > dword_EA3E4[0]; i = (_DWORD *)*i )
    ++*(_WORD *)((char *)&loc_3653D + v0 + 1);
  *(_WORD *)((char *)&loc_3653D + v0 + 3) = 0;
  for ( j = *(_DWORD **)(v1 + 38403); (unsigned int)j > dword_EA3E4[0]; j = (_DWORD *)*j )
    ++*(_WORD *)((char *)&loc_3653D + v0 + 3);
  *(_WORD *)((char *)&loc_36543 + v0 + 1) = 0;
  for ( k = *(_DWORD **)(v1 + 38403); (unsigned int)k > dword_EA3E4[0]; k = (_DWORD *)*k )
    ++*(_WORD *)((char *)&loc_36543 + v0 + 1);
  *(_WORD *)((char *)&loc_36541 + v0 + 1) = 0;
  for ( result = *(_DWORD *)(v1 + 38503); result > dword_EA3E4[0]; result = *(_DWORD *)result )
  {
    if ( *(_BYTE *)(result + 69) != 0xC8 )
      ++*(_WORD *)((char *)&loc_36541 + v0 + 1);
  }
  dword_D41A4 = v1;
  dword_D41A0 = v0;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00022490) --------------------------------------------------------
char __cdecl sub_22490(unsigned __int16 *a1)
{
  unsigned __int16 v1; // ax
  int v2; // esi
  unsigned __int16 v3; // bx
  int i; // edi
  unsigned __int16 v6; // [esp+8h] [ebp-4h]

  LOBYTE(v1) = ((unsigned __int16)(a1[38] + 128) >> 8) - 19;
  HIBYTE(v1) = ((unsigned __int16)(a1[39] + 128) >> 8) - 19;
  v2 = 0;
  v6 = v1;
  do
  {
    v3 = v6;
    for ( i = 0; i < 38; ++i )
    {
      LOBYTE(v1) = sub_57390(v3, a1[13]);
      LOBYTE(v3) = v3 + 1;
    }
    ++v2;
    ++HIBYTE(v6);
  }
  while ( v2 < 38 );
  return v1;
}

//----- (00022530) --------------------------------------------------------
int __cdecl sub_22530(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = 80;
  return result;
}

//----- (00022540) --------------------------------------------------------
int __cdecl sub_22540(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = 80;
  return result;
}

//----- (00022550) --------------------------------------------------------
int __cdecl sub_22550(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = 80;
  return result;
}

//----- (00022560) --------------------------------------------------------
int __cdecl sub_22560(int a1)
{
  return sub_1C890(a1, 80);
}

//----- (00022580) --------------------------------------------------------
void __cdecl sub_22580(int a1)
{
  sub_1C930(a1);
}

//----- (000225A0) --------------------------------------------------------
int __cdecl sub_225A0(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = 80;
  return result;
}

//----- (000225B0) --------------------------------------------------------
int __cdecl sub_225B0(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = 80;
  return result;
}

//----- (00022640) --------------------------------------------------------
_BOOL1 __cdecl sub_22640(_WORD *a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4)
{
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // bh

  v4 = HIBYTE(*a1) - ((int)a2 >> 1);
  v5 = HIBYTE(a1[1]) - ((int)a3 >> 1);
  if ( (v4 + v5) % 2 )
    ++v4;
  return (__int16)sub_48990(v4, v5, a3, a2) < (int)a4;
}

//----- (000226D0) --------------------------------------------------------
_WORD *__cdecl sub_226D0(unsigned __int16 a1, _WORD *a2, _WORD *a3)
{
  unsigned __int16 v3; // cx
  unsigned __int16 v4; // bx
  _WORD *result; // eax

  v3 = *(unsigned __int8 *)(dword_EA3BC + 6 * a1 + 5);
  v4 = *(unsigned __int8 *)(dword_EA3BC + 6 * a1 + 4);
  if ( word_180660 == 1 )
  {
    v3 >>= 1;
    v4 >>= 1;
  }
  *a3 = (v3 << 8) / 2 + 768;
  result = a2;
  *a2 = (v4 << 8) / 2 + 768;
  return result;
}
// EA3BC: using guessed type int dword_EA3BC;
// 180660: using guessed type __int16 word_180660;

//----- (00022760) --------------------------------------------------------
char __cdecl sub_22760(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  __int16 v4; // ax
  unsigned int v5; // edx
  __int16 v6; // ax
  __int16 v7; // di
  int v8; // eax
  char v9; // cl
  unsigned int i; // esi
  unsigned int j; // esi
  unsigned int k; // esi
  unsigned int m; // esi
  int v14; // esi
  char v15; // al
  int v17; // [esp+0h] [ebp-1Ch]
  unsigned __int16 v18; // [esp+8h] [ebp-14h] BYREF
  unsigned __int16 v19; // [esp+Ch] [ebp-10h] BYREF
  __int16 v20; // [esp+10h] [ebp-Ch]
  int v21; // [esp+14h] [ebp-8h]
  unsigned __int8 v22; // [esp+18h] [ebp-4h]

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v20 = 96;
  v17 = v1;
  if ( !*(_BYTE *)(v1 + 63) || *(_BYTE *)(v1 + 64) != 45 )
  {
    *(_DWORD *)(a1 + 16) = 5;
LABEL_51:
    v15 = v20;
    *(_WORD *)(a1 + 150) = 0;
    LOBYTE(v8) = v15 + 1;
    *(_BYTE *)(a1 + 69) = v8;
    return v8;
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(v1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(v1 + 80);
  v2 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = v2 + 1;
  if ( v2 >= 4 )
  {
    *(_DWORD *)(a1 + 16) = 1;
    goto LABEL_51;
  }
  v22 = sub_232C0();
  sub_226D0(v22, &v19, &v18);
  v3 = *(_DWORD *)(a1 + 16) - 1;
  switch ( *(_DWORD *)(a1 + 16) )
  {
    case 1:
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v4 = 9377 * *(_WORD *)(a1 + 20);
      word_EB398 += ((*(_WORD *)(a1 + 20) % 3u) << 8) + *(_WORD *)(v17 + 84) + v19 + 256;
      *(_WORD *)(a1 + 20) = v4 + 9439;
      v3 = ((*(unsigned __int16 *)(a1 + 20) % 3u) << 8) - 1280;
      LOWORD(v5) = v3 + word_EB39A;
      goto LABEL_10;
    case 2:
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      word_EB398 -= ((*(_WORD *)(a1 + 20) % 3u) << 8) + *(_WORD *)(v17 + 84) + v19 + 256;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v3 = ((*(unsigned __int16 *)(a1 + 20) % 3u) << 8) - 1280;
      LOWORD(v5) = v3 + word_EB39A;
      goto LABEL_10;
    case 3:
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v6 = 9377 * *(_WORD *)(a1 + 20);
      word_EB398 += ((*(_WORD *)(a1 + 20) % 3u) << 8) - 1280;
      *(_WORD *)(a1 + 20) = v6 + 9439;
      v3 = ((*(unsigned __int16 *)(a1 + 20) % 3u) << 8) + *(__int16 *)(v17 + 86) + v18 + 256;
      LOWORD(v5) = v3 + word_EB39A;
      goto LABEL_10;
    case 4:
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      word_EB398 += ((*(_WORD *)(a1 + 20) % 3u) << 8) - 1280;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v3 = *(__int16 *)(v17 + 86) + v18;
      v5 = word_EB39A - (v3 + ((*(unsigned __int16 *)(a1 + 20) % 3u) << 8) + 256);
LABEL_10:
      word_EB39A = v5;
      break;
    default:
      break;
  }
  LOWORD(v3) = word_EB398;
  v7 = word_EB39A;
  v21 = v3;
  if ( sub_104D0(&word_EB398) == 1 )
  {
    *(_DWORD *)(a1 + 16) = 2;
    goto LABEL_51;
  }
  LOBYTE(v8) = sub_22640(&word_EB398, (int)v19 >> 8, (int)v18 >> 8, (((int)v19 >> 7) + ((int)v18 >> 7) > 4) + 15);
  if ( (_BYTE)v8 )
  {
    v9 = 0;
    for ( i = *(_DWORD *)(dword_D41A4 + 38527); !v9 && i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      v8 = abs16(*(_WORD *)(i + 76) - v21);
      if ( v8 <= *(__int16 *)(i + 84) + v19 )
      {
        v8 = abs16(*(_WORD *)(i + 78) - v7);
        if ( v8 <= v18 + *(__int16 *)(i + 86) )
          v9 = 1;
      }
    }
    if ( !v9 )
    {
      for ( j = *(_DWORD *)(dword_D41A4 + 38519); !v9 && j > dword_EA3E4[0]; j = *(_DWORD *)j )
      {
        if ( *(_BYTE *)(j + 64) == 2 )
        {
          v8 = abs16(*(_WORD *)(j + 76) - v21);
          if ( v8 <= *(__int16 *)(j + 84) + v19 )
          {
            v8 = abs16(*(_WORD *)(j + 78) - v7);
            if ( v8 <= v18 + *(__int16 *)(j + 86) )
              v9 = 1;
          }
        }
      }
    }
    if ( !v9 )
    {
      for ( k = *(_DWORD *)(dword_D41A4 + 38535); !v9 && k > dword_EA3E4[0]; k = *(_DWORD *)k )
      {
        if ( *(_BYTE *)(k + 64) == 67 )
        {
          v8 = abs16(*(_WORD *)(k + 76) - v21);
          if ( v8 <= *(__int16 *)(k + 84) + v19 )
          {
            v8 = abs16(*(_WORD *)(k + 78) - v7);
            if ( v8 <= v18 + *(__int16 *)(k + 86) )
              v9 = 1;
          }
        }
      }
    }
    if ( !v9 )
    {
      for ( m = *(_DWORD *)(dword_D41A4 + 38451); !v9 && m > dword_EA3E4[0]; m = *(_DWORD *)m )
      {
        if ( *(_BYTE *)(m + 61) )
          v9 = 1;
      }
    }
    if ( !v9 )
    {
      v8 = sub_4A190((int)&word_EB398, 10, 45);
      v14 = v8;
      if ( v8 )
      {
        sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
        LOBYTE(v8) = sub_49A30(v14, v22);
        *(_BYTE *)(v14 + 69) = 51;
      }
      *(_WORD *)(a1 + 150) = 0;
      *(_BYTE *)(a1 + 61) = 1;
      *(_BYTE *)(a1 + 69) = 105;
    }
  }
  return v8;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;

//----- (00022C80) --------------------------------------------------------
char __cdecl sub_22C80(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // ax
  int i; // edx
  int v4; // ecx
  int v5; // edx
  int v6; // eax
  unsigned int v7; // edx
  unsigned __int16 v8; // ax

  *(_BYTE *)(a1 + 61) = 0;
  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    v1 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        v1 = 1;
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v1 = 2;
  }
  if ( v1 )
  {
    if ( v1 <= 1 )
    {
      v7 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( v7 > dword_EA3E4[0] && *(_BYTE *)(v7 + 64) <= 1u )
        *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      LOBYTE(v6) = 102;
    }
    else
    {
      LOBYTE(v6) = 100;
    }
    goto LABEL_23;
  }
  sub_1B8C0(a1);
  LOWORD(v6) = *(unsigned __int8 *)(a1 + 62) / *(__int16 *)(*(_DWORD *)(a1 + 160) + 26);
  if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v8 = *(_WORD *)(a1 + 20);
    *(_WORD *)(a1 + 20) = 9377 * v8 + 9439;
    *(_WORD *)(a1 + 32) += ((unsigned __int8)*(_WORD *)(a1 + 20) + 85) * (2 * ((int)(v8 % 0x9Du) / 79) - 1);
    v6 = *(_DWORD *)(a1 + 16);
    *(_BYTE *)(a1 + 33) &= 7u;
    *(_DWORD *)(a1 + 16) = v6 - 1;
    if ( !v6 )
    {
      LOBYTE(v6) = 99;
      *(_DWORD *)(a1 + 16) = 1;
LABEL_23:
      *(_BYTE *)(a1 + 69) = v6;
    }
  }
  if ( *(_BYTE *)(a1 + 69) == 102 )
  {
    LOWORD(v6) = *(_WORD *)(a1 + 132);
    *(_WORD *)(a1 + 130) = v6;
  }
  return v6;
}
// 22D22: conditional instruction was optimized away because eax.4==2
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00022E60) --------------------------------------------------------
char __cdecl sub_22E60(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // ax
  int i; // edx
  int v4; // esi
  int v5; // edx
  unsigned int v6; // eax
  unsigned int v7; // edx
  int v8; // edx
  int v9; // eax
  _WORD *v10; // esi

  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    v1 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        v1 = 1;
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v1 = 2;
  }
  if ( v1 )
  {
    if ( v1 <= 1 )
    {
      v7 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( v7 > dword_EA3E4[0] && *(_BYTE *)(v7 + 64) <= 1u )
        *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      LOBYTE(v6) = 102;
    }
    else
    {
      LOBYTE(v6) = 100;
    }
    goto LABEL_26;
  }
  sub_1B8C0(a1);
  v6 = *(unsigned __int8 *)(a1 + 62) % *(__int16 *)(*(_DWORD *)(a1 + 160) + 26) / 2;
  if ( !v6 )
  {
    v8 = *(_DWORD *)(a1 + 16);
    v9 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    *(_DWORD *)(a1 + 16) = v8 - 1;
    if ( !v8 || !*(_BYTE *)(v9 + 63) )
    {
      *(_DWORD *)(a1 + 16) = 5;
      *(_BYTE *)(a1 + 69) = 97;
    }
    v10 = (_WORD *)(v9 + 76);
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v9 + 76));
    v6 = sub_583F0((_WORD *)(a1 + 76), v10);
    if ( v6 < 0xA00 )
    {
      LOBYTE(v6) = 96;
      *(_DWORD *)(a1 + 16) = 0;
LABEL_26:
      *(_BYTE *)(a1 + 69) = v6;
    }
  }
  if ( *(_BYTE *)(a1 + 69) == 102 )
  {
    LOWORD(v6) = *(_WORD *)(a1 + 132);
    *(_WORD *)(a1 + 130) = v6;
  }
  return v6;
}
// 22EFF: conditional instruction was optimized away because eax.4==2
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00023020) --------------------------------------------------------
char __cdecl sub_23020(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // ax
  int i; // edx
  int v4; // esi
  int v5; // edx
  __int16 v6; // ax
  unsigned int v7; // edx
  unsigned int v8; // edi
  unsigned int j; // esi
  unsigned int v10; // eax
  unsigned int v12; // [esp+0h] [ebp-8h]

  v1 = 0;
  v12 = -1;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    v1 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        v1 = 1;
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v1 = 2;
  }
  if ( v1 )
  {
    if ( v1 <= 1 )
    {
      v7 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( v7 > dword_EA3E4[0] && *(_BYTE *)(v7 + 64) <= 1u )
        *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      LOBYTE(v6) = 102;
    }
    else
    {
      LOBYTE(v6) = 100;
    }
  }
  else
  {
    v8 = 0;
    for ( j = *(_DWORD *)(dword_D41A4 + 38527); j > dword_EA3E4[0]; j = *(_DWORD *)j )
    {
      v10 = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(j + 76));
      if ( v10 && v10 < v12 )
      {
        v8 = j;
        v12 = v10;
      }
    }
    if ( v8 )
    {
      *(_WORD *)(a1 + 150) = (int)(v8 - (dword_D41A0 + 28302)) / 168;
      *(_DWORD *)(a1 + 16) = 10;
      LOBYTE(v6) = 98;
    }
    else
    {
      *(_DWORD *)(a1 + 16) = 5;
      LOBYTE(v6) = 97;
    }
  }
  *(_BYTE *)(a1 + 69) = v6;
  if ( *(_BYTE *)(a1 + 69) == 102 )
  {
    v6 = *(_WORD *)(a1 + 132);
    *(_WORD *)(a1 + 130) = v6;
  }
  return v6;
}
// 230C7: conditional instruction was optimized away because eax.4==2
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000231E0) --------------------------------------------------------
int __cdecl sub_231E0(int a1)
{
  return sub_1C890(a1, 96);
}

//----- (00023200) --------------------------------------------------------
void __cdecl sub_23200(int a1)
{
  unsigned int v1; // edx

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 36)];
  if ( v1 > dword_EA3E4[0] && *(_BYTE *)(v1 + 64) <= 1u )
    *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 36)] + 164) + 584) = 200;
  sub_1C930(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00023260) --------------------------------------------------------
__int16 __cdecl sub_23260(int a1)
{
  __int16 result; // ax

  LOBYTE(result) = sub_1C980(a1, 96);
  HIBYTE(result) = *(_BYTE *)(a1 + 69);
  if ( HIBYTE(result) != 102 )
  {
    *(_DWORD *)(a1 + 16) = 5;
    *(_WORD *)(a1 + 150) = 0;
    result = *(_WORD *)(a1 + 134);
    *(_BYTE *)(a1 + 69) = 97;
    *(_WORD *)(a1 + 130) = result;
  }
  return result;
}

//----- (000232A0) --------------------------------------------------------
char __cdecl sub_232A0(int a1)
{
  *(_DWORD *)(a1 + 16) = 5;
  *(_BYTE *)(a1 + 69) = 97;
  return sub_22C80(a1);
}

//----- (000232C0) --------------------------------------------------------
char sub_232C0()
{
  int v0; // eax
  unsigned __int8 v1; // bl
  unsigned int v2; // eax

  v0 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
  v1 = 0;
  v2 = *(_DWORD *)(v0 + 8) % 0x3Cu + 17;
  while ( (byte_D93C2[4 * (unsigned __int8)v2] & 2) == 0 && v1 < 0x4Du )
  {
    LOBYTE(v2) = v2 + 1;
    ++v1;
    if ( (unsigned __int8)v2 >= 0x4Cu )
      LOBYTE(v2) = 17;
  }
  if ( v1 >= 0x4Du )
    LOBYTE(v2) = 17;
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00023320) --------------------------------------------------------
char __cdecl sub_23320(int a1)
{
  *(_BYTE *)(a1 + 69) = 105;
  return sub_23340(a1);
}

//----- (00023340) --------------------------------------------------------
char __cdecl sub_23340(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // ax
  int i; // edx
  int v4; // edx
  int v5; // esi
  unsigned int j; // eax
  unsigned int v7; // edx
  unsigned __int16 v8; // di
  unsigned __int16 v9; // ax
  unsigned int v10; // edi
  unsigned int v11; // esi
  int v12; // edx
  unsigned int v13; // edx
  int v14; // esi

  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    v1 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        v1 = 1;
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v1 = 2;
  }
  if ( v1 )
  {
    if ( v1 <= 1 )
    {
      v7 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( v7 > dword_EA3E4[0] && *(_BYTE *)(v7 + 64) <= 1u )
        *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      LOBYTE(j) = 110;
      *(_BYTE *)(a1 + 69) = 110;
    }
    else
    {
      LOBYTE(j) = 108;
      *(_BYTE *)(a1 + 69) = 108;
    }
    goto LABEL_39;
  }
  sub_1B8C0(a1);
  LOWORD(j) = *(unsigned __int8 *)(a1 + 62) / *(__int16 *)(*(_DWORD *)(a1 + 160) + 26);
  if ( *(unsigned __int8 *)(a1 + 62) % *(__int16 *)(*(_DWORD *)(a1 + 160) + 26) )
    goto LABEL_39;
  v8 = *(_WORD *)(a1 + 150);
  if ( v8 )
  {
    v14 = dword_EA3E4[v8];
    if ( *(_BYTE *)(v14 + 63) == 10 && *(_BYTE *)(v14 + 64) == 45 )
    {
      if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v14 + 76)) > 0x800 )
      {
        LOWORD(j) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v14 + 76));
        *(_WORD *)(a1 + 32) = j;
        goto LABEL_39;
      }
      if ( *(__int16 *)(v14 + 132) > *(_DWORD *)(v14 + 16) )
      {
        *(_DWORD *)(a1 + 16) = 1;
        LOBYTE(j) = 108;
        *(_BYTE *)(a1 + 69) = 108;
        ++*(_DWORD *)(v14 + 16);
        goto LABEL_39;
      }
    }
    *(_WORD *)(a1 + 150) = 0;
    LOWORD(j) = *(_WORD *)(a1 + 134);
    goto LABEL_38;
  }
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  v9 = *(_WORD *)(a1 + 20);
  *(_WORD *)(a1 + 20) = 9377 * v9 + 9439;
  *(_WORD *)(a1 + 32) += (2 * (v9 % 0x9Du / 79i64) - 1) * ((unsigned __int8)*(_WORD *)(a1 + 20) + 85);
  *(_BYTE *)(a1 + 33) &= 7u;
  LOWORD(j) = *(unsigned __int8 *)(a1 + 62) / *(__int16 *)(*(_DWORD *)(a1 + 160) + 26);
  if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
  {
    v10 = -1;
    v11 = 0;
    for ( j = *(_DWORD *)(dword_D41A4 + 38527); j > dword_EA3E4[0]; j = *(_DWORD *)j )
    {
      if ( (byte_D93C2[4 * *(char *)(j + 70)] & 1) != 0 )
      {
        v12 = (__int16)(*(_WORD *)(j + 76) - *(_WORD *)(a1 + 76));
        v13 = v12 * v12
            + (__int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78)) * (__int16)(*(_WORD *)(j + 78) - *(_WORD *)(a1 + 78));
        if ( v13 < v10 )
        {
          v11 = j;
          v10 = v13;
        }
      }
    }
    if ( v11 )
    {
      *(_WORD *)(a1 + 150) = (int)(v11 - (dword_D41A0 + 28302)) / 168;
      LOWORD(j) = *(_WORD *)(a1 + 134) + 12;
LABEL_38:
      *(_WORD *)(a1 + 130) = j;
    }
  }
LABEL_39:
  if ( *(_BYTE *)(a1 + 69) == 110 )
  {
    LOWORD(j) = *(_WORD *)(a1 + 132);
    *(_WORD *)(a1 + 130) = j;
  }
  return j;
}
// 233DB: conditional instruction was optimized away because eax.4==2
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00023640) --------------------------------------------------------
char __cdecl sub_23640(int a1)
{
  *(_BYTE *)(a1 + 69) = 105;
  return sub_23340(a1);
}

//----- (00023660) --------------------------------------------------------
char __cdecl sub_23660(int a1)
{
  *(_BYTE *)(a1 + 69) = 105;
  return sub_23340(a1);
}

//----- (00023680) --------------------------------------------------------
int __cdecl sub_23680(int a1)
{
  unsigned int v2; // ebx

  if ( *(_DWORD *)(a1 + 16) )
    return sub_57F10(a1);
  v2 = dword_EA3E4[*(unsigned __int16 *)(a1 + 36)];
  if ( v2 > dword_EA3E4[0] && *(_BYTE *)(v2 + 64) <= 1u )
    *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 36)] + 164) + 584) = 200;
  return sub_1C890(a1, 104);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000236F0) --------------------------------------------------------
void __cdecl sub_236F0(int a1)
{
  sub_1C930(a1);
}

//----- (00023710) --------------------------------------------------------
__int16 __cdecl sub_23710(int a1)
{
  __int16 result; // ax

  LOBYTE(result) = sub_1C980(a1, 104);
  HIBYTE(result) = *(_BYTE *)(a1 + 69);
  if ( HIBYTE(result) != 110 )
  {
    result = *(_WORD *)(a1 + 134);
    *(_WORD *)(a1 + 150) = 0;
    *(_WORD *)(a1 + 130) = result;
  }
  return result;
}

//----- (00023750) --------------------------------------------------------
__int16 __cdecl sub_23750(int a1)
{
  __int16 result; // ax

  sub_1D5D0(a1, 104);
  if ( *(_BYTE *)(a1 + 69) == 110 )
    result = *(_WORD *)(a1 + 132);
  else
    result = *(_WORD *)(a1 + 134);
  *(_WORD *)(a1 + 130) = result;
  return result;
}

//----- (00023790) --------------------------------------------------------
char __cdecl sub_23790(int a1)
{
  *(_BYTE *)(a1 + 69) = 113;
  return sub_237B0(a1);
}

//----- (000237B0) --------------------------------------------------------
char __cdecl sub_237B0(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // ax
  int i; // edx
  int v4; // edx
  int v5; // esi
  unsigned int v6; // eax
  unsigned int v7; // edx
  unsigned __int16 v8; // di
  unsigned __int16 v9; // ax
  unsigned int v10; // edi
  unsigned int v11; // esi
  int v12; // edx
  unsigned int v13; // edx
  int v14; // esi

  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    v1 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        v1 = 1;
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v1 = 2;
  }
  if ( v1 )
  {
    if ( v1 <= 1 )
    {
      v7 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( v7 > dword_EA3E4[0] && *(_BYTE *)(v7 + 64) <= 1u )
        *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
      LOBYTE(v6) = 118;
      *(_BYTE *)(a1 + 69) = 118;
    }
    else
    {
      LOBYTE(v6) = 116;
      *(_BYTE *)(a1 + 69) = 116;
    }
    goto LABEL_40;
  }
  sub_1B8C0(a1);
  LOWORD(v6) = *(unsigned __int8 *)(a1 + 62) / *(__int16 *)(*(_DWORD *)(a1 + 160) + 26);
  if ( *(unsigned __int8 *)(a1 + 62) % *(__int16 *)(*(_DWORD *)(a1 + 160) + 26) )
    goto LABEL_40;
  v8 = *(_WORD *)(a1 + 150);
  if ( v8 )
  {
    v14 = dword_EA3E4[v8];
    if ( *(_BYTE *)(v14 + 63) == 10 && *(_BYTE *)(v14 + 64) == 45 )
    {
      if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v14 + 76)) > 0x800 )
      {
        LOWORD(v6) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v14 + 76));
        *(_WORD *)(a1 + 32) = v6;
        goto LABEL_40;
      }
      if ( *(__int16 *)(v14 + 132) > *(_DWORD *)(v14 + 16) )
      {
        *(_DWORD *)(a1 + 16) = 1;
        LOBYTE(v6) = 116;
        *(_BYTE *)(a1 + 69) = 116;
        ++*(_DWORD *)(v14 + 16);
        goto LABEL_40;
      }
    }
    *(_WORD *)(a1 + 150) = 0;
    LOWORD(v6) = *(_WORD *)(a1 + 134);
    goto LABEL_39;
  }
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  v9 = *(_WORD *)(a1 + 20);
  *(_WORD *)(a1 + 20) = 9377 * v9 + 9439;
  *(_WORD *)(a1 + 32) += ((unsigned __int8)*(_WORD *)(a1 + 20) + 85) * (2 * (v9 % 0x9Du / 79i64) - 1);
  *(_BYTE *)(a1 + 33) &= 7u;
  LOWORD(v6) = *(unsigned __int8 *)(a1 + 62) / *(__int16 *)(*(_DWORD *)(a1 + 160) + 26);
  if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
  {
    v10 = -1;
    v6 = *(_DWORD *)(dword_D41A4 + 38527);
    v11 = 0;
    while ( v6 > dword_EA3E4[0] )
    {
      if ( (byte_D93C2[4 * *(char *)(v6 + 70)] & 1) != 0 )
      {
        v12 = (__int16)(*(_WORD *)(v6 + 76) - *(_WORD *)(a1 + 76));
        v13 = v12 * v12
            + (__int16)(*(_WORD *)(v6 + 78) - *(_WORD *)(a1 + 78))
            * (__int16)(*(_WORD *)(v6 + 78) - *(_WORD *)(a1 + 78));
        if ( v13 < v10 && v13 > 0xE100000 )
        {
          v11 = v6;
          v10 = v13;
        }
      }
      v6 = *(_DWORD *)v6;
    }
    if ( v11 )
    {
      *(_WORD *)(a1 + 150) = (int)(v11 - (dword_D41A0 + 28302)) / 168;
      LOWORD(v6) = *(_WORD *)(a1 + 134) + 12;
LABEL_39:
      *(_WORD *)(a1 + 130) = v6;
    }
  }
LABEL_40:
  if ( *(_BYTE *)(a1 + 69) == 118 )
  {
    LOWORD(v6) = *(_WORD *)(a1 + 132);
    *(_WORD *)(a1 + 130) = v6;
  }
  return v6;
}
// 2384B: conditional instruction was optimized away because eax.4==2
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00023AC0) --------------------------------------------------------
char __cdecl sub_23AC0(int a1)
{
  *(_BYTE *)(a1 + 69) = 113;
  return sub_237B0(a1);
}

//----- (00023AE0) --------------------------------------------------------
char __cdecl sub_23AE0(int a1)
{
  *(_BYTE *)(a1 + 69) = 113;
  return sub_237B0(a1);
}

//----- (00023B00) --------------------------------------------------------
int __cdecl sub_23B00(int a1)
{
  if ( *(_DWORD *)(a1 + 16) )
    return sub_57F10(a1);
  else
    return sub_1C890(a1, 112);
}

//----- (00023B30) --------------------------------------------------------
void __cdecl sub_23B30(int a1)
{
  unsigned int v1; // edx

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 36)];
  if ( v1 > dword_EA3E4[0] && *(_BYTE *)(v1 + 64) <= 1u )
    *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 36)] + 164) + 584) = 200;
  sub_1C930(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00023B90) --------------------------------------------------------
__int16 __cdecl sub_23B90(int a1)
{
  __int16 result; // ax

  LOBYTE(result) = sub_1C980(a1, 112);
  HIBYTE(result) = *(_BYTE *)(a1 + 69);
  if ( HIBYTE(result) != 118 )
  {
    result = *(_WORD *)(a1 + 134);
    *(_WORD *)(a1 + 150) = 0;
    *(_WORD *)(a1 + 130) = result;
  }
  return result;
}

//----- (00023BD0) --------------------------------------------------------
__int16 __cdecl sub_23BD0(int a1)
{
  __int16 result; // ax

  sub_1D5D0(a1, 112);
  if ( *(_BYTE *)(a1 + 69) == 118 )
    result = *(_WORD *)(a1 + 132);
  else
    result = *(_WORD *)(a1 + 134);
  *(_WORD *)(a1 + 130) = result;
  return result;
}

//----- (00023C20) --------------------------------------------------------
int __cdecl sub_23C20(int a1)
{
  return sub_1BD90(a1, 120);
}

//----- (00023C40) --------------------------------------------------------
void __cdecl sub_23C40(int a1)
{
  unsigned int v1; // esi
  __int16 v2; // ax
  int i; // eax
  int v4; // edx
  int v5; // eax
  int v6; // eax
  __int16 v7; // ax
  int v8; // esi
  int v9; // eax
  unsigned int v10; // esi
  int v11; // edi
  unsigned int v12; // edi
  __int16 v13; // ax
  int v14; // eax
  unsigned int v15; // [esp+0h] [ebp-10h]
  int v16; // [esp+4h] [ebp-Ch]
  unsigned int v17; // [esp+8h] [ebp-8h]
  unsigned int v18; // [esp+Ch] [ebp-4h]

  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v1 = 1;
    *(_WORD *)(a1 + 38) = v2;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        v1 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v1 )
  {
    if ( v1 <= 1 )
    {
      v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( *(_BYTE *)(v6 + 63) == 3 && *(_WORD *)(v6 + 26) != *(_WORD *)(a1 + 26) )
      {
        v7 = *(_WORD *)(a1 + 38);
        *(_BYTE *)(a1 + 69) = 122;
        *(_WORD *)(a1 + 150) = v7;
      }
      sub_1EEE0(a1);
    }
    else
    {
      *(_BYTE *)(a1 + 69) = 124;
    }
  }
  else
  {
    sub_24190(a1);
    v8 = *(_DWORD *)(a1 + 160);
    if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(v8 + 26)) && *(_BYTE *)(a1 + 57) )
    {
      v9 = *(__int16 *)(v8 + 28) * *(__int16 *)(v8 + 28);
      v15 = -1;
      v18 = 0;
      v10 = *(_DWORD *)(dword_D41A4 + 38519);
      v17 = v9;
      while ( v10 > dword_EA3E4[0] )
      {
        if ( *(_WORD *)(v10 + 26) != *(_WORD *)(a1 + 26) )
        {
          v11 = (__int16)(*(_WORD *)(v10 + 76) - *(_WORD *)(a1 + 76));
          v12 = (__int16)(*(_WORD *)(v10 + 78) - *(_WORD *)(a1 + 78))
              * (__int16)(*(_WORD *)(v10 + 78) - *(_WORD *)(a1 + 78))
              + v11 * v11;
          if ( v12 <= v17 && (*(_BYTE *)(v10 + 12) & 0x20) == 0 )
          {
            v16 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 30);
            v13 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v10 + 76));
            if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v13) < v16 && v12 < v15 )
            {
              v18 = v10;
              v15 = v12;
            }
          }
        }
        v10 = *(_DWORD *)v10;
      }
      if ( v18 )
      {
        v14 = (int)(v18 - (dword_D41A0 + 28302)) / 168;
        *(_BYTE *)(a1 + 69) = 122;
        *(_WORD *)(a1 + 150) = v14;
      }
    }
  }
  if ( *(_BYTE *)(a1 + 69) == 122 )
    sub_24100((_WORD *)a1);
}
// 23CD5: conditional instruction was optimized away because esi.4==2
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00023E60) --------------------------------------------------------
void __cdecl sub_23E60(int a1)
{
  unsigned int v1; // esi
  __int16 v2; // ax
  int i; // eax
  int v4; // edx
  int v5; // eax
  unsigned int v6; // edi
  int v7; // esi
  unsigned int v8; // esi
  int v9; // eax
  int v10; // esi
  _WORD *v11; // [esp+4h] [ebp-8h]
  _WORD *v12; // [esp+8h] [ebp-4h]

  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v1 = 1;
    *(_WORD *)(a1 + 38) = v2;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        v1 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v1 > 1 )
  {
    *(_BYTE *)(a1 + 69) = 124;
    goto LABEL_25;
  }
  v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  if ( (*(_BYTE *)(a1 + 62) & 3) == 0 )
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v6 + 76));
  if ( *(int *)(v6 + 8) < 0 || (*(_BYTE *)(v6 + 13) & 4) != 0 )
  {
    *(_BYTE *)(a1 + 69) = 121;
    goto LABEL_25;
  }
  v7 = *(_DWORD *)(a1 + 160);
  if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(v7 + 26)) )
  {
    v11 = (_WORD *)(v6 + 76);
    v8 = *(__int16 *)(v7 + 28);
    v12 = (_WORD *)(a1 + 76);
    if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v6 + 76)) >= v8 )
    {
      *(_BYTE *)(a1 + 69) = 121;
      goto LABEL_25;
    }
    v9 = sub_4A190((int)v12, 9, 13);
    v10 = v9;
    if ( v9 )
    {
      *(_WORD *)(v9 + 26) = *(_WORD *)(a1 + 26);
      *(_WORD *)(v9 + 28) = sub_581E0(v12, v11);
      *(_WORD *)(v10 + 30) = sub_58210(v12, v11);
      *(_WORD *)(v10 + 80) += *(__int16 *)(a1 + 88) / 2;
      *(_WORD *)(v10 + 150) = *(_WORD *)(a1 + 150);
      *(_BYTE *)(v10 + 66) = *(_BYTE *)(a1 + 66);
      *(_BYTE *)(v10 + 65) = *(_BYTE *)(a1 + 65);
      sub_5EF70(v6);
    }
  }
  sub_1EEE0(a1);
LABEL_25:
  if ( *(_BYTE *)(a1 + 69) != 122 )
    sub_24150((_WORD *)a1);
}
// 23EF3: conditional instruction was optimized away because esi.4==2
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000240A0) --------------------------------------------------------
char __cdecl sub_240A0(int a1)
{
  return sub_1C560(a1, 0x78u);
}

//----- (000240C0) --------------------------------------------------------
int __cdecl sub_240C0(int a1)
{
  return sub_1C890(a1, 120);
}

//----- (000240E0) --------------------------------------------------------
void __cdecl sub_240E0(int a1)
{
  sub_1C930(a1);
}

//----- (00024100) --------------------------------------------------------
int __cdecl sub_24100(_WORD *a1)
{
  signed int v1; // edx

  a1[10] = 9377 * a1[10] + 9439;
  v1 = (unsigned __int16)a1[10] % 0x14u;
  a1[65] = 0;
  if ( v1 <= 10 )
    return sub_49CD0(a1, 206);
  else
    return sub_49CD0(a1, 1);
}

//----- (00024150) --------------------------------------------------------
int __cdecl sub_24150(_WORD *a1)
{
  a1[65] = a1[66];
  return sub_49CD0(a1, 0);
}

//----- (00024190) --------------------------------------------------------
int __cdecl sub_24190(int a1)
{
  int v1; // esi
  int result; // eax
  unsigned __int16 v3; // dx
  unsigned int v4; // esi
  int v5; // eax
  unsigned int i; // ecx
  __int64 v7; // rax
  __int64 v8; // rax
  __int16 v9; // ax
  unsigned __int16 v10; // [esp-Ch] [ebp-24h]
  _WORD v11[4]; // [esp+0h] [ebp-18h] BYREF
  int v12; // [esp+8h] [ebp-10h]
  int v13; // [esp+Ch] [ebp-Ch]
  int v14; // [esp+10h] [ebp-8h]
  char v15; // [esp+14h] [ebp-4h]

  v12 = 0;
  strcpy((char *)v11, "X\x1BX\x1B\n");
  v11[3] = *(_WORD *)&aXX[6];
  v14 = 1;
  if ( !(*(unsigned __int8 *)(a1 + 62) % 8) )
  {
    v1 = ~*(_DWORD *)(*(_DWORD *)(a1 + 160) + 20);
    result = sub_104D0((__int16 *)(a1 + 76));
    if ( (result & v1) != 0 )
    {
      *(_BYTE *)(a1 + 69) = 124;
      return result;
    }
    LOWORD(result) = *(_WORD *)(a1 + 28);
    while ( 1 )
    {
      v13 = result;
      if ( (unsigned __int16)v12 >= 4u )
        break;
      v10 = v13;
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      sub_57FA0(&word_EB398, v10, 0, 256);
      v3 = v12;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v4 = *(unsigned __int16 *)(a1 + 20) % (unsigned int)(unsigned __int16)v11[v3];
      v5 = (v4 + 2) * (sub_102D0(a1, &word_EB398, 1) == 0);
      if ( (unsigned __int16)v5 > (unsigned __int16)v14 )
      {
        v14 = v5;
        *(_WORD *)(a1 + 28) = v13;
      }
      result = v13;
      BYTE1(result) = (BYTE1(v13) + 2) & 7;
      ++v12;
    }
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  if ( !(*(unsigned __int8 *)(a1 + 62) % 16) )
  {
    switch ( ((*(unsigned __int16 *)(a1 + 28) - 256) >> 9) & 3 )
    {
      case 0:
      case 2:
        word_EB39A = (word_EB39A >> 8 << 8) + 128;
        break;
      case 1:
      case 3:
        word_EB398 = (word_EB398 >> 8 << 8) + 128;
        break;
      default:
        break;
    }
  }
  v15 = 0;
  for ( i = *(_DWORD *)(4 * *(char *)(a1 + 64) + dword_D41A4 + 38403); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) )
    {
      v7 = *(__int16 *)(a1 + 76) - *(__int16 *)(i + 76);
      if ( (int)((HIDWORD(v7) ^ v7) - HIDWORD(v7)) < 256 )
      {
        v8 = *(__int16 *)(a1 + 78) - *(__int16 *)(i + 78);
        if ( (int)((HIDWORD(v8) ^ v8) - HIDWORD(v8)) < 256 )
        {
          *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(i + 76), (_WORD *)(a1 + 76));
          v15 = 1;
          break;
        }
      }
    }
  }
  if ( *(_WORD *)(a1 + 32) == *(_WORD *)(a1 + 28)
    || (*(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439, (int)(*(unsigned __int16 *)(a1 + 20) % 0x14u) <= 10) )
  {
    v9 = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
    sub_57CF0(v9, a1, (int)&word_EB398);
  }
  return sub_1EEE0(a1);
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;

//----- (00024400) --------------------------------------------------------
void __cdecl sub_24400(int a1)
{
  sub_1D5D0(a1, 120);
}

//----- (00024420) --------------------------------------------------------
int __cdecl sub_24420(int a1)
{
  return sub_1BD90(a1, 128);
}

//----- (00024440) --------------------------------------------------------
void __cdecl sub_24440(int a1)
{
  int v1; // ecx
  int v2; // edx
  unsigned int v3; // esi
  unsigned int i; // eax
  int v5; // ecx
  unsigned int v6; // ecx
  int v7; // eax
  unsigned int v8; // [esp+4h] [ebp-4h]

  sub_1BF90(a1, 128);
  if ( *(_BYTE *)(a1 + 69) == 0x81 )
  {
    v1 = *(_DWORD *)(a1 + 160);
    v2 = *(unsigned __int8 *)(a1 + 62) % (*(__int16 *)(v1 + 26) + 1);
    if ( !v2 )
    {
      v8 = *(__int16 *)(v1 + 28) * *(__int16 *)(v1 + 28);
      v3 = -1;
      for ( i = *(_DWORD *)(dword_D41A4 + 38527); i > dword_EA3E4[0]; i = *(_DWORD *)i )
      {
        v5 = (__int16)(*(_WORD *)(i + 76) - *(_WORD *)(a1 + 76));
        v6 = v5 * v5
           + (__int16)(*(_WORD *)(i + 78) - *(_WORD *)(a1 + 78)) * (__int16)(*(_WORD *)(i + 78) - *(_WORD *)(a1 + 78));
        if ( v6 <= v8 && v6 < v3 )
        {
          v2 = i;
          v3 = v6;
        }
      }
      if ( v2 )
      {
        v7 = (v2 - (dword_D41A0 + 28302)) / 168;
        *(_BYTE *)(a1 + 69) = -126;
        *(_WORD *)(a1 + 150) = v7;
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00024510) --------------------------------------------------------
__int16 __cdecl sub_24510(int a1)
{
  int v1; // eax
  unsigned int i; // eax
  unsigned int v3; // esi
  int v4; // edi
  unsigned int v5; // edi
  int v6; // eax
  int v7; // eax
  int v8; // esi
  __int16 v9; // ax
  int v10; // eax
  __int16 v11; // ax
  unsigned int v13; // [esp+4h] [ebp-8h]
  _WORD *v14; // [esp+8h] [ebp-4h]

  v1 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
  i = v1 * v1;
  v3 = 0;
  v13 = i;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    LOWORD(i) = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v3 = 1;
    *(_WORD *)(a1 + 38) = i;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v4 + 52) )
    {
      v4 = dword_EA3E4[i];
      if ( v4 == dword_EA3E4[0] )
        break;
      i = *(_DWORD *)(v4 + 8);
      if ( (signed int)i < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = i;
        LOWORD(i) = *(_WORD *)(v4 + 38);
        v3 = 1;
        *(_WORD *)(a1 + 38) = i;
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    LOWORD(i) = *(_WORD *)(a1 + 38);
    v3 = 2;
    *(_WORD *)(a1 + 36) = i;
  }
  if ( v3 )
  {
    if ( v3 <= 1 )
    {
      LOWORD(i) = *(_WORD *)(a1 + 38);
      *(_WORD *)(a1 + 150) = i;
    }
    else
    {
      *(_BYTE *)(a1 + 69) = -124;
    }
  }
  else
  {
    sub_1B8C0(a1);
    i = sub_1ED30(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
    v5 = i;
    if ( i > dword_EA3E4[0] )
    {
      if ( (*(_BYTE *)(a1 + 62) & 7) == 0 )
      {
        if ( *(_BYTE *)(i + 63) == 3 || (i = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(i + 76)), i >= 0x200) )
        {
          LOWORD(i) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v5 + 76));
          *(_WORD *)(a1 + 32) = i;
        }
      }
      if ( *(int *)(v5 + 8) < 0 || (*(_BYTE *)(v5 + 13) & 4) != 0 )
      {
        *(_BYTE *)(a1 + 69) = -127;
      }
      else
      {
        v6 = *(_DWORD *)(a1 + 16);
        if ( v6 )
        {
          *(_DWORD *)(a1 + 16) = v6 - 1;
          v14 = (_WORD *)(a1 + 76);
          v7 = sub_4A190(a1 + 76, 9, 0);
          v8 = v7;
          if ( v7 )
          {
            *(_BYTE *)(v7 + 67) = 10;
            *(_BYTE *)(v7 + 68) = 0;
            *(_DWORD *)(v7 + 160) = &unk_D83F0;
            *(_BYTE *)(v7 + 66) = *(_BYTE *)(v5 + 64);
            *(_BYTE *)(v7 + 65) = *(_BYTE *)(v5 + 63);
            *(_WORD *)(v7 + 26) = *(_WORD *)(a1 + 26);
            *(_WORD *)(v7 + 28) = sub_581E0(v14, (_WORD *)(v5 + 76));
            *(_WORD *)(v8 + 30) = sub_58210(v14, (_WORD *)(v5 + 76));
            *(_WORD *)(v8 + 80) += 6 * *(_WORD *)(a1 + 88);
            v9 = *(_WORD *)(a1 + 150);
            *(_WORD *)(v8 + 42) = 1600;
            *(_DWORD *)(v8 + 144) = 50000;
            *(_WORD *)(v8 + 150) = v9;
          }
        }
        LOWORD(i) = *(unsigned __int8 *)(a1 + 62) / *(__int16 *)(*(_DWORD *)(a1 + 160) + 26);
        if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
        {
          v10 = (__int16)(*(_WORD *)(v5 + 76) - *(_WORD *)(a1 + 76));
          i = v10 * v10
            + (__int16)(*(_WORD *)(v5 + 78) - *(_WORD *)(a1 + 78))
            * (__int16)(*(_WORD *)(v5 + 78) - *(_WORD *)(a1 + 78));
          if ( i < v13 )
          {
            if ( !(*(unsigned __int8 *)(a1 + 62) % (2 * *(__int16 *)(*(_DWORD *)(a1 + 160) + 26))) )
              sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 39);
            v11 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v5 + 76));
            LOWORD(i) = sub_582B0(*(_WORD *)(a1 + 28), v11);
            if ( (unsigned __int16)i < 0xE3u )
            {
              *(_DWORD *)(a1 + 16) = 15;
              LOWORD(i) = sub_5EF70(v5);
            }
          }
          else
          {
            *(_BYTE *)(a1 + 69) = -127;
          }
        }
      }
    }
  }
  return i;
}
// 245B2: conditional instruction was optimized away because esi.4==2
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000247D0) --------------------------------------------------------
char __cdecl sub_247D0(int a1)
{
  return sub_1C560(a1, 0x80u);
}

//----- (000247F0) --------------------------------------------------------
int __cdecl sub_247F0(int a1)
{
  return sub_1C890(a1, 128);
}

//----- (00024810) --------------------------------------------------------
void __cdecl sub_24810(int a1)
{
  sub_1C930(a1);
}

//----- (00024840) --------------------------------------------------------
void __cdecl sub_24840(int a1)
{
  sub_1D5D0(a1, 128);
}

//----- (00024860) --------------------------------------------------------
unsigned int __cdecl sub_24860(int a1)
{
  unsigned int result; // eax

  result = sub_1BD90(a1, 136);
  BYTE1(result) = *(_BYTE *)(a1 + 69);
  if ( BYTE1(result) == 0x8A )
  {
    result = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( result <= dword_EA3E4[0] || *(_BYTE *)(result + 63) != 3 || *(_BYTE *)(result + 64) >= 2u )
      *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 70) = 0;
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000248C0) --------------------------------------------------------
void __cdecl sub_248C0(int a1)
{
  unsigned int v1; // eax

  sub_1BF90(a1, 136);
  if ( *(_BYTE *)(a1 + 69) == 0x8A )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v1 <= dword_EA3E4[0] || *(_BYTE *)(v1 + 63) != 3 || *(_BYTE *)(v1 + 64) >= 2u )
      *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 70) = 0;
  }
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00024930) --------------------------------------------------------
__int16 __cdecl sub_24930(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // ax
  int i; // ecx
  int v4; // edx
  unsigned int v5; // eax
  char v6; // al
  unsigned int j; // ecx
  __int64 v8; // rax
  __int64 v9; // rax
  int v10; // esi
  int v11; // eax
  __int16 v12; // ax
  int v13; // esi
  int v15; // [esp+0h] [ebp-10h]
  int v16; // [esp+4h] [ebp-Ch]
  unsigned int v17; // [esp+8h] [ebp-8h]

  sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 58);
  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    v1 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = dword_EA3E4[*(unsigned __int16 *)(a1 + 52)];
          i != dword_EA3E4[0];
          i = dword_EA3E4[*(unsigned __int16 *)(i + 52)] )
    {
      v4 = *(_DWORD *)(i + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(i + 38);
        v1 = 1;
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v1 = 2;
  }
  if ( v1 )
  {
    if ( v1 > 1 )
    {
      *(_BYTE *)(a1 + 69) = -116;
      return v1;
    }
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
  }
  v15 = sub_1B8C0(a1);
  v5 = sub_1ED30(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
  v17 = v5;
  if ( v5 <= dword_EA3E4[0] || *(int *)(v5 + 8) < 0 || (*(_BYTE *)(v5 + 13) & 4) != 0 )
  {
    *(_DWORD *)(a1 + 160) = &unk_D8720;
    *(_WORD *)(a1 + 150) = 0;
    LOWORD(v1) = *(_WORD *)(a1 + 132);
    *(_BYTE *)(a1 + 69) = -119;
    *(_WORD *)(a1 + 130) = v1;
  }
  else
  {
    if ( (*(_BYTE *)(a1 + 62) & 3) == 0 )
    {
      v6 = *(_BYTE *)(a1 + 70);
      if ( !v6 || v6 == 4 )
      {
        *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v17 + 76));
        for ( j = *(_DWORD *)(4 * *(char *)(a1 + 64) + dword_D41A4 + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
        {
          if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26) )
          {
            v8 = *(__int16 *)(a1 + 76) - *(__int16 *)(j + 76);
            if ( (int)((HIDWORD(v8) ^ v8) - HIDWORD(v8)) < *(__int16 *)(a1 + 84) )
            {
              v9 = *(__int16 *)(a1 + 78) - *(__int16 *)(j + 78);
              if ( (int)((HIDWORD(v9) ^ v9) - HIDWORD(v9)) < *(__int16 *)(a1 + 84) )
              {
                *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
                break;
              }
            }
          }
        }
      }
    }
    LOWORD(v1) = *(unsigned __int8 *)(a1 + 70);
    switch ( *(_BYTE *)(a1 + 70) )
    {
      case 0:
        LOWORD(v1) = *(unsigned __int8 *)(a1 + 62) / *(__int16 *)(*(_DWORD *)(a1 + 160) + 26);
        if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
        {
          v1 = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v17 + 76));
          if ( v1 >= *(__int16 *)(*(_DWORD *)(a1 + 160) + 28) )
          {
            *(_BYTE *)(a1 + 69) = -119;
          }
          else if ( v1 >= 0x700 )
          {
            LOWORD(v1) = sub_1D0E0((_WORD *)a1, v17);
          }
          else
          {
            *(_BYTE *)(a1 + 70) = 1;
          }
        }
        return v1;
      case 1:
        LOWORD(v1) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v17 + 76));
        *(_WORD *)(a1 + 32) = v1;
        *(_WORD *)(a1 + 28) = v1;
        LOWORD(v1) = 3 * *(_WORD *)(a1 + 132);
        *(_DWORD *)(a1 + 160) = &unk_D8764;
        *(_DWORD *)(a1 + 16) = 0;
        *(_BYTE *)(a1 + 70) = 2;
        *(_WORD *)(a1 + 130) = v1;
        return v1;
      case 2:
      case 3:
        if ( v15 != 3 )
          *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        v10 = *(_DWORD *)(a1 + 16);
        if ( v10 <= 4 )
        {
          v11 = 192 >> *(_BYTE *)(a1 + 16);
        }
        else
        {
          if ( 4 - (v10 - 4) <= 0 )
          {
            v16 = -192;
            goto LABEL_46;
          }
          v11 = -(192 >> (4 - (v10 - 4)));
        }
        v16 = v11;
LABEL_46:
        ++*(_DWORD *)(a1 + 16);
        v12 = *(_WORD *)(a1 + 130);
        if ( v12 > *(__int16 *)(a1 + 134) )
          *(_WORD *)(a1 + 130) = v12 - 8;
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        v13 = v16 + word_EB39C;
        LOWORD(v1) = sub_10C40(&word_EB398);
        if ( v13 <= (__int16)v1 )
        {
          *(_BYTE *)(a1 + 70) = 4;
          *(_DWORD *)(a1 + 16) = 18;
        }
        else
        {
          LOBYTE(v1) = v16;
          BYTE1(v1) = *(_BYTE *)(a1 + 70);
          *(_WORD *)(a1 + 80) += v16;
          if ( BYTE1(v1) != 3 )
          {
            LOWORD(v1) = sub_1CED0(a1, v17);
            if ( (_WORD)v1 )
              *(_BYTE *)(a1 + 70) = 3;
          }
        }
        break;
      case 4:
        v1 = *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 16) = v1 - 1;
        if ( v1 )
        {
          if ( v1 == 18 )
          {
            LOWORD(v1) = *(_WORD *)(a1 + 134);
            *(_DWORD *)(a1 + 160) = &unk_D8720;
            *(_WORD *)(a1 + 130) = v1;
          }
        }
        else
        {
          *(_BYTE *)(a1 + 70) = 0;
          LOWORD(v1) = *(_WORD *)(a1 + 132);
          *(_WORD *)(a1 + 130) = v1;
        }
        return v1;
      default:
        return v1;
    }
  }
  return v1;
}
// 249F0: conditional instruction was optimized away because eax.4==2
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00024D40) --------------------------------------------------------
char __cdecl sub_24D40(int a1)
{
  unsigned int v1; // eax

  LOBYTE(v1) = sub_1C560(a1, 0x88u);
  if ( *(_BYTE *)(a1 + 69) == 0x8A )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v1 <= dword_EA3E4[0] || *(_BYTE *)(v1 + 63) != 3 || *(_BYTE *)(v1 + 64) >= 2u )
      *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 70) = 0;
  }
  return v1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00024DA0) --------------------------------------------------------
int __cdecl sub_24DA0(int a1)
{
  return sub_1C890(a1, 136);
}

//----- (00024DC0) --------------------------------------------------------
void __cdecl sub_24DC0(int a1)
{
  sub_1C930(a1);
}

//----- (00024DF0) --------------------------------------------------------
void __cdecl sub_24DF0(int a1)
{
  sub_1D5D0(a1, 136);
  if ( *(_BYTE *)(a1 + 69) == 0x8A )
    *(_BYTE *)(a1 + 70) = 0;
}

//----- (00024E20) --------------------------------------------------------
int __cdecl sub_24E20(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // eax
  unsigned int v4; // edi
  unsigned int v5; // esi
  int v6; // edx
  __int16 v7; // ax
  int v8; // eax
  int v9; // esi
  int v10; // eax
  unsigned __int16 v11; // ax
  unsigned int v12; // et2
  unsigned int v13; // [esp+0h] [ebp-10h]
  int v14; // [esp+4h] [ebp-Ch]
  unsigned int v15; // [esp+8h] [ebp-8h]
  unsigned int v16; // [esp+Ch] [ebp-4h]

  result = sub_252E0(a1);
  if ( result )
  {
    if ( result == 1 )
      return sub_253B0(1, a1, 2u, 0);
  }
  else
  {
    result = *(unsigned __int8 *)(a1 + 70);
    if ( (_BYTE)result )
    {
      if ( (_BYTE)result == 1 && *(_WORD *)(a1 + 150) )
      {
        v9 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
        v10 = sub_58490((_WORD *)(a1 + 76), (_WORD *)(v9 + 76));
        if ( v10 < *(__int16 *)(*(_DWORD *)(a1 + 160) + 28) )
        {
          sub_254E0(a1, v9, 4u);
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          v11 = *(_WORD *)(a1 + 20);
          v12 = v11 % 0x31u;
          result = v11 / 0x31u;
          if ( !v12 )
            return sub_253B0(result, a1, 2u, 0);
        }
        else
        {
          *(_WORD *)(a1 + 150) = 0;
          return sub_253B0(v10, a1, 0, 0);
        }
      }
    }
    else
    {
      v2 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v2;
      if ( v2 )
      {
        if ( *(_BYTE *)(a1 + 57) )
        {
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          result = *(_WORD *)(a1 + 20) & 1;
          if ( !result )
          {
            v3 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
            result = v3 * v3;
            v15 = -1;
            v4 = 0;
            v5 = *(_DWORD *)(dword_D41A4 + 38519);
            v13 = result;
            while ( v5 > dword_EA3E4[0] )
            {
              v6 = (__int16)(*(_WORD *)(v5 + 76) - *(_WORD *)(a1 + 76));
              v16 = (__int16)(*(_WORD *)(v5 + 78) - *(_WORD *)(a1 + 78))
                  * (__int16)(*(_WORD *)(v5 + 78) - *(_WORD *)(a1 + 78))
                  + v6 * v6;
              result = v16;
              if ( v16 <= v13 && (*(_BYTE *)(v5 + 12) & 0x20) == 0 )
              {
                v14 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 30);
                v7 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v5 + 76));
                result = (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v7);
                if ( result < v14 )
                {
                  result = v16;
                  if ( v16 < v15 )
                  {
                    v4 = v5;
                    v15 = v16;
                  }
                }
              }
              v5 = *(_DWORD *)v5;
            }
            if ( v4 && *(_BYTE *)(v4 + 63) == 3 )
            {
              v8 = (int)(v4 - (dword_D41A0 + 28302)) / 168;
              *(_WORD *)(a1 + 150) = v8;
              return sub_253B0(v8, a1, 0, 1u);
            }
          }
        }
      }
      else
      {
        return sub_253B0(result, a1, 1u, 0);
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00025050) --------------------------------------------------------
int __cdecl sub_25050(int a1)
{
  int result; // eax
  int v2; // edx

  result = sub_252E0(a1);
  if ( result )
  {
    if ( result == 1 )
      return sub_253B0(1, a1, 0, 1u);
  }
  else
  {
    *(_WORD *)(a1 + 150) = 0;
    result = sub_1B8C0(a1);
    v2 = *(_DWORD *)(a1 + 16) - 1;
    *(_DWORD *)(a1 + 16) = v2;
    if ( v2 <= 0 )
      return sub_253B0(result, a1, 0, 0);
  }
  return result;
}

//----- (000250B0) --------------------------------------------------------
__int16 __cdecl sub_250B0(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // edx
  unsigned __int16 v4; // ax
  unsigned int v5; // et2
  int v6; // esi
  int v7; // esi
  int v8; // ecx

  v1 = sub_252E0(a1);
  v2 = v1;
  if ( (unsigned int)v1 <= 1 )
  {
    v1 = *(unsigned __int8 *)(a1 + 70);
    switch ( *(_BYTE *)(a1 + 70) )
    {
      case 0:
        v1 = sub_254E0(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)], 4u);
        if ( v2 == 1 )
        {
          v3 = *(_DWORD *)(a1 + 16) - 47;
          *(_DWORD *)(a1 + 16) = v3;
          if ( v3 >= 0 )
            return v1;
          goto LABEL_5;
        }
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v4 = *(_WORD *)(a1 + 20);
        v5 = v4 % 0x29u;
        v1 = v4 / 0x29u;
        if ( !v5 )
        {
LABEL_5:
          LOWORD(v1) = sub_253B0(v1, a1, 2u, 1u);
          return v1;
        }
        v6 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v6;
        if ( v6 < 0 )
          goto LABEL_8;
        break;
      case 1:
        v1 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v1;
        if ( v1 <= 0 )
          goto LABEL_8;
        LOWORD(v1) = *(unsigned __int8 *)(a1 + 62) / *(__int16 *)(*(_DWORD *)(a1 + 160) + 26);
        if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(*(_DWORD *)(a1 + 160) + 26)) )
        {
          v1 = sub_1ED30(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
          v7 = v1;
          if ( (unsigned int)v1 <= dword_EA3E4[0] || *(int *)(v1 + 8) < 0 || (*(_BYTE *)(v1 + 13) & 4) != 0 )
          {
LABEL_8:
            LOWORD(v1) = sub_253B0(v1, a1, 2u, 2u);
          }
          else
          {
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
            *(_WORD *)(a1 + 28) += sub_58350(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32), 5, 0x400u);
            *(_BYTE *)(a1 + 29) &= 7u;
            LOWORD(v1) = sub_1D460((_WORD *)a1, v7);
          }
        }
        return v1;
      case 2:
        v1 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v1;
        if ( v1 <= 0 )
          LOWORD(v1) = sub_253B0(v1, a1, 2u, 3u);
        return v1;
      case 3:
        v8 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v8;
        if ( v8 < 0 )
        {
          LOWORD(v1) = sub_253B0(v1, a1, 1u, 0);
        }
        else if ( v8 >= 8 )
        {
          *(_WORD *)(a1 + 28) += 170;
          *(_BYTE *)(a1 + 29) &= 7u;
          LOWORD(v1) = *(_WORD *)(a1 + 28);
          *(_WORD *)(a1 + 32) = v1;
        }
        return v1;
      default:
        return v1;
    }
  }
  return v1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00025280) --------------------------------------------------------
int __usercall sub_25280@<eax>(int a1@<eax>, int a2)
{
  return sub_253B0(a1, a2, 0, 0);
}

//----- (000252A0) --------------------------------------------------------
int __cdecl sub_252A0(int a1)
{
  return sub_1C890(a1, 144);
}

//----- (000252C0) --------------------------------------------------------
void __cdecl sub_252C0(int a1)
{
  sub_1C930(a1);
}

//----- (000252E0) --------------------------------------------------------
unsigned int __cdecl sub_252E0(int a1)
{
  __int16 v1; // ax
  __int16 v2; // dx
  unsigned int result; // eax
  __int16 v4; // ax
  int i; // edx
  int v6; // ecx
  int v7; // edx

  v1 = sub_10C40((__int16 *)(a1 + 76));
  v2 = *(_WORD *)(a1 + 98);
  *(_WORD *)(a1 + 80) = v1;
  result = 0;
  if ( v2 )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v4 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v4;
    result = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v7 + 52) )
    {
      v7 = dword_EA3E4[i];
      if ( v7 == dword_EA3E4[0] )
        break;
      v6 = *(_DWORD *)(v7 + 8);
      if ( v6 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v6;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v7 + 38);
        result = 1;
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    result = 2;
  }
  if ( result )
  {
    if ( result <= 1 )
      *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
    else
      *(_BYTE *)(a1 + 69) = -108;
  }
  return result;
}
// 25381: conditional instruction was optimized away because eax.4==2
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000253B0) --------------------------------------------------------
int __usercall sub_253B0@<eax>(int result@<eax>, int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v4; // esi
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rt2
  unsigned __int16 v7; // ax
  unsigned int v8; // et2
  unsigned __int16 v9; // ax
  unsigned int v10; // et2

  if ( !a3 )
  {
    if ( a4 )
    {
      if ( a4 != 1 )
        goto LABEL_17;
      HIDWORD(v5) = 0;
      *(_WORD *)(a2 + 20) = 9377 * *(_WORD *)(a2 + 20) + 9439;
      WORD1(v5) = 0;
      v4 = 60;
    }
    else
    {
      v4 = 400;
      *(_WORD *)(a2 + 20) = 9377 * *(_WORD *)(a2 + 20) + 9439;
      v5 = 0i64;
    }
    LOWORD(v5) = *(_WORD *)(a2 + 20);
    v6 = v5 % (unsigned int)v4;
    result = v5 / (unsigned int)v4;
    *(_DWORD *)(a2 + 16) = v4 + v6;
LABEL_17:
    *(_BYTE *)(a2 + 70) = a4;
    *(_BYTE *)(a2 + 69) = a3 - 112;
    return result;
  }
  if ( a3 <= 1u )
  {
    *(_WORD *)(a2 + 20) = 9377 * *(_WORD *)(a2 + 20) + 9439;
    v7 = *(_WORD *)(a2 + 20);
    v8 = v7 % 0x190u;
    result = v7 / 0x190u;
    *(_DWORD *)(a2 + 16) = v8 + 400;
    *(_BYTE *)(a2 + 70) = a4;
    *(_BYTE *)(a2 + 69) = a3 - 112;
    return result;
  }
  if ( a3 != 2 )
    goto LABEL_17;
  result = a4;
  switch ( a4 )
  {
    case 0u:
      *(_WORD *)(a2 + 20) = 9377 * *(_WORD *)(a2 + 20) + 9439;
      v9 = *(_WORD *)(a2 + 20);
      v10 = v9 % 0xC8u;
      result = v9 / 0xC8u;
      *(_DWORD *)(a2 + 16) = v10 + 200;
      *(_BYTE *)(a2 + 70) = a4;
      *(_BYTE *)(a2 + 69) = -110;
      break;
    case 1u:
      *(_DWORD *)(a2 + 16) = 10;
      *(_BYTE *)(a2 + 70) = a4;
      *(_BYTE *)(a2 + 69) = -110;
      break;
    case 2u:
      *(_DWORD *)(a2 + 16) = 12;
      *(_BYTE *)(a2 + 70) = a4;
      *(_BYTE *)(a2 + 69) = -110;
      break;
    case 3u:
      *(_DWORD *)(a2 + 16) = 14;
      goto LABEL_17;
    default:
      goto LABEL_17;
  }
  return result;
}

//----- (000254E0) --------------------------------------------------------
int __cdecl sub_254E0(int a1, int a2, unsigned __int8 a3)
{
  int result; // eax

  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
  result = sub_58350(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32), 5, (a3 << 11) / 360);
  *(_WORD *)(a1 + 28) += result;
  BYTE1(result) = *(_BYTE *)(a1 + 29) & 7;
  *(_BYTE *)(a1 + 29) = BYTE1(result);
  return result;
}

//----- (00025550) --------------------------------------------------------
int __cdecl sub_25550(int a1)
{
  int result; // eax

  sub_1D5D0(a1, 144);
  result = sub_10C40((__int16 *)(a1 + 76));
  *(_WORD *)(a1 + 80) = result;
  BYTE1(result) = *(_BYTE *)(a1 + 69);
  if ( BYTE1(result) == 0x92 )
    return sub_253B0(result, a1, 2u, 0);
  return result;
}

//----- (00025590) --------------------------------------------------------
int __cdecl sub_25590(int a1)
{
  int result; // eax

  result = sub_1BD90(a1, 152);
  BYTE1(result) = *(_BYTE *)(a1 + 69);
  if ( BYTE1(result) == 0x9A )
    *(_BYTE *)(a1 + 70) = 0;
  return result;
}

//----- (000255C0) --------------------------------------------------------
void __cdecl sub_255C0(int a1)
{
  sub_1BF90(a1, 152);
  if ( *(_BYTE *)(a1 + 69) == 0x9A )
    *(_BYTE *)(a1 + 70) = 0;
}

//----- (00025610) --------------------------------------------------------
void __cdecl sub_25610(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // ax
  int i; // edx
  int v4; // edx
  int v5; // ecx
  __int16 v6; // ax
  unsigned int v7; // eax
  __int16 v8; // ax
  __int16 v9; // ax
  char v10; // dh
  unsigned int j; // ecx
  __int64 v12; // rax
  __int64 v13; // rax
  __int16 v14; // cx
  int v15; // eax
  int v16; // edx
  unsigned int v17; // ecx
  __int64 v18; // rax
  __int64 v19; // rax
  unsigned int v20; // edx
  __int16 v21; // dx
  __int16 v22; // dx
  __int16 v23; // ax
  int v24; // edi
  unsigned int v25; // ecx
  __int64 v26; // rax
  __int64 v27; // rax
  int v28; // ecx
  char v29; // dh
  int v30; // ecx
  unsigned int v31; // esi
  __int16 v32; // ax
  __int16 v33; // ax
  int v34; // edx
  unsigned int v35; // ecx
  __int64 v36; // rax
  __int64 v37; // rax
  int v38; // ecx
  unsigned int v39; // esi
  __int16 v40; // ax
  __int16 v41; // [esp-4h] [ebp-18h]
  unsigned __int16 *v42; // [esp+0h] [ebp-14h]

  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    v1 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        v1 = 1;
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v1 = 2;
  }
  if ( v1 )
  {
    if ( v1 <= 1 )
    {
      v6 = *(_WORD *)(a1 + 38);
      *(_BYTE *)(a1 + 70) = 7;
      *(_WORD *)(a1 + 150) = v6;
    }
    else
    {
      *(_BYTE *)(a1 + 69) = -100;
    }
  }
  else
  {
    sub_1B8C0(a1);
    v7 = sub_1ED30(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
    v42 = (unsigned __int16 *)v7;
    if ( v7 <= dword_EA3E4[0] || *(int *)(v7 + 8) < 0 || (*(_BYTE *)(v7 + 13) & 4) != 0 )
    {
LABEL_89:
      v40 = *(_WORD *)(a1 + 132);
      *(_BYTE *)(a1 + 69) = -103;
      *(_WORD *)(a1 + 130) = v40;
    }
    else
    {
      switch ( *(_BYTE *)(a1 + 70) )
      {
        case 0:
          v8 = *(_WORD *)(a1 + 132);
          *(_BYTE *)(a1 + 70) = 1;
          *(_WORD *)(a1 + 130) = v8;
          goto LABEL_22;
        case 1:
LABEL_22:
          *(_DWORD *)&word_EB398 = *((_DWORD *)v42 + 19);
          *(&word_EB398 + 2) = v42[40];
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          sub_57FA0(
            &word_EB398,
            (v42[14] - 256 + (int)((*(unsigned __int16 *)(a1 + 20) % 0x5Au) << 11) / 360) & 0x7FF,
            0,
            2048);
          if ( sub_583F0((_WORD *)(a1 + 76), &word_EB398) <= 0x500 )
          {
            *(_BYTE *)(a1 + 70) = 2;
          }
          else
          {
            v9 = sub_581E0((_WORD *)(a1 + 76), &word_EB398);
            v10 = *(_BYTE *)(a1 + 62);
            *(_WORD *)(a1 + 32) = v9;
            if ( (v10 & 3) != 0 )
              return;
            for ( j = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
            {
              if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26) )
              {
                v12 = *(__int16 *)(a1 + 76) - *(__int16 *)(j + 76);
                if ( (int)((HIDWORD(v12) ^ v12) - HIDWORD(v12)) < *(__int16 *)(a1 + 84) )
                {
                  v13 = *(__int16 *)(a1 + 78) - *(__int16 *)(j + 78);
                  if ( (int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) < *(__int16 *)(a1 + 84) )
                  {
                    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
                    return;
                  }
                }
              }
            }
          }
          return;
        case 2:
          v14 = *(_WORD *)(a1 + 20);
          *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 134);
          *(_WORD *)(a1 + 20) = 9377 * v14 + 9439;
          v15 = *(__int16 *)(v7 + 80);
          v16 = *(_WORD *)(a1 + 20) & 0x3FF;
          *(_BYTE *)(a1 + 70) = 3;
          *(_DWORD *)(a1 + 16) = v16 + v15;
          goto LABEL_34;
        case 3:
LABEL_34:
          *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), v42 + 38);
          if ( (*(_BYTE *)(a1 + 62) & 3) != 0 )
            return;
          v17 = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403);
          while ( 2 )
          {
            if ( v17 > dword_EA3E4[0] )
            {
              if ( *(_WORD *)(v17 + 26) == *(_WORD *)(a1 + 26)
                || (v18 = *(__int16 *)(a1 + 76) - *(__int16 *)(v17 + 76),
                    (int)((HIDWORD(v18) ^ v18) - HIDWORD(v18)) >= *(__int16 *)(a1 + 84))
                || (v19 = *(__int16 *)(a1 + 78) - *(__int16 *)(v17 + 78),
                    (int)((HIDWORD(v19) ^ v19) - HIDWORD(v19)) >= *(__int16 *)(a1 + 84)) )
              {
                v17 = *(_DWORD *)v17;
                continue;
              }
              *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(v17 + 76), (_WORD *)(a1 + 76));
            }
            break;
          }
          *(_DWORD *)&word_EB398 = *((_DWORD *)v42 + 19);
          *(&word_EB398 + 2) = v42[40];
          sub_57FA0(&word_EB398, v42[14], 0, 2048);
          if ( sub_583F0((_WORD *)(a1 + 76), &word_EB398) > 0x500 )
          {
LABEL_54:
            *(_BYTE *)(a1 + 70) = 0;
          }
          else
          {
            *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
            v20 = *(unsigned __int16 *)(a1 + 20) % 0x11Fu;
            if ( (v20 & 0x3F) == 0 )
              *(_BYTE *)(a1 + 70) = 6;
            if ( (v20 & 0x1F) == 0 )
              *(_BYTE *)(a1 + 70) = 7;
            if ( !v20 )
              *(_BYTE *)(a1 + 70) = 4;
            if ( (v20 & 3) == 0 )
            {
              if ( *(__int16 *)(a1 + 80) <= *(_DWORD *)(a1 + 16) )
                v21 = 64;
              else
                v21 = -64;
              *(_WORD *)(a1 + 80) += v21;
            }
          }
          return;
        case 4:
          v32 = *(_WORD *)(a1 + 132);
          *(_BYTE *)(a1 + 70) = 5;
          *(_WORD *)(a1 + 130) = v32;
          goto LABEL_78;
        case 5:
LABEL_78:
          if ( (*(_BYTE *)(a1 + 62) & 3) != 0 )
            goto LABEL_86;
          v33 = sub_581E0((_WORD *)(a1 + 76), v42 + 38);
          v34 = dword_D41A4;
          *(_WORD *)(a1 + 32) = v33;
          v35 = *(_DWORD *)(v34 + 4 * *(char *)(a1 + 64) + 38403);
          while ( 2 )
          {
            if ( v35 > dword_EA3E4[0] )
            {
              if ( *(_WORD *)(v35 + 26) == *(_WORD *)(a1 + 26)
                || (v36 = *(__int16 *)(a1 + 76) - *(__int16 *)(v35 + 76),
                    (int)((HIDWORD(v36) ^ v36) - HIDWORD(v36)) >= *(__int16 *)(a1 + 84))
                || (v37 = *(__int16 *)(a1 + 78) - *(__int16 *)(v35 + 78),
                    (int)((HIDWORD(v37) ^ v37) - HIDWORD(v37)) >= *(__int16 *)(a1 + 84)) )
              {
                v35 = *(_DWORD *)v35;
                continue;
              }
              *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(v35 + 76), (_WORD *)(a1 + 76));
            }
            break;
          }
LABEL_86:
          v38 = *(_DWORD *)(a1 + 160);
          if ( *(unsigned __int8 *)(a1 + 62) % *(__int16 *)(v38 + 26) )
            return;
          v39 = *(__int16 *)(v38 + 28);
          if ( sub_583F0((_WORD *)(a1 + 76), v42 + 38) >= v39 )
            goto LABEL_76;
          sub_1CC20((_WORD *)a1, (unsigned int)v42);
          return;
        case 6:
          goto LABEL_89;
        case 7:
          v22 = *(_WORD *)(a1 + 20);
          *(_WORD *)(a1 + 130) = 3 * *(_WORD *)(a1 + 132);
          *(_WORD *)(a1 + 20) = 9377 * v22 + 9439;
          v41 = (*(_WORD *)(a1 + 20) & 1) + 43;
          v23 = (a1 - (dword_D41A0 + 28302)) / 168;
          *(_DWORD *)(a1 + 16) = 24;
          *(_BYTE *)(a1 + 70) = 8;
          sub_6E450(v23, -1, v41);
          goto LABEL_56;
        case 8:
        case 9:
LABEL_56:
          v24 = *(_DWORD *)(a1 + 16) - 1;
          *(_DWORD *)(a1 + 16) = v24;
          if ( !v24 )
            goto LABEL_54;
          if ( (*(_BYTE *)(a1 + 62) & 3) != 0 )
            goto LABEL_67;
          if ( v24 > 16 )
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), v42 + 38);
          v25 = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403);
          break;
        default:
          return;
      }
      while ( v25 > dword_EA3E4[0] )
      {
        if ( *(_WORD *)(v25 + 26) != *(_WORD *)(a1 + 26) )
        {
          v26 = *(__int16 *)(a1 + 76) - *(__int16 *)(v25 + 76);
          if ( (int)((HIDWORD(v26) ^ v26) - HIDWORD(v26)) < *(__int16 *)(a1 + 84) )
          {
            v27 = *(__int16 *)(a1 + 78) - *(__int16 *)(v25 + 78);
            if ( (int)((HIDWORD(v27) ^ v27) - HIDWORD(v27)) < *(__int16 *)(a1 + 84) )
            {
              *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(v25 + 76), (_WORD *)(a1 + 76));
              break;
            }
          }
        }
        v25 = *(_DWORD *)v25;
      }
LABEL_67:
      v28 = (__int16)v42[40] - *(__int16 *)(a1 + 80);
      if ( (int)abs32(v28) > 64 )
      {
        if ( v28 <= 0 )
          LOWORD(v28) = -64;
        else
          LOWORD(v28) = 64;
      }
      v29 = *(_BYTE *)(a1 + 70);
      *(_WORD *)(a1 + 80) += v28;
      if ( v29 == 8 && (unsigned __int16)sub_1CED0(a1, (int)v42) )
        *(_BYTE *)(a1 + 70) = 9;
      v30 = *(_DWORD *)(a1 + 160);
      if ( !(*(unsigned __int8 *)(a1 + 62) % *(__int16 *)(v30 + 26)) )
      {
        v31 = *(__int16 *)(v30 + 28);
        if ( sub_583F0((_WORD *)(a1 + 76), v42 + 38) >= v31 )
LABEL_76:
          *(_BYTE *)(a1 + 70) = 6;
      }
    }
  }
}
// 256A2: conditional instruction was optimized away because eax.4==2
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00025CD0) --------------------------------------------------------
char __cdecl sub_25CD0(int a1)
{
  char result; // al

  result = sub_1C560(a1, 0x98u);
  if ( *(_BYTE *)(a1 + 69) == 0x9A )
    *(_BYTE *)(a1 + 70) = 0;
  return result;
}

//----- (00025D00) --------------------------------------------------------
int __cdecl sub_25D00(int a1)
{
  return sub_1C890(a1, 152);
}

//----- (00025D20) --------------------------------------------------------
void __cdecl sub_25D20(int a1)
{
  sub_1C930(a1);
}

//----- (00025D50) --------------------------------------------------------
void __cdecl sub_25D50(int a1)
{
  sub_1D5D0(a1, 152);
  if ( *(_BYTE *)(a1 + 69) == 0x9A )
    *(_BYTE *)(a1 + 70) = 0;
}

//----- (00025D80) --------------------------------------------------------
unsigned int __cdecl sub_25D80(int a1)
{
  unsigned int result; // eax

  result = sub_1BD90(a1, 160);
  BYTE1(result) = *(_BYTE *)(a1 + 69);
  if ( BYTE1(result) == 0xA2 )
  {
    result = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( result <= dword_EA3E4[0] || *(_BYTE *)(result + 63) != 3 || *(_BYTE *)(result + 64) >= 2u )
      *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 70) = 0;
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00025DE0) --------------------------------------------------------
void __cdecl sub_25DE0(int a1)
{
  unsigned int v1; // eax

  sub_1BF90(a1, 160);
  if ( *(_BYTE *)(a1 + 69) == 0xA2 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v1 <= dword_EA3E4[0] || *(_BYTE *)(v1 + 63) != 3 || *(_BYTE *)(v1 + 64) >= 2u )
      *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 70) = 0;
  }
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00025E40) --------------------------------------------------------
void __cdecl sub_25E40(int a1)
{
  unsigned int v1; // esi
  unsigned __int8 v2; // al
  char v3; // al
  _BOOL1 v4; // zf
  __int16 v5; // dx
  int v6; // ecx
  __int16 v7; // ax
  char v8; // [esp+0h] [ebp-4h]

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v8 = 0;
  if ( v1 <= dword_EA3E4[0] )
  {
    *(_BYTE *)(a1 + 69) = -95;
    goto LABEL_20;
  }
  sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 32);
  v2 = *(_BYTE *)(a1 + 70);
  if ( v2 )
  {
    if ( v2 <= 1u )
    {
      *(_BYTE *)(a1 + 70) = 2;
      v5 = *(_WORD *)(a1 + 132);
      *(_DWORD *)(a1 + 16) = 32;
      *(_WORD *)(a1 + 130) = 2 * v5;
    }
    else if ( v2 != 2 )
    {
      goto LABEL_20;
    }
    if ( (unsigned __int16)sub_1C310(a1, 160, (unsigned __int16 (__cdecl *)(int, int))sub_1CE80) )
      v8 = 1;
    v6 = *(_DWORD *)(a1 + 16) - 1;
    *(_DWORD *)(a1 + 16) = v6;
    if ( !v6 )
      v8 = 1;
    if ( v8 )
    {
      v7 = *(_WORD *)(a1 + 132);
      *(_BYTE *)(a1 + 70) = 0;
      *(_WORD *)(a1 + 130) = v7;
    }
  }
  else
  {
    v3 = sub_1C310(a1, 160, (unsigned __int16 (__cdecl *)(int, int))sub_1D1A0);
    if ( *(_BYTE *)(v1 + 63) != 3 || *(_BYTE *)(v1 + 64) )
      v4 = v3 == 0;
    else
      v4 = *(_BYTE *)(*(_DWORD *)(v1 + 164) + 334) == 0;
    if ( !v4 )
      *(_BYTE *)(a1 + 70) = 1;
  }
LABEL_20:
  if ( *(_BYTE *)(a1 + 69) != 0xA2 )
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00025F70) --------------------------------------------------------
char __cdecl sub_25F70(int a1)
{
  unsigned int v1; // eax

  LOBYTE(v1) = sub_1C560(a1, 0xA0u);
  if ( *(_BYTE *)(a1 + 69) == 0xA2 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v1 <= dword_EA3E4[0] || *(_BYTE *)(v1 + 63) != 3 || *(_BYTE *)(v1 + 64) >= 2u )
      *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 70) = 0;
  }
  return v1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00025FD0) --------------------------------------------------------
int __cdecl sub_25FD0(int a1)
{
  return sub_1C890(a1, 160);
}

//----- (00025FF0) --------------------------------------------------------
void __cdecl sub_25FF0(int a1)
{
  sub_1C930(a1);
}

//----- (00026020) --------------------------------------------------------
void __cdecl sub_26020(int a1)
{
  sub_1D5D0(a1, 160);
  if ( *(_BYTE *)(a1 + 69) == 0xA2 )
    *(_BYTE *)(a1 + 70) = 0;
}

//----- (00026050) --------------------------------------------------------
int __cdecl sub_26050(int a1)
{
  return sub_268F0(a1, 1u);
}

//----- (00026070) --------------------------------------------------------
char __cdecl sub_26070(int a1)
{
  int v1; // eax
  unsigned __int16 v2; // ax
  int v3; // eax
  unsigned int v4; // edi
  unsigned int v5; // esi
  int v6; // edx
  int v7; // eax
  __int16 v8; // ax
  int v10; // [esp+0h] [ebp-10h]
  unsigned int v11; // [esp+4h] [ebp-Ch]
  unsigned int v12; // [esp+8h] [ebp-8h]
  unsigned int v13; // [esp+Ch] [ebp-4h]

  v1 = sub_26830(a1);
  if ( (unsigned int)v1 <= 1 )
  {
    sub_1B8C0(a1);
    sub_265A0(a1);
    LOBYTE(v1) = sub_26930(a1);
    if ( (_BYTE)v1 )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v2 = *(_WORD *)(a1 + 20);
      *(_WORD *)(a1 + 20) = 9377 * v2 + 9439;
      *(_WORD *)(a1 + 28) += ((unsigned __int8)*(_WORD *)(a1 + 20) + 85) * (2 * (v2 % 0x9Du / 79i64) - 1);
      *(_BYTE *)(a1 + 29) &= 7u;
      LOWORD(v1) = *(_WORD *)(a1 + 28);
      *(_WORD *)(a1 + 32) = v1;
    }
    if ( (*(_BYTE *)(a1 + 62) & 0x3F) == 0 && *(_BYTE *)(a1 + 57) )
    {
      v3 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
      v1 = v3 * v3;
      v4 = 0;
      v12 = -1;
      v5 = *(_DWORD *)(dword_D41A4 + 38519);
      v11 = v1;
      while ( v5 > dword_EA3E4[0] )
      {
        v6 = (__int16)(*(_WORD *)(v5 + 76) - *(_WORD *)(a1 + 76));
        v7 = (__int16)(*(_WORD *)(v5 + 78) - *(_WORD *)(a1 + 78));
        v1 = v7 * v7;
        v13 = v1 + v6 * v6;
        if ( v13 <= v11 && (*(_BYTE *)(v5 + 12) & 0x20) == 0 )
        {
          v10 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 30);
          v8 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v5 + 76));
          v1 = (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v8);
          if ( v1 < v10 )
          {
            LOBYTE(v1) = v13;
            if ( v13 < v12 )
            {
              v4 = v5;
              v12 = v13;
            }
          }
        }
        v5 = *(_DWORD *)v5;
      }
      if ( v4 )
      {
        *(_WORD *)(a1 + 150) = (int)(v4 - (dword_D41A0 + 28302)) / 168;
        LOBYTE(v1) = sub_268F0(a1, 2u);
      }
    }
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00026220) --------------------------------------------------------
unsigned int __usercall sub_26220@<eax>(unsigned int a1@<esi>, int a2)
{
  unsigned int result; // eax
  unsigned __int16 v3; // dx
  unsigned int v4; // eax
  unsigned int i; // ecx
  unsigned int v6; // edi
  char v7; // [esp+8h] [ebp-8h]
  char v8; // [esp+Ch] [ebp-4h]

  v7 = 1;
  v8 = 0;
  result = sub_26830(a2);
  if ( result <= 1 )
  {
    v3 = *(_WORD *)(a2 + 150);
    if ( v3 )
    {
      v4 = sub_1ED30(a2, dword_EA3E4[v3]);
      a1 = v4;
      if ( v4 <= dword_EA3E4[0] || *(int *)(v4 + 8) < 0 || (*(_BYTE *)(v4 + 13) & 4) != 0 )
        v7 = 0;
    }
    else
    {
      v7 = 0;
    }
    if ( !v7 )
      goto LABEL_21;
    if ( sub_26930(a2) )
    {
      *(_WORD *)(a2 + 32) = sub_581E0((_WORD *)(a2 + 76), (_WORD *)(a1 + 76));
      if ( (*(_BYTE *)(a2 + 62) & 3) == 0 )
      {
        for ( i = *(_DWORD *)(4 * *(char *)(a2 + 64) + dword_D41A4 + 38403); i > dword_EA3E4[0]; i = *(_DWORD *)i )
        {
          if ( *(_WORD *)(i + 26) != *(_WORD *)(a2 + 26)
            && (int)abs32(*(__int16 *)(a2 + 76) - *(__int16 *)(i + 76)) < *(__int16 *)(a2 + 84)
            && (int)abs32(*(__int16 *)(a2 + 78) - *(__int16 *)(i + 78)) < *(__int16 *)(a2 + 84) )
          {
            *(_WORD *)(a2 + 32) = sub_581E0((_WORD *)(i + 76), (_WORD *)(a2 + 76));
            break;
          }
        }
      }
    }
    if ( (*(_BYTE *)(a2 + 62) & 0x1F) != 0 )
      goto LABEL_22;
    v6 = *(__int16 *)(*(_DWORD *)(a2 + 160) + 28);
    if ( sub_583F0((_WORD *)(a2 + 76), (_WORD *)(a1 + 76)) < v6 )
      sub_1CC20((_WORD *)a2, a1);
    else
LABEL_21:
      v8 = 1;
LABEL_22:
    sub_1B8C0(a2);
    result = sub_265A0(a2);
    if ( v8 )
      return sub_268F0(a2, 1u);
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000263C0) --------------------------------------------------------
int __cdecl sub_263C0(int a1)
{
  return sub_268F0(a1, 1u);
}

//----- (000263E0) --------------------------------------------------------
int __cdecl sub_263E0(int a1)
{
  return sub_1C890(a1, 168);
}

//----- (00026400) --------------------------------------------------------
void __cdecl sub_26400(int a1)
{
  sub_1C930(a1);
}

//----- (00026470) --------------------------------------------------------
int __cdecl sub_26470(_BYTE *a1)
{
  int result; // eax

  sub_1D5D0((int)a1, 168);
  result = (unsigned __int8)(a1[73] - 1);
  switch ( a1[73] )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 0xA:
      result = sub_265A0((int)a1);
      break;
    case 0xD:
    case 0xE:
    case 0x10:
      a1[67] = 0;
      result = sub_265A0((int)a1);
      break;
    default:
      break;
  }
  BYTE1(result) = a1[69];
  if ( BYTE1(result) != 0xAF )
    return sub_268F0((int)a1, BYTE1(result) + 88);
  return result;
}

//----- (00026500) --------------------------------------------------------
int __usercall sub_26500@<eax>(int result@<eax>, int a2)
{
  switch ( *(_BYTE *)(a2 + 70) )
  {
    case 0:
      result = 311;
      break;
    case 1:
    case 2:
    case 3:
    case 9:
      result = 308;
      break;
    case 4:
      result = 309;
      break;
    case 5:
      result = 310;
      break;
    case 6:
      result = 305;
      break;
    case 7:
      result = 306;
      break;
    case 8:
      result = 307;
      break;
    case 0xA:
      result = 312;
      break;
    default:
      break;
  }
  if ( *(__int16 *)(a2 + 90) != result )
    return sub_49CD0((_WORD *)a2, result);
  return result;
}

//----- (000265A0) --------------------------------------------------------
int __cdecl sub_265A0(int a1)
{
  char v1; // dh
  __int16 v2; // t2
  int v3; // esi
  unsigned int v4; // esi
  unsigned int v5; // edx
  int v6; // esi
  __int16 v7; // cx
  int v8; // edi
  int v9; // eax
  int v10; // eax
  int result; // eax
  char v12; // [esp+0h] [ebp-8h]
  char v13; // [esp+4h] [ebp-4h]

  v12 = 0;
  v13 = 1;
  switch ( *(_BYTE *)(a1 + 70) )
  {
    case 0:
    case 1:
      v1 = *(_BYTE *)(a1 + 68);
      if ( v1 )
        *(_BYTE *)(a1 + 68) = v1 - 1;
      else
        *(_BYTE *)(a1 + 70) = 2;
      v12 = 1;
      v13 = 0;
      break;
    case 2:
      v12 = 1;
      *(_BYTE *)(a1 + 70) = 3;
      v13 = 0;
      break;
    case 3:
      *(_BYTE *)(a1 + 70) = 4;
      break;
    case 4:
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v2 = *(_WORD *)(a1 + 20) % 0x64u;
      *(_BYTE *)(a1 + 70) = 5;
      *(_WORD *)(a1 + 44) = v2 + 140;
      break;
    case 5:
      if ( *(__int16 *)(a1 + 44) < 0 )
        *(_BYTE *)(a1 + 70) = 6;
      break;
    case 6:
      v3 = *(__int16 *)(a1 + 80);
      if ( v3 - (__int16)sub_10C40((__int16 *)(a1 + 76)) < 230 )
        *(_BYTE *)(a1 + 70) = 7;
      break;
    case 7:
      *(_BYTE *)(a1 + 70) = 8;
      v13 = 0;
      break;
    case 8:
      v12 = 1;
      *(_BYTE *)(a1 + 70) = 9;
      v13 = 0;
      break;
    case 9:
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      if ( !(*(unsigned __int16 *)(a1 + 20) % 0xBu) )
        sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 42);
      if ( *(_BYTE *)(a1 + 67) )
      {
        v4 = *(char *)(a1 + 67);
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v5 = *(unsigned __int16 *)(a1 + 20) % v4;
        *(_BYTE *)(a1 + 68) = v5;
        *(_BYTE *)(a1 + 70) = (v5 & 1) == 0;
      }
      else
      {
        *(_BYTE *)(a1 + 68) = 1;
        *(_BYTE *)(a1 + 70) = 0;
      }
      v12 = 1;
      v13 = 0;
      break;
    case 0xA:
      v12 = 1;
      break;
    default:
      break;
  }
  v6 = (__int16)sub_10C40((__int16 *)(a1 + 76));
  if ( v12 )
  {
    *(_WORD *)(a1 + 80) -= 42;
  }
  else
  {
    v7 = *(_WORD *)(a1 + 44) - 42;
    *(_WORD *)(a1 + 80) += *(_WORD *)(a1 + 44);
    *(_WORD *)(a1 + 44) = v7;
  }
  if ( *(__int16 *)(a1 + 80) < v6 )
    *(_WORD *)(a1 + 80) = v6;
  if ( byte_D41B6 )
  {
    v8 = *(__int16 *)(a1 + 88);
    v9 = (__int16)sub_10C60((__int16 *)(a1 + 76)) - v8;
    if ( *(__int16 *)(a1 + 80) > v9 )
    {
      *(_WORD *)(a1 + 44) = 0;
      *(_WORD *)(a1 + 80) = v9;
    }
  }
  if ( sub_104D0((__int16 *)(a1 + 76)) == 1 )
  {
    if ( *(_BYTE *)(a1 + 70) == 10 )
    {
      if ( *(__int16 *)(a1 + 80) > v6 )
        *(_BYTE *)(a1 + 70) = 0;
    }
    else if ( *(__int16 *)(a1 + 80) == v6 )
    {
      *(_BYTE *)(a1 + 70) = 10;
      sub_4A190((int)&word_EB398, 10, 5);
    }
    if ( *(_BYTE *)(a1 + 69) == 0xAA )
      v10 = 66;
    else
      v10 = 40;
  }
  else
  {
    if ( *(_BYTE *)(a1 + 70) == 10 )
      *(_BYTE *)(a1 + 70) = 0;
    if ( *(_BYTE *)(a1 + 69) == 0xAA )
      v10 = 96;
    else
      v10 = 60;
  }
  *(_WORD *)(a1 + 130) = v10;
  result = sub_26500(v10, a1);
  if ( !v13 )
    *(_BYTE *)(a1 + 13) |= 8u;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// EB398: using guessed type __int16 word_EB398;

//----- (00026830) --------------------------------------------------------
int __cdecl sub_26830(int a1)
{
  __int16 v1; // dx
  unsigned int v2; // ebx
  int i; // edx
  int v4; // ecx
  int v5; // edx

  v1 = *(_WORD *)(a1 + 98);
  v2 = 0;
  if ( v1 )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v1 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v2 = 1;
  }
  *(_WORD *)(a1 + 38) = v1;
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        v2 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    v2 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v2 )
  {
    if ( v2 > 1 )
    {
      *(_BYTE *)(a1 + 69) = -84;
      return 2;
    }
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
    sub_268F0(a1, 2u);
  }
  return v2;
}
// 268BB: conditional instruction was optimized away because ebx.4==2
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000268F0) --------------------------------------------------------
int __cdecl sub_268F0(int a1, unsigned __int8 a2)
{
  int result; // eax

  result = a1;
  if ( a2 )
  {
    if ( a2 <= 1u )
    {
      *(_BYTE *)(a1 + 67) = 64;
      *(_WORD *)(a1 + 150) = 0;
    }
    else if ( a2 == 2 )
    {
      *(_BYTE *)(a1 + 67) = 0;
    }
  }
  *(_BYTE *)(a1 + 69) = a2 - 88;
  return result;
}

//----- (00026930) --------------------------------------------------------
char __cdecl sub_26930(int a1)
{
  char result; // al
  unsigned __int8 v2; // ah

  result = 0;
  v2 = *(_BYTE *)(a1 + 70);
  if ( v2 >= 9u && (v2 <= 9u || v2 == 10 && (*(_BYTE *)(a1 + 62) & 7) == 0) )
    return 1;
  return result;
}

//----- (00026960) --------------------------------------------------------
void __cdecl sub_26960(int a1)
{
  sub_26FF0(a1);
  sub_272C0(a1);
  sub_26F10(a1);
  sub_27880(a1);
}

//----- (00026990) --------------------------------------------------------
int __cdecl sub_26990(int a1)
{
  __int16 v1; // si
  __int16 v2; // di
  int result; // eax
  int v4; // edx
  __int16 v5; // ax
  int v6; // [esp+0h] [ebp-1Ch]
  int v7; // [esp+8h] [ebp-14h]
  __int16 v8; // [esp+10h] [ebp-Ch]
  char v9; // [esp+18h] [ebp-4h]

  v9 = 1;
  sub_26FF0(a1);
  sub_272C0(a1);
  v7 = *(int *)(a1 + 16) >> 8;
  v1 = (unsigned __int8)*(_WORD *)(a1 + 16);
  v2 = 0;
  result = sub_369F0(a1, *(_WORD *)(a1 + 148));
  v8 = result;
  while ( v2 < (__int16)((v1 != 0) + 1) )
  {
    if ( v2 )
      v4 = -v1;
    else
      LOWORD(v4) = v1;
    result = abs16(v4 + v7);
    if ( result <= *(char *)(a1 + 70) / 2 )
    {
      result = sub_27470(a1, v4 + v7);
      v6 = result;
      if ( result )
      {
        v5 = sub_278F0(v8, *(char *)(a1 + 70), v4 + v7);
        result = sub_49D50(v6, v5);
        v9 = 0;
      }
    }
    ++v2;
  }
  if ( v9 )
  {
    if ( *(_WORD *)(a1 + 148) )
      *(_BYTE *)(a1 + 69) = -78;
    else
      *(_BYTE *)(a1 + 69) = -80;
  }
  else
  {
    result = (__int16)(v1 + 1);
    *(_DWORD *)(a1 + 16) = result | ((__int16)v7 << 8);
  }
  return result;
}

//----- (00026AA0) --------------------------------------------------------
void __cdecl sub_26AA0(int a1)
{
  unsigned __int16 v1; // dx
  int v2; // eax
  unsigned __int16 v3; // si
  int v4; // esi
  __int16 v5; // ax
  char v6; // ch
  char v7; // [esp+4h] [ebp-4h]

  v7 = 0;
  sub_26FF0(a1);
  sub_272C0(a1);
  sub_26F10(a1);
  sub_27880(a1);
  if ( (*(_BYTE *)(a1 + 62) & 0x1F) == 0 )
  {
    v1 = *(_WORD *)(a1 + 148);
    if ( !v1 )
      goto LABEL_12;
    if ( *(_WORD *)(a1 + 130) > *(_WORD *)(a1 + 134) )
      goto LABEL_13;
    v2 = dword_EA3E4[v1];
    if ( *(_BYTE *)(v2 + 63) != 3 )
      goto LABEL_12;
    if ( *(int *)(v2 + 8) < 0 )
      goto LABEL_12;
    if ( (*(_BYTE *)(v2 + 13) & 4) != 0 )
      goto LABEL_12;
    v3 = *(_WORD *)(*(_DWORD *)(v2 + 164) + 58);
    if ( !v3 )
      goto LABEL_12;
    v4 = dword_EA3E4[v3];
    v5 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v4 + 76));
    v6 = *(_BYTE *)(a1 + 62);
    *(_WORD *)(a1 + 32) = v5;
    if ( (v6 & 3) != 0 || sub_58490((_WORD *)(a1 + 76), (_WORD *)(v4 + 76)) > 0x100 )
      goto LABEL_13;
    if ( *(_DWORD *)(a1 + 144) + *(_DWORD *)(v4 + 144) < *(_DWORD *)(v4 + 140) )
    {
      *(_DWORD *)(a1 + 16) = 128;
      *(_BYTE *)(a1 + 69) = -77;
    }
    else
    {
LABEL_12:
      v7 = 1;
    }
LABEL_13:
    if ( v7 )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_WORD *)(a1 + 148) = 0;
      *(_BYTE *)(a1 + 69) = -79;
    }
  }
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00026BD0) --------------------------------------------------------
void __cdecl sub_26BD0(int a1)
{
  int v1; // edx
  char v2; // dl
  int v3; // eax
  unsigned __int16 v4; // dx
  int v5; // eax
  int v6; // edi
  int v7; // edx

  sub_272C0(a1);
  v1 = *(_DWORD *)(a1 + 16);
  if ( v1 )
  {
    *(_DWORD *)(a1 + 16) = v1 - 1;
  }
  else if ( (*(_BYTE *)(a1 + 62) & 1) == 0 )
  {
    v2 = *(_BYTE *)(a1 + 70);
    if ( v2 > 1 )
    {
      sub_27720(a1, v2 - 2);
    }
    else
    {
      v3 = dword_EA3E4[*(unsigned __int16 *)(a1 + 148)];
      if ( *(_BYTE *)(v3 + 63) == 3 && *(int *)(v3 + 8) >= 0 && (*(_BYTE *)(v3 + 13) & 4) == 0 )
      {
        v4 = *(_WORD *)(*(_DWORD *)(v3 + 164) + 58);
        if ( v4 )
        {
          v5 = dword_EA3E4[v4];
          v6 = *(_DWORD *)(v5 + 140);
          v7 = *(_DWORD *)(a1 + 144) + *(_DWORD *)(v5 + 144);
          if ( v7 >= v6 )
            *(_DWORD *)(v5 + 144) = v6;
          else
            *(_DWORD *)(v5 + 144) = v7;
        }
      }
      sub_57F10(a1);
    }
  }
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00026CA0) --------------------------------------------------------
int __cdecl sub_26CA0(int a1)
{
  sub_271D0(a1);
  return sub_26D20(a1);
}

//----- (00026CC0) --------------------------------------------------------
int __cdecl sub_26CC0(int a1)
{
  int i; // ebx
  int v2; // ebx

  for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v2 + 52) )
  {
    v2 = dword_EA3E4[i];
    if ( v2 == dword_EA3E4[0] )
      break;
    sub_36BA0(v2, 0);
    sub_57F10(v2);
  }
  sub_36BA0(a1, 0);
  return sub_57F10(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00026D20) --------------------------------------------------------
int __cdecl sub_26D20(int a1)
{
  int v1; // ebx
  unsigned __int8 v2; // al
  __int16 v3; // ax
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  __int16 v8; // cx
  __int16 v9; // ax
  __int16 v10; // ax
  int i; // eax
  int v12; // eax

  if ( *(_BYTE *)(a1 + 57) )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    v2 = *(_BYTE *)(v1 + 69);
    if ( v2 >= 0xB0u && (v2 <= 0xB0u || v2 == 0xB2) )
    {
      if ( *(_WORD *)(a1 + 98) )
      {
        *(_WORD *)(v1 + 130) = ((*(__int16 *)(v1 + 132) - *(__int16 *)(v1 + 134)) >> 2) + *(_WORD *)(v1 + 134);
        v3 = sub_581E0((_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 98)] + 76), (_WORD *)(a1 + 76));
        *(_WORD *)(v1 + 28) = v3;
        *(_WORD *)(v1 + 32) = v3;
        v4 = 56 * abs8(*(_BYTE *)(a1 + 70)) / (*(char *)(v1 + 70) >> 1);
        if ( ((*(_WORD *)(v1 + 28) - *(_WORD *)(a1 + 44)) & 0x7FFu) >= 0x400 )
          v4 = -v4;
        v5 = v4 + *(__int16 *)(v1 + 44);
        if ( (int)abs32(v5) < 11 )
        {
          if ( v5 <= 0 )
            v5 = -11;
          else
            v5 = 11;
        }
        if ( (int)abs32(v5) > 227 )
        {
          if ( v5 <= 0 )
            LOWORD(v5) = -227;
          else
            LOWORD(v5) = 227;
        }
        v6 = *(unsigned __int16 *)(v1 + 52);
        *(_WORD *)(v1 + 44) = v5;
        while ( 1 )
        {
          v7 = dword_EA3E4[v6];
          if ( v7 == dword_EA3E4[0] )
            break;
          *(_WORD *)(v7 + 98) = 0;
          v6 = *(unsigned __int16 *)(v7 + 52);
        }
      }
      v8 = *(_WORD *)(a1 + 104);
      if ( v8 )
      {
        if ( v8 != *(_WORD *)(v1 + 148) )
        {
          if ( *(_DWORD *)(a1 + 100) )
          {
            *(_BYTE *)(v1 + 69) = -79;
            *(_DWORD *)(v1 + 16) = *(char *)(a1 + 70) << 8;
            v10 = *(_WORD *)(a1 + 104);
            *(_WORD *)(v1 + 148) = v10;
            sub_6E450(v10, -1, 4);
            *(_BYTE *)(a1 + 14) |= 0x20u;
          }
          else if ( (*(_BYTE *)(a1 + 14) & 0x20) == 0 )
          {
            *(_BYTE *)(v1 + 69) = -79;
            *(_DWORD *)(v1 + 16) = *(char *)(a1 + 70) << 8;
            v9 = *(_WORD *)(a1 + 104);
            *(_WORD *)(v1 + 148) = v9;
            sub_6E450(v9, -1, 4);
          }
        }
        for ( i = *(unsigned __int16 *)(v1 + 52); ; i = *(unsigned __int16 *)(v12 + 52) )
        {
          v12 = dword_EA3E4[i];
          if ( v12 == dword_EA3E4[0] )
            break;
          *(_WORD *)(v12 + 104) = 0;
        }
      }
    }
  }
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00026F10) --------------------------------------------------------
int __cdecl sub_26F10(int a1)
{
  int v1; // eax
  __int16 v2; // cx
  __int16 v3; // si
  __int16 v4; // ax
  __int16 v5; // di
  __int16 v6; // ax

  if ( *(_BYTE *)(a1 + 57) )
  {
    if ( *(_WORD *)(a1 + 98) )
    {
      v1 = (*(int *)(a1 + 94) >> 2) + *(__int16 *)(a1 + 130);
      v2 = *(_WORD *)(a1 + 134);
      *(_WORD *)(a1 + 130) = v1;
      if ( (__int16)v1 < v2 )
        *(_WORD *)(a1 + 130) = v2;
      v3 = *(_WORD *)(a1 + 132);
      if ( *(__int16 *)(a1 + 130) > v3 )
        *(_WORD *)(a1 + 130) = v3;
      v4 = sub_581E0((_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 98)] + 76), (_WORD *)(a1 + 76));
      *(_WORD *)(a1 + 98) = 0;
      *(_WORD *)(a1 + 28) = v4;
      *(_WORD *)(a1 + 32) = v4;
    }
    v5 = *(_WORD *)(a1 + 104);
    if ( v5 )
    {
      if ( v5 != *(_WORD *)(a1 + 148) )
      {
        v6 = *(_WORD *)(a1 + 104);
        *(_WORD *)(a1 + 148) = v6;
        *(_BYTE *)(a1 + 69) = -79;
        *(_DWORD *)(a1 + 16) = 0;
        sub_6E450(v6, -1, 4);
      }
      *(_WORD *)(a1 + 104) = 0;
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
    *(_BYTE *)(a1 + 69) = -75;
  return 0;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00026FF0) --------------------------------------------------------
__int16 __cdecl sub_26FF0(int a1)
{
  __int16 v1; // ax
  __int16 v2; // si
  __int16 v3; // di
  int v4; // eax
  signed int v5; // eax
  signed int v6; // esi
  __int16 v7; // si
  int v9; // [esp+0h] [ebp-10h] BYREF
  __int16 v10; // [esp+4h] [ebp-Ch]
  _WORD *v11; // [esp+8h] [ebp-8h]
  int v12; // [esp+Ch] [ebp-4h]

  v1 = *(_WORD *)(a1 + 130);
  if ( v1 > *(__int16 *)(a1 + 134) )
    *(_WORD *)(a1 + 130) = v1 - 2;
  v2 = *(_WORD *)(a1 + 88);
  v3 = *(_WORD *)(a1 + 84);
  sub_49EA0((_WORD *)a1, *(char *)(a1 + 70) << 8, v2);
  sub_1B8C0(a1);
  if ( (*(_BYTE *)(a1 + 62) & 0xF) == 0 )
    sub_27120(a1);
  v11 = (_WORD *)a1;
  v12 = 0;
  sub_49EA0((_WORD *)a1, v3, v2);
  while ( v11 != (_WORD *)dword_EA3E4[0] )
  {
    v4 = sub_10C40(v11 + 38);
    if ( (__int16)v4 > (__int16)v12 )
    {
      v12 = v4;
      v9 = *((_DWORD *)v11 + 19);
      v10 = v11[40];
    }
    v11 = (_WORD *)dword_EA3E4[(unsigned __int16)v11[26]];
  }
  v12 += 384;
  LOWORD(v5) = *(_WORD *)(a1 + 80);
  if ( (__int16)v5 >= (__int16)v12 )
  {
    v7 = *(_WORD *)(a1 + 36);
    if ( v7 )
    {
      LOWORD(v5) = v7 - 1;
      *(_WORD *)(a1 + 36) = v7 - 1;
    }
    else
    {
      *(_WORD *)(a1 + 80) = v5 - 2;
    }
  }
  else
  {
    v6 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 16);
    v5 = sub_1B7A0((__int16 *)&v9);
    if ( v5 > v6 )
      ++*(_BYTE *)(a1 + 81);
    else
      *(_WORD *)(a1 + 80) += 64;
    *(_WORD *)(a1 + 36) = 64;
  }
  return v5;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00027120) --------------------------------------------------------
int __cdecl sub_27120(int a1)
{
  int v1; // edi
  int v2; // esi
  unsigned int v3; // ecx
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int16 v8; // ax

  v1 = 2 * *(__int16 *)(a1 + 88) + 32;
  v2 = 2 * *(__int16 *)(a1 + 84);
  v3 = *(_DWORD *)(4 * *(char *)(a1 + 64) + dword_D41A4 + 38403);
  if ( v3 <= dword_EA3E4[0] )
    return 0;
  do
  {
    if ( *(_WORD *)(v3 + 26) != *(_WORD *)(a1 + 26) )
    {
      v5 = *(__int16 *)(a1 + 76) - *(__int16 *)(v3 + 76);
      if ( (int)((HIDWORD(v5) ^ v5) - HIDWORD(v5)) < v2 )
      {
        v6 = *(__int16 *)(a1 + 78) - *(__int16 *)(v3 + 78);
        if ( (int)((HIDWORD(v6) ^ v6) - HIDWORD(v6)) < v2 )
        {
          v7 = *(__int16 *)(a1 + 80) - *(__int16 *)(v3 + 80);
          if ( (int)((HIDWORD(v7) ^ v7) - HIDWORD(v7)) < v1 )
          {
            v8 = *(_WORD *)(a1 + 80);
            if ( v8 >= *(__int16 *)(v3 + 80) )
              *(_WORD *)(a1 + 80) = v8 + 64;
          }
        }
      }
    }
    v3 = *(_DWORD *)v3;
  }
  while ( v3 > dword_EA3E4[0] );
  return 0;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000271D0) --------------------------------------------------------
int __cdecl sub_271D0(int a1)
{
  int result; // eax
  int v2; // eax
  __int16 v3; // si
  unsigned __int16 v4; // ax
  int v5; // ebx
  unsigned __int16 v6; // cx

  result = a1;
  if ( *(_WORD *)(a1 + 150) )
  {
    v2 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    v3 = *(_WORD *)(v2 + 42);
    v4 = (v3 + sub_273C0(*(unsigned __int8 *)(v2 + 92), *(_WORD *)(v2 + 54), *(char *)(a1 + 70), *(char *)(v2 + 70))) & 0x7FF;
    *(_WORD *)(a1 + 44) = v4;
    v5 = dword_EA3E4[*(unsigned __int16 *)(a1 + 50)];
    if ( v5 )
    {
      v6 = *(_WORD *)(v5 + 50);
      if ( v6 )
        v5 = dword_EA3E4[v6];
    }
    *(_DWORD *)&word_EB398 = *(_DWORD *)(v5 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(v5 + 80);
    sub_57FA0(&word_EB398, v4, 0, *(_WORD *)(a1 + 84) + *(_WORD *)(v5 + 84));
    word_EB39C = *(_WORD *)(v5 + 84) - *(_WORD *)(a1 + 84) + *(_WORD *)(v5 + 80);
    return sub_57CF0(word_EB39C, a1, (int)&word_EB398);
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (000272C0) --------------------------------------------------------
char __cdecl sub_272C0(int a1)
{
  __int16 v1; // ax
  unsigned __int8 v2; // dl
  unsigned __int8 v3; // ch
  char v4; // ah
  char v5; // dl
  __int16 v6; // ax
  int v7; // edx
  __int16 v9; // [esp+0h] [ebp-4h]

  if ( *(char *)(a1 + 70) >= 11 )
  {
    v1 = sub_27430(*(unsigned __int8 *)(a1 + 92));
    v2 = *(_BYTE *)(a1 + 92);
    v9 = v1;
    if ( v2 && v2 < 0x10u )
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 48);
    if ( (*(_BYTE *)(a1 + 54) & 1) != 0 )
    {
      v3 = v9 + *(_BYTE *)(a1 + 92);
      *(_BYTE *)(a1 + 92) = v3;
      if ( v3 > 0x64u )
      {
        v4 = *(_BYTE *)(a1 + 54);
        *(_BYTE *)(a1 + 92) = 100;
        *(_BYTE *)(a1 + 54) = v4 & 0xFE;
      }
    }
    else if ( *(unsigned __int8 *)(a1 + 92) > v9 )
    {
      *(_BYTE *)(a1 + 92) -= v9;
    }
    else
    {
      v5 = *(_BYTE *)(a1 + 54) | 1;
      *(_BYTE *)(a1 + 54) = v5;
      *(_BYTE *)(a1 + 92) = 0;
      *(_BYTE *)(a1 + 54) = v5 ^ 2;
    }
  }
  *(_WORD *)(a1 + 42) += *(_WORD *)(a1 + 44);
  LOBYTE(v6) = *(_BYTE *)(a1 + 62);
  *(_BYTE *)(a1 + 43) &= 7u;
  if ( (v6 & 3) == 0 )
  {
    v6 = abs16(*(_WORD *)(a1 + 44)) - 5;
    if ( v6 < 11 )
      v6 = 11;
    if ( *(__int16 *)(a1 + 44) <= 0 )
      v7 = -v6;
    else
      LOWORD(v7) = v6;
    *(_WORD *)(a1 + 44) = v7;
  }
  return v6;
}
// D41A0: using guessed type int dword_D41A0;

//----- (000273C0) --------------------------------------------------------
int __cdecl sub_273C0(__int16 a1, char a2, __int16 a3, __int16 a4)
{
  unsigned __int16 v4; // ax
  int result; // eax
  __int16 v6; // ax

  v4 = abs16(a3);
  result = ((15 - a4) * v4 + v4 * a1) & 0x7FF;
  if ( a3 >= 0 )
  {
    if ( (a2 & 2) != 0 )
      return result;
    v6 = 2048 - result;
  }
  else if ( (a2 & 2) != 0 )
  {
    v6 = 1024 - result;
  }
  else
  {
    v6 = result + 1024;
  }
  return v6 & 0x7FF;
}

//----- (00027430) --------------------------------------------------------
int __cdecl sub_27430(int a1)
{
  int v1; // eax

  HIWORD(v1) = HIWORD(a1);
  if ( (__int16)a1 >= 96 )
    return 2;
  if ( (__int16)a1 >= 87 )
    return 3;
  if ( (__int16)a1 >= 60 )
    return 4;
  LOBYTE(v1) = (__int16)a1 < 30;
  BYTE1(v1) = 0;
  return v1 + 5;
}

//----- (00027470) --------------------------------------------------------
int __cdecl sub_27470(int a1, __int16 a2)
{
  int result; // eax

  result = a1;
  if ( a2 )
  {
    while ( 1 )
    {
      result = dword_EA3E4[*(unsigned __int16 *)(result + 52)];
      if ( result == dword_EA3E4[0] )
        break;
      if ( *(char *)(result + 70) == a2 )
        return result;
    }
    return 0;
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000274C0) --------------------------------------------------------
int __cdecl sub_274C0(int a1, int a2, _WORD *a3, __int16 a4)
{
  int v4; // edx
  int v5; // eax

  qmemcpy((void *)a2, a3, 0xA8u);
  v4 = a2 - (dword_D41A0 + 28302);
  *(_WORD *)(a2 + 50) = ((int)a3 - dword_D41A0 - 28302) / 168;
  a3[26] = v4 / 168;
  *(_WORD *)(a2 + 52) = 0;
  *(_BYTE *)(a2 + 62) = abs16(a4) & 1;
  *(_BYTE *)(a2 + 12) &= ~4u;
  *(_BYTE *)(a2 + 70) = a4;
  v5 = (a1 - (dword_D41A0 + 28302)) / 168;
  *(_BYTE *)(a2 + 69) = -76;
  *(_WORD *)(a2 + 44) = 0;
  *(_WORD *)(a2 + 148) = 0;
  *(_DWORD *)(a2 + 144) = 0;
  *(_WORD *)(a2 + 150) = v5;
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57D70(a2, (int)&word_EB398);
  return sub_49A20(a2);
}
// D41A0: using guessed type int dword_D41A0;
// EB398: using guessed type __int16 word_EB398;

//----- (00027590) --------------------------------------------------------
int __usercall sub_27590@<eax>(int a1@<ebx>, int a2)
{
  __int16 v2; // di
  __int16 v3; // ax
  int result; // eax
  __int16 v5; // ax
  int v6; // ebx

  v2 = sub_369F0(a1, *(_WORD *)(a2 + 148));
  v3 = sub_278F0(v2, *(char *)(a2 + 70), 0);
  sub_49D50(a2, v3);
  for ( result = *(unsigned __int16 *)(a2 + 52); ; result = *(unsigned __int16 *)(v6 + 52) )
  {
    v6 = dword_EA3E4[result];
    if ( v6 == dword_EA3E4[0] )
      break;
    v5 = sub_278F0(v2, *(char *)(a2 + 70), *(char *)(v6 + 70));
    sub_49D50(v6, v5);
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00027610) --------------------------------------------------------
int __usercall sub_27610@<eax>(int a1@<ebx>, int a2)
{
  __int16 v2; // di
  __int16 v3; // ax
  int result; // eax
  __int16 v5; // ax
  int v6; // ebx

  v2 = sub_369F0(a1, *(_WORD *)(a2 + 148));
  v3 = 550 * (unsigned __int16)word_D9524[7 * (__int16)sub_278F0(v2, *(char *)(a2 + 70), 0)] / 1000;
  sub_49EA0((_WORD *)a2, v3, v3);
  for ( result = *(unsigned __int16 *)(a2 + 52); ; result = *(unsigned __int16 *)(v6 + 52) )
  {
    v6 = dword_EA3E4[result];
    if ( v6 == dword_EA3E4[0] )
      break;
    v5 = 550 * (unsigned __int16)word_D9524[7 * (__int16)sub_278F0(v2, *(char *)(a2 + 70), *(char *)(v6 + 70))] / 1000;
    sub_49EA0((_WORD *)v6, v5, v5);
  }
  return result;
}
// D9524: using guessed type __int16 word_D9524[];
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000276E0) --------------------------------------------------------
int __cdecl sub_276E0(int a1)
{
  int result; // eax
  int i; // ebx
  int v3; // ebx

  result = a1;
  for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v3 + 52) )
  {
    v3 = dword_EA3E4[i];
    if ( v3 == dword_EA3E4[0] )
      break;
    result = sub_271D0(v3);
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00027720) --------------------------------------------------------
void __cdecl sub_27720(int a1, __int16 a2)
{
  int i; // ebx
  __int16 v3; // di
  _WORD *v4; // edi
  __int64 v5; // rax
  int v6; // eax
  __int16 v7; // [esp-4h] [ebp-14h]
  int v8; // [esp+0h] [ebp-10h]
  int v9; // [esp+4h] [ebp-Ch]
  int v10; // [esp+8h] [ebp-8h]
  char v11; // [esp+Ch] [ebp-4h]

  LOBYTE(a2) = a2 | 1;
  v11 = 0;
  if ( a2 >= 1 && a2 <= 15 && *(char *)(a1 + 70) != a2 )
  {
    for ( i = a1; ; i = dword_EA3E4[*(unsigned __int16 *)(i + 52)] )
    {
      v3 = *(_WORD *)(i + 52);
      if ( !v3 )
        break;
    }
    if ( *(char *)(a1 + 70) >= a2 )
    {
      v5 = *(char *)(a1 + 70) - a2;
      v10 = ((int)v5 - HIDWORD(v5)) >> 1;
      while ( v3 < (__int16)v10 )
      {
        v6 = dword_EA3E4[*(unsigned __int16 *)(i + 50)];
        i = dword_EA3E4[*(unsigned __int16 *)(v6 + 50)];
        *(_WORD *)(i + 52) = 0;
        v8 = dword_EA3E4[*(unsigned __int16 *)(v6 + 52)];
        sub_57F10(v6);
        ++v3;
        sub_57F10(v8);
      }
    }
    else
    {
      v4 = (_WORD *)sub_4A050();
      if ( v4 )
      {
        v9 = sub_4A050();
        if ( v9 )
        {
          sub_274C0(a1, (int)v4, (_WORD *)i, abs8(*(_BYTE *)(i + 70)) + 1);
          v7 = -(__int16)(abs8(*(_BYTE *)(i + 70)) + 1);
          i = v9;
          sub_274C0(a1, v9, v4, v7);
        }
        else
        {
          sub_57F10((int)v4);
          v11 = 1;
        }
      }
      else
      {
        v11 = 1;
      }
    }
    if ( !v11 )
    {
      *(_BYTE *)(a1 + 70) = a2;
      sub_27590(i, a1);
      sub_27610(i, a1);
    }
  }
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00027880) --------------------------------------------------------
void __cdecl sub_27880(int a1)
{
  __int16 v1; // dx
  char v2; // ah
  int v3; // edx

  v1 = *(_WORD *)(a1 + 150);
  if ( v1 )
  {
    *(_WORD *)(a1 + 150) = v1 - 1;
  }
  else
  {
    v2 = *(_BYTE *)(a1 + 70);
    *(_WORD *)(a1 + 150) = 1024;
    if ( v2 <= 13 )
      sub_27720(a1, v2 + 2);
    v3 = *(_DWORD *)(a1 + 144);
    if ( v3 < 50000 )
      *(_DWORD *)(a1 + 144) = v3 + 1000;
  }
}

//----- (000278F0) --------------------------------------------------------
int __cdecl sub_278F0(int a1, __int16 a2, __int16 a3)
{
  int v3; // eax

  v3 = (__int16)abs16(a3);
  LOWORD(v3) = (unsigned __int8)byte_D400C[8 * (a2 >> 1) + (__int16)v3];
  return a1 + v3;
}

//----- (00027930) --------------------------------------------------------
void __cdecl sub_27930(int a1)
{
  sub_1D5D0(a1, 176);
}

//----- (00027950) --------------------------------------------------------
char __cdecl sub_27950(int a1)
{
  unsigned int i; // ecx
  __int64 v2; // rax
  __int64 v3; // rax
  int v4; // ecx
  __int16 v5; // cx
  unsigned __int8 v6; // cl
  int v7; // eax
  unsigned int v8; // eax
  int v9; // eax
  __int16 v10; // ax
  _WORD *v11; // edi
  char v13; // [esp-Ch] [ebp-10h]
  char v14; // [esp-8h] [ebp-Ch]
  int v15; // [esp-4h] [ebp-8h]

  sub_1B8C0(a1);
  for ( i = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) )
    {
      v2 = *(__int16 *)(a1 + 76) - *(__int16 *)(i + 76);
      if ( (int)((HIDWORD(v2) ^ v2) - HIDWORD(v2)) < *(__int16 *)(a1 + 84) )
      {
        v3 = *(__int16 *)(a1 + 78) - *(__int16 *)(i + 78);
        if ( (int)((HIDWORD(v3) ^ v3) - HIDWORD(v3)) < *(__int16 *)(a1 + 84) )
        {
          *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(i + 76), (_WORD *)(a1 + 76));
          break;
        }
      }
    }
  }
  v4 = *(__int16 *)(a1 + 80) - *(__int16 *)(a1 + 44);
  if ( (int)abs32(v4) >= 256 )
  {
    if ( v4 <= 0 )
      v5 = 32;
    else
      v5 = -32;
    *(_WORD *)(a1 + 80) += v5;
  }
  v6 = *(_BYTE *)(a1 + 70);
  if ( !v6 )
  {
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 134);
    v7 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v7 - 1;
    if ( v7 )
      return sub_28110(a1);
    goto LABEL_26;
  }
  if ( v6 <= 1u )
  {
    v8 = sub_28000(a1);
    if ( v8 )
    {
      v9 = (int)(v8 - (dword_D41A0 + 28302)) / 168;
      *(_WORD *)(a1 + 44) = 0x2000;
      *(_WORD *)(a1 + 150) = v9;
      sub_27FE0(a1, 184, 2, 0);
    }
    else
    {
      v10 = sub_10C40((__int16 *)(a1 + 76));
      HIBYTE(v10) += 7;
      *(_WORD *)(a1 + 44) = v10;
      sub_27FE0(a1, 184, 0, 80);
    }
    return sub_28110(a1);
  }
  if ( v6 != 2 )
    return sub_28110(a1);
  v7 = sub_28420(a1);
  if ( !v7 )
  {
LABEL_26:
    v15 = v7;
    v14 = 1;
    v13 = -72;
    goto LABEL_27;
  }
  if ( (*(_BYTE *)(a1 + 62) & 3) == 0 )
  {
    v11 = (_WORD *)(v7 + 76);
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v7 + 76));
    if ( (int)sub_58490((_WORD *)(a1 + 76), v11) < 768 )
    {
      v15 = 500;
      v14 = 0;
      v13 = -71;
LABEL_27:
      sub_27FE0(a1, v13, v14, v15);
    }
  }
  return sub_28110(a1);
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00027B20) --------------------------------------------------------
char __cdecl sub_27B20(int a1)
{
  char v1; // al
  int v2; // edx
  int v3; // esi
  __int16 v5; // dx
  char v6; // [esp+0h] [ebp-4h]

  v6 = 0;
  v1 = *(_BYTE *)(a1 + 70);
  if ( v1 )
  {
    if ( v1 == 1 )
    {
      v5 = *(_WORD *)(a1 + 80);
      if ( v5 >= 0x2000 )
      {
        sub_27FE0(a1, 184, 0, 80);
        return sub_28110(a1);
      }
      *(_WORD *)(a1 + 80) = v5 + 32;
    }
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 16);
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
    *(_DWORD *)(a1 + 16) = --v2;
    if ( v2 && (v3 = sub_28420(a1)) != 0 && !sub_28060(a1) )
    {
      if ( sub_28390((_WORD *)a1, v3) )
        sub_27FE0(a1, 187, 0, 0);
    }
    else
    {
      v6 = 1;
    }
    if ( v6 )
    {
      sub_27FE0(a1, 185, 1, 0);
      return sub_28110(a1);
    }
  }
  return sub_28110(a1);
}

//----- (00027C10) --------------------------------------------------------
char __cdecl sub_27C10(int a1)
{
  unsigned __int8 v1; // al
  int v2; // eax
  int v3; // eax
  int v4; // esi
  int v5; // edi
  int v6; // edx
  unsigned int v7; // eax
  char v9; // [esp+0h] [ebp-8h]
  char v10; // [esp+4h] [ebp-4h]

  v10 = 0;
  v9 = 0;
  sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 59);
  v1 = *(_BYTE *)(a1 + 70);
  if ( v1 )
  {
    if ( v1 > 1u )
    {
      if ( v1 == 3 )
      {
        *(_WORD *)(a1 + 150) = 0;
        v7 = sub_28000(a1);
        if ( v7
          && (*(_WORD *)(a1 + 150) = (int)(v7 - (dword_D41A0 + 28302)) / 168,
              (int)sub_58490((_WORD *)(a1 + 76), (_WORD *)(v7 + 76)) <= 3584) )
        {
          sub_27FE0(a1, 185, 0, 500);
        }
        else
        {
          v10 = 1;
        }
      }
      goto LABEL_23;
    }
  }
  else
  {
    v2 = sub_28420(a1);
    if ( !v2 || (*(_BYTE *)(v2 + 12) & 0x40) != 0 )
    {
      v9 = 1;
    }
    else
    {
      *(_WORD *)(a1 + 44) = 18;
      sub_27FE0(a1, 187, 1, 64);
    }
  }
  if ( *(_WORD *)(a1 + 150) )
  {
    v3 = sub_28420(a1);
    v4 = v3;
    v5 = v3;
    if ( v3 && (v6 = *(_DWORD *)(a1 + 16) - 1, (*(_DWORD *)(a1 + 16) = v6) != 0) )
    {
      *(_BYTE *)(v3 + 12) |= 0x40u;
      *(_WORD *)(v3 + 150) = (a1 - (dword_D41A0 + 28302)) / 168;
      *(_WORD *)(a1 + 44) += 10;
      if ( sub_106C0(a1, v3) || *(_WORD *)(v4 + 80) > *(_WORD *)(a1 + 80) )
      {
        *(_DWORD *)(a1 + 144) += *(_DWORD *)(v5 + 144);
        sub_57F10(v5);
        v9 = 1;
      }
    }
    else
    {
      v9 = 1;
    }
  }
  else
  {
    v10 = 1;
  }
  if ( v9 )
    sub_27FE0(a1, 187, 3, 0);
LABEL_23:
  if ( v10 )
    sub_27FE0(a1, 185, 1, 0);
  return sub_28110(a1);
}
// D41A0: using guessed type int dword_D41A0;

//----- (00027E00) --------------------------------------------------------
char __cdecl sub_27E00(int a1)
{
  unsigned int v1; // eax
  unsigned int v2; // esi
  unsigned int i; // ecx
  __int64 v4; // rax
  __int64 v5; // rax
  int v6; // eax
  unsigned int v7; // edi
  char result; // al
  char v9; // [esp+4h] [ebp-8h]

  v9 = 0;
  sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 59);
  *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
  sub_1B8C0(a1);
  v1 = sub_1ED30(a1, dword_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
  v2 = v1;
  if ( v1 <= dword_EA3E4[0] || *(int *)(v1 + 8) < 0 || (*(_BYTE *)(v1 + 13) & 4) != 0 )
  {
LABEL_15:
    v9 = 1;
    goto LABEL_16;
  }
  if ( (*(_BYTE *)(a1 + 62) & 3) == 0 )
  {
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
    for ( i = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) )
      {
        v4 = *(__int16 *)(a1 + 76) - *(__int16 *)(i + 76);
        if ( (int)((HIDWORD(v4) ^ v4) - HIDWORD(v4)) < *(__int16 *)(a1 + 84) )
        {
          v5 = *(__int16 *)(a1 + 78) - *(__int16 *)(i + 78);
          if ( (int)((HIDWORD(v5) ^ v5) - HIDWORD(v5)) < *(__int16 *)(a1 + 84) )
          {
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(i + 76), (_WORD *)(a1 + 76));
            break;
          }
        }
      }
    }
  }
  v6 = *(_DWORD *)(a1 + 160);
  if ( (*(__int16 *)(v6 + 26) & *(unsigned __int8 *)(a1 + 62)) == 0 )
  {
    v7 = *(__int16 *)(v6 + 28);
    if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v2 + 76)) < v7 )
    {
      sub_1D260(a1, v2);
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_16:
  result = sub_28110(a1);
  if ( v9 )
  {
    *(_WORD *)(a1 + 150) = 0;
    return sub_27FE0(a1, 187, 3, 0);
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00027FA0) --------------------------------------------------------
int __cdecl sub_27FA0(int a1)
{
  return sub_1C890(a1, 184);
}

//----- (00027FC0) --------------------------------------------------------
void __cdecl sub_27FC0(int a1)
{
  sub_1C930(a1);
}

//----- (00027FE0) --------------------------------------------------------
int __cdecl sub_27FE0(int a1, char a2, char a3, int a4)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = a2;
  *(_BYTE *)(a1 + 70) = a3;
  *(_DWORD *)(a1 + 16) = a4;
  return result;
}

//----- (00028000) --------------------------------------------------------
unsigned int __cdecl sub_28000(int a1)
{
  unsigned int v1; // edi
  unsigned int v2; // esi
  unsigned int v3; // ebx
  unsigned int v5; // eax

  v1 = -1;
  v2 = 0;
  v3 = *(_DWORD *)(dword_D41A4 + 38523);
  if ( v3 <= dword_EA3E4[0] )
    return 0;
  do
  {
    if ( *(_BYTE *)(v3 + 64) == 39 )
    {
      v5 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76));
      if ( v5 < v1 )
      {
        v2 = v3;
        v1 = v5;
      }
    }
    v3 = *(_DWORD *)v3;
  }
  while ( v3 > dword_EA3E4[0] );
  return v2;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00028060) --------------------------------------------------------
char __cdecl sub_28060(int a1)
{
  int v1; // esi
  unsigned int i; // ecx
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  __int16 v6; // ax
  char v8; // [esp+4h] [ebp-4h]

  v8 = 0;
  v1 = 2 * *(__int16 *)(a1 + 84);
  for ( i = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) )
    {
      v3 = *(__int16 *)(a1 + 76) - *(__int16 *)(i + 76);
      if ( (int)((HIDWORD(v3) ^ v3) - HIDWORD(v3)) < v1 )
      {
        v4 = *(__int16 *)(a1 + 78) - *(__int16 *)(i + 78);
        if ( (int)((HIDWORD(v4) ^ v4) - HIDWORD(v4)) < v1 )
        {
          v5 = *(__int16 *)(a1 + 80) - *(__int16 *)(i + 80);
          if ( (int)((HIDWORD(v5) ^ v5) - HIDWORD(v5)) < 2 * *(__int16 *)(a1 + 88) )
          {
            v6 = *(_WORD *)(a1 + 80);
            if ( v6 >= *(__int16 *)(i + 80) )
            {
              v8 = 1;
              *(_WORD *)(a1 + 80) = v6 + 16;
              return v8;
            }
          }
        }
      }
    }
  }
  return v8;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00028110) --------------------------------------------------------
char __cdecl sub_28110(int a1)
{
  int v1; // esi
  __int16 v2; // ax
  unsigned __int16 v3; // ax
  int v4; // eax
  int v5; // ecx
  char v6; // al
  unsigned int v7; // eax
  unsigned int v8; // edi
  unsigned int v9; // esi
  int v10; // eax
  char v11; // dh

  v1 = 0;
  if ( *(_BYTE *)(a1 + 57) )
  {
    if ( *(_WORD *)(a1 + 98) )
    {
      v2 = *(_WORD *)(a1 + 98);
      *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
      *(_WORD *)(a1 + 38) = v2;
      v3 = *(_WORD *)(a1 + 38);
      *(_WORD *)(a1 + 98) = 0;
      if ( *(_BYTE *)(dword_EA3E4[v3] + 63) == 3 )
      {
        v1 = 1;
        v4 = sub_28420(a1);
        v5 = v4;
        if ( v4
          && (*(_BYTE *)(v4 + 12) & 0x40) != 0
          && *(unsigned __int16 *)(v4 + 150) == (a1 - (dword_D41A0 + 28302)) / 168 )
        {
          v6 = *(_BYTE *)(v4 + 12);
          *(_WORD *)(v5 + 150) = 0;
          *(_BYTE *)(v5 + 12) = v6 & 0xBF;
        }
        *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
        sub_27FE0(a1, 186, 0, 0);
      }
    }
    else
    {
      *(_WORD *)(a1 + 38) = 0;
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    sub_27FE0(a1, 188, 0, 0);
  }
  if ( !v1 && (*(_BYTE *)(a1 + 62) & 0x1F) == 0 )
  {
    v7 = sub_282D0(a1);
    v8 = v7;
    if ( v7 )
    {
      v9 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
      if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v7 + 76)) < v9 )
      {
        v10 = sub_28420(a1);
        if ( v10
          && (*(_BYTE *)(v10 + 12) & 0x40) != 0
          && *(unsigned __int16 *)(v10 + 150) == (a1 - (dword_D41A0 + 28302)) / 168 )
        {
          v11 = *(_BYTE *)(v10 + 12);
          *(_WORD *)(v10 + 150) = 0;
          *(_BYTE *)(v10 + 12) = v11 & 0xBF;
        }
        *(_WORD *)(a1 + 150) = (int)(v8 - (dword_D41A0 + 28302)) / 168;
        sub_27FE0(a1, 186, 0, 0);
      }
    }
  }
  return 0;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000282D0) --------------------------------------------------------
unsigned int __cdecl sub_282D0(int a1)
{
  unsigned int v1; // esi
  unsigned int v2; // edi
  unsigned int i; // ebx
  unsigned __int8 v4; // al
  int v5; // eax
  int v6; // eax
  int v7; // eax
  unsigned int v8; // eax

  v1 = -1;
  v2 = 0;
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    v4 = *(_BYTE *)(i + 64);
    if ( v4 <= 1u )
    {
      v5 = *(_DWORD *)(i + 164);
    }
    else
    {
      if ( v4 != 3 )
        continue;
      if ( *(int *)(i + 144) <= 0 )
        continue;
      v6 = dword_EA3E4[*(__int16 *)(i + 26)];
      if ( !v6 )
        continue;
      v5 = *(_DWORD *)(v6 + 164);
    }
    v7 = dword_EA3E4[*(unsigned __int16 *)(v5 + 58)];
    if ( v7 )
    {
      if ( !sub_10750(i, v7) )
      {
        v8 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
        if ( v8 < v1 )
        {
          v1 = v8;
          v2 = i;
        }
      }
    }
  }
  return v2;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00028390) --------------------------------------------------------
char __cdecl sub_28390(_WORD *a1, int a2)
{
  __int64 v2; // rax
  char v4; // [esp+0h] [ebp-4h]

  v4 = 1;
  if ( (int)sub_58490(a1 + 38, (_WORD *)(a2 + 76)) > 128 )
  {
    v4 = 0;
    a1[16] = sub_581E0(a1 + 38, (_WORD *)(a2 + 76));
    sub_1B8C0((int)a1);
  }
  v2 = (__int16)a1[40] - (*(__int16 *)(a2 + 80) + 640);
  if ( (int)((HIDWORD(v2) ^ v2) - HIDWORD(v2)) > 64 )
  {
    v4 = 0;
    if ( (__int16)a1[40] - (*(__int16 *)(a2 + 80) + 640) <= 0 )
      a1[40] += 32;
    else
      a1[40] -= 32;
  }
  return v4;
}

//----- (00028420) --------------------------------------------------------
int __cdecl sub_28420(int a1)
{
  int result; // eax

  result = 0;
  if ( *(_WORD *)(a1 + 150) )
  {
    LOWORD(result) = *(_WORD *)(a1 + 150);
    result = dword_EA3E4[result];
    if ( result )
    {
      if ( *(int *)(result + 8) < 0
        || (*(_BYTE *)(result + 13) & 4) != 0
        || *(_BYTE *)(result + 63) != 10
        || *(_BYTE *)(result + 64) != 39 )
      {
        return 0;
      }
    }
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00028470) --------------------------------------------------------
void __cdecl sub_28470(int a1)
{
  sub_1D5D0(a1, 184);
}

//----- (00028490) --------------------------------------------------------
int __cdecl sub_28490(int a1)
{
  sub_1BD90(a1, 192);
  if ( *(_BYTE *)(a1 + 69) == 0xC0 )
  {
    if ( (*(_BYTE *)(a1 + 62) & 7) == 0 )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      if ( !(*(unsigned __int16 *)(a1 + 20) % 3u) )
        *(_BYTE *)(a1 + 69) = -63;
    }
    if ( *(_BYTE *)(a1 + 69) == 0xC0 )
      sub_28690(a1);
  }
  else
  {
    *(_BYTE *)(a1 + 69) = -58;
  }
  return sub_287B0(a1);
}

//----- (00028500) --------------------------------------------------------
int __cdecl sub_28500(int a1)
{
  sub_1BF90(a1, 192);
  if ( *(_BYTE *)(a1 + 69) == 0xC1 )
  {
    if ( (*(_BYTE *)(a1 + 62) & 7) == 0 )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      if ( !(*(unsigned __int16 *)(a1 + 20) % 3u) )
        *(_BYTE *)(a1 + 69) = -64;
    }
    if ( *(_BYTE *)(a1 + 69) == 0xC1 )
      sub_28690(a1);
  }
  else
  {
    *(_BYTE *)(a1 + 69) = -58;
  }
  return sub_287B0(a1);
}

//----- (00028570) --------------------------------------------------------
int __cdecl sub_28570(int a1)
{
  sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 7);
  if ( (unsigned __int16)sub_1C310(a1, 192, (unsigned __int16 (__cdecl *)(int, int))sub_1CF20) )
    *(_BYTE *)(a1 + 69) = -58;
  return sub_287B0(a1);
}
// D41A0: using guessed type int dword_D41A0;

//----- (000285D0) --------------------------------------------------------
int __cdecl sub_285D0(int a1)
{
  *(_BYTE *)(a1 + 69) = -63;
  return sub_1BD90(a1, 192);
}

//----- (000285F0) --------------------------------------------------------
int __cdecl sub_285F0(int a1)
{
  return sub_1C890(a1, 192);
}

//----- (00028610) --------------------------------------------------------
void __cdecl sub_28610(int a1)
{
  sub_1C930(a1);
}

//----- (00028630) --------------------------------------------------------
int __cdecl sub_28630(int a1)
{
  sub_1C980(a1, 192);
  sub_28690(a1);
  return sub_287B0(a1);
}

//----- (00028660) --------------------------------------------------------
int __cdecl sub_28660(int a1)
{
  sub_1D5D0(a1, 192);
  return sub_287B0(a1);
}

//----- (00028690) --------------------------------------------------------
void __cdecl sub_28690(int a1)
{
  int v1; // eax
  unsigned int v2; // esi
  int v3; // edi
  unsigned int v4; // edi
  __int16 v5; // ax
  unsigned int v6; // eax
  int v7; // eax
  unsigned int v8; // [esp+0h] [ebp-10h]
  int v9; // [esp+4h] [ebp-Ch]
  int v10; // [esp+8h] [ebp-8h]
  unsigned int v11; // [esp+Ch] [ebp-4h]

  if ( *(_BYTE *)(a1 + 57) && (*(_BYTE *)(a1 + 62) & 0xF) == 0 )
  {
    v1 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
    v11 = -1;
    v10 = 0;
    v2 = *(_DWORD *)(dword_D41A4 + 38519);
    v8 = v1 * v1;
    while ( v2 > dword_EA3E4[0] )
    {
      v3 = (__int16)(*(_WORD *)(v2 + 76) - *(_WORD *)(a1 + 76));
      v4 = (__int16)(*(_WORD *)(v2 + 78) - *(_WORD *)(a1 + 78)) * (__int16)(*(_WORD *)(v2 + 78) - *(_WORD *)(a1 + 78))
         + v3 * v3;
      if ( v4 <= v8 && (*(_BYTE *)(v2 + 12) & 0x20) == 0 )
      {
        v9 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 30);
        v5 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v2 + 76));
        if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v5) < v9 && v4 < v11 )
        {
          v10 = v2;
          v11 = v4;
        }
      }
      v2 = *(_DWORD *)v2;
    }
    if ( v10 )
    {
      v6 = sub_1ED30(a1, v10);
      if ( v6 > dword_EA3E4[0] && *(int *)(v6 + 8) >= 0 && (*(_BYTE *)(v6 + 13) & 4) == 0 )
      {
        v7 = (int)(v6 - (dword_D41A0 + 28302)) / 168;
        *(_BYTE *)(a1 + 69) = -62;
        *(_WORD *)(a1 + 150) = v7;
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000287B0) --------------------------------------------------------
int __cdecl sub_287B0(int a1)
{
  int result; // eax
  unsigned __int8 v2; // dl
  int v3; // edx
  __int16 v4; // dx

  result = a1;
  v2 = *(_BYTE *)(a1 + 69);
  if ( v2 < 0xC2u )
  {
    if ( v2 == 0xC0 )
    {
      v3 = 336;
      *(_WORD *)(a1 + 130) = 0;
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  if ( v2 <= 0xC2u )
  {
    v4 = *(_WORD *)(a1 + 132);
  }
  else
  {
    if ( v2 != 0xC6 )
    {
LABEL_9:
      v4 = *(_WORD *)(a1 + 134);
      goto LABEL_10;
    }
    v4 = 2 * *(_WORD *)(a1 + 134);
  }
LABEL_10:
  *(_WORD *)(a1 + 130) = v4;
  v3 = 335;
LABEL_11:
  if ( v3 != *(__int16 *)(a1 + 90) )
  {
    *(_WORD *)(a1 + 90) = v3;
    *(_BYTE *)(a1 + 92) = 0;
    *(_BYTE *)(a1 + 93) = byte_D8A2E[(unsigned __int8)byte_D9528[14 * v3]];
  }
  return result;
}

//----- (00028860) --------------------------------------------------------
__int16 __cdecl sub_28860(int a1)
{
  char v1; // dh
  int v2; // eax
  __int16 v3; // ax
  int i; // edx
  int v5; // ecx
  int v6; // edx
  __int16 v7; // si
  int v8; // eax
  int v9; // ecx
  int v10; // ecx
  __int16 v11; // ax
  char v12; // cl
  int v13; // eax
  __int16 v14; // ax
  unsigned int v15; // et2
  int v16; // eax
  unsigned __int16 v17; // di
  int v18; // esi
  unsigned __int16 v19; // dx
  int v20; // esi
  int v21; // ecx
  __int16 v22; // cx
  char v23; // ch
  char v25; // [esp+0h] [ebp-4h]

  v25 = 0;
  v1 = *(_BYTE *)(a1 + 70);
  v2 = 0;
  if ( v1 != 1 && v1 != 2 )
  {
    if ( *(_WORD *)(a1 + 98) )
    {
      *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
      v3 = *(_WORD *)(a1 + 98);
      *(_WORD *)(a1 + 98) = 0;
      *(_WORD *)(a1 + 38) = v3;
      v2 = 1;
    }
    else
    {
      *(_WORD *)(a1 + 38) = 0;
    }
    if ( *(_WORD *)(a1 + 52) )
    {
      for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
      {
        v6 = dword_EA3E4[i];
        if ( v6 == dword_EA3E4[0] )
          break;
        v5 = *(_DWORD *)(v6 + 8);
        if ( v5 < *(_DWORD *)(a1 + 8) )
        {
          *(_DWORD *)(a1 + 8) = v5;
          *(_WORD *)(a1 + 38) = *(_WORD *)(v6 + 38);
          v2 = 1;
          break;
        }
      }
    }
    if ( *(int *)(a1 + 8) < 0 )
    {
      *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
      v2 = 2;
    }
  }
  v7 = *(_WORD *)(a1 + 42) - 1;
  *(_WORD *)(a1 + 42) = v7;
  if ( !v7 )
    v2 = 2;
  if ( v2 == 2 )
  {
    *(_BYTE *)(a1 + 69) = -52;
  }
  else
  {
    switch ( *(_BYTE *)(a1 + 70) )
    {
      case 1:
        *(_DWORD *)(a1 + 16) = 52;
        *(_BYTE *)(a1 + 70) = 2;
        goto LABEL_20;
      case 2:
LABEL_20:
        v8 = *(_DWORD *)(a1 + 4);
        v9 = *(_DWORD *)(a1 + 16);
        *(_WORD *)(a1 + 98) = 0;
        v10 = v9 - 1;
        *(_DWORD *)(a1 + 8) = v8;
        *(_DWORD *)(a1 + 16) = v10;
        if ( v10 < 0 )
          goto LABEL_21;
        if ( v10 > 13 )
        {
          v11 = *(_WORD *)(a1 + 32);
          HIBYTE(v11) = (HIBYTE(v11) + 1) & 7;
          *(_WORD *)(a1 + 32) = v11;
        }
        break;
      case 3:
        v12 = 0;
        if ( *(_WORD *)(a1 + 36)
          && (v13 = dword_EA3E4[*(unsigned __int16 *)(a1 + 36)], *(_BYTE *)(v13 + 63) == 3)
          && *(_BYTE *)(v13 + 64) <= 1u )
        {
          if ( *(_WORD *)(*(_DWORD *)(v13 + 164) + 58) )
          {
            v14 = *(_WORD *)(a1 + 36);
            *(_BYTE *)(a1 + 70) = 5;
            *(_WORD *)(a1 + 150) = v14;
          }
          else
          {
            *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
            v15 = *(unsigned __int16 *)(a1 + 20) % 0x64u;
            *(_BYTE *)(a1 + 70) = 4;
            *(_DWORD *)(a1 + 16) = v15 + 100;
          }
        }
        else
        {
          v12 = 1;
        }
        if ( v12 )
        {
          *(_BYTE *)(a1 + 70) = 8;
          *(_DWORD *)(a1 + 16) = 100;
        }
        break;
      case 4:
        v16 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v16;
        if ( v16 < 0 )
          goto LABEL_34;
        break;
      case 5:
        v17 = *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 164) + 58);
        if ( v17 )
        {
          if ( (*(_BYTE *)(a1 + 62) & 7) == 0 )
          {
            v18 = dword_EA3E4[v17];
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v18 + 76));
            if ( sub_10750(a1, v18) )
              *(_BYTE *)(a1 + 70) = 6;
          }
        }
        else
        {
LABEL_34:
          *(_BYTE *)(a1 + 70) = 3;
        }
        break;
      case 6:
        *(_BYTE *)(a1 + 70) = 7;
        v25 = 1;
        goto LABEL_40;
      case 7:
LABEL_40:
        v19 = *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 164) + 58);
        if ( v19 )
        {
          v20 = dword_EA3E4[v19];
          if ( sub_10750(a1, v20) )
          {
            sub_11900(a1, v20, 0, 0x3Cu);
          }
          else
          {
            *(_BYTE *)(a1 + 70) = 5;
            v25 = 1;
          }
        }
        else
        {
LABEL_21:
          *(_BYTE *)(a1 + 70) = 3;
          v25 = 1;
        }
        break;
      case 8:
        v21 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v21;
        if ( v21 < 0 )
          *(_BYTE *)(a1 + 69) = -52;
        break;
      default:
        break;
    }
    if ( (*(_BYTE *)(a1 + 62) & 7) == 0 )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v22 = 2 * (*(unsigned __int16 *)(a1 + 20) % 0x9Du / 79i64);
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      *(_WORD *)(a1 + 32) += (v22 - 1) * (*(_WORD *)(a1 + 20) % 0x17Du);
      *(_BYTE *)(a1 + 33) &= 7u;
    }
    sub_1B8C0(a1);
    v2 = sub_104D0((__int16 *)(a1 + 76));
    if ( v2 == 1 )
    {
      if ( *(_WORD *)(a1 + 90) == 314 )
      {
        LOWORD(v2) = sub_10C40((__int16 *)(a1 + 76));
        if ( (__int16)v2 < *(__int16 *)(a1 + 80) )
          LOWORD(v2) = sub_49CD0((_WORD *)a1, 313);
      }
      else
      {
        LOWORD(v2) = sub_49CD0((_WORD *)a1, 314);
        *(_WORD *)(a1 + 132) = 35;
        v25 = 1;
      }
    }
    else if ( *(_WORD *)(a1 + 90) != 313 )
    {
      LOWORD(v2) = sub_49CD0((_WORD *)a1, 313);
      *(_WORD *)(a1 + 132) = 60;
      v25 = 1;
    }
    if ( v25 )
    {
      LOWORD(v2) = *(_WORD *)(a1 + 132);
      v23 = *(_BYTE *)(a1 + 70);
      *(_WORD *)(a1 + 130) = v2;
      if ( v23 == 2 )
        *(_WORD *)(a1 + 130) = v2 + 50;
    }
  }
  return v2;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00028C30) --------------------------------------------------------
int __cdecl sub_28C30(int a1)
{
  int result; // eax

  sub_1BF90(a1, 200);
  if ( *(int *)(a1 + 8) < 0 )
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (00028C60) --------------------------------------------------------
int __cdecl sub_28C60(int a1)
{
  int result; // eax

  sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 37);
  result = sub_1C310(a1, 200, (unsigned __int16 (__cdecl *)(int, int))sub_1CC20);
  if ( *(int *)(a1 + 8) < 0 )
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00028CC0) --------------------------------------------------------
int __cdecl sub_28CC0(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  v2 = *(_DWORD *)(a1 + 8);
  *(_BYTE *)(a1 + 69) = -55;
  if ( v2 < 0 )
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (00028CE0) --------------------------------------------------------
int __cdecl sub_28CE0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax
  __int16 v5; // ax
  int v6; // edx
  int v7; // eax
  int result; // eax
  int v9; // [esp+0h] [ebp-10h]
  int i; // [esp+4h] [ebp-Ch]
  int v11; // [esp+8h] [ebp-8h]
  int v12; // [esp+Ch] [ebp-4h]

  if ( *(_BYTE *)(a1 + 70) )
    return sub_1C890(a1, 200);
  if ( sub_4A810() <= 1 )
  {
    sub_36BA0(a1, 0);
  }
  else
  {
    v12 = *(_DWORD *)(a1 + 144);
    v9 = v12 / 3;
    for ( i = 0; i < 3; ++i )
    {
      v1 = sub_4A050();
      v2 = v1;
      v11 = v1;
      if ( v1 )
      {
        *(_BYTE *)(v1 + 69) = -56;
        *(_BYTE *)(v1 + 63) = 5;
        *(_BYTE *)(v1 + 64) = 25;
        *(_DWORD *)(v1 + 76) = *(_DWORD *)(a1 + 76);
        *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 80);
        *(_BYTE *)(v1 + 70) = 3;
        *(_WORD *)(v1 + 132) = 35;
        *(_WORD *)(v1 + 134) = 60;
        *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132) + 50;
        v3 = *(_WORD *)(v1 + 20);
        *(_DWORD *)(v1 + 144) = v9;
        *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
        v4 = *(_WORD *)(v1 + 20);
        *(_DWORD *)(v2 + 4) = 80;
        *(_WORD *)(v2 + 42) = 15000;
        v5 = (v4 & 0x7FF) - 1;
        *(_WORD *)(v2 + 32) = v5;
        *(_WORD *)(v2 + 28) = v5;
        *(_BYTE *)(v2 + 56) = 1;
        v6 = *(char *)(a1 + 64) + dword_D41A0;
        LOBYTE(v5) = *(_BYTE *)(v6 + 16);
        *(_BYTE *)(v6 + 16) = v5 + 1;
        *(_BYTE *)(v2 + 62) = v5;
        *(_DWORD *)(v2 + 160) = &unk_D8874;
        *(_BYTE *)(v2 + 57) = 64;
        v12 -= v9;
        *(_BYTE *)(v2 + 65) = 3;
        sub_57D70(v2, a1 + 76);
        sub_49A20(v2);
        sub_49CD0((_WORD *)v2, 314);
        sub_49EA0((_WORD *)v2, 32, 32);
        *(_BYTE *)(v2 + 70) = 1;
        *(_WORD *)(v2 + 36) = *(_WORD *)(a1 + 38);
      }
    }
    if ( v11 )
      *(_DWORD *)(v11 + 144) += v12;
  }
  v7 = sub_4A190(a1 + 76, 10, 1);
  if ( v7 )
    *(_WORD *)(v7 + 26) = *(_WORD *)(a1 + 26);
  *(_BYTE *)(a1 + 69) = -51;
  result = dword_D41A0;
  *(_DWORD *)((char *)&loc_364D1 + dword_D41A0 + 1) += 3;
  return result;
}
// 28E47: variable 'v11' is possibly undefined
// D41A0: using guessed type int dword_D41A0;

//----- (00028EC0) --------------------------------------------------------
void __cdecl sub_28EC0(int a1)
{
  int v1; // edx
  int v2; // edx

  if ( *(_BYTE *)(a1 + 70) )
  {
    v2 = 2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0;
    if ( *(_WORD *)(a1 + 36) == *(_WORD *)(v2 + 11240) )
      ++*(_DWORD *)(v2 + 12601);
    sub_1C930(a1);
  }
  else
  {
    v1 = 2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0;
    if ( *(_WORD *)(a1 + 36) == *(_WORD *)(v1 + 11240) )
      ++*(_DWORD *)(v1 + 12601);
    *(_DWORD *)(a1 + 8) = -1;
    sub_57F10(a1);
  }
}
// D41A0: using guessed type int dword_D41A0;

//----- (00028F50) --------------------------------------------------------
void __cdecl sub_28F50(int a1)
{
  if ( *(_BYTE *)(a1 + 70) )
  {
    sub_12470(a1, 200);
    *(_BYTE *)(a1 + 70) = 3;
  }
  else
  {
    sub_1D5D0(a1, 200);
  }
}

//----- (00028F90) --------------------------------------------------------
int __cdecl sub_28F90(int a1)
{
  sub_1BD90(a1, 208);
  return sub_293B0(a1);
}

//----- (00028FC0) --------------------------------------------------------
int __cdecl sub_28FC0(int a1)
{
  sub_1BF90(a1, 208);
  return sub_293B0(a1);
}

//----- (00028FF0) --------------------------------------------------------
int __cdecl sub_28FF0(int a1)
{
  unsigned int v1; // esi
  __int16 v2; // ax
  int i; // ecx
  int v4; // eax
  int v5; // ecx
  unsigned int v6; // esi
  unsigned int j; // ecx
  __int64 v8; // rax
  __int64 v9; // rax
  int v10; // edx
  signed int v11; // eax
  int v12; // eax
  unsigned int v13; // edx
  int v14; // edx
  int v15; // eax
  __int16 v16; // dx
  int v17; // edx
  int v18; // eax
  __int16 v19; // cx

  if ( (*(_BYTE *)(a1 + 62) & 0x1F) == 0 )
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 62);
  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    v1 = 1;
    *(_WORD *)(a1 + 38) = v2;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        v1 = 1;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    v1 = 2;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
  }
  if ( v1 )
  {
    if ( v1 > 1 )
    {
      *(_BYTE *)(a1 + 69) = -44;
      return sub_293D0(a1);
    }
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
  }
  sub_1B8C0(a1);
  v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  if ( v6 <= dword_EA3E4[0]
    || *(_BYTE *)(v6 + 63) != 3
    || *(_BYTE *)(v6 + 64) > 1u
    || *(int *)(v6 + 8) < 0
    || (*(_BYTE *)(v6 + 13) & 4) != 0 )
  {
    goto LABEL_47;
  }
  if ( (*(_BYTE *)(a1 + 62) & 3) == 0 )
  {
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v6 + 76));
    for ( j = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
    {
      if ( *(_WORD *)(j + 26) != *(_WORD *)(a1 + 26) )
      {
        v8 = *(__int16 *)(a1 + 76) - *(__int16 *)(j + 76);
        if ( (int)((HIDWORD(v8) ^ v8) - HIDWORD(v8)) < *(__int16 *)(a1 + 84) )
        {
          v9 = *(__int16 *)(a1 + 78) - *(__int16 *)(j + 78);
          if ( (int)((HIDWORD(v9) ^ v9) - HIDWORD(v9)) < *(__int16 *)(a1 + 84) )
          {
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(j + 76), (_WORD *)(a1 + 76));
            break;
          }
        }
      }
    }
  }
  v10 = *(_DWORD *)(v6 + 144) - (*(_DWORD *)(v6 + 136) + 14);
  *(_DWORD *)(v6 + 144) = v10;
  if ( v10 < 0 )
    *(_DWORD *)(v6 + 144) = 0;
  if ( (*(_BYTE *)(a1 + 62) & 3) == 0 )
  {
    v11 = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v6 + 76));
    if ( v11 <= *(__int16 *)(*(_DWORD *)(a1 + 160) + 28) )
    {
      if ( v11 < 2048 && !*(_BYTE *)(v6 + 64) )
      {
        v12 = dword_D41A0;
        *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
        v13 = *(_DWORD *)(v12 + 8) % 0x3Fu;
        if ( v13 >= 4 )
        {
          if ( v13 <= 4 )
          {
            v17 = *(_DWORD *)(v6 + 164);
            v18 = *(__int16 *)(v17 + 1107);
            if ( v18 != -1 )
            {
              v19 = *(_WORD *)(v17 + 2 * v18 + 819);
              if ( v19 )
                sub_69300(dword_EA3E4[v19], a1);
            }
          }
          else if ( v13 == 5 )
          {
            v14 = *(_DWORD *)(v6 + 164);
            v15 = *(__int16 *)(v14 + 1105);
            if ( v15 != -1 )
            {
              v16 = *(_WORD *)(v14 + 2 * v15 + 819);
              if ( v16 )
                sub_69300(dword_EA3E4[v16], a1);
            }
          }
        }
      }
      return sub_293D0(a1);
    }
LABEL_47:
    *(_BYTE *)(a1 + 69) = -47;
  }
  return sub_293D0(a1);
}
// 290B3: conditional instruction was optimized away because esi.4==2
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00029300) --------------------------------------------------------
int __cdecl sub_29300(int a1)
{
  sub_1C560(a1, 0xD0u);
  return sub_293B0(a1);
}

//----- (00029330) --------------------------------------------------------
int __cdecl sub_29330(int a1)
{
  return sub_1C890(a1, 208);
}

//----- (00029350) --------------------------------------------------------
void __cdecl sub_29350(int a1)
{
  sub_1C930(a1);
}

//----- (00029380) --------------------------------------------------------
int __cdecl sub_29380(int a1)
{
  sub_1D5D0(a1, 208);
  return sub_293B0(a1);
}

//----- (000293B0) --------------------------------------------------------
int __cdecl sub_293B0(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_BYTE *)(a1 + 69) == 0xD2 )
  {
    *(_BYTE *)(a1 + 14) &= ~0x80u;
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
  }
  return result;
}

//----- (000293D0) --------------------------------------------------------
int __cdecl sub_293D0(int a1)
{
  int result; // eax
  char v2; // dh

  result = a1;
  if ( *(_BYTE *)(a1 + 69) != 0xD2 )
  {
    v2 = *(_BYTE *)(a1 + 14);
    *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 14) = v2 | 0x80;
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 134);
  }
  return result;
}

//----- (00029400) --------------------------------------------------------
unsigned __int16 __cdecl sub_29400(int a1)
{
  unsigned int v1; // eax
  unsigned int i; // eax
  __int16 v3; // cx
  __int16 v4; // ax
  int v5; // esi
  signed int v6; // eax
  unsigned int v8; // [esp+0h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 16);
  v8 = 0;
  *(_DWORD *)(a1 + 16) = v1 + 1;
  if ( v1 < 9 )
  {
    if ( v1 < 3 )
    {
      if ( !v1 )
      {
        sub_2AED0(a1, 337);
        *(_DWORD *)(a1 + 8) = &unk_F4240;
        *(_WORD *)(a1 + 150) = 0;
      }
      goto LABEL_25;
    }
    if ( v1 <= 3 )
    {
LABEL_15:
      v8 = 1;
      i = a1;
      goto LABEL_33;
    }
    if ( v1 != 6 )
    {
LABEL_25:
      if ( !v8 )
        goto LABEL_34;
      i = a1;
      goto LABEL_33;
    }
  }
  else
  {
    if ( v1 <= 9 )
    {
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v3 = (*(_WORD *)(a1 + 20) & 7) + 8;
      v4 = 9377 * *(_WORD *)(a1 + 20) + 9439;
      *(_WORD *)(a1 + 20) = v4;
      v5 = 0;
      LOWORD(v6) = (((v4 & 7) + 8) << 8) + word_EB39A;
      word_EB398 += v3 << 8;
      word_EB39A = v6;
      while ( v5 < 128 )
      {
        word_EB39C = sub_10C40(&word_EB398);
        if ( !sub_102D0(a1, &word_EB398, 1) && !sub_102D0(a1, &word_EB398, 4) )
        {
          v6 = sub_1B830(&word_EB398);
          if ( v6 < 32 )
            break;
        }
        ++v5;
        LOWORD(v6) = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, 768);
      }
      sub_57CF0(v6, a1, (int)&word_EB398);
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 22);
      goto LABEL_34;
    }
    if ( v1 >= 0xF )
    {
      if ( v1 > 0xF )
      {
        if ( v1 == 18 )
        {
          *(_BYTE *)(a1 + 69) = -38;
          v8 = 3;
          sub_2AED0(a1, 337);
          *(_WORD *)(a1 + 150) = 0;
          *(_BYTE *)(a1 + 70) = 1;
        }
        goto LABEL_25;
      }
      goto LABEL_15;
    }
    if ( v1 != 12 )
      goto LABEL_25;
  }
  v8 = 2;
LABEL_33:
  for ( i = a1; i > dword_EA3E4[0]; i = dword_EA3E4[*(unsigned __int16 *)(i + 52)] )
  {
    *(_WORD *)(i + 14) &= 0xFE7Fu;
    if ( v8 <= 1 )
    {
      *(_BYTE *)(i + 15) |= 1u;
    }
    else if ( v8 == 2 )
    {
      *(_BYTE *)(i + 14) |= 0x80u;
    }
  }
LABEL_34:
  *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
  return sub_29A90(a1);
}
// 295C9: conditional instruction was optimized away because %var_4.4==0
// 2961B: conditional instruction was optimized away because %var_4.4 is in (1..3)
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00029670) --------------------------------------------------------
unsigned __int16 __cdecl sub_29670(int a1)
{
  int v1; // eax
  __int16 v2; // ax
  char v3; // al

  v1 = sub_2A6B0(a1);
  if ( v1 )
  {
    if ( v1 != 1 )
      return sub_29A90(a1);
    *(_BYTE *)(a1 + 69) = -38;
    v2 = *(_WORD *)(a1 + 38);
    *(_DWORD *)(a1 + 8) = &unk_F4240;
    *(_WORD *)(a1 + 150) = v2;
  }
  v3 = sub_2AF10(a1, 1);
  if ( (unsigned __int8)v3 >= 3u )
  {
    if ( (unsigned __int8)v3 <= 3u )
      return sub_29A90(a1);
    if ( v3 == 4 )
    {
      *(_BYTE *)(a1 + 69) = -40;
      *(_DWORD *)(a1 + 16) = 0;
      return sub_29A90(a1);
    }
  }
  if ( (*(_BYTE *)(a1 + 62) & 0x3F) == 0 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    *(_WORD *)(a1 + 32) = (*(_WORD *)(a1 + 20) % 0x1C7u + *(_WORD *)(a1 + 32) - 227) & 0x7FF;
  }
  return sub_29A90(a1);
}

//----- (00029710) --------------------------------------------------------
unsigned __int16 __cdecl sub_29710(int a1)
{
  int v1; // eax
  char v2; // al
  unsigned int v3; // esi
  int v4; // edi
  __int16 v5; // ax
  unsigned int v6; // edi
  char v8; // [esp+0h] [ebp-4h]

  v8 = 0;
  v1 = sub_2A6B0(a1);
  if ( v1 )
  {
    if ( v1 != 1 )
      goto LABEL_19;
    *(_DWORD *)(a1 + 8) = &unk_F4240;
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
  }
  v2 = sub_2AF10(a1, *(_BYTE *)(a1 + 70) == 0);
  if ( v2 == 4 )
  {
    *(_BYTE *)(a1 + 69) = -40;
    *(_DWORD *)(a1 + 16) = 0;
  }
  else
  {
    v3 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v3 <= dword_EA3E4[0] || *(int *)(v3 + 8) < 0 || (*(_BYTE *)(v3 + 13) & 4) != 0 )
      goto LABEL_17;
    if ( (*(_BYTE *)(a1 + 62) & 3) == 0 && v2 != 3 && !*(_BYTE *)(a1 + 70) )
      *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76));
    if ( (*(_BYTE *)(a1 + 62) & 0x1F) == 0 )
    {
      v4 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 30);
      v5 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76));
      if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v5) <= v4 )
      {
        *(_BYTE *)(a1 + 70) = 1;
        sub_2AED0(a1, 337);
      }
      else
      {
        *(_BYTE *)(a1 + 70) = 0;
        sub_2AED0(a1, 315);
      }
      v6 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
      if ( sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76)) >= v6 )
LABEL_17:
        v8 = 1;
    }
  }
LABEL_19:
  if ( v8 )
  {
    *(_BYTE *)(a1 + 69) = -39;
    sub_2AED0(a1, 315);
    *(_WORD *)(a1 + 150) = 0;
    *(_BYTE *)(a1 + 70) = 0;
  }
  return sub_29A90(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00029890) --------------------------------------------------------
unsigned __int16 __cdecl sub_29890(int a1)
{
  *(_BYTE *)(a1 + 69) = -39;
  return sub_29670(a1);
}

//----- (000298B0) --------------------------------------------------------
int __cdecl sub_298B0(int a1)
{
  *(_DWORD *)(a1 + 8) = -1;
  return sub_1C890(a1, 216);
}

//----- (000298D0) --------------------------------------------------------
int __cdecl sub_298D0(unsigned int a1)
{
  int v1; // eax

  *(_DWORD *)(a1 + 8) = -1;
  sub_36BA0(a1, 1);
  if ( (*(_BYTE *)(a1 + 14) & 0x10) == 0 )
  {
    v1 = sub_4A190(a1 + 76, 10, 1);
    if ( v1 )
      *(_WORD *)(v1 + 26) = *(_WORD *)(a1 + 26);
  }
  return sub_2AE80(a1);
}

//----- (00029930) --------------------------------------------------------
unsigned __int16 __cdecl sub_29930(int a1)
{
  unsigned __int8 v1; // al
  char v2; // ah
  int v3; // eax
  unsigned int v4; // eax

  sub_1D5D0(a1, 216);
  v1 = *(_BYTE *)(a1 + 73);
  if ( v1 < 2u || v1 > 2u && (v1 < 6u || v1 > 9u) )
    sub_2AED0(a1, 315);
  else
    sub_2AED0(a1, 337);
  v2 = *(_BYTE *)(a1 + 69);
  *(_DWORD *)(a1 + 8) = &unk_F4240;
  if ( v2 == -38 )
  {
    v3 = *(unsigned __int16 *)(a1 + 52);
    *(_BYTE *)(a1 + 73) = 10;
    while ( 1 )
    {
      v4 = dword_EA3E4[v3];
      if ( v4 <= dword_EA3E4[0] )
        break;
      if ( *(_BYTE *)(v4 + 69) == 0xE9 && *(_BYTE *)(v4 + 70) == 1 )
      {
        *(_BYTE *)(v4 + 70) = 2;
        *(_WORD *)(v4 + 150) = *(_WORD *)(a1 + 150);
      }
      v3 = *(unsigned __int16 *)(v4 + 52);
    }
  }
  else if ( v2 == -40 )
  {
    *(_BYTE *)(a1 + 73) = 15;
  }
  return sub_29A90(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00029A90) --------------------------------------------------------
unsigned __int16 __cdecl sub_29A90(int a1)
{
  unsigned __int16 result; // ax
  unsigned int i; // ebx
  char *v3; // esi
  unsigned __int8 v4; // al
  __int16 v5; // di
  unsigned __int16 v6; // ax
  __int16 v7; // ax
  unsigned int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  unsigned __int8 v12; // dl
  _WORD *v13; // esi
  int v14; // eax
  int v15; // ecx
  int v16; // edi
  int v17; // edx
  int v18; // eax
  int v19; // ecx
  int v20; // edx
  int j; // eax
  char v22; // dh
  __int16 v23; // ax
  int v24; // esi
  int m; // eax
  int v26; // eax
  char v27; // cl
  __int16 v28; // ax
  __int16 v29; // ax
  int v30; // ecx
  int v31; // edx
  int k; // eax
  int v33; // esi
  int v34; // ecx
  unsigned int v35; // et2
  int v36; // [esp+0h] [ebp-10h]
  unsigned int v37; // [esp+4h] [ebp-Ch]
  char v38; // [esp+8h] [ebp-8h]
  char v39; // [esp+Ch] [ebp-4h]

  result = *(_WORD *)(a1 + 52);
  for ( i = dword_EA3E4[result]; i > dword_EA3E4[0]; i = dword_EA3E4[*(unsigned __int16 *)(i + 52)] )
  {
    if ( *(_BYTE *)(i + 69) == 0xE9 )
    {
      v39 = 0;
      v3 = (char *)&off_D404C + 22 * *(unsigned __int8 *)(i + 59);
      v4 = *(_BYTE *)(i + 70);
      ++*(_BYTE *)(i + 62);
      if ( v4 <= 5u )
      {
        *(_WORD *)(i + 20) = 9377 * *(_WORD *)(i + 20) + 9439;
        *(_BYTE *)(i + 67) = *(_WORD *)(i + 20) % 0x14u;
        sub_2A5B0(a1, i, 672);
        sub_2A660(a1, i);
        if ( *(_BYTE *)(i + 70) == 1 )
        {
          *(_WORD *)(i + 20) = 9377 * *(_WORD *)(i + 20) + 9439;
          v5 = *(_WORD *)(i + 38);
          v36 = *(_WORD *)(i + 20) & 7;
          if ( v5 )
          {
            if ( (*(_WORD *)(i + 20) & 7u) < 4 )
            {
              *(_WORD *)(i + 38) = 0;
              *(_BYTE *)(i + 70) = 2;
              v6 = *(_WORD *)(i + 54);
              *(_WORD *)(i + 150) = v5;
              v6 += 22;
              *(_WORD *)(i + 54) = v6;
              if ( v6 > 0x44u )
                *(_WORD *)(i + 54) = 68;
            }
          }
          else if ( (*(_WORD *)(i + 20) & 7u) < 4 && *(_WORD *)(a1 + 150) && (*(_BYTE *)(i + 62) & 7) == 0 )
          {
            v7 = *(_WORD *)(a1 + 150);
            *(_BYTE *)(i + 70) = 2;
            *(_WORD *)(i + 150) = v7;
          }
        }
      }
      switch ( *(_BYTE *)(i + 70) )
      {
        case 0:
          *(_WORD *)(i + 150) = 0;
          *(_BYTE *)(i + 70) = 1;
          *(_WORD *)(i + 44) = 0;
          *(_WORD *)(i + 54) = 0;
          *(_WORD *)(i + 132) = 16;
          goto LABEL_15;
        case 1:
LABEL_15:
          if ( *(_BYTE *)(a1 + 57) )
          {
            if ( (*(_BYTE *)(i + 62) & 7) == 0 )
            {
              if ( v36 )
              {
                if ( v36 > 4 )
                  *(_BYTE *)(i + 70) = 4;
              }
              else
              {
                v8 = sub_2A6F0(i);
                v37 = v8;
                if ( v8 )
                {
                  v9 = (int)(v8 - (dword_D41A0 + 28302)) / 168;
                  *(_BYTE *)(i + 70) = 2;
                  *(_WORD *)(i + 150) = v9;
                }
              }
            }
            if ( (*(_BYTE *)(i + 62) & 7) == 0 && (v36 & 1) == 0 )
            {
              v10 = *(_DWORD *)(i + 160);
              *(_WORD *)(i + 20) = 9377 * *(_WORD *)(i + 20) + 9439;
              *(_WORD *)(i + 28) = *(_WORD *)(a1 + 28)
                                 + *((_WORD *)v3 + 6)
                                 - *(_WORD *)(v10 + 30)
                                 + *(unsigned __int16 *)(i + 20) % (unsigned int)*(__int16 *)(v10 + 30);
            }
          }
          break;
        case 2:
          *(_BYTE *)(i + 70) = 3;
          *(_BYTE *)(i + 68) = 0;
          *(_WORD *)(i + 44) = 2;
          *(_WORD *)(i + 132) = 16;
          goto LABEL_26;
        case 3:
LABEL_26:
          v11 = sub_2A7B0(i);
          v37 = v11;
          if ( v11 )
          {
            v12 = *(_BYTE *)(i + 68);
            if ( v12 )
            {
              if ( v12 <= 1u )
              {
                if ( *(_WORD *)(i + 130) == 192 )
                {
                  *(_WORD *)(i + 44) = 3;
                  *(_BYTE *)(i + 68) = 3;
                  *(_DWORD *)(i + 16) = 4;
                  v39 = 1;
                }
              }
              else if ( v12 == 3 )
              {
                v39 = 2;
                v14 = *(_DWORD *)(i + 16) - 1;
                *(_DWORD *)(i + 16) = v14;
                if ( !v14 )
                {
                  *(_BYTE *)(i + 70) = 0;
                  *(_DWORD *)(i + 16) = 1;
                }
              }
            }
            else if ( !*(_WORD *)(i + 130) )
            {
              v13 = (_WORD *)(v11 + 76);
              *(_BYTE *)(i + 68) = 1;
              *(_WORD *)(i + 44) = 1;
              *(_WORD *)(i + 132) = 16;
              *(_WORD *)(i + 28) = sub_581E0((_WORD *)(i + 76), (_WORD *)(v11 + 76));
              *(_WORD *)(i + 30) = sub_58210((_WORD *)(i + 76), v13);
              *(_WORD *)(i + 32) = *(_WORD *)(i + 28) - *(_WORD *)(a1 + 28);
              *(_WORD *)(i + 34) = *(_WORD *)(i + 30) - *(_WORD *)(a1 + 30);
            }
          }
          else
          {
            *(_BYTE *)(i + 70) = 0;
          }
          break;
        case 4:
          *(_BYTE *)(i + 70) = 5;
          *(_BYTE *)(i + 68) = 0;
          *(_WORD *)(i + 44) = 2;
          *(_WORD *)(i + 132) = 16;
          goto LABEL_39;
        case 5:
LABEL_39:
          switch ( *(_BYTE *)(i + 68) )
          {
            case 0:
              if ( !*(_WORD *)(i + 130) )
              {
                *(_BYTE *)(i + 68) = 1;
                *(_WORD *)(i + 44) = 1;
                *(_WORD *)(i + 132) = -16;
                *(_WORD *)(i + 32) = *((_WORD *)v3 + 6);
                *(_WORD *)(i + 34) = *((_WORD *)v3 + 7);
                *(_WORD *)(i + 28) = *(_WORD *)(i + 32) + *(_WORD *)(a1 + 28);
                *(_WORD *)(i + 30) = *(_WORD *)(i + 34) + *(_WORD *)(a1 + 30);
              }
              break;
            case 1:
              if ( *(__int16 *)(i + 130) == -192 )
              {
                *(_BYTE *)(i + 68) = 2;
                *(_DWORD *)(i + 16) = 2;
              }
              break;
            case 2:
              v15 = *(_DWORD *)(i + 16) - 1;
              *(_DWORD *)(i + 16) = v15;
              if ( !v15 )
              {
                *(_WORD *)(i + 44) = 4;
                *(_BYTE *)(i + 68) = 6;
                *(_DWORD *)(i + 16) = 1;
              }
              break;
            case 5:
              v17 = *(_DWORD *)(i + 16) - 1;
              *(_DWORD *)(i + 16) = v17;
              if ( v17 <= 4 )
              {
                *(_BYTE *)(i + 70) = 0;
                *(_DWORD *)(i + 16) = 4;
              }
              break;
            case 6:
              sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 17);
              v16 = *(_DWORD *)(i + 16) + 1;
              *(_DWORD *)(i + 16) = v16;
              if ( v16 >= 4 )
                *(_BYTE *)(i + 68) = 5;
              break;
            default:
              goto LABEL_93;
          }
          break;
        case 6:
          *(_DWORD *)(i + 16) = 0;
          *(_WORD *)(i + 44) = 2;
          *(_BYTE *)(i + 70) = 7;
          *(_BYTE *)(i + 68) = 0;
          *(_WORD *)(i + 132) = 80;
          goto LABEL_51;
        case 7:
LABEL_51:
          v38 = 0;
          sub_2A5B0(a1, i, 672);
          switch ( *(_BYTE *)(i + 68) )
          {
            case 0:
              if ( !*(_WORD *)(i + 130) )
              {
                *(_BYTE *)(i + 68) = 1;
                *(_WORD *)(i + 44) = 1;
                *(_WORD *)(i + 32) = *((_WORD *)v3 + 6);
                *(_WORD *)(i + 34) = *((_WORD *)v3 + 7);
              }
              break;
            case 1:
              v38 = 1;
              if ( *(_WORD *)(i + 130) == 192 )
              {
                *(_BYTE *)(i + 68) = 7;
                *(_WORD *)(i + 44) = 5;
                *(_DWORD *)(i + 16) = 8;
              }
              break;
            case 7:
              v38 = 1;
              v18 = *(_DWORD *)(i + 16) - 1;
              *(_DWORD *)(i + 16) = v18;
              if ( !v18 )
              {
                *(_BYTE *)(i + 68) = 8;
                *(_WORD *)(i + 44) = 6;
                *(_WORD *)(i + 34) = 0;
                *(_BYTE *)(i + 67) = 0;
                *(_WORD *)(i + 54) = 0;
                *(_WORD *)(i + 132) = 12;
                *(_DWORD *)(i + 16) = 0;
              }
              break;
            case 8:
              v19 = *(_DWORD *)(i + 16);
              if ( v19 > 10 )
              {
                *(_BYTE *)(i + 70) = 8;
              }
              else
              {
                if ( v19 )
                {
                  v20 = dword_EA3E4[*(unsigned __int16 *)(i + 52)];
                  for ( j = 0; ; ++j )
                  {
                    v37 = v20;
                    if ( j >= 9 - *(_DWORD *)(i + 16) )
                      break;
                    v20 = dword_EA3E4[*(unsigned __int16 *)(v20 + 52)];
                  }
                }
                else
                {
                  v37 = i;
                }
                if ( v37 > dword_EA3E4[0] )
                  *(_BYTE *)(v37 + 12) = *(_BYTE *)(v37 + 12) & 0xF6 | 1;
                v22 = *(_BYTE *)(i + 67) + 1;
                ++*(_DWORD *)(i + 16);
                *(_BYTE *)(i + 67) = v22;
                *(_WORD *)(i + 54) += 28 * v22;
              }
              break;
            default:
              break;
          }
          if ( v38 )
          {
            if ( (*(_BYTE *)(i + 62) & 1) != 0 )
              v23 = -204;
            else
              v23 = 204;
            *(_WORD *)(i + 28) = *(_WORD *)(a1 + 28) + *((_WORD *)v3 + 6) + v23;
          }
          sub_2A340(a1, i);
          sub_2A940(a1, i);
          break;
        case 8:
          *(_BYTE *)(i + 70) = 9;
          *(_DWORD *)(i + 16) = 100;
          --*(_BYTE *)(a1 + 59);
          goto LABEL_82;
        case 9:
LABEL_82:
          v26 = *(_DWORD *)(i + 16) - 1;
          *(_DWORD *)(i + 16) = v26;
          if ( !v26 )
            *(_BYTE *)(i + 70) = 10;
          break;
        case 0xA:
          ++*(_BYTE *)(a1 + 59);
          *(_BYTE *)(i + 70) = 11;
          *(_WORD *)(i + 44) = 5;
          v27 = *(_BYTE *)(i + 12);
          *(_DWORD *)(i + 16) = 7;
          v27 &= 0xF6u;
          v28 = *(_WORD *)(i + 52);
          *(_BYTE *)(i + 12) = v27;
          *(_WORD *)(i + 150) = v28;
          *(_BYTE *)(i + 12) = v27 | 8;
          *(_WORD *)(i + 32) = *((_WORD *)v3 + 6);
          v29 = *((_WORD *)v3 + 7);
          *(_WORD *)(i + 130) = 156;
          *(_WORD *)(i + 34) = v29;
          goto LABEL_85;
        case 0xB:
LABEL_85:
          v30 = *(_DWORD *)(i + 16) - 1;
          *(_DWORD *)(i + 16) = v30;
          if ( v30 <= 0 )
          {
            *(_BYTE *)(i + 70) = 12;
            *(_DWORD *)(i + 16) = 0;
          }
          break;
        case 0xC:
          if ( *(int *)(i + 16) < 9 )
          {
            v31 = *(unsigned __int16 *)(i + 52);
            for ( k = 0; ; ++k )
            {
              v33 = dword_EA3E4[v31];
              if ( k >= *(_DWORD *)(i + 16) )
                break;
              v31 = *(unsigned __int16 *)(v33 + 52);
            }
            *(_BYTE *)(v33 + 12) &= ~1u;
            v34 = *(_DWORD *)(i + 16) + 1;
            *(_WORD *)(i + 150) = *(_WORD *)(v33 + 52);
            *(_DWORD *)(i + 16) = v34;
            if ( v34 >= 9 )
            {
              *(_WORD *)(i + 20) = 9377 * *(_WORD *)(i + 20) + 9439;
              v35 = *(unsigned __int16 *)(i + 20) % 0x398u;
              *(_WORD *)(i + 98) = 0;
              *(_BYTE *)(i + 70) = 0;
              *(_DWORD *)(i + 8) = v35 + 920;
            }
          }
          break;
        case 0xD:
          *(_BYTE *)(i + 70) = 14;
          *(_BYTE *)(i + 67) = 10;
          *(_DWORD *)(i + 16) = 10;
          goto LABEL_76;
        case 0xE:
LABEL_76:
          v24 = *(_DWORD *)(i + 16) - 1;
          *(_DWORD *)(i + 16) = v24;
          if ( !v24 )
            *(_BYTE *)(i + 70) = 15;
          break;
        case 0xF:
          v37 = i;
          *(_BYTE *)(i + 70) = 8;
          for ( m = 0; m < 10; ++m )
          {
            *(_BYTE *)(v37 + 12) = *(_BYTE *)(v37 + 12) & 0xF6 | 1;
            v37 = dword_EA3E4[*(unsigned __int16 *)(v37 + 52)];
          }
          break;
        default:
          break;
      }
LABEL_93:
      result = *(unsigned __int8 *)(i + 70);
      switch ( *(_BYTE *)(i + 70) )
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          sub_2A340(a1, i);
          sub_2A940(a1, i);
          sub_2AA90(i, a1, i);
          if ( v39 )
          {
            sub_2A7F0(i, v37, v39 == 1);
            sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 17);
          }
          goto LABEL_98;
        case 6:
        case 7:
          result = sub_2AA90(i, a1, i);
          break;
        case 0xB:
        case 0xC:
          sub_2A5B0(a1, i, 672);
          sub_2A940(a1, i);
          sub_2AA90(i, a1, i);
          v37 = dword_EA3E4[*(unsigned __int16 *)(i + 150)];
          *(_DWORD *)&word_EB398 = *(_DWORD *)(v37 + 76);
          *(&word_EB398 + 2) = *(_WORD *)(v37 + 80);
          sub_57CF0(v37, i, (int)&word_EB398);
LABEL_98:
          result = sub_2A9F0(a1, i);
          break;
        default:
          continue;
      }
    }
  }
  return result;
}
// 29C06: variable 'v36' is possibly undefined
// 2A23C: variable 'v37' is possibly undefined
// D404C: using guessed type void *off_D404C;
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (0002A340) --------------------------------------------------------
char __cdecl sub_2A340(int a1, int a2)
{
  int v2; // eax
  __int16 v3; // ax
  __int16 v4; // si
  __int16 v5; // di
  __int16 v6; // di
  __int16 v7; // ax
  __int16 v8; // dx
  __int16 v9; // di
  unsigned __int16 v10; // ax
  __int16 v11; // t2
  __int16 v12; // cx
  __int16 v13; // cx

  LOWORD(v2) = *(_WORD *)(a2 + 44);
  switch ( (__int16)v2 )
  {
    case 0:
      v3 = *(_WORD *)(a2 + 134);
      v4 = *(_WORD *)(a2 + 54);
      v5 = *(_WORD *)(a2 + 34);
      *(_WORD *)(a2 + 32) += v4 + v3 + 73;
      v6 = v4 + v3 + 62 + v5;
      v7 = *(_WORD *)(a2 + 130);
      *(_WORD *)(a2 + 34) = v6;
      if ( v7 != 192 )
      {
        v8 = *(_WORD *)(a2 + 132) + *(_WORD *)(a2 + 130);
        *(_WORD *)(a2 + 130) = v8;
        if ( abs16(v8) > 0xC0u )
        {
          if ( *(__int16 *)(a2 + 132) <= 0 )
            *(_WORD *)(a2 + 130) = -192;
          else
            *(_WORD *)(a2 + 130) = 192;
          *(_WORD *)(a2 + 132) = -*(_WORD *)(a2 + 132);
        }
      }
      if ( (*(_BYTE *)(a2 + 62) & 1) == 0 )
      {
        v9 = *(_WORD *)(a2 + 54);
        if ( v9 )
          *(_WORD *)(a2 + 54) = v9 - 1;
      }
      LOBYTE(v2) = *(_BYTE *)(a2 + 67);
      if ( (_BYTE)v2 )
      {
        if ( (_BYTE)v2 == 3 && *(_WORD *)(a2 + 130) == 192 )
        {
          *(_WORD *)(a2 + 132) = -16;
          LOWORD(v2) = *(_WORD *)(a2 + 132);
          *(_WORD *)(a2 + 130) += v2;
        }
      }
      else
      {
        *(_WORD *)(a2 + 20) = 9377 * *(_WORD *)(a2 + 20) + 9439;
        v10 = *(_WORD *)(a2 + 20);
        v11 = v10 % 0x1Cu;
        LOWORD(v2) = v10 / 0x1Cu;
        *(_WORD *)(a2 + 134) = v11;
      }
      break;
    case 1:
      v2 = abs16(*(_WORD *)(a2 + 130));
      if ( v2 < 192 )
      {
        LOWORD(v2) = *(_WORD *)(a2 + 132);
        *(_WORD *)(a2 + 130) += v2;
      }
      if ( *(__int16 *)(a2 + 132) <= 0 )
      {
        v2 = *(__int16 *)(a2 + 130);
        if ( v2 < -192 )
LABEL_23:
          *(_WORD *)(a2 + 130) = -192;
      }
      else if ( *(__int16 *)(a2 + 130) > 192 )
      {
LABEL_21:
        *(_WORD *)(a2 + 130) = 192;
      }
      break;
    case 2:
      v2 = abs16(*(_WORD *)(a2 + 130));
      if ( v2 < *(__int16 *)(a2 + 132) )
      {
        *(_WORD *)(a2 + 130) = 0;
      }
      else
      {
        v12 = *(_WORD *)(a2 + 130);
        LOWORD(v2) = *(_WORD *)(a2 + 132);
        if ( v12 <= 0 )
          *(_WORD *)(a2 + 130) = v2 + v12;
        else
          *(_WORD *)(a2 + 130) = v12 - v2;
      }
      break;
    case 3:
    case 4:
      v2 = *(_DWORD *)(a2 + 16) - 1;
      switch ( *(_DWORD *)(a2 + 16) )
      {
        case 1:
          goto LABEL_23;
        case 2:
          *(_WORD *)(a2 + 130) = -130;
          break;
        case 3:
          *(_WORD *)(a2 + 130) = -23;
          break;
        case 4:
          goto LABEL_21;
        default:
          return v2;
      }
      break;
    case 6:
      v13 = *(_WORD *)(a2 + 80) - *(_WORD *)(a2 + 54);
      *(_WORD *)(a2 + 130) -= *(_WORD *)(a2 + 132);
      *(_WORD *)(a2 + 80) = v13;
      LOWORD(v2) = sub_10C40((__int16 *)(a2 + 76));
      if ( *(__int16 *)(a2 + 80) < (__int16)v2 )
        *(_WORD *)(a2 + 80) = v2;
      break;
    default:
      return v2;
  }
  return v2;
}

//----- (0002A5B0) --------------------------------------------------------
int __cdecl sub_2A5B0(int a1, int a2, __int16 a3)
{
  __int16 *v3; // ebx
  __int16 v4; // si
  __int16 v5; // ax
  __int16 v6; // ax

  v3 = (__int16 *)&off_D404C + 11 * *(unsigned __int8 *)(a2 + 59);
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57FA0(&word_EB398, v3[1] + *(_WORD *)(a1 + 28), 0, *v3);
  v4 = v3[7];
  v5 = *(_WORD *)(a1 + 30);
  word_EB39C += v3[2];
  v6 = (unsigned __int16)sub_57FA0(&word_EB398, v3[6] + *(_WORD *)(a1 + 28), v4 + v5, a3);
  return sub_57CF0(v6, a2, (int)&word_EB398);
}
// D404C: using guessed type void *off_D404C;
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0002A660) --------------------------------------------------------
int __cdecl sub_2A660(int a1, int a2)
{
  int result; // eax
  __int16 v3; // dx
  int v4; // edx
  __int16 v5; // dx
  int v6; // ecx

  result = a2;
  v3 = *(_WORD *)(a2 + 98);
  if ( v3 )
  {
    *(_WORD *)(a1 + 98) = v3;
    v4 = *(_DWORD *)(a2 + 94);
    *(_DWORD *)(a1 + 94) = v4;
    if ( v4 > 76 )
      v4 = 76;
    *(_DWORD *)(a2 + 8) -= v4;
    v5 = *(_WORD *)(a2 + 98);
    *(_WORD *)(a2 + 98) = 0;
    v6 = *(_DWORD *)(a2 + 8);
    *(_WORD *)(a2 + 38) = v5;
    if ( v6 < 0 )
      *(_BYTE *)(a2 + 70) = 6;
  }
  return result;
}

//----- (0002A6B0) --------------------------------------------------------
int __cdecl sub_2A6B0(int a1)
{
  __int16 v1; // bx
  int v2; // edx
  char v3; // dl

  v1 = *(_WORD *)(a1 + 98);
  v2 = 0;
  if ( v1 )
  {
    v3 = *(_BYTE *)(a1 + 59);
    *(_WORD *)(a1 + 38) = v1;
    if ( v3 )
    {
      v2 = 1;
    }
    else
    {
      *(_BYTE *)(a1 + 69) = -36;
      v2 = 2;
      *(_WORD *)(a1 + 36) = v1;
    }
    *(_WORD *)(a1 + 98) = 0;
  }
  return v2;
}

//----- (0002A6F0) --------------------------------------------------------
unsigned int __cdecl sub_2A6F0(int a1)
{
  int v1; // esi
  unsigned int v2; // edi
  unsigned int v3; // ebx
  int v4; // esi
  __int16 v5; // ax
  int v7; // [esp+0h] [ebp-14h]
  int v8; // [esp+4h] [ebp-10h]
  int v9; // [esp+10h] [ebp-4h]

  v1 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
  v2 = 0;
  v9 = 0x10000000;
  v3 = *(_DWORD *)(dword_D41A4 + 38519);
  v8 = v1 * v1;
  while ( v3 > dword_EA3E4[0] )
  {
    v4 = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76));
    if ( v4 < v8 )
    {
      v7 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 30);
      v5 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v3 + 76));
      if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v5) < v7 && v4 < v9 )
      {
        v2 = v3;
        v9 = v4;
      }
    }
    v3 = *(_DWORD *)v3;
  }
  return v2;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002A7B0) --------------------------------------------------------
int __cdecl sub_2A7B0(int a1)
{
  unsigned __int16 v1; // bx
  int result; // eax
  int v3; // edx

  v1 = *(_WORD *)(a1 + 150);
  result = 0;
  if ( v1 )
  {
    v3 = dword_EA3E4[v1];
    if ( *(int *)(v3 + 8) >= 0 && (*(_BYTE *)(v3 + 13) & 4) == 0 )
      return dword_EA3E4[v1];
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002A7F0) --------------------------------------------------------
void __cdecl sub_2A7F0(int a1, int a2, char a3)
{
  int v3; // esi
  signed int v4; // edx
  unsigned int v5; // eax
  int v6; // eax
  __int16 v7; // [esp-4h] [ebp-8h]

  v3 = 0;
  if ( a3 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v4 = *(unsigned __int16 *)(a1 + 20) % 0xCu;
    *(_WORD *)(a1 + 20) += *(_WORD *)(dword_D41A4 + 30);
    *(_DWORD *)(a1 + 136) = (v4 > 7) + 1;
  }
  v5 = *(_DWORD *)(a1 + 136);
  if ( v5 )
  {
    if ( v5 <= 1 )
    {
      if ( !a3 )
        goto LABEL_13;
      v6 = sub_4A190(a1 + 76, 9, 0);
      v3 = v6;
      if ( !v6 )
        goto LABEL_13;
      *(_BYTE *)(v6 + 67) = 10;
      *(_BYTE *)(v6 + 68) = 0;
      v7 = 15;
    }
    else
    {
      if ( v5 != 2 )
        goto LABEL_13;
      v6 = sub_4A190(a1 + 76, 9, 9);
      v3 = v6;
      if ( !v6 )
        goto LABEL_13;
      *(_BYTE *)(v6 + 67) = 10;
      *(_BYTE *)(v6 + 68) = 23;
      v7 = 23;
    }
    *(_WORD *)(v6 + 42) = 850;
    sub_6E450(*(_WORD *)(a1 + 26), -1, v7);
  }
LABEL_13:
  if ( v3 )
  {
    *(_WORD *)(v3 + 26) = *(_WORD *)(a1 + 26);
    *(_WORD *)(v3 + 28) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
    *(_WORD *)(v3 + 30) = sub_58210((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
    *(_WORD *)(v3 + 80) += *(__int16 *)(a1 + 88) / 2;
    *(_WORD *)(v3 + 150) = *(_WORD *)(a1 + 150);
    *(_DWORD *)(v3 + 160) = &off_D89EA;
    *(_BYTE *)(v3 + 66) = *(_BYTE *)(a2 + 64);
    *(_BYTE *)(v3 + 65) = *(_BYTE *)(a2 + 63);
  }
}
// D41A4: using guessed type int dword_D41A4;
// D89EA: using guessed type void *off_D89EA;

//----- (0002A940) --------------------------------------------------------
int __cdecl sub_2A940(int a1, int a2)
{
  int result; // eax
  char *v3; // edx
  __int16 v4; // ax

  result = a1;
  if ( dword_E9BA8 )
  {
    v3 = (char *)&off_D404C + 22 * *(unsigned __int8 *)(a2 + 59);
    *(_WORD *)(a2 + 32) = *((_WORD *)v3 + 6);
    LOWORD(v3) = *((_WORD *)v3 + 7);
    *(_WORD *)(a2 + 130) = 192;
    *(_BYTE *)(a2 + 70) = 0;
    *(_WORD *)(a2 + 34) = (_WORD)v3;
    *(_BYTE *)(a1 + 13) |= 8u;
  }
  else
  {
    *(_BYTE *)(a1 + 13) &= ~8u;
  }
  if ( *(_WORD *)(a2 + 130) )
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a2 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a2 + 80);
    v4 = (unsigned __int16)sub_57FA0(
                             &word_EB398,
                             *(_WORD *)(a2 + 32) + *(_WORD *)(a1 + 28),
                             *(_WORD *)(a2 + 34) + *(_WORD *)(a1 + 30),
                             *(_WORD *)(a2 + 130));
    return sub_57CF0(v4, a2, (int)&word_EB398);
  }
  return result;
}
// D404C: using guessed type void *off_D404C;
// E9BA8: using guessed type int dword_E9BA8;
// EB398: using guessed type __int16 word_EB398;

//----- (0002A9F0) --------------------------------------------------------
int __cdecl sub_2A9F0(int a1, int a2)
{
  int v2; // eax
  _WORD *v3; // eax
  __int16 v4; // di
  __int16 v5; // dx
  __int16 v6; // ax
  __int16 v8; // [esp-4h] [ebp-4h]

  v2 = 22 * *(unsigned __int8 *)(a2 + 59);
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a2 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a2 + 80);
  v3 = (_WORD *)((char *)&off_D404C + v2);
  v4 = v3[7];
  v8 = v3[3];
  v5 = *(_WORD *)(a1 + 30);
  word_EB39C += v3[5];
  v6 = (unsigned __int16)sub_57FA0(&word_EB398, v3[6] + *(_WORD *)(a1 + 28), v4 + v5, v8);
  return sub_57CF0(v6, a2, (int)&word_EB398);
}
// D404C: using guessed type void *off_D404C;
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0002AA90) --------------------------------------------------------
unsigned __int16 __usercall sub_2AA90@<ax>(int a1@<ebx>, int a2, int a3)
{
  __int16 *v3; // ecx
  __int16 v4; // ax
  int v5; // edx
  int v6; // esi
  _WORD *v7; // edi
  int v8; // ebx
  __int16 v9; // ax
  unsigned __int16 result; // ax
  int v11; // [esp+0h] [ebp-20h] BYREF
  int v12; // [esp+4h] [ebp-1Ch]
  int v13; // [esp+8h] [ebp-18h] BYREF
  __int16 v14; // [esp+Ch] [ebp-14h]
  __int16 *v15; // [esp+10h] [ebp-10h]
  int v16; // [esp+14h] [ebp-Ch]
  int v17; // [esp+18h] [ebp-8h]
  int v18; // [esp+1Ch] [ebp-4h]

  v3 = (__int16 *)&off_D404C + 11 * *(unsigned __int8 *)(a3 + 59);
  v11 = *(_DWORD *)(a2 + 76);
  LOWORD(v12) = *(_WORD *)(a2 + 80);
  v4 = *v3;
  v15 = v3;
  sub_57FA0(&v11, v3[1] + *(_WORD *)(a2 + 28), 0, v4);
  LOWORD(v12) = v15[2] + v12;
  v13 = *(_DWORD *)(a3 + 76);
  v14 = *(_WORD *)(a3 + 80);
  v5 = 16 - (int)(sub_583F0(&v11, &v13) - 468) / 24;
  v17 = v5;
  if ( v5 <= 15 )
  {
    if ( v5 < 0 )
      v17 = 0;
  }
  else
  {
    v17 = 15;
  }
  LOWORD(v18) = sub_581E0(&v11, &v13);
  v18 = (unsigned __int16)v18;
  LOWORD(v16) = sub_58210(&v11, &v13);
  v16 = (unsigned __int16)v16;
  v6 = 0;
  v7 = (_WORD *)dword_EA3E4[*(unsigned __int16 *)(a3 + 52)];
  do
  {
    switch ( v6 )
    {
      case 0:
        LOWORD(a1) = 0;
        break;
      case 1:
      case 8:
        v8 = dword_D40BC[3 * v17];
        goto LABEL_12;
      case 2:
      case 7:
        v8 = dword_D40C0[3 * v17];
LABEL_12:
        a1 = -v8;
        break;
      case 3:
      case 6:
        a1 = dword_D40C0[3 * v17];
        break;
      case 4:
      case 5:
        a1 = dword_D40BC[3 * v17];
        break;
      default:
        break;
    }
    if ( v6 )
      sub_57FA0(&v11, v18, a1 + v16, 96);
    sub_57CF0((__int16)&v11, (int)v7, (int)&v11);
    if ( *(_BYTE *)(a3 + 70) == 7 && *(_BYTE *)(a3 + 68) == 8 )
    {
      v9 = sub_10C40(v7 + 38);
      if ( (__int16)v7[40] <= v9 )
        v7[40] = v9;
    }
    result = v7[26];
    ++v6;
    v7 = (_WORD *)dword_EA3E4[result];
  }
  while ( v6 < 9 );
  return result;
}
// D404C: using guessed type void *off_D404C;
// D40BC: using guessed type int dword_D40BC[];
// D40C0: using guessed type int dword_D40C0[];
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002AC50) --------------------------------------------------------
_WORD *__cdecl sub_2AC50(int a1)
{
  int v1; // ecx
  int v2; // edx
  int v3; // ecx
  char v4; // ah

  *(_WORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
  v1 = dword_D41A0;
  *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 32);
  *(_WORD *)(a1 + 132) = 64;
  *(_WORD *)(a1 + 134) = 0;
  *(_WORD *)(a1 + 130) = 30;
  *(_BYTE *)(a1 + 59) = 5;
  *(_DWORD *)(a1 + 8) = &unk_F4240;
  *(_DWORD *)(a1 + 4) = 36000;
  *(_DWORD *)(a1 + 144) = 20000;
  *(_DWORD *)(a1 + 16) = (a1 - (v1 + 28302)) / 168 % 100;
  v2 = *(char *)(a1 + 64);
  *(_WORD *)(a1 + 34) = 0;
  v3 = v2 + v1;
  *(_BYTE *)(a1 + 56) = 1;
  LOBYTE(v2) = *(_BYTE *)(v3 + 16);
  *(_BYTE *)(v3 + 16) = v2 + 1;
  *(_DWORD *)(a1 + 160) = &off_D88B8;
  *(_BYTE *)(a1 + 62) = v2;
  v4 = *(_BYTE *)(a1 + 15) | 0x80;
  LOBYTE(v2) = *(_BYTE *)(*(_DWORD *)(a1 + 160) + 26);
  *(_BYTE *)(a1 + 65) = 3;
  *(_BYTE *)(a1 + 15) = v4;
  *(_BYTE *)(a1 + 57) = v2 + 1;
  sub_49CD0((_WORD *)a1, 315);
  return sub_49EA0((_WORD *)a1, 1024, 1536);
}
// D41A0: using guessed type int dword_D41A0;
// D88B8: using guessed type void *off_D88B8;

//----- (0002AD40) --------------------------------------------------------
unsigned __int16 __cdecl sub_2AD40(int a1)
{
  unsigned __int16 result; // ax
  int v2; // esi
  unsigned int i; // ebx
  __int16 v4; // cx
  int v5; // eax

  result = *(_WORD *)(a1 + 52);
  v2 = 1;
  for ( i = dword_EA3E4[result]; i > dword_EA3E4[0]; i = dword_EA3E4[*(unsigned __int16 *)(i + 52)] )
  {
    if ( *(_BYTE *)(i + 69) == 0xE9 )
    {
      sub_49CD0((_WORD *)i, 316);
      *(_BYTE *)(i + 15) |= 0xA0u;
      *(_WORD *)(i + 20) = 9377 * *(_WORD *)(i + 20) + 9439;
      v4 = *(_WORD *)(i + 20);
      *(_WORD *)(i + 32) = v4 & 0x7FF;
      *(_WORD *)(i + 20) = 9377 * v4 + 9439;
      *(_WORD *)(i + 34) = *(_WORD *)(i + 20) & 0x7FF;
      *(_WORD *)(i + 132) = 16;
      *(_WORD *)(i + 130) = 16;
      *(_DWORD *)(i + 160) = &off_D8984;
      *(_BYTE *)(i + 56) = 1;
      v5 = 460 * v2 + 920;
      *(_DWORD *)(i + 8) = v5;
      *(_DWORD *)(i + 4) = v5;
      result = sub_2A940(a1, i);
    }
    ++v2;
  }
  return result;
}
// D8984: using guessed type void *off_D8984;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002AE30) --------------------------------------------------------
int __cdecl sub_2AE30(int a1)
{
  int result; // eax
  int i; // ebx
  unsigned int v3; // ebx

  result = a1;
  for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v3 + 52) )
  {
    v3 = dword_EA3E4[i];
    if ( v3 <= dword_EA3E4[0] )
      break;
    if ( *(_BYTE *)(v3 + 69) == 0xEA )
    {
      result = sub_49CD0((_WORD *)v3, 317);
      *(_BYTE *)(v3 + 15) |= 0xA0u;
    }
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002AE80) --------------------------------------------------------
int __cdecl sub_2AE80(unsigned int a1)
{
  int i; // ebx
  unsigned int v2; // ebx
  int result; // eax

  if ( a1 && a1 > dword_EA3E4[0] )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v2 + 52) )
    {
      v2 = dword_EA3E4[i];
      if ( v2 <= dword_EA3E4[0] )
        break;
      sub_57F10(v2);
    }
    return sub_57F10(a1);
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002AED0) --------------------------------------------------------
char __cdecl sub_2AED0(int a1, int a2)
{
  int v2; // eax

  v2 = *(__int16 *)(a1 + 90);
  if ( a2 != v2 )
  {
    *(_WORD *)(a1 + 90) = a2;
    *(_BYTE *)(a1 + 92) = 0;
    LOBYTE(v2) = byte_D8A2E[(unsigned __int8)byte_D9528[14 * a2]];
    *(_BYTE *)(a1 + 93) = v2;
  }
  return v2;
}

//----- (0002AF10) --------------------------------------------------------
char __cdecl sub_2AF10(int a1, char a2)
{
  char v2; // dh
  char v3; // al
  signed int v4; // eax
  __int16 v5; // ax
  int v7; // [esp+0h] [ebp-1Ch]
  unsigned __int16 v8; // [esp+4h] [ebp-18h]
  int v9; // [esp+8h] [ebp-14h]
  char v10; // [esp+Ch] [ebp-10h]
  char v11; // [esp+10h] [ebp-Ch]
  char v12; // [esp+14h] [ebp-8h]
  char v13; // [esp+18h] [ebp-4h]

  v2 = *(_BYTE *)(a1 + 14);
  v10 = 0;
  v12 = 0;
  if ( (v2 & 0x10) != 0 )
    *(_BYTE *)(a1 + 14) = v2 & 0xEF;
  else
    *(_BYTE *)(a1 + 12) &= ~1u;
  v3 = *(_BYTE *)(a1 + 13);
  if ( (v3 & 8) != 0 )
  {
    *(_BYTE *)(a1 + 13) = v3 & 0xF7;
    v13 = 4;
  }
  else
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    if ( a2 )
      sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
    word_EB39C = sub_10C40(&word_EB398);
    if ( a2 && *(__int16 *)(a1 + 76) >> 8 == word_EB398 >> 8 && (v4 = word_EB39A >> 8, *(__int16 *)(a1 + 78) >> 8 == v4) )
    {
      v10 = 1;
      v12 = 1;
      v13 = 1;
      *(_BYTE *)(a1 + 14) &= ~4u;
    }
    else if ( sub_102D0(a1, &word_EB398, 1) || sub_102D0(a1, &word_EB398, 4) || (v4 = sub_1B830(&word_EB398), v4 >= 32) )
    {
      LOWORD(v4) = *(_WORD *)(a1 + 28);
      if ( (_WORD)v4 == *(_WORD *)(a1 + 32) )
      {
        *(_BYTE *)(a1 + 14) |= 4u;
        v7 = 91;
        v9 = 1;
        v11 = 0;
        while ( v7 <= 1024 )
        {
          *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
          *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
          v8 = (*(_WORD *)(a1 + 28) + v9 * v7) & 0x7FF;
          sub_57FA0(&word_EB398, v8, 0, *(_WORD *)(a1 + 130));
          word_EB39C = sub_10C40(&word_EB398);
          if ( !sub_102D0(a1, &word_EB398, 1) && !sub_102D0(a1, &word_EB398, 4) )
          {
            v4 = sub_1B830(&word_EB398);
            if ( v4 < 32 )
            {
              v11 = 1;
              break;
            }
          }
          v9 = -v9;
          if ( v9 == 1 )
            v4 = 91;
          else
            v4 = 0;
          v7 += v4;
        }
        if ( v11 )
        {
          LOWORD(v4) = v8;
          *(_WORD *)(a1 + 32) = v8;
          v12 = 1;
          v13 = 3;
        }
        else
        {
          v13 = 4;
        }
      }
      else
      {
        LOBYTE(v4) = *(_BYTE *)(a1 + 14) | 4;
        *(_BYTE *)(a1 + 14) = v4;
        BYTE1(v4) = 3;
        v12 = 1;
        v13 = 3;
      }
    }
    else
    {
      BYTE1(v4) = 1;
      v10 = 1;
      v12 = 1;
      v13 = 2;
      *(_BYTE *)(a1 + 14) &= ~4u;
    }
    if ( a2 && v10 )
      sub_57CF0(v4, a1, (int)&word_EB398);
    if ( v12 )
    {
      v5 = *(_WORD *)(a1 + 28)
         + sub_58350(
             *(_WORD *)(a1 + 28),
             *(_WORD *)(a1 + 32),
             *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 4),
             *(_WORD *)(*(_DWORD *)(a1 + 160) + 2));
      HIBYTE(v5) &= 7u;
      *(_WORD *)(a1 + 28) = v5;
    }
    *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
  }
  if ( v13 == 4 )
  {
    *(_BYTE *)(a1 + 69) = -40;
    *(_DWORD *)(a1 + 16) = 0;
  }
  return v13;
}
// 2B126: variable 'v8' is possibly undefined
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0002B1D0) --------------------------------------------------------
int __cdecl sub_2B1D0(int a1)
{
  int result; // eax

  result = sub_1BD90(a1, 224);
  BYTE1(result) = *(_BYTE *)(a1 + 69);
  if ( BYTE1(result) == 0xE2 )
    return sub_2B840(a1);
  return result;
}

//----- (0002B200) --------------------------------------------------------
void __cdecl sub_2B200(int a1)
{
  sub_1BF90(a1, 224);
  if ( *(_BYTE *)(a1 + 69) == 0xE2 )
    sub_2B840(a1);
}

//----- (0002B260) --------------------------------------------------------
char __cdecl sub_2B260(int a1)
{
  int v1; // eax
  __int16 v2; // dx
  unsigned __int16 *v3; // edx
  int v4; // edi
  unsigned int v5; // ecx
  __int64 v6; // rax
  __int64 v7; // rax
  int v8; // edx
  __int16 v9; // ax
  char v10; // dl
  unsigned __int16 v11; // di
  char v12; // al
  unsigned __int16 *v13; // edx
  int v14; // esi
  char v15; // al
  unsigned int v16; // ecx
  __int64 v17; // rax
  __int64 v18; // rax
  char v19; // cl
  __int16 v20; // ax
  char v21; // al
  unsigned __int16 v22; // cx
  unsigned __int16 *v23; // edx
  unsigned int v24; // esi
  int v25; // esi
  int v27; // [esp+0h] [ebp-1Ch] BYREF
  unsigned __int16 v28; // [esp+4h] [ebp-18h]
  unsigned __int16 *v29; // [esp+8h] [ebp-14h]
  char v30; // [esp+Ch] [ebp-10h]
  char v31; // [esp+10h] [ebp-Ch]
  char v32; // [esp+14h] [ebp-8h]
  char v33; // [esp+18h] [ebp-4h]

  v1 = sub_2B9A0(a1);
  if ( (unsigned int)v1 <= 1 )
  {
    LOBYTE(v1) = *(_BYTE *)(a1 + 70);
    switch ( (char)v1 )
    {
      case 0:
        sub_2B860(a1, 3u);
        LOBYTE(v1) = sub_2BA50(a1, 1u);
        return v1;
      case 1:
        sub_4A190(a1 + 76, 10, 5);
        LOBYTE(v1) = sub_2BA50(a1, 2u);
        return v1;
      case 2:
        LOBYTE(v1) = 0;
        v2 = *(_WORD *)(a1 + 150);
        v33 = 0;
        if ( v2 )
        {
          v3 = (unsigned __int16 *)dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
          v29 = v3;
          if ( (unsigned int)v3 > dword_EA3E4[0] && *((int *)v3 + 2) >= 0 && (*((_BYTE *)v3 + 13) & 4) == 0 )
            LOBYTE(v1) = 1;
        }
        if ( !(_BYTE)v1 || (v4 = *(_DWORD *)(a1 + 16) - 1, *(_DWORD *)(a1 + 16) = v4, v4 <= 0) )
        {
          v33 = 1;
          goto LABEL_31;
        }
        v27 = *((_DWORD *)v29 + 19);
        v28 = v29[40];
        sub_57FA0(&v27, v29[14], 0, 768);
        if ( (*(_BYTE *)(a1 + 62) & 3) == 0 )
          *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), &v27);
        if ( (*(_BYTE *)(a1 + 62) & 3) != 0 )
          goto LABEL_22;
        v32 = 0;
        v5 = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403);
        while ( 2 )
        {
          if ( v5 > dword_EA3E4[0] )
          {
            if ( *(_WORD *)(v5 + 26) == *(_WORD *)(a1 + 26)
              || (v6 = *(__int16 *)(a1 + 76) - *(__int16 *)(v5 + 76),
                  (int)((HIDWORD(v6) ^ v6) - HIDWORD(v6)) >= *(__int16 *)(a1 + 84))
              || (v7 = *(__int16 *)(a1 + 78) - *(__int16 *)(v5 + 78),
                  (int)((HIDWORD(v7) ^ v7) - HIDWORD(v7)) >= *(__int16 *)(a1 + 84)) )
            {
              v5 = *(_DWORD *)v5;
              continue;
            }
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(v5 + 76), (_WORD *)(a1 + 76));
            v32 = 1;
          }
          break;
        }
LABEL_22:
        v1 = sub_1B8C0(a1);
        if ( v1 == 3 )
        {
          LOBYTE(v1) = sub_2BA50(a1, 7u);
        }
        else if ( (*(_BYTE *)(a1 + 62) & 3) == 0 && *(int *)(a1 + 16) < 14 )
        {
          v1 = sub_584D0((_WORD *)(a1 + 76), &v27);
          if ( v1 < 2768896 )
          {
            LOBYTE(v1) = sub_2B7E0(a1);
            if ( !(_BYTE)v1 )
              LOBYTE(v1) = sub_2BA50(a1, 3u);
          }
        }
LABEL_31:
        if ( v33 )
        {
          LOBYTE(v1) = sub_2B7E0(a1);
          if ( !(_BYTE)v1 )
            LOBYTE(v1) = sub_2BA50(a1, 3u);
        }
        return v1;
      case 3:
        sub_2BA50(a1, 4u);
        sub_2B860(a1, 2u);
        v8 = dword_D41A0 + 28302;
        *(_WORD *)(a1 + 48) = *(_WORD *)(a1 + 28);
        sub_6E450((a1 - v8) / 168, -1, 38);
        goto LABEL_35;
      case 4:
      case 5:
LABEL_35:
        if ( *(int *)(a1 + 16) <= 0 )
        {
          LOBYTE(v1) = sub_2BA50(a1, 6u);
          return v1;
        }
        v9 = *(_WORD *)(a1 + 48);
        *(_WORD *)(a1 + 28) = v9;
        v10 = *(_BYTE *)(a1 + 70);
        *(_WORD *)(a1 + 32) = v9;
        if ( v10 == 4 )
        {
          v11 = *(_WORD *)(a1 + 150);
          v12 = 0;
          if ( v11 )
          {
            v13 = (unsigned __int16 *)dword_EA3E4[v11];
            v29 = v13;
            if ( (unsigned int)v13 > dword_EA3E4[0] && *((int *)v13 + 2) >= 0 && (*((_BYTE *)v13 + 13) & 4) == 0 )
              v12 = 1;
          }
          if ( v12 )
          {
            if ( (*(_BYTE *)(a1 + 62) & 7) == 0 && sub_584D0((_WORD *)(a1 + 76), v29 + 38) > 802816 )
              *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), v29 + 38);
            v14 = *(_DWORD *)(a1 + 16);
            if ( *(__int16 *)(a1 + 44) - 3 > v14 && v14 > 3 && (unsigned __int16)sub_1CED0(a1, (int)v29) )
              *(_BYTE *)(a1 + 70) = 5;
          }
        }
        v15 = *(_BYTE *)(a1 + 62);
        --*(_DWORD *)(a1 + 16);
        if ( (v15 & 3) != 0 )
          goto LABEL_58;
        v31 = 0;
        v16 = *(_DWORD *)(dword_D41A4 + 4 * *(char *)(a1 + 64) + 38403);
        break;
      case 6:
        sub_2B860(a1, 3u);
        sub_4A190(a1 + 76, 10, 5);
        v21 = 0;
        v22 = *(_WORD *)(a1 + 150);
        v30 = 0;
        if ( v22 )
        {
          v23 = (unsigned __int16 *)dword_EA3E4[v22];
          v29 = v23;
          if ( (unsigned int)v23 > dword_EA3E4[0] && *((int *)v23 + 2) >= 0 && (*((_BYTE *)v23 + 13) & 4) == 0 )
            v21 = 1;
        }
        if ( v21 )
        {
          v24 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 28);
          if ( sub_583F0((_WORD *)(a1 + 76), v29 + 38) < v24 )
            v30 = 1;
        }
        if ( v30 )
          LOBYTE(v1) = sub_2BA50(a1, 2u);
        else
          LOBYTE(v1) = sub_2BA50(a1, 7u);
        return v1;
      case 7:
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 20) & 0x7FF;
        sub_2BA50(a1, 8u);
        goto LABEL_76;
      case 8:
LABEL_76:
        LOBYTE(v1) = sub_1B8C0(a1);
        v25 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v25;
        if ( v25 <= 0 )
          LOBYTE(v1) = sub_2BA50(a1, 9u);
        return v1;
      case 9:
        LOBYTE(v1) = sub_2B860(a1, 1u);
        *(_BYTE *)(a1 + 69) = -31;
        *(_WORD *)(a1 + 150) = 0;
        return v1;
      default:
        return v1;
    }
    while ( v16 > dword_EA3E4[0] )
    {
      if ( *(_WORD *)(v16 + 26) != *(_WORD *)(a1 + 26) )
      {
        v17 = *(__int16 *)(a1 + 76) - *(__int16 *)(v16 + 76);
        if ( (int)((HIDWORD(v17) ^ v17) - HIDWORD(v17)) < *(__int16 *)(a1 + 84) )
        {
          v18 = *(__int16 *)(a1 + 78) - *(__int16 *)(v16 + 78);
          if ( (int)((HIDWORD(v18) ^ v18) - HIDWORD(v18)) < *(__int16 *)(a1 + 84) )
          {
            *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(v16 + 76), (_WORD *)(a1 + 76));
            v31 = 1;
            break;
          }
        }
      }
      v16 = *(_DWORD *)v16;
    }
LABEL_58:
    sub_1B8C0(a1);
    v19 = *(_BYTE *)(a1 + 16);
    *(_WORD *)(a1 + 48) = *(_WORD *)(a1 + 28);
    if ( (v19 & 4) != 0 )
      v20 = 56;
    else
      v20 = -56;
    LOWORD(v1) = *(_WORD *)(a1 + 28) + v20;
    *(_WORD *)(a1 + 28) = v1;
    *(_BYTE *)(a1 + 29) &= 7u;
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002B750) --------------------------------------------------------
int __cdecl sub_2B750(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = -31;
  return result;
}

//----- (0002B760) --------------------------------------------------------
int __cdecl sub_2B760(int a1)
{
  return sub_1C890(a1, 224);
}

//----- (0002B780) --------------------------------------------------------
void __cdecl sub_2B780(int a1)
{
  sub_1C930(a1);
}

//----- (0002B7B0) --------------------------------------------------------
void __cdecl sub_2B7B0(int a1)
{
  sub_1D5D0(a1, 224);
  if ( *(_BYTE *)(a1 + 69) == 0xE2 )
    sub_2B840(a1);
}

//----- (0002B7E0) --------------------------------------------------------
char __cdecl sub_2B7E0(int a1)
{
  unsigned int v1; // eax
  char v3; // bl

  v1 = *(_DWORD *)(dword_D41A4 + 38515);
  if ( v1 <= dword_EA3E4[0] )
    return 0;
  do
  {
    if ( v1 != a1 && *(_BYTE *)(v1 + 69) == 0xE2 )
    {
      v3 = *(_BYTE *)(v1 + 70);
      if ( v3 == 3 || v3 == 4 || v3 == 5 )
        return 1;
    }
    v1 = *(_DWORD *)v1;
  }
  while ( v1 > dword_EA3E4[0] );
  return 0;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002B840) --------------------------------------------------------
int __cdecl sub_2B840(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 69) = -30;
  *(_BYTE *)(a1 + 70) = 0;
  return result;
}

//----- (0002B860) --------------------------------------------------------
char __cdecl sub_2B860(int a1, unsigned __int8 a2)
{
  __int16 v2; // ax
  char v3; // ah
  char v4; // dh
  unsigned __int16 v5; // si
  char v6; // ch

  LOBYTE(v2) = a2;
  if ( a2 < 2u )
  {
    if ( a2 == 1 )
    {
      v3 = *(_BYTE *)(a1 + 12) & 0xF6;
      *(_DWORD *)(a1 + 160) = &unk_D8830;
      *(_BYTE *)(a1 + 12) = v3 | 8;
      sub_49CD0((_WORD *)a1, 292);
      sub_49EA0((_WORD *)a1, 85, 42);
      v2 = *(_WORD *)(a1 + 134);
      *(_WORD *)(a1 + 130) = v2;
    }
  }
  else if ( a2 <= 2u )
  {
    *(_DWORD *)(a1 + 160) = &unk_D8830;
    *(_WORD *)(a1 + 44) = 0;
    v4 = *(_BYTE *)(a1 + 12) & 0xF6;
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132);
    *(_BYTE *)(a1 + 12) = v4;
    v5 = word_DA506;
    *(_BYTE *)(a1 + 12) = v4 | 8;
    sub_49CD0((_WORD *)a1, 291);
    sub_49EA0((_WORD *)a1, 384, 768);
    LOBYTE(v2) = sub_71AB0(v5, 0);
    if ( dword_F66F0[v5] )
    {
      *(_DWORD *)(a1 + 16) = *(unsigned __int16 *)(sub_724F0(dword_E9C08, v5) + 16);
      v2 = *(_WORD *)(a1 + 16);
      *(_WORD *)(a1 + 44) = v2;
    }
  }
  else if ( a2 == 3 )
  {
    *(_BYTE *)(a1 + 57) = 0;
    *(_DWORD *)(a1 + 160) = &unk_D8852;
    v6 = *(_BYTE *)(a1 + 12) | 1;
    *(_WORD *)(a1 + 130) = *(_WORD *)(a1 + 132) - 28;
    LOBYTE(v2) = v6 & 0xF7;
    *(_BYTE *)(a1 + 12) = v6 & 0xF7;
  }
  return v2;
}
// DA506: using guessed type __int16 word_DA506;
// E9C08: using guessed type int dword_E9C08;
// F66F0: using guessed type int dword_F66F0[504];

//----- (0002B9A0) --------------------------------------------------------
int __cdecl sub_2B9A0(int a1)
{
  unsigned int v1; // edx
  __int16 v2; // dx
  int i; // ebx
  int v4; // ecx
  int v5; // ebx

  v1 = 0;
  if ( *(_WORD *)(a1 + 98) )
  {
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    v2 = *(_WORD *)(a1 + 98);
    *(_WORD *)(a1 + 98) = 0;
    *(_WORD *)(a1 + 38) = v2;
    v1 = 1;
  }
  else
  {
    *(_WORD *)(a1 + 38) = 0;
  }
  if ( *(_WORD *)(a1 + 52) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52) )
    {
      v5 = dword_EA3E4[i];
      if ( v5 == dword_EA3E4[0] )
        break;
      v4 = *(_DWORD *)(v5 + 8);
      if ( v4 < *(_DWORD *)(a1 + 8) )
      {
        *(_DWORD *)(a1 + 8) = v4;
        *(_WORD *)(a1 + 38) = *(_WORD *)(v5 + 38);
        v1 = 1;
        break;
      }
    }
  }
  if ( *(int *)(a1 + 8) < 0 )
  {
    *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 38);
    v1 = 2;
  }
  if ( v1 )
  {
    if ( v1 > 1 )
    {
      *(_BYTE *)(a1 + 69) = -28;
      return 2;
    }
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 38);
  }
  return v1;
}
// 2BA31: conditional instruction was optimized away because edx.4==2
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0002BA50) --------------------------------------------------------
unsigned __int8 __cdecl sub_2BA50(int a1, unsigned __int8 a2)
{
  unsigned __int8 result; // al

  result = a2;
  *(_BYTE *)(a1 + 70) = a2;
  if ( a2 < 2u )
    goto LABEL_7;
  if ( a2 <= 2u )
  {
    *(_DWORD *)(a1 + 16) = 32;
    return result;
  }
  if ( a2 == 8 )
    *(_DWORD *)(a1 + 16) = 16;
  else
LABEL_7:
    *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (0002BB40) --------------------------------------------------------
int __cdecl sub_2BB40(__int16 a1, __int16 a2, int a3)
{
  int (__cdecl *v3)(__int16, __int16, int); // eax
  int result; // eax
  int v5; // edi
  int (__cdecl *v6)(__int16, __int16, int); // [esp+0h] [ebp-4h]

  if ( (word_180660 & 1) != 0 )
    v3 = sub_8F8B0;
  else
    v3 = sub_8F8E8;
  v6 = v3;
  v3(a1, a2, a3);
  result = dword_D41A0;
  if ( *(_BYTE *)(dword_D41A0 + 8592) == 1 )
  {
    v5 = dword_180628;
    dword_180628 = dword_E9C3C;
    result = v6(a1, a2, a3);
    dword_180628 = v5;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E9C3C: using guessed type int dword_E9C3C;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0002BBB0) --------------------------------------------------------
int __cdecl sub_2BBB0(__int16 a1, __int16 a2, int a3)
{
  int result; // eax
  int v4; // edi

  dword_F01EC(a1, a2, a3);
  result = dword_D41A0;
  if ( *(_BYTE *)(dword_D41A0 + 8592) == 1 )
  {
    v4 = dword_180628;
    dword_180628 = dword_E9C3C;
    result = dword_F01EC(a1, a2, a3);
    dword_180628 = v4;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E9C3C: using guessed type int dword_E9C3C;
// F01EC: using guessed type int (__cdecl *dword_F01EC)(_DWORD, _DWORD, _DWORD);
// 180628: using guessed type int dword_180628;

//----- (0002BC10) --------------------------------------------------------
int __cdecl sub_2BC10(_BYTE *a1, __int16 a2, __int16 a3, unsigned __int8 a4)
{
  int result; // eax
  int v5; // [esp+0h] [ebp-4h]

  sub_6F940(a1, a2, a3, a4);
  result = dword_D41A0;
  if ( *(_BYTE *)(dword_D41A0 + 8592) == 1 )
  {
    v5 = dword_180628;
    dword_180628 = dword_E9C3C;
    sub_6F940(a1, a2, a3, a4);
    result = v5;
    dword_180628 = v5;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E9C3C: using guessed type int dword_E9C3C;
// 180628: using guessed type int dword_180628;

//----- (0002BC80) --------------------------------------------------------
int __cdecl sub_2BC80(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5)
{
  void *v5; // ebx
  int result; // eax
  int v7; // [esp+0h] [ebp-10h]

  if ( (word_180660 & 1) != 0 )
    v5 = sub_90164;
  else
    v5 = sub_901E4;
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v5)(a1, a2, a3, a4, a5);
  result = dword_D41A0;
  if ( *(_BYTE *)(dword_D41A0 + 8592) == 1 )
  {
    v7 = dword_180628;
    dword_180628 = dword_E9C3C;
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v5)(a1, a2, a3, a4, a5);
    result = v7;
    dword_180628 = v7;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E9C3C: using guessed type int dword_E9C3C;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0002BD10) --------------------------------------------------------
int __cdecl sub_2BD10(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5)
{
  void *v5; // ebx
  int result; // eax
  int v7; // [esp+0h] [ebp-10h]

  if ( (word_180660 & 1) != 0 )
    v5 = sub_BD524;
  else
    v5 = sub_BD542;
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v5)(a1, a2, a3, a4, a5);
  result = dword_D41A0;
  if ( *(_BYTE *)(dword_D41A0 + 8592) == 1 )
  {
    v7 = dword_180628;
    dword_180628 = dword_E9C3C;
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v5)(a1, a2, a3, a4, a5);
    result = v7;
    dword_180628 = v7;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E9C3C: using guessed type int dword_E9C3C;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0002BE30) --------------------------------------------------------
int sub_2BE30()
{
  int (__cdecl *v0)(__int16, __int16, int); // eax
  char v1; // bh
  int v2; // esi
  char v3; // dl
  int v4; // ebx
  int v5; // edi
  __int16 v6; // bx
  int v7; // ebx
  int v8; // edx
  int v9; // eax
  int v10; // edi
  int v11; // ebx
  unsigned __int8 v12; // al
  int v13; // edi
  int v14; // edx
  int v15; // eax
  int v16; // esi
  int v17; // esi
  int v18; // edx
  int v19; // eax
  int v20; // esi
  unsigned __int16 v21; // dx
  int v22; // eax
  int v23; // esi
  int v24; // esi
  int v25; // ecx
  int v26; // eax
  int v27; // esi
  int i; // ebx
  __int16 v29; // di
  int v30; // esi
  int v32; // eax
  unsigned __int16 v33; // cx
  int v34; // [esp+8h] [ebp-18h]
  __int16 v35; // [esp+Ch] [ebp-14h]
  __int16 v36; // [esp+10h] [ebp-10h]
  __int16 v37; // [esp+14h] [ebp-Ch]
  __int16 v38; // [esp+18h] [ebp-8h]
  __int16 v39; // [esp+1Ch] [ebp-4h]

  dword_D41C8 = 0;
  if ( *(_BYTE *)(dword_D41A0 + 8600) )
  {
    if ( (word_180660 & 1) != 0 )
      v0 = sub_8F8B0;
    else
      v0 = sub_8F8E8;
    dword_F01E8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))v0;
  }
  else
  {
    dword_F01E8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))sub_2DE80;
  }
  dword_F01EC = dword_F01E8;
  v1 = *(_BYTE *)(dword_D41A4 + 10);
  dword_F01E8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))sub_2BBB0;
  if ( v1 )
    sub_88580();
  switch ( *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) )
  {
    case 0:
    case 3:
    case 5:
    case 9:
    case 0xA:
    case 0xD:
      v2 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
      if ( byte_D41C4 || *(char *)(dword_D41A0 + 8589) != (unsigned __int8)byte_D41C6 )
      {
        v3 = *(_BYTE *)(dword_D41A0 + 8589);
        byte_D41C4 = 0;
        byte_D41C6 = v3;
        if ( v3 < 40 )
        {
          if ( (word_180660 & 1) != 0 )
            sub_72883((unsigned __int8)byte_EB3A8, (void *)dword_180628, 0xC8u, byte_EB3A8);
          else
            sub_728A9(dword_180628, (void *)dword_180628, 0x1E0u, byte_EB3A8);
        }
      }
      if ( *(char *)(dword_D41A0 + 8589) < 40 )
      {
        if ( (word_180660 & 1) != 0 )
          sub_72883((unsigned __int8)byte_EB3A8, (void *)dword_180628, 0xC8u, byte_EB3A8);
        else
          sub_728A9((unsigned __int8)byte_EB3A8, (void *)dword_180628, 0x1E0u, byte_EB3A8);
      }
      sub_40C50(*(char *)(dword_D41A0 + 8589));
      v4 = dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12);
      v5 = *(unsigned __int16 *)(v4 + 11244);
      sub_411A0(
        dword_180628,
        *(__int16 *)(v4 + 14 * (unsigned __int16)v5 + 11709),
        *(__int16 *)(v4 + 14 * (unsigned __int16)v5 + 11711),
        *(_WORD *)(v4 + 14 * (unsigned __int16)v5 + 11715),
        *(__int16 *)(v4 + 14 * (unsigned __int16)v5 + 11713) + 128,
        *(__int16 *)(v4 + 14 * (unsigned __int16)v5 + 11717),
        *(_WORD *)(v4 + 14 * (unsigned __int16)v5 + 11719),
        *(__int16 *)(v4 + 14 * (unsigned __int16)v5 + 11721));
      if ( *(int *)(v2 + 8) < 0 )
      {
        v12 = *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221);
        if ( v12 < 0xAu )
        {
          if ( v12 == 9 )
          {
            sub_30050();
            break;
          }
        }
        else if ( v12 <= 0xAu )
        {
          sub_303D0(v5);
        }
        else if ( v12 == 13 )
        {
          sub_30A60(6, 6);
          break;
        }
        sub_2FD90();
      }
      else
      {
        if ( dword_D4188 && *(_BYTE *)(*(_DWORD *)(v2 + 164) + 334) )
        {
          if ( (word_180660 & 1) != 0 )
          {
            v38 = 2;
            v36 = 4;
          }
          else
          {
            v38 = 4;
            v36 = 6;
          }
          v5 = 1;
          v37 = 0;
          v39 = 0;
          v6 = *(unsigned __int8 *)(dword_D418C + 11);
          while ( v37 < v38 )
          {
            v35 = 0;
            v34 = 0;
            while ( v35 < v36 )
            {
              v7 = 6 * v5;
              sub_2BB40(v34, v39, 6 * v5 + dword_D418C);
              ++v35;
              ++v5;
              v34 += *(unsigned __int8 *)(v7 + dword_D418C + 4);
              v6 = *(unsigned __int8 *)(dword_D418C + 11);
            }
            ++v37;
            v39 += v6;
          }
        }
        if ( *(_BYTE *)(dword_D41A0 + 8590) )
        {
          v8 = dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12);
          v9 = v8 + 14 * *(unsigned __int16 *)(v8 + 11244);
          sub_63600(
            0,
            0,
            *(__int16 *)(v9 + 11709),
            *(__int16 *)(v9 + 11711),
            128,
            128,
            *(_WORD *)(v9 + 11715),
            256,
            dword_180648 - 2 * (dword_180648 / 5u),
            0);
          v10 = 2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0;
          sub_61880(
            0,
            0,
            *(_WORD *)(v10 + 14 * *(unsigned __int16 *)(v10 + 11244) + 11709),
            *(_WORD *)(v10 + 14 * *(unsigned __int16 *)(v10 + 11244) + 11711),
            128,
            128,
            *(_WORD *)(v10 + 14 * *(unsigned __int16 *)(v10 + 11244) + 11715),
            256);
          v11 = dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12);
          v5 = 256;
          sub_644F0(
            0,
            0,
            *(_WORD *)(v11 + 14 * *(unsigned __int16 *)(v11 + 11244) + 11709),
            *(_WORD *)(v11 + 14 * *(unsigned __int16 *)(v11 + 11244) + 11711),
            128,
            128,
            *(_WORD *)(v11 + 14 * *(unsigned __int16 *)(v11 + 11244) + 11715),
            256);
        }
        sub_6FC50(byte_D419D);
        if ( *(_BYTE *)(dword_D41A0 + 8591) )
        {
          sub_2E260(
            510,
            2,
            dword_EA3E4[*(__int16 *)(*(_DWORD *)(v2 + 164) + 2 * *(__int16 *)(*(_DWORD *)(v2 + 164) + 1105) + 819)],
            0);
          sub_2E260(
            574,
            2,
            dword_EA3E4[*(__int16 *)(*(_DWORD *)(v2 + 164) + 2 * *(__int16 *)(*(_DWORD *)(v2 + 164) + 1107) + 819)],
            0);
          sub_2D710(v2);
        }
        switch ( *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) )
        {
          case 3:
            sub_2F6B0();
            goto LABEL_41;
          case 9:
            sub_30050();
            goto LABEL_42;
          case 0xA:
            sub_303D0(v5);
            goto LABEL_41;
          case 0xD:
            sub_30A60(132, 50);
            goto LABEL_42;
          default:
LABEL_41:
            sub_2FD90();
LABEL_42:
            sub_2CE30(132, 50);
            if ( *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) == 5 )
              sub_2ECC0();
            break;
        }
      }
      break;
    case 6:
    case 7:
    case 8:
    case 0xB:
    case 0xC:
    case 0xE:
      v13 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
      if ( (word_180660 & 1) != 0 )
        sub_72883((unsigned __int8)byte_EB3A8, (void *)dword_180628, 0xC8u, byte_EB3A8);
      else
        sub_728A9((unsigned __int8)byte_EB3A8, (void *)dword_180628, 0x1E0u, byte_EB3A8);
      if ( word_180660 == 1 )
      {
        v14 = dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12);
        v15 = v14 + 14 * *(unsigned __int16 *)(v14 + 11244);
        sub_63600(
          0,
          0,
          *(__int16 *)(v15 + 11709),
          *(__int16 *)(v15 + 11711),
          382,
          400,
          *(_WORD *)(v15 + 11715),
          204,
          dword_180648 - 192,
          1);
        v16 = dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12);
        sub_61880(
          0,
          0,
          *(_WORD *)(v16 + 14 * *(unsigned __int16 *)(v16 + 11244) + 11709),
          *(_WORD *)(v16 + 14 * *(unsigned __int16 *)(v16 + 11244) + 11711),
          382,
          400,
          *(_WORD *)(v16 + 14 * *(unsigned __int16 *)(v16 + 11244) + 11715),
          204);
      }
      else
      {
        v17 = dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12);
        sub_63600(
          0,
          0,
          *(__int16 *)(v17 + 14 * *(unsigned __int16 *)(v17 + 11244) + 11709),
          *(__int16 *)(v17 + 14 * *(unsigned __int16 *)(v17 + 11244) + 11711),
          382,
          400,
          *(_WORD *)(v17 + 14 * *(unsigned __int16 *)(v17 + 11244) + 11715),
          204,
          dword_180648 - 192,
          1);
        v18 = dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12);
        v19 = v18 + 14 * *(unsigned __int16 *)(v18 + 11244);
        sub_61880(0, 0, *(_WORD *)(v19 + 11709), *(_WORD *)(v19 + 11711), 382, 400, *(_WORD *)(v19 + 11715), 204);
      }
      sub_40BF0(384, 0, 256, 400);
      v20 = dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12);
      v21 = *(_WORD *)(v20 + 11244);
      sub_411A0(
        dword_180628,
        *(__int16 *)(v20 + 14 * v21 + 11709),
        *(__int16 *)(v20 + 14 * v21 + 11711),
        *(_WORD *)(v20 + 14 * v21 + 11715),
        *(__int16 *)(v20 + 14 * v21 + 11713) + 128,
        *(__int16 *)(v20 + 14 * v21 + 11717),
        *(_WORD *)(v20 + 14 * v21 + 11719),
        *(__int16 *)(v20 + 14 * v21 + 11721));
      if ( (word_180660 & 1) != 0 )
        sub_9025C(384, 0, 384, 400, (unsigned __int8)byte_E8900[0], 0);
      else
        sub_90374(384, 0, 384, 400, (unsigned __int8)byte_E8900[0], 0);
      if ( (word_180660 & 1) != 0 )
        sub_9025C(382, 0, 382, 400, (unsigned __int8)byte_E8900[0], 0);
      else
        sub_90374(382, 0, 382, 400, (unsigned __int8)byte_E8900[0], 0);
      sub_40C50(*(char *)(dword_D41A0 + 8589));
      if ( word_180660 == 1 )
      {
        v22 = dword_D41A0;
        v23 = 2124 * *(__int16 *)(dword_D41A0 + 12);
      }
      else
      {
        v23 = dword_D41A0;
        v22 = 2124 * *(__int16 *)(dword_D41A0 + 12);
      }
      v24 = v22 + v23;
      sub_644F0(
        0,
        0,
        *(_WORD *)(v24 + 14 * *(unsigned __int16 *)(v24 + 11244) + 11709),
        *(_WORD *)(v24 + 14 * *(unsigned __int16 *)(v24 + 11244) + 11711),
        382,
        400,
        *(_WORD *)(v24 + 14 * *(unsigned __int16 *)(v24 + 11244) + 11715),
        204);
      switch ( *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) )
      {
        case 7:
          sub_2D1D0();
          break;
        case 8:
          sub_2FD90();
          sub_2ECC0();
          break;
        case 0xB:
          sub_30050();
          break;
        case 0xC:
          sub_303D0(v13);
          goto LABEL_73;
        case 0xE:
          sub_30A60(6, 6);
          break;
        default:
LABEL_73:
          sub_2FD90();
          break;
      }
      sub_2CE30(6, 6);
      if ( *(_BYTE *)(dword_D41A4 + 38400) )
        sub_2E260(
          510,
          2,
          dword_EA3E4[*(__int16 *)(*(_DWORD *)(v13 + 164) + 2 * *(__int16 *)(*(_DWORD *)(v13 + 164) + 1105) + 819)],
          0);
      if ( *(_BYTE *)(dword_D41A4 + 38401) )
        sub_2E260(
          574,
          2,
          dword_EA3E4[*(__int16 *)(*(_DWORD *)(v13 + 164) + 2 * *(__int16 *)(*(_DWORD *)(v13 + 164) + 1107) + 819)],
          0);
      break;
    default:
      break;
  }
  if ( *((_BYTE *)&loc_36E03 + dword_D41A0 + 1) )
    sub_30630();
  sub_6FC50(byte_D419D);
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 4) == 0 )
    return _wcpp_1_unwind_leave__62();
  if ( *(_BYTE *)(dword_D41A4 + 204) == 3 )
  {
    v25 = *(_DWORD *)(dword_D41A4 + 210);
    if ( v25 <= 0 )
      *(_BYTE *)(dword_D41A4 + 204) = 2;
    else
      *(_DWORD *)(dword_D41A4 + 210) = v25 - 1;
  }
  v26 = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 204) == 2 )
  {
    *(_BYTE *)(dword_D41A4 + 204) = 1;
    *(_WORD *)(v26 + 214) = 0;
    *(_DWORD *)(v26 + 210) = 50;
  }
  if ( *(_BYTE *)(dword_D41A4 + 204) != 1 )
    return _wcpp_1_unwind_leave__62();
  if ( *(int *)(dword_D41A4 + 210) <= 0 )
  {
    while ( 1 )
    {
      v32 = dword_D41A4;
      if ( *off_DB558[*(unsigned __int16 *)(dword_D41A4 + 214)] == 33 )
        break;
      ++*(_WORD *)(dword_D41A4 + 214);
    }
    v33 = *(_WORD *)(dword_D41A4 + 214) + 1;
    *(_WORD *)(dword_D41A4 + 214) = v33;
    if ( *off_DB558[v33] == 35 )
    {
      *(_BYTE *)(v32 + 204) = 3;
      *(_DWORD *)(v32 + 210) = 200;
      return _wcpp_1_unwind_leave__62();
    }
    *(_DWORD *)(v32 + 210) = 50;
    return _wcpp_1_unwind_leave__62();
  }
  v27 = 380;
  for ( i = 0; *(&off_DB558[i])[*(unsigned __int16 *)(dword_D41A4 + 214)] != 33; ++i )
    v27 -= sub_6FC30();
  v29 = 0;
  v30 = 8;
  while ( i > 0 )
  {
    if ( v29 )
      sub_2BC10((&off_DB558[v29])[*(unsigned __int16 *)(dword_D41A4 + 214)], 8, v30, byte_E8900[0]);
    else
      sub_2BC10(off_DB558[*(unsigned __int16 *)(dword_D41A4 + 214)], 8, v30, byte_E98FF);
    --i;
    ++v29;
    v30 += sub_6FC30();
  }
  --*(_DWORD *)(dword_D41A4 + 210);
  return _wcpp_1_unwind_leave__62();
}
// 2BB30: using guessed type int _wcpp_1_unwind_leave__62(void);
// D4188: using guessed type int dword_D4188;
// D418C: using guessed type int dword_D418C;
// D419D: using guessed type char byte_D419D;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41C4: using guessed type char byte_D41C4;
// D41C6: using guessed type char byte_D41C6;
// D41C8: using guessed type int dword_D41C8;
// DB558: using guessed type char *off_DB558[3];
// E98FF: using guessed type char byte_E98FF;
// EA3E4: using guessed type int dword_EA3E4[];
// EB3A8: using guessed type char byte_EB3A8;
// F01E8: using guessed type int (__cdecl *dword_F01E8)(_DWORD, _DWORD, _DWORD);
// F01EC: using guessed type int (__cdecl *dword_F01EC)(_DWORD, _DWORD, _DWORD);
// 180628: using guessed type int dword_180628;
// 180648: using guessed type int dword_180648;
// 180660: using guessed type __int16 word_180660;

//----- (0002CA60) --------------------------------------------------------
int __cdecl sub_2CA60(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  int result; // eax

  dword_EA3D0 = a1;
  dword_EA3CC = a2;
  dword_EA3C4 = a3;
  result = a4;
  dword_EA3C0 = a4;
  return result;
}
// EA3C0: using guessed type int dword_EA3C0;
// EA3C4: using guessed type int dword_EA3C4;
// EA3CC: using guessed type int dword_EA3CC;
// EA3D0: using guessed type int dword_EA3D0;

//----- (0002CA90) --------------------------------------------------------
int __cdecl sub_2CA90(__int16 a1)
{
  int v1; // eax
  int result; // eax
  int v3; // esi
  int v4; // ecx

  v1 = 40 - a1;
  dword_EA3D0 = 8 * v1;
  dword_EA3C4 = 16 * a1;
  if ( (word_180660 & 1) != 0 )
  {
    result = 5 * v1 / 2;
    v3 = 10 * a1;
    v4 = 2 * result;
  }
  else
  {
    result = 12 * v1 / 2;
    v3 = 12 * a1;
    v4 = result;
  }
  dword_EA3C0 = v3;
  dword_EA3CC = v4;
  return result;
}
// EA3C0: using guessed type int dword_EA3C0;
// EA3C4: using guessed type int dword_EA3C4;
// EA3CC: using guessed type int dword_EA3CC;
// EA3D0: using guessed type int dword_EA3D0;
// 180660: using guessed type __int16 word_180660;

//----- (0002CB30) --------------------------------------------------------
__int16 __cdecl sub_2CB30(_DWORD *a1, __int16 a2, __int16 a3, __int16 a4)
{
  char *v4; // edi
  char *v5; // esi
  char v6; // al
  char v7; // al
  int v8; // esi
  int v9; // ebx
  int v10; // eax
  __int16 v11; // bx
  __int16 v12; // di
  int v13; // esi
  char v15[32]; // [esp+0h] [ebp-58h] BYREF
  int v16; // [esp+20h] [ebp-38h]
  int v17; // [esp+24h] [ebp-34h]
  int v18; // [esp+28h] [ebp-30h]
  int v19; // [esp+2Ch] [ebp-2Ch]
  int v20; // [esp+30h] [ebp-28h]
  int v21; // [esp+34h] [ebp-24h]
  int v22; // [esp+38h] [ebp-20h]
  int v23; // [esp+3Ch] [ebp-1Ch]
  unsigned __int8 v24; // [esp+40h] [ebp-18h]
  unsigned __int8 v25; // [esp+44h] [ebp-14h]
  unsigned __int8 v26; // [esp+48h] [ebp-10h]
  unsigned __int8 v27; // [esp+4Ch] [ebp-Ch]
  unsigned __int8 v28; // [esp+50h] [ebp-8h]
  unsigned __int8 v29; // [esp+54h] [ebp-4h]

  v22 = dword_EA3C4 + dword_EA3D0 - 4;
  v20 = dword_EA3C0 + dword_EA3CC - 22;
  v16 = *(__int16 *)(a1[41] + 56);
  v4 = v15;
  v5 = (char *)(2124 * v16 + dword_D41A0 + 11230 + 927);
  do
  {
    v6 = *v5;
    *v4 = *v5;
    if ( !v6 )
      break;
    v7 = v5[1];
    v5 += 2;
    v4[1] = v7;
    v4 += 2;
  }
  while ( v7 );
  v27 = byte_E88E0[3 * sub_61790(v16)];
  v26 = byte_E8900[0];
  v25 = byte_E88E0[3 * sub_61790(v16)];
  v8 = 5 * *((unsigned __int8 *)&loc_2FED1 + dword_D41A0 + 3);
  v24 = byte_D94F2[v8];
  v29 = byte_D94F3[v8];
  v28 = byte_D94F0[v8];
  v9 = (a4 >> 1) + a2;
  if ( (word_180660 & 1) != 0 )
  {
    LOWORD(v9) = 2 * v9;
    a3 *= 2;
  }
  LOWORD(v10) = dword_EA3CC;
  v11 = dword_EA3D0 + v9;
  v12 = dword_EA3CC + a3 - 20;
  if ( v11 >= dword_EA3D0 )
  {
    LOWORD(v10) = v12;
    if ( v12 >= dword_EA3CC && v11 < v22 && v12 < v20 )
    {
      v10 = strlen(v15);
      v13 = 8 * v10 + 4;
      if ( v11 + v13 > v22 )
      {
        v13 = v22 - v11;
        v10 = (v13 - 4 - (__CFSHL__((v13 - 4) >> 31, 3) + 8 * ((v13 - 4) >> 31))) >> 3;
      }
      if ( v10 > 0 )
      {
        v15[v10] = 0;
        v23 = v13 + 2;
        v17 = (__int16)(v13 + 2);
        v21 = v11;
        sub_2BC80(v11, v12, v13 + 2, 18, v28);
        v18 = v24;
        sub_2BC80(v21, v12, v17, 2, v24);
        v19 = v29;
        sub_2BC80(v21, v12 + 16, v17, 2, v29);
        sub_2BC80(v21, v12, 2, 16, v18);
        sub_2BC80(v11 + v23 - 2, v12, 2, 18, v19);
        sub_2BC10(v15, v11 + 4, v12, v25);
        sub_2BC80(v11 + 2, v12 + 14, v13 - 2, 2, v26);
        LOWORD(v10) = (_WORD)a1;
        if ( a1[1] )
        {
          v10 = a1[2] * (v13 - 2) / a1[1];
          if ( v21 + 2 + v10 > v22 - 2 )
            v10 = v22 - 2 - (v21 + 2);
          if ( v10 > 0 )
            LOWORD(v10) = sub_2BC80(v11 + 2, v12 + 14, v10, 2, v27);
        }
      }
    }
  }
  return v10;
}
// D41A0: using guessed type int dword_D41A0;
// EA3C0: using guessed type int dword_EA3C0;
// EA3C4: using guessed type int dword_EA3C4;
// EA3CC: using guessed type int dword_EA3CC;
// EA3D0: using guessed type int dword_EA3D0;
// 180660: using guessed type __int16 word_180660;
// 2CB30: using guessed type char var_58[32];

//----- (0002CE30) --------------------------------------------------------
int __cdecl sub_2CE30(__int16 a1, int a2)
{
  int v2; // esi
  int result; // eax
  __int16 v4; // di
  unsigned __int8 v5; // bl
  int v6; // eax
  int i; // ebx
  __int16 v8; // kr00_2
  __int16 v9; // ax
  int v10; // eax
  __int16 v11; // ax
  int v12; // eax
  __int16 v13; // ax
  __int64 v14; // rax
  unsigned __int8 v15; // al
  int v16; // eax
  __int16 v17; // ax
  __int64 v18; // rax
  char v19[128]; // [esp+0h] [ebp-Eh] BYREF
  const char *v20; // [esp+80h] [ebp+72h]
  int v21; // [esp+84h] [ebp+76h]

  v2 = a2;
  sub_6FC50(byte_D419D);
  result = dword_D41A4;
  v4 = a1;
  v5 = byte_E9800;
  if ( !*(_BYTE *)(dword_D41A4 + 205) && !*(_BYTE *)(dword_D41A4 + 38546) )
  {
    if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) != 0 )
    {
      sub_2BC10((_BYTE *)dword_EA2F0, a1, a2, byte_E89F0);
      v4 = -8 * ~(strlen((const char *)dword_EA2F0) + 1) + a1;
    }
    if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x20) == 0 && byte_3659C[11 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0] )
    {
      sprintf(v19, "%s. %s.", (const char *)dword_EA234, (const char *)dword_EA238);
      sub_2BC10(v19, v4, a2, v5);
      v4 = a1;
      LOWORD(v6) = sub_6FC30();
      v2 = v6 + a2;
    }
    v21 = 0;
    for ( i = dword_D41A0 + 11230; ; i += 2124 )
    {
      result = dword_D41A0;
      if ( (unsigned __int16)v21 >= *(_WORD *)(dword_D41A0 + 14) )
        break;
      v8 = *(_WORD *)(i + 79) - 1;
      v20 = (const char *)(i + 28);
      switch ( v8 )
      {
        case 0:
          v9 = *(_WORD *)(i + 77);
          *(_WORD *)(i + 77) = v9 - 1;
          if ( v9 <= 0 )
            goto LABEL_23;
          sprintf(v19, "%s %s", (const char *)(i + 927), (const char *)(i + 28));
          sub_2BC10(v19, v4, v2, byte_E9800);
          v4 = a1;
          LOWORD(v10) = sub_6FC30();
          v2 += v10;
          break;
        case 1:
          v13 = *(_WORD *)(i + 77);
          *(_WORD *)(i + 77) = v13 - 1;
          if ( v13 <= 0 )
            goto LABEL_23;
          sprintf(v19, "[%s] %s", (const char *)(i + 927), v20);
          if ( *(__int16 *)(i + 77) <= 100 )
          {
            v15 = byte_E9800;
          }
          else
          {
            v14 = 4080 * *(unsigned __int8 *)(dword_D41A4 + 123);
            v15 = byte_E8900[256 * ((int)(v14 - (__CFSHL__(HIDWORD(v14), 8) + (HIDWORD(v14) << 8))) >> 8)];
          }
          sub_2BC10(v19, v4, v2, v15);
          LOWORD(v16) = sub_6FC30();
          v4 = a1;
          v2 += v16;
          break;
        case 2:
        case 4:
          v11 = *(_WORD *)(i + 77);
          *(_WORD *)(i + 77) = v11 - 1;
          if ( v11 <= 0 )
            goto LABEL_23;
          if ( *(_WORD *)(i + 79) == 3 || (unsigned __int16)v21 == *(__int16 *)(dword_D41A0 + 12) )
          {
            sprintf(v19, "%s", (const char *)(i + 28));
            sub_2BC10(v19, v4, v2, byte_E9800);
            v4 = a1;
            LOWORD(v12) = sub_6FC30();
            v2 += v12;
          }
          break;
        case 3:
          v17 = *(_WORD *)(i + 77);
          *(_WORD *)(i + 77) = v17 - 1;
          if ( v17 <= 0 )
          {
LABEL_23:
            *(_WORD *)(i + 79) = 0;
          }
          else
          {
            sprintf(v19, "[%s] %s", (const char *)(i + 927), v20);
            v18 = 4080 * *(unsigned __int8 *)(dword_D41A4 + 123);
            sub_2BC10(
              v19,
              v4,
              v2,
              byte_E8900[16 * ((int)(v18 - (__CFSHL__(HIDWORD(v18), 8) + (HIDWORD(v18) << 8))) >> 8)]);
            v4 = a1;
            LOWORD(v18) = sub_6FC30();
            v2 += v18;
          }
          break;
        default:
          break;
      }
      ++v21;
    }
  }
  return result;
}
// 2CF2D: variable 'v6' is possibly undefined
// 2CFC4: variable 'v10' is possibly undefined
// 2D039: variable 'v12' is possibly undefined
// 2D0D1: variable 'v16' is possibly undefined
// 2D152: variable 'v18' is possibly undefined
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D419D: using guessed type char byte_D419D;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E89F0: using guessed type char byte_E89F0;
// E9800: using guessed type char byte_E9800;
// EA234: using guessed type int dword_EA234;
// EA238: using guessed type int dword_EA238;
// EA2F0: using guessed type int dword_EA2F0;

//----- (0002D190) --------------------------------------------------------
int __cdecl sub_2D190(__int16 a1, __int16 a2, int a3, __int16 a4, int a5, unsigned __int8 a6)
{
  int result; // eax

  result = a5;
  if ( a5 >= a3 )
    result = a3;
  if ( result >= 2 )
    return sub_2BC80(a1, a2, result, a4, a6);
  return result;
}

//----- (0002D1D0) --------------------------------------------------------
int sub_2D1D0()
{
  int v0; // esi
  int v1; // eax
  int v2; // edx
  int v3; // ebx
  int v4; // edx
  int v5; // ebx
  char v6; // cl
  int v7; // edi
  unsigned __int8 v8; // si
  int v9; // esi
  int v10; // eax
  int v11; // edi
  int v12; // eax
  int v13; // esi
  int v14; // eax
  unsigned __int16 v15; // cx
  int j; // esi
  int v17; // eax
  int v18; // eax
  int result; // eax
  unsigned __int8 v20; // [esp-4h] [ebp-128h]
  char v21[256]; // [esp+0h] [ebp-124h] BYREF
  int v22; // [esp+100h] [ebp-24h]
  int v23; // [esp+104h] [ebp-20h]
  int i; // [esp+108h] [ebp-1Ch]
  int v25; // [esp+10Ch] [ebp-18h]
  int v26; // [esp+110h] [ebp-14h]
  int v27; // [esp+114h] [ebp-10h]
  int v28; // [esp+118h] [ebp-Ch]
  unsigned __int8 v29; // [esp+11Ch] [ebp-8h]
  unsigned __int8 v30; // [esp+120h] [ebp-4h]

  v0 = 0;
  sub_6FC50(byte_D419D);
  v1 = 0;
  v2 = dword_D41A0 + 11230;
  while ( v0 < *(unsigned __int16 *)(dword_D41A0 + 14) )
  {
    if ( *(_BYTE *)(v2 + 6) )
      ++v1;
    ++v0;
    v2 += 2124;
  }
  v3 = v1 * *(unsigned __int8 *)(dword_EA3DC + 515);
  v28 = (640 - (v1 * *(unsigned __int8 *)(dword_EA3DC + 520) + *(unsigned __int8 *)(dword_EA3DC + 514))) / 2;
  if ( word_180660 == 1 )
    v4 = 400;
  else
    v4 = 480;
  v5 = (v4 - v3) / 2;
  v25 = 0;
  for ( i = dword_D41A0 + 11230; ; i += 2124 )
  {
    result = *(unsigned __int16 *)(dword_D41A0 + 14);
    if ( result <= v25 )
      break;
    v6 = *(_BYTE *)(i + 6);
    v23 = dword_EA3E4[*(unsigned __int16 *)(i + 10)];
    if ( v6 == 1 )
    {
      v29 = byte_E88E1[3 * sub_61790(v25)];
      v30 = byte_E88E0[3 * sub_61790(v25)];
      v7 = v28;
      sub_2BB40(v28, v5, dword_EA3DC + 510);
      sub_2BC80(
        v7 + 4,
        v5 + 4,
        *(unsigned __int8 *)(dword_EA3DC + 514) - 8,
        *(unsigned __int8 *)(dword_EA3DC + 515) - 8,
        v30);
      v8 = v29;
      v22 = (__int16)(v7 + 8);
      sub_2BC10((_BYTE *)(i + 927), v7 + 8, v5 + 6, v29);
      sprintf(v21, "%d", *(_DWORD *)(v23 + 140));
      v20 = v8;
      v9 = v25;
      sub_2BC10(v21, v22, v5 + 20, v20);
      if ( !v9 && *(_BYTE *)(dword_D41A4 + 10) )
      {
        word_180546 = v7 + 20;
        word_180548 = v5 + 30;
      }
      HIWORD(v10) = HIWORD(dword_EA3DC);
      LOWORD(v10) = *(unsigned __int8 *)(dword_EA3DC + 514);
      v11 = v10 + v7;
      if ( *(_BYTE *)(dword_D41A4 + 10) && *(_WORD *)(dword_D41A0 + 14) > 1u && !byte_180558 )
      {
        dword_180532 = 9377 * dword_180532 + 9439;
        v12 = (unsigned __int8)*(_DWORD *)(dword_D41A4 + 26);
        byte_180558 = dword_180532 % (unsigned int)*(unsigned __int16 *)(dword_D41A0 + 14) + 1;
        v13 = v12 + dword_180532;
        v14 = 1;
        dword_180532 = v13;
        while ( v14 < 8 && !*(_BYTE *)(dword_D41A0 + 2124 * v14 + 11236) )
        {
          v15 = *(_WORD *)(dword_D41A0 + 14);
          if ( (unsigned __int8)++byte_180558 >= (int)v15 )
            byte_180558 = 1;
          ++v14;
        }
        if ( !*(_BYTE *)(dword_D41A0 + 2124 * (unsigned __int8)byte_180558 + 11236) )
          byte_180558 = 0;
      }
      for ( j = 0; j < 8; ++j )
      {
        if ( *(_BYTE *)(dword_D41A0 + 2124 * j + 11236) == 1 )
        {
          v27 = v11 + 4;
          v26 = v5 + 4;
          if ( j == v25 )
          {
            sub_2BB40(v11, v5, dword_EA3DC + 516);
            sub_2BC80(
              v27,
              v26,
              *(unsigned __int8 *)(dword_EA3DC + 520) - 8,
              *(unsigned __int8 *)(dword_EA3DC + 521) - 8,
              byte_E8900[0]);
          }
          else
          {
            v29 = byte_E88E1[3 * sub_61790(j)];
            v30 = byte_E88E0[3 * sub_61790(j)];
            sub_2BB40(v11, v5, dword_EA3DC + 516);
            sub_2BC80(
              v27,
              v26,
              *(unsigned __int8 *)(dword_EA3DC + 520) - 8,
              *(unsigned __int8 *)(dword_EA3DC + 521) - 8,
              v30);
            sprintf(v21, "%03d", *(__int16 *)(*(_DWORD *)(v23 + 164) + 2 * j + 38));
            sub_2BC10(v21, v11 + 8, v5 + 10, v29);
            if ( *(_BYTE *)(dword_D41A4 + 10) && byte_180558 && !v25 && j == (unsigned __int8)byte_180558 )
            {
              word_18054A = v11 + 20;
              word_18054C = v5 + 20;
            }
          }
          HIWORD(v17) = HIWORD(dword_EA3DC);
          LOWORD(v17) = *(unsigned __int8 *)(dword_EA3DC + 520);
          v11 += v17;
        }
      }
      HIWORD(v18) = HIWORD(dword_EA3DC);
      LOWORD(v18) = *(unsigned __int8 *)(dword_EA3DC + 515);
      v5 += v18;
    }
    ++v25;
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D419D: using guessed type char byte_D419D;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// 180532: using guessed type int dword_180532;
// 180546: using guessed type __int16 word_180546;
// 180548: using guessed type __int16 word_180548;
// 18054A: using guessed type __int16 word_18054A;
// 18054C: using guessed type __int16 word_18054C;
// 180558: using guessed type char byte_180558;
// 180660: using guessed type __int16 word_180660;

//----- (0002D710) --------------------------------------------------------
int __cdecl sub_2D710(int a1)
{
  __int16 v1; // bx
  _DWORD *v2; // ecx
  int v3; // ecx
  int v4; // edx
  int v5; // eax
  __int64 v6; // rtt
  __int16 v7; // bx
  unsigned int v8; // eax
  __int16 v9; // bx
  __int16 v10; // bx
  unsigned __int8 v12; // [esp-4h] [ebp-4Ch]
  int v13; // [esp+0h] [ebp-48h]
  int v14; // [esp+8h] [ebp-40h]
  unsigned int v15; // [esp+Ch] [ebp-3Ch]
  int v16; // [esp+10h] [ebp-38h]
  __int16 v17; // [esp+1Ch] [ebp-2Ch]
  __int16 v18; // [esp+24h] [ebp-24h]
  unsigned int v19; // [esp+28h] [ebp-20h]
  __int16 v20; // [esp+2Ch] [ebp-1Ch]
  __int16 v21; // [esp+30h] [ebp-18h]
  unsigned __int8 v22; // [esp+34h] [ebp-14h]
  unsigned __int8 v23; // [esp+3Ch] [ebp-Ch]
  unsigned __int8 v24; // [esp+40h] [ebp-8h]

  v24 = byte_E88E0[3 * sub_61790(*(__int16 *)(*(_DWORD *)(a1 + 164) + 56))];
  v23 = byte_E88E1[3 * sub_61790(*(__int16 *)(*(_DWORD *)(a1 + 164) + 56))];
  v22 = byte_E88E0[3 * sub_61790(*(__int16 *)(*(_DWORD *)(a1 + 164) + 56)) + *(unsigned __int8 *)(dword_D41A4 + 123)];
  dword_F01E8(2, 2, dword_EA3DC + 240);
  v1 = *(unsigned __int8 *)(dword_EA3DC + 244) + 2;
  v14 = *(_DWORD *)(dword_D41A4 + 246);
  v16 = *(_DWORD *)(a1 + 164);
  v2 = (_DWORD *)dword_EA3E4[*(unsigned __int16 *)(v16 + 58)];
  v19 = (unsigned int)v2;
  if ( (unsigned int)v2 > dword_EA3E4[0] && v2[4] )
  {
    if ( *(char *)(v16 + 405) > 0 && *(_BYTE *)(dword_D41A4 + 122) )
    {
      dword_F01E8(v1, 2, dword_EA3DC + 330);
      --*(_BYTE *)(*(_DWORD *)(a1 + 164) + 405);
    }
    else
    {
      dword_F01E8(v1, 2, dword_EA3DC + 246);
    }
    sub_2BB40(v1 + 2, 2, 6 * (v2[4] + 43) + dword_EA3DC);
    sub_2BB40(v1 + 38, 2, dword_EA3DC + 252);
    v18 = v1 + 58;
    sub_2D190(v1 + 58, 10, 64, 10, (v2[2] << 6) / v2[1], 0x7Bu);
    v13 = (v2[36] + *(_DWORD *)(*(_DWORD *)(a1 + 164) + 316)) << 6;
    if ( v2[36] + *(_DWORD *)(*(_DWORD *)(a1 + 164) + 316) == v2[35] )
    {
      if ( *(_BYTE *)(dword_D41A4 + 123) == 1 )
      {
        v3 = v14;
        v4 = *(_DWORD *)(v19 + 140) << 6;
        v12 = v23;
        v5 = v4;
      }
      else
      {
        v12 = v24;
        v5 = (v2[36] + *(_DWORD *)(*(_DWORD *)(a1 + 164) + 316)) << 6;
        v4 = v5;
        v3 = v14;
      }
    }
    else
    {
      sub_2D190(v18, 28, 64, 10, (v2[35] << 6) / v14, v23);
      v12 = v24;
      v5 = v13;
      v4 = v13;
      v3 = v14;
    }
    LODWORD(v6) = v5;
    HIDWORD(v6) = v4 >> 31;
    sub_2D190(v18, 28, 64, 10, v6 / v3, v12);
    if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) == 0 && *(_WORD *)((char *)&loc_2FED5 + dword_D41A0) )
    {
      sub_2BC80(v18 + (*(unsigned __int16 *)((char *)&loc_2FED5 + dword_D41A0) << 6) / 100, 26, 2, 2, v22);
      sub_2BC80(v18 + (*(unsigned __int16 *)((char *)&loc_2FED5 + dword_D41A0) << 6) / 100, 38, 2, 2, v22);
    }
  }
  else
  {
    dword_F01E8(v1, 2, dword_EA3DC + 324);
  }
  v7 = *(unsigned __int8 *)(dword_EA3DC + 250) + v1;
  if ( dword_EA3E4[0] >= v19 )
  {
    dword_F01E8(v7, 2, dword_EA3DC + 324);
  }
  else
  {
    if ( *(char *)(*(_DWORD *)(a1 + 164) + 407) > 0 && *(_BYTE *)(dword_D41A4 + 122) )
    {
      dword_F01E8(v7, 2, dword_EA3DC + 330);
      --*(_BYTE *)(*(_DWORD *)(a1 + 164) + 407);
    }
    else
    {
      dword_F01E8(v7, 2, dword_EA3DC + 246);
    }
    switch ( *(_DWORD *)(v19 + 16) )
    {
      case 1:
      case 2:
      case 3:
        v21 = 1;
        break;
      case 4:
      case 5:
        v21 = 2;
        break;
      case 6:
      case 7:
        v21 = 3;
        break;
      default:
        v21 = 0;
        break;
    }
    sub_2BB40(v7 + 2, 2, 6 * (v21 + 50) + dword_EA3DC);
    v20 = 0;
    sub_2BB40(v7 + 38, 2, dword_EA3DC + 252);
    if ( v21 > 0 )
    {
      do
      {
        v17 = v7 + 58;
        v8 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 2 * v20 + 60)];
        v15 = v8;
        if ( v8 > dword_EA3E4[0] )
        {
          if ( *(int *)(v8 + 8) >= 0 )
            sub_2D190(v17, 2 * v20 + 12, 64, 2, (*(_DWORD *)(v8 + 8) << 6) / *(_DWORD *)(v8 + 4), 0x7Bu);
          sub_2D190(v17, 2 * v20 + 30, 64, 2, (*(_DWORD *)(v15 + 144) << 6) / *(_DWORD *)(v15 + 140), v24);
        }
        ++v20;
      }
      while ( v20 < v21 );
    }
  }
  v9 = *(unsigned __int8 *)(dword_EA3DC + 250) + v7;
  if ( *(char *)(*(_DWORD *)(a1 + 164) + 406) > 0 && *(_BYTE *)(dword_D41A4 + 122) )
  {
    dword_F01E8(v9, 2, dword_EA3DC + 330);
    --*(_BYTE *)(*(_DWORD *)(a1 + 164) + 406);
  }
  else
  {
    dword_F01E8(v9, 2, dword_EA3DC + 246);
  }
  if ( ((*(_BYTE *)(a1 + 12) & 0x20) != 0 || *(_WORD *)(*(_DWORD *)(a1 + 164) + 345)) && *(_BYTE *)(dword_D41A4 + 123) )
  {
    sub_2DE80(v9 + 2, 2, dword_EA3DC + 258);
    sub_2DE80(v9 + 38, 2, dword_EA3DC + 252);
  }
  else
  {
    sub_2BB40(v9 + 2, 2, dword_EA3DC + 258);
    sub_2BB40(v9 + 38, 2, dword_EA3DC + 252);
  }
  v10 = v9 + 58;
  sub_2D190(v10, 10, 64, 10, (*(_DWORD *)(a1 + 8) << 6) / *(_DWORD *)(a1 + 4), 0x7Bu);
  sub_2D190(v10, 28, 64, 10, (*(_DWORD *)(a1 + 140) << 6) / v14, v23);
  return sub_2D190(v10, 28, 64, 10, (*(_DWORD *)(a1 + 144) << 6) / v14, v24);
}
// 2DA68: conditional instruction was optimized away because %var_4.1==0
// 2DC94: conditional instruction was optimized away because %var_4.1==0
// 2DD19: conditional instruction was optimized away because %var_4.1==0
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// F01E8: using guessed type int (__cdecl *dword_F01E8)(_DWORD, _DWORD, _DWORD);

//----- (0002DE80) --------------------------------------------------------
char __cdecl sub_2DE80(__int16 a1, __int16 a2, int a3)
{
  int v3; // ebx
  int v4; // eax
  _BYTE *v5; // edi
  _BYTE *v6; // edx
  _BYTE *v7; // esi
  int v8; // ecx
  __int16 v9; // bx
  _BYTE *v10; // edi
  _BYTE *v11; // edx
  _BYTE *v12; // esi
  int v13; // ecx
  int v15; // [esp+0h] [ebp-Ch]
  int v16; // [esp+0h] [ebp-Ch]
  _BYTE *v17; // [esp+4h] [ebp-8h]
  _BYTE *i; // [esp+8h] [ebp-4h]

  if ( word_180660 == 1 )
  {
    v3 = (int)*(unsigned __int8 *)(a3 + 5) >> 1;
    v4 = a2 / 2 * dword_18062C + a1 / 2;
    v5 = (_BYTE *)(v4 + dword_180628);
    v6 = *(_BYTE **)a3;
    for ( i = (_BYTE *)(v4 + dword_180628); (_WORD)v3; v5 = i )
    {
      while ( 1 )
      {
        LOBYTE(v4) = *v6++;
        if ( !(_BYTE)v4 )
          break;
        if ( (v4 & 0x80u) == 0 )
        {
          v7 = v6;
          v8 = (char)v4;
          v15 = (char)v4;
          HIWORD(v4) = 0;
          do
          {
            LOBYTE(v4) = *v7++;
            BYTE1(v4) = *v5;
            *v5++ = byte_FAEE0[v4];
            --v8;
          }
          while ( v8 );
          v6 += v15;
        }
        else
        {
          v5 -= (char)v4;
        }
      }
      LOWORD(v3) = v3 - 1;
      i += dword_18062C;
    }
  }
  else
  {
    v4 = a1 + dword_18062C * a2;
    v9 = *(unsigned __int8 *)(a3 + 5);
    v10 = (_BYTE *)(v4 + dword_180628);
    v11 = *(_BYTE **)a3;
    v17 = (_BYTE *)(v4 + dword_180628);
    if ( *(_BYTE *)(a3 + 5) )
    {
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            LOBYTE(v4) = *v11++;
            if ( (_BYTE)v4 )
              break;
            --v9;
            v17 += dword_18062C;
            v10 = v17;
            if ( !v9 )
              return v4;
          }
          if ( (v4 & 0x80u) == 0 )
            break;
          v10 -= (char)v4;
          if ( !v9 )
            return v4;
        }
        v12 = v11;
        v13 = (char)v4;
        v16 = (char)v4;
        HIWORD(v4) = 0;
        do
        {
          LOBYTE(v4) = *v12++;
          BYTE1(v4) = *v10;
          LOBYTE(v4) = byte_FAEE0[v4];
          *v10++ = v4;
          --v13;
        }
        while ( v13 );
        v11 += v16;
      }
      while ( v9 );
    }
  }
  return v4;
}
// 2DF16: conditional instruction was optimized away because bx.2!=0
// 2DF3D: conditional instruction was optimized away because bx.2!=0
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (0002DFD0) --------------------------------------------------------
char __cdecl sub_2DFD0(__int16 a1, __int16 a2, int a3, unsigned __int8 a4)
{
  int v4; // eax
  _BYTE *v5; // edi
  char *v6; // edx
  char v7; // al
  int v8; // ebx
  int v9; // ecx
  _BYTE *v10; // edi
  char *v11; // edx
  int v12; // ebx
  int v13; // ecx
  int v15; // [esp+0h] [ebp-14h]
  _BYTE *i; // [esp+4h] [ebp-10h]
  _BYTE *v17; // [esp+8h] [ebp-Ch]
  __int16 v18; // [esp+Ch] [ebp-8h]
  int v19; // [esp+10h] [ebp-4h]

  if ( word_180660 == 1 )
  {
    v19 = (int)*(unsigned __int8 *)(a3 + 5) >> 1;
    v4 = a2 / 2 * dword_18062C + a1 / 2;
    v5 = (_BYTE *)(v4 + dword_180628);
    v6 = *(char **)a3;
    for ( i = (_BYTE *)(v4 + dword_180628); (_WORD)v19; --v19 )
    {
      while ( 1 )
      {
        v7 = *v6++;
        if ( !v7 )
          break;
        if ( v7 >= 0 )
        {
          v8 = a4;
          v9 = v7;
          do
          {
            BYTE1(v8) = *v5;
            *v5++ = byte_FAEE0[v8];
            --v9;
          }
          while ( v9 );
          v6 += v7;
        }
        else
        {
          v5 -= v7;
        }
      }
      LOBYTE(v4) = dword_18062C;
      i += dword_18062C;
      v5 = i;
    }
  }
  else
  {
    v18 = *(unsigned __int8 *)(a3 + 5);
    LOBYTE(v4) = dword_180628;
    v10 = (_BYTE *)(dword_180628 + a1 + dword_18062C * a2);
    v11 = *(char **)a3;
    v17 = v10;
    if ( *(_BYTE *)(a3 + 5) )
    {
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            LOBYTE(v4) = *v11++;
            if ( (_BYTE)v4 )
              break;
            LOBYTE(v4) = dword_18062C;
            v10 = &v17[dword_18062C];
            v17 += dword_18062C;
            if ( !--v18 )
              return v4;
          }
          if ( (v4 & 0x80u) == 0 )
            break;
          v10 -= (char)v4;
          if ( !v18 )
            return v4;
        }
        v12 = a4;
        v13 = (char)v4;
        v15 = (char)v4;
        do
        {
          BYTE1(v12) = *v10;
          LOBYTE(v4) = byte_FAEE0[v12];
          *v10++ = v4;
          --v13;
        }
        while ( v13 );
        v11 += v15;
      }
      while ( v18 );
    }
  }
  return v4;
}
// 2E070: conditional instruction was optimized away because %var_4.2!=0
// 2E09B: conditional instruction was optimized away because %var_4.2!=0
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (0002E260) --------------------------------------------------------
void __cdecl sub_2E260(__int16 a1, __int16 a2, unsigned int a3, char a4)
{
  unsigned int v4; // eax
  __int16 v5; // cx
  int v6; // eax
  int v7; // eax
  int v8; // edi
  unsigned __int16 v9; // di
  unsigned __int8 v10; // al
  int i; // [esp+0h] [ebp-14h]
  int j; // [esp+4h] [ebp-10h]
  unsigned int v13; // [esp+8h] [ebp-Ch]
  unsigned __int8 v14; // [esp+Ch] [ebp-8h]
  unsigned __int8 v15; // [esp+10h] [ebp-4h]

  if ( a3 > dword_EA3E4[0] )
  {
    sub_6FC50(byte_D419D);
    v4 = dword_EA3E4[*(unsigned __int16 *)(a3 + 40)];
    v13 = v4;
    if ( v4 > dword_EA3E4[0] )
    {
      v15 = byte_E88E0[3 * sub_61790(*(__int16 *)(*(_DWORD *)(v4 + 164) + 56))];
      v14 = byte_E88E1[3 * sub_61790(*(__int16 *)(*(_DWORD *)(v13 + 164) + 56))];
      if ( (byte_DA819[80 * *(char *)(a3 + 64)] & 4) == 0
        || (v5 = *(_WORD *)(a3 + 46), v5 <= 0)
        || v5 >= 32
        || !*(_BYTE *)(dword_D41A4 + 122) )
      {
        if ( a4 )
        {
          if ( *(_WORD *)(a3 + 46) )
            v6 = dword_EA3DC + 12;
          else
            v6 = dword_EA3DC + 6;
          sub_2BB40(a1, a2, v6);
        }
        else
        {
          if ( *(_WORD *)(a3 + 46) )
            v7 = dword_EA3DC + 12;
          else
            v7 = dword_EA3DC + 6;
          dword_F01E8(a1, a2, v7);
        }
        sub_2BB40(a1, a2, 6 * (*(char *)(a3 + 64) + 123) + dword_EA3DC);
        sub_2BC10(
          *(&off_DB06C + *(char *)(a3 + 70)),
          *(unsigned __int8 *)(dword_EA3DC + 10) + a1 - 8 * strlen((const char *)*(&off_DB06C + *(char *)(a3 + 70))) - 2,
          a2,
          byte_E8900[0]);
        if ( *(_DWORD *)(a3 + 140) )
        {
          sub_2BC80(
            a1 + 4,
            a2 + 36,
            56 * (*(_DWORD *)(v13 + 144) % *(_DWORD *)(a3 + 140)) / *(_DWORD *)(a3 + 140),
            4,
            v14);
          v8 = *(_DWORD *)(v13 + 144) / *(_DWORD *)(a3 + 140);
          for ( i = 0; i < 27 && v8; ++i )
          {
            for ( j = 0; j < 2 && v8; ++j )
            {
              sub_2BC80(a1 + 2 * (i + 2), a2 + 2 * (j + 18), 2, 2, v15);
              --v8;
            }
          }
        }
        if ( *(_DWORD *)(a3 + 136) )
        {
          v9 = *(_WORD *)(*(_DWORD *)(v13 + 164) + 58);
          if ( !v9 || *(_DWORD *)(a3 + 136) > *(_DWORD *)(dword_EA3E4[v9] + 144) )
          {
            if ( *((_BYTE *)&loc_2FED1 + dword_D41A0 + 3) )
              v10 = 16;
            else
              v10 = 48;
            sub_2E850(a1, a2, *(unsigned __int8 *)(dword_EA3DC + 10), *(unsigned __int8 *)(dword_EA3DC + 11), v10);
          }
        }
      }
    }
  }
}
// D419D: using guessed type char byte_D419D;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// DB06C: using guessed type void *off_DB06C;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// F01E8: using guessed type int (__cdecl *dword_F01E8)(_DWORD, _DWORD, _DWORD);

//----- (0002E790) --------------------------------------------------------
int __cdecl sub_2E790(__int16 a1, int a2, __int16 a3, __int16 a4, unsigned __int8 a5)
{
  __int16 v5; // bx
  int v6; // ecx
  int v7; // eax
  int result; // eax
  __int16 i; // si
  int v10; // [esp+Ch] [ebp-4h]

  v5 = a1;
  v6 = a2;
  if ( word_180660 == 1 )
  {
    v5 = a1 / 2;
    HIWORD(v7) = HIWORD(a2);
    LOWORD(v7) = (__int16)a2 / 2;
    v6 = v7;
    a3 /= 2;
    a4 /= 2;
  }
  for ( result = v6; (__int16)result < (__int16)v6 + a4; ++result )
  {
    for ( i = v5; ; ++i )
    {
      v10 = i;
      if ( a3 + v5 <= i )
        break;
      *(_BYTE *)(dword_180628 + dword_18062C * (__int16)result + v10) = byte_FAEE0[256 * a5
                                                                                 + *(unsigned __int8 *)(dword_180628 + dword_18062C * (__int16)result + v10)];
    }
  }
  return result;
}
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (0002E850) --------------------------------------------------------
int __cdecl sub_2E850(__int16 a1, int a2, __int16 a3, __int16 a4, unsigned __int8 a5)
{
  __int16 v5; // bx
  int v6; // ecx
  int v7; // eax
  int result; // eax
  __int16 i; // si
  int v10; // [esp+Ch] [ebp-4h]

  v5 = a1;
  v6 = a2;
  if ( word_180660 == 1 )
  {
    v5 = a1 / 2;
    HIWORD(v7) = HIWORD(a2);
    LOWORD(v7) = (__int16)a2 / 2;
    v6 = v7;
    a3 /= 2;
    a4 /= 2;
  }
  for ( result = v6; (__int16)result < (__int16)v6 + a4; ++result )
  {
    for ( i = v5; ; ++i )
    {
      v10 = i;
      if ( a3 + v5 <= i )
        break;
      *(_BYTE *)(dword_180628 + dword_18062C * (__int16)result + v10) = byte_F6EE0[256 * a5
                                                                                 + *(unsigned __int8 *)(dword_180628 + dword_18062C * (__int16)result + v10)];
    }
  }
  return result;
}
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (0002EB40) --------------------------------------------------------
int sub_2EB40()
{
  int result; // eax

  BYTE1(result) = 0;
  byte_D41CE = 0;
  byte_D41C1 = 0;
  dword_D41D0 = 0;
  return result;
}
// D41C1: using guessed type char byte_D41C1;
// D41CE: using guessed type char byte_D41CE;
// D41D0: using guessed type int dword_D41D0;

//----- (0002EB60) --------------------------------------------------------
int sub_2EB60()
{
  int result; // eax

  if ( !byte_D41CE )
  {
    byte_D41CE = 1;
    byte_D41C1 = 1;
    dword_F01E4 = dword_180628 + 64320;
    word_F01F4 = 12800;
    result = sub_2EC30();
    dword_D41D0 = 0;
  }
  return result;
}
// D41C1: using guessed type char byte_D41C1;
// D41CE: using guessed type char byte_D41CE;
// D41D0: using guessed type int dword_D41D0;
// F01E4: using guessed type int dword_F01E4;
// F01F4: using guessed type __int16 word_F01F4;
// 180628: using guessed type int dword_180628;

//----- (0002EBB0) --------------------------------------------------------
int __cdecl sub_2EBB0(_BYTE *a1)
{
  int result; // eax

  if ( byte_D41CE )
  {
    dword_D41D0 = (int)a1;
    word_E36D4 = 64;
    dword_180628 += 9920;
    result = sub_7FCB0(64, a1, 0, 630, 340, 5, byte_EB3B6, 0);
    word_E36D4 = 0;
    dword_180628 -= 9920;
  }
  return result;
}
// D41CE: using guessed type char byte_D41CE;
// D41D0: using guessed type int dword_D41D0;
// E36D4: using guessed type __int16 word_E36D4;
// EB3B6: using guessed type char byte_EB3B6;
// 180628: using guessed type int dword_180628;

//----- (0002EC30) --------------------------------------------------------
int sub_2EC30()
{
  int result; // eax

  if ( byte_D41CE )
    return memset(dword_F01E4, 0, (unsigned __int16)word_F01F4);
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41CE: using guessed type char byte_D41CE;
// F01E4: using guessed type int dword_F01E4;
// F01F4: using guessed type __int16 word_F01F4;

//----- (0002EC60) --------------------------------------------------------
int sub_2EC60()
{
  int result; // eax

  if ( byte_D41CE )
  {
    result = sub_2EC30();
    byte_D41C1 = 0;
    byte_D41CE = 0;
    dword_D41D0 = 0;
  }
  return result;
}
// D41C1: using guessed type char byte_D41C1;
// D41CE: using guessed type char byte_D41CE;
// D41D0: using guessed type int dword_D41D0;

//----- (0002EC90) --------------------------------------------------------
char __cdecl sub_2EC90(char a1)
{
  char result; // al

  if ( byte_D41CE )
  {
    result = a1;
    byte_EB3B6 = a1;
    if ( dword_D41D0 )
      return sub_2EBB0((_BYTE *)dword_D41D0);
  }
  return result;
}
// D41CE: using guessed type char byte_D41CE;
// D41D0: using guessed type int dword_D41D0;
// EB3B6: using guessed type char byte_EB3B6;

//----- (0002ECC0) --------------------------------------------------------
__int16 sub_2ECC0()
{
  int v0; // eax
  char v1; // dh
  __int16 v2; // ax
  __int16 v3; // si
  __int16 v4; // di
  __int16 i; // bx
  char v6; // dl
  unsigned int v7; // edx
  __int16 v8; // ax
  __int16 v9; // ax
  unsigned __int16 v10; // dx
  int v11; // eax
  unsigned __int8 v12; // al
  int v13; // eax
  int v14; // eax
  unsigned __int8 v15; // dl
  __int16 v16; // cx
  int v17; // esi
  __int16 v18; // bx
  char *v19; // edi
  int v20; // eax
  unsigned __int16 v21; // cx
  __int16 v22; // ax
  __int16 v23; // cx
  __int16 v24; // ax
  int v25; // ecx
  int v26; // edx
  int v27; // ecx
  int v28; // edi
  __int16 result; // ax
  int v30; // [esp+4h] [ebp-6Ch]
  int v31; // [esp+Ch] [ebp-64h]
  int v32; // [esp+10h] [ebp-60h]
  unsigned int v33; // [esp+14h] [ebp-5Ch]
  int j; // [esp+18h] [ebp-58h]
  char *v35; // [esp+24h] [ebp-4Ch]
  int k; // [esp+28h] [ebp-48h]
  __int16 v37; // [esp+2Ch] [ebp-44h]
  __int16 v38; // [esp+34h] [ebp-3Ch]
  __int16 v39; // [esp+38h] [ebp-38h]
  __int16 v40; // [esp+38h] [ebp-38h]
  __int16 v41; // [esp+3Ch] [ebp-34h]
  unsigned __int8 v42; // [esp+40h] [ebp-30h]
  __int16 v43; // [esp+40h] [ebp-30h]
  __int16 v44; // [esp+44h] [ebp-2Ch]
  __int16 v45; // [esp+48h] [ebp-28h]
  __int16 v46; // [esp+4Ch] [ebp-24h]
  __int16 v47; // [esp+50h] [ebp-20h]
  __int16 v48; // [esp+54h] [ebp-1Ch]
  __int16 v49; // [esp+58h] [ebp-18h]
  __int16 v50; // [esp+5Ch] [ebp-14h]
  char v51; // [esp+60h] [ebp-10h]
  unsigned __int8 v52; // [esp+64h] [ebp-Ch]
  unsigned __int8 v53; // [esp+68h] [ebp-8h]
  char v54; // [esp+6Ch] [ebp-4h]

  v33 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v0 = *(_DWORD *)(v33 + 164);
  v32 = v0 + 611;
  v53 = byte_E88E0[3 * sub_61790(*(__int16 *)(v0 + 56))];
  v52 = byte_E88E1[3 * sub_61790(*(__int16 *)(*(_DWORD *)(v33 + 164) + 56))];
  v1 = word_180660;
  *(_BYTE *)(dword_D41A4 + 50) = -1;
  if ( (v1 & 1) != 0 )
    v2 = 400;
  else
    v2 = 480;
  v37 = *(unsigned __int8 *)(dword_EA3DC + 532);
  v44 = *(unsigned __int8 *)(dword_EA3DC + 539);
  v47 = v2 - 2 * v44;
  v38 = *(unsigned __int8 *)(dword_EA3DC + 538);
  v45 = 0;
  v50 = 0;
  v41 = v38 - *(unsigned __int8 *)(dword_EA3DC + 898);
  v3 = v47;
  while ( v45 < 2 )
  {
    if ( !v45 )
      dword_F01E8(0, v3, dword_EA3DC + 528);
    v4 = v37;
    for ( i = 0; i < 13; ++i )
    {
      v39 = (unsigned __int8)byte_D94FF[v50];
      v6 = 1;
      if ( !byte_DA818[80 * (unsigned __int8)byte_D94FF[v50]] || !byte_D41B6 && v39 == 25 )
        v6 = 0;
      if ( !v6 )
      {
        dword_F01E8(v4, v3, dword_EA3DC + 534);
        goto LABEL_53;
      }
      v7 = dword_EA3E4[*(__int16 *)(*(_DWORD *)(v33 + 164) + 2 * (unsigned __int8)byte_D94FF[v50] + 819)];
      if ( v7 > dword_EA3E4[0] )
      {
        if ( v50 == *(char *)(v32 + 501) )
        {
          *(_BYTE *)(dword_D41A4 + 50) = v50;
          v8 = *(char *)(v32 + 502);
        }
        else
        {
          v8 = *(char *)((unsigned __int8)byte_D94FF[v50] + v32 + 468);
        }
        v42 = v8;
        v35 = &byte_DA818[80 * v39 + 2 + 26 * v8];
        if ( (byte_DA819[80 * *(char *)(v7 + 64)] & 4) != 0 )
        {
          v9 = *(_WORD *)(v7 + 46);
          if ( v9 > 0 && v9 < 32 && *(_BYTE *)(dword_D41A4 + 122) )
            goto LABEL_43;
        }
        v51 = 0;
        if ( !*((_DWORD *)v35 + 2)
          || (v10 = *(_WORD *)(*(_DWORD *)(v33 + 164) + 58)) != 0
          && *((_DWORD *)v35 + 2) <= *(_DWORD *)(dword_EA3E4[v10] + 144) )
        {
          v51 = 1;
        }
        if ( v51 )
        {
          if ( *(char *)(dword_D41A4 + 50) == v50 )
          {
            v31 = sub_6D710(v33, v39, v42);
            if ( v31 > 0 )
            {
              sub_2BB40(v4, v3, dword_EA3DC + 522);
              sub_2BC80(v4 + 6, v3 + 28, 36 * (*(_DWORD *)(v33 + 144) % v31) / v31, 4, v52);
              v30 = *(_DWORD *)(v33 + 144) / v31;
              for ( j = 0; j < 36 && v30 > 0; j += 2 )
              {
                for ( k = 0; k < 4 && v30 > 0; k += 2 )
                {
                  sub_2BC80(j + v4 + 6, k + v3 + 28, 2, 2, v53);
                  --v30;
                }
              }
            }
LABEL_40:
            if ( v51 )
              sub_2BB40(v4, v3, dword_EA3DC + 6 * (v39 + 97));
            else
              sub_2DE80(v4, v3, 6 * (v39 + 97) + dword_EA3DC);
LABEL_43:
            v12 = *(_BYTE *)(v32 + v39 + 338);
            if ( v12 )
            {
              if ( v12 <= 1u )
              {
                sub_2DE80(v4, v3, dword_EA3DC + 894);
              }
              else if ( v12 == 2 )
              {
                sub_2DE80(v4 + v41, v3, dword_EA3DC + 900);
              }
            }
            goto LABEL_53;
          }
          v11 = dword_EA3DC + 534;
        }
        else
        {
          v11 = dword_EA3DC + 546;
        }
        dword_F01E8(v4, v3, v11);
        goto LABEL_40;
      }
      dword_F01E8(v4, v3, dword_EA3DC + 534);
      v13 = v39 + *(_DWORD *)(v33 + 164);
      if ( *(_BYTE *)(v13 + 1001) || *(_BYTE *)(v13 + 1027) )
        sub_2DFD0(v4, v3, dword_EA3DC + 6 * (v39 + 97), 0xA6u);
LABEL_53:
      v4 += v38;
      ++v50;
    }
    if ( !v45 )
      dword_F01E8(v4, v3, dword_EA3DC + 528);
    v3 += *(unsigned __int8 *)(dword_EA3DC + 539);
    ++v45;
  }
  sub_2BB40(v37 + v38 * (*(char *)(v32 + 501) % 13), *(char *)(v32 + 501) / 13 * v44 + v47, dword_EA3DC + 540);
  v14 = *(char *)(dword_D41A4 + 50);
  if ( v14 != -1 )
  {
    v15 = byte_D94FF[v14];
    v40 = v15;
    v43 = *(char *)(v32 + v15 + 442);
    v16 = 3 * *(unsigned __int8 *)(dword_EA3DC + 982);
    v46 = v47 - *(unsigned __int8 *)(dword_EA3DC + 983);
    v17 = v38 / 2 + v38 * (*(char *)(v32 + 501) % 13) + v37 - v16 / 2;
    if ( (__int16)v17 <= 640 - v16 )
    {
      if ( (v17 & 0x8000u) != 0 )
        LOWORD(v17) = 0;
    }
    else
    {
      LOWORD(v17) = 640 - v16;
    }
    v18 = 0;
    v48 = *(unsigned __int8 *)(dword_EA3DC + 982);
    while ( v18 < 3 )
    {
      v19 = &byte_DA818[80 * v40 + 2 + 26 * v18];
      LOBYTE(v20) = 0;
      v54 = 0;
      if ( !*((_DWORD *)v19 + 2)
        || (v21 = *(_WORD *)(*(_DWORD *)(v33 + 164) + 58)) != 0
        && *((_DWORD *)v19 + 2) <= *(_DWORD *)(dword_EA3E4[v21] + 144) )
      {
        v54 = 1;
        v20 = *(_DWORD *)(v33 + 144) / sub_6D710(v33, v40, v18);
      }
      if ( v18 > v43 )
      {
        sub_2BB40(v17, v46, dword_EA3DC + 978);
      }
      else
      {
        if ( v54 && (_BYTE)v20 )
          v22 = 161;
        else
          v22 = 162;
        sub_2BB40(v17, v46, dword_EA3DC + 6 * v22);
        sub_2BB40(v17 + 6, v46 + 10, dword_EA3DC + 6 * (__int16)(v18 + 165));
        v49 = v17 + 18;
        v23 = v46 + 6;
        v24 = v18 + 3 * v40 + 179;
        if ( v54 )
          sub_2BB40(v49, v23, dword_EA3DC + 6 * v24);
        else
          sub_2DE80(v49, v23, 6 * v24 + dword_EA3DC);
      }
      if ( v18 == *(char *)(v32 + 502) )
        sub_2BB40(v17, v46, dword_EA3DC + 984);
      if ( v18 <= v43 && v18 < 2 )
      {
        if ( v18 == v43 )
        {
          if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
          {
            v25 = *(_DWORD *)(v19 + 42);
            v26 = *((_DWORD *)v19 + 4);
          }
          else
          {
            v25 = *(_DWORD *)(v19 + 38);
            v26 = *((_DWORD *)v19 + 3);
          }
          v27 = v25 - v26;
          if ( v27 > 0 )
          {
            v28 = 54 * (*(_DWORD *)(4 * v40 + v32) + *(_DWORD *)(4 * v40 + v32 + 104) - v26) / v27;
            goto LABEL_91;
          }
LABEL_90:
          LOWORD(v28) = 0;
        }
        else
        {
          if ( v18 >= v43 )
            goto LABEL_90;
          LOWORD(v28) = 54;
        }
LABEL_91:
        if ( (v28 & 0x8000u) != 0 )
          LOWORD(v28) = 0;
        if ( (__int16)v28 > 54 )
          LOWORD(v28) = 54;
        sub_2BC80(v17 + 6, v46 + 28, 54, 2, byte_E8900[0]);
        if ( (_WORD)v28 )
          sub_2BC80(v17 + 6, v46 + 28, v28, 2, byte_E9800);
      }
      ++v18;
      LOWORD(v17) = v48 + v17;
      continue;
    }
  }
  result = word_1805C2;
  if ( word_1805C2 == 8
    || word_1805C2 == 12
    || word_1805C2 == 13
    || word_1805C2 == 4
    || word_1805C2 == 6
    || word_1805C2 == 11
    || word_1805C2 == 5 )
  {
    return sub_2BB40(dword_1805B0, dword_1805B4, dword_EB394 + 6 * (unsigned __int8)byte_D419E);
  }
  return result;
}
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// E9800: using guessed type char byte_E9800;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// EB394: using guessed type int dword_EB394;
// F01E8: using guessed type int (__cdecl *dword_F01E8)(_DWORD, _DWORD, _DWORD);
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;
// 180660: using guessed type __int16 word_180660;

//----- (0002F6B0) --------------------------------------------------------
int sub_2F6B0()
{
  int v0; // eax
  int v1; // eax
  unsigned __int8 v2; // dl
  unsigned __int8 v3; // dh
  unsigned __int8 v4; // al
  __int16 v5; // si
  __int16 v6; // bx
  __int16 v7; // di
  __int16 v8; // bx
  __int16 v9; // si
  unsigned __int8 v10; // al
  __int16 v11; // si
  __int16 v12; // bx
  __int16 v13; // si
  __int16 v14; // bx
  int v15; // eax
  __int16 v16; // bx
  __int16 v17; // si
  int v18; // eax
  __int16 v19; // ax
  int v20; // ebx
  int v21; // esi
  char v22; // al
  int v23; // eax
  __int16 v24; // si
  __int16 v25; // bx
  __int16 v26; // si
  unsigned __int8 v27; // di
  int result; // eax
  __int16 v29; // [esp-14h] [ebp-22h]
  __int16 v30; // [esp-10h] [ebp-1Eh]
  char v31[72]; // [esp+0h] [ebp-Eh] BYREF
  int v32; // [esp+48h] [ebp+3Ah]
  int v33; // [esp+4Ch] [ebp+3Eh]
  int v34; // [esp+50h] [ebp+42h]
  int v35; // [esp+54h] [ebp+46h]
  int v36; // [esp+58h] [ebp+4Ah]
  int v37; // [esp+5Ch] [ebp+4Eh]
  int v38; // [esp+60h] [ebp+52h]
  _BYTE *v39; // [esp+64h] [ebp+56h]
  unsigned __int8 v40; // [esp+68h] [ebp+5Ah]
  unsigned __int8 v41; // [esp+6Ch] [ebp+5Eh]
  unsigned __int8 v42; // [esp+70h] [ebp+62h]
  unsigned __int8 v43; // [esp+74h] [ebp+66h]
  unsigned __int8 v44; // [esp+78h] [ebp+6Ah]
  unsigned __int8 v45; // [esp+7Ch] [ebp+6Eh]
  unsigned __int8 v46; // [esp+80h] [ebp+72h]
  unsigned __int8 v47; // [esp+84h] [ebp+76h]
  _BOOL1 v48; // [esp+88h] [ebp+7Ah]
  char v49; // [esp+8Ch] [ebp+7Eh]

  v39 = (_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230);
  if ( (word_180660 & 1) != 0 )
    v0 = 400;
  else
    v0 = 480;
  v38 = v0 - 72;
  v34 = 0;
  v1 = 5 * *((unsigned __int8 *)&loc_2FED1 + dword_D41A0 + 3);
  v2 = byte_D94F0[v1];
  v45 = byte_D94F1[v1];
  v3 = byte_D94F2[v1];
  v46 = byte_D94F3[v1];
  v40 = byte_E98FF;
  v42 = byte_E8900[0];
  v47 = v3;
  v43 = byte_E89F0;
  v41 = byte_E9800;
  v49 = -1;
  sub_2BC80(0, v38, 640, 72, v2);
  v32 = v3;
  sub_2BC80(0, v38, 640, 2, v3);
  sub_2BC80(0, v38 + 70, 640, 2, v46);
  sub_2BC80(0, v38, 2, 70, v3);
  sub_2BC80(638, v38, 2, 72, v46);
  if ( (__int16)dword_E3760 < 4
    || (__int16)dword_E3760 >= 66
    || SHIWORD(dword_E3760) < v38 + 28
    || SHIWORD(dword_E3760) >= v38 + 66 )
  {
    v4 = v39[992];
  }
  else
  {
    v4 = 4 * ((SHIWORD(dword_E3760) - (v38 + 28)) / 20)
       + (((__int16)dword_E3760
         - 4
         - (__CFSHL__(((__int16)dword_E3760 - 4) >> 31, 4)
          + 16 * (((__int16)dword_E3760 - 4) >> 31))) >> 4);
  }
  v44 = v4;
  v5 = v38 + 4;
  v6 = v34 + 4;
  v7 = v34 + 4;
  v32 = (__int16)(v38 + 4);
  sub_2BC80(v34 + 4, v38 + 4, 372, 20, v45);
  v33 = v46;
  sub_2BC80(v7, v32, 372, 2, v46);
  v36 = v47;
  sub_2BC80(v7, v5 + 18, 372, 2, v47);
  sub_2BC80(v7, v32, 2, 18, v33);
  sub_2BC80(v6 + 370, v32, 2, 20, v36);
  sprintf(v31, "%s", &v39[48 * v44 + 81]);
  v5 += 2;
  v6 += 6;
  sub_2BC10(v31, v6, v5, v40);
  v8 = 8 * strlen(v31) + v6;
  v9 = v5 + 2;
  if ( (*(_BYTE *)(dword_D41A4 + 26) & 8) != 0 )
    v10 = v41;
  else
    v10 = v45;
  v30 = v9;
  v37 = 0;
  v29 = v8;
  v11 = v38;
  v12 = v34;
  sub_2BC80(v29, v30, 6, 12, v10);
  v13 = v11 + 28;
  v14 = v12 + 4;
  while ( v37 < 8 )
  {
    if ( (unsigned __int8)v39[992] == v37 )
      v15 = dword_EA3DC + 930;
    else
      v15 = dword_EA3DC + 948;
    sub_2BB40(v14, v13, v15);
    sprintf(v31, "%d", v37 + 1);
    sub_2BC10(v31, v14 + 4, v13 + 2, v42);
    if ( ++v37 == 4 )
    {
      v14 = 4;
      v13 += 20;
    }
    else
    {
      v14 += 16;
    }
  }
  v37 = 0;
  v16 = v34 + 82;
  v17 = v38 + 32;
  while ( v37 < 4 )
  {
    if ( (unsigned __int8)v39[993] == v37 )
      v18 = dword_EA3DC + 936;
    else
      v18 = dword_EA3DC + 954;
    sub_2BB40(v16, v17, v18);
    switch ( v37 )
    {
      case 0:
        v35 = 154;
        break;
      case 1:
        v35 = 153;
        break;
      case 2:
        v35 = 152;
        break;
      case 3:
        v35 = 151;
        break;
      default:
        break;
    }
    sub_2BB40(v16 + 2, v17 + 2, 6 * v35 + dword_EA3DC);
    if ( ++v37 == 3 )
      v19 = 20;
    else
      v19 = 2;
    v16 += v19 + 68;
  }
  v48 = v39[993] != 3;
  v37 = 0;
  v20 = v34 + 384;
  v21 = v38 + 26;
  while ( v37 < 8 )
  {
    if ( *(__int16 *)(dword_D41A0 + 12) == v37 )
      ++v37;
    v22 = 1;
    if ( !v48 && ((1 << v37) & (unsigned __int8)v39[995]) != 0 )
      v22 = 0;
    if ( v22 )
      v23 = dword_EA3DC + 960;
    else
      v23 = dword_EA3DC + 942;
    sub_2BB40(v20, v21, v23);
    sub_2BB40(v20 + 2, v21 + 2, 6 * (v37 + 74) + dword_EA3DC);
    if ( (__int16)dword_E3760 >= v20
      && (__int16)dword_E3760 < v20 + 32
      && SHIWORD(dword_E3760) >= v21
      && SHIWORD(dword_E3760) < v21 + 22 )
    {
      v49 = v37;
    }
    v20 += 34;
    ++v37;
  }
  v24 = v38 + 4;
  v25 = v34 + 384;
  sub_2BB40(v34 + 384, v38 + 4, dword_EA3DC + 1554);
  sub_2BB40(v34 + 474, v24, dword_EA3DC + 1566);
  sub_2BB40(v34 + 564, v24, dword_EA3DC + 1560);
  v26 = v38 + 50;
  sub_2BC80(v25, v38 + 50, 236, 18, v45);
  v27 = v46;
  sub_2BC80(v25, v26, 236, 2, v46);
  v36 = v47;
  sub_2BC80(v25, v38 + 66, 236, 2, v47);
  sub_2BC80(v25, v26, 2, 16, v27);
  sub_2BC80(v34 + 618, v26, 2, 18, v36);
  result = v49;
  if ( v49 != -1 )
    result = sub_2BC10((_BYTE *)(2124 * v49 + dword_D41A0 + 11230 + 927), v34 + 390, v38 + 52, v43);
  if ( word_1805C2 == 8
    || word_1805C2 == 12
    || word_1805C2 == 13
    || word_1805C2 == 4
    || word_1805C2 == 6
    || word_1805C2 == 11
    || word_1805C2 == 5 )
  {
    return sub_2BB40(dword_1805B0, dword_1805B4, dword_EB394 + 6 * (unsigned __int8)byte_D419E);
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E3760: using guessed type int dword_E3760;
// E89F0: using guessed type char byte_E89F0;
// E9800: using guessed type char byte_E9800;
// E98FF: using guessed type char byte_E98FF;
// EA3DC: using guessed type int dword_EA3DC;
// EB394: using guessed type int dword_EB394;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;
// 180660: using guessed type __int16 word_180660;

//----- (0002FD90) --------------------------------------------------------
char sub_2FD90()
{
  char result; // al
  int i; // ebx
  int j; // ebx
  int k; // ebx
  int v4; // [esp+0h] [ebp-14h] BYREF
  int v5; // [esp+4h] [ebp-10h] BYREF
  int v6; // [esp+8h] [ebp-Ch] BYREF
  int v7; // [esp+Ch] [ebp-8h] BYREF
  unsigned __int8 v8; // [esp+10h] [ebp-4h]

  v8 = byte_E8900[0];
  result = dword_D41A4;
  if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) != 0 )
  {
    if ( !*(_BYTE *)(dword_D41A4 + 206) )
    {
      sub_2FFE0(&v6, &v7, &v5, &v4);
      sub_2BB40(v6, v7, dword_EA3DC + 1044);
      v7 += v4;
      sub_2BB40(v6, v7, dword_EA3DC + 1050);
      if ( !*(_BYTE *)(dword_D41A4 + 208) )
      {
        for ( i = 0; i < 2; ++i )
          sub_2E790(v6, (__int16)v7, v5 - 2, v4, v8);
      }
      v7 += v4;
      sub_2BB40(v6, v7, dword_EA3DC + 1056);
      if ( !byte_E3798 )
      {
        for ( j = 0; j < 2; ++j )
          sub_2E790(
            v6,
            (__int16)v7,
            *(unsigned __int8 *)(dword_EA3DC + 1060),
            *(unsigned __int8 *)(dword_EA3DC + 1061),
            v8);
      }
      sub_2BB40(v6 + *(unsigned __int8 *)(dword_EA3DC + 1060), v7, dword_EA3DC + 1062);
      if ( !byte_E37FC )
      {
        for ( k = 0; k < 2; ++k )
          sub_2E790(
            v6 + *(unsigned __int8 *)(dword_EA3DC + 1060),
            (__int16)v7,
            *(unsigned __int8 *)(dword_EA3DC + 1066),
            *(unsigned __int8 *)(dword_EA3DC + 1067),
            v8);
      }
      v7 += v4;
      sub_2BB40(v6, v7, dword_EA3DC + 1068);
    }
    if ( word_1805C2 == 8
      || word_1805C2 == 12
      || word_1805C2 == 13
      || word_1805C2 == 4
      || word_1805C2 == 6
      || word_1805C2 == 11
      || word_1805C2 == 5 )
    {
      sub_2BB40(dword_1805B0, dword_1805B4, dword_EB394 + 6 * (unsigned __int8)byte_D419E);
    }
    result = dword_D41A4;
    if ( (*(_BYTE *)(dword_D41A4 + 25) & 0x10) != 0 )
      return sub_30870();
  }
  return result;
}
// D419E: using guessed type char byte_D419E;
// D41A4: using guessed type int dword_D41A4;
// E3798: using guessed type char byte_E3798;
// E37FC: using guessed type char byte_E37FC;
// EA3DC: using guessed type int dword_EA3DC;
// EB394: using guessed type int dword_EB394;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (0002FFE0) --------------------------------------------------------
int *__cdecl sub_2FFE0(int *a1, int *a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // eax
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int *result; // eax

  v4 = dword_EA3DC;
  *a3 = *(unsigned __int8 *)(dword_EA3DC + 1048) + 2;
  v5 = *(unsigned __int8 *)(v4 + 1049);
  *a4 = v5;
  v6 = (400 - 4 * v5) / 2 - 60;
  v7 = (640 - *a3) / 2;
  LOBYTE(v7) = v7 & 0xFE;
  *a1 = v7;
  result = a2;
  LOBYTE(v6) = v6 & 0xFE;
  *a2 = v6;
  return result;
}
// EA3DC: using guessed type int dword_EA3DC;

//----- (00030050) --------------------------------------------------------
int sub_30050()
{
  __int64 v0; // rax
  int v1; // esi
  int v2; // edx
  int v3; // ebx
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // edi
  unsigned __int8 v8; // dl
  int v9; // ebx
  int v10; // esi
  int v11; // edi
  int v12; // eax
  unsigned __int8 v13; // dl
  int result; // eax
  int v15; // [esp+0h] [ebp-20h] BYREF
  int v16; // [esp+4h] [ebp-1Ch] BYREF
  int v17; // [esp+8h] [ebp-18h]
  int v18; // [esp+Ch] [ebp-14h]
  char *v19; // [esp+10h] [ebp-10h]
  int v20; // [esp+14h] [ebp-Ch]
  int v21; // [esp+18h] [ebp-8h]
  int v22; // [esp+1Ch] [ebp-4h]

  v0 = 640 - *(__int16 *)(dword_D41A4 + 186);
  LODWORD(v0) = ((int)v0 - HIDWORD(v0)) >> 1;
  v1 = 67;
  v2 = 0;
  v3 = v0;
  while ( 1 )
  {
    v22 = v2;
    if ( v2 >= 17 )
      break;
    sub_1A5B0(v22 + 1, &v16, &v15);
    v20 = 1 << v22;
    if ( ((1 << v22) & *(_DWORD *)(dword_D41A4 + 192)) != 0 && ((1 << v22) & *(_DWORD *)(dword_D41A4 + 188)) != 0 )
      v4 = v16;
    else
      v4 = v15;
    v19 = (char *)dword_E9C4C[v4];
    v5 = *(__int16 *)(dword_D41A4 + 186);
    v17 = v3 + *(unsigned __int8 *)(dword_EA3DC + 1012);
    v6 = v3 + v5 - *(unsigned __int8 *)(dword_EA3DC + 1024);
    v18 = *(unsigned __int8 *)(dword_EA3DC + 1018);
    v21 = v6;
    sub_2BB40(v3, v1, dword_EA3DC + 1008);
    v7 = v17;
    sub_2BB40(v21, v1, dword_EA3DC + 1020);
    while ( v7 < v21 )
    {
      sub_2BB40(v7, v1, dword_EA3DC + 1014);
      v7 += v18;
    }
    if ( (v20 & *(_DWORD *)(dword_D41A4 + 192)) != 0 )
    {
      if ( v3 > dword_1805B0
        || v3 + *(__int16 *)(dword_D41A4 + 186) <= dword_1805B0
        || v1 > dword_1805B4
        || v1 + 18 <= dword_1805B4 )
      {
        v8 = byte_E98FF;
      }
      else
      {
        v8 = byte_E9800;
      }
    }
    else
    {
      v8 = byte_E9188;
    }
    sub_2BC10(v19, v3 + ((*(__int16 *)(dword_D41A4 + 186) - 8 * strlen(v19)) >> 1), v1 + 2, v8);
    v1 += 18;
    v2 = v22 + 1;
  }
  v9 = (*(__int16 *)(dword_D41A4 + 186) - 82) / 2 + (640 - *(__int16 *)(dword_D41A4 + 186)) / 2;
  v17 = v9 + *(unsigned __int8 *)(dword_EA3DC + 1012);
  v10 = *(unsigned __int8 *)(dword_EA3DC + 1018);
  v21 = v9 + 82 - *(unsigned __int8 *)(dword_EA3DC + 1024);
  sub_2BB40(v9, 377, dword_EA3DC + 1008);
  v11 = v17;
  sub_2BB40(v21, 377, dword_EA3DC + 1020);
  while ( v11 < v21 )
  {
    sub_2BB40(v11, 377, dword_EA3DC + 1014);
    v11 += v10;
  }
  v12 = (640 - *(__int16 *)(dword_D41A4 + 186)) / 2 + (*(__int16 *)(dword_D41A4 + 186) - 82) / 2;
  if ( v12 > dword_1805B0 || v12 + 82 <= dword_1805B0 || dword_1805B4 < 377 || dword_1805B4 >= 395 )
    v13 = byte_E98FF;
  else
    v13 = byte_E9800;
  result = sub_2BC10(
             &aOk_0[3],
             (640 - *(__int16 *)(dword_D41A4 + 186)) / 2 + (*(__int16 *)(dword_D41A4 + 186) - 82) / 2 + 33,
             379,
             v13);
  if ( word_1805C2 == 8
    || word_1805C2 == 12
    || word_1805C2 == 13
    || word_1805C2 == 4
    || word_1805C2 == 6
    || word_1805C2 == 11
    || word_1805C2 == 5 )
  {
    return sub_2BB40(dword_1805B0, dword_1805B4, 6 * (unsigned __int8)byte_D419E + dword_EB394);
  }
  return result;
}
// D419E: using guessed type char byte_D419E;
// D41A4: using guessed type int dword_D41A4;
// E9188: using guessed type char byte_E9188;
// E9800: using guessed type char byte_E9800;
// E98FF: using guessed type char byte_E98FF;
// E9C4C: using guessed type int dword_E9C4C[];
// EA3DC: using guessed type int dword_EA3DC;
// EB394: using guessed type int dword_EB394;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (000303D0) --------------------------------------------------------
int __usercall sub_303D0@<eax>(int a1@<edi>)
{
  int v1; // edx
  unsigned __int8 v2; // bh
  unsigned __int8 v3; // bl
  unsigned __int8 v4; // al
  int v5; // eax
  unsigned __int8 v6; // si
  int v7; // ebx
  int v9; // [esp+0h] [ebp-1Ch] BYREF
  int v10; // [esp+4h] [ebp-18h] BYREF
  int v11; // [esp+8h] [ebp-14h] BYREF
  int v12; // [esp+Ch] [ebp-10h] BYREF
  int v13; // [esp+10h] [ebp-Ch]
  int v14; // [esp+14h] [ebp-8h]
  unsigned __int8 v15; // [esp+18h] [ebp-4h]

  v1 = *(unsigned __int8 *)(dword_D41A0 + 196308);
  v2 = byte_D94F0[5 * v1];
  v3 = byte_D94F2[5 * v1];
  v15 = byte_D94F3[5 * v1];
  sub_2FFE0(&v12, &v11, &v10, &v9);
  v4 = *(_BYTE *)(dword_D41A4 + 38543);
  if ( v4 )
  {
    if ( v4 <= 1u )
    {
      v5 = *(__int16 *)(dword_D41A4 + 6);
    }
    else
    {
      if ( v4 != 2 )
        goto LABEL_8;
      v5 = *(__int16 *)(dword_D41A4 + 8);
    }
    a1 = 127;
    v14 = v5;
  }
LABEL_8:
  v10 -= 2;
  v13 = v2;
  v11 += 4 * v9;
  sub_2BC80(v12, v11, v10, 24, v2);
  sub_2BC80(v12, v11, v10, 2, v3);
  v6 = v15;
  sub_2BC80(v12, v11 + 22, v10, 2, v15);
  sub_2BC80(v12, v11, 2, 22, v3);
  sub_2BC80(v10 + v12 - 2, v11, 2, 24, v6);
  sub_2BC80(v12 + 4, v11 + 4, v10 - 8, 16, v13);
  sub_2BC80(v12 + 4, v11 + 4, v10 - 8, 2, v6);
  sub_2BC80(v12 + 4, v11 + 18, v10 - 8, 2, v3);
  sub_2BC80(v12 + 4, v11 + 4, 2, 14, v6);
  sub_2BC80(v12 + 4 + v10 - 8 - 2, v11 + 4, 2, 16, v3);
  v7 = v14 * (v10 - 12) / a1;
  v11 += 6;
  v12 += 6;
  sub_2BC80(v12, v11, v10 - 12, 12, byte_E8900[0]);
  return sub_2BC80(v12, v11, v7, 12, byte_E89F0);
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E89F0: using guessed type char byte_E89F0;

//----- (00030630) --------------------------------------------------------
int sub_30630()
{
  char v0; // dl
  int result; // eax
  unsigned __int16 v2; // cx
  int v3; // edx
  int v4; // edx
  const char *v5; // ebx
  __int16 v6[24]; // [esp+0h] [ebp-34h] BYREF
  char v7; // [esp+30h] [ebp-4h]
  unsigned __int8 v8; // [esp+31h] [ebp-3h]

  v0 = *(_BYTE *)(dword_D41A4 + 22);
  result = 0;
  if ( (v0 & 0x10) == 0 && (v0 & 0x20) == 0 )
  {
    if ( (*(_BYTE *)(dword_D41A4 + 23) & 2) != 0 )
    {
      v4 = 11 * *(__int16 *)(dword_D41A0 + 12);
      if ( byte_3659C[v4 + dword_D41A0] )
        result = (unsigned __int8)byte_DB526;
      else
        result = (unsigned __int8)byte_DB520[(unsigned __int8)byte_3659D[v4 + dword_D41A0]];
    }
    else if ( (*((_BYTE *)&loc_36E09 + dword_D41A0 + 2) & 1) != 0 )
    {
      result = (*(_BYTE *)(dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12) + 12226) != 0) + 284;
    }
    else
    {
      v2 = *(_WORD *)(dword_D41A4 + 43);
      if ( v2 >= 0x1Eu && v2 <= 0x22u )
      {
        if ( byte_3659C[11 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0] )
          result = (unsigned __int8)byte_DB511;
        else
          result = (unsigned __int8)byte_DB4EE[0] + 3;
      }
      else if ( (*(_BYTE *)(dword_D41A4 + 38545) & 0x20) != 0
             && !byte_3659D[11 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0] )
      {
        *((_BYTE *)&loc_36E03 + dword_D41A0 + 1) = 0;
      }
      else
      {
        v3 = 11 * *(__int16 *)(dword_D41A0 + 12);
        if ( byte_3659C[v3 + dword_D41A0] )
          result = (unsigned __int8)byte_DB507[*(unsigned __int16 *)(dword_D41A4 + 43)];
        else
          result = (unsigned __int8)byte_3659D[v3 + dword_D41A0]
                 + (unsigned __int8)byte_DB4EE[*(unsigned __int16 *)(dword_D41A4 + 43)];
      }
    }
    if ( result )
    {
      v5 = (const char *)dword_E9C4C[result];
      v6[8] = 8;
      v6[7] = 400;
      v6[10] = 40;
      v6[11] = 600;
      v6[9] = 14;
      v6[13] = 260;
      v7 = byte_E9800;
      v6[12] = 80;
      v8 = byte_E8900[0];
      v6[0] = 320;
      v6[1] = 300;
      v6[6] = 320;
      sub_89420(v6, v5);
      sub_89520(v6);
      sub_89980(v6);
      sub_2E790(v6[18], v6[19], v6[20], v6[21], v8);
      sub_895D0((int)v6, v5);
      return sub_89690(v6);
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// DB511: using guessed type char byte_DB511;
// DB526: using guessed type char byte_DB526;
// E9800: using guessed type char byte_E9800;
// E9C4C: using guessed type int dword_E9C4C[];

//----- (00030870) --------------------------------------------------------
char sub_30870()
{
  const char *v0; // ebx
  __int16 v1; // ax
  char v3[128]; // [esp+0h] [ebp-32h] BYREF
  __int16 v4[24]; // [esp+80h] [ebp+4Eh] BYREF
  char v5; // [esp+B0h] [ebp+7Eh]
  char v6; // [esp+B1h] [ebp+7Fh]

  sub_2BC80(4, 286, 632, 190, 0);
  sprintf(v3, "%d", word_D41D4);
  sub_2BC10(v3, 10, 300, byte_E98FF);
  v4[7] = 400;
  v4[10] = 4;
  v4[8] = 8;
  v4[9] = 14;
  v4[11] = 636;
  v0 = (const char *)dword_E9C4C[word_D41D4];
  v4[6] = 600;
  v4[0] = 320;
  v5 = byte_E9800;
  v6 = byte_E8900[0];
  v4[12] = 310;
  v4[13] = 630;
  v4[1] = 310;
  sub_89420(v4, v0);
  sub_89520(v4);
  sub_89980(v4);
  LOBYTE(v1) = sub_895D0((int)v4, v0);
  switch ( byte_1806E4 )
  {
    case 'H':
      if ( ++word_D41D4 < 1 )
        word_D41D4 = 1;
      if ( word_D41D4 > 470 )
        word_D41D4 = 470;
      byte_1806E4 = 0;
      break;
    case 'P':
      v1 = word_D41D4 - 1;
      word_D41D4 = v1;
      if ( v1 < 1 )
        word_D41D4 = 1;
      if ( word_D41D4 > 470 )
        word_D41D4 = 470;
      byte_1806E4 = 0;
      break;
    case 'K':
      word_D41D4 = 1;
      byte_1806E4 = 0;
      break;
    case 'M':
      word_D41D4 = 470;
      LOBYTE(v1) = 0;
      byte_1806E4 = 0;
      break;
  }
  return v1;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41D4: using guessed type __int16 word_D41D4;
// E9800: using guessed type char byte_E9800;
// E98FF: using guessed type char byte_E98FF;
// E9C4C: using guessed type int dword_E9C4C[];
// 1806E4: using guessed type char byte_1806E4;

//----- (00030A60) --------------------------------------------------------
int __cdecl sub_30A60(__int16 a1, __int16 a2)
{
  int result; // eax
  unsigned __int8 v3; // dl
  __int64 v4; // rax
  char v5[128]; // [esp+0h] [ebp-Eh] BYREF
  int v6; // [esp+80h] [ebp+72h] BYREF
  int v7; // [esp+84h] [ebp+76h] BYREF

  v7 = a1;
  v6 = a2;
  result = dword_D41A4;
  v3 = *(_BYTE *)(dword_D41A4 + 38546);
  if ( v3 )
  {
    if ( v3 < 2u )
    {
      sprintf(v5, "%s?", (const char *)dword_E9C54);
    }
    else if ( v3 <= 2u )
    {
      sprintf(v5, "%s?", (const char *)dword_EA2E8);
    }
    else if ( v3 == 3 )
    {
      sprintf(v5, "%s?", (const char *)dword_EA2EC);
    }
    v4 = 4080 * *(unsigned __int8 *)(dword_D41A4 + 125);
    sub_2BC10(v5, v7, v6, byte_E8900[256 * ((int)(v4 - (__CFSHL__(HIDWORD(v4), 8) + (HIDWORD(v4) << 8))) >> 8)]);
    sub_30BE0(&v7, &v6);
    sub_2BB40(v7, v6, dword_EA3DC + 1542);
    result = sub_2BB40(v7 + 50, v6, dword_EA3DC + 1548);
    if ( word_1805C2 == 8
      || word_1805C2 == 12
      || word_1805C2 == 13
      || word_1805C2 == 4
      || word_1805C2 == 6
      || word_1805C2 == 11
      || word_1805C2 == 5 )
    {
      return sub_2BB40(dword_1805B0, dword_1805B4, 6 * (unsigned __int8)byte_D419E + dword_EB394);
    }
  }
  return result;
}
// 30AA9: conditional instruction was optimized away because dl.1==1
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D419E: using guessed type char byte_D419E;
// D41A4: using guessed type int dword_D41A4;
// E9C54: using guessed type int dword_E9C54;
// EA2E8: using guessed type int dword_EA2E8;
// EA2EC: using guessed type int dword_EA2EC;
// EA3DC: using guessed type int dword_EA3DC;
// EB394: using guessed type int dword_EB394;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (00030BE0) --------------------------------------------------------
_DWORD *__cdecl sub_30BE0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  *a1 = 270;
  result = a2;
  *a2 = 104;
  return result;
}

//----- (00030D50) --------------------------------------------------------
void __cdecl sub_30D50(int a1)
{
  int v1; // eax
  char v2; // dl
  int v3; // esi
  char v4; // cl
  char v5; // ch
  __int16 v6; // ax
  int v7; // eax
  int v8; // edi
  int v9; // esi
  unsigned __int16 v10; // [esp+0h] [ebp-4h]

  if ( (*(_BYTE *)(a1 + 16) & 3) != 0 )
  {
    --*(_DWORD *)(a1 + 16);
  }
  else
  {
    v1 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v1 - 1;
    if ( v1 >= 0 )
    {
      v2 = *(_BYTE *)(a1 + 12) & 0xFE;
      *(_BYTE *)(a1 + 12) = v2;
      v3 = (__int16)sub_10C40((__int16 *)(a1 + 76));
      if ( (*(_BYTE *)(a1 + 12) & 2) == 0 )
      {
        LOBYTE(v10) = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
        v4 = *(_BYTE *)(a1 + 14);
        HIBYTE(v10) = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
        if ( (v4 & 1) == 0 )
          sub_10C80(a1, 0, *(_WORD *)(a1 + 42));
        v5 = byte_10B4E0[v10];
        if ( v5 )
        {
          switch ( v5 )
          {
            case 26:
              sub_45DC0(v2, v4, v10, 0x14u);
              break;
            case 10:
              sub_45DC0(v2, v4, v10, 0x15u);
              break;
            case 11:
              sub_45DC0(v2, v4, v10, 0x16u);
              break;
            default:
              if ( ((unsigned __int8)v5 < 6u || (unsigned __int8)v5 > 0x22u)
                && (byte_13B4E0[v10] & 7) != 1
                && *(__int16 *)(a1 + 80) - v3 <= 128
                && (sub_104A0(a1 + 76) & 1) == 0 )
              {
                *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
                sub_572C0((__int16 *)a1, 0, 0, -(*(_WORD *)(a1 + 20) % 7u), 1);
              }
              break;
          }
        }
        v6 = 9377 * *(_WORD *)(a1 + 20);
        *(_BYTE *)(a1 + 12) |= 2u;
        *(_WORD *)(a1 + 20) = v6 + 9439;
        v7 = dword_D41A0 + 28302;
        *(_WORD *)(a1 + 44) = *(_WORD *)(a1 + 20) % 0x41u - 32;
        sub_6E450((a1 - v7) / 168, -1, 3);
      }
      sub_580E0(a1 + 76, v3, 0, 0, *(_WORD *)(a1 + 44));
      if ( byte_D41B6 )
      {
        v8 = *(__int16 *)(a1 + 88);
        v9 = (__int16)sub_10C60((__int16 *)(a1 + 76)) - v8;
        if ( *(__int16 *)(a1 + 80) > v9 )
          *(_WORD *)(a1 + 80) = v9;
      }
      sub_585A0(a1);
    }
    else
    {
      sub_57F10(a1);
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;

//----- (00030F60) --------------------------------------------------------
unsigned int __cdecl sub_30F60(int a1)
{
  int v1; // eax
  unsigned int result; // eax
  int v3; // eax
  int v4; // esi
  int v5; // eax
  unsigned int v6; // edx
  __int16 v7[4]; // [esp+0h] [ebp-10h] BYREF
  int v8; // [esp+8h] [ebp-8h] BYREF
  int v9; // [esp+Ch] [ebp-4h] BYREF

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  if ( (*(_BYTE *)(a1 + 12) & 2) == 0 )
  {
    v3 = dword_D41A0 + 28302;
    *(_BYTE *)(a1 + 12) |= 2u;
    sub_6E450((a1 - v3) / 168, -1, 3);
  }
  result = sub_10080(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 16));
  v4 = result;
  if ( result )
  {
    while ( sub_10130(v4, &v9, &v8) == 1 )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      if ( (int)(2 * (*(unsigned __int16 *)(a1 + 20) % 0x9Du / 79i64) - 1) > 0 )
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v7[0] = *(_WORD *)(a1 + 76) - 96 + 192 * v9 + *(_WORD *)(a1 + 20) % 0x81u - 64;
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v7[1] = *(_WORD *)(a1 + 78) - 96 + 192 * v8 + *(_WORD *)(a1 + 20) % 0x81u - 64;
        v7[2] = *(_WORD *)(a1 + 80);
        v5 = sub_4A190((int)v7, 10, 0);
        if ( v5 )
        {
          *(_WORD *)(v5 + 26) = *(_WORD *)(a1 + 26);
          *(_WORD *)(v5 + 28) = *(_WORD *)(a1 + 28);
          v6 = (unsigned int)sub_10000 & *(_DWORD *)(a1 + 12);
          LOBYTE(v6) = v6 | 0x80;
          *(_DWORD *)(v5 + 12) |= v6;
        }
      }
    }
    return sub_10100(v4);
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;

//----- (00031100) --------------------------------------------------------
int __cdecl sub_31100(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = result - 1;
  if ( result < 0 )
    return sub_57F10(a1);
  return result;
}

//----- (00031120) --------------------------------------------------------
int __cdecl sub_31120(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // eax
  char v4; // [esp+0h] [ebp-4h]

  v4 = 0;
  result = sub_10C40((__int16 *)(a1 + 76));
  if ( (_WORD)result != *(_WORD *)(a1 + 80) )
    goto LABEL_7;
  if ( *(_DWORD *)(a1 + 4) - 5 == *(_DWORD *)(a1 + 8) )
  {
    sub_4A190(a1 + 76, 10, 87);
    v2 = dword_D41A0;
    v3 = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
    *(_DWORD *)(dword_D41A0 + 8) = v3;
    if ( (v3 & 1) == 0 )
      sub_6E450((a1 - (v2 + 28302)) / 168, -1, *(_WORD *)(a1 + 90) - 282);
  }
  result = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = result - 1;
  if ( result >= 0 )
    result = sub_585A0(a1);
  else
LABEL_7:
    v4 = 1;
  if ( v4 )
    return sub_57F10(a1);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (000311E0) --------------------------------------------------------
char __cdecl sub_311E0(int a1)
{
  unsigned int v1; // eax
  int v2; // eax
  unsigned __int8 v3; // dl
  __int16 v4; // di
  __int16 v5; // ax
  int v6; // edi
  char v7; // al
  char v8; // al
  signed int v9; // eax
  int v10; // esi
  int v11; // edx
  int v12; // esi
  int v13; // eax
  unsigned int j; // esi
  __int64 v15; // rax
  int v16; // eax
  unsigned int v17; // ecx
  __int64 v18; // rax
  int v19; // eax
  unsigned int v20; // edx
  int v21; // ecx
  int v22; // edx
  int v23; // eax
  unsigned __int8 v24; // dh
  char v25; // cl
  int v26; // eax
  unsigned __int16 v27; // dx
  __int16 v28; // si
  __int16 v30; // [esp+0h] [ebp-50h] BYREF
  __int16 v31; // [esp+2h] [ebp-4Eh]
  int v32; // [esp+8h] [ebp-48h]
  unsigned int v33; // [esp+Ch] [ebp-44h]
  int v34; // [esp+10h] [ebp-40h]
  int v35; // [esp+14h] [ebp-3Ch]
  int v36; // [esp+18h] [ebp-38h]
  int v37; // [esp+1Ch] [ebp-34h]
  int v38; // [esp+20h] [ebp-30h]
  int k; // [esp+24h] [ebp-2Ch]
  int v40; // [esp+28h] [ebp-28h]
  int v41; // [esp+2Ch] [ebp-24h]
  int v42; // [esp+30h] [ebp-20h]
  int v43; // [esp+34h] [ebp-1Ch]
  int v44; // [esp+38h] [ebp-18h]
  int v45; // [esp+3Ch] [ebp-14h]
  int v46; // [esp+40h] [ebp-10h]
  int v47; // [esp+44h] [ebp-Ch]
  int v48; // [esp+48h] [ebp-8h]
  unsigned __int16 i; // [esp+4Ch] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 4);
  if ( !v1 )
    goto LABEL_7;
  if ( v1 <= 1 )
  {
    v41 = 5;
    goto LABEL_8;
  }
  if ( v1 == 2 )
    v41 = 7;
  else
LABEL_7:
    v41 = 3;
LABEL_8:
  v38 = v41 + 12;
  LOBYTE(v2) = *(_BYTE *)(a1 + 70);
  if ( (unsigned __int8)v2 < 2u )
  {
    if ( (_BYTE)v2 )
      return v2;
    v3 = ((unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8) - v38;
    BYTE1(v48) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - v38;
    v4 = BYTE1(v48);
    LOBYTE(v48) = v3;
    *(_WORD *)(a1 + 80) = sub_48EF0(v3, BYTE1(v48), 2 * v38, 2 * v38);
    v5 = sub_48E60(v3, v4, 2 * v38, 2 * v38);
    *(_DWORD *)(a1 + 8) = 40;
    *(_WORD *)(a1 + 44) = 227;
    *(_WORD *)(a1 + 54) = 0;
    *(_BYTE *)(a1 + 70) = 2;
    *(_WORD *)(a1 + 158) = v5;
  }
  else if ( (unsigned __int8)v2 > 2u )
  {
    if ( (_BYTE)v2 == 3 )
      LOBYTE(v2) = sub_57F10(a1);
    return v2;
  }
  v34 = *(__int16 *)(a1 + 80);
  v44 = *(__int16 *)(a1 + 158);
  v35 = 0;
  v46 = v34 - v44;
  v37 = 0;
  v6 = *(__int16 *)(a1 + 44);
  LOBYTE(v2) = v41;
  v46 = ((v34 - v44) >> 1) + v34 - v44;
  v40 = v41;
  while ( v35 < 6 )
  {
    v45 = v37 - 1024;
    if ( v37 - 1024 < 0 )
      v45 = 0;
    if ( v38 << 8 < v45 )
      v45 = v38 << 8;
    v37 = v40 << 8;
    LOBYTE(v2) = 2 * v40;
    v43 = 2 * v40;
    if ( v6 > 0 && v6 <= 512 )
    {
      v7 = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - v40;
      LOBYTE(v48) = ((unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8) - v40;
      BYTE1(v48) = v7;
      v36 = 0;
      for ( i = v48; ; ++HIBYTE(i) )
      {
        LOBYTE(v2) = v36;
        if ( v36 >= v43 )
          break;
        v42 = 0;
        v8 = v48;
        while ( 1 )
        {
          LOBYTE(i) = v8;
          if ( v42 >= v43 )
            break;
          v30 = (unsigned __int8)i << 8;
          v31 = HIBYTE(i) << 8;
          v9 = sub_58490((_WORD *)(a1 + 76), &v30);
          if ( v9 < v37 && v9 >= v45 )
          {
            v10 = ((v46 * (((int)sub_10000 + (int)off_DBF50[(v9 << 10) / v37]) >> 1)) >> 16)
                * ((char *)sub_10000 - (char *)off_DBF50[v6]);
            v11 = (v10 >> 18) + v44;
            v12 = v10 >> 16;
            v47 = v11;
            if ( (unsigned __int8)byte_11B4E0[i] < v11 )
              sub_570F0((unsigned __int8)i, HIBYTE(i), v47, 0, 1, 1);
            v13 = (unsigned __int8)byte_14B4E0[i];
            v47 = v34 - v12;
            if ( v34 - v12 < 0 )
              v47 = 0;
            if ( v13 > v47 )
              byte_14B4E0[i] = v47;
            for ( j = *(_DWORD *)(dword_D41A4 + 38519); j > dword_EA3E4[0]; j = *(_DWORD *)j )
            {
              if ( !*(_BYTE *)(j + 64) )
              {
                v15 = v30 - *(__int16 *)(j + 76);
                v16 = (HIDWORD(v15) ^ v15) - HIDWORD(v15);
                v17 = v16;
                if ( v16 >= 0x8000 )
                  v17 = abs32(v16 - (_DWORD)sub_10000);
                v18 = v31 - *(__int16 *)(j + 78);
                v19 = (HIDWORD(v18) ^ v18) - HIDWORD(v18);
                v20 = v19;
                if ( v19 >= 0x8000 )
                  v20 = abs32(v19 - (_DWORD)sub_10000);
                v21 = v17 * v17;
                v22 = v20 * v20;
                if ( v21 + v22 <= (int)&loc_64000 )
                {
                  v33 = sub_7277A((unsigned int)&loc_64000 - v21 - v22) >> 5;
                  v32 = *(__int16 *)(j + 80) >> 5;
                  v47 = v32 - v33;
                  if ( (int)(v32 - v33) < 0 )
                    v47 = 0;
                  if ( v47 > 254 )
                    v47 = 254;
                  if ( (unsigned __int8)byte_11B4E0[i] > v47 )
                    sub_570F0((unsigned __int8)i, HIBYTE(i), v47, 0, 0, 1);
                  v47 = v33 + v32;
                  if ( (int)(v33 + v32) < 0 )
                    v47 = 0;
                  if ( v47 > 254 )
                    v47 = 254;
                  if ( (unsigned __int8)byte_14B4E0[i] < v47 )
                    byte_14B4E0[i] = v47;
                }
              }
            }
          }
          v23 = i;
          v24 = byte_11B4E0[i];
          if ( (unsigned __int8)byte_14B4E0[i] > v24 )
          {
            byte_13B4E0[i] &= ~8u;
          }
          else
          {
            v25 = byte_13B4E0[i] | 8;
            byte_14B4E0[i] = v24;
            byte_13B4E0[v23] = v25;
          }
          v8 = i + 1;
          ++v42;
        }
        ++v36;
      }
    }
    v6 -= 68;
    ++v35;
    v40 += 2;
  }
  if ( !*(_WORD *)(a1 + 54) && *(__int16 *)(a1 + 44) > 455 )
  {
    *(_WORD *)(a1 + 54) = 1;
    for ( k = 0; k < 2048; k += 28 )
    {
      v26 = (v41 << 8) - 768;
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      if ( v26 < 256 )
        v26 = 256;
      if ( v26 > 0x2000 )
        LOWORD(v26) = 0x2000;
      sub_57FA0(&word_EB398, k, 0, v26);
      v2 = sub_4A190((int)&word_EB398, 10, 13);
      if ( v2 )
      {
        *(_WORD *)(v2 + 28) = k;
        v27 = i;
        *(_WORD *)(v2 + 134) = 512;
        word_EB39C = 32 * (unsigned __int8)byte_11B4E0[v27];
        LOBYTE(v2) = sub_57CF0(v2, v2, (int)&word_EB398);
      }
    }
  }
  v28 = *(_WORD *)(a1 + 44) + 22;
  *(_DWORD *)(a1 + 8) += 4;
  *(_WORD *)(a1 + 44) = v28;
  if ( v28 > 1024 )
    *(_BYTE *)(a1 + 70) = 3;
  return v2;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A4: using guessed type int dword_D41A4;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00031760) --------------------------------------------------------
char __cdecl sub_31760(int a1)
{
  int v1; // eax
  int v2; // esi
  __int16 v3; // cx
  char v4; // ah
  int v5; // eax
  __int16 v6; // dx
  __int16 v7; // di
  int v8; // eax

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    goto LABEL_11;
  sub_5C870(a1);
  if ( *(int *)(a1 + 8) < 12 )
  {
    if ( *(int *)(a1 + 16) > 0 )
    {
      v3 = *(_WORD *)(a1 + 90);
      --*(_DWORD *)(a1 + 16);
      v4 = *(_BYTE *)(a1 + 12);
      *(_WORD *)(a1 + 90) = v3 - 1;
      if ( v4 >= 0 )
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        if ( !(*(unsigned __int16 *)(a1 + 20) % 7u) )
        {
          v5 = sub_4A190(a1 + 76, 10, 14);
          if ( v5 )
          {
            v6 = *(_WORD *)(a1 + 26);
            *(_DWORD *)(v5 + 16) = 100;
            v7 = *(_WORD *)(v5 + 90);
            *(_DWORD *)(v5 + 8) = 15;
            *(_WORD *)(v5 + 26) = v6;
            *(_WORD *)(v5 + 90) = v7 + 2;
          }
        }
      }
    }
  }
  else if ( *(int *)(a1 + 16) <= 6 )
  {
    v2 = *(_DWORD *)(a1 + 16) + 1;
    ++*(_WORD *)(a1 + 90);
    *(_DWORD *)(a1 + 16) = v2;
  }
  *(_WORD *)(a1 + 80) = *(_WORD *)(a1 + 44) + sub_10C40((__int16 *)(a1 + 76));
  v8 = sub_104D0((__int16 *)(a1 + 76));
  if ( v8 == 1 )
LABEL_11:
    LOBYTE(v8) = sub_57F10(a1);
  if ( (*(_BYTE *)(a1 + 14) & 1) == 0 )
    LOBYTE(v8) = sub_11400(a1, 0, *(_WORD *)(a1 + 42));
  return v8;
}

//----- (00031870) --------------------------------------------------------
int __cdecl sub_31870(int a1)
{
  return sub_57F10(a1);
}

//----- (00031890) --------------------------------------------------------
int __cdecl sub_31890(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = result - 1;
  if ( result < 0 )
    return sub_57F10(a1);
  return result;
}

//----- (000318B0) --------------------------------------------------------
void __cdecl sub_318B0(int a1)
{
  int v1; // edx
  int v2; // eax

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 >= 0 )
  {
    sub_585A0(a1);
    if ( (*(_BYTE *)(a1 + 12) & 2) == 0 )
    {
      v2 = dword_D41A0 + 28302;
      *(_BYTE *)(a1 + 12) |= 2u;
      sub_6E450((a1 - v2) / 168, -1, 27);
    }
  }
  else
  {
    sub_57F10(a1);
  }
}
// D41A0: using guessed type int dword_D41A0;

//----- (00031920) --------------------------------------------------------
int __cdecl sub_31920(int a1)
{
  return sub_57F10(a1);
}

//----- (00031940) --------------------------------------------------------
char __cdecl sub_31940(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // esi
  int v4; // edi
  int v5; // esi
  int v6; // eax
  unsigned __int16 v7; // bx
  int v8; // edx
  signed int v9; // eax
  int v10; // edx
  int v11; // eax
  unsigned __int16 v12; // bx
  int v13; // edx
  int v14; // eax
  unsigned __int16 v15; // si
  int v16; // esi
  int v17; // esi
  unsigned __int16 v18; // bx
  int v19; // eax
  int v20; // eax
  unsigned __int16 v21; // bx
  int i; // edx
  int v23; // edx
  unsigned __int16 v24; // si
  __int16 v26; // [esp-10h] [ebp-4Ch]
  __int16 v27; // [esp-Ch] [ebp-48h]
  __int16 v28[4]; // [esp+0h] [ebp-3Ch] BYREF
  int v29; // [esp+8h] [ebp-34h]
  int v30; // [esp+Ch] [ebp-30h]
  int v31; // [esp+10h] [ebp-2Ch]
  int v32; // [esp+14h] [ebp-28h]
  int v33; // [esp+18h] [ebp-24h]
  int v34; // [esp+1Ch] [ebp-20h]
  int v35; // [esp+20h] [ebp-1Ch]
  int v36; // [esp+24h] [ebp-18h]
  int v37; // [esp+28h] [ebp-14h]
  int v38; // [esp+2Ch] [ebp-10h]
  int v39; // [esp+30h] [ebp-Ch]
  char v40; // [esp+34h] [ebp-8h]
  char v41; // [esp+35h] [ebp-7h]
  char v42; // [esp+38h] [ebp-4h]
  char v43; // [esp+39h] [ebp-3h]

  v42 = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
  v43 = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
  LOBYTE(v1) = *(_BYTE *)(a1 + 70);
  v35 = 0;
  if ( (_BYTE)v1 )
  {
    if ( (unsigned __int8)v1 > 1u )
    {
      if ( (_BYTE)v1 == 2 )
      {
        v39 = *(__int16 *)(a1 + 80) + *(__int16 *)(a1 + 44) - 24;
        v16 = *(__int16 *)(a1 + 84);
        v40 = v42 - BYTE1(v16);
        v41 = v43 - BYTE1(v16);
        v17 = v16 >> 7;
        HIBYTE(v18) = v41;
        v19 = 0;
        if ( v17 > 0 )
        {
          do
          {
            LOBYTE(v18) = v40;
            for ( i = 0; i < v17; ++i )
            {
              if ( (unsigned __int8)byte_11B4E0[v18] > v39 )
                byte_11B4E0[v18] = v39;
              LOBYTE(v18) = v18 + 1;
            }
            ++v19;
            ++HIBYTE(v18);
          }
          while ( v19 < v17 );
          v20 = 0;
          HIBYTE(v21) = v43 - 1;
        }
        else
        {
          v20 = 0;
          HIBYTE(v21) = v43 - 1;
        }
        while ( v20 < 2 )
        {
          v23 = 0;
          LOBYTE(v21) = v42 - 1;
          while ( v23 < 2 )
          {
            byte_11B4E0[v21] = v39 - 16;
            if ( *(_BYTE *)(dword_D41A0 + 196308) )
              v32 = 1;
            else
              v32 = 63;
            v24 = v21;
            ++v23;
            LOBYTE(v21) = v21 + 1;
            byte_12B4E0[v24] = v32;
          }
          ++v20;
          ++HIBYTE(v21);
        }
        LOBYTE(v1) = sub_57F10(a1);
      }
      return v1;
    }
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 4);
    LOBYTE(v2) = v2 | 1;
    sub_49EA0((_WORD *)a1, (_WORD)v2 << 8, 0x4000);
    v40 = v42 - v2;
    v41 = v43 - v2;
    v27 = (unsigned __int8)(v43 - v2);
    v26 = (unsigned __int8)(v42 - v2);
    LOWORD(v2) = 2 * v2;
    *(_WORD *)(a1 + 80) = sub_48E60(v26, v27, v2, v2);
    *(_WORD *)(a1 + 44) = v2 + 100;
    if ( *(__int16 *)(a1 + 80) + *(__int16 *)(a1 + 44) > 255 )
      *(_WORD *)(a1 + 44) = 255 - *(_WORD *)(a1 + 80);
    *(_BYTE *)(a1 + 70) = 1;
  }
  LOBYTE(v1) = a1;
  v3 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v3;
  if ( v3 <= 0 )
  {
    *(_BYTE *)(a1 + 70) = 2;
  }
  else
  {
    v4 = *(__int16 *)(a1 + 84);
    v5 = v4 >> 7;
    v40 = v42 - BYTE1(v4);
    v30 = v4 - ((((v4 >> 8) - 7) >> 1 << 8) + 512);
    v41 = v43 - BYTE1(v4);
    v6 = 0;
    for ( HIBYTE(v7) = v43 - BYTE1(v4); ; ++HIBYTE(v7) )
    {
      v37 = v6;
      if ( v5 <= v6 )
        break;
      v8 = 0;
      for ( LOBYTE(v7) = v40; ; LOBYTE(v7) = v7 + 1 )
      {
        v36 = v8;
        if ( v5 <= v8 )
          break;
        v28[0] = (unsigned __int8)v7 << 8;
        v28[1] = HIBYTE(v7) << 8;
        v9 = sub_58490((_WORD *)(a1 + 76), v28);
        v29 = v9;
        if ( v9 < v4 )
        {
          v39 = ((*(__int16 *)(a1 + 44) * (((int)sub_10000 + (int)off_DBF50[(v9 << 10) / v4]) >> 1)) >> 16)
              + *(__int16 *)(a1 + 80);
          v38 = (unsigned __int8)byte_11B4E0[v7];
          v10 = v38;
          if ( v39 > v38 )
            v10 = (v39 - v38) / *(_DWORD *)(a1 + 8) + v38;
          v39 = v10;
          sub_570F0((unsigned __int8)v7, HIBYTE(v7), v10, 0, v29 <= v30, 1);
          if ( byte_D41B6 )
          {
            v39 += 64;
            if ( v39 > 254 )
              v39 = 254;
            v33 = v7;
            v34 = (unsigned __int8)byte_14B4E0[v7];
            if ( v39 > v34 )
            {
              v11 = (v34 - v39) / *(_DWORD *)(a1 + 8);
              v39 = v34 - v11;
              byte_14B4E0[v33] = v34 - v11;
            }
          }
        }
        if ( byte_D41B6 )
        {
          if ( (unsigned __int8)byte_14B4E0[v7] > (unsigned __int8)byte_11B4E0[v7] )
            byte_13B4E0[v7] &= ~8u;
          else
            byte_13B4E0[v7] |= 8u;
        }
        v8 = v36 + 1;
      }
      v6 = v37 + 1;
    }
    if ( !*((_BYTE *)&loc_36E03 + dword_D41A0) )
      v35 = (__int16)sub_116A0(a1, 0, *(_WORD *)(a1 + 42));
    if ( v35 )
      sub_6D8B0(*(_WORD *)(a1 + 26), 0x12u, v35);
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
    if ( *((_BYTE *)&loc_36E03 + dword_D41A0) && (*(_BYTE *)(a1 + 62) & 3) == 0 )
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 63);
    LOBYTE(v1) = a1;
    if ( *(_DWORD *)(a1 + 8) == 3 )
    {
      HIBYTE(v12) = v43 - 1;
      v13 = 0;
      v39 = *(__int16 *)(a1 + 80) + *(__int16 *)(a1 + 44) - 24;
      while ( v13 < 2 )
      {
        v14 = 0;
        LOBYTE(v12) = v42 - 1;
        while ( v14 < 2 )
        {
          byte_11B4E0[v12] = v39 - 16;
          if ( *(_BYTE *)(dword_D41A0 + 196308) )
            v31 = 1;
          else
            v31 = 63;
          v15 = v12;
          ++v14;
          LOBYTE(v12) = v12 + 1;
          byte_12B4E0[v15] = v31;
        }
        ++v13;
        ++HIBYTE(v12);
      }
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      word_EB39C = sub_10C40(&word_EB398);
      v1 = *((_BYTE *)&loc_36E03 + dword_D41A0)
         ? sub_4A190((int)&word_EB398, 10, 91)
         : sub_4A190((int)&word_EB398, 10, 18);
      if ( v1 )
        *(_WORD *)(v1 + 26) = *(_WORD *)(a1 + 26);
    }
  }
  return v1;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00031E90) --------------------------------------------------------
int __cdecl sub_31E90(__int16 *a1)
{
  if ( (sub_104A0((int)(a1 + 38)) & 1) == 0 )
  {
    a1[10] = 9377 * a1[10] + 9439;
    sub_572C0(
      a1,
      0,
      (int)(a1[42] - (__CFSHL__((unsigned __int64)a1[42] >> 32, 8) + ((unsigned __int64)a1[42] >> 32 << 8))) >> 8,
      -((unsigned __int16)a1[10] % 7u),
      1);
  }
  return sub_57F10((int)a1);
}

//----- (00031F00) --------------------------------------------------------
int __cdecl sub_31F00(__int16 *a1, __int16 a2, __int16 a3)
{
  int v3; // ebx
  int v4; // esi
  int v5; // edi
  int result; // eax
  int v7; // ebx
  int v8; // [esp+0h] [ebp-Ch] BYREF
  int v9; // [esp+4h] [ebp-8h] BYREF
  int v10; // [esp+8h] [ebp-4h]

  LOWORD(v3) = a3;
  v4 = (a1[38] + 128) >> 8;
  v5 = (a1[39] + 128) >> 8;
  if ( a3 > (int)(a1[42] - (__CFSHL__((unsigned __int64)a1[42] >> 32, 8) + ((unsigned __int64)a1[42] >> 32 << 8))) >> 8 )
    v3 = (int)(a1[42] - (__CFSHL__((unsigned __int64)a1[42] >> 32, 8) + ((unsigned __int64)a1[42] >> 32 << 8))) >> 8;
  v10 = -3;
  result = sub_10080(a2, (__int16)v3);
  v7 = result;
  if ( result )
  {
    while ( sub_10130(v7, &v9, &v8) == 1 )
      sub_56F10(v4 + v9, v5 + v8, v10, 0);
    return sub_10100(v7);
  }
  return result;
}

//----- (00031FB0) --------------------------------------------------------
void __cdecl sub_31FB0(int a1)
{
  int v1; // edx
  unsigned __int16 v2; // ax
  __int16 v3; // ax
  unsigned __int16 v4; // dx
  int v5; // eax
  __int16 v6; // si

  if ( !(*(unsigned __int8 *)(a1 + 62) % 3) )
    ++*(_DWORD *)(a1 + 16);
  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 || (sub_104A0(a1 + 76) & 1) != 0 )
  {
    sub_57F10(a1);
  }
  else
  {
    if ( (*(_BYTE *)(a1 + 12) & 2) != 0 )
      v2 = *(unsigned __int16 *)(a1 + 42) / 25;
    else
      v2 = *(_WORD *)(a1 + 42);
    v3 = sub_116A0(a1, 0, v2);
    if ( v3 )
    {
      v4 = *(_WORD *)(a1 + 38);
      if ( v4 >= 0xBu )
      {
        if ( v4 <= 0xBu )
        {
          sub_6D8B0(*(_WORD *)(a1 + 26), 0x10u, v3);
        }
        else if ( v4 == 15 )
        {
          sub_6D8B0(*(_WORD *)(a1 + 26), 0x11u, v3);
        }
      }
    }
    v5 = (int)(*(__int16 *)(a1 + 84)
             - (__CFSHL__((unsigned __int64)*(__int16 *)(a1 + 84) >> 32, 8)
              + ((unsigned __int64)*(__int16 *)(a1 + 84) >> 32 << 8))) >> 8;
    v6 = *(_WORD *)(a1 + 16);
    if ( v6 > v5 - 1 )
    {
      v6 = v5 - 1;
      if ( (*(_BYTE *)(a1 + 12) & 2) == 0 )
        sub_31F00((__int16 *)a1, v5, v5);
    }
    *(_BYTE *)(a1 + 12) |= 2u;
    sub_31F00((__int16 *)a1, 0, v6);
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
  }
}
// D41A0: using guessed type int dword_D41A0;

//----- (000320E0) --------------------------------------------------------
int __cdecl sub_320E0(int a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 8);
  ++*(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  sub_585A0(a1);
  return sub_112D0(a1, 0);
}

//----- (00032120) --------------------------------------------------------
int __cdecl sub_32120(int a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 8);
  ++*(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  sub_585A0(a1);
  return sub_112D0(a1, 1u);
}

//----- (00032160) --------------------------------------------------------
int __cdecl sub_32160(int a1)
{
  int v1; // eax
  __int16 v3; // dx
  __int16 v4; // ax
  int v5; // edx
  __int16 v6; // si

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  v3 = *(_WORD *)(a1 + 130) - 4;
  *(_WORD *)(a1 + 130) = v3;
  if ( v3 < 64 )
    *(_WORD *)(a1 + 130) = 64;
  if ( *(__int16 *)(a1 + 130) > 128 )
    *(_WORD *)(a1 + 130) = 128;
  word_EB39C += *(_WORD *)(a1 + 130);
  v4 = sub_10C40((__int16 *)(a1 + 76));
  if ( word_EB39C < v4 )
    word_EB39C = v4;
  v5 = *(_DWORD *)(a1 + 16) + 1;
  *(_DWORD *)(a1 + 16) = v5;
  if ( v5 < 16 )
  {
    sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 134));
    v4 = *(_WORD *)(a1 + 134) - 52;
    *(_WORD *)(a1 + 134) = v4;
    if ( v4 < 30 )
      *(_WORD *)(a1 + 134) = 30;
    if ( *(__int16 *)(a1 + 134) > 1024 )
      *(_WORD *)(a1 + 134) = 1024;
    if ( (*(_BYTE *)(a1 + 16) & 1) == 0 )
    {
      v6 = *(_WORD *)(a1 + 90);
      if ( v6 < 74 )
        *(_WORD *)(a1 + 90) = v6 + 1;
    }
  }
  if ( *(int *)(a1 + 8) < 6 )
  {
    v4 = *(_WORD *)(a1 + 90);
    if ( v4 > 67 )
      *(_WORD *)(a1 + 90) = v4 - 1;
  }
  return sub_57CF0(v4, a1, (int)&word_EB398);
}
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (000322A0) --------------------------------------------------------
int __cdecl sub_322A0(int a1)
{
  int v1; // eax
  __int16 v3; // dx
  __int16 v4; // ax
  int v5; // edx
  __int16 v6; // si

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  v3 = *(_WORD *)(a1 + 130) - 4;
  *(_WORD *)(a1 + 130) = v3;
  if ( v3 < 64 )
    *(_WORD *)(a1 + 130) = 64;
  if ( *(__int16 *)(a1 + 130) > 128 )
    *(_WORD *)(a1 + 130) = 128;
  word_EB39C += *(_WORD *)(a1 + 130);
  v4 = sub_10C40((__int16 *)(a1 + 76));
  if ( word_EB39C < v4 )
    word_EB39C = v4;
  v5 = *(_DWORD *)(a1 + 16) + 1;
  *(_DWORD *)(a1 + 16) = v5;
  if ( v5 < 16 )
  {
    sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 134));
    v4 = *(_WORD *)(a1 + 134) - 52;
    *(_WORD *)(a1 + 134) = v4;
    if ( v4 < 30 )
      *(_WORD *)(a1 + 134) = 30;
    if ( *(__int16 *)(a1 + 134) > 1024 )
      *(_WORD *)(a1 + 134) = 1024;
    if ( (*(_BYTE *)(a1 + 16) & 1) == 0 )
    {
      v6 = *(_WORD *)(a1 + 90);
      if ( v6 < 16 )
        *(_WORD *)(a1 + 90) = v6 + 1;
    }
  }
  if ( *(int *)(a1 + 8) < 6 )
  {
    v4 = *(_WORD *)(a1 + 90);
    if ( v4 > 9 )
      *(_WORD *)(a1 + 90) = v4 - 1;
  }
  return sub_57CF0(v4, a1, (int)&word_EB398);
}
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (000323E0) --------------------------------------------------------
char __cdecl sub_323E0(int a1)
{
  return sub_32420(a1);
}

//----- (00032400) --------------------------------------------------------
char __cdecl sub_32400(int a1)
{
  return sub_32420(a1);
}

//----- (00032420) --------------------------------------------------------
char __cdecl sub_32420(int a1)
{
  int v1; // ecx
  int v2; // eax
  int v3; // eax
  __int16 v4; // dx
  __int16 v5; // ax
  __int16 v6; // dx
  __int16 v7; // ax
  int v9; // [esp+0h] [ebp-8h] BYREF
  __int16 v10; // [esp+4h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 - 1;
  if ( v2 < 0 )
  {
    LOBYTE(v3) = sub_57F10(a1);
    return v3;
  }
  v9 = *(_DWORD *)(a1 + 76);
  v10 = *(_WORD *)(a1 + 80);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  LOWORD(v9) = *(_WORD *)(a1 + 20) % 0xA0u + v9;
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  v10 += *(_WORD *)(a1 + 20) % 0xA0u;
  LOBYTE(v3) = *(_BYTE *)(a1 + 64);
  if ( (unsigned __int8)v3 >= 0x3Bu )
  {
    if ( (unsigned __int8)v3 <= 0x3Bu )
    {
      v3 = sub_4E9E0((int)&v9);
    }
    else
    {
      if ( (_BYTE)v3 != 60 )
        goto LABEL_10;
      v3 = sub_4EA20((int)&v9);
    }
    v1 = v3;
  }
LABEL_10:
  if ( v1 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v4 = *(_WORD *)(a1 + 20) % 0x4Du;
    v5 = *(_WORD *)(a1 + 130);
    *(_DWORD *)(v1 + 8) = 32;
    v6 = v5 + v4;
    v7 = *(_WORD *)(v1 + 130);
    *(_DWORD *)(v1 + 4) = 32;
    LOWORD(v3) = v6 + v7;
    *(_WORD *)(v1 + 130) = v3;
  }
  return v3;
}
// 324CA: variable 'v1' is possibly undefined

//----- (00032530) --------------------------------------------------------
int __cdecl sub_32530(int a1)
{
  int v1; // ecx
  int v2; // eax
  int result; // eax
  __int16 v4; // dx

  if ( (sub_104A0(a1 + 76) & 1) != 0 )
  {
    ++*(_DWORD *)(a1 + 16);
  }
  else
  {
    v1 = *(_DWORD *)(a1 + 16);
    if ( v1 > 0 )
      *(_DWORD *)(a1 + 16) = v1 - 1;
  }
  v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 - 1;
  if ( v2 < 0 || *(int *)(a1 + 16) > 8 )
    return sub_57F10(a1);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  *(_WORD *)(a1 + 28) = (*(_WORD *)(a1 + 20) % 0x5Bu + *(_WORD *)(a1 + 28) - 45) & 0x7FF;
  sub_57FA0((_WORD *)(a1 + 76), *(_WORD *)(a1 + 28), 0, 256);
  result = sub_4A190(a1 + 76, 10, 11);
  if ( result )
  {
    *(_DWORD *)(result + 84) = *(_DWORD *)(a1 + 84);
    *(_WORD *)(result + 88) = *(_WORD *)(a1 + 88);
    *(_DWORD *)(result + 8) = 10;
    v4 = *(_WORD *)(a1 + 26);
    *(_WORD *)(result + 38) = 15;
    *(_WORD *)(result + 26) = v4;
  }
  return result;
}

//----- (00032600) --------------------------------------------------------
__int16 __cdecl sub_32600(int a1)
{
  int v1; // eax
  int v2; // eax
  char v3; // ah
  __int16 v4; // di
  __int16 v5; // ax
  int v6; // eax
  __int16 v7; // si
  int v8; // edx
  int v9; // edx
  __int16 v10; // cx
  int v11; // eax
  int v12; // edx

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 >= 0 )
  {
    v3 = *(_BYTE *)(a1 + 12);
    if ( (v3 & 2) == 0 )
      *(_BYTE *)(a1 + 12) = v3 | 2;
    if ( *(__int16 *)(a1 + 154) < -80 )
      *(_WORD *)(a1 + 154) = -80;
    if ( *(__int16 *)(a1 + 154) > 80 )
      *(_WORD *)(a1 + 154) = 80;
    if ( *(__int16 *)(a1 + 156) < -80 )
      *(_WORD *)(a1 + 156) = -80;
    if ( *(__int16 *)(a1 + 156) > 80 )
      *(_WORD *)(a1 + 156) = 80;
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v4 = *(_WORD *)(a1 + 156);
    word_EB398 = *(_WORD *)(a1 + 154) + *(_WORD *)(a1 + 76);
    word_EB39A = v4 + *(_WORD *)(a1 + 78);
    v5 = *(_WORD *)(a1 + 44);
    word_EB39C += v5;
    *(_WORD *)(a1 + 44) = v5 - 28;
    if ( (__int16)(v5 - 28) < -384 )
      *(_WORD *)(a1 + 44) = -384;
    if ( *(__int16 *)(a1 + 44) > 256 )
      *(_WORD *)(a1 + 44) = 256;
    LOWORD(v6) = sub_10C40(&word_EB398);
    v7 = v6;
    if ( (__int16)v6 > word_EB39C )
    {
      v8 = *(__int16 *)(a1 + 44);
      word_EB39C = v6;
      *(_WORD *)(a1 + 44) = -(__int16)((v8 - (__CFSHL__(v8 >> 31, 2) + 4 * (v8 >> 31))) >> 2);
      if ( sub_104D0((__int16 *)(a1 + 76)) == 1 )
      {
        v6 = sub_4A190((int)&word_EB398, 10, 5);
        if ( v6 )
        {
          *(_WORD *)(v6 + 26) = *(_WORD *)(a1 + 26);
          LOWORD(v6) = sub_57F10(a1);
        }
      }
      else
      {
        v6 = sub_10B70((unsigned __int16 *)&word_EB398, 10, 6);
        if ( !v6 )
        {
          v6 = sub_4A190((int)&word_EB398, 10, 6);
          v9 = v6;
          if ( v6 )
          {
            v10 = *(_WORD *)(v6 + 42);
            *(_WORD *)(v6 + 26) = *(_WORD *)(a1 + 26);
            LOWORD(v6) = 3 * v10;
            *(_DWORD *)(v9 + 8) = 30;
            *(_WORD *)(v9 + 42) = 3 * v10;
            *(_DWORD *)(a1 + 16) = 0;
          }
        }
        if ( *(__int16 *)(a1 + 44) <= 28 )
          *(_WORD *)(a1 + 44) = 0;
      }
    }
    ++*(_DWORD *)(a1 + 16);
    sub_57CF0(v6, a1, (int)&word_EB398);
    LOWORD(v2) = word_EB39C;
    if ( v7 == word_EB39C )
    {
      sub_58030(a1 + 76, &word_EB398);
      *(_WORD *)(a1 + 154) += word_EB398;
      v11 = 250 * *(__int16 *)(a1 + 154);
      *(_WORD *)(a1 + 156) += word_EB39A;
      v12 = *(__int16 *)(a1 + 156);
      *(_WORD *)(a1 + 154) = (v11 - (__CFSHL__(v11 >> 31, 8) + (v11 >> 31 << 8))) >> 8;
      v2 = (250 * v12 - (__CFSHL__((250 * v12) >> 31, 8) + ((250 * v12) >> 31 << 8))) >> 8;
      *(_WORD *)(a1 + 156) = v2;
    }
  }
  else
  {
    LOWORD(v2) = sub_57F10(a1);
  }
  return v2;
}
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00032880) --------------------------------------------------------
int __cdecl sub_32880(int a1)
{
  int v1; // edx
  int result; // eax
  int v3; // edx
  __int16 v4; // ax
  int v5; // edi
  int v6; // eax
  int v7; // esi
  int v8; // ecx
  __int16 v9[4]; // [esp+0h] [ebp-10h] BYREF
  int v10; // [esp+8h] [ebp-8h] BYREF
  int v11; // [esp+Ch] [ebp-4h] BYREF

  v1 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  if ( (*(_BYTE *)(a1 + 12) & 2) == 0 )
  {
    v3 = a1 - (dword_D41A0 + 28302);
    *(_DWORD *)(a1 + 12) |= (unsigned int)&loc_10001 + 1;
    sub_6E450(v3 / 168, -1, 30);
  }
  sub_49EA0(
    (_WORD *)a1,
    (768 * *(_DWORD *)(a1 + 16)
   - (__CFSHL__((768 * *(_DWORD *)(a1 + 16)) >> 31, 2)
    + 4 * ((768 * *(_DWORD *)(a1 + 16)) >> 31))) >> 2,
    512);
  v4 = sub_10C80(a1, 0, *(unsigned __int16 *)(a1 + 42) / *(int *)(a1 + 4));
  if ( v4 )
    sub_6D8B0(*(_WORD *)(a1 + 26), 9u, v4);
  v5 = sub_10080(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 16));
  if ( v5 )
  {
    while ( sub_10130(v5, &v10, &v11) == 1 )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v9[0] = *(_WORD *)(a1 + 76) - 96 + 160 * v10 + *(_WORD *)(a1 + 20) % 0x81u - 64;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v9[1] = *(_WORD *)(a1 + 20) % 0x81u + 160 * v11 + *(_WORD *)(a1 + 78) - 96 - 64;
      v9[2] = *(_WORD *)(a1 + 80);
      v6 = sub_4A190((int)v9, 10, 0);
      v7 = v6;
      if ( v6 )
      {
        v8 = *(_DWORD *)(v6 + 12);
        *(_WORD *)(v6 + 26) = *(_WORD *)(a1 + 26);
        *(_WORD *)(v6 + 28) = *(_WORD *)(a1 + 28);
        *(_DWORD *)(v6 + 12) = (unsigned int)sub_10080 | v8;
        sub_49EA0((_WORD *)v6, 512, 512);
        *(_DWORD *)(v7 + 16) = 0;
      }
    }
    sub_10100(v5);
  }
  result = (*(_DWORD *)(a1 + 16) + 2) / 11;
  *(_DWORD *)(a1 + 16) = (*(_DWORD *)(a1 + 16) + 2) % 11;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00032A70) --------------------------------------------------------
void __cdecl sub_32A70(int a1)
{
  __int16 v1; // si
  __int16 v2; // ax
  __int16 v3; // si
  __int16 v4; // ax
  unsigned int v5; // eax
  int v6; // eax
  int v7; // esi
  int v8; // eax
  __int16 v9; // dx
  int v10; // esi
  __int16 v11; // ax
  int v12; // [esp+0h] [ebp-4h]

  if ( *(int *)(a1 + 16) > 2500 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    if ( !(*(unsigned __int16 *)(a1 + 20) % 0x64u) && !*(_WORD *)(dword_D41A0 + 49) )
    {
      v1 = *(_WORD *)(a1 + 80);
      v2 = sub_10C40((__int16 *)(a1 + 76));
      *(_WORD *)(a1 + 80) = v2;
      if ( v1 != v2 )
      {
        sub_57F10(a1);
        return;
      }
      *(_DWORD *)(a1 + 16) = 0;
    }
  }
  if ( *(int *)(a1 + 16) < 128
    && (*(_BYTE *)(a1 + 16) & 0xF) != 0
    && (*(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439, !(*(unsigned __int16 *)(a1 + 20) % 5u))
    || !*(_DWORD *)(a1 + 16) )
  {
    v3 = *(_WORD *)(a1 + 80);
    v4 = sub_10C40((__int16 *)(a1 + 76));
    *(_WORD *)(a1 + 80) = v4;
    if ( v3 != v4 )
    {
      sub_57F10(a1);
      *(_WORD *)(dword_D41A0 + 49) = 0;
      return;
    }
    if ( !*(_DWORD *)(a1 + 16) )
    {
      v5 = dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 49)];
      if ( v5 > dword_EA3E4[0] )
        *(_DWORD *)(v5 + 16) = 250;
      *(_WORD *)(dword_D41A0 + 49) = (a1 - (dword_D41A0 + 28302)) / 168;
      v6 = sub_4A190(a1 + 76, 10, 19);
      v7 = v6;
      if ( v6 )
      {
        *(_WORD *)(v6 + 26) = *(_WORD *)(a1 + 26);
        if ( (unsigned int)dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 51)] > dword_EA3E4[0] )
          sub_57F10(dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 51)]);
        *(_WORD *)(dword_D41A0 + 51) = (v7 - (dword_D41A0 + 28302)) / 168;
      }
    }
    v8 = sub_4A190(a1 + 76, 10, 16);
    if ( v8 )
    {
      *(_WORD *)(v8 + 26) = *(_WORD *)(a1 + 26);
      v9 = 9377 * *(_WORD *)(a1 + 20) + 9439;
      *(_WORD *)(a1 + 20) = v9;
      *(_WORD *)(v8 + 20) = v9;
    }
    v10 = *(_DWORD *)(a1 + 16);
    *(_BYTE *)(a1 + 29) += 5;
    if ( !v10 )
    {
      v12 = sub_4A190(a1 + 76, 9, 0);
      if ( v12 )
      {
        *(_WORD *)(v12 + 26) = *(_WORD *)(a1 + 26);
        v11 = *(_WORD *)(a1 + 28);
        *(_WORD *)(v12 + 30) = -386;
        *(_BYTE *)(v12 + 67) = 10;
        *(_BYTE *)(v12 + 68) = 17;
        HIBYTE(v11) &= 7u;
        *(_DWORD *)(v12 + 8) = 1;
        *(_WORD *)(v12 + 28) = v11;
        *(_DWORD *)(v12 + 154) = *(_DWORD *)(a1 + 76);
        *(_WORD *)(v12 + 158) = *(_WORD *)(a1 + 80);
        sub_57FA0((_WORD *)(v12 + 154), *(_WORD *)(v12 + 28), 0, 1536);
        *(_WORD *)(v12 + 158) = sub_10C40((__int16 *)(v12 + 154));
      }
    }
    if ( *(int *)(a1 + 16) >= 127 )
    {
      sub_57F10(a1);
      *(_WORD *)(dword_D41A0 + 49) = 0;
    }
  }
  ++*(_DWORD *)(a1 + 16);
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00032CF0) --------------------------------------------------------
void __cdecl sub_32CF0(int a1)
{
  int v1; // eax
  int v2; // ecx
  int v3; // ebx
  char v4; // ah
  __int16 v5; // t2
  __int16 v6; // ax
  unsigned int v7; // ecx
  int v8; // esi
  __int16 v9; // ax
  __int16 v10; // ax
  __int16 v11; // cx
  __int16 v12; // ax
  char *v13; // esi
  int j; // ebx
  unsigned __int16 v15; // [esp-8h] [ebp-Ch]
  int v16; // [esp-4h] [ebp-8h]
  int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 3; ++i )
  {
    v1 = sub_4A190(a1 + 76, 10, 39);
    v2 = v1;
    v3 = v1;
    if ( v1 )
    {
      v4 = *(_BYTE *)(v1 + 13) | 0x20;
      *(_DWORD *)(v2 + 4) = 140;
      *(_BYTE *)(v2 + 13) = v4;
      *(_DWORD *)(v2 + 8) = *(_DWORD *)(v2 + 4);
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v5 = *(_WORD *)(a1 + 20) % 0x300u;
      *(_WORD *)(v2 + 130) = v5;
      if ( v5 < 64 )
        *(_WORD *)(v2 + 130) = 64;
      if ( *(__int16 *)(v3 + 130) > 768 )
        *(_WORD *)(v3 + 130) = 768;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v6 = *(_WORD *)(a1 + 20) & 0x7F;
      *(_WORD *)(v3 + 148) = 0;
      *(_WORD *)(v3 + 44) = v6 + 128;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v7 = *(unsigned __int16 *)(a1 + 20) % 9u - 1;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v8 = 0;
      *(_DWORD *)(v3 + 144) = *(unsigned __int16 *)(a1 + 20) % 0xA00u + 1;
      while ( v8 < 7 && *(_DWORD *)(v3 + 144) > dword_DB538[v8] )
        ++v8;
      v9 = sub_36A50(v3, v7);
      sub_49CD0((_WORD *)v3, v8 + v9);
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v10 = *(_WORD *)(a1 + 20) & 0x7FF;
      *(_WORD *)(v3 + 30) = 0;
      *(_WORD *)(v3 + 28) = v10;
      *(_WORD *)(v3 + 32) = *(_WORD *)(v3 + 28);
      *(_DWORD *)(v3 + 154) = *(_DWORD *)(a1 + 76);
      *(_WORD *)(v3 + 158) = *(_WORD *)(a1 + 80);
      sub_57FA0((_WORD *)(v3 + 154), *(_WORD *)(v3 + 28), 0, *(_WORD *)(v3 + 130));
      v11 = *(_WORD *)(v3 + 156);
      v12 = *(_WORD *)(v3 + 78);
      *(_WORD *)(v3 + 154) -= *(_WORD *)(v3 + 76);
      *(_WORD *)(v3 + 156) = v11 - v12;
      *(_WORD *)(v3 + 80) = sub_10C40((__int16 *)(v3 + 76)) + 96;
    }
  }
  if ( (*(_BYTE *)(a1 + 62) & 1) == 0 )
  {
    v13 = byte_DA818;
    for ( j = 0; j < 26; ++j )
    {
      v16 = (*(_DWORD *)(v13 + 66) - (__CFSHL__(*(int *)(v13 + 66) >> 31, 9) + (*(int *)(v13 + 66) >> 31 << 9))) >> 9;
      v15 = j;
      v13 += 80;
      sub_6D8B0(*(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240), v15, v16);
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// DB538: using guessed type int dword_DB538[8];

//----- (00032F40) --------------------------------------------------------
int __cdecl sub_32F40(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // eax
  __int16 v5[4]; // [esp+0h] [ebp-14h] BYREF
  int v6; // [esp+8h] [ebp-Ch] BYREF
  int v7; // [esp+Ch] [ebp-8h] BYREF
  int v8; // [esp+10h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 >= 0 )
  {
    *(_DWORD *)(a1 + 16) = 0;
    v2 = sub_10080(0, *(_DWORD *)(a1 + 16));
    if ( v2 )
    {
      while ( sub_10130(v2, &v7, &v6) == 1 )
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        if ( (int)(2 * (*(unsigned __int16 *)(a1 + 20) % 0x9Du / 79i64) - 1) > 0 )
        {
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          v5[0] = *(_WORD *)(a1 + 20) % 0x81u + *(_WORD *)(a1 + 76) - 96 + 192 * v7 - 64;
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          v5[1] = *(_WORD *)(a1 + 78) - 96 + 192 * v6 + *(_WORD *)(a1 + 20) % 0x81u - 64;
          v5[2] = *(_WORD *)(a1 + 80);
          if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
          {
            LOWORD(v8) = ((*(_DWORD *)(a1 + 8) / 2) & 1) << 8;
            while ( (unsigned __int16)v8 < 0x800u )
            {
              v3 = sub_4A190((int)v5, 10, 14);
              if ( v3 )
              {
                *(_WORD *)(v3 + 26) = *(_WORD *)(a1 + 26);
                *(_WORD *)(v3 + 28) = v8;
              }
              BYTE1(v8) += 2;
            }
          }
        }
      }
      sub_10100(v2);
    }
    *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
  }
  else
  {
    sub_57F10(a1);
    *(_WORD *)(dword_D41A0 + 51) = 0;
  }
  return sub_10C80(a1, 0, *(_WORD *)(a1 + 42));
}
// D41A0: using guessed type int dword_D41A0;

//----- (00033110) --------------------------------------------------------
void __cdecl sub_33110(unsigned int a1)
{
  int v1; // edx

  v1 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v1;
  if ( v1 < 0 )
  {
    sub_6EAB0((__int16)((int)(a1 - (dword_D41A0 + 28302)) / 168), -1, 49);
    sub_338D0(a1);
  }
  else
  {
    sub_331A0(a1);
    sub_33340((_WORD *)a1);
    sub_33710(a1);
    sub_6E450((int)(a1 - (dword_D41A0 + 28302)) / 168, -1, 49);
  }
}
// D41A0: using guessed type int dword_D41A0;

//----- (000331A0) --------------------------------------------------------
_WORD *__cdecl sub_331A0(int a1)
{
  __int16 v1; // ax
  __int16 v2; // ax
  _WORD *result; // eax
  _WORD *v4; // edi
  signed int v5; // eax
  int v6; // edi
  _WORD *v7; // [esp+0h] [ebp-4h]

  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  *(_WORD *)(a1 + 48) = word_EB39C;
  if ( (*(_BYTE *)(a1 + 62) & 0xF) == 0 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    if ( (*(_WORD *)(a1 + 20) & 1) == 0 )
      *(_WORD *)(a1 + 46) = -*(_WORD *)(a1 + 46);
  }
  v1 = *(_WORD *)(a1 + 32) + 11 * *(_WORD *)(a1 + 46);
  HIBYTE(v1) &= 7u;
  *(_WORD *)(a1 + 32) = v1;
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 32), 0, 32);
  *(_DWORD *)(a1 + 154) = *(_DWORD *)&word_EB398;
  *(_WORD *)(a1 + 158) = *(&word_EB398 + 2);
  v2 = *(_WORD *)(a1 + 28) + 341;
  HIBYTE(v2) &= 7u;
  *(_WORD *)(a1 + 28) = v2;
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, 120);
  word_EB39C = sub_10C40(&word_EB398);
  sub_57CF0(word_EB39C, a1, (int)&word_EB398);
  v7 = (_WORD *)dword_EA3E4[*(unsigned __int16 *)(a1 + 52)];
  result = (_WORD *)a1;
  while ( (unsigned int)v7 > dword_EA3E4[0] )
  {
    *(_DWORD *)&word_EB398 = *((_DWORD *)v7 + 19);
    *(&word_EB398 + 2) = v7[40];
    v4 = result + 38;
    v7[14] = sub_581E0(v7 + 38, result + 38);
    v5 = sub_58490(v4, v7 + 38);
    v6 = 72 - 4 * (12 - (__int16)v7[22]);
    if ( v5 > v6 )
      sub_57FA0(&word_EB398, v7[14], 0, v5 - v6);
    word_EB39C = v7[27] + *(_WORD *)(a1 + 80);
    sub_57CF0(word_EB39C, (int)v7, (int)&word_EB398);
    result = v7;
    v7 = (_WORD *)dword_EA3E4[(unsigned __int16)v7[26]];
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00033340) --------------------------------------------------------
void __cdecl sub_33340(_WORD *a1)
{
  int i; // ebx
  char v2; // dl
  int v3; // eax
  int v4; // eax
  int v5; // eax
  __int16 v6; // dx
  int v7; // eax
  __int16 v8; // cx
  int v9; // edi
  __int16 v10; // si
  __int16 v11; // ax
  __int16 v12; // cx
  unsigned int v13; // esi
  __int16 v14; // dx
  __int16 v15; // ax
  __int16 v16; // ax
  char v17; // ch
  int v18; // edx
  int v19; // edi
  int v20; // esi
  int v21; // eax
  __int16 v22; // ax
  __int16 v23; // ax
  int v24; // esi
  int v25; // [esp-Ch] [ebp-40h]
  int v26; // [esp-8h] [ebp-3Ch]
  __int16 v27; // [esp-4h] [ebp-38h]
  unsigned __int16 v28; // [esp-4h] [ebp-38h]
  int v29; // [esp+0h] [ebp-34h] BYREF
  int v30; // [esp+4h] [ebp-30h] BYREF
  int v31; // [esp+8h] [ebp-2Ch]
  int v32; // [esp+Ch] [ebp-28h]
  int v33; // [esp+10h] [ebp-24h]
  int v34; // [esp+14h] [ebp-20h]
  int v35; // [esp+18h] [ebp-1Ch]
  int v36; // [esp+1Ch] [ebp-18h]
  int v37; // [esp+20h] [ebp-14h]
  int v38; // [esp+24h] [ebp-10h]
  int v39; // [esp+28h] [ebp-Ch]
  char v40; // [esp+2Ch] [ebp-8h]
  _BOOL1 v41; // [esp+30h] [ebp-4h]

  v32 = 0;
  v33 = ((unsigned __int16)a1[38] + 128) >> 8;
  v37 = ((unsigned __int16)a1[39] + 128) >> 8;
  v36 = sub_10080(0, 12);
  if ( v36 )
  {
    while ( 1 )
    {
      v24 = v36;
      if ( sub_10130(v36, &v30, &v29) != 1 )
        break;
      for ( i = dword_EA3E4[word_15B4E0[256 * (unsigned __int8)(v29 + v37) + (unsigned __int8)(v30 + v33)]];
            i != dword_EA3E4[0];
            i = dword_EA3E4[*(unsigned __int16 *)(i + 22)] )
      {
        if ( sub_33810((int)a1, i) )
        {
          v2 = *(_BYTE *)(i + 63);
          v40 = 0;
          v38 = 0;
          v31 = 0;
          v41 = v2 == 3 && !*(_BYTE *)(i + 64);
          if ( v41 )
            v3 = 56;
          else
            v3 = 204;
          v39 = v3;
          if ( v41 )
            v4 = 384;
          else
            v4 = 768;
          v35 = v4;
          v5 = sub_584D0(a1 + 77, (_WORD *)(i + 76));
          v34 = v5;
          if ( v5 >= 3211264 )
          {
            *(_DWORD *)&word_EB398 = *(_DWORD *)(i + 76);
            *(&word_EB398 + 2) = *(_WORD *)(i + 80);
            if ( (*(_BYTE *)(i + 15) & 0x10) != 0 )
            {
              v17 = *(_BYTE *)(i + 13) | 8;
              v40 = 1;
              v18 = *(_DWORD *)(i + 160);
              *(_BYTE *)(i + 13) = v17;
              v38 = *(__int16 *)(v18 + 14);
              LOWORD(v18) = v39 + *(_WORD *)(i + 28);
              BYTE1(v18) &= 7u;
              v31 = 64;
              *(_WORD *)(i + 28) = v18;
              if ( v5 >= 5308416 )
                *(_BYTE *)(i + 15) &= ~0x10u;
            }
          }
          else
          {
            v6 = sub_581E0(a1 + 77, (_WORD *)(i + 76));
            if ( (*(_BYTE *)(i + 15) & 0x10) != 0 )
            {
              *(_BYTE *)(i + 13) |= 8u;
              v31 = 128;
              *(_DWORD *)&word_EB398 = *(_DWORD *)(i + 76);
              *(&word_EB398 + 2) = *(_WORD *)(i + 80);
              v15 = *(_WORD *)(i + 28);
              v40 = 1;
              v16 = v39 + v15;
              HIBYTE(v16) &= 7u;
              word_EB39C += 114;
              *(_WORD *)(i + 28) = v16;
            }
            else
            {
              if ( v41 )
              {
                v7 = *(_DWORD *)(i + 164);
                v8 = *(_WORD *)(v7 + 341);
                if ( v8 < 256 )
                  *(_WORD *)(v7 + 341) = v8 + 28;
                *(_WORD *)(i + 130) = 80;
              }
              if ( v34 >= (int)&loc_40000 )
              {
                v14 = v6 + 591;
                HIBYTE(v14) &= 7u;
                *(_DWORD *)&word_EB398 = *(_DWORD *)(i + 76);
                *(&word_EB398 + 2) = *(_WORD *)(i + 80);
                *(_WORD *)(i + 48) = v14;
                *(_WORD *)(i + 28) = v14;
                v31 = 96;
              }
              else
              {
                *(_BYTE *)(i + 13) |= 8u;
                *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 77);
                *(&word_EB398 + 2) = a1[79];
                v9 = *(__int16 *)(i + 80) - (__int16)a1[24] + 57;
                v10 = sub_10C40(&word_EB398);
                word_EB39C = v9 + v10;
                if ( (__int16)(v9 + v10) < v10 )
                  word_EB39C = v10;
                v11 = v39 + *(_WORD *)(i + 28);
                HIBYTE(v11) &= 7u;
                v12 = *(_WORD *)(i + 20);
                *(_WORD *)(i + 28) = v11;
                v13 = v35;
                *(_WORD *)(i + 20) = 9377 * v12 + 9439;
                if ( v9 >= (int)(v13 + *(unsigned __int16 *)(i + 20) % v13) )
                {
                  *(_BYTE *)(i + 15) |= 0x10u;
                  *(_WORD *)(i + 48) = *(_WORD *)(i + 28);
                }
              }
            }
          }
          sub_57FA0(&word_EB398, *(_WORD *)(i + 48), 0, v31);
          if ( byte_D41B6 )
          {
            v19 = *(__int16 *)(i + 88);
            v20 = (__int16)sub_10C60(&word_EB398) - v19;
            if ( word_EB39C > v20 )
              word_EB39C = v20;
          }
          v21 = *(_DWORD *)(i + 160);
          v27 = v38;
          v26 = *(__int16 *)(v21 + 10);
          v25 = *(__int16 *)(v21 + 12);
          v22 = sub_10C40(&word_EB398);
          v23 = sub_580E0((int)&word_EB398, v22, v25, v26, v27);
          sub_57CF0(v23, i, (int)&word_EB398);
          if ( v40 )
          {
            v28 = a1[21];
            ++v32;
            sub_11900((int)a1, i, 0, v28);
          }
        }
      }
    }
    sub_10100(v24);
    if ( v32 )
      sub_6D8B0(a1[13], 0x15u, v32);
  }
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00033710) --------------------------------------------------------
void __cdecl sub_33710(int a1)
{
  int v1; // edi
  _DWORD *i; // ebx
  unsigned int j; // ebx
  __int16 v4; // ax

  v1 = 0;
  if ( (*(_BYTE *)(a1 + 62) & 7) == 0 )
  {
    for ( i = *(_DWORD **)(dword_D41A4 + 38527); (unsigned int)i > dword_EA3E4[0]; i = (_DWORD *)*i )
    {
      if ( sub_10750(a1, (int)i) )
        sub_11900(a1, (int)i, 0, *(_WORD *)(a1 + 42));
    }
    for ( j = *(_DWORD *)(dword_D41A4 + 38519); j > dword_EA3E4[0]; j = *(_DWORD *)j )
    {
      if ( *(_BYTE *)(j + 64) == 2 && sub_10750(a1, j) )
      {
        v4 = (a1 - (dword_D41A0 + 28302)) / 168;
        *(_WORD *)(j + 48) = 30;
        *(_WORD *)(j + 38) = v4;
        *(_DWORD *)(j + 94) += *(unsigned __int16 *)(a1 + 42);
        v1 += 2;
        *(_WORD *)(j + 98) = *(_WORD *)(a1 + 26);
      }
    }
    if ( v1 )
      sub_6D8B0(*(_WORD *)(a1 + 26), 0x15u, v1);
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00033810) --------------------------------------------------------
char __cdecl sub_33810(int a1, int a2)
{
  char result; // al
  char v3; // bl
  unsigned __int8 v4; // ah
  unsigned __int8 v5; // ah
  unsigned __int8 v6; // ah

  result = 1;
  switch ( *(_BYTE *)(a2 + 63) )
  {
    case 2:
      v6 = *(_BYTE *)(a2 + 64);
      if ( v6 < 7u || v6 > 8u )
        goto LABEL_25;
      break;
    case 3:
      if ( *(_WORD *)(a2 + 26) == *(_WORD *)(a1 + 26) )
        goto LABEL_25;
      if ( *(_BYTE *)(a2 + 64) == 2 )
        result = 0;
      break;
    case 5:
      v3 = *(_BYTE *)(a2 + 69);
      if ( v3 == -24 || v3 == -76 )
        goto LABEL_25;
      v4 = *(_BYTE *)(a2 + 64);
      if ( v4 < 0xFu )
      {
        if ( v4 == 10 )
          result = 0;
      }
      else if ( v4 <= 0xFu || v4 >= 0x12u && (v4 <= 0x12u || v4 >= 0x1Bu && v4 <= 0x1Cu) )
      {
        goto LABEL_25;
      }
      break;
    case 0xA:
      v5 = *(_BYTE *)(a2 + 64);
      if ( v5 < 0x27u )
      {
        if ( v5 < 0xDu )
          goto LABEL_25;
        if ( v5 > 0xEu )
          result = 0;
      }
      else if ( v5 > 0x27u && v5 != 57 )
      {
        result = 0;
      }
      break;
    default:
LABEL_25:
      result = 0;
      break;
  }
  return result;
}

//----- (000338D0) --------------------------------------------------------
unsigned int __cdecl sub_338D0(unsigned int a1)
{
  int v1; // edi
  int v2; // esi
  unsigned int result; // eax
  int v4; // edi
  int v5; // ebx
  int i; // eax
  int v7; // eax
  unsigned int j; // ebx
  int v9; // [esp+0h] [ebp-8h] BYREF
  int v10; // [esp+4h] [ebp-4h] BYREF

  v1 = *(unsigned __int16 *)(a1 + 78) + 128;
  v2 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
  result = sub_10080(0, 12);
  v4 = v1 >> 8;
  v5 = result;
  if ( result )
  {
    while ( sub_10130(v5, &v10, &v9) == 1 )
    {
      for ( i = word_15B4E0[256 * (unsigned __int8)(v4 + v9) + (unsigned __int8)(v2 + v10)];
            ;
            i = *(unsigned __int16 *)(v7 + 22) )
      {
        v7 = dword_EA3E4[i];
        if ( v7 == dword_EA3E4[0] )
          break;
        *(_DWORD *)(v7 + 12) &= 0xEFFFF7FF;
      }
    }
    result = sub_10100(v5);
  }
  for ( j = a1; j > dword_EA3E4[0]; j = dword_EA3E4[*(unsigned __int16 *)(j + 52)] )
    result = sub_57F10(j);
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (000339B0) --------------------------------------------------------
char __cdecl sub_339B0(int a1)
{
  __int16 v1; // ax
  unsigned __int16 v2; // dx
  int v3; // eax
  __int16 v4; // cx
  int v5; // edx
  char v6; // ah
  __int16 v7; // di

  LOBYTE(v1) = *(_BYTE *)(a1 + 70);
  if ( (_BYTE)v1 )
  {
    if ( (unsigned __int8)v1 > 1u )
    {
      if ( (_BYTE)v1 == 2 )
      {
        v6 = *(_BYTE *)(a1 + 61);
        if ( v6 < 0 )
          *(_BYTE *)(a1 + 61) = -v6;
        sub_33B20(a1);
        v1 = *(char *)(a1 + 61);
        v7 = *(_WORD *)(a1 + 44) - v1;
        *(_WORD *)(a1 + 44) = v7;
        if ( v7 < 0 )
        {
          sub_4A190(a1 + 76, 10, 0);
          LOBYTE(v1) = sub_33D40(a1);
        }
      }
      return v1;
    }
  }
  else
  {
    v2 = *(_WORD *)(a1 + 150);
    if ( v2 )
    {
      v3 = dword_EA3E4[v2];
      *(_WORD *)(a1 + 134) = *(__int16 *)(v3 + 84) >> 1;
      v4 = *(_WORD *)(a1 + 134);
      *(_WORD *)(a1 + 132) = (6 * *(__int16 *)(v3 + 84)) >> 2;
      if ( v4 < 128 )
        *(_WORD *)(a1 + 134) = 128;
      if ( *(__int16 *)(a1 + 132) > 640 )
        *(_WORD *)(a1 + 132) = 640;
    }
    *(_BYTE *)(a1 + 70) = 1;
  }
  sub_33C70(a1);
  sub_33AD0(a1);
  sub_33B20(a1);
  LOBYTE(v1) = sub_33C00(a1);
  v5 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v5;
  if ( v5 < 1 )
    *(_BYTE *)(a1 + 70) = 2;
  return v1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00033AD0) --------------------------------------------------------
int __cdecl sub_33AD0(int a1)
{
  int result; // eax
  __int16 v2; // bx
  __int16 v3; // cx
  char v4; // dl
  __int16 v5; // si
  char v6; // dh

  result = a1;
  v2 = *(char *)(a1 + 61) + *(_WORD *)(a1 + 44);
  v3 = *(_WORD *)(a1 + 132);
  *(_WORD *)(a1 + 44) = v2;
  if ( v2 <= v3 )
  {
    v5 = *(_WORD *)(a1 + 134);
    if ( v2 < v5 )
    {
      v6 = *(_BYTE *)(a1 + 61);
      *(_WORD *)(a1 + 44) = v5;
      *(_BYTE *)(a1 + 61) = -v6;
    }
  }
  else
  {
    v4 = *(_BYTE *)(a1 + 61);
    *(_WORD *)(a1 + 44) = v3;
    *(_BYTE *)(a1 + 61) = -v4;
  }
  return result;
}

//----- (00033B20) --------------------------------------------------------
__int16 __cdecl sub_33B20(int a1)
{
  __int16 v1; // ax
  __int16 v2; // ax
  int i; // eax
  __int16 v4; // ax
  __int16 v5; // ax
  __int16 v6; // ax
  unsigned __int16 v7; // ax
  __int16 v8; // ax
  _WORD *v9; // ebx
  __int16 v11; // [esp-8h] [ebp-8h]

  v1 = *(_WORD *)(a1 + 28) + 22;
  HIBYTE(v1) &= 7u;
  *(_WORD *)(a1 + 28) = v1;
  v2 = *(_WORD *)(a1 + 30) + 16;
  HIBYTE(v2) &= 7u;
  *(_WORD *)(a1 + 30) = v2;
  for ( i = *(unsigned __int16 *)(a1 + 52); ; i = (unsigned __int16)v9[26] )
  {
    v9 = (_WORD *)dword_EA3E4[i];
    if ( (unsigned int)v9 <= dword_EA3E4[0] )
      break;
    v4 = v9[16] + v9[14];
    HIBYTE(v4) &= 7u;
    v9[14] = v4;
    v5 = v9[17] + v9[15];
    HIBYTE(v5) &= 7u;
    v9[15] = v5;
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v6 = v9[15] + *(_WORD *)(a1 + 30);
    HIBYTE(v6) &= 7u;
    v11 = v6;
    v7 = v9[14] + *(_WORD *)(a1 + 28);
    HIBYTE(v7) &= 7u;
    v8 = (unsigned __int16)sub_57FA0(&word_EB398, v7, v11, *(_WORD *)(a1 + 44));
    sub_57CF0(v8, (int)v9, (int)&word_EB398);
  }
  return i;
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00033C00) --------------------------------------------------------
int __cdecl sub_33C00(int a1)
{
  int result; // eax
  unsigned int v2; // ebx

  for ( result = *(unsigned __int16 *)(a1 + 52); ; result = *(unsigned __int16 *)(v2 + 52) )
  {
    v2 = dword_EA3E4[result];
    if ( v2 <= dword_EA3E4[0] )
      break;
    if ( !*(_BYTE *)(v2 + 68) )
    {
      if ( (unsigned __int16)sub_10C80(v2, 0, *(_WORD *)(a1 + 42)) )
        sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 3);
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00033C70) --------------------------------------------------------
int __cdecl sub_33C70(int a1)
{
  unsigned __int16 v1; // dx
  int v2; // eax
  int v3; // edi
  int result; // eax
  int v5; // esi
  int v6; // edi
  int v7; // esi
  int v8; // [esp+0h] [ebp-8h]
  char v9; // [esp+4h] [ebp-4h]

  v1 = *(_WORD *)(a1 + 150);
  v9 = 0;
  if ( v1 )
  {
    v2 = dword_EA3E4[v1];
    *(_DWORD *)&word_EB398 = *(_DWORD *)(v2 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(v2 + 80);
    v8 = v2;
    LOWORD(v2) = *(_WORD *)(v2 + 82);
    word_EB39C += v2;
    sub_57CF0(v2, a1, (int)&word_EB398);
    if ( *(int *)(v8 + 8) < 0 || (*(_BYTE *)(v8 + 13) & 4) != 0 )
      v9 = 1;
  }
  v3 = *(__int16 *)(a1 + 44);
  result = sub_10C40((__int16 *)(a1 + 76));
  v5 = v3 + (__int16)result;
  if ( *(__int16 *)(a1 + 80) < v5 )
    *(_WORD *)(a1 + 80) = v5;
  if ( byte_D41B6 )
  {
    v6 = *(__int16 *)(a1 + 44);
    result = sub_10C60((__int16 *)(a1 + 76));
    v7 = (__int16)result - v6;
    if ( *(__int16 *)(a1 + 80) > v7 )
      *(_WORD *)(a1 + 80) = v7;
  }
  if ( v9 )
    *(_BYTE *)(a1 + 70) = 2;
  return result;
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00033D40) --------------------------------------------------------
int __cdecl sub_33D40(int a1)
{
  int i; // ebx
  unsigned int v2; // ebx

  for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v2 + 52) )
  {
    v2 = dword_EA3E4[i];
    if ( v2 <= dword_EA3E4[0] )
      break;
    sub_57F10(v2);
  }
  return sub_57F10(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00033D80) --------------------------------------------------------
void __cdecl sub_33D80(int a1)
{
  int v1; // eax
  __int16 v2; // ax
  char v3; // dl

  v1 = *(_DWORD *)(a1 + 8);
  ++*(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 >= 0 )
  {
    if ( (*(_BYTE *)(a1 + 12) & 2) == 0 )
    {
      v2 = sub_10C80(a1, 0, *(_WORD *)(a1 + 42));
      if ( v2 )
        sub_6D8B0(*(_WORD *)(a1 + 26), 7u, v2);
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 24);
      v3 = *(_BYTE *)(a1 + 12);
      *(_DWORD *)(a1 + 8) = 1;
      *(_BYTE *)(a1 + 12) = v3 | 2;
    }
  }
  else
  {
    sub_57F10(a1);
  }
}
// D41A0: using guessed type int dword_D41A0;

//----- (00033E20) --------------------------------------------------------
void __cdecl sub_33E20(int a1)
{
  int v1; // ecx
  unsigned __int16 v2; // [esp-4h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 8) - 1;
  ++*(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 8) = v1;
  if ( v1 >= 0 )
  {
    if ( (*(_BYTE *)(a1 + 12) & 2) == 0 )
    {
      v2 = *(char *)(a1 + 70);
      *(_BYTE *)(a1 + 12) |= 2u;
      if ( (unsigned __int16)sub_10C80(a1, 3u, v2) )
        *(_DWORD *)(a1 + 8) = 0;
    }
  }
  else
  {
    sub_57F10(a1);
  }
}

//----- (00033E80) --------------------------------------------------------
int __cdecl sub_33E80(int a1)
{
  int v1; // eax
  int result; // eax

  v1 = *(_DWORD *)(a1 + 8);
  ++*(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  sub_585A0(a1);
  result = sub_10C80(a1, 4u, *(char *)(a1 + 70));
  if ( (_WORD)result )
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (00033F70) --------------------------------------------------------
_BOOL1 __cdecl sub_33F70(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  int v2; // edx
  unsigned __int16 v3; // ax
  _BOOL1 result; // al

  HIBYTE(v1) = HIBYTE(a1);
  LOBYTE(v1) = a1 - 1;
  result = 1;
  if ( byte_10B4E0[v1] == 8 )
  {
    v2 = (unsigned __int16)((unsigned __int8)byte_11B4E0[a1] + 30);
    if ( (unsigned __int8)byte_11B4E0[v1] <= (int)(unsigned __int16)v2 )
    {
      LOBYTE(v1) = v1 + 2;
      if ( (unsigned __int8)byte_11B4E0[v1] <= v2 )
      {
        LOBYTE(v3) = v1 - 1;
        HIBYTE(v3) = HIBYTE(a1) + 1;
        if ( (unsigned __int8)byte_11B4E0[v3] <= v2 )
        {
          HIBYTE(v3) = HIBYTE(a1) - 1;
          if ( (unsigned __int8)byte_11B4E0[v3] <= v2 )
            return 0;
        }
      }
    }
  }
  return result;
}

//----- (00034000) --------------------------------------------------------
int __cdecl sub_34000(int a1)
{
  unsigned __int16 v1; // bx
  unsigned __int16 v3; // [esp+0h] [ebp-Ch]
  __int16 j; // [esp+4h] [ebp-8h]
  __int16 i; // [esp+8h] [ebp-4h]

  LOBYTE(v3) = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
  HIBYTE(v3) = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
  if ( v3 % 2 )
    LOBYTE(v3) = v3 + 1;
  LOBYTE(v3) = v3 - *(_BYTE *)(a1 + 8) + 1;
  for ( i = *(_WORD *)(a1 + 8) + *(_WORD *)(a1 + 16); i; --i )
  {
    HIBYTE(v1) = HIBYTE(v3);
    LOBYTE(v1) = v3 - 1;
    byte_13B4E0[v1] |= 0x80u;
    LOBYTE(v1) = v3;
    for ( j = *(_WORD *)(a1 + 8); j; --j )
    {
      if ( byte_10B4E0[v1] != 8 || sub_33F70(v1) )
        byte_11B4E0[v1] += 48;
      sub_46180(v1++, 8);
    }
    byte_13B4E0[v1] |= 0x80u;
    ++HIBYTE(v3);
  }
  return sub_57F10(a1);
}

//----- (00034110) --------------------------------------------------------
int __cdecl sub_34110(_WORD *a1)
{
  unsigned __int16 v1; // bx
  char v3; // [esp+0h] [ebp-Ch]
  char v4; // [esp+1h] [ebp-Bh]
  __int16 j; // [esp+4h] [ebp-8h]
  __int16 i; // [esp+8h] [ebp-4h]

  v3 = (unsigned __int16)(a1[38] + 128) >> 8;
  v4 = ((unsigned __int16)(a1[39] + 128) >> 8) + 2;
  for ( i = a1[4] + a1[8]; i; --i )
  {
    HIBYTE(v1) = v4;
    LOBYTE(v1) = v3 - 1;
    byte_13B4E0[v1] |= 0x80u;
    LOBYTE(v1) = v3;
    for ( j = a1[4]; j; --j )
    {
      if ( byte_10B4E0[v1] != 8 || sub_33F70(v1) )
        byte_11B4E0[v1] += 48;
      sub_46180(v1++, 8);
    }
    byte_13B4E0[v1] |= 0x80u;
    --v4;
  }
  return sub_57F10((int)a1);
}

//----- (00034210) --------------------------------------------------------
int __cdecl sub_34210(_WORD *a1)
{
  __int16 v1; // dx
  int v2; // ebx
  unsigned __int16 v3; // di
  char v4; // cl
  __int16 v5; // dx
  unsigned __int16 v6; // bx
  int v7; // ebx
  __int16 j; // dx
  unsigned __int16 v9; // di
  char v10; // cl
  int v12; // [esp+4h] [ebp-8h]
  __int16 i; // [esp+8h] [ebp-4h]

  LOBYTE(v12) = (unsigned __int16)(a1[38] + 128) >> 8;
  BYTE1(v12) = (unsigned __int16)(a1[39] + 128) >> 8;
  if ( ((unsigned __int8)v12 + BYTE1(v12)) % 2 )
    LOBYTE(v12) = v12 + 1;
  v2 = v12;
  v1 = a1[8];
  BYTE1(v2) = BYTE1(v12) - 1;
  while ( v1 )
  {
    v3 = v2;
    --v1;
    v4 = byte_13B4E0[(unsigned __int16)v2++] | 0x80;
    byte_13B4E0[v3] = v4;
  }
  for ( i = a1[4]; i; --i )
  {
    v5 = a1[8];
    v6 = v12;
    while ( v5 )
    {
      if ( byte_10B4E0[v6] != 8 || sub_33F70(v6) )
        byte_11B4E0[v6] += 48;
      sub_46180(v6++, 8);
      --v5;
    }
    ++BYTE1(v12);
  }
  v7 = v12;
  for ( j = a1[8]; j; --j )
  {
    v9 = v7;
    v10 = byte_13B4E0[(unsigned __int16)v7++] | 0x80;
    byte_13B4E0[v9] = v10;
  }
  return sub_57F10((int)a1);
}
// 3425A: variable 'v12' is possibly undefined

//----- (00034330) --------------------------------------------------------
int __cdecl sub_34330(int a1)
{
  return sub_57F10(a1);
}

//----- (00034350) --------------------------------------------------------
int __cdecl sub_34350(int a1)
{
  return sub_57F10(a1);
}

//----- (00034390) --------------------------------------------------------
int __cdecl sub_34390(int a1)
{
  unsigned int v1; // eax

  v1 = sub_5B070(a1);
  if ( v1 )
    *(_DWORD *)(v1 + 8) = 2;
  return sub_57F10(a1);
}

//----- (000343C0) --------------------------------------------------------
int __cdecl sub_343C0(int a1)
{
  unsigned int v1; // eax

  v1 = sub_5B070(a1);
  if ( v1 )
    *(_DWORD *)(v1 + 8) = 1;
  return sub_57F10(a1);
}

//----- (000343F0) --------------------------------------------------------
int __cdecl sub_343F0(_WORD *a1)
{
  unsigned __int16 v1; // bx
  __int16 v2; // di
  __int16 v4; // [esp+0h] [ebp-8h]
  __int16 v5; // [esp+4h] [ebp-4h]

  LOBYTE(v1) = (unsigned __int16)(a1[38] + 128) >> 8;
  HIBYTE(v1) = (unsigned __int16)(a1[39] + 128) >> 8;
  v5 = a1[14];
  v2 = a1[8];
  v4 = a1[15];
  while ( v2 )
  {
    byte_13B4E0[v1] = byte_13B4E0[v1] & 0xF0 | 1;
    --v2;
    sub_462A0(v1, v1);
    LOBYTE(v1) = v5 + v1;
    HIBYTE(v1) += v4;
  }
  return sub_57F10((int)a1);
}

//----- (00034480) --------------------------------------------------------
int __cdecl sub_34480(int a1)
{
  return sub_57F10(a1);
}

//----- (000344A0) --------------------------------------------------------
_WORD *__cdecl sub_344A0(int a1)
{
  int v1; // eax
  int v3; // eax

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 || (sub_104A0(a1 + 76) & 1) != 0 )
    return (_WORD *)sub_57F10(a1);
  v3 = sub_4A190(a1 + 76, 10, 11);
  if ( v3 )
  {
    *(_WORD *)(v3 + 88) = *(_WORD *)(a1 + 88);
    *(_WORD *)(v3 + 26) = *(_WORD *)(a1 + 26);
    *(_DWORD *)(v3 + 8) = *(char *)(a1 + 70);
  }
  return sub_57FA0((_WORD *)(a1 + 76), *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
}

//----- (00034520) --------------------------------------------------------
int __cdecl sub_34520(int a1)
{
  return sub_57F10(a1);
}

//----- (00034540) --------------------------------------------------------
int __cdecl sub_34540(int a1)
{
  int v1; // ebx
  int v2; // eax
  int v3; // edx
  int v4; // esi
  int v5; // edi
  int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // ebx
  int v9; // eax
  int v10; // ebx
  int v11; // eax
  int v12; // ebx
  unsigned int v13; // eax
  int v14; // ebx
  int v15; // ebx
  int v16; // ebx
  unsigned __int8 v17; // ah
  char v18; // dl
  int i; // eax
  int v20; // ebx
  unsigned int v22; // [esp-4h] [ebp-50h]
  int v23; // [esp+0h] [ebp-4Ch] BYREF
  __int16 v24; // [esp+4h] [ebp-48h]
  int v25; // [esp+8h] [ebp-44h] BYREF
  __int16 v26; // [esp+Ch] [ebp-40h]
  int v27; // [esp+10h] [ebp-3Ch]
  int v28; // [esp+14h] [ebp-38h]
  int v29; // [esp+18h] [ebp-34h]
  int v30; // [esp+1Ch] [ebp-30h]
  unsigned int v31; // [esp+20h] [ebp-2Ch]
  int v32; // [esp+24h] [ebp-28h]
  int v33; // [esp+28h] [ebp-24h]
  int v34; // [esp+2Ch] [ebp-20h]
  int v35; // [esp+30h] [ebp-1Ch]
  int v36; // [esp+34h] [ebp-18h]
  int v37; // [esp+38h] [ebp-14h]
  int v38; // [esp+3Ch] [ebp-10h]
  unsigned __int16 v39; // [esp+40h] [ebp-Ch]
  unsigned __int8 v40; // [esp+44h] [ebp-8h]
  unsigned __int8 v41; // [esp+48h] [ebp-4h]

  v28 = (*(char *)(a1 + 70) >> 4 << 8) + 512;
  v27 = ((*(_BYTE *)(a1 + 70) & 0xF) << 8) + 512;
  v29 = sub_58490((_WORD *)(a1 + 76), (_WORD *)(a1 + 154)) / 0x55;
  v34 = (unsigned __int16)sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a1 + 154));
  v33 = 0;
  v25 = *(_DWORD *)(a1 + 76);
  v26 = *(_WORD *)(a1 + 80);
  while ( v33 < 32 )
  {
    LOBYTE(v39) = BYTE1(v25);
    HIBYTE(v39) = HIBYTE(v25);
    v1 = ((unsigned __int8)byte_11B4E0[v39] + (unsigned __int8)byte_14B4E0[v39]) / 2;
    if ( v1 < 0 )
      v1 = 0;
    if ( v1 > 254 )
      LOBYTE(v1) = -2;
    byte_F0200[v33++] = v1;
    sub_57FA0(&v25, v34, 0, 85);
  }
  v30 = 0;
  v23 = *(_DWORD *)(a1 + 76);
  v24 = *(_WORD *)(a1 + 80);
  while ( v30 < v29 )
  {
    v2 = v28 + v30 * ((v27 - v28) / v29);
    v36 = v2 * v2;
    v3 = 2 * v2 + 128;
    v40 = (unsigned __int16)(v23 + 128) >> 8;
    v35 = (unsigned __int8)byte_F0200[0];
    v4 = v3 >> 8;
    v3 >>= 9;
    v41 = (unsigned __int16)(HIWORD(v23) + 128) >> 8;
    LOBYTE(v37) = v40 - v3;
    BYTE1(v37) = v41 - v3;
    v5 = 0;
    LOWORD(v38) = v37;
    while ( v5 < v4 )
    {
      v32 = 0;
      v39 = v38;
      while ( v4 > v32 )
      {
        v6 = abs32((unsigned __int8)v39 - v40);
        v7 = v6;
        if ( v6 >= 128 )
          v7 = abs32(v6 - 256);
        v8 = v7 << 8;
        v9 = abs32(HIBYTE(v39) - v41);
        if ( v9 >= 128 )
          v9 = abs32(v9 - 256);
        v10 = v8 * v8;
        v11 = (v9 << 8) * (v9 << 8);
        if ( v10 + v11 <= v36 )
        {
          v22 = v36 - v10 - v11;
          v12 = v35;
          v13 = sub_7277A(v22) >> 5;
          v14 = v12 - v13;
          v31 = v13;
          if ( v14 < 0 )
            v14 = 0;
          if ( v14 > 254 )
            v14 = 254;
          if ( (unsigned __int8)byte_11B4E0[v39] > v14 )
            sub_570F0((unsigned __int8)v39, HIBYTE(v39), v14, 0, 0, 1);
          v15 = v31 + v35;
          if ( (int)(v31 + v35) < 0 )
            v15 = 0;
          if ( v15 > 254 )
            v15 = 254;
          if ( (unsigned __int8)byte_14B4E0[v39] < v15 )
            byte_14B4E0[v39] = v15;
        }
        v16 = v39;
        v17 = byte_11B4E0[v39];
        if ( (unsigned __int8)byte_14B4E0[v39] > v17 )
        {
          byte_13B4E0[v39] &= ~8u;
        }
        else
        {
          v18 = byte_13B4E0[v39] | 8;
          byte_14B4E0[v39] = v17 - 1;
          byte_13B4E0[v16] = v18;
        }
        ++v32;
        LOBYTE(v39) = v39 + 1;
      }
      ++v5;
      ++BYTE1(v38);
    }
    sub_34B00(v37 - 1, BYTE1(v37) - 1, v4 + 1, v4 + 1);
    sub_57FA0(&v23, v34, 0, 85);
    for ( i = 1; i < 32; byte_F01FE[i] = byte_F01FF[i] )
      ++i;
    LOBYTE(v39) = BYTE1(v25);
    HIBYTE(v39) = HIBYTE(v25);
    v20 = ((unsigned __int8)byte_11B4E0[v39] + (unsigned __int8)byte_14B4E0[v39]) / 2;
    if ( v20 < 0 )
      v20 = 0;
    if ( v20 > 254 )
      LOBYTE(v20) = -2;
    byte_F021F = v20;
    ++v30;
    sub_57FA0(&v25, v34, 0, 85);
  }
  return sub_57F10(a1);
}
// F021F: using guessed type char byte_F021F;

//----- (00034910) --------------------------------------------------------
int __cdecl sub_34910(int a1)
{
  int v1; // ebx
  int v2; // esi
  int v3; // ecx
  int v4; // edi
  unsigned int v5; // ebx
  int v6; // eax
  int v7; // eax
  unsigned __int8 v8; // dh
  char v9; // cl
  int v11; // [esp+8h] [ebp-1Ch]
  int v12; // [esp+Ch] [ebp-18h]
  int v13; // [esp+10h] [ebp-14h]
  int i; // [esp+14h] [ebp-10h]
  int v15; // [esp+18h] [ebp-Ch]
  unsigned __int16 v16; // [esp+1Ch] [ebp-8h]
  unsigned __int16 v17; // [esp+20h] [ebp-4h]

  v13 = 3 * *(char *)(a1 + 70);
  v1 = *(char *)(a1 + 67);
  v2 = 2 * v1;
  v5 = (*(__int16 *)(a1 + 76) >> 8) - v1;
  v3 = *(char *)(a1 + 68);
  v4 = 2 * v3;
  BYTE1(v5) = HIBYTE(*(_WORD *)(a1 + 78)) - v3;
  v11 = sub_48E60((unsigned __int8)v5, BYTE1(v5), v2, 2 * v3);
  v16 = v5;
  v12 = sub_48E90((unsigned __int8)v5, BYTE1(v5), v2, 2 * v3);
  for ( i = 0; v4 > i; ++i )
  {
    v15 = 0;
    v17 = v16;
    while ( v2 > v15 )
    {
      v6 = v11 - v13;
      if ( v11 - v13 < 0 )
        v6 = 0;
      if ( v6 > 254 )
        v6 = 254;
      if ( (unsigned __int8)byte_11B4E0[v17] > v6 )
        sub_570F0((unsigned __int8)v17, HIBYTE(v16), v6, 0, 0, 0);
      v7 = v13 + v12;
      if ( v13 + v12 < 0 )
        v7 = 0;
      if ( v7 > 254 )
        v7 = 254;
      if ( v7 > (unsigned __int8)byte_14B4E0[v17] )
        byte_14B4E0[v17] = v7;
      v8 = byte_11B4E0[v17];
      if ( (unsigned __int8)byte_14B4E0[v17] > v8 )
      {
        byte_13B4E0[v17] &= ~8u;
      }
      else
      {
        v9 = byte_13B4E0[v17] | 8;
        byte_14B4E0[v17] = v8 - 1;
        byte_13B4E0[v17] = v9;
      }
      ++v15;
      LOBYTE(v17) = v17 + 1;
    }
    ++HIBYTE(v16);
  }
  sub_34B00(v5 - 1, BYTE1(v5) - 1, v2 + 1, v4 + 1);
  sub_43C60(v5, SBYTE1(v5), (unsigned __int16)v2, (unsigned __int16)v4);
  return sub_57F10(a1);
}

//----- (00034B00) --------------------------------------------------------
int __cdecl sub_34B00(char a1, char a2, __int16 a3, __int16 a4)
{
  unsigned __int16 v4; // bx
  char v5; // dl
  int v6; // eax
  char v7; // ch
  int result; // eax
  unsigned __int16 v9; // bx
  char v10; // dl
  int v11; // eax
  char v12; // ch
  int v13; // [esp+0h] [ebp-Ch]
  int i; // [esp+4h] [ebp-8h]

  for ( i = 0; a3 > i; ++i )
  {
    HIBYTE(v4) = a2;
    LOBYTE(v4) = i + a1;
    v5 = byte_13B4E0[v4];
    if ( (v5 & 8) != 0 )
    {
      byte_13B4E0[v4] = v5 & 0xF8 | 1;
      byte_10B4E0[v4] = 1;
      sub_462A0(v4, v4);
    }
    HIWORD(v6) = 0;
    HIBYTE(v4) = a4 + a2;
    LOWORD(v6) = v4;
    v7 = byte_13B4E0[v4];
    if ( (v7 & 8) != 0 )
    {
      byte_13B4E0[v6] = v7 & 0xF8 | 1;
      sub_462A0(v4, v4);
    }
  }
  v13 = 0;
  for ( result = a4; a4 > v13; result = a4 )
  {
    LOBYTE(v9) = a1;
    HIBYTE(v9) = v13 + a2;
    v10 = byte_13B4E0[v9];
    if ( (v10 & 8) != 0 )
    {
      byte_13B4E0[v9] = v10 & 0xF8 | 1;
      byte_10B4E0[v9] = 1;
      sub_462A0(v9, v9);
    }
    HIWORD(v11) = 0;
    LOBYTE(v9) = a3 + v9;
    LOWORD(v11) = v9;
    v12 = byte_13B4E0[v9];
    if ( (v12 & 8) != 0 )
    {
      byte_13B4E0[v11] = v12 & 0xF8 | 1;
      sub_462A0(v9, v9);
    }
    ++v13;
  }
  return result;
}

//----- (00034C40) --------------------------------------------------------
char __cdecl sub_34C40(int a1)
{
  int v1; // edx
  int v2; // eax
  int v3; // esi
  unsigned __int8 v4; // cl
  unsigned __int8 v5; // dl
  signed int v6; // edi
  signed int v7; // eax
  int v8; // ecx
  int v9; // ecx
  __int16 v11[4]; // [esp+0h] [ebp-40h] BYREF
  int v12; // [esp+8h] [ebp-38h]
  int v13; // [esp+Ch] [ebp-34h]
  int v14; // [esp+10h] [ebp-30h]
  int v15; // [esp+14h] [ebp-2Ch]
  int v16; // [esp+18h] [ebp-28h]
  int v17; // [esp+1Ch] [ebp-24h]
  int v18; // [esp+20h] [ebp-20h]
  int v19; // [esp+24h] [ebp-1Ch]
  int v20; // [esp+28h] [ebp-18h]
  int v21; // [esp+2Ch] [ebp-14h]
  int v22; // [esp+30h] [ebp-10h]
  int v23; // [esp+34h] [ebp-Ch]
  unsigned __int16 i; // [esp+38h] [ebp-8h]
  int v25; // [esp+3Ch] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v1;
  if ( v1 <= 0 )
  {
    LOBYTE(v2) = sub_57F10(a1);
  }
  else
  {
    v2 = *(__int16 *)(a1 + 154);
    v3 = 2 * v2;
    v4 = ((unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8) - v2;
    BYTE1(v25) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - v2;
    v5 = *(_BYTE *)(a1 + 70);
    LOBYTE(v25) = v4;
    if ( v5 )
    {
      if ( v5 <= 1u )
      {
        v6 = v2 << 8;
        v21 = *(__int16 *)(a1 + 80);
        v22 = *(__int16 *)(a1 + 158);
        v15 = (49152 * v2) >> 8;
        v12 = v22 - v21;
        LOBYTE(v2) = v25;
        v18 = 0;
        for ( i = v25; v3 > v18; ++HIBYTE(i) )
        {
          v17 = 0;
          LOBYTE(v2) = v25;
          LOBYTE(i) = v25;
          while ( v3 > v17 )
          {
            v11[0] = (unsigned __int8)i << 8;
            v11[1] = HIBYTE(i) << 8;
            v14 = 0;
            v7 = sub_58490((_WORD *)(a1 + 76), v11);
            v13 = v7;
            if ( v7 < v6 )
            {
              v20 = (unsigned __int8)byte_11B4E0[i];
              v23 = (unsigned __int8)byte_14B4E0[i];
              v16 = (v12 * (((int)sub_10000 + (int)off_DBF50[(v7 << 10) / v6]) >> 1)) >> 16;
              v8 = v16 + v21;
              if ( v16 + v21 > 254 )
                v8 = 254;
              if ( v8 > v20 )
                sub_570F0((unsigned __int8)i, HIBYTE(i), (v8 - v20) / *(_DWORD *)(a1 + 8) + v20, 0, v13 <= v15, 1);
              v9 = v14 + v22 - v16;
              if ( v9 < 0 )
                v9 = 0;
              if ( v9 < v23 )
                byte_14B4E0[i] = v23 - (v23 - v9) / *(_DWORD *)(a1 + 8);
              if ( (unsigned __int8)byte_14B4E0[i] > (unsigned __int8)byte_11B4E0[i] )
                byte_13B4E0[i] &= ~8u;
              else
                byte_13B4E0[i] |= 8u;
            }
            LOBYTE(v2) = ++v17;
            LOBYTE(i) = i + 1;
          }
          ++v18;
        }
      }
      else if ( v5 == 2 )
      {
        *(_DWORD *)(a1 + 8) = 0;
      }
    }
    else
    {
      v19 = BYTE1(v25);
      *(_WORD *)(a1 + 80) = sub_48E60(v4, BYTE1(v25), v3, v3);
      LOWORD(v2) = sub_48EF0(v4, v19, v3, v3);
      *(_WORD *)(a1 + 158) = v2;
      LOBYTE(v2) = ((__int16)v2 - *(__int16 *)(a1 + 80) <= 0) + 1;
      *(_BYTE *)(a1 + 70) = v2;
    }
  }
  return v2;
}
// 10000: using guessed type void __noreturn sub_10000();
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();

//----- (00034EE0) --------------------------------------------------------
void __usercall sub_34EE0(int a1@<edi>, int a2@<esi>, int a3)
{
  int v3; // edx
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  unsigned __int8 v7; // dl
  unsigned __int8 v8; // al
  __int16 v9; // dx
  char v10; // ah
  __int16 v11; // di
  int v12; // edi
  int v13; // ecx
  __int64 v14; // rax
  int v15; // esi
  signed int v16; // eax
  int v17; // ecx
  unsigned __int8 v18; // al
  int v19; // ecx
  int v20; // ecx
  int v21; // eax
  int v22; // ecx
  int v23; // eax
  int v24; // ecx
  unsigned __int8 v25; // dl
  char v26; // dh
  __int16 v27[4]; // [esp+0h] [ebp-34h] BYREF
  int v28; // [esp+8h] [ebp-2Ch]
  int v29; // [esp+Ch] [ebp-28h]
  int v30; // [esp+10h] [ebp-24h]
  int v31; // [esp+14h] [ebp-20h]
  int v32; // [esp+18h] [ebp-1Ch]
  int v33; // [esp+1Ch] [ebp-18h]
  int v34; // [esp+20h] [ebp-14h]
  int v35; // [esp+24h] [ebp-10h]
  int v36; // [esp+28h] [ebp-Ch]
  unsigned int v37; // [esp+2Ch] [ebp-8h]
  unsigned __int16 i; // [esp+30h] [ebp-4h]

  v3 = *(_DWORD *)(a3 + 8) - 1;
  *(_DWORD *)(a3 + 8) = v3;
  if ( v3 <= 0 )
  {
    sub_57F10(a3);
  }
  else
  {
    v4 = *(__int16 *)(a3 + 154);
    v5 = *(__int16 *)(a3 + 78);
    v36 = 2 * v4;
    v6 = (*(__int16 *)(a3 + 76) + 128) >> 8;
    v34 = (v5 + 128) >> 8;
    LOBYTE(v37) = v6 - v4;
    BYTE1(v37) = v34 - v4;
    v7 = *(_BYTE *)(a3 + 70);
    if ( v7 )
    {
      if ( v7 <= 1u )
      {
        v33 = v4 << 8;
        v12 = *(__int16 *)(a3 + 158);
        v13 = 768 * v4;
        v14 = *(__int16 *)(a3 + 80) - v12;
        v15 = (HIDWORD(v14) ^ v14) - HIDWORD(v14);
        v32 = 0;
        v28 = (char)(v13 >> 2);
        for ( i = v37; v32 < v36; ++HIBYTE(i) )
        {
          v31 = 0;
          LOBYTE(i) = v37;
          while ( v31 < v36 )
          {
            v27[0] = (unsigned __int8)i << 8;
            v27[1] = HIBYTE(i) << 8;
            v16 = sub_58490((_WORD *)(a3 + 76), v27);
            v29 = v16;
            if ( v16 < v33 )
            {
              v17 = v15 * (((int)sub_10000 + (int)off_DBF50[(v16 << 10) / v33]) >> 1);
              v18 = *(_BYTE *)(a3 + 64);
              v19 = v17 >> 16;
              if ( v18 >= 0x54u )
              {
                if ( v18 <= 0x54u )
                {
                  v20 = v12 - v19;
                  if ( v20 < 0 )
                    v20 = 0;
                  v30 = i;
                  v35 = (unsigned __int8)byte_14B4E0[i];
                  v21 = (v35 - v20) / *(_DWORD *)(a3 + 8);
                  if ( v35 - v21 < v35 )
                    byte_14B4E0[v30] = v35 - v21;
                }
                else if ( v18 == 85 )
                {
                  v22 = v12 + v19;
                  if ( v22 > 254 )
                    v22 = 254;
                  v35 = (unsigned __int8)byte_11B4E0[i];
                  v23 = (v22 - v35) / *(_DWORD *)(a3 + 8);
                  if ( v23 + v35 > v35 )
                    sub_570F0((unsigned __int8)i, HIBYTE(i), v23 + v35, 0, v29 <= v28, 1);
                }
              }
              v24 = i;
              v25 = byte_11B4E0[i];
              if ( (unsigned __int8)byte_14B4E0[i] > v25 )
              {
                byte_13B4E0[i] &= ~8u;
              }
              else
              {
                v26 = byte_13B4E0[i] | 8;
                byte_14B4E0[i] = v25 - 1;
                byte_13B4E0[v24] = v26;
              }
            }
            ++v31;
            LOBYTE(i) = i + 1;
          }
          ++v32;
        }
      }
      else if ( v7 == 2 )
      {
        if ( *(_BYTE *)(a3 + 64) == 84 )
          sub_43C60(v37, SBYTE1(v37), (unsigned __int16)v36, (unsigned __int16)v36);
        *(_DWORD *)(a3 + 8) = 0;
      }
    }
    else
    {
      v8 = *(_BYTE *)(a3 + 64);
      if ( v8 >= 0x54u )
      {
        if ( v8 <= 0x54u )
        {
          v35 = BYTE1(v37);
          v34 = (unsigned __int8)v37;
          a1 = sub_48EF0((unsigned __int8)v37, BYTE1(v37), v36, v36);
          a2 = a1 - sub_48E90((unsigned __int8)v37, BYTE1(v37), v36, v36) - 1;
        }
        else if ( v8 == 85 )
        {
          v34 = BYTE1(v37);
          v35 = (unsigned __int8)v37;
          a1 = sub_48E60((unsigned __int8)v37, BYTE1(v37), v36, v36);
          a2 = sub_48EC0((unsigned __int8)v37, BYTE1(v37), v36, v36) - a1 - 1;
        }
      }
      if ( a2 <= 0 )
      {
        *(_BYTE *)(a3 + 70) = 2;
      }
      else
      {
        v9 = *(_WORD *)(a3 + 80);
        if ( v9 )
        {
          a2 = (51 * v9 * a2 - (__CFSHL__((51 * v9 * a2) >> 31, 8) + ((51 * v9 * a2) >> 31 << 8))) >> 8;
        }
        else
        {
          *(_WORD *)(a3 + 20) = 9377 * *(_WORD *)(a3 + 20) + 9439;
          LOWORD(a2) = *(unsigned __int16 *)(a3 + 20) % (unsigned int)a2;
        }
        v10 = *(_BYTE *)(a3 + 64);
        *(_WORD *)(a3 + 158) = a1;
        if ( v10 == 84 )
          v11 = a1 - a2;
        else
          v11 = a2 + a1;
        *(_WORD *)(a3 + 80) = v11;
        *(_BYTE *)(a3 + 70) = 1;
      }
    }
  }
}
// 10000: using guessed type void __noreturn sub_10000();
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();

//----- (000352A0) --------------------------------------------------------
int __cdecl sub_352A0(int a1)
{
  return sub_57F10(a1);
}

//----- (000352C0) --------------------------------------------------------
_WORD *__cdecl sub_352C0(int a1)
{
  int v1; // edx

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 || (sub_104A0(a1 + 76) & 1) != 0 )
    return (_WORD *)sub_57F10(a1);
  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  if ( !sub_572C0((__int16 *)a1, 0, 1024, *(_WORD *)(a1 + 20) % 0xFu + 10, 0) )
  {
    sub_10C80(a1, 0, *(_WORD *)(a1 + 42));
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
  }
  return sub_57FA0((_WORD *)(a1 + 76), *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
}
// D41A0: using guessed type int dword_D41A0;

//----- (00035390) --------------------------------------------------------
void __cdecl sub_35390(int a1)
{
  int v1; // eax
  int v2; // edx
  int v3; // edi
  int v4; // esi
  __int16 v5; // ax
  __int16 v6; // ax
  int v7; // edx
  __int16 v8; // ax
  int v9; // [esp+0h] [ebp-10h]
  __int16 *v10; // [esp+8h] [ebp-8h]
  unsigned __int16 i; // [esp+Ch] [ebp-4h]

  if ( (*(_BYTE *)(a1 + 12) & 2) == 0 )
  {
    v1 = dword_D41A0 + 28302;
    *(_BYTE *)(a1 + 12) |= 2u;
    sub_6E450((a1 - v1) / 168, -1, 21);
  }
  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 > 0 && (*(_DWORD *)(a1 + 8) = v2 - 1, v2 == 1) )
  {
    sub_57F10(a1);
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 20);
  }
  else
  {
    v3 = dword_D41A0 + 11230;
    for ( i = 0; ; ++i )
    {
      v10 = (__int16 *)(a1 + 76);
      if ( *(_WORD *)(dword_D41A0 + 14) <= i )
        break;
      v4 = dword_EA3E4[*(unsigned __int16 *)(v3 + 10)];
      if ( sub_106C0(a1, v4) )
      {
        v5 = sub_581E0((_WORD *)(v4 + 76), v10);
        if ( (unsigned __int16)sub_582B0(*(_WORD *)(v4 + 28), v5) < 0xAAu )
        {
          v9 = *(_DWORD *)(a1 + 160);
          v6 = sub_10C40((__int16 *)(a1 + 154));
          v7 = dword_D41A0;
          *(_WORD *)(a1 + 158) = *(_WORD *)(v9 + 12) + v6;
          sub_6E450((a1 - (v7 + 28302)) / 168, -1, 22);
          sub_57CF0(v8, v4, a1 + 154);
          sub_5C800(v4, 6);
        }
      }
      v3 += 2124;
    }
    *(_WORD *)(a1 + 80) = sub_10C40(v10);
  }
}
// 354D7: variable 'v8' is possibly undefined
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00035530) --------------------------------------------------------
unsigned int __cdecl sub_35530(int a1)
{
  unsigned int result; // eax
  __int16 v2; // ax
  __int16 v3; // ax

  result = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
  if ( result > dword_EA3E4[0] )
  {
    if ( *(_DWORD *)(result + 8) == 1 )
    {
      return sub_57F10(a1);
    }
    else
    {
      *(_DWORD *)&word_EB398 = *(_DWORD *)(result + 76);
      *(&word_EB398 + 2) = *(_WORD *)(result + 80);
      sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
      v2 = *(_WORD *)(a1 + 28) + 45;
      HIBYTE(v2) &= 7u;
      *(_WORD *)(a1 + 28) = v2;
      v3 = sub_10C40(&word_EB398);
      ++HIBYTE(v3);
      word_EB39C = v3;
      return sub_57CF0(v3, a1, (int)&word_EB398);
    }
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00035600) --------------------------------------------------------
int __cdecl sub_35600(int a1)
{
  int result; // eax
  int v2; // edx
  char v3; // dl

  result = a1;
  ++*(_DWORD *)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 - 1;
  if ( v2 < 0 )
    return sub_57F10(a1);
  v3 = *(_BYTE *)(a1 + 12);
  if ( (v3 & 2) == 0 )
    *(_BYTE *)(a1 + 12) = v3 | 2;
  return result;
}

//----- (00035640) --------------------------------------------------------
void __cdecl sub_35640(int a1)
{
  __int16 v1; // si
  __int16 v2; // dx
  int v3; // eax
  __int16 v4; // ax
  __int16 v5; // ax
  int v6; // eax
  int v7; // ecx
  __int16 v8; // ax
  int v9; // [esp-8h] [ebp-Ch]
  int v10; // [esp-4h] [ebp-8h]
  int v11; // [esp+0h] [ebp-4h]

  v1 = 0;
  v2 = sub_10C40((__int16 *)(a1 + 76));
  if ( *(__int16 *)(a1 + 80) < v2 + 1024 )
  {
    v1 = 1;
    *(_WORD *)(a1 + 80) += 64;
  }
  if ( *(__int16 *)(a1 + 80) > v2 + 1024 )
  {
    HIBYTE(v2) += 4;
    v1 = 1;
    *(_WORD *)(a1 + 80) = v2;
  }
  if ( !v1 )
  {
    v3 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v3 - 1;
    if ( v3 >= 0 )
    {
      v4 = 9377 * *(_WORD *)(a1 + 20);
      *(_WORD *)(a1 + 30) = 56;
      *(_WORD *)(a1 + 20) = v4 + 9439;
      v11 = 0;
      *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 20) & 0x7FF;
      do
      {
        v5 = *(_WORD *)(a1 + 28);
        HIBYTE(v5) = (HIBYTE(v5) + 4) & 7;
        *(_WORD *)(a1 + 28) = v5;
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        v10 = *(char *)(a1 + 68);
        v9 = *(char *)(a1 + 67);
        word_EB39C += *(_WORD *)(a1 + 82);
        v6 = sub_4A190(a1 + 76, v9, v10);
        v7 = v6;
        if ( v6 )
        {
          *(_WORD *)(v6 + 26) = *(_WORD *)(a1 + 26);
          *(int *)(v6 + 8) /= 3;
          *(_WORD *)(v6 + 28) = *(_WORD *)(a1 + 28);
          *(_WORD *)(v6 + 30) = *(_WORD *)(a1 + 30);
          v8 = *(_WORD *)(a1 + 42);
          *(_BYTE *)(v7 + 67) = 10;
          *(_BYTE *)(v7 + 68) = 23;
          *(_WORD *)(v7 + 42) = v8;
          if ( !v11 )
            sub_6E450((v7 - (dword_D41A0 + 28302)) / 168, -1, 23);
        }
        ++v11;
      }
      while ( v11 < 2 );
    }
    else
    {
      sub_57F10(a1);
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (000357C0) --------------------------------------------------------
int __cdecl sub_357C0(int a1)
{
  __int16 v1; // bx
  unsigned __int16 v2; // cx
  unsigned int i; // eax
  int v4; // eax
  int v5; // ecx
  __int16 v6; // ax
  int v8; // [esp+0h] [ebp-10h]
  unsigned __int16 v9; // [esp+4h] [ebp-Ch]
  __int16 v10; // [esp+8h] [ebp-8h]
  int v11; // [esp+Ch] [ebp-4h]

  *(_WORD *)(a1 + 42) = 10000;
  if ( *(_WORD *)(a1 + 42) )
  {
    v1 = sub_4A810();
    if ( v1 < 0 )
      v1 = 0;
    if ( v1 > 8 )
      v1 = 8;
    v2 = 0;
    for ( i = *(_DWORD *)(dword_D41A4 + 38439); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(unsigned __int16 *)(i + 148) == *(__int16 *)(a1 + 26) )
        ++v2;
    }
    if ( v1 > 64 - v2 )
      v1 = 64 - v2;
    if ( v1 > 0 )
    {
      HIWORD(v4) = HIWORD(a1);
      LOWORD(v4) = *(_WORD *)(a1 + 42);
      v8 = v4;
      v11 = (__int16)v4 / v1;
      v10 = 2048 / v1;
      v9 = 0;
      while ( v1 > 0 )
      {
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        sub_57FA0(&word_EB398, v9, 0, 512);
        v5 = sub_4A190((int)&word_EB398, 5, 9);
        if ( v5 )
        {
          *(_DWORD *)(v5 + 144) = (__int16)v8 % (__int16)v11;
          *(_WORD *)(v5 + 148) = *(_WORD *)(a1 + 26);
          *(_WORD *)(v5 + 26) = *(_WORD *)(a1 + 26);
          LOBYTE(v6) = v9;
          HIBYTE(v6) = (HIBYTE(v9) + 4) & 7;
          *(_WORD *)(v5 + 32) = v6;
          *(_WORD *)(v5 + 28) = v6;
          v8 -= v11;
        }
        --v1;
        v9 += v10;
      }
    }
  }
  return sub_57F10(a1);
}
// 35827: conditional instruction was optimized away because bx.2<9u
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00035940) --------------------------------------------------------
void __cdecl sub_35940(int a1)
{
  char v1; // dh
  __int16 v2; // dx
  __int16 v3; // ax
  __int16 v4; // ax
  unsigned __int16 v5; // si
  int v6; // eax
  char v7; // dl
  unsigned __int16 v8; // ax
  signed int v9; // eax
  _WORD *v10; // eax
  __int16 v11; // si
  __int16 v12; // ax
  __int16 v13; // cx
  __int16 v14; // ax
  int v15; // eax
  __int16 v16; // ax
  __int16 v17; // dx
  __int16 v18; // cx
  int v19; // eax
  __int16 v20; // si
  __int16 v21; // cx
  int v22; // eax
  int v23; // eax
  int v24; // edx
  unsigned int v25; // eax
  char v26; // cl
  unsigned __int16 v27; // [esp-Ch] [ebp-28h]
  __int16 v28; // [esp-4h] [ebp-20h]
  int v29; // [esp+0h] [ebp-1Ch]
  unsigned __int16 v30; // [esp+4h] [ebp-18h]
  int v31; // [esp+8h] [ebp-14h]
  __int16 v32; // [esp+Ch] [ebp-10h]
  char v33; // [esp+10h] [ebp-Ch]
  char v34; // [esp+14h] [ebp-8h]
  char v35; // [esp+18h] [ebp-4h]

  v1 = *(_BYTE *)(a1 + 13);
  v34 = 0;
  v35 = 0;
  if ( (v1 & 8) != 0 )
  {
    *(_BYTE *)(a1 + 13) = v1 & 0xF7;
  }
  else
  {
    v2 = *(_WORD *)(a1 + 104);
    if ( v2 )
    {
      if ( v2 != *(_WORD *)(a1 + 148) )
      {
        v35 = 1;
        if ( *(_DWORD *)(a1 + 100) )
        {
          v4 = *(_WORD *)(a1 + 104);
          *(_WORD *)(a1 + 148) = v4;
          sub_6E450(v4, -1, 4);
          *(_DWORD *)(a1 + 12) &= 0xFFDFFFBF;
          *(_BYTE *)(a1 + 14) |= 0x20u;
        }
        else if ( (*(_BYTE *)(a1 + 14) & 0x20) == 0 )
        {
          v3 = *(_WORD *)(a1 + 104);
          *(_WORD *)(a1 + 148) = v3;
          sub_6E450(v3, -1, 4);
          *(_BYTE *)(a1 + 12) &= ~0x40u;
        }
      }
      *(_WORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
    }
    v5 = *(_WORD *)(a1 + 122);
    if ( v5 )
    {
      v34 = 1;
      *(_WORD *)(a1 + 28) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(dword_EA3E4[v5] + 76));
      v28 = *(_WORD *)(a1 + 118);
      v27 = *(_WORD *)(a1 + 28);
      word_EB398 = 0;
      word_EB39A = 0;
      word_EB39C = 0;
      sub_57FA0(&word_EB398, v27, 0, v28);
      *(_WORD *)(a1 + 154) = word_EB398;
      *(_WORD *)(a1 + 156) = word_EB39A;
      *(_WORD *)(a1 + 122) = 0;
    }
    if ( (*(_BYTE *)(a1 + 12) & 0x40) != 0 )
    {
      v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
      v7 = 1;
      if ( *(_BYTE *)(v6 + 63) == 3 && *(_BYTE *)(v6 + 64) == 3 )
      {
        v7 = 0;
        v32 = 32;
      }
      else if ( *(_BYTE *)(v6 + 63) == 5 && *(_BYTE *)(v6 + 64) == 23 )
      {
        v7 = 0;
        v32 = *(_WORD *)(v6 + 44);
      }
      if ( v7 )
      {
        *(_BYTE *)(a1 + 12) &= ~0x40u;
      }
      else
      {
        v8 = *(_WORD *)(a1 + 150);
        *(_WORD *)(a1 + 44) = 128;
        *(_WORD *)(a1 + 28) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(dword_EA3E4[v8] + 76));
        v9 = sub_58490((_WORD *)(a1 + 76), (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 76));
        if ( v9 <= 1024 )
        {
          if ( v9 >= 16 )
          {
            *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
            *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
            sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, 16);
          }
          else
          {
            *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
            *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
            v10 = (_WORD *)dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
            word_EB398 = v10[38];
            v11 = v10[40];
            word_EB39A = v10[39];
            if ( word_EB39C >= v11 )
            {
              if ( word_EB39C > v11 + 512 )
                word_EB39C -= v32;
            }
            else
            {
              word_EB39C += v32;
            }
          }
          v12 = sub_10C40(&word_EB398);
          if ( v12 > word_EB39C )
            word_EB39C = v12;
          sub_57CF0(v12, a1, (int)&word_EB398);
        }
        else
        {
          *(_BYTE *)(a1 + 12) &= ~0x40u;
        }
      }
    }
    else if ( *(_BYTE *)(a1 + 57) || v34 )
    {
      if ( *(__int16 *)(a1 + 154) < -64 )
        *(_WORD *)(a1 + 154) = -64;
      if ( *(__int16 *)(a1 + 154) > 64 )
        *(_WORD *)(a1 + 154) = 64;
      if ( *(__int16 *)(a1 + 156) < -64 )
        *(_WORD *)(a1 + 156) = -64;
      if ( *(__int16 *)(a1 + 156) > 64 )
        *(_WORD *)(a1 + 156) = 64;
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      v13 = *(_WORD *)(a1 + 156);
      word_EB398 = *(_WORD *)(a1 + 154) + *(_WORD *)(a1 + 76);
      word_EB39A = v13 + *(_WORD *)(a1 + 78);
      v14 = *(_WORD *)(a1 + 44);
      word_EB39C += v14;
      *(_WORD *)(a1 + 44) = v14 - 16;
      if ( (__int16)(v14 - 16) < -128 )
        *(_WORD *)(a1 + 44) = -128;
      if ( byte_D41B6 && sub_11E70(a1, &word_EB398) )
      {
        if ( v34 )
        {
          *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
          *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        }
        else
        {
          *(_WORD *)(a1 + 130) = 256;
          v31 = 170;
          v33 = 0;
          v29 = 1;
          while ( v31 <= 1024 )
          {
            *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
            *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
            v30 = (v29 * v31 + *(_WORD *)(a1 + 28) + 512) & 0x7FF;
            sub_57FA0(&word_EB398, v30, 0, *(_WORD *)(a1 + 130));
            word_EB39C = sub_10C40(&word_EB398);
            if ( !sub_11E70(a1, &word_EB398) )
            {
              v33 = 1;
              break;
            }
            v29 = -v29;
            if ( v29 == 1 )
              v15 = 170;
            else
              v15 = 0;
            v31 += v15;
          }
          if ( v33 )
          {
            *(_WORD *)(a1 + 32) = v30;
            *(_WORD *)(a1 + 28) = v30;
          }
          else
          {
            *(_WORD *)(a1 + 154) = 64;
            v16 = *(_WORD *)(a1 + 76);
            v17 = *(_WORD *)(a1 + 154);
            *(_WORD *)(a1 + 156) = 64;
            v18 = *(_WORD *)(a1 + 156);
            word_EB398 = v17 + v16;
            word_EB39A = v18 + *(_WORD *)(a1 + 78);
          }
        }
        *(_WORD *)(a1 + 44) = -128;
      }
      LOWORD(v19) = sub_10C40(&word_EB398);
      v20 = v19;
      if ( (__int16)v19 > word_EB39C )
      {
        v19 = -((int)(*(__int16 *)(a1 + 44)
                    - (__CFSHL__((unsigned __int64)*(__int16 *)(a1 + 44) >> 32, 2)
                     + 4 * ((unsigned __int64)*(__int16 *)(a1 + 44) >> 32))) >> 2);
        *(_WORD *)(a1 + 44) = v19;
        if ( (__int16)v19 <= 16 )
          *(_WORD *)(a1 + 44) = 0;
        word_EB39C = v20;
      }
      if ( byte_D41B6 )
      {
        LOWORD(v19) = sub_10C60(&word_EB398);
        v21 = v19 - *(_WORD *)(a1 + 88);
        if ( v21 < word_EB39C )
        {
          v19 = -abs16(*(_WORD *)(a1 + 44));
          *(_WORD *)(a1 + 44) = v19;
          word_EB39C = v21;
        }
      }
      sub_57CF0(v19, a1, (int)&word_EB398);
      if ( v20 == word_EB39C )
      {
        v22 = sub_10A50(a1);
        if ( v22 && (*(_BYTE *)(a1 + 13) & 0x20) == 0 )
          sub_36D50(a1, v22);
        sub_58030(a1 + 76, &word_EB398);
        *(_WORD *)(a1 + 154) += word_EB398;
        v23 = 250 * *(__int16 *)(a1 + 154);
        *(_WORD *)(a1 + 156) += word_EB39A;
        v24 = *(__int16 *)(a1 + 156);
        *(_WORD *)(a1 + 154) = (v23 - (__CFSHL__(v23 >> 31, 8) + (v23 >> 31 << 8))) >> 8;
        *(_WORD *)(a1 + 156) = (250 * v24 - (__CFSHL__((250 * v24) >> 31, 8) + ((250 * v24) >> 31 << 8))) >> 8;
      }
      if ( (*(_BYTE *)(a1 + 13) & 0x20) == 0 || v35 )
        sub_36920(a1, a1);
    }
    if ( (*(_BYTE *)(a1 + 13) & 0x20) != 0 )
    {
      v25 = *(_DWORD *)(a1 + 8) - 1;
      *(_DWORD *)(a1 + 8) = v25;
      if ( v25 < 6 )
      {
        if ( !v25 )
          sub_57F10(a1);
      }
      else if ( v25 <= 6 )
      {
        v26 = *(_BYTE *)(a1 + 15) & 0xFE;
        *(_BYTE *)(a1 + 14) |= 0x80u;
        *(_BYTE *)(a1 + 15) = v26;
      }
      else if ( v25 == 12 )
      {
        *(_BYTE *)(a1 + 15) |= 1u;
      }
    }
  }
}
// 35B64: variable 'v32' is possibly undefined
// 35D8F: variable 'v30' is possibly undefined
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00036680) --------------------------------------------------------
char __cdecl sub_36680(int a1)
{
  unsigned __int8 v1; // al
  int v2; // eax
  int v3; // eax
  char v5; // [esp+0h] [ebp-4h]

  v5 = 0;
  if ( *(_WORD *)(a1 + 40) == *(_WORD *)(a1 + 104) )
  {
    *(_WORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  else
  {
    v1 = *(_BYTE *)(a1 + 70);
    if ( v1 )
    {
      if ( v1 <= 1u )
      {
        v2 = *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 16) = v2 + 1;
        if ( v2 >= 8 )
        {
LABEL_14:
          sub_6D8B0(*(_WORD *)(a1 + 40), 0x16u, 1);
          return 1;
        }
        if ( (*(_BYTE *)(a1 + 16) & 1) == 0 )
          sub_36770((_WORD *)a1);
      }
      else if ( v1 <= 3u )
      {
        v3 = *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 16) = v3 + 1;
        if ( !v3 )
        {
          sub_36850(a1);
          return 0;
        }
        if ( v3 + 1 > 2 )
          goto LABEL_14;
      }
    }
    else
    {
      sub_36770((_WORD *)a1);
      sub_6D8B0(*(_WORD *)(a1 + 40), 0x16u, 1);
      return 1;
    }
  }
  return v5;
}

//----- (00036770) --------------------------------------------------------
void __cdecl sub_36770(_WORD *a1)
{
  _WORD *v1; // ebx
  int v2; // eax
  int v3; // [esp-4h] [ebp-4h]

  v1 = (_WORD *)sub_4A190((int)(a1 + 38), 9, 0);
  if ( v1 )
  {
    v3 = dword_EA3E4[(unsigned __int16)a1[52]];
    v1[75] = a1[52];
    sub_655C0(v1, v3);
    v1[14] = v1[16];
    v1[15] = v1[17];
    v1[40] += a1[44];
    v1[21] = a1[21];
    sub_6E450(((int)v1 - dword_D41A0 - 28302) / 168, -1, 9);
    if ( sub_104D0(v1 + 38) == 1 )
    {
      v2 = sub_4A190((int)(a1 + 38), 10, 5);
      if ( v2 )
        sub_6E450((v2 - (dword_D41A0 + 28302)) / 168, -1, 27);
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00036850) --------------------------------------------------------
char __cdecl sub_36850(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // esi

  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  v1 = sub_4A190((int)&word_EB398, 9, 9);
  v2 = v1;
  if ( v1 )
  {
    v3 = dword_EA3E4[*(unsigned __int16 *)(a1 + 104)];
    *(_BYTE *)(v1 + 67) = 10;
    *(_BYTE *)(v1 + 68) = 23;
    *(_WORD *)(v1 + 26) = *(_WORD *)(a1 + 26);
    *(_WORD *)(v1 + 150) = *(_WORD *)(a1 + 104);
    sub_655C0((_WORD *)v1, v3);
    LOWORD(v1) = *(_WORD *)(v2 + 32);
    *(_DWORD *)(v2 + 160) = &off_D8456;
    *(_WORD *)(v2 + 28) = v1;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 34);
    *(_BYTE *)(v2 + 66) = *(_BYTE *)(v3 + 64);
    LOBYTE(v1) = *(_BYTE *)(v3 + 63);
    *(_BYTE *)(v2 + 65) = v1;
    *(_WORD *)(v2 + 80) += *(_WORD *)(a1 + 88);
    *(_WORD *)(v2 + 42) = *(_WORD *)(a1 + 42);
  }
  return v1;
}
// D8456: using guessed type void *off_D8456;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00036920) --------------------------------------------------------
__int16 __usercall sub_36920@<ax>(__int16 a1@<bx>, int a2)
{
  __int16 i; // si
  __int16 result; // ax

  for ( i = 0; i < 7 && *(_DWORD *)(a2 + 144) > dword_DB538[i]; ++i )
    ;
  result = sub_369F0(a1, *(_WORD *)(a2 + 148));
  if ( result + i != *(__int16 *)(a2 + 90) )
  {
    sub_49C90(a2, i + result);
    result = i;
    switch ( i )
    {
      case 0:
        a1 = 13;
        break;
      case 1:
        a1 = 28;
        break;
      case 2:
        a1 = 42;
        break;
      case 3:
        a1 = 56;
        break;
      case 4:
        a1 = 70;
        break;
      case 5:
        a1 = 84;
        break;
      case 6:
        a1 = 98;
        break;
      case 7:
        a1 = 112;
        break;
      default:
        break;
    }
    *(_WORD *)(a2 + 84) = a1;
    *(_WORD *)(a2 + 86) = a1;
    *(_WORD *)(a2 + 88) = a1;
    *(_WORD *)(a2 + 82) = a1;
  }
  return result;
}
// DB538: using guessed type int dword_DB538[8];

//----- (000369F0) --------------------------------------------------------
int __usercall sub_369F0@<eax>(int a1@<ebx>, __int16 a2)
{
  unsigned int v2; // eax

  v2 = dword_EA3E4[a2];
  if ( v2 > dword_EA3E4[0] && *(_BYTE *)(v2 + 63) == 3 )
    return sub_36A50(a1, *(_BYTE *)(*(_DWORD *)(v2 + 164) + 56));
  else
    return 52;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00036A50) --------------------------------------------------------
int __usercall sub_36A50@<eax>(int a1@<ebx>, char a2)
{
  char v2; // al
  int result; // eax

  v2 = a2;
  if ( a2 >= 0 )
    v2 = sub_616D0(a2);
  switch ( v2 )
  {
    case -1:
      result = 52;
      break;
    case 0:
      result = 105;
      break;
    case 1:
      result = 113;
      break;
    case 2:
      result = 121;
      break;
    case 3:
      result = 129;
      break;
    case 4:
      result = 137;
      break;
    case 5:
      result = 145;
      break;
    case 6:
      result = 153;
      break;
    case 7:
      a1 = 161;
      goto LABEL_13;
    default:
LABEL_13:
      result = a1;
      break;
  }
  return result;
}

//----- (00036AE0) --------------------------------------------------------
int __cdecl sub_36AE0(__int16 *a1)
{
  int result; // eax
  unsigned __int16 v2; // dx
  int v3; // edi
  unsigned int i; // ecx

  result = sub_10C40(a1 + 38);
  v2 = a1[52];
  a1[40] = result;
  if ( v2 )
  {
    v3 = dword_EA3E4[v2];
    if ( *(_BYTE *)(v3 + 63) == 3 && !a1[74] )
    {
      for ( i = dword_EA3E8; i < dword_EB384; i += 168 )
      {
        if ( ((int)a1 - dword_D41A0 - 28302) / 168 == *(unsigned __int16 *)(i + 148) )
          *(_WORD *)(i + 148) = (v3 - (dword_D41A0 + 28302)) / 168;
      }
    }
    a1[52] = 0;
    return sub_57F10((int)a1);
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EA3E8: using guessed type int dword_EA3E8;
// EB384: using guessed type int dword_EB384;

//----- (00036BA0) --------------------------------------------------------
void __cdecl sub_36BA0(int a1, char a2)
{
  int v2; // edx
  int v3; // edi
  int v4; // eax
  _WORD *v5; // ebx
  int v6; // edx
  __int16 v7; // cx
  unsigned __int16 v8; // dx
  unsigned __int16 v9; // ax
  __int16 v10; // ax
  int v11; // [esp+0h] [ebp-Ch]
  int v12; // [esp+4h] [ebp-8h]
  int v13; // [esp+8h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 144);
  if ( v2 > 0 )
  {
    if ( a2 )
    {
      v3 = v2 / 1000;
      if ( v2 / 1000 < 1 )
        v3 = 1;
      if ( v3 > 16 )
        v3 = 16;
      v13 = *(_DWORD *)(a1 + 144) / v3;
    }
    else
    {
      v3 = 1;
      v13 = *(_DWORD *)(a1 + 144);
    }
    v11 = 0;
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    while ( v3 > v11 )
    {
      v4 = sub_4A190(a1 + 76, 10, 39);
      v5 = (_WORD *)v4;
      if ( v4 )
      {
        if ( v3 - 1 == v11 )
          v6 = *(_DWORD *)(a1 + 144) - (v3 - 1) * v13;
        else
          v6 = v13;
        *(_DWORD *)(v4 + 144) = v6;
        v7 = *(_WORD *)(v4 + 20);
        *(_WORD *)(v4 + 148) = *(_WORD *)(a1 + 148);
        *(_WORD *)(v4 + 20) = 9377 * v7 + 9439;
        v8 = *(_WORD *)(v4 + 20);
        *(_WORD *)(v4 + 28) = (v8 % 0x71u + *(_WORD *)(a1 + 28) - 56) & 0x7FF;
        *(_WORD *)(v4 + 20) = 9377 * v8 + 9439;
        v9 = *(_WORD *)(v4 + 20);
        v5[77] = 0;
        v5[78] = 0;
        v5[65] = v9 % 0x30u + 16;
        v12 = *(__int16 *)(a1 + 80);
        v10 = sub_10C40((__int16 *)(a1 + 76));
        v5[22] = (1024 - (v12 - v10) - (__CFSHL__((1024 - (v12 - v10)) >> 31, 3) + 8 * ((1024 - (v12 - v10)) >> 31))) >> 3;
        sub_57FA0(v5 + 77, v5[14], 0, v5[65]);
      }
      ++v11;
    }
    *(_WORD *)(a1 + 148) = 0;
  }
}

//----- (00036D50) --------------------------------------------------------
int __cdecl sub_36D50(int a1, int a2)
{
  int v2; // eax
  int v4; // edx
  int v5; // eax
  int v6; // eax
  int v7; // edi
  int v8; // edx
  int v9; // eax
  int v10; // eax
  int v11; // eax
  __int64 v12; // rtt

  if ( *(_WORD *)(a1 + 148) || *(_WORD *)(a2 + 148) )
  {
    if ( !*(_WORD *)(a1 + 148) )
    {
      *(_DWORD *)(a1 + 144) += *(_DWORD *)(a2 + 144);
      LOWORD(v2) = *(_WORD *)(a2 + 148);
      *(_WORD *)(a1 + 148) = v2;
      if ( (*(_BYTE *)(a2 + 14) & 0x20) != 0 )
      {
        *(_BYTE *)(a1 + 14) |= 0x20u;
        return sub_57F20(v2, a2);
      }
      return sub_57F20(v2, a2);
    }
    if ( *(_WORD *)(a2 + 148) )
    {
      v4 = dword_EA3E4[*(unsigned __int16 *)(a1 + 148)];
      v5 = dword_EA3E4[*(unsigned __int16 *)(a2 + 148)];
      if ( *(_BYTE *)(v4 + 63) != 10 || *(_BYTE *)(v5 + 63) != 10 )
      {
        if ( *(_BYTE *)(v4 + 63) == 10 )
        {
          v6 = v5 - (dword_D41A0 + 28302);
          *(_DWORD *)(a1 + 144) += *(_DWORD *)(a2 + 144);
          v2 = v6 / 168;
LABEL_21:
          *(_WORD *)(a1 + 148) = v2;
          return sub_57F20(v2, a2);
        }
        if ( *(_BYTE *)(v5 + 63) == 10 )
        {
          v7 = *(_DWORD *)(a2 + 144) + *(_DWORD *)(a1 + 144);
          v8 = v4 - (dword_D41A0 + 28302);
          v9 = v8;
          goto LABEL_20;
        }
        if ( v4 != v5 )
        {
          if ( *(_DWORD *)(v4 + 140) > *(_DWORD *)(v5 + 140) )
          {
            v11 = dword_D41A0 + 28302;
            *(_DWORD *)(a1 + 144) += *(_DWORD *)(a2 + 144);
            v2 = (v4 - v11) / 168;
            goto LABEL_21;
          }
          v7 = *(_DWORD *)(a2 + 144) + *(_DWORD *)(a1 + 144);
          v9 = v5 - (dword_D41A0 + 28302);
          v8 = v9;
LABEL_20:
          LODWORD(v12) = v9;
          HIDWORD(v12) = v8 >> 31;
          v2 = v12 / 168;
          *(_DWORD *)(a1 + 144) = v7;
          goto LABEL_21;
        }
      }
    }
    v10 = *(_DWORD *)(a2 + 144);
    *(_DWORD *)(a1 + 144) += v10;
    return sub_57F20(v10, a2);
  }
  v2 = *(_DWORD *)(a2 + 144);
  *(_DWORD *)(a1 + 144) += v2;
  return sub_57F20(v2, a2);
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00036F30) --------------------------------------------------------
int __cdecl sub_36F30(int a1, int a2)
{
  __int16 v2; // bx

  LOBYTE(v2) = 0;
  if ( *(_BYTE *)(a1 + 70) >= *(_BYTE *)(a2 + 70) )
  {
    if ( *(_WORD *)(a2 + 40) != *(_WORD *)(a1 + 40) )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v2 = *(_WORD *)(a1 + 20) & 1;
    }
  }
  else
  {
    LOBYTE(v2) = 1;
  }
  if ( (_BYTE)v2 )
  {
    *(_WORD *)(a1 + 40) = *(_WORD *)(a2 + 40);
    *(_WORD *)(a1 + 148) = *(_WORD *)(a2 + 148);
    *(_BYTE *)(a1 + 70) = *(_BYTE *)(a2 + 70);
    *(_WORD *)(a1 + 42) = *(_WORD *)(a2 + 42);
  }
  *(_DWORD *)(a1 + 144) += *(_DWORD *)(a2 + 144);
  return sub_57F20(a1, a2);
}

//----- (00036FC0) --------------------------------------------------------
char __cdecl sub_36FC0(int a1)
{
  unsigned __int8 v1; // bl
  int v2; // edi
  unsigned int v3; // esi
  unsigned int v4; // edi
  char result; // al
  unsigned __int16 v6; // bx
  unsigned __int8 v7; // cl
  char v8; // dl
  __int16 v9; // dx
  int v10; // eax
  int v11; // eax
  unsigned __int8 v12; // cl
  char v13; // ch
  unsigned __int16 v14; // bx
  unsigned __int8 *j; // [esp+0h] [ebp-2Ch]
  unsigned __int8 *v16; // [esp+4h] [ebp-28h]
  unsigned int i; // [esp+8h] [ebp-24h]
  unsigned int v18; // [esp+Ch] [ebp-20h]
  unsigned int v19; // [esp+10h] [ebp-1Ch]
  unsigned int k; // [esp+14h] [ebp-18h]
  unsigned __int8 *v21; // [esp+18h] [ebp-14h]
  unsigned __int16 v22; // [esp+1Ch] [ebp-10h]
  unsigned __int16 v23; // [esp+1Ch] [ebp-10h]
  __int16 v24; // [esp+20h] [ebp-Ch]
  char v25; // [esp+24h] [ebp-8h]
  unsigned __int16 v26; // [esp+24h] [ebp-8h]
  char v27; // [esp+25h] [ebp-7h]
  char v28; // [esp+28h] [ebp-4h]

  v28 = 0;
  v25 = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
  v27 = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
  v1 = *(_BYTE *)(a1 + 70);
  v24 = *(__int16 *)(a1 + 80) >> 5;
  v2 = 6 * v1 + dword_EA3BC;
  v3 = *(unsigned __int8 *)(v2 + 5);
  v16 = *(unsigned __int8 **)v2;
  v4 = *(unsigned __int8 *)(v2 + 4);
  result = sub_37740(a1);
  if ( !result )
  {
    if ( word_180660 == 1 )
    {
      v3 >>= 1;
      v4 >>= 1;
    }
    if ( byte_D41B6 && (byte_D93C2[4 * v1] & 4) == 0 )
      v28 = 1;
    LOBYTE(v26) = v25 - (v4 >> 1);
    HIBYTE(v26) = v27 - (v3 >> 1);
    v22 = v26;
    v19 = 0;
    v21 = v16;
    while ( v3 > v19 )
    {
      v6 = v22;
      for ( i = 0; v4 > i; ++i )
      {
        sub_57390(v6, *(_WORD *)(a1 + 26));
        v7 = v21[1];
        if ( v7 != 0xFF )
        {
          byte_11B4E0[v6] = v7 + v24;
          v8 = byte_13B4E0[v6];
          if ( (v8 & 7) == 0 )
          {
            byte_13B4E0[v6] = v8 & 0xF8 | 1;
            sub_462A0(v6, v6);
          }
        }
        if ( v28 )
        {
          v9 = (unsigned __int8)byte_11B4E0[v6];
          if ( v9 >= v24 )
            v10 = (unsigned __int8)v9;
          else
            v10 = v24;
          v11 = v10 + 80;
          if ( v11 > 255 )
            v11 = 255;
          if ( v11 > (unsigned __int8)byte_14B4E0[v6] )
            byte_14B4E0[v6] = v11;
          v12 = byte_11B4E0[v6];
          if ( (unsigned __int8)byte_14B4E0[v6] > v12 )
          {
            byte_13B4E0[v6] &= ~8u;
          }
          else
          {
            v13 = byte_13B4E0[v6] | 8;
            byte_14B4E0[v6] = v12 - 1;
            byte_13B4E0[v6] = v13;
          }
        }
        LOBYTE(v6) = v6 + 1;
        v21 += 2;
      }
      ++v19;
      ++HIBYTE(v22);
    }
    v23 = v26;
    result = (char)v16;
    v18 = 0;
    for ( j = v16; v3 > v18; ++HIBYTE(v23) )
    {
      v14 = v23;
      for ( k = 0; v4 > k; ++k )
      {
        if ( *j != 0xFF )
          sub_45DC0((char)j, 0, v14, *j);
        LOBYTE(v14) = v14 + 1;
        j += 2;
      }
      result = ++v18;
    }
  }
  return result;
}
// D41B6: using guessed type char byte_D41B6;
// EA3BC: using guessed type int dword_EA3BC;
// 180660: using guessed type __int16 word_180660;

//----- (00037240) --------------------------------------------------------
void __cdecl sub_37240(int a1)
{
  unsigned __int8 v1; // cl
  int v2; // esi
  unsigned int v3; // edi
  unsigned int v4; // esi
  int v5; // ecx
  char v6; // dh
  __int16 v7; // dx
  int v8; // eax
  int v9; // eax
  int v10; // edx
  unsigned __int8 v11; // ch
  char v12; // cl
  _BYTE *v13; // ebx
  unsigned int v14; // edx
  unsigned __int8 *v15; // ebx
  char v16; // dl
  unsigned __int8 v17; // al
  __int16 v18; // ax
  int v19; // edi
  unsigned int v20; // [esp+0h] [ebp-58h]
  unsigned int v21; // [esp+4h] [ebp-54h]
  unsigned int v22; // [esp+8h] [ebp-50h]
  unsigned int v23; // [esp+Ch] [ebp-4Ch]
  unsigned int v24; // [esp+18h] [ebp-40h]
  _BYTE *v25; // [esp+1Ch] [ebp-3Ch]
  _BYTE *v26; // [esp+20h] [ebp-38h]
  unsigned int v27; // [esp+24h] [ebp-34h]
  unsigned int v28; // [esp+28h] [ebp-30h]
  unsigned int v29; // [esp+2Ch] [ebp-2Ch]
  unsigned int v30; // [esp+30h] [ebp-28h]
  unsigned int v31; // [esp+34h] [ebp-24h]
  unsigned int v32; // [esp+38h] [ebp-20h]
  _BYTE *v33; // [esp+40h] [ebp-18h]
  int v34; // [esp+44h] [ebp-14h]
  char v35; // [esp+48h] [ebp-10h]
  unsigned __int16 v36; // [esp+48h] [ebp-10h]
  __int16 v37; // [esp+48h] [ebp-10h]
  char v38; // [esp+49h] [ebp-Fh]
  unsigned __int16 v39; // [esp+4Ch] [ebp-Ch]
  unsigned __int16 v40; // [esp+4Ch] [ebp-Ch]
  unsigned __int16 v41; // [esp+4Ch] [ebp-Ch]
  unsigned __int16 i; // [esp+4Ch] [ebp-Ch]
  __int16 v43; // [esp+4Ch] [ebp-Ch]
  unsigned __int16 v44; // [esp+50h] [ebp-8h]
  unsigned __int16 v45; // [esp+50h] [ebp-8h]
  unsigned __int16 v46; // [esp+50h] [ebp-8h]
  unsigned __int16 v47; // [esp+50h] [ebp-8h]
  __int16 v48; // [esp+50h] [ebp-8h]
  char v49; // [esp+54h] [ebp-4h]

  v49 = 0;
  if ( *(_DWORD *)(a1 + 4) == *(_DWORD *)(a1 + 8) )
    sub_49EC0((_WORD *)a1, *(char *)(a1 + 70));
  if ( !sub_37740(a1) )
  {
    v35 = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
    v1 = *(_BYTE *)(a1 + 70);
    v38 = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
    v34 = *(__int16 *)(a1 + 80) >> 5;
    v2 = 6 * v1 + dword_EA3BC;
    v3 = *(unsigned __int8 *)(v2 + 5);
    v25 = *(_BYTE **)v2;
    v4 = *(unsigned __int8 *)(v2 + 4);
    if ( word_180660 == 1 )
    {
      v3 >>= 1;
      v4 >>= 1;
    }
    if ( byte_D41B6 && (byte_D93C2[4 * v1] & 4) == 0 )
      v49 = 1;
    v21 = v3 >> 1;
    v5 = *(_DWORD *)(a1 + 8) - 1;
    *(_DWORD *)(a1 + 8) = v5;
    v24 = v4 >> 1;
    if ( v5 <= 0 )
    {
      LOBYTE(v37) = v35 - v24;
      HIBYTE(v37) = v38 - v21;
      v22 = 0;
      v43 = v37;
      v26 = v25;
      while ( v3 > v22 )
      {
        v20 = 0;
        v48 = v43;
        while ( v4 > v20 )
        {
          if ( *v26 != 0xFF )
            sub_462A0(v48, v48);
          ++v20;
          v26 += 2;
          LOBYTE(v48) = v48 + 1;
        }
        ++v22;
        ++HIBYTE(v43);
      }
      v17 = *(_BYTE *)(a1 + 69);
      if ( v17 >= 0x30u )
      {
        if ( v17 <= 0x30u )
        {
          *(_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 40)] + 46) = 2;
          sub_377A0(a1);
          sub_57F10(a1);
        }
        else if ( v17 == 51 )
        {
          *(_DWORD *)(a1 + 8) = 1000 * *(unsigned __int16 *)(a1 + 42);
          v18 = *(_WORD *)(a1 + 148);
          *(_BYTE *)(a1 + 69) = 52;
          if ( v18 )
            *(_BYTE *)(a1 + 12) &= ~1u;
          else
            *(_BYTE *)(a1 + 12) |= 1u;
          *(_WORD *)(a1 + 158) = *(_WORD *)(a1 + 80);
          *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
          v19 = (unsigned __int16)(v3 >> 1);
          sub_48A20(v19, v37, SHIBYTE(v37), v19, (unsigned __int16)(v4 >> 1), 2u);
          sub_48A20(v19, v37, SHIBYTE(v37), v19, (unsigned __int16)(v4 >> 1), 5u);
          sub_377A0(a1);
        }
      }
    }
    else
    {
      LOBYTE(v36) = v35 - v24;
      HIBYTE(v36) = v38 - v21;
      if ( *(_DWORD *)(a1 + 4) - 1 == *(_DWORD *)(a1 + 8) )
      {
        v28 = 0;
        v39 = v36;
        while ( v3 > v28 )
        {
          v29 = 0;
          v44 = v39;
          while ( v4 > v29 )
          {
            sub_57390(v44, *(_WORD *)(a1 + 26));
            ++v29;
            LOBYTE(v44) = v44 + 1;
          }
          ++v28;
          ++HIBYTE(v39);
        }
      }
      v40 = v36;
      v27 = 0;
      v33 = v25;
      while ( v3 > v27 )
      {
        v32 = 0;
        v45 = v40;
        while ( v4 > v32 )
        {
          if ( v33[1] != 0xFF )
          {
            v6 = byte_13B4E0[v45];
            byte_11B4E0[v45] += ((unsigned __int8)v33[1] + (__int16)v34 - (unsigned __int8)byte_11B4E0[v45])
                              / *(_DWORD *)(a1 + 8);
            if ( (v6 & 7) == 0 )
            {
              byte_13B4E0[v45] = v6 & 0xF0 | 1;
              sub_462A0(v45, v45);
            }
          }
          if ( v49 )
          {
            v7 = (unsigned __int8)byte_11B4E0[v45];
            if ( v7 >= (__int16)v34 )
              v8 = (unsigned __int8)v7;
            else
              v8 = (__int16)v34;
            v9 = v8 + 80;
            if ( v9 > 255 )
              v9 = 255;
            v10 = (unsigned __int8)byte_14B4E0[v45];
            if ( v9 > v10 )
              byte_14B4E0[v45] = v10 + (v9 - v10) / *(_DWORD *)(a1 + 8);
            v11 = byte_11B4E0[v45];
            if ( (unsigned __int8)byte_14B4E0[v45] > v11 )
            {
              byte_13B4E0[v45] &= ~8u;
            }
            else
            {
              byte_14B4E0[v45] = v11 - 1;
              byte_13B4E0[v45] |= 8u;
            }
          }
          ++v32;
          v33 += 2;
          LOBYTE(v45) = v45 + 1;
        }
        ++v27;
        ++HIBYTE(v40);
      }
      v12 = 5;
      if ( !(*(_DWORD *)(a1 + 8) % 5) || *(_DWORD *)(a1 + 8) == 1 )
      {
        v13 = v25;
        v14 = 0;
        v41 = v36;
        while ( v14 < v3 )
        {
          v12 = 0;
          v31 = 0;
          v46 = v41;
          while ( v4 > v31 )
          {
            if ( *v13 != 0xFF )
            {
              v12 = byte_13B4E0[v46] & 0xF0 | 1;
              byte_13B4E0[v46] = v12;
              byte_10B4E0[v46] = 1;
            }
            v13 += 2;
            ++v31;
            LOBYTE(v46) = v46 + 1;
          }
          ++v14;
          ++HIBYTE(v41);
        }
        v30 = 0;
        v15 = v25;
        for ( i = v36; v3 > v30; ++HIBYTE(i) )
        {
          v16 = 0;
          v23 = 0;
          v47 = i;
          while ( v4 > v23 )
          {
            if ( *v15 != 0xFF )
              sub_45DC0(v16, v12, v47, *v15);
            v15 += 2;
            v12 = v23 + 1;
            v16 = v47 + 1;
            ++v23;
            LOBYTE(v47) = v47 + 1;
          }
          ++v30;
        }
      }
    }
  }
}
// D41B6: using guessed type char byte_D41B6;
// EA3BC: using guessed type int dword_EA3BC;
// EA3E4: using guessed type int dword_EA3E4[];
// 180660: using guessed type __int16 word_180660;

//----- (00037740) --------------------------------------------------------
char __cdecl sub_37740(int a1)
{
  unsigned int v1; // ebx
  char v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  v1 = *(_DWORD *)(dword_D41A4 + 38535);
  if ( v1 <= dword_EA3E4[0] )
    return 0;
  while ( *(_BYTE *)(v1 + 63) != 10 || *(_BYTE *)(v1 + 64) != 42 || !sub_10750(a1, v1) )
  {
    v1 = *(_DWORD *)v1;
    if ( v1 <= dword_EA3E4[0] )
      return v3;
  }
  return 1;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000377A0) --------------------------------------------------------
void __cdecl sub_377A0(int a1)
{
  __int16 *i; // ebx

  for ( i = *(__int16 **)(dword_D41A4 + 38519); (unsigned int)i > dword_EA3E4[0]; i = *(__int16 **)i )
  {
    if ( sub_10750(a1, (int)i) )
      sub_5FBD0(i);
  }
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000377F0) --------------------------------------------------------
__int16 __cdecl sub_377F0(int a1)
{
  char v1; // dl
  char v2; // dh
  int v3; // eax
  unsigned int v4; // esi
  unsigned int v5; // eax
  unsigned int v6; // edi
  char v7; // cl
  __int16 v8; // ax
  int v9; // eax
  unsigned int v10; // edx
  unsigned __int16 v11; // ax
  char v12; // cl
  unsigned __int8 v13; // ch
  unsigned int k; // ecx
  unsigned int v15; // edx
  unsigned __int8 v16; // ch
  unsigned int m; // [esp+0h] [ebp-28h]
  unsigned int i; // [esp+4h] [ebp-24h]
  int v20; // [esp+8h] [ebp-20h]
  unsigned int j; // [esp+10h] [ebp-18h]
  __int16 v22; // [esp+18h] [ebp-10h]

  v1 = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
  v2 = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
  if ( word_180660 == 1 )
    v3 = (int)*(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 4) >> 1;
  else
    v3 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 4);
  v4 = v3;
  if ( word_180660 == 1 )
    v5 = (int)*(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 5) >> 1;
  else
    v5 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 5);
  v6 = v5;
  if ( word_180660 == 1 )
  {
    v6 = v5 >> 1;
    v4 >>= 1;
  }
  LOBYTE(v22) = v1 - (v4 >> 1);
  v7 = *(_BYTE *)(a1 + 12);
  HIBYTE(v22) = v2 - (v6 >> 1);
  if ( (v7 & 2) != 0 )
  {
    if ( !*(_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 40)] + 48) && *(_DWORD *)(a1 + 16) )
    {
      v20 = (*(unsigned __int16 *)(a1 + 42) - *(__int16 *)(a1 + 46)) / *(_DWORD *)(a1 + 16);
      v9 = *(_DWORD *)(a1 + 16);
      *(_WORD *)(a1 + 46) += v20;
      if ( v9 == 1 )
      {
        v10 = 0;
        v11 = v22;
        while ( v6 > v10 )
        {
          for ( i = 0; v4 > i; ++i )
          {
            v12 = byte_13B4E0[v11];
            if ( v12 < 0 )
            {
              byte_13B4E0[v11] = v12 & 0x7F;
              if ( !byte_D41B6 )
                byte_13B4E0[v11] = v12 & 0x77 | 8;
            }
            v13 = v20 + byte_11B4E0[v11];
            byte_11B4E0[v11] = v13;
            if ( byte_D41B6 )
            {
              if ( v13 < (unsigned __int8)byte_14B4E0[v11] )
              {
                byte_13B4E0[v11] &= ~8u;
              }
              else
              {
                byte_14B4E0[v11] = v13 - 1;
                byte_13B4E0[v11] |= 8u;
              }
            }
            LOBYTE(v11) = v11 + 1;
          }
          ++v10;
          v11 = __PAIR16__(HIBYTE(v11), v22) + 256;
        }
        LOWORD(v9) = -10;
        *(_DWORD *)(a1 + 16) = -10;
      }
      else if ( v9 == -1 )
      {
        LOWORD(v9) = v22;
        for ( j = 0; v6 > j; ++j )
        {
          for ( k = 0; k < v4; ++k )
          {
            if ( !byte_D41B6 && (byte_13B4E0[(unsigned __int16)v9] & 8) != 0 )
            {
              byte_13B4E0[(unsigned __int16)v9] |= 0x80u;
              byte_13B4E0[(unsigned __int16)v9] &= ~8u;
            }
            LOBYTE(v9) = v9 + 1;
          }
          LOWORD(v9) = __PAIR16__(BYTE1(v9), v22) + 256;
        }
        ++*(_DWORD *)(a1 + 16);
      }
      else if ( v9 <= 0 )
      {
        *(_DWORD *)(a1 + 16) = v9 + 1;
      }
      else
      {
        v15 = 0;
        LOWORD(v9) = v22;
        while ( v6 > v15 )
        {
          for ( m = 0; v4 > m; ++m )
          {
            v16 = v20 + byte_11B4E0[(unsigned __int16)v9];
            byte_11B4E0[(unsigned __int16)v9] = v16;
            if ( byte_D41B6 )
            {
              if ( v16 < (unsigned __int8)byte_14B4E0[(unsigned __int16)v9] )
              {
                byte_13B4E0[(unsigned __int16)v9] &= ~8u;
              }
              else
              {
                byte_14B4E0[(unsigned __int16)v9] = v16 - 1;
                byte_13B4E0[(unsigned __int16)v9] |= 8u;
              }
            }
            LOBYTE(v9) = v9 + 1;
          }
          ++v15;
          LOWORD(v9) = __PAIR16__(BYTE1(v9), v22) + 256;
        }
        --*(_DWORD *)(a1 + 16);
      }
    }
    else
    {
      *(_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 40)] + 46) = 2;
      *(_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 40)] + 158) = 32 * *(_WORD *)(a1 + 46);
      sub_48A20(v6 >> 1, v1, v2, (unsigned __int16)(v6 >> 1), (unsigned __int16)(v4 >> 1), 3u);
      LOWORD(v9) = sub_57F10(a1);
    }
  }
  else
  {
    *(_WORD *)(a1 + 46) = *(__int16 *)(a1 + 80) >> 5;
    *(_DWORD *)(a1 + 16) = 10;
    *(_BYTE *)(a1 + 12) = v7 | 2;
    v8 = sub_48DF0(v22 - 1, HIBYTE(v22) - 1, v6 + 2, v4 + 2);
    *(_WORD *)(a1 + 42) = v8;
    if ( (unsigned __int16)v8 > 0xDCu )
      *(_WORD *)(a1 + 42) = 220;
    v9 = *(__int16 *)(a1 + 46);
    if ( v9 == *(unsigned __int16 *)(a1 + 42) )
      *(_DWORD *)(a1 + 16) = 0;
  }
  return v9;
}
// D41B6: using guessed type char byte_D41B6;
// EA3BC: using guessed type int dword_EA3BC;
// EA3E4: using guessed type int dword_EA3E4[];
// 180660: using guessed type __int16 word_180660;

//----- (00037BC0) --------------------------------------------------------
__int16 __cdecl sub_37BC0(int a1)
{
  int v1; // eax
  int v2; // edx
  int v3; // eax
  unsigned int v4; // eax
  int v5; // eax
  int v6; // eax
  unsigned int v7; // edx
  unsigned int v8; // edx
  unsigned __int16 v9; // ax
  unsigned __int8 *v10; // esi
  int v11; // edi
  unsigned __int8 v12; // ch
  int v13; // edx
  unsigned int v14; // edi
  int v15; // esi
  char v16; // al
  char v17; // dl
  __int16 v18; // dx
  int v19; // eax
  int v20; // eax
  int v21; // edx
  unsigned __int8 v22; // ch
  int v23; // eax
  unsigned int v24; // esi
  unsigned int v25; // eax
  unsigned int v26; // edx
  unsigned int i; // ecx
  int v29; // [esp+4h] [ebp-54h]
  unsigned int v30; // [esp+10h] [ebp-48h]
  unsigned int v31; // [esp+14h] [ebp-44h]
  unsigned int v32; // [esp+18h] [ebp-40h]
  unsigned int m; // [esp+1Ch] [ebp-3Ch]
  unsigned int v34; // [esp+20h] [ebp-38h]
  unsigned int v35; // [esp+24h] [ebp-34h]
  unsigned int v36; // [esp+28h] [ebp-30h]
  unsigned int v37; // [esp+2Ch] [ebp-2Ch]
  unsigned int v38; // [esp+30h] [ebp-28h]
  int v39; // [esp+34h] [ebp-24h]
  __int16 v40; // [esp+38h] [ebp-20h]
  unsigned __int16 v41; // [esp+38h] [ebp-20h]
  unsigned __int16 v42; // [esp+3Ch] [ebp-1Ch]
  unsigned __int16 k; // [esp+3Ch] [ebp-1Ch]
  unsigned __int16 v44; // [esp+3Ch] [ebp-1Ch]
  unsigned __int16 v45; // [esp+40h] [ebp-18h]
  unsigned __int8 j; // [esp+44h] [ebp-14h]
  char v47; // [esp+48h] [ebp-10h]
  unsigned __int8 v48; // [esp+50h] [ebp-8h]
  char v49; // [esp+54h] [ebp-4h]
  char v50; // [esp+54h] [ebp-4h]

  LOBYTE(v1) = dword_E9C38;
  v29 = dword_E9C38;
  BYTE1(v1) = *(_BYTE *)(a1 + 12);
  if ( (v1 & 0x200) == 0 )
  {
    *(_DWORD *)(a1 + 16) = 19;
    *(_BYTE *)(a1 + 12) = BYTE1(v1) | 2;
  }
  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 <= 0 )
  {
    *(_DWORD *)(a1 + 16) = v2 + 1;
    if ( v2 == -1 )
    {
      v50 = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
      if ( word_180660 == 1 )
        v23 = (int)*(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 4) >> 1;
      else
        v23 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 4);
      v24 = v23;
      if ( word_180660 == 1 )
        v25 = (int)*(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 5) >> 1;
      else
        v25 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 5);
      if ( !byte_D41B6 )
      {
        v26 = 0;
        HIBYTE(v41) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - (v25 >> 1);
        LOBYTE(v41) = v50 - (v24 >> 1);
        v44 = v41;
        while ( v26 < v25 )
        {
          for ( i = 0; i < v24; ++i )
          {
            if ( (byte_13B4E0[v44] & 8) != 0 )
            {
              byte_13B4E0[v44] |= 0x80u;
              byte_13B4E0[v44] &= ~8u;
            }
            LOBYTE(v44) = v44 + 1;
          }
          LOBYTE(v44) = v50 - (v24 >> 1);
          ++v26;
          ++HIBYTE(v44);
        }
      }
      *(_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 40)] + 46) = 2;
      LOWORD(v1) = sub_57F10(a1);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 16) = v2 - 1;
    if ( v2 == 1 )
    {
      if ( *(_BYTE *)(a1 + 59) )
        *(_DWORD *)(a1 + 16) = -25;
      else
        *(_DWORD *)(a1 + 16) = -1;
    }
    else
    {
      v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
      if ( !*(_WORD *)(v1 + 48) )
      {
        v49 = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
        v47 = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
        v39 = *(__int16 *)(a1 + 80) >> 5;
        if ( word_180660 == 1 )
          v3 = (int)*(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 4) >> 1;
        else
          v3 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 4);
        v35 = v3;
        if ( word_180660 == 1 )
          v4 = (int)*(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 5) >> 1;
        else
          v4 = *(unsigned __int8 *)(dword_EA3BC + 6 * *(char *)(a1 + 70) + 5);
        v36 = v4;
        v48 = v4 >> 1;
        LOBYTE(v40) = v49 - (v35 >> 1);
        HIBYTE(v40) = v47 - v48;
        memset(v29, 0, 2 * v4 * v35);
        for ( j = 1; j <= *(char *)(a1 + 70); ++j )
        {
          v5 = 6 * j;
          if ( word_180660 == 1 )
            v6 = (int)*(unsigned __int8 *)(dword_EA3BC + v5 + 4) >> 1;
          else
            v6 = *(unsigned __int8 *)(dword_EA3BC + v5 + 4);
          v30 = v6;
          if ( word_180660 == 1 )
            v7 = (int)*(unsigned __int8 *)(dword_EA3BC + 6 * j + 5) >> 1;
          else
            v7 = *(unsigned __int8 *)(dword_EA3BC + 6 * j + 5);
          v38 = v7;
          v8 = v7 >> 1;
          LOBYTE(v9) = v49 - v8;
          HIBYTE(v9) = v47 - (v30 >> 1);
          v10 = *(unsigned __int8 **)(dword_EA3BC + 6 * j);
          v45 = v9;
          v32 = (unsigned __int8)(v35 >> 1) - v8;
          v37 = 0;
          v11 = v35 * (v48 - (v30 >> 1));
          while ( v37 < v30 )
          {
            v34 = v11 + v32;
            v31 = 0;
            v42 = v45;
            while ( v31 < v38 )
            {
              if ( (*(_BYTE *)(a1 + 14) & 1) != 0 )
                sub_57390(v42, *(_WORD *)(a1 + 26));
              v12 = v10[1];
              if ( v12 != 0xFF )
                *(_WORD *)(v29 + 2 * v34) = v12 + (_WORD)v39 - (unsigned __int8)byte_11B4E0[v42];
              v13 = *(_DWORD *)(a1 + 16) % 7;
              if ( (!v13 || *(_DWORD *)(a1 + 16) == 1) && *v10 != 0xFF )
                sub_45DC0(v13, 7, v42, *v10);
              v10 += 2;
              ++v31;
              LOBYTE(v42) = v42 + 1;
              ++v34;
            }
            v11 += v35;
            ++v37;
            ++HIBYTE(v45);
          }
        }
        LOWORD(v1) = v40;
        v14 = 0;
        v15 = 0;
        for ( k = v40; v14 < v36; ++HIBYTE(k) )
        {
          for ( m = 0; m < v35; ++m )
          {
            if ( *(_WORD *)(v29 + 2 * v15) )
            {
              if ( !byte_11B4E0[k] || sub_57450(byte_10B4E0[k]) )
              {
                byte_13B4E0[k] = byte_13B4E0[k] & 0xF8 | 1;
                sub_46570(k, k);
              }
              byte_11B4E0[k] += *(__int16 *)(v29 + 2 * v15) / *(int *)(a1 + 16);
              if ( *(_DWORD *)(a1 + 16) == 1 )
              {
                v16 = byte_13B4E0[k];
                if ( v16 < 0 )
                {
                  v17 = byte_D41B6;
                  byte_13B4E0[k] = v16 & 0x7F;
                  if ( !v17 )
                    byte_13B4E0[k] = v16 & 0x77 | 8;
                }
              }
            }
            if ( byte_D41B6 )
            {
              v18 = (unsigned __int8)byte_11B4E0[k];
              if ( v18 >= (__int16)v39 )
                v19 = (unsigned __int8)v18;
              else
                v19 = (__int16)v39;
              v20 = v19 + 100;
              if ( v20 > 255 )
                v20 = 255;
              v21 = (unsigned __int8)byte_14B4E0[k];
              if ( v20 > v21 )
                byte_14B4E0[k] += (v20 - v21) / *(_DWORD *)(a1 + 16);
              v22 = byte_11B4E0[k];
              if ( (unsigned __int8)byte_14B4E0[k] > v22 )
              {
                byte_13B4E0[k] &= ~8u;
              }
              else
              {
                byte_14B4E0[k] = v22 - 1;
                byte_13B4E0[k] |= 8u;
              }
            }
            if ( !byte_D41B6 && *(_DWORD *)(a1 + 16) == 2 )
              byte_13B4E0[k] &= ~8u;
            LOBYTE(k) = k + 1;
            ++v15;
          }
          LOBYTE(k) = v49 - (v35 >> 1);
          LOWORD(v1) = __PAIR16__(HIBYTE(k), v40) + 256;
          ++v14;
        }
      }
    }
  }
  return v1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41B6: using guessed type char byte_D41B6;
// E9C38: using guessed type int dword_E9C38;
// EA3BC: using guessed type int dword_EA3BC;
// EA3E4: using guessed type int dword_EA3E4[];
// 180660: using guessed type __int16 word_180660;

//----- (00038270) --------------------------------------------------------
int __cdecl sub_38270(int a1)
{
  int v1; // ebx
  int result; // eax
  int v3; // eax

  *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
  v1 = 0;
  switch ( *(unsigned __int16 *)(a1 + 20) % 0xCu )
  {
    case 0u:
    case 1u:
      result = sub_4A190((int)&word_EB398, 5, 4);
      v1 = result;
      if ( !result )
        goto LABEL_10;
      *(_BYTE *)(result + 69) = 33;
      break;
    case 2u:
    case 3u:
      result = sub_4A190((int)&word_EB398, 5, 14);
      v1 = result;
      if ( !result )
        goto LABEL_10;
      *(_BYTE *)(result + 69) = 113;
      break;
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 8u:
      result = sub_4A190((int)&word_EB398, 5, 13);
      v1 = result;
      if ( !result )
        goto LABEL_10;
      *(_BYTE *)(result + 69) = 105;
      break;
    case 9u:
    case 0xAu:
    case 0xBu:
      v3 = sub_4A190((int)&word_EB398, 5, 12);
      v1 = v3;
      if ( v3 )
        *(_BYTE *)(v3 + 69) = 97;
      goto LABEL_10;
    default:
LABEL_10:
      result = v1;
      break;
  }
  return result;
}
// EB398: using guessed type __int16 word_EB398;

//----- (00038330) --------------------------------------------------------
int __cdecl sub_38330(int a1)
{
  unsigned int v1; // eax
  int v2; // edx
  int v3; // eax
  int v4; // eax
  __int16 v5; // dx
  unsigned int v6; // edx
  __int16 v7; // cx
  __int16 v8; // ax
  __int16 v9; // cx
  unsigned int v10; // ecx
  int result; // eax

  v1 = sub_38B00(a1);
  if ( v1 )
  {
    if ( v1 > 1 )
    {
      if ( v1 == 2 )
        *(_BYTE *)(a1 + 69) = 53;
      goto LABEL_29;
    }
    v2 = *(_DWORD *)(a1 + 16);
    if ( v2 > 2 )
    {
      v3 = *(char *)(a1 + 70);
      *(_DWORD *)(a1 + 16) = v2 - 1;
      if ( (byte_D93C2[4 * v3] & 1) != 0 )
      {
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        word_EB398 += *(_WORD *)(a1 + 84);
        v4 = sub_4A190((int)&word_EB398, 5, 4);
        if ( v4 )
        {
          *(_BYTE *)(v4 + 69) = 33;
          v5 = *(_WORD *)(a1 + 38);
          *(_DWORD *)(v4 + 94) = 1;
          *(_WORD *)(v4 + 98) = v5;
        }
      }
      v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 38)];
      if ( v6 > dword_EA3E4[0] && *(_BYTE *)(v6 + 64) <= 1u )
        *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
    }
  }
  v7 = *(_WORD *)(a1 + 104);
  if ( v7 )
  {
    if ( v7 != *(_WORD *)(a1 + 148) )
    {
      if ( *(_DWORD *)(a1 + 100) )
      {
        *(_WORD *)(a1 + 148) = v7;
        sub_6E450(v7, -1, 4);
        *(_DWORD *)(a1 + 12) &= 0xFFDFFFFE;
        *(_BYTE *)(a1 + 14) |= 0x20u;
        sub_49CD0((_WORD *)a1, 177);
        *(_WORD *)(a1 + 90) += *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 104)] + 164) + 56);
      }
      else if ( (*(_BYTE *)(a1 + 14) & 0x20) == 0 )
      {
        v8 = *(_WORD *)(a1 + 104);
        *(_WORD *)(a1 + 148) = v8;
        sub_6E450(v8, -1, 4);
        *(_BYTE *)(a1 + 12) &= ~1u;
        sub_49CD0((_WORD *)a1, 177);
        *(_WORD *)(a1 + 90) += *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 104)] + 164) + 56);
      }
    }
    *(_WORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  if ( (*(_BYTE *)(a1 + 62) & 0x1F) == 0 && (byte_D93C2[4 * *(char *)(a1 + 70)] & 1) != 0 )
  {
    v9 = *(_WORD *)(a1 + 132);
    if ( v9 > 5 && v9 == *(_DWORD *)(a1 + 16) )
    {
      v10 = *(__int16 *)(a1 + 132);
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      if ( (int)(*(unsigned __int16 *)(a1 + 20) % v10) > *(__int16 *)(a1 + 132) - (*(__int16 *)(a1 + 132) >> 4) - 2 )
      {
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        word_EB398 += *(_WORD *)(a1 + 84);
        sub_38270(a1);
      }
    }
  }
  if ( (byte_D93C2[4 * *(char *)(a1 + 70)] & 1) != 0 )
    sub_5C8D0(a1);
LABEL_29:
  result = sub_10C40((__int16 *)(a1 + 76));
  *(_WORD *)(a1 + 80) = result;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (000385C0) --------------------------------------------------------
int __cdecl sub_385C0(int a1)
{
  unsigned __int8 v1; // dl
  int v2; // eax
  _BYTE *v3; // edi
  int v4; // esi
  int v5; // edx
  int v6; // eax
  __int16 v7; // dx
  unsigned __int8 v8; // cl
  char v9; // ch
  int v11; // esi
  __int16 v12; // cx
  char v13; // ah
  unsigned int v14; // edi
  _BYTE *v15; // eax
  unsigned int v16; // esi
  unsigned int v17; // [esp+0h] [ebp-28h]
  int v18; // [esp+4h] [ebp-24h]
  unsigned int v19; // [esp+8h] [ebp-20h]
  _BYTE *v20; // [esp+Ch] [ebp-1Ch]
  unsigned int v21; // [esp+10h] [ebp-18h]
  unsigned int v22; // [esp+14h] [ebp-14h]
  __int16 v23; // [esp+18h] [ebp-10h]
  unsigned __int16 v24; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v25; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v26; // [esp+20h] [ebp-8h]
  unsigned __int16 v27; // [esp+20h] [ebp-8h]
  unsigned __int16 v28; // [esp+24h] [ebp-4h]

  v1 = *(_BYTE *)(a1 + 70);
  v20 = *(_BYTE **)(dword_EA3BC + 6 * v1);
  v19 = *(unsigned __int8 *)(dword_EA3BC + 6 * v1 + 5);
  v22 = *(unsigned __int8 *)(dword_EA3BC + 6 * v1 + 4);
  if ( word_180660 == 1 )
  {
    v19 >>= 1;
    v22 = *(unsigned __int8 *)(dword_EA3BC + 6 * v1 + 4) >> 1;
  }
  LOBYTE(v28) = ((unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8) - (v22 >> 1);
  HIBYTE(v28) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - (v19 >> 1);
  if ( *(_BYTE *)(a1 + 61) )
  {
    v11 = sub_4A190(a1 + 76, 10, 45);
    if ( v11 )
    {
      sub_49A30(v11, *(char *)(a1 + 61));
      *(_WORD *)(v11 + 80) = *(_WORD *)(a1 + 158);
      *(_BYTE *)(v11 + 65) = *(_BYTE *)(a1 + 65);
      v12 = *(_WORD *)(a1 + 148);
      if ( v12 )
      {
        v13 = *(_BYTE *)(v11 + 12);
        *(_WORD *)(v11 + 148) = v12;
        *(_BYTE *)(v11 + 12) = v13 | 1;
        if ( (*(_BYTE *)(a1 + 14) & 0x20) != 0 )
          *(_BYTE *)(v11 + 14) |= 0x20u;
        else
          *(_BYTE *)(v11 + 14) &= ~0x20u;
        sub_49CD0((_WORD *)v11, 177);
        *(_WORD *)(v11 + 90) = *(_WORD *)(a1 + 90);
      }
      sub_59760(a1, v11);
      v14 = 0;
      v27 = v28;
      v15 = v20;
      while ( v14 < v19 )
      {
        v16 = 0;
        v25 = v27;
        while ( v16 < v22 )
        {
          if ( v15[1] != 0xFF || *v15 != 0xFF )
            byte_13B4E0[v25] &= ~0x80u;
          ++v16;
          v15 += 2;
          LOBYTE(v25) = v25 + 1;
        }
        ++v14;
        ++HIBYTE(v27);
      }
    }
    else
    {
      *(_BYTE *)(a1 + 61) = 0;
    }
  }
  else
  {
    if ( *(_BYTE *)(a1 + 64) )
      LOWORD(v2) = sub_48DF0(v28, SHIBYTE(v28), v19, v22);
    else
      v2 = *(__int16 *)(a1 + 80) >> 5;
    v23 = v2;
    v17 = 0;
    v26 = v28;
    v3 = v20;
    v18 = 0;
    while ( v17 < v19 )
    {
      v21 = 0;
      v24 = v26;
      while ( v21 < v22 )
      {
        if ( v3[1] != 0xFF || *v3 != 0xFF )
        {
          word_EB398 = (unsigned __int8)v24 << 8;
          word_EB39A = HIBYTE(v26) << 8;
          ++v18;
          word_EB39C = 32 * v23;
          if ( (v18 & 7) == 0 )
            word_EB39C = 32 * (v23 - 10);
          v4 = *(_DWORD *)(a1 + 16);
          if ( v4 > 0 )
          {
            *(_DWORD *)(a1 + 16) = v4 - 1;
            if ( (byte_D93C2[4 * *(char *)(a1 + 70)] & 1) != 0 )
            {
              v5 = *(_DWORD *)(a1 + 16);
              if ( v5 )
              {
                if ( v5 >= 4 )
                {
                  v6 = sub_38270(a1);
                }
                else
                {
                  v6 = sub_4A190((int)&word_EB398, 5, 4);
                  if ( v6 )
                    *(_BYTE *)(v6 + 69) = 33;
                }
              }
              else
              {
                v6 = sub_4A190((int)&word_EB398, 5, 12);
                if ( v6 )
                  *(_BYTE *)(v6 + 69) = 97;
              }
              if ( v6 )
              {
                v7 = *(_WORD *)(a1 + 38);
                *(_DWORD *)(v6 + 94) = 1;
                *(_WORD *)(v6 + 98) = v7;
              }
            }
          }
          byte_13B4E0[v24] = byte_13B4E0[v24] & 0x70 | 1;
          sub_46570(v24, v24);
          v8 = v3[1];
          if ( v8 != 0xFF )
          {
            if ( v8 >= (unsigned __int8)byte_11B4E0[v24] )
            {
              byte_11B4E0[v24] = 0;
            }
            else
            {
              *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
              if ( (int)(*(unsigned __int16 *)(a1 + 20) % 0x32u) <= 20 )
              {
                byte_11B4E0[v24] -= v3[1];
              }
              else
              {
                *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
                byte_11B4E0[v24] -= v3[1] - *(_WORD *)(a1 + 20) % 0x14u;
              }
            }
          }
        }
        v3 += 2;
        ++v21;
        LOBYTE(v24) = v24 + 1;
      }
      ++v17;
      ++HIBYTE(v26);
    }
    sub_48B50(v28, SHIBYTE(v28), (unsigned __int16)v19, (unsigned __int16)v22);
    v9 = *(_BYTE *)(a1 + 65);
    if ( v9 )
      sub_4A1E0(v9, v9, 1);
    if ( *(_BYTE *)(a1 + 70) == 68 )
    {
      *(_WORD *)(dword_D41A0 + 222538) = 0;
      return sub_57F10(a1);
    }
  }
  return sub_57F10(a1);
}
// D41A0: using guessed type int dword_D41A0;
// EA3BC: using guessed type int dword_EA3BC;
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;
// 180660: using guessed type __int16 word_180660;

//----- (000389F0) --------------------------------------------------------
int __cdecl sub_389F0(int a1)
{
  int v1; // eax
  __int16 v2; // dx

  v1 = *(_DWORD *)(a1 + 8);
  ++*(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 >= 0 )
  {
    sub_585A0(a1);
    if ( (*(_BYTE *)(a1 + 12) & 2) == 0 )
    {
      *(_BYTE *)(a1 + 12) |= 2u;
      sub_10C40((__int16 *)(a1 + 76));
      if ( sub_106C0(a1, dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(dword_EA3E4[*(__int16 *)(a1 + 26)] + 164) + 58)]) )
      {
        v2 = *(_WORD *)(a1 + 26);
        *(_WORD *)(dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(dword_EA3E4[v2] + 164) + 58)] + 128) = v2;
        *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(dword_EA3E4[v2] + 164) + 58)] + 124) = 10;
      }
      else
      {
        sub_5F890(a1, 0);
      }
    }
  }
  return sub_57F10(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00038B00) --------------------------------------------------------
int __cdecl sub_38B00(int a1)
{
  int v1; // ebx
  int v3; // ecx
  __int16 v4; // bx

  *(_WORD *)(a1 + 38) = 0;
  v1 = 0;
  if ( *(int *)(a1 + 8) < 0 )
    return 2;
  if ( *(_WORD *)(a1 + 98) )
  {
    v3 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 94);
    *(_DWORD *)(a1 + 8) = v3;
    if ( v3 < 0 )
    {
      v4 = *(_WORD *)(a1 + 98);
      *(_WORD *)(a1 + 36) = v4;
      *(_WORD *)(a1 + 38) = v4;
      return 2;
    }
    *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 98);
    *(_DWORD *)(a1 + 94) = 0;
    v1 = 1;
    *(_WORD *)(a1 + 98) = 0;
  }
  return v1;
}

//----- (00038B90) --------------------------------------------------------
int __cdecl sub_38B90(int a1)
{
  int v1; // eax
  int result; // eax
  int v3; // eax
  int v4; // edi
  int v5; // eax
  int v6; // esi
  __int16 v7[4]; // [esp+0h] [ebp-10h] BYREF
  int v8; // [esp+8h] [ebp-8h] BYREF
  int v9; // [esp+Ch] [ebp-4h] BYREF

  v1 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if ( v1 < 0 )
    return sub_57F10(a1);
  if ( (*(_BYTE *)(a1 + 12) & 2) == 0 )
  {
    v3 = dword_D41A0 + 28302;
    *(_DWORD *)(a1 + 12) |= (unsigned int)&loc_10001 + 1;
    sub_6E450((a1 - v3) / 168, -1, 30);
  }
  sub_49EA0(
    (_WORD *)a1,
    (768 * *(_DWORD *)(a1 + 16)
   - (__CFSHL__((768 * *(_DWORD *)(a1 + 16)) >> 31, 2)
    + 4 * ((768 * *(_DWORD *)(a1 + 16)) >> 31))) >> 2,
    512);
  sub_10C80(a1, 0, *(unsigned __int16 *)(a1 + 42) / *(int *)(a1 + 4));
  v4 = sub_10080(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 16));
  if ( v4 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    while ( sub_10130(v4, &v9, &v8) == 1 )
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v7[0] = *(_WORD *)(a1 + 76) - 96 + 160 * v9 + *(_WORD *)(a1 + 20) % 0x81u - 64;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v7[1] = *(_WORD *)(a1 + 20) % 0x81u + *(_WORD *)(a1 + 78) - 96 + 160 * v8 - 64;
      v7[2] = *(_WORD *)(a1 + 80);
      v5 = sub_4A190((int)v7, 10, 0);
      v6 = v5;
      if ( v5 )
      {
        *(_WORD *)(v5 + 26) = *(_WORD *)(a1 + 26);
        *(_WORD *)(v5 + 28) = *(_WORD *)(a1 + 28);
        *(_DWORD *)(v5 + 12) |= (unsigned int)sub_10080;
        sub_49EA0((_WORD *)v5, 512, 512);
        *(_DWORD *)(v6 + 16) = 0;
      }
    }
    sub_10100(v4);
  }
  result = (*(_DWORD *)(a1 + 16) + 2) / 7;
  *(_DWORD *)(a1 + 16) = (*(_DWORD *)(a1 + 16) + 2) % 7;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00038D80) --------------------------------------------------------
signed int __cdecl sub_38D80(int a1)
{
  signed int result; // eax
  unsigned int i; // ebx
  unsigned int v3; // ecx

  result = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = result - 1;
  if ( result < 0 )
    return sub_57F10(a1);
  for ( i = *(_DWORD *)(dword_D41A4 + 38523); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( !*(_WORD *)(i + 122) )
    {
      result = sub_584D0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
      if ( (unsigned int)result < *(_DWORD *)(a1 + 16) )
      {
        v3 = sub_7277A(result);
        if ( v3 > 0x2A )
          v3 = 42;
        result = (a1 - (dword_D41A0 + 28302)) / 168;
        *(_DWORD *)(i + 118) = v3;
        *(_WORD *)(i + 122) = result;
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00038E20) --------------------------------------------------------
int __cdecl sub_38E20(int a1)
{
  return sub_57F10(a1);
}

//----- (00038E40) --------------------------------------------------------
int __cdecl sub_38E40(int a1)
{
  return sub_57F10(a1);
}

//----- (00038E70) --------------------------------------------------------
int __cdecl sub_38E70(int a1)
{
  unsigned __int16 v1; // dx
  int v2; // ebx
  int v3; // eax
  unsigned __int8 v4; // dh
  __int64 v5; // rtt

  v1 = *(_WORD *)(a1 + 150);
  if ( v1 )
  {
    v2 = dword_EA3E4[v1];
    if ( *(_BYTE *)(v2 + 63) == 3 && !*(_BYTE *)(v2 + 64) )
    {
      v3 = *(_DWORD *)(v2 + 164);
      v4 = *(_BYTE *)(v3 + 332);
      if ( v4 < 3u )
      {
        if ( !v4 )
        {
          *(_WORD *)(v3 + 30) = -80;
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          sub_6E450(*(_WORD *)(a1 + 150), -1, (*(_WORD *)(a1 + 20) & 3) + 54);
        }
        LODWORD(v5) = 171 * (unsigned __int8)++*(_BYTE *)(*(_DWORD *)(v2 + 164) + 332);
        HIDWORD(v5) = *(unsigned __int8 *)(*(_DWORD *)(v2 + 164) + 332) / 0xBFA030u;
        sub_5C830(v2, 3, v5 / 3 + 85);
      }
      *(_BYTE *)(*(_DWORD *)(v2 + 164) + 333) = 8;
    }
  }
  return sub_57F10(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00038F70) --------------------------------------------------------
int __cdecl sub_38F70(_WORD *a1)
{
  unsigned __int16 v1; // dx
  int v2; // esi
  int v3; // eax

  v1 = a1[75];
  if ( v1 )
  {
    v2 = dword_EA3E4[v1];
    if ( *(_BYTE *)(v2 + 63) == 3 && !*(_BYTE *)(v2 + 64) )
    {
      v3 = *(_DWORD *)(v2 + 164);
      if ( !*(_BYTE *)(v3 + 334) )
      {
        *(_WORD *)(v3 + 30) = -80;
        a1[10] = 9377 * a1[10] + 9439;
        sub_6E450(a1[75], -1, (a1[10] & 3) + 54);
        sub_11900((int)a1, v2, 0, a1[21]);
      }
      *(_BYTE *)(*(_DWORD *)(v2 + 164) + 334) = 1;
      *(_BYTE *)(*(_DWORD *)(v2 + 164) + 335) = 10;
    }
  }
  return sub_57F10((int)a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00039040) --------------------------------------------------------
char __cdecl sub_39040(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  char v4; // bl
  unsigned __int16 v5; // cx
  __int16 v6; // cx
  int v7; // edx
  int v8; // ecx
  unsigned __int16 v9; // bx
  signed int v10; // eax
  __int16 v11; // ax
  int v12; // ecx
  int v13; // ecx
  char v14; // dl
  int v15; // edx
  int v16; // esi
  char v17; // al
  unsigned __int16 v18; // cx
  int v19; // eax
  int v20; // ecx
  char v21; // al
  char v22; // dh
  unsigned __int16 v23; // dx
  __int16 v24; // ax
  int v25; // esi
  unsigned __int16 v26; // bx
  int v27; // ecx
  int v28; // edi
  int v29; // eax
  unsigned __int16 v30; // bx
  int j; // esi
  int k; // edi
  unsigned __int16 v33; // ax
  __int16 v34; // dx
  unsigned __int16 v35; // bx
  int m; // eax
  int v37; // edx
  unsigned __int16 v38; // si
  __int16 v40[4]; // [esp+0h] [ebp-3Ch] BYREF
  int v41; // [esp+8h] [ebp-34h] BYREF
  __int16 v42; // [esp+Ch] [ebp-30h]
  int i; // [esp+10h] [ebp-2Ch]
  int v44; // [esp+14h] [ebp-28h]
  int v45; // [esp+18h] [ebp-24h]
  int v46; // [esp+1Ch] [ebp-20h]
  int v47; // [esp+20h] [ebp-1Ch]
  int v48; // [esp+24h] [ebp-18h]
  int v49; // [esp+28h] [ebp-14h]
  int v50; // [esp+2Ch] [ebp-10h]
  char v51; // [esp+30h] [ebp-Ch]
  char v52; // [esp+31h] [ebp-Bh]
  char v53; // [esp+34h] [ebp-8h]
  char v54; // [esp+35h] [ebp-7h]
  char v55; // [esp+38h] [ebp-4h]

  v55 = 0;
  LOBYTE(v1) = a1;
  v2 = *(_DWORD *)(a1 + 8) - 1;
  dword_E9B90 = 0;
  *(_DWORD *)(a1 + 8) = v2;
  if ( v2 <= 0 )
  {
    *(_BYTE *)(a1 + 69) = 74;
    *(_BYTE *)(a1 + 70) = 0;
  }
  else
  {
    v3 = (*(__int16 *)(a1 + 76) + 128) >> 8;
    v1 = (*(__int16 *)(a1 + 78) + 128) >> 8;
    v53 = v3 - 15;
    v54 = v1 - 15;
    v51 = v3;
    v4 = *(_BYTE *)(a1 + 70);
    v52 = v1;
    switch ( v4 )
    {
      case 0:
        LOBYTE(v1) = sub_39E40(a1);
        if ( (_BYTE)v1 )
          *(_BYTE *)(a1 + 70) = 1;
        else
          LOBYTE(v1) = sub_57F10(a1);
        break;
      case 1:
        v5 = sub_48DF0(v3 - 9, v1 - 9, 18, 18);
        *(_WORD *)(a1 + 80) = 0;
        *(_WORD *)(a1 + 44) = 0;
        if ( v5 > 0x40u )
        {
          v6 = v5 - 64;
          *(_WORD *)(a1 + 80) = v6;
          if ( v6 > 16 )
            *(_WORD *)(a1 + 44) = 32 * (v6 - 16);
        }
        *(_DWORD *)(a1 + 144) = 0;
        *(_BYTE *)(a1 + 70) = 2;
        *(_DWORD *)(a1 + 16) = 12;
        sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 64);
        goto LABEL_10;
      case 2:
LABEL_10:
        v7 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v7;
        if ( v7 <= 0 )
        {
          *(_BYTE *)(a1 + 70) = 3;
        }
        else
        {
          v8 = 0;
          for ( HIBYTE(v9) = v54; ; ++HIBYTE(v9) )
          {
            v50 = v8;
            if ( v8 >= 30 )
              break;
            LOBYTE(v9) = v53;
            for ( i = 0; i < 30; ++i )
            {
              v40[0] = (unsigned __int8)v9 << 8;
              v40[1] = HIBYTE(v9) << 8;
              v10 = sub_58490((_WORD *)(a1 + 76), v40);
              v47 = v10;
              if ( v10 < 3840 )
              {
                if ( v10 >= 2304 )
                {
                  v11 = sub_581E0((_WORD *)(a1 + 76), v40);
                  v41 = *(_DWORD *)(a1 + 76);
                  v42 = *(_WORD *)(a1 + 80);
                  sub_57FA0(&v41, v11, 0, 3840);
                  v12 = (__int16)sub_10C40((__int16 *)&v41) >> 5;
                  if ( *(__int16 *)(a1 + 44) < v12 )
                    *(_WORD *)(a1 + 44) = v12;
                  v49 = v12
                      - (((((int)sub_10000 + (int)off_DBF50[((v47 - 2304) << 10) / 1536]) >> 1)
                        * (v12 - (*(__int16 *)(a1 + 80) + 64))) >> 16);
                }
                else
                {
                  v49 = *(__int16 *)(a1 + 80)
                      + 64
                      - (__int16)(((char *)sub_10000 - (char *)off_DBF50[((2304 - v10) << 9) / 2304]) >> 10);
                }
                v13 = (v49 - (unsigned __int8)byte_11B4E0[v9]) / *(_DWORD *)(a1 + 16) + (unsigned __int8)byte_11B4E0[v9];
                if ( v13 < 1 )
                  v13 = 1;
                if ( v13 > 255 )
                  v13 = 255;
                v14 = byte_D41B6;
                byte_11B4E0[v9] = v13;
                if ( v14 )
                {
                  v49 = v13 + 64;
                  if ( v13 + 64 > 254 )
                    v49 = 254;
                  v15 = (unsigned __int8)byte_14B4E0[v9];
                  v46 = v9;
                  v49 = v15 - (v15 - v49) / *(_DWORD *)(a1 + 16);
                  byte_14B4E0[v9] = v49;
                }
                v16 = *(__int16 *)(a1 + 80);
                if ( v13 <= v16 + 64 && v13 >= v16 + 6 * *(_DWORD *)(a1 + 16) && sub_57450(byte_10B4E0[v9]) )
                {
                  v17 = byte_13B4E0[v9] & 0xF8;
                  v55 = 1;
                  byte_10B4E0[v9] = 1;
                  byte_13B4E0[v9] = v17 | 1;
                }
              }
              LOBYTE(v9) = v9 + 1;
              ++HIBYTE(v9);
              v18 = v9;
              LOBYTE(v9) = v9 - 2;
              HIBYTE(v9) -= 2;
              v19 = (unsigned __int8)byte_11B4E0[v9];
              LOBYTE(v9) = v9 + 1;
              v20 = v19 - (unsigned __int8)byte_11B4E0[v18] + 32;
              ++HIBYTE(v9);
              if ( v20 >= 28 )
              {
                if ( v20 > 40 )
                  LOBYTE(v20) = (v20 & 7) + 40;
              }
              else
              {
                LOBYTE(v20) = (v20 & 3) + 28;
              }
              if ( *(_BYTE *)(dword_D41A0 + 196308) )
                v21 = 32 - v20 + 32;
              else
                v21 = v20;
              v22 = byte_D41B6;
              byte_12B4E0[v9] = v21;
              if ( v22 )
              {
                if ( (unsigned __int8)byte_14B4E0[v9] > (unsigned __int8)byte_11B4E0[v9] )
                  byte_13B4E0[v9] &= ~8u;
                else
                  byte_13B4E0[v9] |= 8u;
              }
              LOBYTE(v9) = v9 + 1;
            }
            v8 = v50 + 1;
          }
          if ( *(_DWORD *)(a1 + 16) == 5 )
          {
            sub_3A090((unsigned __int16 *)a1);
            v55 = 1;
          }
          if ( v55 )
          {
            LOBYTE(v23) = v51 - 15;
            LOBYTE(v24) = v51 + 15;
            HIBYTE(v23) = v52 - 15;
            HIBYTE(v24) = v52 + 15;
            sub_462A0(v23, v24);
          }
          v25 = 0;
          HIBYTE(v26) = v52 - 1;
          do
          {
            v45 = 0;
            LOBYTE(v26) = v51 - 1;
            while ( v45 < 2 )
            {
              v27 = (unsigned __int8)byte_11B4E0[v26] - (unsigned __int8)byte_11B4E0[v26] / *(int *)(a1 + 16);
              if ( v27 < 0 )
                v27 = 0;
              if ( v27 > 255 )
                LOBYTE(v27) = -1;
              byte_11B4E0[v26] = v27;
              v28 = *(_DWORD *)(a1 + 16);
              v29 = 31 / v28 + 32;
              if ( *(_BYTE *)(dword_D41A0 + 196308) )
                v29 = -31 / v28 + 32;
              byte_12B4E0[v26] = v29;
              LOBYTE(v26) = v26 + 1;
              ++v45;
            }
            ++v25;
            ++HIBYTE(v26);
          }
          while ( v25 < 2 );
        }
        LOBYTE(v1) = a1;
        if ( *(int *)(a1 + 16) < 6 )
          LOBYTE(v1) = sub_39B60(a1);
        break;
      case 3:
        HIBYTE(v30) = v54;
        for ( j = 0; j < 30; ++j )
        {
          LOBYTE(v30) = v53;
          for ( k = 0; k < 30; ++k )
          {
            v48 = v30;
            if ( sub_57450(byte_10B4E0[v30]) || byte_10B4E0[v48] == 8 )
            {
              byte_10B4E0[v30] = 1;
              byte_13B4E0[v30] = byte_13B4E0[v30] & 0xF8 | 1;
            }
            LOBYTE(v30) = v30 + 1;
          }
          ++HIBYTE(v30);
        }
        LOBYTE(v33) = v51 - 15;
        LOBYTE(v34) = v51 + 15;
        HIBYTE(v33) = v52 - 15;
        HIBYTE(v34) = v52 + 15;
        sub_46570(v33, v34);
        HIBYTE(v35) = v52 - 1;
        for ( m = 0; m < 2; ++m )
        {
          v37 = 0;
          LOBYTE(v35) = v51 - 1;
          while ( v37 < 2 )
          {
            if ( *(_BYTE *)(dword_D41A0 + 196308) )
              v44 = 1;
            else
              v44 = 63;
            v38 = v35;
            ++v37;
            LOBYTE(v35) = v35 + 1;
            byte_12B4E0[v38] = v44;
          }
          ++HIBYTE(v35);
        }
        sub_39B60(a1);
        LOBYTE(v1) = a1;
        *(_BYTE *)(a1 + 69) = 73;
        break;
      default:
        return v1;
    }
  }
  return v1;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// E9B90: using guessed type int dword_E9B90;

//----- (000396A0) --------------------------------------------------------
int __cdecl sub_396A0(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  v2 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v2;
  if ( v2 > 0 )
    return sub_39B60(a1);
  *(_BYTE *)(a1 + 69) = 74;
  *(_BYTE *)(a1 + 70) = 0;
  return result;
}

//----- (000396D0) --------------------------------------------------------
unsigned __int8 __cdecl sub_396D0(int a1)
{
  __int16 v1; // dx
  unsigned __int8 result; // al
  int v3; // edi
  __int16 v4; // dx
  unsigned __int16 v5; // bx
  unsigned __int16 v6; // dx
  __int16 v7; // ax
  int v8; // edx
  unsigned __int16 v9; // bx
  __int16 v10; // ax
  __int16 v11; // ax
  int v12; // ecx
  int v13; // edx
  int v14; // ecx
  unsigned __int16 v15; // ax
  int v16; // edx
  int v17; // eax
  char v18; // dl
  char v19; // ch
  unsigned __int16 v20; // bx
  int i; // edi
  int v22; // esi
  char v23; // al
  unsigned __int16 v24; // dx
  unsigned int j; // ecx
  char v26; // dl
  int v27; // [esp+0h] [ebp-30h] BYREF
  __int16 v28; // [esp+4h] [ebp-2Ch]
  __int16 v29[4]; // [esp+8h] [ebp-28h] BYREF
  int k; // [esp+10h] [ebp-20h]
  int n; // [esp+14h] [ebp-1Ch]
  int v32; // [esp+18h] [ebp-18h]
  int m; // [esp+1Ch] [ebp-14h]
  int v34; // [esp+20h] [ebp-10h]
  char v35; // [esp+24h] [ebp-Ch]
  char v36; // [esp+25h] [ebp-Bh]
  char v37; // [esp+28h] [ebp-8h]
  char v38; // [esp+2Ch] [ebp-4h]

  v1 = *(_WORD *)(a1 + 76) + 128;
  v37 = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
  v36 = v37 - 15;
  v38 = HIBYTE(v1);
  result = *(_BYTE *)(a1 + 70);
  v35 = HIBYTE(v1) - 15;
  if ( result )
  {
    if ( result > 1u )
    {
      if ( result == 2 )
      {
        HIBYTE(v20) = v36;
        for ( i = 0; i < 30; ++i )
        {
          LOBYTE(v20) = v35;
          v22 = 0;
          while ( v22 < 30 )
          {
            v23 = sub_439A0(v22++, v20);
            v24 = v20;
            LOBYTE(v20) = v20 + 1;
            byte_11B4E0[v24] = v23;
          }
          ++HIBYTE(v20);
        }
        for ( j = *(_DWORD *)(dword_D41A4 + 38519); j > dword_EA3E4[0]; j = *(_DWORD *)j )
        {
          if ( *(_BYTE *)(j + 64) == 2
            && (*(_BYTE *)(j + 14) & 0x10) != 0
            && *(unsigned __int16 *)(j + 38) == (a1 - (dword_D41A0 + 28302)) / 168 )
          {
            v26 = *(_BYTE *)(j + 14);
            *(_WORD *)(j + 38) = 0;
            *(_BYTE *)(j + 14) = v26 & 0xEF;
          }
        }
        return sub_57F10(a1);
      }
      return result;
    }
  }
  else
  {
    sub_39B60(a1);
    sub_3A090((unsigned __int16 *)a1);
    *(_BYTE *)(a1 + 70) = 1;
    v3 = 0;
    v4 = *(_WORD *)(a1 + 80);
    *(_DWORD *)(a1 + 16) = 16;
    *(_WORD *)(a1 + 80) = v4 + 64;
    HIBYTE(v5) = v36;
    while ( v3 < 30 )
    {
      LOBYTE(v5) = v35;
      for ( k = 0; k < 30; ++k )
      {
        if ( sub_57450(byte_10B4E0[v5]) )
        {
          byte_10B4E0[v5] = 1;
          byte_13B4E0[v5] = byte_13B4E0[v5] & 0xF8 | 1;
        }
        LOBYTE(v5) = v5 + 1;
      }
      ++v3;
      ++HIBYTE(v5);
    }
    LOBYTE(v6) = v38 - 15;
    LOBYTE(v7) = v38 + 15;
    HIBYTE(v6) = v37 - 15;
    HIBYTE(v7) = v37 + 15;
    sub_462A0(v6, v7);
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 64);
  }
  result = a1;
  if ( (*(_BYTE *)(a1 + 8) & 3) == 0 )
  {
    v8 = *(_DWORD *)(a1 + 16) - 1;
    *(_DWORD *)(a1 + 16) = v8;
    if ( v8 <= 0 )
    {
      *(_BYTE *)(a1 + 70) = 2;
    }
    else
    {
      HIBYTE(v9) = v36;
      for ( m = 0; m < 30; ++m )
      {
        LOBYTE(v9) = v35;
        for ( n = 0; n < 30; ++n )
        {
          v29[0] = (unsigned __int8)v9 << 8;
          v29[1] = HIBYTE(v9) << 8;
          v34 = sub_58490((_WORD *)(a1 + 76), v29);
          if ( v34 < 3840 )
          {
            v10 = sub_581E0((_WORD *)(a1 + 76), v29);
            v27 = *(_DWORD *)(a1 + 76);
            v28 = *(_WORD *)(a1 + 80);
            sub_57FA0(&v27, v10, 0, 3840);
            v11 = sub_10C40((__int16 *)&v27);
            v12 = (v11 >> 5)
                - (((((int)sub_10000 + (int)off_DBF50[(v34 << 10) / 3840]) >> 1) * ((v11 >> 5) - *(__int16 *)(a1 + 80))) >> 16);
            *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
            v13 = (*(_WORD *)(a1 + 20) & 3) + v12 - 2;
            v32 = (unsigned __int8)byte_11B4E0[v9];
            v32 += (v13 - v32) / *(_DWORD *)(a1 + 16);
            if ( v32 < 1 )
              v32 = 1;
            if ( v32 > 255 )
              v32 = 255;
            byte_11B4E0[v9] = v32;
            if ( *(int *)(a1 + 16) < 3 )
              byte_11B4E0[v9] = sub_439A0(v9, v9);
            if ( byte_D41B6 )
            {
              v14 = (unsigned __int8)byte_11B4E0[v9] + 64;
              if ( v14 > 254 )
                v14 = 254;
              byte_14B4E0[v9] -= ((unsigned __int8)byte_14B4E0[v9] - v14) / *(_DWORD *)(a1 + 16);
            }
          }
          LOBYTE(v9) = v9 + 1;
          ++HIBYTE(v9);
          v15 = v9;
          LOBYTE(v9) = v9 - 2;
          HIBYTE(v9) -= 2;
          v16 = (unsigned __int8)byte_11B4E0[v9];
          LOBYTE(v9) = v9 + 1;
          v17 = v16 - (unsigned __int8)byte_11B4E0[v15] + 32;
          ++HIBYTE(v9);
          if ( v17 >= 28 )
          {
            if ( v17 > 40 )
              LOBYTE(v17) = (v17 & 7) + 40;
          }
          else
          {
            LOBYTE(v17) = (v17 & 3) + 28;
          }
          if ( *(_BYTE *)(dword_D41A0 + 196308) )
            v18 = 32 - v17 + 32;
          else
            v18 = v17;
          v19 = byte_D41B6;
          byte_12B4E0[v9] = v18;
          if ( v19 )
          {
            if ( (unsigned __int8)byte_14B4E0[v9] > (unsigned __int8)byte_11B4E0[v9] )
              byte_13B4E0[v9] &= ~8u;
            else
              byte_13B4E0[v9] |= 8u;
          }
          result = n + 1;
          LOBYTE(v9) = v9 + 1;
        }
        ++HIBYTE(v9);
      }
    }
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00039B60) --------------------------------------------------------
int __cdecl sub_39B60(int a1)
{
  char v1; // al
  int i; // eax
  signed int v3; // eax
  int v4; // esi
  int v5; // esi
  __int16 v6; // ax
  int v7; // ecx
  int v8; // eax
  int v9; // ebx
  int result; // eax
  __int16 v11[4]; // [esp+0h] [ebp-1Ch] BYREF
  int v12; // [esp+8h] [ebp-14h]
  int v13; // [esp+Ch] [ebp-10h]
  unsigned __int16 v14; // [esp+10h] [ebp-Ch]
  int v15; // [esp+14h] [ebp-8h]
  int v16; // [esp+18h] [ebp-4h]

  v1 = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - 13;
  LOBYTE(v13) = ((unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8) - 13;
  BYTE1(v13) = v1;
  v15 = 0;
  v14 = v13;
  do
  {
    v16 = 0;
    LOBYTE(v14) = v13;
    while ( (__int16)v16 < 26 )
    {
      v11[0] = (unsigned __int8)v14 << 8;
      v11[1] = HIBYTE(v14) << 8;
      if ( (unsigned int)sub_584D0((_WORD *)(a1 + 76), v11) < 0xA90000 )
      {
        for ( i = word_15B4E0[v14]; ; i = *(unsigned __int16 *)(v9 + 22) )
        {
          v9 = dword_EA3E4[i];
          if ( v9 == dword_EA3E4[0] )
            goto LABEL_33;
          if ( sub_39FA0(a1, dword_EA3E4[i]) )
          {
            v3 = sub_58490((_WORD *)(v9 + 76), (_WORD *)(a1 + 76));
            v4 = *(__int16 *)(v9 + 80) - *(__int16 *)(a1 + 44);
            v12 = v4;
            if ( v3 < 3328 && v4 < 4096 )
              break;
          }
LABEL_23:
          if ( *(_BYTE *)(a1 + 69) == 74 && (*(_BYTE *)(v9 + 14) & 0x10) != 0 )
          {
            if ( *(_BYTE *)(v9 + 63) == 3
              && !*(_BYTE *)(v9 + 64)
              && *(_WORD *)(*(_DWORD *)(v9 + 164) + 56) == *(_WORD *)(dword_D41A0 + 12) )
            {
              *(_BYTE *)(v9 + 12) |= 1u;
            }
            else
            {
              *(_BYTE *)(v9 + 12) &= ~1u;
            }
            *(_BYTE *)(v9 + 14) &= ~0x10u;
          }
        }
        if ( v3 <= 32 || v4 <= 96 )
        {
          sub_3A200(a1, v9);
          goto LABEL_23;
        }
        *(_DWORD *)&word_EB398 = *(_DWORD *)(v9 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(v9 + 80);
        v5 = (char)((((3328 - v3) << 8) / 3328) >> 1);
        if ( v5 < 4 )
          v5 = 4;
        if ( v5 > v3 )
          LOWORD(v5) = v3;
        v6 = sub_581E0(&word_EB398, (_WORD *)(a1 + 76));
        sub_57FA0(&word_EB398, v6, 0, v5);
        v7 = (__int16)sub_10C40(&word_EB398);
        if ( *(_BYTE *)(v9 + 63) == 3 && !*(_BYTE *)(v9 + 64) )
        {
          v8 = (__int16)(word_EB39C
                       - ((48
                         * ((((4096 - v12) << 8)
                           - (__CFSHL__((4096 - v12) << 8 >> 31, 12)
                            + ((4096 - v12) << 8 >> 31 << 12))) >> 12)) >> 8));
          word_EB39C -= (48
                       * ((((4096 - v12) << 8)
                         - (__CFSHL__((4096 - v12) << 8 >> 31, 12)
                          + ((4096 - v12) << 8 >> 31 << 12))) >> 12)) >> 8;
          goto LABEL_19;
        }
        v8 = *(__int16 *)(*(_DWORD *)(v9 + 160) + 14);
        if ( v8 < -64 )
          goto LABEL_20;
        word_EB39C -= (48
                     * ((((4096 - v12) << 8) - (__CFSHL__((4096 - v12) << 8 >> 31, 12) + ((4096 - v12) << 8 >> 31 << 12))) >> 12)) >> 8;
        v8 = word_EB39C;
LABEL_19:
        if ( v8 < v7 )
LABEL_20:
          word_EB39C = v7;
        sub_57CF0(v8, v9, (int)&word_EB398);
        goto LABEL_23;
      }
LABEL_33:
      ++v16;
      LOBYTE(v14) = v14 + 1;
    }
    result = ++v15;
    ++HIBYTE(v14);
  }
  while ( (__int16)v15 < 26 );
  return result;
}
// 39CA6: conditional instruction was optimized away because esi.4 is in (4..7F)
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00039E40) --------------------------------------------------------
char __cdecl sub_39E40(int a1)
{
  char v1; // ch
  int v2; // edx
  int v3; // esi
  unsigned __int16 v4; // ax
  int v5; // edi
  char v6; // bl
  int v7; // esi
  unsigned __int16 v8; // ax
  int v9; // edx
  int i; // edx
  unsigned __int8 v11; // ch
  char v12; // ch
  int v13; // edx
  int v15; // [esp+4h] [ebp-8h]

  v1 = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
  v2 = 0;
  v3 = 0;
  HIBYTE(v4) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - 15;
  while ( v3 < 30 )
  {
    v5 = 0;
    LOBYTE(v4) = v1 - 15;
    while ( v5 < 30 )
    {
      if ( !byte_10B4E0[v4] )
        ++v2;
      ++v5;
      LOBYTE(v4) = v4 + 1;
    }
    ++v3;
    ++HIBYTE(v4);
  }
  if ( v2 >= 225 )
    return 0;
  v6 = v1 - 27;
  v7 = 0;
  HIBYTE(v8) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - 27;
  do
  {
    v9 = 0;
    for ( LOBYTE(v8) = v6; ; LOBYTE(v8) = v8 + 1 )
    {
      v15 = v9;
      if ( v9 >= 54 )
        break;
      for ( i = word_15B4E0[v8]; ; i = *(unsigned __int16 *)(v13 + 22) )
      {
        v13 = dword_EA3E4[i];
        if ( v13 == dword_EA3E4[0] )
          break;
        if ( v13 != a1 && *(_BYTE *)(v13 + 63) == 10 )
        {
          v11 = *(_BYTE *)(v13 + 64);
          if ( v11 >= 0x2Du )
          {
            if ( v11 <= 0x2Du )
            {
              v12 = *(_BYTE *)(v13 + 69);
              if ( v12 == 48 || v12 == 51 )
                return 0;
            }
            else if ( v11 == 67 )
            {
              return 0;
            }
          }
        }
      }
      v9 = v15 + 1;
    }
    ++v7;
    ++HIBYTE(v8);
  }
  while ( v7 < 54 );
  return 1;
}
// EA3E4: using guessed type int dword_EA3E4[];
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00039FA0) --------------------------------------------------------
char __cdecl sub_39FA0(int a1, int a2)
{
  char result; // al
  char v3; // bl
  unsigned __int8 v4; // ah
  unsigned __int8 v5; // dl
  unsigned __int8 v6; // ah
  unsigned __int8 v7; // dl
  _BOOL1 v8; // zf

  result = 1;
  switch ( *(_BYTE *)(a2 + 63) )
  {
    case 1:
    case 4:
    case 6:
    case 7:
    case 8:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xF:
      return 0;
    case 3:
      v6 = *(_BYTE *)(a2 + 64);
      if ( !v6 )
        goto LABEL_20;
      if ( v6 > 1u )
      {
        if ( v6 != 2 )
          return result;
        return 0;
      }
      if ( (*(_BYTE *)(a2 + 12) & 0x21) != 0 )
        return 0;
LABEL_20:
      if ( *(_WORD *)(a1 + 26) == *(_WORD *)(a2 + 26) )
        return 0;
      return result;
    case 5:
      if ( (*(_BYTE *)(a2 + 12) & 0x21) != 0 )
        return 0;
      v3 = *(_BYTE *)(a2 + 69);
      if ( v3 == -24 )
        return 0;
      v4 = *(_BYTE *)(a2 + 64);
      if ( v4 < 0x16u )
        return result;
      if ( v4 <= 0x16u )
        return 0;
      if ( v4 != 27 )
        return result;
      if ( v3 == -23 )
        return 0;
      if ( v3 == -22 )
        return 0;
      return result;
    case 9:
      v5 = *(_BYTE *)(a2 + 64);
      if ( !v5 )
        return result;
      if ( v5 < 0xDu )
        return 0;
      if ( v5 > 0xEu )
        return 0;
      return result;
    case 0xA:
      v7 = *(_BYTE *)(a2 + 64);
      if ( v7 < 0x27u )
      {
        v8 = v7 == 6;
      }
      else
      {
        if ( v7 <= 0x28u )
          return result;
        v8 = v7 == 57;
      }
      if ( !v8 )
        return 0;
      return result;
    case 0xE:
      if ( (*(_BYTE *)(a2 + 12) & 0x21) != 0 || *(_BYTE *)(a2 + 64) == 1 )
        return 0;
      return result;
    default:
      return result;
  }
}

//----- (0003A090) --------------------------------------------------------
void __cdecl sub_3A090(unsigned __int16 *a1)
{
  unsigned int i; // ebx
  unsigned int j; // ebx
  int v3; // edi
  int v4; // eax
  int v5; // eax
  unsigned __int16 v6; // bx
  char v7; // al
  int v8; // [esp+0h] [ebp-10h]
  int k; // [esp+4h] [ebp-Ch]
  int v10; // [esp+8h] [ebp-8h]
  char v11; // [esp+Ch] [ebp-4h]

  v8 = 0;
  for ( i = *(_DWORD *)(dword_D41A4 + 38527); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( sub_10750((int)a1, i) )
    {
      *(_DWORD *)(i + 8) = -1;
      *(_BYTE *)(i + 61) = 0;
    }
  }
  for ( j = *(_DWORD *)(dword_D41A4 + 38519); j > dword_EA3E4[0]; j = *(_DWORD *)j )
  {
    if ( *(_BYTE *)(j + 64) == 2 && sub_10750((int)a1, j) )
    {
      v3 = dword_E9B90 + 1;
      v4 = dword_D41A0 + 28302;
      *(_BYTE *)(j + 14) |= 0x10u;
      dword_E9B90 = v3;
      *(_WORD *)(j + 48) = 30;
      *(_WORD *)(j + 38) = ((int)a1 - v4) / 168;
      *(_DWORD *)(j + 94) += a1[21];
      v8 += 2;
      *(_WORD *)(j + 98) = a1[13];
    }
  }
  v11 = ((unsigned __int16)(a1[38] + 128) >> 8) - 15;
  v5 = 0;
  for ( HIBYTE(v6) = ((unsigned __int16)(a1[39] + 128) >> 8) - 15; ; ++HIBYTE(v6) )
  {
    v10 = v5;
    if ( v5 >= 30 )
      break;
    LOBYTE(v6) = v11;
    for ( k = 0; k < 30; ++k )
    {
      if ( (sub_10590(byte_10B4E0[v6]) & 0x7F0000) != 0 )
      {
        v7 = byte_13B4E0[v6] & 0xF8 | 1;
        byte_10B4E0[v6] = 1;
        byte_13B4E0[v6] = v7;
      }
      LOBYTE(v6) = v6 + 1;
    }
    v5 = v10 + 1;
  }
  if ( v8 )
    sub_6D8B0(a1[13], 0x14u, v8);
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E9B90: using guessed type int dword_E9B90;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0003A200) --------------------------------------------------------
void __cdecl sub_3A200(int a1, int a2)
{
  _BOOL1 v2; // ah
  unsigned __int8 v3; // al
  unsigned __int8 v4; // al
  int v5; // edx
  unsigned __int16 v6; // ax
  char v7; // [esp+0h] [ebp-4h]

  v2 = 0;
  v7 = 0;
  v3 = *(_BYTE *)(a2 + 63);
  *(_DWORD *)(a2 + 12) |= (unsigned int)&unk_100001;
  if ( v3 < 3u )
    goto LABEL_13;
  if ( v3 > 3u )
  {
    if ( v3 != 5 )
      goto LABEL_13;
    v4 = *(_BYTE *)(a2 + 64);
    if ( v4 < 0x12u )
    {
      if ( v4 != 12 )
        goto LABEL_13;
    }
    else if ( v4 > 0x12u )
    {
      if ( v4 == 27 )
        v7 = 1;
      goto LABEL_13;
    }
    v2 = 1;
    goto LABEL_13;
  }
  if ( !*(_BYTE *)(a2 + 64) )
  {
    v5 = *(_DWORD *)(a2 + 164);
    *(_WORD *)(a2 + 30) = 512;
    *(_WORD *)(v5 + 343) = 512;
  }
LABEL_13:
  if ( !v2 )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v2 = *(unsigned __int16 *)(a1 + 20) % 7u == 0;
  }
  if ( v2 && !v7 && (*(_BYTE *)(a2 + 56) & 1) != 0 )
  {
    *(_DWORD *)(a2 + 94) += *(_DWORD *)(a2 + 8) + 1;
    v6 = *(_WORD *)(a1 + 26);
    *(_WORD *)(a2 + 98) = v6;
    sub_6D8B0(v6, 0x14u, 1);
  }
}

//----- (0003A2D0) --------------------------------------------------------
void __cdecl sub_3A2D0(int a1)
{
  unsigned __int8 v1; // al
  int v2; // ecx
  int v3; // edx
  int v4; // esi
  int v5; // edi
  int v6; // esi
  int v7; // edx
  char v8; // dl
  unsigned __int16 v9; // dx
  int v10; // ecx
  int v11; // eax
  int v12; // edi
  unsigned __int16 v13; // dx
  int v14; // eax
  __int16 v15; // ax
  int v16; // [esp+0h] [ebp-1Ch] BYREF
  int v17; // [esp+4h] [ebp-18h] BYREF
  int v18; // [esp+8h] [ebp-14h]
  int v19; // [esp+Ch] [ebp-10h]
  int v20; // [esp+10h] [ebp-Ch]
  char v21; // [esp+14h] [ebp-8h]
  char v22; // [esp+18h] [ebp-4h]

  if ( *(int *)(a1 + 8) >= 0 )
  {
    v1 = *(_BYTE *)(a1 + 70);
    if ( v1 )
    {
      if ( v1 > 3u )
      {
LABEL_51:
        --*(_DWORD *)(a1 + 8);
        return;
      }
    }
    else
    {
      v2 = *(_DWORD *)(a1 + 4);
      v3 = *(unsigned __int16 *)(a1 + 42);
      *(_WORD *)(a1 + 44) = v2 >> 3;
      *(_DWORD *)(a1 + 16) = 0;
      *(_BYTE *)(a1 + 70) = 1;
      *(_WORD *)(a1 + 42) = 4 * (v3 / v2);
    }
    v4 = *(__int16 *)(a1 + 44);
    v5 = *(_DWORD *)(a1 + 8);
    if ( *(_DWORD *)(a1 + 4) - 3 * v4 >= v5 )
    {
      if ( *(_DWORD *)(a1 + 4) - 5 * v4 > v5 )
      {
        v6 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v6;
      }
      else
      {
        v6 = 3 * v4;
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        if ( !(*(unsigned __int16 *)(a1 + 20) % 5u) )
          *(_BYTE *)(a1 + 70) += 2;
      }
    }
    else
    {
      v6 = *(_DWORD *)(a1 + 16) + 1;
      *(_DWORD *)(a1 + 16) = v6;
    }
    if ( v6 < 0 )
      v6 = 0;
    v7 = *(__int16 *)(a1 + 44);
    if ( v6 > 3 * v7 )
      v6 = 3 * v7;
    if ( v6 < 0 )
      v6 = 0;
    if ( v6 > 15 )
      v6 = 15;
    v8 = *(_BYTE *)(a1 + 70);
    v20 = 0;
    if ( v8 > 1 )
    {
      v20 = 1;
      *(_BYTE *)(a1 + 70) = v8 - 1;
    }
    if ( v6 > 0 )
    {
      v21 = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
      v22 = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
      v18 = sub_10080(0, v6);
      if ( v18 )
      {
        while ( sub_10130(v18, &v17, &v16) == 1 )
        {
          LOBYTE(v9) = v17 + v21;
          HIBYTE(v9) = v16 + v22;
          if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
            v10 = 1;
          else
            v10 = -1;
          v11 = v10 + (unsigned __int8)byte_11B4E0[v9];
          if ( v11 < 0 )
            v11 = 0;
          if ( v11 > 255 )
            LOBYTE(v11) = -1;
          byte_11B4E0[v9] = v11;
        }
        sub_10100(v18);
      }
      if ( v20 )
      {
        v12 = sub_10080(0, v6 >> 1);
        if ( v12 )
        {
          while ( sub_10130(v12, &v17, &v16) == 1 )
          {
            LOBYTE(v13) = v17 + v21;
            HIBYTE(v13) = v16 + v22;
            if ( (*(_BYTE *)(a1 + 8) & 1) != 0 )
              v19 = 1;
            else
              v19 = -1;
            v14 = v19 + (unsigned __int8)byte_11B4E0[v13];
            if ( v14 < 0 )
              v14 = 0;
            if ( v14 > 255 )
              LOBYTE(v14) = -1;
            byte_11B4E0[v13] = v14;
          }
          sub_10100(v12);
        }
      }
      if ( (*(_BYTE *)(a1 + 8) & 3) == 0 )
      {
        sub_49EA0((_WORD *)a1, (_WORD)v6 << 8, 2048);
        sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
        v15 = sub_10C80(a1, 0, *(_WORD *)(a1 + 42));
        if ( v15 )
          sub_6D8B0(*(_WORD *)(a1 + 26), 0xFu, v15);
      }
    }
    goto LABEL_51;
  }
  sub_57F10(a1);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0003A5B0) --------------------------------------------------------
void __cdecl sub_3A5B0(int a1)
{
  int v1; // edx
  int v2; // eax
  char v3; // dl
  __int16 v4; // dx

  v1 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v1;
  if ( v1 < 0 )
  {
    sub_57F10(a1);
  }
  else if ( !v1 )
  {
    v2 = sub_4A190(a1 + 76, 5, *(char *)(a1 + 70));
    if ( v2 )
    {
      v3 = 8 * *(_BYTE *)(v2 + 64);
      *(_BYTE *)(v2 + 73) = 13;
      *(_BYTE *)(v2 + 69) = v3 + 7;
      *(_WORD *)(v2 + 40) = *(_WORD *)(a1 + 40);
      v4 = *(_WORD *)(a1 + 26);
      *(_WORD *)(v2 + 150) = 0;
      *(_DWORD *)(v2 + 144) = 0;
      *(_DWORD *)(v2 + 140) = 0;
      *(_WORD *)(v2 + 46) = 250;
      *(_WORD *)(v2 + 26) = v4;
    }
  }
}

//----- (0003A630) --------------------------------------------------------
int __cdecl sub_3A630(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  v2 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v2;
  if ( v2 <= 0 )
    return sub_57F10(a1);
  return result;
}

//----- (0003A650) --------------------------------------------------------
int __cdecl sub_3A650(int a1)
{
  unsigned int v1; // edi
  char v2; // al
  int k; // eax
  __int16 v4; // ax
  __int16 v5; // ax
  unsigned int v6; // ebx
  __int16 v8; // [esp+0h] [ebp-14h]
  char v9; // [esp+4h] [ebp-10h]
  char v10; // [esp+8h] [ebp-Ch]
  unsigned __int8 j; // [esp+Ch] [ebp-8h]
  unsigned __int8 i; // [esp+10h] [ebp-4h]

  if ( *(_WORD *)(a1 + 150) )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v1 > dword_EA3E4[0] )
    {
      v2 = *(_BYTE *)(a1 + 70);
      v10 = ((unsigned __int16)(*(_WORD *)(v1 + 76) + 128) >> 8) - v2;
      v8 = 2 * v2;
      v9 = ((unsigned __int16)(*(_WORD *)(v1 + 78) + 128) >> 8) - v2;
      for ( i = 0; i < v8; ++i )
      {
        for ( j = 0; j < v8; ++j )
        {
          for ( k = word_15B4E0[256 * (unsigned __int8)(v9 + i) + (unsigned __int8)(j + v10)];
                ;
                k = *(unsigned __int16 *)(v6 + 22) )
          {
            v6 = dword_EA3E4[k];
            if ( v6 <= dword_EA3E4[0] )
              break;
            if ( *(_BYTE *)(v6 + 63) == *(_BYTE *)(v1 + 63)
              && *(_BYTE *)(v6 + 64) == *(_BYTE *)(v1 + 64)
              && sub_3A7F0((_BYTE *)v6) )
            {
              sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 6);
              *(_BYTE *)(v6 + 73) = 14;
              v4 = *(unsigned __int8 *)(v6 + 72);
              *(_BYTE *)(v6 + 72) = 0;
              *(_WORD *)(v6 + 74) = v4;
              *(_WORD *)(v6 + 40) = *(_WORD *)(a1 + 26);
              v5 = *(_WORD *)(a1 + 42);
              *(_WORD *)(v6 + 46) = v5;
              *(_WORD *)(v6 + 48) = v5;
              if ( (*(_BYTE *)(v6 + 69) & 7) == 2 )
                *(_WORD *)(v6 + 150) = 0;
              else
                *(_BYTE *)(v6 + 69) = 8 * *(_BYTE *)(v6 + 64) + 7;
            }
          }
        }
      }
    }
  }
  return sub_57F10(a1);
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (0003A7F0) --------------------------------------------------------
char __cdecl sub_3A7F0(_BYTE *a1)
{
  char result; // al
  unsigned __int8 v2; // ah
  char v3; // bh

  result = 1;
  if ( a1[63] != 5 )
    return 0;
  v2 = a1[64];
  if ( v2 < 0x16u )
  {
    if ( v2 >= 0xCu && v2 <= 0xFu )
      goto LABEL_12;
  }
  else
  {
    if ( v2 <= 0x17u )
      goto LABEL_12;
    if ( v2 >= 0x19u )
    {
      if ( v2 > 0x19u )
      {
        if ( v2 > 0x1Bu )
          goto LABEL_13;
        goto LABEL_12;
      }
      if ( a1[70] )
LABEL_12:
        result = 0;
    }
  }
LABEL_13:
  if ( result )
  {
    v3 = a1[73];
    if ( v3 == 14 || v3 == 13 || v3 == 16 || v3 == 17 )
      result = 0;
  }
  if ( result && a1[69] == 0xE8 )
    return 0;
  return result;
}

//----- (0003A8B0) --------------------------------------------------------
char __cdecl sub_3A8B0(int a1)
{
  __int16 v1; // cx
  int v2; // eax
  char v3; // dh
  __int16 v4; // ax
  char v5; // cl
  int v6; // esi
  char v7; // ah
  int v8; // eax
  __int16 v9; // di
  unsigned int v10; // eax
  __int64 v11; // rax
  __int16 v12; // dx
  int v13; // esi
  int v14; // eax
  int v15; // edx
  unsigned __int16 v16; // ax
  unsigned int v17; // et2
  int v18; // esi
  unsigned int i; // esi
  unsigned __int16 v20; // di
  int v21; // edi
  _WORD *v22; // eax
  _WORD *v23; // esi
  __int16 v24; // ax
  char v25; // ah
  __int16 v26; // ax
  char v27; // al
  char v28; // dl
  int v29; // esi
  char v30; // cl
  int v31; // edx
  void (__noreturn *v33)(); // [esp+0h] [ebp-24h]
  __int16 *v34; // [esp+4h] [ebp-20h]
  unsigned int v35; // [esp+8h] [ebp-1Ch]
  _WORD *v36; // [esp+Ch] [ebp-18h]
  int v37; // [esp+10h] [ebp-14h]
  _BOOL1 v38; // [esp+14h] [ebp-10h]
  unsigned __int8 v39; // [esp+1Ch] [ebp-8h]
  char v40; // [esp+20h] [ebp-4h]

  v2 = dword_EA3E4[*(unsigned __int16 *)(a1 + 50)];
  v35 = 0;
  v33 = sub_10000;
  v37 = v2;
  if ( *(int *)(v2 + 8) >= 0 && (*(_BYTE *)(v2 + 13) & 4) == 0 )
  {
    v3 = *(_BYTE *)(a1 + 68);
    if ( v3 )
    {
      switch ( abs8(v3) )
      {
        case 1u:
          v1 = 0;
          break;
        case 2u:
          v1 = 153;
          break;
        case 3u:
          v1 = 307;
          break;
        case 4u:
          v1 = 445;
          break;
        case 5u:
          v1 = 491;
          break;
        case 6u:
          v1 = 512;
          break;
        default:
          break;
      }
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 154);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 158);
      word_EB39C = *(_WORD *)(a1 + 80);
      v4 = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, v1);
      sub_57CF0(v4, a1, (int)&word_EB398);
      v5 = *(_BYTE *)(a1 + 68) + 1;
      *(_BYTE *)(a1 + 68) = v5;
      if ( v5 >= 7 )
        *(_BYTE *)(a1 + 68) = -5;
    }
    v6 = (__int16)sub_10C40((__int16 *)(a1 + 76));
    v7 = *(_BYTE *)(a1 + 70);
    if ( v7 != 9 && v7 != 7 )
    {
      v8 = *(_DWORD *)(a1 + 8) - 1;
      *(_DWORD *)(a1 + 8) = v8;
      if ( v8 <= 0 )
        *(_BYTE *)(a1 + 70) = 6;
      if ( *(_WORD *)(dword_D41A0 + 12) == *(_WORD *)(*(_DWORD *)(v37 + 164) + 56) )
      {
        v9 = *(_WORD *)(a1 + 54);
        *(_BYTE *)(a1 + 12) &= ~1u;
        if ( v9 != -1 )
          *(_BYTE *)(a1 + 14) |= 0x80u;
      }
      else if ( (*(_BYTE *)(a1 + 62) & 7) == 0 )
      {
        v10 = dword_EA3E4[*(__int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 13071)];
        if ( v10 > dword_EA3E4[0] && *(_WORD *)(v10 + 46) && *(char *)(v10 + 70) >= 2 )
          *(_BYTE *)(a1 + 12) &= ~1u;
        else
          *(_BYTE *)(a1 + 12) |= 1u;
      }
      if ( *(__int16 *)(a1 + 80) < v6 )
        *(_WORD *)(a1 + 80) = v6;
      if ( !*(_BYTE *)(a1 + 68) )
      {
        v11 = *(__int16 *)(a1 + 80) - (v6 + 1024);
        if ( (int)((HIDWORD(v11) ^ v11) - HIDWORD(v11)) > 96 )
        {
          if ( *(__int16 *)(a1 + 80) - (v6 + 1024) <= 0 )
            v12 = 48;
          else
            v12 = -48;
          *(_WORD *)(a1 + 80) += v12;
        }
      }
      if ( byte_D41B6 )
      {
        v13 = *(__int16 *)(a1 + 88);
        v6 = (__int16)sub_10C60((__int16 *)(a1 + 76)) - v13;
        if ( *(__int16 *)(a1 + 80) > v6 )
          *(_WORD *)(a1 + 80) = v6;
      }
    }
    LOBYTE(v14) = *(_BYTE *)(a1 + 70);
    switch ( (char)v14 )
    {
      case 0:
        v14 = (int)&unk_DAF4A + 26 * *(unsigned __int16 *)(a1 + 42);
        v15 = *(_DWORD *)v14;
        *(_DWORD *)(a1 + 4) = *(_DWORD *)v14;
        *(_DWORD *)(a1 + 8) = v15;
        *(_DWORD *)(a1 + 154) = *(_DWORD *)(a1 + 76);
        *(_WORD *)(a1 + 158) = *(_WORD *)(a1 + 80);
        LOBYTE(v14) = *(_BYTE *)(v14 + 24);
        switch ( (char)v14 )
        {
          case 0:
            *(_BYTE *)(a1 + 67) = 1;
            break;
          case 1:
            *(_BYTE *)(a1 + 67) = 2;
            break;
          case 2:
            *(_BYTE *)(a1 + 67) = 4;
            break;
          case 3:
            *(_BYTE *)(a1 + 67) = 8;
            break;
          default:
            break;
        }
        *(_BYTE *)(a1 + 70) = 1;
        goto LABEL_44;
      case 1:
LABEL_44:
        if ( *(_WORD *)(a1 + 54) != 0xFFFF )
          goto LABEL_45;
        return v14;
      case 2:
        *(_BYTE *)(a1 + 12) &= ~8u;
        *(_WORD *)(a1 + 26) = *(_WORD *)(a1 + 50);
        if ( (byte_DA818[80 * *(unsigned __int16 *)(a1 + 54) + 27 + 26 * *(unsigned __int16 *)(a1 + 52)] & 1) != 0 )
          *(_BYTE *)(a1 + 61) = 6;
        else
          *(_BYTE *)(a1 + 61) = 1;
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v16 = *(_WORD *)(a1 + 20);
        v17 = v16 % 0x32u;
        LOWORD(v14) = v16 / 0x32u;
        *(_BYTE *)(a1 + 70) = 3;
        *(_DWORD *)(a1 + 16) = v17 + 16;
        return v14;
      case 3:
        v18 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v18;
        if ( !v18 )
          *(_BYTE *)(a1 + 70) = 4;
        return v14;
      case 4:
        if ( (*(_BYTE *)(a1 + 62) & 0xF) == 0 )
        {
          for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
          {
            LOBYTE(v14) = *(_BYTE *)(i + 64);
            if ( (unsigned __int8)v14 <= 1u && i != v37 )
            {
              v14 = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
              if ( v14 < 3584 && v14 < (int)v33 )
              {
                v35 = i;
                v33 = (void (__noreturn *)())v14;
              }
            }
          }
          if ( v35 )
          {
            v14 = (int)(v35 - (dword_D41A0 + 28302)) / 168;
            *(_BYTE *)(a1 + 70) = 5;
            *(_WORD *)(a1 + 150) = v14;
          }
        }
        return v14;
      case 5:
        *(_DWORD *)(a1 + 12) &= 0xFF7FFFFE;
        LOBYTE(v14) = 0;
        v20 = *(_WORD *)(a1 + 150);
        v40 = 0;
        if ( !v20
          || (LOBYTE(v14) = *(_WORD *)(a1 + 150), v21 = dword_EA3E4[v20], *(int *)(v21 + 8) < 0)
          || (*(_BYTE *)(v21 + 13) & 4) != 0 )
        {
          v40 = 1;
        }
        else
        {
          sub_6D8B0(*(_WORD *)(v37 + 26), 0x17u, 1);
          v34 = (__int16 *)&byte_DA818[80 * *(unsigned __int16 *)(a1 + 54) + 2 + 26 * *(unsigned __int16 *)(a1 + 52)];
          v38 = *(_WORD *)(a1 + 54) == 7
             && byte_DA818[80 * *(unsigned __int16 *)(a1 + 54) + 26 + 26 * *(unsigned __int16 *)(a1 + 52)] == 2;
          v39 = 0;
          LOBYTE(v14) = 0;
          if ( v38 != -1 )
          {
            do
            {
              v22 = (_WORD *)sub_6DCA0(v37, a1 + 76, *(_WORD *)(a1 + 54), v34, 0, 1);
              v23 = v22;
              v36 = v22;
              if ( v22 )
              {
                v22[13] = *(_WORD *)(a1 + 50);
                v22[75] = *(_WORD *)(a1 + 150);
                sub_655C0(v22, v21);
                v23[14] = v23[16];
                v23[15] = v23[17];
                v24 = v23[14];
                v23[40] += *(_WORD *)(a1 + 82);
                HIBYTE(v24) = (HIBYTE(v24) + 4) & 7;
                *(_WORD *)(a1 + 28) = v24;
                v25 = *(_BYTE *)(a1 + 68);
                if ( v25 )
                {
                  *(_BYTE *)(a1 + 68) = v25 + 1;
                  if ( (char)(v25 + 1) > 5 )
                    *(_BYTE *)(a1 + 68) = 5;
                }
                else
                {
                  *(_BYTE *)(a1 + 68) = 1;
                }
                if ( v38 )
                {
                  if ( v39 )
                    v26 = v36[14] - 113;
                  else
                    v26 = v36[14] + 113;
                  v36[14] = v26 & 0x7FF;
                }
                v27 = *(_BYTE *)(a1 + 61) - 1;
                *(_BYTE *)(a1 + 61) = v27;
                if ( !v27 )
                  v40 = 1;
              }
              LOBYTE(v14) = ++v39;
            }
            while ( v39 < (unsigned __int8)(v38 + 1) );
          }
        }
        if ( !v40 )
          return v14;
        v28 = *(_BYTE *)(a1 + 67);
        *(_WORD *)(a1 + 150) = 0;
        *(_BYTE *)(a1 + 67) = --v28;
        if ( v28 )
LABEL_45:
          *(_BYTE *)(a1 + 70) = 2;
        else
          *(_BYTE *)(a1 + 70) = 6;
        return v14;
      case 6:
        v30 = *(_BYTE *)(a1 + 68);
        *(_DWORD *)(a1 + 12) &= 0xFF7FFFFE;
        if ( !v30 )
        {
          *(_BYTE *)(a1 + 70) = 7;
          *(_DWORD *)(a1 + 16) = 10;
        }
        return v14;
      case 7:
        v14 = *(_DWORD *)(a1 + 16) - 1;
        *(_DWORD *)(a1 + 16) = v14;
        if ( !v14 )
        {
          *(_BYTE *)(a1 + 70) = 9;
          *(_DWORD *)(a1 + 16) = 3;
        }
        return v14;
      case 8:
        *(_BYTE *)(a1 + 70) = 9;
        v29 = *(_DWORD *)(a1 + 12);
        *(_DWORD *)(a1 + 16) = 3;
        *(_DWORD *)(a1 + 12) = v29 & 0xFF7FFFFE;
        return v14;
      case 9:
        v31 = *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 16) = v31 + 1;
        LOWORD(v14) = *(_WORD *)(a1 + 80) - 32 * v31;
        *(_WORD *)(a1 + 80) = v14;
        if ( (__int16)v14 >= v6 )
          return v14;
        *(_WORD *)(a1 + 80) = v6;
        if ( sub_104D0((__int16 *)(a1 + 76)) == 1 )
          sub_4A190(a1 + 76, 10, 5);
        else
          sub_4A190(a1 + 76, 10, 0);
        break;
      default:
        return v14;
    }
  }
  LOBYTE(v14) = sub_57F10(a1);
  return v14;
}
// 3A95E: variable 'v1' is possibly undefined
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0003AF00) --------------------------------------------------------
int __cdecl sub_3AF00(int a1)
{
  int v1; // edx
  __int16 v2; // dx
  int v3; // esi
  int v4; // eax
  unsigned int v5; // et2
  int i; // ecx
  unsigned __int8 v7; // al
  unsigned __int8 v8; // al
  _BOOL1 v9; // zf
  int v10; // eax
  int v11; // edx
  __int16 v12; // di
  signed int v13; // edx
  __int16 v14; // ax
  int v15; // edi
  char v16; // dh
  char v17; // dl
  __int16 v18; // ax
  __int16 v19; // ax
  char v20; // dh
  __int16 v21; // ax
  int result; // eax
  int v23; // ecx
  int v24; // ecx
  __int16 *v25; // esi
  int v26; // edx
  int v27; // [esp+0h] [ebp-30h] BYREF
  int v28; // [esp+4h] [ebp-2Ch] BYREF
  int v29; // [esp+8h] [ebp-28h]
  int v30; // [esp+Ch] [ebp-24h]
  int v31; // [esp+10h] [ebp-20h]
  int v32; // [esp+14h] [ebp-1Ch]
  int v33; // [esp+18h] [ebp-18h]
  char v34; // [esp+1Ch] [ebp-14h]
  unsigned __int8 v35; // [esp+20h] [ebp-10h]
  char v36; // [esp+24h] [ebp-Ch]
  unsigned __int8 v37; // [esp+28h] [ebp-8h]
  char v38; // [esp+2Ch] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 8);
  v36 = 0;
  if ( v1 < 0 )
    return sub_57F10(a1);
  v2 = *(_WORD *)(a1 + 26);
  if ( !v2 )
    return sub_57F10(a1);
  v33 = dword_EA3E4[v2];
  v3 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(v33 + 164) + 58)];
  if ( *(__int16 *)(a1 + 74) <= 1 )
    v32 = 384;
  else
    v32 = 224;
  LOWORD(v4) = *(unsigned __int8 *)(a1 + 70);
  switch ( *(_BYTE *)(a1 + 70) )
  {
    case 0:
      *(_DWORD *)(a1 + 154) = *(_DWORD *)(a1 + 76);
      *(_WORD *)(a1 + 158) = *(_WORD *)(a1 + 80);
      v3 = a1 + 82;
      *(_BYTE *)(a1 + 70) = 1;
      goto LABEL_74;
    case 1:
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v5 = *(unsigned __int16 *)(a1 + 20) % 0x30u;
      *(_BYTE *)(a1 + 70) = 2;
      *(_DWORD *)(a1 + 16) = v5 + 16;
      goto LABEL_9;
    case 2:
LABEL_9:
      v4 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v4;
      if ( !v4 )
        *(_BYTE *)(a1 + 70) = 3;
      goto LABEL_74;
    case 3:
      if ( (*(_BYTE *)(a1 + 62) & 0x3F) != 0 )
        goto LABEL_74;
      v31 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
      v30 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
      v4 = sub_10080(3, 12);
      v3 = v4;
      if ( !v4 )
        goto LABEL_74;
      v34 = 0;
      break;
    case 4:
      *(_BYTE *)(a1 + 70) = 5;
      *(_DWORD *)(a1 + 16) = 4;
      goto LABEL_37;
    case 5:
LABEL_37:
      v11 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v11;
      if ( v11 )
      {
        *(_WORD *)(a1 + 54) += 160;
      }
      else
      {
        *(_BYTE *)(a1 + 70) = 6;
        *(_WORD *)(a1 + 54) = 0;
      }
      goto LABEL_74;
    case 6:
      v12 = *(_WORD *)(a1 + 20);
      *(_WORD *)(a1 + 158) = *(_WORD *)(a1 + 80);
      *(_WORD *)(a1 + 20) = 9377 * v12 + 9439;
      v13 = *(unsigned __int16 *)(a1 + 20) % 0x64u;
      *(_BYTE *)(a1 + 70) = 7;
      if ( v13 )
      {
        if ( v13 <= 5 )
        {
          v14 = (*(_BYTE *)(a1 + 67) == 1) + 2;
        }
        else
        {
          LOBYTE(v14) = *(_BYTE *)(a1 + 67) != 1;
          HIBYTE(v14) = 0;
        }
        *(_WORD *)(a1 + 44) = v14;
      }
      else
      {
        *(_WORD *)(a1 + 44) = 4;
      }
      LOWORD(v4) = *(_WORD *)(a1 + 44);
      *(_BYTE *)(a1 + 61) = 1;
      if ( (unsigned __int16)v4 <= 1u )
        *(_BYTE *)(a1 + 61) = 6;
      goto LABEL_48;
    case 7:
    case 8:
LABEL_48:
      LOBYTE(v4) = 0;
      v38 = 0;
      if ( !*(_WORD *)(a1 + 150) )
        goto LABEL_67;
      LOWORD(v4) = *(_WORD *)(a1 + 150);
      v15 = dword_EA3E4[(unsigned __int16)v4];
      if ( *(int *)(v15 + 8) < 0 || (*(_BYTE *)(v15 + 13) & 4) != 0 )
        goto LABEL_67;
      switch ( *(_WORD *)(a1 + 44) )
      {
        case 0:
          v35 = 0;
          v37 = 1;
          break;
        case 1:
          v35 = 7;
          goto LABEL_57;
        case 2:
          v35 = 7;
          v37 = 1;
          break;
        case 3:
          v35 = 0;
          v37 = 2;
          break;
        case 4:
          v35 = 9;
LABEL_57:
          v37 = 0;
          break;
        default:
          break;
      }
      v4 = sub_6DCA0(v3, a1 + 76, v35, (__int16 *)&byte_DA818[80 * v35 + 2 + 26 * v37], 0, *(_BYTE *)(a1 + 70) == 7);
      v3 = v4;
      if ( v4 )
      {
        *(_WORD *)(v4 + 26) = *(_WORD *)(a1 + 26);
        *(_WORD *)(v4 + 150) = *(_WORD *)(a1 + 150);
        if ( *(_WORD *)(*(_DWORD *)(v33 + 164) + 56) == *(_WORD *)(dword_D41A0 + 12) && !v35 )
          sub_49C90(v4, 42);
        sub_655C0((_WORD *)v3, v15);
        *(_WORD *)(v3 + 28) = *(_WORD *)(v3 + 32);
        *(_WORD *)(v3 + 30) = *(_WORD *)(v3 + 34);
        LOWORD(v4) = *(_WORD *)(v3 + 28);
        *(_WORD *)(v3 + 80) += *(_WORD *)(a1 + 82);
        BYTE1(v4) &= 7u;
        *(_WORD *)(a1 + 28) = v4;
        LOWORD(v4) = *(_WORD *)(v3 + 30);
        BYTE1(v4) &= 7u;
        v16 = *(_BYTE *)(a1 + 68);
        *(_WORD *)(a1 + 30) = v4;
        if ( v16 )
        {
          *(_BYTE *)(a1 + 68) = v16 + 1;
          if ( (char)(v16 + 1) > 5 )
            *(_BYTE *)(a1 + 68) = 5;
        }
        else
        {
          *(_BYTE *)(a1 + 68) = 1;
        }
        LOBYTE(v4) = *(_BYTE *)(a1 + 61) - 1;
        *(_BYTE *)(a1 + 61) = v4;
        if ( !(_BYTE)v4 )
LABEL_67:
          v38 = 1;
      }
      if ( v38 )
      {
        *(_WORD *)(a1 + 150) = 0;
        *(_BYTE *)(a1 + 70) = 1;
      }
      else
      {
        *(_BYTE *)(a1 + 70) = 8;
      }
      goto LABEL_74;
    case 9:
      goto LABEL_73;
    case 0xA:
      v4 = sub_4A190(a1 + 76, 10, 1);
      if ( v4 )
        *(_WORD *)(v4 + 26) = *(_WORD *)(a1 + 26);
LABEL_73:
      v36 = 1;
      goto LABEL_74;
    default:
      goto LABEL_74;
  }
LABEL_33:
  if ( sub_10130(v3, &v28, &v27) == 1 && !v34 )
  {
    for ( i = dword_EA3E4[word_15B4E0[256 * (unsigned __int8)(v27 + v30) + (unsigned __int8)(v28 + v31)]];
          ;
          i = dword_EA3E4[*(unsigned __int16 *)(i + 22)] )
    {
      if ( i == dword_EA3E4[0] || v34 )
        goto LABEL_33;
      v7 = *(_BYTE *)(i + 63);
      if ( v7 >= 3u )
      {
        if ( v7 <= 3u )
        {
          v8 = *(_BYTE *)(i + 64);
          if ( v8 <= 1u || v8 == 3 )
          {
            v9 = *(_WORD *)(i + 26) == *(_WORD *)(a1 + 26);
LABEL_26:
            if ( v9 )
              goto LABEL_28;
LABEL_27:
            v34 = 1;
          }
        }
        else if ( v7 == 5 && *(_BYTE *)(i + 64) != 22 && *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) )
        {
          if ( *(_BYTE *)(i + 73) == 14 )
          {
            v9 = *(unsigned __int16 *)(i + 40) == *(__int16 *)(a1 + 26);
            goto LABEL_26;
          }
          goto LABEL_27;
        }
      }
LABEL_28:
      if ( v34 )
      {
        v10 = (i - (dword_D41A0 + 28302)) / 168;
        *(_BYTE *)(a1 + 70) = 4;
        *(_WORD *)(a1 + 150) = v10;
      }
    }
  }
  LOWORD(v4) = sub_10100(v3);
LABEL_74:
  if ( v36 )
    return sub_57F20(v4, a1);
  v17 = *(_BYTE *)(a1 + 68);
  if ( v17 )
  {
    switch ( abs8(v17) )
    {
      case 1u:
        v29 = 0;
        break;
      case 2u:
        v29 = 115;
        break;
      case 3u:
        v29 = 230;
        break;
      case 4u:
        v29 = 334;
        break;
      case 5u:
        v29 = 368;
        break;
      case 6u:
        v29 = 384;
        break;
      default:
        break;
    }
    v18 = -(__int16)v29;
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 154);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 158);
    v3 = a1 + 160;
    v19 = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), v18);
    sub_57CF0(v19, a1, (int)&word_EB398);
    v20 = *(_BYTE *)(a1 + 68) + 1;
    *(_BYTE *)(a1 + 68) = v20;
    if ( v20 >= 7 )
      *(_BYTE *)(a1 + 68) = -5;
  }
  v21 = sub_10C40((__int16 *)(a1 + 76));
  result = v32 + v21;
  v23 = *(__int16 *)(a1 + 80);
  if ( v23 < result )
  {
LABEL_97:
    *(_WORD *)(a1 + 80) = result;
    return result;
  }
  LOWORD(v3) = *(_WORD *)(a1 + 54);
  if ( (_WORD)v3 )
  {
    result += v3;
    goto LABEL_97;
  }
  if ( !*(_BYTE *)(a1 + 68) )
  {
    v24 = v23 - result;
    result = abs32(v24);
    if ( result > 32 )
    {
      v25 = (__int16 *)(a1 + 80);
      if ( v24 <= 0 )
        v26 = 16;
      else
        v26 = -16;
      result = v26 + *v25;
      *v25 = result;
    }
    if ( (*(_BYTE *)(a1 + 62) & 8) != 0 )
      *(_WORD *)(a1 + 80) += 6;
    else
      *(_WORD *)(a1 + 80) -= 6;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (0003B4D0) --------------------------------------------------------
int *__cdecl sub_3B4D0(int a1)
{
  int *result; // eax
  char v2; // bl
  int v3; // edx

  result = (int *)&unk_D4350;
  v2 = 32;
  v3 = (a1 << 16) - 1;
  do
  {
    if ( *result )
      *result = v3;
    if ( result[1] )
      result[1] = v3;
    if ( result[2] )
      result[2] = v3;
    if ( result[3] )
      result[3] = v3;
    if ( result[4] )
      result[4] = v3;
    if ( result[5] )
      result[5] = v3;
    if ( result[6] )
      result[6] = v3;
    if ( result[7] )
      result[7] = v3;
    result += 8;
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (0003B560) --------------------------------------------------------
_DWORD *__cdecl sub_3B560(__int16 a1)
{
  int v1; // edx
  _DWORD *v2; // edi
  int *v3; // esi
  int v4; // eax
  __int16 v5; // bx
  int v6; // ecx
  int v7; // edx
  _BOOL1 v8; // cf
  int v9; // eax
  int v10; // esi
  void (__noreturn *v11)(); // eax
  _DWORD *v12; // edi
  int *v13; // esi
  int v14; // eax
  int v15; // ecx
  int v16; // edx
  _DWORD *v17; // edi
  int *v18; // esi
  int v19; // eax
  __int16 v20; // bx
  int v21; // ecx
  int v22; // edx
  _DWORD *v23; // edi
  int *v24; // esi
  int v25; // eax
  __int16 v26; // bx
  int v27; // ecx
  int v28; // edx
  _DWORD *result; // eax
  int v30; // eax
  int *v31; // esi
  _DWORD *v32; // edi
  int v33; // eax
  int v34; // ecx
  int v35; // edx
  _DWORD *v36; // edi
  int *v37; // esi
  int v38; // eax
  __int16 v39; // bx
  int v40; // ecx
  int v41; // edx
  int v42; // edx
  _DWORD *v43; // edi
  int *v44; // esi
  int v45; // eax
  __int16 v46; // bx
  int v47; // ecx
  int v48; // edx
  int v49; // esi
  int v50; // esi
  int *v51; // esi
  _DWORD *v52; // edi
  int v53; // eax
  int v54; // ecx
  int v55; // edx
  _DWORD *v56; // edi
  int *v57; // esi
  int v58; // eax
  __int16 v59; // bx
  int v60; // ecx
  int v61; // edx
  _DWORD *v62; // edi
  int *v63; // esi
  int v64; // eax
  __int16 v65; // bx
  int v66; // ecx
  int v67; // edx
  int v68; // esi
  int v69; // eax
  _DWORD *v70; // edi
  int *v71; // esi
  int v72; // eax
  int v73; // ecx
  int v74; // edx
  _DWORD *v75; // edi
  int *v76; // esi
  int v77; // eax
  __int16 v78; // bx
  int v79; // ecx
  int v80; // edx
  int v81; // edx
  int v82; // ecx
  int v83; // [esp+0h] [ebp-10h]
  int v84; // [esp+0h] [ebp-10h]
  int v85; // [esp+0h] [ebp-10h]
  int v86; // [esp+0h] [ebp-10h]
  int v87; // [esp+4h] [ebp-Ch]
  int v88; // [esp+4h] [ebp-Ch]
  int v89; // [esp+4h] [ebp-Ch]
  int v90; // [esp+4h] [ebp-Ch]
  int v91; // [esp+8h] [ebp-8h]
  int v92; // [esp+8h] [ebp-8h]
  int v93; // [esp+8h] [ebp-8h]
  int v94; // [esp+8h] [ebp-8h]
  int v95; // [esp+8h] [ebp-8h]
  int v96; // [esp+8h] [ebp-8h]
  int v97; // [esp+8h] [ebp-8h]
  int v98; // [esp+8h] [ebp-8h]
  int v99; // [esp+8h] [ebp-8h]
  __int16 v100; // [esp+Ch] [ebp-4h]
  __int16 v101; // [esp+Ch] [ebp-4h]
  __int16 v102; // [esp+Ch] [ebp-4h]
  __int16 v103; // [esp+Ch] [ebp-4h]
  __int16 v104; // [esp+Ch] [ebp-4h]
  __int16 v105; // [esp+Ch] [ebp-4h]
  __int16 v106; // [esp+Ch] [ebp-4h]
  __int16 v107; // [esp+Ch] [ebp-4h]

  v1 = a1 & 0x7FF;
  dword_F2C98 = v1 >> 8;
  switch ( v1 >> 8 )
  {
    case 0:
      dword_F2CBC = dword_DB750[v1];
      dword_F2C8C = (int)off_DBF50[v1];
      v87 = dword_DE560;
      v91 = (unsigned __int16)dword_DE564;
      dword_F2C9C = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v100 = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v2 = &unk_F0E20;
      v3 = (int *)(dword_E9C38 + 59360);
      v4 = 0;
      v5 = 0;
      v6 = 1;
      v7 = 0;
      do
      {
        v2[1] = v4;
        v2[2] = v7;
        v8 = __CFADD__(v100, v5);
        v5 += v100;
        if ( v8 )
        {
          v4 += v87;
          ++v7;
          *v3++ = v6;
        }
        v2 += 3;
        ++v4;
        ++v6;
        --v91;
      }
      while ( v91 );
      dword_F2C94 = v7;
      dword_F2CA4 = -v7;
      dword_F2CB4 = (unsigned __int16)dword_DE568;
      dword_F2CB8 = (unsigned __int16)dword_DE564;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      dword_F2C88 = 4 * (v7 - 1) + dword_E9C38 + 59360;
      v9 = dword_DE560;
      dword_F2C84 = (unsigned __int16)dword_DE568 - v7;
      goto LABEL_66;
    case 1:
      v10 = dword_DB750[v1];
      v11 = off_DBF50[v1];
      dword_F2CBC = v10;
      dword_F2C8C = (int)v11;
      v83 = dword_DE560;
      v92 = (unsigned __int16)dword_DE568;
      if ( v1 == 256 )
      {
        dword_F2C9C = (int)sub_10000;
        v12 = &unk_F0E20;
        v13 = (int *)(dword_E9C38 + 59360);
        v14 = 0;
        v15 = 1;
        v16 = 0;
        do
        {
          v12[1] = v14;
          v12[2] = v16++;
          *v13++ = v15;
          v12 += 3;
          v14 += v83 + 1;
          ++v15;
          --v92;
        }
        while ( v92 );
        dword_F2C94 = (unsigned __int16)dword_DE568;
        dword_F2CA4 = -(unsigned __int16)dword_DE568;
      }
      else
      {
        dword_F2C9C = (dword_F2C8C << 8) / (v10 >> 8);
        v101 = (dword_F2C8C << 8) / (v10 >> 8);
        v17 = &unk_F0E20;
        v18 = (int *)(dword_E9C38 + 59360);
        v19 = 0;
        v20 = 0;
        v21 = 1;
        v22 = 0;
        do
        {
          v17[1] = v19;
          v17[2] = v22;
          v8 = __CFADD__(v101, v20);
          v20 += v101;
          if ( v8 )
          {
            ++v19;
            ++v22;
            *v18++ = v21;
          }
          v17 += 3;
          v19 += v83;
          ++v21;
          --v92;
        }
        while ( v92 );
        dword_F2C94 = v22;
        dword_F2CA4 = -v22;
      }
      dword_F2CB4 = (unsigned __int16)dword_DE564;
      dword_F2CB8 = (unsigned __int16)dword_DE568;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      dword_F2C88 = 4 * (-1 - dword_F2CA4) + dword_E9C38 + 59360;
      v9 = -1;
      dword_F2C84 = (unsigned __int16)dword_DE564 + dword_F2CA4;
      goto LABEL_66;
    case 2:
      dword_F2CBC = dword_DAF50[v1];
      dword_F2C8C = dword_DB750[v1];
      v84 = dword_DE560;
      v93 = (unsigned __int16)dword_DE568;
      dword_F2C9C = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v102 = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v23 = &unk_F0E20;
      v24 = (int *)(dword_E9C38 + 59360);
      v25 = 0;
      v26 = 0;
      v27 = 1;
      v28 = 0;
      do
      {
        v23[1] = v25;
        v23[2] = v28;
        v8 = __CFADD__(v102, v26);
        v26 += v102;
        if ( v8 )
        {
          --v25;
          ++v28;
          *v24++ = v27;
        }
        v23 += 3;
        v25 += v84;
        ++v27;
        --v93;
      }
      while ( v93 );
      dword_F2C94 = v28;
      dword_F2CA4 = -v28;
      dword_F2CB4 = (unsigned __int16)dword_DE564;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      dword_F2CB8 = (unsigned __int16)dword_DE568;
      dword_F2CAC = -1;
      dword_F2C84 = (unsigned __int16)dword_DE564 - v28;
      dword_F2C88 = 4 * (v28 - 1) + dword_E9C38 + 59360;
      v94 = (unsigned __int16)dword_DE568 - 1;
      result = &unk_F0E20;
      if ( v94 < 0 )
        return result;
      goto LABEL_68;
    case 3:
      v30 = dword_DB750[v1];
      dword_F2CBC = dword_DAF50[v1];
      dword_F2C8C = v30;
      v88 = dword_DE560;
      v95 = (unsigned __int16)dword_DE564;
      if ( v1 == 768 )
      {
        dword_F2C9C = (int)sub_10000;
        v31 = (int *)(dword_E9C38 + 59360);
        v32 = &unk_F0E20;
        v33 = 0;
        v34 = 1;
        v35 = 0;
        do
        {
          v32[1] = v33;
          v32[2] = v35++;
          *v31++ = v34;
          v32 += 3;
          v33 = v88 + v33 - 1;
          ++v34;
          --v95;
        }
        while ( v95 );
        dword_F2C94 = (unsigned __int16)dword_DE564;
        dword_F2CA4 = -(unsigned __int16)dword_DE564;
      }
      else
      {
        dword_F2C9C = (dword_F2C8C << 8) / (dword_F2CBC >> 8);
        v103 = (dword_F2C8C << 8) / (dword_F2CBC >> 8);
        v36 = &unk_F0E20;
        v37 = (int *)(dword_E9C38 + 59360);
        v38 = 0;
        v39 = 0;
        v40 = 1;
        v41 = 0;
        do
        {
          v36[1] = v38;
          v36[2] = v41;
          v8 = __CFADD__(v103, v39);
          v39 += v103;
          if ( v8 )
          {
            v38 += v88;
            ++v41;
            *v37++ = v40;
          }
          v36 += 3;
          --v38;
          ++v40;
          --v95;
        }
        while ( v95 );
        dword_F2C94 = v41;
        dword_F2CA4 = -v41;
      }
      dword_F2CB4 = (unsigned __int16)dword_DE568;
      dword_F2CB8 = (unsigned __int16)dword_DE564;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      v42 = 4 * (-1 - dword_F2CA4) + dword_E9C38 + 59360;
      dword_F2C84 = (unsigned __int16)dword_DE568 + dword_F2CA4;
      v9 = -dword_DE560;
      goto LABEL_65;
    case 4:
      dword_F2CBC = dword_DA750[v1];
      dword_F2C8C = dword_DAF50[v1];
      v89 = -dword_DE560;
      v96 = (unsigned __int16)dword_DE564;
      dword_F2C9C = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v104 = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v43 = &unk_F0E20;
      v44 = (int *)(dword_E9C38 + 59360);
      v45 = 0;
      v46 = 0;
      v47 = 1;
      v48 = 0;
      do
      {
        v43[1] = v45;
        v43[2] = v48;
        v8 = __CFADD__(v104, v46);
        v46 += v104;
        if ( v8 )
        {
          v45 += v89;
          ++v48;
          *v44++ = v47;
        }
        v43 += 3;
        --v45;
        ++v47;
        --v96;
      }
      while ( v96 );
      dword_F2C94 = v48;
      dword_F2CA4 = -v48;
      v49 = (unsigned __int16)dword_DE568 - v48;
      dword_F2CB4 = (unsigned __int16)dword_DE568;
      dword_F2CB8 = (unsigned __int16)dword_DE564;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      v42 = 4 * (v48 - 1) + dword_E9C38 + 59360;
      dword_F2C84 = v49;
      v9 = -dword_DE560;
      goto LABEL_65;
    case 5:
      v50 = dword_DA750[v1];
      dword_F2C8C = dword_DAF50[v1];
      dword_F2CBC = v50;
      v85 = -dword_DE560;
      v97 = (unsigned __int16)dword_DE568;
      if ( v1 == 1280 )
      {
        dword_F2C9C = (int)sub_10000;
        v51 = (int *)(dword_E9C38 + 59360);
        v52 = &unk_F0E20;
        v53 = 0;
        v54 = 1;
        v55 = 0;
        do
        {
          v52[1] = v53;
          v52[2] = v55++;
          *v51++ = v54;
          v52 += 3;
          v53 = v85 + v53 - 1;
          ++v54;
          --v97;
        }
        while ( v97 );
        dword_F2C94 = (unsigned __int16)dword_DE568;
        dword_F2CA4 = -(unsigned __int16)dword_DE568;
      }
      else
      {
        dword_F2C9C = (dword_F2C8C << 8) / (dword_F2CBC >> 8);
        v105 = (dword_F2C8C << 8) / (dword_F2CBC >> 8);
        v56 = &unk_F0E20;
        v57 = (int *)(dword_E9C38 + 59360);
        v58 = 0;
        v59 = 0;
        v60 = 1;
        v61 = 0;
        do
        {
          v56[1] = v58;
          v56[2] = v61;
          v8 = __CFADD__(v105, v59);
          v59 += v105;
          if ( v8 )
          {
            --v58;
            ++v61;
            *v57++ = v60;
          }
          v56 += 3;
          v58 += v85;
          ++v60;
          --v97;
        }
        while ( v97 );
        dword_F2C94 = v61;
        dword_F2CA4 = -v61;
      }
      dword_F2CB4 = (unsigned __int16)dword_DE564;
      dword_F2CB8 = (unsigned __int16)dword_DE568;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      dword_F2CAC = 1;
      dword_F2C84 = (unsigned __int16)dword_DE564 + dword_F2CA4;
      dword_F2C88 = 4 * (-1 - dword_F2CA4) + dword_E9C38 + 59360;
      v94 = (unsigned __int16)dword_DE568 - 1;
      result = &unk_F0E20;
      if ( v94 < 0 )
        return result;
      goto LABEL_68;
    case 6:
      dword_F2CBC = dword_D9F50[v1];
      dword_F2C8C = dword_DA750[v1];
      v86 = -dword_DE560;
      v98 = (unsigned __int16)dword_DE568;
      dword_F2C9C = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v106 = (dword_F2CBC << 8) / (dword_F2C8C >> 8);
      v62 = &unk_F0E20;
      v63 = (int *)(dword_E9C38 + 59360);
      v64 = 0;
      v65 = 0;
      v66 = 1;
      v67 = 0;
      do
      {
        v62[1] = v64;
        v62[2] = v67;
        v8 = __CFADD__(v106, v65);
        v65 += v106;
        if ( v8 )
        {
          ++v64;
          ++v67;
          *v63++ = v66;
        }
        v62 += 3;
        v64 += v86;
        ++v66;
        --v98;
      }
      while ( v98 );
      dword_F2C94 = v67;
      dword_F2CA4 = -v67;
      dword_F2C84 = (unsigned __int16)dword_DE564 - v67;
      dword_F2CB4 = (unsigned __int16)dword_DE564;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      dword_F2CB8 = (unsigned __int16)dword_DE568;
      dword_F2CAC = 1;
      dword_F2C88 = 4 * (v67 - 1) + dword_E9C38 + 59360;
      v94 = (unsigned __int16)dword_DE568 - 1;
      result = &unk_F0E20;
      if ( v94 < 0 )
        return result;
      goto LABEL_68;
    case 7:
      v68 = dword_D9F50[v1];
      v69 = dword_DA750[v1];
      dword_F2CBC = v68;
      dword_F2C8C = v69;
      v90 = -dword_DE560;
      v99 = (unsigned __int16)dword_DE564;
      if ( v1 == 1792 )
      {
        v70 = &unk_F0E20;
        v71 = (int *)(dword_E9C38 + 59360);
        dword_F2C9C = (int)sub_10000;
        v72 = 0;
        v73 = 1;
        v74 = 0;
        do
        {
          v70[1] = v72;
          v70[2] = v74++;
          *v71++ = v73;
          v70 += 3;
          v72 += v90 + 1;
          ++v73;
          --v99;
        }
        while ( v99 );
        dword_F2C94 = (unsigned __int16)dword_DE564;
        dword_F2CA4 = -(unsigned __int16)dword_DE564;
      }
      else
      {
        dword_F2C9C = (dword_F2C8C << 8) / (v68 >> 8);
        v107 = (dword_F2C8C << 8) / (v68 >> 8);
        v75 = &unk_F0E20;
        v76 = (int *)(dword_E9C38 + 59360);
        v77 = 0;
        v78 = 0;
        v79 = 1;
        v80 = 0;
        do
        {
          v75[1] = v77;
          v75[2] = v80;
          v8 = __CFADD__(v107, v78);
          v78 += v107;
          if ( v8 )
          {
            v77 += v90;
            ++v80;
            *v76++ = v79;
          }
          v75 += 3;
          ++v77;
          ++v79;
          --v99;
        }
        while ( v99 );
        dword_F2C94 = v80;
        dword_F2CA4 = -v80;
      }
      dword_F2CB4 = (unsigned __int16)dword_DE568;
      dword_F2CB8 = (unsigned __int16)dword_DE564;
      dword_F2C90 = (unsigned __int16)dword_DE568 + (unsigned __int16)dword_DE564;
      dword_F2C84 = (unsigned __int16)dword_DE568 + dword_F2CA4;
      v42 = 4 * (-1 - dword_F2CA4) + dword_E9C38 + 59360;
      v9 = dword_DE560;
LABEL_65:
      dword_F2C88 = v42;
LABEL_66:
      dword_F2CAC = v9;
      break;
    default:
      break;
  }
  v94 = dword_F2CB8 - 1;
  for ( result = &unk_F0E20; v94 >= 0; --v94 )
  {
LABEL_68:
    v81 = result[1];
    v82 = *(result - 2);
    result += 3;
    *(result - 3) = v81 - v82;
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// D9F50: using guessed type int dword_D9F50[];
// DA750: using guessed type int dword_DA750[];
// DAF50: using guessed type int dword_DAF50[58];
// DB750: using guessed type int dword_DB750[256];
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;
// E9C38: using guessed type int dword_E9C38;
// F2C84: using guessed type int dword_F2C84;
// F2C88: using guessed type int dword_F2C88;
// F2C8C: using guessed type int dword_F2C8C;
// F2C90: using guessed type int dword_F2C90;
// F2C94: using guessed type int dword_F2C94;
// F2C98: using guessed type int dword_F2C98;
// F2C9C: using guessed type int dword_F2C9C;
// F2CA4: using guessed type int dword_F2CA4;
// F2CAC: using guessed type int dword_F2CAC;
// F2CB4: using guessed type int dword_F2CB4;
// F2CB8: using guessed type int dword_F2CB8;
// F2CBC: using guessed type int dword_F2CBC;

//----- (0003C080) --------------------------------------------------------
char __usercall sub_3C080@<al>(
        int a1@<ebx>,
        int a2@<esi>,
        __int16 a3,
        __int16 a4,
        __int16 a5,
        int a6,
        int a7,
        __int16 a8,
        int a9)
{
  int v9; // eax
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // edi
  char v14; // dh
  int v15; // eax
  char v16; // dl
  char v17; // dl
  _DWORD *v18; // eax
  char v19; // dh
  int v20; // ebx
  int v21; // ecx
  char v22; // ch
  int v23; // eax
  int v24; // edx
  unsigned int v25; // edi
  int v26; // ebx
  int v27; // eax
  __int16 v28; // si
  int v29; // edx
  __int16 v30; // cx
  int v31; // eax
  int v32; // ecx
  int v33; // esi
  int v34; // ebx
  unsigned __int16 v35; // dx
  int v36; // eax
  __int16 v37; // ax
  int v38; // eax
  int v39; // edi
  int v40; // edx
  unsigned __int16 v41; // bx
  int v42; // edx
  _BYTE *v43; // eax
  char v44; // bh
  int v45; // edx
  int v46; // eax
  int v47; // esi
  int v48; // ecx
  int v49; // ecx
  int v50; // ebx
  int v51; // ecx
  int v52; // ebx
  int v53; // esi
  int v54; // esi
  int v55; // eax
  int v56; // esi
  char v57; // ah
  int j; // ebx
  char v59; // dl
  char v60; // dh
  char v61; // ch
  char v62; // ah
  char v63; // dl
  char v64; // dh
  char v65; // ch
  char v66; // dl
  int v67; // ebx
  int *v68; // edx
  char v69; // dl
  char v70; // dh
  char v71; // ch
  char v72; // ah
  char v73; // dl
  char v74; // dh
  char v75; // ch
  char v76; // dl
  char v77; // dh
  int v78; // ebx
  int *v79; // edx
  unsigned int v80; // edi
  unsigned int v81; // ebx
  char v82; // dl
  char v83; // cl
  char v84; // dh
  char v85; // al
  char v86; // dl
  char v87; // dh
  int v88; // eax
  unsigned int v89; // ebx
  char v90; // cl
  char v91; // dl
  int v92; // ebx
  int *v93; // edx
  char v94; // al
  char v95; // dl
  char v96; // dh
  char v97; // ah
  char v98; // dl
  char v99; // dh
  char v100; // ch
  int v101; // eax
  int v102; // ebx
  char v103; // dl
  char v104; // dh
  int v105; // ebx
  int *v106; // edx
  int v107; // esi
  int v108; // ebx
  unsigned __int16 v109; // dx
  __int16 v110; // ax
  int v111; // eax
  unsigned int v112; // ecx
  int v113; // edx
  int v114; // eax
  int v115; // edx
  unsigned __int16 v116; // bx
  unsigned __int8 v117; // al
  int v118; // edx
  _BYTE *v119; // eax
  char v120; // bh
  int v121; // ebx
  int v122; // eax
  int v123; // esi
  int v124; // ecx
  int v125; // ecx
  int v126; // edx
  int v127; // ecx
  int v128; // edx
  int v129; // esi
  int v130; // esi
  int v131; // esi
  int v132; // ebx
  int v133; // eax
  char v134; // dl
  char v135; // ch
  char v136; // dl
  int v137; // eax
  int v138; // ebx
  int v139; // eax
  char v140; // ch
  int v141; // ebx
  char v142; // dl
  int *v143; // edx
  unsigned int v144; // ebx
  char v145; // dl
  char v146; // dl
  int v147; // eax
  unsigned int v148; // ebx
  int v149; // eax
  char v150; // cl
  int v151; // eax
  int v152; // ebx
  char v153; // dl
  int *v154; // edx
  int v155; // eax
  int v156; // esi
  int v157; // ebx
  int v158; // eax
  char v159; // dl
  char v160; // dh
  char v161; // ah
  char v162; // dl
  char v163; // dh
  int v164; // eax
  int v165; // ebx
  char v166; // ch
  int v167; // eax
  int v168; // ebx
  char v169; // dl
  char v170; // dh
  int *v171; // edx
  int *v172; // edx
  unsigned int v173; // edi
  unsigned int v174; // ebx
  char v175; // dl
  char v176; // ch
  char v177; // dh
  char v178; // ah
  char v179; // dl
  char v180; // dh
  int v181; // eax
  unsigned int v182; // ebx
  int v183; // eax
  int v184; // eax
  char v185; // ch
  int v186; // ebx
  char v187; // dl
  char v188; // dh
  int *v189; // edx
  char v190; // ch
  int *v191; // edx
  char v192; // ch
  int v193; // ecx
  int v194; // esi
  int v195; // ebx
  unsigned __int16 v196; // di
  __int16 v197; // ax
  int v198; // eax
  int v199; // eax
  unsigned __int16 v200; // bx
  unsigned __int8 *v201; // ecx
  int v202; // edx
  _BYTE *v203; // eax
  int v204; // eax
  int v205; // ebx
  int v206; // edx
  void (__noreturn *v207)(); // eax
  int v208; // ecx
  int v209; // edx
  int v210; // ecx
  int v211; // edx
  int v212; // esi
  int v213; // esi
  int v214; // ebx
  char v215; // dl
  char v216; // dh
  char v217; // al
  char v218; // dl
  char v219; // dh
  int v220; // eax
  int v221; // ebx
  char v222; // cl
  int v223; // ebx
  char v224; // dl
  char v225; // dh
  int *v226; // edx
  unsigned int v227; // edi
  unsigned int v228; // ebx
  char v229; // dl
  char v230; // ch
  char v231; // dh
  char v232; // ah
  char v233; // dl
  char v234; // dh
  int v235; // eax
  unsigned int v236; // ebx
  int v237; // eax
  char v238; // ch
  int v239; // ebx
  char v240; // dl
  char v241; // dh
  int *v242; // edx
  int v244; // [esp+0h] [ebp-62h] BYREF
  int v245; // [esp+4h] [ebp-5Eh]
  int v246; // [esp+8h] [ebp-5Ah]
  int v247; // [esp+Ch] [ebp-56h]
  int v248; // [esp+10h] [ebp-52h]
  int v249; // [esp+18h] [ebp-4Ah] BYREF
  int v250; // [esp+1Ch] [ebp-46h]
  int v251; // [esp+20h] [ebp-42h]
  int v252; // [esp+24h] [ebp-3Eh]
  int v253; // [esp+28h] [ebp-3Ah]
  int v254; // [esp+30h] [ebp-32h] BYREF
  int v255; // [esp+34h] [ebp-2Eh]
  int v256; // [esp+38h] [ebp-2Ah]
  int v257; // [esp+3Ch] [ebp-26h]
  int v258; // [esp+40h] [ebp-22h]
  int v259; // [esp+48h] [ebp-1Ah] BYREF
  int v260; // [esp+4Ch] [ebp-16h]
  int v261; // [esp+50h] [ebp-12h]
  int v262; // [esp+54h] [ebp-Eh]
  int v263; // [esp+58h] [ebp-Ah]
  int v264; // [esp+60h] [ebp-2h]
  int v265; // [esp+64h] [ebp+2h]
  int v266; // [esp+68h] [ebp+6h]
  int v267; // [esp+6Ch] [ebp+Ah]
  int v268; // [esp+70h] [ebp+Eh]
  int v269; // [esp+74h] [ebp+12h]
  void (__noreturn *v270)(); // [esp+78h] [ebp+16h]
  int v271; // [esp+7Ch] [ebp+1Ah]
  int v272; // [esp+80h] [ebp+1Eh]
  _BYTE *v273; // [esp+84h] [ebp+22h]
  int v274; // [esp+88h] [ebp+26h]
  unsigned __int16 v275; // [esp+8Ch] [ebp+2Ah]
  char m; // [esp+90h] [ebp+2Eh]
  char v277; // [esp+94h] [ebp+32h]
  char v278; // [esp+98h] [ebp+36h]
  char v279; // [esp+9Ch] [ebp+3Ah]
  char k; // [esp+A0h] [ebp+3Eh]
  char v281; // [esp+A4h] [ebp+42h]
  char i; // [esp+A8h] [ebp+46h]
  char kk; // [esp+ACh] [ebp+4Ah]
  char n; // [esp+B0h] [ebp+4Eh]
  char v285; // [esp+B4h] [ebp+52h]
  char ii; // [esp+B8h] [ebp+56h]
  char jj; // [esp+BCh] [ebp+5Ah]
  char mm; // [esp+C0h] [ebp+5Eh]
  char v289; // [esp+C4h] [ebp+62h]

  byte_F2CC7 = *(_BYTE *)(dword_D41A0 + 8587);
  byte_D4320 = *(_BYTE *)(dword_D41A0 + 196308) != 0;
  dword_F2C60 = (int)(unsigned __int16)dword_DE568 >> 1;
  word_F2CC4 = a3;
  word_F2CC0 = a5 & 0x7FF;
  word_F2CC2 = a4;
  v9 = (a5 & 0x7FF) + 256;
  dword_F2CA0 = a6;
  v10 = dword_DBB50[v9];
  dword_F2CB0 = dword_D4324 + ((int)(unsigned __int16)dword_DE564 >> 1);
  dword_F2C5C = v10;
  v11 = dword_DB350[v9];
  v12 = ((((a5 & 0x7FF) + 256) & 0x1FF) - 256) & 0x7FF;
  v272 = (v9 >> 9) & 3;
  v270 = off_DBF50[v12];
  dword_F2C7C = v11;
  v13 = dword_DB750[v12];
  sub_3B560(-a8 & 0x7FF);
  dword_F2C80 = (7
               * sub_7277A(
                   (unsigned __int16)dword_DE564 * (unsigned __int16)dword_DE564
                 + (unsigned __int16)dword_DE568 * (unsigned __int16)dword_DE568)
               * a9) >> 11;
  v273 = (char *)&unk_D4328 + 10 * v272;
  switch ( v272 )
  {
    case 0:
      a2 = (unsigned __int8)a4 - 256;
      a1 = -(unsigned __int8)a3 - 4864;
      break;
    case 1:
      a1 = -(unsigned __int8)a4 - 4864;
      a2 = -(unsigned __int8)a3;
      break;
    case 2:
      a1 = (unsigned __int8)a3 - 4864;
      a2 = -(unsigned __int8)a4;
      break;
    case 3:
      a1 = (unsigned __int8)a4 - 4864;
      a2 = (unsigned __int8)a3 - 256;
      break;
    default:
      break;
  }
  v14 = 40;
  v15 = dword_E9C38;
  do
  {
    v269 = (a1 * v13) >> 16;
    v16 = 21;
    v268 = (a1 * (int)v270) >> 16;
    while ( v16 )
    {
      *(_DWORD *)v15 = v268;
      *(_DWORD *)(v15 + 12) = v269;
      if ( a1 < 0 )
        *(_WORD *)(v15 + 38) = 0;
      else
        *(_WORD *)(v15 + 38) = 4;
      v15 += 1760;
      --v16;
    }
    v15 -= 36916;
    a1 += 256;
    --v14;
  }
  while ( v14 );
  v17 = 21;
  v18 = (_DWORD *)dword_E9C38;
  while ( v17 )
  {
    v267 = (a2 * v13) >> 16;
    v19 = 40;
    v20 = (a2 * (int)v270) >> 16;
    while ( v19 )
    {
      *v18 -= v267;
      v21 = v18[3];
      v18 += 11;
      --v19;
      *(v18 - 8) = v20 + v21;
    }
    a2 += 256;
    --v17;
  }
  dword_F2C74 = 26214400;
  v274 = dword_E9C38;
  dword_F2C68 = 8912896;
  v22 = *v273;
  dword_F2CA8 = (a7 * (unsigned __int16)dword_DE564) >> 8;
  LOBYTE(v275) = v22 + HIBYTE(a3);
  HIBYTE(v275) = v273[1] + HIBYTE(a4);
  v23 = a8 & 0x7FF;
  v24 = dword_DB750[v23];
  v25 = 14745600;
  dword_F2C64 = (int)off_DBF50[v23];
  dword_F2C78 = 23658496;
  dword_F2C54 = v24;
  LOBYTE(v24) = *(_BYTE *)(dword_D41A0 + 8588);
  dword_F2C6C = 14745600;
  if ( !(_BYTE)v24 || byte_D41B6 )
  {
    v26 = dword_DE560 - (unsigned __int16)dword_DE564;
    v28 = dword_DE568;
    v25 = dword_DE558;
    v29 = (int)(unsigned __int16)dword_DE564 >> 2;
    HIWORD(v27) = HIWORD(v29);
    LOBYTE(v27) = word_D4B7C;
    BYTE1(v27) = word_D4B7C;
    v30 = v27;
    v31 = v27 << 16;
    LOWORD(v31) = v30;
    do
    {
      memset32((void *)v25, v31, v29);
      v25 += v26 + 4 * v29;
      --v28;
    }
    while ( v28 );
  }
  else
  {
    sub_40950(a8);
  }
  if ( byte_D41B6 )
  {
    for ( i = 21; ; --i )
    {
      if ( !i )
      {
        v45 = 840;
        v46 = dword_E9C38;
        while ( v45 )
        {
          v47 = ((*(_DWORD *)(v46 + 16) * dword_F2C64 - dword_F2C54 * *(_DWORD *)(v46 + 20)) >> 16) + dword_F2CB0;
          v265 = ((*(_DWORD *)(v46 + 16) * dword_F2C64 - dword_F2C54 * *(_DWORD *)(v46 + 28)) >> 16) + dword_F2CB0;
          v48 = *(_DWORD *)(v46 + 16) * dword_F2C54;
          v264 = dword_F2C60 - ((v48 + dword_F2C64 * *(_DWORD *)(v46 + 20)) >> 16);
          v49 = dword_F2C60 - ((v48 + dword_F2C64 * *(_DWORD *)(v46 + 28)) >> 16);
          *(_DWORD *)(v46 + 16) = v47;
          v50 = v49;
          v51 = v264;
          *(_DWORD *)(v46 + 28) = v50;
          *(_DWORD *)(v46 + 20) = v51;
          v52 = *(_DWORD *)(v46 + 16);
          *(_DWORD *)(v46 + 24) = v265;
          if ( v52 >= 0 )
          {
            if ( (unsigned __int16)dword_DE564 <= *(int *)(v46 + 16) )
              *(_BYTE *)(v46 + 38) |= 0x10u;
          }
          else
          {
            *(_BYTE *)(v46 + 38) |= 8u;
          }
          v53 = *(_DWORD *)(v46 + 20);
          if ( v53 >= 0 )
          {
            if ( (unsigned __int16)dword_DE568 <= v53 )
              *(_BYTE *)(v46 + 38) |= 0x40u;
          }
          else
          {
            *(_BYTE *)(v46 + 38) |= 0x20u;
          }
          if ( *(int *)(v46 + 24) >= 0 )
          {
            if ( (unsigned __int16)dword_DE564 <= *(int *)(v46 + 24) )
              *(_BYTE *)(v46 + 39) |= 2u;
          }
          else
          {
            *(_BYTE *)(v46 + 39) |= 1u;
          }
          v54 = *(_DWORD *)(v46 + 28);
          if ( v54 >= 0 )
          {
            if ( (unsigned __int16)dword_DE568 <= v54 )
              *(_BYTE *)(v46 + 39) |= 8u;
          }
          else
          {
            *(_BYTE *)(v46 + 39) |= 4u;
          }
          v46 += 44;
          --v45;
        }
        LOBYTE(v55) = 20;
        v56 = dword_E9C38 + 35200;
        v277 = 20;
        do
        {
          v57 = 39;
          for ( j = v56; ; j = v78 + 44 )
          {
            v289 = v57;
            if ( !v57 )
              break;
            v259 = *(_DWORD *)(j + 24);
            v260 = *(_DWORD *)(j + 28);
            v55 = *(_DWORD *)(j + 32);
            j += 44;
            v263 = v55;
            v59 = *(_BYTE *)(j - 6);
            v60 = v59;
            if ( (*(_BYTE *)(j + 38) & 4) != 0 )
              break;
            v254 = *(_DWORD *)(j + 24);
            v255 = *(_DWORD *)(j + 28);
            v258 = *(_DWORD *)(j + 32);
            v61 = *(_BYTE *)(j + 38);
            v249 = *(_DWORD *)(j - 1736);
            v250 = *(_DWORD *)(j - 1732);
            v253 = *(_DWORD *)(j - 1728);
            v62 = *(_BYTE *)(j - 1722);
            v63 = v62 | v61 | v59;
            v64 = v62 & v61 & v60;
            v244 = *(_DWORD *)(j - 1780);
            v245 = *(_DWORD *)(j - 1776);
            v248 = *(_DWORD *)(j - 1772);
            v65 = *(_BYTE *)(j - 1766);
            v66 = v65 | v63;
            v67 = j - 1804 + 1760;
            if ( (v65 & v64 & 0x80u) == 0 )
            {
              if ( (*(_BYTE *)(v67 + 39) & 0x10) != 0 )
              {
                byte_E126D = 7;
                byte_E126C = (v248 + v253 + v258 + v263) >> 18;
              }
              else
              {
                byte_E126D = 5;
              }
              if ( (v66 & 2) == 0 )
              {
                v68 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v67 + 42));
                v261 = *v68;
                v262 = v68[1];
                v256 = v68[2];
                v257 = v68[3];
                v251 = v68[4];
                v252 = v68[5];
                v246 = v68[6];
                v247 = v68[7];
                dword_DE55C = dword_DDF54;
                byte_E126D = 5;
                if ( (*(_BYTE *)(v67 + 38) & 1) != 0 )
                {
                  sub_B6253(&v259, &v244, &v254);
                  sub_B6253(&v244, &v249, &v254);
                }
                else
                {
                  sub_B6253(&v259, &v249, &v254);
                  sub_B6253(&v259, &v244, &v249);
                }
              }
            }
            v259 = *(_DWORD *)(v67 + 16);
            v260 = *(_DWORD *)(v67 + 20);
            v55 = *(_DWORD *)(v67 + 32);
            j = v67 + 44;
            v263 = v55;
            v69 = *(_BYTE *)(j - 6);
            v70 = v69;
            if ( (*(_BYTE *)(j + 38) & 4) != 0 )
              break;
            v254 = *(_DWORD *)(j + 16);
            v255 = *(_DWORD *)(j + 20);
            v258 = *(_DWORD *)(j + 32);
            v71 = *(_BYTE *)(j + 38);
            v249 = *(_DWORD *)(j - 1744);
            v250 = *(_DWORD *)(j - 1740);
            v253 = *(_DWORD *)(j - 1728);
            v72 = *(_BYTE *)(j - 1722);
            v73 = v72 | v71 | v69;
            v74 = v72 & v71 & v70;
            v244 = *(_DWORD *)(j - 1788);
            v245 = *(_DWORD *)(j - 1784);
            v55 = *(_DWORD *)(j - 1772);
            v248 = v55;
            v75 = *(_BYTE *)(j - 1766);
            v76 = v75 | v73;
            v77 = v75 & v74;
            v78 = j - 1804 + 1760;
            if ( v77 >= 0 )
            {
              if ( (*(_BYTE *)(v78 + 39) & 0x10) != 0 )
              {
                byte_E126D = 7;
                v55 = (v248 + v253 + v258 + v263) >> 18;
                byte_E126C = v55;
              }
              else
              {
                byte_E126D = 5;
              }
              if ( (v76 & 2) == 0 && (v77 & 0x78) == 0 )
              {
                v79 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v78 + 42));
                v261 = *v79;
                v262 = v79[1];
                v256 = v79[2];
                v257 = v79[3];
                v251 = v79[4];
                v252 = v79[5];
                v246 = v79[6];
                v247 = v79[7];
                dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v78 + 41)];
                if ( (*(_BYTE *)(v78 + 38) & 1) != 0 )
                {
                  sub_B6253(&v259, &v254, &v244);
                  v55 = (int)&v244;
                  sub_B6253(&v244, &v254, &v249);
                }
                else
                {
                  sub_B6253(&v259, &v254, &v249);
                  v55 = (int)&v259;
                  sub_B6253(&v259, &v249, &v244);
                }
              }
              if ( *(_WORD *)(v78 + 36) )
                LOBYTE(v55) = sub_3E360(v56, v78);
            }
            v57 = v289 - 1;
          }
          if ( v289 )
          {
            v80 = j - 44;
            v81 = v56 + 1672;
            do
            {
              v259 = *(_DWORD *)(v81 + 24);
              v260 = *(_DWORD *)(v81 + 28);
              v263 = *(_DWORD *)(v81 + 32);
              v82 = *(_BYTE *)(v81 + 38);
              v254 = *(_DWORD *)(v81 + 68);
              v255 = *(_DWORD *)(v81 + 72);
              v258 = *(_DWORD *)(v81 + 76);
              v83 = *(_BYTE *)(v81 + 82);
              v249 = *(_DWORD *)(v81 - 1692);
              v250 = *(_DWORD *)(v81 - 1688);
              v84 = v82;
              v253 = *(_DWORD *)(v81 - 1684);
              v85 = *(_BYTE *)(v81 - 1678);
              v86 = v85 | v83 | v82;
              v87 = v85 & v83 & v84;
              v244 = *(_DWORD *)(v81 - 1736);
              v245 = *(_DWORD *)(v81 - 1732);
              v88 = *(_DWORD *)(v81 - 1728);
              v89 = v81 + 44;
              v248 = v88;
              v90 = *(_BYTE *)(v89 - 1766);
              v91 = v90 | v86;
              v92 = v89 - 1804 + 1760;
              if ( (v90 & v87 & 0x80u) == 0 )
              {
                if ( (*(_BYTE *)(v92 + 39) & 0x10) != 0 )
                {
                  byte_E126D = 7;
                  byte_E126C = (v248 + v253 + v258 + v263) >> 18;
                }
                else
                {
                  byte_E126D = 5;
                }
                if ( (v91 & 2) == 0 )
                {
                  v93 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v92 + 42));
                  v261 = *v93;
                  v262 = v93[1];
                  v256 = v93[2];
                  v257 = v93[3];
                  v251 = v93[4];
                  v252 = v93[5];
                  v246 = v93[6];
                  v247 = v93[7];
                  dword_DE55C = dword_DDF54;
                  v94 = *(_BYTE *)(v92 + 38);
                  byte_E126D = 5;
                  if ( (v94 & 1) != 0 )
                  {
                    sub_B6253(&v259, &v244, &v254);
                    sub_B6253(&v244, &v249, &v254);
                  }
                  else
                  {
                    sub_B6253(&v259, &v249, &v254);
                    sub_B6253(&v259, &v244, &v249);
                  }
                }
              }
              v259 = *(_DWORD *)(v92 + 16);
              v260 = *(_DWORD *)(v92 + 20);
              v263 = *(_DWORD *)(v92 + 32);
              v95 = *(_BYTE *)(v92 + 38);
              v254 = *(_DWORD *)(v92 + 60);
              v255 = *(_DWORD *)(v92 + 64);
              v258 = *(_DWORD *)(v92 + 76);
              v96 = v95;
              v97 = *(_BYTE *)(v92 + 82);
              v98 = v97 | v95;
              v99 = v97 & v96;
              v249 = *(_DWORD *)(v92 - 1700);
              v250 = *(_DWORD *)(v92 - 1696);
              v253 = *(_DWORD *)(v92 - 1684);
              v100 = *(_BYTE *)(v92 - 1678);
              v244 = *(_DWORD *)(v92 - 1744);
              v101 = *(_DWORD *)(v92 - 1740);
              v102 = v92 + 44;
              v245 = v101;
              v55 = *(_DWORD *)(v102 - 1772);
              v248 = v55;
              BYTE1(v55) = *(_BYTE *)(v102 - 1766);
              v103 = BYTE1(v55) | v100 | v98;
              v104 = BYTE1(v55) & v100 & v99;
              v105 = v102 - 1804 + 1760;
              if ( v104 >= 0 )
              {
                if ( (*(_BYTE *)(v105 + 39) & 0x10) != 0 )
                {
                  byte_E126D = 7;
                  v55 = (v248 + v253 + v258 + v263) >> 18;
                  byte_E126C = v55;
                }
                else
                {
                  byte_E126D = 5;
                }
                if ( (v103 & 2) == 0 && (v104 & 0x78) == 0 )
                {
                  v106 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v105 + 42));
                  v261 = *v106;
                  v262 = v106[1];
                  v256 = v106[2];
                  v257 = v106[3];
                  v251 = v106[4];
                  v252 = v106[5];
                  v246 = v106[6];
                  v247 = v106[7];
                  LOBYTE(v106) = *(_BYTE *)(v105 + 38);
                  dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v105 + 41)];
                  if ( ((unsigned __int8)v106 & 1) != 0 )
                  {
                    sub_B6253(&v259, &v254, &v244);
                    v55 = (int)&v244;
                    sub_B6253(&v244, &v254, &v249);
                  }
                  else
                  {
                    sub_B6253(&v259, &v254, &v249);
                    v55 = (int)&v259;
                    sub_B6253(&v259, &v249, &v244);
                  }
                }
                if ( *(_WORD *)(v105 + 36) )
                  LOBYTE(v55) = sub_3E360(v56, v105);
              }
              v81 = v105 - 44;
            }
            while ( v81 >= v80 );
          }
          v56 -= 1760;
          --v277;
        }
        while ( v277 );
        return v55;
      }
      for ( k = 40; k; --k )
      {
        v32 = ((unsigned __int8)byte_12B4E0[v275] << 8) + 128;
        v33 = *(_DWORD *)(v274 + 12);
        v34 = v33 * v33 + *(_DWORD *)v274 * *(_DWORD *)v274;
        *(_WORD *)(v274 + 36) = 0;
        if ( v33 <= -256 || v34 >= dword_F2C74 )
        {
          *(_BYTE *)(v274 + 38) |= 2u;
          goto LABEL_46;
        }
        if ( v33 < 128 )
          v33 = 128;
        *(_DWORD *)(v274 + 16) = dword_F2C80 * *(_DWORD *)v274 / v33;
        v35 = v275;
        *(_DWORD *)(v274 + 4) = 32 * (unsigned __int8)byte_11B4E0[v275] - a6;
        *(_DWORD *)(v274 + 8) = ((unsigned __int8)byte_14B4E0[v35] << 15 >> 10) - a6;
        v36 = 0;
        if ( !byte_10B4E0[v35] )
        {
          v37 = 32 * *(_DWORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248);
          v36 = (dword_DB750[(v37 + (HIBYTE(v275) << 7)) & 0x7FF] >> 8)
              * (dword_DB750[(((unsigned __int8)v275 << 7) + v37) & 0x7FF] >> 8);
          *(_DWORD *)(v274 + 4) -= v36 >> 13;
          if ( v32 >= 14464 )
            v36 = 0;
        }
        v38 = (v32 << 8) + 8 * v36;
        if ( v34 <= dword_F2C6C )
          goto LABEL_39;
        if ( v34 < dword_F2C78 )
        {
          v38 = v38 * (__int64)(dword_F2C78 - v34) / dword_F2C68;
LABEL_39:
          *(_DWORD *)(v274 + 32) = v38;
          goto LABEL_40;
        }
        *(_DWORD *)(v274 + 32) = 0;
LABEL_40:
        if ( (byte_13B4E0[v275] & 8) != 0 )
          *(_BYTE *)(v274 + 38) |= 0x80u;
        v39 = dword_F2C80;
        v40 = v274;
        *(_DWORD *)(v274 + 20) = dword_F2CA8 + dword_F2C80 * *(_DWORD *)(v274 + 4) / v33;
        *(_DWORD *)(v274 + 28) = dword_F2CA8 + v39 * *(_DWORD *)(v40 + 8) / v33;
        LOBYTE(v41) = v273[2] + v275;
        HIBYTE(v41) = v273[3] + HIBYTE(v275);
        v42 = v274;
        *(_BYTE *)(v274 + 41) = byte_10B4E0[v41];
        if ( *(_BYTE *)(dword_D41A0 + 8601) )
          *(_BYTE *)(v42 + 39) |= 0x10u;
        *(_BYTE *)(v274 + 43) = byte_D41D8[*(unsigned __int8 *)(v274 + 41)];
        *(_BYTE *)(v274 + 42) = v272 + (((int)(unsigned __int8)byte_13B4E0[v41] >> 2) & 0x1C);
        LOBYTE(v41) = v273[4] + v41;
        HIBYTE(v41) += v273[5];
        *(_WORD *)(v274 + 36) = word_15B4E0[v41];
LABEL_46:
        v43 = v273;
        *(_WORD *)(v274 + 38) |= ((_BYTE)v275 + HIBYTE(v275)) & 1;
        LOBYTE(v275) = v43[8] + v275;
        HIBYTE(v275) += v273[9];
        v274 += 44;
      }
      v44 = v273[6] + v275;
      HIBYTE(v275) += v273[7];
      LOBYTE(v275) = v44;
    }
  }
  if ( *(_BYTE *)(dword_D41A0 + 8586) )
  {
    for ( m = 21; ; --m )
    {
      if ( !m )
      {
        v121 = 840;
        v122 = dword_E9C38;
        while ( v121 )
        {
          v123 = ((dword_F2C64 * *(_DWORD *)(v122 + 16) - dword_F2C54 * *(_DWORD *)(v122 + 20)) >> 16) + dword_F2CB0;
          v265 = ((dword_F2C64 * *(_DWORD *)(v122 + 16) - dword_F2C54 * *(_DWORD *)(v122 + 28)) >> 16) + dword_F2CB0;
          v124 = *(_DWORD *)(v122 + 16) * dword_F2C54;
          v25 = dword_F2C60 - ((v124 + dword_F2C64 * *(_DWORD *)(v122 + 20)) >> 16);
          v264 = v25;
          v125 = dword_F2C60 - ((v124 + dword_F2C64 * *(_DWORD *)(v122 + 28)) >> 16);
          *(_DWORD *)(v122 + 16) = v123;
          v126 = v125;
          v127 = v264;
          *(_DWORD *)(v122 + 28) = v126;
          *(_DWORD *)(v122 + 20) = v127;
          v128 = *(_DWORD *)(v122 + 16);
          *(_DWORD *)(v122 + 24) = v265;
          if ( v128 >= 0 )
          {
            if ( (unsigned __int16)dword_DE564 <= *(int *)(v122 + 16) )
              *(_BYTE *)(v122 + 38) |= 0x10u;
          }
          else
          {
            *(_BYTE *)(v122 + 38) |= 8u;
          }
          v129 = *(_DWORD *)(v122 + 20);
          if ( v129 >= 0 )
          {
            if ( (unsigned __int16)dword_DE568 <= v129 )
              *(_BYTE *)(v122 + 38) |= 0x40u;
          }
          else
          {
            *(_BYTE *)(v122 + 38) |= 0x20u;
          }
          if ( *(int *)(v122 + 24) >= 0 )
          {
            if ( (unsigned __int16)dword_DE564 <= *(int *)(v122 + 24) )
              *(_BYTE *)(v122 + 39) |= 2u;
          }
          else
          {
            *(_BYTE *)(v122 + 39) |= 1u;
          }
          v130 = *(_DWORD *)(v122 + 28);
          if ( v130 >= 0 )
          {
            if ( (unsigned __int16)dword_DE568 <= v130 )
              *(_BYTE *)(v122 + 39) |= 8u;
          }
          else
          {
            *(_BYTE *)(v122 + 39) |= 4u;
          }
          v122 += 44;
          --v121;
        }
        if ( a6 < 4096 )
        {
          v131 = dword_E9C38 + 35200;
          for ( n = 20; n; --n )
          {
            v132 = v131;
            for ( ii = 39; ii; --ii )
            {
              v259 = *(_DWORD *)(v132 + 24);
              v260 = *(_DWORD *)(v132 + 28);
              v133 = *(_DWORD *)(v132 + 32);
              v132 += 44;
              v263 = v133;
              v134 = *(_BYTE *)(v132 - 6);
              if ( (*(_BYTE *)(v132 + 38) & 4) != 0 )
                break;
              v254 = *(_DWORD *)(v132 + 24);
              v255 = *(_DWORD *)(v132 + 28);
              v258 = *(_DWORD *)(v132 + 32);
              v135 = *(_BYTE *)(v132 + 38);
              v249 = *(_DWORD *)(v132 - 1736);
              v250 = *(_DWORD *)(v132 - 1732);
              v253 = *(_DWORD *)(v132 - 1728);
              v136 = *(_BYTE *)(v132 - 1722) | v135 | v134;
              v244 = *(_DWORD *)(v132 - 1780);
              v137 = *(_DWORD *)(v132 - 1776);
              v138 = v132 - 1760;
              v245 = v137;
              v139 = *(_DWORD *)(v138 - 12);
              v138 -= 44;
              v248 = v139;
              v140 = *(_BYTE *)(v138 + 38);
              v141 = v138 + 1760;
              v142 = v140 | v136;
              if ( *(_BYTE *)(v141 + 41) )
              {
                if ( (*(_BYTE *)(v141 + 39) & 0x10) != 0 )
                {
                  byte_E126D = 7;
                  v25 = v253;
                  byte_E126C = (v248 + v253 + v258 + v263) >> 18;
                }
                else
                {
                  byte_E126D = 5;
                }
                if ( (v142 & 2) == 0 )
                {
                  v143 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v141 + 42));
                  v261 = *v143;
                  v262 = v143[1];
                  v256 = v143[2];
                  v257 = v143[3];
                  v251 = v143[4];
                  v252 = v143[5];
                  v246 = v143[6];
                  v247 = v143[7];
                  dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v141 + 41)];
                  LOBYTE(v143) = *(_BYTE *)(v141 + 38);
                  byte_E126D = 5;
                  if ( ((unsigned __int8)v143 & 1) != 0 )
                  {
                    sub_B6253(&v259, &v244, &v254);
                    sub_B6253(&v244, &v249, &v254);
                  }
                  else
                  {
                    sub_B6253(&v259, &v249, &v254);
                    sub_B6253(&v259, &v244, &v249);
                  }
                }
              }
              if ( *(_WORD *)(v141 + 36) )
                sub_3FD60(v25, v141);
              v132 = v141 + 44;
            }
            if ( ii )
            {
              v25 = v132 - 44;
              v144 = v131 + 1672;
              do
              {
                v259 = *(_DWORD *)(v144 + 24);
                v260 = *(_DWORD *)(v144 + 28);
                v263 = *(_DWORD *)(v144 + 32);
                v145 = *(_BYTE *)(v144 + 38);
                v254 = *(_DWORD *)(v144 + 68);
                v255 = *(_DWORD *)(v144 + 72);
                v258 = *(_DWORD *)(v144 + 76);
                v146 = *(_BYTE *)(v144 + 82) | v145;
                v249 = *(_DWORD *)(v144 - 1692);
                v147 = *(_DWORD *)(v144 - 1688);
                v148 = v144 + 44;
                v250 = v147;
                v149 = *(_DWORD *)(v148 - 1728);
                v148 -= 1760;
                v253 = v149;
                v150 = *(_BYTE *)(v148 + 38);
                v244 = *(_DWORD *)(v148 - 20);
                v151 = *(_DWORD *)(v148 - 16);
                v148 -= 44;
                v245 = v151;
                v248 = *(_DWORD *)(v148 + 32);
                LOBYTE(v151) = *(_BYTE *)(v148 + 38);
                v152 = v148 + 1760;
                v153 = v151 | v150 | v146;
                if ( *(_BYTE *)(v152 + 41) )
                {
                  if ( (*(_BYTE *)(v152 + 39) & 0x10) != 0 )
                  {
                    byte_E126D = 7;
                    byte_E126C = (v248 + v253 + v258 + v263) >> 18;
                  }
                  else
                  {
                    byte_E126D = 5;
                  }
                  if ( (v153 & 2) == 0 )
                  {
                    v154 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v152 + 42));
                    v261 = *v154;
                    v262 = v154[1];
                    v256 = v154[2];
                    v257 = v154[3];
                    v251 = v154[4];
                    v252 = v154[5];
                    v246 = v154[6];
                    v247 = v154[7];
                    v155 = *(unsigned __int8 *)(v152 + 41);
                    byte_E126D = 5;
                    BYTE1(v154) = *(_BYTE *)(v152 + 38);
                    dword_DE55C = dword_DDF50[v155];
                    if ( (BYTE1(v154) & 1) != 0 )
                    {
                      sub_B6253(&v259, &v244, &v254);
                      sub_B6253(&v244, &v249, &v254);
                    }
                    else
                    {
                      sub_B6253(&v259, &v249, &v254);
                      sub_B6253(&v259, &v244, &v249);
                    }
                  }
                }
                if ( *(_WORD *)(v152 + 36) )
                  sub_3FD60(v25, v152);
                v144 = v152 - 44;
              }
              while ( v144 >= v25 );
            }
            v131 -= 1760;
          }
        }
        v156 = dword_E9C38 + 35200;
        v278 = 20;
        while ( 1 )
        {
          v157 = v156;
          for ( jj = 39; jj; --jj )
          {
            v259 = *(_DWORD *)(v157 + 16);
            v260 = *(_DWORD *)(v157 + 20);
            v158 = *(_DWORD *)(v157 + 32);
            v157 += 44;
            v263 = v158;
            v159 = *(_BYTE *)(v157 - 6);
            v160 = v159;
            if ( (*(_BYTE *)(v157 + 38) & 4) != 0 )
              break;
            v254 = *(_DWORD *)(v157 + 16);
            v255 = *(_DWORD *)(v157 + 20);
            v258 = *(_DWORD *)(v157 + 32);
            v161 = *(_BYTE *)(v157 + 38);
            v162 = v161 | v159;
            v163 = v161 & v160;
            v249 = *(_DWORD *)(v157 - 1744);
            v250 = *(_DWORD *)(v157 - 1740);
            v164 = *(_DWORD *)(v157 - 1728);
            v165 = v157 - 1760;
            v253 = v164;
            v166 = *(_BYTE *)(v165 + 38);
            v244 = *(_DWORD *)(v165 - 28);
            v167 = *(_DWORD *)(v165 - 24);
            v165 -= 44;
            v245 = v167;
            v248 = *(_DWORD *)(v165 + 32);
            BYTE1(v167) = *(_BYTE *)(v165 + 38);
            v168 = v165 + 1760;
            v169 = BYTE1(v167) | v166 | v162;
            v170 = BYTE1(v167) & v166 & v163;
            if ( *(char *)(v168 + 38) >= 0 )
            {
              if ( (*(_BYTE *)(v168 + 39) & 0x10) != 0 )
              {
                byte_E126D = 7;
                byte_E126C = (v248 + v253 + v258 + v263) >> 18;
              }
              else
              {
                byte_E126D = 5;
              }
              if ( (v169 & 2) == 0 && (v170 & 0x78) == 0 )
              {
                v172 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v168 + 42));
                v261 = *v172;
                v262 = v172[1];
                v256 = v172[2];
                v257 = v172[3];
                v251 = v172[4];
                v252 = v172[5];
                v246 = v172[6];
                v247 = v172[7];
                dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v168 + 41)];
                if ( (*(_BYTE *)(v168 + 38) & 1) != 0 )
                {
LABEL_207:
                  sub_B6253(&v259, &v254, &v244);
                  sub_B6253(&v244, &v254, &v249);
                  goto LABEL_209;
                }
                goto LABEL_208;
              }
            }
            else
            {
              byte_E126D = 26;
              if ( (v169 & 2) == 0 && (v170 & 0x78) == 0 )
              {
                v171 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v168 + 42));
                v261 = *v171;
                v262 = v171[1];
                v256 = v171[2];
                v257 = v171[3];
                v251 = v171[4];
                v252 = v171[5];
                v246 = v171[6];
                v247 = v171[7];
                dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v168 + 41)];
                if ( (*(_BYTE *)(v168 + 38) & 1) != 0 )
                  goto LABEL_207;
LABEL_208:
                sub_B6253(&v259, &v254, &v249);
                sub_B6253(&v259, &v249, &v244);
              }
            }
LABEL_209:
            if ( *(_WORD *)(v168 + 36) )
              sub_3E360(v156, v168);
            v157 = v168 + 44;
          }
          if ( jj )
            break;
LABEL_231:
          LOBYTE(v55) = v278 - 1;
          v156 -= 1760;
          if ( !--v278 )
            return v55;
        }
        v173 = v157 - 44;
        v174 = v156 + 1672;
        while ( 2 )
        {
          v259 = *(_DWORD *)(v174 + 16);
          v260 = *(_DWORD *)(v174 + 20);
          v263 = *(_DWORD *)(v174 + 32);
          v175 = *(_BYTE *)(v174 + 38);
          v254 = *(_DWORD *)(v174 + 60);
          v255 = *(_DWORD *)(v174 + 64);
          v258 = *(_DWORD *)(v174 + 76);
          v176 = *(_BYTE *)(v174 + 82);
          v249 = *(_DWORD *)(v174 - 1700);
          v250 = *(_DWORD *)(v174 - 1696);
          v177 = v175;
          v253 = *(_DWORD *)(v174 - 1684);
          v178 = *(_BYTE *)(v174 - 1678);
          v179 = v178 | v176 | v175;
          v180 = v178 & v176 & v177;
          v181 = *(_DWORD *)(v174 - 1744);
          v182 = v174 + 44;
          v244 = v181;
          v183 = *(_DWORD *)(v182 - 1784);
          v182 -= 1760;
          v245 = v183;
          v184 = *(_DWORD *)(v182 - 12);
          v182 -= 44;
          v248 = v184;
          v185 = *(_BYTE *)(v182 + 38);
          v186 = v182 + 1760;
          v187 = v185 | v179;
          v188 = v185 & v180;
          if ( *(char *)(v186 + 38) >= 0 )
          {
            if ( (*(_BYTE *)(v186 + 39) & 0x10) != 0 )
            {
              byte_E126D = 7;
              byte_E126C = (v248 + v253 + v258 + v263) >> 18;
            }
            else
            {
              byte_E126D = 5;
            }
            if ( (v187 & 2) == 0 && (v188 & 0x78) == 0 )
            {
              v191 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v186 + 42));
              v261 = *v191;
              v262 = v191[1];
              v256 = v191[2];
              v257 = v191[3];
              v251 = v191[4];
              v252 = v191[5];
              v246 = v191[6];
              v247 = v191[7];
              v192 = *(_BYTE *)(v186 + 38);
              dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v186 + 41)];
              if ( (v192 & 1) == 0 )
                goto LABEL_227;
              goto LABEL_226;
            }
          }
          else
          {
            byte_E126D = 26;
            if ( (v187 & 2) == 0 && (v188 & 0x78) == 0 )
            {
              v189 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v186 + 42));
              v261 = *v189;
              v262 = v189[1];
              v256 = v189[2];
              v257 = v189[3];
              v251 = v189[4];
              v252 = v189[5];
              v246 = v189[6];
              v247 = v189[7];
              v190 = *(_BYTE *)(v186 + 38);
              dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v186 + 41)];
              if ( (v190 & 1) == 0 )
              {
LABEL_227:
                sub_B6253(&v259, &v254, &v249);
                sub_B6253(&v259, &v249, &v244);
                goto LABEL_228;
              }
LABEL_226:
              sub_B6253(&v259, &v254, &v244);
              sub_B6253(&v244, &v254, &v249);
            }
          }
LABEL_228:
          if ( *(_WORD *)(v186 + 36) )
            sub_3E360(v156, v186);
          v174 = v186 - 44;
          if ( v174 < v173 )
            goto LABEL_231;
          continue;
        }
      }
      for ( kk = 40; kk; --kk )
      {
        v271 = ((unsigned __int8)byte_12B4E0[v275] << 8) + 128;
        v107 = *(_DWORD *)(v274 + 12);
        v108 = v107 * v107 + *(_DWORD *)v274 * *(_DWORD *)v274;
        *(_WORD *)(v274 + 36) = 0;
        if ( v107 <= -256 || v108 >= dword_F2C74 )
        {
          *(_BYTE *)(v274 + 38) |= 2u;
          goto LABEL_139;
        }
        if ( v107 < 128 )
          v107 = 128;
        *(_DWORD *)(v274 + 16) = dword_F2C80 * *(_DWORD *)v274 / v107;
        v109 = v275;
        *(_DWORD *)(v274 + 4) = 32 * (unsigned __int8)byte_11B4E0[v275] - a6;
        v110 = (unsigned __int16)*(_DWORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248) << 6;
        v266 = dword_DB750[(v110 + (HIBYTE(v275) << 7)) & 0x7FF] >> 8;
        v111 = v266 * (dword_DB750[(((unsigned __int8)v275 << 7) + v110) & 0x7FF] >> 8);
        v266 = (unsigned __int8)byte_11B4E0[v109];
        v25 = v274;
        *(_DWORD *)(v274 + 8) = -((v266 * ((v111 >> 4) + 0x8000)) >> 10) - a6;
        if ( (byte_13B4E0[v109] & 8) == 0
          || (v112 = v25,
              v25 = *(_DWORD *)(v25 + 4) - (v111 >> 10),
              v113 = v271,
              *(_DWORD *)(v112 + 4) = v25,
              v113 >= 14464) )
        {
          v111 = 0;
        }
        v114 = (v271 << 8) + 8 * v111;
        if ( v108 <= dword_F2C6C )
          goto LABEL_132;
        v25 = dword_F2C78;
        if ( v108 < dword_F2C78 )
        {
          v114 = v114 * (__int64)(dword_F2C78 - v108) / dword_F2C68;
LABEL_132:
          *(_DWORD *)(v274 + 32) = v114;
          goto LABEL_133;
        }
        *(_DWORD *)(v274 + 32) = 0;
LABEL_133:
        v115 = v274;
        *(_DWORD *)(v274 + 20) = dword_F2CA8 + dword_F2C80 * *(_DWORD *)(v274 + 4) / v107;
        *(_DWORD *)(v274 + 28) = dword_F2CA8 + dword_F2C80 * *(_DWORD *)(v115 + 8) / v107;
        LOBYTE(v116) = v273[2] + v275;
        HIBYTE(v116) = v273[3] + HIBYTE(v275);
        v117 = byte_10B4E0[v116];
        *(_BYTE *)(v274 + 41) = v117;
        if ( byte_D427C[v117] )
          *(_BYTE *)(v274 + 38) |= 0x80u;
        if ( *(_BYTE *)(dword_D41A0 + 8601) )
          *(_BYTE *)(v274 + 39) |= 0x10u;
        v118 = v274;
        *(_BYTE *)(v274 + 43) = byte_D41D8[*(unsigned __int8 *)(v274 + 41)];
        *(_BYTE *)(v118 + 42) = v272 + (((int)(unsigned __int8)byte_13B4E0[v116] >> 2) & 0x1C);
        LOBYTE(v116) = v273[4] + v116;
        HIBYTE(v116) += v273[5];
        *(_WORD *)(v274 + 36) = word_15B4E0[v116];
LABEL_139:
        v119 = v273;
        *(_WORD *)(v274 + 38) |= ((_BYTE)v275 + HIBYTE(v275)) & 1;
        LOBYTE(v275) = v119[8] + v275;
        HIBYTE(v275) += v273[9];
        v274 += 44;
      }
      v120 = v273[6] + v275;
      HIBYTE(v275) += v273[7];
      LOBYTE(v275) = v120;
    }
  }
  v279 = 21;
LABEL_252:
  if ( v279 )
  {
    v281 = 40;
    while ( 1 )
    {
      if ( !v281 )
      {
        LOBYTE(v275) = v273[6] + v275;
        HIBYTE(v275) += v273[7];
        --v279;
        goto LABEL_252;
      }
      v193 = ((unsigned __int8)byte_12B4E0[v275] << 8) + 128;
      v194 = *(_DWORD *)(v274 + 12);
      v195 = v194 * v194 + *(_DWORD *)v274 * *(_DWORD *)v274;
      *(_WORD *)(v274 + 36) = 0;
      if ( v194 > -256 && v195 < dword_F2C74 )
        break;
      *(_BYTE *)(v274 + 38) |= 2u;
LABEL_249:
      v202 = v274;
      v203 = v273;
      *(_WORD *)(v274 + 38) |= ((_BYTE)v275 + HIBYTE(v275)) & 1;
      LOBYTE(v275) = v203[8] + v275;
      HIBYTE(v275) += v273[9];
      --v281;
      v274 = v202 + 44;
    }
    if ( v194 < 128 )
      v194 = 128;
    v196 = v275;
    *(_DWORD *)(v274 + 16) = dword_F2C80 * *(_DWORD *)v274 / v194;
    *(_DWORD *)(v274 + 4) = 32 * (unsigned __int8)byte_11B4E0[v196] - a6;
    v197 = (unsigned __int16)*(_DWORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248) << 6;
    v266 = dword_DB750[(v197 + (HIBYTE(v275) << 7)) & 0x7FF] >> 8;
    v198 = v266 * (dword_DB750[(((unsigned __int8)v275 << 7) + v197) & 0x7FF] >> 8);
    if ( (byte_13B4E0[v196] & 8) == 0 || (*(_DWORD *)(v274 + 4) -= v198 >> 10, v193 >= 14464) )
      v198 = 0;
    v199 = (v193 << 8) + 8 * v198;
    if ( v195 > dword_F2C6C )
    {
      if ( v195 >= dword_F2C78 )
      {
        *(_DWORD *)(v274 + 32) = 0;
LABEL_247:
        *(_DWORD *)(v274 + 20) = dword_F2CA8 + dword_F2C80 * *(_DWORD *)(v274 + 4) / v194;
        LOBYTE(v200) = v273[2] + v275;
        HIBYTE(v200) = v273[3] + HIBYTE(v275);
        v201 = (unsigned __int8 *)v274;
        *(_BYTE *)(v274 + 41) = byte_10B4E0[v200];
        v201[43] = byte_D41D8[v201[41]];
        v201[42] = v272 + (((int)(unsigned __int8)byte_13B4E0[v200] >> 2) & 0x1C);
        LOBYTE(v200) = v273[4] + v200;
        HIBYTE(v200) += v273[5];
        *(_WORD *)(v274 + 36) = word_15B4E0[v200];
        goto LABEL_249;
      }
      v199 = v199 * (__int64)(dword_F2C78 - v195) / dword_F2C68;
    }
    *(_DWORD *)(v274 + 32) = v199;
    goto LABEL_247;
  }
  v204 = a8 & 0x7FF;
  v205 = 840;
  v206 = dword_DB750[v204];
  v207 = off_DBF50[v204];
  dword_F2C54 = v206;
  dword_F2C64 = (int)v207;
  v55 = dword_E9C38;
  while ( v205 )
  {
    v208 = dword_F2C60;
    v209 = (dword_F2C54 * *(_DWORD *)(v55 + 16) + dword_F2C64 * *(_DWORD *)(v55 + 20)) >> 16;
    *(_DWORD *)(v55 + 16) = ((*(_DWORD *)(v55 + 16) * dword_F2C64 - dword_F2C54 * *(_DWORD *)(v55 + 20)) >> 16)
                          + dword_F2CB0;
    v210 = v208 - v209;
    v211 = *(_DWORD *)(v55 + 16);
    *(_DWORD *)(v55 + 20) = v210;
    if ( v211 >= 0 )
    {
      if ( (unsigned __int16)dword_DE564 <= *(int *)(v55 + 16) )
        *(_BYTE *)(v55 + 38) |= 0x10u;
    }
    else
    {
      *(_BYTE *)(v55 + 38) |= 8u;
    }
    v212 = *(_DWORD *)(v55 + 20);
    if ( v212 >= 0 )
    {
      if ( (unsigned __int16)dword_DE568 <= v212 )
        *(_BYTE *)(v55 + 38) |= 0x40u;
    }
    else
    {
      *(_BYTE *)(v55 + 38) |= 0x20u;
    }
    v55 += 44;
    --v205;
  }
  v213 = dword_E9C38 + 35200;
  v285 = 20;
  do
  {
    v214 = v213;
    for ( mm = 39; mm; --mm )
    {
      v259 = *(_DWORD *)(v214 + 16);
      v260 = *(_DWORD *)(v214 + 20);
      v55 = *(_DWORD *)(v214 + 32);
      v214 += 44;
      v263 = v55;
      v215 = *(_BYTE *)(v214 - 6);
      v216 = v215;
      if ( (*(_BYTE *)(v214 + 38) & 4) != 0 )
        break;
      v254 = *(_DWORD *)(v214 + 16);
      v255 = *(_DWORD *)(v214 + 20);
      v258 = *(_DWORD *)(v214 + 32);
      v217 = *(_BYTE *)(v214 + 38);
      v218 = v217 | v215;
      v219 = v217 & v216;
      v249 = *(_DWORD *)(v214 - 1744);
      v250 = *(_DWORD *)(v214 - 1740);
      v220 = *(_DWORD *)(v214 - 1728);
      v221 = v214 - 1760;
      v253 = v220;
      v222 = *(_BYTE *)(v221 + 38);
      v244 = *(_DWORD *)(v221 - 28);
      v55 = *(_DWORD *)(v221 - 24);
      v221 -= 44;
      v245 = v55;
      v248 = *(_DWORD *)(v221 + 32);
      LOBYTE(v55) = *(_BYTE *)(v221 + 38);
      v223 = v221 + 1760;
      v224 = v55 | v222 | v218;
      v225 = v55 & v222 & v219;
      if ( (*(_BYTE *)(v223 + 39) & 0x10) != 0 )
      {
        byte_E126D = 7;
        v55 = (v248 + v253 + v258 + v263) >> 18;
        byte_E126C = v55;
      }
      else
      {
        byte_E126D = 5;
      }
      if ( (v224 & 2) == 0 && (v225 & 0x78) == 0 )
      {
        v226 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v223 + 42));
        v261 = *v226;
        v262 = v226[1];
        v256 = v226[2];
        v257 = v226[3];
        v251 = v226[4];
        v252 = v226[5];
        v246 = v226[6];
        v247 = v226[7];
        dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v223 + 41)];
        if ( (*(_BYTE *)(v223 + 38) & 1) != 0 )
        {
          sub_B6253(&v259, &v254, &v244);
          v55 = (int)&v244;
          sub_B6253(&v244, &v254, &v249);
        }
        else
        {
          sub_B6253(&v259, &v254, &v249);
          v55 = (int)&v259;
          sub_B6253(&v259, &v249, &v244);
        }
      }
      if ( *(_WORD *)(v223 + 36) )
        LOBYTE(v55) = sub_3E360(v213, v223);
      v214 = v223 + 44;
    }
    if ( mm )
    {
      v227 = v214 - 44;
      v228 = v213 + 1672;
      do
      {
        v259 = *(_DWORD *)(v228 + 16);
        v260 = *(_DWORD *)(v228 + 20);
        v263 = *(_DWORD *)(v228 + 32);
        v229 = *(_BYTE *)(v228 + 38);
        v254 = *(_DWORD *)(v228 + 60);
        v255 = *(_DWORD *)(v228 + 64);
        v258 = *(_DWORD *)(v228 + 76);
        v230 = *(_BYTE *)(v228 + 82);
        v249 = *(_DWORD *)(v228 - 1700);
        v250 = *(_DWORD *)(v228 - 1696);
        v231 = v229;
        v253 = *(_DWORD *)(v228 - 1684);
        v232 = *(_BYTE *)(v228 - 1678);
        v233 = v232 | v230 | v229;
        v234 = v232 & v230 & v231;
        v235 = *(_DWORD *)(v228 - 1744);
        v236 = v228 + 44;
        v244 = v235;
        v237 = *(_DWORD *)(v236 - 1784);
        v236 -= 1760;
        v245 = v237;
        v55 = *(_DWORD *)(v236 - 12);
        v236 -= 44;
        v248 = v55;
        v238 = *(_BYTE *)(v236 + 38);
        v239 = v236 + 1760;
        v240 = v238 | v233;
        v241 = v238 & v234;
        if ( (*(_BYTE *)(v239 + 39) & 0x10) != 0 )
        {
          byte_E126D = 7;
          v55 = (v248 + v253 + v258 + v263) >> 18;
          byte_E126C = v55;
        }
        else
        {
          byte_E126D = 5;
        }
        if ( (v240 & 2) == 0 && (v241 & 0x78) == 0 )
        {
          v242 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v239 + 42));
          v261 = *v242;
          v262 = v242[1];
          v256 = v242[2];
          v257 = v242[3];
          v251 = v242[4];
          v252 = v242[5];
          v246 = v242[6];
          v247 = v242[7];
          dword_DE55C = dword_DDF50[*(unsigned __int8 *)(v239 + 41)];
          if ( (*(_BYTE *)(v239 + 38) & 1) != 0 )
          {
            sub_B6253(&v259, &v254, &v244);
            v55 = (int)&v244;
            sub_B6253(&v244, &v254, &v249);
          }
          else
          {
            sub_B6253(&v259, &v254, &v249);
            v55 = (int)&v259;
            sub_B6253(&v259, &v249, &v244);
          }
        }
        if ( *(_WORD *)(v239 + 36) )
          LOBYTE(v55) = sub_3E360(v213, v239);
        v228 = v239 - 44;
      }
      while ( v228 >= v227 );
    }
    v213 -= 1760;
    --v285;
  }
  while ( v285 );
  return v55;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// D4320: using guessed type char byte_D4320;
// D4324: using guessed type int dword_D4324;
// D4B7C: using guessed type __int16 word_D4B7C;
// DB350: using guessed type int dword_DB350[103];
// DB750: using guessed type int dword_DB750[256];
// DBB50: using guessed type int dword_DBB50[256];
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// DDF50: using guessed type int dword_DDF50[];
// DDF54: using guessed type int dword_DDF54;
// DE558: using guessed type int dword_DE558;
// DE55C: using guessed type int dword_DE55C;
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;
// E126C: using guessed type char byte_E126C;
// E126D: using guessed type char byte_E126D;
// E9C38: using guessed type int dword_E9C38;
// F2C54: using guessed type int dword_F2C54;
// F2C5C: using guessed type int dword_F2C5C;
// F2C60: using guessed type int dword_F2C60;
// F2C64: using guessed type int dword_F2C64;
// F2C68: using guessed type int dword_F2C68;
// F2C6C: using guessed type int dword_F2C6C;
// F2C74: using guessed type int dword_F2C74;
// F2C78: using guessed type int dword_F2C78;
// F2C7C: using guessed type int dword_F2C7C;
// F2C80: using guessed type int dword_F2C80;
// F2CA0: using guessed type int dword_F2CA0;
// F2CA8: using guessed type int dword_F2CA8;
// F2CB0: using guessed type int dword_F2CB0;
// F2CC0: using guessed type __int16 word_F2CC0;
// F2CC2: using guessed type __int16 word_F2CC2;
// F2CC4: using guessed type __int16 word_F2CC4;
// F2CC7: using guessed type char byte_F2CC7;
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (0003E360) --------------------------------------------------------
unsigned __int16 __usercall sub_3E360@<ax>(int a1@<esi>, int a2)
{
  unsigned __int16 result; // ax
  int v3; // eax
  __int16 v4; // cx
  int v5; // ecx
  int v6; // edx
  __int16 *v7; // edi
  int v8; // ecx
  char v9; // al
  int v10; // ebx
  int v11; // eax
  int v12; // ebx
  int v13; // ebx
  int v14; // eax
  int v15; // ebx
  int v16; // ebx
  int v17; // ebx
  int v18; // eax
  int v19; // eax
  int v20; // edx
  int v21; // eax
  int v22; // ebx
  int v23; // edx
  unsigned __int16 v24; // ax
  int v25; // edx
  unsigned __int16 v26; // ax
  int v27; // ebx
  int v28; // eax
  int v29; // edx
  int v30; // eax
  int v31; // ebx
  int v32; // edx
  int v33; // eax
  int v34; // eax
  int v35; // ebx
  char v36; // ch
  unsigned __int8 v37; // al
  int v38; // ecx
  int v39; // eax
  int v40; // eax
  int v41; // ecx
  __int16 *v42; // ebx
  int v43; // edx
  __int16 *v44; // edi
  int v45; // ecx
  char v46; // al
  int v47; // ebx
  int v48; // eax
  int v49; // ebx
  int v50; // ebx
  int *v51; // esi
  int v52; // ebx
  int v53; // ebx
  int v54; // eax
  int v55; // edx
  unsigned __int16 v56; // ax
  int v57; // eax
  int v58; // eax
  int v59; // edx
  int v60; // eax
  int v61; // ebx
  int v62; // eax
  int v63; // edx
  int v64; // eax
  int v65; // eax
  int v66; // ebx
  int v67; // eax
  int v68; // ebx
  int v69; // edx
  int v70; // eax
  int v71; // eax
  int v72; // edx
  unsigned __int16 v73; // ax
  int v74; // ebx
  __int16 v75; // cx
  unsigned __int8 v76; // al
  char v77; // cl
  int v78; // eax
  int v79; // eax
  int v80; // [esp+0h] [ebp-20h]
  int v81; // [esp+8h] [ebp-18h]
  int v82; // [esp+10h] [ebp-10h]
  int v83; // [esp+10h] [ebp-10h]
  int v84; // [esp+14h] [ebp-Ch]
  int v85; // [esp+18h] [ebp-8h]
  int v86; // [esp+1Ch] [ebp-4h]

  result = *(_WORD *)(a2 + 36);
  do
  {
    v3 = dword_EA3E4[result];
    dword_F2C70 = v3;
    if ( (*(_BYTE *)(v3 + 12) & 0x21) == 0 )
    {
      v4 = *(_WORD *)(v3 + 78);
      v80 = (__int16)(*(_WORD *)(v3 + 76) - word_F2CC4);
      v81 = (__int16)(word_F2CC2 - v4);
      if ( byte_F2CC7 )
      {
        if ( !*(_BYTE *)(a2 + 43) && (*(_WORD *)(v3 + 14) & 0x808) == 0 )
        {
          v82 = sub_B5C60(*(_WORD *)(v3 + 76), v4) - dword_F2CA0;
          v5 = (dword_F2C5C * v80 - dword_F2C7C * v81) >> 16;
          v85 = (dword_F2C7C * v80 + dword_F2C5C * v81) >> 16;
          v6 = v85 * v85 + v5 * v5;
          if ( v85 > 64 && v6 < dword_F2C74 )
          {
            if ( v6 <= dword_F2C6C )
              dword_F2C20 = 0x2000;
            else
              dword_F2C20 = v6 < dword_F2C78 ? (32 * (dword_F2C78 - v6) / dword_F2C68) << 8 : 0;
            v7 = &word_D951C[7 * *(__int16 *)(dword_F2C70 + 90)];
            if ( !*((_BYTE *)v7 + 10) )
            {
              v8 = v5 * dword_F2C80 / v85;
              v83 = dword_F2C80 * v82 / v85 + dword_F2CA8;
              dword_F2C30 = ((v8 * dword_F2C64 - dword_F2C54 * v83) >> 16) + dword_F2CB0;
              dword_F2C2C = dword_F2C60 - ((dword_F2C54 * v8 + v83 * dword_F2C64) >> 16);
              v9 = *((_BYTE *)v7 + 12);
              byte_F2CC6 = 0;
              switch ( v9 )
              {
                case 0:
                  v10 = (unsigned __int16)*v7;
                  if ( dword_F66F0[v10] )
                  {
                    v11 = (unsigned __int16)*v7;
                    v12 = 4 * v10;
                  }
                  else
                  {
                    if ( !sub_71520(v10) )
                      goto LABEL_178;
                    v11 = (unsigned __int16)*v7;
                    v12 = 4 * v11;
                  }
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 2 * (v11 + v12) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                  a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7];
                  goto LABEL_51;
                case 1:
                  if ( !dword_F66F0[(unsigned __int16)*v7] && !sub_71520(*v7) )
                    goto LABEL_178;
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)*v7 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                  a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7];
                  goto LABEL_51;
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                  goto LABEL_29;
                case 17:
                  v22 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
                  if ( v22 < 8 )
                  {
                    if ( dword_F66F0[v22 + (unsigned __int16)*v7] )
                    {
                      v23 = dword_D41A4;
                      v24 = *(_WORD *)(dword_F6ED0 + 10 * (v22 + (unsigned __int16)*v7) + 8);
                    }
                    else
                    {
                      if ( !sub_71520(v22 + *v7) )
                        goto LABEL_178;
                      v23 = dword_D41A4;
                      v24 = *(_WORD *)(dword_F6ED0 + 10 * (v22 + (unsigned __int16)*v7) + 8);
                    }
                    dword_F5730[v24] = *(_DWORD *)(v23 + 26);
                    a1 = *(_DWORD *)dword_F66F0[v22 + (unsigned __int16)*v7];
                    goto LABEL_51;
                  }
                  if ( dword_F66F0[(unsigned __int16)*v7 + 15 - v22] )
                  {
                    v25 = dword_D41A4;
                    v26 = *(_WORD *)(dword_F6ED0 + 10 * ((unsigned __int16)*v7 + 15 - v22) + 8);
                  }
                  else
                  {
                    if ( !sub_71520(*v7 + 15 - v22) )
                      goto LABEL_178;
                    v25 = dword_D41A4;
                    v26 = *(_WORD *)(dword_F6ED0 + 10 * ((unsigned __int16)*v7 + 15 - v22) + 8);
                  }
                  dword_F5730[v26] = *(_DWORD *)(v25 + 26);
                  a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7 + 15 - v22];
                  dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                  dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                  dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v85;
                  dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
                  v19 = -dword_F2C40;
                  goto LABEL_72;
                case 18:
                  v27 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
                  v28 = v27 + (unsigned __int16)*v7;
                  if ( dword_F66F0[v28] )
                  {
                    v30 = *(unsigned __int16 *)(dword_F6ED0 + 10 * v28 + 8);
                    v29 = dword_D41A4;
                  }
                  else
                  {
                    if ( !sub_71520(v27 + *v7) )
                      goto LABEL_178;
                    v29 = dword_D41A4;
                    v30 = *(unsigned __int16 *)(dword_F6ED0 + 10 * (v27 + (unsigned __int16)*v7) + 8);
                  }
                  dword_F5730[v30] = *(_DWORD *)(v29 + 26);
                  a1 = *(_DWORD *)dword_F66F0[v27 + (unsigned __int16)*v7];
                  dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                  dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                  dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v85;
                  dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
                  v19 = dword_F2C40;
                  goto LABEL_72;
                case 19:
                  v17 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
                  if ( v17 >= 8 )
                  {
                    v20 = (unsigned __int8)byte_D475C[v17];
                    v21 = v20 + (unsigned __int16)*v7;
                    if ( dword_F66F0[v21] )
                    {
                      dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v21 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                    }
                    else
                    {
                      if ( !sub_71520(*v7 + (unsigned __int8)v20) )
                        goto LABEL_178;
                      dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                      + 10 * ((unsigned __int16)*v7 + (unsigned __int8)byte_D475C[v17])
                                                      + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                    }
                    a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7 + (unsigned __int8)byte_D475C[v17]];
                    dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                    dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                    dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v85;
                    dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
                    v19 = -dword_F2C40;
                  }
                  else
                  {
                    v18 = (unsigned __int8)byte_D475C[v17] + (unsigned __int16)*v7;
                    if ( dword_F66F0[v18] )
                    {
                      dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v18 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                    }
                    else
                    {
                      if ( !sub_71520(*v7 + (unsigned __int8)byte_D475C[v17]) )
                        goto LABEL_178;
                      dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                      + 10 * ((unsigned __int16)*v7 + (unsigned __int8)byte_D475C[v17])
                                                      + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                    }
                    a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7 + (unsigned __int8)byte_D475C[v17]];
                    dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                    dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                    dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v85;
                    dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
                    v19 = dword_F2C40;
                  }
                  goto LABEL_72;
                case 20:
                  v31 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
                  if ( v31 >= 8 )
                  {
                    v34 = (unsigned __int16)*v7 + (unsigned __int8)byte_D476C[v31];
                    if ( !dword_F66F0[v34] )
                    {
                      if ( !sub_71520(*v7 + (unsigned __int8)byte_D476C[v31]) )
                        goto LABEL_178;
                      v34 = (unsigned __int8)byte_D476C[v31] + (unsigned __int16)*v7;
                    }
                    dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v34 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                    a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7 + (unsigned __int8)byte_D476C[v31]];
                    dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                    dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                    dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v85;
                    dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
                    v19 = -dword_F2C40;
                  }
                  else
                  {
                    v32 = (unsigned __int8)byte_D476C[v31];
                    v33 = v32 + (unsigned __int16)*v7;
                    if ( dword_F66F0[v33] )
                    {
                      dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v33 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                    }
                    else
                    {
                      if ( !sub_71520(*v7 + (unsigned __int8)v32) )
                        goto LABEL_178;
                      dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                      + 10 * ((unsigned __int16)*v7 + (unsigned __int8)byte_D476C[v31])
                                                      + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                    }
                    a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7 + (unsigned __int8)byte_D476C[v31]];
                    dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                    dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                    dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v85;
                    dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
                    v19 = dword_F2C40;
                  }
                  goto LABEL_72;
                case 21:
                  v13 = (unsigned __int16)*v7;
                  if ( dword_F66F0[v13] )
                  {
                    v14 = (unsigned __int16)*v7;
                    v15 = 4 * v13;
                  }
                  else
                  {
                    if ( !sub_71520(v13) )
                      goto LABEL_178;
                    v14 = (unsigned __int16)*v7;
                    v15 = 4 * v14;
                  }
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 2 * (v14 + v15) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                  a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7];
                  goto LABEL_51;
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                  byte_F2CC6 = 1;
LABEL_29:
                  v16 = (unsigned __int16)*v7 + *(unsigned __int8 *)(dword_F2C70 + 92);
                  if ( dword_F66F0[v16] )
                  {
                    dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v16 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                  }
                  else
                  {
                    if ( !sub_71520(*v7 + *(unsigned __int8 *)(dword_F2C70 + 92)) )
                      goto LABEL_178;
                    dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                    + 10
                                                    * ((unsigned __int16)*v7 + *(unsigned __int8 *)(dword_F2C70 + 92))
                                                    + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                  }
                  a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v7 + *(unsigned __int8 *)(dword_F2C70 + 92)];
LABEL_51:
                  dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                  dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                  dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v85;
                  dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
                  v19 = dword_F2C40;
LABEL_72:
                  dword_F2C34 = v19;
LABEL_73:
                  v35 = dword_F2C20;
                  v36 = *(_BYTE *)a1 | 8;
                  dword_F2C28 = a1 + 6;
                  *(_BYTE *)a1 = v36;
                  if ( v35 == 0x2000 )
                    v37 = byte_D4750[*((unsigned __int8 *)v7 + 10)];
                  else
                    v37 = byte_D4756[*((unsigned __int8 *)v7 + 10)];
                  dword_F2C24 = v37;
                  v38 = dword_F2C50 >> 2;
                  dword_F2C50 >>= 2;
                  if ( dword_F2C44 > 0 && v38 > 0 )
                  {
                    v39 = dword_F2C20 >> 2;
                    if ( byte_D4320 )
                      dword_F2C20 = 0x2000 - v39;
                    else
                      dword_F2C20 = v39 + 0x2000;
                    dword_F2C24 = 8;
                    sub_41BD3(0);
                  }
                  break;
                default:
                  goto LABEL_73;
              }
            }
          }
        }
      }
      if ( *(char *)(dword_F2C70 + 15) >= 0 )
        v40 = *(__int16 *)(dword_F2C70 + 80);
      else
        v40 = *(__int16 *)(dword_F2C70 + 80) - 160;
      v86 = (dword_F2C7C * v80 + dword_F2C5C * v81) >> 16;
      v41 = (dword_F2C5C * v80 - dword_F2C7C * v81) >> 16;
      if ( (*(_BYTE *)(dword_F2C70 + 15) & 0x20) != 0 )
      {
        v42 = (__int16 *)&off_D404C + 11 * *(unsigned __int8 *)(dword_F2C70 + 59);
        switch ( (((*(unsigned __int16 *)(dword_EA3E4[*(unsigned __int16 *)(dword_F2C70 + 50)] + 28)
                  - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4 )
        {
          case 0:
          case 15:
            v86 -= v42[8];
            break;
          case 1:
          case 14:
            v86 -= v42[9];
            break;
          case 2:
          case 13:
            v86 -= v42[10];
            break;
          case 5:
          case 10:
            v86 += v42[10];
            break;
          case 6:
          case 9:
            v86 += v42[9];
            break;
          case 7:
          case 8:
            v86 += v42[8];
            break;
          default:
            break;
        }
      }
      v43 = v86 * v86 + v41 * v41;
      if ( v86 > 64 && v43 < dword_F2C74 )
      {
        if ( v43 <= dword_F2C6C )
        {
          dword_F2C20 = 0x2000;
        }
        else if ( v43 < dword_F2C78 )
        {
          dword_F2C20 = (32 * (dword_F2C78 - v43) / dword_F2C68) << 8;
        }
        else
        {
          dword_F2C20 = 0;
        }
        v44 = &word_D951C[7 * *(__int16 *)(dword_F2C70 + 90)];
        v45 = v41 * dword_F2C80 / v86;
        v84 = dword_F2C80 * (v40 - dword_F2CA0) / v86 + dword_F2CA8;
        dword_F2C30 = ((v45 * dword_F2C64 - dword_F2C54 * v84) >> 16) + dword_F2CB0;
        dword_F2C2C = dword_F2C60 - ((dword_F2C54 * v45 + v84 * dword_F2C64) >> 16);
        v46 = *((_BYTE *)v44 + 12);
        byte_F2CC6 = 0;
        switch ( v46 )
        {
          case 0:
            v47 = (unsigned __int16)*v44;
            if ( dword_F66F0[v47] )
            {
              v48 = (unsigned __int16)*v44;
              v49 = 4 * v47;
              goto LABEL_105;
            }
            if ( sub_71520(v47) )
            {
              v48 = (unsigned __int16)*v44;
              v49 = 4 * v48;
LABEL_105:
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 2 * (v48 + v49) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v44];
              goto LABEL_141;
            }
            break;
          case 1:
            if ( dword_F66F0[(unsigned __int16)*v44] )
            {
              dword_F5730[*(unsigned __int16 *)(10 * (unsigned __int16)*v44 + dword_F6ED0 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            else
            {
              if ( !sub_71520(*v44) )
                break;
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)*v44 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v44];
            goto LABEL_141;
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
          case 15:
          case 16:
            goto LABEL_117;
          case 17:
            v61 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
            if ( (*(_BYTE *)(dword_F2C70 + 15) & 0x40) != 0 )
              v61 = (unsigned __int8)byte_D477C[v61];
            if ( v61 < 8 )
            {
              v62 = v61 + (unsigned __int16)*v44;
              if ( dword_F66F0[v62] )
              {
                v63 = dword_D41A4;
                v64 = *(unsigned __int16 *)(dword_F6ED0 + 10 * v62 + 8);
              }
              else
              {
                if ( !sub_71520(v61 + *v44) )
                  break;
                v63 = dword_D41A4;
                v64 = *(unsigned __int16 *)(dword_F6ED0 + 10 * (v61 + (unsigned __int16)*v44) + 8);
              }
              dword_F5730[v64] = *(_DWORD *)(v63 + 26);
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v44 + v61];
              goto LABEL_141;
            }
            v65 = (unsigned __int16)*v44 + 15 - v61;
            if ( dword_F66F0[v65] )
            {
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v65 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            else
            {
              if ( !sub_71520(*v44 + 15 - v61) )
                break;
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * ((unsigned __int16)*v44 + 15 - v61) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v44 + 15 - v61];
            dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
            dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
            dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v44[4]) / v86;
            dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
            v57 = -dword_F2C40;
            goto LABEL_163;
          case 18:
            v66 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
            v67 = v66 + (unsigned __int16)*v44;
            if ( dword_F66F0[v67] )
            {
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v67 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            else
            {
              if ( !sub_71520(v66 + *v44) )
                break;
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (v66 + (unsigned __int16)*v44) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            a1 = *(_DWORD *)dword_F66F0[v66 + (unsigned __int16)*v44];
            dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
            dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
            dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v44[4]) / v86;
            dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
            v57 = dword_F2C40;
            goto LABEL_163;
          case 19:
            v53 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
            if ( v53 >= 8 )
            {
              v58 = (unsigned __int16)*v44 + (unsigned __int8)byte_D475C[v53];
              if ( dword_F66F0[v58] )
              {
                v60 = *(unsigned __int16 *)(dword_F6ED0 + 10 * v58 + 8);
                v59 = dword_D41A4;
              }
              else
              {
                if ( !sub_71520(*v44 + (unsigned __int8)byte_D475C[v53]) )
                  break;
                v59 = dword_D41A4;
                v60 = *(unsigned __int16 *)(dword_F6ED0
                                          + 10 * ((unsigned __int16)*v44 + (unsigned __int8)byte_D475C[v53])
                                          + 8);
              }
              dword_F5730[v60] = *(_DWORD *)(v59 + 26);
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v44 + (unsigned __int8)byte_D475C[v53]];
              dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
              dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
              dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v44[4]) / v86;
              dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
              v57 = -dword_F2C40;
            }
            else
            {
              v54 = (unsigned __int16)*v44 + (unsigned __int8)byte_D475C[v53];
              if ( dword_F66F0[v54] )
              {
                v55 = dword_D41A4;
                v56 = *(_WORD *)(dword_F6ED0 + 10 * v54 + 8);
              }
              else
              {
                if ( !sub_71520(*v44 + (unsigned __int8)byte_D475C[v53]) )
                  break;
                v55 = dword_D41A4;
                v56 = *(_WORD *)(dword_F6ED0 + 10 * ((unsigned __int8)byte_D475C[v53] + (unsigned __int16)*v44) + 8);
              }
              dword_F5730[v56] = *(_DWORD *)(v55 + 26);
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v44 + (unsigned __int8)byte_D475C[v53]];
              dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
              dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
              dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v44[4]) / v86;
              dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
              v57 = dword_F2C40;
            }
            goto LABEL_163;
          case 20:
            v68 = (((*(unsigned __int16 *)(dword_F2C70 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
            if ( v68 >= 8 )
            {
              v71 = (unsigned __int8)byte_D476C[v68] + (unsigned __int16)*v44;
              if ( dword_F66F0[v71] )
              {
                v72 = dword_D41A4;
                v73 = *(_WORD *)(dword_F6ED0 + 10 * v71 + 8);
              }
              else
              {
                if ( !sub_71520(*v44 + (unsigned __int8)byte_D476C[v68]) )
                  break;
                v72 = dword_D41A4;
                v73 = *(_WORD *)(dword_F6ED0 + 10 * ((unsigned __int16)*v44 + (unsigned __int8)byte_D476C[v68]) + 8);
              }
              dword_F5730[v73] = *(_DWORD *)(v72 + 26);
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v44 + (unsigned __int8)byte_D476C[v68]];
              dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
              dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
              dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v44[4]) / v86;
              dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
              v57 = -dword_F2C40;
            }
            else
            {
              v69 = (unsigned __int8)byte_D476C[v68];
              v70 = v69 + (unsigned __int16)*v44;
              if ( dword_F66F0[v70] )
              {
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v70 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              else
              {
                if ( !sub_71520(*v44 + (unsigned __int8)v69) )
                  break;
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                + 10 * ((unsigned __int16)*v44 + (unsigned __int8)byte_D476C[v68])
                                                + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v44 + (unsigned __int8)byte_D476C[v68]];
              dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
              dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
              dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v44[4]) / v86;
              dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
              v57 = dword_F2C40;
            }
            goto LABEL_163;
          case 21:
            v50 = (unsigned __int16)*v44;
            if ( dword_F66F0[v50] )
            {
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v50 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            else
            {
              if ( !sub_71520(v50) )
                break;
              dword_F5730[*(unsigned __int16 *)(10 * (unsigned __int16)*v44 + dword_F6ED0 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            v51 = (int *)dword_F66F0[(unsigned __int16)*v44];
            byte_F2CC6 = 1;
            a1 = *v51;
            goto LABEL_141;
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
          case 28:
          case 29:
          case 30:
          case 31:
          case 32:
          case 33:
          case 34:
          case 35:
          case 36:
            byte_F2CC6 = 1;
LABEL_117:
            v52 = (unsigned __int16)*v44 + *(unsigned __int8 *)(dword_F2C70 + 92);
            if ( dword_F66F0[v52] )
            {
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v52 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            else
            {
              if ( !sub_71520(*v44 + *(unsigned __int8 *)(dword_F2C70 + 92)) )
                break;
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                              + 10 * ((unsigned __int16)*v44 + *(unsigned __int8 *)(dword_F2C70 + 92))
                                              + 8)] = *(_DWORD *)(dword_D41A4 + 26);
            }
            a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v44 + *(unsigned __int8 *)(dword_F2C70 + 92)];
LABEL_141:
            dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
            dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
            dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v44[4]) / v86;
            dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
            v57 = dword_F2C40;
LABEL_163:
            dword_F2C34 = v57;
LABEL_164:
            v74 = dword_F2C70;
            *(_BYTE *)a1 |= 8u;
            v75 = *(_WORD *)(v74 + 14);
            dword_F2C28 = a1 + 6;
            if ( (v75 & 0x380) != 0 )
            {
              v77 = *(_BYTE *)(v74 + 15);
              if ( (v77 & 2) != 0 )
              {
                v78 = (unsigned __int8)byte_E88E2[3
                                                * *(__int16 *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(v74 + 40)]
                                                                         + 164)
                                                             + 56)];
                dword_F2C24 = 4;
                dword_F2C3C = v78;
              }
              else if ( (v77 & 4) != 0 )
              {
                v79 = (unsigned __int8)byte_E88E2[3
                                                * *(__int16 *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(v74 + 40)]
                                                                         + 164)
                                                             + 56)];
                dword_F2C24 = 5;
                dword_F2C3C = v79;
              }
              else if ( *(char *)(v74 + 14) >= 0 )
              {
                if ( (v77 & 1) != 0 )
                  dword_F2C24 = 3;
              }
              else
              {
                dword_F2C24 = 2;
              }
            }
            else
            {
              if ( dword_F2C20 == 0x2000 )
                v76 = byte_D4750[*((unsigned __int8 *)v44 + 10)];
              else
                v76 = byte_D4756[*((unsigned __int8 *)v44 + 10)];
              dword_F2C24 = v76;
            }
            ++dword_F2C44;
            ++dword_F2C50;
            sub_41BD3(1u);
            break;
          default:
            goto LABEL_164;
        }
      }
    }
LABEL_178:
    result = *(_WORD *)(dword_F2C70 + 22);
  }
  while ( result );
  return result;
}
// D404C: using guessed type void *off_D404C;
// D41A4: using guessed type int dword_D41A4;
// D4320: using guessed type char byte_D4320;
// D951C: using guessed type __int16 word_D951C[];
// EA3E4: using guessed type int dword_EA3E4[];
// F2C20: using guessed type int dword_F2C20;
// F2C24: using guessed type int dword_F2C24;
// F2C28: using guessed type int dword_F2C28;
// F2C2C: using guessed type int dword_F2C2C;
// F2C30: using guessed type int dword_F2C30;
// F2C34: using guessed type int dword_F2C34;
// F2C38: using guessed type int dword_F2C38;
// F2C3C: using guessed type int dword_F2C3C;
// F2C40: using guessed type int dword_F2C40;
// F2C44: using guessed type int dword_F2C44;
// F2C50: using guessed type int dword_F2C50;
// F2C54: using guessed type int dword_F2C54;
// F2C5C: using guessed type int dword_F2C5C;
// F2C60: using guessed type int dword_F2C60;
// F2C64: using guessed type int dword_F2C64;
// F2C68: using guessed type int dword_F2C68;
// F2C6C: using guessed type int dword_F2C6C;
// F2C70: using guessed type int dword_F2C70;
// F2C74: using guessed type int dword_F2C74;
// F2C78: using guessed type int dword_F2C78;
// F2C7C: using guessed type int dword_F2C7C;
// F2C80: using guessed type int dword_F2C80;
// F2CA0: using guessed type int dword_F2CA0;
// F2CA8: using guessed type int dword_F2CA8;
// F2CB0: using guessed type int dword_F2CB0;
// F2CC0: using guessed type __int16 word_F2CC0;
// F2CC2: using guessed type __int16 word_F2CC2;
// F2CC4: using guessed type __int16 word_F2CC4;
// F2CC6: using guessed type char byte_F2CC6;
// F2CC7: using guessed type char byte_F2CC7;
// F5730: using guessed type int dword_F5730[504];
// F66F0: using guessed type int dword_F66F0[504];
// F6ED0: using guessed type int dword_F6ED0;

//----- (0003FD60) --------------------------------------------------------
unsigned __int16 __usercall sub_3FD60@<ax>(int a1@<edi>, int a2)
{
  unsigned __int16 result; // ax
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // ecx
  int v7; // edx
  __int16 *v8; // esi
  int v9; // ecx
  char v10; // al
  int v11; // ebx
  int v12; // eax
  int v13; // ebx
  int v14; // ebx
  int *v15; // edi
  int v16; // eax
  int v17; // ebx
  int v18; // edx
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // ebx
  int v23; // ebx
  int v24; // eax
  int v25; // ebx
  int v26; // eax
  int v27; // eax
  char v28; // cl
  int v29; // eax
  unsigned __int8 v30; // al
  int v31; // [esp+0h] [ebp-Ch]
  int v32; // [esp+4h] [ebp-8h]
  int v33; // [esp+8h] [ebp-4h]
  int v34; // [esp+8h] [ebp-4h]

  result = *(_WORD *)(a2 + 36);
  do
  {
    if ( result < 0x3E8u )
    {
      v3 = dword_EA3E4[result];
      v32 = v3;
      if ( (*(_BYTE *)(v3 + 12) & 0x21) == 0 )
      {
        v4 = (__int16)(*(_WORD *)(v3 + 76) - word_F2CC4);
        v5 = (__int16)(word_F2CC2 - *(_WORD *)(v3 + 78));
        v33 = -*(__int16 *)(v32 + 80) - dword_F2CA0;
        v6 = (v4 * dword_F2C5C - v5 * dword_F2C7C) >> 16;
        v31 = (dword_F2C7C * v4 + dword_F2C5C * v5) >> 16;
        v7 = v31 * v31 + v6 * v6;
        if ( v31 > 64 && v7 < dword_F2C74 )
        {
          if ( v7 <= dword_F2C6C )
          {
            dword_F2C20 = 0x2000;
          }
          else if ( v7 < dword_F2C78 )
          {
            dword_F2C20 = (32 * (dword_F2C78 - v7) / dword_F2C68) << 8;
          }
          else
          {
            dword_F2C20 = 0;
          }
          v8 = &word_D951C[7 * *(__int16 *)(v32 + 90)];
          v9 = v6 * dword_F2C80 / v31;
          v34 = dword_F2C80 * v33 / v31 + dword_F2CA8;
          dword_F2C30 = ((v9 * dword_F2C64 - dword_F2C54 * v34) >> 16) + dword_F2CB0;
          dword_F2C2C = dword_F2C60 - ((dword_F2C54 * v9 + v34 * dword_F2C64) >> 16);
          v10 = *((_BYTE *)v8 + 12);
          byte_F2CC6 = 0;
          switch ( v10 )
          {
            case 0:
              v11 = (unsigned __int16)*v8;
              if ( dword_F66F0[v11] )
              {
                v12 = (unsigned __int16)*v8;
                v13 = 4 * v11;
                goto LABEL_16;
              }
              if ( sub_71520(v11) )
              {
                v12 = (unsigned __int16)*v8;
                v13 = 4 * v12;
LABEL_16:
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 2 * (v12 + v13) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v8];
                goto LABEL_47;
              }
              break;
            case 1:
              if ( !dword_F66F0[(unsigned __int16)*v8] && !sub_71520(*v8) )
                break;
              dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)*v8 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v8];
              goto LABEL_47;
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
              goto LABEL_26;
            case 17:
              v22 = (((*(unsigned __int16 *)(v32 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
              if ( v22 < 8 )
              {
                if ( dword_F66F0[v22 + (unsigned __int16)*v8] )
                {
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (v22 + (unsigned __int16)*v8) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                else
                {
                  if ( !sub_71520(v22 + *v8) )
                    break;
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (v22 + (unsigned __int16)*v8) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                a1 = *(_DWORD *)dword_F66F0[v22 + (unsigned __int16)*v8];
                goto LABEL_47;
              }
              if ( dword_F66F0[(unsigned __int16)*v8 + 15 - v22] )
              {
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * ((unsigned __int16)*v8 + 15 - v22) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              else
              {
                if ( !sub_71520(*v8 + 15 - v22) )
                  break;
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * ((unsigned __int16)*v8 + 15 - v22) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v8 + 15 - v22];
              dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
              dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
              dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v8[4]) / v31;
              dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
              v20 = -dword_F2C40;
              goto LABEL_69;
            case 18:
              v23 = (((*(unsigned __int16 *)(v32 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
              v24 = v23 + (unsigned __int16)*v8;
              if ( dword_F66F0[v24] )
              {
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v24 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              else
              {
                if ( !sub_71520(v23 + *v8) )
                  break;
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (v23 + (unsigned __int16)*v8) + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v8 + v23];
              dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
              dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
              dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v8[4]) / v31;
              dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
              v20 = dword_F2C40;
              goto LABEL_69;
            case 19:
              v17 = (((*(unsigned __int16 *)(v32 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
              if ( v17 >= 8 )
              {
                v21 = (unsigned __int16)*v8 + (unsigned __int8)byte_D475C[v17];
                if ( !dword_F66F0[v21] )
                {
                  if ( !sub_71520(*v8 + (unsigned __int8)byte_D475C[v17]) )
                    break;
                  v21 = (unsigned __int16)*v8 + (unsigned __int8)byte_D475C[v17];
                }
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v21 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v8 + (unsigned __int8)byte_D475C[v17]];
                dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v8[4]) / v31;
                dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
                v20 = -dword_F2C40;
              }
              else
              {
                v18 = (unsigned __int8)byte_D475C[v17];
                v19 = v18 + (unsigned __int16)*v8;
                if ( dword_F66F0[v19] )
                {
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v19 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                else
                {
                  if ( !sub_71520(*v8 + (unsigned __int8)v18) )
                    break;
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                  + 10 * ((unsigned __int16)*v8 + (unsigned __int8)byte_D475C[v17])
                                                  + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v8 + (unsigned __int8)byte_D475C[v17]];
                dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v8[4]) / v31;
                dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
                v20 = dword_F2C40;
              }
              goto LABEL_69;
            case 20:
              v25 = (((*(unsigned __int16 *)(v32 + 28) - (unsigned __int16)word_F2CC0) >> 3) & 0xF0) >> 4;
              if ( v25 >= 8 )
              {
                v27 = (unsigned __int16)*v8 + (unsigned __int8)byte_D476C[v25];
                if ( dword_F66F0[v27] )
                {
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v27 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                else
                {
                  if ( !sub_71520(*v8 + (unsigned __int8)byte_D476C[v25]) )
                    break;
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                  + 10 * ((unsigned __int16)*v8 + (unsigned __int8)byte_D476C[v25])
                                                  + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                a1 = *(_DWORD *)dword_F66F0[(unsigned __int8)byte_D476C[v25] + (unsigned __int16)*v8];
                dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v8[4]) / v31;
                dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
                v20 = -dword_F2C40;
              }
              else
              {
                v26 = (unsigned __int16)*v8 + (unsigned __int8)byte_D476C[v25];
                if ( dword_F66F0[v26] )
                {
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v26 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                else
                {
                  if ( !sub_71520(*v8 + (unsigned __int8)byte_D476C[v25]) )
                    break;
                  dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                  + 10 * ((unsigned __int16)*v8 + (unsigned __int8)byte_D476C[v25])
                                                  + 8)] = *(_DWORD *)(dword_D41A4 + 26);
                }
                a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v8 + (unsigned __int8)byte_D476C[v25]];
                dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
                dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
                dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v8[4]) / v31;
                dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
                v20 = dword_F2C40;
              }
              goto LABEL_69;
            case 21:
              v14 = (unsigned __int16)*v8;
              if ( dword_F66F0[v14] )
              {
                dword_F5730[*(unsigned __int16 *)(10 * v14 + dword_F6ED0 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              else
              {
                if ( !sub_71520(v14) )
                  break;
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)*v8 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              v15 = (int *)dword_F66F0[(unsigned __int16)*v8];
              byte_F2CC6 = 1;
              a1 = *v15;
              goto LABEL_47;
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
              byte_F2CC6 = 1;
LABEL_26:
              v16 = *(unsigned __int8 *)(v32 + 92) + (unsigned __int16)*v8;
              if ( dword_F66F0[v16] )
              {
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0 + 10 * v16 + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              else
              {
                if ( !sub_71520(*v8 + *(unsigned __int8 *)(v32 + 92)) )
                  break;
                dword_F5730[*(unsigned __int16 *)(dword_F6ED0
                                                + 10 * ((unsigned __int16)*v8 + *(unsigned __int8 *)(v32 + 92))
                                                + 8)] = *(_DWORD *)(dword_D41A4 + 26);
              }
              a1 = *(_DWORD *)dword_F66F0[(unsigned __int16)*v8 + *(unsigned __int8 *)(v32 + 92)];
LABEL_47:
              dword_F2C40 = *(unsigned __int16 *)(a1 + 2);
              dword_F2C38 = *(unsigned __int16 *)(a1 + 4);
              dword_F2C50 = (__int64)(dword_F2C80 * (unsigned __int64)(unsigned __int16)v8[4]) / v31;
              dword_F2C44 = dword_F2C50 * dword_F2C40 / dword_F2C38;
              v20 = dword_F2C40;
LABEL_69:
              dword_F2C34 = v20;
LABEL_70:
              v28 = *(_BYTE *)a1 | 8;
              dword_F2C28 = a1 + 6;
              v29 = dword_F2C20;
              *(_BYTE *)a1 = v28;
              if ( v29 == 0x2000 )
                v30 = byte_D4750[*((unsigned __int8 *)v8 + 10)];
              else
                v30 = byte_D4756[*((unsigned __int8 *)v8 + 10)];
              dword_F2C24 = v30;
              ++dword_F2C44;
              ++dword_F2C50;
              sub_41BD3(2u);
              break;
            default:
              goto LABEL_70;
          }
        }
      }
    }
    result = *(_WORD *)(v32 + 22);
  }
  while ( result );
  return result;
}
// 4092E: variable 'v32' is possibly undefined
// D41A4: using guessed type int dword_D41A4;
// D951C: using guessed type __int16 word_D951C[];
// EA3E4: using guessed type int dword_EA3E4[];
// F2C20: using guessed type int dword_F2C20;
// F2C24: using guessed type int dword_F2C24;
// F2C28: using guessed type int dword_F2C28;
// F2C2C: using guessed type int dword_F2C2C;
// F2C30: using guessed type int dword_F2C30;
// F2C34: using guessed type int dword_F2C34;
// F2C38: using guessed type int dword_F2C38;
// F2C40: using guessed type int dword_F2C40;
// F2C44: using guessed type int dword_F2C44;
// F2C50: using guessed type int dword_F2C50;
// F2C54: using guessed type int dword_F2C54;
// F2C5C: using guessed type int dword_F2C5C;
// F2C60: using guessed type int dword_F2C60;
// F2C64: using guessed type int dword_F2C64;
// F2C68: using guessed type int dword_F2C68;
// F2C6C: using guessed type int dword_F2C6C;
// F2C74: using guessed type int dword_F2C74;
// F2C78: using guessed type int dword_F2C78;
// F2C7C: using guessed type int dword_F2C7C;
// F2C80: using guessed type int dword_F2C80;
// F2CA0: using guessed type int dword_F2CA0;
// F2CA8: using guessed type int dword_F2CA8;
// F2CB0: using guessed type int dword_F2CB0;
// F2CC0: using guessed type __int16 word_F2CC0;
// F2CC2: using guessed type __int16 word_F2CC2;
// F2CC4: using guessed type __int16 word_F2CC4;
// F2CC6: using guessed type char byte_F2CC6;
// F5730: using guessed type int dword_F5730[504];
// F66F0: using guessed type int dword_F66F0[504];
// F6ED0: using guessed type int dword_F6ED0;

//----- (00040950) --------------------------------------------------------
__int16 __cdecl sub_40950(__int16 a1)
{
  int v1; // ebx
  int v2; // edx
  int v3; // esi
  int v4; // ebx
  char *v5; // edx
  int v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // ebx
  int v10; // edx
  __int16 result; // ax
  int v12; // eax
  char *v13; // esi
  int *v14; // edi
  char *v15; // edx
  int v16; // ecx
  int v17; // ebx
  int v18; // eax
  char v19[1280]; // [esp+0h] [ebp-52Ch] BYREF
  int v20; // [esp+500h] [ebp-2Ch]
  int v21; // [esp+504h] [ebp-28h]
  int *v22; // [esp+508h] [ebp-24h]
  int v23; // [esp+50Ch] [ebp-20h]
  int v24; // [esp+510h] [ebp-1Ch]
  int v25; // [esp+514h] [ebp-18h]
  int v26; // [esp+518h] [ebp-14h]
  int v27; // [esp+51Ch] [ebp-10h]
  char v28; // [esp+520h] [ebp-Ch]
  char v29; // [esp+524h] [ebp-8h]
  unsigned __int8 v30; // [esp+528h] [ebp-4h]

  v1 = a1 & 0x7FF;
  v2 = (_DWORD)off_DBF50[v1] << 8;
  v26 = (dword_DB750[v1] << 8) / (unsigned __int16)dword_DE564;
  v3 = 0;
  v25 = v2 / (unsigned __int16)dword_DE564;
  v4 = 0;
  v29 = 0;
  v5 = v19;
  v30 = 0;
  v6 = (unsigned __int16)dword_DE564;
  while ( v6 )
  {
    v28 = BYTE2(v3);
    *v5 = BYTE2(v3) - v29;
    v21 = BYTE2(v4);
    v20 = BYTE2(v4) - v30;
    v5 += 2;
    --v6;
    *(v5 - 1) = BYTE2(v4) - v30;
    v29 = v28;
    v30 = BYTE2(v4);
    v4 += v26;
    v3 += v25;
  }
  v7 = (-(dword_F2C54 * dword_F2CA8) >> 16) + dword_F2CB0;
  v8 = dword_F2C60 - ((dword_F2C64 * dword_F2CA8) >> 16);
  v9 = ((unsigned __int16)word_F2CC0 << 15) - (v7 * v25 - v8 * v26);
  v10 = v25 * v8 + v26 * v7;
  v23 = v9;
  v22 = (int *)dword_DE558;
  result = dword_DE568;
  v27 = -v10;
  v24 = (unsigned __int16)dword_DE568;
  if ( (_WORD)dword_DE568 )
  {
    do
    {
      v12 = (int)(unsigned __int16)dword_DE564 >> 2;
      v13 = v19;
      v20 = v27 >> 16;
      v14 = v22;
      v21 = v23 >> 16;
      v15 = off_D41A8;
      BYTE1(v17) = BYTE2(v27);
      v16 = v12;
      LOBYTE(v17) = BYTE2(v23);
      v17 = (unsigned __int16)v17;
      do
      {
        LOBYTE(v12) = v15[v17];
        LOBYTE(v17) = *v13 + v17;
        BYTE1(v17) += v13[1];
        BYTE1(v12) = v15[v17];
        LOBYTE(v17) = v13[2] + v17;
        BYTE1(v17) += v13[3];
        v18 = v12 << 16;
        LOBYTE(v18) = v15[v17];
        LOBYTE(v17) = v13[4] + v17;
        BYTE1(v17) += v13[5];
        BYTE1(v18) = v15[v17];
        LOBYTE(v17) = v13[6] + v17;
        BYTE1(v17) += v13[7];
        v12 = __ROL4__(v18, 16);
        *v14++ = v12;
        v13 += 8;
        --v16;
      }
      while ( v16 );
      v22 = (int *)((char *)v22 + dword_DE560);
      result = v25;
      --v24;
      v23 -= v26;
      v27 += v25;
    }
    while ( v24 );
  }
  return result;
}
// D41A8: using guessed type char *off_D41A8;
// DB750: using guessed type int dword_DB750[256];
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// DE558: using guessed type int dword_DE558;
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;
// F2C54: using guessed type int dword_F2C54;
// F2C60: using guessed type int dword_F2C60;
// F2C64: using guessed type int dword_F2C64;
// F2CA8: using guessed type int dword_F2CA8;
// F2CB0: using guessed type int dword_F2CB0;
// F2CC0: using guessed type __int16 word_F2CC0;

//----- (00040BF0) --------------------------------------------------------
int __cdecl sub_40BF0(int a1, int a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // eax
  int v6; // ecx
  int v7; // edx
  int result; // eax

  v4 = a1;
  v5 = a2;
  LOWORD(v6) = a3;
  LOWORD(v7) = a4;
  if ( (word_180660 & 1) != 0 )
  {
    v4 = a1 >> 1;
    v5 = a2 >> 1;
    v6 = a3 >> 1;
    v7 = a4 >> 1;
  }
  dword_F2C58 = v4 + dword_18062C * v5;
  result = dword_F2C58 + dword_180628;
  sub_BCD45(dword_F2C58 + dword_180628, 0, dword_18062C, (unsigned __int16)v6, (unsigned __int16)v7);
  return result;
}
// F2C58: using guessed type int dword_F2C58;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (00040C50) --------------------------------------------------------
int __cdecl sub_40C50(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // eax
  unsigned __int16 v4; // bx
  int result; // eax
  int v6; // [esp-4h] [ebp-4h]

  v1 = 40 - a1;
  if ( (word_180660 & 1) != 0 )
  {
    v2 = dword_18062C * (5 * v1 / 2) + 4 * v1;
    v3 = (unsigned __int16)(5 * a1);
    v4 = 8 * a1;
  }
  else
  {
    v2 = dword_18062C * (12 * v1 / 2) + 8 * v1;
    v3 = (unsigned __int16)(12 * a1);
    v4 = 16 * a1;
  }
  v6 = v3;
  result = v2 + dword_180628;
  dword_F2C58 = v2;
  sub_BCD45(v2 + dword_180628, 0, dword_18062C, v4, v6);
  return result;
}
// F2C58: using guessed type int dword_F2C58;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (00040D10) --------------------------------------------------------
int __fastcall sub_40D10(int a1)
{
  int v1; // ebx
  int v2; // ecx
  _BYTE *v3; // esi
  int *v4; // edi
  int v5; // ecx
  _BYTE *v6; // esi
  int *v7; // edi
  int v8; // ecx
  int *v9; // edi
  _BYTE *v10; // esi
  int v11; // ecx
  int *v12; // edi
  _BYTE *v13; // esi
  int v14; // ecx
  int *v15; // edi
  _BYTE *v16; // esi
  int v17; // ecx
  int *v18; // edi
  _BYTE *v19; // esi
  int v20; // ecx
  int *v21; // edi
  _BYTE *v22; // esi
  int v23; // ecx
  int *v24; // edi
  _BYTE *v25; // esi
  int result; // eax
  int v27; // [esp+4h] [ebp-10h]
  int v28; // [esp+8h] [ebp-Ch]
  int v29; // [esp+Ch] [ebp-8h]
  int *v30; // [esp+10h] [ebp-4h]

  __outword(0x3CEu, 0xFF08u);
  HIWORD(v1) = 0;
  v30 = (int *)&loc_A0000;
  v28 = dword_180628;
  v27 = 200;
  v29 = dword_E9C3C;
  while ( v27 )
  {
    v2 = 10;
    v3 = (_BYTE *)v28;
    v4 = v30;
    __outword(0x3C4u, 0x102u);
    do
    {
      LOBYTE(a1) = v3[8];
      LOBYTE(v1) = v3[24];
      BYTE1(a1) = v3[12];
      BYTE1(v1) = v3[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v3;
      LOBYTE(v1) = v3[16];
      BYTE1(a1) = v3[4];
      BYTE1(v1) = v3[20];
      *v4 = a1;
      v4[1] = v1;
      v3 += 32;
      v4 += 2;
      --v2;
    }
    while ( v2 );
    v5 = 10;
    v6 = (_BYTE *)v29;
    v7 = v30 + 20;
    do
    {
      LOBYTE(a1) = v6[8];
      LOBYTE(v1) = v6[24];
      BYTE1(a1) = v6[12];
      BYTE1(v1) = v6[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v6;
      LOBYTE(v1) = v6[16];
      BYTE1(a1) = v6[4];
      BYTE1(v1) = v6[20];
      *v7 = a1;
      v7[1] = v1;
      v6 += 32;
      v7 += 2;
      --v5;
    }
    while ( v5 );
    v8 = 10;
    v9 = v30;
    v10 = (_BYTE *)(v28 + 1);
    __outword(0x3C4u, 0x202u);
    do
    {
      LOBYTE(a1) = v10[8];
      LOBYTE(v1) = v10[24];
      BYTE1(a1) = v10[12];
      BYTE1(v1) = v10[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v10;
      LOBYTE(v1) = v10[16];
      BYTE1(a1) = v10[4];
      BYTE1(v1) = v10[20];
      *v9 = a1;
      v9[1] = v1;
      v10 += 32;
      v9 += 2;
      --v8;
    }
    while ( v8 );
    v11 = 10;
    v12 = v30 + 20;
    v13 = (_BYTE *)(v29 + 1);
    do
    {
      LOBYTE(a1) = v13[8];
      LOBYTE(v1) = v13[24];
      BYTE1(a1) = v13[12];
      BYTE1(v1) = v13[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v13;
      LOBYTE(v1) = v13[16];
      BYTE1(a1) = v13[4];
      BYTE1(v1) = v13[20];
      *v12 = a1;
      v12[1] = v1;
      v13 += 32;
      v12 += 2;
      --v11;
    }
    while ( v11 );
    v14 = 10;
    v15 = v30;
    v16 = (_BYTE *)(v28 + 2);
    __outword(0x3C4u, 0x402u);
    do
    {
      LOBYTE(a1) = v16[8];
      LOBYTE(v1) = v16[24];
      BYTE1(a1) = v16[12];
      BYTE1(v1) = v16[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v16;
      LOBYTE(v1) = v16[16];
      BYTE1(a1) = v16[4];
      BYTE1(v1) = v16[20];
      *v15 = a1;
      v15[1] = v1;
      v16 += 32;
      v15 += 2;
      --v14;
    }
    while ( v14 );
    v17 = 10;
    v18 = v30 + 20;
    v19 = (_BYTE *)(v29 + 2);
    do
    {
      LOBYTE(a1) = v19[8];
      LOBYTE(v1) = v19[24];
      BYTE1(a1) = v19[12];
      BYTE1(v1) = v19[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v19;
      LOBYTE(v1) = v19[16];
      BYTE1(a1) = v19[4];
      BYTE1(v1) = v19[20];
      *v18 = a1;
      v18[1] = v1;
      v19 += 32;
      v18 += 2;
      --v17;
    }
    while ( v17 );
    v20 = 10;
    v21 = v30;
    v22 = (_BYTE *)(v28 + 3);
    __outword(0x3C4u, 0x802u);
    do
    {
      LOBYTE(a1) = v22[8];
      LOBYTE(v1) = v22[24];
      BYTE1(a1) = v22[12];
      BYTE1(v1) = v22[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v22;
      LOBYTE(v1) = v22[16];
      BYTE1(a1) = v22[4];
      BYTE1(v1) = v22[20];
      *v21 = a1;
      v21[1] = v1;
      v22 += 32;
      v21 += 2;
      --v20;
    }
    while ( v20 );
    v23 = 10;
    v24 = v30 + 20;
    v25 = (_BYTE *)(v29 + 3);
    do
    {
      LOBYTE(a1) = v25[8];
      LOBYTE(v1) = v25[24];
      BYTE1(a1) = v25[12];
      BYTE1(v1) = v25[28];
      a1 = __ROL4__(a1, 16);
      v1 = __ROL4__(v1, 16);
      LOBYTE(a1) = *v25;
      LOBYTE(v1) = v25[16];
      BYTE1(a1) = v25[4];
      BYTE1(v1) = v25[20];
      *v24 = a1;
      v24[1] = v1;
      v25 += 32;
      v24 += 2;
      --v23;
    }
    while ( v23 );
    a1 = v27 - 1;
    v28 += 320;
    v29 += 320;
    v30 += 40;
    --v27;
  }
  result = 0;
  memset((void *)dword_180628, 0, 0xFA00u);
  return result;
}
// E9C3C: using guessed type int dword_E9C3C;
// 180628: using guessed type int dword_180628;

//----- (00040F80) --------------------------------------------------------
void sub_40F80()
{
  int v0; // eax
  int v1; // ecx
  _BYTE *v2; // esi
  _BYTE *v3; // edi
  int v4; // edx
  int v5; // ebx
  int v6; // eax
  int v7; // ecx
  _BYTE *v8; // esi
  _BYTE *v9; // edi
  int v10; // edx
  int v11; // ebx
  char v12; // bl
  int v13; // [esp+0h] [ebp-10h]
  int i; // [esp+4h] [ebp-Ch]
  int v15; // [esp+8h] [ebp-8h]
  _BYTE *v16; // [esp+8h] [ebp-8h]
  int v17; // [esp+Ch] [ebp-4h]
  _BYTE *v18; // [esp+Ch] [ebp-4h]

  if ( *(_BYTE *)(dword_D41A0 + 8592) == 2 && !byte_D478C )
  {
    v13 = (int)(unsigned __int16)dword_DE564 >> 2;
    v15 = dword_E9C3C;
    v17 = dword_DE558;
    v0 = (unsigned __int16)dword_DE568 / 2;
    for ( i = v0; i; --i )
    {
      v1 = v13;
      v2 = (_BYTE *)v15;
      v3 = (_BYTE *)v17;
      v4 = 0;
      v5 = 0;
      do
      {
        LOBYTE(v5) = v2[2];
        LOBYTE(v4) = v3[2];
        LOBYTE(v0) = byte_F0520[v4] + byte_F0620[v5];
        LOBYTE(v5) = v2[3];
        LOBYTE(v4) = v3[3];
        BYTE1(v0) = byte_F0920[v4] + byte_F0220[v5];
        v0 <<= 16;
        LOBYTE(v5) = *v2;
        LOBYTE(v4) = *v3;
        LOBYTE(v0) = byte_F0520[v4] + byte_F0620[v5];
        LOBYTE(v5) = v2[1];
        LOBYTE(v4) = v3[1];
        BYTE1(v0) = byte_F0920[v4] + byte_F0220[v5];
        *(_DWORD *)v3 = v0;
        v3 += 4;
        v2 += 4;
        --v1;
      }
      while ( v1 );
      HIWORD(v6) = HIWORD(dword_DE560);
      v7 = v13;
      v16 = (_BYTE *)(dword_DE560 + v15);
      v18 = (_BYTE *)(dword_DE560 + v17);
      v8 = v16;
      v9 = v18;
      v10 = 0;
      v11 = 0;
      do
      {
        LOBYTE(v11) = v8[2];
        LOBYTE(v10) = v9[2];
        LOBYTE(v6) = byte_F0820[v10] + byte_F0320[v11];
        LOBYTE(v11) = v8[3];
        LOBYTE(v10) = v9[3];
        BYTE1(v6) = byte_F0720[v10] + byte_F0420[v11];
        v6 <<= 16;
        LOBYTE(v11) = *v8;
        LOBYTE(v10) = *v9;
        LOBYTE(v6) = byte_F0820[v10] + byte_F0320[v11];
        LOBYTE(v11) = v8[1];
        LOBYTE(v10) = v9[1];
        BYTE1(v6) = byte_F0720[v10] + byte_F0420[v11];
        *(_DWORD *)v9 = v6;
        v9 += 4;
        v8 += 4;
        --v7;
      }
      while ( v7 );
      HIWORD(v0) = HIWORD(dword_DE560);
      v15 = (int)&v16[dword_DE560];
      v17 = (int)&v18[dword_DE560];
    }
  }
  v12 = *(_BYTE *)(dword_D41A0 + 8592);
  if ( v12 == 1 )
  {
    sub_40D10(dword_D41A0);
    return;
  }
  if ( (word_180660 & 1) == 0 )
  {
    if ( *(_BYTE *)(dword_D41A0 + 8595) && v12 )
    {
      sub_BD3DD();
      return;
    }
    if ( byte_D478C )
    {
      sub_BD1B6((int)&unk_F0A20);
      return;
    }
    if ( (word_180660 & 1) == 0 )
      goto LABEL_24;
LABEL_23:
    sub_90478();
    return;
  }
  if ( byte_D478C )
  {
    sub_BD2CB((int)&unk_F0A20);
    return;
  }
  if ( (word_180660 & 1) != 0 )
    goto LABEL_23;
LABEL_24:
  sub_75200(480);
}
// D41A0: using guessed type int dword_D41A0;
// D478C: using guessed type char byte_D478C;
// DE558: using guessed type int dword_DE558;
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;
// E9C3C: using guessed type int dword_E9C3C;
// 180660: using guessed type __int16 word_180660;

//----- (000411A0) --------------------------------------------------------
char __cdecl sub_411A0(int a1, int a2, int a3, __int16 a4, int a5, int a6, __int16 a7, int a8)
{
  unsigned __int16 v8; // ax
  unsigned __int16 v9; // cx
  int v10; // edx
  int v11; // ecx
  int v12; // ebx
  int v13; // edx
  int v14; // ecx
  int v15; // ebx
  int v16; // edx
  int v17; // ecx
  int v18; // ebx
  int v19; // edx
  int v20; // esi
  int v21; // edx
  int v22; // ebx
  void (__noreturn *v23)(); // edx
  int v24; // ebx
  __int16 v25; // di
  char result; // al
  int v27; // ebx
  void (__noreturn *v28)(); // edx
  int v29; // ebx
  __int16 v30; // di
  int v31; // edx
  __int64 v32; // rax
  _BYTE *v33; // edi
  int v34; // eax
  _BYTE *v35; // esi
  int v36; // ecx
  unsigned __int16 v37; // bx
  unsigned __int16 v38; // dx
  unsigned __int16 v39; // bx
  unsigned __int16 v40; // dx
  _BYTE *v41; // edi
  int v42; // esi
  int v43; // ecx
  int v44; // eax
  int v45; // ebx
  int v46; // edx
  int v47; // [esp+0h] [ebp-1Ch]
  int v48; // [esp+4h] [ebp-18h]
  int v49; // [esp+8h] [ebp-14h]
  char v50; // [esp+Ch] [ebp-10h]
  int v51; // [esp+10h] [ebp-Ch]
  int v52; // [esp+14h] [ebp-8h]
  int i; // [esp+18h] [ebp-4h]
  int v54; // [esp+34h] [ebp+18h]
  int v55; // [esp+38h] [ebp+1Ch]

  LOBYTE(v8) = BYTE1(a2);
  HIBYTE(v8) = BYTE1(a3);
  if ( (unsigned __int8)a2 < 0x80u )
    LOBYTE(v8) = BYTE1(a2) - 1;
  if ( (unsigned __int8)a3 < 0x80u )
    HIBYTE(v8) = BYTE1(a3) - 1;
  v9 = v8;
  LOBYTE(v8) = v8 + 2;
  v10 = (unsigned __int8)byte_11B4E0[v9];
  v11 = (unsigned __int8)byte_11B4E0[v8];
  HIBYTE(v8) += 2;
  v12 = v10 - v11;
  v13 = v11 + v10;
  v14 = (unsigned __int8)byte_11B4E0[v8];
  LOBYTE(v8) = v8 - 2;
  v15 = v12 - v14;
  v16 = v13 - v14;
  v17 = (unsigned __int8)byte_11B4E0[v8];
  v18 = 2 * (v17 + v15);
  v19 = 2 * (v16 - v17);
  if ( v18 <= 100 )
  {
    if ( v18 < -100 )
      v18 = -100;
  }
  else
  {
    v18 = 100;
  }
  if ( v19 <= 100 )
  {
    if ( v19 < -100 )
      v19 = -100;
  }
  else
  {
    v19 = 100;
  }
  v20 = a4 & 0x7FF;
  dword_D4794 += (v18 - dword_D4794) >> 3;
  dword_D4798 += (v19 - dword_D4798) >> 3;
  v54 = dword_D4794 + a2;
  v55 = dword_D4798 + a3;
  if ( *(_BYTE *)(dword_D41A0 + 8595) && *(_BYTE *)(dword_D41A0 + 8592) && dword_18062C == 640 )
  {
    sub_BCD45(
      dword_180628,
      0,
      2 * dword_18062C,
      (unsigned __int16)(dword_18062C / 2 - 8),
      (unsigned __int16)(dword_180624 / 2 - 40));
    v21 = dword_DB750[v20];
    dword_D4790 = 20;
    v22 = 5 * v21;
    v23 = off_DBF50[v20];
    dword_D4324 = -5;
    v24 = (__int16)(v22 >> 14);
    v25 = (5 * (int)v23) >> 14;
    sub_3C080(v24, v20, v54 - v25, v55 - v24, v20, a5, a6, a7, a8);
    sub_BCD45(dword_180628 + dword_18062C / 2, 0, 0, 0, 0);
    dword_D4324 = 5;
    sub_3C080(v55 + v24, v20, v54 + v25, v55 + v24, v20, a5, a6, a7, a8);
    result = dword_18062C;
    dword_D4324 = 0;
    sub_BCD45(dword_180628, 0, dword_18062C, (unsigned __int16)dword_18062C, (unsigned __int16)dword_180624);
  }
  else if ( *(_BYTE *)(dword_D41A0 + 8592) != 1 || *(_BYTE *)(dword_D41A0 + 8595) )
  {
    v50 = *(_BYTE *)(dword_D41A0 + 8593);
    if ( word_180660 == 1 )
    {
      v31 = dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12);
      if ( !*(_BYTE *)(v31 + 12221) )
      {
        if ( *(_BYTE *)(dword_D41A4 + 34) )
        {
          if ( dword_E9C3C )
          {
            if ( *(_BYTE *)(dword_D41A0 + 8589) == 40 )
            {
              v32 = *(__int16 *)(dword_EA3E4[*(unsigned __int16 *)(v31 + 11240)] + 130);
              if ( (int)((HIDWORD(v32) ^ v32) - HIDWORD(v32)) > 80 )
                *(_BYTE *)(dword_D41A0 + 8593) = 1;
            }
          }
        }
      }
    }
    if ( *(_BYTE *)(dword_D41A0 + 8625) && *(_BYTE *)(dword_D41A0 + 8593) && dword_E9C3C )
    {
      v33 = (_BYTE *)dword_DE558;
      sub_BCD45(dword_E9C3C, 0, 0, 0, 0);
      sub_3C080(v54, v20, v54, v55, v20, a5, a6, a7, a8);
      sub_BCD45((int)v33, 0, 0, 0, 0);
      v49 = (int)(unsigned __int16)dword_DE564 >> 2;
      v47 = dword_DE560 - (unsigned __int16)dword_DE564;
      v48 = (unsigned __int16)dword_DE568;
      HIWORD(v34) = HIWORD(dword_D41A0);
      if ( *(_BYTE *)(dword_D41A0 + 8593) != 1 )
      {
        v35 = (_BYTE *)dword_E9C3C;
        goto LABEL_33;
      }
      v35 = (_BYTE *)dword_E9C3C;
      v36 = (int)(unsigned __int16)dword_DE564 >> 2;
      LOBYTE(v37) = *(_BYTE *)(dword_E9C3C + 2);
      HIBYTE(v37) = v33[2];
      LOBYTE(v38) = *(_BYTE *)(dword_E9C3C + 3);
      LOBYTE(v34) = byte_FAEE0[v37];
      HIBYTE(v38) = v33[3];
      BYTE1(v34) = byte_FAEE0[v38];
      v34 <<= 16;
      LOBYTE(v37) = *(_BYTE *)dword_E9C3C;
      HIBYTE(v37) = *v33;
      LOBYTE(v38) = *(_BYTE *)(dword_E9C3C + 1);
      LOBYTE(v34) = byte_FAEE0[v37];
      HIBYTE(v38) = v33[1];
      for ( BYTE1(v34) = byte_FAEE0[v38]; ; BYTE1(v34) = byte_FAEE0[v40] )
      {
        *(_DWORD *)v33 = v34;
        v33 += 4;
        v35 += 4;
        if ( !--v36 )
        {
          HIWORD(v34) = HIWORD(v47);
          v35 += v47;
          v33 += v47;
          if ( !--v48 )
            goto LABEL_44;
LABEL_33:
          v36 = v49;
        }
        HIBYTE(v39) = v35[2];
        LOBYTE(v39) = v33[2];
        HIBYTE(v40) = v35[3];
        LOBYTE(v34) = byte_FAEE0[v39];
        LOBYTE(v40) = v33[3];
        BYTE1(v34) = byte_FAEE0[v40];
        v34 <<= 16;
        HIBYTE(v39) = *v35;
        LOBYTE(v39) = *v33;
        HIBYTE(v40) = v35[1];
        LOBYTE(v34) = byte_FAEE0[v39];
        LOBYTE(v40) = v33[1];
      }
    }
    sub_3C080(v55, v20, v54, v55, v20, a5, a6, a7, a8);
    if ( *(_BYTE *)(dword_D41A0 + 8594) )
    {
      v52 = dword_DE558;
      for ( i = (unsigned __int16)dword_DE568 - 1; i; --i )
      {
        v41 = (_BYTE *)v52;
        v42 = dword_DE560;
        v43 = (unsigned __int16)dword_DE564 - 1;
        HIWORD(v44) = 0;
        HIWORD(v45) = 0;
        HIWORD(v46) = 0;
        do
        {
          LOBYTE(v44) = *v41;
          LOBYTE(v45) = v41[1];
          BYTE1(v44) = v41[v42];
          LOBYTE(v46) = byte_FAEE0[v44];
          BYTE1(v45) = v41[v42 + 1];
          BYTE1(v46) = byte_FAEE0[v45];
          *v41++ = byte_FAEE0[v46];
          --v43;
        }
        while ( v43 );
        v52 += dword_DE560;
      }
    }
LABEL_44:
    result = dword_D41A0;
    *(_BYTE *)(dword_D41A0 + 8593) = v50;
  }
  else
  {
    v27 = 5 * dword_DB750[v20];
    v28 = off_DBF50[v20];
    dword_D4790 = 20;
    dword_D4324 = dword_DE560 / 0x28u;
    v29 = (__int16)(v27 >> 14);
    v30 = (5 * (int)v28) >> 14;
    sub_3C080(v29, v20, v30 + v54, v29 + v55, v20, a5, a6, a7, a8);
    v51 = dword_DE558;
    sub_BCD45(dword_E9C3C, 0, 0, 0, 0);
    dword_D4324 = -(dword_DE560 / 0x28u);
    result = sub_3C080(v29, v20, v54 - v30, v55 - v29, v20, a5, a6, a7, a8);
    sub_BCD45(v51, 0, 0, 0, 0);
    dword_D4324 = 0;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D4324: using guessed type int dword_D4324;
// D4790: using guessed type int dword_D4790;
// D4794: using guessed type int dword_D4794;
// D4798: using guessed type int dword_D4798;
// DB750: using guessed type int dword_DB750[256];
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// DE558: using guessed type int dword_DE558;
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;
// E9C3C: using guessed type int dword_E9C3C;
// EA3E4: using guessed type int dword_EA3E4[];
// 180624: using guessed type int dword_180624;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (000417A0) --------------------------------------------------------
__int16 sub_417A0()
{
  sub_90810();
  sub_41A90((unsigned __int8 *)dword_EA3D8);
  return sub_6EF10(0, 640, 0, 400);
}
// EA3D8: using guessed type int dword_EA3D8;

//----- (000417D0) --------------------------------------------------------
__int16 sub_417D0()
{
  sub_906B4();
  sub_41A90((unsigned __int8 *)dword_EA3D8);
  return sub_6EF10(0, 640, 0, 800);
}
// EA3D8: using guessed type int dword_EA3D8;

//----- (00041A90) --------------------------------------------------------
unsigned __int8 __cdecl sub_41A90(unsigned __int8 *a1)
{
  unsigned __int8 result; // al
  unsigned __int8 *v2; // ebx
  unsigned __int16 v3; // cx
  unsigned __int8 v4; // al
  unsigned __int8 *v5; // ebx
  unsigned __int8 v6; // al

  result = -1;
  v2 = a1;
  __outbyte(0x3C6u, 0xFFu);
  v3 = 0;
  while ( v3 < 0x100u )
  {
    __outbyte(0x3C8u, v3);
    v4 = *v2;
    v5 = v2 + 1;
    __outbyte(0x3C9u, v4);
    v6 = *v5++;
    __outbyte(0x3C9u, v6);
    ++v3;
    result = *v5;
    v2 = v5 + 1;
    __outbyte(0x3C9u, result);
  }
  if ( byte_E12EC )
    return sub_75A10(2, a1);
  return result;
}
// E12EC: using guessed type char byte_E12EC;

//----- (00041AF0) --------------------------------------------------------
unsigned __int8 sub_41AF0()
{
  unsigned __int8 result; // al
  unsigned __int8 *v1; // [esp-4h] [ebp-4h]

  if ( !byte_D47D9 )
  {
    result = dword_D41A0;
    if ( *(_BYTE *)(dword_D41A0 + 8592) )
    {
      if ( *(_BYTE *)(dword_D41A0 + 8595) && dword_DE560 == 640 )
        sub_75C50();
      byte_D47D8 = *(_BYTE *)(dword_D41A0 + 8592);
      sub_417A0();
      v1 = (unsigned __int8 *)dword_EA3D8;
      *(_BYTE *)(dword_D41A0 + 8592) = 0;
      result = sub_41A90(v1);
    }
  }
  ++byte_D47D9;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D47D8: using guessed type char byte_D47D8;
// D47D9: using guessed type char byte_D47D9;
// DE560: using guessed type int dword_DE560;
// EA3D8: using guessed type int dword_EA3D8;

//----- (00041B60) --------------------------------------------------------
char sub_41B60()
{
  char v0; // dl
  char result; // al

  if ( byte_D47D9 == 1 )
  {
    v0 = byte_D47D8;
    *(_BYTE *)(dword_D41A0 + 8592) = byte_D47D8;
    result = v0;
    if ( v0 == 1 )
      result = sub_417D0();
    byte_D47D8 = 0;
  }
  if ( byte_D47D9 )
    --byte_D47D9;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D47D8: using guessed type char byte_D47D8;
// D47D9: using guessed type char byte_D47D9;

//----- (00041BC0) --------------------------------------------------------
__int64 sub_41BC0()
{
  __int64 result; // rax

  BYTE1(result) = 0;
  byte_D47D9 = 0;
  byte_D47D8 = 0;
  return result;
}
// D47D8: using guessed type char byte_D47D8;
// D47D9: using guessed type char byte_D47D9;

//----- (00041BD3) --------------------------------------------------------
__int16 __cdecl sub_41BD3(unsigned int a1)
{
  int v1; // eax
  char *v2; // ebx
  _DWORD *v3; // esi
  _BYTE *v4; // edi
  int v5; // ecx
  char v6; // cf
  int v7; // ecx
  int v8; // ecx
  char v9; // al
  char v10; // al
  char v11; // al
  char v12; // al
  int v13; // eax
  _BYTE *v14; // ebx
  _DWORD *v15; // esi
  _BYTE *v16; // edi
  int v17; // ecx
  _BYTE *v18; // ebx
  _DWORD *v19; // esi
  _BYTE *v20; // edi
  int v21; // eax
  int v22; // ecx
  _BYTE *v23; // ebx
  _DWORD *v24; // esi
  _BYTE *v25; // edi
  int v26; // eax
  int v27; // ecx
  _BYTE *v28; // ebx
  _DWORD *v29; // esi
  _BYTE *v30; // edi
  int v31; // eax
  int v32; // ecx
  int v33; // eax
  _BYTE *v34; // ebx
  _DWORD *v35; // esi
  _BYTE *v36; // edi
  int v37; // ecx
  int v38; // edx
  _BYTE *v39; // ebx
  _DWORD *v40; // esi
  _BYTE *v41; // edi
  int v42; // eax
  int v43; // ecx
  int v44; // edx
  _BYTE *v45; // ebx
  _DWORD *v46; // esi
  _BYTE *v47; // edi
  int v48; // eax
  int v49; // ecx
  char *v50; // ebx
  _BYTE *v51; // edx
  _DWORD *v52; // esi
  char *v53; // edi
  int v54; // ecx
  int v55; // ecx
  int v56; // ecx
  char v57; // al
  char v58; // al
  char v59; // al
  char v60; // al
  _BYTE *v61; // ebx
  int v62; // eax
  _BYTE *v63; // edx
  _DWORD *v64; // esi
  _DWORD *v65; // edi
  int v66; // ecx
  _BYTE *v67; // ebx
  _BYTE *v68; // edx
  _DWORD *v69; // esi
  _DWORD *v70; // edi
  int v71; // eax
  int v72; // ecx
  _BYTE *v73; // ebx
  _BYTE *v74; // edx
  _DWORD *v75; // esi
  _DWORD *v76; // edi
  int v77; // eax
  int v78; // ecx
  _BYTE *v79; // ebx
  _BYTE *v80; // edx
  _DWORD *v81; // esi
  _DWORD *v82; // edi
  int v83; // eax
  int v84; // ecx
  _BYTE *v85; // ebx
  int v86; // eax
  _BYTE *v87; // edx
  _DWORD *v88; // esi
  _DWORD *v89; // edi
  int v90; // ecx
  int v91; // ecx
  _BYTE *v92; // ebx
  _BYTE *v93; // edx
  int v94; // eax
  _DWORD *v95; // esi
  _DWORD *v96; // edi
  int v97; // ecx
  _BYTE *v98; // ebx
  _BYTE *v99; // edx
  int v100; // eax
  _DWORD *v101; // esi
  _DWORD *v102; // edi
  char *v103; // ebx
  int v104; // eax
  _BYTE *v105; // edx
  _DWORD *v106; // esi
  _DWORD *v107; // edi
  int v108; // ecx
  char v109; // al
  char v110; // al
  int v111; // eax
  int v112; // edx
  int v113; // edx
  int v115; // [esp+10h] [ebp-54h]
  _DWORD *v116; // [esp+14h] [ebp-50h]
  _DWORD *v117; // [esp+14h] [ebp-50h]
  _DWORD *v118; // [esp+14h] [ebp-50h]
  _DWORD *v119; // [esp+14h] [ebp-50h]
  int v120; // [esp+1Ch] [ebp-48h]
  int v121; // [esp+20h] [ebp-44h]
  int v122; // [esp+20h] [ebp-44h]
  int v123; // [esp+24h] [ebp-40h]
  int v124; // [esp+24h] [ebp-40h]
  int i; // [esp+24h] [ebp-40h]
  int j; // [esp+24h] [ebp-40h]
  int k; // [esp+24h] [ebp-40h]
  int v128; // [esp+24h] [ebp-40h]
  int v129; // [esp+24h] [ebp-40h]
  int m; // [esp+28h] [ebp-3Ch]
  int v131; // [esp+28h] [ebp-3Ch]
  int v132; // [esp+28h] [ebp-3Ch]
  int v133; // [esp+34h] [ebp-30h]
  int v134; // [esp+34h] [ebp-30h]
  int v135; // [esp+38h] [ebp-2Ch]
  int v136; // [esp+38h] [ebp-2Ch]
  int v137; // [esp+3Ch] [ebp-28h]
  int v138; // [esp+3Ch] [ebp-28h]
  int v139; // [esp+3Ch] [ebp-28h]
  int v140; // [esp+3Ch] [ebp-28h]
  int v141; // [esp+3Ch] [ebp-28h]
  int v142; // [esp+3Ch] [ebp-28h]
  int v143; // [esp+3Ch] [ebp-28h]
  int v144; // [esp+3Ch] [ebp-28h]
  int v145; // [esp+3Ch] [ebp-28h]
  int v146; // [esp+3Ch] [ebp-28h]
  int v147; // [esp+3Ch] [ebp-28h]
  int v148; // [esp+3Ch] [ebp-28h]
  int v149; // [esp+3Ch] [ebp-28h]
  int v150; // [esp+3Ch] [ebp-28h]
  int v151; // [esp+3Ch] [ebp-28h]
  int v152; // [esp+3Ch] [ebp-28h]
  _DWORD *v153; // [esp+40h] [ebp-24h]
  _DWORD *v154; // [esp+40h] [ebp-24h]
  int v155; // [esp+40h] [ebp-24h]
  int v156; // [esp+44h] [ebp-20h]
  int v157; // [esp+48h] [ebp-1Ch]
  int v158; // [esp+48h] [ebp-1Ch]
  int v159; // [esp+4Ch] [ebp-18h]
  int v160; // [esp+50h] [ebp-14h]
  int v161; // [esp+50h] [ebp-14h]
  int *v162; // [esp+54h] [ebp-10h]
  _DWORD *v163; // [esp+54h] [ebp-10h]
  _DWORD *v164; // [esp+54h] [ebp-10h]
  _DWORD *v165; // [esp+54h] [ebp-10h]
  int *v166; // [esp+54h] [ebp-10h]
  _DWORD *v167; // [esp+54h] [ebp-10h]
  _DWORD *v168; // [esp+54h] [ebp-10h]
  char *v169; // [esp+58h] [ebp-Ch]
  int v170; // [esp+5Ch] [ebp-8h]
  int v171; // [esp+5Ch] [ebp-8h]
  int v172; // [esp+60h] [ebp-4h]
  int v173; // [esp+60h] [ebp-4h]
  int v174; // [esp+60h] [ebp-4h]
  int v175; // [esp+60h] [ebp-4h]

  if ( !byte_F2CC6 )
  {
    if ( a1 )
    {
      if ( a1 <= 1 )
      {
        dword_F2C30 -= (((dword_F2C64 * dword_F2C44) >> 1) + dword_F2C54 * dword_F2C50) >> 16;
        dword_F2C2C -= (dword_F2C64 * dword_F2C50 - ((dword_F2C54 * dword_F2C44) >> 1)) >> 16;
LABEL_124:
        LOWORD(v1) = dword_F2C98;
        switch ( dword_F2C98 )
        {
          case 0:
            v1 = (dword_F2C8C * dword_F2C44) >> 16;
            v156 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            v1 = (dword_F2C50 << 16) / dword_F2C8C;
            v159 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            v134 = (dword_F2C38 << 16) / v1;
            if ( a1 == 1 )
            {
              dword_F2C48 = 0;
            }
            else
            {
              dword_F2C48 = (v1 - 1) * v134;
              v134 = -v134;
            }
            v160 = dword_F2CBC * dword_F2C50 / v1;
            v162 = (int *)(dword_E9C38 + 45920);
            v157 = dword_F2C30 << 16;
            v170 = dword_F2C2C - ((dword_F2C9C * dword_F2C30) >> 16);
            if ( v170 >= dword_F2CA4 )
              goto LABEL_133;
            v138 = dword_F2CA4 - v170;
            LOWORD(v1) = dword_F2CA4 - v170;
            v159 -= dword_F2CA4 - v170;
            if ( v159 > 0 )
            {
              dword_F2C48 += v138 * v134;
              v157 -= v138 * v160;
              v170 = dword_F2CA4;
LABEL_133:
              v122 = dword_DE560 * v170 + dword_DE558;
              goto LABEL_134;
            }
            goto LABEL_375;
          case 1:
            v1 = (dword_F2CBC * dword_F2C44) >> 16;
            v156 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            v1 = (dword_F2C50 << 16) / dword_F2CBC;
            v159 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            v134 = (dword_F2C38 << 16) / v1;
            if ( a1 == 1 )
            {
              dword_F2C48 = 0;
            }
            else
            {
              dword_F2C48 = (v1 - 1) * v134;
              v134 = -v134;
            }
            v161 = dword_F2C8C * dword_F2C50 / v1;
            v166 = (int *)(dword_E9C38 + 45920);
            v158 = dword_F2C2C << 16;
            v171 = dword_F2C30 - ((dword_F2C9C * dword_F2C2C) >> 16);
            if ( v171 < dword_F2CB4 )
            {
              LOWORD(v1) = dword_F2C30 - ((unsigned int)(dword_F2C9C * dword_F2C2C) >> 16);
              if ( v171 < dword_F2CA4 )
                goto LABEL_375;
            }
            else
            {
              v141 = v171 - dword_F2CB4;
              LOWORD(v1) = v171 - dword_F2CB4;
              v159 -= v171 - dword_F2CB4;
              if ( v159 <= 0 )
                goto LABEL_375;
              dword_F2C48 += v141 * v134;
              v158 += v141 * v161;
              v171 = dword_F2CB4;
            }
            v122 = v171 + dword_DE558;
            goto LABEL_281;
          case 2:
            v1 = (dword_F2C8C * dword_F2C44) >> 16;
            v156 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            v1 = (dword_F2C50 << 16) / dword_F2C8C;
            v159 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            v134 = (dword_F2C38 << 16) / v1;
            if ( a1 == 1 )
            {
              dword_F2C48 = 0;
            }
            else
            {
              dword_F2C48 = (v1 - 1) * v134;
              v134 = -v134;
            }
            v160 = dword_F2CBC * dword_F2C50 / v1;
            v162 = (int *)(dword_E9C38 + 45920);
            v157 = dword_F2C2C << 16;
            v170 = dword_F2CB4 - dword_F2C30 - ((dword_F2C9C * dword_F2C2C) >> 16);
            if ( v170 >= dword_F2CA4 )
              goto LABEL_325;
            v147 = dword_F2CA4 - v170;
            LOWORD(v1) = dword_F2CA4 - v170;
            v159 -= dword_F2CA4 - v170;
            if ( v159 <= 0 )
              goto LABEL_375;
            dword_F2C48 += v147 * v134;
            v157 -= v147 * v160;
            v170 = dword_F2CA4;
LABEL_325:
            v122 = dword_F2CB4 + dword_DE558 - 1 - v170;
            goto LABEL_134;
          case 3:
            v1 = (dword_F2CBC * dword_F2C44) >> 16;
            v156 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            v1 = (dword_F2C50 << 16) / dword_F2CBC;
            v159 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            v134 = (dword_F2C38 << 16) / v1;
            if ( a1 == 1 )
            {
              dword_F2C48 = 0;
            }
            else
            {
              dword_F2C48 = (v1 - 1) * v134;
              v134 = -v134;
            }
            v161 = dword_F2C8C * dword_F2C50 / v1;
            v166 = (int *)(dword_E9C38 + 45920);
            v158 = (dword_F2CB8 - dword_F2C30) << 16;
            v171 = dword_F2C2C - ((dword_F2C9C * (dword_F2CB8 - dword_F2C30)) >> 16);
            if ( v171 < dword_F2CB4 )
            {
              LOWORD(v1) = dword_F2C2C - ((unsigned int)(dword_F2C9C * (dword_F2CB8 - dword_F2C30)) >> 16);
              if ( v171 < dword_F2CA4 )
                goto LABEL_375;
            }
            else
            {
              v148 = v171 - dword_F2CB4;
              LOWORD(v1) = v171 - dword_F2CB4;
              v159 -= v171 - dword_F2CB4;
              if ( v159 <= 0 )
                goto LABEL_375;
              dword_F2C48 += v148 * v134;
              v158 += v148 * v161;
              v171 = dword_F2CB4;
            }
            v122 = dword_F2CB8 + dword_DE560 * v171 - 1 + dword_DE558;
            goto LABEL_281;
          case 4:
            v1 = (dword_F2C8C * dword_F2C44) >> 16;
            v156 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            v1 = (dword_F2C50 << 16) / dword_F2C8C;
            v159 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            v134 = (dword_F2C38 << 16) / v1;
            if ( a1 == 1 )
            {
              dword_F2C48 = 0;
            }
            else
            {
              dword_F2C48 = (v1 - 1) * v134;
              v134 = -v134;
            }
            v160 = dword_F2CBC * dword_F2C50 / v1;
            v162 = (int *)(dword_E9C38 + 45920);
            v157 = (dword_F2CB8 - dword_F2C30) << 16;
            v170 = dword_F2CB4 - dword_F2C2C - ((dword_F2C9C * (dword_F2CB8 - dword_F2C30)) >> 16);
            if ( v170 >= dword_F2CA4 )
              goto LABEL_344;
            v149 = dword_F2CA4 - v170;
            LOWORD(v1) = dword_F2CA4 - v170;
            v159 -= dword_F2CA4 - v170;
            if ( v159 <= 0 )
              goto LABEL_375;
            dword_F2C48 += v149 * v134;
            v157 -= v149 * v160;
            v170 = dword_F2CA4;
LABEL_344:
            v122 = dword_F2CB8 + dword_DE558 + dword_DE560 * (dword_F2CB4 - v170 - 1) - 1;
            goto LABEL_134;
          case 5:
            v1 = (dword_F2CBC * dword_F2C44) >> 16;
            v156 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            v1 = (dword_F2C50 << 16) / dword_F2CBC;
            v159 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            v134 = (dword_F2C38 << 16) / v1;
            if ( a1 == 1 )
            {
              dword_F2C48 = 0;
            }
            else
            {
              dword_F2C48 = (v1 - 1) * v134;
              v134 = -v134;
            }
            v161 = dword_F2C8C * dword_F2C50 / v1;
            v166 = (int *)(dword_E9C38 + 45920);
            v158 = (dword_F2CB8 - dword_F2C2C) << 16;
            v112 = (dword_F2C9C * (dword_F2CB8 - dword_F2C2C)) >> 16;
            v171 = dword_F2CB4 - dword_F2C30 - v112;
            if ( v171 < dword_F2CB4 )
            {
              LOWORD(v1) = dword_F2CB4 - dword_F2C30 - v112;
              if ( v171 < dword_F2CA4 )
                goto LABEL_375;
            }
            else
            {
              v150 = v171 - dword_F2CB4;
              LOWORD(v1) = v171 - dword_F2CB4;
              v159 -= v171 - dword_F2CB4;
              if ( v159 <= 0 )
                goto LABEL_375;
              dword_F2C48 += v150 * v134;
              v158 += v150 * v161;
              v171 = dword_F2CB4;
            }
            v122 = (dword_F2CB8 - 1) * dword_DE560 + dword_F2CB4 + dword_DE558 - 1 - v171;
            goto LABEL_281;
          case 6:
            v1 = (dword_F2C8C * dword_F2C44) >> 16;
            v156 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            v1 = (dword_F2C50 << 16) / dword_F2C8C;
            v159 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            v134 = (dword_F2C38 << 16) / v1;
            if ( a1 == 1 )
            {
              dword_F2C48 = 0;
            }
            else
            {
              dword_F2C48 = (v1 - 1) * v134;
              v134 = -v134;
            }
            v160 = dword_F2CBC * dword_F2C50 / v1;
            v162 = (int *)(dword_E9C38 + 45920);
            v157 = (dword_F2CB8 - dword_F2C2C) << 16;
            v170 = dword_F2C30 - ((dword_F2C9C * (dword_F2CB8 - dword_F2C2C)) >> 16);
            if ( v170 >= dword_F2CA4 )
              goto LABEL_363;
            v151 = dword_F2CA4 - v170;
            LOWORD(v1) = dword_F2CA4 - v170;
            v159 -= dword_F2CA4 - v170;
            if ( v159 <= 0 )
              goto LABEL_375;
            dword_F2C48 += v151 * v134;
            v157 -= v151 * v160;
            v170 = dword_F2CA4;
LABEL_363:
            v122 = dword_DE558 + dword_DE560 * (dword_F2CB8 - 1) + v170;
LABEL_134:
            v139 = dword_F2CB4 - dword_F2CA4;
            if ( v170 <= 0 )
            {
              if ( v159 > v139 )
                v159 = dword_F2CB4 - dword_F2CA4;
            }
            else if ( v170 + v159 > v139 )
            {
              LOWORD(v1) = v139 - v170;
              v159 = v139 - v170;
              if ( v139 - v170 <= 0 )
                goto LABEL_375;
            }
            v115 = 9999999;
            v123 = v159;
            while ( 2 )
            {
              if ( !v123 )
                goto LABEL_151;
              v172 = v157 >> 16;
              if ( v157 >> 16 < 0 )
              {
                v173 = -v172;
                *v162 = 0;
                v162[1] = v156 - v173;
                if ( v162[1] <= 0 )
                {
                  v159 -= v123;
LABEL_151:
                  if ( v170 + v159 > dword_F2C84 )
                  {
                    if ( dword_F2C84 - v170 <= 0 )
                    {
                      v163 = (_DWORD *)(dword_E9C38 + 45920);
                      v116 = (_DWORD *)(4 * (dword_F2C84 - v170) + dword_F2C88);
                      v124 = v159;
                    }
                    else
                    {
                      v163 = (_DWORD *)(12 * (dword_F2C84 - v170) + dword_E9C38 + 45920);
                      v116 = (_DWORD *)dword_F2C88;
                      v124 = v170 + v159 - dword_F2C84;
                    }
                    while ( v124 )
                    {
                      if ( *v163 + v163[1] > *v116 )
                      {
                        if ( *v163 >= *v116 )
                        {
                          v159 -= v124;
                          break;
                        }
                        v163[1] = *v116 - *v163;
                      }
                      v163 += 3;
                      --v116;
                      --v124;
                    }
                  }
                  if ( v170 < 0 )
                  {
                    v117 = (_DWORD *)(4 * (-1 - v170) + dword_E9C38 + 59360);
                    v164 = (_DWORD *)(dword_E9C38 + 45920);
                    while ( v170 )
                    {
                      if ( *v117 > *v164 )
                      {
                        if ( v164[1] + *v164 >= *v117 )
                        {
                          v140 = *v117 - *v164;
                          *v164 = *v117;
                          v164[2] += v140;
                          v164[1] -= v140;
                        }
                        else
                        {
                          v164[1] = 0;
                        }
                      }
                      --v117;
                      v164 += 3;
                      ++v170;
                    }
                  }
LABEL_169:
                  v136 = (dword_F2C34 << 16) / v156;
                  dword_F2C4C = 0;
                  if ( dword_F2C34 < 0 )
                    dword_F2C4C -= v136 * (v156 - 1);
                  LOWORD(v1) = v156 - v115;
                  v131 = v156 - v115;
                  if ( v156 - v115 > 0 )
                  {
                    if ( v131 > dword_F2C90 )
                      v131 = dword_F2C90;
                    dword_F2C4C += v136 * v115;
                    v154 = (_DWORD *)(dword_E9C38 + 36960);
                    while ( v131 >= 0 )
                    {
                      v154[1] = dword_F2C4C >> 16;
                      *v154 = v154[1] - *(v154 - 1);
                      dword_F2C4C += v136;
                      v154 += 2;
                      --v131;
                    }
                    v165 = (_DWORD *)(dword_E9C38 + 45920);
                    LOWORD(v1) = v159;
                    for ( i = v159; i; --i )
                    {
                      v132 = v165[1];
                      if ( v132 > 0 )
                      {
                        v169 = (char *)&unk_F0E20 + 12 * *v165;
                        v155 = 8 * (v165[2] - v115) + dword_E9C38 + 36960;
                        v120 = dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28;
                        switch ( dword_F2C24 )
                        {
                          case 0:
                            v50 = (char *)(*(_DWORD *)(v155 + 4) + v120);
                            v51 = (_BYTE *)(*((_DWORD *)v169 + 1) + v122);
                            v52 = (_DWORD *)(8 * (v165[2] - v115) + dword_E9C38 + 36960);
                            v53 = (char *)&unk_F0E20 + 12 * *v165;
                            v54 = v132 >> 1;
                            if ( !(v132 & 1) )
                            {
                              v6 = v54 & 1;
                              v55 = v132 >> 2;
                              if ( v6 )
                              {
                                ++v55;
                                v52 = (_DWORD *)(v155 - 8);
                                v53 = v169 - 12;
                                goto LABEL_193;
                              }
                              v52 = (_DWORD *)(v155 + 8);
                              v53 = v169 + 12;
                              goto LABEL_187;
                            }
                            v56 = v54 + 2;
                            v6 = v56 & 1;
                            v55 = v56 >> 1;
                            if ( !v6 )
                            {
                              v52 = (_DWORD *)(v155 - 16);
                              v53 = v169 - 24;
                              goto LABEL_196;
                            }
                            while ( 1 )
                            {
                              v58 = *v50;
                              v50 += v52[2];
                              if ( v58 )
                                *v51 = v58;
                              v51 += *((_DWORD *)v53 + 3);
LABEL_193:
                              v59 = *v50;
                              v50 += v52[4];
                              if ( v59 )
                                *v51 = v59;
                              v51 += *((_DWORD *)v53 + 6);
LABEL_196:
                              v60 = *v50;
                              v50 += v52[6];
                              if ( v60 )
                                *v51 = v60;
                              v51 += *((_DWORD *)v53 + 9);
                              v52 += 8;
                              v53 += 48;
                              if ( !--v55 )
                                break;
LABEL_187:
                              v57 = *v50;
                              v50 += *v52;
                              if ( v57 )
                                *v51 = v57;
                              v51 += *(_DWORD *)v53;
                            }
                            break;
                          case 1:
                            v61 = (_BYTE *)(*(_DWORD *)(v155 + 4) + v120);
                            v62 = dword_F2C20;
                            v63 = (_BYTE *)(*((_DWORD *)v169 + 1) + v122);
                            v64 = (_DWORD *)(8 * (v165[2] - v115) + dword_E9C38 + 36960);
                            v65 = (_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
                            v66 = v132 >> 1;
                            if ( !(v132 & 1) )
                            {
                              v64 = (_DWORD *)(v155 + 8);
                              v65 = v169 + 12;
                              goto LABEL_203;
                            }
                            ++v66;
                            while ( 1 )
                            {
                              LOBYTE(v62) = *v61;
                              v61 += v64[2];
                              if ( (_BYTE)v62 )
                                *v63 = byte_F6EE0[v62];
                              v63 += v65[3];
                              v64 += 4;
                              v65 += 6;
                              if ( !--v66 )
                                break;
LABEL_203:
                              LOBYTE(v62) = *v61;
                              v61 += *v64;
                              if ( (_BYTE)v62 )
                                *v63 = byte_F6EE0[v62];
                              v63 += *v65;
                            }
                            break;
                          case 2:
                            v67 = (_BYTE *)(*(_DWORD *)(v155 + 4) + v120);
                            v68 = (_BYTE *)(*((_DWORD *)v169 + 1) + v122);
                            v69 = (_DWORD *)(8 * (v165[2] - v115) + dword_E9C38 + 36960);
                            v70 = (_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
                            HIWORD(v71) = 0;
                            v72 = v132 >> 1;
                            if ( !(v132 & 1) )
                            {
                              v69 = (_DWORD *)(v155 + 8);
                              v70 = v169 + 12;
                              goto LABEL_213;
                            }
                            ++v72;
                            while ( 1 )
                            {
                              BYTE1(v71) = *v67;
                              v67 += v69[2];
                              if ( BYTE1(v71) )
                              {
                                LOBYTE(v71) = *v68;
                                *v68 = byte_FAEE0[v71];
                              }
                              v68 += v70[3];
                              v69 += 4;
                              v70 += 6;
                              if ( !--v72 )
                                break;
LABEL_213:
                              BYTE1(v71) = *v67;
                              v67 += *v69;
                              if ( BYTE1(v71) )
                              {
                                LOBYTE(v71) = *v68;
                                *v68 = byte_FAEE0[v71];
                              }
                              v68 += *v70;
                            }
                            break;
                          case 3:
                            v73 = (_BYTE *)(*(_DWORD *)(v155 + 4) + v120);
                            v74 = (_BYTE *)(*((_DWORD *)v169 + 1) + v122);
                            v75 = (_DWORD *)(8 * (v165[2] - v115) + dword_E9C38 + 36960);
                            v76 = (_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
                            HIWORD(v77) = 0;
                            v78 = v132 >> 1;
                            if ( !(v132 & 1) )
                            {
                              v75 = (_DWORD *)(v155 + 8);
                              v76 = v169 + 12;
                              goto LABEL_223;
                            }
                            ++v78;
                            while ( 1 )
                            {
                              LOBYTE(v77) = *v73;
                              v73 += v75[2];
                              if ( (_BYTE)v77 )
                              {
                                BYTE1(v77) = *v74;
                                *v74 = byte_FAEE0[v77];
                              }
                              v74 += v76[3];
                              v75 += 4;
                              v76 += 6;
                              if ( !--v78 )
                                break;
LABEL_223:
                              LOBYTE(v77) = *v73;
                              v73 += *v75;
                              if ( (_BYTE)v77 )
                              {
                                BYTE1(v77) = *v74;
                                *v74 = byte_FAEE0[v77];
                              }
                              v74 += *v76;
                            }
                            break;
                          case 4:
                            v79 = (_BYTE *)(*(_DWORD *)(v155 + 4) + v120);
                            HIWORD(v83) = HIWORD(dword_F2C3C);
                            v80 = (_BYTE *)(*((_DWORD *)v169 + 1) + v122);
                            v81 = (_DWORD *)(8 * (v165[2] - v115) + dword_E9C38 + 36960);
                            v82 = (_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
                            BYTE1(v83) = dword_F2C3C;
                            v84 = v132 >> 1;
                            if ( !(v132 & 1) )
                            {
                              v81 = (_DWORD *)(v155 + 8);
                              v82 = v169 + 12;
                              goto LABEL_233;
                            }
                            ++v84;
                            while ( 1 )
                            {
                              LOBYTE(v83) = *v79;
                              v79 += v81[2];
                              if ( (_BYTE)v83 )
                                *v80 = byte_FAEE0[v83];
                              v80 += v82[3];
                              v81 += 4;
                              v82 += 6;
                              if ( !--v84 )
                                break;
LABEL_233:
                              LOBYTE(v83) = *v79;
                              v79 += *v81;
                              if ( (_BYTE)v83 )
                                *v80 = byte_FAEE0[v83];
                              v80 += *v82;
                            }
                            break;
                          case 5:
                            v85 = (_BYTE *)(*(_DWORD *)(v155 + 4) + v120);
                            v86 = dword_F2C3C;
                            v87 = (_BYTE *)(*((_DWORD *)v169 + 1) + v122);
                            v88 = (_DWORD *)(8 * (v165[2] - v115) + dword_E9C38 + 36960);
                            v89 = (_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
                            v90 = v132 >> 1;
                            if ( !(v132 & 1) )
                            {
                              v88 = (_DWORD *)(v155 + 8);
                              v89 = v169 + 12;
                              goto LABEL_243;
                            }
                            ++v90;
                            while ( 1 )
                            {
                              BYTE1(v86) = *v85;
                              v85 += v88[2];
                              if ( BYTE1(v86) )
                                *v87 = byte_FAEE0[v86];
                              v87 += v89[3];
                              v88 += 4;
                              v89 += 6;
                              if ( !--v90 )
                                break;
LABEL_243:
                              BYTE1(v86) = *v85;
                              v85 += *v88;
                              if ( BYTE1(v86) )
                                *v87 = byte_FAEE0[v86];
                              v87 += *v89;
                            }
                            break;
                          case 6:
                            v91 = dword_F2C20;
                            v92 = (_BYTE *)(*(_DWORD *)(v155 + 4) + v120);
                            v93 = (_BYTE *)(*((_DWORD *)v169 + 1) + v122);
                            HIWORD(v94) = 0;
                            v95 = (_DWORD *)(v155 + 8);
                            v96 = v169 + 12;
                            do
                            {
                              BYTE1(v94) = *v92;
                              v92 += *v95;
                              if ( BYTE1(v94) )
                              {
                                LOBYTE(v94) = *v93;
                                LOBYTE(v91) = byte_FAEE0[v94];
                                *v93 = byte_F6EE0[v91];
                              }
                              v93 += *v96;
                              v95 += 2;
                              v96 += 3;
                              --v132;
                            }
                            while ( v132 );
                            break;
                          case 7:
                            v97 = dword_F2C20;
                            v98 = (_BYTE *)(*(_DWORD *)(v155 + 4) + v120);
                            v99 = (_BYTE *)(*((_DWORD *)v169 + 1) + v122);
                            HIWORD(v100) = 0;
                            v101 = (_DWORD *)(v155 + 8);
                            v102 = v169 + 12;
                            do
                            {
                              LOBYTE(v100) = *v98;
                              v98 += *v101;
                              if ( (_BYTE)v100 )
                              {
                                BYTE1(v100) = *v99;
                                LOBYTE(v97) = byte_FAEE0[v100];
                                *v99 = byte_F6EE0[v97];
                              }
                              v99 += *v102;
                              v101 += 2;
                              v102 += 3;
                              --v132;
                            }
                            while ( v132 );
                            break;
                          case 8:
                            v103 = (char *)(*(_DWORD *)(v155 + 4) + v120);
                            v104 = dword_F2C20;
                            v105 = (_BYTE *)(*((_DWORD *)v169 + 1) + v122);
                            v106 = (_DWORD *)(8 * (v165[2] - v115) + dword_E9C38 + 36960);
                            v107 = (_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
                            v108 = v132 >> 1;
                            if ( !(v132 & 1) )
                            {
                              v106 = (_DWORD *)(v155 + 8);
                              v107 = v169 + 12;
                              goto LABEL_263;
                            }
                            ++v108;
                            while ( 1 )
                            {
                              v110 = *v103;
                              v103 += v106[2];
                              if ( v110 )
                              {
                                LOBYTE(v104) = *v105;
                                *v105 = byte_F6EE0[v104];
                              }
                              v105 += v107[3];
                              v106 += 4;
                              v107 += 6;
                              if ( !--v108 )
                                break;
LABEL_263:
                              v109 = *v103;
                              v103 += *v106;
                              if ( v109 )
                              {
                                LOBYTE(v104) = *v105;
                                *v105 = byte_F6EE0[v104];
                              }
                              v105 += *v107;
                            }
                            break;
                          default:
                            break;
                        }
                      }
                      dword_F2C48 += v134;
                      v122 += dword_F2CAC;
                      v165 += 3;
                      LOWORD(v1) = i;
                    }
                  }
LABEL_375:
                  if ( a1 == 1 )
                  {
                    if ( !*(_BYTE *)(dword_D41A4 + 207)
                      && *(_BYTE *)(dword_F2C70 + 63) == 3
                      && *(_BYTE *)(dword_F2C70 + 64) <= 1u )
                    {
                      sub_2CB30((_DWORD *)dword_F2C70, dword_F2C30, dword_F2C2C, dword_F2C44);
                    }
                    if ( *(_BYTE *)(dword_D41A4 + 10) )
                      sub_88740(dword_F2C70, dword_F2C30 + (dword_F2C44 >> 1), dword_F2C2C + (dword_F2C50 >> 1));
                    LOWORD(v1) = dword_F2C70;
                    if ( (*(_BYTE *)(dword_F2C70 + 15) & 0x40) != 0 )
                    {
                      LOWORD(v1) = dword_F2C70;
                      *(_BYTE *)(dword_F2C70 + 42) |= 0x40u;
                    }
                  }
                  return v1;
                }
                v162[2] = v173;
                if ( v173 < v115 )
                  v115 = v173;
              }
              else
              {
                *v162 = v172;
                v162[1] = v156;
                v162[2] = 0;
                v115 = 0;
              }
              if ( v162[1] + *v162 > dword_F2CB8 )
                v162[1] = dword_F2CB8 - *v162;
              v157 -= v160;
              v162 += 3;
              --v123;
              continue;
            }
          case 7:
            v1 = (dword_F2CBC * dword_F2C44) >> 16;
            v156 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            v1 = (dword_F2C50 << 16) / dword_F2CBC;
            v159 = v1;
            if ( v1 <= 0 )
              goto LABEL_375;
            LOWORD(v1) = dword_F2C30;
            if ( dword_F2C30 >= dword_F2CB8 )
              goto LABEL_375;
            v134 = (dword_F2C38 << 16) / v159;
            if ( a1 == 1 )
            {
              dword_F2C48 = 0;
            }
            else
            {
              dword_F2C48 = (v159 - 1) * v134;
              v134 = -v134;
            }
            v161 = dword_F2C8C * dword_F2C50 / v159;
            v166 = (int *)(dword_E9C38 + 45920);
            v158 = dword_F2C30 << 16;
            v113 = (dword_F2C9C * dword_F2C30) >> 16;
            v171 = dword_F2CB4 - dword_F2C2C - v113;
            if ( v171 < dword_F2CB4 )
            {
              LOWORD(v1) = dword_F2CB4 - dword_F2C2C - v113;
              if ( v171 < dword_F2CA4 )
                goto LABEL_375;
            }
            else
            {
              v152 = v171 - dword_F2CB4;
              LOWORD(v1) = v171 - dword_F2CB4;
              v159 -= v171 - dword_F2CB4;
              if ( v159 <= 0 )
                goto LABEL_375;
              dword_F2C48 += v152 * v134;
              v158 += v152 * v161;
              v171 = dword_F2CB4;
            }
            v122 = dword_DE560 * (dword_F2CB4 - 1 - v171) + dword_DE558;
LABEL_281:
            v142 = dword_F2CB4 - dword_F2CA4;
            if ( v171 < dword_F2CB4 )
            {
              if ( v159 > v142 )
                v159 = dword_F2CB4 - dword_F2CA4;
            }
            else if ( v171 + v159 - dword_F2CB4 > v142 )
            {
              LOWORD(v1) = v142 - v171;
              v159 = v142 - v171 + dword_F2CB4;
              if ( v159 <= 0 )
                goto LABEL_375;
            }
            v115 = 9999999;
            for ( j = v159; j; --j )
            {
              v174 = v158 >> 16;
              if ( v158 >> 16 < 0 )
              {
                v175 = -v174;
                *v166 = 0;
                v166[1] = v156 - v175;
                v166[2] = v175;
                if ( v175 < v115 )
                  v115 = v175;
              }
              else
              {
                *v166 = v174;
                v166[1] = v156;
                v166[2] = 0;
                v115 = 0;
              }
              if ( v166[1] + *v166 > dword_F2CB8 )
                v166[1] = dword_F2CB8 - *v166;
              v158 += v161;
              v166 += 3;
            }
            v143 = v171 + dword_F2C94 - dword_F2CB4 + 1;
            if ( v143 > 0 )
            {
              v167 = (_DWORD *)(12 * v143 + dword_E9C38 + 45920);
              v118 = (_DWORD *)dword_F2C88;
              for ( k = v171 + dword_F2C94 - dword_F2CB4 + 2; k; --k )
              {
                v167 -= 3;
                if ( dword_E9C38 + 45920 > (unsigned int)v167 )
                  break;
                v144 = v167[1] + *v167 - *v118;
                if ( v144 > 0 )
                {
                  v167[1] -= v144;
                  if ( (int)v167[1] < 0 )
                    v167[1] = 0;
                }
                --v118;
              }
            }
            if ( v171 - v159 < 0 )
            {
              v128 = v159 - v171;
              v168 = (_DWORD *)(12 * v171 + dword_E9C38 + 45920);
              v119 = (_DWORD *)(dword_E9C38 + 59360);
              v145 = v171 - v159 - dword_F2CA4;
              if ( v145 < 0 )
              {
                LOWORD(v1) = v171 - v159 - dword_F2CA4;
                v159 = v171 - dword_F2CA4;
                if ( v171 - dword_F2CA4 <= 0 )
                  goto LABEL_375;
                v128 += v145;
              }
              v111 = v128;
              v129 = v128 - 1;
              if ( v111 > 0 )
              {
                while ( v129 )
                {
                  v168 += 3;
                  if ( dword_E9C38 + 45920 <= (unsigned int)v168 )
                  {
                    v146 = *v119 - *v168;
                    if ( v146 > 0 )
                    {
                      *v168 = *v119;
                      v168[1] -= v146;
                      if ( (int)v168[1] < 0 )
                        v168[1] = 0;
                      v168[2] += v146;
                    }
                  }
                  ++v119;
                  --v129;
                }
              }
            }
            goto LABEL_169;
          default:
            goto LABEL_375;
        }
      }
      if ( a1 != 2 )
        goto LABEL_124;
    }
    dword_F2C30 -= (dword_F2C64 * dword_F2C44) >> 17;
    dword_F2C2C -= -(dword_F2C54 * dword_F2C44) >> 17;
    goto LABEL_124;
  }
  v137 = (dword_F2C50 + dword_F2C44) >> 2;
  if ( a1 )
  {
    if ( a1 <= 1 )
    {
      dword_F2C30 += -((dword_F2C54 * v137) >> 16) - v137;
      dword_F2C2C += -((dword_F2C64 * v137) >> 16) - v137;
    }
    else if ( a1 == 2 )
    {
      dword_F2C30 += ((dword_F2C54 * v137) >> 16) - v137;
      dword_F2C2C += ((dword_F2C64 * v137) >> 16) - v137;
    }
  }
  LOWORD(v1) = dword_DE564;
  if ( (unsigned __int16)dword_DE564 > dword_F2C30 )
  {
    v135 = (dword_F2C34 << 16) / dword_F2C44;
    if ( -dword_F2C30 < 0 || dword_F2C30 == 0 )
    {
      dword_F2C4C = 0;
      if ( dword_F2C44 + dword_F2C30 - (unsigned __int16)dword_DE564 > 0 )
        dword_F2C44 -= dword_F2C44 + dword_F2C30 - (unsigned __int16)dword_DE564;
    }
    else
    {
      LOWORD(v1) = -(__int16)dword_F2C30;
      dword_F2C44 += dword_F2C30;
      if ( dword_F2C44 <= 0 )
        return v1;
      dword_F2C4C = v135 * -dword_F2C30;
      dword_F2C30 = 0;
      if ( (unsigned __int16)dword_DE564 <= dword_F2C44 )
        dword_F2C44 = (unsigned __int16)dword_DE564;
    }
    LOWORD(v1) = dword_DE568;
    if ( (unsigned __int16)dword_DE568 > dword_F2C2C )
    {
      v133 = (dword_F2C38 << 16) / dword_F2C50;
      if ( -dword_F2C2C < 0 || dword_F2C2C == 0 )
      {
        dword_F2C48 = 0;
        if ( dword_F2C50 + dword_F2C2C - (unsigned __int16)dword_DE568 > 0 )
          dword_F2C50 -= dword_F2C50 + dword_F2C2C - (unsigned __int16)dword_DE568;
      }
      else
      {
        LOWORD(v1) = -(__int16)dword_F2C2C;
        dword_F2C50 += dword_F2C2C;
        if ( dword_F2C50 <= 0 )
          return v1;
        dword_F2C48 = v133 * -dword_F2C2C;
        dword_F2C2C = 0;
        if ( (unsigned __int16)dword_DE568 <= dword_F2C50 )
          dword_F2C50 = (unsigned __int16)dword_DE568;
      }
      v153 = (_DWORD *)(dword_E9C38 + 36960);
      for ( m = dword_F2C44; m; --m )
      {
        v153[1] = dword_F2C4C >> 16;
        if ( (_DWORD *)(dword_E9C38 + 36960) == v153 )
          *v153 = 22;
        else
          *v153 = v153[1] - *(v153 - 1);
        dword_F2C4C += v135;
        v153 += 2;
      }
      if ( a1 == 1 && *(_BYTE *)(dword_D41A4 + 10) )
        sub_88740(dword_F2C70, dword_F2C30 + (dword_F2C44 >> 1), dword_F2C2C + (dword_F2C50 >> 1));
      LOWORD(v1) = dword_F2C2C * dword_DE560 + dword_F2C30 + dword_DE558;
      v121 = dword_F2C2C * dword_DE560 + dword_F2C30 + dword_DE558;
      while ( dword_F2C50 )
      {
        switch ( dword_F2C24 )
        {
          case 0:
            v2 = (char *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
            v3 = (_DWORD *)(dword_E9C38 + 36960);
            v4 = (_BYTE *)v121;
            v5 = dword_F2C44 >> 1;
            if ( !(dword_F2C44 & 1) )
            {
              v6 = v5 & 1;
              v7 = dword_F2C44 >> 2;
              if ( v6 )
              {
                ++v7;
                v3 = (_DWORD *)(dword_E9C38 + 36952);
                v4 = (_BYTE *)(v121 - 2);
                goto LABEL_48;
              }
              v3 = (_DWORD *)(dword_E9C38 + 36968);
              goto LABEL_44;
            }
            v8 = v5 + 2;
            v6 = v8 & 1;
            v7 = v8 >> 1;
            if ( !v6 )
            {
              v3 = (_DWORD *)(dword_E9C38 + 36944);
              v4 = (_BYTE *)(v121 - 3);
              goto LABEL_50;
            }
            v4 = (_BYTE *)(v121 - 1);
            while ( 1 )
            {
              v10 = *v2;
              v2 += v3[2];
              if ( v10 )
                v4[1] = v10;
LABEL_48:
              v11 = *v2;
              v2 += v3[4];
              if ( v11 )
                v4[2] = v11;
LABEL_50:
              v12 = *v2;
              v2 += v3[6];
              if ( v12 )
                v4[3] = v12;
              v4 += 4;
              v3 += 8;
              if ( !--v7 )
                break;
LABEL_44:
              v9 = *v2;
              v2 += *v3;
              if ( v9 )
                *v4 = v9;
            }
            break;
          case 1:
            v13 = dword_F2C20;
            v14 = (_BYTE *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
            v15 = (_DWORD *)(dword_E9C38 + 36960);
            v16 = (_BYTE *)v121;
            v17 = dword_F2C44 >> 1;
            if ( !(dword_F2C44 & 1) )
            {
              v15 = (_DWORD *)(dword_E9C38 + 36968);
              goto LABEL_57;
            }
            ++v17;
            v16 = (_BYTE *)(v121 - 1);
            while ( 1 )
            {
              LOBYTE(v13) = *v14;
              v14 += v15[2];
              if ( (_BYTE)v13 )
                v16[1] = byte_F6EE0[v13];
              v16 += 2;
              v15 += 4;
              if ( !--v17 )
                break;
LABEL_57:
              LOBYTE(v13) = *v14;
              v14 += *v15;
              if ( (_BYTE)v13 )
                *v16 = byte_F6EE0[v13];
            }
            break;
          case 2:
            v18 = (_BYTE *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
            v19 = (_DWORD *)(dword_E9C38 + 36960);
            v20 = (_BYTE *)v121;
            HIWORD(v21) = 0;
            v22 = dword_F2C44 >> 1;
            if ( !(dword_F2C44 & 1) )
            {
              v19 = (_DWORD *)(dword_E9C38 + 36968);
              goto LABEL_66;
            }
            ++v22;
            v20 = (_BYTE *)(v121 - 1);
            while ( 1 )
            {
              BYTE1(v21) = *v18;
              v18 += v19[2];
              if ( BYTE1(v21) )
              {
                LOBYTE(v21) = v20[1];
                v20[1] = byte_FAEE0[v21];
              }
              v20 += 2;
              v19 += 4;
              if ( !--v22 )
                break;
LABEL_66:
              BYTE1(v21) = *v18;
              v18 += *v19;
              if ( BYTE1(v21) )
              {
                LOBYTE(v21) = *v20;
                *v20 = byte_FAEE0[v21];
              }
            }
            break;
          case 3:
            v23 = (_BYTE *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
            v24 = (_DWORD *)(dword_E9C38 + 36960);
            v25 = (_BYTE *)v121;
            HIWORD(v26) = 0;
            v27 = dword_F2C44 >> 1;
            if ( !(dword_F2C44 & 1) )
            {
              v24 = (_DWORD *)(dword_E9C38 + 36968);
              goto LABEL_75;
            }
            ++v27;
            v25 = (_BYTE *)(v121 - 1);
            while ( 1 )
            {
              LOBYTE(v26) = *v23;
              v23 += v24[2];
              if ( (_BYTE)v26 )
              {
                BYTE1(v26) = v25[1];
                v25[1] = byte_FAEE0[v26];
              }
              v25 += 2;
              v24 += 4;
              if ( !--v27 )
                break;
LABEL_75:
              LOBYTE(v26) = *v23;
              v23 += *v24;
              if ( (_BYTE)v26 )
              {
                BYTE1(v26) = *v25;
                *v25 = byte_FAEE0[v26];
              }
            }
            break;
          case 4:
            HIWORD(v31) = HIWORD(dword_F2C3C);
            v28 = (_BYTE *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
            v29 = (_DWORD *)(dword_E9C38 + 36960);
            v30 = (_BYTE *)v121;
            BYTE1(v31) = dword_F2C3C;
            v32 = dword_F2C44 >> 1;
            if ( !(dword_F2C44 & 1) )
            {
              v29 = (_DWORD *)(dword_E9C38 + 36968);
              goto LABEL_84;
            }
            ++v32;
            v30 = (_BYTE *)(v121 - 1);
            while ( 1 )
            {
              LOBYTE(v31) = *v28;
              v28 += v29[2];
              if ( (_BYTE)v31 )
                v30[1] = byte_FAEE0[v31];
              v30 += 2;
              v29 += 4;
              if ( !--v32 )
                break;
LABEL_84:
              LOBYTE(v31) = *v28;
              v28 += *v29;
              if ( (_BYTE)v31 )
                *v30 = byte_FAEE0[v31];
            }
            break;
          case 5:
            v33 = dword_F2C3C;
            v34 = (_BYTE *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
            v35 = (_DWORD *)(dword_E9C38 + 36960);
            v36 = (_BYTE *)v121;
            v37 = dword_F2C44 >> 1;
            if ( !(dword_F2C44 & 1) )
            {
              v35 = (_DWORD *)(dword_E9C38 + 36968);
              goto LABEL_93;
            }
            ++v37;
            v36 = (_BYTE *)(v121 - 1);
            while ( 1 )
            {
              BYTE1(v33) = *v34;
              v34 += v35[2];
              if ( BYTE1(v33) )
                v36[1] = byte_FAEE0[v33];
              v36 += 2;
              v35 += 4;
              if ( !--v37 )
                break;
LABEL_93:
              BYTE1(v33) = *v34;
              v34 += *v35;
              if ( BYTE1(v33) )
                *v36 = byte_FAEE0[v33];
            }
            break;
          case 6:
            v38 = dword_F2C20;
            v39 = (_BYTE *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
            v40 = (_DWORD *)(dword_E9C38 + 36960);
            v41 = (_BYTE *)v121;
            HIWORD(v42) = 0;
            v43 = dword_F2C44 >> 1;
            if ( !(dword_F2C44 & 1) )
            {
              v40 = (_DWORD *)(dword_E9C38 + 36968);
              goto LABEL_102;
            }
            ++v43;
            v41 = (_BYTE *)(v121 - 1);
            while ( 1 )
            {
              BYTE1(v42) = *v39;
              v39 += v40[2];
              if ( BYTE1(v42) )
              {
                LOBYTE(v42) = v41[1];
                LOBYTE(v38) = byte_FAEE0[v42];
                v41[1] = byte_F6EE0[v38];
              }
              v41 += 2;
              v40 += 4;
              if ( !--v43 )
                break;
LABEL_102:
              BYTE1(v42) = *v39;
              v39 += *v40;
              if ( BYTE1(v42) )
              {
                LOBYTE(v42) = *v41;
                LOBYTE(v38) = byte_FAEE0[v42];
                *v41 = byte_F6EE0[v38];
              }
            }
            break;
          case 7:
            v44 = dword_F2C20;
            v45 = (_BYTE *)(dword_F2C40 * (dword_F2C48 >> 16) + dword_F2C28 + *(_DWORD *)(dword_E9C38 + 36964));
            v46 = (_DWORD *)(dword_E9C38 + 36960);
            v47 = (_BYTE *)v121;
            HIWORD(v48) = 0;
            v49 = dword_F2C44 >> 1;
            if ( !(dword_F2C44 & 1) )
            {
              v46 = (_DWORD *)(dword_E9C38 + 36968);
              goto LABEL_111;
            }
            ++v49;
            v47 = (_BYTE *)(v121 - 1);
            while ( 1 )
            {
              LOBYTE(v48) = *v45;
              v45 += v46[2];
              if ( (_BYTE)v48 )
              {
                BYTE1(v48) = v47[1];
                LOBYTE(v44) = byte_FAEE0[v48];
                v47[1] = byte_F6EE0[v44];
              }
              v47 += 2;
              v46 += 4;
              if ( !--v49 )
                break;
LABEL_111:
              LOBYTE(v48) = *v45;
              v45 += *v46;
              if ( (_BYTE)v48 )
              {
                BYTE1(v48) = *v47;
                LOBYTE(v44) = byte_FAEE0[v48];
                *v47 = byte_F6EE0[v44];
              }
            }
            break;
          default:
            break;
        }
        dword_F2C48 += v133;
        LOWORD(v1) = dword_DE560;
        v121 += dword_DE560;
        --dword_F2C50;
      }
    }
  }
  return v1;
}
// D41A4: using guessed type int dword_D41A4;
// DE558: using guessed type int dword_DE558;
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;
// E9C38: using guessed type int dword_E9C38;
// F2C20: using guessed type int dword_F2C20;
// F2C24: using guessed type int dword_F2C24;
// F2C28: using guessed type int dword_F2C28;
// F2C2C: using guessed type int dword_F2C2C;
// F2C30: using guessed type int dword_F2C30;
// F2C34: using guessed type int dword_F2C34;
// F2C38: using guessed type int dword_F2C38;
// F2C3C: using guessed type int dword_F2C3C;
// F2C40: using guessed type int dword_F2C40;
// F2C44: using guessed type int dword_F2C44;
// F2C48: using guessed type int dword_F2C48;
// F2C4C: using guessed type int dword_F2C4C;
// F2C50: using guessed type int dword_F2C50;
// F2C54: using guessed type int dword_F2C54;
// F2C64: using guessed type int dword_F2C64;
// F2C70: using guessed type int dword_F2C70;
// F2C84: using guessed type int dword_F2C84;
// F2C88: using guessed type int dword_F2C88;
// F2C8C: using guessed type int dword_F2C8C;
// F2C90: using guessed type int dword_F2C90;
// F2C94: using guessed type int dword_F2C94;
// F2C98: using guessed type int dword_F2C98;
// F2C9C: using guessed type int dword_F2C9C;
// F2CA4: using guessed type int dword_F2CA4;
// F2CAC: using guessed type int dword_F2CAC;
// F2CB4: using guessed type int dword_F2CB4;
// F2CB8: using guessed type int dword_F2CB8;
// F2CBC: using guessed type int dword_F2CBC;
// F2CC6: using guessed type char byte_F2CC6;

//----- (00043830) --------------------------------------------------------
int __usercall sub_43830@<eax>(int a1@<esi>, int a2)
{
  word_17B4E0 = *(_WORD *)(a2 + 23);
  *(_DWORD *)(dword_D41A0 + 8) = *(_DWORD *)(a2 + 23);
  memset(word_15B4E0, 0, &loc_20000);
  sub_B5E70(word_17B4E0, *(_WORD *)(a2 + 27), *(_WORD *)(a2 + 31));
  sub_44DB0();
  memset(word_15B4E0, 0, &loc_20000);
  sub_44E40(*(_DWORD *)(a2 + 39), *(_WORD *)(a2 + 43));
  sub_45AA0();
  sub_440D0(*(_WORD *)(a2 + 51));
  sub_45060(*(_WORD *)(a2 + 55), *(_WORD *)(a2 + 59));
  sub_44320();
  sub_45210(*(_WORD *)(a2 + 55), *(_WORD *)(a2 + 59));
  sub_454F0(*(_WORD *)(a2 + 47), *(_WORD *)(a2 + 67));
  sub_45600(*(_WORD *)(a2 + 63));
  sub_43FC0();
  memset(byte_10B4E0, 0, sub_10000);
  sub_43970(a1);
  sub_43EE0();
  sub_44580();
  if ( byte_D41B6 )
    sub_43B40();
  else
    sub_43D50();
  return sub_44D00();
}
// 10000: using guessed type void __noreturn sub_10000();
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// 15B4E0: using guessed type __int16 word_15B4E0[9616];
// 17B4E0: using guessed type __int16 word_17B4E0;

//----- (00043970) --------------------------------------------------------
unsigned int __usercall sub_43970@<eax>(int a1@<esi>)
{
  unsigned __int16 v1; // bx
  unsigned int result; // eax

  v1 = 0;
  do
  {
    result = sub_439A0(a1, v1);
    byte_11B4E0[v1++] = result;
  }
  while ( v1 );
  return result;
}

//----- (000439A0) --------------------------------------------------------
unsigned int __usercall sub_439A0@<eax>(int a1@<esi>, unsigned __int16 a2)
{
  unsigned __int16 v2; // ax
  unsigned __int8 v3; // dl
  unsigned __int8 v4; // dh
  unsigned __int8 v5; // ch
  unsigned __int8 v6; // cl
  int v7; // ebx
  unsigned __int8 v8; // cl
  int v9; // ebx
  unsigned __int8 v10; // cl
  int v11; // ebx
  unsigned __int8 v12; // cl
  int v13; // ebx
  unsigned __int8 v14; // cl
  int v15; // ebx
  unsigned __int8 v16; // cl
  int v17; // ebx
  unsigned __int8 v18; // cl
  int v19; // ebx
  unsigned __int8 v20; // al
  unsigned int v21; // ebx
  unsigned int v22; // ebx

  LOBYTE(v2) = a2;
  LOWORD(a1) = (unsigned __int8)byte_11B4E0[a2];
  if ( (byte_13B4E0[a2] & 7) != 0 )
  {
    HIBYTE(v2) = HIBYTE(a2) - 1;
    v3 = byte_11B4E0[a2];
    v4 = v3;
    v5 = v3;
    v6 = byte_11B4E0[v2];
    v7 = v6;
    if ( v6 > v3 )
      v3 = byte_11B4E0[v2];
    if ( v6 < v4 )
      v4 = byte_11B4E0[v2];
    LOBYTE(v2) = a2 + 1;
    v8 = byte_11B4E0[v2];
    v9 = v8 + v7;
    if ( v8 > v3 )
      v3 = byte_11B4E0[v2];
    if ( v8 < v4 )
      v4 = byte_11B4E0[v2];
    HIBYTE(v2) = HIBYTE(a2);
    v10 = byte_11B4E0[v2];
    v11 = v10 + v9;
    if ( v10 > v3 )
      v3 = byte_11B4E0[v2];
    if ( v10 < v4 )
      v4 = byte_11B4E0[v2];
    HIBYTE(v2) = HIBYTE(a2) + 1;
    v12 = byte_11B4E0[v2];
    v13 = v12 + v11;
    if ( v12 > v3 )
      v3 = byte_11B4E0[v2];
    if ( v12 < v4 )
      v4 = byte_11B4E0[v2];
    LOBYTE(v2) = a2;
    v14 = byte_11B4E0[v2];
    v15 = v14 + v13;
    if ( v14 > v3 )
      v3 = byte_11B4E0[v2];
    if ( v14 < v4 )
      v4 = byte_11B4E0[v2];
    LOBYTE(v2) = a2 - 1;
    v16 = byte_11B4E0[v2];
    v17 = v16 + v15;
    if ( v16 > v3 )
      v3 = byte_11B4E0[v2];
    if ( v16 < v4 )
      v4 = byte_11B4E0[v2];
    HIBYTE(v2) = HIBYTE(a2);
    v18 = byte_11B4E0[v2];
    v19 = v18 + v17;
    if ( v18 > v3 )
      v3 = byte_11B4E0[v2];
    if ( v18 < v4 )
      v4 = byte_11B4E0[v2];
    HIBYTE(v2) = HIBYTE(a2) - 1;
    v20 = byte_11B4E0[v2];
    v21 = v20 + v19;
    if ( v20 > v3 )
      v3 = v20;
    if ( v20 < v4 )
      v4 = v20;
    v22 = v21 >> 3;
    if ( (unsigned __int8)(v5 - v4) <= 4u )
    {
      if ( (unsigned __int8)(v3 - v5) <= 4u )
        return a1;
      if ( (unsigned __int8)(v3 - v5) <= 0xAu )
        return (v5 + v22) >> 1;
    }
    else if ( (unsigned __int8)(v5 - v4) <= 0xAu )
    {
      return (v22 + v5) >> 1;
    }
    return v22;
  }
  return a1;
}

//----- (00043B40) --------------------------------------------------------
__int16 sub_43B40()
{
  unsigned __int16 v0; // dx
  int v1; // eax
  unsigned __int8 v2; // bl
  unsigned __int8 v3; // bh
  char v4; // cl

  v0 = 0;
  do
  {
    v1 = (unsigned __int8)byte_11B4E0[v0];
    if ( v1 > (unsigned __int8)byte_D41B7 )
      LOBYTE(v1) = byte_D41B7;
    v2 = byte_D41B7 - v1;
    byte_14B4E0[v0] = byte_D41B7 - v1;
    v3 = byte_11B4E0[v0];
    if ( v2 > v3 )
    {
      byte_13B4E0[v0] &= ~8u;
    }
    else
    {
      v4 = byte_13B4E0[v0] | 8;
      byte_14B4E0[v0] = v3 - 1;
      byte_13B4E0[v0] = v4;
    }
    ++v0;
  }
  while ( v0 );
  return sub_43BB0();
}
// D41B7: using guessed type char byte_D41B7;

//----- (00043BB0) --------------------------------------------------------
__int16 sub_43BB0()
{
  unsigned int v0; // esi
  unsigned __int16 v1; // cx
  signed int v2; // ebx
  unsigned __int16 v3; // bx
  int v4; // eax
  unsigned __int8 v5; // dh
  char v6; // cl

  v0 = 37487429;
  v1 = 0;
  do
  {
    if ( (byte_13B4E0[v1] & 8) == 0 )
    {
      v0 = 9377 * v0 + 9439;
      v2 = v0 % 7 - 3 + (unsigned __int8)byte_14B4E0[v1];
      if ( v2 < 0 )
        v2 = 0;
      if ( v2 > 254 )
        LOBYTE(v2) = -2;
      byte_14B4E0[v1] = v2;
    }
    ++v1;
  }
  while ( v1 );
  v3 = 0;
  do
  {
    v4 = v3;
    v5 = byte_11B4E0[v3];
    if ( (unsigned __int8)byte_14B4E0[v3] > v5 )
    {
      byte_13B4E0[v3] &= ~8u;
    }
    else
    {
      v6 = byte_13B4E0[v3] | 8;
      byte_14B4E0[v3] = v5 - 1;
      byte_13B4E0[v3] = v6;
    }
    ++v3;
  }
  while ( v3 );
  return v4;
}

//----- (00043C60) --------------------------------------------------------
void __cdecl sub_43C60(unsigned __int8 a1, char a2, int a3, int a4)
{
  unsigned int v4; // ecx
  int v5; // esi
  unsigned __int16 v6; // bx
  int v7; // edi
  int v8; // ecx
  unsigned __int16 v9; // bx
  int v10; // esi
  unsigned __int8 v11; // dh

  v4 = 37487429;
  LOBYTE(v6) = a1;
  v5 = a3;
  HIBYTE(v6) = a2;
  while ( (_WORD)--v5 != 0xFFFF )
  {
    v7 = a4;
    while ( (_WORD)--v7 != 0xFFFF )
    {
      if ( (byte_13B4E0[v6] & 8) == 0 )
      {
        v4 = 9377 * v4 + 9439;
        byte_14B4E0[v6] += v4 % 7 - 3;
      }
      LOBYTE(v6) = v6 + 1;
    }
    v6 = __PAIR16__(HIBYTE(v6), a1) + 256;
  }
  LOBYTE(v9) = a1;
  v8 = a3;
  HIBYTE(v9) = a2;
  while ( (_WORD)--v8 != 0xFFFF )
  {
    v10 = a4;
    while ( (_WORD)--v10 != 0xFFFF )
    {
      v11 = byte_11B4E0[v9];
      if ( (unsigned __int8)byte_14B4E0[v9] > v11 )
      {
        byte_13B4E0[v9] &= ~8u;
      }
      else
      {
        byte_14B4E0[v9] = v11 - 1;
        byte_13B4E0[v9] |= 8u;
      }
      LOBYTE(v9) = v9 + 1;
    }
    v9 = __PAIR16__(HIBYTE(v9), a1) + 256;
  }
}

//----- (00043D50) --------------------------------------------------------
unsigned __int16 sub_43D50()
{
  unsigned __int16 result; // ax
  unsigned __int16 v1; // dx
  unsigned __int16 v2; // bx
  unsigned __int16 v3; // bx
  unsigned __int16 v4; // bx
  unsigned __int16 v5; // bx
  unsigned __int16 v6; // bx
  unsigned __int16 v7; // bx
  unsigned __int16 v8; // dx
  unsigned __int16 v9; // bx
  unsigned __int16 v10; // bx

  result = 0;
  do
  {
    byte_13B4E0[result] &= ~8u;
    if ( !byte_11B4E0[result] )
    {
      --HIBYTE(result);
      v1 = result;
      LOBYTE(result) = result + 1;
      v2 = result;
      ++HIBYTE(result);
      LOBYTE(v1) = (byte_11B4E0[v2] != 0) + (byte_11B4E0[v1] != 0);
      v3 = result;
      ++HIBYTE(result);
      LOBYTE(v1) = (byte_11B4E0[v3] != 0) + v1;
      v4 = result;
      LOBYTE(result) = result - 1;
      LOBYTE(v1) = (byte_11B4E0[v4] != 0) + v1;
      v5 = result;
      LOBYTE(result) = result - 1;
      LOBYTE(v1) = (byte_11B4E0[v5] != 0) + v1;
      v6 = result;
      --HIBYTE(result);
      LOBYTE(v1) = (byte_11B4E0[v6] != 0) + v1;
      v7 = result;
      --HIBYTE(result);
      LOBYTE(v1) = (byte_11B4E0[v7] != 0) + v1;
      LOBYTE(v7) = byte_11B4E0[result] != 0;
      LOBYTE(result) = result + 1;
      ++HIBYTE(result);
      if ( !((_BYTE)v7 + (_BYTE)v1) )
      {
        v8 = result;
        LOBYTE(result) = result - 1;
        v9 = result;
        --HIBYTE(result);
        LOBYTE(v8) = (byte_10B4E0[v9] != 0) + (byte_10B4E0[v8] != 0);
        v10 = result;
        LOBYTE(result) = result + 1;
        LOBYTE(v8) = (byte_10B4E0[result] != 0) + (byte_10B4E0[v10] != 0) + v8;
        ++HIBYTE(result);
        if ( !(_BYTE)v8 )
          byte_13B4E0[result] |= 8u;
      }
    }
    ++result;
  }
  while ( result );
  return result;
}

//----- (00043EE0) --------------------------------------------------------
unsigned __int16 sub_43EE0()
{
  unsigned __int16 result; // ax
  unsigned __int16 v1; // cx
  char v2; // dh
  unsigned __int8 v3; // dl
  int v4; // ecx
  char v5; // bl
  char v6; // bh
  unsigned __int8 v7; // cl
  char v8; // bh
  char v9; // bh
  unsigned __int16 v10; // cx
  unsigned __int16 v11; // cx
  unsigned __int16 v12; // cx
  unsigned __int16 v13; // cx

  result = 0;
  do
  {
    v1 = result;
    v2 = 0;
    LOBYTE(result) = result + 1;
    v3 = byte_11B4E0[v1];
    v4 = v1;
    LOWORD(v4) = result;
    v5 = 0;
    v6 = byte_13B4E0[result];
    if ( v6 )
    {
      if ( v6 == 4 )
        v2 = 1;
    }
    else
    {
      v7 = byte_11B4E0[v4];
      v5 = 1;
      if ( v7 < v3 )
        v3 = v7;
    }
    ++HIBYTE(result);
    v8 = byte_13B4E0[result];
    if ( v8 )
    {
      if ( v8 == 4 )
        ++v2;
    }
    else
    {
      ++v5;
      if ( (unsigned __int8)byte_11B4E0[result] < v3 )
        v3 = byte_11B4E0[result];
    }
    LOBYTE(result) = result - 1;
    v9 = byte_13B4E0[result];
    if ( v9 )
    {
      if ( v9 == 4 )
        ++v2;
    }
    else
    {
      ++v5;
      if ( (unsigned __int8)byte_11B4E0[result] < v3 )
        v3 = byte_11B4E0[result];
    }
    --HIBYTE(result);
    if ( v2 && v5 && !v3 )
    {
      v10 = result;
      LOBYTE(result) = result + 1;
      byte_11B4E0[v10] = 0;
      v11 = result;
      ++HIBYTE(result);
      byte_11B4E0[v11] = 0;
      v12 = result;
      LOBYTE(result) = result - 1;
      byte_11B4E0[v12] = 0;
      v13 = result;
      --HIBYTE(result);
      byte_11B4E0[v13] = 0;
    }
    ++result;
  }
  while ( result );
  return result;
}

//----- (00043FC0) --------------------------------------------------------
unsigned __int16 sub_43FC0()
{
  unsigned __int16 result; // ax
  unsigned __int16 v1; // dx
  char v2; // dh
  unsigned __int16 v3; // bx
  unsigned __int16 v4; // bx
  unsigned __int16 v5; // bx
  unsigned __int16 v6; // bx
  unsigned __int16 v7; // bx
  char v8; // bl
  unsigned __int16 v9; // ax

  result = 0;
  do
  {
    --HIBYTE(result);
    v1 = result;
    LOBYTE(result) = result + 1;
    v2 = byte_13B4E0[v1];
    LOBYTE(v1) = v2 == byte_13B4E0[result];
    ++HIBYTE(result);
    v3 = result;
    ++HIBYTE(result);
    LOBYTE(v1) = (v2 == byte_13B4E0[v3]) + v1;
    v4 = result;
    LOBYTE(result) = result - 1;
    LOBYTE(v1) = (v2 == byte_13B4E0[v4]) + v1;
    v5 = result;
    LOBYTE(result) = result - 1;
    LOBYTE(v1) = (v2 == byte_13B4E0[v5]) + v1;
    v6 = result;
    --HIBYTE(result);
    LOBYTE(v1) = (v2 == byte_13B4E0[v6]) + v1;
    v7 = result;
    --HIBYTE(result);
    v8 = (v2 == byte_13B4E0[result]) + (v2 == byte_13B4E0[v7]) + v1;
    LOBYTE(result) = result + 1;
    HIBYTE(v9) = HIBYTE(result) + 1;
    if ( v2 )
    {
      if ( v8 == 7 )
        byte_13B4E0[v9] = v2;
    }
    result = v9 + 1;
  }
  while ( result );
  return result;
}

//----- (000440D0) --------------------------------------------------------
unsigned __int16 __cdecl sub_440D0(unsigned __int16 a1)
{
  unsigned __int16 result; // ax
  unsigned __int8 v2; // dh
  unsigned __int8 v3; // dl
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // ax
  int v6; // ebx
  char v7; // bl
  char v8; // dl
  char v9; // dh

  result = 0;
  do
  {
    if ( byte_13B4E0[result] == 5 )
    {
      v2 = 0;
      v3 = -1;
      if ( byte_11B4E0[result] )
        v2 = byte_11B4E0[result];
      if ( byte_11B4E0[result] != -1 )
        v3 = byte_11B4E0[result];
      --HIBYTE(result);
      if ( v2 < (unsigned __int8)byte_11B4E0[result] )
        v2 = byte_11B4E0[result];
      if ( v3 > (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      LOBYTE(result) = result + 1;
      ++HIBYTE(result);
      if ( v2 < (unsigned __int8)byte_11B4E0[result] )
        v2 = byte_11B4E0[v4];
      if ( v3 > (unsigned __int8)byte_11B4E0[v4] )
        v3 = byte_11B4E0[v4];
      LOBYTE(v4) = v4 - 1;
      ++HIBYTE(v4);
      if ( v2 < (unsigned __int8)byte_11B4E0[v4] )
        v2 = byte_11B4E0[v5];
      if ( v3 > (unsigned __int8)byte_11B4E0[v5] )
        v3 = byte_11B4E0[v5];
      LOBYTE(result) = v5 - 1;
      HIBYTE(result) = HIBYTE(v5) - 1;
      if ( v2 < (unsigned __int8)byte_11B4E0[result] )
        v2 = byte_11B4E0[result];
      if ( v3 > (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      v6 = v2 - v3;
      LOBYTE(result) = result + 1;
      if ( v6 <= a1 )
      {
        if ( v6 == a1 )
          byte_13B4E0[result] = 4;
        else
          byte_13B4E0[result] = 3;
      }
    }
    ++result;
  }
  while ( result );
  do
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    if ( byte_13B4E0[result] == 3 )
      v7 = 1;
    if ( byte_13B4E0[result] == 2 )
      v8 = 1;
    if ( byte_13B4E0[result] == 5 )
      v9 = 1;
    LOBYTE(result) = result + 1;
    if ( byte_13B4E0[result] == 3 )
      ++v7;
    if ( byte_13B4E0[result] == 2 )
      ++v8;
    if ( byte_13B4E0[result] == 5 )
      ++v9;
    ++HIBYTE(result);
    if ( byte_13B4E0[result] == 3 )
      ++v7;
    if ( byte_13B4E0[result] == 2 )
      ++v8;
    if ( byte_13B4E0[result] == 5 )
      ++v9;
    LOBYTE(result) = result - 1;
    if ( byte_13B4E0[result] == 3 )
      ++v7;
    if ( byte_13B4E0[result] == 2 )
      ++v8;
    if ( byte_13B4E0[result] == 5 )
      ++v9;
    --HIBYTE(result);
    if ( !v8 && v7 && v9 )
    {
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result + 1;
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      ++HIBYTE(result);
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result - 1;
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      --HIBYTE(result);
    }
    ++result;
  }
  while ( result );
  return result;
}

//----- (00044320) --------------------------------------------------------
unsigned __int16 sub_44320()
{
  unsigned __int16 result; // ax
  char v1; // bl
  char v2; // dh
  char v3; // dl

  result = 0;
  do
  {
    v1 = 0;
    v2 = 0;
    v3 = 0;
    if ( !byte_13B4E0[result] )
      v1 = 1;
    if ( byte_13B4E0[result] == 5 )
      v3 = 1;
    if ( byte_13B4E0[result] == 3 )
      v2 = 1;
    LOBYTE(result) = result + 1;
    if ( !byte_13B4E0[result] )
      ++v1;
    if ( byte_13B4E0[result] == 5 )
      ++v3;
    if ( byte_13B4E0[result] == 3 )
      ++v2;
    ++HIBYTE(result);
    if ( !byte_13B4E0[result] )
      ++v1;
    if ( byte_13B4E0[result] == 5 )
      ++v3;
    if ( byte_13B4E0[result] == 3 )
      ++v2;
    LOBYTE(result) = result - 1;
    if ( !byte_13B4E0[result] )
      ++v1;
    if ( byte_13B4E0[result] == 5 )
      ++v3;
    if ( byte_13B4E0[result] == 3 )
      ++v2;
    --HIBYTE(result);
    if ( v2 && v3 )
    {
      if ( byte_13B4E0[result] == 5 )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result + 1;
      if ( byte_13B4E0[result] == 5 )
        byte_13B4E0[result] = 4;
      ++HIBYTE(result);
      if ( byte_13B4E0[result] == 5 )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result - 1;
      if ( byte_13B4E0[result] == 5 )
        byte_13B4E0[result] = 4;
      --HIBYTE(result);
    }
    if ( v2 && v1 )
    {
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result + 1;
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      ++HIBYTE(result);
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result - 1;
      if ( byte_13B4E0[result] == 3 )
        byte_13B4E0[result] = 4;
      --HIBYTE(result);
    }
    if ( v1 && v3 )
    {
      if ( byte_13B4E0[result] )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result + 1;
      if ( byte_13B4E0[result] )
        byte_13B4E0[result] = 4;
      ++HIBYTE(result);
      if ( byte_13B4E0[result] )
        byte_13B4E0[result] = 4;
      LOBYTE(result) = result - 1;
      if ( byte_13B4E0[result] )
        byte_13B4E0[result] = 4;
      --HIBYTE(result);
    }
    ++result;
  }
  while ( result );
  return result;
}

//----- (00044580) --------------------------------------------------------
__int16 sub_44580()
{
  _BYTE *v0; // eax
  unsigned __int16 i; // bx
  unsigned __int16 v2; // bx
  char v3; // al
  char v4; // dl
  char v5; // cl
  char v6; // ah
  int v7; // edi
  unsigned __int8 *v8; // esi
  unsigned __int8 v9; // dh
  unsigned __int8 *v10; // esi
  char v11; // dh
  char v12; // al
  char v13; // dl
  char v14; // dh
  char v15; // ah
  unsigned __int8 *v16; // esi
  char v17; // cl
  unsigned __int8 v18; // dh
  unsigned __int8 *v19; // esi
  char v20; // dh
  char v21; // al
  char v22; // ah
  char v23; // dh
  char v24; // dl
  int v25; // edi
  unsigned __int8 *v26; // esi
  char v27; // cl
  unsigned __int8 v28; // dh
  unsigned __int8 *v29; // esi
  char v30; // dh
  char v31; // al
  char v32; // dl
  char v33; // dh
  char v34; // ah
  unsigned __int8 *v35; // esi
  char v36; // cl
  unsigned __int8 v37; // dh
  unsigned __int8 *v38; // esi
  char v39; // dh
  int v40; // edi
  int v41; // esi
  char v42; // al
  unsigned __int8 *v43; // esi
  char v44; // cl
  unsigned __int8 v45; // dh
  unsigned __int8 *v46; // esi
  char v47; // dh
  char v48; // al
  char v49; // dl
  char v50; // dh
  int v51; // edi
  int v52; // esi
  char v53; // ah
  unsigned __int8 *v54; // esi
  char v55; // cl
  unsigned __int8 v56; // dh
  unsigned __int8 *v57; // esi
  char v58; // dh
  char v59; // al
  char v60; // ah
  char v61; // dh
  char v62; // dl
  int v63; // edi
  unsigned __int8 *v64; // esi
  char v65; // cl
  unsigned __int8 v66; // dh
  unsigned __int8 *v67; // esi
  unsigned __int8 *v68; // eax
  unsigned __int8 v69; // dl
  char *v70; // esi
  char j; // bl
  char k; // ch
  char m; // cl
  char n; // bh
  _BYTE *v75; // eax
  unsigned __int16 v76; // cx
  int v77; // eax
  unsigned __int16 v78; // ax
  char v79; // bh
  unsigned __int16 v80; // ax
  int v81; // esi
  unsigned __int8 v82; // al
  unsigned __int8 v83; // bl
  int v84; // edx
  int v86; // [esp+0h] [ebp-18h]
  int v87; // [esp+0h] [ebp-18h]
  char *v88; // [esp+8h] [ebp-10h]
  int v89; // [esp+Ch] [ebp-Ch]
  char v90; // [esp+14h] [ebp-4h]

  v0 = (_BYTE *)dword_180628;
  for ( i = 0; i < 0x961u; ++i )
  {
    *v0 = 0;
    v0 += 25;
  }
  v2 = 0;
  v89 = dword_180628;
  v88 = (char *)&unk_D47E0;
  while ( v2 < 0x94u )
  {
    v3 = *v88;
    if ( *v88 >= 0 )
    {
      v4 = v88[1];
      if ( v4 >= 0 )
      {
        v5 = v88[2];
        if ( v5 >= 0 )
        {
          v6 = v88[3];
          if ( v6 >= 0 )
          {
            v7 = 49 * v4 + 7 * v5 + v6 + 343 * v3;
            v8 = (unsigned __int8 *)(v89 + 25 * v7);
            v9 = *v8;
            if ( *v8 < 0xCu )
            {
              *v8 = v9 + 1;
              v10 = &v8[v9];
              v10[13] = 0;
              v10[1] = v2;
            }
            v11 = v3;
            v12 = v4;
            v13 = v11;
            v14 = v6;
            v86 = 7 * v6;
            v15 = v5;
            v16 = (unsigned __int8 *)(v89 + 25 * (49 * v13 + v5 + v86 + 343 * v12));
            v17 = v14;
            v18 = *v16;
            if ( *v16 < 0xCu )
            {
              *v16 = v18 + 1;
              v19 = &v16[v18];
              v19[13] = 16;
              v19[1] = v2;
            }
            v20 = v12;
            v21 = v15;
            v22 = v20;
            v23 = v13;
            v24 = v17;
            v25 = 49 * v17 + v22 + 7 * v23 + 343 * v21;
            v26 = (unsigned __int8 *)(v89 + 25 * v25);
            v27 = v23;
            v28 = *v26;
            if ( *v26 < 0xCu )
            {
              *v26 = v28 + 1;
              v29 = &v26[v28];
              v29[13] = 48;
              v29[1] = v2;
            }
            v30 = v21;
            v31 = v24;
            v32 = v30;
            v33 = v22;
            v87 = 7 * v22;
            v34 = v27;
            v35 = (unsigned __int8 *)(v89 + 25 * (49 * v32 + v27 + v87 + 343 * v31));
            v36 = v33;
            v37 = *v35;
            if ( *v35 < 0xCu )
            {
              *v35 = v37 + 1;
              v38 = &v35[v37];
              v38[13] = 32;
              v38[1] = v2;
            }
            v39 = v31;
            v40 = v31;
            v41 = 8 * v31;
            v42 = v36;
            v43 = (unsigned __int8 *)(v89 + 25 * (49 * v32 + v41 - v40 + v34 + 343 * v36));
            v44 = v39;
            v45 = *v43;
            if ( *v43 < 0xCu )
            {
              *v43 = v45 + 1;
              v46 = &v43[v45];
              v46[13] = 96;
              v46[1] = v2;
            }
            v47 = v42;
            v48 = v32;
            v49 = v47;
            v50 = v34;
            v51 = v34;
            v52 = 8 * v34;
            v53 = v44;
            v54 = (unsigned __int8 *)(v89 + 25 * (49 * v49 + v52 - v51 + v44 + 343 * v48));
            v55 = v50;
            v56 = *v54;
            if ( *v54 < 0xCu )
            {
              *v54 = v56 + 1;
              v57 = &v54[v56];
              v57[13] = 112;
              v57[1] = v2;
            }
            v58 = v48;
            v59 = v53;
            v60 = v58;
            v61 = v49;
            v62 = v55;
            v63 = 49 * v55 + 7 * v61 + v60 + 343 * v59;
            v64 = (unsigned __int8 *)(v89 + 25 * v63);
            v65 = v61;
            v66 = *v64;
            if ( *v64 < 0xCu )
            {
              *v64 = v66 + 1;
              v67 = &v64[v66];
              v67[13] = 80;
              v67[1] = v2;
            }
            v68 = (unsigned __int8 *)(v89 + 25 * (343 * v62 + 7 * v60 + v65 + 49 * v59));
            v69 = *v68;
            if ( *v68 < 0xCu )
            {
              *v68 = v69 + 1;
              v68[v69 + 13] = 64;
              v68[v69 + 1] = v2;
            }
          }
        }
      }
    }
    ++v2;
    v88 += 4;
  }
  v70 = &byte_F2CD0;
  for ( j = 0; j < 7; ++j )
  {
    for ( k = 0; k < 7; ++k )
    {
      for ( m = 0; m < 7; ++m )
      {
        for ( n = 0; n < 7; ++n )
        {
          v75 = (_BYTE *)(v89 + 25 * (49 * k + 7 * m + n + 343 * j));
          if ( *v75 )
          {
            *v70 = v75[1];
            v70[1] = v75[13];
          }
          else
          {
            *v70 = 1;
            v70[1] = 0;
          }
          v70 += 2;
        }
      }
    }
  }
  v76 = 0;
  do
  {
    v77 = v76;
    if ( !byte_10B4E0[v76] )
    {
      LOBYTE(v76) = v76 + 1;
      v90 = byte_13B4E0[v77] & 7;
      v78 = v76;
      ++HIBYTE(v76);
      v79 = byte_13B4E0[v78];
      v80 = v76;
      LOBYTE(v76) = v76 - 1;
      v81 = 343 * v90 + 49 * (v79 & 7) + (byte_13B4E0[v76] & 7) + 7 * (byte_13B4E0[v80] & 7);
      v82 = *(_BYTE *)(v89 + 25 * v81);
      --HIBYTE(v76);
      if ( v82 )
      {
        word_17B4E0 = 9377 * word_17B4E0 + 9439;
        v83 = (unsigned __int16)word_17B4E0 % (unsigned __int16)(v82 + 1);
        if ( v83 >= v82 )
          v83 = 0;
        v84 = v83 + 25 * v81 + v89;
        LOWORD(v77) = v76;
        byte_10B4E0[v76] = *(_BYTE *)(v84 + 1);
        byte_13B4E0[v76] = (byte_13B4E0[v76] & 7) + *(_BYTE *)(v84 + 13);
      }
      else
      {
        LOWORD(v77) = v76;
        byte_10B4E0[v76] = 1;
      }
    }
    ++v76;
  }
  while ( v76 );
  return v77;
}
// F2CD0: using guessed type char byte_F2CD0;
// 17B4E0: using guessed type __int16 word_17B4E0;
// 180628: using guessed type int dword_180628;

//----- (00044D00) --------------------------------------------------------
int sub_44D00()
{
  unsigned __int16 v0; // cx
  unsigned __int16 v1; // dx
  int result; // eax
  unsigned __int16 v3; // cx
  unsigned __int16 v4; // tt
  char v5; // dl

  v0 = 0;
  word_17B4E0 = 0;
  do
  {
    LOBYTE(v0) = v0 + 1;
    HIWORD(result) = 0;
    ++HIBYTE(v0);
    LOWORD(result) = v0;
    LOBYTE(v0) = v0 - 2;
    HIBYTE(v0) -= 2;
    v1 = v0;
    LOBYTE(v0) = v0 + 1;
    LOBYTE(result) = byte_11B4E0[v1] - byte_11B4E0[(unsigned __int16)result] + 32;
    HIBYTE(v3) = HIBYTE(v0) + 1;
    if ( (_BYTE)result == 32 )
    {
      result = 9377 * (unsigned __int16)word_17B4E0;
      word_17B4E0 = result + 9439;
      v4 = result + 9439;
      BYTE1(result) = (unsigned __int16)(result + 9439) / 0x900u;
      LOBYTE(result) = v4 % 9u + 28;
    }
    else if ( (char)result >= 28 )
    {
      if ( (char)result > 40 )
        LOBYTE(result) = (result & 7) + 40;
    }
    else
    {
      LOBYTE(result) = (result & 3) + 28;
    }
    if ( *(_BYTE *)(dword_D41A0 + 196308) )
    {
      result = 32 - (char)result;
      v5 = result + 32;
    }
    else
    {
      v5 = result;
    }
    LOBYTE(result) = v5;
    byte_12B4E0[v3] = v5;
    v0 = v3 + 1;
  }
  while ( v0 );
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// 17B4E0: using guessed type __int16 word_17B4E0;

//----- (00044DB0) --------------------------------------------------------
int sub_44DB0()
{
  __int16 v0; // dx
  __int16 v1; // cx
  unsigned __int16 v2; // bx
  __int16 v3; // ax
  int v4; // edx
  int result; // eax

  v0 = -32000;
  v1 = 32000;
  v2 = 0;
  do
  {
    v3 = word_15B4E0[v2];
    if ( v3 > v0 )
      v0 = word_15B4E0[v2];
    if ( v3 < v1 )
      v1 = word_15B4E0[v2];
    ++v2;
  }
  while ( v2 );
  if ( v0 )
    v4 = 12845056 / v0;
  else
    v4 = 0;
  do
  {
    result = (v4 * word_15B4E0[v2]) >> 16;
    word_15B4E0[v2] = 0;
    if ( (result & 0x8000u) != 0 )
      result = 0;
    if ( (__int16)result > 196 )
      result = 196;
    byte_11B4E0[v2++] = result;
  }
  while ( v2 );
  return result;
}
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00044E40) --------------------------------------------------------
unsigned __int16 __cdecl sub_44E40(int a1, unsigned __int8 a2)
{
  unsigned __int16 v3; // si
  int v4; // ecx
  int v5; // eax
  int v6; // ebx
  unsigned __int16 result; // ax

  v3 = 0;
  do
  {
    if ( byte_11B4E0[v3] )
      byte_13B4E0[v3] = 5;
    else
      byte_13B4E0[v3] = 0;
    ++v3;
  }
  while ( v3 );
LABEL_12:
  if ( a1 > 0 )
  {
    v4 = 1000;
    while ( 1 )
    {
      v6 = 0xFFFF;
      word_17B4E0 = 9377 * word_17B4E0 + 9439;
      HIWORD(v5) = 0;
      LOBYTE(v6) = byte_11B4E0[(unsigned __int16)word_17B4E0 % 0xFFFFu];
      if ( !--v4 )
        break;
      if ( (unsigned __int8)v6 > a2 )
      {
        LOWORD(v5) = (unsigned __int16)word_17B4E0 % 0xFFFFu;
        if ( byte_13B4E0[v5] )
        {
          --a1;
          sub_44EE0(v6, (unsigned __int16)word_17B4E0 % 0xFFFFu);
          goto LABEL_12;
        }
      }
    }
  }
  do
  {
    result = v3;
    byte_10B4E0[v3++] = -1;
  }
  while ( v3 );
  return result;
}
// 17B4E0: using guessed type __int16 word_17B4E0;

//----- (00044EE0) --------------------------------------------------------
unsigned __int16 __usercall sub_44EE0@<ax>(int a1@<ebx>, int a2)
{
  int v2; // eax
  unsigned __int16 v3; // dx
  unsigned __int8 v4; // dh
  unsigned __int16 v5; // si
  int v6; // esi
  unsigned __int8 v7; // dl
  unsigned __int16 result; // ax

  v2 = a2;
  v3 = 0;
  do
    byte_10B4E0[v3++] = 3;
  while ( v3 );
  v4 = byte_11B4E0[(unsigned __int16)a2];
  do
  {
    v5 = v2;
    --BYTE1(v2);
    byte_10B4E0[v5] = 0;
    v6 = v5;
    LOWORD(v6) = v2;
    v7 = -1;
    if ( byte_10B4E0[(unsigned __int16)v2] && byte_11B4E0[v6] != -1 )
    {
      v7 = byte_11B4E0[v6];
      a1 = v2;
    }
    LOBYTE(v2) = v2 + 1;
    if ( byte_10B4E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_11B4E0[(unsigned __int16)v2] )
    {
      v7 = byte_11B4E0[(unsigned __int16)v2];
      a1 = v2;
    }
    ++BYTE1(v2);
    if ( byte_10B4E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_11B4E0[(unsigned __int16)v2] )
    {
      v7 = byte_11B4E0[(unsigned __int16)v2];
      a1 = v2;
    }
    ++BYTE1(v2);
    if ( byte_10B4E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_11B4E0[(unsigned __int16)v2] )
    {
      v7 = byte_11B4E0[(unsigned __int16)v2];
      a1 = v2;
    }
    LOBYTE(v2) = v2 - 1;
    if ( byte_10B4E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_11B4E0[(unsigned __int16)v2] )
    {
      v7 = byte_11B4E0[(unsigned __int16)v2];
      a1 = v2;
    }
    LOBYTE(v2) = v2 - 1;
    if ( byte_10B4E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_11B4E0[(unsigned __int16)v2] )
    {
      v7 = byte_11B4E0[(unsigned __int16)v2];
      a1 = v2;
    }
    --BYTE1(v2);
    if ( byte_10B4E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_11B4E0[(unsigned __int16)v2] )
    {
      v7 = byte_11B4E0[(unsigned __int16)v2];
      a1 = v2;
    }
    --BYTE1(v2);
    if ( byte_10B4E0[(unsigned __int16)v2] && v7 > (unsigned __int8)byte_11B4E0[(unsigned __int16)v2] )
    {
      v7 = byte_11B4E0[(unsigned __int16)v2];
      a1 = v2;
    }
    if ( !byte_13B4E0[(unsigned __int16)a1] || v7 == 0xFF )
      break;
    if ( v7 > v4 )
      byte_11B4E0[(unsigned __int16)a1] = v4;
    v4 = byte_11B4E0[(unsigned __int16)a1];
    v2 = a1;
  }
  while ( v4 );
  result = 0;
  do
  {
    if ( !byte_10B4E0[result] )
      byte_13B4E0[result] = 0;
    ++result;
  }
  while ( result );
  return result;
}

//----- (00045060) --------------------------------------------------------
unsigned __int8 __cdecl sub_45060(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int16 v2; // dx
  unsigned __int8 result; // al
  unsigned __int8 v4; // ah
  unsigned __int16 v5; // dx

  qmemcpy(byte_10B4E0, byte_13B4E0, (unsigned int)sub_10000);
  v2 = 0;
  do
  {
    result = 0;
    v4 = -1;
    if ( byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( byte_11B4E0[v2] != -1 )
      v4 = byte_11B4E0[v2];
    --HIBYTE(v2);
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    LOBYTE(v2) = v2 + 1;
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    ++HIBYTE(v2);
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    ++HIBYTE(v2);
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    LOBYTE(v2) = v2 - 1;
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    LOBYTE(v2) = v2 - 1;
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    --HIBYTE(v2);
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    --HIBYTE(v2);
    if ( result < (unsigned __int8)byte_11B4E0[v2] )
      result = byte_11B4E0[v2];
    if ( v4 > (unsigned __int8)byte_11B4E0[v2] )
      v4 = byte_11B4E0[v2];
    LOBYTE(v2) = v2 + 1;
    HIBYTE(v5) = HIBYTE(v2) + 1;
    if ( result < a1 && result - v4 <= a2 )
    {
      if ( byte_13B4E0[v5] )
        byte_13B4E0[v5] = 5;
    }
    v2 = v5 + 1;
  }
  while ( v2 );
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();

//----- (00045210) --------------------------------------------------------
char __cdecl sub_45210(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int16 v2; // dx
  int v3; // eax
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // bh
  unsigned __int16 v6; // dx
  int v7; // ecx

  qmemcpy(byte_10B4E0, byte_13B4E0, (unsigned int)sub_10000);
  v2 = 0;
  do
  {
    LOWORD(v3) = -256;
    v4 = 0;
    v5 = 0;
    if ( byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( byte_11B4E0[v2] != -1 )
      BYTE1(v3) = byte_11B4E0[v2];
    --HIBYTE(v2);
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      v5 = 1;
    if ( byte_13B4E0[v2] == 2 )
      v4 = 1;
    LOBYTE(v2) = v2 + 1;
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      ++v5;
    if ( byte_13B4E0[v2] == 2 )
      ++v4;
    ++HIBYTE(v2);
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      ++v5;
    if ( byte_13B4E0[v2] == 2 )
      ++v4;
    ++HIBYTE(v2);
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      ++v5;
    if ( byte_13B4E0[v2] == 2 )
      ++v4;
    LOBYTE(v2) = v2 - 1;
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      ++v5;
    if ( byte_13B4E0[v2] == 2 )
      ++v4;
    LOBYTE(v2) = v2 - 1;
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      ++v5;
    if ( byte_13B4E0[v2] == 2 )
      ++v4;
    --HIBYTE(v2);
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      ++v5;
    if ( byte_13B4E0[v2] == 2 )
      ++v4;
    --HIBYTE(v2);
    if ( (unsigned __int8)v3 < (unsigned __int8)byte_11B4E0[v2] )
      LOBYTE(v3) = byte_11B4E0[v2];
    if ( BYTE1(v3) > (unsigned __int8)byte_11B4E0[v2] )
      BYTE1(v3) = byte_11B4E0[v2];
    if ( byte_13B4E0[v2] == 5 )
      ++v5;
    if ( byte_13B4E0[v2] == 2 )
      ++v4;
    LOBYTE(v2) = v2 + 1;
    HIBYTE(v6) = HIBYTE(v2) + 1;
    if ( (unsigned __int8)v3 < a1 )
    {
      v7 = (unsigned __int8)v3 - BYTE1(v3);
      LOBYTE(v3) = a2;
      if ( v7 <= a2 && byte_13B4E0[v6] == 5 )
      {
        v3 = v5 + v4;
        if ( v3 == 8 )
          byte_13B4E0[v6] = 2;
      }
    }
    v2 = v6 + 1;
  }
  while ( v2 );
  return v3;
}
// 10000: using guessed type void __noreturn sub_10000();

//----- (000454F0) --------------------------------------------------------
unsigned __int16 __cdecl sub_454F0(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int16 result; // ax
  unsigned __int8 v3; // dh
  unsigned __int8 v4; // dl
  unsigned __int16 v5; // ax
  unsigned __int16 v6; // ax

  result = 0;
  do
  {
    if ( (unsigned __int8)byte_11B4E0[result] > a1 )
    {
      v3 = 0;
      v4 = -1;
      if ( byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      if ( byte_11B4E0[result] != -1 )
        v4 = byte_11B4E0[result];
      --HIBYTE(result);
      if ( v3 < (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      if ( v4 > (unsigned __int8)byte_11B4E0[result] )
        v4 = byte_11B4E0[result];
      LOBYTE(result) = result + 1;
      ++HIBYTE(result);
      if ( v3 < (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[v5];
      if ( v4 > (unsigned __int8)byte_11B4E0[v5] )
        v4 = byte_11B4E0[v5];
      ++HIBYTE(v5);
      LOBYTE(v5) = v5 - 1;
      if ( v3 < (unsigned __int8)byte_11B4E0[v5] )
        v3 = byte_11B4E0[v6];
      if ( v4 > (unsigned __int8)byte_11B4E0[v6] )
        v4 = byte_11B4E0[v6];
      LOBYTE(result) = v6 - 1;
      HIBYTE(result) = HIBYTE(v6) - 1;
      if ( v3 < (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      if ( v4 > (unsigned __int8)byte_11B4E0[result] )
        v4 = byte_11B4E0[result];
      LOBYTE(result) = result + 1;
      if ( byte_13B4E0[result] )
      {
        if ( v3 - v4 < a2 )
          byte_13B4E0[result] = 6;
      }
    }
    ++result;
  }
  while ( result );
  return result;
}

//----- (00045600) --------------------------------------------------------
unsigned __int16 __cdecl sub_45600(unsigned __int8 a1)
{
  unsigned __int16 result; // ax
  unsigned __int8 v2; // dh
  unsigned __int8 v3; // dl
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // ax
  unsigned __int16 v6; // ax
  __int16 v7; // bx
  char v8; // dh
  char v9; // dl

  qmemcpy(byte_10B4E0, byte_13B4E0, (unsigned int)sub_10000);
  result = 0;
  do
  {
    v2 = 0;
    v3 = -1;
    if ( byte_11B4E0[result] )
      v2 = byte_11B4E0[result];
    if ( byte_11B4E0[result] != -1 )
      v3 = byte_11B4E0[result];
    --HIBYTE(result);
    if ( v2 < (unsigned __int8)byte_11B4E0[result] )
      v2 = byte_11B4E0[result];
    if ( v3 > (unsigned __int8)byte_11B4E0[result] )
      v3 = byte_11B4E0[result];
    LOBYTE(result) = result + 1;
    ++HIBYTE(result);
    if ( v2 < (unsigned __int8)byte_11B4E0[result] )
      v2 = byte_11B4E0[v4];
    if ( v3 > (unsigned __int8)byte_11B4E0[v4] )
      v3 = byte_11B4E0[v4];
    ++HIBYTE(v4);
    LOBYTE(v4) = v4 - 1;
    if ( v2 < (unsigned __int8)byte_11B4E0[v4] )
      v2 = byte_11B4E0[v5];
    if ( v3 > (unsigned __int8)byte_11B4E0[v5] )
      v3 = byte_11B4E0[v5];
    LOBYTE(v5) = v5 - 1;
    --HIBYTE(v5);
    if ( v2 < (unsigned __int8)byte_11B4E0[v5] )
      v2 = byte_11B4E0[v6];
    if ( v3 > (unsigned __int8)byte_11B4E0[v6] )
      v3 = byte_11B4E0[v6];
    LOBYTE(v6) = v6 + 1;
    if ( byte_13B4E0[v6] && v2 - v3 >= a1 )
      byte_13B4E0[v6] = 1;
    result = v6 + 1;
  }
  while ( result );
  do
  {
    if ( byte_13B4E0[result] != 6 )
      goto LABEL_100;
    v7 = 0;
    --HIBYTE(result);
    v8 = 0;
    v9 = 0;
    if ( byte_13B4E0[result] == 3 )
      HIBYTE(v7) = 1;
    if ( byte_13B4E0[result] == 2 )
      v9 = 1;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = 1;
    if ( byte_13B4E0[result] == 4 )
      v8 = 1;
    LOBYTE(result) = result + 1;
    if ( byte_13B4E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_13B4E0[result] == 2 )
      ++v9;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    if ( byte_13B4E0[result] == 4 )
      ++v8;
    ++HIBYTE(result);
    if ( byte_13B4E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_13B4E0[result] == 2 )
      ++v9;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    if ( byte_13B4E0[result] == 4 )
      ++v8;
    ++HIBYTE(result);
    if ( byte_13B4E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_13B4E0[result] == 2 )
      ++v9;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    if ( byte_13B4E0[result] == 4 )
      ++v8;
    LOBYTE(result) = result - 1;
    if ( byte_13B4E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_13B4E0[result] == 2 )
      ++v9;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    if ( byte_13B4E0[result] == 4 )
      ++v8;
    LOBYTE(result) = result - 1;
    if ( byte_13B4E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_13B4E0[result] == 2 )
      ++v9;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    if ( byte_13B4E0[result] == 4 )
      ++v8;
    --HIBYTE(result);
    if ( byte_13B4E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_13B4E0[result] == 2 )
      ++v9;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    if ( byte_13B4E0[result] == 4 )
      ++v8;
    --HIBYTE(result);
    if ( byte_13B4E0[result] == 3 )
      ++HIBYTE(v7);
    if ( byte_13B4E0[result] == 2 )
      ++v9;
    if ( byte_13B4E0[result] == 5 )
      LOBYTE(v7) = v7 + 1;
    if ( byte_13B4E0[result] == 4 )
      ++v8;
    LOBYTE(result) = result + 1;
    ++HIBYTE(result);
    if ( HIBYTE(v7) )
    {
      if ( v9 || (_BYTE)v7 || v8 )
        goto LABEL_99;
    }
    else if ( v9 || (_BYTE)v7 && v8 )
    {
LABEL_99:
      byte_13B4E0[result] = 1;
    }
LABEL_100:
    ++result;
  }
  while ( result );
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();

//----- (00045AA0) --------------------------------------------------------
unsigned __int16 sub_45AA0()
{
  unsigned __int16 result; // ax
  char v1; // dh
  unsigned __int16 v2; // cx
  unsigned __int8 v3; // dl
  unsigned __int8 v4; // bl
  unsigned __int16 v5; // cx
  unsigned __int16 v6; // cx
  unsigned __int16 v7; // cx
  unsigned __int16 v8; // cx
  char v9; // [esp+0h] [ebp-4h]

  do
  {
    result = 0;
    v9 = 0;
    do
    {
      v1 = byte_13B4E0[result] == 0;
      v2 = result;
      LOBYTE(result) = result + 1;
      v3 = byte_11B4E0[v2];
      v4 = v3;
      if ( !byte_13B4E0[result] )
        ++v1;
      if ( v3 > (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      if ( v4 < (unsigned __int8)byte_11B4E0[result] )
        v4 = byte_11B4E0[result];
      ++HIBYTE(result);
      if ( !byte_13B4E0[result] )
        ++v1;
      if ( v3 > (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      if ( v4 < (unsigned __int8)byte_11B4E0[result] )
        v4 = byte_11B4E0[result];
      LOBYTE(result) = result - 1;
      if ( !byte_13B4E0[result] )
        ++v1;
      if ( v3 > (unsigned __int8)byte_11B4E0[result] )
        v3 = byte_11B4E0[result];
      if ( v4 < (unsigned __int8)byte_11B4E0[result] )
        v4 = byte_11B4E0[result];
      --HIBYTE(result);
      if ( v4 != v3 && v1 == 4 )
      {
        v9 = 1;
        v5 = result;
        LOBYTE(result) = result + 1;
        byte_11B4E0[v5] = v3;
        v6 = result;
        ++HIBYTE(result);
        byte_11B4E0[v6] = v3;
        v7 = result;
        LOBYTE(result) = result - 1;
        byte_11B4E0[v7] = v3;
        v8 = result;
        --HIBYTE(result);
        byte_11B4E0[v8] = v3;
      }
      ++result;
    }
    while ( result );
  }
  while ( v9 );
  return result;
}

//----- (00045BE0) --------------------------------------------------------
char __usercall sub_45BE0@<al>(char a1@<dl>, char a2@<cl>, unsigned __int16 a3)
{
  unsigned __int16 v3; // ax
  unsigned __int8 v4; // bl
  unsigned __int8 v5; // dh
  unsigned __int8 v6; // bh
  unsigned __int8 v7; // al
  char result; // al

  HIBYTE(v3) = HIBYTE(a3);
  v4 = -1;
  v5 = 0;
  if ( byte_11B4E0[a3] )
  {
    v5 = byte_11B4E0[a3];
    a1 = 0;
  }
  if ( byte_11B4E0[a3] != -1 )
    v4 = byte_11B4E0[a3];
  LOBYTE(v3) = a3 + 1;
  if ( (unsigned __int8)byte_11B4E0[v3] > v5 )
  {
    v5 = byte_11B4E0[v3];
    a1 = 1;
  }
  if ( (unsigned __int8)byte_11B4E0[v3] < v4 )
    v4 = byte_11B4E0[v3];
  HIBYTE(v3) = HIBYTE(a3) + 1;
  if ( (unsigned __int8)byte_11B4E0[v3] > v5 )
  {
    v5 = byte_11B4E0[v3];
    a1 = 2;
  }
  if ( (unsigned __int8)byte_11B4E0[v3] < v4 )
    v4 = byte_11B4E0[v3];
  LOBYTE(v3) = a3;
  if ( (unsigned __int8)byte_11B4E0[v3] > v5 )
  {
    v5 = byte_11B4E0[v3];
    a1 = 3;
  }
  if ( (unsigned __int8)byte_11B4E0[v3] < v4 )
    v4 = byte_11B4E0[v3];
  HIBYTE(v3) = HIBYTE(a3);
  v6 = 0;
  if ( a1 && byte_11B4E0[v3] )
  {
    v6 = byte_11B4E0[v3];
    a2 = 0;
  }
  LOBYTE(v3) = a3 + 1;
  if ( a1 != 1 && (unsigned __int8)byte_11B4E0[v3] > v6 )
  {
    v6 = byte_11B4E0[v3];
    a2 = 1;
  }
  HIBYTE(v3) = HIBYTE(a3) + 1;
  if ( a1 != 2 && (unsigned __int8)byte_11B4E0[v3] > v6 )
  {
    v6 = byte_11B4E0[v3];
    a2 = 2;
  }
  LOBYTE(v3) = a3;
  if ( a1 != 3 )
  {
    v7 = byte_11B4E0[v3];
    if ( v7 > v6 )
    {
      a2 = 3;
      v6 = v7;
    }
  }
  if ( v5 - v6 < 8 )
  {
    switch ( a1 )
    {
      case 0:
        if ( a2 == 1 )
          goto LABEL_33;
        goto LABEL_39;
      case 1:
        if ( a2 == 2 )
          goto LABEL_35;
LABEL_33:
        result = 4;
        dword_D47DC = v5 - v4 <= 8;
        return result;
      case 2:
        if ( a2 == 3 )
          goto LABEL_37;
LABEL_35:
        result = 5;
        dword_D47DC = v5 - v4 <= 8;
        break;
      case 3:
        if ( a2 )
        {
LABEL_37:
          result = 6;
          dword_D47DC = v5 - v4 <= 8;
        }
        else
        {
LABEL_39:
          result = 7;
          dword_D47DC = v5 - v4 <= 8;
        }
        break;
      default:
        result = 0;
        goto LABEL_41;
    }
  }
  else
  {
    result = a1;
LABEL_41:
    dword_D47DC = v5 - v4 <= 8;
  }
  return result;
}
// D47DC: using guessed type int dword_D47DC;

//----- (00045DC0) --------------------------------------------------------
char __usercall sub_45DC0@<al>(char a1@<dl>, char a2@<cl>, unsigned __int16 a3, unsigned __int8 a4)
{
  unsigned __int16 v4; // bx
  int v5; // eax
  char v6; // ch
  char *v7; // eax
  char v8; // al
  char v9; // ah
  unsigned __int8 v10; // al
  char v11; // cl
  unsigned __int8 v12; // dh
  unsigned __int8 v13; // dh
  char v14; // cl
  unsigned __int8 v15; // dh
  char v16; // cl
  unsigned __int8 v17; // dh
  char v18; // bl
  unsigned __int16 v19; // ax
  char v20; // ch
  unsigned __int16 v21; // ax
  char v22; // dl
  unsigned __int8 v24; // [esp+0h] [ebp-4h]

  HIBYTE(v4) = HIBYTE(a3);
  v24 = 8 * ((HIBYTE(a3) + a3) & 1);
  if ( a4 >= 8u )
  {
    switch ( a4 )
    {
      case 8u:
        byte_10B4E0[a3] = 8;
        goto LABEL_30;
      case 9u:
        byte_10B4E0[a3] = 9;
        goto LABEL_30;
      case 0xAu:
        v8 = sub_45BE0(a1, a2, a3);
        v9 = v8;
        if ( dword_D47DC )
          v9 = v8 + 8;
        v10 = v9;
        goto LABEL_28;
      case 0xBu:
        v10 = sub_45BE0(a1, a2, a3) + 16;
        if ( dword_D47DC )
          v10 += 8;
        goto LABEL_28;
      case 0xCu:
        v10 = sub_45BE0(a1, a2, a3) + 32;
        if ( dword_D47DC )
          v10 += 8;
        goto LABEL_28;
      case 0xDu:
        v10 = sub_45BE0(a1, a2, a3) + 48;
        if ( dword_D47DC )
          v10 += 8;
        goto LABEL_28;
      case 0xEu:
        v10 = sub_45BE0(a1, a2, a3) + 64;
        if ( dword_D47DC )
          v10 += 8;
LABEL_28:
        v7 = (char *)&unk_D4AB0 + 2 * v10;
        goto LABEL_29;
      case 0xFu:
        byte_10B4E0[a3] = 11;
        goto LABEL_30;
      case 0x10u:
        v6 = byte_10B4E0[a3];
        if ( v6 == 10 || v6 == 11 || v6 == 12 )
          goto LABEL_30;
        v7 = (char *)&unk_D4A30 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3);
LABEL_29:
        byte_10B4E0[a3] = *v7;
        byte_13B4E0[a3] = byte_13B4E0[a3] & 0x8F | v7[1];
LABEL_30:
        v11 = byte_13B4E0[a3] | 0x80;
        byte_13B4E0[a3] = v11;
        if ( byte_D41B6 )
        {
          v12 = byte_11B4E0[a3];
          if ( (unsigned __int8)byte_14B4E0[a3] > v12 )
          {
            byte_13B4E0[a3] = v11 & 0xF7;
          }
          else
          {
            byte_13B4E0[a3] = v11 | 8;
            byte_14B4E0[a3] = v12 - 1;
          }
          LOBYTE(v4) = a3 + 1;
          v13 = byte_11B4E0[v4];
          if ( (unsigned __int8)byte_14B4E0[v4] > v13 )
          {
            byte_13B4E0[v4] &= ~8u;
          }
          else
          {
            v14 = byte_13B4E0[v4] | 8;
            byte_14B4E0[v4] = v13 - 1;
            byte_13B4E0[v4] = v14;
          }
          HIBYTE(v4) = HIBYTE(a3) + 1;
          v15 = byte_11B4E0[v4];
          if ( (unsigned __int8)byte_14B4E0[v4] > v15 )
          {
            byte_13B4E0[v4] &= ~8u;
          }
          else
          {
            v16 = byte_13B4E0[v4] | 8;
            byte_14B4E0[v4] = v15 - 1;
            byte_13B4E0[v4] = v16;
          }
          LOBYTE(v4) = a3;
          v5 = v4;
          v17 = byte_11B4E0[v4];
          if ( (unsigned __int8)byte_14B4E0[v4] <= v17 )
          {
            v18 = byte_13B4E0[v4] | 8;
            byte_14B4E0[v5] = v17 - 1;
            byte_13B4E0[v5] = v18;
            return v5;
          }
        }
        else
        {
          LOBYTE(v4) = a3 + 1;
          byte_13B4E0[a3] = v11 & 0xF7;
          v19 = v4;
          v20 = byte_13B4E0[v4] & 0xF7;
          HIBYTE(v4) = HIBYTE(a3) + 1;
          byte_13B4E0[v19] = v20;
          v21 = v4;
          v22 = byte_13B4E0[v4] & 0xF7;
          LOBYTE(v4) = a3;
          byte_13B4E0[v21] = v22;
          v5 = v21;
          LOWORD(v5) = v4;
        }
        byte_13B4E0[v5] &= ~8u;
        break;
      case 0x11u:
        v7 = (char *)&unk_D4A70 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3);
        goto LABEL_29;
      case 0x12u:
        v7 = (char *)&unk_D4A80 + 2 * v24 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3);
        goto LABEL_29;
      case 0x13u:
        v7 = (char *)&unk_D4A80 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3) + 2 * v24 + 16;
        goto LABEL_29;
      case 0x14u:
        v7 = (char *)&unk_D4A40 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3);
        goto LABEL_29;
      case 0x15u:
        v7 = (char *)&unk_D4A40 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3) + 16;
        goto LABEL_29;
      case 0x16u:
        v7 = (char *)&unk_D4A40 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3) + 32;
        goto LABEL_29;
      default:
        goto LABEL_30;
    }
  }
  else
  {
    byte_13B4E0[a3] = a4 | byte_13B4E0[a3] & 0xF0;
    LOBYTE(v5) = sub_462A0(a3, a3);
  }
  return v5;
}
// D41B6: using guessed type char byte_D41B6;
// D47DC: using guessed type int dword_D47DC;

//----- (00046180) --------------------------------------------------------
unsigned __int16 __cdecl sub_46180(unsigned __int16 a1, char a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // bx
  unsigned __int16 v4; // bx
  unsigned __int16 v5; // bx
  unsigned __int16 result; // ax
  char v7; // bl
  char i; // bh
  unsigned __int16 v9; // dx
  unsigned __int16 v10; // si
  char v11; // dl

  HIBYTE(v2) = HIBYTE(a1);
  LOBYTE(v2) = a1 - 1;
  byte_10B4E0[a1] = a2;
  v3 = v2;
  HIBYTE(result) = HIBYTE(a1) - 1;
  byte_10B4E0[v3] = a2;
  v4 = result;
  LOBYTE(result) = a1;
  byte_10B4E0[v4] = a2;
  v5 = result;
  LOBYTE(result) = a1 - 1;
  byte_10B4E0[v5] = a2;
  v7 = 3;
  do
  {
    for ( i = 3; i; --i )
    {
      LOBYTE(result) = result + 1;
      ++HIBYTE(result);
      v9 = result;
      LOBYTE(result) = result - 2;
      HIBYTE(result) -= 2;
      v10 = result;
      LOBYTE(result) = result + 1;
      v11 = byte_11B4E0[v10] - byte_11B4E0[v9] + 32;
      ++HIBYTE(result);
      if ( v11 >= 28 )
      {
        if ( v11 > 40 )
          v11 = (v11 & 7) + 40;
      }
      else
      {
        v11 = (v11 & 3) + 28;
      }
      if ( *(_BYTE *)(dword_D41A0 + 196308) )
        v11 = 32 - v11 + 32;
      byte_12B4E0[result] = v11;
      if ( byte_D41B6 && (unsigned __int8)byte_14B4E0[result] <= (unsigned __int8)byte_11B4E0[result] )
      {
        byte_14B4E0[result] = byte_11B4E0[result] - 1;
        byte_13B4E0[result] |= 8u;
      }
      else
      {
        byte_13B4E0[result] &= ~8u;
      }
      LOBYTE(result) = result + 1;
    }
    LOBYTE(result) = result - 3;
    --v7;
    ++HIBYTE(result);
  }
  while ( v7 );
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;

//----- (000462A0) --------------------------------------------------------
char __cdecl sub_462A0(unsigned __int16 a1, __int16 a2)
{
  unsigned __int16 v2; // cx
  _BOOL1 v3; // zf
  int v4; // eax
  unsigned __int16 v5; // cx
  int v6; // edx
  unsigned __int16 v7; // ax
  int v8; // edx
  int v9; // ebx
  int v10; // eax
  int v11; // edx
  unsigned __int16 v12; // cx
  char v13; // dh
  char j; // dl
  unsigned __int16 v15; // ax
  unsigned __int16 v16; // bx
  char v17; // al
  char v18; // bl
  unsigned __int8 v19; // bh
  char i; // [esp+0h] [ebp-14h]
  char v22; // [esp+4h] [ebp-10h]
  char v23; // [esp+4h] [ebp-10h]
  char v24; // [esp+8h] [ebp-Ch]
  char v25; // [esp+8h] [ebp-Ch]
  char v26; // [esp+8h] [ebp-Ch]
  char v27; // [esp+Ch] [ebp-8h]
  char v28; // [esp+10h] [ebp-4h]
  unsigned __int16 v29; // [esp+24h] [ebp+10h]

  LOBYTE(v4) = a2 - a1 + 1;
  v2 = a1;
  v24 = v4;
  BYTE1(v4) = HIBYTE(a2) - HIBYTE(a1) + 1;
  v3 = BYTE1(v4) == 0;
  v22 = BYTE1(v4);
  while ( !v3 )
  {
    LOBYTE(v4) = a2 - a1 + 1;
    while ( (_BYTE)v4 )
    {
      if ( byte_13B4E0[v2] >= 0 )
        byte_10B4E0[v2] = 1;
      LOBYTE(v2) = v2 - 1;
      if ( byte_13B4E0[v2] >= 0 )
        byte_10B4E0[v2] = 1;
      --HIBYTE(v2);
      if ( byte_13B4E0[v2] >= 0 )
        byte_10B4E0[v2] = 1;
      LOBYTE(v2) = v2 + 1;
      if ( byte_13B4E0[v2] >= 0 )
        byte_10B4E0[v2] = 1;
      ++HIBYTE(v2);
      LOBYTE(v4) = v4 - 1;
      LOBYTE(v2) = v2 + 1;
    }
    LOBYTE(v2) = v2 - v24;
    ++HIBYTE(v2);
    v3 = --BYTE1(v4) == 0;
  }
  LOBYTE(a1) = a1 - 1;
  --HIBYTE(a1);
  v23 = v22 + 1;
  v27 = v23;
  v5 = a1;
  v25 = v24 + 1;
  while ( v27 )
  {
    LOBYTE(v4) = v25;
    for ( i = v25; i; --i )
    {
      v4 = v5;
      if ( byte_10B4E0[v5] == 1 )
      {
        LOBYTE(v5) = v5 + 1;
        v6 = 343 * (byte_13B4E0[v4] & 7);
        v7 = v5;
        ++HIBYTE(v5);
        v8 = 49 * (byte_13B4E0[v7] & 7) + v6;
        v9 = byte_13B4E0[v5] & 7;
        LOBYTE(v5) = v5 - 1;
        v10 = byte_13B4E0[v5] & 7;
        --HIBYTE(v5);
        v11 = 2 * (v10 + 7 * v9 + v8);
        LOBYTE(v10) = byte_F2CD0[v11];
        byte_10B4E0[v5] = v10;
        if ( (unsigned __int8)v10 >= 8u )
        {
          LOBYTE(v4) = byte_F2CD1[v11] + (byte_13B4E0[v5] & 0x87);
        }
        else
        {
          v28 = byte_13B4E0[v5] & 0x87;
          word_17B4E0 = 9377 * word_17B4E0 + 9439;
          LOBYTE(v4) = v28 + 16 * ((unsigned __int16)word_17B4E0 % 7u);
        }
        byte_13B4E0[v5] = v4;
      }
      LOBYTE(v5) = v5 + 1;
    }
    LOBYTE(v5) = v5 - v25;
    ++HIBYTE(v5);
    --v27;
  }
  v26 = v25 + 1;
  v12 = v29;
  v13 = v23 + 1;
  if ( v23 != -1 )
  {
    do
    {
      for ( j = v26; j; --j )
      {
        LOBYTE(v12) = v12 + 1;
        ++HIBYTE(v12);
        v15 = v12;
        LOBYTE(v12) = v12 - 2;
        HIBYTE(v12) -= 2;
        v16 = v12;
        LOBYTE(v12) = v12 + 1;
        v17 = byte_11B4E0[v16] - byte_11B4E0[v15] + 32;
        ++HIBYTE(v12);
        if ( v17 >= 28 )
        {
          if ( v17 > 40 )
            v17 = (v17 & 7) + 40;
        }
        else
        {
          v17 = (v17 & 3) + 28;
        }
        if ( *(_BYTE *)(dword_D41A0 + 196308) )
          v18 = 32 - v17 + 32;
        else
          v18 = v17;
        v4 = v12;
        byte_12B4E0[v12] = v18;
        if ( byte_D41B6 && (v19 = byte_11B4E0[v12], (unsigned __int8)byte_14B4E0[v12] <= v19) )
        {
          byte_14B4E0[v12] = v19 - 1;
          byte_13B4E0[v12] |= 8u;
        }
        else
        {
          byte_13B4E0[v12] &= ~8u;
        }
        LOBYTE(v12) = v12 + 1;
      }
      LOBYTE(v12) = v12 - v26;
      --v13;
      ++HIBYTE(v12);
    }
    while ( v13 );
  }
  return v4;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// 17B4E0: using guessed type __int16 word_17B4E0;

//----- (00046570) --------------------------------------------------------
char __cdecl sub_46570(unsigned __int16 a1, __int16 a2)
{
  unsigned __int16 v2; // cx
  _BOOL1 v3; // zf
  int v4; // eax
  unsigned __int16 v5; // dx
  unsigned __int16 v6; // dx
  unsigned __int16 v7; // dx
  unsigned __int16 v8; // dx
  unsigned __int16 v9; // cx
  int v10; // edx
  unsigned __int16 v11; // ax
  int v12; // edx
  int v13; // ebx
  int v14; // eax
  int v15; // edx
  unsigned __int16 v16; // cx
  char v17; // dh
  char j; // dl
  unsigned __int16 v19; // ax
  unsigned __int16 v20; // bx
  char v21; // al
  char v22; // bl
  unsigned __int8 v23; // bh
  char i; // [esp+0h] [ebp-14h]
  char v26; // [esp+4h] [ebp-10h]
  char v27; // [esp+4h] [ebp-10h]
  char v28; // [esp+8h] [ebp-Ch]
  char v29; // [esp+8h] [ebp-Ch]
  char v30; // [esp+8h] [ebp-Ch]
  char v31; // [esp+Ch] [ebp-8h]
  char v32; // [esp+10h] [ebp-4h]
  unsigned __int16 v33; // [esp+24h] [ebp+10h]

  LOBYTE(v4) = a2 - a1 + 1;
  v2 = a1;
  v28 = v4;
  BYTE1(v4) = HIBYTE(a2) - HIBYTE(a1) + 1;
  v3 = BYTE1(v4) == 0;
  v26 = BYTE1(v4);
  while ( !v3 )
  {
    LOBYTE(v4) = a2 - a1 + 1;
    while ( (_BYTE)v4 )
    {
      v5 = v2;
      LOBYTE(v2) = v2 - 1;
      byte_10B4E0[v5] = 1;
      v6 = v2;
      --HIBYTE(v2);
      byte_10B4E0[v6] = 1;
      v7 = v2;
      LOBYTE(v2) = v2 + 1;
      byte_10B4E0[v7] = 1;
      v8 = v2;
      LOBYTE(v4) = v4 - 1;
      ++HIBYTE(v2);
      byte_10B4E0[v8] = 1;
      LOBYTE(v2) = v2 + 1;
    }
    LOBYTE(v2) = v2 - v28;
    ++HIBYTE(v2);
    v3 = --BYTE1(v4) == 0;
  }
  LOBYTE(a1) = a1 - 1;
  --HIBYTE(a1);
  v27 = v26 + 1;
  v32 = v27;
  v9 = a1;
  v29 = v28 + 1;
  while ( v32 )
  {
    LOBYTE(v4) = v29;
    for ( i = v29; i; --i )
    {
      v4 = v9;
      if ( byte_10B4E0[v9] == 1 )
      {
        LOBYTE(v9) = v9 + 1;
        v10 = 343 * (byte_13B4E0[v4] & 7);
        v11 = v9;
        ++HIBYTE(v9);
        v12 = 49 * (byte_13B4E0[v11] & 7) + v10;
        v13 = byte_13B4E0[v9] & 7;
        LOBYTE(v9) = v9 - 1;
        v14 = byte_13B4E0[v9] & 7;
        --HIBYTE(v9);
        v15 = 2 * (v14 + 7 * v13 + v12);
        LOBYTE(v14) = byte_F2CD0[v15];
        byte_10B4E0[v9] = v14;
        if ( (unsigned __int8)v14 >= 8u )
        {
          LOBYTE(v4) = byte_F2CD1[v15] + (byte_13B4E0[v9] & 0x87);
        }
        else
        {
          v31 = byte_13B4E0[v9] & 0x87;
          word_17B4E0 = 9377 * word_17B4E0 + 9439;
          LOBYTE(v4) = v31 + 16 * ((unsigned __int16)word_17B4E0 % 7u);
        }
        byte_13B4E0[v9] = v4;
      }
      LOBYTE(v9) = v9 + 1;
    }
    LOBYTE(v9) = v9 - v29;
    ++HIBYTE(v9);
    --v32;
  }
  v30 = v29 + 1;
  v16 = v33;
  v17 = v27 + 1;
  if ( v27 != -1 )
  {
    do
    {
      for ( j = v30; j; --j )
      {
        LOBYTE(v16) = v16 + 1;
        ++HIBYTE(v16);
        v19 = v16;
        LOBYTE(v16) = v16 - 2;
        HIBYTE(v16) -= 2;
        v20 = v16;
        LOBYTE(v16) = v16 + 1;
        v21 = byte_11B4E0[v20] - byte_11B4E0[v19] + 32;
        ++HIBYTE(v16);
        if ( v21 >= 28 )
        {
          if ( v21 > 40 )
            v21 = (v21 & 7) + 40;
        }
        else
        {
          v21 = (v21 & 3) + 28;
        }
        if ( *(_BYTE *)(dword_D41A0 + 196308) )
          v22 = 32 - v21 + 32;
        else
          v22 = v21;
        v4 = v16;
        byte_12B4E0[v16] = v22;
        if ( byte_D41B6 && (v23 = byte_11B4E0[v16], (unsigned __int8)byte_14B4E0[v16] <= v23) )
        {
          byte_14B4E0[v16] = v23 - 1;
          byte_13B4E0[v16] |= 8u;
        }
        else
        {
          byte_13B4E0[v16] &= ~8u;
        }
        LOBYTE(v16) = v16 + 1;
      }
      LOBYTE(v16) = v16 - v30;
      --v17;
      ++HIBYTE(v16);
    }
    while ( v17 );
  }
  return v4;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// 17B4E0: using guessed type __int16 word_17B4E0;

//----- (00046820) --------------------------------------------------------
int sub_46820()
{
  ++dword_17DB54;
  return 0;
}
// 17DB54: using guessed type int dword_17DB54;

//----- (00046830) --------------------------------------------------------
int __usercall sub_46830@<eax>(__int16 *a1@<ebx>, int a2@<edi>, unsigned __int16 a3@<si>)
{
  int result; // eax
  int v4; // edx
  int v5; // eax
  unsigned __int16 v6; // dx
  _BOOL1 v7; // al
  unsigned __int8 v8; // dl
  unsigned __int8 v9; // al
  unsigned __int8 v10; // al
  int v11; // eax
  char v12; // ch
  _WORD *v13; // eax

  *(_DWORD *)(dword_D41A4 + 30) = 0;
  *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11234) = 0;
  while ( 1 )
  {
    result = dword_D41A0;
    v4 = 2124 * *(__int16 *)(dword_D41A0 + 12);
    if ( *(_BYTE *)(v4 + dword_D41A0 + 11234) )
      return result;
    v5 = sub_48350();
    sub_76930(v5, v4, a1);
    if ( !*(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11234) )
    {
      v6 = *(_WORD *)(dword_D41A4 + 43);
      v7 = v6 > 0x18u && v6 < 0x32u;
      sub_47FC0(v7);
      sub_56A30(a3);
      sub_47160();
      while ( !*(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11234) )
      {
        if ( byte_E37FC && byte_E37FD && word_E3804 )
        {
          v8 = *(_BYTE *)(dword_D41A0 + 196308);
          if ( v8 )
          {
            if ( v8 <= 1u )
            {
              *(_DWORD *)(dword_D41A0 + 565) = 1;
            }
            else if ( v8 == 2 )
            {
              *(_DWORD *)(dword_D41A0 + 565) = 3;
            }
          }
          else
          {
            *(_DWORD *)(dword_D41A0 + 565) = 2;
          }
        }
        sub_6EDB0();
        sub_47320(a2);
        sub_53CC0();
        sub_8D8F0();
        sub_8E020();
        sub_86860(word_1803EC);
        sub_59BF0();
        sub_90B27(0, 0x10u, 0);
        if ( (word_180660 & 1) != 0 )
        {
          v9 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
          a1 = (__int16 *)dword_180628;
          sub_72883(v9, (void *)dword_180628, 0xC8u, v9);
        }
        else
        {
          v10 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
          a3 = dword_180628;
          sub_728A9(v10, (void *)dword_180628, 0x1E0u, v10);
        }
        if ( (word_180660 & 1) != 0 )
          sub_90478();
        else
          sub_75200(480);
        if ( (*(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) & 2) != 0
          && (*(_BYTE *)(dword_D41A4 + 38545) & 4) == 0 )
        {
          sub_6DB50(1, 0);
        }
        sub_713A0();
        v11 = 2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0;
        v12 = *(_BYTE *)(v11 + 11232);
        if ( (v12 & 4) != 0 )
        {
          sub_56D60(a3, 0);
          *(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) = 4;
        }
        else if ( (v12 & 2) != 0 )
        {
          sub_5C530();
          if ( (*(_BYTE *)(dword_D41A4 + 38545) & 0x20) != 0 )
            sub_6E0D0();
        }
        else
        {
          LOBYTE(a1) = v12 | 8;
          *(_BYTE *)(v11 + 11232) = v12 | 8;
        }
        BYTE1(a1) = *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232);
        if ( (BYTE1(a1) & 0x10) != 0 )
        {
          a3 = *(_WORD *)(dword_D41A4 + 43);
          if ( a3 >= 0x18u )
          {
            if ( (BYTE1(a1) & 2) != 0 )
              sub_5C530();
            break;
          }
          if ( (BYTE1(a1) & 2) != 0 )
          {
            v13 = sub_824B0(a3);
            if ( v13 )
            {
              *(_WORD *)(dword_D41A4 + 43) = v13[3];
              sub_47FC0(1);
              sub_56A30(a3);
              sub_47160();
            }
          }
        }
        else if ( (BYTE1(a1) & 0xA) != 0 )
        {
          break;
        }
      }
      word_E29D8 = 4;
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E29D8: using guessed type __int16 word_E29D8;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E3804: using guessed type __int16 word_E3804;
// EA3D8: using guessed type int dword_EA3D8;
// 1803EC: using guessed type __int16 word_1803EC;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (00046B40) --------------------------------------------------------
void sub_46B40()
{
  int v0; // kr00_4
  char v1; // al
  unsigned __int8 v2; // al
  unsigned __int8 v3; // al

  v0 = dword_E3760;
  if ( byte_D41B4 )
  {
    sub_90B27(0, 0x10u, 0);
    sub_417A0();
    memset(dword_EA3D8, 0, 768);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
    if ( dword_E9C3C )
    {
      sub_83E80(dword_E9C3C);
      dword_E9C3C = 0;
    }
    sub_54600();
    sub_6EBF0((unsigned int **)&off_D918C);
    sub_6EBF0((unsigned int **)off_D91BC);
    sub_6EBF0((unsigned int **)&off_D91EC);
    sub_47130();
    if ( word_180660 == 1 )
    {
      sub_90D3F((int)aDataMsprd00Dat);
      word_180660 = 8;
    }
    else
    {
      sub_6EBF0((unsigned int **)&off_D91D4);
      sub_90D3F((int)aDataHsprd00Dat);
      word_180660 = 1;
    }
    sub_47160();
    sub_6EB90((unsigned int **)&off_D918C);
    sub_6EB90((unsigned int **)&off_D91EC);
    memset(dword_EA3D8, 0, 768);
    if ( (word_180660 & 1) != 0 )
    {
      v1 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
      sub_72883(dword_180628, (void *)dword_180628, 0xC8u, v1);
    }
    else
    {
      v2 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
      sub_728A9(v2, (void *)dword_180628, 0x1E0u, v2);
    }
    memset(dword_EA3D8, 0, 768);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
    if ( (word_180660 & 1) != 0 )
      sub_90D6E((unsigned __int8 *)dword_EA3D8);
    else
      sub_90E07((unsigned __int8 *)dword_EA3D8);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
    v3 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
    byte_EB3A8 = v3;
    if ( (word_180660 & 1) != 0 )
      sub_72883(v3, (void *)dword_180628, 0xC8u, v3);
    else
      sub_728A9(v3, (void *)dword_180628, 0x1E0u, v3);
    sub_8CEDF();
    sub_8CD27(dword_EB394);
    *(_BYTE *)(dword_D41A4 + 51) = 2;
    if ( word_180660 == 1 )
      byte_D419D = 1;
    else
      byte_D419D = 3;
    sub_5BDC0(v0, SHIWORD(v0));
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D419D: using guessed type char byte_D419D;
// D41A4: using guessed type int dword_D41A4;
// D41B4: using guessed type char byte_D41B4;
// D918C: using guessed type int *off_D918C;
// D91BC: using guessed type int *off_D91BC[2];
// D91D4: using guessed type void *off_D91D4;
// D91EC: using guessed type int *off_D91EC;
// E3760: using guessed type int dword_E3760;
// E9C3C: using guessed type int dword_E9C3C;
// EA3D8: using guessed type int dword_EA3D8;
// EB394: using guessed type int dword_EB394;
// EB3A8: using guessed type char byte_EB3A8;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (00046DD0) --------------------------------------------------------
char __fastcall sub_46DD0(int a1, unsigned __int16 a2, int a3, int a4)
{
  int v4; // eax
  char v5; // bl
  char v6; // dl
  char v8[64]; // [esp+0h] [ebp-40h] BYREF

  sub_83CC0(20);
  if ( !byte_D4B50 )
  {
    LOBYTE(a2) = 1;
    byte_D4B50 = 1;
    if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x40) != 0 )
    {
      sub_70910();
      byte_E37FD = 0;
      byte_E3799 = 0;
      byte_E37FC = 0;
      byte_E3798 = 0;
    }
    else
    {
      sprintf(v8, "%s/%s", aNetherw, aSound);
      sub_90EA0(*(unsigned __int8 *)(dword_D41A4 + 182) - 64, v8);
      v4 = sub_70910();
      sub_90FD0(v4, a2, a3, a4);
      if ( !word_E2A14 )
        printf(aErrorNotEnough);
      if ( (*(_BYTE *)(dword_D41A4 + 25) & 0x40) != 0 )
        sub_8EAD0(1);
    }
    if ( byte_E3798 || byte_E37FC )
    {
      dword_F42A4 = sub_92600((int)sub_46820);
      sub_92930(dword_F42A4, 0x78u);
      sub_92BA0(dword_F42A4);
      byte_D4B51 = 1;
    }
    else
    {
      sub_6FDA0();
    }
    v5 = byte_E3798;
    if ( !byte_E3798 && !byte_E37FC && byte_E2A28 )
    {
      sub_86860(word_1803EC);
      sub_86BD0();
      v6 = *(_BYTE *)(dword_D41A4 + 24) & 0xBF;
      byte_E2A28 = v5;
      *(_BYTE *)(dword_D41A4 + 24) = v6;
    }
  }
  return sub_83CC0(21);
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;
// D4B50: using guessed type char byte_D4B50;
// D4B51: using guessed type char byte_D4B51;
// E2A14: using guessed type __int16 word_E2A14;
// E2A28: using guessed type char byte_E2A28;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// F42A4: using guessed type int dword_F42A4;
// 1803EC: using guessed type __int16 word_1803EC;

//----- (00046F50) --------------------------------------------------------
void sub_46F50()
{
  if ( byte_D4B51 )
    sub_92DC0(dword_F42A4);
  else
    sub_6FE20();
  sub_986E0();
}
// D4B51: using guessed type char byte_D4B51;
// F42A4: using guessed type int dword_F42A4;

//----- (00046F80) --------------------------------------------------------
unsigned int *sub_46F80()
{
  unsigned __int8 v0; // al
  char *v1; // esi
  char *v2; // esi
  unsigned int *result; // eax
  int v4; // eax
  unsigned int *v5; // ebx
  unsigned int v6; // esi
  unsigned int v7; // esi
  _DWORD v8[4]; // [esp+0h] [ebp-2h] BYREF
  __int16 v9; // [esp+10h] [ebp+Eh]
  char v10[64]; // [esp+40h] [ebp+3Eh] BYREF
  int v11; // [esp+80h] [ebp+7Eh]

  sub_47130();
  v0 = *(_BYTE *)(dword_D41A0 + 196308);
  if ( v0 )
  {
    if ( v0 <= 1u )
    {
      if ( word_180660 == 1 )
      {
        strcpy(v10, "data/mwebn0-0.dat");
        v1 = aDataMwebn00Tab;
      }
      else
      {
        strcpy(v10, "data/hwebn0-0.dat");
        v1 = aDataHwebn00Tab;
      }
    }
    else
    {
      if ( v0 != 2 )
        goto LABEL_15;
      if ( word_180660 == 1 )
      {
        strcpy(v10, "data/mwebc0-0.dat");
        v1 = aDataMwebc00Tab;
      }
      else
      {
        strcpy(v10, "data/hwebc0-0.dat");
        v1 = aDataHwebc00Tab;
      }
    }
  }
  else if ( word_180660 == 1 )
  {
    strcpy(v10, "data/mwebd0-0.dat");
    v1 = aDataMwebd00Tab;
  }
  else
  {
    strcpy(v10, "data/hwebd0-0.dat");
    v1 = aDataHwebd00Tab;
  }
  v8[0] = *(_DWORD *)v1;
  v2 = v1 + 4;
  v8[1] = *(_DWORD *)v2;
  v2 += 4;
  v8[2] = *(_DWORD *)v2;
  v2 += 4;
  v8[3] = *(_DWORD *)v2;
  v9 = *((_WORD *)v2 + 2);
LABEL_15:
  result = (unsigned int *)sub_53E60((int)v10, (char *)dword_180628);
  if ( (int)result > 0 )
  {
    v4 = (int)(result + 2);
    LOBYTE(v4) = v4 & 0xF8;
    v11 = v4;
    result = (unsigned int *)sub_53E60((int)v8, (char *)(v4 + dword_180628));
    v5 = result;
    if ( (int)result > 0 )
    {
      v6 = (unsigned int)result + v11;
      result = (unsigned int *)sub_83CD0((int)result + v11);
      dword_D4188 = (int)result;
      if ( result )
      {
        qmemcpy(result, (const void *)dword_180628, v6);
        dword_D418C = dword_D4188 + v11;
        v7 = (unsigned int)v5 + dword_D4188 + v11;
        dword_D4190 = v7;
        if ( (word_180660 & 1) != 0 )
          return (unsigned int *)sub_98709(dword_D4188 + v11, v7, dword_D4188);
        else
          return sub_9874D((unsigned int *)(dword_D4188 + v11), v7, dword_D4188);
      }
    }
  }
  return result;
}
// D4188: using guessed type int dword_D4188;
// D418C: using guessed type int dword_D418C;
// D4190: using guessed type int dword_D4190;
// D41A0: using guessed type int dword_D41A0;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;
// 46F80: using guessed type _DWORD var_84[4];

//----- (00047130) --------------------------------------------------------
void sub_47130()
{
  if ( dword_D4188 )
  {
    sub_83E80(dword_D4188);
    dword_D4188 = 0;
    dword_D418C = 0;
    dword_D4190 = 0;
  }
}
// D4188: using guessed type int dword_D4188;
// D418C: using guessed type int dword_D418C;
// D4190: using guessed type int dword_D4190;

//----- (00047160) --------------------------------------------------------
unsigned int *sub_47160()
{
  unsigned __int8 v0; // al

  v0 = *(_BYTE *)(dword_D41A0 + 196308);
  if ( v0 )
  {
    if ( v0 <= 1u )
    {
      sprintf(aDataMsprd00Dat, "%s", aDataMsprn00Dat);
      sprintf(aDataMsprd00Tab_0, "%s", aDataMsprn00Tab);
      sprintf(aDataHsprd00Dat, "%s", aDataHsprn00Dat);
      sprintf(aDataHsprd00Tab_0, "%s", aDataHsprn00Tab);
    }
    else if ( v0 == 2 )
    {
      sprintf(aDataMsprd00Dat, "%s", aDataMsprc00Dat);
      sprintf(aDataMsprd00Tab_0, "%s", aDataMsprc00Tab);
      sprintf(aDataHsprd00Dat, "%s", aDataHsprc00Dat);
      sprintf(aDataHsprd00Tab_0, "%s", aDataHsprc00Tab);
    }
  }
  else
  {
    sprintf(aDataMsprd00Dat, "%s", aDataMsprd00Dat_0);
    sprintf(aDataMsprd00Tab_0, "%s", aDataMsprd00Tab);
    sprintf(aDataHsprd00Dat, "%s", aDataHsprd00Dat_0);
    sprintf(aDataHsprd00Tab_0, "%s", aDataHsprd00Tab);
  }
  if ( word_180660 == 1 )
  {
    sub_84250((int)aDataMsprd00Dat);
    if ( dword_E9C3C )
      sub_83E80(dword_E9C3C);
    dword_E9C3C = sub_83CD0(64000);
  }
  else
  {
    sub_84250((int)aDataHsprd00Dat);
    if ( dword_E9C3C )
      sub_83E80(dword_E9C3C);
    dword_E9C3C = sub_83CD0((int)&loc_4AFFE + 2);
    sub_6EB90((unsigned int **)&off_D91D4);
  }
  sub_6EB90((unsigned int **)off_D91BC);
  return sub_46F80();
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// D91BC: using guessed type int *off_D91BC[2];
// D91D4: using guessed type void *off_D91D4;
// E9C3C: using guessed type int dword_E9C3C;
// 180660: using guessed type __int16 word_180660;

//----- (00047320) --------------------------------------------------------
int __usercall sub_47320@<eax>(int a1@<edi>)
{
  _BYTE *v1; // ebx
  int v2; // esi
  unsigned int v3; // esi
  int result; // eax

  *(_BYTE *)(dword_D41A4 + 51) = 0;
  v1 = 0;
  *(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) = 0;
  while ( 1 )
  {
    result = 2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0;
    if ( *(_BYTE *)(result + 11234) || (*(_BYTE *)(result + 11232) & 8) != 0 )
      break;
    v2 = dword_17DB54;
    sub_47560(v1, a1, dword_17DB54);
    v3 = v2 + 5;
    while ( v3 > dword_17DB54 )
      ;
    if ( (unsigned __int16)v1 < 2u )
    {
      sub_8E020();
      if ( (_WORD)v1 == 1 )
        sub_8E160(*(_WORD *)(dword_D41A0 + 565), 0x7Fu);
      ++v1;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 17DB54: using guessed type int dword_17DB54;

//----- (000473B0) --------------------------------------------------------
int sub_473B0()
{
  int result; // eax

  dword_EA3B4 = 0;
  result = (unsigned __int8)byte_1806E4;
  word_F42AE = (unsigned __int8)byte_1806E4;
  word_F42A8 = 64;
  return result;
}
// EA3B4: using guessed type int dword_EA3B4;
// F42A8: using guessed type __int16 word_F42A8;
// F42AE: using guessed type __int16 word_F42AE;
// 1806E4: using guessed type char byte_1806E4;

//----- (000473E0) --------------------------------------------------------
int sub_473E0()
{
  char v0; // bl
  __int16 v1; // ax

  v0 = 0;
  if ( dword_EA3B4 )
    return dword_EA3B4;
  if ( word_F42A8 )
    --word_F42A8;
  if ( !word_18074C && !word_18074A )
  {
    if ( byte_18068E || byte_18069A )
    {
      if ( (unsigned __int8)byte_1806E4 < 0x36u )
      {
        if ( byte_1806E4 != 42 )
          goto LABEL_24;
      }
      else if ( (unsigned __int8)byte_1806E4 > 0x36u
             && ((unsigned __int8)byte_1806E4 < 0x3Bu || (unsigned __int8)byte_1806E4 > 0x3Fu && byte_1806E4 != 66) )
      {
        goto LABEL_24;
      }
    }
    else if ( (unsigned __int8)byte_1806E4 < 0x3Bu )
    {
      if ( byte_1806E4 != 19 )
        goto LABEL_24;
    }
    else if ( (unsigned __int8)byte_1806E4 > 0x3Bu
           && ((unsigned __int8)byte_1806E4 < 0x3Fu || (unsigned __int8)byte_1806E4 > 0x41u) )
    {
LABEL_24:
      HIBYTE(v1) = HIBYTE(word_F42A8);
      if ( word_F42A8 )
      {
        word_F42AE = (unsigned __int8)byte_1806E4;
      }
      else
      {
        LOBYTE(v1) = byte_1806E4;
        if ( v1 != word_F42AE )
          v0 = 1;
      }
      goto LABEL_28;
    }
    sub_473B0();
    goto LABEL_24;
  }
  v0 = 1;
LABEL_28:
  if ( v0 )
    dword_EA3B4 = 1;
  return dword_EA3B4;
}
// EA3B4: using guessed type int dword_EA3B4;
// F42A8: using guessed type __int16 word_F42A8;
// F42AE: using guessed type __int16 word_F42AE;
// 18068E: using guessed type char byte_18068E;
// 18069A: using guessed type char byte_18069A;
// 1806E4: using guessed type char byte_1806E4;
// 18074A: using guessed type __int16 word_18074A;
// 18074C: using guessed type __int16 word_18074C;

//----- (00047560) --------------------------------------------------------
void __usercall sub_47560(_BYTE *a1@<ebx>, int a2@<edi>, __int16 a3@<si>)
{
  unsigned __int8 v3; // al
  int j; // ebx
  int i; // ebx
  int v6; // eax

  sub_47760();
  if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) == 0 )
    sub_715B0();
  sub_89D10();
  sub_17A00(a1, a2, a3);
  sub_51BB0(a2);
  sub_848A0();
  v3 = *(_BYTE *)(dword_D41A4 + 178);
  if ( v3 )
  {
    if ( v3 <= 1u )
    {
      for ( i = 0; i < 4; ++i )
        sub_57730();
    }
    else if ( v3 == 2 )
    {
      for ( j = 0; j < 8; ++j )
        sub_57730();
    }
  }
  else
  {
    sub_57730();
  }
  sub_84B80();
  sub_58F00();
  sub_59820();
  if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) == 0 )
    sub_57570();
  sub_575C0();
  sub_6E150();
  sub_2BE30();
  if ( *(_BYTE *)(dword_D41A4 + 10) )
    sub_871F0();
  *(_DWORD *)(dword_D41A4 + 196) = dword_17DB54 - *(_DWORD *)(dword_D41A4 + 196);
  sub_6FEC0();
  v6 = dword_D41A4;
  *(_DWORD *)(dword_D41A4 + 196) = dword_17DB54;
  if ( *(_BYTE *)(v6 + 51) >= 3u )
    sub_40F80();
}
// D41A4: using guessed type int dword_D41A4;
// 17DB54: using guessed type int dword_17DB54;

//----- (00047650) --------------------------------------------------------
int __fastcall sub_47650(int a1, int a2)
{
  unsigned __int8 v2; // al
  int v3; // esi
  int v4; // edx
  int i; // ebx
  int v6; // ecx
  int v7; // eax
  int result; // eax

  qmemcpy((void *)dword_EA3D8, (const void *)dword_EA3B8, 0x300u);
  v2 = *(_BYTE *)(dword_D41A0 + 196308);
  if ( v2 )
  {
    if ( v2 <= 1u )
    {
      a2 = *(char *)(dword_D41A4 + 12);
    }
    else if ( v2 == 2 )
    {
      a2 = *(char *)(dword_D41A4 + 13);
    }
  }
  else
  {
    a2 = *(char *)(dword_D41A4 + 11);
  }
  v3 = 0;
  v4 = 6 * a2;
  while ( v3 < 256 )
  {
    for ( i = 0; i < 3; ++i )
    {
      v6 = v4 + *(unsigned __int8 *)(dword_EA3D8 + i + 3 * v3);
      if ( v6 < 0 )
        v6 = 0;
      if ( v6 > 63 )
        LOBYTE(v6) = 63;
      v7 = i + 3 * v3;
      *(_BYTE *)(dword_EA3D8 + v7) = v6;
    }
    ++v3;
  }
  result = dword_D41A4;
  *(_BYTE *)(dword_D41A4 + 180) = 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3B8: using guessed type int dword_EA3B8;
// EA3D8: using guessed type int dword_EA3D8;

//----- (00047760) --------------------------------------------------------
char sub_47760()
{
  _BYTE *v0; // eax
  unsigned __int8 v1; // dl
  int v2; // edx
  unsigned __int8 v3; // al
  int i; // eax
  int v5; // edx
  int j; // eax
  int v7; // ebx
  int v8; // ebx
  int v9; // ebx
  int k; // edx
  int v11; // ebx
  int v12; // eax
  int m; // eax
  int v14; // ebx
  int n; // ebx
  int v16; // ecx
  char v17; // al
  int ii; // eax
  int v19; // ebx
  int v21; // [esp-Ch] [ebp-Ch]
  char *v22; // [esp-Ch] [ebp-Ch]
  char *v23; // [esp-Ch] [ebp-Ch]
  char *v24; // [esp-Ch] [ebp-Ch]

  v0 = (_BYTE *)dword_D41A4;
  v1 = *(_BYTE *)(dword_D41A4 + 51);
  *(_BYTE *)(dword_D41A4 + 181) = 0;
  if ( v1 < 2u )
  {
    sub_480A0();
    LOBYTE(v0) = dword_D41A4;
    ++*(_BYTE *)(dword_D41A4 + 51);
  }
  else if ( v1 <= 2u )
  {
    v0[51] = v1 + 1;
    v21 = dword_EA3D8;
    v0[180] = 1;
    memset(v21, 0, 768);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
    v2 = dword_D41A0;
    v3 = *(_BYTE *)(dword_D41A0 + 196308);
    if ( v3 )
    {
      if ( v3 <= 1u )
      {
        if ( (*(_BYTE *)(dword_D41A0 + 196306) & 2) != 0 )
          sub_53E60((int)aDataPalf0Dat, (char *)dword_EA3D8);
        else
          sub_53E60((int)aDataPaln0Dat, (char *)dword_EA3D8);
        sub_53E60((int)aDataClrn0Dat, byte_E8900);
      }
      else if ( v3 == 2 )
      {
        sub_53E60((int)aDataPalc0Dat, (char *)dword_EA3D8);
        sub_53E60((int)aDataClrc0Dat, byte_E8900);
      }
    }
    else
    {
      sub_53E60((int)aDataPald0Dat, (char *)dword_EA3D8);
      sub_53E60((int)aDataClrd0Dat, byte_E8900);
    }
    qmemcpy((void *)dword_EA3B8, (const void *)dword_EA3D8, 0x300u);
    sub_47650(768, v2);
    sub_90D27();
    byte_EB3A8 = byte_E8900[0];
    LOBYTE(v0) = sub_57640();
  }
  else if ( v1 == 3 )
  {
    switch ( v0[180] )
    {
      case 1:
        v22 = (char *)dword_EA3D8;
        v0[181] = 1;
        LOWORD(v0) = sub_90B27(v22, 4u, 1);
        if ( (_WORD)v0 == 4 )
        {
          LOBYTE(v0) = dword_D41A4;
          *(_BYTE *)(dword_D41A4 + 180) = 0;
        }
        return (char)v0;
      case 2:
        for ( i = 1; i < 256; ++i )
        {
          dword_F42A0 = *(unsigned __int8 *)(3 * i + dword_EA3D8) + 40;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA0[3 * i] = dword_F42A0;
          dword_F42A0 = *(unsigned __int8 *)(3 * i + dword_EA3D8 + 1);
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA1[3 * i] = dword_F42A0;
          dword_F42A0 = *(unsigned __int8 *)(3 * i + dword_EA3D8 + 2);
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          v5 = 3 * i;
          byte_F3FA2[v5] = dword_F42A0;
        }
        goto LABEL_74;
      case 3:
        for ( j = 1; j < 256; ++j )
        {
          v7 = *(__int16 *)(dword_D41A4 + 184);
          dword_F42A0 = *(unsigned __int8 *)(3 * j + dword_EA3D8);
          dword_F42A0 += (-56 * v7) >> 8;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA0[3 * j] = dword_F42A0;
          dword_F42A0 = *(unsigned __int8 *)(3 * j + dword_EA3D8 + 1);
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA1[3 * j] = dword_F42A0;
          v8 = *(__int16 *)(dword_D41A4 + 184);
          dword_F42A0 = *(unsigned __int8 *)(3 * j + dword_EA3D8 + 2);
          dword_F42A0 += (-56 * v8) >> 8;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          v9 = 3 * j;
          byte_F3FA2[v9] = dword_F42A0;
        }
        goto LABEL_74;
      case 4:
        for ( k = 1; k < 256; ++k )
        {
          v11 = dword_EA3D8;
          v12 = 3 * k;
          dword_F42A0 = 255;
          byte_F3FA0[v12] = *(_BYTE *)(dword_EA3D8 + 3 * k);
          byte_F3FA1[v12] = *(_BYTE *)(v11 + 3 * k + 1);
          byte_F3FA2[v12] = 63;
        }
        goto LABEL_74;
      case 5:
        memset(dword_EA3D8, 0, 768);
        v0 = (_BYTE *)dword_D41A4;
        *(_BYTE *)(dword_D41A4 + 180) = 10;
        v0[181] = 1;
        return (char)v0;
      case 6:
        for ( m = 1; m < 256; ++m )
        {
          dword_F42A0 = *(unsigned __int8 *)(3 * m + dword_EA3D8 + 2) + 48;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA0[3 * m] = dword_F42A0;
          dword_F42A0 = *(unsigned __int8 *)(3 * m + dword_EA3D8 + 1) + 32;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA1[3 * m] = dword_F42A0;
          dword_F42A0 = *(unsigned __int8 *)(3 * m + dword_EA3D8 + 2) + 32;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          v14 = 3 * m;
          byte_F3FA2[v14] = dword_F42A0;
        }
        goto LABEL_74;
      case 7:
        for ( n = 1; n < 256; ++n )
        {
          v16 = 3 * n;
          dword_F42A0 = (*(unsigned __int8 *)(3 * n + dword_EA3D8)
                       + *(unsigned __int8 *)(3 * n + dword_EA3D8 + 1)
                       + *(unsigned __int8 *)(3 * n + dword_EA3D8 + 2))
                      / 3;
          v17 = dword_F42A0;
          byte_F3FA0[v16] = dword_F42A0;
          byte_F3FA1[v16] = v17;
          byte_F3FA2[v16] = v17;
        }
LABEL_74:
        sub_90D27();
        sub_41A90((unsigned __int8 *)byte_F3FA0);
        v0 = (_BYTE *)dword_D41A4;
        *(_BYTE *)(dword_D41A4 + 180) = 1;
        v0[181] = 1;
        break;
      case 8:
        for ( ii = 1; ii < 256; ++ii )
        {
          dword_F42A0 = *(unsigned __int8 *)(3 * ii + dword_EA3D8) + 48;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA0[3 * ii] = dword_F42A0;
          dword_F42A0 = *(unsigned __int8 *)(3 * ii + dword_EA3D8 + 1) + 48;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          byte_F3FA1[3 * ii] = dword_F42A0;
          dword_F42A0 = *(unsigned __int8 *)(3 * ii + dword_EA3D8 + 2) + 48;
          if ( dword_F42A0 < 0 )
            dword_F42A0 = 0;
          if ( dword_F42A0 > 63 )
            dword_F42A0 = 63;
          v19 = 3 * ii;
          byte_F3FA2[v19] = dword_F42A0;
        }
        sub_90D27();
        sub_41A90((unsigned __int8 *)byte_F3FA0);
        v0 = (_BYTE *)dword_D41A4;
        *(_BYTE *)(dword_D41A4 + 180) = 9;
        v0[181] = 1;
        break;
      case 9:
        v23 = (char *)dword_EA3D8;
        v0[181] = 1;
        LOWORD(v0) = sub_90B27(v23, 0x10u, 1);
        if ( (_WORD)v0 == 16 )
        {
          LOBYTE(v0) = dword_D41A4;
          *(_BYTE *)(dword_D41A4 + 180) = 0;
        }
        break;
      case 0xA:
        v24 = (char *)dword_EA3D8;
        v0[181] = 1;
        LOWORD(v0) = sub_90B27(v24, 0x1Cu, 1);
        if ( (_WORD)v0 == 28 )
        {
          LOBYTE(v0) = dword_D41A4;
          *(_BYTE *)(dword_D41A4 + 180) = 0;
        }
        break;
      default:
        return (char)v0;
    }
  }
  return (char)v0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3B8: using guessed type int dword_EA3B8;
// EA3D8: using guessed type int dword_EA3D8;
// EB3A8: using guessed type char byte_EB3A8;
// F42A0: using guessed type int dword_F42A0;

//----- (00047FC0) --------------------------------------------------------
int __cdecl sub_47FC0(char a1)
{
  int result; // eax

  sub_90B27(0, 0x10u, 0);
  if ( a1 )
    sub_53E60((int)aDataSmatitl2Da, (char *)dword_E9C38);
  else
    sub_53E60((int)aDataSmatitleDa, (char *)dword_E9C38);
  sub_85B20((_BYTE *)dword_E9C38, (_WORD *)dword_180628, 0x190u);
  if ( (word_180660 & 1) != 0 )
    sub_90478();
  else
    sub_75200(480);
  if ( a1 )
    sub_53E60((int)aDataSmatitl2Pa, (char *)dword_EA3D8);
  else
    sub_53E60((int)aDataSmatitlePa, (char *)dword_EA3D8);
  sub_90B27((char *)dword_EA3D8, 0x20u, 0);
  result = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 570) = 1;
  *(_DWORD *)(result + 574) = 0;
  *(_DWORD *)(result + 578) = 0;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E9C38: using guessed type int dword_E9C38;
// EA3D8: using guessed type int dword_EA3D8;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (000480A0) --------------------------------------------------------
char sub_480A0()
{
  int v0; // ebx
  char *v2; // [esp-4h] [ebp-4h]

  v0 = j___clock();
  sub_98790(0x1F4u, 0);
  while ( (unsigned int)(j___clock() - v0) < 0x32 )
    ;
  sub_90B27(0, 0x10u, 0);
  v2 = (char *)dword_EA3D8;
  *(_DWORD *)(dword_D41A0 + 570) = 0;
  sub_53E60((int)aDataPald0Dat, v2);
  sub_53E60((int)aDataClrd0Dat, byte_E8900);
  return sub_48120();
}
// 98786: using guessed type int j___clock(void);
// D41A0: using guessed type int dword_D41A0;
// EA3D8: using guessed type int dword_EA3D8;

//----- (00048120) --------------------------------------------------------
char sub_48120()
{
  char result; // al

  result = *(_BYTE *)(dword_D41A0 + 196308);
  if ( !result )
  {
    byte_E88E0 = 96;
    byte_E88E1 = 100;
    byte_E88E6 = 28;
    byte_E88E2 = 123;
    byte_E88E3 = 123;
    byte_E88E5 = 123;
    byte_E88E7 = 24;
    byte_E88E8 = 123;
    byte_E88ED = -105;
    result = -37;
    byte_E88E4 = 119;
    byte_E88E9 = 91;
    byte_E88EB = 123;
    byte_E88EF = -37;
    byte_E88F5 = 61;
    byte_E88EA = 87;
    byte_E88EC = -102;
    byte_E88EE = 123;
    byte_E88F0 = -40;
    byte_E88F1 = 123;
    byte_E88F6 = 58;
    byte_E88F2 = 118;
    byte_E88F3 = -96;
    byte_E88F7 = 123;
    byte_E88F4 = 123;
    return result;
  }
  if ( (unsigned __int8)result <= 1u )
  {
    byte_E88E0 = -92;
    byte_E88E1 = -86;
    byte_E88E3 = 119;
    byte_E88E2 = 123;
    byte_E88E4 = 125;
    byte_E88E5 = 123;
    byte_E88E7 = -58;
    byte_E88E8 = 123;
    byte_E88E6 = -64;
    byte_E88EC = -105;
    byte_E88EF = -41;
    byte_E88EB = 123;
    byte_E88F0 = -35;
    byte_E88E9 = 88;
LABEL_8:
    byte_E88F3 = 98;
    byte_E88EA = 93;
    byte_E88F1 = 123;
    byte_E88ED = -99;
    byte_E88EE = 123;
    byte_E88F2 = 105;
    result = 123;
    byte_E88F4 = 123;
    byte_E88F5 = -55;
    byte_E88F7 = 123;
    byte_E88F6 = -49;
    return result;
  }
  if ( result == 2 )
  {
    byte_E88E0 = -32;
    byte_E88E1 = 88;
    byte_E88E3 = 119;
    byte_E88E2 = 123;
    byte_E88E4 = 125;
    byte_E88E5 = 123;
    byte_E88E7 = -58;
    byte_E88E8 = 123;
    byte_E88E9 = 88;
    byte_E88E6 = -64;
    byte_E88EC = -105;
    byte_E88EF = -41;
    byte_E88EB = 123;
    byte_E88F0 = -35;
    goto LABEL_8;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E88E0: using guessed type char byte_E88E0;
// E88E1: using guessed type char byte_E88E1;
// E88E2: using guessed type char byte_E88E2;
// E88E3: using guessed type char byte_E88E3;
// E88E4: using guessed type char byte_E88E4;
// E88E5: using guessed type char byte_E88E5;
// E88E6: using guessed type char byte_E88E6;
// E88E7: using guessed type char byte_E88E7;
// E88E8: using guessed type char byte_E88E8;
// E88E9: using guessed type char byte_E88E9;
// E88EA: using guessed type char byte_E88EA;
// E88EB: using guessed type char byte_E88EB;
// E88EC: using guessed type char byte_E88EC;
// E88ED: using guessed type char byte_E88ED;
// E88EE: using guessed type char byte_E88EE;
// E88EF: using guessed type char byte_E88EF;
// E88F0: using guessed type char byte_E88F0;
// E88F1: using guessed type char byte_E88F1;
// E88F2: using guessed type char byte_E88F2;
// E88F3: using guessed type char byte_E88F3;
// E88F4: using guessed type char byte_E88F4;
// E88F5: using guessed type char byte_E88F5;
// E88F6: using guessed type char byte_E88F6;
// E88F7: using guessed type char byte_E88F7;

//----- (00048350) --------------------------------------------------------
int sub_48350()
{
  int result; // eax

  *(_BYTE *)(dword_D41A4 + 38545) &= 0x43u;
  result = dword_D41A0;
  *(_BYTE *)(dword_D41A0 + 224779) &= ~1u;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00048370) --------------------------------------------------------
int __cdecl sub_48370(__int16 a1, __int16 a2, __int16 a3)
{
  int result; // eax
  int v4; // ebx
  int v5; // edx

  LOWORD(result) = a2 - a1;
  v4 = (__int16)(a2 - a1);
  v5 = a3 >> 1;
  if ( v4 > v5 )
    return (__int16)(result - a3);
  if ( v4 < -v5 )
    LOWORD(result) = a3 + result;
  return (__int16)result;
}

//----- (000483A0) --------------------------------------------------------
int __cdecl sub_483A0(__int16 a1, int a2, char a3, char a4)
{
  unsigned __int16 v4; // ax
  __int16 v5; // bx
  unsigned __int16 v6; // ax
  int result; // eax

  LOBYTE(v4) = a1;
  HIBYTE(v4) = a2;
  LOBYTE(v5) = byte_11B4E0[v4];
  LOBYTE(v6) = a3;
  v5 = (unsigned __int8)v5;
  HIBYTE(v6) = a4;
  if ( (unsigned __int8)byte_11B4E0[v6] > (int)(unsigned __int8)v5 )
    LOBYTE(v5) = byte_11B4E0[v6];
  word_EB398 = a1 << 8;
  result = a2 << 8;
  word_EB39C = 32 * v5;
  word_EB39A = (_WORD)a2 << 8;
  return result;
}
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00048400) --------------------------------------------------------
int __cdecl sub_48400(__int16 a1, int a2, __int16 a3, int a4)
{
  int v4; // ebx
  int result; // eax
  int v6; // ecx
  char v7; // al
  char v8; // al
  int v9; // edi
  int v10; // esi
  int v11; // eax
  int v12; // eax
  int v13; // ebx
  int v14; // edx
  signed int v15; // edi
  int v16; // esi
  int v17; // eax
  int v18; // ebx
  int v19; // eax
  int v20; // [esp+8h] [ebp-Ch]
  int v21; // [esp+8h] [ebp-Ch]
  int v22; // [esp+Ch] [ebp-8h]
  int v23; // [esp+Ch] [ebp-8h]
  int v24; // [esp+10h] [ebp-4h]
  int v25; // [esp+10h] [ebp-4h]

  v4 = sub_48370(a1, a3, 256);
  result = sub_48370(a2, a4, 256);
  v6 = result;
  if ( v4 || result )
  {
    if ( v4 < 0 )
    {
      v7 = a1;
      v4 = -v4;
      v6 = -v6;
      a1 = a3;
      LOBYTE(a3) = v7;
      v8 = a2;
      a2 = a4;
      LOBYTE(a4) = v8;
    }
    if ( v4 <= (int)abs32(v6) )
    {
      v15 = abs32(v6 / 10) + 1;
      v16 = v6 / v15;
      v25 = v4 / v15;
      v23 = v6 % v15;
      v21 = v4 % v15;
      do
      {
        sub_483A0(a1, (unsigned __int16)a2, a3, a4);
        v17 = sub_4A190((int)&word_EB398, 10, 27);
        if ( v16 >= 0 )
        {
          *(_BYTE *)(v17 + 69) = 28;
          v18 = v16 + v23;
        }
        else
        {
          *(_BYTE *)(v17 + 69) = 27;
          v18 = -v16 - v23;
        }
        *(_DWORD *)(v17 + 16) = v18;
        sub_483A0(a1, (unsigned __int16)(v16 + v23 + a2), a3, a4);
        --v15;
        LOWORD(a2) = v16 + v23 + a2;
        v19 = sub_4A190((int)&word_EB398, 10, 27);
        *(_BYTE *)(v19 + 69) = 29;
        *(_DWORD *)(v19 + 16) = v21 + v25;
        result = 0;
        a1 += v21 + v25;
        v21 = 0;
        v23 = 0;
      }
      while ( v15 );
    }
    else
    {
      v9 = v4 / 10 + 1;
      v24 = v4 / v9;
      v10 = v6 / v9;
      result = v9 * (v6 / v9);
      v20 = v4 % v9;
      v22 = v6 % v9;
      if ( v4 / 10 != -1 )
      {
        do
        {
          sub_483A0(a1, (unsigned __int16)a2, a3, a4);
          v11 = sub_4A190((int)&word_EB398, 10, 27);
          *(_BYTE *)(v11 + 69) = 29;
          *(_DWORD *)(v11 + 16) = v20 + v24;
          a1 += v20 + v24;
          sub_483A0(a1, (unsigned __int16)a2, a3, a4);
          v12 = sub_4A190((int)&word_EB398, 10, 27);
          if ( v10 >= 0 )
          {
            *(_BYTE *)(v12 + 69) = 28;
            v13 = v10 + v22;
          }
          else
          {
            *(_BYTE *)(v12 + 69) = 27;
            v13 = -v10 - v22;
          }
          *(_DWORD *)(v12 + 16) = v13;
          --v9;
          result = v10 + v22;
          v20 = 0;
          v14 = v10 + v22 + a2;
          v22 = 0;
          a2 = v14;
        }
        while ( v9 );
      }
    }
  }
  return result;
}
// 485BA: conditional instruction was optimized away because edi.4!=0
// EB398: using guessed type __int16 word_EB398;

//----- (00048690) --------------------------------------------------------
int __cdecl sub_48690(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  int v4; // ebx
  __int16 v5; // si
  int v6; // eax
  __int16 v7; // bx
  signed int v8; // edi
  int v9; // eax
  int result; // eax
  unsigned int v11; // [esp+0h] [ebp-14h]
  int v12; // [esp+4h] [ebp-10h]
  __int16 v13; // [esp+8h] [ebp-Ch]
  __int16 v14; // [esp+Ch] [ebp-8h]
  signed int v15; // [esp+10h] [ebp-4h]

  v4 = sub_48370(a1, a3, 256);
  v12 = v4;
  v5 = 0;
  v6 = sub_48370(a2, a4, 256);
  if ( v4 )
  {
    v5 = -1;
    if ( v4 > 0 )
      v5 = 1;
  }
  v7 = 0;
  if ( v6 )
  {
    v7 = -1;
    if ( v6 > 0 )
      v7 = 1;
  }
  v15 = abs32(v6);
  v8 = abs32(v12);
  v11 = abs32(v15 - v8);
  if ( v8 <= v15 )
  {
    v14 = v7;
    v13 = 0;
  }
  else
  {
    v8 = v15;
    v13 = v5;
    v14 = 0;
  }
  word_EB398 = a1 << 8;
  word_EB39A = a2 << 8;
  v9 = sub_4A190((int)&word_EB398, 10, 30);
  if ( v9 )
  {
    *(_DWORD *)(v9 + 16) = v8;
    *(_WORD *)(v9 + 28) = v5;
    *(_WORD *)(v9 + 30) = v7;
  }
  word_EB398 = ((_WORD)v8 * v5 + a1) << 8;
  word_EB39A = ((_WORD)v8 * v7 + a2) << 8;
  result = sub_4A190((int)&word_EB398, 10, 30);
  if ( result )
  {
    *(_DWORD *)(result + 16) = v11;
    *(_WORD *)(result + 28) = v13;
    *(_WORD *)(result + 30) = v14;
  }
  return result;
}
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;

//----- (000487D0) --------------------------------------------------------
int __cdecl sub_487D0(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4, char a5)
{
  __int16 v5; // si
  unsigned __int16 v6; // bx
  int result; // eax
  __int16 v8[4]; // [esp+0h] [ebp-10h] BYREF
  __int16 v9[4]; // [esp+8h] [ebp-8h] BYREF

  v8[0] = a1 << 8;
  v8[1] = a2 << 8;
  v8[2] = 32 * (unsigned __int8)byte_11B4E0[256 * a2 + a1];
  v9[0] = a3 << 8;
  v9[1] = a4 << 8;
  v5 = sub_581E0(v8, v9);
  v6 = sub_58490(v8, v9);
  result = sub_4A190((int)v8, 10, 32);
  if ( result )
  {
    *(_WORD *)(result + 28) = v5;
    *(_DWORD *)(result + 8) = (int)v6 >> 8;
    *(_BYTE *)(result + 70) = a5;
  }
  return result;
}

//----- (00048880) --------------------------------------------------------
int __cdecl sub_48880(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4)
{
  __int16 v4; // si
  unsigned __int16 v5; // di
  int result; // eax
  int v7; // ebx
  int v8; // ecx
  __int16 v9[4]; // [esp+0h] [ebp-10h] BYREF
  __int16 v10[4]; // [esp+8h] [ebp-8h] BYREF

  v9[0] = a1 << 8;
  v9[1] = a2 << 8;
  v9[2] = 16 * (unsigned __int8)byte_11B4E0[256 * a2 + a1];
  v10[0] = a3 << 8;
  v10[1] = a4 << 8;
  v4 = sub_581E0(v9, v10);
  v5 = sub_58490(v9, v10);
  result = sub_4A190((int)v9, 10, 51);
  v7 = result;
  if ( result )
  {
    v8 = *(__int16 *)(result + 130);
    *(_WORD *)(result + 28) = v4;
    result = v5 / v8;
    *(_DWORD *)(v7 + 8) = result;
  }
  return result;
}

//----- (00048990) --------------------------------------------------------
unsigned int __cdecl sub_48990(char a1, char a2, char a3, char a4)
{
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // dx
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // ecx
  unsigned int v9; // ecx
  unsigned int v10; // ecx

  LOBYTE(v4) = a1;
  HIBYTE(v4) = a2;
  HIBYTE(v5) = a2;
  LOBYTE(v5) = a4 + a1;
  v6 = (unsigned __int8)byte_11B4E0[v4];
  v7 = v6;
  v8 = (unsigned __int8)byte_11B4E0[v5];
  if ( v8 <= v6 )
  {
    if ( v8 < v6 )
      v7 = (unsigned __int8)byte_11B4E0[v5];
  }
  else
  {
    v6 = (unsigned __int8)byte_11B4E0[v5];
  }
  HIBYTE(v5) = a3 + a2;
  v9 = (unsigned __int8)byte_11B4E0[v5];
  if ( v9 <= v6 )
  {
    if ( v9 < v7 )
      v7 = (unsigned __int8)byte_11B4E0[v5];
  }
  else
  {
    v6 = (unsigned __int8)byte_11B4E0[v5];
  }
  LOBYTE(v5) = a1;
  v10 = (unsigned __int8)byte_11B4E0[v5];
  if ( v10 > v6 )
    return v10 - v7;
  if ( v10 < v7 )
    v7 = (unsigned __int8)byte_11B4E0[v5];
  return v6 - v7;
}

//----- (00048A20) --------------------------------------------------------
__int16 __usercall sub_48A20@<ax>(int a1@<edi>, char a2, char a3, int a4, int a5, unsigned __int8 a6)
{
  int v6; // eax
  int v7; // esi
  unsigned __int16 v8; // bx
  unsigned __int16 v9; // bx
  int v10; // eax
  int v11; // edi
  char v13; // [esp+0h] [ebp-8h]
  char v14; // [esp+1h] [ebp-7h]
  __int16 v15; // [esp+2h] [ebp-6h]
  unsigned __int16 v16; // [esp+4h] [ebp-4h]
  unsigned __int16 v17; // [esp+4h] [ebp-4h]

  v13 = a2 - a5;
  v14 = a3 - a4;
  HIWORD(v6) = v15;
  HIBYTE(v16) = a3 - a4;
  HIBYTE(v8) = a3 - a4;
  v7 = 2 * a4;
  LOBYTE(v8) = a2 - a5 - a6;
  LOBYTE(v16) = 2 * a5 + a2 - a5;
  while ( (_WORD)--v7 != 0xFFFF )
  {
    LOWORD(a1) = a6;
    ++a1;
    while ( (_WORD)--a1 != 0xFFFF )
    {
      sub_48B90(v8);
      sub_48B90(v16);
      LOBYTE(v8) = v8 + 1;
      LOBYTE(v16) = v16 + 1;
    }
    LOBYTE(v16) = 2 * a5 + v13;
    LOBYTE(v8) = v13 - a6;
    ++HIBYTE(v8);
    ++HIBYTE(v16);
  }
  LOBYTE(v9) = v13 - a6;
  LOBYTE(v17) = v13 - a6;
  HIBYTE(v9) = v14 - a6;
  HIBYTE(v17) = 2 * a4 + v14;
  LOWORD(v6) = a6;
  v10 = 2 * v6;
  v11 = v10 + 2 * a5;
  while ( (_WORD)--v11 != 0xFFFF )
  {
    LOWORD(v7) = a6;
    ++v7;
    while ( (_WORD)--v7 != 0xFFFF )
    {
      sub_48B90(v9);
      sub_48B90(v17);
      ++HIBYTE(v9);
      ++HIBYTE(v17);
    }
    LOBYTE(v10) = 2 * a4;
    HIBYTE(v9) = v14 - a6;
    LOBYTE(v9) = v9 + 1;
    BYTE1(v10) = 2 * a4 + v14;
    HIBYTE(v17) = BYTE1(v10);
    LOBYTE(v17) = v17 + 1;
  }
  return v10;
}
// 48A3D: variable 'v15' is possibly undefined
// 48AE6: variable 'v6' is possibly undefined

//----- (00048B50) --------------------------------------------------------
__int16 __cdecl sub_48B50(unsigned __int8 a1, char a2, int a3, int a4)
{
  unsigned __int16 v5; // bx
  int v6; // esi
  __int16 result; // ax

  LOBYTE(v5) = a1;
  HIBYTE(v5) = a2;
  while ( (_WORD)--a3 != 0xFFFF )
  {
    v6 = a4;
    while ( (_WORD)--v6 != 0xFFFF )
    {
      result = sub_48B90(v5);
      LOBYTE(v5) = v5 + 1;
    }
    v5 = __PAIR16__(HIBYTE(v5), a1) + 256;
  }
  return result;
}

//----- (00048B90) --------------------------------------------------------
__int16 __cdecl sub_48B90(int a1)
{
  int i; // eax
  unsigned int v2; // ecx
  unsigned int v3; // ebx
  char v4; // dl
  char v5; // dh
  unsigned __int8 v6; // dh
  char v7; // bl

  LOWORD(i) = a1;
  v2 = 0;
  v3 = 0;
  if ( (byte_13B4E0[(unsigned __int16)a1] & 7) != 0
    && byte_11B4E0[(unsigned __int16)a1]
    && ((unsigned __int8)byte_10B3DF[(unsigned __int16)a1] <= 5u
     || (unsigned __int8)byte_10B3DF[(unsigned __int16)a1] > 0x22u)
    && ((unsigned __int8)byte_10B3E0[(unsigned __int16)a1] <= 5u
     || (unsigned __int8)byte_10B3E0[(unsigned __int16)a1] > 0x22u)
    && ((unsigned __int8)byte_10B4DF[(unsigned __int16)a1] <= 5u
     || (unsigned __int8)byte_10B4DF[(unsigned __int16)a1] > 0x22u)
    && ((unsigned __int8)byte_10B4E0[(unsigned __int16)a1] <= 5u
     || (unsigned __int8)byte_10B4E0[(unsigned __int16)a1] > 0x22u) )
  {
    v4 = 3;
    for ( i = a1 - 257; --v4 != -1; i += 253 )
    {
      v5 = 3;
      while ( --v5 != -1 )
      {
        if ( (unsigned __int8)byte_10B4E0[(unsigned __int16)i] <= 5u
          || (unsigned __int8)byte_10B4E0[(unsigned __int16)i] > 0x22u )
        {
          ++v3;
          v2 += (unsigned __int8)byte_11B4E0[(unsigned __int16)i];
        }
        ++i;
      }
    }
    if ( v3 )
    {
      i = (unsigned __int16)a1;
      byte_11B4E0[(unsigned __int16)a1] = v2 / v3;
      if ( byte_D41B6 )
      {
        v6 = byte_11B4E0[(unsigned __int16)a1];
        if ( (unsigned __int8)byte_14B4E0[(unsigned __int16)a1] > v6 )
        {
          byte_13B4E0[(unsigned __int16)a1] &= ~8u;
        }
        else
        {
          v7 = byte_13B4E0[(unsigned __int16)a1] | 8;
          byte_14B4E0[(unsigned __int16)a1] = v6 - 1;
          byte_13B4E0[(unsigned __int16)a1] = v7;
        }
      }
    }
  }
  return i;
}
// D41B6: using guessed type char byte_D41B6;

//----- (00048D20) --------------------------------------------------------
__int16 __cdecl sub_48D20(int a1, unsigned __int16 a2)
{
  unsigned int v2; // esi
  unsigned int v3; // ecx
  int v4; // eax
  int v5; // ebx
  __int64 v6; // rax
  unsigned __int8 v7; // bl
  unsigned __int8 v8; // dh
  char v10; // [esp+8h] [ebp-8h]
  char v11; // [esp+Ch] [ebp-4h]

  v2 = 0;
  v3 = 0;
  LOBYTE(v4) = byte_14B4E0[(unsigned __int16)a1];
  BYTE1(v4) = 3;
  v5 = a1 - 257;
  v10 = 3;
  while ( --v10 != -1 )
  {
    v11 = 3;
    while ( 1 )
    {
      BYTE1(v4) = v11 - 1;
      v11 = BYTE1(v4);
      if ( BYTE1(v4) == 0xFF )
        break;
      v6 = (unsigned __int8)byte_14B4E0[(unsigned __int16)v5] - (unsigned __int8)byte_14B4E0[(unsigned __int16)a1];
      v4 = (HIDWORD(v6) ^ v6) - HIDWORD(v6);
      if ( v4 > a2 )
      {
        v4 = (unsigned __int8)byte_14B4E0[(unsigned __int16)v5];
        ++v3;
        v2 += v4;
      }
      ++v5;
    }
    v5 += 253;
  }
  if ( v3 )
  {
    v7 = v2 / v3;
    v4 = (unsigned __int16)a1;
    v8 = byte_11B4E0[(unsigned __int16)a1];
    byte_14B4E0[(unsigned __int16)a1] = v7;
    if ( v7 > v8 )
    {
      byte_13B4E0[(unsigned __int16)a1] &= ~8u;
    }
    else
    {
      byte_14B4E0[(unsigned __int16)a1] = v8 - 1;
      byte_13B4E0[(unsigned __int16)a1] |= 8u;
    }
  }
  return v4;
}

//----- (00048DF0) --------------------------------------------------------
__int16 __cdecl sub_48DF0(char a1, char a2, char a3, char a4)
{
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // dx
  int v6; // eax
  unsigned __int16 v7; // bx

  LOBYTE(v4) = a1;
  HIBYTE(v4) = a2;
  HIBYTE(v5) = a2;
  LOBYTE(v5) = a4 + a1;
  v6 = (unsigned __int8)byte_11B4E0[v5] + (unsigned __int8)byte_11B4E0[v4];
  HIBYTE(v5) = a3 + a2;
  v7 = v5;
  LOBYTE(v5) = a1;
  return ((unsigned __int8)byte_11B4E0[v5] + (unsigned int)(unsigned __int8)byte_11B4E0[v7] + v6) >> 2;
}

//----- (00048E60) --------------------------------------------------------
int __cdecl sub_48E60(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4)
{
  return sub_48F20(a1, a2, a3, a4, (int)byte_11B4E0);
}

//----- (00048E90) --------------------------------------------------------
int __cdecl sub_48E90(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4)
{
  return sub_48FD0(a1, a2, a3, a4, (int)byte_11B4E0);
}

//----- (00048EC0) --------------------------------------------------------
int __cdecl sub_48EC0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4)
{
  return sub_48F20(a1, a2, a3, a4, (int)byte_14B4E0);
}

//----- (00048EF0) --------------------------------------------------------
int __cdecl sub_48EF0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4)
{
  return sub_48FD0(a1, a2, a3, a4, (int)byte_14B4E0);
}

//----- (00048F20) --------------------------------------------------------
int __cdecl sub_48F20(char a1, char a2, __int16 a3, unsigned __int16 a4, int a5)
{
  int result; // eax
  unsigned __int16 v6; // dx
  int v7; // esi
  unsigned __int16 v8; // bx
  int v9; // ebx
  unsigned __int16 v10; // bx
  int v11; // ebx

  LOBYTE(v6) = a1;
  result = 250;
  HIBYTE(v6) = a2;
  v7 = a4;
  if ( a4 )
  {
    do
    {
      LOBYTE(v8) = v6;
      if ( result > *(unsigned __int8 *)(a5 + v6) )
        result = *(unsigned __int8 *)(a5 + v6);
      HIBYTE(v8) = a3 + a2;
      v9 = *(unsigned __int8 *)(a5 + v8);
      if ( v9 < result )
        result = v9;
      LOBYTE(v6) = v6 + 1;
      --v7;
    }
    while ( v7 );
    LOWORD(v7) = a3;
    if ( a3 )
      goto LABEL_9;
  }
  else
  {
    LOWORD(v7) = a3;
    while ( v7 )
    {
LABEL_9:
      HIBYTE(v10) = HIBYTE(v6);
      if ( result > *(unsigned __int8 *)(a5 + v6) )
        result = *(unsigned __int8 *)(a5 + v6);
      LOBYTE(v10) = v6 - a4;
      v11 = *(unsigned __int8 *)(a5 + v10);
      if ( v11 < result )
        result = v11;
      ++HIBYTE(v6);
      --v7;
    }
  }
  return result;
}

//----- (00048FD0) --------------------------------------------------------
int __cdecl sub_48FD0(char a1, char a2, __int16 a3, unsigned __int16 a4, int a5)
{
  int result; // eax
  unsigned __int16 v6; // dx
  int v7; // esi
  unsigned __int16 v8; // bx
  int v9; // ebx
  unsigned __int16 v10; // bx
  int v11; // ebx

  LOBYTE(v6) = a1;
  result = 0;
  HIBYTE(v6) = a2;
  v7 = a4;
  if ( a4 )
  {
    do
    {
      LOBYTE(v8) = v6;
      if ( result < *(unsigned __int8 *)(a5 + v6) )
        result = *(unsigned __int8 *)(a5 + v6);
      HIBYTE(v8) = a3 + a2;
      v9 = *(unsigned __int8 *)(a5 + v8);
      if ( v9 > result )
        result = v9;
      LOBYTE(v6) = v6 + 1;
      --v7;
    }
    while ( v7 );
    LOWORD(v7) = a3;
    if ( a3 )
      goto LABEL_9;
  }
  else
  {
    LOWORD(v7) = a3;
    while ( v7 )
    {
LABEL_9:
      HIBYTE(v10) = HIBYTE(v6);
      if ( result < *(unsigned __int8 *)(a5 + v6) )
        result = *(unsigned __int8 *)(a5 + v6);
      LOBYTE(v10) = v6 - a4;
      v11 = *(unsigned __int8 *)(a5 + v10);
      if ( v11 > result )
        result = v11;
      ++HIBYTE(v6);
      --v7;
    }
  }
  return result;
}

//----- (00049090) --------------------------------------------------------
void __cdecl sub_49090(int a1, _WORD *a2)
{
  _WORD *v2; // ebx
  unsigned __int16 v3; // si
  __int16 v4; // di
  unsigned __int16 v5; // dx
  __int16 v6; // dx
  unsigned __int16 v7; // cx
  int v8; // eax
  int (*v9)(); // [esp+4h] [ebp-10h]
  unsigned __int16 v10; // [esp+8h] [ebp-Ch]

  v2 = a2;
  v3 = a2[1];
  v4 = *a2;
  v9 = 0;
  if ( *a2 == 10 )
  {
    if ( v3 < 0x1Fu )
    {
      if ( v3 >= 0x1Cu )
      {
        if ( v3 <= 0x1Cu )
        {
          v9 = (int (*)())sub_48400;
        }
        else if ( v3 == 29 )
        {
          v9 = (int (*)())sub_48690;
        }
      }
    }
    else if ( v3 <= 0x1Fu )
    {
      v9 = (int (*)())sub_487D0;
    }
    else if ( v3 >= 0x32u )
    {
      if ( v3 <= 0x32u )
      {
        v9 = (int (*)())sub_48880;
      }
      else if ( v3 == 80 )
      {
        v9 = sub_48930;
      }
    }
  }
  if ( v9 )
  {
    while ( 1 )
    {
      v5 = v2[7];
      if ( !v5 )
        break;
      v2 = (_WORD *)(20 * v5 + a1 + 1091);
    }
    do
    {
      if ( v4 != *v2 )
        break;
      if ( v3 != v2[1] )
        break;
      v6 = v2[8];
      v2[6] = 0;
      if ( !v6 )
        break;
      v7 = v2[3];
      v10 = v2[2];
      v8 = (unsigned __int16)v2[9];
      v2 = (_WORD *)(20 * (unsigned __int16)v2[8] + a1 + 1091);
      if ( v3 >= 0x1Fu )
      {
        if ( v3 <= 0x1Fu )
        {
          switch ( v8 )
          {
            case 0:
              v8 = 2;
              break;
            case 1:
              v8 = 6;
              break;
            case 2:
              v8 = 16;
              break;
            case 3:
              v8 = 32;
              break;
            default:
              break;
          }
        }
        else if ( v3 == 80 )
        {
          v8 = v2[9] & 0xF | (16 * (v8 & 0xF));
        }
      }
      ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, int))v9)(
        v10,
        v7,
        (unsigned __int16)v2[2],
        (unsigned __int16)v2[3],
        v8);
    }
    while ( v2 );
  }
}
// 48930: using guessed type int sub_48930();

//----- (00049270) --------------------------------------------------------
int __cdecl sub_49270(int a1)
{
  sub_49830(a1);
  return sub_49290(a1, 1);
}

//----- (00049290) --------------------------------------------------------
int __cdecl sub_49290(int a1, char a2)
{
  __int16 *i; // ebx
  __int16 v3; // ax
  __int16 *j; // ebx
  __int16 v5; // cx
  __int16 v6; // ax
  __int16 *k; // ebx
  __int16 v8; // dx
  __int16 v9; // ax
  __int16 *m; // ebx
  __int16 v11; // ax
  __int16 *n; // ebx
  __int16 v13; // ax
  __int16 v14; // ax
  __int16 *ii; // ebx
  __int16 v16; // ax
  __int16 *jj; // ebx
  __int16 v18; // ax

  for ( i = (__int16 *)(a1 + 1111); (unsigned int)i < a1 + 25091; i += 10 )
  {
    if ( i[4] == -1 && *i == 10 && i[1] == 82 )
    {
      sub_49540(a1, (int)i);
      if ( a2 )
        v3 = 0;
      else
        v3 = *i;
      *i = v3;
    }
  }
  sub_498A0();
  for ( j = (__int16 *)(a1 + 1111); (unsigned int)j < a1 + 25091; j += 10 )
  {
    if ( j[4] == -1 && *j == 10 )
    {
      v5 = j[1];
      if ( v5 == 9
        || v5 == 83
        || v5 == 84
        || v5 == 85
        || v5 == 11
        || v5 == 15
        || v5 == 30
        || v5 == 29
        || v5 == 32
        || v5 == 31
        || v5 == 51
        || v5 == 50
        || v5 == 88 )
      {
        sub_49540(a1, (int)j);
        if ( a2 )
          v6 = 0;
        else
          v6 = *j;
        *j = v6;
      }
    }
  }
  sub_498A0();
  for ( k = (__int16 *)(a1 + 1111); (unsigned int)k < a1 + 25091; k += 10 )
  {
    if ( k[4] == -1 && *k == 10 )
    {
      v8 = k[1];
      if ( v8 == 81 || v8 == 80 )
      {
        sub_49540(a1, (int)k);
        if ( a2 )
          v9 = 0;
        else
          v9 = *k;
        *k = v9;
      }
    }
  }
  sub_498A0();
  for ( m = (__int16 *)(a1 + 1111); (unsigned int)m < a1 + 25091; m += 10 )
  {
    if ( m[4] == -1 && *m == 14 && m[1] == 2 )
    {
      sub_49540(a1, (int)m);
      if ( a2 )
        v11 = 0;
      else
        v11 = *m;
      *m = v11;
    }
  }
  sub_498A0();
  for ( n = (__int16 *)(a1 + 1111); (unsigned int)n < a1 + 25091; n += 10 )
  {
    if ( n[4] == -1 && *n == 10 )
    {
      v13 = n[1];
      if ( v13 == 27 || v13 == 28 )
      {
        sub_49540(a1, (int)n);
        if ( a2 )
          v14 = 0;
        else
          v14 = *n;
        *n = v14;
      }
    }
  }
  sub_498A0();
  for ( ii = (__int16 *)(a1 + 1111); (unsigned int)ii < a1 + 25091; ii += 10 )
  {
    if ( ii[4] == -1 && *ii == 10 && ii[1] == 45 && (byte_D93C2[4 * (unsigned __int16)ii[7]] & 0x10) != 0 )
    {
      sub_49540(a1, (int)ii);
      if ( a2 )
        v16 = 0;
      else
        v16 = *ii;
      *ii = v16;
    }
  }
  sub_498A0();
  for ( jj = (__int16 *)(a1 + 1111); (unsigned int)jj < a1 + 25091; jj += 10 )
  {
    if ( jj[4] == -1 && *jj == 10 && jj[1] == 45 && (byte_D93C2[4 * (unsigned __int16)jj[7]] & 0x10) == 0 )
    {
      sub_49540(a1, (int)jj);
      if ( a2 )
        v18 = 0;
      else
        v18 = *jj;
      *jj = v18;
    }
  }
  return sub_498A0();
}

//----- (00049540) --------------------------------------------------------
void __cdecl sub_49540(int a1, int a2)
{
  unsigned __int16 v2; // ax
  __int16 v3; // ax
  unsigned __int16 v4; // dx
  int v5; // eax
  __int16 v6; // ax
  unsigned __int16 v7; // dx
  int v8; // eax
  int v9; // esi
  unsigned __int16 v10; // dx
  char *v11; // eax
  __int16 v12; // ax
  unsigned __int16 v13; // dx
  int v14; // eax

  if ( *(_WORD *)a2 < 0xAu )
    return;
  if ( *(_WORD *)a2 > 0xAu )
  {
    if ( *(_WORD *)a2 == 14 && *(_WORD *)(a2 + 2) == 2 )
    {
      word_EB398 = *(_WORD *)(a2 + 4) << 8;
      word_EB39A = *(_WORD *)(a2 + 6) << 8;
      v12 = sub_10C40(&word_EB398);
      v13 = *(_WORD *)(a2 + 2);
      word_EB39C = v12;
      if ( *(int (__cdecl **)(int))((char *)&off_D7B7A + 14 * v13) )
      {
        v14 = (*(int (__cdecl **)(int))((char *)&off_D7B7A + 14 * v13))((int)&word_EB398);
        if ( v14 )
        {
          *(_WORD *)(v14 + 44) = *(_WORD *)(a2 + 14);
          *(_WORD *)(v14 + 150) = *(_WORD *)(a2 + 18);
        }
      }
    }
    return;
  }
  v2 = *(_WORD *)(a2 + 2);
  if ( v2 < 0x2Du )
  {
    if ( v2 < 0x1Cu || v2 > 0x1Du && v2 != 31 )
      goto LABEL_20;
LABEL_18:
    if ( *(_WORD *)(a2 + 12) )
      sub_49090(a1, (_WORD *)a2);
    return;
  }
  if ( v2 <= 0x2Du )
  {
    word_EB398 = *(_WORD *)(a2 + 4) << 8;
    word_EB39A = *(_WORD *)(a2 + 6) << 8;
    v3 = sub_10C40(&word_EB398);
    v4 = *(_WORD *)(a2 + 2);
    word_EB39C = v3;
    if ( *(int (__cdecl **)(int))((char *)&off_D697E + 14 * v4) )
    {
      v5 = (*(int (__cdecl **)(int))((char *)&off_D697E + 14 * v4))((int)&word_EB398);
      if ( v5 )
        sub_49A30(v5, *(_WORD *)(a2 + 14));
    }
    return;
  }
  if ( v2 >= 0x32u && (v2 <= 0x32u || v2 == 80) )
    goto LABEL_18;
LABEL_20:
  word_EB398 = *(_WORD *)(a2 + 4) << 8;
  word_EB39A = *(_WORD *)(a2 + 6) << 8;
  v6 = sub_10C40(&word_EB398);
  v7 = *(_WORD *)(a2 + 2);
  word_EB39C = v6;
  if ( *(int (__cdecl **)(int))((char *)&off_D697E + 14 * v7) )
  {
    v8 = (*(int (__cdecl **)(int))((char *)&off_D697E + 14 * v7))((int)&word_EB398);
    v9 = v8;
    if ( v8 )
    {
      v10 = *(_WORD *)(a2 + 2);
      if ( v10 < 0x52u )
      {
        if ( v10 < 0xBu )
        {
          if ( v10 != 9 )
            return;
        }
        else if ( v10 > 0xBu && v10 != 15 )
        {
          return;
        }
        v11 = &byte_DA818[80 * (unsigned __int8)sub_6E020(*(_WORD *)(a2 + 2)) + 2 + 26 * *(unsigned __int16 *)(a2 + 14)];
        *(_WORD *)(v9 + 42) = *(_WORD *)v11;
        if ( *(_WORD *)(a2 + 2) == 9 )
          *(_DWORD *)(v9 + 4) = (unsigned __int8)v11[24];
        else
          *(_DWORD *)(v9 + 8) = (unsigned __int8)v11[24];
        return;
      }
      if ( v10 <= 0x52u )
      {
        *(_BYTE *)(v8 + 70) = *(_BYTE *)(a2 + 18);
        *(_BYTE *)(v8 + 67) = *(_BYTE *)(a2 + 14);
        *(_BYTE *)(v8 + 68) = *(_BYTE *)(a2 + 16);
      }
      else if ( v10 < 0x54u )
      {
        *(_WORD *)(v8 + 154) = *(_WORD *)(a2 + 10);
      }
      else if ( v10 <= 0x55u )
      {
        *(_WORD *)(v8 + 154) = *(_WORD *)(a2 + 10);
        *(_WORD *)(v8 + 80) = *(_WORD *)(a2 + 18);
      }
      else if ( v10 == 88 )
      {
        *(_WORD *)(v8 + 84) = *(_WORD *)(a2 + 14);
        *(_WORD *)(v8 + 86) = *(_WORD *)(a2 + 16);
      }
    }
  }
}
// D697E: using guessed type int (__cdecl *off_D697E)(int);
// D7B7A: using guessed type int (__cdecl *off_D7B7A)(int);
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00049830) --------------------------------------------------------
int __cdecl sub_49830(int a1)
{
  _WORD *v1; // edx
  int result; // eax
  unsigned __int16 v3; // ax

  v1 = (_WORD *)(a1 + 1111);
  result = a1 + 25091;
  if ( a1 + 1111 < (unsigned int)(a1 + 25091) )
  {
    do
    {
      if ( v1[4] != 0xFFFF || *v1 != 10 )
        goto LABEL_13;
      v3 = v1[1];
      if ( v3 < 0x1Fu )
      {
        if ( v3 < 0x1Cu || v3 > 0x1Du )
          goto LABEL_13;
      }
      else if ( v3 > 0x1Fu && (v3 < 0x32u || v3 > 0x32u && v3 != 80) )
      {
        goto LABEL_13;
      }
      v1[6] = 1;
LABEL_13:
      v1 += 10;
      result = a1 + 25091;
    }
    while ( (unsigned int)v1 < a1 + 25091 );
  }
  return result;
}

//----- (000498A0) --------------------------------------------------------
int sub_498A0()
{
  int result; // eax
  int v1; // esi
  unsigned int i; // ebx
  int v3; // eax
  int (__cdecl *v4)(unsigned int, _DWORD); // [esp+0h] [ebp-8h]
  int (__cdecl *v5)(unsigned int); // [esp+4h] [ebp-4h]

  result = dword_D41A0;
  v1 = 1;
  *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
LABEL_2:
  if ( v1 )
  {
    v1 = 0;
    for ( i = dword_D41A0 + 28470; ; i += 168 )
    {
      result = dword_D41A0 + 196302;
      if ( i >= dword_D41A0 + 196302 )
        goto LABEL_2;
      BYTE1(v3) = *(_BYTE *)(i + 63);
      if ( BYTE1(v3) )
        break;
LABEL_37:
      ;
    }
    if ( BYTE1(v3) != 10 )
    {
      if ( BYTE1(v3) == 14 )
      {
        LOBYTE(v3) = *(_BYTE *)(i + 64);
        if ( (_BYTE)v3 == 2 && !*(_DWORD *)(i + 8) )
        {
          v3 = *(int *)((char *)&dword_D4C52 + 18 * *(char *)(i + 63)) + 14 * *(unsigned __int8 *)(i + 69);
          v1 = 1;
          v4 = *(int (__cdecl **)(unsigned int, _DWORD))(v3 + 6);
          if ( v4 )
          {
            if ( *(_DWORD *)(v3 + 10) )
              LOWORD(v3) = v4(i, v4);
          }
        }
      }
      else
      {
        LOWORD(v3) = sub_57F10(i);
      }
      goto LABEL_35;
    }
    LOBYTE(v3) = *(_BYTE *)(i + 64);
    if ( (unsigned __int8)v3 < 0x1Bu )
    {
      if ( (unsigned __int8)v3 >= 0xBu )
      {
        if ( (unsigned __int8)v3 > 0xBu && (_BYTE)v3 != 15 )
          goto LABEL_26;
        goto LABEL_23;
      }
      if ( (_BYTE)v3 == 9 )
        goto LABEL_23;
    }
    else
    {
      if ( (unsigned __int8)v3 <= 0x20u )
        goto LABEL_23;
      if ( (unsigned __int8)v3 >= 0x32u )
      {
        if ( (unsigned __int8)v3 > 0x33u
          && ((unsigned __int8)v3 < 0x50u || (unsigned __int8)v3 > 0x55u && (_BYTE)v3 != 88) )
        {
          goto LABEL_26;
        }
LABEL_23:
        v3 = *(int *)((char *)&dword_D4C52 + 18 * *(char *)(i + 63)) + 14 * *(unsigned __int8 *)(i + 69);
        v1 = 1;
        v5 = *(int (__cdecl **)(unsigned int))(v3 + 6);
        if ( v5 && *(_DWORD *)(v3 + 10) )
          LOWORD(v3) = v5(i);
        goto LABEL_27;
      }
      if ( (_BYTE)v3 == 45 )
      {
        if ( *(_BYTE *)(i + 69) != 51 )
        {
LABEL_27:
          ++*(_BYTE *)(i + 62);
LABEL_35:
          if ( (*(_BYTE *)(i + 13) & 4) != 0 )
            sub_57F20(v3, i);
          goto LABEL_37;
        }
        goto LABEL_23;
      }
    }
LABEL_26:
    LOWORD(v3) = sub_57F10(i);
    goto LABEL_27;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D4C52: using guessed type int dword_D4C52;

//----- (00049A20) --------------------------------------------------------
int __cdecl sub_49A20(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

//----- (00049A30) --------------------------------------------------------
__int16 __cdecl sub_49A30(int a1, unsigned __int16 a2)
{
  int v2; // eax
  __int16 v3; // dx
  int v4; // eax
  int v5; // eax
  char v6; // dl
  int v7; // edx
  unsigned __int16 v9; // [esp+0h] [ebp-10h]
  unsigned __int16 v10; // [esp+4h] [ebp-Ch]
  unsigned __int8 v11; // [esp+8h] [ebp-8h]
  unsigned __int8 v12; // [esp+Ch] [ebp-4h]

  v2 = dword_EA3BC + 6 * a2;
  v9 = *(unsigned __int8 *)(v2 + 5);
  v10 = *(unsigned __int8 *)(v2 + 4);
  *(_DWORD *)(a1 + 16) = 2;
  v3 = word_180660;
  *(_WORD *)(a1 + 132) = ((unsigned __int8)v10 * (unsigned __int8)v9) >> 4;
  if ( v3 == 1 )
  {
    v9 >>= 1;
    v10 >>= 1;
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  word_EB398 = *(__int16 *)(a1 + 76) >> 8 << 8;
  word_EB39A = *(__int16 *)(a1 + 78) >> 8 << 8;
  sub_57CF0(word_EB39A, a1, (int)&word_EB398);
  v11 = HIBYTE(*(_WORD *)(a1 + 76)) - ((int)v10 >> 1);
  v12 = HIBYTE(*(_WORD *)(a1 + 78)) - ((int)v9 >> 1);
  v4 = (v11 + v12) / 2;
  if ( (v11 + v12) % 2 )
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    BYTE1(v4) = ++HIBYTE(word_EB398);
    sub_57CF0(v4, a1, (int)&word_EB398);
    ++v11;
  }
  sub_49EC0((_WORD *)a1, a2);
  *(_WORD *)(a1 + 80) = 32 * sub_48DF0(v11, v12, v9, v10);
  *(_BYTE *)(a1 + 70) = a2;
  LOWORD(v5) = a2;
  *(_DWORD *)(a1 + 8) = 30;
  *(_WORD *)(a1 + 42) = word_D93C0[2 * a2];
  v6 = byte_D93C3[4 * a2];
  *(_BYTE *)(a1 + 65) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  *(_BYTE *)(a1 + 61) = v6;
  if ( (byte_D93C2[4 * a2] & 8) == 0 )
  {
    v7 = *(_DWORD *)(a1 + 144);
    *(_BYTE *)(a1 + 56) |= 2u;
    if ( v7 < 0 )
      *(_DWORD *)(a1 + 144) = 0;
    if ( *(int *)(a1 + 144) > 1000 )
      *(_DWORD *)(a1 + 144) = 1000;
    v5 = (1000 * *(unsigned __int16 *)(a1 + 42)) >> 7;
    *(_DWORD *)(a1 + 144) = v5;
  }
  if ( a2 == 68 )
  {
    v5 = (a1 - (dword_D41A0 + 28302)) / 168;
    *(_WORD *)(dword_D41A0 + 222538) = v5;
  }
  return v5;
}
// D41A0: using guessed type int dword_D41A0;
// D93C0: using guessed type __int16 word_D93C0[];
// EA3BC: using guessed type int dword_EA3BC;
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// 180660: using guessed type __int16 word_180660;

//----- (00049C70) --------------------------------------------------------
int __cdecl sub_49C70(int a1)
{
  int result; // eax

  result = *(int *)(a1 + 4) >> 1;
  *(_DWORD *)(a1 + 144) = result;
  return result;
}

//----- (00049C90) --------------------------------------------------------
char __cdecl sub_49C90(int a1, __int16 a2)
{
  char result; // al

  *(_WORD *)(a1 + 90) = a2;
  *(_BYTE *)(a1 + 92) = 0;
  result = byte_D8A2E[(unsigned __int8)byte_D9528[14 * a2]];
  *(_BYTE *)(a1 + 93) = result;
  return result;
}

//----- (00049CD0) --------------------------------------------------------
int __cdecl sub_49CD0(_WORD *a1, __int16 a2)
{
  int v2; // ebx
  int result; // eax

  sub_49C90((int)a1, a2);
  v2 = 7 * a2;
  a1[41] = (unsigned __int16)word_D9524[v2] / 2;
  a1[42] = (unsigned __int16)word_D9522[v2] / 2;
  a1[43] = (unsigned __int16)word_D9522[v2] / 2;
  result = (unsigned __int16)word_D9524[v2] / 2;
  a1[44] = result;
  return result;
}
// D9522: using guessed type __int16 word_D9522[];
// D9524: using guessed type __int16 word_D9524[];

//----- (00049D50) --------------------------------------------------------
int __cdecl sub_49D50(int a1, __int16 a2)
{
  int result; // eax

  *(_WORD *)(a1 + 90) = a2;
  *(_BYTE *)(a1 + 93) = byte_D8A2E[(unsigned __int8)byte_D9528[14 * a2]];
  result = (unsigned __int16)word_D9524[7 * a2] / 2;
  *(_WORD *)(a1 + 82) = result;
  return result;
}
// D9524: using guessed type __int16 word_D9524[];

//----- (00049DA0) --------------------------------------------------------
int __cdecl sub_49DA0(_WORD *a1, __int16 a2)
{
  int v2; // ebx
  int result; // eax

  sub_49CD0(a1, a2);
  v2 = 7 * a2;
  a1[42] = (unsigned __int16)word_D9522[v2] / 2;
  a1[43] = (unsigned __int16)word_D9522[v2] / 2;
  result = (unsigned __int16)word_D9524[v2] / 2;
  a1[44] = result;
  return result;
}
// D9522: using guessed type __int16 word_D9522[];
// D9524: using guessed type __int16 word_D9524[];

//----- (00049E10) --------------------------------------------------------
int __cdecl sub_49E10(_WORD *a1, __int16 a2)
{
  int result; // eax
  __int16 v3; // cx
  __int16 v4; // si

  result = sub_49CD0(a1, a2);
  v3 = a1[43];
  v4 = a1[44];
  a1[42] *= 2;
  a1[43] = 2 * v3;
  a1[44] = 2 * v4;
  return result;
}

//----- (00049EA0) --------------------------------------------------------
_WORD *__cdecl sub_49EA0(_WORD *a1, __int16 a2, __int16 a3)
{
  _WORD *result; // eax

  result = a1;
  a1[42] = a2;
  a1[43] = a2;
  a1[44] = a3;
  return result;
}

//----- (00049EC0) --------------------------------------------------------
unsigned int __cdecl sub_49EC0(_WORD *a1, __int16 a2)
{
  int v2; // eax
  unsigned int v3; // edx
  unsigned int v4; // eax
  unsigned int result; // eax

  v2 = dword_EA3BC + 6 * a2;
  v3 = *(unsigned __int8 *)(v2 + 5);
  v4 = *(unsigned __int8 *)(v2 + 4);
  if ( word_180660 == 1 )
  {
    v3 >>= 1;
    v4 >>= 1;
  }
  a1[42] = ((v4 << 8) + 1280) >> 1;
  a1[41] = 0;
  a1[44] = 256;
  result = ((v3 << 8) + 1280) >> 1;
  a1[43] = result;
  return result;
}
// EA3BC: using guessed type int dword_EA3BC;
// 180660: using guessed type __int16 word_180660;

//----- (00049F30) --------------------------------------------------------
int sub_49F30()
{
  int v0; // eax
  int result; // eax
  int v2; // edx
  int v3; // ebx
  int v4; // ebx
  int v5; // edx

  v0 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 28466) = &unk_F42B0;
  *(_DWORD *)(v0 + 53) = -1;
  *(_DWORD *)(v0 + 4582) = -1;
  for ( result = 999; result > 0; --result )
  {
    v2 = dword_D41A0;
    v3 = *(_DWORD *)(dword_D41A0 + 53) + 1;
    *(_DWORD *)(dword_D41A0 + 53) = v3;
    v4 = v2 + 4 * v3;
    v5 = dword_EA3E4[result];
    *(_DWORD *)(v4 + 582) = v5;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00049F90) --------------------------------------------------------
int __fastcall sub_49F90(__int16 a1)
{
  unsigned int i; // ebx
  int v2; // eax
  int v3; // ebx
  int result; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // ecx
  int v8; // eax
  int v9; // esi
  int v10; // ecx

  for ( i = dword_EA3E8; i < dword_EB384; i += 168 )
  {
    if ( *(_BYTE *)(i + 63) && (*(_BYTE *)(i + 13) & 4) != 0 )
      a1 = sub_57F20(a1, i);
  }
  v2 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 53) = -1;
  v3 = 999;
  *(_DWORD *)(v2 + 4582) = -1;
  do
  {
    result = dword_EA3E4[v3];
    if ( *(_BYTE *)(result + 63) )
    {
      if ( (*(_BYTE *)(result + 14) & 2) != 0 )
      {
        v8 = dword_D41A0;
        v9 = *(_DWORD *)(dword_D41A0 + 4582) + 1;
        *(_DWORD *)(dword_D41A0 + 4582) = v9;
        v10 = v8 + 4 * v9;
        result = dword_EA3E4[v3];
        *(_DWORD *)(v10 + 4586) = result;
      }
    }
    else
    {
      v5 = dword_D41A0;
      v6 = *(_DWORD *)(dword_D41A0 + 53) + 1;
      *(_DWORD *)(dword_D41A0 + 53) = v6;
      v7 = v5 + 4 * v6;
      result = dword_EA3E4[v3];
      *(_DWORD *)(v7 + 582) = result;
    }
    --v3;
  }
  while ( v3 > 0 );
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EA3E8: using guessed type int dword_EA3E8;
// EB384: using guessed type int dword_EB384;

//----- (0004A050) --------------------------------------------------------
int sub_4A050()
{
  int v0; // edx
  int v1; // ebx
  int v2; // eax
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // edx
  int result; // eax

  v0 = *(_DWORD *)(dword_D41A0 + 53);
  if ( v0 >= 0 )
  {
    v1 = *(_DWORD *)(dword_D41A0 + 4 * v0 + 582);
    *(_DWORD *)(dword_D41A0 + 53) = v0 - 1;
LABEL_5:
    memset(v1, 0, 168);
    v4 = dword_D41A0;
    v5 = (v1 - (dword_D41A0 + 28302)) / 168;
    *(_DWORD *)(v1 + 4) = 300;
    *(_DWORD *)(v1 + 12) = 8;
    *(_WORD *)(v1 + 130) = 16;
    *(_WORD *)(v1 + 42) = 100;
    *(_WORD *)(v1 + 26) = v5;
    v6 = *(_DWORD *)(v4 + 8);
    *(_BYTE *)(v1 + 65) = -1;
    *(_BYTE *)(v1 + 66) = -1;
    *(_DWORD *)(v1 + 160) = &unk_D83AC;
    *(_DWORD *)(v1 + 164) = &unk_F42B0;
    *(_BYTE *)(v1 + 67) = 10;
    *(_BYTE *)(v1 + 57) = -6;
    LOWORD(v6) = v5 + v6;
    *(_BYTE *)(v1 + 62) = v5;
    result = v1;
    *(_WORD *)(v1 + 20) = v6;
    return result;
  }
  if ( *(int *)(dword_D41A0 + 4582) >= 0 )
  {
    memset(dword_D41A4 + 38403, 0, 116);
    v2 = dword_D41A4;
    *(_DWORD *)(dword_D41A4 + 38523) = 0;
    *(_DWORD *)(v2 + 38527) = 0;
    *(_DWORD *)(v2 + 38519) = 0;
    *(_DWORD *)(v2 + 38531) = 0;
    *(_DWORD *)(v2 + 38535) = 0;
    v1 = *(_DWORD *)(dword_D41A0 + 4 * *(_DWORD *)(dword_D41A0 + 4582) + 4586);
    sub_57E50(dword_D41A0, v1);
    v3 = dword_D41A0;
    *(_BYTE *)(v1 + 63) = 0;
    --*(_DWORD *)(v3 + 4582);
    goto LABEL_5;
  }
  return 0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (0004A190) --------------------------------------------------------
int __cdecl sub_4A190(int a1, int a2, int a3)
{
  int v3; // eax

  v3 = *(int *)((char *)&dword_D4C56 + 18 * a2) + 14 * a3;
  if ( *(_DWORD *)(v3 + 10) && *(__int16 *)(v3 + 4) == a3 )
    return (*(int (__cdecl **)(int))(v3 + 6))(a1);
  else
    return 0;
}
// D4C56: using guessed type int dword_D4C56;

//----- (0004A1E0) --------------------------------------------------------
int __usercall sub_4A1E0@<eax>(__int16 a1@<ax>, int a2, char a3)
{
  unsigned __int16 *i; // ebx
  unsigned __int16 *j; // ebx
  unsigned __int16 v5; // ax
  int result; // eax
  int v7; // [esp-Ch] [ebp-Ch]
  unsigned __int16 v8; // [esp-Ch] [ebp-Ch]
  unsigned __int16 v9; // [esp-8h] [ebp-8h]

  if ( !a2 )
  {
    v7 = dword_D41A0 + 222422;
    *(_DWORD *)(dword_D41A0 + 222418) = 0;
    memset(v7, 0, 104);
    sub_716A0();
    for ( i = (unsigned __int16 *)((char *)&loc_30325 + dword_D41A0); (unsigned int)i < dword_D41A0 + 221393; i += 10 )
    {
      v9 = i[1];
      v8 = *i;
      sub_716C0(v8, v9, -1);
    }
    LOBYTE(a1) = sub_71780();
  }
  sub_49F90(a1);
  sub_122C0(a2);
  for ( j = (unsigned __int16 *)((char *)&loc_30325 + dword_D41A0); (unsigned int)j < dword_D41A0 + 221393; j += 10 )
  {
    if ( *j && j[4] == a2 )
    {
      sub_4A310(j);
      if ( *j == 5 )
      {
        v5 = j[1];
        if ( v5 < 0xCu || v5 > 0xFu && v5 != 22 )
          ++*(_DWORD *)(dword_D41A0 + 222418);
      }
      if ( a3 )
        *j = 0;
    }
  }
  sub_12870();
  result = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 4582) = -1;
  return result;
}
// 4A247: variable 'a1' is possibly undefined
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;

//----- (0004A310) --------------------------------------------------------
int __cdecl sub_4A310(unsigned __int16 *a1)
{
  int result; // eax
  int v2; // edx
  int v3; // ebx
  unsigned __int8 v4; // al
  int v5; // eax
  __int16 v6; // di
  char *v7; // edx
  unsigned __int8 v8; // al
  int v9; // eax
  unsigned __int8 v10; // al
  __int16 v11[4]; // [esp+0h] [ebp-8h] BYREF

  result = *(int *)((char *)&dword_D4C56 + 18 * *a1);
  if ( !*(_DWORD *)(result + 14 * a1[1] + 10) )
    return result;
  v11[0] = (a1[2] << 8) + 128;
  v11[1] = (a1[3] << 8) + 128;
  v11[2] = sub_10C40(v11);
  result = sub_4A190((int)v11, *a1, a1[1]);
  v2 = result;
  v3 = result;
  if ( !result )
    return result;
  switch ( *(_BYTE *)(result + 63) )
  {
    case 5:
      if ( *(_BYTE *)(result + 64) == 22 )
      {
        *(_BYTE *)(result + 70) = *((_BYTE *)a1 + 14);
        sub_4CB60(result);
      }
      sub_12100((int)a1, v3, *(_BYTE *)(v3 + 64) == 9);
      return sub_58DA0((int)a1, v3);
    case 0xA:
      v4 = *(_BYTE *)(result + 64);
      if ( v4 < 0x22u )
      {
        if ( v4 < 0xBu )
        {
          if ( v4 < 4u )
            return sub_58DA0((int)a1, v3);
          if ( v4 <= 4u )
          {
            *(_WORD *)(v2 + 26) = a1[6];
            sub_49EA0((_WORD *)v2, a1[5] << 8, a1[5] << 8);
            sub_49A20(v3);
            return sub_58DA0((int)a1, v3);
          }
          if ( v4 != 9 )
            return sub_58DA0((int)a1, v3);
        }
        else if ( v4 > 0xBu )
        {
          if ( v4 < 0x11u )
          {
            if ( v4 != 15 )
              return sub_58DA0((int)a1, v3);
          }
          else if ( v4 > 0x11u && v4 != 22 )
          {
            return sub_58DA0((int)a1, v3);
          }
        }
        goto LABEL_51;
      }
      if ( v4 <= 0x22u )
      {
        *(_WORD *)(v2 + 154) = (a1[8] << 8) + 128;
        *(_WORD *)(v2 + 156) = (a1[7] << 8) + 128;
        return sub_58DA0((int)a1, v3);
      }
      if ( v4 >= 0x43u )
      {
        if ( v4 > 0x43u )
        {
          if ( v4 >= 0x53u )
          {
            if ( v4 > 0x53u )
            {
              if ( v4 <= 0x55u )
              {
                v6 = *(_WORD *)(v2 + 78);
                *(_WORD *)(v2 + 76) -= 128;
                *(_WORD *)(v2 + 78) = v6 - 128;
                *(_WORD *)(v2 + 154) = a1[5];
                *(_WORD *)(v2 + 80) = a1[9];
              }
              return sub_58DA0((int)a1, v3);
            }
            *(_WORD *)(v2 + 154) = a1[5];
            return sub_58DA0((int)a1, v3);
          }
          if ( v4 != 71 )
            return sub_58DA0((int)a1, v3);
        }
LABEL_51:
        v7 = &byte_DA818[80 * (unsigned __int16)sub_6E020(*(char *)(v3 + 64)) + 2 + 26 * a1[7]];
        *(_WORD *)(v3 + 42) = *(_WORD *)v7;
        v8 = *(_BYTE *)(v3 + 64);
        if ( v8 >= 0x11u )
        {
          if ( v8 <= 0x11u )
          {
            v9 = (unsigned __int8)v7[24];
          }
          else
          {
            if ( v8 >= 0x43u )
            {
              if ( v8 > 0x43u && v8 != 71 )
                return sub_58DA0((int)a1, v3);
LABEL_65:
              v9 = (unsigned __int8)v7[24];
LABEL_69:
              *(_DWORD *)(v3 + 8) = v9;
              return sub_58DA0((int)a1, v3);
            }
            if ( v8 != 22 )
              return sub_58DA0((int)a1, v3);
            v9 = 8 * (unsigned __int8)v7[24];
          }
          *(_DWORD *)(v3 + 4) = v9;
          goto LABEL_69;
        }
        if ( v8 < 0xBu )
        {
          if ( v8 != 9 )
            return sub_58DA0((int)a1, v3);
          *(_DWORD *)(v3 + 4) = (unsigned __int8)v7[24];
          return sub_58DA0((int)a1, v3);
        }
        if ( v8 > 0xBu && v8 != 15 )
          return sub_58DA0((int)a1, v3);
        goto LABEL_65;
      }
      if ( v4 < 0x36u )
      {
        if ( v4 == 45 )
        {
          sub_49A30(v2, a1[7]);
          *(_BYTE *)(v3 + 65) = *((_BYTE *)a1 + 16);
        }
        return sub_58DA0((int)a1, v3);
      }
      if ( v4 > 0x36u )
      {
        if ( v4 >= 0x3Du && v4 <= 0x3Eu )
          goto LABEL_49;
        return sub_58DA0((int)a1, v3);
      }
      *(_DWORD *)(v3 + 16) = (a1[6] << 8) * (a1[6] << 8);
      v5 = 8 * a1[6] + 16;
      *(_DWORD *)(v3 + 4) = v5;
      if ( v5 < 128 )
        *(_DWORD *)(v3 + 4) = 128;
      sub_49A20(v3);
      return sub_58DA0((int)a1, v3);
    case 0xB:
      *(_WORD *)(result + 26) = a1[6];
      if ( *(_BYTE *)(result + 64) == 32 )
        *(_BYTE *)(result + 70) = *((_BYTE *)a1 + 14);
      else
        sub_49EA0((_WORD *)result, a1[5] << 8, 4096);
      sub_49A20(v3);
      *(_BYTE *)(v3 + 12) |= 1u;
      return sub_58DA0((int)a1, v3);
    case 0xC:
    case 0xF:
      *(_BYTE *)(result + 69) += *((_BYTE *)a1 + 12);
      if ( a1[6] < 3u )
        return sub_58DA0((int)a1, v3);
      *(_BYTE *)(result + 69) -= 3;
      return sub_58DA0((int)a1, result);
    case 0xE:
      v10 = *(_BYTE *)(result + 64);
      if ( !v10 )
        return sub_58DA0((int)a1, v3);
      if ( v10 > 1u )
      {
        if ( v10 == 2 )
        {
          *(_WORD *)(v2 + 44) = a1[7];
          *(_WORD *)(v2 + 150) = a1[9];
        }
        return sub_58DA0((int)a1, v3);
      }
LABEL_49:
      *(_BYTE *)(v2 + 70) = *((_BYTE *)a1 + 14);
      *(_DWORD *)(v2 + 16) = a1[8];
      return sub_58DA0((int)a1, v3);
    default:
      return sub_58DA0((int)a1, v3);
  }
}
// D4C56: using guessed type int dword_D4C56;

//----- (0004A810) --------------------------------------------------------
int sub_4A810()
{
  return *(_DWORD *)(dword_D41A0 + 53) + 1;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A820) --------------------------------------------------------
int __cdecl sub_4A820(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9058;
  result = 0;
  *(_DWORD *)(dword_D41A0 + 9058) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A840) --------------------------------------------------------
int __cdecl sub_4A840(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9064;
  result = 0;
  *(_DWORD *)(dword_D41A0 + 9064) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A860) --------------------------------------------------------
int __cdecl sub_4A860(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9070;
  result = 0;
  *(_DWORD *)(dword_D41A0 + 9070) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A880) --------------------------------------------------------
int __cdecl sub_4A880(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9076;
  result = 0;
  *(_DWORD *)(dword_D41A0 + 9076) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A8A0) --------------------------------------------------------
int __cdecl sub_4A8A0(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9082;
  result = 0;
  *(_DWORD *)(dword_D41A0 + 9082) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A8C0) --------------------------------------------------------
int __cdecl sub_4A8C0(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9088;
  result = 0;
  *(_DWORD *)(dword_D41A0 + 9088) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A8E0) --------------------------------------------------------
int __cdecl sub_4A8E0(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9094;
  result = 0;
  *(_DWORD *)(dword_D41A0 + 9094) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A900) --------------------------------------------------------
int __cdecl sub_4A900(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = dword_D41A0 + 9100;
  result = 0;
  *(_DWORD *)(dword_D41A0 + 9100) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 4) = *(_WORD *)(a1 + 4);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A920) --------------------------------------------------------
_WORD *__cdecl sub_4A920(int a1)
{
  int v1; // eax
  _WORD *v2; // esi
  int v3; // ecx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 0;
    *(_BYTE *)(v1 + 63) = 3;
    v3 = dword_D41A0;
    *(_BYTE *)(v1 + 64) = 0;
    *(_DWORD *)(v1 + 4) = 10000;
    *(_WORD *)(v1 + 132) = 80;
    *(_BYTE *)(v1 + 56) = 29;
    *(_WORD *)(v1 + 26) = (v1 - (v3 + 28302)) / 168;
    if ( *(_BYTE *)(v3 + 196308) == 2 )
      *(_DWORD *)(v1 + 160) = &unk_D89A6;
    else
      *(_DWORD *)(v1 + 160) = &unk_D849A;
    sub_57D70(v1, a1);
    sub_49CD0(v2, 44);
    sub_49A20((int)v2);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004A9C0) --------------------------------------------------------
_WORD *__cdecl sub_4A9C0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 1;
    *(_BYTE *)(v1 + 63) = 3;
    v3 = dword_D41A0;
    *(_BYTE *)(v1 + 64) = 1;
    *(_DWORD *)(v1 + 4) = 10000;
    *(_WORD *)(v1 + 132) = 80;
    *(_DWORD *)(v1 + 160) = &unk_D84BC;
    *(_BYTE *)(v1 + 56) = 29;
    *(_WORD *)(v1 + 26) = (v1 - (v3 + 28302)) / 168;
    sub_57D70(v1, a1);
    sub_49CD0(v2, 44);
    sub_49A20((int)v2);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004AA40) --------------------------------------------------------
int __cdecl sub_4AA40(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // edx
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // cx
  int v6; // [esp+0h] [ebp-Ch] BYREF
  __int16 v7; // [esp+4h] [ebp-8h]
  int v8; // [esp+8h] [ebp-4h]

  *(_DWORD *)&word_EB398 = *(_DWORD *)a1;
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 4);
  result = sub_4A050();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 69) = 5;
    *(_BYTE *)(result + 63) = 3;
    *(_BYTE *)(result + 64) = 2;
    *(_DWORD *)(result + 4) = 40000;
    *(_DWORD *)(result + 16) = 0;
    *(_BYTE *)(result + 56) = 33;
    LOWORD(v6) = HIBYTE(word_EB398);
    HIWORD(v6) = HIBYTE(word_EB39A);
    v7 = sub_10C40(&word_EB398);
    if ( ((__int16)v6 + SHIWORD(v6)) % 2 )
      LOWORD(v6) = v6 + 1;
    LOWORD(v6) = (_WORD)v6 << 8;
    HIWORD(v6) <<= 8;
    v3 = dword_EA3BC;
    HIBYTE(v4) = 0;
    *(_DWORD *)(v2 + 154) = v6;
    *(_WORD *)(v2 + 158) = v7;
    LOBYTE(v4) = *(_BYTE *)(v3 + 10);
    v5 = *(unsigned __int8 *)(v3 + 11);
    if ( word_180660 == 1 )
    {
      v5 >>= 1;
      v4 >>= 1;
    }
    v8 = ((__int16)v6 >> 8) - v4 / 2;
    *(_WORD *)(v2 + 158) = 32 * sub_48E60(((__int16)v6 >> 8) - v4 / 2, (SHIWORD(v6) >> 8) - ((int)v5 >> 1), v4, v5);
    sub_57D70(v2, (int)&v6);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 177);
    return v2;
  }
  return result;
}
// EA3BC: using guessed type int dword_EA3BC;
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// 180660: using guessed type __int16 word_180660;

//----- (0004ABA0) --------------------------------------------------------
int __cdecl sub_4ABA0(int a1)
{
  int result; // eax
  _WORD *v2; // ebx
  int v3; // esi

  result = sub_4A050();
  v2 = (_WORD *)result;
  v3 = result;
  if ( result )
  {
    *(_BYTE *)(result + 69) = 7;
    *(_BYTE *)(result + 63) = 3;
    *(_BYTE *)(result + 64) = 3;
    *(_DWORD *)(result + 4) = 10000;
    *(_WORD *)(result + 130) = 48;
    *(_DWORD *)(result + 140) = 10000;
    *(_DWORD *)(result + 144) = 0;
    *(_BYTE *)(result + 56) = 1;
    *(_DWORD *)(result + 160) = &unk_D84DE;
    sub_57D70(result, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 169);
    if ( byte_D41B6 )
      sub_49EA0(v2, 256, 768);
    return v3;
  }
  return result;
}
// D41B6: using guessed type char byte_D41B6;

//----- (0004AC40) --------------------------------------------------------
int __cdecl sub_4AC40(int *a1)
{
  int result; // eax
  int v2; // ebx
  unsigned __int16 v3; // ax
  int v4; // [esp+0h] [ebp-Ch] BYREF
  __int16 v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]

  result = sub_4A050();
  v2 = result;
  v6 = result;
  if ( result )
  {
    *(_BYTE *)(result + 69) = 0;
    *(_BYTE *)(result + 63) = 2;
    *(_BYTE *)(result + 64) = 0;
    *(_DWORD *)(result + 16) = (result - (dword_D41A0 + 28302)) / 168 % 11;
    *(_WORD *)(result + 20) = 9377 * *(_WORD *)(result + 20) + 9439;
    v3 = *(_WORD *)(result + 20);
    *(_BYTE *)(v2 + 56) = 1;
    *(_DWORD *)(v2 + 8) = v3 % 0x1388u + 2500;
    v4 = *a1;
    v5 = *((_WORD *)a1 + 2);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    LOWORD(v4) = (*(_WORD *)(v2 + 20) & 0x3F) - 32 + v4;
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    HIWORD(v4) += (*(_WORD *)(v2 + 20) & 0x3F) - 32;
    sub_57D70(v2, (int)&v4);
    sub_49A20(v2);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    if ( (*(_WORD *)(v2 + 20) & 1) != 0 )
      sub_49DA0((_WORD *)v2, 84);
    else
      sub_49DA0((_WORD *)v2, 83);
    return v6;
  }
  return result;
}
// 4AD45: conditional instruction was optimized away because eax.4==1
// D41A0: using guessed type int dword_D41A0;

//----- (0004AD70) --------------------------------------------------------
_WORD *__cdecl sub_4AD70(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // ecx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    v3 = v1 - (dword_D41A0 + 28302);
    *(_BYTE *)(v1 + 12) &= ~8u;
    *(_DWORD *)(v1 + 16) = v3 / 168 % 11;
    *(_BYTE *)(v1 + 69) = 3;
    *(_BYTE *)(v1 + 63) = 2;
    *(_BYTE *)(v1 + 64) = 1;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49DA0(v2, 79);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004ADF0) --------------------------------------------------------
_WORD *__cdecl sub_4ADF0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // ecx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    v3 = v1 - (dword_D41A0 + 28302);
    *(_BYTE *)(v1 + 12) &= ~8u;
    *(_DWORD *)(v1 + 16) = v3 / 168 % 11;
    *(_BYTE *)(v1 + 69) = 6;
    *(_BYTE *)(v1 + 63) = 2;
    *(_BYTE *)(v1 + 64) = 2;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49DA0(v2, 39);
    sub_49EA0(v2, 1024, 1024);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004AE80) --------------------------------------------------------
_WORD *__cdecl sub_4AE80(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // ecx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    v3 = v1 - (dword_D41A0 + 28302);
    *(_BYTE *)(v1 + 12) &= ~8u;
    *(_DWORD *)(v1 + 16) = v3 / 168 % 11;
    *(_BYTE *)(v1 + 69) = 9;
    *(_BYTE *)(v1 + 63) = 2;
    *(_BYTE *)(v1 + 64) = 3;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49DA0(v2, 270);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004AF00) --------------------------------------------------------
_WORD *__cdecl sub_4AF00(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    v3 = dword_D41A0;
    *(_BYTE *)(v1 + 69) = 12;
    *(_BYTE *)(v1 + 63) = 2;
    *(_BYTE *)(v1 + 64) = 4;
    *(_DWORD *)(v1 + 16) = (v1 - (v3 + 28302)) / 168 % 11;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49DA0(v2, 48);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004AF70) --------------------------------------------------------
_WORD *__cdecl sub_4AF70(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    v3 = dword_D41A0;
    *(_BYTE *)(v1 + 69) = 15;
    *(_BYTE *)(v1 + 63) = 2;
    *(_BYTE *)(v1 + 64) = 5;
    *(_DWORD *)(v1 + 16) = (v1 - (v3 + 28302)) / 168 % 11;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49DA0(v2, 48);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004AFE0) --------------------------------------------------------
int __cdecl sub_4AFE0(int *a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  unsigned __int16 v4; // ax
  int v6; // [esp+0h] [ebp-8h] BYREF
  __int16 v7; // [esp+4h] [ebp-4h]

  if ( *(_BYTE *)(dword_D41A0 + 196308) != 2 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = 18;
  *(_BYTE *)(v1 + 63) = 2;
  v3 = *(_WORD *)(v1 + 20);
  *(_BYTE *)(v1 + 64) = 6;
  *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
  v4 = *(_WORD *)(v1 + 20);
  *(_BYTE *)(v2 + 56) = 1;
  *(_DWORD *)(v2 + 4) = v4 % 0x50u + 100;
  v6 = *a1;
  v7 = *((_WORD *)a1 + 2);
  LOBYTE(v3) = -95 * *(_BYTE *)(v2 + 20) - 33;
  *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
  LOWORD(v6) = (v3 & 0x3F) - 32 + v6;
  *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
  HIWORD(v6) += (*(_WORD *)(v2 + 20) & 0x3F) - 32;
  sub_57D70(v2, (int)&v6);
  sub_49A20(v2);
  *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
  sub_49DA0((_WORD *)v2, (*(_WORD *)(v2 + 20) & 3) + 324);
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004B0F0) --------------------------------------------------------
int __cdecl sub_4B0F0(int *a1)
{
  if ( *(_BYTE *)(dword_D41A0 + 196308) == 2 )
    return 0;
  else
    return sub_4B150(a1, 7, 20, 322);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004B120) --------------------------------------------------------
int __cdecl sub_4B120(int *a1)
{
  if ( *(_BYTE *)(dword_D41A0 + 196308) == 2 )
    return 0;
  else
    return sub_4B150(a1, 8, 21, 323);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004B150) --------------------------------------------------------
int __cdecl sub_4B150(int *a1, char a2, char a3, __int16 a4)
{
  int v4; // eax
  int v5; // ebx
  __int16 v6; // dx
  unsigned __int16 v7; // ax
  int v9; // [esp+0h] [ebp-8h] BYREF
  __int16 v10; // [esp+4h] [ebp-4h]

  v4 = sub_4A050();
  v5 = v4;
  if ( v4 )
  {
    *(_BYTE *)(v4 + 69) = a3;
    v6 = *(_WORD *)(v4 + 20);
    *(_BYTE *)(v4 + 64) = a2;
    *(_WORD *)(v4 + 20) = 9377 * v6 + 9439;
    v7 = *(_WORD *)(v4 + 20);
    *(_BYTE *)(v5 + 63) = 2;
    *(_BYTE *)(v5 + 56) = 1;
    *(_BYTE *)(v5 + 70) = 0;
    *(_WORD *)(v5 + 44) = -128;
    *(_WORD *)(v5 + 130) = 0;
    *(_DWORD *)(v5 + 4) = v7 % 0x7D0u + 400;
    v9 = *a1;
    v10 = *((_WORD *)a1 + 2);
    *(_WORD *)(v5 + 20) = 9377 * *(_WORD *)(v5 + 20) + 9439;
    LOWORD(v9) = (*(_WORD *)(v5 + 20) & 0x3F) - 32 + v9;
    LOBYTE(v6) = -95 * *(_BYTE *)(v5 + 20) - 33;
    *(_WORD *)(v5 + 20) = 9377 * *(_WORD *)(v5 + 20) + 9439;
    HIWORD(v9) += (v6 & 0x3F) - 32;
    sub_57D70(v5, (int)&v9);
    sub_49A20(v5);
    sub_49DA0((_WORD *)v5, a4);
  }
  return v5;
}

//----- (0004B240) --------------------------------------------------------
_DWORD *__cdecl sub_4B240(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax
  __int16 v4; // dx
  int v5; // ecx
  int v6; // edx
  int v7; // eax
  int v8; // eax
  int v9; // ebx
  int v10; // edx
  _DWORD *v12; // [esp+0h] [ebp-10h]
  int v13; // [esp+4h] [ebp-Ch]
  int v14; // [esp+8h] [ebp-8h]
  int v15; // [esp+Ch] [ebp-4h]

  if ( sub_4A810() < 16 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  v12 = (_DWORD *)v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = 1;
  *(_BYTE *)(v1 + 63) = 5;
  *(_BYTE *)(v1 + 64) = 0;
  *(_WORD *)(v1 + 132) = 80;
  *(_WORD *)(v1 + 134) = 16;
  *(_WORD *)(v1 + 130) = 30;
  *(_DWORD *)(v1 + 4) = 4000;
  *(_DWORD *)(v1 + 144) = 4500;
  v3 = *(_DWORD *)(v1 + 144);
  *(_DWORD *)(v2 + 140) = v3;
  v4 = *(_WORD *)(v2 + 20);
  *(_DWORD *)(v2 + 144) = v3 / 2;
  *(_WORD *)(v2 + 20) = 9377 * v4 + 9439;
  LOWORD(v3) = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
  *(_WORD *)(v2 + 32) = v3;
  *(_WORD *)(v2 + 28) = v3;
  v5 = dword_D41A0;
  v6 = dword_D41A0 + 28302;
  *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
  *(_WORD *)(v2 + 34) = 0;
  *(_WORD *)(v2 + 54) = 96;
  *(_BYTE *)(v2 + 56) = 1;
  v7 = *(char *)(v2 + 64);
  *(_DWORD *)(v2 + 16) = (v2 - v6) / 168 % 100;
  LOBYTE(v6) = *(_BYTE *)(v5 + v7 + 16);
  *(_BYTE *)(v5 + v7 + 16) = v6 + 1;
  *(_DWORD *)(v2 + 160) = &unk_D8544;
  *(_BYTE *)(v2 + 62) = v6;
  LOWORD(v5) = *(_WORD *)(*(_DWORD *)(v2 + 160) + 26);
  LOWORD(v6) = *(unsigned __int8 *)(v2 + 62) % (__int16)v5;
  *(_BYTE *)(v2 + 65) = 3;
  *(_WORD *)(v2 + 44) = 0;
  *(_BYTE *)(v2 + 70) = 0;
  v14 = v2;
  *(_BYTE *)(v2 + 61) = 0;
  v15 = 0;
  *(_BYTE *)(v2 + 57) = v5 - v6 + 4;
  while ( v15 <= 15 )
  {
    v8 = sub_4A050();
    v9 = v8;
    v13 = v8;
    if ( v8 )
    {
      qmemcpy((void *)v8, v12, 0xA8u);
      v10 = v8 - (dword_D41A0 + 28302);
      *(_WORD *)(v8 + 50) = (v14 - (dword_D41A0 + 28302)) / 168;
      *(_WORD *)(v14 + 52) = v10 / 168;
      *(_WORD *)(v8 + 52) = 0;
      *(_BYTE *)(v8 + 69) = -24;
      v12[36] = (v12[35] - (__CFSHL__((int)v12[35] >> 31, 5) + 32 * ((int)v12[35] >> 31))) >> 5;
      *(_BYTE *)(v8 + 62) = v15;
      sub_49CD0((_WORD *)v8, v15 + 19);
      *(_WORD *)(v9 + 54) = *(_WORD *)(v9 + 84);
      sub_57D70(v9, a1);
      sub_49A20(v9);
    }
    v14 = v13;
    ++v15;
  }
  sub_57D70((int)v12, a1);
  sub_49A20((int)v12);
  sub_49CD0(v12, 40);
  return v12;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004B490) --------------------------------------------------------
int __cdecl sub_4B490(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 9;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 1;
    *(_WORD *)(v1 + 132) = 54;
    *(_WORD *)(v1 + 134) = 18;
    *(_DWORD *)(v1 + 4) = 600;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 134);
    sub_49C70(v1);
    *(_WORD *)(v2 + 32) = 0;
    *(_WORD *)(v2 + 28) = *(_WORD *)(v2 + 32);
    v3 = dword_D41A0;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    *(_DWORD *)(v2 + 16) = (v2 - (v3 + 28302)) / 168 % 100;
    v4 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 34) = 0;
    v5 = v4 + v3;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v4) = *(_BYTE *)(v5 + 16);
    *(_BYTE *)(v5 + 16) = v4 + 1;
    *(_DWORD *)(v2 + 160) = &unk_D88DA;
    *(_BYTE *)(v2 + 62) = v4;
    *(_BYTE *)(v2 + 57) = *(_BYTE *)(*(_DWORD *)(v2 + 160) + 26) + 1;
    *(_BYTE *)(v2 + 65) = 3;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 238);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004B590) --------------------------------------------------------
int __cdecl sub_4B590(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  __int16 v4; // ax
  int v5; // ecx
  int v6; // edx
  int v7; // edx
  int v8; // ecx

  if ( *(_BYTE *)(dword_D41A0 + 196308) )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = 17;
  *(_BYTE *)(v1 + 63) = 5;
  *(_BYTE *)(v1 + 64) = 2;
  *(_WORD *)(v1 + 132) = 64;
  v3 = *(__int16 *)(v1 + 132);
  *(_WORD *)(v1 + 134) = 30;
  *(_DWORD *)(v1 + 4) = 3000;
  *(_WORD *)(v1 + 130) = v3 / 2;
  sub_49C70(v1);
  *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
  v4 = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
  *(_WORD *)(v2 + 32) = v4;
  *(_WORD *)(v2 + 28) = v4;
  v5 = dword_D41A0;
  v6 = dword_D41A0 + 28302;
  *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
  *(_WORD *)(v2 + 34) = 0;
  *(_WORD *)(v2 + 42) = 200;
  *(_BYTE *)(v2 + 65) = 3;
  *(_BYTE *)(v2 + 66) = 0;
  *(_DWORD *)(v2 + 16) = (v2 - v6) / 168 % 100;
  v7 = *(char *)(v2 + 64);
  *(_BYTE *)(v2 + 56) = 1;
  LOBYTE(v4) = *(_BYTE *)(v5 + v7 + 16);
  *(_BYTE *)(v5 + v7 + 16) = v4 + 1;
  *(_DWORD *)(v2 + 160) = &unk_D8588;
  *(_BYTE *)(v2 + 62) = v4;
  v8 = *(__int16 *)(*(_DWORD *)(v2 + 160) + 26)
     - *(unsigned __int8 *)(v2 + 62) % *(__int16 *)(*(_DWORD *)(v2 + 160) + 26);
  *(_BYTE *)(v2 + 65) = 3;
  *(_BYTE *)(v2 + 57) = v8 + 4;
  sub_57D70(v2, a1);
  sub_49A20(v2);
  sub_49CD0((_WORD *)v2, 3);
  sub_49EA0((_WORD *)v2, 128, 128);
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004B6F0) --------------------------------------------------------
int __cdecl sub_4B6F0(int a1)
{
  int result; // eax
  int v2; // ebx
  __int64 v3; // rax
  int v4; // ecx
  int v5; // eax
  _WORD *v6; // ebx
  int v7; // edx
  unsigned __int16 v8; // ax
  int v9; // [esp+0h] [ebp-10h]
  int v10; // [esp+4h] [ebp-Ch]
  int v11; // [esp+8h] [ebp-8h]
  int v12; // [esp+Ch] [ebp-4h]

  result = sub_4A050();
  v2 = result;
  v9 = result;
  if ( result )
  {
    *(_BYTE *)(result + 69) = 25;
    *(_BYTE *)(result + 63) = 5;
    *(_BYTE *)(result + 64) = 3;
    *(_WORD *)(result + 132) = 64;
    *(_WORD *)(result + 134) = 16;
    *(_WORD *)(result + 130) = 30;
    *(_DWORD *)(result + 4) = 9000;
    sub_49C70(result);
    v3 = *(int *)(v2 + 144);
    *(_DWORD *)(v2 + 140) = v3;
    LODWORD(v3) = ((int)v3 - HIDWORD(v3)) >> 1;
    WORD2(v3) = *(_WORD *)(v2 + 20);
    *(_DWORD *)(v2 + 144) = v3;
    *(_WORD *)(v2 + 20) = 9377 * WORD2(v3) + 9439;
    LOWORD(v3) = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
    *(_WORD *)(v2 + 32) = v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = dword_D41A0;
    HIDWORD(v3) = dword_D41A0 + 28302;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    *(_WORD *)(v2 + 34) = 0;
    *(_WORD *)(v2 + 54) = 96;
    *(_BYTE *)(v2 + 56) = 1;
    LODWORD(v3) = *(char *)(v2 + 64);
    *(_DWORD *)(v2 + 16) = (v2 - HIDWORD(v3)) / 168 % 100;
    BYTE4(v3) = *(_BYTE *)(v4 + v3 + 16);
    *(_BYTE *)(v4 + v3 + 16) = BYTE4(v3) + 1;
    *(_DWORD *)(v2 + 160) = &unk_D85AA;
    *(_BYTE *)(v2 + 62) = BYTE4(v3);
    LOWORD(v4) = *(_WORD *)(*(_DWORD *)(v2 + 160) + 26);
    WORD2(v3) = *(unsigned __int8 *)(v2 + 62) % (__int16)v4;
    v11 = v2;
    *(_BYTE *)(v2 + 65) = 3;
    v12 = 0;
    *(_BYTE *)(v2 + 57) = v4 - BYTE4(v3) + 4;
    while ( v12 <= 15 )
    {
      v5 = sub_4A050();
      v6 = (_WORD *)v5;
      v10 = v5;
      if ( v5 )
      {
        qmemcpy((void *)v5, (const void *)v9, 0xA8u);
        v7 = v5 - (dword_D41A0 + 28302);
        *(_WORD *)(v5 + 50) = (v11 - (dword_D41A0 + 28302)) / 168;
        *(_WORD *)(v11 + 52) = v7 / 168;
        *(_WORD *)(v5 + 52) = 0;
        *(_BYTE *)(v5 + 69) = -24;
        *(_DWORD *)(v5 + 144) = (*(_DWORD *)(v9 + 140)
                               - (__CFSHL__(*(int *)(v9 + 140) >> 31, 5)
                                + 32 * (*(int *)(v9 + 140) >> 31))) >> 5;
        *(_BYTE *)(v5 + 62) = v12;
        sub_49CD0((_WORD *)v5, v12 + 89);
        v6[42] = 65 * (unsigned __int16)word_D9522[7 * v12 + 623] / 100;
        v6[43] = 65 * (unsigned __int16)word_D9522[7 * v12 + 623] / 100;
        v6[44] = 65 * (unsigned __int16)word_D9524[7 * v12 + 623] / 100;
        v8 = v6[42];
        v6[27] = v8;
        if ( !v12 )
          v6[27] = 125 * v8 / 100;
        sub_57D70(v10, a1);
        sub_49A20(v10);
      }
      v11 = v10;
      ++v12;
    }
    sub_57D70(v9, a1);
    sub_49A20(v9);
    sub_49CD0((_WORD *)v9, 88);
    *(_WORD *)(v9 + 84) = 60 * (unsigned __int16)word_D99F2 / 100;
    *(_WORD *)(v9 + 86) = 60 * (unsigned __int16)word_D99F2 / 100;
    *(_WORD *)(v9 + 88) = 60 * (unsigned __int16)word_D99F4 / 100;
    return v9;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D9522: using guessed type __int16 word_D9522[];
// D9524: using guessed type __int16 word_D9524[];
// D99F2: using guessed type __int16 word_D99F2;
// D99F4: using guessed type __int16 word_D99F4;

//----- (0004BA10) --------------------------------------------------------
int __cdecl sub_4BA10(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // ecx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 33;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 4;
    *(_WORD *)(v1 + 132) = 30;
    *(_WORD *)(v1 + 134) = 0;
    *(_DWORD *)(v1 + 4) = 1000;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    sub_49C70(v1);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v3 = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
    *(_WORD *)(v2 + 32) = v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = dword_D41A0;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    *(_WORD *)(v2 + 34) = 0;
    *(_DWORD *)(v2 + 16) = (v2 - (v4 + 28302)) / 168 % 100;
    v5 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 42) = 500;
    v6 = v5 + v4;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v5) = *(_BYTE *)(v6 + 16);
    *(_BYTE *)(v6 + 16) = v5 + 1;
    *(_DWORD *)(v2 + 160) = &off_D85CC;
    *(_BYTE *)(v2 + 62) = v5;
    v7 = *(__int16 *)(*(_DWORD *)(v2 + 160) + 26)
       - *(unsigned __int8 *)(v2 + 62) % *(__int16 *)(*(_DWORD *)(v2 + 160) + 26);
    *(_BYTE *)(v2 + 65) = 3;
    *(_BYTE *)(v2 + 57) = v7 + 4;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 0);
    sub_49EA0((_WORD *)v2, 128, 256);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D85CC: using guessed type void *off_D85CC;

//----- (0004BBB0) --------------------------------------------------------
int __cdecl sub_4BBB0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // ax
  unsigned __int16 v4; // ax
  __int16 v5; // dx
  int v6; // edx
  int v7; // eax
  int v8; // eax
  int v9; // esi
  int v10; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 72;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 9;
    *(_WORD *)(v1 + 132) = 20;
    *(_WORD *)(v1 + 134) = 0;
    v3 = *(_WORD *)(v1 + 132);
    *(_DWORD *)(v2 + 4) = 1000;
    *(_WORD *)(v2 + 130) = v3;
    sub_49C70(v2);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v4 = *(_WORD *)(v2 + 20);
    *(_WORD *)(v2 + 34) = 0;
    v5 = v4 % 0x832u - 1;
    *(_WORD *)(v2 + 32) = v5;
    *(_WORD *)(v2 + 28) = v5;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    v6 = dword_D41A0;
    v7 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 42) = 500;
    v8 = v6 + v7;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v6) = *(_BYTE *)(v8 + 16);
    *(_BYTE *)(v8 + 16) = v6 + 1;
    *(_DWORD *)(v2 + 160) = &off_D8676;
    *(_BYTE *)(v2 + 62) = v6;
    v9 = *(__int16 *)(*(_DWORD *)(v2 + 160) + 26)
       - *(unsigned __int8 *)(v2 + 62) % *(__int16 *)(*(_DWORD *)(v2 + 160) + 26);
    *(_BYTE *)(v2 + 65) = 3;
    *(_DWORD *)(v2 + 16) = 16;
    *(_BYTE *)(v2 + 57) = v9 + 4;
    sub_57D70(v2, a1);
    *(_WORD *)(v2 + 80) = sub_10C40((__int16 *)(v2 + 76));
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 220);
    sub_49EA0((_WORD *)v2, 128, 128);
    v10 = sub_102D0(v2, (__int16 *)(v2 + 76), 1);
    if ( v10 )
    {
      sub_57F20(v10, v2);
      return 0;
    }
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D8676: using guessed type void *off_D8676;

//----- (0004BD00) --------------------------------------------------------
int __cdecl sub_4BD00(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // edx
  int v5; // eax

  if ( (*(_BYTE *)(dword_D41A0 + 196306) & 2) == 0 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = 80;
  *(_BYTE *)(v1 + 63) = 5;
  *(_BYTE *)(v1 + 64) = 10;
  *(_DWORD *)(v1 + 4) = 300000;
  sub_49C70(v1);
  *(_DWORD *)(v2 + 12) |= 0x48800001u;
  v3 = dword_D41A0;
  v4 = *(char *)(v2 + 64);
  *(_WORD *)(v2 + 42) = 0;
  v5 = v4 + v3;
  *(_BYTE *)(v2 + 56) = 1;
  LOBYTE(v4) = *(_BYTE *)(v5 + 16);
  *(_BYTE *)(v5 + 16) = v4 + 1;
  *(_DWORD *)(v2 + 160) = &off_D89C8;
  *(_BYTE *)(v2 + 57) = 64;
  *(_BYTE *)(v2 + 65) = 3;
  *(_DWORD *)(v2 + 16) = 0;
  *(_BYTE *)(v2 + 70) = 0;
  *(_BYTE *)(v2 + 62) = v4;
  sub_57D70(v2, a1);
  *(_WORD *)(v2 + 80) = sub_10C40((__int16 *)(v2 + 76));
  sub_49A20(v2);
  sub_49C90(v2, 341);
  *(_WORD *)(v2 + 82) = 512;
  sub_49EA0((_WORD *)v2, 1024, 1280);
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D89C8: using guessed type void *off_D89C8;

//----- (0004BDF0) --------------------------------------------------------
int __cdecl sub_4BDF0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // cx
  __int16 v4; // dx
  __int16 v5; // dx
  int v6; // ecx
  int v7; // edx
  int v8; // edx
  char v9; // al

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_WORD *)(v1 + 134) = 24;
    v3 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 134);
    *(_BYTE *)(v1 + 69) = 97;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 12;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 132) = 54;
    *(_DWORD *)(v1 + 4) = 1000;
    v5 = (v4 & 0x7FF) - 1;
    *(_WORD *)(v1 + 32) = v5;
    *(_WORD *)(v1 + 28) = v5;
    v6 = dword_D41A0;
    *(_WORD *)(v1 + 30) = *(_WORD *)(v1 + 32);
    *(_DWORD *)(v1 + 144) = 0;
    *(_WORD *)(v1 + 34) = 0;
    *(_DWORD *)(v1 + 16) = (v1 - (v6 + 28302)) / 168 % 100;
    v7 = *(char *)(v1 + 64);
    *(_WORD *)(v1 + 42) = 500;
    v8 = v6 + v7;
    *(_BYTE *)(v1 + 56) = 1;
    v9 = *(_BYTE *)(v8 + 16);
    *(_BYTE *)(v8 + 16) = v9 + 1;
    *(_DWORD *)(v2 + 160) = &off_D8940;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_DWORD *)(v2 + 16) = 2;
    *(_BYTE *)(v2 + 62) = v9;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 221);
    sub_49EA0((_WORD *)v2, 128, 128);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D8940: using guessed type void *off_D8940;

//----- (0004C0B0) --------------------------------------------------------
int __cdecl sub_4C0B0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // cx
  __int16 v4; // dx
  __int16 v5; // dx
  int v6; // ecx
  int v7; // edx
  int v8; // edx
  char v9; // al

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_WORD *)(v1 + 134) = 18;
    v3 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 134);
    *(_BYTE *)(v1 + 69) = 113;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 14;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 132) = 54;
    *(_DWORD *)(v1 + 4) = 1000;
    v5 = (v4 & 0x7FF) - 1;
    *(_WORD *)(v1 + 32) = v5;
    *(_WORD *)(v1 + 28) = v5;
    v6 = dword_D41A0;
    *(_WORD *)(v1 + 30) = *(_WORD *)(v1 + 32);
    *(_DWORD *)(v1 + 144) = 0;
    *(_WORD *)(v1 + 34) = 0;
    *(_DWORD *)(v1 + 16) = (v1 - (v6 + 28302)) / 168 % 100;
    v7 = *(char *)(v1 + 64);
    *(_WORD *)(v1 + 42) = 500;
    v8 = v6 + v7;
    *(_BYTE *)(v1 + 56) = 1;
    v9 = *(_BYTE *)(v8 + 16);
    *(_BYTE *)(v8 + 16) = v9 + 1;
    *(_DWORD *)(v2 + 160) = &off_D891E;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_DWORD *)(v2 + 16) = 2;
    *(_BYTE *)(v2 + 62) = v9;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 219);
    sub_49EA0((_WORD *)v2, 128, 128);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D891E: using guessed type void *off_D891E;

//----- (0004C1E0) --------------------------------------------------------
int __cdecl sub_4C1E0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  char v6; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 121;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 15;
    *(_WORD *)(v1 + 132) = 30;
    *(_WORD *)(v1 + 134) = 0;
    *(_DWORD *)(v1 + 4) = 1000;
    *(_WORD *)(v1 + 32) = 0;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    *(_WORD *)(v1 + 28) = *(_WORD *)(v1 + 32);
    v3 = dword_D41A0;
    *(_WORD *)(v1 + 30) = *(_WORD *)(v1 + 32);
    *(_DWORD *)(v1 + 144) = 0;
    *(_WORD *)(v1 + 34) = 0;
    *(_DWORD *)(v1 + 16) = (v1 - (v3 + 28302)) / 168 % 100;
    v4 = *(char *)(v1 + 64);
    *(_WORD *)(v1 + 42) = 500;
    v5 = v4 + v3;
    *(_BYTE *)(v1 + 56) = 1;
    LOBYTE(v4) = *(_BYTE *)(v5 + 16);
    *(_BYTE *)(v5 + 16) = v4 + 1;
    *(_DWORD *)(v1 + 160) = &off_D86DC;
    *(_BYTE *)(v1 + 62) = v4;
    LOWORD(v5) = *(_WORD *)(*(_DWORD *)(v1 + 160) + 26);
    LOWORD(v4) = *(unsigned __int8 *)(v1 + 62) % (__int16)v5;
    *(_BYTE *)(v1 + 65) = 3;
    v6 = *(_BYTE *)(v1 + 14) | 2;
    *(_BYTE *)(v2 + 57) = v5 - v4 + 4;
    *(_BYTE *)(v2 + 14) = v6;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 0);
    sub_49EA0((_WORD *)v2, 128, 128);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D86DC: using guessed type void *off_D86DC;

//----- (0004C310) --------------------------------------------------------
int __cdecl sub_4C310(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // ax
  __int16 v4; // ax
  int v5; // ecx
  int v6; // edx
  int v7; // eax
  int v8; // ecx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -127;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 16;
    *(_WORD *)(v1 + 132) = 60;
    *(_WORD *)(v1 + 134) = 20;
    v3 = *(_WORD *)(v1 + 132);
    *(_DWORD *)(v2 + 4) = 60000;
    *(_WORD *)(v2 + 130) = v3;
    sub_49C70(v2);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v4 = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
    *(_WORD *)(v2 + 32) = v4;
    *(_WORD *)(v2 + 28) = v4;
    v5 = dword_D41A0;
    v6 = dword_D41A0 + 28302;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    *(_WORD *)(v2 + 34) = 0;
    *(_WORD *)(v2 + 42) = 500;
    v7 = *(char *)(v2 + 64);
    *(_BYTE *)(v2 + 56) = 1;
    v8 = v7 + v5;
    *(_DWORD *)(v2 + 16) = (v2 - v6) / 168 % 100;
    LOBYTE(v7) = *(_BYTE *)(v8 + 16);
    *(_BYTE *)(v8 + 16) = v7 + 1;
    *(_DWORD *)(v2 + 160) = &unk_D86FE;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_DWORD *)(v2 + 16) = 0;
    *(_BYTE *)(v2 + 62) = v7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 207);
    *(_WORD *)(v2 + 82) = (5 * (unsigned __int16)word_DA076
                         - (__CFSHL__((5 * (unsigned __int16)word_DA076) >> 31, 3)
                          + 8 * ((5 * (unsigned __int16)word_DA076) >> 31))) >> 3;
    sub_49EA0((_WORD *)v2, 128, 128);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// DA076: using guessed type __int16 word_DA076;

//----- (0004C460) --------------------------------------------------------
int __cdecl sub_4C460(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  int v4; // ecx
  int v5; // edx
  int v6; // edx
  char v7; // al

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -119;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 17;
    *(_WORD *)(v1 + 132) = 68;
    *(_WORD *)(v1 + 134) = 20;
    *(_DWORD *)(v1 + 4) = 10000;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    sub_49C70(v1);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v3 = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
    *(_WORD *)(v2 + 32) = v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = dword_D41A0;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    *(_WORD *)(v2 + 34) = 0;
    *(_DWORD *)(v2 + 16) = (v2 - (v4 + 28302)) / 168 % 100;
    v5 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 42) = 350;
    v6 = v4 + v5;
    *(_BYTE *)(v2 + 56) = 1;
    v7 = *(_BYTE *)(v6 + 16);
    *(_BYTE *)(v6 + 16) = v7 + 1;
    *(_DWORD *)(v2 + 160) = &unk_D8720;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_DWORD *)(v2 + 16) = 0;
    *(_BYTE *)(v2 + 62) = v7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 285);
    sub_49EA0((_WORD *)v2, 128, 128);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004C590) --------------------------------------------------------
int __cdecl sub_4C590(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  int v4; // ecx
  int v5; // edx
  int v6; // edx
  char v7; // al

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -109;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 18;
    *(_WORD *)(v1 + 132) = 10;
    *(_WORD *)(v1 + 134) = 6;
    *(_DWORD *)(v1 + 4) = 36000;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    sub_49C70(v1);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v3 = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
    *(_WORD *)(v2 + 32) = v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = dword_D41A0;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    *(_WORD *)(v2 + 34) = 0;
    *(_DWORD *)(v2 + 16) = (v2 - (v4 + 28302)) / 168 % 100;
    v5 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 42) = 500;
    v6 = v4 + v5;
    *(_BYTE *)(v2 + 56) = 1;
    v7 = *(_BYTE *)(v6 + 16);
    *(_BYTE *)(v6 + 16) = v7 + 1;
    *(_DWORD *)(v2 + 160) = &off_D8742;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_BYTE *)(v2 + 62) = v7;
    *(_DWORD *)(v2 + 16) = 100;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 286);
    sub_49EA0((_WORD *)v2, 512, 512);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D8742: using guessed type void *off_D8742;

//----- (0004C6B0) --------------------------------------------------------
int __cdecl sub_4C6B0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // ecx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -103;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 19;
    *(_WORD *)(v1 + 132) = 76;
    *(_WORD *)(v1 + 134) = 8;
    *(_DWORD *)(v1 + 4) = 600;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    sub_49C70(v1);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v3 = (*(_WORD *)(v2 + 20) & 0x7FF) - 1;
    *(_WORD *)(v2 + 32) = v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = dword_D41A0;
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    *(_WORD *)(v2 + 34) = 0;
    *(_WORD *)(v2 + 42) = 300;
    *(_BYTE *)(v2 + 65) = 3;
    *(_DWORD *)(v2 + 16) = (v2 - (v4 + 28302)) / 168 % 100;
    v5 = *(char *)(v2 + 64);
    *(_BYTE *)(v2 + 66) = 0;
    v6 = v5 + v4;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v5) = *(_BYTE *)(v6 + 16);
    *(_BYTE *)(v6 + 16) = v5 + 1;
    *(_DWORD *)(v2 + 160) = &unk_D8786;
    *(_BYTE *)(v2 + 62) = v5;
    v7 = *(__int16 *)(*(_DWORD *)(v2 + 160) + 26)
       - *(unsigned __int8 *)(v2 + 62) % *(__int16 *)(*(_DWORD *)(v2 + 160) + 26);
    *(_BYTE *)(v2 + 65) = 3;
    *(_BYTE *)(v2 + 57) = v7 + 4;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 287);
    sub_49EA0((_WORD *)v2, 85, 51);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004C7F0) --------------------------------------------------------
int __cdecl sub_4C7F0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  int v4; // eax
  int v5; // edx
  int v6; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -95;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 20;
    *(_WORD *)(v1 + 132) = 32;
    *(_WORD *)(v1 + 134) = 20;
    *(_DWORD *)(v1 + 4) = 5500;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    sub_49C70(v1);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v3 = *(_WORD *)(v2 + 20) & 0x7FF;
    *(_WORD *)(v2 + 34) = 0;
    *(_WORD *)(v2 + 32) = --v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    v5 = dword_D41A0;
    *(_WORD *)(v2 + 42) = 100;
    v6 = v4 + v5;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v4) = *(_BYTE *)(v6 + 16);
    *(_BYTE *)(v6 + 16) = v4 + 1;
    *(_DWORD *)(v2 + 160) = &unk_D87A8;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_BYTE *)(v2 + 62) = v4;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 288);
    sub_49EA0((_WORD *)v2, 384, 512);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004C8F0) --------------------------------------------------------
int __cdecl sub_4C8F0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // cx
  __int16 v4; // dx
  __int16 v5; // dx
  int v6; // edx
  char v7; // al
  int v8; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    v3 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 134);
    *(_BYTE *)(v1 + 69) = -87;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 21;
    *(_WORD *)(v1 + 132) = 96;
    *(_DWORD *)(v1 + 4) = 1000;
    *(_DWORD *)(v1 + 144) = 1000;
    *(_WORD *)(v1 + 34) = 0;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 42) = 400;
    *(_BYTE *)(v1 + 56) = 1;
    v5 = (v4 & 0x7FF) - 1;
    *(_WORD *)(v1 + 32) = v5;
    *(_WORD *)(v1 + 28) = v5;
    *(_WORD *)(v1 + 30) = *(_WORD *)(v1 + 32);
    v6 = *(char *)(v1 + 64) + dword_D41A0;
    v7 = *(_BYTE *)(v6 + 16);
    *(_BYTE *)(v6 + 16) = v7 + 1;
    *(_DWORD *)(v2 + 160) = &unk_D8896;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_BYTE *)(v2 + 70) = 0;
    *(_WORD *)(v2 + 44) = 0;
    *(_BYTE *)(v2 + 68) = 0;
    *(_BYTE *)(v2 + 67) = 0;
    *(_BYTE *)(v2 + 62) = v7;
    sub_57D70(v2, a1);
    v8 = sub_49A20(v2);
    sub_26500(v8, v2);
    sub_268F0(v2, 1u);
    sub_49EA0((_WORD *)v2, 128, 128);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004CA00) --------------------------------------------------------
int __cdecl sub_4CA00(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax
  int v5; // ecx
  int v6; // eax
  int v7; // ecx
  __int16 v8; // dx

  if ( sub_4A810() < 15 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = -80;
  *(_BYTE *)(v1 + 63) = 5;
  *(_BYTE *)(v1 + 64) = 22;
  *(_WORD *)(v1 + 132) = 128;
  *(_WORD *)(v1 + 134) = 16;
  v3 = *(_WORD *)(v1 + 20);
  *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 134);
  *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
  v4 = (*(_WORD *)(v1 + 20) & 0x7FF) - 1;
  *(_WORD *)(v2 + 32) = v4;
  *(_WORD *)(v2 + 28) = v4;
  v5 = *(char *)(v2 + 64);
  *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
  v6 = dword_D41A0;
  *(_DWORD *)(v2 + 4) = 2000;
  v7 = v6 + v5;
  *(_WORD *)(v2 + 34) = 0;
  LOBYTE(v3) = *(_BYTE *)(v7 + 16);
  *(_BYTE *)(v7 + 16) = v3 + 1;
  *(_DWORD *)(v2 + 160) = &unk_D87CA;
  *(_BYTE *)(v2 + 62) = v3;
  LOWORD(v7) = *(_WORD *)(*(_DWORD *)(v2 + 160) + 26);
  v8 = *(unsigned __int8 *)(v2 + 62) % (__int16)v7;
  *(_BYTE *)(v2 + 65) = 3;
  *(_BYTE *)(v2 + 56) = 3;
  *(_WORD *)(v2 + 148) = 0;
  *(_WORD *)(v2 + 82) = 0;
  *(_BYTE *)(v2 + 92) = 0;
  *(_WORD *)(v2 + 44) = 11;
  *(_WORD *)(v2 + 42) = 0;
  *(_WORD *)(v2 + 54) = 0;
  *(_WORD *)(v2 + 150) = 1024;
  *(_WORD *)(v2 + 36) = 0;
  *(_BYTE *)(v2 + 70) = 15;
  *(_BYTE *)(v2 + 57) = v7 - v8 + 4;
  *(_DWORD *)&word_EB398 = *(_DWORD *)a1;
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 4);
  word_EB39C = sub_10C40(&word_EB398) + 384;
  sub_57D70(v2, (int)&word_EB398);
  sub_49C70(v2);
  sub_49A20(v2);
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0004CB60) --------------------------------------------------------
int __cdecl sub_4CB60(int a1)
{
  int v1; // ebx
  __int16 i; // di
  int v3; // eax
  _WORD *v5; // [esp+0h] [ebp-8h]
  int v6; // [esp+4h] [ebp-4h]

  v1 = 1;
  v5 = (_WORD *)a1;
  while ( (__int16)v1 <= *(char *)(a1 + 70) / 2 )
  {
    for ( i = 0; i < 2; ++i )
    {
      v6 = sub_4A050();
      if ( v6 )
      {
        if ( i )
          v3 = -(__int16)v1;
        else
          LOWORD(v3) = v1;
        sub_274C0(a1, v6, v5, v3);
      }
      v5 = (_WORD *)v6;
    }
    ++v1;
  }
  sub_27590(v1, a1);
  sub_27610(v1, a1);
  return sub_276E0(a1);
}

//----- (0004CBF0) --------------------------------------------------------
int __cdecl sub_4CBF0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax
  __int16 v5; // ax
  int v6; // edx
  int v7; // eax
  int v8; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -72;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 23;
    *(_WORD *)(v1 + 132) = 24;
    *(_WORD *)(v1 + 134) = 14;
    v3 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_DWORD *)(v2 + 4) = 10000;
    *(_DWORD *)(v2 + 144) = 100;
    v5 = (v4 & 0x7FF) - 1;
    *(_WORD *)(v2 + 32) = v5;
    v6 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 28) = v5;
    v7 = dword_D41A0;
    *(_WORD *)(v2 + 42) = 500;
    v8 = v6 + v7;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v6) = *(_BYTE *)(v8 + 16);
    *(_BYTE *)(v8 + 16) = v6 + 1;
    *(_DWORD *)(v2 + 160) = &unk_D87EC;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_WORD *)(v2 + 44) = 0x2000;
    *(_BYTE *)(v2 + 62) = v6;
    *(_WORD *)(a1 + 4) = *(_WORD *)(v2 + 44);
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 289);
    sub_49EA0((_WORD *)v2, 384, 384);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004CCF0) --------------------------------------------------------
int __cdecl sub_4CCF0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // ax
  __int16 v4; // ax
  int v5; // edx
  int v6; // eax
  int v7; // eax

  if ( *(_BYTE *)(dword_D41A0 + 196308) != 2 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = -63;
  *(_BYTE *)(v1 + 63) = 5;
  *(_BYTE *)(v1 + 64) = 24;
  *(_BYTE *)(v1 + 70) = 0;
  *(_WORD *)(v1 + 132) = 80;
  *(_WORD *)(v1 + 134) = 24;
  v3 = *(_WORD *)(v1 + 134);
  *(_DWORD *)(v2 + 4) = 16000;
  *(_WORD *)(v2 + 130) = v3;
  sub_49C70(v2);
  *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
  v4 = *(_WORD *)(v2 + 20) & 0x7FF;
  *(_WORD *)(v2 + 34) = 0;
  *(_WORD *)(v2 + 32) = --v4;
  *(_WORD *)(v2 + 28) = v4;
  v5 = *(char *)(v2 + 64);
  *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
  v6 = dword_D41A0;
  *(_WORD *)(v2 + 42) = 1500;
  v7 = v5 + v6;
  *(_BYTE *)(v2 + 56) = 1;
  LOBYTE(v5) = *(_BYTE *)(v7 + 16);
  *(_BYTE *)(v7 + 16) = v5 + 1;
  *(_BYTE *)(v2 + 62) = v5;
  *(_DWORD *)(v2 + 160) = &unk_D8962;
  *(_BYTE *)(v2 + 57) = 64;
  *(_BYTE *)(v2 + 65) = 3;
  sub_57D70(v2, a1);
  sub_49A20(v2);
  sub_49CD0((_WORD *)v2, 335);
  sub_49EA0((_WORD *)v2, 256, 640);
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004CE00) --------------------------------------------------------
int __cdecl sub_4CE00(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  int v4; // eax
  int v5; // edx
  int v6; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -55;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 25;
    *(_BYTE *)(v1 + 70) = 0;
    *(_WORD *)(v1 + 132) = 60;
    *(_WORD *)(v1 + 134) = 20;
    *(_DWORD *)(v1 + 4) = 7500;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 132);
    sub_49C70(v1);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v3 = *(_WORD *)(v2 + 20) & 0x7FF;
    *(_WORD *)(v2 + 34) = 0;
    *(_WORD *)(v2 + 32) = --v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    v5 = dword_D41A0;
    *(_WORD *)(v2 + 42) = 300;
    v6 = v4 + v5;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v4) = *(_BYTE *)(v6 + 16);
    *(_BYTE *)(v6 + 16) = v4 + 1;
    *(_DWORD *)(v2 + 160) = &unk_D880E;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_BYTE *)(v2 + 62) = v4;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 290);
    sub_49EA0((_WORD *)v2, 384, 384);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004CF00) --------------------------------------------------------
int __cdecl sub_4CF00(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  int v4; // eax
  int v5; // edx
  int v6; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -47;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 26;
    *(_WORD *)(v1 + 132) = 25;
    *(_WORD *)(v1 + 134) = 25;
    *(_DWORD *)(v1 + 4) = 4400;
    *(_WORD *)(v1 + 130) = *(_WORD *)(v1 + 134);
    sub_49C70(v1);
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v3 = *(_WORD *)(v2 + 20) & 0x7FF;
    *(_WORD *)(v2 + 34) = 0;
    *(_WORD *)(v2 + 32) = --v3;
    *(_WORD *)(v2 + 28) = v3;
    v4 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    v5 = dword_D41A0;
    *(_WORD *)(v2 + 42) = 300;
    v6 = v4 + v5;
    *(_BYTE *)(v2 + 56) = 1;
    LOBYTE(v4) = *(_BYTE *)(v6 + 16);
    *(_BYTE *)(v6 + 16) = v4 + 1;
    *(_DWORD *)(v2 + 160) = &unk_D88FC;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_BYTE *)(v2 + 62) = v4;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 318);
    sub_49EA0((_WORD *)v2, 256, 384);
    sub_293D0(v2);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004D000) --------------------------------------------------------
unsigned int __usercall sub_4D000@<eax>(unsigned int a1@<esi>, int a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // ebx
  int v4; // edi
  _BYTE *v5; // eax
  _WORD *v6; // ebx
  __int16 v7; // ax
  _BYTE *v8; // eax
  _WORD *v9; // ebx
  int v10; // eax
  _BYTE *v12; // [esp+0h] [ebp-14h]
  int i; // [esp+4h] [ebp-10h]
  _BYTE *v14; // [esp+8h] [ebp-Ch]
  _WORD *v15; // [esp+8h] [ebp-Ch]
  int v16; // [esp+Ch] [ebp-8h]
  char v17; // [esp+10h] [ebp-4h]

  v17 = 0;
  if ( *(_BYTE *)(dword_D41A0 + 196308) == 2 )
  {
    v17 = 1;
  }
  else
  {
    if ( sub_4A810() >= 51 )
    {
      v2 = (_BYTE *)sub_4A050();
      v3 = v2;
      a1 = (unsigned int)v2;
      if ( v2 )
      {
        v2[69] = -39;
        v2[63] = 5;
        v2[64] = 27;
        sub_57D70((int)v2, a2);
        v14 = v3;
        v16 = 0;
        v4 = (int)&v3[-dword_D41A0 - 28302] / 168;
        while ( v16 < 5 && !v17 )
        {
          v5 = (_BYTE *)sub_4A050();
          v6 = v5;
          v12 = v5;
          if ( v5 )
          {
            v5[69] = -23;
            v5[63] = 5;
            v5[64] = 27;
            v5[59] = v16;
            v7 = (int)&v5[-dword_D41A0 - 28302] / 168;
            v6[13] = v4;
            v6[25] = v4;
            *((_WORD *)v14 + 26) = v7;
            v15 = v6;
            v6[26] = 0;
            sub_57D70((int)v6, a2);
            for ( i = 0; i < 9 && !v17; ++i )
            {
              v8 = (_BYTE *)sub_4A050();
              v9 = v8;
              v12 = v8;
              if ( v8 )
              {
                v8[69] = -22;
                v8[63] = 5;
                v8[64] = 27;
                v8[59] = v16;
                v10 = (int)&v8[-dword_D41A0 - 28302] / 168;
                v9[13] = v4;
                v9[25] = v4;
                v15[26] = v10;
                v9[26] = 0;
                sub_57D70((int)v9, a2);
              }
              else
              {
                v17 = 1;
              }
              v15 = v12;
            }
          }
          else
          {
            v17 = 1;
          }
          v14 = v12;
          ++v16;
        }
      }
    }
    if ( !a1 || v17 )
    {
      sub_2AE80(a1);
    }
    else
    {
      sub_2AC50(a1);
      sub_2AD40(a1);
      sub_2AE30(a1);
    }
  }
  if ( v17 )
    return 0;
  return a1;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004D1D0) --------------------------------------------------------
int __cdecl sub_4D1D0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax
  int v5; // edx
  int v6; // eax
  int v7; // edx
  char v8; // cl
  int v9; // ecx
  int v10; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = -31;
    *(_BYTE *)(v1 + 63) = 5;
    *(_BYTE *)(v1 + 64) = 28;
    *(_WORD *)(v1 + 132) = 120;
    *(_WORD *)(v1 + 134) = 64;
    *(_DWORD *)(v1 + 4) = 8000;
    sub_49C70(v1);
    v3 = *(_WORD *)(v2 + 20);
    *(_BYTE *)(v2 + 15) |= 8u;
    *(_WORD *)(v2 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v2 + 20) & 0x7FF;
    *(_WORD *)(v2 + 34) = 0;
    *(_WORD *)(v2 + 32) = --v4;
    *(_WORD *)(v2 + 28) = v4;
    v5 = *(char *)(v2 + 64);
    *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
    v6 = dword_D41A0;
    *(_WORD *)(v2 + 42) = 2000;
    v7 = v6 + v5;
    *(_BYTE *)(v2 + 56) = 1;
    v8 = *(_BYTE *)(v7 + 16);
    *(_BYTE *)(v7 + 16) = v8 + 1;
    *(_BYTE *)(v2 + 62) = v8;
    v9 = *(__int16 *)(v2 + 134);
    v10 = (*(__int16 *)(v2 + 132) - v9) / 2;
    *(_DWORD *)(v2 + 160) = &unk_D8830;
    *(_BYTE *)(v2 + 57) = 64;
    *(_BYTE *)(v2 + 65) = 3;
    *(_WORD *)(v2 + 130) = v9 + v10;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 292);
    sub_49EA0((_WORD *)v2, 85, 42);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004D2E0) --------------------------------------------------------
int __cdecl sub_4D2E0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 0;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 0;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D8456;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 340);
    sub_847D0(v2, 128, 1, 0);
  }
  return v2;
}
// D8456: using guessed type void *off_D8456;

//----- (0004D380) --------------------------------------------------------
int __cdecl sub_4D380(int a1)
{
  int result; // eax

  result = sub_4D2E0(a1);
  if ( result )
  {
    *(_BYTE *)(result + 69) = 29;
    *(_BYTE *)(result + 64) = 28;
  }
  return result;
}

//----- (0004D3B0) --------------------------------------------------------
int __cdecl sub_4D3B0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax

  result = sub_4A050();
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 69) = 1;
    *(_BYTE *)(result + 63) = 9;
    *(_BYTE *)(result + 64) = 1;
    *(_WORD *)(result + 130) = 384;
    *(_WORD *)(result + 132) = 384;
    v3 = 4096 / *(__int16 *)(result + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 160) = &unk_D83F0;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_BYTE *)(v2 + 65) = 10;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 209);
    sub_49EA0((_WORD *)v2, 2 * *(_WORD *)(v2 + 84), 5 * *(__int16 *)(v2 + 88) / 2);
    return v2;
  }
  return result;
}

//----- (0004D470) --------------------------------------------------------
int __cdecl sub_4D470(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 2;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 2;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 211);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D500) --------------------------------------------------------
int __cdecl sub_4D500(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 3;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 3;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 76);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D590) --------------------------------------------------------
int __cdecl sub_4D590(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 4;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 4;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 210);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D620) --------------------------------------------------------
int __cdecl sub_4D620(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 5;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 5;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 211);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D6B0) --------------------------------------------------------
int __cdecl sub_4D6B0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 6;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 6;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 212);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D740) --------------------------------------------------------
int __cdecl sub_4D740(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 7;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 7;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 213);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D7D0) --------------------------------------------------------
int __cdecl sub_4D7D0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 8;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 8;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D8434;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 214);
  }
  return v2;
}
// D8434: using guessed type void *off_D8434;

//----- (0004D860) --------------------------------------------------------
int __cdecl sub_4D860(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 9;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 9;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 3584 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D8434;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 216);
    sub_847D0(v2, 128, 9, 0);
  }
  return v2;
}
// D8434: using guessed type void *off_D8434;

//----- (0004D900) --------------------------------------------------------
int __cdecl sub_4D900(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 10;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 10;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 18);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D990) --------------------------------------------------------
int __cdecl sub_4D990(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 11;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 11;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 281);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004DA20) --------------------------------------------------------
int __cdecl sub_4DA20(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 12;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 12;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 2048 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 216);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004DAB0) --------------------------------------------------------
_WORD *__cdecl sub_4DAB0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 13;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 13;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    *(_DWORD *)(v1 + 4) = 5120 / *(__int16 *)(v1 + 130);
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49E10(v2, 195);
  }
  return v2;
}

//----- (0004DBC0) --------------------------------------------------------
_WORD *__cdecl sub_4DBC0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 15;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 14;
    *(_WORD *)(v1 + 130) = 128;
    *(_WORD *)(v1 + 132) = 128;
    *(_DWORD *)(v1 + 4) = 4096 / *(__int16 *)(v1 + 130);
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 196);
  }
  return v2;
}

//----- (0004DC40) --------------------------------------------------------
_WORD *__cdecl sub_4DC40(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 21;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 20;
    *(_WORD *)(v1 + 130) = 394;
    *(_WORD *)(v1 + 132) = *(_WORD *)(v1 + 130);
    *(_DWORD *)(v1 + 4) = 7680 / *(__int16 *)(v1 + 130);
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 196);
  }
  return v2;
}

//----- (0004DCC0) --------------------------------------------------------
_WORD *__cdecl sub_4DCC0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 22;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 21;
    *(_WORD *)(v1 + 130) = 394;
    *(_WORD *)(v1 + 132) = *(_WORD *)(v1 + 130);
    *(_DWORD *)(v1 + 4) = 7680 / *(__int16 *)(v1 + 130);
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 319);
    sub_49EA0(v2, 256, 512);
  }
  return v2;
}

//----- (0004DD50) --------------------------------------------------------
_WORD *__cdecl sub_4DD50(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 80;
    *(_BYTE *)(v1 + 69) = 16;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 15;
    *(_WORD *)(v1 + 130) = 128;
    *(_WORD *)(v1 + 132) = 128;
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 215);
  }
  return v2;
}

//----- (0004DDD0) --------------------------------------------------------
int __cdecl sub_4DDD0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 18;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 17;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 4096 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &unk_D83F0;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 209);
    sub_49EA0((_WORD *)v2, 2 * *(_WORD *)(v2 + 84), 2 * *(_WORD *)(v2 + 88));
  }
  return v2;
}

//----- (0004DEA0) --------------------------------------------------------
int __cdecl sub_4DEA0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 23;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 22;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 211);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004DF30) --------------------------------------------------------
int __cdecl sub_4DF30(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 28;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 27;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 215);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004DFC0) --------------------------------------------------------
int __cdecl sub_4DFC0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // esi
  int v4; // eax

  v1 = sub_4A050();
  v2 = v1;
  v3 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 24;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 23;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v4 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v4;
    BYTE1(v4) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v4) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 211);
  }
  return v3;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004E050) --------------------------------------------------------
int __cdecl sub_4E050(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax
  char v4; // dl

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 25;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 24;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    v4 = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 4) = v3;
    *(_BYTE *)(v2 + 12) = v4 & 0xF7;
    BYTE1(v3) = *(_BYTE *)(v2 + 4);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 4) = BYTE1(v3) & 0xFC;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 281);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004E0F0) --------------------------------------------------------
int __cdecl sub_4E0F0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 26;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 25;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 4096 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &unk_D83F0;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 321);
  }
  return v2;
}

//----- (0004E180) --------------------------------------------------------
int __cdecl sub_4E180(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 27;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 26;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 320);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004E210) --------------------------------------------------------
int __cdecl sub_4E210(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 31;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 30;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    v3 = 0x2000 / *(__int16 *)(v1 + 130);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 4) = v3;
    BYTE1(v3) = *(_BYTE *)(v2 + 12);
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 211);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004E2A0) --------------------------------------------------------
int __cdecl sub_4E2A0(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 30;
    *(_BYTE *)(v1 + 63) = 9;
    *(_BYTE *)(v1 + 64) = 29;
    *(_WORD *)(v1 + 130) = 384;
    *(_WORD *)(v1 + 132) = 384;
    *(_DWORD *)(v1 + 4) = 10;
    v3 = *(_BYTE *)(v1 + 12);
    *(_DWORD *)(v2 + 144) = 50;
    *(_DWORD *)(v2 + 160) = &off_D83CE;
    *(_BYTE *)(v2 + 12) = v3 & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 66);
  }
  return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004E320) --------------------------------------------------------
_WORD *__cdecl sub_4E320(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 8;
    *(_BYTE *)(v1 + 69) = 0;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 0;
    *(_WORD *)(v1 + 42) = 400;
    v3 = *(_DWORD *)(v1 + 12);
    *(_BYTE *)(v1 + 56) = 0;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 14) |= 2u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 7);
    sub_49EA0(v2, 128, 128);
    sub_847D0((int)v2, 128, 7, 1);
  }
  return v2;
}

//----- (0004E3B0) --------------------------------------------------------
_WORD *__cdecl sub_4E3B0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 1;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 1;
    *(_DWORD *)(v1 + 4) = 1;
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 42) = 400;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 14) |= 2u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 41);
    sub_847D0((int)v2, 128, 7, 1);
  }
  return v2;
}

//----- (0004E430) --------------------------------------------------------
int __cdecl sub_4E430(int a1)
{
  int v1; // eax
  int v2; // ebx
  unsigned int v3; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 8;
    *(_BYTE *)(v1 + 69) = 2;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 2;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    v3 = *(_DWORD *)(v1 + 12) & 0xFFFDFFF6;
    *(_DWORD *)(v1 + 16) = 0;
    *(_DWORD *)(v1 + 12) = v3 | 0x20001;
    sub_49A20(v1);
  }
  return v2;
}

//----- (0004E490) --------------------------------------------------------
int __cdecl sub_4E490(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  char v4; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 7;
    *(_BYTE *)(v1 + 69) = 3;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 3;
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 42) = 0;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    v4 = *(_BYTE *)(v1 + 14) | 2;
    *(_DWORD *)(v2 + 16) = 0;
    *(_BYTE *)(v2 + 14) = v4;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 36);
  }
  return v2;
}

//----- (0004E500) --------------------------------------------------------
int __cdecl sub_4E500(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 100;
    *(_BYTE *)(v1 + 69) = 4;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 4;
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 42) = 0;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 14) |= 2u;
    *(_DWORD *)(v1 + 16) = 0;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 80) = sub_10C40((__int16 *)(v1 + 76));
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004E570) --------------------------------------------------------
int __cdecl sub_4E570(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  char v4; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 8;
    *(_BYTE *)(v1 + 69) = 5;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 5;
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 42) = 0;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    v4 = *(_BYTE *)(v1 + 14) | 2;
    *(_DWORD *)(v2 + 16) = 0;
    *(_BYTE *)(v2 + 14) = v4;
    sub_57D70(v2, a1);
    *(_WORD *)(v2 + 80) = sub_10C40((__int16 *)(v2 + 76));
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 244);
  }
  return v2;
}

//----- (0004E5F0) --------------------------------------------------------
int __cdecl sub_4E5F0(__int16 *a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 6;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 6;
    *(_WORD *)(v1 + 42) = 50;
    *(_DWORD *)(v1 + 4) = 240;
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 44) = 0;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 14) |= 2u;
    sub_57D70(v1, (int)a1);
    *(_WORD *)(v2 + 80) = sub_10C40(a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 228);
    sub_49EA0((_WORD *)v2, 272, 1536);
    *(_DWORD *)(v2 + 16) = 0;
    sub_847D0(v2, 80, 11, 1);
  }
  return v2;
}

//----- (0004E6A0) --------------------------------------------------------
int __cdecl sub_4E6A0(__int16 *a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  __int16 v4; // t2

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 7;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 7;
    v3 = *(_DWORD *)(v1 + 12);
    *(_DWORD *)(v1 + 4) = 12;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    LOWORD(v3) = *(_WORD *)(v1 + 20);
    *(_BYTE *)(v1 + 14) |= 2u;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20) % 0x14u;
    *(_BYTE *)(v1 + 65) = 10;
    *(_BYTE *)(v1 + 66) = 7;
    *(_WORD *)(v1 + 130) = v4 + 20;
    sub_57D70(v1, (int)a1);
    *(_WORD *)(v2 + 80) = sub_10C40(a1);
    sub_49DA0((_WORD *)v2, 78);
    sub_49A20(v2);
    *(_BYTE *)(v2 + 12) |= 1u;
  }
  return v2;
}

//----- (0004E760) --------------------------------------------------------
int __cdecl sub_4E760(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 9;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 9;
    *(_DWORD *)(v1 + 4) = 11;
    *(_DWORD *)(v1 + 8) = 17;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 42) = 2000;
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_49EA0((_WORD *)v1, 7, 0x4000);
    *((_BYTE *)&loc_36E03 + dword_D41A0) = 0;
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004E7D0) --------------------------------------------------------
_WORD *__cdecl sub_4E7D0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 10;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 10;
    *(_DWORD *)(v1 + 4) = 1;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 42) = 100;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 14) |= 2u;
    sub_49A20(v1);
    sub_49EA0(v2, 128, 128);
  }
  return v2;
}

//----- (0004E840) --------------------------------------------------------
int __cdecl sub_4E840(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  char v4; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 11;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 11;
    *(_DWORD *)(v1 + 4) = 40;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 42) = 200;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    v4 = *(_BYTE *)(v1 + 14) | 2;
    *(_WORD *)(v2 + 38) = 11;
    *(_BYTE *)(v2 + 14) = v4;
    sub_49A20(v2);
    sub_49EA0((_WORD *)v2, 2304, 0x2000);
  }
  return v2;
}

//----- (0004E8C0) --------------------------------------------------------
int __cdecl sub_4E8C0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 12;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 12;
    *(_DWORD *)(v1 + 4) = 8;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 42) = -1536;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_57D70(v1, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 41);
    *(_BYTE *)(v2 + 12) |= 1u;
    sub_49EA0((_WORD *)v2, 512, 512);
  }
  return v2;
}

//----- (0004E950) --------------------------------------------------------
int __cdecl sub_4E950(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 77;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 70;
    *(_DWORD *)(v1 + 4) = 8;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 42) = -1536;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_57D70(v1, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 41);
    *(_BYTE *)(v2 + 12) |= 1u;
    sub_49EA0((_WORD *)v2, 512, 512);
  }
  return v2;
}

//----- (0004E9E0) --------------------------------------------------------
int __cdecl sub_4E9E0(int a1)
{
  int v1; // eax

  v1 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
  return sub_4EAA0(a1, 13, 13, 67, *(_DWORD *)(v1 + 8) % 0x17u + 17);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004EA20) --------------------------------------------------------
int __cdecl sub_4EA20(int a1)
{
  int v1; // eax

  v1 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
  return sub_4EAA0(a1, 14, 14, 9, *(_DWORD *)(v1 + 8) % 0x21u + 28);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004EA60) --------------------------------------------------------
int __cdecl sub_4EA60(int a1)
{
  int v1; // eax

  v1 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
  return sub_4EAA0(a1, 87, 94, 67, *(_DWORD *)(v1 + 8) % 0x17u + 17);
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004EAA0) --------------------------------------------------------
int __cdecl sub_4EAA0(int a1, char a2, char a3, __int16 a4, int a5)
{
  int v5; // eax
  int v6; // ebx
  unsigned int v7; // edx
  __int16 v8; // t2
  char v9; // ah

  v5 = sub_4A050();
  v6 = v5;
  if ( v5 )
  {
    v7 = *(_DWORD *)(v5 + 12) & 0xFFFDFFF7;
    *(_BYTE *)(v5 + 69) = a3;
    *(_DWORD *)(v5 + 12) = v7;
    *(_BYTE *)(v5 + 64) = a2;
    LOWORD(v7) = *(_WORD *)(v5 + 20);
    *(_DWORD *)(v5 + 4) = a5;
    *(_WORD *)(v5 + 20) = 9377 * v7 + 9439;
    v8 = *(_WORD *)(v5 + 20) % 0x35u;
    *(_BYTE *)(v5 + 63) = 10;
    *(_WORD *)(v5 + 134) = 30;
    *(_BYTE *)(v5 + 65) = 10;
    *(_BYTE *)(v5 + 66) = a2;
    v9 = *(_BYTE *)(v5 + 14);
    *(_WORD *)(v6 + 130) = v8 + 51;
    *(_BYTE *)(v6 + 14) = v9 | 2;
    sub_57D70(v6, a1);
    sub_49DA0((_WORD *)v6, a4);
    sub_49A20(v6);
  }
  return v6;
}

//----- (0004EB50) --------------------------------------------------------
int __cdecl sub_4EB50(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // cx
  char v5; // ah

  if ( sub_4A810() < 32 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = 64;
  *(_BYTE *)(v1 + 63) = 10;
  v3 = *(_WORD *)(v1 + 20);
  *(_BYTE *)(v1 + 64) = 59;
  *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
  v4 = *(_WORD *)(v1 + 20);
  v5 = *(_BYTE *)(v1 + 12) & 0xF6;
  *(_DWORD *)(v2 + 4) = *(unsigned __int16 *)(v2 + 20) % 0x64u + 800;
  *(_BYTE *)(v2 + 12) = v5 | 1;
  *(_WORD *)(v2 + 20) = 9377 * v4 + 9439;
  *(_WORD *)(v2 + 130) = *(_WORD *)(v2 + 20) % 0x11u;
  *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
  *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
  sub_49A20(v2);
  return v2;
}

//----- (0004EC10) --------------------------------------------------------
int __cdecl sub_4EC10(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // cx
  char v5; // ah

  if ( sub_4A810() < 32 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = 65;
  *(_BYTE *)(v1 + 63) = 10;
  v3 = *(_WORD *)(v1 + 20);
  *(_BYTE *)(v1 + 64) = 60;
  *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
  v4 = *(_WORD *)(v1 + 20);
  v5 = *(_BYTE *)(v1 + 12) & 0xF6;
  *(_DWORD *)(v2 + 4) = *(unsigned __int16 *)(v2 + 20) % 0x64u + 800;
  *(_BYTE *)(v2 + 12) = v5 | 1;
  *(_WORD *)(v2 + 20) = 9377 * v4 + 9439;
  *(_WORD *)(v2 + 130) = *(_WORD *)(v2 + 20) % 0x11u;
  *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
  *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
  sub_49A20(v2);
  return v2;
}

//----- (0004ECD0) --------------------------------------------------------
int __cdecl sub_4ECD0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 15;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 15;
    *(_DWORD *)(v1 + 4) = 128;
    *(_WORD *)(v1 + 130) = 256;
    v3 = *(_WORD *)(v1 + 20);
    *(_BYTE *)(v1 + 12) &= ~8u;
    *(_WORD *)(v1 + 42) = 100;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_DWORD *)(v2 + 16) = 0;
    *(_WORD *)(v2 + 28) = v4 & 0x7FF;
    *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
    sub_49A20(v2);
    sub_49EA0((_WORD *)v2, 1024, 0x4000);
  }
  return v2;
}

//----- (0004ED70) --------------------------------------------------------
int __cdecl sub_4ED70(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 17;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 17;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_DWORD *)(v1 + 4) = 10;
    *(_WORD *)(v1 + 42) = 3000;
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_49A20(v1);
  }
  return v2;
}

//----- (0004EDC0) --------------------------------------------------------
int __cdecl sub_4EDC0(__int16 *a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  __int16 v4; // ax
  __int16 v5; // ax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 16;
    *(_BYTE *)(v1 + 63) = 10;
    v3 = *(_DWORD *)(v1 + 12);
    *(_BYTE *)(v1 + 64) = 16;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    LOWORD(v3) = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 42) = 200;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = 9377 * *(_WORD *)(v1 + 20);
    *(_DWORD *)(v2 + 4) = *(unsigned __int16 *)(v2 + 20) % 0x64u + 100;
    *(_WORD *)(v2 + 20) = v4 + 9439;
    LOWORD(v3) = *(_WORD *)(v2 + 20) % 0x32u;
    *(_WORD *)(v2 + 20) = 9377 * *(_WORD *)(v2 + 20) + 9439;
    v5 = *(_WORD *)(v2 + 20);
    *(_WORD *)(v2 + 44) = 256;
    *(_WORD *)(v2 + 28) = v5 & 0x7FF;
    HIBYTE(v5) = *(_BYTE *)(v2 + 14);
    *(_WORD *)(v2 + 130) = v3 + 52;
    *(_BYTE *)(v2 + 14) = HIBYTE(v5) | 2;
    sub_57D70(v2, (int)a1);
    *(_WORD *)(v2 + 80) = sub_10C40(a1) + 64;
    sub_57FA0((_WORD *)(v2 + 154), *(_WORD *)(v2 + 28), 0, *(_WORD *)(v2 + 130));
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 210);
  }
  return v2;
}

//----- (0004EED0) --------------------------------------------------------
int __cdecl sub_4EED0(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 18;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 18;
    *(_WORD *)(v1 + 42) = 200;
    v3 = *(_BYTE *)(v1 + 12);
    *(_DWORD *)(v2 + 16) = 0;
    *(_DWORD *)(v2 + 4) = 10000;
    *(_BYTE *)(v2 + 12) = v3 & 0xF7;
    *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004EF30) --------------------------------------------------------
int __cdecl sub_4EF30(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 98;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 91;
    *(_WORD *)(v1 + 42) = 200;
    v3 = *(_BYTE *)(v1 + 12);
    *(_DWORD *)(v2 + 16) = 0;
    v3 &= 0xF6u;
    *(_DWORD *)(v2 + 4) = 10000;
    *(_BYTE *)(v2 + 12) = v3;
    *(_BYTE *)(v2 + 12) = v3 | 1;
    *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004EF90) --------------------------------------------------------
int __cdecl sub_4EF90(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 19;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 19;
    *(_WORD *)(v1 + 42) = 200;
    v3 = *(_DWORD *)(v1 + 12);
    *(_DWORD *)(v1 + 4) = 240;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 14) |= 2u;
    sub_57D70(v1, a1);
    *(_BYTE *)(v2 + 12) |= 1u;
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 228);
    sub_49EA0((_WORD *)v2, 512, 512);
  }
  return v2;
}

//----- (0004F040) --------------------------------------------------------
_WORD *__cdecl sub_4F040(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax
  __int16 v5; // ax
  int v6; // eax
  int v7; // ecx
  int v9; // [esp+0h] [ebp-10h]
  int v10; // [esp+4h] [ebp-Ch]
  _WORD *v11; // [esp+8h] [ebp-8h]
  int i; // [esp+Ch] [ebp-4h]

  if ( sub_4A810() < 12 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  v11 = (_WORD *)v1;
  if ( !v1 )
    return 0;
  *(_BYTE *)(v1 + 69) = 22;
  *(_BYTE *)(v1 + 63) = 10;
  *(_BYTE *)(v1 + 64) = 22;
  *(_WORD *)(v1 + 44) = 0;
  *(_WORD *)(v1 + 46) = 1;
  *(_BYTE *)(v1 + 60) = 0;
  *(_WORD *)(v1 + 132) = 20;
  *(_WORD *)(v1 + 134) = 10;
  *(_WORD *)(v1 + 130) = 50;
  *(_DWORD *)(v1 + 4) = 500;
  *(_WORD *)(v1 + 42) = 1000;
  v3 = *(_WORD *)(v1 + 20);
  *(_BYTE *)(v1 + 12) &= ~8u;
  *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
  v4 = *(_WORD *)(v1 + 20);
  *(_WORD *)(v2 + 34) = 0;
  *(_BYTE *)(v2 + 56) = 1;
  v5 = (v4 & 0x7FF) - 1;
  *(_WORD *)(v2 + 32) = v5;
  *(_WORD *)(v2 + 28) = v5;
  v10 = v2;
  *(_WORD *)(v2 + 30) = *(_WORD *)(v2 + 32);
  sub_49A20(v2);
  for ( i = 0; i < 11; ++i )
  {
    v6 = sub_4A050();
    v9 = v6;
    if ( v6 )
    {
      qmemcpy((void *)v6, v11, 0xA8u);
      *(_BYTE *)(v6 + 64) = 75;
      v7 = dword_D41A0;
      *(_BYTE *)(v6 + 69) = 82;
      v7 += 28302;
      *(_WORD *)(v6 + 44) = i + 1;
      *(_WORD *)(v6 + 50) = (v10 - v7) / 168;
      *(_WORD *)(v10 + 52) = (v6 - v7) / 168;
      *(_WORD *)(v6 + 52) = 0;
      *(_BYTE *)(v6 + 62) = i;
      sub_57D70(v6, a1);
    }
    v10 = v9;
  }
  sub_57D70((int)v11, a1);
  sub_4F1C0(v11);
  return v11;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004F1C0) --------------------------------------------------------
unsigned __int16 __cdecl sub_4F1C0(_WORD *a1)
{
  _WORD *v1; // ebx
  int v2; // esi
  unsigned __int16 result; // ax
  int v4; // ecx
  unsigned __int16 v5; // di
  int v6; // edi
  int v7; // [esp+0h] [ebp-Ch]
  unsigned __int16 i; // [esp+4h] [ebp-8h]

  v1 = a1;
  v2 = 0;
  result = sub_10C40(a1 + 38);
  for ( i = result; (unsigned int)v1 > dword_EA3E4[0]; v1 = (_WORD *)dword_EA3E4[result] )
  {
    v4 = (__int16)v1[22] + 293;
    v5 = word_D9524[7 * v4];
    v7 = 550 * v5 / 1000;
    v6 = 450 * v5 / 1000;
    sub_49CD0(v1, v4);
    sub_49EA0(v1, v7, v6);
    v1[40] = v2 + i;
    result = v1[26];
    v1[27] = v2;
    v2 += 2 * v6;
  }
  return result;
}
// D9524: using guessed type __int16 word_D9524[];
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0004F2A0) --------------------------------------------------------
_WORD *__cdecl sub_4F2A0(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah
  int v4; // eax
  int v5; // ecx
  int v7; // [esp+0h] [ebp-10h]
  int v8; // [esp+4h] [ebp-Ch]
  int i; // [esp+8h] [ebp-8h]
  _WORD *v10; // [esp+Ch] [ebp-4h]

  v10 = 0;
  if ( sub_4A810() >= 26 )
  {
    v1 = sub_4A050();
    v2 = v1;
    v10 = (_WORD *)v1;
    if ( v1 )
    {
      *(_BYTE *)(v1 + 69) = 83;
      *(_BYTE *)(v1 + 63) = 10;
      *(_BYTE *)(v1 + 64) = 76;
      *(_DWORD *)(v1 + 4) = 80;
      *(_WORD *)(v1 + 42) = 70;
      *(_WORD *)(v1 + 130) = 40;
      *(_WORD *)(v1 + 134) = 192;
      *(_WORD *)(v1 + 132) = 480;
      *(_WORD *)(v1 + 130) = 40;
      v3 = *(_BYTE *)(v1 + 12);
      *(_BYTE *)(v2 + 56) = 1;
      *(_BYTE *)(v2 + 67) = 0;
      *(_BYTE *)(v2 + 68) = 0;
      *(_WORD *)(v2 + 44) = 0;
      *(_BYTE *)(v2 + 61) = 0;
      v8 = v2;
      *(_BYTE *)(v2 + 12) = v3 & 0xF6 | 1;
      sub_49A20(v2);
      for ( i = 0; i < 25; ++i )
      {
        v4 = sub_4A050();
        v7 = v4;
        if ( v4 )
        {
          qmemcpy((void *)v4, v10, 0xA8u);
          v5 = dword_D41A0 + 28302;
          *(_BYTE *)(v4 + 64) = 77;
          *(_BYTE *)(v4 + 69) = 84;
          *(_WORD *)(v4 + 50) = (v8 - v5) / 168;
          *(_WORD *)(v8 + 52) = (v4 - v5) / 168;
          *(_BYTE *)(v4 + 62) = i;
          *(_BYTE *)(v4 + 67) = i / 5;
          *(_WORD *)(v4 + 52) = 0;
          *(_BYTE *)(v4 + 68) = i % 5;
          sub_57D70(v4, a1);
        }
        v8 = v7;
      }
      sub_57D70((int)v10, a1);
      sub_49EA0(v10, 640, 640);
      sub_4F440((int)v10);
    }
  }
  return v10;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0004F440) --------------------------------------------------------
__int16 __cdecl sub_4F440(int a1)
{
  unsigned __int16 v1; // ax
  int v2; // eax
  char v3; // ah
  char v4; // dl
  char v5; // cl
  __int16 v6; // ax
  __int16 v7; // dx
  __int16 v8; // dx
  __int16 v9; // dx
  __int16 v10; // cx
  __int16 v11; // dx
  __int16 v12; // dx
  __int16 v13; // ax
  unsigned int v14; // ebx

  v1 = *(_WORD *)(a1 + 134);
  *(_BYTE *)(a1 + 61) = 18;
  *(_WORD *)(a1 + 44) = v1;
  *(_WORD *)(a1 + 28) = 0;
  v2 = v1;
  LOWORD(v2) = *(_WORD *)(a1 + 52);
  *(_WORD *)(a1 + 30) = 0;
  while ( 1 )
  {
    v14 = dword_EA3E4[v2];
    if ( v14 <= dword_EA3E4[0] )
      return v2;
    v3 = *(_BYTE *)(v14 + 12) & 0xFE;
    v4 = *(_BYTE *)(v14 + 68);
    *(_BYTE *)(v14 + 12) = v3;
    if ( v4 )
    {
      v5 = *(_BYTE *)(v14 + 12) & 0xF7;
      *(_BYTE *)(v14 + 14) |= 0x80u;
      *(_BYTE *)(v14 + 12) = v5;
    }
    else
    {
      *(_BYTE *)(v14 + 12) = v3 | 8;
    }
    *(_WORD *)(v14 + 20) = 9377 * *(_WORD *)(v14 + 20) + 9439;
    v6 = (*(_WORD *)(v14 + 20) & 0x3F) + 84;
    switch ( *(_BYTE *)(v14 + 67) )
    {
      case 0:
        v7 = *(char *)(v14 + 68);
        *(_WORD *)(v14 + 30) = 0;
        *(_WORD *)(v14 + 34) = 0;
        v8 = 512 - 96 * v7;
        *(_WORD *)(v14 + 32) = v6;
        HIBYTE(v8) &= 7u;
        *(_WORD *)(v14 + 28) = v8;
        break;
      case 1:
        v9 = 96 * *(char *)(v14 + 68);
        v10 = 512;
        *(_WORD *)(v14 + 28) = 512;
        goto LABEL_11;
      case 2:
        v11 = *(char *)(v14 + 68);
        *(_WORD *)(v14 + 28) = 0;
        *(_WORD *)(v14 + 32) = 0;
        v12 = -96 * v11;
        goto LABEL_12;
      case 3:
        v9 = 96 * *(char *)(v14 + 68);
        v10 = 256;
        *(_WORD *)(v14 + 28) = 256;
        goto LABEL_11;
      case 4:
        v9 = 96 * *(char *)(v14 + 68);
        v10 = 768;
        *(_WORD *)(v14 + 28) = 768;
LABEL_11:
        *(_WORD *)(v14 + 32) = 0;
        v12 = v10 - v9;
LABEL_12:
        *(_WORD *)(v14 + 34) = v6;
        HIBYTE(v12) &= 7u;
        *(_WORD *)(v14 + 30) = v12;
        break;
      default:
        break;
    }
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v13 = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(v14 + 28), *(_WORD *)(v14 + 30), *(_WORD *)(a1 + 44));
    sub_57CF0(v13, v14, (int)&word_EB398);
    sub_49CD0((_WORD *)v14, 340);
    sub_847D0(v14, 128, 1, 0);
    v2 = *(unsigned __int16 *)(v14 + 52);
  }
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (0004F5F0) --------------------------------------------------------
int __cdecl sub_4F5F0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 8;
    *(_BYTE *)(v1 + 69) = 23;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 23;
    v3 = *(_DWORD *)(v1 + 12);
    *(_WORD *)(v1 + 42) = 25;
    *(_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
    *(_BYTE *)(v1 + 14) |= 2u;
    sub_57D70(v1, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 7);
    sub_49EA0((_WORD *)v2, 200, 200);
    *(_BYTE *)(v2 + 12) |= 1u;
    sub_847D0(v2, 128, 9, 0);
  }
  return v2;
}

//----- (0004F6A0) --------------------------------------------------------
_WORD *__cdecl sub_4F6A0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 25;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 25;
    *(_DWORD *)(v1 + 4) = 8;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 42) = 2000;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49EA0(v2, 512, 512);
  }
  return v2;
}

//----- (0004F720) --------------------------------------------------------
_WORD *__cdecl sub_4F720(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 26;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 26;
    *(_DWORD *)(v1 + 4) = 8;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 42) = 200;
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 213);
    sub_49EA0(v2, 512, 512);
  }
  return v2;
}

//----- (0004F7A0) --------------------------------------------------------
int __cdecl sub_4F7A0(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 2;
    *(_BYTE *)(v1 + 69) = 27;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 27;
    *(_WORD *)(v1 + 42) = (*(__int16 *)(a1 + 4) >> 5) + 48;
    v3 = *(_BYTE *)(v1 + 12);
    *(_DWORD *)(v2 + 16) = 10;
    *(_BYTE *)(v2 + 12) = v3 & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004F800) --------------------------------------------------------
int __cdecl sub_4F800(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 69) = 30;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 28;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004F860) --------------------------------------------------------
int __cdecl sub_4F860(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 52;
    *(_BYTE *)(v1 + 69) = 66;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 61;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004F8B0) --------------------------------------------------------
int __cdecl sub_4F8B0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 52;
    *(_BYTE *)(v1 + 69) = 67;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 62;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004F900) --------------------------------------------------------
int __cdecl sub_4F900(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 1;
    *(_BYTE *)(v1 + 69) = 68;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 63;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004F950) --------------------------------------------------------
int __cdecl sub_4F950(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 1;
    *(_BYTE *)(v1 + 69) = 69;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 64;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004F9A0) --------------------------------------------------------
int __cdecl sub_4F9A0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 69) = 32;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 30;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004FA00) --------------------------------------------------------
int __cdecl sub_4FA00(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 69) = 31;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 29;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004FA60) --------------------------------------------------------
int __cdecl sub_4FA60(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 69) = 34;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 32;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    v3 = *(_BYTE *)(v1 + 12);
    *(_WORD *)(v2 + 130) = 256;
    *(_BYTE *)(v2 + 70) = 2;
    *(_BYTE *)(v2 + 12) = v3 & 0xF7;
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004FAC0) --------------------------------------------------------
int __cdecl sub_4FAC0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 69) = 33;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 31;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004FB20) --------------------------------------------------------
int __cdecl sub_4FB20(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // dl

  if ( !byte_D41B6 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_DWORD *)(v1 + 4) = 0;
  *(_BYTE *)(v1 + 69) = 88;
  *(_BYTE *)(v1 + 63) = 10;
  *(_BYTE *)(v1 + 64) = 81;
  *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
  *(_WORD *)(v1 + 130) = 256;
  v3 = *(_BYTE *)(v1 + 12);
  *(_BYTE *)(v1 + 70) = 2;
  *(_BYTE *)(v1 + 12) = v3 & 0xF7;
  sub_49A20(v1);
  return v2;
}
// D41B6: using guessed type char byte_D41B6;

//----- (0004FB80) --------------------------------------------------------
int __cdecl sub_4FB80(int a1)
{
  int v1; // eax
  int v2; // ebx

  if ( !byte_D41B6 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  *(_DWORD *)(v1 + 4) = 0;
  *(_BYTE *)(v1 + 69) = 87;
  *(_BYTE *)(v1 + 63) = 10;
  *(_BYTE *)(v1 + 64) = 80;
  *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
  *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
  *(_BYTE *)(v1 + 12) &= ~8u;
  sub_57D70(v1, a1);
  sub_49A20(v2);
  return v2;
}
// D41B6: using guessed type char byte_D41B6;

//----- (0004FBE0) --------------------------------------------------------
int __cdecl sub_4FBE0(int a1)
{
  int result; // eax

  if ( !byte_D41B6 )
    return 0;
  result = sub_4A050();
  if ( !result )
    return 0;
  *(_DWORD *)(result + 4) = 0;
  *(_BYTE *)(result + 69) = 89;
  *(_BYTE *)(result + 63) = 10;
  *(_BYTE *)(result + 64) = 82;
  *(_DWORD *)(result + 76) = *(_DWORD *)a1;
  *(_WORD *)(result + 80) = *(_WORD *)(a1 + 4);
  *(_BYTE *)(result + 70) = 2;
  *(_BYTE *)(result + 67) = 3;
  *(_BYTE *)(result + 68) = 3;
  return result;
}
// D41B6: using guessed type char byte_D41B6;

//----- (0004FC30) --------------------------------------------------------
int __cdecl sub_4FC30(int a1)
{
  int result; // eax
  char v2; // dl

  if ( !byte_D41B6 )
    return 0;
  result = sub_4A050();
  if ( !result )
    return 0;
  *(_DWORD *)(result + 8) = 16;
  *(_BYTE *)(result + 69) = 90;
  *(_BYTE *)(result + 63) = 10;
  *(_BYTE *)(result + 64) = 83;
  *(_DWORD *)(result + 76) = *(_DWORD *)a1;
  *(_WORD *)(result + 80) = *(_WORD *)(a1 + 4);
  *(_BYTE *)(result + 70) = 0;
  *(_WORD *)(result + 154) = 2;
  v2 = *(_BYTE *)(result + 12);
  *(_WORD *)(result + 158) = 0;
  v2 |= 1u;
  *(_BYTE *)(result + 12) = v2;
  *(_WORD *)(result + 80) = 0;
  *(_BYTE *)(result + 12) = v2 & 0xF7;
  return result;
}
// D41B6: using guessed type char byte_D41B6;

//----- (0004FCA0) --------------------------------------------------------
int __cdecl sub_4FCA0(int a1)
{
  int result; // eax

  result = sub_4FD00(a1);
  if ( result )
  {
    *(_BYTE *)(result + 69) = 91;
    *(_BYTE *)(result + 64) = 84;
  }
  return result;
}

//----- (0004FCD0) --------------------------------------------------------
int __cdecl sub_4FCD0(int a1)
{
  int result; // eax

  result = sub_4FD00(a1);
  if ( result )
  {
    *(_BYTE *)(result + 69) = 92;
    *(_BYTE *)(result + 64) = 85;
  }
  return result;
}

//----- (0004FD00) --------------------------------------------------------
int __cdecl sub_4FD00(int a1)
{
  int v1; // edx
  int v2; // eax
  char v3; // bl

  v1 = 0;
  if ( byte_D41B6 )
  {
    v2 = sub_4A050();
    v1 = v2;
    if ( v2 )
    {
      *(_DWORD *)(v2 + 8) = 16;
      *(_BYTE *)(v2 + 63) = 10;
      *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
      *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
      *(_BYTE *)(v2 + 70) = 0;
      *(_WORD *)(v2 + 154) = 2;
      v3 = *(_BYTE *)(v2 + 12);
      *(_WORD *)(v2 + 158) = 0;
      v3 |= 1u;
      *(_BYTE *)(v2 + 12) = v3;
      *(_WORD *)(v2 + 80) = 0;
      *(_BYTE *)(v2 + 12) = v3 & 0xF7;
    }
  }
  return v1;
}
// D41B6: using guessed type char byte_D41B6;

//----- (0004FD70) --------------------------------------------------------
int __cdecl sub_4FD70(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 69) = 55;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 51;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    v3 = *(_BYTE *)(v1 + 12);
    *(_DWORD *)(v2 + 16) = 256;
    *(_WORD *)(v2 + 130) = 1024;
    *(_BYTE *)(v2 + 12) = v3 & 0xF7;
    sub_49EA0((_WORD *)v2, 768, 768);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004FDE0) --------------------------------------------------------
int __cdecl sub_4FDE0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 69) = 54;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 50;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_57D70(v1, a1);
    sub_49A20(v2);
  }
  return v2;
}

//----- (0004FE40) --------------------------------------------------------
_WORD *__cdecl sub_4FE40(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 36;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 34;
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 65) = 3;
    *(_BYTE *)(v1 + 66) = -1;
    *(_BYTE *)(v1 + 12) &= ~8u;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    sub_49CD0((_WORD *)v1, 223);
    sub_49EA0(v2, 256, 256);
    sub_49A20((int)v2);
    sub_57D70((int)v2, a1);
    v2[40] = sub_10C40(v2 + 38) + 640;
    *(_DWORD *)(v2 + 77) = *((_DWORD *)v2 + 19);
    v2[79] = v2[40];
    v2[10] = 9377 * v2[10] + 9439;
    sub_57FA0(v2 + 77, v2[10] & 0x7FF, 0, -32768);
  }
  return v2;
}

//----- (0004FF20) --------------------------------------------------------
int sub_4FF20()
{
  return sub_4A050();
}

//----- (0004FF30) --------------------------------------------------------
_WORD *__cdecl sub_4FF30(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 38;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 36;
    *(_DWORD *)(v1 + 4) = 8;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v1 + 42) = -1536;
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 41);
    sub_49EA0(v2, 512, 512);
  }
  return v2;
}

//----- (0004FFB0) --------------------------------------------------------
int __cdecl sub_4FFB0(int a1)
{
  _BYTE *v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = (_BYTE *)sub_4A050();
  v2 = (int)v1;
  if ( v1 )
  {
    v1[69] = 40;
    v1[63] = 10;
    v1[64] = 38;
    v3 = v1[12] & 0xF7;
    *(_DWORD *)(v2 + 4) = 32;
    *(_BYTE *)(v2 + 12) = v3;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 272);
    sub_49EA0((_WORD *)v2, 512, 512);
  }
  return v2;
}

//----- (00050020) --------------------------------------------------------
_WORD *__cdecl sub_50020(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 35;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 33;
    *(_BYTE *)(v1 + 12) &= ~8u;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    sub_49A20(v1);
    sub_49EA0(v2, 512, 512);
  }
  return v2;
}

//----- (00050080) --------------------------------------------------------
int __cdecl sub_50080(int a1)
{
  return sub_500C0(a1, 512);
}

//----- (000500A0) --------------------------------------------------------
int __cdecl sub_500A0(int a1)
{
  return sub_500C0(a1, 2560);
}

//----- (000500C0) --------------------------------------------------------
int __cdecl sub_500C0(int a1, __int16 a2)
{
  int result; // eax
  int v3; // ebx

  result = sub_4A050();
  v3 = result;
  if ( result )
  {
    *(_BYTE *)(result + 69) = 41;
    *(_BYTE *)(result + 63) = 10;
    *(_BYTE *)(result + 64) = 39;
    *(_BYTE *)(result + 65) = 10;
    *(_BYTE *)(result + 66) = 39;
    *(_WORD *)(result + 44) = 128;
    *(_WORD *)(result + 130) = 32;
    *(_BYTE *)(result + 56) = 3;
    *(_BYTE *)(result + 57) = 0x80;
    *(_BYTE *)(result + 58) = 0;
    *(_DWORD *)(result + 144) = a2;
    sub_57D70(result, a1);
    sub_49A20(v3);
    sub_36920(v3, v3);
    return v3;
  }
  return result;
}

//----- (00050130) --------------------------------------------------------
int __cdecl sub_50130(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  unsigned int v4; // et2
  char v5; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 62;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 57;
    *(_BYTE *)(v1 + 65) = 10;
    *(_BYTE *)(v1 + 66) = 57;
    v3 = *(_WORD *)(v1 + 20);
    *(_WORD *)(v1 + 44) = 128;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(unsigned __int16 *)(v1 + 20) % 0x7D0u;
    *(_WORD *)(v1 + 130) = 0;
    *(_BYTE *)(v1 + 56) = 3;
    *(_BYTE *)(v1 + 57) = 0x80;
    *(_BYTE *)(v1 + 58) = 0;
    *(_BYTE *)(v1 + 67) = 10;
    *(_DWORD *)(v1 + 144) = v4;
    v5 = *(_BYTE *)(v1 + 14);
    *(_BYTE *)(v2 + 68) = 1;
    *(_BYTE *)(v2 + 14) = v5 | 2;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_36920(v2, v2);
  }
  return v2;
}

//----- (000501D0) --------------------------------------------------------
_WORD *__cdecl sub_501D0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    v3 = dword_D41A0;
    *(_BYTE *)(v1 + 69) = 42;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 40;
    *(_DWORD *)(v1 + 16) = (v1 - (v3 + 28302)) / 168 % 11;
    *(_BYTE *)(v1 + 56) = 2;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49DA0(v2, 65);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00050250) --------------------------------------------------------
_WORD *__cdecl sub_50250(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 30;
    *(_BYTE *)(v1 + 69) = 51;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 45;
    *(_WORD *)(v1 + 42) = 100;
    *(_DWORD *)(v1 + 16) = 4;
    *(_DWORD *)(v1 + 12) = 9;
    *(_BYTE *)(v1 + 56) = 33;
    sub_57D70(v1, a1);
    sub_49CD0(v2, 177);
  }
  return v2;
}

//----- (000502B0) --------------------------------------------------------
_WORD *__cdecl sub_502B0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 45;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 43;
    *(_DWORD *)(v1 + 4) = 8;
    *(_WORD *)(v1 + 42) = -1536;
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 41);
    sub_49EA0(v2, 512, 512);
  }
  return v2;
}

//----- (00050320) --------------------------------------------------------
int __cdecl sub_50320(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 43;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 41;
    *(_DWORD *)(v1 + 4) = 0;
    *(_BYTE *)(v1 + 12) &= ~8u;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    sub_49A20(v1);
  }
  return v2;
}

//----- (00050370) --------------------------------------------------------
int __cdecl sub_50370(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 44;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 42;
    *(_DWORD *)(v1 + 4) = 0;
    v3 = *(_BYTE *)(v1 + 12) & 0xF6;
    *(_BYTE *)(v2 + 12) = v3;
    *(_BYTE *)(v2 + 12) = v3 | 1;
    *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v2 + 59) = 1;
    sub_49A20(v2);
  }
  return v2;
}

//----- (000503D0) --------------------------------------------------------
_WORD *__cdecl sub_503D0(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 46;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 44;
    *(_DWORD *)(v1 + 4) = 500;
    *(_WORD *)(v1 + 42) = 500;
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 8);
  }
  return v2;
}

//----- (00050430) --------------------------------------------------------
_WORD *__cdecl sub_50430(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 56;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 52;
    *(_DWORD *)(v1 + 4) = 100000;
    *(_WORD *)(v1 + 42) = 500;
    *(_DWORD *)(v1 + 16) = 600;
    *(_DWORD *)(v1 + 144) = 500;
    *(_DWORD *)(v1 + 140) = 2000;
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 205);
  }
  return v2;
}

//----- (000504B0) --------------------------------------------------------
int __cdecl sub_504B0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 58;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 53;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_DWORD *)(v1 + 4) = 6;
    *(_WORD *)(v1 + 42) = 3000;
    *(_BYTE *)(v1 + 12) &= ~8u;
    sub_49A20(v1);
  }
  return v2;
}

//----- (00050500) --------------------------------------------------------
int __cdecl sub_50500(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 59;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 54;
    *(_DWORD *)(v1 + 4) = 128;
    *(_WORD *)(v1 + 130) = 256;
    v3 = *(_WORD *)(v1 + 20);
    *(_BYTE *)(v1 + 12) &= ~8u;
    *(_WORD *)(v1 + 42) = 100;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_DWORD *)(v2 + 16) = 12845056;
    *(_WORD *)(v2 + 28) = v4 & 0x7FF;
    *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v2 + 12) |= 1u;
    sub_49A20(v2);
    sub_49EA0((_WORD *)v2, 1024, 0x4000);
  }
  return v2;
}

//----- (000505A0) --------------------------------------------------------
int __cdecl sub_505A0(int a1)
{
  int result; // eax

  result = sub_505E0(a1);
  if ( result )
  {
    *(_BYTE *)(result + 64) = 68;
    *(_BYTE *)(result + 69) = 75;
  }
  return result;
}

//----- (000505E0) --------------------------------------------------------
int __cdecl sub_505E0(int a1)
{
  int v1; // eax
  int v2; // ebx

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 63) = 10;
    *(_WORD *)(v1 + 130) = 64;
    *(_DWORD *)(v1 + 16) = 12845056;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    sub_49EA0((_WORD *)v1, 256, 256);
  }
  return v2;
}

//----- (00050640) --------------------------------------------------------
int __cdecl sub_50640(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 60;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 55;
    *(_DWORD *)(v1 + 4) = 19;
    *(_WORD *)(v1 + 130) = 256;
    v3 = *(_WORD *)(v1 + 20);
    *(_BYTE *)(v1 + 12) &= ~8u;
    *(_WORD *)(v1 + 42) = 100;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_DWORD *)(v2 + 16) = 32;
    *(_WORD *)(v2 + 28) = v4 & 0x7FF;
    *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v2 + 12) |= 1u;
    sub_49A20(v2);
    sub_49EA0((_WORD *)v2, 1024, 0x4000);
  }
  return v2;
}

//----- (000506E0) --------------------------------------------------------
int __cdecl sub_506E0(int a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // dx
  __int16 v4; // ax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 61;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 56;
    *(_DWORD *)(v1 + 4) = 128;
    *(_WORD *)(v1 + 130) = 256;
    v3 = *(_WORD *)(v1 + 20);
    *(_BYTE *)(v1 + 12) &= ~8u;
    *(_WORD *)(v1 + 42) = 100;
    *(_WORD *)(v1 + 20) = 9377 * v3 + 9439;
    v4 = *(_WORD *)(v1 + 20);
    *(_DWORD *)(v2 + 16) = 0;
    *(_WORD *)(v2 + 28) = v4 & 0x7FF;
    *(_DWORD *)(v2 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v2 + 80) = *(_WORD *)(a1 + 4);
    *(_BYTE *)(v2 + 12) |= 1u;
    sub_49A20(v2);
    sub_49EA0((_WORD *)v2, 1024, 0x4000);
  }
  return v2;
}

//----- (00050780) --------------------------------------------------------
int __cdecl sub_50780(int a1)
{
  int result; // eax
  char v2; // dl

  result = sub_4A050();
  if ( result )
  {
    *(_BYTE *)(result + 69) = 70;
    v2 = *(_BYTE *)(result + 12);
    *(_BYTE *)(result + 63) = 10;
    v2 &= 0xF6u;
    *(_BYTE *)(result + 12) = v2;
    *(_BYTE *)(result + 64) = 65;
    *(_BYTE *)(result + 12) = v2 | 1;
    *(_DWORD *)(result + 76) = *(_DWORD *)a1;
    *(_WORD *)(result + 80) = *(_WORD *)(a1 + 4);
  }
  return result;
}

//----- (000507C0) --------------------------------------------------------
int __cdecl sub_507C0(int a1)
{
  int result; // eax
  char v2; // dl

  result = sub_4A050();
  if ( result )
  {
    *(_BYTE *)(result + 69) = 71;
    v2 = *(_BYTE *)(result + 12);
    *(_BYTE *)(result + 63) = 10;
    v2 &= 0xF6u;
    *(_BYTE *)(result + 12) = v2;
    *(_BYTE *)(result + 64) = 66;
    *(_BYTE *)(result + 12) = v2 | 1;
    *(_DWORD *)(result + 76) = *(_DWORD *)a1;
    *(_WORD *)(result + 80) = *(_WORD *)(a1 + 4);
    *(_WORD *)(result + 42) = 200;
  }
  return result;
}

//----- (00050800) --------------------------------------------------------
_BYTE *sub_50800()
{
  _BYTE *result; // eax
  char v1; // bl

  result = (_BYTE *)sub_4A050();
  if ( result )
  {
    result[69] = 81;
    v1 = result[12];
    result[63] = 10;
    v1 &= 0xF6u;
    result[12] = v1;
    result[64] = 74;
    result[12] = v1 | 1;
  }
  return result;
}

//----- (00050840) --------------------------------------------------------
_WORD *__cdecl sub_50840(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // edx

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 1000;
    *(_BYTE *)(v1 + 69) = 85;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 78;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    v3 = dword_D41A0 + 28302;
    *(_BYTE *)(v1 + 12) |= 8u;
    *(_WORD *)(v1 + 42) = 0;
    *(_BYTE *)(v1 + 70) = 0;
    *(_WORD *)(v1 + 54) = -1;
    *(_BYTE *)(v1 + 61) = 1;
    *(_BYTE *)(v1 + 67) = 1;
    *(_BYTE *)(v1 + 68) = 0;
    *(_WORD *)(v1 + 50) = (v1 - v3) / 168;
    sub_57D70(v1, a1);
    sub_49A20((int)v2);
    sub_49CD0(v2, 66);
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (000508E0) --------------------------------------------------------
int __cdecl sub_508E0(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // ah

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 100000;
    *(_BYTE *)(v1 + 69) = 86;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 79;
    *(_DWORD *)(v1 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v1 + 80) = *(_WORD *)(a1 + 4);
    v3 = *(_BYTE *)(v1 + 12);
    *(_BYTE *)(v2 + 70) = 0;
    *(_BYTE *)(v2 + 67) = 0;
    *(_WORD *)(v2 + 44) = 0;
    *(_BYTE *)(v2 + 61) = 1;
    *(_WORD *)(v2 + 54) = 0;
    *(_BYTE *)(v2 + 12) = v3 & 0xF7;
    sub_57D70(v2, a1);
    sub_49A20(v2);
    sub_49CD0((_WORD *)v2, 66);
  }
  return v2;
}

//----- (00050960) --------------------------------------------------------
int __cdecl sub_50960(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // edx
  __int16 v5; // ax
  __int16 v6; // ax

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 9;
    v3 = *(_DWORD *)(v1 + 4);
    *(_BYTE *)(v2 + 69) = 93;
    v4 = *(_DWORD *)(v2 + 12);
    *(_BYTE *)(v2 + 63) = 10;
    *(_DWORD *)(v2 + 8) = v3;
    *(_DWORD *)(v2 + 12) = v4 & 0xFFFDFFF7;
    BYTE1(v3) = *(_BYTE *)(v2 + 14);
    *(_BYTE *)(v2 + 64) = 86;
    *(_BYTE *)(v2 + 14) = BYTE1(v3) | 2;
    sub_57D70(v2, a1);
    v5 = sub_10C40((__int16 *)(v2 + 76));
    LOWORD(v4) = *(_WORD *)(v2 + 20);
    *(_WORD *)(v2 + 80) = v5;
    *(_WORD *)(v2 + 20) = 9377 * v4 + 9439;
    sub_49CD0((_WORD *)v2, *(_WORD *)(v2 + 20) % 3u + 332);
    v6 = sub_104A0(v2 + 76);
    if ( (v6 & 1) == 0 )
    {
      sub_57F20(v6, v2);
      return 0;
    }
  }
  return v2;
}

//----- (00050A20) --------------------------------------------------------
int __cdecl sub_50A20(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // dl

  if ( *(_BYTE *)(dword_D41A0 + 196308) != 2 )
    return 0;
  v1 = sub_4A050();
  v2 = v1;
  if ( !v1 )
    return 0;
  v3 = *(_BYTE *)(v1 + 12) & 0xF6;
  *(_BYTE *)(v1 + 12) = v3;
  *(_BYTE *)(v1 + 69) = 96;
  *(_BYTE *)(v1 + 12) = v3 | 1;
  *(_BYTE *)(v1 + 63) = 10;
  *(_BYTE *)(v1 + 64) = 89;
  *(_DWORD *)(v1 + 8) = 40;
  sub_57D70(v1, a1);
  return v2;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00050A90) --------------------------------------------------------
int __cdecl sub_50A90(int a1, char a2, char a3)
{
  int v3; // eax
  int v4; // ebx
  char v5; // dl

  v3 = sub_4A050();
  v4 = v3;
  if ( v3 )
  {
    *(_BYTE *)(v3 + 63) = 11;
    *(_BYTE *)(v3 + 64) = a2;
    *(_BYTE *)(v3 + 69) = a3;
    *(_BYTE *)(v3 + 12) &= 0xF6u;
    v5 = *(_BYTE *)(v3 + 12);
    *(_DWORD *)(v3 + 16) = 0;
    *(_BYTE *)(v3 + 12) = v5 | 1;
    *(_DWORD *)(v3 + 76) = *(_DWORD *)a1;
    *(_WORD *)(v3 + 80) = *(_WORD *)(a1 + 4);
    sub_49A20(v3);
  }
  return v4;
}

//----- (00050AE0) --------------------------------------------------------
int __cdecl sub_50AE0(int a1)
{
  return sub_50A90(a1, 0, 0);
}

//----- (00050B00) --------------------------------------------------------
int __cdecl sub_50B00(int a1)
{
  return sub_50A90(a1, 1, 1);
}

//----- (00050B20) --------------------------------------------------------
int __cdecl sub_50B20(int a1)
{
  return sub_50A90(a1, 2, 2);
}

//----- (00050B40) --------------------------------------------------------
int __cdecl sub_50B40(int a1)
{
  return sub_50A90(a1, 3, 3);
}

//----- (00050B60) --------------------------------------------------------
int __cdecl sub_50B60(int a1)
{
  return sub_50A90(a1, 4, 4);
}

//----- (00050B80) --------------------------------------------------------
int __cdecl sub_50B80(int a1)
{
  return sub_50A90(a1, 32, 32);
}

//----- (00050C10) --------------------------------------------------------
int __cdecl sub_50C10(int a1)
{
  return sub_50A90(a1, 12, 12);
}

//----- (00050C30) --------------------------------------------------------
int __cdecl sub_50C30(int a1)
{
  return sub_50A90(a1, 13, 13);
}

//----- (00050C50) --------------------------------------------------------
int __cdecl sub_50C50(int a1)
{
  return sub_50A90(a1, 14, 14);
}

//----- (00050C70) --------------------------------------------------------
int __cdecl sub_50C70(int a1)
{
  return sub_50A90(a1, 15, 15);
}

//----- (00050C90) --------------------------------------------------------
int __cdecl sub_50C90(int a1)
{
  return sub_50A90(a1, 16, 16);
}

//----- (00050CB0) --------------------------------------------------------
int __cdecl sub_50CB0(int a1)
{
  return sub_50A90(a1, 17, 17);
}

//----- (00050CD0) --------------------------------------------------------
int __cdecl sub_50CD0(int a1)
{
  return sub_50A90(a1, 18, 18);
}

//----- (00050CF0) --------------------------------------------------------
int __cdecl sub_50CF0(int a1)
{
  return sub_50A90(a1, 19, 19);
}

//----- (00050D10) --------------------------------------------------------
int __cdecl sub_50D10(int a1)
{
  return sub_50A90(a1, 20, 20);
}

//----- (00050D30) --------------------------------------------------------
int __cdecl sub_50D30(int a1)
{
  return sub_50A90(a1, 21, 21);
}

//----- (00050D50) --------------------------------------------------------
int __cdecl sub_50D50(int a1)
{
  return sub_50A90(a1, 22, 22);
}

//----- (00050D70) --------------------------------------------------------
int __cdecl sub_50D70(int a1)
{
  return sub_50A90(a1, 23, 23);
}

//----- (00050D90) --------------------------------------------------------
int __cdecl sub_50D90(int a1)
{
  return sub_50A90(a1, 24, 24);
}

//----- (00050DB0) --------------------------------------------------------
int __cdecl sub_50DB0(int a1)
{
  return sub_50A90(a1, 25, 25);
}

//----- (00050DD0) --------------------------------------------------------
int __cdecl sub_50DD0(int a1)
{
  return sub_50A90(a1, 26, 26);
}

//----- (00050DF0) --------------------------------------------------------
int __cdecl sub_50DF0(int a1)
{
  return sub_50A90(a1, 27, 27);
}

//----- (00050E10) --------------------------------------------------------
int __cdecl sub_50E10(int a1)
{
  return sub_50A90(a1, 28, 28);
}

//----- (00050E30) --------------------------------------------------------
int __cdecl sub_50E30(int a1)
{
  return sub_50A90(a1, 29, 29);
}

//----- (00050E50) --------------------------------------------------------
int __cdecl sub_50E50(int a1)
{
  return sub_50A90(a1, 33, 33);
}

//----- (00050E70) --------------------------------------------------------
int __cdecl sub_50E70(int a1)
{
  return sub_50A90(a1, 34, 34);
}

//----- (00050E90) --------------------------------------------------------
int __cdecl sub_50E90(int a1)
{
  return sub_50A90(a1, 35, 35);
}

//----- (00050EB0) --------------------------------------------------------
int __cdecl sub_50EB0(int a1)
{
  return sub_50A90(a1, 36, 36);
}

//----- (00050ED0) --------------------------------------------------------
int __cdecl sub_50ED0(int a1)
{
  return sub_50A90(a1, 37, 37);
}

//----- (00050EF0) --------------------------------------------------------
int __cdecl sub_50EF0(int a1)
{
  return sub_50A90(a1, 38, 38);
}

//----- (00050F10) --------------------------------------------------------
int __cdecl sub_50F10(int a1)
{
  return sub_50A90(a1, 39, 39);
}

//----- (00050F30) --------------------------------------------------------
int __cdecl sub_50F30(int a1)
{
  return sub_50A90(a1, 40, 40);
}

//----- (00050F50) --------------------------------------------------------
int __cdecl sub_50F50(int a1)
{
  return sub_50A90(a1, 41, 41);
}

//----- (00050F70) --------------------------------------------------------
int __cdecl sub_50F70(int a1)
{
  return sub_50A90(a1, 42, 42);
}

//----- (00050F90) --------------------------------------------------------
int __cdecl sub_50F90(int a1)
{
  return sub_50A90(a1, 43, 43);
}

//----- (00050FB0) --------------------------------------------------------
int __cdecl sub_50FB0(int a1)
{
  return sub_50A90(a1, 44, 44);
}

//----- (00050FD0) --------------------------------------------------------
int __cdecl sub_50FD0(int a1)
{
  return sub_50A90(a1, 30, 30);
}

//----- (00050FF0) --------------------------------------------------------
int __cdecl sub_50FF0(int a1)
{
  int v1; // edx
  int v2; // eax
  char v3; // cl

  v1 = 0;
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) == 0 && (*(_BYTE *)(dword_D41A4 + 38545) & 8) == 0 )
  {
    v1 = sub_50A90(a1, 31, 31);
    if ( v1 )
    {
      v2 = dword_D41A0;
      v3 = *(_BYTE *)(dword_D41A0 + 224779);
      *(_BYTE *)(dword_D41A0 + 224770) = 1;
      *(_BYTE *)(v2 + 224779) = v3 | 1;
    }
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00051120) --------------------------------------------------------
int __cdecl sub_51120(int a1, char a2, char a3)
{
  int v3; // eax
  int v4; // ebx
  int v5; // esi
  char v6; // ah

  v3 = sub_4A050();
  v4 = v3;
  v5 = v3;
  if ( v3 )
  {
    *(_BYTE *)(v3 + 63) = 15;
    *(_DWORD *)(v3 + 4) = 0;
    *(_BYTE *)(v3 + 64) = a2;
    *(_BYTE *)(v3 + 69) = a3;
    v6 = *(_BYTE *)(v3 + 12);
    *(_DWORD *)(v4 + 8) = 0;
    *(_BYTE *)(v4 + 12) = v6 & 0xF7;
    sub_57D70(v4, a1);
    sub_49CD0((_WORD *)v4, 77);
    sub_49EA0((_WORD *)v4, 768, 1280);
    sub_49A20(v4);
    sub_6D5E0(v4, 0);
  }
  return v5;
}

//----- (000511A0) --------------------------------------------------------
int __cdecl sub_511A0(int a1)
{
  return sub_51120(a1, 0, 0);
}

//----- (000511C0) --------------------------------------------------------
int __cdecl sub_511C0(int a1)
{
  return sub_51120(a1, 1, 3);
}

//----- (000511E0) --------------------------------------------------------
int __cdecl sub_511E0(int a1)
{
  return sub_51120(a1, 2, 6);
}

//----- (00051200) --------------------------------------------------------
int __cdecl sub_51200(int a1)
{
  return sub_51120(a1, 3, 9);
}

//----- (00051220) --------------------------------------------------------
int __cdecl sub_51220(int a1)
{
  return sub_51120(a1, 4, 12);
}

//----- (00051240) --------------------------------------------------------
int __cdecl sub_51240(int a1)
{
  return sub_51120(a1, 5, 15);
}

//----- (00051260) --------------------------------------------------------
int __cdecl sub_51260(int a1)
{
  return sub_51120(a1, 6, 18);
}

//----- (00051280) --------------------------------------------------------
int __cdecl sub_51280(int a1)
{
  return sub_51120(a1, 7, 21);
}

//----- (000512A0) --------------------------------------------------------
int __cdecl sub_512A0(int a1)
{
  return sub_51120(a1, 8, 24);
}

//----- (000512C0) --------------------------------------------------------
int __cdecl sub_512C0(int a1)
{
  return sub_51120(a1, 9, 27);
}

//----- (000512E0) --------------------------------------------------------
int __cdecl sub_512E0(int a1)
{
  return sub_51120(a1, 10, 30);
}

//----- (00051300) --------------------------------------------------------
int __cdecl sub_51300(int a1)
{
  return sub_51120(a1, 11, 33);
}

//----- (00051320) --------------------------------------------------------
int __cdecl sub_51320(int a1)
{
  return sub_51120(a1, 12, 36);
}

//----- (00051340) --------------------------------------------------------
int __cdecl sub_51340(int a1)
{
  return sub_51120(a1, 13, 39);
}

//----- (00051360) --------------------------------------------------------
int __cdecl sub_51360(int a1)
{
  return sub_51120(a1, 14, 42);
}

//----- (00051380) --------------------------------------------------------
int __cdecl sub_51380(int a1)
{
  return sub_51120(a1, 15, 45);
}

//----- (000513A0) --------------------------------------------------------
int __cdecl sub_513A0(int a1)
{
  return sub_51120(a1, 16, 48);
}

//----- (000513C0) --------------------------------------------------------
int __cdecl sub_513C0(int a1)
{
  return sub_51120(a1, 17, 51);
}

//----- (000513E0) --------------------------------------------------------
int __cdecl sub_513E0(int a1)
{
  return sub_51120(a1, 18, 54);
}

//----- (00051400) --------------------------------------------------------
int __cdecl sub_51400(int a1)
{
  return sub_51120(a1, 19, 57);
}

//----- (00051420) --------------------------------------------------------
int __cdecl sub_51420(int a1)
{
  return sub_51120(a1, 20, 60);
}

//----- (00051440) --------------------------------------------------------
int __cdecl sub_51440(int a1)
{
  return sub_51120(a1, 21, 63);
}

//----- (00051460) --------------------------------------------------------
int __cdecl sub_51460(int a1)
{
  return sub_51120(a1, 22, 66);
}

//----- (00051480) --------------------------------------------------------
int __cdecl sub_51480(int a1)
{
  return sub_51120(a1, 23, 69);
}

//----- (000514A0) --------------------------------------------------------
int __cdecl sub_514A0(int a1)
{
  return sub_51120(a1, 24, 72);
}

//----- (000514C0) --------------------------------------------------------
int __cdecl sub_514C0(int a1)
{
  return sub_51120(a1, 25, 75);
}

//----- (000514E0) --------------------------------------------------------
int __cdecl sub_514E0(int a1, char a2, char a3, __int16 a4)
{
  int v4; // ebx

  v4 = sub_4A050();
  if ( v4 )
  {
    *(_BYTE *)(v4 + 63) = 14;
    *(_BYTE *)(v4 + 70) = 0;
    *(_BYTE *)(v4 + 69) = a3;
    *(_BYTE *)(v4 + 64) = a2;
    sub_57D70(v4, a1);
    sub_49A20(v4);
    sub_49DA0((_WORD *)v4, a4);
  }
  return v4;
}

//----- (00051530) --------------------------------------------------------
_WORD *__cdecl sub_51530(int a1)
{
  _WORD *v1; // eax
  _WORD *v2; // ebx

  v1 = (_WORD *)sub_514E0(a1, 0, 0, 77);
  v2 = v1;
  if ( v1 )
    sub_49EA0(v1, 384, 384);
  return v2;
}

//----- (00051570) --------------------------------------------------------
int __cdecl sub_51570(int a1)
{
  int result; // eax

  result = sub_514E0(a1, 3, 8, 338);
  if ( result )
  {
    *(_WORD *)(dword_D41A0 + 224766) = (result - (dword_D41A0 + 28302)) / 168;
    *(_BYTE *)(result + 12) |= 1u;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (000515C0) --------------------------------------------------------
int __cdecl sub_515C0(int a1)
{
  int result; // eax

  result = sub_514E0(a1, 4, 9, 339);
  if ( result )
  {
    *(_WORD *)((char *)&loc_36DFC + dword_D41A0) = (result - (dword_D41A0 + 28302)) / 168;
    *(_BYTE *)(result + 12) |= 1u;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00051610) --------------------------------------------------------
_WORD *__cdecl sub_51610(int a1)
{
  _WORD *v1; // eax
  _WORD *v2; // ebx
  _WORD *v3; // esi

  v1 = (_WORD *)sub_514E0(a1, 5, 10, 280);
  v2 = v1;
  v3 = v1;
  if ( v1 )
  {
    sub_49EA0(v1, 768, 1280);
    if ( (*(_BYTE *)(dword_D41A4 + 38545) & 4) != 0 )
      *((_BYTE *)v2 + 12) |= 1u;
  }
  return v3;
}
// D41A4: using guessed type int dword_D41A4;

//----- (00051660) --------------------------------------------------------
int __cdecl sub_51660(int a1)
{
  int v1; // eax
  int v2; // ebx
  char v3; // dl

  v1 = sub_4A050();
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 6;
    v3 = *(_BYTE *)(v1 + 12);
    *(_BYTE *)(v1 + 63) = 14;
    v3 &= 0xF6u;
    *(_BYTE *)(v1 + 12) = v3;
    *(_BYTE *)(v1 + 64) = 1;
    *(_BYTE *)(v1 + 12) = v3 | 1;
    *(_DWORD *)(v1 + 4) = 0;
    *(_DWORD *)(v1 + 8) = 0;
    *(_WORD *)(v1 + 42) = 0;
    sub_57D70(v1, a1);
  }
  return v2;
}

//----- (000516C0) --------------------------------------------------------
int __cdecl sub_516C0(int a1)
{
  int v1; // ebx
  int v2; // eax
  char v3; // dl

  v1 = 0;
  if ( byte_D41B6 )
  {
    v2 = sub_4A050();
    v1 = v2;
    if ( v2 )
    {
      *(_BYTE *)(v2 + 69) = 7;
      *(_BYTE *)(v2 + 63) = 14;
      v3 = *(_BYTE *)(v2 + 12);
      *(_BYTE *)(v2 + 64) = 2;
      v3 &= 0xF6u;
      *(_BYTE *)(v2 + 12) = v3;
      *(_DWORD *)(v2 + 8) = 0;
      *(_BYTE *)(v2 + 12) = v3 | 1;
      *(_WORD *)(v2 + 42) = 0;
      *(_WORD *)(v2 + 44) = 0;
      *(_WORD *)(v2 + 150) = 0;
      sub_57D70(v2, a1);
    }
  }
  return v1;
}
// D41B6: using guessed type char byte_D41B6;

//----- (00051730) --------------------------------------------------------
int __cdecl sub_51730(int a1)
{
  int v1; // eax
  _WORD *v2; // ebx
  int v3; // esi

  v1 = sub_4A050();
  v2 = (_WORD *)v1;
  v3 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 69) = 72;
    *(_BYTE *)(v1 + 63) = 10;
    *(_BYTE *)(v1 + 64) = 67;
    *(_BYTE *)(v1 + 12) = *(_BYTE *)(v1 + 12) & 0xF6 | 1;
    *(_DWORD *)(v1 + 8) = 120;
    *(_WORD *)(v1 + 42) = 20000;
    sub_57D70(v1, a1);
    sub_49EA0(v2, 4352, 4352);
  }
  return v3;
}

//----- (00051790) --------------------------------------------------------
_BYTE *__cdecl sub_51790(int a1)
{
  _BYTE *v1; // eax
  int v2; // ebx
  _BYTE *v3; // esi
  char v4; // ah

  v1 = (_BYTE *)sub_4A050();
  v2 = (int)v1;
  v3 = v1;
  if ( v1 )
  {
    v1[69] = 78;
    v1[63] = 10;
    v1[64] = 71;
    v4 = v1[12];
    *(_DWORD *)(v2 + 8) = 120;
    *(_WORD *)(v2 + 42) = 20000;
    *(_BYTE *)(v2 + 12) = v4 & 0xF6 | 1;
    *(_BYTE *)(v2 + 70) = 0;
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(v2 + 8);
    sub_57D70(v2, a1);
    sub_49EA0((_WORD *)v2, 1280, 2048);
  }
  return v3;
}

//----- (00051800) --------------------------------------------------------
_WORD *__cdecl sub_51800(int a1)
{
  int v1; // ebx
  int v2; // eax
  char v3; // dl
  int v4; // eax
  _WORD *v5; // ebx
  int v6; // edx
  int v7; // eax
  int v9; // [esp+0h] [ebp-10h]
  int v10; // [esp+4h] [ebp-Ch]
  _WORD *v11; // [esp+8h] [ebp-8h]
  __int16 v12; // [esp+Ch] [ebp-4h]

  v11 = 0;
  v1 = *(unsigned __int8 *)(dword_D41A4 + 224);
  if ( sub_4A810() >= v1 )
  {
    v2 = sub_4A050();
    v11 = (_WORD *)v2;
    if ( v2 )
    {
      *(_BYTE *)(v2 + 69) = 79;
      *(_BYTE *)(v2 + 63) = 10;
      *(_BYTE *)(v2 + 64) = 72;
      v3 = *(_BYTE *)(v2 + 12);
      *(_DWORD *)(v2 + 4) = 16;
      *(_BYTE *)(v2 + 12) = v3 & 0xF7;
      v10 = v2;
      *(_DWORD *)(v2 + 8) = *(_DWORD *)(v2 + 4);
      v12 = 1;
      *(_BYTE *)(v2 + 62) = 0;
      while ( *(unsigned __int8 *)(dword_D41A4 + 224) > v12 )
      {
        v4 = sub_4A050();
        v5 = (_WORD *)v4;
        v9 = v4;
        if ( v4 )
        {
          qmemcpy((void *)v4, v11, 0xA8u);
          v6 = v4 - (dword_D41A0 + 28302);
          *(_WORD *)(v4 + 50) = (v10 - (dword_D41A0 + 28302)) / 168;
          *(_WORD *)(v10 + 52) = v6 / 168;
          *(_WORD *)(v4 + 52) = 0;
          *(_BYTE *)(v4 + 62) = v12;
          v7 = dword_D41A4;
          *(_DWORD *)&word_EB398 = *(_DWORD *)a1;
          *(&word_EB398 + 2) = *(_WORD *)(a1 + 4);
          sub_57FA0(&word_EB398, v12 * (2048 / *(unsigned __int8 *)(v7 + 224)), 0, 512);
          word_EB39C = sub_10C40(&word_EB398);
          sub_57D70((int)v5, (int)&word_EB398);
          sub_49EA0(v5, 128, 256);
          sub_49CD0(v5, 220);
        }
        v10 = v9;
        ++v12;
      }
      *(_DWORD *)&word_EB398 = *(_DWORD *)a1;
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 4);
      sub_57FA0(&word_EB398, 0, 0, 512);
      word_EB39C = sub_10C40(&word_EB398);
      sub_57D70((int)v11, (int)&word_EB398);
      sub_49EA0(v11, 128, 256);
      sub_49CD0(v11, 220);
    }
  }
  return v11;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00051A00) --------------------------------------------------------
_BYTE *__cdecl sub_51A00(int a1)
{
  _BYTE *v1; // eax
  int v2; // ebx
  char v3; // ah
  _BYTE *v5; // [esp+0h] [ebp-4h]

  v1 = (_BYTE *)sub_4A050();
  v2 = (int)v1;
  v5 = v1;
  if ( v1 )
  {
    v1[69] = 80;
    v1[63] = 10;
    v1[64] = 73;
    v3 = v1[12] & 0xF7;
    *(_DWORD *)(v2 + 8) = 16;
    *(_BYTE *)(v2 + 12) = v3;
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(v2 + 8);
    *(_DWORD *)&word_EB398 = *(_DWORD *)a1;
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 4);
    word_EB39C = sub_10C40(&word_EB398);
    sub_57D70(v2, (int)&word_EB398);
    sub_49EA0((_WORD *)v2, 128, 256);
    sub_49CD0((_WORD *)v2, 220);
  }
  return v5;
}
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00051BB0) --------------------------------------------------------
int __usercall sub_51BB0@<eax>(int a1@<edi>)
{
  char v1; // al
  _BYTE *v2; // ecx
  unsigned __int16 v3; // dx
  int i; // ebx
  char *v5; // esi
  char *v6; // edi
  char v7; // al
  char v8; // al
  int v9; // esi
  int v10; // edx
  int v11; // eax
  int v12; // esi
  char v13; // dl
  char v14; // bl
  __int16 j; // bx
  char v16; // cl
  int v17; // eax
  int v18; // ebx
  int v19; // eax
  char *v20; // esi
  char *v21; // edi
  char v22; // al
  char v23; // al
  char *v24; // esi
  char *v25; // edi
  char v26; // al
  char v27; // al
  __int16 v28; // ax
  int v29; // eax
  int v30; // edx
  char *v31; // eax
  int v32; // eax
  char v33; // dl
  const char *v34; // edi
  unsigned int v35; // kr08_4
  const char *v36; // edi
  unsigned int v37; // kr0C_4
  char *v38; // esi
  const char *v39; // edi
  char *v40; // edi
  char v41; // al
  char v42; // al
  char *v43; // edi
  char *v44; // esi
  char v45; // al
  char v46; // al
  int v47; // edx
  int v48; // ecx
  _BOOL1 v49; // zf
  char *v50; // esi
  char *v51; // edi
  char v52; // al
  char v53; // al
  char *v54; // eax
  __int16 k; // ax
  int v56; // edx
  unsigned __int16 v57; // si
  int m; // eax
  int v59; // eax
  int v60; // esi
  int v61; // eax
  int v62; // ecx
  __int16 v63; // ax
  __int16 mm; // ax
  int v65; // edx
  unsigned int nn; // eax
  int v67; // eax
  int v68; // edx
  unsigned int n; // eax
  unsigned int ii; // eax
  unsigned int jj; // eax
  __int16 kk; // ax
  int v73; // edx
  char v74; // dl
  char v75; // ch
  __int16 v76; // cx
  int v77; // eax
  char *v78; // edx
  char *v79; // edx
  char *v80; // edi
  char *v81; // esi
  char v82; // al
  char v83; // al
  int v84; // eax
  int v85; // eax
  int v86; // edx
  int v87; // eax
  unsigned __int8 v88; // cl
  char v89; // al
  char *v90; // eax
  char v91; // dl
  int v92; // eax
  int v93; // edx
  unsigned int v94; // eax
  int v95; // ecx
  __int64 v96; // rax
  int v97; // ecx
  __int64 v98; // rax
  int v99; // esi
  int v100; // esi
  int result; // eax
  __int16 v102; // [esp-4h] [ebp-120h]
  __int16 v103; // [esp-4h] [ebp-120h]
  const char *v104; // [esp-4h] [ebp-120h]
  char v105[256]; // [esp+0h] [ebp-11Ch] BYREF
  int v106; // [esp+100h] [ebp-1Ch]
  int v107; // [esp+104h] [ebp-18h]
  char *v108; // [esp+108h] [ebp-14h]
  int v109; // [esp+10Ch] [ebp-10h]
  int v110; // [esp+110h] [ebp-Ch]
  char v111; // [esp+114h] [ebp-8h]
  char v112; // [esp+118h] [ebp-4h]

  if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
  {
    sub_74374();
    sub_7438A(dword_D41A0 + 28222, 0xAu);
    v1 = 0;
    v2 = (_BYTE *)(dword_D41A0 + 28222);
    v3 = 0;
    for ( i = dword_D41A0 + 11230; ; i += 2124 )
    {
      v9 = dword_D41A0;
      if ( v3 >= *(_WORD *)(dword_D41A0 + 14) )
        break;
      if ( *v2 == 1 )
      {
        *(_BYTE *)(i + 6) = 1;
        if ( v3 == *(__int16 *)(v9 + 12) && *(_BYTE *)(dword_D41A4 + 57) )
        {
          v5 = (char *)(dword_D41A4 + 57);
          v6 = (char *)(i + 927);
          do
          {
            v7 = *v5;
            *v6 = *v5;
            if ( !v7 )
              break;
            v8 = v5[1];
            v5 += 2;
            v6[1] = v8;
            v6 += 2;
          }
          while ( v8 );
          a1 = i + 927;
        }
        v1 = 1;
      }
      v2 += 10;
      ++v3;
    }
    if ( v1 )
      sub_7438A(dword_D41A0 + 11230, 0x84Cu);
  }
  v10 = 2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0;
  v11 = dword_D41A4;
  ++*(_DWORD *)(v10 + 11248);
  v12 = *(_DWORD *)(v11 + 30);
  ++*(_DWORD *)(v11 + 26);
  v13 = *(_BYTE *)(v11 + 38400);
  *(_DWORD *)(v11 + 30) = v12 + 1;
  if ( v13 )
    *(_BYTE *)(v11 + 38400) = v13 - 1;
  v14 = *(_BYTE *)(dword_D41A4 + 38401);
  if ( v14 )
    *(_BYTE *)(dword_D41A4 + 38401) = v14 - 1;
  for ( j = 1; j < 16; ++j )
  {
    v16 = (*(_DWORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248) / (unsigned int)j) & 1;
    v17 = j;
    *(_BYTE *)(dword_D41A4 + v17 + 121) = v16;
  }
  v108 = (char *)(dword_D41A0 + 28222);
  v18 = dword_D41A0 + 11230;
  v110 = 0;
  while ( 1 )
  {
    result = dword_D41A0;
    if ( (unsigned __int16)v110 >= *(_WORD *)(dword_D41A0 + 14) )
      return result;
    v107 = dword_EA3E4[*(unsigned __int16 *)(v18 + 10)];
    if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x20) != 0 )
    {
      a1 = (int)v108;
      sub_53A40(v108);
    }
    switch ( *v108 )
    {
      case 1:
        v19 = dword_D41A4;
        *(_BYTE *)(v18 + 6) = 1;
        if ( (*(_BYTE *)(v19 + 22) & 0x10) == 0
          && (unsigned __int16)v110 == *(__int16 *)(dword_D41A0 + 12)
          && *(_BYTE *)(dword_D41A4 + 57) )
        {
          v20 = (char *)(dword_D41A4 + 57);
          v21 = (char *)(v18 + 927);
          do
          {
            v22 = *v20;
            *v21 = *v20;
            if ( !v22 )
              break;
            v23 = v20[1];
            v20 += 2;
            v21[1] = v23;
            v21 += 2;
          }
          while ( v23 );
          a1 = v18 + 927;
        }
        goto LABEL_33;
      case 2:
        sub_53120();
        if ( *(__int16 *)(dword_D41A0 + 12) == (unsigned __int16)v110 )
          *(_BYTE *)(v18 + 4) = 1;
        if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
          sub_5E660(v107);
        sub_7373D(v110);
        *(_BYTE *)(v18 + 6) = 0;
        goto LABEL_214;
      case 3:
        goto LABEL_33;
      case 4:
        *(_BYTE *)(v18 + 5) ^= v108[1];
        goto LABEL_214;
      case 6:
        if ( (v108[5] & 0x40) != 0 )
          *(_BYTE *)(*(_DWORD *)(v107 + 164) + 1112) = v108[1];
        if ( v108[5] < 0 && !*(_BYTE *)(v18 + 2118) )
          *(_BYTE *)(v18 + 2118) = 1;
        goto LABEL_214;
      case 7:
        if ( *(unsigned __int16 *)(v18 + 14) + v108[1] >= 0
          && v108[1] + *(unsigned __int16 *)(v18 + 14) < *(unsigned __int16 *)(v18 + 16) - 1 )
        {
          *(_WORD *)(v18 + 14) += v108[1];
        }
        goto LABEL_214;
      case 8:
        *(_WORD *)(v18 + 477) += v108[1];
        goto LABEL_214;
      case 12:
        *(_BYTE *)(dword_D41A4 + 22) = *(_BYTE *)(dword_D41A4 + 22) & 0xD9 | 0x22;
        goto LABEL_214;
      case 13:
        *(_BYTE *)(dword_D41A4 + 22) = *(_BYTE *)(dword_D41A4 + 22) & 0xD9 | 0x24;
        goto LABEL_214;
      case 15:
        if ( *(_WORD *)(*(_DWORD *)(v107 + 164) + 58) )
          goto LABEL_33;
        if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
        {
LABEL_56:
          v24 = (char *)dword_EA0B8;
          v25 = (char *)(v18 + 28);
          do
          {
            v26 = *v24;
            *v25 = *v24;
            if ( !v26 )
              break;
            v27 = v24[1];
            v24 += 2;
            v25[1] = v27;
            v25 += 2;
          }
          while ( v27 );
          HIWORD(a1) = (unsigned int)(v18 + 28) >> 16;
          *(_WORD *)(v18 + 79) = 1;
          v28 = v110;
          *(_WORD *)(v18 + 77) = 100;
          *(_WORD *)(v18 + 2) = 8;
          sub_7373D(v28);
          v29 = dword_D41A4;
          *(_BYTE *)(v18 + 6) = 0;
          if ( (*(_BYTE *)(v29 + 22) & 0x10) != 0 )
            sub_5E660(v107);
          LOWORD(a1) = *(_WORD *)(dword_D41A4 + 43);
          *(_BYTE *)(dword_D41A4 + 22) &= 0xD9u;
          if ( (unsigned __int16)a1 > 0x18u )
            *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) |= 0x10u;
        }
        else
        {
          *(_BYTE *)(v18 + 2) |= 0xCu;
LABEL_33:
          sub_5C950(v107, v18, v107);
          sub_6EDB0();
          sub_548F0((_WORD *)v18);
          sub_52E90(v18, 0, 0);
        }
        goto LABEL_214;
      case 16:
        if ( *(_BYTE *)(dword_D41A0 + 224746) && (unsigned __int16)v110 == *(__int16 *)(dword_D41A0 + 12) )
        {
          v31 = v108;
          v108[3] = 0;
          v31[4] = 0;
          sub_6EDB0();
        }
        sub_52E90(v18, 3, 1);
        v32 = dword_D41A0;
        *(_BYTE *)(v18 + 994) = 0;
        if ( (unsigned __int16)v110 == *(__int16 *)(v32 + 12) )
          sub_54960();
        goto LABEL_214;
      case 17:
        v33 = v108[1];
        if ( v33 == 8 )
        {
          v34 = (const char *)(48 * *(unsigned __int8 *)(v18 + 992) + v18 + 81);
          v35 = strlen(v34) + 1;
          a1 = (int)&v34[v35];
          if ( v35 != 1 )
          {
            --*(_BYTE *)(v18 + 994);
            *(_BYTE *)(v35 - 1 + v18 + 48 * *(unsigned __int8 *)(v18 + 992) + 80) = 0;
          }
        }
        else if ( v33 )
        {
          v36 = (const char *)(48 * *(unsigned __int8 *)(v18 + 992) + v18 + 81);
          v37 = strlen(v36) + 1;
          a1 = (int)&v36[v37];
          if ( v37 - 1 < 0x2B )
          {
            if ( !*(_BYTE *)(v18 + 994) )
              *(_BYTE *)(v18 + 48 * *(unsigned __int8 *)(v18 + 992) + 81) = 0;
            ++*(_BYTE *)(v18 + 994);
            sprintf(v105, "%c", v108[1]);
            v38 = v105;
            v39 = (const char *)(48 * *(unsigned __int8 *)(v18 + 992) + v18 + 81);
            v104 = v39;
            v40 = (char *)&v39[strlen(v39)];
            do
            {
              v41 = *v38;
              *v40 = *v38;
              if ( !v41 )
                break;
              v42 = v38[1];
              v38 += 2;
              v40[1] = v42;
              v40 += 2;
            }
            while ( v42 );
            a1 = (int)v104;
          }
        }
        goto LABEL_214;
      case 18:
        sub_52E90(v18, 0, 1);
        goto LABEL_214;
      case 19:
        goto LABEL_82;
      case 20:
        if ( *(_BYTE *)(dword_D41A0 + 224746) && (unsigned __int16)v110 == *(__int16 *)(dword_D41A0 + 12) )
        {
          switch ( v108[1] )
          {
            case 3:
            case 5:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
              v54 = v108;
              v108[3] = 0;
              v54[4] = 0;
              sub_6EDB0();
              break;
            default:
              break;
          }
        }
        sub_52E90(v18, v108[1], 1);
        goto LABEL_214;
      case 23:
        if ( v108[2] != -1 )
        {
          for ( k = 0; k < 26; ++k )
          {
            v56 = k + *(_DWORD *)(v107 + 164);
            if ( *(_BYTE *)(v56 + 923) == v108[2] )
              *(_BYTE *)(v56 + 923) = -1;
          }
          *(_BYTE *)(v108[1] + *(_DWORD *)(v107 + 164) + 923) = v108[2];
          sub_6E450(0, *(_WORD *)(v18 + 7), 14);
        }
        goto LABEL_214;
      case 25:
      case 26:
        v57 = 0;
        for ( m = dword_D41A0; v57 < *(_WORD *)(dword_D41A0 + 14); m = dword_D41A0 )
        {
          v59 = 2124 * v57 + m;
          if ( *(_BYTE *)(v59 + 11236) )
          {
            *(_BYTE *)(v59 + 11234) = 1;
            sub_7373D(v57);
          }
          ++v57;
        }
        goto LABEL_214;
      case 27:
        sub_53120();
        v102 = v110;
        *(_WORD *)(v18 + 2) = 10;
        sub_7373D(v102);
        goto LABEL_214;
      case 28:
        v103 = v110;
        *(_WORD *)(v18 + 2) = 12;
        sub_7373D(v103);
        goto LABEL_214;
      case 29:
        goto LABEL_56;
      case 30:
        sub_53120();
        switch ( v108[1] )
        {
          case 1:
            v106 = 0;
            break;
          case 2:
            v67 = sub_4A190(v107 + 76, 10, 39);
            if ( v67 )
            {
              v68 = dword_D41A0;
              *(_DWORD *)(v67 + 144) = 100000;
              *(_WORD *)(v67 + 148) = (v107 - (v68 + 28302)) / 168;
            }
            *(_DWORD *)(v107 + 144) = *(_DWORD *)(v107 + 140);
            sub_52D70(v110, aCheatMoreMana);
            goto LABEL_214;
          case 3:
            for ( n = *(_DWORD *)(dword_D41A4 + 38519); n > dword_EA3E4[0]; n = *(_DWORD *)n )
            {
              if ( *(_WORD *)(n + 26) != *(_WORD *)(v107 + 26) && *(_BYTE *)(n + 64) <= 1u )
                *(_DWORD *)(n + 8) = -1;
            }
            sub_52D70(v110, aCheatDestroyAl);
            goto LABEL_214;
          case 4:
            for ( ii = *(_DWORD *)(dword_D41A4 + 38519); ii > dword_EA3E4[0]; ii = *(_DWORD *)ii )
            {
              if ( *(_WORD *)(ii + 26) != *(_WORD *)(v107 + 26) && *(_BYTE *)(ii + 64) == 2 )
                *(_DWORD *)(ii + 8) = -1;
            }
            sub_52D70(v110, aCheatDestroyAl_0);
            goto LABEL_214;
          case 5:
            for ( jj = *(_DWORD *)(dword_D41A4 + 38519); jj > dword_EA3E4[0]; jj = *(_DWORD *)jj )
            {
              if ( *(_WORD *)(jj + 26) != *(_WORD *)(v107 + 26) && *(_BYTE *)(jj + 64) == 3 )
                *(_DWORD *)(jj + 8) = -1;
            }
            sub_52D70(v110, aCheatDestroyAl_1);
            goto LABEL_214;
          case 6:
            *(_DWORD *)(v107 + 8) = *(_DWORD *)(v107 + 4);
            sub_52D70(v110, aCheatHeal);
            goto LABEL_214;
          case 7:
            sub_1B5F0();
            sub_52D70(v110, aCheatKillAllCr);
            goto LABEL_214;
          case 8:
            for ( kk = 0; kk < 26; ++kk )
            {
              v73 = (unsigned __int8)byte_D94FF[kk];
              *(_DWORD *)(*(_DWORD *)(v107 + 164) + 4 * v73 + 715) += 100;
            }
            sub_6DB50(0, 0);
            sub_52D70(v110, aCheatMoreSpell);
            goto LABEL_214;
          case 9:
            v74 = *(_BYTE *)(dword_D41A4 + 24);
            if ( (v74 & 0x20) != 0 )
            {
              *(_BYTE *)(dword_D41A4 + 24) = v74 & 0xDF;
              sub_52D70(v110, aCheatFreeSpell);
            }
            else
            {
              *(_BYTE *)(dword_D41A4 + 24) = v74 | 0x20;
              sub_52D70(v110, aCheatFreeSpell_0);
            }
            goto LABEL_214;
          case 10:
            v75 = *(_BYTE *)(dword_D41A4 + 25);
            if ( (v75 & 1) != 0 )
              *(_BYTE *)(dword_D41A4 + 25) = v75 & 0xFE;
            else
              *(_BYTE *)(dword_D41A4 + 25) = v75 | 1;
            if ( (*(_BYTE *)(dword_D41A4 + 25) & 1) != 0 )
              sub_52D70(v110, aCheatInvincabi);
            else
              sub_52D70(v110, aCheatInvincabi_0);
            goto LABEL_214;
          default:
            goto LABEL_214;
        }
        break;
      case 31:
      case 32:
        if ( v108[1] != -1 )
        {
          sub_6E450(0, *(_WORD *)(v18 + 7), 14);
          sub_87C10();
          v76 = (unsigned __int8)byte_D94FF[v108[1]];
          v77 = *(_DWORD *)(v107 + 164) + 611;
          *(_BYTE *)(v77 + (unsigned __int8)byte_D94FF[v108[1]] + 468) = v108[2];
          if ( (unsigned __int8)*v108 >= 0x1Fu )
          {
            if ( (unsigned __int8)*v108 <= 0x1Fu )
            {
              v78 = v108;
              *(_WORD *)(v77 + 494) = v76;
              *(_BYTE *)(v77 + 498) = v78[2];
              *(_BYTE *)(dword_D41A4 + 38400) = 8;
            }
            else if ( *v108 == 32 )
            {
              v79 = v108;
              *(_WORD *)(v77 + 496) = v76;
              *(_BYTE *)(v77 + 499) = v79[2];
              *(_BYTE *)(dword_D41A4 + 38401) = 8;
            }
          }
          a1 = dword_EA3E4[*(__int16 *)(v77 + 2 * v76 + 208)];
          sub_6D5E0(a1, v108[2]);
          sub_6D830(a1, v108[2]);
          if ( (unsigned __int16)v110 == *(__int16 *)(dword_D41A0 + 12) )
          {
            v80 = (char *)(v18 + 28);
            v81 = (char *)dword_E9C4C[word_DA82E[40 * v76 + 13 * v108[2]]];
            do
            {
              v82 = *v81;
              *v80 = *v81;
              if ( !v82 )
                break;
              v83 = v81[1];
              v81 += 2;
              v80[1] = v83;
              v80 += 2;
            }
            while ( v83 );
            a1 = v18 + 28;
            *(_WORD *)(v18 + 77) = 20;
            *(_WORD *)(v18 + 79) = 3;
          }
          if ( (*(_BYTE *)(dword_D41A4 + 22) & 4) != 0 )
          {
            v84 = *(__int16 *)(dword_D41A0 + 12);
            if ( (unsigned __int16)v110 == v84 )
            {
              sub_6D200(dword_D41A0 + 11230 + 2124 * v84);
              sub_473B0();
            }
          }
        }
        goto LABEL_214;
      case 35:
        v89 = v108[1];
        *(_BYTE *)(v18 + 994) = 0;
        *(_BYTE *)(v18 + 992) = v89;
        goto LABEL_214;
      case 36:
        *(_BYTE *)(v18 + 993) = v108[1];
        goto LABEL_214;
      case 37:
        if ( *(_BYTE *)(v18 + 993) == 3 )
          *(_BYTE *)(v18 + 995) ^= 1 << v108[1];
        goto LABEL_214;
      case 38:
        *(_BYTE *)(v108[1] + *(_DWORD *)(v107 + 164) + 949) = v108[2];
        sub_6E450(0, *(_WORD *)(v18 + 7), 14);
        goto LABEL_214;
      case 39:
        v90 = v108;
        v108[3] = 0;
        v91 = v90[1];
        v90[4] = 0;
        if ( v91 )
        {
          v92 = v107;
          *(_WORD *)(v107 + 130) = 0;
          *(_WORD *)(*(_DWORD *)(v92 + 164) + 12) = 0;
          LOWORD(a1) = *(_WORD *)(*(_DWORD *)(v107 + 164) + 825);
          if ( (_WORD)a1 )
            *(_WORD *)(dword_EA3E4[(__int16)a1] + 46) = 0;
        }
        if ( *(_WORD *)(v18 + 7) == *(_WORD *)(dword_D41A0 + 12) )
          sub_6EDB0();
        goto LABEL_214;
      case 40:
        if ( (*(_BYTE *)(dword_D41A4 + 22) & 4) != 0 )
        {
          v85 = *(_DWORD *)(v107 + 164);
          *(_BYTE *)(v85 + 1112) = v108[1];
          *(_BYTE *)(v85 + 1111) = v108[2];
          v86 = *(__int16 *)(dword_D41A0 + 12);
          if ( (unsigned __int16)v110 == v86 )
            goto LABEL_196;
        }
        goto LABEL_214;
      case 41:
        if ( (*(_BYTE *)(dword_D41A4 + 22) & 4) != 0 )
        {
          v87 = *(_DWORD *)(v107 + 164);
          v88 = byte_D94FF[*(char *)(v87 + 1112)];
          v87 += 611;
          *(_BYTE *)(v87 + 502) = v108[1];
          *(_BYTE *)(v87 + v88 + 468) = v108[1];
          v86 = *(__int16 *)(dword_D41A0 + 12);
          if ( (unsigned __int16)v110 == v86 )
          {
LABEL_196:
            sub_6D200(2124 * v86 + dword_D41A0 + 11230);
            sub_473B0();
          }
        }
        goto LABEL_214;
      case 42:
        v93 = *(_DWORD *)(v107 + 164);
        a1 = dword_EA3E4[0];
        v94 = dword_EA3E4[*(unsigned __int16 *)(v93 + 58)];
        if ( v94 > dword_EA3E4[0] )
        {
          if ( *(_DWORD *)(v94 + 16) == 1 )
            *(_BYTE *)(v93 + 446) = 1;
          *(_DWORD *)(v94 + 8) = -1;
        }
        goto LABEL_214;
      case 43:
        *(_BYTE *)(v18 + 992) = v108[1];
LABEL_82:
        v43 = v105;
        v44 = (char *)(48 * *(unsigned __int8 *)(v18 + 992) + v18 + 81);
        do
        {
          v45 = *v44;
          *v43 = *v44;
          if ( !v45 )
            break;
          v46 = v44[1];
          v44 += 2;
          v43[1] = v46;
          v43 += 2;
        }
        while ( v46 );
        a1 = (int)v105;
        v112 = 0;
        if ( v105[0] )
        {
          v112 = 1;
          if ( toupper((unsigned __int8)v105[0]) == 87
            && toupper((unsigned __int8)v105[1]) == 73
            && toupper((unsigned __int8)v105[2]) == 78
            && toupper((unsigned __int8)v105[3]) == 68
            && toupper((unsigned __int8)v105[4]) == 89 )
          {
            if ( (unsigned __int16)v110 == *(__int16 *)(dword_D41A0 + 12) )
              *(_BYTE *)(dword_D41A4 + 23) |= 0x80u;
          }
          else
          {
            v111 = 0;
            v47 = *(__int16 *)(dword_D41A0 + 12);
            if ( (unsigned __int16)v110 != v47 )
            {
              v48 = 2124 * v47 + dword_D41A0;
              switch ( *(_BYTE *)(v18 + 993) )
              {
                case 0:
                  v49 = sub_61810(v107, dword_EA3E4[*(unsigned __int16 *)(v48 + 11240)]) == 0;
                  goto LABEL_97;
                case 1:
                  a1 = v107;
                  v49 = sub_61620(v107, dword_EA3E4[*(unsigned __int16 *)(v48 + 11240)]) == 0;
LABEL_97:
                  if ( !v49 )
                    break;
                  goto LABEL_99;
                case 2:
                  break;
                case 3:
                  if ( ((1 << *(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12284)) & *(unsigned __int8 *)(v18 + 995)) != 0 )
                    break;
                  goto LABEL_99;
                default:
                  goto LABEL_99;
              }
            }
            v111 = 1;
LABEL_99:
            if ( v111 )
            {
              v50 = v105;
              v51 = (char *)(v18 + 28);
              do
              {
                v52 = *v50;
                *v51 = *v50;
                if ( !v52 )
                  break;
                v53 = v50[1];
                v50 += 2;
                v51[1] = v53;
                v51 += 2;
              }
              while ( v53 );
              a1 = v18 + 28;
              *(_WORD *)(v18 + 77) = 200;
              *(_WORD *)(v18 + 79) = 2;
            }
          }
        }
        sub_52E90(v18, 0, v112);
        goto LABEL_214;
      case 44:
        v30 = *(unsigned __int8 *)(v18 + 992);
        *(_BYTE *)(v18 + 994) = 0;
        *(_BYTE *)(v18 + 48 * v30 + 81) = 0;
        sub_6E450(0, *(_WORD *)(v18 + 7), 14);
        goto LABEL_214;
      default:
        goto LABEL_214;
    }
    do
    {
      v60 = 2 * v106;
      if ( !*(_WORD *)(2 * v106 + *(_DWORD *)(v107 + 164) + 819) )
      {
        v61 = (*(int (__cdecl **)(int))((char *)&off_D781E + 14 * v106))(v107 + 76);
        v62 = v61;
        if ( v61 )
        {
          a1 = dword_D41A0 + 28302;
          *(_BYTE *)(v61 + 12) |= 1u;
          v109 = 168;
          v63 = (v107 - a1) / 168;
          *(_DWORD *)(v62 + 136) = 0;
          *(_WORD *)(v62 + 40) = v63;
          *(_WORD *)(v60 + *(_DWORD *)(v107 + 164) + 819) = (v62 - a1) / 168;
          for ( mm = 0; mm < 10; ++mm )
          {
            v65 = *(_DWORD *)(v107 + 164) + mm;
            if ( *(char *)(v65 + 923) == -1 )
            {
              *(_BYTE *)(v65 + 923) = v106;
              break;
            }
          }
        }
      }
      ++v106;
    }
    while ( v106 < 26 );
    for ( nn = dword_EA3E8; nn < dword_EB384; nn += 168 )
    {
      if ( *(_BYTE *)(nn + 63) == 11 )
        *(_BYTE *)(nn + 12) &= ~1u;
    }
    sub_52D70(v110, aCheatAccessAll);
LABEL_214:
    v95 = *(_DWORD *)(v107 + 164);
    v96 = 2 * v108[3] - *(__int16 *)(v95 + 341);
    *(_WORD *)(v95 + 4) = (int)(v96 - (__CFSHL__(HIDWORD(v96), 2) + 4 * HIDWORD(v96))) >> 2;
    v97 = *(_DWORD *)(v107 + 164);
    v98 = 2 * v108[4] - *(__int16 *)(v97 + 343);
    LODWORD(v98) = (int)(v98 - (__CFSHL__(HIDWORD(v98), 2) + 4 * HIDWORD(v98))) >> 2;
    HIDWORD(v98) = v108;
    *(_WORD *)(v97 + 6) = v98;
    **(_DWORD **)(v107 + 164) = *(unsigned __int8 *)(HIDWORD(v98) + 5);
    *(_WORD *)(*(_DWORD *)(v107 + 164) + 24) = *((_WORD *)v108 + 3);
    *(_WORD *)(*(_DWORD *)(v107 + 164) + 26) = *((_WORD *)v108 + 4);
    v99 = dword_EA3E4[*(unsigned __int16 *)(v18 + 10)];
    sub_57B20(v18, v99);
    if ( *(_BYTE *)(v18 + 2118) )
      sub_55C60(a1, v99, v18);
    a1 = (int)v108;
    v18 += 2124;
    v100 = v110 + 1;
    memset(v108, 0, 10);
    v110 = v100;
    v108 = (char *)(a1 + 10);
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98805: using guessed type _DWORD __cdecl toupper(_DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D781E: using guessed type int (__cdecl *off_D781E)(int);
// DA82E: using guessed type __int16 word_DA82E[];
// E9C4C: using guessed type int dword_E9C4C[];
// EA0B8: using guessed type int dword_EA0B8;
// EA3E4: using guessed type int dword_EA3E4[];
// EA3E8: using guessed type int dword_EA3E8;
// EB384: using guessed type int dword_EB384;

//----- (00052D70) --------------------------------------------------------
char __cdecl sub_52D70(unsigned __int16 a1, char *a2)
{
  int v3; // edx
  char *v4; // edi
  char result; // al

  v3 = dword_D41A0 + 11230 + 2124 * a1;
  v4 = (char *)(v3 + 28);
  do
  {
    result = *a2;
    *v4 = *a2;
    if ( !result )
      break;
    result = a2[1];
    a2 += 2;
    v4[1] = result;
    v4 += 2;
  }
  while ( result );
  *(_WORD *)(v3 + 77) = 100;
  *(_WORD *)(v3 + 79) = 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00052E90) --------------------------------------------------------
char __cdecl sub_52E90(int a1, int a2, char a3)
{
  int v3; // edx
  unsigned __int16 v4; // ax
  __int16 v5; // ax
  int v6; // edx
  unsigned __int16 v8; // [esp+0h] [ebp-4h]

  v3 = dword_D41A0;
  v4 = *(unsigned __int8 *)(a1 + 991);
  *(_BYTE *)(a1 + 991) = a2;
  v8 = v4;
  if ( *(_WORD *)(a1 + 7) != *(_WORD *)(v3 + 12) )
    return sub_53120();
  *(_BYTE *)(dword_D41A4 + 38544) = v4;
  sub_87C10();
  if ( (_WORD)a2 )
  {
    sub_41AF0();
  }
  else if ( v8 )
  {
    sub_41B60();
  }
  if ( !(_WORD)a2 || (unsigned __int16)a2 >= 6u && (unsigned __int16)a2 <= 7u )
  {
    if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) == 0 || word_1805C2 != 7 && word_1805C2 != 1 && word_1805C2 != 2 )
    {
      sub_8CD27(dword_EB394);
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  if ( word_1805C2 == 7 || word_1805C2 == 1 || word_1805C2 == 2 )
LABEL_19:
    sub_8CD27(6 * (unsigned __int8)byte_D419E + dword_EB394);
LABEL_20:
  switch ( (__int16)a2 )
  {
    case 3:
    case 7:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      *(_BYTE *)(dword_D41A0 + 224772) = 0;
      break;
    default:
      break;
  }
  switch ( v8 )
  {
    case 0u:
    case 6u:
      if ( (_WORD)a2 == v8 && (*(_BYTE *)(dword_D41A4 + 24) & 1) == 0 )
        sub_548B0((__int16 *)a1);
      break;
    case 3u:
    case 5u:
    case 8u:
    case 9u:
    case 0xAu:
    case 0xBu:
    case 0xCu:
    case 0xDu:
    case 0xEu:
      sub_548B0((__int16 *)a1);
      sub_473B0();
      break;
    default:
      break;
  }
  switch ( (__int16)a2 )
  {
    case 0:
    case 6:
      if ( (_WORD)a2 == v8 && (*(_BYTE *)(dword_D41A4 + 24) & 1) != 0 )
      {
        sub_6EDB0();
        goto LABEL_31;
      }
      break;
    case 3:
    case 5:
    case 8:
LABEL_31:
      sub_548F0((_WORD *)a1);
      break;
    case 9:
    case 11:
      sub_1A280();
      v5 = sub_1A4A0();
      v6 = dword_D41A4;
      *(_BYTE *)(dword_D41A4 + 225) = 1;
      *(_WORD *)(v6 + 186) = v5;
      sub_548F0((_WORD *)a1);
      break;
    case 10:
    case 12:
      sub_548F0((_WORD *)a1);
      sub_19D60(a2, a1);
      break;
    case 13:
    case 14:
      sub_548F0((_WORD *)a1);
      sub_1A030();
      break;
    default:
      break;
  }
  if ( (unsigned __int16)a2 < 5u )
    goto LABEL_40;
  if ( (unsigned __int16)a2 > 5u )
  {
    if ( (_WORD)a2 != 8 )
      goto LABEL_40;
    a3 = 0;
  }
  *(_BYTE *)(a1 + 2109) = 0;
  sub_6D200(a1);
  sub_473B0();
LABEL_40:
  if ( v8 >= 5u && (v8 <= 5u || v8 == 8) )
    a3 = 0;
  switch ( (__int16)a2 )
  {
    case 6:
    case 7:
    case 8:
    case 11:
    case 12:
    case 14:
      sub_2CA60(384, 0, 256, 400);
      break;
    default:
      sub_2CA90(*(char *)(dword_D41A0 + 8589));
      break;
  }
  if ( a3 )
    sub_6E450(0, *(_WORD *)(a1 + 7), 14);
  return sub_53120();
}
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EB394: using guessed type int dword_EB394;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (00053120) --------------------------------------------------------
char sub_53120()
{
  int v0; // eax

  LOBYTE(v0) = dword_D41A4;
  if ( (*(_BYTE *)(dword_D41A4 + 26) & 7) == 0 )
  {
    LOBYTE(v0) = *(_BYTE *)(dword_D41A4 + 52) & 3;
    if ( (_BYTE)v0 == 1 )
    {
      LOWORD(v0) = sub_10010();
      if ( !v0 )
      {
        LOBYTE(v0) = dword_D41A0;
        *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11234) = 2;
      }
    }
  }
  return v0;
}
// 5313E: variable 'v0' is possibly undefined
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00053160) --------------------------------------------------------
int sub_53160()
{
  int v0; // ebx
  int v1; // esi
  int v2; // eax
  __int16 v3; // ax
  __int16 v4; // dx
  int v5; // eax
  char *v6; // edi
  char *v7; // esi
  char v8; // al
  char v9; // al
  int result; // eax
  _BYTE *v11; // [esp+4h] [ebp-Ch]
  unsigned __int16 v12; // [esp+8h] [ebp-8h]
  char v13; // [esp+Ch] [ebp-4h]

  v13 = 1;
  v12 = 0;
  v11 = (_BYTE *)(dword_D41A0 + 28222);
  v0 = dword_D41A0 + 11230;
  do
  {
    memset(v11, 0, 10);
    qmemcpy((void *)(dword_D41A4 + 256), (const void *)v0, 0x84Cu);
    memset(v0, 0, 2124);
    v1 = dword_D41A4 + 2255;
    qmemcpy((void *)(v0 + 1999), (const void *)(dword_D41A4 + 2255), 0x18u);
    qmemcpy((void *)(v0 + 2023), (const void *)(v1 + 24), 2u);
    if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
      v13 = 0;
    if ( v13 )
      sub_549A0(v0 + 1609, dword_D41A4 + 1865);
    v2 = dword_D41A4;
    *(_DWORD *)(v0 + 24) = *(_DWORD *)(dword_D41A4 + 280);
    *v11 = 1;
    *(_WORD *)(v0 + 7) = v12;
    if ( (*(_BYTE *)(v2 + 22) & 0x10) == 0 && v12 != *(__int16 *)(dword_D41A0 + 12) )
      *(_BYTE *)(v0 + 9) = 1;
    *(_WORD *)(v0 + 16) = 32;
    *(_WORD *)(v0 + 477) = 128;
    v3 = *(_WORD *)(v0 + 16);
    *(_BYTE *)(v0 + 993) = 2;
    v4 = 0;
    *(_WORD *)(v0 + 14) = v3 - 1;
    while ( v4 < (int)*(unsigned __int16 *)(v0 + 16) )
    {
      v5 = 7 * v4++;
      *(_DWORD *)(v0 + 2 * v5 + 479) = *(_DWORD *)(v0 + 465);
      *(_DWORD *)(v0 + 2 * v5 + 483) = *(_DWORD *)(v0 + 469);
      *(_DWORD *)(v0 + 2 * v5 + 487) = *(_DWORD *)(v0 + 473);
      *(_WORD *)(v0 + 2 * v5 + 491) = *(_WORD *)(v0 + 477);
    }
    if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
      *(_BYTE *)(v0 + 1446) = byte_E131C[v12];
    v6 = (char *)(v0 + 927);
    v7 = (&off_D93A0)[sub_61790(v12)];
    do
    {
      v8 = *v7;
      *v6 = *v7;
      if ( !v8 )
        break;
      v9 = v7[1];
      v7 += 2;
      v6[1] = v9;
      v6 += 2;
    }
    while ( v9 );
    result = sub_54A50(v12, v0);
    v0 += 2124;
    v11 += 10;
    ++v12;
  }
  while ( v12 < 8u );
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D93A0: using guessed type char *off_D93A0;

//----- (000533B0) --------------------------------------------------------
char __cdecl sub_533B0(__int16 a1, void *a2)
{
  int v2; // edi
  int v3; // ebx
  int v5; // esi
  int *v6; // eax
  int v7; // edi
  char v8[64]; // [esp+0h] [ebp-44h] BYREF
  int v9; // [esp+40h] [ebp-4h]

  v2 = dword_E9C38;
  if ( a1 < 1000 )
  {
    sprintf(v8, "%c:%s/%s/levels.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aClevels);
    v3 = sub_98817((int)v8, 512);
    if ( v3 == -1 )
    {
      v3 = sub_98817((int)aLevelsLevelsDa, 512);
      if ( v3 == -1 )
        return 0;
    }
    sprintf(v8, "%c:%s/%s/levels.tab", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aClevels);
    v5 = sub_98817((int)v8, 512);
    if ( v5 == -1 )
    {
      v5 = sub_98817((int)aLevelsLevelsTa, 512);
      if ( v5 == -1 )
      {
        sub_98882(v3);
        return 0;
      }
    }
    sub_988A7(v5, v2, 4000);
    v6 = (int *)(v2 + 4 * a1);
    v7 = *v6;
    v9 = v6[1] - *v6;
    sub_98882(v5);
    if ( filelength )
    {
      sub_9891E(v3, v7, 0);
      sub_988A7(v3, dword_E9C38, v9);
      if ( sub_9894C(dword_E9C38, (char *)dword_E9C38) < 0 )
      {
        printf(aErrorDecompres);
        return 0;
      }
      qmemcpy(a2, (const void *)dword_E9C38, 0x6604u);
      memset(dword_E9C38, 0, 26116);
    }
    sub_98882(v3);
    sub_56C00((int)a2);
    sub_53590((int)a2);
  }
  return 1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// D41A4: using guessed type int dword_D41A4;
// E9C38: using guessed type int dword_E9C38;

//----- (00053590) --------------------------------------------------------
int __cdecl sub_53590(int a1)
{
  int result; // eax

  result = *(unsigned __int16 *)(a1 + 2);
  *(_DWORD *)(dword_D41A0 + 4) = result;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00053770) --------------------------------------------------------
char __cdecl sub_53770(__int16 a1)
{
  int v1; // eax
  char v3[64]; // [esp+0h] [ebp-40h] BYREF

  sprintf(v3, "%s/gam%05d.dat", aMovie, a1);
  v1 = sub_98817((int)v3, 512);
  if ( v1 == -1 )
    return 0;
  sub_98882(v1);
  return 1;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (00053950) --------------------------------------------------------
char __cdecl sub_53950(__int16 a1)
{
  int v1; // eax
  char v3[64]; // [esp+0h] [ebp-40h] BYREF

  sprintf(v3, "%s/map%05d.dat", aMovie, a1);
  v1 = sub_98817((int)v3, 512);
  if ( v1 == -1 )
    return 0;
  sub_98882(v1);
  return 1;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (000539A0) --------------------------------------------------------
char sub_539A0()
{
  int v0; // eax
  int v1; // ebx
  char v3; // [esp+0h] [ebp-4h]

  v3 = 1;
  v0 = sub_98817((int)aDataBldgprmDat, 512);
  v1 = v0;
  if ( v0 < 0 )
    return 0;
  sub_988A7(v0, (int)word_D93C0, 304);
  sub_98882(v1);
  return v3;
}
// D93C0: using guessed type __int16 word_D93C0[];

//----- (00053A40) --------------------------------------------------------
void __cdecl sub_53A40(char *a1)
{
  char v1; // ah
  int v2; // eax
  int v3; // edx
  int v4; // edx
  char v5; // al
  int v6; // ecx
  char v7; // dh
  int v8; // edi
  int v9; // eax
  int v10; // edx
  int v11; // edx
  char v12; // ch
  int v13; // eax
  char v14[64]; // [esp+0h] [ebp-48h] BYREF
  char v15; // [esp+40h] [ebp-8h]
  char v16; // [esp+44h] [ebp-4h]

  v1 = *(_BYTE *)(dword_D41A4 + 22);
  if ( (v1 & 4) != 0 )
  {
    v15 = 0;
    if ( !*(_DWORD *)(dword_D41A4 + 35) && !((int)&a1[-dword_D41A0 - 28222] / 10) )
    {
      sprintf(v14, "%s/mvi%05d.dat", aMovie, *(__int16 *)(dword_D41A4 + 39));
      v2 = sub_98817((int)v14, 512);
      v3 = dword_D41A4;
      *(_DWORD *)(dword_D41A4 + 35) = v2;
      if ( v2 <= -1 || !sub_54D30(*(_WORD *)(v3 + 39)) )
        v15 = 1;
      if ( v15 )
      {
        v4 = dword_D41A4;
        v5 = *(_BYTE *)(dword_D41A4 + 22);
        *(_DWORD *)(dword_D41A4 + 35) = 0;
        *(_BYTE *)(v4 + 22) = v5 & 0xFB;
      }
      else
      {
        sub_53C70();
      }
    }
    if ( v15 )
      goto LABEL_21;
    v6 = *(_DWORD *)(dword_D41A4 + 35);
    if ( !v6 )
      goto LABEL_21;
    if ( *a1 != 2 && sub_988A7(v6, (int)a1, 10) == 10 )
    {
      v7 = *a1;
      if ( *a1 == 13 )
      {
        *a1 = 0;
        goto LABEL_21;
      }
      if ( v7 != 2 && v7 != 29 && !sub_473E0() )
        goto LABEL_21;
    }
    v15 = 1;
LABEL_21:
    if ( v15 )
    {
      sub_53CC0();
      *(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) = 8;
      sub_53CA0();
      *a1 = 0;
    }
    return;
  }
  if ( (v1 & 2) != 0 )
  {
    v8 = *(_DWORD *)(dword_D41A4 + 35);
    v16 = 0;
    if ( !v8 && !((int)&a1[-dword_D41A0 - 28222] / 10) )
    {
      sprintf(v14, "%s/mvi%05d.dat", aMovie, *(__int16 *)(dword_D41A4 + 39));
      v9 = sub_98817((int)v14, 546);
      v10 = dword_D41A4;
      *(_DWORD *)(dword_D41A4 + 35) = v9;
      if ( v9 <= -1 || !sub_54F00(*(_WORD *)(v10 + 39)) )
        v16 = 1;
      if ( v16 )
      {
        v11 = dword_D41A4;
        v12 = *(_BYTE *)(dword_D41A4 + 22);
        *(_DWORD *)(dword_D41A4 + 35) = 0;
        *(_BYTE *)(v11 + 22) = v12 & 0xFD;
      }
      else
      {
        sub_53C70();
      }
    }
    if ( !v16 )
    {
      v13 = *(_DWORD *)(dword_D41A4 + 35);
      if ( v13 )
      {
        if ( sub_98CAA(v13, (int)a1, 10) != 10 )
          sub_53CC0();
        if ( *a1 == 12 )
          *a1 = 0;
      }
    }
  }
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00053C70) --------------------------------------------------------
int sub_53C70()
{
  int result; // eax
  int v1; // edx

  result = dword_D41A4;
  *(_DWORD *)(dword_D41A4 + 26) = 0;
  v1 = *(_DWORD *)(result + 22);
  *(_DWORD *)(result + 30) = 0;
  *(_DWORD *)(result + 22) = v1 | 0x1208000;
  return result;
}
// D41A4: using guessed type int dword_D41A4;

//----- (00053CA0) --------------------------------------------------------
int sub_53CA0()
{
  int result; // eax

  result = dword_D41A4;
  *(_DWORD *)(dword_D41A4 + 22) &= 0xFEDF7FFF;
  return result;
}
// D41A4: using guessed type int dword_D41A4;

//----- (00053CC0) --------------------------------------------------------
int sub_53CC0()
{
  int result; // eax
  char v1; // dl

  result = dword_D41A4;
  if ( *(_DWORD *)(dword_D41A4 + 35) )
  {
    sub_98882(*(_DWORD *)(dword_D41A4 + 35));
    result = dword_D41A4;
    v1 = *(_BYTE *)(dword_D41A4 + 22);
    *(_DWORD *)(dword_D41A4 + 35) = 0;
    *(_BYTE *)(result + 22) = v1 & 0xD9;
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;

//----- (00053CF0) --------------------------------------------------------
int __cdecl sub_53CF0(int a1)
{
  return access(a1, 0);
}
// 98CF2: using guessed type _DWORD __cdecl access(_DWORD, _DWORD);

//----- (00053D10) --------------------------------------------------------
char __cdecl sub_53D10(unsigned __int8 a1, const char *a2, char *a3)
{
  char *v4; // esi
  char *v5; // edi
  char v6; // al
  char v7; // al
  char *v8; // esi
  char *v9; // edi
  char v10; // al
  char v11; // al
  char *v13; // edi
  char v14; // al
  char v15; // al
  char v16[144]; // [esp+0h] [ebp-12h] BYREF
  char v17[144]; // [esp+90h] [ebp+7Eh] BYREF
  char v18[8]; // [esp+120h] [ebp+10Eh] BYREF

  if ( dos_getdiskfree(a1 - 64, v18) )
    return 1;
  sprintf(v16, "%c:%s", a1, a2);
  if ( (__int16)sub_53CF0((int)v16) <= -1 && mkdir(v16) )
    return 2;
  v4 = v16;
  v5 = v17;
  do
  {
    v6 = *v4;
    *v5 = *v4;
    if ( !v6 )
      break;
    v7 = v4[1];
    v4 += 2;
    v5[1] = v7;
    v5 += 2;
  }
  while ( v7 );
  v8 = &aVe[2];
  v9 = &v17[strlen(v17)];
  do
  {
    v10 = *v8;
    *v9 = *v8;
    if ( !v10 )
      break;
    v11 = v8[1];
    v8 += 2;
    v9[1] = v11;
    v9 += 2;
  }
  while ( v11 );
  v13 = &v17[strlen(v17)];
  do
  {
    v14 = *a3;
    *v13 = *a3;
    if ( !v14 )
      break;
    v15 = a3[1];
    a3 += 2;
    v13[1] = v15;
    v13 += 2;
  }
  while ( v15 );
  if ( (sub_53CF0((int)v17) & 0x8000u) != 0 && mkdir(v17) )
    return 2;
  else
    return 3;
}
// 8C1E8: using guessed type _DWORD __cdecl dos_getdiskfree(_DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98D30: using guessed type _DWORD __cdecl mkdir(_DWORD);
// 53D10: using guessed type char var_8[8];
// 53D10: using guessed type char var_98[144];

//----- (00053E60) --------------------------------------------------------
int __cdecl sub_53E60(int a1, char *a2)
{
  int result; // eax
  int v3; // ebx
  int v4; // esi

  result = sub_98817(a1, 512);
  v3 = result;
  if ( result != -1 )
  {
    v4 = filelength(result);
    sub_988A7(v3, (int)a2, v4);
    sub_98882(v3);
    result = sub_9894C((int)a2, a2);
    if ( result >= 0 )
    {
      if ( !result )
        return v4;
    }
    else
    {
      printf(aErrorDecompres_0);
      return -2;
    }
  }
  return result;
}
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);

//----- (00053EF0) --------------------------------------------------------
int __cdecl sub_53EF0(int a1, int a2)
{
  int v2; // esi
  int v3; // eax
  int v4; // edi
  unsigned __int8 v6; // [esp+0h] [ebp-4h]

  v6 = 0;
  v2 = sub_98817(a1, 512);
  v3 = sub_98817(a2, 512);
  v4 = v3;
  if ( v2 == -1 || v3 == -1 )
    v6 = 1;
  if ( v2 > -1 )
    sub_98882(v2);
  if ( v4 > -1 )
    sub_98882(v4);
  return v6;
}

//----- (00053F60) --------------------------------------------------------
bool __cdecl sub_53F60(int a1)
{
  return (unsigned __int16)access(a1, 0) == 0;
}
// 98CF2: using guessed type _DWORD __cdecl access(_DWORD, _DWORD);

//----- (00053F80) --------------------------------------------------------
char __cdecl sub_53F80(const char *a1, const char *a2, const char *a3)
{
  int v3; // ebx
  int v4; // esi
  int v5; // eax
  int v6; // edi
  int v8; // ebx
  int v9; // edi
  int v10; // ebx
  int v11; // eax
  int v12; // esi
  int v13; // esi
  int v14; // eax
  char v15[144]; // [esp+0h] [ebp-194h] BYREF
  char v16[144]; // [esp+90h] [ebp-104h] BYREF
  char v17[100]; // [esp+120h] [ebp-74h] BYREF
  int v18; // [esp+184h] [ebp-10h]
  int v19; // [esp+188h] [ebp-Ch]
  int v20; // [esp+18Ch] [ebp-8h]
  int v21; // [esp+190h] [ebp-4h]

  if ( !sub_53F60((int)a1) )
    return 2;
  if ( !sub_53F60((int)a2) )
    return 1;
  sprintf(v15, "%s/%s.tab", a1, a3);
  sprintf(v16, "%s/%s.tab", a2, a3);
  v3 = sub_98817((int)v15, 512);
  if ( v3 == -1 )
    return 3;
  v4 = sub_98817((int)v16, 546);
  if ( v4 == -1 )
    return 3;
  v5 = filelength(v3);
  v6 = sub_988A7(v3, dword_180628, v5);
  v19 = sub_98CAA(v4, dword_180628, v6);
  sub_98882(v3);
  sub_98882(v4);
  if ( v6 != v19 )
    return 3;
  sprintf(v15, "%s/%s.dat", a1, a3);
  sprintf(v16, "%s/%s.dat", a2, a3);
  v8 = sub_98817((int)v15, 512);
  v21 = v8;
  if ( v8 == -1 )
    return 3;
  v9 = sub_98817((int)v16, 546);
  if ( v9 == -1 )
    return 3;
  v10 = filelength(v8);
  v18 = v10;
  v20 = 0;
  while ( v10 )
  {
    if ( v10 <= 64000 )
      v11 = v10;
    else
      v11 = 64000;
    v12 = sub_988A7(v21, dword_180628, v11);
    v10 -= v12;
    if ( sub_98CAA(v9, dword_180628, v12) != v12 )
    {
      sub_98882(v21);
      sub_98882(v9);
      return 3;
    }
    v20 += v12;
    v13 = v20;
    settextposition((__int16)dword_F4720, SHIWORD(dword_F4720));
    v14 = 100 * v13 / v18;
    if ( (__int16)v14 > 100 )
      LOWORD(v14) = 100;
    sprintf(v17, "%d%c", (__int16)v14, 37);
    outtext(v17);
  }
  sub_98882(v21);
  sub_98882(v9);
  memset(dword_180628, 0, 64000);
  return 0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// BD985: using guessed type _DWORD __cdecl settextposition(_DWORD, _DWORD);
// BDBED: using guessed type _DWORD __cdecl outtext(_DWORD);
// F4720: using guessed type int dword_F4720;
// 180628: using guessed type int dword_180628;

//----- (00054200) --------------------------------------------------------
char sub_54200()
{
  char v0; // bl
  char v1; // bh
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  char v7[64]; // [esp+0h] [ebp-2h] BYREF
  char v8[64]; // [esp+40h] [ebp+3Eh] BYREF
  int v9; // [esp+80h] [ebp+7Eh] BYREF

  v9 = 0;
  outtext(aCheckingSetupV);
  v0 = 1;
  v1 = 0;
  sprintf(v7, "%c:%s/%s/%s", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata, aVersionDat);
  sub_53E60((int)v7, (char *)&v9);
  if ( v9 != 60 )
    v1 = 1;
  outtext(asc_D0650);
  sprintf(v7, "%c:%s/%s/%s.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata, aTmaps00);
  sprintf(v8, "data/%s.dat", aTmaps00);
  if ( v1 || (unsigned __int16)sub_53EF0((int)v7, (int)v8) )
  {
    v2 = outtext(aCreatingSetupD);
    dword_F4720 = gettextposition(v2);
    sprintf(v7, "%c:%s/%s", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata);
    if ( sub_53F80(aData, v7, aTmaps00) )
      v0 = 0;
    outtext(asc_D0650);
  }
  if ( v0 )
  {
    sprintf(v7, "%c:%s/%s/%s.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata, aTmaps10);
    sprintf(v8, "data/%s.dat", aTmaps10);
    if ( v1 || (unsigned __int16)sub_53EF0((int)v7, (int)v8) )
    {
      v3 = outtext(aCreatingSetupD_0);
      dword_F4720 = gettextposition(v3);
      sprintf(v7, "%c:%s/%s", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata);
      if ( sub_53F80(aData, v7, aTmaps10) )
        v0 = 0;
      outtext(asc_D0650);
    }
  }
  if ( v0 )
  {
    sprintf(v7, "%c:%s/%s/%s.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata, aTmaps20);
    sprintf(v8, "data/%s.dat", aTmaps20);
    if ( v1 || (unsigned __int16)sub_53EF0((int)v7, (int)v8) )
    {
      v4 = outtext(aCreatingSetupD_1);
      dword_F4720 = gettextposition(v4);
      sprintf(v7, "%c:%s/%s", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata);
      if ( sub_53F80(aData, v7, aTmaps20) )
        v0 = 0;
      outtext(asc_D0650);
    }
  }
  if ( v0 && (*(_BYTE *)(dword_D41A4 + 22) & 8) == 0 )
  {
    sprintf(v7, "%c:%s/%s/levels.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aClevels);
    v5 = outtext(aSettingUpLevel);
    dword_F4720 = gettextposition(v5);
    sprintf(v7, "%c:%s/%s", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aClevels);
    if ( sub_53F80(aLevels, v7, aLevels) )
      v0 = 0;
    outtext(asc_D0650);
  }
  if ( v0 && v1 )
  {
    sprintf(v7, "%c:%s/%s/%s", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aCdata, aVersionDat);
    v9 = 60;
    sub_98C48((int)v7, (int)&v9, 4);
  }
  return v0;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// BD953: using guessed type int __fastcall gettextposition(_DWORD);
// BDBED: using guessed type _DWORD __cdecl outtext(_DWORD);
// D41A4: using guessed type int dword_D41A4;
// F4720: using guessed type int dword_F4720;

//----- (00054600) --------------------------------------------------------
int sub_54600()
{
  int result; // eax
  char v1[28]; // [esp+0h] [ebp-38h] BYREF
  __int16 v2[14]; // [esp+1Ch] [ebp-1Ch] BYREF

  v2[0] = 0;
  result = int386(51, v2, v1);
  dword_E3768 = 0;
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E3768: using guessed type int dword_E3768;
// 54600: using guessed type char var_38[28];
// 54600: using guessed type __int16 var_1C[14];

//----- (00054630) --------------------------------------------------------
__int16 __cdecl sub_54630(__int16 a1)
{
  __int16 result; // ax

  result = a1;
  if ( (unsigned __int16)a1 >= 0x10u )
  {
    if ( (unsigned __int16)a1 <= 0x10u )
    {
      return sub_84250((int)aDataBlock16Dat);
    }
    else if ( a1 == 32 )
    {
      return sub_84250((int)aDataBlock32Dat);
    }
  }
  return result;
}

//----- (00054660) --------------------------------------------------------
int __cdecl sub_54660(unsigned __int8 a1, int a2)
{
  int result; // eax

  result = a2;
  if ( a1 )
  {
    if ( a1 > 1u )
    {
      if ( a1 == 2 )
      {
        if ( (unsigned __int16)a2 >= 0x10u )
        {
          if ( (unsigned __int16)a2 <= 0x10u )
          {
            sub_53E60((int)aDataBl16c00Dat, (char *)dword_E9C2C);
          }
          else if ( (_WORD)a2 == 32 )
          {
            sub_53E60((int)aDataBl32c00Dat, (char *)dword_E9C2C);
          }
        }
        return sub_53E60((int)aDataTmaps20Tab, (char *)dword_F6ED0);
      }
      return result;
    }
    if ( (unsigned __int16)a2 >= 0x10u )
    {
      if ( (unsigned __int16)a2 <= 0x10u )
      {
        if ( (*(_BYTE *)(dword_D41A0 + 196306) & 2) != 0 )
          sub_53E60((int)aDataBl16f00Dat, (char *)dword_E9C2C);
        else
          sub_53E60((int)aDataBl16n00Dat, (char *)dword_E9C2C);
      }
      else
      {
        if ( (_WORD)a2 != 32 )
          return sub_53E60((int)aDataTmaps10Tab, (char *)dword_F6ED0);
        if ( (*(_BYTE *)(dword_D41A0 + 196306) & 2) != 0 )
          sub_53E60((int)aDataBl32f00Dat, (char *)dword_E9C2C);
        else
          sub_53E60((int)aDataBl32n00Dat, (char *)dword_E9C2C);
      }
      sub_53E60((int)aDataSkyn00Dat, off_D41A8);
    }
    return sub_53E60((int)aDataTmaps10Tab, (char *)dword_F6ED0);
  }
  if ( (unsigned __int16)a2 >= 0x10u )
  {
    if ( (unsigned __int16)a2 <= 0x10u )
    {
      sub_53E60((int)aDataBlock16Dat_0, (char *)dword_E9C2C);
      sub_53E60((int)aDataSkyd00Dat, off_D41A8);
    }
    else if ( (_WORD)a2 == 32 )
    {
      sub_53E60((int)aDataBlock32Dat_0, (char *)dword_E9C2C);
      sub_53E60((int)aDataSkyd00Dat, off_D41A8);
    }
  }
  return sub_53E60((int)aDataTmaps00Tab, (char *)dword_F6ED0);
}
// D41A0: using guessed type int dword_D41A0;
// D41A8: using guessed type char *off_D41A8;
// E9C2C: using guessed type int dword_E9C2C;
// F6ED0: using guessed type int dword_F6ED0;

//----- (00054800) --------------------------------------------------------
unsigned __int8 __cdecl sub_54800(unsigned __int8 a1)
{
  unsigned __int8 result; // al

  result = a1;
  if ( a1 )
  {
    if ( a1 <= 1u )
    {
      result = sub_53E60((int)aDataTablesnDat, byte_F6EE0);
      word_D4B7E = 255;
      word_D4B7C = 0;
    }
    else if ( a1 == 2 )
    {
      sub_53E60((int)aDataTablescDat, byte_F6EE0);
      result = -1;
      word_D4B7C = 254;
      word_D4B7E = 255;
    }
  }
  else
  {
    result = sub_53E60((int)aDataTablesdDat, byte_F6EE0);
    word_D4B7E = 0;
    word_D4B7C = 254;
  }
  return result;
}
// D4B7C: using guessed type __int16 word_D4B7C;
// D4B7E: using guessed type __int16 word_D4B7E;

//----- (000548B0) --------------------------------------------------------
__int16 __cdecl sub_548B0(__int16 *a1)
{
  __int16 result; // ax

  result = *(__int16 *)((char *)a1 + 7);
  if ( result == *(_WORD *)(dword_D41A0 + 12) )
    return sub_5BDC0(a1[509], a1[510]);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (000548F0) --------------------------------------------------------
_WORD *__cdecl sub_548F0(_WORD *a1)
{
  _WORD *result; // eax
  __int16 v2; // dx

  result = a1;
  if ( *(_WORD *)((char *)a1 + 7) == *(_WORD *)(dword_D41A0 + 12) )
  {
    if ( word_1805C2 == 7 || word_1805C2 == 1 || word_1805C2 == 2 )
    {
      a1[509] = word_E3760;
      v2 = word_E3762;
    }
    else
    {
      a1[509] = dword_1805B0;
      v2 = dword_1805B4;
    }
    a1[510] = v2;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E3760: using guessed type __int16 word_E3760;
// E3762: using guessed type __int16 word_E3762;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (00054960) --------------------------------------------------------
int sub_54960()
{
  __int16 v0; // ax

  if ( (word_180660 & 1) != 0 )
    v0 = 400;
  else
    v0 = 480;
  return sub_5BDC0(426, v0 - 72 + 17);
}
// 180660: using guessed type __int16 word_180660;

//----- (000549A0) --------------------------------------------------------
int __cdecl sub_549A0(int a1, int a2)
{
  int result; // eax

  qmemcpy((void *)(a1 + 390), (const void *)(a2 + 390), 0x18u);
  qmemcpy((void *)(a1 + 414), (const void *)(a2 + 414), 2u);
  qmemcpy((void *)a1, (const void *)a2, 0x68u);
  qmemcpy((void *)(a1 + 442), (const void *)(a2 + 442), 0x18u);
  qmemcpy((void *)(a1 + 466), (const void *)(a2 + 466), 2u);
  qmemcpy((void *)(a1 + 338), (const void *)(a2 + 338), 0x18u);
  qmemcpy((void *)(a1 + 362), (const void *)(a2 + 362), 2u);
  result = 26;
  qmemcpy((void *)(a1 + 468), (const void *)(a2 + 468), 0x18u);
  qmemcpy((void *)(a1 + 492), (const void *)(a2 + 492), 2u);
  return result;
}

//----- (00054A50) --------------------------------------------------------
int __cdecl sub_54A50(unsigned __int16 a1, int a2)
{
  int i; // eax
  int v3; // eax
  unsigned __int16 v4; // cx
  int v5; // esi
  int result; // eax
  int v7; // ebx
  char v8; // bl
  _BOOL1 v9; // zf
  int v10; // edi
  int v11; // [esp+0h] [ebp-30h]
  int v12; // [esp+20h] [ebp-10h]
  int v13; // [esp+24h] [ebp-Ch]
  int v14; // [esp+28h] [ebp-8h]
  unsigned int v15; // [esp+2Ch] [ebp-4h]

  for ( i = 0; i < 26; *(_BYTE *)(a2 + i + 2076) = 0 )
  {
    ++i;
    *(_WORD *)(a2 + 2 * i + 1815) = 0;
    *(_BYTE *)(a2 + i + 2024) = 0;
  }
  *(_WORD *)(a2 + 2103) = -1;
  v3 = dword_D41A4;
  *(_WORD *)(a2 + 2105) = -1;
  if ( (*(_BYTE *)(v3 + 22) & 0x10) != 0 )
    v4 = 0;
  else
    v4 = a1;
  v5 = 0;
  v14 = 0;
  do
  {
    result = (unsigned __int8)byte_D94FF[v5];
    v7 = result + 110 * v4 + dword_D41A0;
    if ( *(_BYTE *)(v7 + 221435) > 2u )
      *(_BYTE *)(v7 + 221435) = 2;
    if ( *(_BYTE *)(a2 + 9) == 1 )
    {
      *(_BYTE *)(a2 + result + 2051) = *(_BYTE *)(110 * v4 + dword_D41A0 + result + 221435);
    }
    else if ( ((*(_BYTE *)(dword_D41A4 + 22) & 8) != 0 || (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0)
           && *(char *)(a2 + result + 2051) < (int)*(unsigned __int8 *)(110 * v4 + dword_D41A0 + result + 221435) )
    {
      v15 = *(unsigned __int8 *)(110 * v4 + dword_D41A0 + result + 221435);
      if ( v15 > 2 )
        v15 = 2;
      *(_BYTE *)(a2 + result + 2051) = v15;
      *(_DWORD *)(a2 + 4 * result + 1609) = *(_DWORD *)&byte_DA818[80 * result + 18 + 26 * v15] + 1;
    }
    *(_BYTE *)(a2 + v5 + 1921) = -1;
    v8 = 0;
    v12 = a2 + result;
    if ( *(_BYTE *)(a2 + 9) == 1 )
    {
      v11 = dword_D41A0;
      *(_BYTE *)(v12 + 1973) = *(_BYTE *)(result + 110 * v4 + dword_D41A0 + 221461);
      if ( !*(_BYTE *)(result + 110 * a1 + v11 + 221409) )
        goto LABEL_35;
      v9 = *(_BYTE *)(v12 + 1973) == 0;
      goto LABEL_33;
    }
    v13 = result + 110 * v4 + dword_D41A0;
    if ( *(_BYTE *)(v13 + 221461) )
      goto LABEL_35;
    if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
    {
      if ( !*(_BYTE *)(v13 + 221409) )
        goto LABEL_35;
      v9 = *(_BYTE *)(v13 + 221461) == 0;
LABEL_33:
      if ( !v9 )
        goto LABEL_35;
      goto LABEL_34;
    }
    if ( *(char *)(dword_D41A4 + 24) >= 0 && *(_WORD *)(dword_D41A4 + 43) )
    {
      if ( !*(_BYTE *)(v12 + 1999) )
        goto LABEL_35;
LABEL_34:
      v8 = 1;
      goto LABEL_35;
    }
    if ( *(_BYTE *)(a2 + result + 1999) )
      goto LABEL_34;
    v10 = result + 110 * v4 + dword_D41A0;
    if ( *(_BYTE *)(v10 + 221409) )
    {
      if ( !*(_BYTE *)(v10 + 221461) )
        goto LABEL_34;
    }
LABEL_35:
    if ( v8 )
    {
      *(_WORD *)(a2 + 2 * result + 1817) = 1;
      *(_BYTE *)(a2 + result + 1999) = 1;
      if ( *(__int16 *)(a2 + 2103) == -1 )
      {
        *(_WORD *)(a2 + 2103) = result;
      }
      else if ( *(__int16 *)(a2 + 2105) == -1 )
      {
        *(_WORD *)(a2 + 2105) = result;
      }
      result = v14 + 1;
      *(_BYTE *)(a2 + v14 + 1 + 1920) = v14;
      ++v14;
    }
    ++v5;
  }
  while ( v5 < 26 );
  return result;
}
// 54B5B: conditional instruction was optimized away because %var_14.4<100u
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00054D30) --------------------------------------------------------
char __cdecl sub_54D30(__int16 a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // ax
  int v4; // eax
  _DWORD *v5; // edi
  _DWORD *v6; // edi
  char result; // al
  char v8[128]; // [esp+0h] [ebp-36h] BYREF
  int v9; // [esp+80h] [ebp+4Ah]
  int v10; // [esp+84h] [ebp+4Eh]
  int v11; // [esp+88h] [ebp+52h]
  int v12; // [esp+8Ch] [ebp+56h]
  int v13; // [esp+90h] [ebp+5Ah]
  int v14; // [esp+94h] [ebp+5Eh]
  int v15; // [esp+98h] [ebp+62h]
  int v16; // [esp+9Ch] [ebp+66h]
  int v17; // [esp+A0h] [ebp+6Ah]
  int v18; // [esp+A4h] [ebp+6Eh]
  int v19; // [esp+A8h] [ebp+72h]
  int v20; // [esp+ACh] [ebp+76h]
  char v21; // [esp+B0h] [ebp+7Ah]

  v21 = 1;
  v17 = *(_DWORD *)(dword_D41A0 + 8586);
  v18 = *(_DWORD *)(dword_D41A0 + 8590);
  v19 = *(_DWORD *)(dword_D41A0 + 8594);
  v20 = *(_DWORD *)(dword_D41A0 + 8598);
  v13 = *(_DWORD *)(dword_D41A0 + 8602);
  v14 = *(_DWORD *)(dword_D41A0 + 8606);
  v15 = *(_DWORD *)(dword_D41A0 + 8610);
  v16 = *(_DWORD *)(dword_D41A0 + 8614);
  v9 = *(_DWORD *)(dword_D41A0 + 8618);
  v10 = *(_DWORD *)(dword_D41A0 + 8622);
  v11 = *(_DWORD *)(dword_D41A0 + 8626);
  v12 = *(_DWORD *)(dword_D41A0 + 8630);
  sprintf(v8, "%s/%s%03d.dat", aMovie, aSmap, a1);
  v1 = sub_98817((int)v8, 512);
  v2 = v1;
  if ( v1 >= 0 )
  {
    sub_988A7(v1, (int)byte_10B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_11B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_12B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_13B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_14B4E0, (int)sub_10000);
    sub_988A7(v2, (int)word_15B4E0, (int)&loc_20000);
    sub_988A7(v2, (int)byte_F2CD0, 4802);
    sub_98882(v2);
  }
  sprintf(v8, "%s/%s%03d.dat", aMovie, aSlev, a1);
  sub_53E60((int)v8, (char *)dword_D41A0);
  sub_55100(2);
  v3 = sub_57680();
  sub_49F90(v3);
  *(_DWORD *)(dword_D41A0 + 4582) = -1;
  sub_71990();
  sub_473B0();
  v4 = dword_D41A0;
  v5 = (_DWORD *)(dword_D41A0 + 8586);
  *(_DWORD *)(dword_D41A0 + 8586) = v17;
  *++v5 = v18;
  *++v5 = v19;
  v5[1] = v20;
  *(_DWORD *)(v4 + 8602) = v13;
  *(_DWORD *)(v4 + 8606) = v14;
  *(_DWORD *)(v4 + 8610) = v15;
  *(_DWORD *)(v4 + 8614) = v16;
  v6 = (_DWORD *)(v4 + 8618);
  result = v21;
  *v6++ = v9;
  *v6++ = v10;
  *v6 = v11;
  v6[1] = v12;
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00054F00) --------------------------------------------------------
char __cdecl sub_54F00(__int16 a1)
{
  int v1; // eax
  int v2; // ebx
  __int16 v3; // ax
  int v5; // [esp-8h] [ebp-Eh]
  char v6[128]; // [esp+0h] [ebp-6h] BYREF
  char v7; // [esp+80h] [ebp+7Ah]

  v7 = 1;
  sub_71930();
  sub_55100(1);
  sprintf(v6, "%s/%s%03d.dat", aMovie, aSlev, a1);
  v5 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 224758) = &unk_D83AC;
  sub_98C48((int)v6, v5, 224791);
  sprintf(v6, "%s/%s%03d.dat", aMovie, aSmap, a1);
  v1 = sub_98817((int)v6, 546);
  v2 = v1;
  if ( v1 >= 0 )
  {
    sub_98CAA(v1, (int)byte_10B4E0, (int)sub_10000);
    sub_98CAA(v2, (int)byte_11B4E0, (int)sub_10000);
    sub_98CAA(v2, (int)byte_12B4E0, (int)sub_10000);
    sub_98CAA(v2, (int)byte_13B4E0, (int)sub_10000);
    sub_98CAA(v2, (int)byte_14B4E0, (int)sub_10000);
    sub_98CAA(v2, (int)word_15B4E0, (int)&loc_20000);
    sub_98CAA(v2, (int)byte_F2CD0, 4802);
    sub_98882(v2);
  }
  v3 = sub_55100(2);
  sub_49F90(v3);
  *(_DWORD *)(dword_D41A0 + 4582) = -1;
  return v7;
}
// 10000: using guessed type void __noreturn sub_10000();
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00055080) --------------------------------------------------------
char __cdecl sub_55080(unsigned __int8 a1, int a2)
{
  char v2; // bl
  __int16 v3; // ax

  v2 = 0;
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) == 0 )
  {
    sub_71930();
    sub_55100(1);
    v2 = sub_55250(a1);
    if ( v2 )
    {
      v2 = sub_55320(a1);
      if ( v2 )
        v2 = sub_55450(a1, a2);
    }
    v3 = sub_55100(2);
    sub_49F90(v3);
    *(_DWORD *)(dword_D41A0 + 4582) = -1;
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00055100) --------------------------------------------------------
int __cdecl sub_55100(char a1)
{
  int v1; // edi
  int v2; // eax
  int v3; // edx
  int v4; // ebx
  int v5; // esi
  int v6; // eax
  unsigned __int8 v7; // cl
  int i; // ebx
  unsigned __int8 v9; // al
  int v10; // eax
  unsigned int v11; // ecx
  int result; // eax
  int j; // ebx

  v1 = dword_D41A0;
  if ( a1 == 1 )
    v2 = -1;
  else
    v2 = 1;
  v3 = v2 * (dword_D41A0 + 28302);
  v4 = 0;
  v5 = v2 * (dword_D41A0 + 197393);
  while ( v4 < *(unsigned __int8 *)(v1 + 224769) )
  {
    v6 = v1 + 10 * v4;
    if ( !*(_DWORD *)(v6 + 222546) )
      goto LABEL_15;
    v7 = *(_BYTE *)(v6 + 222540);
    if ( v7 < 3u )
    {
      if ( !v7 )
        goto LABEL_15;
LABEL_11:
      v6 = v1 + 10 * v4;
      if ( (*(_BYTE *)(v6 + 222541) & 1) == 0 )
      {
        *(_DWORD *)(v6 + 222546) += v5;
        goto LABEL_15;
      }
LABEL_14:
      *(_DWORD *)(v6 + 222546) += v3;
      goto LABEL_15;
    }
    if ( v7 <= 3u )
    {
      if ( (*(_BYTE *)(v6 + 222541) & 1) == 0 )
        goto LABEL_15;
      goto LABEL_14;
    }
    if ( v7 == 4 )
      goto LABEL_11;
LABEL_15:
    ++v4;
  }
  for ( i = 1; ; ++i )
  {
    result = v1;
    if ( i > *(unsigned __int8 *)(v1 + 224768) )
      break;
    v9 = *(_BYTE *)(v1 + 8 * i + 222708);
    if ( v9 >= 3u && (v9 <= 5u || v9 >= 8u && v9 <= 9u) )
    {
      v10 = v1 + 8 * i;
      if ( (*(_BYTE *)(v10 + 222709) & 2) == 0 )
      {
        v11 = *(_DWORD *)((char *)sub_365F8 + v10);
        if ( v11 >= dword_EA3E4[0] && v11 < dword_EB384 )
          *(_DWORD *)((char *)sub_365F8 + v10) = v3 + v11;
      }
    }
  }
  for ( j = 1; j < 50; ++j )
  {
    result = v1 + 39 * j;
    if ( *(_BYTE *)(result + 222796) )
      *(_DWORD *)(result + 222806) += v3;
  }
  dword_D41A0 = v1;
  return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB384: using guessed type int dword_EB384;

//----- (00055250) --------------------------------------------------------
char __cdecl sub_55250(unsigned __int8 a1)
{
  char v1; // bl
  int v2; // esi
  int v3; // edi
  int v4; // eax
  int v6; // [esp-8h] [ebp-48h]
  char v7[64]; // [esp+0h] [ebp-40h] BYREF

  v1 = 0;
  sprintf(v7, "%c:%s/%s/%s%d.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSlev, a1 + 1);
  v2 = dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12);
  *(_DWORD *)(dword_D41A0 + 224758) = &unk_D83AC;
  v3 = *(_DWORD *)(v2 + 12621);
  v4 = j___clock();
  v6 = dword_D41A0;
  *(_DWORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12621) = v4 - *(_DWORD *)(v2 + 12621);
  if ( sub_98C48((int)v7, v6, 224791) == 224791 )
    v1 = 1;
  *(_DWORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12621) = v3;
  return v1;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98786: using guessed type int j___clock(void);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00055320) --------------------------------------------------------
char __cdecl sub_55320(unsigned __int8 a1)
{
  int v1; // eax
  int v2; // ebx
  char v4[64]; // [esp+0h] [ebp-48h] BYREF
  _BOOL1 v5; // [esp+40h] [ebp-8h]
  char v6; // [esp+44h] [ebp-4h]

  v6 = 0;
  sprintf(v4, "%c:%s/%s/%s%d.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSmap, a1 + 1);
  v1 = sub_98817((int)v4, 546);
  v2 = v1;
  if ( v1 >= 0 )
  {
    sub_98CAA(v1, (int)byte_10B4E0, (int)sub_10000);
    sub_98CAA(v2, (int)byte_11B4E0, (int)sub_10000);
    sub_98CAA(v2, (int)byte_12B4E0, (int)sub_10000);
    sub_98CAA(v2, (int)byte_13B4E0, (int)sub_10000);
    sub_98CAA(v2, (int)byte_14B4E0, (int)sub_10000);
    sub_98CAA(v2, (int)word_15B4E0, (int)&loc_20000);
    v5 = sub_98CAA(v2, (int)byte_F2CD0, 4802) != 4802;
    sub_98882(v2);
    return !v5;
  }
  return v6;
}
// 10000: using guessed type void __noreturn sub_10000();
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00055450) --------------------------------------------------------
char __cdecl sub_55450(unsigned __int8 a1, int a2)
{
  char v2; // bl
  char v4[64]; // [esp+0h] [ebp-48h] BYREF
  int v5[2]; // [esp+40h] [ebp-8h] BYREF

  v5[1] = a2;
  v5[0] = 15;
  v2 = 0;
  sprintf(v4, "%c:%s/%s/%s%d.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSver, a1 + 1);
  if ( sub_98C48((int)v4, (int)v5, 8) == 8 )
    return 1;
  return v2;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;

//----- (000555D0) --------------------------------------------------------
char __cdecl sub_555D0(unsigned __int8 a1, int a2)
{
  char v2; // bl
  __int16 v3; // ax
  int v4; // eax
  int v5; // edx
  int v6; // ecx
  int v7; // eax
  _DWORD *v8; // edi
  int v10; // [esp+0h] [ebp-34h]
  int v11; // [esp+4h] [ebp-30h]
  int v12; // [esp+8h] [ebp-2Ch]
  int v13; // [esp+Ch] [ebp-28h]
  int v14; // [esp+10h] [ebp-24h]
  int v15; // [esp+14h] [ebp-20h]
  int v16; // [esp+18h] [ebp-1Ch]
  int v17; // [esp+1Ch] [ebp-18h]
  int v18; // [esp+20h] [ebp-14h]
  int v19; // [esp+24h] [ebp-10h]
  int v20; // [esp+28h] [ebp-Ch]
  int v21; // [esp+2Ch] [ebp-8h]

  v2 = 0;
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) == 0 )
  {
    v14 = *(_DWORD *)(dword_D41A0 + 8586);
    v15 = *(_DWORD *)(dword_D41A0 + 8590);
    v16 = *(_DWORD *)(dword_D41A0 + 8594);
    v17 = *(_DWORD *)(dword_D41A0 + 8598);
    v10 = *(_DWORD *)(dword_D41A0 + 8602);
    v11 = *(_DWORD *)(dword_D41A0 + 8606);
    v12 = *(_DWORD *)(dword_D41A0 + 8610);
    v13 = *(_DWORD *)(dword_D41A0 + 8614);
    v18 = *(_DWORD *)(dword_D41A0 + 8618);
    v19 = *(_DWORD *)(dword_D41A0 + 8622);
    v20 = *(_DWORD *)(dword_D41A0 + 8626);
    v21 = *(_DWORD *)(dword_D41A0 + 8630);
    v2 = sub_55750(a1, a2);
    if ( v2 )
    {
      v2 = sub_558E0(a1);
      if ( v2 )
      {
        qmemcpy(
          (void *)(dword_D41A4 + 256),
          (const void *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230),
          0x84Cu);
        v2 = sub_55A10(a1);
        if ( v2 )
        {
          sub_55100(2);
          sub_57680();
          v3 = sub_549A0(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230 + 1609, dword_D41A4 + 1865);
          sub_49F90(v3);
          v4 = dword_D41A0;
          v5 = 2124 * *(__int16 *)(dword_D41A0 + 12);
          v6 = dword_D41A0 + 11230;
          *(_DWORD *)(dword_D41A0 + 4582) = -1;
          sub_55AB0(*(unsigned __int16 *)(v4 + 12), v6 + v5);
          sub_71990();
          sub_473B0();
        }
      }
    }
    v7 = dword_D41A0;
    v8 = (_DWORD *)(dword_D41A0 + 8586);
    *(_DWORD *)(dword_D41A0 + 8586) = v14;
    *++v8 = v15;
    *++v8 = v16;
    v8[1] = v17;
    *(_DWORD *)(v7 + 8602) = v10;
    *(_DWORD *)(v7 + 8606) = v11;
    *(_DWORD *)(v7 + 8610) = v12;
    *(_DWORD *)(v7 + 8614) = v13;
    *(_DWORD *)(v7 + 8618) = v18;
    *(_DWORD *)(v7 + 8622) = v19;
    *(_DWORD *)(v7 + 8626) = v20;
    *(_DWORD *)(v7 + 8630) = v21;
  }
  return v2;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00055750) --------------------------------------------------------
char __cdecl sub_55750(unsigned __int8 a1, int a2)
{
  int v2; // eax
  int v3; // esi
  int v4; // eax
  _BOOL1 v5; // bl
  int v6; // edi
  int v7; // eax
  int v8; // ebx
  void *v9; // esi
  char v11[64]; // [esp+0h] [ebp-54h] BYREF
  int v12[2]; // [esp+40h] [ebp-14h] BYREF
  char v13[4]; // [esp+48h] [ebp-Ch] BYREF
  int v14; // [esp+4Ch] [ebp-8h]
  char v15; // [esp+50h] [ebp-4h]

  v15 = 0;
  sprintf(v11, "%c:%s/%s/%s%d.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSver, a1 + 1);
  if ( sub_53E60((int)v11, (char *)v12) == 8 && v12[1] == a2 && v12[0] == 15 )
  {
    sprintf(v11, "%c:%s/%s/%s%d.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSlev, a1 + 1);
    v2 = sub_98817((int)v11, 512);
    v3 = v2;
    if ( v2 >= 0 )
    {
      v4 = sub_988A7(v2, (int)v13, 8);
      v5 = v4 != 8;
      if ( v4 == 8 && v14 != *(_DWORD *)(dword_D41A0 + 4) )
        v5 = 1;
      v6 = filelength(v3);
      sub_98882(v3);
      if ( v6 == 224791 && !v5 )
      {
        sprintf(v11, "%c:%s/%s/%s%d.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSmap, a1 + 1);
        v7 = sub_98817((int)v11, 512);
        v8 = v7;
        if ( v7 >= 0 )
        {
          v9 = (void *)filelength(v7);
          sub_98882(v8);
          if ( v9 == &loc_712C2 )
            return 1;
        }
      }
    }
  }
  return v15;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 55750: using guessed type char var_C[4];

//----- (000558E0) --------------------------------------------------------
char __cdecl sub_558E0(unsigned __int8 a1)
{
  int v1; // eax
  int v2; // ebx
  char v4[64]; // [esp+0h] [ebp-48h] BYREF
  _BOOL1 v5; // [esp+40h] [ebp-8h]
  char v6; // [esp+44h] [ebp-4h]

  v6 = 0;
  sprintf(v4, "%c:%s/%s/%s%d.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSmap, a1 + 1);
  v1 = sub_98817((int)v4, 512);
  v2 = v1;
  if ( v1 >= 0 )
  {
    sub_988A7(v1, (int)byte_10B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_11B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_12B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_13B4E0, (int)sub_10000);
    sub_988A7(v2, (int)byte_14B4E0, (int)sub_10000);
    sub_988A7(v2, (int)word_15B4E0, (int)&loc_20000);
    v5 = sub_988A7(v2, (int)byte_F2CD0, 4802) != 4802;
    sub_98882(v2);
    return !v5;
  }
  return v6;
}
// 10000: using guessed type void __noreturn sub_10000();
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00055A10) --------------------------------------------------------
char __cdecl sub_55A10(unsigned __int8 a1)
{
  char v1; // bl
  int v2; // ebx
  char v4[64]; // [esp+0h] [ebp-40h] BYREF

  v1 = 0;
  sprintf(v4, "%c:%s/%s/%s%d.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_0, aSave, aSlev, a1 + 1);
  if ( sub_53E60((int)v4, (char *)dword_D41A0) == 224791 )
  {
    v2 = dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12);
    *(_DWORD *)(v2 + 12621) = j___clock() - *(_DWORD *)(v2 + 12621);
    return 1;
  }
  return v1;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98786: using guessed type int j___clock(void);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00055AB0) --------------------------------------------------------
int __cdecl sub_55AB0(int a1, int a2)
{
  int result; // eax
  int v3; // esi
  int v4; // edi
  int v5; // edx
  int v6; // edx
  int v7; // edx
  int v8; // edx
  int v9; // [esp-4h] [ebp-10h]
  int v10; // [esp+0h] [ebp-Ch]
  int v11; // [esp+4h] [ebp-8h]

  result = *(unsigned __int16 *)(a2 + 10);
  v3 = 0;
  v4 = dword_EA3E4[(unsigned __int16)result];
  while ( v3 < 26 )
  {
    v5 = (unsigned __int8)byte_D94FF[v3];
    result = a2 + v5;
    if ( *(_BYTE *)(a2 + v5 + 1999) || *(_BYTE *)(result + 2025) )
    {
      result = 2 * v5;
      v11 = a2 + 2 * v5;
      if ( !*(_WORD *)(v11 + 1817) )
      {
        result = sub_4A190(v4 + 76, 15, v5);
        if ( result )
        {
          v10 = dword_D41A0 + 28302;
          *(_WORD *)(v11 + 1817) = (result - (dword_D41A0 + 28302)) / 168;
          *(_WORD *)(result + 40) = (v4 - v10) / 168;
          *(_BYTE *)(result + 12) |= 1u;
          LOBYTE(result) = sub_6D5E0(result, *(_BYTE *)(a2 + *(char *)(result + 64) + 2077));
        }
      }
    }
    else
    {
      v6 = a2 + 2 * v5;
      LOWORD(result) = *(_WORD *)(v6 + 1817);
      if ( (_WORD)result )
      {
        v9 = dword_EA3E4[(__int16)result];
        *(_WORD *)(v6 + 1817) = 0;
        result = sub_57F20(v9, v9);
      }
    }
    ++v3;
  }
  v7 = *(__int16 *)(a2 + 2103);
  if ( v7 != -1 && !*(_WORD *)(a2 + 2 * v7 + 1817) )
    *(_WORD *)(a2 + 2103) = -1;
  v8 = *(__int16 *)(a2 + 2105);
  if ( v8 != -1 && !*(_WORD *)(a2 + 2 * v8 + 1817) )
    *(_WORD *)(a2 + 2105) = -1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00055C00) --------------------------------------------------------
char __cdecl sub_55C00(__int16 a1)
{
  return sub_55750(0, a1);
}

//----- (00055C60) --------------------------------------------------------
unsigned int __usercall sub_55C60@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  unsigned int result; // eax
  int v4; // eax
  int v5; // edx
  unsigned __int16 v6; // ax
  int v7; // edx
  char v8; // cl
  __int16 v9; // ax
  __int16 v10; // ax
  unsigned __int8 v11; // ch
  __int64 v12; // rax
  char v13; // dl
  __int16 v14; // ax
  __int16 v15; // dx
  int v16; // [esp+0h] [ebp-4h]

  result = dword_D41A4;
  if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) == 0 )
  {
    v4 = abs16(*(_WORD *)(a3 + 1339));
    v5 = v4 + 2048;
    switch ( *(_BYTE *)(a3 + 2118) )
    {
      case 1:
      case 2:
        v5 = 1024;
        a2 = 1;
        a1 = -2;
        goto LABEL_9;
      case 3:
        a2 = 1;
        v16 = v4 + 2048;
        a1 = 1;
        break;
      case 4:
        a2 = 1;
        a1 = -2;
        v16 = v4 + 2116;
        break;
      case 5:
        a2 = -1;
        a1 = 3;
        goto LABEL_9;
      case 6:
        a2 = -1;
        a1 = -4;
        v16 = v4 + 2013;
        break;
      case 7:
        a2 = 1;
        a1 = 5;
LABEL_9:
        v16 = v5;
        break;
      default:
        break;
    }
    if ( *(_BYTE *)(a3 + 2118) == 1 )
    {
      if ( *(__int16 *)(a3 + 1339) >= 0 )
        *(_BYTE *)(a3 + 2119) = 1;
      else
        *(_BYTE *)(a3 + 2119) = -1;
      v6 = abs16(*(_WORD *)(a3 + 1339));
      *(_WORD *)(a3 + 2122) = 91;
      v7 = dword_D41A4;
      v8 = *(_BYTE *)(a3 + 2118);
      *(_WORD *)(a3 + 2120) = v6;
      v9 = dword_E3760;
      *(_BYTE *)(a3 + 2118) = v8 + 1;
      *(_WORD *)(v7 + 220) = v9;
      sub_55EB0(*(_WORD *)(a3 + 10));
    }
    *(_WORD *)(a3 + 2120) += a2 * *(_WORD *)(a3 + 2122);
    if ( a1 )
    {
      v10 = a1 + *(_WORD *)(a3 + 2122);
      *(_WORD *)(a3 + 2122) = v10;
      if ( v10 < 11 )
        *(_WORD *)(a3 + 2122) = 11;
      if ( *(__int16 *)(a3 + 2122) > 68 )
        *(_WORD *)(a3 + 2122) = 68;
    }
    if ( a2 > 0 && *(__int16 *)(a3 + 2120) >= v16 || a2 < 0 && *(__int16 *)(a3 + 2120) <= v16 )
    {
      v11 = *(_BYTE *)(a3 + 2118) + 1;
      *(_BYTE *)(a3 + 2118) = v11;
      if ( v11 > 3u )
        *(__int16 *)(a3 + 2122) >>= 1;
    }
    if ( *(_BYTE *)(a3 + 2118) >= 4u )
    {
      v12 = (__int16)dword_E3760 - *(__int16 *)(dword_D41A4 + 220);
      if ( (int)((HIDWORD(v12) ^ v12) - HIDWORD(v12)) > 16 )
        *(_BYTE *)(a3 + 2118) = 8;
      *(_WORD *)(dword_D41A4 + 220) = dword_E3760;
    }
    v13 = *(_BYTE *)(a3 + 2118);
    *(_WORD *)(a3 + 1002) = 0;
    if ( v13 == 8 )
    {
      result = sub_55EB0(*(_WORD *)(a3 + 10));
      *(_BYTE *)(a3 + 2118) = 0;
    }
    else
    {
      v14 = *(_WORD *)(a3 + 2120) * *(char *)(a3 + 2119);
      HIBYTE(v14) &= 7u;
      v15 = v14;
      result = *(unsigned __int16 *)(a3 + 16) - 1;
      *(_WORD *)(a3 + 14 * result + 489) = v15;
    }
  }
  return result;
}
// 55DD4: variable 'v16' is possibly undefined
// D41A4: using guessed type int dword_D41A4;
// E3760: using guessed type int dword_E3760;

//----- (00055EB0) --------------------------------------------------------
unsigned int __cdecl sub_55EB0(__int16 a1)
{
  unsigned int result; // eax
  unsigned int i; // edx

  for ( result = 0; (int)result < 29; ++result )
  {
    if ( result < 0xC )
    {
      if ( result == 1 )
        continue;
    }
    else if ( result <= 0xF || result >= 0x16 && result <= 0x17 )
    {
      continue;
    }
    for ( i = *(_DWORD *)(dword_D41A4 + 4 * result + 38403); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( *(unsigned __int16 *)(i + 150) == a1 )
        *(_WORD *)(i + 150) = 0;
    }
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00055F70) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // edi
  unsigned __int16 v4; // si
  __int16 v5; // fps
  __int16 v7[14]; // [esp+0h] [ebp-1Ch] BYREF

  memset(v7, 0, sizeof(v7));
  v7[6] = 0;
  v7[0] = 13057;
  int386(33, v7, v7);
  signal(7, 1);
  signal(4, 1);
  signal(6, 1);
  sub_56210(argc, (int)argv);
  sub_5B8D0(v5);
  sub_46830(0, v3, v4);
  sub_5BC20();
  sub_56730();
  return 0;
}
// 55FE1: variable 'v3' is possibly undefined
// 55FE1: variable 'v4' is possibly undefined
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 98DC0: using guessed type _DWORD __cdecl signal(_DWORD, _DWORD);

//----- (000560D0) --------------------------------------------------------
char sub_560D0()
{
  int v0; // eax
  int v1; // ebx
  int v2; // eax
  int v3; // ebx
  char v5[128]; // [esp+0h] [ebp-2Ah] BYREF
  char v6[40]; // [esp+80h] [ebp+56h] BYREF
  char v7; // [esp+A8h] [ebp+7Eh]

  v7 = 1;
  sprintf(v5, aDeviceNoneDriv);
  sprintf(v6, "%c:%s/%s/dig.ini", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_1, aSound_0);
  v0 = sub_98817((int)v6, 512);
  if ( v0 == -1 )
  {
    v1 = sub_98817((int)v6, 546);
    if ( v1 != -1 )
    {
      sub_98CAA(v1, (int)v5, strlen(v5));
      sub_98882(v1);
    }
  }
  else
  {
    sub_98882(v0);
  }
  sprintf(v6, "%c:%s/%s/mdi.ini", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_1, aSound_0);
  v2 = sub_98817((int)v6, 512);
  if ( v2 == -1 )
  {
    v3 = sub_98817((int)v6, 546);
    if ( v3 != -1 )
    {
      sub_98CAA(v3, (int)v5, strlen(v5));
      sub_98882(v3);
    }
  }
  else
  {
    sub_98882(v2);
  }
  return v7;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;

//----- (00056210) --------------------------------------------------------
int __cdecl sub_56210(unsigned __int16 a1, int a2)
{
  int v2; // ebx
  char v3; // dl
  char *v4; // edi
  char *v5; // esi
  char v6; // al
  char v7; // al
  unsigned __int8 v8; // al
  int v9; // ebx
  int result; // eax
  int v11; // [esp-4h] [ebp-4Ah]
  char v12[128]; // [esp+0h] [ebp-46h] BYREF
  int v13; // [esp+80h] [ebp+3Ah]
  char v14; // [esp+84h] [ebp+3Eh]
  unsigned __int8 v15; // [esp+88h] [ebp+42h]
  char v16; // [esp+8Ch] [ebp+46h]
  char v17; // [esp+90h] [ebp+4Ah]
  char v18; // [esp+94h] [ebp+4Eh]
  char v19; // [esp+98h] [ebp+52h]
  char v20; // [esp+9Ch] [ebp+56h]
  char v21; // [esp+A0h] [ebp+5Ah]
  char v22; // [esp+A4h] [ebp+5Eh]
  char v23; // [esp+A8h] [ebp+62h]
  unsigned __int8 v24; // [esp+ACh] [ebp+66h]
  char v25; // [esp+B0h] [ebp+6Ah]
  char v26; // [esp+B4h] [ebp+6Eh]
  char v27; // [esp+B8h] [ebp+72h]
  char v28; // [esp+BCh] [ebp+76h]

  v2 = 1;
  v13 = -1;
  v24 = 67;
  v14 = 0;
  v15 = 0;
  v23 = 0;
  v17 = 0;
  v28 = 0;
  v27 = 0;
  v22 = 0;
  v20 = 0;
  v21 = 0;
  v16 = 0;
  v18 = 0;
  v26 = 0;
  v19 = 0;
  v25 = 0;
  sub_89B60(7u);
  while ( (__int16)v2 < (int)a1 )
  {
    v3 = **(_BYTE **)(a2 + 4 * (__int16)v2);
    if ( v3 == 45 || v3 == 47 )
    {
      v4 = v12;
      v5 = (char *)(*(_DWORD *)(a2 + 4 * (__int16)v2) + 1);
      do
      {
        v6 = *v5;
        *v4 = *v5;
        if ( !v6 )
          break;
        v7 = v5[1];
        v5 += 2;
        v4[1] = v7;
        v4 += 2;
      }
      while ( v7 );
    }
    if ( stricmp(aNetwork, v12) )
    {
      if ( !stricmp(aLevel, v12) )
      {
        v15 = unknown_libname_1(*(_DWORD *)(a2 + 4 * (__int16)++v2));
        byte_D419C = v15;
        v27 = 1;
      }
      else if ( !stricmp(aHarddrive, v12) )
      {
        v24 = **(_BYTE **)(a2 + 4 * (__int16)++v2);
        v8 = toupper(v24);
        v24 = v8;
        if ( v8 < 0x41u || v8 > 0x5Au )
          v24 = 67;
      }
      else if ( !stricmp(aSkipscreens, v12) )
      {
        byte_D41AD = 1;
      }
      else if ( !stricmp(aNocd, v12) )
      {
        v22 = 1;
      }
      else if ( !stricmp(aShowversion, v12) )
      {
        v20 = 1;
      }
      else if ( !stricmp(aShowversion2, v12) )
      {
        v21 = 1;
      }
      else if ( !stricmp(aDetectoff, v12) )
      {
        v26 = 1;
      }
      else if ( !stricmp(aLangcheck, v12) )
      {
        v19 = 1;
      }
      else if ( !stricmp(&aMavio[2], v12) )
      {
        v9 = v2 + 1;
        v11 = *(_DWORD *)(a2 + 4 * (__int16)v9);
        v2 = v9 + 1;
        word_1805C4 = unknown_libname_1(v11);
        word_1805C6 = unknown_libname_1(*(_DWORD *)(a2 + 4 * (__int16)v2));
        sub_89B60(1u);
      }
      else if ( !stricmp(aExtern, v12) )
      {
        dword_E36C4 = sub_98FF5(*(char **)(a2 + 4 * (__int16)++v2));
        printf(aExternalCtrlAt);
        sub_89B60(6u);
      }
      else if ( !stricmp(aVfx1, v12) )
      {
        sub_89B60(2u);
      }
      else if ( !stricmp(&aScc[3], v12) )
      {
        v18 = unknown_libname_1(*(_DWORD *)(a2 + 4 * (__int16)++v2));
      }
      else if ( !stricmp(aSpellsedit, v12) )
      {
        v28 = 1;
      }
      else if ( !stricmp(aMusic2, v12) )
      {
        v25 = 1;
      }
    }
    ++v2;
  }
  if ( !v22 )
    sub_86A00();
  dword_D41A0 = sub_83CD0(224791);
  if ( !dword_D41A0 )
  {
    printf(aErrorCantAlloc_0);
LABEL_46:
    exit(-1);
  }
  dword_D41A4 = sub_83CD0(38547);
  if ( !dword_D41A4 )
  {
    sub_83E80(dword_D41A0);
    printf(aErrorCantAlloc);
    goto LABEL_46;
  }
  memset(dword_D41A0, 0, 224791);
  memset(dword_D41A4, 0, 38547);
  if ( v14 )
    *(_DWORD *)(dword_D41A4 + 22) |= 0x800008u;
  if ( v23 )
    *(_BYTE *)(dword_D41A4 + 24) |= 2u;
  if ( v17 )
    *(_BYTE *)(dword_D41A4 + 24) |= 8u;
  if ( v28 )
    *(_BYTE *)(dword_D41A4 + 24) |= 0x10u;
  if ( !v22 && byte_E2A28 )
    *(_BYTE *)(dword_D41A4 + 24) |= 0x40u;
  if ( v27 )
    *(_BYTE *)(dword_D41A4 + 24) |= 0x80u;
  if ( v16 )
    *(_BYTE *)(dword_D41A4 + 23) |= 2u;
  if ( v20 )
    *(_BYTE *)(dword_D41A4 + 25) |= 8u;
  if ( v19 )
    *(_BYTE *)(dword_D41A4 + 25) |= 0x10u;
  if ( v25 )
    *(_BYTE *)(dword_D41A4 + 25) |= 0x40u;
  if ( v26 )
    sub_99080(0);
  result = dword_D41A4;
  *(_WORD *)(dword_D41A4 + 43) = v15;
  *(_WORD *)(result + 45) = v13;
  *(_BYTE *)(result + 182) = v24;
  if ( v18 )
    *(_BYTE *)(result + 25) = *(_BYTE *)(result + 25) & 0xF9 | 4;
  if ( v21 )
  {
    sub_70890();
    sub_5BC20();
    exit(1);
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98805: using guessed type _DWORD __cdecl toupper(_DWORD);
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// 98F9E: using guessed type _DWORD __cdecl unknown_libname_1(_DWORD);
// D419C: using guessed type char byte_D419C;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41AD: using guessed type char byte_D41AD;
// E2A28: using guessed type char byte_E2A28;
// E36C4: using guessed type int dword_E36C4;
// 1805C4: using guessed type __int16 word_1805C4;
// 1805C6: using guessed type __int16 word_1805C6;

//----- (00056730) --------------------------------------------------------
int sub_56730()
{
  return sub_8B5A0();
}

//----- (000567C0) --------------------------------------------------------
int sub_567C0()
{
  int result; // eax
  int v1; // ebx

  memset(dword_D41A0 + 16, 0, 29);
  memset(dword_D41A0 + 45, 0, 4);
  memset(dword_D41A0 + 49, 0, 2);
  memset(dword_D41A0 + 51, 0, 2);
  memset(dword_D41A0 + 53, 0, 4);
  memset(dword_D41A0 + 569, 0, 1);
  memset(dword_D41A0 + 222418, 0, 108);
  memset(dword_D41A0 + 9058, 0, 48);
  memset(dword_D41A0 + 28302, 0, 168000);
  memset(dword_D41A4 + 51, 0, 1);
  memset(dword_D41A4 + 121, 0, 16);
  memset(dword_D41A4 + 178, 0, 1);
  memset(dword_D41A4 + 180, 0, 1);
  memset(dword_D41A4 + 242, 0, 14);
  memset(dword_D41A4 + 38403, 0, 116);
  memset(dword_D41A4 + 38519, 0, 4);
  memset(dword_D41A4 + 38523, 0, 4);
  memset(dword_D41A4 + 38527, 0, 4);
  memset(dword_D41A4 + 38531, 0, 4);
  memset(dword_D41A4 + 38535, 0, 4);
  memset(word_15B4E0, 0, &loc_20000);
  memset(byte_10B4E0, 0, sub_10000);
  memset(byte_11B4E0, 0, sub_10000);
  memset(byte_12B4E0, 0, sub_10000);
  memset(byte_13B4E0, 0, sub_10000);
  memset(dword_E9C38, 0, 64000);
  result = dword_D41A4;
  *(_DWORD *)(dword_D41A4 + 30) = 0;
  v1 = *(_DWORD *)(result + 22);
  *(_DWORD *)(result + 26) = 0;
  *(_DWORD *)(result + 22) = v1 & 0xFFFE3FFF;
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E9C38: using guessed type int dword_E9C38;
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00056A30) --------------------------------------------------------
char __usercall sub_56A30@<al>(int a1@<esi>)
{
  char v1; // bl
  __int16 v2; // ax
  int v3; // eax
  __int16 v4; // ax

  v1 = byte_E3799;
  byte_E3799 = 0;
  sub_567C0();
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 8) == 0 )
  {
    sub_70910();
    sub_533B0(*(_WORD *)(dword_D41A4 + 43), (void *)(dword_D41A0 + 196302));
  }
  sub_54660(*(_BYTE *)(dword_D41A0 + 196308), byte_D41B5);
  sub_54800(*(_BYTE *)(dword_D41A0 + 196308));
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) == 0 )
    *(_WORD *)(dword_D41A0 + 14) = *(_WORD *)(dword_D41A0 + 196311);
  sub_70910();
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 4) == 0 )
    sub_43830(a1, dword_D41A0 + 196302);
  sub_49F30();
  sub_70910();
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 4) == 0 )
    sub_49270(dword_D41A0 + 196302);
  sub_70910();
  v2 = memset(&word_EB398, 0, 6);
  sub_49F90(v2);
  v3 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 4582) = -1;
  sub_71A70(*(_BYTE *)(v3 + 196308));
  v4 = dword_D41A4;
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 4) == 0 )
  {
    sub_58940(dword_D41A0 + 196302);
    sub_11EE0(dword_D41A0 + 196302);
    v4 = sub_84790();
  }
  sub_4A1E0(v4, 0, 1);
  byte_E3799 = v1;
  sub_53160();
  return sub_60F00();
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B5: using guessed type char byte_D41B5;
// E3799: using guessed type char byte_E3799;
// EB398: using guessed type __int16 word_EB398;

//----- (00056C00) --------------------------------------------------------
int __cdecl sub_56C00(int a1)
{
  unsigned __int8 v1; // al
  int v2; // eax
  char v3; // cl
  int result; // eax

  byte_D41B6 = 0;
  byte_DA972 = 19;
  word_DAE1E = 245;
  word_DA96E = 199;
  v1 = *(_BYTE *)(a1 + 6);
  byte_DAE22 = 19;
  if ( v1 )
  {
    if ( v1 <= 1u )
    {
      *(_BYTE *)(dword_D41A0 + 8600) = 0;
      sub_84300(1u);
      byte_D419E = 9;
    }
    else if ( v1 == 2 )
    {
      *(_BYTE *)(dword_D41A0 + 8600) = 1;
      byte_D41B6 = 1;
      byte_D41B7 = *(_BYTE *)(a1 + 5);
      sub_84300(2u);
      byte_D419E = 10;
    }
  }
  else
  {
    byte_DA972 = 2;
    word_DA96E = 198;
    byte_DAE22 = 2;
    word_DAE1E = 244;
    *(_BYTE *)(dword_D41A0 + 8600) = 0;
    sub_84300(0);
    byte_D419E = 1;
  }
  sub_5C0A0();
  v2 = dword_D41A0;
  *(_BYTE *)(dword_D41A0 + 224770) = 1;
  *(_WORD *)(v2 + 224766) = 0;
  *(_WORD *)((char *)&loc_36DFC + v2) = 0;
  *(_BYTE *)(v2 + 8625) = 0;
  v3 = *(_BYTE *)(v2 + 224779);
  *(_BYTE *)(v2 + 8593) = 0;
  *(_BYTE *)(v2 + 224779) = v3 & 0xFC;
  result = dword_D41A4;
  *(_BYTE *)(dword_D41A4 + 38546) = 0;
  if ( word_180660 == 1 )
    byte_D419D = 1;
  else
    byte_D419D = 3;
  return result;
}
// D419D: using guessed type char byte_D419D;
// D419E: using guessed type char byte_D419E;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// D41B7: using guessed type char byte_D41B7;
// DA96E: using guessed type __int16 word_DA96E;
// DA972: using guessed type char byte_DA972;
// DAE1E: using guessed type __int16 word_DAE1E;
// DAE22: using guessed type char byte_DAE22;
// 180660: using guessed type __int16 word_180660;

//----- (00056D60) --------------------------------------------------------
char __usercall sub_56D60@<al>(int a1@<esi>, char a2)
{
  char v2; // bl
  __int16 v3; // ax
  int v4; // eax
  __int16 v5; // ax
  int v7; // [esp-4h] [ebp-4h]

  v2 = byte_E3799;
  byte_E3799 = 0;
  sub_567C0();
  sub_533B0(*(_WORD *)(dword_D41A4 + 43), (void *)(dword_D41A0 + 196302));
  if ( a2 )
  {
    sub_54660(*(_BYTE *)(dword_D41A0 + 196308), byte_D41B5);
    sub_54800(*(_BYTE *)(dword_D41A0 + 196308));
  }
  v7 = dword_D41A0 + 196302;
  *(_WORD *)(dword_D41A0 + 14) = *(_WORD *)(dword_D41A0 + 196311);
  sub_43830(a1, v7);
  sub_49F30();
  sub_49270(dword_D41A0 + 196302);
  v3 = memset(&word_EB398, 0, 6);
  sub_49F90(v3);
  v4 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 4582) = -1;
  if ( a2 )
    sub_71A70(*(_BYTE *)(v4 + 196308));
  sub_58940(dword_D41A0 + 196302);
  sub_11EE0(dword_D41A0 + 196302);
  v5 = sub_84790();
  sub_4A1E0(v5, 0, 1);
  byte_E3799 = v2;
  sub_53160();
  return sub_60F00();
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B5: using guessed type char byte_D41B5;
// E3799: using guessed type char byte_E3799;
// EB398: using guessed type __int16 word_EB398;

//----- (00056EE0) --------------------------------------------------------
_BOOL1 __cdecl sub_56EE0(unsigned __int16 a1)
{
  char v1; // al

  v1 = byte_13B4E0[a1] & 7;
  return v1 != 5 && v1 != 2 && v1 != 3;
}

//----- (00056F10) --------------------------------------------------------
char __cdecl sub_56F10(__int16 a1, __int16 a2, __int16 a3, char a4)
{
  __int16 v4; // bx
  char v5; // dh
  int v6; // edx
  int v7; // eax
  char v8; // dl
  unsigned __int16 v9; // bx
  char v11; // [esp+0h] [ebp-8h]
  unsigned __int16 v12; // [esp+4h] [ebp-4h]

  LOBYTE(v12) = a1;
  HIBYTE(v12) = a2;
  v11 = 0;
  v4 = a3 + (unsigned __int8)byte_11B4E0[v12];
  if ( v4 > 200 )
  {
    v4 = 200;
    if ( !a1 && !a2 )
      v11 = 1;
  }
  if ( v4 < 0 )
  {
    v4 = 0;
    if ( !a1 && !a2 )
      v11 = 1;
  }
  if ( a4 && byte_13B4E0[v12] < 0 )
    return 1;
  v5 = byte_D41B6;
  byte_11B4E0[v12] = v4;
  if ( v5 )
  {
    v6 = (unsigned __int8)byte_14B4E0[v12] - a3;
    if ( v6 >= 255 )
      byte_14B4E0[v12] = -1;
    else
      byte_14B4E0[v12] = v6;
  }
  if ( v4 )
  {
    v7 = v12;
    v8 = byte_13B4E0[v12] & 0xF8 | 1;
  }
  else
  {
    LOBYTE(v9) = a1 - 1;
    HIBYTE(v9) = a2 - 1;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    LOBYTE(v9) = v9 + 1;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    LOBYTE(v9) = v9 + 1;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    HIBYTE(v9) = a2;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    LOBYTE(v9) = v9 - 2;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    HIBYTE(v9) = a2 + 1;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    LOBYTE(v9) = v9 + 1;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    LOBYTE(v9) = v9 + 1;
    if ( !sub_56EE0(v9) )
      goto LABEL_28;
    v7 = v12;
    v8 = byte_13B4E0[v12] & 0xF0;
  }
  byte_13B4E0[v7] = v8;
LABEL_28:
  if ( a4 )
    sub_462A0(v12, v12);
  else
    sub_46570(v12, v12);
  return v11;
}
// D41B6: using guessed type char byte_D41B6;

//----- (000570F0) --------------------------------------------------------
char __cdecl sub_570F0(__int16 a1, __int16 a2, __int16 a3, char a4, char a5, char a6)
{
  unsigned __int16 v6; // bx
  char v8; // [esp+0h] [ebp-8h]
  unsigned __int16 v9; // [esp+4h] [ebp-4h]

  LOBYTE(v9) = a1;
  HIBYTE(v9) = a2;
  v8 = 0;
  if ( a3 > 255 )
  {
    a3 = 255;
    if ( !a1 && !a2 )
      v8 = 1;
  }
  if ( a3 < 0 )
  {
    a3 = 0;
    if ( !a1 && !a2 )
      v8 = 1;
  }
  if ( a4 && byte_13B4E0[v9] < 0 )
    return 1;
  byte_11B4E0[v9] = a3;
  if ( a5 || sub_57450(byte_10B4E0[v9]) )
    byte_13B4E0[v9] = byte_13B4E0[v9] & 0xF8 | 1;
  if ( !a3 )
  {
    if ( !a6 )
      goto LABEL_25;
    LOBYTE(v6) = a1 - 1;
    HIBYTE(v6) = a2 - 1;
    if ( sub_56EE0(v6) )
    {
      LOBYTE(v6) = v6 + 1;
      if ( sub_56EE0(v6) )
      {
        LOBYTE(v6) = v6 + 1;
        if ( sub_56EE0(v6) )
        {
          HIBYTE(v6) = a2;
          if ( sub_56EE0(v6) )
          {
            LOBYTE(v6) = v6 - 2;
            if ( sub_56EE0(v6) )
            {
              HIBYTE(v6) = a2 + 1;
              if ( sub_56EE0(v6) )
              {
                LOBYTE(v6) = v6 + 1;
                if ( sub_56EE0(v6) )
                {
                  LOBYTE(v6) = v6 + 1;
                  if ( sub_56EE0(v6) )
LABEL_25:
                    byte_13B4E0[v9] &= 0xF0u;
                }
              }
            }
          }
        }
      }
    }
  }
  if ( a4 )
    sub_462A0(v9, v9);
  else
    sub_46570(v9, v9);
  return v8;
}

//----- (000572C0) --------------------------------------------------------
char __cdecl sub_572C0(__int16 *a1, __int16 a2, __int16 a3, __int16 a4, char a5)
{
  int v5; // ebx
  int v6; // esi
  int v7; // edi
  int v8; // ebx
  int v10; // [esp+0h] [ebp-8h] BYREF
  int v11; // [esp+4h] [ebp-4h] BYREF

  LOWORD(v5) = a3;
  v6 = (a1[38] + 128) >> 8;
  v7 = (a1[39] + 128) >> 8;
  if ( a3 > (int)(a1[42] - (__CFSHL__((unsigned __int64)a1[42] >> 32, 8) + ((unsigned __int64)a1[42] >> 32 << 8))) >> 8 )
    v5 = (int)(a1[42] - (__CFSHL__((unsigned __int64)a1[42] >> 32, 8) + ((unsigned __int64)a1[42] >> 32 << 8))) >> 8;
  v8 = sub_10080(a2, (__int16)v5);
  if ( !v8 )
    return 0;
  do
  {
    if ( sub_10130(v8, &v11, &v10) != 1 )
    {
      sub_10100(v8);
      return 0;
    }
  }
  while ( !sub_56F10(v6 + v11, v7 + v10, a4, a5) );
  sub_10100(v8);
  return 1;
}

//----- (00057390) --------------------------------------------------------
unsigned __int8 __cdecl sub_57390(unsigned __int16 a1, unsigned __int16 a2)
{
  unsigned __int8 result; // al
  int i; // ebx
  char v4; // ah
  int v5; // ebx

  result = a1;
  for ( i = word_15B4E0[a1]; ; i = *(unsigned __int16 *)(v5 + 22) )
  {
    v5 = dword_EA3E4[i];
    if ( v5 == dword_EA3E4[0] )
      break;
    result = a2;
    if ( *(__int16 *)(v5 + 26) != a2 )
    {
      result = *(_BYTE *)(v5 + 63);
      if ( result >= 2u )
      {
        if ( result <= 2u )
        {
          result = sub_57F10(v5);
          continue;
        }
        if ( result == 5 )
        {
          v4 = 1;
          result = *(_BYTE *)(v5 + 64);
          if ( result < 0x10u )
          {
            if ( result < 8u )
            {
              if ( result != 6 )
                goto LABEL_25;
            }
            else if ( result > 8u && result != 10 )
            {
              goto LABEL_25;
            }
          }
          else if ( result > 0x10u )
          {
            if ( result < 0x19u )
            {
              if ( result < 0x16u || result > 0x17u )
                goto LABEL_25;
            }
            else if ( result <= 0x19u )
            {
              if ( *(_BYTE *)(v5 + 69) != 0xC8 )
                goto LABEL_25;
            }
            else if ( result != 27 )
            {
LABEL_25:
              if ( v4 )
              {
                *(_DWORD *)(v5 + 8) = -1;
                *(_WORD *)(v5 + 36) = a2;
                *(_WORD *)(v5 + 38) = a2;
              }
              continue;
            }
          }
          v4 = 0;
          goto LABEL_25;
        }
      }
    }
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00057450) --------------------------------------------------------
_BOOL1 __cdecl sub_57450(unsigned __int8 a1)
{
  if ( a1 < 0x53u )
  {
    if ( a1 < 0x25u )
    {
      if ( a1 )
        return 0;
    }
    else if ( a1 > 0x26u )
    {
      if ( a1 >= 0x2Cu )
        return a1 <= 0x2Fu || a1 == 81;
      return 0;
    }
    return 1;
  }
  if ( a1 <= 0x53u )
    return 1;
  if ( a1 < 0x6Du )
  {
    if ( a1 >= 0x68u )
      return a1 <= 0x69u;
    return 0;
  }
  if ( a1 <= 0x6Du )
    return 1;
  if ( a1 >= 0x72u )
    return a1 <= 0x72u || a1 == 116;
  return 0;
}

//----- (000574A0) --------------------------------------------------------
_WORD *sub_574A0()
{
  _WORD *result; // eax
  int v1; // ebx
  int v2; // edx

  result = (_WORD *)dword_D41A4;
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) == 0 )
  {
    memset(dword_D41A0 + 222422, 0, 104);
    result = (_WORD *)((char *)&loc_30325 + dword_D41A0);
    v1 = *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)]
                   + 164)
       + 611;
    while ( (unsigned int)result < dword_D41A0 + 221393 )
    {
      if ( *result == 15 )
      {
        v2 = (unsigned __int16)result[1];
        if ( !*(_WORD *)(v1 + 2 * (unsigned __int16)v2 + 208) && !*(_BYTE *)(v2 + v1 + 390) )
          ++*(_DWORD *)(dword_D41A0 + 4 * v2 + 222422);
      }
      result += 10;
    }
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00057570) --------------------------------------------------------
int sub_57570()
{
  int result; // eax
  int v1; // edx
  char v2; // ch

  result = dword_D41A4;
  if ( (*(_BYTE *)(dword_D41A4 + 23) & 1) == 0 )
  {
    result = dword_D41A0;
    v1 = *(__int16 *)(dword_D41A0 + 12);
    if ( byte_3659C[11 * v1 + dword_D41A0] )
    {
      result = 2124 * v1 + dword_D41A0;
      v2 = *(_BYTE *)(result + 11232);
      if ( (v2 & 0x10) == 0 )
        *(_BYTE *)(result + 11232) = v2 | 2;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (000575C0) --------------------------------------------------------
char sub_575C0()
{
  int v0; // eax
  char v1; // dl

  v0 = 2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0;
  v1 = *(_BYTE *)(v0 + 11232);
  if ( (v1 & 8) != 0 && (v1 & 4) != 0 )
  {
    LOBYTE(v0) = dword_D41A4;
    if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) == 0 && *(char *)(dword_D41A4 + 38545) < 0 )
    {
      LOBYTE(v0) = sub_555D0(1u, *(unsigned __int16 *)(dword_D41A4 + 43));
      if ( (_BYTE)v0 )
      {
        v0 = dword_D41A0;
        *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) &= ~8u;
        *(_BYTE *)(2124 * *(__int16 *)(v0 + 12) + v0 + 11232) &= ~4u;
      }
    }
  }
  return v0;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00057640) --------------------------------------------------------
char sub_57640()
{
  char result; // al

  result = dword_D41A4;
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) == 0 && *(char *)(dword_D41A4 + 38545) >= 0 )
  {
    result = sub_55080(1u, *(unsigned __int16 *)(dword_D41A4 + 43));
    if ( result )
    {
      result = dword_D41A4;
      *(_BYTE *)(dword_D41A4 + 38545) |= 0x80u;
    }
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;

//----- (00057680) --------------------------------------------------------
unsigned int sub_57680()
{
  int i; // edx
  int v1; // ebx
  int v2; // ecx
  unsigned int result; // eax
  char *j; // edx

  for ( i = 0; i < *(unsigned __int16 *)(dword_D41A0 + 14); ++i )
  {
    v1 = dword_D41A0 + 11230 + 2124 * i;
    v2 = dword_EA3E4[*(unsigned __int16 *)(2124 * i + dword_D41A0 + 11240)];
    *(_DWORD *)(v2 + 164) = v1 + 998;
  }
  result = dword_EA3E8;
  for ( j = (char *)&unk_D83AC - *(_DWORD *)(dword_D41A0 + 224758); result < dword_EB384; result += 168 )
  {
    if ( *(_BYTE *)(result + 63) )
      *(_DWORD *)(result + 160) += j;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EA3E8: using guessed type int dword_EA3E8;
// EB384: using guessed type int dword_EB384;

//----- (00057730) --------------------------------------------------------
char sub_57730()
{
  __int16 v0; // ax
  unsigned int i; // ebx
  int v2; // eax
  _DWORD *v3; // esi
  _DWORD *v4; // ecx
  _DWORD *v5; // edx
  int *j; // eax
  char v7; // bl
  unsigned __int8 v8; // bl
  _BOOL1 v9; // zf
  int v10; // ebx
  int **v11; // edi
  unsigned __int8 v12; // bl
  int v13; // ebx
  unsigned __int8 v14; // bl
  char result; // al
  int k; // esi
  unsigned int m; // ebx
  _BYTE *n; // ebx
  char v19; // cl
  int v20; // eax
  __int16 v21; // si
  int v22[29]; // [esp+0h] [ebp-7Ch] BYREF
  _DWORD *v23; // [esp+74h] [ebp-8h]
  _DWORD *v24; // [esp+78h] [ebp-4h]

  v0 = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
  for ( i = dword_EA3E8; i < dword_EB384; i += 168 )
  {
    if ( *(_BYTE *)(i + 63) && (*(_BYTE *)(i + 13) & 4) != 0 )
      v0 = sub_57F20(v0, i);
  }
  memset(v22, 0, sizeof(v22));
  memset(dword_D41A4 + 38403, 0, 116);
  v2 = dword_D41A4;
  v3 = 0;
  *(_DWORD *)(dword_D41A4 + 38523) = 0;
  v24 = 0;
  *(_DWORD *)(v2 + 38527) = 0;
  v23 = 0;
  *(_DWORD *)(v2 + 38519) = 0;
  *(_DWORD *)(v2 + 38531) = 0;
  v4 = 0;
  *(_DWORD *)(v2 + 38535) = 0;
  v5 = 0;
  for ( j = (int *)dword_EA3E8; (unsigned int)j < dword_EB384; j += 42 )
  {
    v7 = *((_BYTE *)j + 63);
    if ( v7 )
    {
      switch ( v7 )
      {
        case 3:
          if ( j[2] >= 0 )
          {
            if ( v4 )
              *v4 = j;
            else
              *(_DWORD *)(dword_D41A4 + 38519) = j;
            v13 = dword_EA3E4[0];
            v4 = j;
            goto LABEL_60;
          }
          continue;
        case 5:
          if ( j[2] < 0 )
            continue;
          v8 = *((_BYTE *)j + 69);
          if ( v8 < 0xE8u )
          {
            v9 = v8 == 0xB4;
          }
          else
          {
            if ( v8 <= 0xE8u )
              continue;
            v9 = v8 == 0xEA;
          }
          if ( !v9 )
          {
            v10 = *((char *)j + 64);
            v11 = (int **)v22[v10];
            if ( v11 )
              *v11 = j;
            else
              *(_DWORD *)(dword_D41A4 + v10 * 4 + 38403) = j;
            *j = dword_EA3E4[0];
            v22[*((char *)j + 64)] = (int)j;
          }
          continue;
        case 9:
          if ( v23 )
            *v23 = j;
          else
            *(_DWORD *)(dword_D41A4 + 38531) = j;
          v13 = dword_EA3E4[0];
          v23 = j;
          goto LABEL_60;
        case 10:
          v12 = *((_BYTE *)j + 64);
          if ( v12 < 0x2Du )
          {
            if ( v12 < 0x27u )
              continue;
            if ( v12 <= 0x28u )
              goto LABEL_32;
            if ( v12 != 42 )
              continue;
LABEL_40:
            if ( v5 )
              *v5 = j;
            else
              *(_DWORD *)(dword_D41A4 + 38535) = j;
            *j = dword_EA3E4[0];
            v5 = j;
            continue;
          }
          if ( v12 <= 0x2Du )
          {
            if ( v24 )
              *v24 = j;
            else
              *(_DWORD *)(dword_D41A4 + 38527) = j;
            v13 = dword_EA3E4[0];
            v24 = j;
            goto LABEL_60;
          }
          if ( v12 < 0x43u )
          {
            if ( v12 != 57 )
              continue;
LABEL_32:
            if ( v3 )
              *v3 = j;
            else
              *(_DWORD *)(dword_D41A4 + 38523) = j;
            v13 = dword_EA3E4[0];
            v3 = j;
LABEL_60:
            *j = v13;
            continue;
          }
          if ( v12 <= 0x43u || v12 == 78 )
            goto LABEL_40;
          break;
        case 11:
          v14 = *((_BYTE *)j + 64);
          if ( v14 >= 0xCu && (v14 <= 0xCu || v14 == 31) )
          {
            if ( v5 )
              *v5 = j;
            else
              *(_DWORD *)(dword_D41A4 + 38535) = j;
            *j = dword_EA3E4[0];
            v5 = j;
          }
          continue;
        default:
          continue;
      }
    }
  }
  result = dword_D41A4;
  if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) == 0 )
  {
    sub_12780();
    for ( k = 0; k < 29; ++k )
    {
      for ( m = *(_DWORD *)(dword_D41A4 + 4 * k + 38403); m > dword_EA3E4[0]; m = *(_DWORD *)m )
      {
        if ( *(_BYTE *)(m + 72) || *(_BYTE *)(m + 73) )
          sub_12500(m);
      }
    }
    if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) == 0 )
      sub_68BF0();
    sub_159E0();
    if ( byte_D41B6 )
      sub_58630();
    sub_60F00();
    for ( n = (_BYTE *)dword_EA3E8; (unsigned int)n < dword_EB384; n += 168 )
    {
      v19 = n[63];
      if ( v19 )
      {
        v20 = 14 * (unsigned __int8)n[69] + *(int *)((char *)&dword_D4C52 + 18 * v19);
        if ( (unsigned __int8)n[69] == *(_WORD *)(v20 + 4) )
        {
          if ( *(_DWORD *)(v20 + 10) )
          {
            (*(void (__cdecl **)(_BYTE *))(v20 + 6))(n);
            ++n[62];
          }
        }
        else
        {
          sub_57F10((int)n);
        }
      }
    }
    sub_585D0();
    result = dword_D41A0;
    v21 = *(_WORD *)(dword_D41A0 + 222538);
    if ( v21 )
      return sub_21F60(dword_EA3E4[v21]);
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// D4C52: using guessed type int dword_D4C52;
// EA3E4: using guessed type int dword_EA3E4[];
// EA3E8: using guessed type int dword_EA3E8;
// EB384: using guessed type int dword_EB384;
// 57730: using guessed type int var_7C[29];

//----- (00057B20) --------------------------------------------------------
char __cdecl sub_57B20(int a1, int a2)
{
  int v2; // edi
  int v3; // ecx

  if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) == 0 )
  {
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 479) = *(_WORD *)(a2 + 76);
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 481) = *(_WORD *)(a2 + 78);
    sub_10C40((__int16 *)(a2 + 76));
    *(_WORD *)(14 * (*(unsigned __int16 *)(a1 + 16) - 1) + a1 + 483) = *(_WORD *)(a2 + 80);
    *(_WORD *)(14 * (*(unsigned __int16 *)(a1 + 16) - 1) + a1 + 485) = *(_WORD *)(a2 + 28);
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 491) = *(_WORD *)(a1 + 477);
    *(_WORD *)(14 * (*(unsigned __int16 *)(a1 + 16) - 1) + a1 + 489) = *(_WORD *)(*(_DWORD *)(a2 + 164) + 341);
    v2 = *(_DWORD *)(a2 + 164);
    v3 = *(__int16 *)(v2 + 30);
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 487) = *(__int16 *)(v2 + 343) / 2
                                                                     + *(unsigned __int8 *)(dword_D41A4 + 122)
                                                                     * (unsigned __int16)((int)(v3
                                                                                              - (__CFSHL__(
                                                                                                   (unsigned __int64)*(__int16 *)(v2 + 30) >> 32,
                                                                                                   4)
                                                                                               + 16
                                                                                               * ((unsigned __int64)*(__int16 *)(v2 + 30) >> 32))) >> 4)
                                                                     - ((v3 - (__CFSHL__(v3 >> 31, 3) + 8 * (v3 >> 31))) >> 3);
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 485) += *(_WORD *)(*(_DWORD *)(a2 + 164) + 24);
    *(_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 487) += *(_WORD *)(*(_DWORD *)(a2 + 164) + 26);
  }
  return 1;
}
// D41A4: using guessed type int dword_D41A4;

//----- (00057CF0) --------------------------------------------------------
int __usercall sub_57CF0@<eax>(__int16 a1@<ax>, int a2, int a3)
{
  int result; // eax

  LOBYTE(a1) = *(_BYTE *)(a2 + 77);
  if ( (_BYTE)a1 == *(_BYTE *)(a3 + 1) && (LOBYTE(a1) = *(_BYTE *)(a2 + 79), (_BYTE)a1 == *(_BYTE *)(a3 + 3)) )
  {
    result = 0;
    *(_DWORD *)(a2 + 76) = *(_DWORD *)a3;
    *(_WORD *)(a2 + 80) = *(_WORD *)(a3 + 4);
  }
  else
  {
    sub_57E50(a1, a2);
    sub_57D70(a2, a3);
    return 1;
  }
  return result;
}

//----- (00057D40) --------------------------------------------------------
int __usercall sub_57D40@<eax>(__int16 a1@<ax>, int a2, int a3)
{
  sub_57E50(a1, a2);
  sub_57D70(a2, a3);
  return 1;
}

//----- (00057D70) --------------------------------------------------------
int __cdecl sub_57D70(int a1, int a2)
{
  unsigned __int16 v2; // di
  int result; // eax

  if ( (*(_BYTE *)(a1 + 12) & 4) == 0 )
  {
    *(_WORD *)(a1 + 24) = 0;
    v2 = word_15B4E0[256 * *(unsigned __int8 *)(a2 + 3) + *(unsigned __int8 *)(a2 + 1)];
    *(_WORD *)(a1 + 22) = v2;
    if ( v2 )
      *(_WORD *)(dword_D41A0 + 168 * v2 + 28326) = (a1 - (dword_D41A0 + 28302)) / 168;
    result = (*(unsigned __int8 *)(a2 + 3) << 8) + *(unsigned __int8 *)(a2 + 1);
    word_15B4E0[result] = (a1 - (dword_D41A0 + 28302)) / 168;
    *(_DWORD *)(a1 + 76) = *(_DWORD *)a2;
    *(_WORD *)(a1 + 80) = *(_WORD *)(a2 + 4);
    *(_BYTE *)(a1 + 12) |= 4u;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00057E50) --------------------------------------------------------
__int16 __usercall sub_57E50@<ax>(__int16 result@<ax>, int a2)
{
  unsigned __int16 v2; // cx

  if ( (*(_BYTE *)(a2 + 12) & 4) != 0 )
  {
    result = *(_WORD *)(a2 + 22);
    if ( *(_WORD *)(a2 + 24) )
      *(_WORD *)(168 * *(unsigned __int16 *)(a2 + 24) + dword_D41A0 + 28324) = result;
    else
      word_15B4E0[256 * *(unsigned __int8 *)(a2 + 79) + *(unsigned __int8 *)(a2 + 77)] = result;
    v2 = *(_WORD *)(a2 + 22);
    if ( v2 )
    {
      result = *(_WORD *)(a2 + 24);
      *(_WORD *)(dword_D41A0 + 168 * v2 + 28326) = result;
    }
    *(_BYTE *)(a2 + 12) &= ~4u;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00057F10) --------------------------------------------------------
int __cdecl sub_57F10(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 13) |= 4u;
  return result;
}

//----- (00057F20) --------------------------------------------------------
int __usercall sub_57F20@<eax>(__int16 a1@<ax>, int a2)
{
  int v2; // edx
  int v3; // ecx
  _DWORD *v4; // eax
  int v5; // edx
  int result; // eax
  int v7; // edx

  sub_57E50(a1, a2);
  if ( (*(_BYTE *)(a2 + 14) & 2) != 0 )
  {
    v2 = 0;
    v3 = 0;
    v4 = (_DWORD *)(dword_D41A0 + 4586);
    while ( v2 <= *(_DWORD *)(dword_D41A0 + 4582) )
    {
      if ( a2 == *v4 )
      {
        v3 = 1;
        break;
      }
      ++v4;
      ++v2;
    }
    if ( v3 )
    {
      v5 = dword_D41A0;
      *v4 = *(_DWORD *)(dword_D41A0 + 4 * *(_DWORD *)(dword_D41A0 + 4582) + 4586);
      --*(_DWORD *)(v5 + 4582);
    }
  }
  result = dword_D41A0;
  *(_BYTE *)(a2 + 63) = 0;
  v7 = *(_DWORD *)(result + 53) + 1;
  *(_DWORD *)(result + 53) = v7;
  *(_DWORD *)(result + 4 * v7 + 582) = a2;
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00057FA0) --------------------------------------------------------
_WORD *__cdecl sub_57FA0(_WORD *a1, unsigned __int16 a2, __int16 a3, __int16 a4)
{
  _WORD *result; // eax
  unsigned __int16 v5; // bx
  int v6; // edx

  result = a1;
  LOBYTE(v5) = a3;
  LOWORD(v6) = a4;
  if ( a4 )
  {
    HIBYTE(v5) = HIBYTE(a3) & 7;
    HIBYTE(a2) &= 7u;
    if ( v5 )
    {
      a1[2] -= (unsigned int)(a4 * dword_DB750[v5]) >> 16;
      v6 = (a4 * (int)off_DBF50[v5]) >> 16;
    }
    *a1 += (unsigned int)((__int16)v6 * dword_DB750[a2]) >> 16;
    a1[1] -= (unsigned int)((_DWORD)off_DBF50[a2] * (__int16)v6) >> 16;
  }
  return result;
}
// DB750: using guessed type int dword_DB750[256];
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();

//----- (00058030) --------------------------------------------------------
_WORD *__cdecl sub_58030(int a1, _WORD *a2)
{
  _WORD *result; // eax
  unsigned __int16 v3; // dx
  unsigned __int8 v4; // cl
  unsigned __int8 v5; // bl
  unsigned __int8 v6; // bl

  result = a2;
  LOBYTE(v3) = *(_BYTE *)(a1 + 1);
  HIBYTE(v3) = *(_BYTE *)(a1 + 3);
  v4 = byte_11B4E0[v3];
  *a2 = v4;
  LOBYTE(v3) = v3 + 1;
  a2[1] = v4;
  *a2 -= (unsigned __int8)byte_11B4E0[v3];
  v5 = byte_11B4E0[v3];
  ++HIBYTE(v3);
  a2[1] += v5;
  *a2 -= (unsigned __int8)byte_11B4E0[v3];
  v6 = byte_11B4E0[v3];
  LOBYTE(v3) = v3 - 1;
  a2[1] -= v6;
  *a2 += (unsigned __int8)byte_11B4E0[v3];
  a2[1] -= (unsigned __int8)byte_11B4E0[v3];
  return result;
}

//----- (000580E0) --------------------------------------------------------
int __cdecl sub_580E0(int a1, int a2, int a3, int a4, __int16 a5)
{
  int result; // eax

  result = 0;
  if ( *(__int16 *)(a1 + 4) > a2 )
  {
    result = 1;
    *(_WORD *)(a1 + 4) += a5;
  }
  if ( *(__int16 *)(a1 + 4) <= a2 + a3 )
  {
    result = 3;
    *(_WORD *)(a1 + 4) = a3 + a2;
  }
  return result;
}

//----- (000581E0) --------------------------------------------------------
__int16 __cdecl sub_581E0(_WORD *a1, _WORD *a2)
{
  return sub_72633(*a2 - *a1, a2[1] - a1[1]);
}

//----- (00058210) --------------------------------------------------------
__int16 __cdecl sub_58210(_WORD *a1, _WORD *a2)
{
  __int16 v2; // ax

  v2 = sub_58490(a1, a2);
  return sub_72633(a1[2] - a2[2], -v2);
}

//----- (000582B0) --------------------------------------------------------
int __cdecl sub_582B0(__int16 a1, __int16 a2)
{
  __int64 v2; // rax
  int result; // eax

  v2 = (a1 & 0x7FF) - (a2 & 0x7FF);
  result = (HIDWORD(v2) ^ v2) - HIDWORD(v2);
  if ( (unsigned __int16)result > 0x400u )
    return 2048 - result;
  return result;
}

//----- (000582F0) --------------------------------------------------------
int __cdecl sub_582F0(int a1, __int16 a2)
{
  int v2; // edx
  int v3; // ebx

  v2 = a1;
  BYTE1(v2) = BYTE1(a1) & 7;
  v3 = (a2 & 0x7FF) - (unsigned __int16)v2;
  if ( !v3 )
    return v2 ^ (unsigned __int16)v2;
  if ( (int)abs32(v3) > 1024 )
  {
    if ( v3 >= 0 )
      v3 -= 2048;
    else
      v3 += 2048;
  }
  if ( v3 )
  {
    if ( v3 > 0 )
      return 1;
    return -1;
  }
  return v3;
}

//----- (00058350) --------------------------------------------------------
int __cdecl sub_58350(unsigned __int16 a1, __int16 a2, int a3, unsigned __int16 a4)
{
  int v4; // ebx
  int v5; // esi
  int v6; // eax

  if ( a1 == a2 )
    return 0;
  v4 = sub_582B0(a1, a2);
  v5 = sub_582F0(a1, a2);
  v6 = v4;
  if ( (__int16)v4 > (int)a4 )
    v6 = a4;
  return v5 * v6;
}

//----- (000583B0) --------------------------------------------------------
int __cdecl sub_583B0(_WORD *a1, _WORD *a2)
{
  int v2; // ebx
  __int64 v3; // rax
  int v4; // eax

  v2 = abs16(*a2 - *a1);
  v3 = (__int16)(a2[1] - a1[1]);
  v4 = (HIDWORD(v3) ^ v3) - HIDWORD(v3);
  if ( v2 < v4 )
    return v4;
  return v2;
}

//----- (000583F0) --------------------------------------------------------
unsigned int __cdecl sub_583F0(_WORD *a1, _WORD *a2)
{
  return sub_7277A(
           (__int16)(a2[1] - a1[1]) * (__int16)(a2[1] - a1[1])
         + (__int16)(*a2 - *a1) * (__int16)(*a2 - *a1)
         + (__int16)(a2[2] - a1[2]) * (__int16)(a2[2] - a1[2]));
}

//----- (00058440) --------------------------------------------------------
int __cdecl sub_58440(_WORD *a1, _WORD *a2)
{
  return (__int16)(a2[1] - a1[1]) * (__int16)(a2[1] - a1[1])
       + (__int16)(*a2 - *a1) * (__int16)(*a2 - *a1)
       + (__int16)(a2[2] - a1[2]) * (__int16)(a2[2] - a1[2]);
}

//----- (00058490) --------------------------------------------------------
unsigned int __cdecl sub_58490(_WORD *a1, _WORD *a2)
{
  return sub_7277A((__int16)(*a2 - *a1) * (__int16)(*a2 - *a1) + (__int16)(a2[1] - a1[1]) * (__int16)(a2[1] - a1[1]));
}

//----- (000584D0) --------------------------------------------------------
int __cdecl sub_584D0(_WORD *a1, _WORD *a2)
{
  return (__int16)(*a2 - *a1) * (__int16)(*a2 - *a1) + (__int16)(a2[1] - a1[1]) * (__int16)(a2[1] - a1[1]);
}

//----- (000585A0) --------------------------------------------------------
int __cdecl sub_585A0(int a1)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 92) >= *(_BYTE *)(a1 + 93) )
    return 1;
  result = 0;
  ++*(_BYTE *)(a1 + 92);
  return result;
}

//----- (000585D0) --------------------------------------------------------
void sub_585D0()
{
  int v0; // esi
  unsigned int i; // ebx
  __int16 v2; // ax

  v0 = word_D84A6;
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( !*(_BYTE *)(i + 64) )
    {
      v2 = sub_10C40((__int16 *)(i + 76));
      if ( *(__int16 *)(i + 80) < v2 + v0 )
        *(_WORD *)(i + 80) = v0 + v2;
    }
  }
}
// D41A4: using guessed type int dword_D41A4;
// D84A6: using guessed type __int16 word_D84A6;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00058630) --------------------------------------------------------
char sub_58630()
{
  char v0; // bl
  unsigned int v1; // edx
  int v2; // eax
  unsigned int v3; // eax
  int v4; // eax
  char v5; // cl
  int v6; // ebx
  char v7; // ch
  unsigned int v8; // eax
  unsigned int v9; // edx
  int v10; // eax
  signed int v11; // esi
  int v12; // edi
  char v13; // ah
  unsigned __int16 v14; // bx
  int v16; // [esp+0h] [ebp-10h] BYREF
  __int16 v17; // [esp+4h] [ebp-Ch]
  int v18; // [esp+8h] [ebp-8h]
  char v19; // [esp+Ch] [ebp-4h]
  char v20; // [esp+Dh] [ebp-3h]

  v0 = 0;
  v1 = 0;
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
  {
    v2 = dword_D41A0;
    *(_DWORD *)(dword_D41A0 + 8) = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
    v1 = *(_DWORD *)(v2 + 8) % (unsigned int)*(unsigned __int16 *)(v2 + 14);
  }
  else if ( (*(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248) & 7) != 0 )
  {
    goto LABEL_5;
  }
  v0 = 1;
LABEL_5:
  v3 = 2124 * v1 + dword_D41A0 + 11230;
  if ( !*(_BYTE *)(v3 + 6) )
    v0 = 0;
  if ( v0 )
  {
    v4 = dword_EA3E4[*(unsigned __int16 *)(v3 + 10)];
    v16 = *(_DWORD *)(v4 + 76);
    v17 = *(_WORD *)(v4 + 80);
    sub_57FA0(&v16, *(_WORD *)(v4 + 28), 0, 2560);
    v5 = (unsigned __int16)(v16 + 128) >> 8;
    v6 = dword_D41A0;
    v7 = (unsigned __int16)(HIWORD(v16) + 128) >> 8;
    v8 = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
    *(_DWORD *)(dword_D41A0 + 8) = v8;
    v9 = v8 % 0x14;
    v10 = 9377 * *(_DWORD *)(v6 + 8);
    v18 = v9;
    v3 = v10 + 9439;
    *(_DWORD *)(v6 + 8) = v3;
    v19 = v5 - 10;
    v11 = v3 % 0x14;
    v20 = v3 % 0x14 + v7 - 10;
    LOBYTE(v3) = 0;
    while ( v11 < 20 && !(_BYTE)v3 )
    {
      v12 = v18;
      HIBYTE(v14) = v20;
      v13 = v18;
      v18 = 0;
      LOBYTE(v14) = v13 + v19;
      while ( v12 < 20 && !(_BYTE)v3 )
      {
        if ( !byte_10B4E0[v14] && (byte_13B4E0[v14] & 8) == 0 )
        {
          LOWORD(v16) = (unsigned __int8)v14 << 8;
          HIWORD(v16) = HIBYTE(v14) << 8;
          sub_4A190((int)&v16, 10, 86);
          LOBYTE(v3) = 1;
        }
        v12 += 11;
        LOBYTE(v14) = v14 + 11;
      }
      ++v11;
      ++v20;
    }
  }
  return v3;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00058940) --------------------------------------------------------
int __cdecl sub_58940(int a1)
{
  int v1; // esi
  int v2; // ecx
  int result; // eax
  int v4; // edx
  int v5; // edi
  __int16 i; // dx
  int v7; // edi
  int v8; // edi
  int v9; // ebx
  char *v10; // [esp-Ch] [ebp-20h]
  int v11; // [esp+0h] [ebp-14h]

  v10 = &byte_3659C[dword_D41A0];
  *(_BYTE *)(dword_D41A0 + 224769) = 0;
  memset(v10, 0, 88);
  memset(dword_D41A0 + 222540, 0, 80);
  v1 = dword_D41A0;
  v2 = dword_D41A4;
  *(_WORD *)((char *)&loc_2FED5 + dword_D41A0) = 0;
  if ( (*(_BYTE *)(v2 + 22) & 0x10) != 0 )
  {
    *(_BYTE *)(v1 + 224769) = 1;
    *(_BYTE *)(v1 + 222540) = 8;
    for ( result = 0; (__int16)result < 8; ++result )
    {
      v9 = 11 * (__int16)result;
      byte_3659F[v1 + v9] = 1;
    }
    dword_D41A0 = v1;
  }
  else
  {
    result = 0;
    do
    {
      if ( *(char *)(7 * (__int16)result + a1 + 25972) != -1 )
      {
        switch ( *(_BYTE *)(v1 + 10 * *(unsigned __int8 *)(v1 + 224769) + 222540) )
        {
          case 1:
          case 2:
          case 4:
          case 6:
          case 7:
          case 9:
            v4 = a1 + 7 * (__int16)result;
            if ( !*(_WORD *)(v4 + 25973) )
              *(_BYTE *)(v4 + 25972) = -1;
            break;
          default:
            break;
        }
      }
      v5 = a1 + 7 * (__int16)result;
      if ( *(char *)(v5 + 25972) != -1 )
      {
        *(_BYTE *)(v1 + 10 * *(unsigned __int8 *)(v1 + 224769) + 222540) = *(_BYTE *)(v5 + 25972);
        for ( i = 0; i < 8; ++i )
        {
          v7 = 11 * i + v1;
          byte_3659F[v7 + *(unsigned __int8 *)(v1 + 224769)] = 1;
        }
        v8 = v1 + 10 * *(unsigned __int8 *)(v1 + 224769);
        switch ( *(_BYTE *)(v8 + 222540) )
        {
          case 0:
            goto LABEL_17;
          case 1:
          case 2:
          case 6:
            *(_DWORD *)(v1 + 10 * *(unsigned __int8 *)(v1 + 224769) + 222546) = 20
                                                                              * *(unsigned __int16 *)(7 * (__int16)result + a1 + 25973)
                                                                              + a1
                                                                              + 1091;
            break;
          case 4:
            v11 = a1 + 7 * (__int16)result;
            *(_DWORD *)(v8 + 222546) = 20 * *(unsigned __int16 *)(v11 + 25973) + a1 + 1091;
            *(_WORD *)((char *)&loc_3654E + 10 * *(unsigned __int8 *)(v1 + 224769) + v1) = *(_WORD *)(v11 + 25975) << 8;
            *(_WORD *)((char *)&loc_36550 + 10 * *(unsigned __int8 *)(v1 + 224769) + v1) = *(_WORD *)(v11 + 25977) << 8;
            break;
          case 5:
            *(_WORD *)((char *)&loc_3654E + v8) = *(_WORD *)(a1 + 7 * (__int16)result + 25975) << 8;
            *(_WORD *)((char *)&loc_36550 + 10 * *(unsigned __int8 *)(v1 + 224769) + v1) = *(_WORD *)(a1 + 7 * (__int16)result + 25977) << 8;
LABEL_17:
            *(_DWORD *)(v1 + 10 * *(unsigned __int8 *)(v1 + 224769) + 222546) = *(unsigned __int16 *)(7 * (__int16)result + a1 + 25973);
            break;
          case 7:
            *(_DWORD *)(v8 + 222546) = *(unsigned __int16 *)(a1
                                                           + 20
                                                           * *(unsigned __int16 *)(7 * (__int16)result + a1 + 25973)
                                                           + 1093);
            break;
          case 8:
            break;
          case 9:
            *(_DWORD *)(v8 + 222546) = *(unsigned __int16 *)(a1
                                                           + 20
                                                           * *(unsigned __int16 *)(7 * (__int16)result + a1 + 25973)
                                                           + 1105);
            break;
          default:
            *(_DWORD *)(v1 + 10 * *(unsigned __int8 *)(v1 + 224769) + 222546) = *(unsigned __int16 *)(7 * (__int16)result + a1 + 25973)
                                                                              - 1;
            break;
        }
        ++*(_BYTE *)(v1 + 224769);
      }
      ++result;
    }
    while ( (__int16)result < 8 );
    dword_D41A0 = v1;
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00058DA0) --------------------------------------------------------
int __cdecl sub_58DA0(int a1, int a2)
{
  __int16 i; // bx
  int v3; // esi
  int v4; // eax
  char v5; // dl
  int v6; // eax
  char v7; // dl
  char v8; // dh
  int result; // eax

  for ( i = 0; ; ++i )
  {
    result = *(unsigned __int8 *)(dword_D41A0 + 224769);
    if ( i >= (__int16)result )
      break;
    v3 = dword_D41A0 + 10 * i;
    switch ( *(_BYTE *)(v3 + 222540) )
    {
      case 1:
      case 2:
      case 4:
        v4 = dword_D41A0 + 10 * i;
        if ( a1 == *(_DWORD *)(v4 + 222546) )
        {
          v5 = *(_BYTE *)(v4 + 222541);
          *(_DWORD *)(v4 + 222546) = a2;
          *(_BYTE *)(v4 + 222541) = v5 | 1;
        }
        break;
      case 3:
        if ( *(_BYTE *)(a2 + 63) == 3 && *(_BYTE *)(a2 + 64) <= 1u )
        {
          v6 = 10 * i + dword_D41A0;
          if ( *(__int16 *)(*(_DWORD *)(a2 + 164) + 56) == *(_DWORD *)(v6 + 222546) )
          {
            v7 = *(_BYTE *)(v6 + 222541);
            *(_DWORD *)(v6 + 222546) = a2;
            *(_BYTE *)(v6 + 222541) = v7 | 1;
          }
        }
        break;
      case 6:
        if ( a1 == *(_DWORD *)(v3 + 222546) )
        {
          v8 = *(_BYTE *)(v3 + 222541);
          *(_DWORD *)(v3 + 222546) = (a2 - (dword_D41A0 + 28302)) / 168;
          *(_BYTE *)(v3 + 222541) = v8 | 1;
        }
        break;
      default:
        continue;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00058F00) --------------------------------------------------------
int sub_58F00()
{
  char *v0; // esi
  int result; // eax
  char v2; // dh
  __int16 v3; // bx
  __int16 v4; // cx
  int v5; // eax
  int v6; // eax
  int v7; // edi
  unsigned int v8; // edx
  __int16 j; // ax
  __int16 i; // ax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int16 v15; // dx
  __int16 v16; // ax
  __int16 k; // bx
  int v18; // edx
  int v19; // [esp+4h] [ebp-44h]
  int v20; // [esp+1Ch] [ebp-2Ch]
  int v21; // [esp+24h] [ebp-24h]
  int v22; // [esp+28h] [ebp-20h]
  char *v23; // [esp+30h] [ebp-18h]
  __int16 v24; // [esp+34h] [ebp-14h]
  __int16 v25; // [esp+38h] [ebp-10h]
  int v26; // [esp+3Ch] [ebp-Ch]
  char v27; // [esp+40h] [ebp-8h]
  unsigned __int8 v28; // [esp+44h] [ebp-4h]

  if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
    v24 = *(_WORD *)(dword_D41A0 + 14);
  else
    v24 = 1;
  v26 = 0;
  v0 = &byte_3659C[dword_D41A0];
  for ( result = 0; (__int16)v26 < v24; result = v26 )
  {
    v2 = v0[2];
    if ( v2 )
    {
      v0[2] = v2 - 1;
    }
    else if ( !*v0 )
    {
      v3 = 0;
      v4 = 0;
      v25 = 0;
      v19 = dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 2124 * (__int16)v26 + 11240)];
      while ( v3 < *(unsigned __int8 *)(dword_D41A0 + 224769) )
      {
        v21 = 10 * v3;
        v5 = v21 + dword_D41A0;
        v23 = &v0[v3];
        if ( (*(_BYTE *)(v21 + dword_D41A0 + 222541) & 2) != 0 )
        {
          v23[3] = 2;
          v4 = 1;
          *(_BYTE *)(v5 + 222541) &= ~2u;
        }
        else if ( v23[3] == 1 )
        {
          switch ( *(_BYTE *)(v5 + 222540) )
          {
            case 0:
              v6 = *(_DWORD *)(v19 + 164);
              if ( *(_WORD *)(v6 + 58) )
              {
                v20 = *(_DWORD *)(dword_D41A4 + 246);
                if ( v20 > 0 )
                {
                  v7 = dword_D41A0;
                  if ( (unsigned int)(100
                                    * (*(_DWORD *)(v6 + 316)
                                     + *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(v6 + 58)] + 144))
                                    / v20) >= *(_DWORD *)(dword_D41A0 + 10 * v3 + 222546) )
                  {
                    v0[v3 + 3] = 2;
                    v4 = 1;
                    *(_WORD *)((char *)&loc_2FED5 + v7) = 0;
                  }
                }
              }
              if ( !*(_WORD *)((char *)&loc_2FED5 + dword_D41A0) && v3 == (unsigned __int8)v0[1] && !v4 )
                *(_WORD *)((char *)&loc_2FED5 + dword_D41A0) = *(_WORD *)(dword_D41A0
                                                                        + 10 * (unsigned __int8)v0[1]
                                                                        + 222546);
              break;
            case 1:
              if ( (*(_BYTE *)(dword_D41A0 + 10 * v3 + 222541) & 1) != 0
                && *(int *)(*(_DWORD *)(dword_D41A0 + 10 * v3 + 222546) + 8) <= -1 )
              {
                v4 = 1;
                v0[v3 + 3] = 2;
              }
              break;
            case 2:
              if ( (*(_BYTE *)(v5 + 222541) & 1) != 0
                && *(int *)(*(_DWORD *)(v5 + 222546) + 8) <= -1
                && !*(_BYTE *)(*(_DWORD *)(10 * v3 + dword_D41A0 + 222546) + 61) )
              {
                v4 = 1;
                v0[v3 + 3] = 2;
              }
              break;
            case 3:
              if ( !*(_BYTE *)(dword_D41A0
                             + 2124 * *(__int16 *)(*(_DWORD *)(*(_DWORD *)(v5 + 222546) + 164) + 56)
                             + 11236) )
              {
                v4 = 1;
                v23[3] = 2;
              }
              break;
            case 4:
              if ( (*(_BYTE *)(v5 + 222541) & 1) != 0 )
              {
                v22 = *(_DWORD *)(v5 + 222546);
                if ( v19 == dword_EA3E4[*(unsigned __int16 *)(v22 + 40)] )
                {
                  v11 = *(__int16 *)((char *)&loc_3654E + v5) - *(__int16 *)(v22 + 76);
                  if ( (int)((HIDWORD(v11) ^ v11) - HIDWORD(v11)) <= 768 )
                  {
                    v12 = *(__int16 *)((char *)&loc_36550 + v21 + dword_D41A0) - *(__int16 *)(v22 + 78);
                    if ( (int)((HIDWORD(v12) ^ v12) - HIDWORD(v12)) <= 768 )
                    {
                      v4 = 1;
                      v23[3] = 2;
                    }
                  }
                }
              }
              break;
            case 5:
              if ( v3 == (unsigned __int8)v0[1] )
              {
                v13 = *(__int16 *)((char *)&loc_3654E + v5) - *(__int16 *)(v19 + 76);
                if ( (int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) <= 768 )
                {
                  v14 = *(__int16 *)((char *)&loc_36550 + v21 + dword_D41A0) - *(__int16 *)(v19 + 78);
                  if ( (int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) <= 768 )
                  {
                    v4 = 1;
                    v23[3] = 2;
                  }
                }
              }
              break;
            case 6:
              if ( v3 == (unsigned __int8)v0[1] && (*(_BYTE *)(v5 + 222541) & 1) != 0 )
              {
                v15 = 0;
                while ( *(__int16 *)(dword_D41A0 + 11230 + 2124 * (__int16)v26 + 1426 + 2 * v15 + 2) != *(_DWORD *)(10 * v3 + dword_D41A0 + 222546) )
                {
                  if ( ++v15 >= 8 )
                    goto LABEL_72;
                }
                v4 = 1;
                v0[v3 + 3] = 2;
              }
              break;
            case 7:
              if ( v3 == (unsigned __int8)v0[1] && !*(_DWORD *)(dword_D41A4 + 4 * *(_DWORD *)(v5 + 222546) + 38403) )
              {
                v4 = 1;
                v23[3] = 2;
              }
              break;
            case 8:
              if ( v3 == (unsigned __int8)v0[1] )
              {
                v4 = 1;
                for ( i = 0; i < (int)*(unsigned __int16 *)(dword_D41A0 + 14); ++i )
                {
                  if ( i != (_WORD)v26 && *(_BYTE *)(2124 * i + dword_D41A0 + 11236) )
                  {
                    v4 = 0;
                    break;
                  }
                }
                if ( v4 )
                  v0[v3 + 3] = 2;
              }
              break;
            case 9:
              if ( v3 == (unsigned __int8)v0[1] && (*(_BYTE *)(dword_D41A4 + 26) & 0xF) == 0 )
              {
                v8 = *(_DWORD *)(dword_D41A4 + 38527);
                v27 = 0;
                while ( v8 > dword_EA3E4[0] && !v27 )
                {
                  v28 = 0;
                  for ( j = *(_WORD *)(dword_D41A0 + 10 * v3 + 222546);
                        j && !v27 && v28 < 8u;
                        j = (unsigned __int8)byte_D93C3[4 * j] )
                  {
                    if ( j == *(char *)(v8 + 70) )
                      v27 = 1;
                    ++v28;
                  }
                  v8 = *(_DWORD *)v8;
                }
                if ( !v27 )
                {
                  v4 = 1;
                  v0[v3 + 3] = 2;
                }
              }
              break;
            default:
              break;
          }
        }
LABEL_72:
        if ( v4 && v3 == (unsigned __int8)v0[1] )
          v25 = 1;
        ++v3;
      }
      if ( v4 )
      {
        sub_88B20();
        v16 = 1;
        for ( k = 0; k < *(unsigned __int8 *)(dword_D41A0 + 224769); ++k )
        {
          if ( v0[k + 3] == 1 )
          {
            v16 = 0;
            v0[1] = k;
            break;
          }
        }
        *v0 = v16;
        if ( v25 || v16 )
        {
          if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 && (_WORD)v26 != *(_WORD *)(dword_D41A0 + 12) )
          {
            v18 = 2124 * (__int16)v26 + dword_D41A0 + 11230 + 28;
            *(_WORD *)(v18 + 49) = 60;
            *(_WORD *)(v18 + 51) = 4;
            if ( v16 )
              sprintf(v18, (const char *)dword_EA308);
            else
              sprintf(v18, (const char *)dword_EA304);
          }
          if ( (_WORD)v26 == *(_WORD *)(dword_D41A0 + 12) )
            *(_BYTE *)(dword_D41A0 + 224770) = 1;
        }
      }
    }
    v0 += 11;
    ++v26;
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA304: using guessed type int dword_EA304;
// EA308: using guessed type int dword_EA308;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000595C0) --------------------------------------------------------
char __cdecl sub_595C0(__int16 a1)
{
  char result; // al
  char *v2; // ebx

  result = -1;
  if ( (*(_BYTE *)(dword_D41A0 + 224779) & 1) != 0 )
    return -3;
  v2 = &byte_3659C[11 * a1 + dword_D41A0];
  if ( !*v2 )
    return *(_BYTE *)(dword_D41A0 + 10 * (unsigned __int8)v2[1] + 222540);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00059610) --------------------------------------------------------
char __cdecl sub_59610(int *a1, __int16 a2)
{
  int v2; // eax
  int v3; // ecx
  char *v4; // ebx
  char v5; // dl
  unsigned __int8 v6; // dh
  int v7; // ebx
  unsigned __int8 v8; // al
  int v9; // eax
  int v10; // eax

  v2 = 11 * a2;
  v3 = dword_D41A0;
  v4 = &byte_3659C[dword_D41A0];
  *a1 = 0;
  v5 = 0;
  v6 = v4[v2 + 1];
  if ( v4[v2] )
    return v5;
  v7 = v3 + 10 * v6;
  v8 = *(_BYTE *)(v7 + 222540);
  if ( v8 < 4u )
  {
    if ( !v8 || v8 > 2u )
      return v5;
  }
  else if ( v8 > 4u )
  {
    if ( v8 == 6 && (*(_BYTE *)(v7 + 222541) & 1) != 0 )
    {
      v10 = dword_EA3E4[*(_DWORD *)(v7 + 222546)];
      goto LABEL_12;
    }
    return v5;
  }
  v9 = dword_D41A0 + 10 * v6;
  if ( (*(_BYTE *)(v9 + 222541) & 1) != 0 )
  {
    v10 = *(_DWORD *)(v9 + 222546);
LABEL_12:
    v5 = 1;
    *a1 = v10;
  }
  return v5;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000596C0) --------------------------------------------------------
char __cdecl sub_596C0(_WORD *a1, __int16 a2)
{
  int v2; // ebx
  char *v3; // ecx
  char v4; // dl
  int v5; // edi
  unsigned __int8 v6; // al

  v2 = dword_D41A0;
  *a1 = -1;
  a1[1] = -1;
  v3 = &byte_3659C[11 * a2 + v2];
  a1[2] = -1;
  v4 = 0;
  if ( !*v3 )
  {
    v5 = v2 + 10 * (unsigned __int8)v3[1];
    v6 = *(_BYTE *)(v5 + 222540);
    if ( v6 >= 4u && v6 <= 5u )
    {
      *a1 = *(_WORD *)((char *)&loc_3654E + v5);
      v4 = 1;
      a1[1] = *(_WORD *)((char *)&loc_36550 + 10 * (unsigned __int8)v3[1] + v2);
    }
  }
  return v4;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00059760) --------------------------------------------------------
int __cdecl sub_59760(int a1, int a2)
{
  int result; // eax
  int v3; // esi
  int v4; // ecx
  char *i; // ebx
  int j; // edx
  int v7; // eax

  result = dword_D41A4;
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
    v3 = *(unsigned __int16 *)(dword_D41A0 + 14);
  else
    v3 = 1;
  v4 = 0;
  for ( i = &byte_3659C[dword_D41A0]; v4 < v3; i += 11 )
  {
    if ( !*i )
    {
      for ( j = 0; ; ++j )
      {
        result = *(unsigned __int8 *)(dword_D41A0 + 224769);
        if ( j >= result )
          break;
        if ( i[j + 3] == 1 )
        {
          v7 = dword_D41A0 + 10 * j;
          if ( *(_BYTE *)(v7 + 222540) == 2 && *(_DWORD *)(v7 + 222546) == a1 && (*(_BYTE *)(v7 + 222541) & 1) != 0 )
            *(_DWORD *)(v7 + 222546) = a2;
        }
      }
    }
    ++v4;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00059820) --------------------------------------------------------
void sub_59820()
{
  char v0; // dl
  int v1; // ebx
  int v2; // eax
  unsigned __int8 v3; // ch
  char v4; // cl
  int v5; // ebx
  unsigned __int16 v6; // dx
  int v7; // eax
  __int16 v8; // bx
  unsigned __int8 v9; // al
  char v10; // cl
  int v11; // ebx

  v0 = *(_BYTE *)(dword_D41A0 + 224772);
  if ( v0 )
  {
    *(_BYTE *)(dword_D41A0 + 224772) = v0 - 1;
    if ( v0 == 1 )
      sub_88BA0();
  }
  if ( (*(_BYTE *)(dword_D41A4 + 38545) & 0x40) != 0 && sub_86180(word_1803EC) == 256 )
    sub_59AF0();
  v1 = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 51) >= 3u )
  {
    v2 = dword_D41A0;
    v3 = *(_BYTE *)(dword_D41A0 + 224770);
    if ( v3 )
    {
      if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
      {
LABEL_37:
        *(_BYTE *)(dword_D41A0 + 224770) = 0;
        return;
      }
      if ( (*(_BYTE *)(dword_D41A4 + 24) & 0x40) != 0 )
      {
        if ( v3 < 7u )
        {
          if ( v3 == 1 )
          {
            ++*(_BYTE *)(dword_D41A0 + 224770);
            return;
          }
          goto LABEL_32;
        }
        if ( v3 > 7u )
        {
          if ( v3 > 8u )
          {
            if ( v3 != 0xC8 )
            {
LABEL_32:
              ++*(_BYTE *)(dword_D41A0 + 224770);
              return;
            }
            goto LABEL_37;
          }
          v4 = *(_BYTE *)(dword_D41A0 + 224779);
          *(_BYTE *)(dword_D41A0 + 224770) = v3 + 1;
          if ( (v4 & 1) != 0 )
          {
            *(_BYTE *)(v1 + 180) = 8;
            sub_86F20(*(_BYTE *)(2124 * *(__int16 *)(v2 + 12) + v2 + 12226));
            sub_59A50();
            return;
          }
          v5 = *(__int16 *)(v2 + 12);
          if ( byte_3659D[11 * v5 + v2] )
            sub_6E450(v5, -1, 61);
          v6 = *(_WORD *)(dword_D41A4 + 43);
          if ( v6 >= 0x1Eu && v6 <= 0x22u )
          {
            if ( !byte_3659C[11 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0] )
            {
              v9 = 4;
              LOBYTE(v8) = 0;
              goto LABEL_30;
            }
            LOBYTE(v8) = 10;
          }
          else
          {
            v7 = 11 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0;
            v8 = *(_WORD *)(dword_D41A4 + 43);
            if ( !byte_3659C[v7] )
            {
              v9 = byte_3659D[v7] + 1;
LABEL_30:
              *(_BYTE *)(dword_D41A4 + 180) = 8;
              sub_86EB0(v8, v9, 1);
              sub_59A50();
              return;
            }
          }
          v9 = 9;
          goto LABEL_30;
        }
        *(_BYTE *)(dword_D41A0 + 224770) = 8;
        *(_BYTE *)(v1 + 180) = 8;
LABEL_36:
        sub_6E450(*(_WORD *)(v2 + 12), -1, 41);
        return;
      }
      *(_BYTE *)(dword_D41A0 + 224770) = 0;
      v10 = *(_BYTE *)(v2 + 224779);
      *(_BYTE *)(v2 + 224772) = -56;
      if ( (v10 & 1) != 0 )
        goto LABEL_36;
      v11 = *(__int16 *)(v2 + 12);
      if ( byte_3659D[11 * v11 + v2] )
        sub_6E450(v11, -1, 61);
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 1803EC: using guessed type __int16 word_1803EC;

//----- (00059A50) --------------------------------------------------------
int sub_59A50()
{
  int result; // eax

  if ( byte_D4B7A == 1 )
  {
    sub_92DC0(dword_F4940);
    byte_D4B7A = 0;
  }
  sub_8E470(*(__int16 *)(dword_D41A4 + 6) / 3);
  byte_D4B78 = *(__int16 *)(dword_D41A4 + 6) / 3;
  sub_8E410((_DWORD *)(*(__int16 *)(dword_D41A4 + 8) / 3));
  result = *(__int16 *)(dword_D41A4 + 8) / 3;
  byte_D4B79 = *(__int16 *)(dword_D41A4 + 8) / 3;
  *(_BYTE *)(dword_D41A4 + 38545) |= 0x40u;
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// D4B78: using guessed type char byte_D4B78;
// D4B79: using guessed type char byte_D4B79;
// D4B7A: using guessed type char byte_D4B7A;
// F4940: using guessed type int dword_F4940;

//----- (00059AF0) --------------------------------------------------------
int sub_59AF0()
{
  int result; // eax

  sub_86860(word_1803EC);
  dword_F4940 = sub_92600((int)sub_59B50);
  sub_92930(dword_F4940, 0x78u);
  sub_92BA0(dword_F4940);
  byte_D4B7A = 1;
  result = dword_D41A4;
  *(_BYTE *)(dword_D41A4 + 38545) &= ~0x40u;
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// D4B7A: using guessed type char byte_D4B7A;
// F4940: using guessed type int dword_F4940;
// 1803EC: using guessed type __int16 word_1803EC;

//----- (00059B50) --------------------------------------------------------
int sub_59B50()
{
  __int16 v0; // dx

  if ( (unsigned __int8)byte_D4B78 == *(_WORD *)(dword_D41A4 + 6)
    && (HIBYTE(v0) = HIBYTE(*(_WORD *)(dword_D41A4 + 6)), LOBYTE(v0) = byte_D4B79, v0 == *(_WORD *)(dword_D41A4 + 8)) )
  {
    byte_D4B7A = 0;
    sub_92DC0(dword_F4940);
  }
  else
  {
    if ( (unsigned __int8)byte_D4B78 < *(__int16 *)(dword_D41A4 + 6) )
      sub_8E470((unsigned __int8)++byte_D4B78);
    if ( (unsigned __int8)byte_D4B79 < *(__int16 *)(dword_D41A4 + 8) )
      sub_8E410((_DWORD *)(unsigned __int8)++byte_D4B79);
  }
  return 0;
}
// D41A4: using guessed type int dword_D41A4;
// D4B78: using guessed type char byte_D4B78;
// D4B79: using guessed type char byte_D4B79;
// D4B7A: using guessed type char byte_D4B7A;
// F4940: using guessed type int dword_F4940;

//----- (00059BF0) --------------------------------------------------------
_DWORD *sub_59BF0()
{
  if ( byte_D4B7A == 1 )
  {
    sub_92DC0(dword_F4940);
    byte_D4B7A = 0;
  }
  sub_8E470(*(__int16 *)(dword_D41A4 + 6));
  return sub_8E410((_DWORD *)*(__int16 *)(dword_D41A4 + 8));
}
// D41A4: using guessed type int dword_D41A4;
// D4B7A: using guessed type char byte_D4B7A;
// F4940: using guessed type int dword_F4940;

//----- (00059C40) --------------------------------------------------------
int __cdecl sub_59C40(int a1)
{
  int result; // eax

  result = sub_10C40((__int16 *)(a1 + 76));
  *(_WORD *)(a1 + 80) = result;
  return result;
}

//----- (00059C60) --------------------------------------------------------
int __cdecl sub_59C60(int a1)
{
  int result; // eax

  result = sub_10C40((__int16 *)(a1 + 76));
  *(_WORD *)(a1 + 80) = result;
  return result;
}

//----- (00059C80) --------------------------------------------------------
int __cdecl sub_59C80(int a1)
{
  int result; // eax
  int v2; // ebx
  unsigned int i; // ebx
  int v4; // edi
  int v5; // eax

  if ( (*(_BYTE *)(dword_D41A4 + 38545) & 4) != 0 )
  {
    *(_BYTE *)(a1 + 12) |= 1u;
    return sub_57F10(a1);
  }
  else
  {
    result = sub_10C40((__int16 *)(a1 + 76));
    v2 = dword_D41A4;
    *(_WORD *)(a1 + 80) = result;
    for ( i = *(_DWORD *)(v2 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
    {
      if ( !*(_BYTE *)(i + 64) && *(int *)(i + 8) >= 0 )
      {
        result = sub_106C0(i, a1);
        if ( result )
        {
          v4 = *(__int16 *)(*(_DWORD *)(i + 164) + 56);
          if ( v4 == *(__int16 *)(dword_D41A0 + 12) )
          {
            if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
              v5 = 50;
            else
              v5 = 4;
            sub_6E090(*(_DWORD *)(i + 164) + 611, v5);
            sub_6E450(v4, -1, 63);
            if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
              sub_6DBD0();
            else
              sub_6DB50(0, 1);
          }
          result = sub_57F10(a1);
        }
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00059DC0) --------------------------------------------------------
char __cdecl sub_59DC0(_WORD *a1)
{
  int v1; // eax
  __int16 v2; // dx
  __int16 v3; // si
  __int16 v4; // ax
  int v5; // eax
  __int16 v6; // ax
  __int16 v7; // ax
  __int16 v8; // ax
  __int16 v10; // [esp-8h] [ebp-14h]
  __int16 v11; // [esp-4h] [ebp-10h]
  int v12; // [esp+0h] [ebp-Ch] BYREF
  __int16 v13; // [esp+4h] [ebp-8h]
  char v14; // [esp+8h] [ebp-4h]

  v14 = 0;
  v1 = dword_EA3E4[(unsigned __int16)a1[20]];
  if ( *(int *)(v1 + 8) < 0 || (*(_BYTE *)(v1 + 13) & 4) != 0 )
    return 1;
  if ( *((int *)a1 + 4) <= 5 )
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(v1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(v1 + 80);
    a1[14] = *(_WORD *)(v1 + 28);
    v2 = a1[8];
    v3 = *(_WORD *)(v1 + 30);
    a1[15] = v3;
    v4 = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(v1 + 28), v3 - 16 * v2, 384);
    sub_57CF0(v4, (int)a1, (int)&word_EB398);
    goto LABEL_10;
  }
  v5 = dword_EA3E4[(unsigned __int16)a1[19]];
  if ( *(int *)(v5 + 8) < 0 || (*(_BYTE *)(v5 + 13) & 4) != 0 )
  {
    v14 = 1;
    goto LABEL_10;
  }
  v12 = *(_DWORD *)(v5 + 76);
  v13 = *(_WORD *)(v5 + 80);
  sub_57FA0(&v12, *(_WORD *)(v5 + 28), 0, 384);
  *(_DWORD *)&word_EB398 = *((_DWORD *)a1 + 19);
  *(&word_EB398 + 2) = a1[40];
  v11 = 32 * (a1[8] - 5);
  v10 = sub_58210(a1 + 38, &v12);
  v6 = sub_581E0(a1 + 38, &v12);
  v7 = (unsigned __int16)sub_57FA0(&word_EB398, v6, v10, v11);
  sub_57CF0(v7, (int)a1, (int)&word_EB398);
  v8 = sub_10C40(a1 + 38);
  if ( (__int16)a1[40] >= v8 + 64 )
  {
LABEL_10:
    ++*((_DWORD *)a1 + 4);
    return v14;
  }
  a1[40] = v8;
  v14 = 1;
  ++*((_DWORD *)a1 + 4);
  return v14;
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (00059F60) --------------------------------------------------------
void __cdecl sub_59F60(int a1)
{
  unsigned int v1; // eax
  int v2; // eax
  char v3; // al
  unsigned __int16 v4; // bx
  unsigned __int16 v5; // cx
  __int64 v6; // rax
  int v7; // eax
  unsigned __int16 v8; // bx
  unsigned __int16 v9; // cx
  int v10; // edx
  unsigned __int16 v11; // di
  int v12; // eax
  __int16 v13; // bx
  int v14; // edx
  unsigned __int16 v15; // cx
  unsigned __int16 v16; // di
  int v17; // edi
  __int16 v18; // bx
  unsigned __int16 v19; // cx
  unsigned __int8 v20; // dh
  int v21; // edx
  unsigned __int16 v22; // bx
  unsigned __int16 v23; // ax
  unsigned __int16 v24; // cx
  char v25; // al
  unsigned __int16 v26; // bx
  char v27; // cl
  unsigned __int16 v28; // ax
  int v29; // eax
  __int16 v30; // bx
  int v31; // edx
  unsigned __int16 v32; // cx
  unsigned __int16 v33; // di
  unsigned __int16 v34; // bx
  unsigned __int16 v35; // cx
  unsigned __int16 v36; // ax
  unsigned __int16 v37; // bx
  int k; // eax
  int v39; // edx
  unsigned __int16 v40; // cx
  unsigned __int16 v41; // di
  __int16 v42; // bx
  int n; // eax
  int v44; // edx
  unsigned __int16 v45; // cx
  unsigned __int16 v46; // di
  __int16 v47; // bx
  int m; // edi
  unsigned __int16 v49; // cx
  unsigned __int8 v50; // dh
  int v51; // edx
  unsigned __int16 v52; // bx
  unsigned __int16 v53; // ax
  unsigned __int16 v54; // cx
  char v55; // al
  char v56; // cl
  unsigned __int16 v57; // ax
  int v58; // eax
  __int16 v59; // bx
  int v60; // edx
  unsigned __int16 v61; // cx
  unsigned __int16 v62; // di
  char v63; // al
  int v64; // eax
  unsigned __int16 v65; // bx
  unsigned __int16 v66; // cx
  int v67; // edx
  unsigned __int16 v68; // di
  int v69; // edx
  __int16 v70; // bx
  int v71; // eax
  unsigned __int16 v72; // cx
  unsigned __int16 v73; // di
  int v74; // edx
  __int16 jj; // bx
  int v76; // eax
  unsigned __int16 v77; // cx
  unsigned __int16 v78; // di
  __int16 v79; // bx
  int ii; // edx
  int v81; // eax
  unsigned __int16 v82; // cx
  unsigned __int16 v83; // di
  int v84; // edx
  __int16 v85; // bx
  int v86; // eax
  unsigned __int16 v87; // cx
  unsigned __int16 v88; // di
  int v89; // edx
  __int16 v90; // bx
  int v91; // eax
  unsigned __int16 v92; // cx
  unsigned __int16 v93; // di
  char v94; // al
  int v95; // eax
  int v96; // ebx
  unsigned __int16 v97; // dx
  char v98; // cl
  unsigned __int16 v99; // dx
  int v100; // edx
  unsigned __int16 kk; // bx
  unsigned __int8 v102; // ch
  unsigned __int8 v103; // ch
  int v104; // eax
  int v105; // ebx
  unsigned __int16 v106; // dx
  char v107; // cl
  int v108; // ebx
  unsigned __int16 v109; // dx
  int v110; // edx
  int v111; // ebx
  unsigned __int8 v112; // ch
  int v113; // ebx
  unsigned __int8 v114; // ch
  char v115; // al
  int v116; // edx
  unsigned __int16 nn; // bx
  unsigned __int16 v118; // ax
  unsigned __int16 v119; // cx
  char v120; // al
  unsigned __int16 v121; // bx
  char v122; // cl
  unsigned __int16 v123; // ax
  unsigned __int16 v124; // bx
  int mm; // edx
  unsigned __int16 v126; // ax
  unsigned __int16 v127; // cx
  char v128; // al
  unsigned __int16 v129; // bx
  char v130; // cl
  unsigned __int16 v131; // ax
  int v132; // edx
  char v133; // al
  int v134; // edx
  unsigned __int16 i1; // bx
  unsigned __int16 v136; // ax
  int v137; // ecx
  int v138; // edi
  int v139; // ecx
  int v140; // edx
  int v141; // ebx
  int v142; // ecx
  int v143; // edi
  int v144; // ebx
  int v145; // ecx
  __int16 v146; // di
  char v147; // al
  int v148; // edx
  unsigned __int16 v149; // bx
  unsigned __int16 v150; // ax
  unsigned __int16 v151; // di
  unsigned __int16 v152; // di
  unsigned __int16 v153; // di
  char v154; // ch
  char v155; // cl
  unsigned __int16 v156; // di
  char v157; // ah
  int v158; // edx
  unsigned __int16 v159; // bx
  unsigned __int8 v160; // ch
  unsigned __int8 v161; // ch
  unsigned __int8 v162; // ch
  unsigned __int8 v163; // ch
  int v164; // edx
  __int16 v165; // bx
  unsigned __int16 v166; // bx
  unsigned __int16 v167; // ax
  char v168; // cl
  int v169; // eax
  unsigned __int16 v170; // cx
  unsigned __int16 v171; // di
  int v172; // edx
  int v173; // ebx
  unsigned __int16 v174; // ax
  int v175; // ebx
  unsigned __int16 v176; // di
  unsigned __int16 v177; // di
  unsigned __int16 v178; // di
  char v179; // ch
  char v180; // cl
  unsigned __int16 v181; // di
  char v182; // ah
  int v183; // edx
  int v184; // ebx
  int v185; // ebx
  unsigned __int8 v186; // ch
  int v187; // ebx
  unsigned __int8 v188; // ch
  int v189; // ebx
  unsigned __int8 v190; // ch
  int v191; // ebx
  unsigned __int8 v192; // ch
  int v193; // eax
  __int16 v194; // bx
  unsigned __int16 v195; // bx
  unsigned __int16 v196; // ax
  int v197; // edx
  unsigned __int16 v198; // cx
  unsigned __int16 v199; // di
  int i; // [esp+4h] [ebp-1Ch]
  int v201; // [esp+8h] [ebp-18h]
  int v202; // [esp+Ch] [ebp-14h]
  int j; // [esp+10h] [ebp-10h]
  int v204; // [esp+14h] [ebp-Ch]
  int v205; // [esp+18h] [ebp-8h]
  int v206; // [esp+1Ch] [ebp-4h]
  unsigned __int16 v207; // [esp+1Ch] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 8);
  if ( !v1 )
  {
    LOBYTE(v207) = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
    v2 = (*(__int16 *)(a1 + 78) + 128) >> 8;
    HIBYTE(v207) = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
    BYTE1(v2) = *(_BYTE *)(a1 + 70);
    ++*(_DWORD *)(a1 + 16);
    if ( BYTE1(v2) )
      HIBYTE(v207) = v2 - 1;
    else
      --v207;
    v3 = *(_BYTE *)(a1 + 70);
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v34 = v207;
        for ( i = 0; i < 2; ++i )
        {
          v35 = v34;
          for ( j = 0; j < *(_DWORD *)(a1 + 16); ++j )
          {
            if ( byte_10B4E0[v35] != 8
              || (LOBYTE(v36) = v34,
                  HIBYTE(v36) = HIBYTE(v35) + 1,
                  (int)abs32((unsigned __int8)byte_11B4E0[v35] - (unsigned __int8)byte_11B4E0[v36]) > 30) )
            {
              byte_11B4E0[v35] += 48;
            }
            ++HIBYTE(v35);
          }
          --v34;
        }
        v37 = v207;
        for ( k = 0; k < 3; ++k )
        {
          v39 = -1;
          v40 = v37 - 256;
          while ( v39 < *(_DWORD *)(a1 + 16) )
          {
            v41 = v40;
            ++v39;
            ++HIBYTE(v40);
            byte_10B4E0[v41] = 8;
            byte_13B4E0[v41] = 1;
          }
          --v37;
        }
        if ( byte_D41B6 )
        {
          v47 = v207 + 1;
          for ( m = 0; m < 4; ++m )
          {
            v201 = -1;
            v49 = v47 - 256;
            while ( *(_DWORD *)(a1 + 16) + 1 > v201 )
            {
              v50 = byte_11B4E0[v49];
              if ( (unsigned __int8)byte_14B4E0[v49] > v50 )
              {
                byte_13B4E0[v49] &= ~8u;
              }
              else
              {
                byte_14B4E0[v49] = v50 - 1;
                byte_13B4E0[v49] |= 8u;
              }
              ++HIBYTE(v49);
              ++v201;
            }
            --v47;
          }
        }
        else
        {
          v42 = v207 + 1;
          for ( n = 0; n < 4; ++n )
          {
            v44 = -1;
            v45 = v42 - 256;
            while ( v44 < *(_DWORD *)(a1 + 16) + 1 )
            {
              v46 = v45;
              ++v44;
              ++HIBYTE(v45);
              byte_13B4E0[v46] &= ~8u;
            }
            --v42;
          }
        }
        v51 = -1;
        v52 = v207 - 256;
        while ( v51 < *(_DWORD *)(a1 + 16) )
        {
          LOBYTE(v52) = v52 + 1;
          ++HIBYTE(v52);
          v53 = v52;
          LOBYTE(v52) = v52 - 2;
          HIBYTE(v52) -= 2;
          v54 = v52;
          LOBYTE(v52) = v52 + 1;
          v55 = byte_11B4E0[v54] - byte_11B4E0[v53] + 32;
          ++HIBYTE(v52);
          if ( v55 >= 28 )
          {
            if ( v55 > 40 )
              v55 = (v55 & 7) + 40;
          }
          else
          {
            v55 = (v55 & 3) + 28;
          }
          if ( *(_BYTE *)(dword_D41A0 + 196308) )
            v56 = 32 - v55 + 32;
          else
            v56 = v55;
          v57 = v52;
          ++v51;
          ++HIBYTE(v52);
          byte_12B4E0[v57] = v56;
        }
        v58 = -3;
        v59 = v207 - 3;
        while ( v58 < 6 )
        {
          v60 = -3;
          v61 = v59 - 768;
          while ( v60 < *(_DWORD *)(a1 + 16) + 3 )
          {
            v62 = v61;
            ++v60;
            ++HIBYTE(v61);
            byte_13B4E0[v62] |= 0x80u;
          }
          ++v58;
          ++v59;
        }
      }
      *(_WORD *)(a1 + 42) = 48;
      *(_DWORD *)(a1 + 8) = 3;
    }
    else
    {
      v205 = 0;
      v4 = v207;
      while ( v205 < *(_DWORD *)(a1 + 16) )
      {
        v204 = 0;
        v5 = v4;
        while ( v204 < 2 )
        {
          if ( byte_10B4E0[v5] != 8
            || (v6 = (unsigned __int8)byte_11B4E0[v5] - (unsigned __int8)byte_11B4E0[(unsigned __int16)(v5 + 1)],
                (int)((HIDWORD(v6) ^ v6) - HIDWORD(v6)) > 30) )
          {
            byte_11B4E0[v5] += 48;
          }
          --HIBYTE(v5);
          ++v204;
        }
        ++v4;
        ++v205;
      }
      v7 = -1;
      v8 = v207 - 1;
      while ( v7 < *(_DWORD *)(a1 + 16) )
      {
        v9 = v8;
        v10 = 0;
        while ( v10 < 3 )
        {
          v11 = v9;
          ++v10;
          --HIBYTE(v9);
          byte_10B4E0[v11] = 8;
          byte_13B4E0[v11] = 1;
        }
        ++v7;
        ++v8;
      }
      if ( byte_D41B6 )
      {
        v17 = -1;
        v18 = v207 - 1;
        while ( v17 < *(_DWORD *)(a1 + 16) + 1 )
        {
          v202 = 0;
          v19 = v18 + 256;
          while ( v202 < 4 )
          {
            v20 = byte_11B4E0[v19];
            if ( (unsigned __int8)byte_14B4E0[v19] > v20 )
            {
              byte_13B4E0[v19] &= ~8u;
            }
            else
            {
              byte_14B4E0[v19] = v20 - 1;
              byte_13B4E0[v19] |= 8u;
            }
            --HIBYTE(v19);
            ++v202;
          }
          ++v17;
          ++v18;
        }
      }
      else
      {
        v12 = -1;
        v13 = v207 - 1;
        while ( v12 < *(_DWORD *)(a1 + 16) + 1 )
        {
          v14 = 0;
          v15 = v13 + 256;
          while ( v14 < 4 )
          {
            v16 = v15;
            ++v14;
            --HIBYTE(v15);
            byte_13B4E0[v16] &= ~8u;
          }
          ++v12;
          ++v13;
        }
      }
      v21 = -1;
      v22 = v207 - 1;
      while ( v21 < *(_DWORD *)(a1 + 16) )
      {
        LOBYTE(v22) = v22 + 1;
        ++HIBYTE(v22);
        v23 = v22;
        LOBYTE(v22) = v22 - 2;
        HIBYTE(v22) -= 2;
        v24 = v22;
        LOBYTE(v22) = v22 + 1;
        v25 = byte_11B4E0[v24] - byte_11B4E0[v23] + 32;
        HIBYTE(v26) = HIBYTE(v22) + 1;
        if ( v25 >= 28 )
        {
          if ( v25 > 40 )
            v25 = (v25 & 7) + 40;
        }
        else
        {
          v25 = (v25 & 3) + 28;
        }
        if ( *(_BYTE *)(dword_D41A0 + 196308) )
          v27 = 32 - v25 + 32;
        else
          v27 = v25;
        v28 = v26;
        ++v21;
        v22 = v26 + 1;
        byte_12B4E0[v28] = v27;
      }
      v29 = -3;
      v30 = v207 - 3;
      while ( v29 < *(_DWORD *)(a1 + 16) + 3 )
      {
        v31 = -3;
        v32 = v30 + 768;
        while ( v31 < 6 )
        {
          v33 = v32;
          ++v31;
          --HIBYTE(v32);
          byte_13B4E0[v33] |= 0x80u;
        }
        ++v29;
        ++v30;
      }
      *(_WORD *)(a1 + 42) = 48;
      *(_DWORD *)(a1 + 8) = 3;
    }
    return;
  }
  if ( v1 <= 1 )
  {
    if ( *(_WORD *)(a1 + 42) < 0x30u )
    {
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 47);
      LOBYTE(v206) = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
      if ( *(_BYTE *)(a1 + 70) )
      {
        BYTE1(v206) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - 1;
      }
      else
      {
        BYTE1(v206) = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
        LOWORD(v206) = v206 - 1;
      }
      if ( !*(_WORD *)(a1 + 42) )
      {
        v63 = *(_BYTE *)(a1 + 70);
        if ( v63 )
        {
          if ( v63 == 1 )
          {
            v79 = v206;
            for ( ii = 0; ii < 3; ++ii )
            {
              v81 = 2;
              v82 = v79 + 512;
              while ( v81 < *(_DWORD *)(a1 + 16) - 3 )
              {
                v83 = v82;
                ++v81;
                ++HIBYTE(v82);
                byte_10B4E0[v83] = 8;
                byte_13B4E0[v83] = 1;
              }
              --v79;
            }
            if ( !byte_D41B6 )
            {
              v84 = 0;
              v85 = v206 + 1;
              while ( v84 < 4 )
              {
                v86 = 2;
                v87 = v85 + 512;
                while ( v86 < *(_DWORD *)(a1 + 16) - 2 )
                {
                  v88 = v87;
                  ++v86;
                  ++HIBYTE(v87);
                  byte_13B4E0[v88] &= ~8u;
                }
                ++v84;
                --v85;
              }
            }
            v89 = -3;
            v90 = v206 - 3;
            while ( v89 < 6 )
            {
              v91 = -3;
              v92 = v90 - 768;
              while ( v91 < *(_DWORD *)(a1 + 16) + 3 )
              {
                v93 = v92;
                ++v91;
                ++HIBYTE(v92);
                byte_13B4E0[v93] |= 0x80u;
              }
              ++v89;
              ++v90;
            }
          }
        }
        else
        {
          v64 = 2;
          v65 = v206 + 2;
          while ( v64 < *(_DWORD *)(a1 + 16) - 3 )
          {
            v66 = v65;
            v67 = 0;
            while ( v67 < 3 )
            {
              v68 = v66;
              ++v67;
              --HIBYTE(v66);
              byte_10B4E0[v68] = 8;
              byte_13B4E0[v68] = 1;
            }
            ++v64;
            ++v65;
          }
          if ( !byte_D41B6 )
          {
            v69 = 2;
            v70 = v206 + 2;
            while ( v69 < *(_DWORD *)(a1 + 16) - 2 )
            {
              v71 = 0;
              v72 = v70 + 256;
              while ( v71 < 4 )
              {
                v73 = v72;
                ++v71;
                --HIBYTE(v72);
                byte_13B4E0[v73] &= ~8u;
              }
              ++v69;
              ++v70;
            }
          }
          v74 = -3;
          for ( jj = v206 - 3; v74 < *(_DWORD *)(a1 + 16) + 3; ++jj )
          {
            v76 = -3;
            v77 = jj + 768;
            while ( v76 < 6 )
            {
              v78 = v77;
              ++v76;
              --HIBYTE(v77);
              byte_13B4E0[v78] |= 0x80u;
            }
            ++v74;
          }
        }
      }
      ++*(_WORD *)(a1 + 42);
      v94 = *(_BYTE *)(a1 + 70);
      if ( v94 )
      {
        if ( v94 == 1 )
        {
          v105 = v206;
          v104 = 3;
          BYTE1(v105) = BYTE1(v206) + 3;
          while ( v104 < *(_DWORD *)(a1 + 16) - 3 )
          {
            v106 = v105;
            v107 = byte_11B4E0[(unsigned __int16)v105] + 1;
            v108 = v105 - 1;
            byte_11B4E0[v106] = v107;
            v109 = v108;
            ++v104;
            v105 = v108 + 1;
            ++BYTE1(v105);
            ++byte_11B4E0[v109];
          }
          if ( byte_D41B6 )
          {
            v111 = v206;
            v110 = 3;
            BYTE1(v111) = BYTE1(v206) + 3;
            while ( v110 < *(_DWORD *)(a1 + 16) - 3 )
            {
              v112 = byte_11B4E0[(unsigned __int16)v111];
              if ( (unsigned __int8)byte_14B4E0[(unsigned __int16)v111] > v112 )
              {
                byte_13B4E0[(unsigned __int16)v111] &= ~8u;
              }
              else
              {
                byte_14B4E0[(unsigned __int16)v111] = v112 - 1;
                byte_13B4E0[(unsigned __int16)v111] |= 8u;
              }
              v113 = v111 - 1;
              v114 = byte_11B4E0[(unsigned __int16)v113];
              if ( (unsigned __int8)byte_14B4E0[(unsigned __int16)v113] > v114 )
              {
                byte_13B4E0[(unsigned __int16)v113] &= ~8u;
              }
              else
              {
                byte_14B4E0[(unsigned __int16)v113] = v114 - 1;
                byte_13B4E0[(unsigned __int16)v113] |= 8u;
              }
              v111 = v113 + 1;
              ++v110;
              ++BYTE1(v111);
            }
          }
        }
      }
      else
      {
        v95 = 3;
        v96 = v206 + 3;
        while ( v95 < *(_DWORD *)(a1 + 16) - 3 )
        {
          v97 = v96;
          v98 = byte_11B4E0[(unsigned __int16)v96] + 1;
          --BYTE1(v96);
          byte_11B4E0[v97] = v98;
          v99 = v96;
          ++v95;
          ++BYTE1(v96);
          ++v96;
          ++byte_11B4E0[v99];
        }
        if ( byte_D41B6 )
        {
          v100 = 3;
          for ( kk = v206 + 3; v100 < *(_DWORD *)(a1 + 16) - 3; ++kk )
          {
            v102 = byte_11B4E0[kk];
            if ( (unsigned __int8)byte_14B4E0[kk] > v102 )
            {
              byte_13B4E0[kk] &= ~8u;
            }
            else
            {
              byte_14B4E0[kk] = v102 - 1;
              byte_13B4E0[kk] |= 8u;
            }
            --HIBYTE(kk);
            v103 = byte_11B4E0[kk];
            if ( (unsigned __int8)byte_14B4E0[kk] > v103 )
            {
              byte_13B4E0[kk] &= ~8u;
            }
            else
            {
              byte_14B4E0[kk] = v103 - 1;
              byte_13B4E0[kk] |= 8u;
            }
            ++HIBYTE(kk);
            ++v100;
          }
        }
      }
      if ( *(_WORD *)(a1 + 42) >= 0x30u )
      {
        v115 = *(_BYTE *)(a1 + 70);
        if ( v115 )
        {
          if ( v115 == 1 )
          {
            v124 = v206;
            for ( mm = 0; mm < 3; ++mm )
            {
              LOBYTE(v124) = v124 + 1;
              ++HIBYTE(v124);
              v126 = v124;
              LOBYTE(v124) = v124 - 2;
              HIBYTE(v124) -= 2;
              v127 = v124;
              LOBYTE(v124) = v124 + 1;
              v128 = byte_11B4E0[v127] - byte_11B4E0[v126] + 32;
              HIBYTE(v129) = HIBYTE(v124) + 1;
              if ( v128 >= 28 )
              {
                if ( v128 > 40 )
                  v128 = (v128 & 7) + 40;
              }
              else
              {
                v128 = (v128 & 3) + 28;
              }
              if ( *(_BYTE *)(dword_D41A0 + 196308) )
                v130 = 32 - v128 + 32;
              else
                v130 = v128;
              v131 = v129;
              v124 = v129 + 1;
              byte_12B4E0[v131] = v130;
            }
          }
        }
        else
        {
          v116 = -1;
          for ( nn = v206 - 1; v116 < *(_DWORD *)(a1 + 16); byte_12B4E0[v123] = v122 )
          {
            LOBYTE(nn) = nn + 1;
            ++HIBYTE(nn);
            v118 = nn;
            LOBYTE(nn) = nn - 2;
            HIBYTE(nn) -= 2;
            v119 = nn;
            LOBYTE(nn) = nn + 1;
            v120 = byte_11B4E0[v119] - byte_11B4E0[v118] + 32;
            HIBYTE(v121) = HIBYTE(nn) + 1;
            if ( v120 >= 28 )
            {
              if ( v120 > 40 )
                v120 = (v120 & 7) + 40;
            }
            else
            {
              v120 = (v120 & 3) + 28;
            }
            if ( *(_BYTE *)(dword_D41A0 + 196308) )
              v122 = 32 - v120 + 32;
            else
              v122 = v120;
            v123 = v121;
            ++v116;
            nn = v121 + 1;
          }
        }
      }
      return;
    }
    v132 = dword_D41A0 + 28302;
    *(_DWORD *)(a1 + 8) = 3;
LABEL_291:
    sub_6EAB0((__int16)((a1 - v132) / 168), -1, 47);
    return;
  }
  if ( v1 != 2 )
    return;
  if ( !*(_WORD *)(a1 + 42) )
  {
    v132 = dword_D41A0 + 28302;
    *(_DWORD *)(a1 + 8) = 4;
    goto LABEL_291;
  }
  sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 47);
  LOBYTE(v206) = (unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8;
  if ( *(_BYTE *)(a1 + 70) )
  {
    BYTE1(v206) = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - 1;
  }
  else
  {
    BYTE1(v206) = (unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8;
    LOWORD(v206) = v206 - 1;
  }
  v133 = *(_BYTE *)(a1 + 70);
  if ( v133 )
  {
    if ( v133 == 1 )
    {
      v141 = v206;
      v140 = 3;
      BYTE1(v141) = BYTE1(v206) + 3;
      while ( v140 < *(_DWORD *)(a1 + 16) - 3 )
      {
        v142 = (unsigned __int8)byte_11B4E0[(unsigned __int16)v141];
        v143 = ((unsigned __int8)byte_11B4E0[(unsigned __int16)(v141 - 2)]
              + (unsigned __int8)byte_11B4E0[(unsigned __int16)(v141 + 1)]) >> 1;
        if ( v143 < v142 )
          byte_11B4E0[(unsigned __int16)v141] = v142 - 1;
        v144 = v141 - 1;
        v145 = (unsigned __int8)byte_11B4E0[(unsigned __int16)v144];
        if ( v143 < v145 )
          byte_11B4E0[(unsigned __int16)v144] = v145 - 1;
        v141 = v144 + 1;
        ++v140;
        ++BYTE1(v141);
      }
    }
  }
  else
  {
    v134 = 3;
    for ( i1 = v206 + 3; v134 < *(_DWORD *)(a1 + 16) - 3; ++i1 )
    {
      v136 = i1 + 256;
      HIBYTE(v136) = HIBYTE(i1) - 2;
      v137 = (unsigned __int8)byte_11B4E0[i1];
      v138 = ((unsigned __int8)byte_11B4E0[v136] + (unsigned __int8)byte_11B4E0[(unsigned __int16)(i1 + 256)]) >> 1;
      if ( v138 < v137 )
        byte_11B4E0[i1] = v137 - 1;
      --HIBYTE(i1);
      v139 = (unsigned __int8)byte_11B4E0[i1];
      if ( v138 < v139 )
        byte_11B4E0[i1] = v139 - 1;
      ++HIBYTE(i1);
      ++v134;
    }
  }
  v146 = *(_WORD *)(a1 + 42) - 1;
  *(_WORD *)(a1 + 42) = v146;
  if ( !v146 )
  {
    v147 = *(_BYTE *)(a1 + 70);
    if ( v147 )
    {
      if ( v147 != 1 )
        return;
      v173 = v206;
      v172 = 3;
      BYTE1(v173) = BYTE1(v206) + 3;
      while ( v172 < *(_DWORD *)(a1 + 16) - 4 )
      {
        v174 = v173 + 2;
        if ( byte_10B4E0[(unsigned __int16)(v173 + 2)] == 8 )
          HIBYTE(v174) += *(int *)(a1 + 16) >> 1;
        v175 = v173 + 1;
        v176 = v175;
        byte_10B4E0[(unsigned __int16)v175] = byte_10B4E0[v174];
        byte_13B4E0[(unsigned __int16)v175] = byte_13B4E0[v174];
        byte_12B4E0[(unsigned __int16)v175--] = 32;
        byte_13B4E0[v176] |= 0x80u;
        v177 = v175;
        byte_10B4E0[(unsigned __int16)v175] = byte_10B4E0[v174];
        byte_13B4E0[(unsigned __int16)v175] = byte_13B4E0[v174];
        byte_12B4E0[(unsigned __int16)v175--] = 32;
        byte_13B4E0[v177] |= 0x80u;
        v178 = v175;
        byte_10B4E0[(unsigned __int16)v175] = byte_10B4E0[v174];
        byte_13B4E0[(unsigned __int16)v175] = byte_13B4E0[v174];
        byte_12B4E0[(unsigned __int16)v175] = 32;
        v179 = byte_13B4E0[(unsigned __int16)v175--] | 0x80;
        byte_13B4E0[v178] = v179;
        v180 = byte_10B4E0[v174];
        v181 = v175;
        ++v172;
        byte_13B4E0[(unsigned __int16)v175] = byte_13B4E0[v174];
        v173 = v175 + 2;
        byte_12B4E0[v181] = 32;
        v182 = byte_13B4E0[v181];
        byte_10B4E0[v181] = v180;
        ++BYTE1(v173);
        byte_13B4E0[v181] = v182 | 0x80;
      }
      if ( byte_D41B6 )
      {
        v184 = v206;
        v183 = 3;
        BYTE1(v184) = BYTE1(v206) + 3;
        if ( *(_DWORD *)(a1 + 16) - 4 > 3 )
        {
          do
          {
            v185 = v184 + 1;
            v186 = byte_11B4E0[(unsigned __int16)v185];
            if ( (unsigned __int8)byte_14B4E0[(unsigned __int16)v185] > v186 )
            {
              byte_13B4E0[(unsigned __int16)v185] &= ~8u;
            }
            else
            {
              byte_14B4E0[(unsigned __int16)v185] = v186 - 1;
              byte_13B4E0[(unsigned __int16)v185] |= 8u;
            }
            v187 = v185 - 1;
            v188 = byte_11B4E0[(unsigned __int16)v187];
            if ( (unsigned __int8)byte_14B4E0[(unsigned __int16)v187] > v188 )
            {
              byte_13B4E0[(unsigned __int16)v187] &= ~8u;
            }
            else
            {
              byte_14B4E0[(unsigned __int16)v187] = v188 - 1;
              byte_13B4E0[(unsigned __int16)v187] |= 8u;
            }
            v189 = v187 - 1;
            v190 = byte_11B4E0[(unsigned __int16)v189];
            if ( (unsigned __int8)byte_14B4E0[(unsigned __int16)v189] > v190 )
            {
              byte_13B4E0[(unsigned __int16)v189] &= ~8u;
            }
            else
            {
              byte_14B4E0[(unsigned __int16)v189] = v190 - 1;
              byte_13B4E0[(unsigned __int16)v189] |= 8u;
            }
            v191 = v189 - 1;
            v192 = byte_11B4E0[(unsigned __int16)v191];
            if ( (unsigned __int8)byte_14B4E0[(unsigned __int16)v191] > v192 )
            {
              byte_13B4E0[(unsigned __int16)v191] &= ~8u;
            }
            else
            {
              byte_14B4E0[(unsigned __int16)v191] = v192 - 1;
              byte_13B4E0[(unsigned __int16)v191] |= 8u;
            }
            v184 = v191 + 2;
            ++v183;
            ++BYTE1(v184);
          }
          while ( v183 < *(_DWORD *)(a1 + 16) - 4 );
          v193 = -3;
          v194 = v206 - 3;
          goto LABEL_285;
        }
      }
      else
      {
        v195 = v206 + 768;
        byte_13B4E0[(unsigned __int16)(v195 + 1)] &= ~8u;
        byte_13B4E0[v195] &= ~8u;
        v196 = v206 + 767;
        byte_13B4E0[v196] = byte_13B4E0[(unsigned __int16)(v206 + 767)] & 0xF7;
        byte_13B4E0[(unsigned __int16)(v196 - 1)] &= ~8u;
      }
      v193 = -3;
      v194 = v206 - 3;
      do
      {
LABEL_285:
        v197 = -3;
        v198 = v194 - 768;
        while ( v197 < *(_DWORD *)(a1 + 16) + 3 )
        {
          v199 = v198;
          ++v197;
          ++HIBYTE(v198);
          byte_13B4E0[v199] |= 0x80u;
        }
        ++v193;
        ++v194;
      }
      while ( v193 < 6 );
      return;
    }
    v148 = 3;
    v149 = v206 + 3;
    while ( v148 < *(_DWORD *)(a1 + 16) - 4 )
    {
      v150 = v149 + 512;
      if ( byte_10B4E0[(unsigned __int16)(v149 + 512)] == 8 )
        v150 += *(int *)(a1 + 16) >> 1;
      ++HIBYTE(v149);
      v151 = v149;
      byte_10B4E0[v149] = byte_10B4E0[v150];
      byte_13B4E0[v149] = byte_13B4E0[v150];
      byte_12B4E0[v149] = 32;
      --HIBYTE(v149);
      byte_13B4E0[v151] |= 0x80u;
      v152 = v149;
      byte_10B4E0[v149] = byte_10B4E0[v150];
      byte_13B4E0[v149] = byte_13B4E0[v150];
      byte_12B4E0[v149] = 32;
      --HIBYTE(v149);
      byte_13B4E0[v152] |= 0x80u;
      v153 = v149;
      byte_10B4E0[v149] = byte_10B4E0[v150];
      byte_13B4E0[v149] = byte_13B4E0[v150];
      byte_12B4E0[v149] = 32;
      v154 = byte_13B4E0[v149] | 0x80;
      --HIBYTE(v149);
      byte_13B4E0[v153] = v154;
      v155 = byte_10B4E0[v150];
      v156 = v149;
      ++v148;
      byte_13B4E0[v149] = byte_13B4E0[v150];
      HIBYTE(v149) += 2;
      byte_12B4E0[v156] = 32;
      v157 = byte_13B4E0[v156];
      byte_10B4E0[v156] = v155;
      ++v149;
      byte_13B4E0[v156] = v157 | 0x80;
    }
    if ( byte_D41B6 )
    {
      v158 = 3;
      v159 = v206 + 3;
      if ( *(_DWORD *)(a1 + 16) - 4 > 3 )
      {
        do
        {
          ++HIBYTE(v159);
          v160 = byte_11B4E0[v159];
          if ( (unsigned __int8)byte_14B4E0[v159] > v160 )
          {
            byte_13B4E0[v159] &= ~8u;
          }
          else
          {
            byte_14B4E0[v159] = v160 - 1;
            byte_13B4E0[v159] |= 8u;
          }
          --HIBYTE(v159);
          v161 = byte_11B4E0[v159];
          if ( (unsigned __int8)byte_14B4E0[v159] > v161 )
          {
            byte_13B4E0[v159] &= ~8u;
          }
          else
          {
            byte_14B4E0[v159] = v161 - 1;
            byte_13B4E0[v159] |= 8u;
          }
          --HIBYTE(v159);
          v162 = byte_11B4E0[v159];
          if ( (unsigned __int8)byte_14B4E0[v159] > v162 )
          {
            byte_13B4E0[v159] &= ~8u;
          }
          else
          {
            byte_14B4E0[v159] = v162 - 1;
            byte_13B4E0[v159] |= 8u;
          }
          --HIBYTE(v159);
          v163 = byte_11B4E0[v159];
          if ( (unsigned __int8)byte_14B4E0[v159] > v163 )
          {
            byte_13B4E0[v159] &= ~8u;
          }
          else
          {
            byte_14B4E0[v159] = v163 - 1;
            byte_13B4E0[v159] |= 8u;
          }
          HIBYTE(v159) += 2;
          ++v158;
          ++v159;
        }
        while ( v158 < *(_DWORD *)(a1 + 16) - 4 );
        v164 = -3;
        v165 = v206 - 3;
        goto LABEL_260;
      }
    }
    else
    {
      v166 = v206 + 3;
      byte_13B4E0[(unsigned __int16)(v206 + 259)] &= ~8u;
      HIBYTE(v166) = ((unsigned __int16)(v206 + 3) >> 8) - 1;
      byte_13B4E0[(unsigned __int16)(v206 + 3)] &= ~8u;
      v167 = v166;
      v168 = byte_13B4E0[v166] & 0xF7;
      HIBYTE(v166) = ((unsigned __int16)(v206 + 3) >> 8) - 2;
      byte_13B4E0[v167] = v168;
      byte_13B4E0[v166] &= ~8u;
    }
    v164 = -3;
    v165 = v206 - 3;
LABEL_260:
    while ( v164 < *(_DWORD *)(a1 + 16) + 3 )
    {
      v169 = -3;
      v170 = v165 + 768;
      while ( v169 < 6 )
      {
        v171 = v170;
        ++v169;
        --HIBYTE(v170);
        byte_13B4E0[v171] |= 0x80u;
      }
      ++v164;
      ++v165;
    }
  }
}
// 5A61A: variable 'v206' is possibly undefined
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;

//----- (0005B070) --------------------------------------------------------
unsigned int __cdecl sub_5B070(int a1)
{
  int v1; // eax
  char v2; // dl
  char v3; // bl
  unsigned int result; // eax

  v1 = word_15B4E0[256 * (unsigned __int8)((unsigned __int16)(*(_WORD *)(a1 + 78) - 128) >> 8)
                 + (unsigned __int8)((unsigned __int16)(*(_WORD *)(a1 + 76) - 128) >> 8)];
  v2 = 0;
  while ( 1 )
  {
    result = dword_EA3E4[v1];
    if ( result <= dword_EA3E4[0] )
      break;
    if ( *(_BYTE *)(result + 63) == 14 )
    {
      v3 = *(_BYTE *)(result + 64);
      if ( v3 == 1 || v3 == 2 )
      {
        v2 = 1;
        break;
      }
    }
    v1 = *(unsigned __int16 *)(result + 22);
  }
  if ( !v2 )
    return 0;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (0005B100) --------------------------------------------------------
void __usercall sub_5B100(int a1@<edx>, int a2@<edi>, int a3)
{
  int v3; // ebx
  int v4; // eax
  int v5; // eax
  char v6; // dl
  unsigned __int16 v7; // bx
  unsigned __int16 v8; // bx
  unsigned __int16 v9; // bx
  char v10; // cl
  unsigned __int16 v11; // bx
  int v12; // edx
  unsigned __int16 v13; // bx
  int i; // eax
  unsigned __int16 v15; // cx
  int v16; // edx
  int v17; // eax
  unsigned __int16 j; // bx
  int v19; // eax
  int v20; // eax
  int v21; // edi
  unsigned __int16 v22; // bx
  unsigned __int16 v23; // cx
  __int64 v24; // rax
  int v25; // edx
  int v26; // eax
  __int64 v27; // rax
  __int64 v28; // rax
  int v29; // edx
  int v30; // eax
  int v31; // edx
  int v32; // [esp-Ch] [ebp-74h]
  int v33; // [esp+0h] [ebp-68h]
  int v34; // [esp+1Ch] [ebp-4Ch]
  int v35; // [esp+20h] [ebp-48h]
  int v36; // [esp+24h] [ebp-44h]
  int v37; // [esp+30h] [ebp-38h]
  int v38; // [esp+34h] [ebp-34h]
  int v39; // [esp+38h] [ebp-30h]
  int v40; // [esp+3Ch] [ebp-2Ch]
  int v41; // [esp+40h] [ebp-28h]
  unsigned __int16 v42; // [esp+44h] [ebp-24h]
  unsigned __int16 v43; // [esp+44h] [ebp-24h]
  unsigned __int16 v44; // [esp+48h] [ebp-20h]
  unsigned __int16 v45; // [esp+4Ch] [ebp-1Ch]
  unsigned __int16 v46; // [esp+4Ch] [ebp-1Ch]
  unsigned __int16 v47; // [esp+4Ch] [ebp-1Ch]
  unsigned __int16 v48; // [esp+50h] [ebp-18h]
  unsigned __int16 v49; // [esp+54h] [ebp-14h]
  char v50; // [esp+58h] [ebp-10h]
  char v51; // [esp+5Ch] [ebp-Ch]
  char v52; // [esp+60h] [ebp-8h]
  char v53; // [esp+64h] [ebp-4h]

  if ( *(_DWORD *)(a3 + 8) <= 2u )
  {
    a2 = *(__int16 *)(a3 + 80);
    a1 = (2 * ((*(unsigned __int16 *)(a3 + 150) << 8) + 512) + 128) >> 8;
    if ( *(_WORD *)(a3 + 44) )
    {
      v33 = (2 * ((*(unsigned __int16 *)(a3 + 150) << 8) + 512) + 128) >> 8;
      v40 = 2;
    }
    else
    {
      v40 = (2 * ((*(unsigned __int16 *)(a3 + 150) << 8) + 512) + 128) >> 8;
      v33 = 2;
    }
    LOBYTE(v42) = HIBYTE(*(_WORD *)(a3 + 76));
    HIBYTE(v42) = HIBYTE(*(_WORD *)(a3 + 78));
    LOBYTE(v49) = v42 - (v33 >> 1);
    HIBYTE(v49) = HIBYTE(v42) - (v40 >> 1);
  }
  v3 = (8 * a1 - (__CFSHL__((8 * a1) >> 31, 5) + 32 * ((8 * a1) >> 31))) >> 5;
  switch ( *(_DWORD *)(a3 + 8) )
  {
    case 0:
      LOBYTE(v43) = HIBYTE(*(_WORD *)(a3 + 76));
      v4 = *(__int16 *)(a3 + 78) >> 8;
      *(_DWORD *)(a3 + 8) = 4;
      HIBYTE(v43) = v4;
      v5 = -1;
      v39 = -1;
      if ( *(_WORD *)(a3 + 44) )
      {
        v6 = 0;
        v7 = v43;
        while ( !v6 )
        {
          if ( (byte_13B4E0[v7] & 8) != 0 )
          {
            v6 = 1;
            v5 = (unsigned __int8)byte_11B4E0[v7];
          }
          LOBYTE(v7) = v7 - 1;
        }
        v8 = v43;
        v52 = 0;
        while ( !v52 )
        {
          if ( (byte_13B4E0[v8] & 8) != 0 )
          {
            v39 = (unsigned __int8)byte_11B4E0[v8];
            v52 = 1;
          }
          LOBYTE(v8) = v8 + 1;
        }
      }
      else
      {
        v9 = v43;
        v10 = 0;
        while ( !v10 )
        {
          if ( (byte_13B4E0[v9] & 8) != 0 )
          {
            v10 = 1;
            v5 = (unsigned __int8)byte_11B4E0[v9];
          }
          --HIBYTE(v9);
        }
        v51 = 0;
        v11 = v43;
        while ( !v51 )
        {
          if ( (byte_13B4E0[v11] & 8) != 0 )
          {
            v39 = (unsigned __int8)byte_11B4E0[v11];
            v51 = 1;
          }
          ++HIBYTE(v11);
        }
      }
      if ( v5 == -1 || v39 == -1 )
      {
        sub_57F20(v5, a3);
      }
      else
      {
        *(_WORD *)(a3 + 80) = (v39 + v5) >> 1;
        v12 = 0;
        v45 = v49;
        while ( v12 < v40 )
        {
          v13 = v45;
          for ( i = 0; i < v33; ++i )
          {
            v15 = v13;
            LOBYTE(v13) = v13 + 1;
            byte_13B4E0[v15] |= 0x80u;
          }
          ++v12;
          ++HIBYTE(v45);
        }
      }
      break;
    case 1:
      sub_6E450((a3 - (dword_D41A0 + 28302)) / 168, -1, 47);
      v35 = (8 * a1 - (__CFSHL__((8 * a1) >> 31, 5) + 32 * ((8 * a1) >> 31))) >> 5;
      v16 = v3 + (unsigned __int8)byte_11B4E0[v42] + 1;
      v41 = (unsigned __int8)byte_14B4E0[v42] - v3 - 1;
      if ( v16 < 0 )
        v16 = 0;
      if ( v16 > a2 )
        v16 = a2;
      if ( a2 > v41 )
        v41 = a2;
      if ( v41 > 254 )
        v41 = 254;
      v50 = 1;
      v38 = 0;
      v46 = v49;
      while ( v38 < v40 )
      {
        v17 = 0;
        for ( j = v46; ; LOBYTE(j) = j + 1 )
        {
          v37 = v17;
          if ( v17 >= v33 )
            break;
          if ( (byte_13B4E0[j] & 8) == 0 )
          {
            v19 = v35 + (unsigned __int8)byte_11B4E0[j];
            if ( v19 > v16 )
              v19 = v16;
            if ( v19 > (unsigned __int8)byte_11B4E0[j] )
            {
              byte_11B4E0[j] = v19;
              v50 = 0;
            }
            v20 = (unsigned __int8)byte_14B4E0[j] - v35;
            if ( v20 < v41 )
              v20 = v41;
            if ( v20 < (unsigned __int8)byte_14B4E0[j] )
            {
              byte_14B4E0[j] = v20;
              v50 = 0;
            }
          }
          if ( (unsigned __int8)byte_14B4E0[j] > (unsigned __int8)byte_11B4E0[j] )
            byte_13B4E0[j] &= ~8u;
          else
            byte_13B4E0[j] |= 8u;
          v17 = v37 + 1;
        }
        ++v38;
        ++HIBYTE(v46);
      }
      if ( v50 )
      {
        v32 = (__int16)((a3 - (dword_D41A0 + 28302)) / 168);
        *(_DWORD *)(a3 + 8) = 3;
        sub_6EAB0(v32, -1, 47);
      }
      break;
    case 2:
      v34 = (8 * a1 - (__CFSHL__((8 * a1) >> 31, 5) + 32 * ((8 * a1) >> 31))) >> 5;
      sub_6E450((a3 - (dword_D41A0 + 28302)) / 168, -1, 47);
      v53 = 1;
      v36 = 0;
      v47 = v49;
      while ( v36 < v40 )
      {
        v21 = 0;
        v22 = v47;
        while ( v21 < v33 )
        {
          if ( *(_WORD *)(a3 + 44) )
          {
            LOBYTE(v48) = v22;
            LOBYTE(v23) = v22;
            LOBYTE(v44) = v22;
            HIBYTE(v48) = HIBYTE(v49) - 1;
            HIBYTE(v23) = HIBYTE(v49) + 2;
            HIBYTE(v44) = HIBYTE(v49) + 3;
          }
          else
          {
            HIBYTE(v48) = HIBYTE(v47);
            HIBYTE(v23) = HIBYTE(v47);
            HIBYTE(v44) = HIBYTE(v47);
            LOBYTE(v48) = v49 - 1;
            LOBYTE(v23) = v49 + 2;
            LOBYTE(v44) = v49 + 3;
          }
          if ( (int)abs32((unsigned __int8)byte_11B4E0[v48] - (unsigned __int8)byte_11B4E0[v23]) <= 4 )
          {
            v25 = ((unsigned __int8)byte_11B4E0[v48] + (unsigned __int8)byte_11B4E0[v23]) / 2;
          }
          else
          {
            v24 = (unsigned __int8)byte_11B4E0[v48] - (unsigned __int8)byte_11B4E0[v44];
            if ( (int)((HIDWORD(v24) ^ v24) - HIDWORD(v24)) > 4 )
              v25 = (unsigned __int8)byte_11B4E0[v23];
            else
              v25 = (unsigned __int8)byte_11B4E0[v48];
          }
          v26 = (unsigned __int8)byte_11B4E0[v22] - v34;
          if ( v26 < v25 )
            v26 = v25;
          if ( v26 < (unsigned __int8)byte_11B4E0[v22] )
          {
            byte_11B4E0[v22] = v26;
            v53 = 0;
          }
          v27 = (unsigned __int8)byte_14B4E0[v48] - (unsigned __int8)byte_14B4E0[v23];
          if ( (int)((HIDWORD(v27) ^ v27) - HIDWORD(v27)) <= 4 )
          {
            v29 = ((unsigned __int8)byte_14B4E0[v48] + (unsigned __int8)byte_14B4E0[v23]) / 2;
          }
          else
          {
            v28 = (unsigned __int8)byte_14B4E0[v48] - (unsigned __int8)byte_14B4E0[v44];
            if ( (int)((HIDWORD(v28) ^ v28) - HIDWORD(v28)) > 4 )
              v29 = (unsigned __int8)byte_14B4E0[v23];
            else
              v29 = (unsigned __int8)byte_14B4E0[v48];
          }
          v30 = v34 + (unsigned __int8)byte_14B4E0[v22];
          if ( v30 > v29 )
            v30 = v29;
          if ( (unsigned __int8)byte_14B4E0[v22] < v30 )
          {
            byte_14B4E0[v22] = v30;
            v53 = 0;
          }
          if ( (unsigned __int8)byte_14B4E0[v22] > (unsigned __int8)byte_11B4E0[v22] )
            byte_13B4E0[v22] &= ~8u;
          else
            byte_13B4E0[v22] |= 8u;
          ++v21;
          LOBYTE(v22) = v22 + 1;
        }
        ++v36;
        ++HIBYTE(v47);
      }
      if ( v53 )
      {
        v31 = dword_D41A0 + 28302;
        *(_DWORD *)(a3 + 8) = 4;
        sub_6EAB0((__int16)((a3 - v31) / 168), -1, 47);
      }
      break;
    default:
      return;
  }
}
// 5B219: conditional instruction was optimized away because %var_54.4==0
// 5B258: conditional instruction was optimized away because %var_58.4==0
// 5B296: conditional instruction was optimized away because %var_5C.4==0
// 5B2D6: conditional instruction was optimized away because %var_50.4==0
// 5B304: variable 'v49' is possibly undefined
// 5B323: variable 'v33' is possibly undefined
// 5B331: variable 'v40' is possibly undefined
// 5B378: variable 'v42' is possibly undefined
// D41A0: using guessed type int dword_D41A0;

//----- (0005B7A0) --------------------------------------------------------
int sub_5B7A0()
{
  int v0; // ebx
  int *v1; // ecx
  signed int i; // eax
  unsigned int j; // edx
  int v5; // [esp+0h] [ebp-Ch]

  v0 = byte_D41B5;
  sub_3B4D0(byte_D41B5);
  v1 = dword_DDF50;
  for ( i = 0; i < (int)(0x100u / (256 / v0)); ++i )
  {
    for ( j = 0; j < 256 / v0; ++j )
    {
      v5 = j * v0 + dword_E9C2C;
      *v1++ = ((i * v0) << 8) + v5;
    }
  }
  _wcpp_1_unwind_leave__93(v5);
  return sub_5B840();
}
// 5B816: variable 'v5' is possibly undefined
// 5B830: using guessed type int __cdecl _wcpp_1_unwind_leave__93(_DWORD);
// D41B5: using guessed type char byte_D41B5;
// DDF50: using guessed type int dword_DDF50[];
// E9C2C: using guessed type int dword_E9C2C;

//----- (0005B840) --------------------------------------------------------
int sub_5B840()
{
  sub_53E60((int)aDataPald0Dat_0, (char *)dword_EA3D8);
  return sub_53E60((int)aDataClrd0Dat_0, byte_E8900);
}
// EA3D8: using guessed type int dword_EA3D8;

//----- (0005B870) --------------------------------------------------------
int __cdecl sub_5B870(_BYTE *a1, int a2, int a3)
{
  int result; // eax
  _DWORD *v6; // ebx
  _BYTE *v7; // ebx

  for ( result = 0; (_WORD)--a3 != 0xFFFF; ++result )
  {
    v6 = (_DWORD *)(a2 + 4 * result);
    *v6 = a1;
    do
      v7 = a1++;
    while ( *v7 );
  }
  return result;
}

//----- (0005B8D0) --------------------------------------------------------
char __usercall sub_5B8D0@<al>(__int16 a1@<fpstat>)
{
  int v1; // eax
  int v2; // ecx
  __int16 v3; // dx
  int v4; // ebx
  int v5; // eax

  sub_70890();
  if ( (*(_BYTE *)(dword_D41A4 + 25) & 8) != 0 )
    sub_5C490();
  if ( sub_53D10(*(_BYTE *)(dword_D41A4 + 182), aNetherw_2, aSave_0) != 3
    || sub_53D10(*(_BYTE *)(dword_D41A4 + 182), aNetherw_2, aCdata_0) != 3
    || sub_53D10(*(_BYTE *)(dword_D41A4 + 182), aNetherw_2, aClevels_0) != 3
    || sub_53D10(*(_BYTE *)(dword_D41A4 + 182), aNetherw_2, aSound_1) != 3
    || sub_53D10(*(_BYTE *)(dword_D41A4 + 182), aNetherw_2, aLanguage) != 3
    || sub_53D10(*(_BYTE *)(dword_D41A4 + 182), aNetherw_2, aShots) != 3 )
  {
    printf(aErrorCreatingS);
    goto LABEL_34;
  }
  sub_560D0();
  sub_5BCC0();
  if ( !(unsigned __int16)sub_5BF50() )
    goto LABEL_34;
  sub_5C1B0(a1);
  if ( !sub_54200() )
  {
    printf(aErrorCopyingDa);
    goto LABEL_34;
  }
  sub_71410();
  sub_6EB90((unsigned int **)&off_D918C);
  sub_6EB90((unsigned int **)&off_D91EC);
  sub_101C0();
  if ( (*(_BYTE *)(dword_D41A4 + 24) & 8) == 0 )
    sub_53E60((int)aDataSpellsDat, byte_DA818);
  v1 = sub_5C0A0();
  if ( byte_D4B80 )
LABEL_34:
    exit(-1);
  byte_D4B80 = 1;
  if ( (word_180660 & 1) != 0 )
    sub_72883(v1, (void *)dword_180628, 0xC8u, 0);
  else
    sub_728A9(v1, (void *)dword_180628, 0x1E0u, 0);
  sub_90B27(0, 0x10u, 0);
  v2 = dword_EA3D8;
  memset(dword_EA3D8, 0, 768);
  sub_41A90((unsigned __int8 *)dword_EA3D8);
  v3 = *(_WORD *)(dword_D41A4 + 22);
  if ( (v3 & 0x110) != 0 )
  {
    if ( (word_180660 & 1) != 0 )
      sub_90D6E((unsigned __int8 *)dword_EA3D8);
    else
      sub_90E07((unsigned __int8 *)dword_EA3D8);
    v3 = dword_EA3D8;
    memset(dword_EA3D8, 0, 768);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
  }
  else
  {
    sub_90B27(0, 0x10u, 0);
    if ( (word_180660 & 1) != 0 )
    {
      v2 = dword_180628;
      sub_90D6E((unsigned __int8 *)dword_180628);
    }
    else
    {
      sub_90E07((unsigned __int8 *)dword_180628);
    }
    memset(dword_EA3D8, 0, 768);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
  }
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 8) != 0 )
    sub_8C2CD();
  else
    sub_753D0(dword_D41A4, v3);
  byte_E3799 = byte_E3798;
  byte_E37FD = byte_E37FC;
  sub_8CEDF();
  if ( !dword_E3768 )
  {
    sub_5BC20();
    printf(aErrorMouseDriv);
    exit(-1);
  }
  v4 = dword_EB394;
  sub_8CD27(dword_EB394);
  v5 = sub_5C430();
  return sub_46DD0(v5, v3, v4, v2);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// D4B80: using guessed type char byte_D4B80;
// D918C: using guessed type int *off_D918C;
// D91EC: using guessed type int *off_D91EC;
// E3768: using guessed type int dword_E3768;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// EA3D8: using guessed type int dword_EA3D8;
// EB394: using guessed type int dword_EB394;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0005BC20) --------------------------------------------------------
char sub_5BC20()
{
  if ( byte_D4B80 == 1 )
  {
    sub_5C450();
    if ( dword_E3768 )
      sub_54600();
    if ( (*(_BYTE *)(dword_D41A4 + 22) & 8) != 0 )
      sub_8C2DE();
    else
      sub_75420();
    sub_46F50();
    sub_8C21F();
    sub_72D04();
    sub_6FE20();
    sub_5C060();
  }
  sub_83E80(dword_D4198);
  sub_83E80(dword_D41A0);
  sub_83E80(dword_D41A4);
  sub_86860(word_1803EC);
  return sub_86BD0();
}
// D4198: using guessed type int dword_D4198;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D4B80: using guessed type char byte_D4B80;
// E3768: using guessed type int dword_E3768;
// 1803EC: using guessed type __int16 word_1803EC;

//----- (0005BCC0) --------------------------------------------------------
int sub_5BCC0()
{
  int result; // eax

  byte_EB39E = 72;
  byte_EB39F = 80;
  byte_EB3A1 = 77;
  byte_EB3A5 = 54;
  byte_EB3A6 = 54;
  result = dword_D41A4;
  byte_EB3A3 = 29;
  *(_WORD *)(dword_D41A4 + 4) = 0;
  *(_WORD *)(result + 6) = 127;
  *(_WORD *)(result + 8) = 127;
  byte_EB3A0 = 75;
  *(_BYTE *)(result + 10) = 1;
  byte_EB3A2 = 28;
  *(_BYTE *)(result + 11) = 0;
  byte_EB3A4 = 56;
  *(_BYTE *)(result + 12) = 0;
  byte_EB3A7 = 56;
  *(_BYTE *)(result + 13) = 0;
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// EB39E: using guessed type char byte_EB39E;
// EB39F: using guessed type char byte_EB39F;
// EB3A0: using guessed type char byte_EB3A0;
// EB3A1: using guessed type char byte_EB3A1;
// EB3A2: using guessed type char byte_EB3A2;
// EB3A3: using guessed type char byte_EB3A3;
// EB3A4: using guessed type char byte_EB3A4;
// EB3A5: using guessed type char byte_EB3A5;
// EB3A6: using guessed type char byte_EB3A6;
// EB3A7: using guessed type char byte_EB3A7;

//----- (0005BDC0) --------------------------------------------------------
int __cdecl sub_5BDC0(__int16 a1, __int16 a2)
{
  __int16 v2; // bx
  __int16 v3; // si
  int v4; // ecx
  int v5; // edx
  int result; // eax
  int v7[7]; // [esp+0h] [ebp-1Ch] BYREF

  v2 = a1;
  v3 = a2;
  memset(v7, 0, sizeof(v7));
  if ( a1 < 0 )
    v2 = 0;
  if ( a2 < 0 )
    v3 = 0;
  _disable();
  v4 = dword_E36C4;
  word_E375C = v2;
  word_E3760 = v2;
  word_E375E = v3;
  word_E3762 = v3;
  dword_1805B8 = v2;
  dword_1805B0 = v2;
  v7[0] = 4;
  dword_1805BC = v3;
  dword_1805B4 = v3;
  if ( dword_E36C4 )
  {
    v5 = dword_1805B0;
    *(_DWORD *)(dword_E36C4 + 40) = v3;
    *(_DWORD *)(v4 + 36) = v5;
  }
  if ( (word_180660 & 8) != 0 )
  {
    v2 *= 8;
    v3 *= 8;
  }
  v7[2] = v2;
  v7[3] = v3;
  result = int386(51, v7, v7);
  _enable();
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E36C4: using guessed type int dword_E36C4;
// E375C: using guessed type __int16 word_E375C;
// E375E: using guessed type __int16 word_E375E;
// E3760: using guessed type __int16 word_E3760;
// E3762: using guessed type __int16 word_E3762;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805B8: using guessed type int dword_1805B8;
// 1805BC: using guessed type int dword_1805BC;
// 180660: using guessed type __int16 word_180660;

//----- (0005BE80) --------------------------------------------------------
char __cdecl sub_5BE80(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  int v5; // edx
  int v6; // ecx
  unsigned int i; // edx
  int v8; // esi
  int v9; // esi
  int v10; // edi
  unsigned int v12; // [esp+0h] [ebp-8h]
  char v13; // [esp+4h] [ebp-4h]

  if ( (word_180660 & 6) != 0 )
    v5 = 16;
  else
    v5 = 256;
  v6 = 9999;
  v12 = v5;
  for ( i = 0; i < v12; ++i )
  {
    v8 = a3 - a1[1];
    v9 = (a2 - *a1) * (a2 - *a1) + v8 * v8;
    v10 = a4 - a1[2];
    if ( v9 + v10 * v10 < v6 )
    {
      v6 = v9 + v10 * v10;
      v13 = i;
    }
    a1 += 3;
  }
  return v13;
}
// 5BEB0: conditional instruction was optimized away because %var_8.4 is in (==10|==100)
// 5BEFF: variable 'v13' is possibly undefined
// 180660: using guessed type __int16 word_180660;

//----- (0005BF10) --------------------------------------------------------
char sub_5BF10()
{
  char result; // al

  if ( byte_E3799 )
    sub_8D8F0();
  if ( byte_E37FD )
    sub_8E020();
  result = 0;
  byte_E37FD = 0;
  byte_E3799 = 0;
  return result;
}
// E3799: using guessed type char byte_E3799;
// E37FD: using guessed type char byte_E37FD;

//----- (0005BF50) --------------------------------------------------------
int sub_5BF50()
{
  int v1; // eax
  int v2; // eax
  int v3; // eax

  dword_181C40 = sub_83D70(256);
  if ( dword_181C40 )
  {
    if ( sub_5C380(257) )
      byte_D41B4 = 1;
    else
      printf(aNoVesaDriverDe);
    LOWORD(v1) = sub_84250((int)aSearchd);
    if ( v1 )
    {
      printf(aNotEnoughMemor);
      sub_90D3F((int)aSearchd);
      return 0;
    }
    else
    {
      LOWORD(v2) = sub_84250((int)aDataBuild00Dat);
      if ( v2 )
      {
        printf(aNotEnoughMemor);
        sub_90D3F((int)aSearchd);
        sub_90D3F((int)aDataBuild00Dat);
        return 0;
      }
      else
      {
        sub_539A0();
        LOWORD(v3) = sub_84250((int)aWscreen);
        if ( v3 )
        {
          sub_90D3F((int)aWscreen);
          printf(aNotEnoughMemor);
          return 0;
        }
        else
        {
          word_180660 = 1;
          sub_83B50();
          return 1;
        }
      }
    }
  }
  else
  {
    printf(aNoVesaDriverDe);
    return 0;
  }
}
// 5BFB2: variable 'v1' is possibly undefined
// 5BFE1: variable 'v2' is possibly undefined
// 5C022: variable 'v3' is possibly undefined
// D41B4: using guessed type char byte_D41B4;
// 180660: using guessed type __int16 word_180660;
// 181C40: using guessed type int dword_181C40;

//----- (0005C060) --------------------------------------------------------
int sub_5C060()
{
  sub_90D3F((int)aSearchd);
  sub_90D3F((int)aDataBuild00Dat);
  sub_90D3F((int)aWscreen);
  return 1;
}

//----- (0005C0A0) --------------------------------------------------------
int sub_5C0A0()
{
  char *v0; // ebx
  unsigned int i; // ecx
  char v2; // dl
  char v3; // ah
  char v4; // dh
  int result; // eax

  v0 = byte_DA818;
  for ( i = 0; (int)i < 26; ++i )
  {
    while ( 1 )
    {
      v2 = v0[53];
      v0[1] = 0;
      v3 = v0[27];
      v0[53] = v2 & 0xFE;
      v4 = v0[79];
      v0[27] = v3 & 0xFE;
      v0[79] = v4 & 0xFE;
      if ( i < 7 )
      {
        if ( i < 3 )
        {
          if ( !i )
            v0[53] |= 1u;
        }
        else if ( i <= 4 || i == 6 )
        {
          goto LABEL_18;
        }
      }
      else
      {
        if ( i <= 7 )
        {
          v0[27] |= 1u;
          goto LABEL_22;
        }
        if ( i < 0xB )
        {
          if ( i != 8 )
            goto LABEL_22;
LABEL_18:
          v0[1] |= 4u;
          goto LABEL_22;
        }
        if ( i <= 0xC )
          goto LABEL_18;
        if ( i >= 0xE )
        {
          if ( i <= 0xE )
            goto LABEL_18;
          if ( i == 23 )
          {
            *(_DWORD *)(v0 + 10) = 50000;
            *((_DWORD *)v0 + 9) = 70000;
            *(_DWORD *)(v0 + 62) = 90000;
          }
        }
      }
LABEL_22:
      result = 1000 / *(_DWORD *)(v0 + 58);
      if ( *(int *)(v0 + 62) <= 0 && result > 0 )
      {
        v0[1] |= 0x20u;
        goto LABEL_30;
      }
      if ( *((int *)v0 + 9) > 0 || 1000 / *((_DWORD *)v0 + 8) <= 0 )
        break;
      v0[1] |= 0x10u;
      ++i;
      v0 += 80;
      if ( (int)i >= 26 )
        return result;
    }
    v0[1] |= 8u;
LABEL_30:
    v0 += 80;
  }
  return result;
}

//----- (0005C1B0) --------------------------------------------------------
int __usercall sub_5C1B0@<eax>(__int16 a1@<fpstat>)
{
  _BYTE *v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // edi
  char v6; // dl
  unsigned __int16 v7; // dx
  unsigned __int16 v8; // bx

  sub_5C330();
  v1 = (_BYTE *)dword_D41A0;
  *(_BYTE *)(dword_D41A0 + 8618) = 1;
  v1[8619] = 1;
  v1[8620] = 1;
  v1[8621] = 1;
  v1[8622] = 1;
  v1[8623] = 1;
  v1[8624] = 1;
  v1[8625] = 0;
  v1[8626] = 1;
  v1[8627] = 1;
  v1[8628] = 1;
  v1[8630] = 1;
  v1[8631] = 1;
  v1[8632] = 1;
  v1[8633] = 1;
  sub_84050(a1);
  v2 = dword_D41A0;
  if ( *(_BYTE *)(dword_D41A4 + 34) )
  {
    *(_BYTE *)(dword_D41A0 + 8586) = 1;
    *(_BYTE *)(v2 + 8588) = 1;
    *(_BYTE *)(v2 + 8598) = 1;
  }
  else
  {
    *(_BYTE *)(dword_D41A0 + 8586) = 0;
    *(_BYTE *)(v2 + 8588) = 0;
    *(_BYTE *)(v2 + 8598) = 0;
  }
  v3 = dword_D41A0;
  *(_BYTE *)(dword_D41A0 + 8587) = 1;
  *(_BYTE *)(v3 + 8591) = 1;
  *(_BYTE *)(v3 + 8590) = 1;
  *(_BYTE *)(v3 + 8589) = 40;
  *(_BYTE *)(v3 + 8599) = 0;
  *(_BYTE *)(v3 + 8600) = 0;
  *(_BYTE *)(v3 + 8601) = 0;
  *(_WORD *)(v3 + 14) = 2;
  v4 = dword_D41A4;
  v5 = dword_D41A4 + 145;
  *(_DWORD *)(dword_D41A4 + 145) = *(_DWORD *)aNetherw_3;
  *(_DWORD *)(v5 + 4) = *(_DWORD *)&aNetherw_3[4];
  *(_WORD *)(v4 + 184) = 256;
  v6 = byte_D0C18;
  *(_WORD *)(v4 + 218) = 25;
  *(_BYTE *)(v4 + 57) = v6;
  v7 = *(_WORD *)(v4 + 43);
  v8 = *(_WORD *)(v4 + 218);
  *(_DWORD *)(v4 + 30) = 0;
  if ( v7 >= v8 )
    *(_WORD *)(v4 + 43) = v8 - 1;
  sub_87090();
  if ( byte_180552 )
    *(_BYTE *)(dword_D41A4 + 10) = 1;
  sub_2CA90(*(char *)(dword_D41A0 + 8589));
  return 1;
}
// D0C18: using guessed type char byte_D0C18;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 180552: using guessed type char byte_180552;

//----- (0005C330) --------------------------------------------------------
void sub_5C330()
{
  int i; // edx
  int v1; // eax

  if ( dword_D41A0 )
  {
    for ( i = 0; i < 1001; dword_EA3E0[i] = dword_D41A0 + 28302 + v1 )
      v1 = 168 * i++;
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E0: using guessed type int dword_EA3E0[];

//----- (0005C380) --------------------------------------------------------
int __cdecl sub_5C380(__int16 a1)
{
  _WORD *i; // eax

  if ( !(unsigned __int16)sub_995B0() )
  {
    for ( i = (_WORD *)(*(unsigned __int16 *)(dword_181C40 + 14) + 16 * *(unsigned __int16 *)(dword_181C40 + 16));
          *i != 0xFFFF;
          ++i )
    {
      if ( a1 == *i )
        return 1;
    }
  }
  return 0;
}
// 181C40: using guessed type int dword_181C40;

//----- (0005C3D0) --------------------------------------------------------
int __cdecl sub_5C3D0(int a1, char *a2)
{
  char v3[8]; // [esp+0h] [ebp-8h] BYREF

  qmemcpy(v3, "RNC", 3);
  v3[3] = 1;
  v3[4] = 0;
  if ( strncmp(a1, v3, 4) )
    return 0;
  sub_9894C(a1, a2);
  return 1;
}
// 99682: using guessed type _DWORD __cdecl strncmp(_DWORD, _DWORD, _DWORD);

//----- (0005C430) --------------------------------------------------------
int sub_5C430()
{
  int result; // eax

  result = sub_74556();
  *(_WORD *)(dword_D41A4 + 216) = result;
  return result;
}
// D41A4: using guessed type int dword_D41A4;

//----- (0005C450) --------------------------------------------------------
void sub_5C450()
{
  if ( *(_WORD *)(dword_D41A4 + 216) )
    sub_72D04();
}
// D41A4: using guessed type int dword_D41A4;

//----- (0005C490) --------------------------------------------------------
int sub_5C490()
{
  int result; // eax
  int v1; // edx

  printf(&aTa[3]);
  printf(asc_D0C20);
  printf(aTestersWriteDo);
  printf(aPressReturnToC);
  printf(asc_D0CE0);
  do
  {
    if ( dword_E3BB0 <= 0 || (dword_E3BB8 & 4) != 0 || *(_BYTE *)dword_E3BAC == 13 || *(_BYTE *)dword_E3BAC == 26 )
    {
      result = fgetc(&dword_E3BAC);
      v1 = result;
    }
    else
    {
      result = dword_E3BAC + 1;
      dword_E3BAC = result;
      v1 = *(unsigned __int8 *)(result - 1);
      --dword_E3BB0;
    }
  }
  while ( v1 != 10 );
  return result;
}
// 996B7: using guessed type _DWORD __cdecl fgetc(_DWORD);
// E3BAC: using guessed type int dword_E3BAC;
// E3BB0: using guessed type int dword_E3BB0;
// E3BB8: using guessed type int dword_E3BB8;

//----- (0005C530) --------------------------------------------------------
int sub_5C530()
{
  int v0; // edx
  int v1; // ecx
  int v2; // ebx
  int i; // eax
  int v4; // esi
  int j; // eax
  int v6; // ecx
  int v7; // ecx
  int v8; // eax
  int v9; // esi
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax

  v0 = 0;
  v1 = 0;
  v2 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  for ( i = 0; i < 26; ++i )
  {
    v4 = *(_DWORD *)(v2 + 164);
    if ( *(_WORD *)(v4 + 2 * i + 819) || *(_BYTE *)(v4 + i + 1027) )
      *(_BYTE *)(*(_DWORD *)(v2 + 164) + i + 1001) = 1;
  }
  if ( (*(_BYTE *)(dword_D41A0 + 224779) & 1) != 0 )
    ++*(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12226);
  for ( j = 0; j < 26; ++j )
  {
    if ( *(_DWORD *)(4 * j + dword_D41A0 + 222422) )
    {
      ++v1;
      if ( *(_BYTE *)(*(_DWORD *)(v2 + 164) + j + 1027) )
        ++v0;
    }
  }
  if ( v1 )
    *(_DWORD *)(*(_DWORD *)(v2 + 164) + 377) = 100 * v0 / v1;
  else
    *(_DWORD *)(*(_DWORD *)(v2 + 164) + 377) = 100;
  if ( *(_DWORD *)(dword_D41A0 + 222418) )
    *(_DWORD *)(*(_DWORD *)(v2 + 164) + 373) = 100
                                             * *(_DWORD *)(*(_DWORD *)(v2 + 164) + 373)
                                             / *(_DWORD *)(dword_D41A0 + 222418);
  else
    *(_DWORD *)(*(_DWORD *)(v2 + 164) + 373) = 100;
  v6 = *(_DWORD *)(v2 + 164);
  if ( *(_DWORD *)(v6 + 357) )
    *(_DWORD *)(v6 + 381) = 100 * *(_DWORD *)(v6 + 361) / *(_DWORD *)(v6 + 357);
  else
    *(_DWORD *)(v6 + 381) = 100;
  v7 = *(_DWORD *)(v2 + 164);
  v8 = dword_EA3E4[*(unsigned __int16 *)(v7 + 58)];
  if ( v8 )
  {
    if ( *(_DWORD *)(dword_D41A4 + 246) - 1 <= 0 )
    {
      *(_DWORD *)(v7 + 385) = 100;
      goto LABEL_29;
    }
    v8 = 100 * (*(_DWORD *)(v7 + 316) + *(_DWORD *)(v8 + 144)) / (*(_DWORD *)(dword_D41A4 + 246) - 1);
  }
  *(_DWORD *)(v7 + 385) = v8;
LABEL_29:
  v9 = *(_DWORD *)(v2 + 164);
  *(_DWORD *)(v9 + 393) = (j___clock() - *(_DWORD *)(v9 + 393)) / 0x64u;
  v10 = *(_DWORD *)(v2 + 164);
  if ( *(int *)(v10 + 377) < 0 )
    *(_DWORD *)(v10 + 377) = 0;
  v11 = *(_DWORD *)(v2 + 164);
  if ( *(int *)(v11 + 377) > 100 )
    *(_DWORD *)(v11 + 377) = 100;
  v12 = *(_DWORD *)(v2 + 164);
  if ( *(int *)(v12 + 373) < 0 )
    *(_DWORD *)(v12 + 373) = 0;
  v13 = *(_DWORD *)(v2 + 164);
  if ( *(int *)(v13 + 373) > 100 )
    *(_DWORD *)(v13 + 373) = 100;
  v14 = *(_DWORD *)(v2 + 164);
  if ( *(int *)(v14 + 381) < 0 )
    *(_DWORD *)(v14 + 381) = 0;
  v15 = *(_DWORD *)(v2 + 164);
  if ( *(int *)(v15 + 381) > 100 )
    *(_DWORD *)(v15 + 381) = 100;
  v16 = *(_DWORD *)(v2 + 164);
  if ( *(int *)(v16 + 385) < 0 )
    *(_DWORD *)(v16 + 385) = 0;
  v17 = *(_DWORD *)(v2 + 164);
  if ( *(int *)(v17 + 385) > 100 )
    *(_DWORD *)(v17 + 385) = 100;
  return sub_82AB0(*(_BYTE *)(dword_D41A4 + 43));
}
// 98786: using guessed type int j___clock(void);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005C800) --------------------------------------------------------
__int16 __cdecl sub_5C800(int a1, char a2)
{
  __int16 result; // ax

  result = *(_WORD *)(dword_D41A0 + 12);
  if ( result == *(_WORD *)(*(_DWORD *)(a1 + 164) + 56) )
  {
    result = dword_D41A4;
    *(_BYTE *)(dword_D41A4 + 180) = a2;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (0005C830) --------------------------------------------------------
__int16 __cdecl sub_5C830(int a1, char a2, __int16 a3)
{
  int v3; // eax

  LOWORD(v3) = *(_WORD *)(dword_D41A0 + 12);
  if ( (_WORD)v3 == *(_WORD *)(*(_DWORD *)(a1 + 164) + 56) )
  {
    v3 = dword_D41A4;
    *(_BYTE *)(dword_D41A4 + 180) = a2;
    *(_WORD *)(v3 + 184) = a3;
  }
  return v3;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (0005C870) --------------------------------------------------------
signed int __cdecl sub_5C870(int a1)
{
  int v1; // ebx
  int v2; // esi
  signed int result; // eax

  v1 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v2 = *(_DWORD *)(v1 + 164);
  result = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
  if ( result <= *(_DWORD *)(v2 + 410) )
    *(_DWORD *)(*(_DWORD *)(v1 + 164) + 410) = result;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005C8D0) --------------------------------------------------------
signed int __cdecl sub_5C8D0(int a1)
{
  int v1; // ebx
  int v2; // esi
  signed int result; // eax

  v1 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v2 = *(_DWORD *)(v1 + 164);
  result = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
  if ( result <= *(_DWORD *)(v2 + 414) )
    *(_DWORD *)(*(_DWORD *)(v1 + 164) + 414) = result;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005C950) --------------------------------------------------------
int __usercall sub_5C950@<eax>(__int16 a1@<ax>, int a2, int a3)
{
  int v3; // ebx
  int v4; // edx
  __int16 v5; // ax
  int v6; // eax
  unsigned __int16 v7; // dx
  int v8; // esi
  int v9; // ecx
  int v10; // edi
  int i; // eax
  int v12; // eax
  int v13; // edx
  __int16 v14; // cx
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // edi
  int v19; // esi
  int v20; // eax
  __int16 v21; // dx
  int v22; // edi
  int v23; // eax
  _WORD *v24; // edx
  int v25; // eax
  int v26; // esi
  int v27; // eax
  int v28; // eax
  int v29; // edx
  unsigned int k; // eax
  int m; // eax
  int result; // eax
  char v33; // [esp-4h] [ebp-18h]
  int v34; // [esp-4h] [ebp-18h]
  int v35; // [esp+0h] [ebp-14h] BYREF
  __int16 v36; // [esp+4h] [ebp-10h]
  int v37; // [esp+8h] [ebp-Ch]
  int j; // [esp+Ch] [ebp-8h]
  int v39; // [esp+10h] [ebp-4h]

  v3 = a3;
  v37 = 0;
  sub_49F90(a1);
  v4 = (a2 - (dword_D41A0 + 11230)) / 2124;
  v35 = *(_DWORD *)(dword_D41A0 + 6 * v4 + 9058);
  v36 = *(_WORD *)(dword_D41A0 + 6 * v4 + 9062);
  v5 = sub_10C40((__int16 *)&v35);
  ++HIBYTE(v5);
  v36 = v5;
  if ( a3 == dword_EA3E4[0] )
  {
    v3 = sub_4A190((int)&v35, 3, *(_BYTE *)(a2 + 9) == 1);
    v37 = 1;
  }
  else
  {
    *(_BYTE *)(a3 + 69) = *(_BYTE *)(a2 + 9) == 1;
    v6 = *(_DWORD *)(a3 + 164);
    *(_BYTE *)(a3 + 12) &= ~0x20u;
    v7 = *(_WORD *)(v6 + 58);
    if ( v7 )
    {
      v8 = dword_EA3E4[v7] + 76;
      v35 = *(_DWORD *)v8;
      v36 = *(_WORD *)(v8 + 4);
    }
    sub_57CF0((__int16)&v35, a3, (int)&v35);
  }
  v9 = dword_D41A0;
  *(_WORD *)(a2 + 10) = (v3 - (dword_D41A0 + 28302)) / 168;
  *(_DWORD *)(v3 + 164) = a2 + 998;
  *(_WORD *)(*(_DWORD *)(v3 + 164) + 56) = (a2 - (v9 + 11230)) / 2124;
  *(_WORD *)(*(_DWORD *)(v3 + 164) + 345) = 100;
  *(_WORD *)(*(_DWORD *)(v3 + 164) + 588) = 0;
  *(_DWORD *)(*(_DWORD *)(v3 + 164) + 365) = 2000;
  *(_WORD *)(*(_DWORD *)(v3 + 164) + 12) = 0;
  *(_WORD *)(*(_DWORD *)(v3 + 164) + 32) = 0;
  *(_WORD *)(*(_DWORD *)(v3 + 164) + 34) = 0;
  *(_WORD *)(*(_DWORD *)(v3 + 164) + 30) = 0;
  *(_WORD *)(*(_DWORD *)(v3 + 164) + 16) = 0;
  memset(*(_DWORD *)(v3 + 164) + 428, 0, 18);
  *(_WORD *)(*(_DWORD *)(v3 + 164) + 586) = 256;
  v33 = v37;
  *(_DWORD *)(v3 + 140) = 1000;
  v10 = v37;
  *(_DWORD *)(v3 + 4) = 10000;
  sub_5CF40(v3, v33);
  if ( v10 )
  {
    sub_58DA0(0, v3);
    for ( i = 0; i < 26; *(_DWORD *)(*(_DWORD *)(v3 + 164) + 4 * i + 711) = 0 )
      ++i;
    *(_DWORD *)(*(_DWORD *)(v3 + 164) + 393) = j___clock();
    switch ( sub_616D0(*(__int16 *)(*(_DWORD *)(v3 + 164) + 56)) )
    {
      case 0:
        sub_49CD0((_WORD *)v3, 44);
        break;
      case 1:
        sub_49CD0((_WORD *)v3, 273);
        break;
      case 2:
        sub_49CD0((_WORD *)v3, 274);
        break;
      case 3:
        sub_49CD0((_WORD *)v3, 275);
        break;
      case 4:
        sub_49CD0((_WORD *)v3, 276);
        break;
      case 5:
        sub_49CD0((_WORD *)v3, 277);
        break;
      case 6:
        sub_49CD0((_WORD *)v3, 278);
        break;
      case 7:
        sub_49CD0((_WORD *)v3, 279);
        break;
      default:
        break;
    }
    if ( *(_BYTE *)(a2 + 9) == 1 )
    {
      v12 = dword_D41A0;
      *(_WORD *)(*(_DWORD *)(v3 + 164) + 578) = *(_WORD *)(110 * *(__int16 *)(*(_DWORD *)(v3 + 164) + 56)
                                                         + dword_D41A0
                                                         + 221397);
      *(_WORD *)(*(_DWORD *)(v3 + 164) + 580) = *(_WORD *)(110 * *(__int16 *)(*(_DWORD *)(v3 + 164) + 56) + v12 + 221405);
      *(_WORD *)(*(_DWORD *)(v3 + 164) + 582) = *(_WORD *)(110 * *(__int16 *)(*(_DWORD *)(v3 + 164) + 56) + v12 + 221401);
      v13 = *(_DWORD *)(v3 + 164);
      v14 = *(_WORD *)(110 * *(__int16 *)(v13 + 56) + v12 + 221487);
      if ( v14 )
      {
        *(_WORD *)(v13 + 586) = v14;
        *(_DWORD *)(v3 + 4) = (*(_DWORD *)(v3 + 4) * *(__int16 *)(*(_DWORD *)(v3 + 164) + 586)) >> 8;
      }
      v15 = *(_DWORD *)(v3 + 164);
      if ( *(_WORD *)(v15 + 823) )
      {
        if ( *(_BYTE *)(dword_D41A0 + *(__int16 *)(v15 + 56) + 196313) )
        {
          v16 = sub_4A190(v3 + 76, 3, 2);
          v39 = v16;
          if ( v16 )
          {
            v17 = dword_D41A0 + 28302;
            *(_WORD *)(v16 + 26) = *(_WORD *)(v3 + 26);
            *(_WORD *)(*(_DWORD *)(v3 + 164) + 58) = (v16 - v17) / 168;
            sub_6E450((v3 - v17) / 168, -1, 30);
            for ( j = 0; ; j = v22 + 1 )
            {
              v23 = *(unsigned __int8 *)(dword_D41A0 + *(__int16 *)(*(_DWORD *)(v3 + 164) + 56) + 196313);
              if ( v23 <= j )
                break;
              v18 = dword_EA3E4[0] + 76;
              v19 = v39 + 154;
              *(_DWORD *)(dword_EA3E4[0] + 76) = *(_DWORD *)(v39 + 154);
              *(_WORD *)(v18 + 4) = *(_WORD *)(v19 + 4);
              v20 = dword_EA3E4[0];
              v21 = *(_WORD *)(v39 + 26);
              *(_BYTE *)(dword_EA3E4[0] + 64) = 0;
              v22 = j;
              *(_DWORD *)(v20 + 16) = 0;
              *(_WORD *)(v20 + 26) = v21;
              *(_BYTE *)(v20 + 70) = j;
              sub_36FC0(v20);
            }
            v24 = (_WORD *)v39;
            *(_DWORD *)(v39 + 16) = v23 - 1;
            sub_49EC0(v24, v24[8]);
            v25 = v39;
            v34 = v39;
            *(_WORD *)(v39 + 82) = -8192;
            v26 = v25;
            *(_WORD *)(v25 + 88) = 0x4000;
            sub_60810(v34);
            v27 = *(_DWORD *)(v26 + 140);
            *(_DWORD *)(v26 + 144) = v27;
            if ( v27 < 0 )
              *(_DWORD *)(v26 + 144) = 0;
            if ( *(int *)(v39 + 144) > 320000 )
              *(_DWORD *)(v39 + 144) = 320000;
          }
        }
      }
    }
    *(_DWORD *)(*(_DWORD *)(v3 + 164) + 373) = 0;
  }
  if ( *(_WORD *)(dword_D41A0 + 12) == *(_WORD *)(*(_DWORD *)(v3 + 164) + 56) )
    *(_BYTE *)(v3 + 12) |= 1u;
  *(_DWORD *)(v3 + 8) = *(_DWORD *)(v3 + 4);
  v28 = *(_DWORD *)(v3 + 140);
  v29 = *(_DWORD *)(v3 + 164);
  *(_DWORD *)(v3 + 144) = v28;
  *(_DWORD *)(v29 + 336) = v28;
  for ( k = *(_DWORD *)(dword_D41A4 + 38519); k > dword_EA3E4[0]; k = *(_DWORD *)k )
  {
    if ( *(_WORD *)(k + 26) != *(_WORD *)(v3 + 26) && *(_BYTE *)(k + 64) <= 1u )
      *(_WORD *)(*(_DWORD *)(k + 164) + 8 * *(__int16 *)(*(_DWORD *)(v3 + 164) + 56) + 516) = -24609;
  }
  *(_WORD *)(*(_DWORD *)(v3 + 164) + 326) = 0;
  *(_WORD *)(*(_DWORD *)(v3 + 164) + 328) = 0;
  if ( *(_BYTE *)(v3 + 64) == 1 )
  {
    memset(*(_DWORD *)(v3 + 164) + 449, 0, 1);
    for ( m = 0; m < 8; *(_WORD *)(*(_DWORD *)(v3 + 164) + 8 * m + 508) = 24607 )
      ++m;
    *(_WORD *)(*(_DWORD *)(v3 + 164) + 875) = 4 * *(_WORD *)(*(_DWORD *)(v3 + 164) + 56);
  }
  *(_DWORD *)(*(_DWORD *)(v3 + 164) + 410) = 2048;
  *(_DWORD *)(*(_DWORD *)(v3 + 164) + 414) = 2048;
  *(_WORD *)(*(_DWORD *)(v3 + 164) + 54) = 0;
  memset(*(_DWORD *)(v3 + 164) + 347, 16, 8);
  result = dword_D41A0;
  *(_DWORD *)(dword_D41A0 + 4582) = -1;
  if ( *(_WORD *)(*(_DWORD *)(v3 + 164) + 56) == *(_WORD *)(result + 12) )
  {
    result = dword_D41A4;
    *(_BYTE *)(dword_D41A4 + 178) = 0;
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type int j___clock(void);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005CF40) --------------------------------------------------------
_WORD *__cdecl sub_5CF40(int a1, char a2)
{
  int i; // esi
  int v3; // edi
  int v4; // eax
  int j; // edx
  int v6; // esi
  int v7; // eax
  __int16 v8; // cx
  int v10; // [esp+0h] [ebp-8h]

  for ( i = 0; i < 26; ++i )
  {
    v3 = 2 * i;
    if ( *(_WORD *)(2 * i + *(_DWORD *)(a1 + 164) + 819) )
    {
      v4 = sub_4A190(a1 + 76, 15, i);
      if ( v4 )
      {
        v10 = dword_D41A0 + 28302;
        *(_WORD *)(*(_DWORD *)(a1 + 164) + v3 + 819) = (v4 - (dword_D41A0 + 28302)) / 168;
        *(_WORD *)(v4 + 40) = (a1 - v10) / 168;
        *(_BYTE *)(v4 + 12) |= 1u;
      }
      else
      {
        *(_WORD *)(v3 + *(_DWORD *)(a1 + 164) + 819) = 0;
      }
    }
  }
  if ( a2 )
  {
    for ( j = 0; j < 26; *(_BYTE *)(j + *(_DWORD *)(a1 + 164) + 1078) = 0 )
      ++j;
  }
  v6 = 0;
  sub_6DB50(0, 0);
  while ( v6 < 26 )
  {
    v7 = *(_DWORD *)(a1 + 164);
    v8 = *(_WORD *)(v7 + 2 * v6 + 819);
    if ( v8 )
      sub_6D5E0(dword_EA3E4[v8], *(_BYTE *)(v6 + v7 + 1079));
    ++v6;
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1109) = *(_BYTE *)(*(_DWORD *)(a1 + 164)
                                                      + *(__int16 *)(*(_DWORD *)(a1 + 164) + 1105)
                                                      + 1079);
  *(_BYTE *)(*(_DWORD *)(a1 + 164) + 1110) = *(_BYTE *)(*(_DWORD *)(a1 + 164)
                                                      + *(__int16 *)(*(_DWORD *)(a1 + 164) + 1107)
                                                      + 1079);
  return sub_574A0();
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005D0A0) --------------------------------------------------------
int __cdecl sub_5D0A0(int a1)
{
  unsigned __int16 v1; // di
  int v2; // eax
  int v3; // eax
  unsigned __int16 v4; // si
  unsigned __int16 v5; // ax
  unsigned __int16 v6; // ax
  int v7; // esi
  int v8; // esi
  __int16 v9; // ax
  int v10; // eax
  int v11; // edx
  int v12; // edx
  __int16 v13; // si
  __int16 v14; // ax
  int v15; // edi
  __int16 v16; // ax
  int v17; // esi
  int v18; // eax
  int *v19; // esi
  char v20; // ch
  int v21; // edx
  int v22; // eax
  int v23; // eax
  __int16 v24; // ax
  __int16 v25; // dx
  int v27; // [esp+0h] [ebp-60h] BYREF
  __int16 v28; // [esp+4h] [ebp-5Ch]
  int v29; // [esp+8h] [ebp-58h]
  __int16 v30; // [esp+Ch] [ebp-54h]
  int v31; // [esp+10h] [ebp-50h] BYREF
  __int16 v32; // [esp+14h] [ebp-4Ch]
  int v33; // [esp+18h] [ebp-48h] BYREF
  __int16 v34; // [esp+1Ch] [ebp-44h]
  int v35; // [esp+20h] [ebp-40h]
  int v36; // [esp+24h] [ebp-3Ch]
  int v37; // [esp+28h] [ebp-38h]
  int v38; // [esp+2Ch] [ebp-34h]
  int v39; // [esp+30h] [ebp-30h]
  int i; // [esp+34h] [ebp-2Ch]
  int v41; // [esp+38h] [ebp-28h]
  unsigned int v42; // [esp+3Ch] [ebp-24h]
  int v43; // [esp+40h] [ebp-20h]
  int v44; // [esp+44h] [ebp-1Ch]
  int v45; // [esp+48h] [ebp-18h]
  int v46; // [esp+4Ch] [ebp-14h]
  unsigned __int16 v47; // [esp+50h] [ebp-10h]
  int v48; // [esp+54h] [ebp-Ch]
  int v49; // [esp+58h] [ebp-8h]
  char v50; // [esp+5Ch] [ebp-4h]

  v46 = 1;
  if ( sub_104D0(&word_EB398) == 256 )
  {
    ++*(_BYTE *)(*(_DWORD *)(a1 + 164) + 610);
    v1 = sub_581E0((_WORD *)(a1 + 76), &word_EB398);
    LOWORD(v2) = sub_58210((_WORD *)(a1 + 76), &word_EB398);
    v45 = v2;
    v42 = sub_583F0((_WORD *)(a1 + 76), &word_EB398);
    v41 = v1;
    v3 = (int)v1 >> 9;
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v4 = (_WORD)v3 << 9;
    v49 = (((_WORD)v3 + 1) << 9) & 0x7FF;
    v5 = sub_582B0(v41, (_WORD)v3 << 9);
    v36 = (unsigned __int16)v42;
    v35 = (unsigned __int16)v45;
    sub_57FA0(
      &word_EB398,
      v4,
      v45,
      ((unsigned __int16)v42 * (512 - v5)
     - (__CFSHL__(((unsigned __int16)v42 * (512 - v5)) >> 31, 9)
      + (((unsigned __int16)v42 * (512 - v5)) >> 31 << 9))) >> 9);
    if ( sub_104D0(&word_EB398) == 256 )
    {
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      v6 = sub_582B0(v41, v49);
      sub_57FA0(
        &word_EB398,
        v49,
        v35,
        (v36 * (512 - v6) - (__CFSHL__((v36 * (512 - v6)) >> 31, 9) + ((v36 * (512 - v6)) >> 31 << 9))) >> 9);
      if ( sub_104D0(&word_EB398) == 256 )
        v46 = 0;
    }
  }
  if ( !byte_D41B6 )
    return v46;
  v31 = *(_DWORD *)&word_EB398;
  v32 = *(&word_EB398 + 2);
  v7 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 12);
  v8 = v7 + (__int16)sub_10C40((__int16 *)&v31) + *(__int16 *)(a1 + 88);
  v9 = sub_10C60((__int16 *)&v31);
  LOBYTE(v47) = BYTE1(v31);
  HIBYTE(v47) = HIBYTE(v31);
  if ( v8 < v9 - 576 && (byte_13B4E0[v47] & 8) == 0 )
    goto LABEL_30;
  v48 = 0;
  LOWORD(v10) = sub_581E0((_WORD *)(a1 + 76), &v31);
  v11 = v10 - 512;
  v50 = 0;
  BYTE1(v11) = ((unsigned __int16)(v10 - 512) >> 8) & 7;
  BYTE1(v10) = (BYTE1(v10) + 2) & 7;
  v43 = v11;
  v44 = v10;
  v12 = 16;
  for ( i = 0; ; ++i )
  {
    v39 = v12;
    if ( i >= 6 || v50 )
      break;
    v33 = v31;
    v34 = v32;
    v27 = v31;
    v28 = v32;
    v13 = v39;
    v37 = (unsigned __int16)v48;
    sub_57FA0(&v33, v43, v48, v39);
    v38 = (__int16)sub_10C60((__int16 *)&v33);
    v14 = sub_10C40((__int16 *)&v33);
    v15 = v38 - v14;
    sub_57FA0(&v27, v44, v37, v13);
    v38 = (__int16)sub_10C60((__int16 *)&v27);
    v16 = sub_10C40((__int16 *)&v27);
    v17 = v38 - v16;
    LOBYTE(v47) = BYTE1(v33);
    HIBYTE(v47) = HIBYTE(v33);
    v18 = (__int16)v27 >> 8;
    BYTE1(v18) = HIBYTE(v27);
    if ( (byte_13B4E0[v47] & 8) == 0 || (byte_13B4E0[(unsigned __int16)v18] & 8) == 0 )
    {
      if ( v15 > v17 && (byte_13B4E0[v47] & 8) == 0 )
      {
        if ( sub_11E20(a1, (__int16 *)&v33) )
          goto LABEL_20;
        v19 = &v33;
        v50 = 1;
        goto LABEL_19;
      }
      if ( v17 > v15 && (byte_13B4E0[(unsigned __int16)v18] & 8) == 0 && !sub_11E20(a1, (__int16 *)&v27) )
      {
        v19 = &v27;
        v50 = 2;
LABEL_19:
        v29 = *v19;
        v30 = *((_WORD *)v19 + 2);
      }
    }
LABEL_20:
    v12 = 16 * (i + 1) + v39;
  }
  v20 = v50;
  if ( v50 )
  {
    v21 = i;
    v22 = 16 * i;
    *(_DWORD *)&word_EB398 = v29;
    *(&word_EB398 + 2) = v30;
    v23 = (v22 + v21) / 6;
    if ( v20 == 1 )
      v23 = -v23;
    v24 = *(_WORD *)(a1 + 28) + v23;
    HIBYTE(v24) &= 7u;
    *(_WORD *)(a1 + 28) = v24;
  }
  else if ( sub_11E20(a1, (__int16 *)&v31) )
  {
    v46 = 0;
  }
  else
  {
    *(_DWORD *)&word_EB398 = v31;
    *(&word_EB398 + 2) = v32;
  }
LABEL_30:
  if ( (_WORD)v46 )
  {
    LOBYTE(v47) = HIBYTE(word_EB398);
    HIBYTE(v47) = HIBYTE(word_EB39A);
    if ( (byte_13B4E0[v47] & 8) != 0 )
      v46 = 0;
  }
  if ( !(_WORD)v46 )
  {
    ++*(_BYTE *)(*(_DWORD *)(a1 + 164) + 610);
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) = 0;
    v25 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 825);
    if ( v25 )
      *(_WORD *)(dword_EA3E4[v25] + 46) = 0;
  }
  return v46;
}
// 5D107: variable 'v2' is possibly undefined
// 5D2A3: variable 'v10' is possibly undefined
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;

//----- (0005D530) --------------------------------------------------------
void __cdecl sub_5D530(int a1)
{
  char v1; // ah
  int v2; // ecx
  unsigned __int8 v3; // dh
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  int v8; // eax
  __int16 v9; // ax
  int v10; // ecx
  int v11; // edx
  __int16 v12; // ax
  int v13; // eax
  __int16 v14; // dx
  int v15; // eax
  unsigned __int8 v16; // cl
  int v17; // eax
  int v18; // eax
  int v19; // edx
  __int16 v20; // di
  int v21; // eax
  unsigned __int16 v22; // ax
  int v23; // eax
  __int16 v24; // dx
  int v25; // eax
  __int16 v26; // si
  _WORD *v27; // edx
  __int16 v28; // ax
  __int64 v29; // rax
  _WORD *v30; // edx
  __int16 v31; // si
  __int16 v32; // ax
  int v33; // edx
  char v34; // cl
  int v35; // edx
  char v36; // ah
  int v37; // eax
  char v38; // ch
  int v39; // edx
  char v40; // ch
  __int16 v41; // ax
  __int16 v42; // dx
  int v43; // ecx
  int v44; // eax
  unsigned int v45; // edx
  char v46; // al
  int v47; // ecx
  unsigned int v48; // eax
  __int16 v49; // si
  int v50; // edx
  __int16 v51; // ax
  __int16 v52; // [esp-4h] [ebp-4h]

  v1 = *(_BYTE *)(a1 + 13);
  if ( (v1 & 8) != 0 )
  {
    *(_BYTE *)(a1 + 13) = v1 & 0xF7;
    return;
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  v2 = *(_DWORD *)(a1 + 164);
  v3 = *(_BYTE *)(v2 + 332);
  if ( v3 )
  {
    v4 = *(__int16 *)(v2 + 4) * (4 - v3);
    *(_WORD *)(v2 + 341) += (v4 - (__CFSHL__(v4 >> 31, 2) + 4 * (v4 >> 31))) >> 2;
    v5 = *(_DWORD *)(a1 + 164);
    v6 = *(__int16 *)(v5 + 6) * (4 - *(unsigned __int8 *)(v5 + 332));
    *(_WORD *)(v5 + 343) += (v6 - (__CFSHL__(v6 >> 31, 2) + 4 * (v6 >> 31))) >> 2;
  }
  else
  {
    *(_WORD *)(v2 + 341) += *(_WORD *)(v2 + 4);
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 343) += *(_WORD *)(*(_DWORD *)(a1 + 164) + 6);
  }
  v7 = *(__int16 *)(*(_DWORD *)(a1 + 164) + 341);
  *(_WORD *)(a1 + 28) = (*(_WORD *)(a1 + 28) + ((v7 - (__CFSHL__(v7 >> 31, 3) + 8 * (v7 >> 31))) >> 3)) & 0x7FF;
  v8 = *(__int16 *)(*(_DWORD *)(a1 + 164) + 12) - *(__int16 *)(a1 + 130);
  if ( v8 )
  {
    if ( v8 <= 0 )
      LOWORD(v8) = -1;
    else
      LOWORD(v8) = 1;
  }
  *(_WORD *)(a1 + 130) += v8 * dword_D4B84;
  v9 = sub_10C40(&word_EB398);
  v10 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 10);
  v11 = ((word_EB39C - v9 - v10) << 10) / v10;
  if ( v11 < -256 )
    v11 = -256;
  if ( v11 > 256 )
    v11 = 256;
  v12 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 343);
  HIBYTE(v12) &= 7u;
  *(_WORD *)(a1 + 30) = v12;
  if ( v12 > 1024 )
    v12 -= 2048;
  if ( *(__int16 *)(a1 + 130) >= 0 || v12 <= 0 )
  {
    if ( *(__int16 *)(a1 + 130) < 0 && v12 < 0 )
      goto LABEL_26;
    if ( *(__int16 *)(a1 + 130) > 0 && v12 < 0 )
    {
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 36) = (v12 * -v11
                                              - (__CFSHL__((v12 * -v11) >> 31, 8)
                                               + ((v12 * -v11) >> 31 << 8))) >> 8;
      goto LABEL_27;
    }
    if ( *(__int16 *)(a1 + 130) > 0 && v12 > 0 )
LABEL_26:
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 36) = *(_WORD *)(*(_DWORD *)(a1 + 164) + 343);
  }
  else
  {
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 36) = (v12 * -v11 - (__CFSHL__((v12 * -v11) >> 31, 8) + ((v12 * -v11) >> 31 << 8))) >> 8;
  }
LABEL_27:
  v13 = *(_DWORD *)(a1 + 164);
  v14 = *(_WORD *)(v13 + 36);
  HIBYTE(v14) &= 7u;
  *(_WORD *)(v13 + 36) = v14;
  v15 = *(_DWORD *)(a1 + 164);
  v16 = *(_BYTE *)(v15 + 332);
  if ( v16 )
  {
    v17 = *(__int16 *)(a1 + 130) * (4 - v16);
    v18 = (v17 - (__CFSHL__(v17 >> 31, 2) + 4 * (v17 >> 31))) >> 2;
  }
  else if ( *(_BYTE *)(v15 + 334) )
  {
    LOWORD(v18) = 0;
  }
  else
  {
    LOWORD(v18) = *(_WORD *)(a1 + 130);
  }
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(*(_DWORD *)(a1 + 164) + 36), v18);
  v19 = *(_DWORD *)(a1 + 164);
  v20 = *(_WORD *)(v19 + 16);
  if ( v20 )
  {
    LOBYTE(v21) = *(_BYTE *)(v19 + 332);
    if ( (_BYTE)v21 )
    {
      v21 = ((4 - *(unsigned __int8 *)(v19 + 332)) * v20
           - (__CFSHL__(((4 - *(unsigned __int8 *)(v19 + 332)) * v20) >> 31, 2)
            + 4 * (((4 - *(unsigned __int8 *)(v19 + 332)) * v20) >> 31))) >> 2;
    }
    else if ( *(_BYTE *)(v19 + 334) )
    {
      BYTE1(v21) = 0;
    }
    else
    {
      LOWORD(v21) = *(_WORD *)(v19 + 16);
    }
    v52 = v21;
    v22 = *(_WORD *)(a1 + 28);
    HIBYTE(v22) += 2;
    sub_57FA0(&word_EB398, v22, 0, v52);
  }
  v23 = *(_DWORD *)(a1 + 164);
  v24 = *(_WORD *)(v23 + 30);
  if ( v24 )
  {
    if ( v24 > 128 )
      *(_WORD *)(v23 + 30) = 128;
    sub_57FA0(&word_EB398, *(_WORD *)(*(_DWORD *)(a1 + 164) + 32), 0, *(_WORD *)(*(_DWORD *)(a1 + 164) + 30));
    v25 = *(_DWORD *)(a1 + 164);
    v26 = *(_WORD *)(v25 + 30);
    v27 = (_WORD *)(v25 + 30);
    if ( v26 )
    {
      if ( v26 <= 0 )
        v28 = -1;
      else
        v28 = 1;
    }
    else
    {
      v28 = 0;
    }
    *v27 += v28 * dword_D4B90;
    v29 = *(__int16 *)(*(_DWORD *)(a1 + 164) + 30);
    if ( (int)((HIDWORD(v29) ^ v29) - HIDWORD(v29)) < 4 )
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 30) = 0;
  }
  v30 = *(_WORD **)(a1 + 164);
  v31 = v30[212] + word_EB39A;
  v32 = v30[213];
  word_EB398 += v30[211];
  word_EB39A = v31;
  word_EB39C += v32;
  v30[211] = 0;
  *(_WORD *)(*(_DWORD *)(a1 + 164) + 424) = 0;
  *(_WORD *)(*(_DWORD *)(a1 + 164) + 426) = 0;
  v33 = *(_DWORD *)(a1 + 164);
  v34 = *(_BYTE *)(v33 + 610);
  if ( v34 )
    *(_BYTE *)(v33 + 610) = v34 - 1;
  sub_5DE30(a1);
  v35 = *(_DWORD *)(a1 + 164);
  if ( *(_BYTE *)(v35 + 332) )
  {
    v36 = *(_BYTE *)(v35 + 333) - 1;
    *(_BYTE *)(v35 + 333) = v36;
    if ( !v36 )
    {
      v37 = *(_DWORD *)(a1 + 164);
      v38 = *(_BYTE *)(v37 + 332) - 1;
      *(_BYTE *)(v37 + 332) = v38;
      if ( v38 )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 164) + 333) = 8;
        *(_BYTE *)(dword_D41A4 + 181) = 1;
      }
      else
      {
        sub_5C800(a1, 1);
      }
    }
  }
  v39 = *(_DWORD *)(a1 + 164);
  if ( *(_BYTE *)(v39 + 334) )
  {
    v40 = *(_BYTE *)(v39 + 335) - 1;
    *(_BYTE *)(v39 + 335) = v40;
    if ( !v40 )
      --*(_BYTE *)(*(_DWORD *)(a1 + 164) + 334);
  }
  if ( (unsigned __int16)sub_5D0A0(a1) )
  {
    v41 = sub_10C40(&word_EB398);
    v42 = v41;
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 164) + 334) )
    {
      word_EB39C -= 51;
    }
    else
    {
      v43 = *(_DWORD *)(a1 + 160);
      if ( word_EB39C > *(__int16 *)(v43 + 12) + v41 )
        word_EB39C += *(_WORD *)(v43 + 14);
    }
    v44 = *(_DWORD *)(a1 + 160);
    if ( word_EB39C >= v42 + *(__int16 *)(v44 + 12) )
    {
      if ( byte_D41B6 )
      {
        LOWORD(v44) = sub_10C60(&word_EB398);
        if ( word_EB39C > (__int16)v44 - 384 )
        {
          LOWORD(v44) = v44 - 384;
          word_EB39C = v44;
        }
      }
    }
    else
    {
      LOWORD(v44) = *(_WORD *)(v44 + 12);
      word_EB39C = v44 + v42;
    }
    sub_57CF0(v44, a1, (int)&word_EB398);
  }
  else
  {
    sub_5DD50(a1);
  }
  if ( (*(_BYTE *)(a1 + 62) & 0x3F) == 0 )
  {
    v45 = dword_EA3E4[*(__int16 *)(*(_DWORD *)(a1 + 164) + 827)];
    if ( v45 > dword_EA3E4[0] )
    {
      if ( *(_WORD *)(v45 + 46) )
      {
        v46 = byte_DA972[26 * *(char *)(v45 + 70)];
        if ( (unsigned __int8)v46 < 0x10u )
        {
          if ( v46 == 2 )
            sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 12);
        }
        else if ( (unsigned __int8)v46 <= 0x10u )
        {
          sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 39);
        }
        else if ( (unsigned __int8)v46 >= 0x13u )
        {
          if ( (unsigned __int8)v46 <= 0x13u )
          {
            sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 43);
          }
          else if ( v46 == 25 )
          {
            sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 37);
          }
        }
      }
    }
  }
  v47 = dword_D41A0;
  if ( *(_BYTE *)(dword_D41A0 + 196308) == 2 )
  {
    v48 = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
    *(_DWORD *)(dword_D41A0 + 8) = v48;
    *(_DWORD *)(v47 + 8) += *(_DWORD *)(dword_D41A4 + 30);
    if ( (int)(v48 % 0x83) < 5 )
    {
      v49 = *(_WORD *)(v47 + 12);
      if ( v49 == *(_WORD *)(*(_DWORD *)(a1 + 164) + 56) )
        sub_6E450(0, v49, v48 % 0x83 + 65);
    }
  }
  else if ( sub_104D0((__int16 *)(a1 + 76)) == 1 )
  {
    sub_6E450(0, *(_WORD *)(dword_D41A0 + 12), 1);
    sub_6EAB0(0, *(_WORD *)(dword_D41A0 + 12), 2);
  }
  else
  {
    sub_6E450(0, *(_WORD *)(dword_D41A0 + 12), 2);
    sub_6EAB0(0, *(_WORD *)(dword_D41A0 + 12), 1);
  }
  if ( *(int *)(*(_DWORD *)(a1 + 164) + 410) >= 1536 )
  {
    sub_6EAB0(0, *(_WORD *)(dword_D41A0 + 12), 5);
  }
  else
  {
    sub_6E450(0, *(_WORD *)(dword_D41A0 + 12), 5);
    *(_DWORD *)(*(_DWORD *)(a1 + 164) + 410) = 2048;
  }
  if ( *(int *)(*(_DWORD *)(a1 + 164) + 414) >= 1536 )
  {
    sub_6EAB0(0, *(_WORD *)(dword_D41A0 + 12), 31);
  }
  else
  {
    sub_6E450(0, *(_WORD *)(dword_D41A0 + 12), 31);
    *(_DWORD *)(*(_DWORD *)(a1 + 164) + 414) = 2048;
  }
  v50 = *(_DWORD *)(a1 + 164);
  if ( *(_WORD *)(v50 + 56) == *(_WORD *)(dword_D41A0 + 12) )
  {
    v51 = *(_WORD *)(v50 + 54);
    if ( v51 <= 0 )
    {
      sub_99970(1, 3u);
    }
    else
    {
      *(_WORD *)(v50 + 54) = v51 - 1;
      sub_99970(2, 3u);
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// D4B84: using guessed type int dword_D4B84;
// D4B90: using guessed type int dword_D4B90;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (0005DD50) --------------------------------------------------------
int __cdecl sub_5DD50(int a1)
{
  int v1; // eax
  __int16 v2; // ax
  int result; // eax
  char v4; // [esp+0h] [ebp-4h]

  v4 = 0;
  if ( sub_104D0((__int16 *)(a1 + 76)) == 256
    || byte_D41B6
    && (v1 = *(__int16 *)(a1 + 76) >> 8,
        BYTE1(v1) = HIBYTE(*(_WORD *)(a1 + 78)),
        (byte_13B4E0[(unsigned __int16)v1] & 8) != 0) )
  {
    v4 = 1;
  }
  if ( !v4 && byte_D41B6 && *(_BYTE *)(*(_DWORD *)(a1 + 164) + 609) && sub_11E20(a1, (__int16 *)(a1 + 76)) )
    v4 = 1;
  if ( v4 )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 164) + 609) = 1;
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v2 = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, 128);
    return sub_57CF0(v2, a1, (int)&word_EB398);
  }
  else
  {
    result = *(_DWORD *)(a1 + 164);
    *(_BYTE *)(result + 609) = 0;
  }
  return result;
}
// D41B6: using guessed type char byte_D41B6;
// EB398: using guessed type __int16 word_EB398;

//----- (0005DE30) --------------------------------------------------------
void __cdecl sub_5DE30(int a1)
{
  int v1; // edx
  unsigned int v2; // ebx
  int v3; // edi
  __int16 v4; // cx
  signed int v5; // ecx
  int v6; // edi
  __int16 v7; // ax
  char v8; // al
  int v9; // esi
  __int16 v10; // [esp+0h] [ebp-10h]
  int v11; // [esp+4h] [ebp-Ch]
  char *v12; // [esp+8h] [ebp-8h]

  v1 = *(_DWORD *)(a1 + 164);
  v2 = dword_EA3E4[*(unsigned __int16 *)(v1 + 326)];
  v3 = 0;
  if ( v2 > dword_EA3E4[0] )
  {
    v12 = (char *)&unk_DAC7A + 26 * *(__int16 *)(v1 + 330);
    v4 = *(_WORD *)(v1 + 847);
    if ( v4 )
      v3 = dword_EA3E4[v4];
    v5 = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v2 + 76));
    if ( v3 && *(_WORD *)(v3 + 46) && v5 < *(_DWORD *)v12 && *(int *)(v2 + 8) >= 0 )
    {
      v11 = 3 * *(__int16 *)(a1 + 132) / 2;
      v6 = (v5 - *(_DWORD *)(*(_DWORD *)(a1 + 164) + 322)) / (1024 / (__int16)v11);
      if ( (__int16)v6 < -(__int16)v11 )
        v6 = 3 * *(__int16 *)(a1 + 132) / -2;
      if ( (__int16)v6 > (__int16)v11 )
        LOWORD(v6) = 3 * *(__int16 *)(a1 + 132) / 2;
      v10 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v2 + 76));
      v7 = *(_WORD *)(a1 + 28) + sub_58350(*(_WORD *)(a1 + 28), v10, 5, 0x82u);
      HIBYTE(v7) &= 7u;
      *(_WORD *)(a1 + 28) = v7;
      sub_57FA0(&word_EB398, v10, *(_WORD *)(a1 + 30), v6);
      v8 = v12[24];
      if ( v8 )
      {
        if ( (unsigned __int8)v8 > 1u )
        {
          if ( v8 != 2 )
            return;
          *(_DWORD *)(v2 + 8) -= *(__int16 *)(*(_DWORD *)(v2 + 164) + 355) + 2;
        }
        v9 = *(_DWORD *)(v2 + 144) - (*(_DWORD *)(v2 + 136) + 8);
        *(_DWORD *)(v2 + 144) = v9;
        if ( v9 < 0 )
          *(_DWORD *)(v2 + 144) = 0;
      }
    }
    else
    {
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 326) = 0;
    }
  }
}
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (0005E010) --------------------------------------------------------
void __cdecl sub_5E010(unsigned int a1)
{
  unsigned __int16 v1; // dx
  int v2; // edx
  int v3; // edx
  unsigned __int8 v4; // cl
  int v5; // edx
  int v6; // edx
  int v7; // eax
  int v8; // edx
  __int16 v9; // cx
  int v10; // edi
  int v11; // edx
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  __int16 v15; // di
  char v16; // [esp+0h] [ebp-4h]

  v16 = 0;
  *(_WORD *)(a1 + 132) = dword_D4B8C;
  if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) == 0 )
  {
    v1 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 58);
    if ( v1 )
    {
      if ( sub_106C0(a1, dword_EA3E4[v1]) )
        v16 = 1;
    }
  }
  sub_5F380(a1);
  if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) == 0 && v16 )
  {
    if ( *(_WORD *)(a1 + 98) )
    {
      v2 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)];
      if ( *(_WORD *)(v2 + 98) )
        *(_DWORD *)(v2 + 94) += *(_DWORD *)(a1 + 94);
      else
        *(_DWORD *)(v2 + 94) = *(_DWORD *)(a1 + 94);
      *(_WORD *)(v2 + 98) = *(_WORD *)(a1 + 98);
    }
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 345) = 2;
  }
  if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) == 0 )
  {
    if ( *(_WORD *)(*(_DWORD *)(a1 + 164) + 345) )
    {
      memset(a1 + 94, 0, 36);
      --*(_WORD *)(*(_DWORD *)(a1 + 164) + 345);
    }
    else
    {
      sub_5EFA0(a1);
    }
    v3 = *(_DWORD *)(a1 + 164);
    v4 = *(_BYTE *)(v3 + 340);
    if ( v4 < 0xC8u )
      *(_BYTE *)(v3 + 340) = v4 + 1;
  }
  sub_5D530(a1);
  if ( *(int *)(a1 + 8) >= 0 )
  {
    if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) == 0 )
    {
      v6 = *(_DWORD *)(a1 + 164);
      *(_DWORD *)(a1 + 144) += *(_DWORD *)(a1 + 136);
      v7 = *(_DWORD *)(v6 + 397);
      if ( v7 )
        *(_DWORD *)(v6 + 397) = v7 - 1;
      else
        *(_DWORD *)(a1 + 8) += *(__int16 *)(v6 + 355);
      v8 = *(_DWORD *)(a1 + 164);
      v9 = *(_WORD *)(v8 + 588);
      if ( v9 )
        *(_WORD *)(v8 + 588) = v9 - 1;
      if ( *(int *)(a1 + 144) < 0 )
        *(_DWORD *)(a1 + 144) = 0;
      v10 = *(_DWORD *)(a1 + 140);
      if ( *(_DWORD *)(a1 + 144) > v10 )
        *(_DWORD *)(a1 + 144) = v10;
      if ( *(int *)(a1 + 8) < -1 )
        *(_DWORD *)(a1 + 8) = -1;
      v11 = *(_DWORD *)(a1 + 4);
      if ( *(_DWORD *)(a1 + 8) > v11 )
        *(_DWORD *)(a1 + 8) = v11;
      v12 = *(_DWORD *)(a1 + 164);
      v13 = *(_DWORD *)(v12 + 365);
      if ( v13 )
        *(_DWORD *)(v12 + 365) = v13 - 1;
      v14 = *(_DWORD *)(a1 + 164);
      v15 = *(_WORD *)(v14 + 584);
      if ( v15 )
        *(_WORD *)(v14 + 584) = v15 - 1;
      if ( v16 || (*(_BYTE *)(a1 + 13) & 0x10) != 0 )
      {
        *(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 140) / 200;
        *(_WORD *)(*(_DWORD *)(a1 + 164) + 355) = *(_DWORD *)(a1 + 4) / 250;
        if ( *(int *)(a1 + 136) < 1000 )
          *(_DWORD *)(a1 + 136) = 1000;
        *(_BYTE *)(a1 + 13) &= ~0x10u;
      }
      else
      {
        *(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 140) / 2000;
        *(_WORD *)(*(_DWORD *)(a1 + 164) + 355) = *(_DWORD *)(a1 + 4) / 2000;
        if ( *(int *)(a1 + 136) < 100 )
          *(_DWORD *)(a1 + 136) = 100;
      }
    }
  }
  else
  {
    v5 = dword_D41A0;
    *(_BYTE *)(a1 + 69) = 2;
    *(_WORD *)(a1 + 44) = 0;
    sub_6E450((int)(a1 - (v5 + 28302)) / 168, -1, 16);
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D4B8C: using guessed type int dword_D4B8C;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005E310) --------------------------------------------------------
int __cdecl sub_5E310(int a1)
{
  int v1; // edx
  __int16 v2; // cx
  int v3; // esi
  __int16 v4; // ax
  __int16 v5; // di
  int v6; // eax
  int result; // eax
  unsigned __int16 v8; // di
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // edx
  char *v13; // esi
  char *v14; // edi
  char v15; // al
  char v16; // al
  int v17; // eax
  unsigned int v18; // edx
  __int16 v19; // di
  __int16 v20; // dx
  int v21; // ecx
  unsigned int j; // ecx
  int v23; // [esp+0h] [ebp-Ch]
  int i; // [esp+4h] [ebp-8h]
  int v25; // [esp+8h] [ebp-4h]

  sub_5D530(a1);
  if ( *(_BYTE *)(dword_D41A4 + 127) )
    sub_5C800(a1, 7);
  v1 = 2124 * *(__int16 *)(*(_DWORD *)(a1 + 164) + 56);
  if ( *(_BYTE *)(v1 + dword_D41A0 + 11230 + 991) )
    sub_52E90(v1 + dword_D41A0 + 11230, 0, 0);
  v2 = *(_WORD *)(a1 + 44) - 2;
  *(_WORD *)(a1 + 80) += *(_WORD *)(a1 + 44);
  *(_WORD *)(a1 + 44) = v2;
  if ( v2 < -256 )
    *(_WORD *)(a1 + 44) = -256;
  if ( *(__int16 *)(a1 + 44) > 0 )
    *(_WORD *)(a1 + 44) = 0;
  v3 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 12);
  v4 = sub_10C40((__int16 *)(a1 + 76));
  v5 = v4;
  if ( *(__int16 *)(a1 + 80) < v3 + v4 )
    *(_WORD *)(a1 + 80) = *(_WORD *)(*(_DWORD *)(a1 + 160) + 12) + v4;
  v6 = sub_4A190((int)&word_EB398, 10, 1);
  if ( v6 )
  {
    *(_BYTE *)(v6 + 12) |= 0x80u;
    *(_WORD *)(v6 + 26) = *(_WORD *)(a1 + 26);
  }
  result = v5 + *(__int16 *)(*(_DWORD *)(a1 + 160) + 12);
  if ( *(__int16 *)(a1 + 80) == result )
  {
    sub_49F90(result);
    v8 = *(_WORD *)(a1 + 36);
    if ( v8 )
    {
      v9 = dword_EA3E4[v8];
      if ( *(_BYTE *)(v9 + 63) == 3 && *(_BYTE *)(v9 + 64) <= 1u )
      {
        v10 = *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 36)] + 164);
        v11 = *(__int16 *)(*(_DWORD *)(a1 + 164) + 56);
        ++*(_WORD *)(v10 + 2 * v11 + 38);
      }
    }
    memset(a1 + 94, 0, 36);
    v12 = 2124 * *(__int16 *)(*(_DWORD *)(a1 + 164) + 56) + dword_D41A0 + 11230;
    v13 = (char *)dword_EA224;
    v14 = (char *)(v12 + 28);
    do
    {
      v15 = *v13;
      *v14 = *v13;
      if ( !v15 )
        break;
      v16 = v13[1];
      v13 += 2;
      v14[1] = v16;
      v14 += 2;
    }
    while ( v16 );
    *(_WORD *)(v12 + 79) = 1;
    *(_WORD *)(v12 + 77) = 100;
    for ( i = 0; i < 26; ++i )
    {
      v17 = *(_DWORD *)(a1 + 164) + 2 * i;
      v18 = dword_EA3E4[*(__int16 *)(v17 + 819)];
      v25 = v18;
      if ( v18 <= dword_EA3E4[0] )
      {
        *(_WORD *)(v17 + 819) = 0;
      }
      else
      {
        *(_WORD *)(v17 + 819) = 1;
        *(_BYTE *)(v18 + 12) &= ~1u;
        ++*(_BYTE *)(v18 + 69);
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v19 = *(_WORD *)(a1 + 20);
        word_EB398 += (v19 & 0x1FF) - 256;
        v20 = 9377 * v19 + 9439;
        *(_WORD *)(a1 + 20) = v20;
        word_EB39A += (v20 & 0x1FF) - 256;
        sub_57CF0(word_EB39A, v25, (int)&word_EB398);
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        *(_DWORD *)(v25 + 8) = *(unsigned __int16 *)(a1 + 20) % 0x5Au + 200;
      }
    }
    v23 = sub_4A190(a1 + 76, 10, 40);
    if ( v23 )
    {
      *(_BYTE *)(a1 + 69) = 3;
      v21 = dword_D41A4;
      *(_DWORD *)(a1 + 16) = 1200;
      for ( j = *(_DWORD *)(v21 + 38523); j > dword_EA3E4[0]; j = *(_DWORD *)j )
      {
        if ( *(_BYTE *)(j + 64) == 39 && *(unsigned __int16 *)(j + 148) == (a1 - (dword_D41A0 + 28302)) / 168 )
          *(_WORD *)(j + 148) = (v23 - (dword_D41A0 + 28302)) / 168;
      }
    }
    *(_BYTE *)(a1 + 12) |= 0x20u;
    result = dword_D41A0;
    --*(_DWORD *)(dword_D41A0 + 4582);
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA224: using guessed type int dword_EA224;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;

//----- (0005E660) --------------------------------------------------------
int __cdecl sub_5E660(int a1)
{
  char v1; // ah
  int v2; // ebx

  v1 = *(_BYTE *)(a1 + 12);
  *(_DWORD *)(a1 + 8) = -1;
  v2 = 0;
  *(_BYTE *)(a1 + 12) = v1 | 0x20;
  while ( v2 < 26 )
  {
    if ( (unsigned int)dword_EA3E4[*(__int16 *)(*(_DWORD *)(a1 + 164) + 2 * v2 + 819)] > dword_EA3E4[0] )
      sub_57F10(dword_EA3E4[*(__int16 *)(*(_DWORD *)(a1 + 164) + 2 * v2 + 819)]);
    ++v2;
  }
  return sub_57F10(a1);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005E6C0) --------------------------------------------------------
__int16 __cdecl sub_5E6C0(int a1)
{
  _WORD *v1; // edi
  __int16 v2; // ax
  __int16 v3; // ax
  __int16 v4; // ax
  __int16 result; // ax
  unsigned __int16 v6; // [esp-10h] [ebp-10h]
  unsigned __int16 v7; // [esp-10h] [ebp-10h]
  __int16 v8; // [esp-Ch] [ebp-Ch]

  if ( *(_WORD *)(a1 + 36) )
  {
    v1 = (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 36)] + 76);
    *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), v1);
    v2 = sub_58210((_WORD *)(a1 + 76), v1);
    v8 = *(_WORD *)(a1 + 32);
    v6 = *(_WORD *)(a1 + 28);
    *(_WORD *)(a1 + 34) = v2;
    v3 = sub_58350(v6, v8, 5, 0x16u);
    LOWORD(v1) = *(_WORD *)(a1 + 34);
    *(_WORD *)(a1 + 28) += v3;
    v7 = *(_WORD *)(a1 + 30);
    *(_BYTE *)(a1 + 29) &= 7u;
    *(_WORD *)(a1 + 30) += sub_58350(v7, (__int16)v1, 5, 0x16u);
    *(_BYTE *)(a1 + 31) &= 7u;
    v4 = sub_10C40((__int16 *)(a1 + 76));
  }
  else
  {
    *(_WORD *)(a1 + 28) += 5;
    *(_BYTE *)(a1 + 29) &= 7u;
    v4 = sub_10C40((__int16 *)(a1 + 76));
    ++HIBYTE(v4);
  }
  *(_WORD *)(a1 + 80) = v4;
  *(_WORD *)(a1 + 30) = 0;
  result = *(_WORD *)(a1 + 30);
  *(_WORD *)(*(_DWORD *)(a1 + 164) + 343) = result;
  *(_WORD *)(*(_DWORD *)(a1 + 164) + 341) = 0;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005E7C0) --------------------------------------------------------
char __cdecl sub_5E7C0(int a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // ebx
  _BYTE *v5; // esi
  _BYTE *v6; // edi

  *(_WORD *)(*(_DWORD *)(a1 + 164) + 30) = 0;
  v1 = *(_DWORD *)(a1 + 164);
  v2 = 2124 * *(__int16 *)(v1 + 56);
  if ( *(_BYTE *)(dword_D41A0 + v2 + 11239) == 1 )
  {
    v3 = v2 + dword_D41A0 + 11230;
    if ( *(_WORD *)(v1 + 58) )
    {
      v4 = *(_DWORD *)(a1 + 16);
      if ( v4 )
        *(_DWORD *)(a1 + 16) = v4 - 1;
      else
        LOBYTE(v1) = sub_5C950(v1, v3, a1);
    }
    else
    {
      if ( *(_BYTE *)(v3 + 6) )
      {
        v5 = (_BYTE *)dword_EA0B8;
        v6 = (_BYTE *)(v3 + 28);
        do
        {
          LOBYTE(v1) = *v5;
          *v6 = *v5;
          if ( !(_BYTE)v1 )
            break;
          LOBYTE(v1) = v5[1];
          v5 += 2;
          v6[1] = v1;
          v6 += 2;
        }
        while ( (_BYTE)v1 );
        *(_WORD *)(v3 + 79) = 1;
        *(_WORD *)(v3 + 77) = 200;
      }
      *(_BYTE *)(v3 + 6) = 0;
    }
  }
  else
  {
    sub_5C800(a1, 7);
    LOBYTE(v1) = sub_5E6C0(a1);
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// EA0B8: using guessed type int dword_EA0B8;

//----- (0005E8C0) --------------------------------------------------------
int __cdecl sub_5E8C0(int a1)
{
  __int16 v1; // si
  int v2; // eax
  unsigned __int8 v3; // dl
  __int16 v4; // di
  __int16 v5; // dx
  unsigned int v6; // eax
  char v7; // dl
  int v8; // esi
  __int16 v9; // ax
  __int16 v10; // ax
  __int16 v11; // si
  int v12; // eax
  int v13; // ecx
  int v14; // edx
  int v15; // esi
  __int16 v16; // di
  __int16 v17; // ax
  int v18; // esi
  __int16 v19; // cx
  __int16 v20; // ax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // edx
  int v25; // eax
  __int16 v26; // ax
  int v27; // edx
  int v28; // esi
  int v29; // ecx
  int result; // eax
  char v31; // [esp+0h] [ebp-4h]

  v31 = 0;
  switch ( *(_BYTE *)(a1 + 70) )
  {
    case 0:
      sub_52E90(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230, 0, 0);
      if ( *(_WORD *)(*(_DWORD *)(a1 + 164) + 56) == *(_WORD *)(dword_D41A0 + 12) )
      {
        sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 41);
        sub_5C800(a1, 6);
      }
      *(_BYTE *)(*(_DWORD *)(a1 + 164) + 334) = 0;
      *(_BYTE *)(*(_DWORD *)(a1 + 164) + 332) = 0;
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 30) = 0;
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 16) = 0;
      v1 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 825);
      if ( v1 )
        *(_WORD *)(dword_EA3E4[v1] + 46) = 0;
      v2 = dword_D41A0;
      *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) |= 0x20u;
      v3 = *(_BYTE *)(a1 + 69);
      *(_WORD *)(a1 + 150) = 0;
      if ( v3 >= 0xBu )
      {
        if ( v3 <= 0xBu )
        {
          v5 = *(_WORD *)((char *)&loc_36DFC + v2);
          if ( v5 )
            *(_WORD *)(a1 + 150) = v5;
        }
        else if ( v3 == 12 )
        {
          v4 = *(_WORD *)(v2 + 224766);
          if ( v4 )
            *(_WORD *)(a1 + 150) = v4;
        }
      }
      v6 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
      if ( v6 > dword_EA3E4[0] )
      {
        if ( *(_BYTE *)(v6 + 63) != 14 || (v7 = *(_BYTE *)(v6 + 64), v7 != 4) && v7 != 3 )
          *(_WORD *)(a1 + 150) = 0;
      }
      *(_BYTE *)(a1 + 70) = 1;
      break;
    case 1:
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      v8 = *(__int16 *)(a1 + 130);
      sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
      v9 = sub_5D0A0(a1);
      if ( v9 )
        sub_57CF0(v9, a1, (int)&word_EB398);
      else
        *(_WORD *)(a1 + 130) = 0;
      if ( (int)abs32(v8) <= 4 )
      {
        *(_WORD *)(a1 + 130) = 0;
      }
      else
      {
        if ( v8 <= 0 )
          v10 = 1;
        else
          v10 = -1;
        *(_WORD *)(a1 + 130) += 4 * v10;
      }
      if ( !*(_WORD *)(a1 + 130) )
        *(_BYTE *)(a1 + 70) = (*(_WORD *)(a1 + 150) == 0) + 3;
      break;
    case 3:
      v11 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 76));
      if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v11) <= 0xBu )
      {
        *(_BYTE *)(a1 + 70) = 4;
        *(_WORD *)(a1 + 28) = v11;
      }
      else
      {
        *(_WORD *)(a1 + 28) += sub_58350(*(_WORD *)(a1 + 28), v11, 0, 0xBu);
        *(_BYTE *)(a1 + 29) &= 7u;
      }
      break;
    case 4:
      *(_DWORD *)(a1 + 16) = 12;
      v12 = dword_D41A0;
      *(_BYTE *)(a1 + 70) = 5;
      *(_BYTE *)(v12 + 224779) |= 2u;
      goto LABEL_34;
    case 5:
LABEL_34:
      v13 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v13;
      if ( v13 )
      {
        if ( v13 > 4 )
          --*(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11707);
      }
      else
      {
        if ( *(_WORD *)(a1 + 150) )
          *(_BYTE *)(a1 + 70) = 6;
        else
          *(_BYTE *)(a1 + 70) = 8;
        if ( dword_E9C3C && !*(_BYTE *)(dword_D41A0 + 196308) )
        {
          sub_86860(word_1803EC);
          sub_53E60((int)aDataGtd2Dat, byte_FAEE0);
        }
      }
      break;
    case 6:
      *(_DWORD *)(a1 + 16) = 512;
      *(_WORD *)(a1 + 130) = 100;
      *(_BYTE *)(a1 + 70) = 7;
      v31 = 1;
      goto LABEL_44;
    case 7:
LABEL_44:
      v14 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v14;
      if ( !v14 )
        goto LABEL_51;
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      v15 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
      *(_WORD *)(a1 + 28) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v15 + 76));
      sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
      v16 = *(_WORD *)(a1 + 130) + 8;
      *(_WORD *)(a1 + 130) = v16;
      if ( v16 < 0 )
        *(_WORD *)(a1 + 130) = 0;
      if ( *(__int16 *)(a1 + 130) > 200 )
        *(_WORD *)(a1 + 130) = 200;
      v17 = sub_5D0A0(a1);
      if ( !v17 )
        goto LABEL_51;
      sub_57CF0(v17, a1, (int)&word_EB398);
      if ( sub_58490((_WORD *)(a1 + 76), (_WORD *)(v15 + 76)) < 0x180 )
        goto LABEL_51;
      break;
    case 8:
      *(_DWORD *)(a1 + 16) = 128;
      *(_WORD *)(a1 + 130) = 100;
      *(_BYTE *)(a1 + 70) = 9;
      v31 = 1;
      goto LABEL_53;
    case 9:
LABEL_53:
      v18 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v18;
      if ( v18 )
      {
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, *(_WORD *)(a1 + 130));
        v19 = *(_WORD *)(a1 + 130) + 8;
        *(_WORD *)(a1 + 130) = v19;
        if ( v19 < 0 )
          *(_WORD *)(a1 + 130) = 0;
        if ( *(__int16 *)(a1 + 130) > 200 )
          *(_WORD *)(a1 + 130) = 200;
        v20 = sub_5D0A0(a1);
        if ( v20 )
          goto LABEL_59;
      }
LABEL_51:
      *(_BYTE *)(a1 + 70) = 10;
      break;
    case 0xA:
      *(_BYTE *)(a1 + 70) = 11;
      v21 = *(_DWORD *)(a1 + 164);
      *(_DWORD *)(a1 + 16) = 32;
      if ( *(_WORD *)(v21 + 56) == *(_WORD *)(dword_D41A0 + 12) )
        sub_5C800(a1, 5);
      goto LABEL_62;
    case 0xB:
LABEL_62:
      v22 = *(_DWORD *)(a1 + 16) - 1;
      *(_DWORD *)(a1 + 16) = v22;
      if ( v22 && *(_BYTE *)(dword_D41A4 + 180) )
      {
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, 2);
        v20 = sub_5D0A0(a1);
        if ( v20 )
LABEL_59:
          sub_57CF0(v20, a1, (int)&word_EB398);
      }
      else
      {
        *(_BYTE *)(a1 + 70) = 12;
      }
      break;
    case 0xC:
      v23 = dword_D41A0;
      v24 = 2124 * *(__int16 *)(dword_D41A0 + 12);
      *(_BYTE *)(dword_D41A0 + 8625) = 0;
      *(_BYTE *)(v23 + 8593) = 0;
      *(_WORD *)(v24 + v23 + 11232) = 10;
      if ( *(_BYTE *)(a1 + 69) == 11 )
        *(_BYTE *)(dword_D41A4 + 38545) &= ~4u;
      if ( *(_BYTE *)(a1 + 69) == 11 || (*(_BYTE *)(dword_D41A4 + 38545) & 0x10) != 0 )
        *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) |= 0x10u;
      break;
    default:
      break;
  }
  if ( v31 )
  {
    if ( *(_WORD *)(*(_DWORD *)(a1 + 164) + 56) == *(_WORD *)(dword_D41A0 + 12) )
    {
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 19);
      if ( dword_E9C3C )
      {
        v25 = dword_D41A0;
        *(_BYTE *)(dword_D41A0 + 8625) = 1;
        *(_BYTE *)(v25 + 8593) = 2;
      }
    }
  }
  v26 = sub_10C40((__int16 *)(a1 + 76));
  v27 = *(__int16 *)(a1 + 80);
  if ( v27 <= v26 + 256 )
  {
    if ( v27 >= v26 )
      *(_WORD *)(a1 + 80) = v26 + 128;
    else
      *(_WORD *)(a1 + 80) += 128;
  }
  else
  {
    *(_WORD *)(a1 + 80) -= 128;
  }
  v28 = *(_DWORD *)(a1 + 164);
  *(_WORD *)(v28 + 341) -= (int)(*(__int16 *)(v28 + 341)
                               - (__CFSHL__((unsigned __int64)*(__int16 *)(v28 + 341) >> 32, 3)
                                + 8 * ((unsigned __int64)*(__int16 *)(v28 + 341) >> 32))) >> 3;
  v29 = *(_DWORD *)(a1 + 164);
  result = (int)(*(__int16 *)(v29 + 343)
               - (__CFSHL__((unsigned __int64)*(__int16 *)(v29 + 343) >> 32, 2)
                + 4 * ((unsigned __int64)*(__int16 *)(v29 + 343) >> 32))) >> 2;
  *(_WORD *)(v29 + 343) -= result;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E9C3C: using guessed type int dword_E9C3C;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// 1803EC: using guessed type __int16 word_1803EC;

//----- (0005EF70) --------------------------------------------------------
unsigned int __cdecl sub_5EF70(unsigned int a1)
{
  unsigned int result; // eax

  result = a1;
  if ( a1 > dword_EA3E4[0] && *(_BYTE *)(a1 + 63) == 3 && !*(_BYTE *)(a1 + 64) )
  {
    result = *(_DWORD *)(a1 + 164);
    *(_WORD *)(result + 54) = 100;
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005EFA0) --------------------------------------------------------
int __cdecl sub_5EFA0(unsigned int a1)
{
  int v1; // esi
  unsigned int v2; // eax
  unsigned __int16 v3; // cx
  int v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  unsigned __int8 v9; // kr00_1
  __int64 v10; // rtt
  __int16 v11; // ax
  char v12; // ch
  int v13; // eax
  char v14; // dl
  int v15; // edi
  char v16; // dh
  unsigned __int16 v17; // di
  int v18; // edi
  int v19; // eax
  int v20; // eax

  *(_WORD *)(a1 + 38) = 0;
  v1 = 0;
  if ( *(_WORD *)(a1 + 150) )
  {
    v2 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    if ( v2 > dword_EA3E4[0] && (*(int *)(v2 + 8) <= 0 || (*(_BYTE *)(v2 + 13) & 4) != 0) )
      *(_WORD *)(a1 + 150) = 0;
  }
  if ( *(int *)(a1 + 8) >= 0 )
  {
    v3 = *(_WORD *)(a1 + 122);
    if ( v3 )
    {
      v4 = dword_EA3E4[v3];
      if ( v4 )
      {
        *(_WORD *)(*(_DWORD *)(v4 + 164) + 326) = (int)(a1 - (dword_D41A0 + 28302)) / 168;
        *(_DWORD *)(*(_DWORD *)(v4 + 164) + 322) = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(v4 + 76));
        *(_WORD *)(*(_DWORD *)(v4 + 164) + 330) = *(_WORD *)(a1 + 118);
        v5 = *(_DWORD *)(v4 + 164);
        if ( *(int *)(v5 + 322) < 1024 )
          *(_DWORD *)(v5 + 322) = 1024;
        v6 = *(_DWORD *)(v4 + 164);
        if ( *(int *)(v6 + 322) > 3072 )
          *(_DWORD *)(v6 + 322) = 3072;
        sub_6D8B0(*(_WORD *)(a1 + 122), 0xEu, 1);
      }
      v7 = *(_DWORD *)(a1 + 164);
      *(_WORD *)(a1 + 122) = 0;
      *(_BYTE *)(v7 + 406) = 4;
      *(_DWORD *)(*(_DWORD *)(a1 + 164) + 397) = 16;
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 588) = 64;
      sub_5EF70(a1);
    }
    if ( *(_WORD *)(a1 + 116) )
      sub_61050(a1);
    v8 = *(_DWORD *)(a1 + 164);
    if ( *(_BYTE *)(v8 + 332) && *(_BYTE *)(dword_D41A4 + 181) )
    {
      v9 = *(_BYTE *)(v8 + 332);
      LODWORD(v10) = 171 * v9;
      HIDWORD(v10) = v9 / 0xBFA030u;
      sub_5C830(a1, 3, v10 / 3 + 85);
    }
    v11 = *(_WORD *)(a1 + 98);
    if ( v11 )
    {
      v12 = *(_BYTE *)(a1 + 13);
      *(_WORD *)(a1 + 38) = v11;
      if ( (v12 & 0x40) != 0 || (*(_BYTE *)(a1 + 14) & 0x40) != 0 )
      {
        sub_6D8B0((int)(a1 - (dword_D41A0 + 28302)) / 168, 6u, 1);
        if ( (*(_BYTE *)(a1 + 13) & 0x40) != 0 )
        {
          v13 = (*(_DWORD *)(a1 + 94) - (__CFSHL__(*(int *)(a1 + 94) >> 31, 2) + 4 * (*(int *)(a1 + 94) >> 31))) >> 2;
          v14 = *(_BYTE *)(a1 + 13);
          v15 = *(_DWORD *)(a1 + 144) - v13;
          *(_DWORD *)(a1 + 94) = v13;
          *(_DWORD *)(a1 + 144) = v15;
          *(_BYTE *)(a1 + 13) = v14 & 0xBF;
        }
        else
        {
          *(_DWORD *)(a1 + 12) &= 0xFFBFBFFF;
          v16 = *(_BYTE *)(a1 + 13);
          *(_DWORD *)(a1 + 94) = 0;
          *(_BYTE *)(a1 + 13) = v16 | 0x40;
        }
      }
      v17 = *(_WORD *)(a1 + 98);
      *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
      v18 = dword_EA3E4[v17];
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 32) = sub_581E0((_WORD *)(v18 + 76), (_WORD *)(a1 + 76));
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 34) = sub_58210((_WORD *)(v18 + 76), (_WORD *)(a1 + 76));
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 30) = *(_DWORD *)(a1 + 94) / 10;
      v19 = *(_DWORD *)(a1 + 164);
      if ( *(__int16 *)(v19 + 30) < 0 )
        *(_WORD *)(v19 + 30) = 0;
      v20 = *(_DWORD *)(a1 + 164);
      if ( *(__int16 *)(v20 + 30) > 80 )
        *(_WORD *)(v20 + 30) = 80;
      sub_5C800(a1, 2);
      *(_BYTE *)(*(_DWORD *)(a1 + 164) + 406) = 4;
      *(_DWORD *)(*(_DWORD *)(a1 + 164) + 397) = 16;
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 588) = 64;
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      sub_6E450((int)(a1 - (dword_D41A0 + 28302)) / 168, -1, (*(_WORD *)(a1 + 20) & 3) + 54);
      if ( *(int *)(a1 + 8) < 0 )
      {
        *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 98);
        if ( *(_BYTE *)(v18 + 63) == 10 && *(_BYTE *)(v18 + 64) == 67 )
          *(_WORD *)(a1 + 36) = 0;
        v1 = 2;
      }
      if ( v1 != 2 )
      {
        v1 = 1;
        sub_5EF70(a1);
        *(_WORD *)(a1 + 98) = 0;
      }
    }
  }
  else
  {
    v1 = 2;
  }
  if ( (*(_BYTE *)(dword_D41A4 + 25) & 1) != 0 && !*(_BYTE *)(a1 + 64) )
  {
    *(_WORD *)(a1 + 38) = 0;
    *(_WORD *)(a1 + 36) = 0;
    *(_WORD *)(a1 + 98) = 0;
    *(_DWORD *)(a1 + 8) = 10000;
    return 0;
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005F380) --------------------------------------------------------
char __cdecl sub_5F380(int a1)
{
  __int16 v1; // ax
  int v2; // edx
  int v3; // edx
  int v4; // eax
  int v5; // eax
  __int16 v6; // ax
  __int16 v7; // di
  __int16 v8; // ax
  __int16 v9; // dx
  __int16 v10; // di
  int v11; // eax
  int v12; // eax
  int v13; // eax
  _BOOL1 v14; // cc
  int v15; // eax
  int v16; // eax
  int v17; // eax
  _BYTE *v18; // eax

  v1 = 0;
  *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 0;
  v2 = *(_DWORD *)(a1 + 164);
  if ( (*(_BYTE *)v2 & 1) != 0 && *(__int16 *)(v2 + 12) < dword_D4B8C )
    v1 = 1;
  v3 = *(_DWORD *)(a1 + 164);
  if ( (*(_BYTE *)v3 & 2) != 0 && *(__int16 *)(v3 + 12) > dword_D4B88 )
    v1 = -1;
  if ( v1 )
  {
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 12) += dword_D4B84 * v1;
    v4 = *(_DWORD *)(a1 + 164);
    if ( *(__int16 *)(v4 + 12) < dword_D4B88 )
      *(_WORD *)(v4 + 12) = dword_D4B88;
    v5 = *(_DWORD *)(a1 + 164);
    if ( *(__int16 *)(v5 + 12) > dword_D4B8C )
      *(_WORD *)(v5 + 12) = dword_D4B8C;
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 14) = 1;
  }
  v6 = 0;
  if ( (**(_BYTE **)(a1 + 164) & 4) != 0 )
    v6 = -1;
  if ( (**(_BYTE **)(a1 + 164) & 8) != 0 )
    v6 = 1;
  if ( v6 )
  {
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 16) += word_D4BA4 * v6;
    v15 = *(_DWORD *)(a1 + 164);
    if ( *(__int16 *)(v15 + 16) < dword_D4BA8 )
      *(_WORD *)(v15 + 16) = dword_D4BA8;
    v13 = *(_DWORD *)(a1 + 164);
    v14 = *(__int16 *)(v13 + 16) <= dword_D4BAC;
  }
  else
  {
    v7 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 16);
    if ( v7 )
    {
      if ( v7 <= 0 )
        v8 = -1;
      else
        v8 = 1;
    }
    else
    {
      v8 = 0;
    }
    v9 = v8;
    *(_WORD *)(*(_DWORD *)(a1 + 164) + 16) += v8 * word_D4BB0;
    v10 = *(_WORD *)(*(_DWORD *)(a1 + 164) + 16);
    if ( v10 )
    {
      if ( v10 <= 0 )
        v11 = -1;
      else
        v11 = 1;
    }
    else
    {
      v11 = 0;
    }
    if ( v9 != v11 )
      *(_WORD *)(*(_DWORD *)(a1 + 164) + 16) = 0;
    v12 = *(_DWORD *)(a1 + 164);
    if ( *(__int16 *)(v12 + 16) < dword_D4BA8 )
      *(_WORD *)(v12 + 16) = dword_D4BA8;
    v13 = *(_DWORD *)(a1 + 164);
    v14 = *(__int16 *)(v13 + 16) <= dword_D4BAC;
  }
  if ( !v14 )
    *(_WORD *)(v13 + 16) = dword_D4BAC;
  v16 = *(_DWORD *)(a1 + 164);
  if ( (*(_BYTE *)v16 & 0x10) != 0 )
    sub_5F660(a1, dword_EA3E4[*(__int16 *)(v16 + 2 * *(__int16 *)(v16 + 1105) + 819)], 256);
  v17 = *(_DWORD *)(a1 + 164);
  if ( (*(_BYTE *)v17 & 0x20) != 0 )
    sub_5F660(a1, dword_EA3E4[*(__int16 *)(v17 + 2 * *(__int16 *)(v17 + 1107) + 819)], 512);
  v18 = *(_BYTE **)(a1 + 164);
  if ( (*v18 & 0x40) != 0 )
    LOBYTE(v18) = sub_5F660(
                    a1,
                    dword_EA3E4[*(__int16 *)&v18[2 * (unsigned __int8)byte_D94FF[(char)v18[1112]] + 819]],
                    256);
  return (char)v18;
}
// D4B84: using guessed type int dword_D4B84;
// D4B88: using guessed type int dword_D4B88;
// D4B8C: using guessed type int dword_D4B8C;
// D4BA4: using guessed type __int16 word_D4BA4;
// D4BA8: using guessed type int dword_D4BA8;
// D4BAC: using guessed type int dword_D4BAC;
// D4BB0: using guessed type __int16 word_D4BB0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005F660) --------------------------------------------------------
char __cdecl sub_5F660(int a1, unsigned int a2, int a3)
{
  char v5; // [esp+0h] [ebp-Ch]
  char v6; // [esp+4h] [ebp-8h]
  char v7; // [esp+8h] [ebp-4h]

  v5 = 0;
  v7 = 0;
  v6 = 0;
  if ( a2 > dword_EA3E4[0] )
  {
    if ( *(_BYTE *)(a1 + 64) == 1 )
    {
      v5 = 1;
      a3 = 0;
    }
    switch ( *(_BYTE *)(a2 + 64) )
    {
      case 0:
        if ( *(char *)(a2 + 70) < 2 )
          goto LABEL_20;
        goto LABEL_16;
      case 1:
        if ( *(__int16 *)(a2 + 46) <= 0 )
          goto LABEL_20;
        *(_BYTE *)(a2 + 60) = 1;
        *(_BYTE *)(a1 + 13) &= 0xFCu;
        *(_DWORD *)(a1 + 12) |= a3;
        sub_5F7E0(a2, a1);
        v7 = 1;
        break;
      case 2:
        if ( *(__int16 *)(a2 + 46) <= 0 )
          goto LABEL_20;
        if ( !v5 )
          sub_6E450(0, *(_WORD *)(*(_DWORD *)(a1 + 164) + 56), 29);
        break;
      case 4:
      case 6:
      case 8:
      case 0xB:
      case 0xC:
      case 0xE:
        if ( *(_BYTE *)(a1 + 64) )
          goto LABEL_16;
        if ( *(__int16 *)(a2 + 46) <= 0 )
          goto LABEL_20;
        if ( *(_BYTE *)(a2 + 64) == 4 )
          *(_WORD *)(a2 + 46) = 7;
        else
          *(_WORD *)(a2 + 46) = 1;
        break;
      case 7:
        if ( *(char *)(a2 + 70) < 1 || !*(_WORD *)(a2 + 46) )
          goto LABEL_20;
        break;
      case 9:
      case 0xA:
      case 0xD:
      case 0xF:
      case 0x10:
      case 0x11:
      case 0x12:
      case 0x13:
      case 0x14:
      case 0x15:
      case 0x16:
      case 0x17:
      case 0x18:
LABEL_16:
        if ( *(_WORD *)(a2 + 46) )
          break;
        goto LABEL_20;
      default:
LABEL_20:
        if ( *(_DWORD *)(a1 + 144) < *(_DWORD *)(a2 + 140) )
        {
          v6 = 1;
        }
        else
        {
          sub_5F7B0(a2, a1, a3);
          v7 = 1;
        }
        break;
    }
  }
  if ( v6 && !v5 )
  {
    sub_88B60();
    sub_6E450(0, *(_WORD *)(*(_DWORD *)(a1 + 164) + 56), 29);
  }
  return v7;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005F7B0) --------------------------------------------------------
unsigned __int8 __cdecl sub_5F7B0(int a1, int a2, int a3)
{
  *(_WORD *)(a1 + 46) = *(_WORD *)(a1 + 48);
  *(_BYTE *)(a2 + 13) &= 0xFCu;
  *(_DWORD *)(a2 + 12) |= a3;
  return sub_5F7E0(a1, a2);
}

//----- (0005F7E0) --------------------------------------------------------
unsigned __int8 __cdecl sub_5F7E0(int a1, int a2)
{
  unsigned __int8 result; // al

  result = *(_BYTE *)(*(_DWORD *)(a2 + 164) + 447);
  if ( result < 2u || result <= 2u && (result = *(_BYTE *)(a1 + 64), result != 1) )
    *(_BYTE *)(a2 + 12) &= ~0x20u;
  return result;
}

//----- (0005F810) --------------------------------------------------------
unsigned int __cdecl sub_5F810(int a1, int a2, int a3)
{
  unsigned int v3; // edi
  unsigned int v4; // esi
  unsigned int v5; // ebx
  unsigned int v7; // eax

  v3 = -1;
  v4 = 0;
  v5 = *(_DWORD *)(dword_D41A4 + 38523);
  if ( v5 <= dword_EA3E4[0] )
    return 0;
  do
  {
    if ( *(_BYTE *)(v5 + 64) == 39
      && (*(_BYTE *)(v5 + 13) & 0x20) == 0
      && *(unsigned __int16 *)(v5 + 148) == *(__int16 *)(a1 + 26)
      && v5 != a2
      && v5 != a3 )
    {
      v7 = sub_58440((_WORD *)(a1 + 76), (_WORD *)(v5 + 76));
      if ( v7 < v3 )
      {
        v4 = v5;
        v3 = v7;
      }
    }
    v5 = *(_DWORD *)v5;
  }
  while ( v5 > dword_EA3E4[0] );
  return v4;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005F890) --------------------------------------------------------
char __cdecl sub_5F890(int a1, __int16 a2)
{
  _WORD *v2; // eax
  __int16 v3; // bx

  v2 = *(_WORD **)(dword_EA3E4[*(__int16 *)(a1 + 26)] + 164);
  v3 = *(_WORD *)((char *)v2 + 823);
  if ( v3 )
  {
    if ( a2 )
    {
      v2 = (_WORD *)dword_EA3E4[v3];
      v2[23] = v2[24] - 1;
    }
    else
    {
      *(_WORD *)(dword_EA3E4[v3] + 46) = 0;
      LOBYTE(v2) = sub_6D880(a1);
    }
  }
  return (char)v2;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005F8F0) --------------------------------------------------------
void __cdecl sub_5F8F0(int a1)
{
  __int16 v1; // si
  char v2; // dl
  unsigned int v3; // esi

  v1 = *(_WORD *)(a1 + 48);
  if ( v1 )
  {
    if ( v1 == 1 )
    {
      if ( (*(_BYTE *)(a1 + 14) & 0x10) == 0 )
      {
        *(_BYTE *)(a1 + 69) = 5;
        *(_WORD *)(a1 + 46) = 3;
        *(_WORD *)(a1 + 48) = 0;
      }
    }
    else
    {
      --*(_WORD *)(a1 + 48);
      sub_5F890(a1, 1);
      *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
    }
  }
  else
  {
    if ( sub_609E0(a1) == 2 )
    {
      *(_BYTE *)(a1 + 69) = 6;
    }
    else if ( (*(_BYTE *)(a1 + 12) & 0x40) != 0 )
    {
      *(_WORD *)(a1 + 46) = 0;
      *(_BYTE *)(a1 + 69) = 5;
    }
    *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
    v2 = *(_BYTE *)(a1 + 62);
    *(_WORD *)(a1 + 148) = *(_WORD *)(a1 + 26);
    if ( (v2 & 1) == 0 )
    {
      sub_5FD00(a1);
      sub_49EC0((_WORD *)a1, *(_WORD *)(a1 + 16));
      *(_WORD *)(a1 + 82) = -8192;
      *(_WORD *)(a1 + 88) = 0x4000;
      sub_5FF50(a1);
      if ( *(_DWORD *)(a1 + 144) < *(_DWORD *)(a1 + 140) )
      {
        v3 = *(_DWORD *)(dword_D41A4 + 38523);
        if ( v3 > dword_EA3E4[0] )
        {
          while ( *(_BYTE *)(v3 + 64) != 39
               || *(unsigned __int16 *)(v3 + 148) != *(__int16 *)(a1 + 26)
               || !sub_10750(a1, v3) )
          {
            v3 = *(_DWORD *)v3;
            if ( v3 <= dword_EA3E4[0] )
              return;
          }
          *(_DWORD *)(a1 + 144) += *(_DWORD *)(v3 + 144);
          sub_57F10(v3);
        }
      }
    }
  }
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005FA70) --------------------------------------------------------
char __cdecl sub_5FA70(int a1)
{
  unsigned int i; // eax
  char v2; // ah
  char v3; // cl
  char v4; // dl

  LOWORD(i) = *(_WORD *)(a1 + 46);
  switch ( (__int16)i )
  {
    case 0:
      sub_11960((_WORD *)a1);
      if ( !*(_DWORD *)(a1 + 16) || sub_11A10((_WORD *)a1) )
      {
        if ( (*(_BYTE *)(a1 + 12) & 2) == 0 )
        {
          *(_WORD *)(a1 + 90) += sub_616D0(*(__int16 *)(*(_DWORD *)(dword_EA3E4[*(__int16 *)(a1 + 26)] + 164) + 56));
          *(_BYTE *)(a1 + 12) |= 2u;
        }
        LOBYTE(i) = sub_60480(a1);
      }
      else
      {
        v2 = *(_BYTE *)(a1 + 12);
        *(_WORD *)(a1 + 46) = 2;
        *(_BYTE *)(a1 + 12) = v2 & 0xBF;
        LOBYTE(i) = sub_88D00();
      }
      break;
    case 1:
    case 6:
      LOWORD(i) = sub_10C40((__int16 *)(a1 + 76));
      *(_WORD *)(a1 + 80) = i;
      break;
    case 2:
      *(_BYTE *)(a1 + 69) = 4;
      LOBYTE(i) = sub_5F890(a1, 0);
      *(_WORD *)(a1 + 46) = 0;
      break;
    case 3:
      sub_5F890(a1, 1);
      LOBYTE(i) = sub_5FBD0((__int16 *)a1);
      break;
    case 4:
      LOWORD(i) = sub_10C40((__int16 *)(a1 + 76));
      v3 = *(_BYTE *)(a1 + 62);
      *(_WORD *)(a1 + 80) = i;
      if ( (v3 & 0x1F) == 0 )
      {
        v4 = 0;
        for ( i = *(_DWORD *)(dword_D41A4 + 38535); i > dword_EA3E4[0] && !v4; i = *(_DWORD *)i )
        {
          if ( *(_BYTE *)(i + 63) == 10 && *(_BYTE *)(i + 64) == 42 )
            v4 = 1;
        }
        if ( !v4 )
          *(_WORD *)(a1 + 46) = 3;
      }
      break;
    case 5:
      sub_5F890(a1, 1);
      *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
      LOBYTE(i) = sub_5FC40(a1);
      break;
    default:
      return i;
  }
  return i;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0005FBD0) --------------------------------------------------------
int __cdecl sub_5FBD0(__int16 *a1)
{
  int result; // eax
  __int16 v2; // [esp-4h] [ebp-4h]

  result = sub_4A190((int)(a1 + 77), 10, 42);
  if ( result )
  {
    *(_BYTE *)(result + 70) = *((_BYTE *)a1 + 16);
    *(_WORD *)(result + 26) = a1[13];
    *(_WORD *)(result + 40) = ((int)a1 - dword_D41A0 - 28302) / 168;
    v2 = a1[8];
    a1[23] = 4;
    return sub_49EC0((_WORD *)result, v2);
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0005FC40) --------------------------------------------------------
int __cdecl sub_5FC40(int a1)
{
  int result; // eax
  int v2; // ebx

  result = sub_4A190(a1 + 154, 10, 41);
  v2 = result;
  if ( result )
  {
    *(_BYTE *)(result + 70) = *(_BYTE *)(a1 + 16);
    *(_WORD *)(result + 26) = *(_WORD *)(a1 + 26);
    result = (a1 - (dword_D41A0 + 28302)) / 168;
    *(_WORD *)(v2 + 40) = result;
    *(_WORD *)(a1 + 46) = 6;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0005FCA0) --------------------------------------------------------
int __cdecl sub_5FCA0(int a1)
{
  int result; // eax

  result = sub_4A810();
  if ( result )
  {
    sub_605E0(a1);
    *(_BYTE *)(a1 + 69) = 4;
    sub_5FD00(a1);
    result = sub_5FF50(a1);
    *(_WORD *)(a1 + 46) = 0;
    *(_WORD *)(a1 + 48) = 5;
  }
  else
  {
    *(_BYTE *)(a1 + 69) = 4;
  }
  return result;
}

//----- (0005FD00) --------------------------------------------------------
int __cdecl sub_5FD00(int a1)
{
  int result; // eax
  int v2; // esi
  int v3; // esi
  int v4; // eax
  int v5; // esi
  __int16 v6; // di
  unsigned __int16 v7; // ax
  int v8; // edi
  __int16 v9; // ax
  __int16 v10; // ax
  int v11; // eax
  int v12; // edi
  __int16 v13; // [esp-4h] [ebp-14h]
  int v14; // [esp+0h] [ebp-10h]
  int v15; // [esp+4h] [ebp-Ch]
  int v16; // [esp+8h] [ebp-8h]
  __int16 v17; // [esp+Ch] [ebp-4h]

  result = *(_DWORD *)(dword_EA3E4[*(__int16 *)(a1 + 26)] + 164);
  v15 = 0;
  v2 = *(_DWORD *)(a1 + 140);
  if ( *(_DWORD *)(result + 316) + *(_DWORD *)(a1 + 144) > v2 )
    v15 = *(_DWORD *)(a1 + 144) - v2;
  if ( !*(_DWORD *)(a1 + 16) )
  {
    result = *(_DWORD *)(a1 + 144);
    v15 = result;
  }
  if ( v15 > 0 )
  {
    v3 = v15 / 1000;
    v17 = sub_4A810();
    if ( v17
      || (sub_49F90(0), result = sub_4A810(), v3 = 8, v17 = result, *(_DWORD *)(dword_D41A0 + 4582) = -1, (_WORD)result) )
    {
      if ( v3 < 1 )
        v3 = 1;
      if ( v3 > 32 )
        v3 = 32;
      if ( v17 < 0 )
        v17 = 0;
      if ( v17 > v3 )
        v17 = v3;
      v14 = 0;
      v16 = v15 / v17;
      for ( result = v17; v17 > v14; result = v17 )
      {
        *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
        *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
        v4 = sub_4A190((int)&word_EB398, 10, 39);
        v5 = v4;
        if ( v4 )
        {
          *(_DWORD *)(v4 + 144) = v16;
          v6 = *(_WORD *)(v4 + 20);
          *(_WORD *)(v4 + 148) = *(_WORD *)(a1 + 26);
          *(_WORD *)(v4 + 20) = 9377 * v6 + 9439;
          v7 = *(_WORD *)(v4 + 20);
          *(_WORD *)(v5 + 154) = 0;
          *(_WORD *)(v5 + 156) = 0;
          *(_WORD *)(v5 + 130) = v7 % 0x30u + 16;
          v8 = *(__int16 *)(a1 + 80);
          v9 = sub_10C40((__int16 *)(a1 + 76));
          *(_WORD *)(v5 + 44) = (1024
                               - (v8
                                - v9)
                               - (__CFSHL__((1024 - (v8 - v9)) >> 31, 3)
                                + 8 * ((1024 - (v8 - v9)) >> 31))) >> 3;
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          v13 = *(_WORD *)(a1 + 20) % 0x1400u + 3840;
          *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
          v10 = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(a1 + 20) & 0x7FF, 0, v13);
          sub_57CF0(v10, v5, (int)&word_EB398);
          v11 = *(_DWORD *)(v5 + 144);
          v12 = v15 - v11;
          v15 = v12;
          *(_DWORD *)(a1 + 144) -= v11;
          if ( v12 < v16 )
            v16 = v12;
        }
        ++v14;
      }
    }
  }
  return result;
}
// 5FD5F: conditional instruction was optimized away because %var_C.4>=1
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (0005FF50) --------------------------------------------------------
int __cdecl sub_5FF50(int a1)
{
  int v1; // edi
  int v2; // eax
  unsigned int v3; // esi
  unsigned int v4; // eax
  unsigned int v5; // eax
  int v6; // edx
  __int64 v7; // rtt
  int v8; // eax
  int v9; // esi
  unsigned int v10; // esi
  __int16 v11; // si
  int result; // eax
  int v13; // edi
  _BYTE *v14; // esi
  __int16 v15; // ax
  int v16; // [esp+4h] [ebp-1Ch]
  int v17; // [esp+8h] [ebp-18h]
  int v18; // [esp+Ch] [ebp-14h]
  __int16 v19; // [esp+14h] [ebp-Ch] BYREF
  int v20; // [esp+18h] [ebp-8h]
  __int16 v21; // [esp+1Ch] [ebp-4h] BYREF

  v18 = dword_EA3E4[*(__int16 *)(a1 + 26)];
  v1 = 0;
  sub_60400(*(_WORD *)(a1 + 16), &v21, &v19);
  if ( v21 > 0 )
  {
    do
    {
      while ( 1 )
      {
        *(_DWORD *)(*(_DWORD *)(v18 + 164) + 302) = 0;
        v2 = *(_DWORD *)(v18 + 164);
        v16 = 2 * (__int16)v1;
        v3 = dword_EA3E4[*(unsigned __int16 *)(v16 + v2 + 60)];
        if ( v3 <= dword_EA3E4[0] )
        {
          v8 = sub_4A190(a1 + 76, 3, 3);
          v9 = v8;
          if ( v8 )
          {
            *(_WORD *)(v8 + 26) = *(_WORD *)(a1 + 26);
            *(_WORD *)(v8 + 90) += sub_616D0(*(__int16 *)(*(_DWORD *)(v18 + 164) + 56));
            *(_WORD *)(v9 + 148) = *(_WORD *)(a1 + 26);
            *(_WORD *)(v16 + *(_DWORD *)(v18 + 164) + 60) = (v9 - (dword_D41A0 + 28302)) / 168;
            *(_BYTE *)(v9 + 69) = 9;
          }
          goto LABEL_17;
        }
        if ( *(int *)(v3 + 8) >= 0 )
          break;
        sub_36BA0(v3, 0);
        sub_57F10(v3);
        *(_WORD *)(v16 + *(_DWORD *)(v18 + 164) + 60) = 0;
LABEL_17:
        if ( (__int16)++v1 >= v21 )
          goto LABEL_22;
      }
      if ( *(_DWORD *)(v2 + 316) + *(_DWORD *)(a1 + 144) >= *(_DWORD *)(a1 + 140) )
      {
        v6 = a1 - (dword_D41A0 + 28302);
        v5 = v6;
      }
      else
      {
        if ( *(unsigned __int8 *)(a1 + 62) % v21 )
          goto LABEL_13;
        if ( *(_BYTE *)(v3 + 69) != 9 )
          goto LABEL_13;
        *(_WORD *)(v3 + 150) = (a1 - (dword_D41A0 + 28302)) / 168;
        if ( *(_DWORD *)(v3 + 140) <= *(_DWORD *)(v3 + 144) )
          goto LABEL_13;
        *(_WORD *)(dword_EA3E4[0] + 150) = 0;
        v4 = sub_5F810(
               v3,
               dword_EA3E4[*(unsigned __int16 *)(dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(v18 + 164)
                                                                                 + 2 * (((__int16)v1 + 1) % 3)
                                                                                 + 60)]
                                               + 150)],
               dword_EA3E4[*(unsigned __int16 *)(dword_EA3E4[*(unsigned __int16 *)(2 * (((__int16)v1 + 2) % 3)
                                                                                 + *(_DWORD *)(v18 + 164)
                                                                                 + 60)]
                                               + 150)]);
        if ( !v4 )
          goto LABEL_13;
        v5 = v4 - (dword_D41A0 + 28302);
        v6 = v5;
      }
      LODWORD(v7) = v5;
      HIDWORD(v7) = v6 >> 31;
      *(_WORD *)(v3 + 150) = v7 / 168;
LABEL_13:
      *(_DWORD *)(*(_DWORD *)(v18 + 164) + 302) += *(_DWORD *)(v3 + 144);
      *(_DWORD *)(*(_DWORD *)(v18 + 164) + 298) += *(_DWORD *)(v3 + 140);
      ++v1;
    }
    while ( (__int16)v1 < v21 );
  }
LABEL_22:
  while ( (__int16)v1 < 3 )
  {
    v10 = dword_EA3E4[*(unsigned __int16 *)(2 * (__int16)v1 + *(_DWORD *)(v18 + 164) + 60)];
    if ( v10 > dword_EA3E4[0] )
    {
      sub_36BA0(v10, 0);
      sub_57F10(v10);
      *(_WORD *)(2 * (__int16)v1 + *(_DWORD *)(v18 + 164) + 60) = 0;
    }
    LOWORD(v1) = v1 + 1;
  }
  v11 = *(_WORD *)(a1 + 44);
  if ( v11 > 0 )
    *(_WORD *)(a1 + 44) = v11 - 1;
  v20 = 0;
  for ( result = 0; (__int16)v20 < v19; result = v20 )
  {
    v13 = 2 * (__int16)v20;
    v14 = (_BYTE *)dword_EA3E4[*(unsigned __int16 *)(v13 + *(_DWORD *)(v18 + 164) + 92)];
    if ( (unsigned int)v14 <= dword_EA3E4[0] )
    {
      if ( !*(_WORD *)(a1 + 44) )
      {
        v17 = sub_4A190(a1 + 76, 5, 15);
        if ( v17 )
        {
          *(_WORD *)(a1 + 44) = 16;
          v15 = *(_WORD *)(a1 + 26);
          *(_WORD *)(v17 + 26) = v15;
          *(_WORD *)(v17 + 148) = v15;
          *(_WORD *)(*(_DWORD *)(v18 + 164) + v13 + 92) = (v17 - (dword_D41A0 + 28302)) / 168;
          *(_WORD *)(v17 + 28) = 512;
          *(_WORD *)(v17 + 32) = *(_WORD *)(v17 + 28);
          *(_DWORD *)&word_EB398 = *(_DWORD *)(v17 + 76);
          *(&word_EB398 + 2) = *(_WORD *)(v17 + 80);
          word_EB398 += 128;
          word_EB39A += 640;
          word_EB39C = sub_10C40(&word_EB398);
          sub_57CF0(word_EB39C, v17, (int)&word_EB398);
        }
      }
    }
    else if ( v14[63] != 5 || v14[64] != 15 || v14[69] == 125 )
    {
      *(_WORD *)(*(_DWORD *)(v18 + 164) + 2 * (__int16)v20 + 92) = 0;
      *(_WORD *)(a1 + 44) = 16;
    }
    ++v20;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00060400) --------------------------------------------------------
_WORD *__cdecl sub_60400(__int16 a1, _WORD *a2, _WORD *a3)
{
  _WORD *result; // eax

  result = a3;
  switch ( a1 )
  {
    case 1:
    case 2:
      *a2 = 1;
      *a3 = 0;
      break;
    case 3:
      *a2 = 1;
      *a3 = 4;
      break;
    case 4:
      *a2 = 2;
      *a3 = 6;
      break;
    case 5:
      *a2 = 2;
      *a3 = 14;
      break;
    case 6:
      *a2 = 3;
      *a3 = 18;
      break;
    case 7:
      *a2 = 3;
      *a3 = 34;
      break;
    default:
      *a2 = 0;
      *a3 = 0;
      break;
  }
  return result;
}

//----- (00060480) --------------------------------------------------------
char __cdecl sub_60480(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // edx
  int v4; // edi
  __int16 v6; // [esp-4h] [ebp-4h]
  __int16 v7; // [esp-4h] [ebp-4h]

  v1 = sub_50370(a1 + 154);
  v2 = v1;
  if ( v1 )
  {
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 10);
    v3 = *(_DWORD *)(a1 + 16) + 1;
    *(_BYTE *)(a1 + 12) &= ~0x40u;
    *(_DWORD *)(a1 + 16) = v3;
    v6 = *(_WORD *)(a1 + 16);
    *(_BYTE *)(a1 + 69) = 5;
    *(_WORD *)(a1 + 46) = 4;
    sub_49EC0((_WORD *)a1, v6);
    v7 = *(_WORD *)(a1 + 16);
    *(_WORD *)(a1 + 82) = -8192;
    *(_WORD *)(a1 + 88) = 0x4000;
    sub_49EC0((_WORD *)v2, v7);
    v4 = dword_EA3E4[*(__int16 *)(a1 + 26)];
    *(_WORD *)(*(_DWORD *)(v4 + 164) + 58) = (a1 - (dword_D41A0 + 28302)) / 168;
    *(_WORD *)(*(_DWORD *)(v4 + 164) + 450) = *(_WORD *)(a1 + 16);
    *(_BYTE *)(*(_DWORD *)(v4 + 164) + 446) = 0;
    sub_60810(a1);
    sub_613D0(a1);
    sub_6D8B0((v4 - (dword_D41A0 + 28302)) / 168, 2u, 1);
    *(_WORD *)(v2 + 40) = (a1 - (dword_D41A0 + 28302)) / 168;
    *(_WORD *)(v2 + 26) = *(_WORD *)(a1 + 26);
    LOBYTE(v3) = *(_BYTE *)(v2 + 14);
    LOBYTE(v1) = *(_BYTE *)(a1 + 16);
    *(_BYTE *)(v2 + 59) = 0;
    *(_BYTE *)(v2 + 70) = v1;
    *(_BYTE *)(v2 + 14) = v3 | 1;
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000605E0) --------------------------------------------------------
char __cdecl sub_605E0(int a1)
{
  int v1; // esi
  int v2; // edi
  int v3; // edx
  int v4; // eax
  int v5; // edx
  char result; // al
  int v7; // esi
  __int16 v8; // dx
  __int16 v9; // [esp-Ch] [ebp-Ch]

  if ( *(int *)(a1 + 16) > 0 )
  {
    v1 = 10 * *(_DWORD *)(a1 + 140) / 100;
    *(_DWORD *)(a1 + 140) -= v1;
    sub_5FD00(a1);
    v9 = (a1 - (dword_D41A0 + 28302)) / 168;
    *(_DWORD *)(a1 + 140) += v1;
    sub_6E450(v9, -1, 30);
    v2 = dword_EA3E4[0] + 76;
    *(_DWORD *)(dword_EA3E4[0] + 76) = *(_DWORD *)(a1 + 154);
    *(_WORD *)(v2 + 4) = *(_WORD *)(a1 + 158);
    v3 = dword_EA3E4[0];
    *(_BYTE *)(dword_EA3E4[0] + 70) = *(_BYTE *)(a1 + 16);
    *(_WORD *)(v3 + 26) = *(_WORD *)(a1 + 26);
    v4 = (a1 - (dword_D41A0 + 28302)) / 168;
    v5 = dword_EA3E4[0];
    *(_BYTE *)(dword_EA3E4[0] + 64) = 0;
    *(_DWORD *)(v5 + 16) = 0;
    *(_WORD *)(v5 + 40) = v4;
    sub_385C0(v5);
    --*(_DWORD *)(a1 + 16);
    sub_49EC0((_WORD *)a1, *(_WORD *)(a1 + 16));
    *(_WORD *)(a1 + 82) = -8192;
    *(_WORD *)(a1 + 88) = 0x4000;
    sub_60810(a1);
    sub_613D0(a1);
    result = sub_5F890(a1, 1);
  }
  if ( !*(_DWORD *)(a1 + 16) )
  {
    v7 = dword_EA3E4[*(__int16 *)(a1 + 26)];
    if ( *(_BYTE *)(v7 + 64) == 1 )
    {
      if ( (*(_BYTE *)(dword_D41A0 + 196306) & 4) != 0 )
      {
        v8 = *(_WORD *)(*(_DWORD *)(v7 + 164) + 823);
        if ( v8 )
        {
          sub_57F10(dword_EA3E4[v8]);
          *(_WORD *)(*(_DWORD *)(v7 + 164) + 823) = 0;
        }
      }
    }
    else
    {
      sub_5F890(a1, *(_DWORD *)(a1 + 16));
    }
    *(_WORD *)(*(_DWORD *)(v7 + 164) + 58) = 0;
    return sub_57F10(a1);
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00060780) --------------------------------------------------------
int __cdecl sub_60780(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // edx
  int v5; // ecx
  __int16 v6; // di
  int result; // eax
  char v8; // [esp-4h] [ebp-4h]

  if ( a3 )
  {
    v4 = a1[2];
    v5 = 0;
    a1[1] = a3;
    if ( v4 < 0 )
    {
      v5 = -v4;
      if ( -v4 > a3 / 2 )
        v5 = a3 / 2;
    }
    a1[2] = a1[1] - v5;
  }
  if ( a2 )
  {
    v8 = *(_BYTE *)(a2 + 70);
    v6 = *(_WORD *)(a2 + 46);
    *(_WORD *)(a2 + 46) = 0;
    sub_6D5E0(a2, v8);
    *(_WORD *)(a2 + 46) = v6;
  }
  result = a4;
  a1[35] = a4;
  return result;
}

//----- (00060810) --------------------------------------------------------
int __cdecl sub_60810(int a1)
{
  int v1; // eax
  __int16 v2; // cx
  int v3; // edx
  int v4; // ecx
  int result; // eax
  int v6; // [esp+8h] [ebp-4h]

  v1 = dword_EA3E4[*(__int16 *)(a1 + 26)];
  if ( *(_BYTE *)(v1 + 69) <= 1u && (v2 = *(_WORD *)(*(_DWORD *)(v1 + 164) + 823)) != 0 )
    v3 = dword_EA3E4[v2];
  else
    v3 = 0;
  v4 = (*(__int16 *)(*(_DWORD *)(v1 + 164) + 586)
      * ((*(char *)(*(_DWORD *)(a1 + 16) + *(_DWORD *)(v1 + 164) + 590) << 8) + 256)) >> 8;
  result = (40000 * v4) >> 8;
  v6 = (60000 * v4) >> 8;
  switch ( *(_DWORD *)(a1 + 16) )
  {
    case 0:
      result = sub_60780((_DWORD *)a1, v3, 0, 5000);
      break;
    case 1:
      result = sub_60780((_DWORD *)a1, v3, (20000 * v4) >> 8, 8500);
      break;
    case 2:
      result = sub_60780((_DWORD *)a1, v3, (40000 * v4) >> 8, 18000);
      break;
    case 3:
      result = sub_60780((_DWORD *)a1, v3, (40000 * v4) >> 8, 38800);
      break;
    case 4:
      result = sub_60780((_DWORD *)a1, v3, v6, 78600);
      break;
    case 5:
      result = sub_60780((_DWORD *)a1, v3, v6, (int)&loc_269F8);
      break;
    case 6:
      result = sub_60780((_DWORD *)a1, v3, (80000 * v4) >> 8, 317400);
      break;
    case 7:
      result = sub_60780((_DWORD *)a1, v3, (80000 * v4) >> 8, 300000000);
      break;
    default:
      return result;
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000609E0) --------------------------------------------------------
int __cdecl sub_609E0(int a1)
{
  int v1; // esi
  int v3; // ecx
  __int16 v4; // ax
  int v5; // eax

  v1 = 0;
  if ( *(int *)(a1 + 8) < 0 )
    return 2;
  if ( *(_WORD *)(a1 + 98) )
  {
    v3 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 94);
    *(_DWORD *)(a1 + 8) = v3;
    if ( v3 < 0 )
    {
      v4 = *(_WORD *)(a1 + 98);
      *(_WORD *)(a1 + 98) = 0;
      *(_WORD *)(a1 + 36) = v4;
      return 2;
    }
    _wcpp_1_unwind_leave__100(a1, *(_DWORD *)(a1 + 94));
    *(_WORD *)(a1 + 98) = 0;
    v5 = *(__int16 *)(a1 + 26);
    *(_DWORD *)(a1 + 94) = 0;
    v1 = 1;
    *(_BYTE *)(*(_DWORD *)(dword_EA3E4[v5] + 164) + 405) = 4;
  }
  if ( *(unsigned __int16 *)(a1 + 128) == *(__int16 *)(a1 + 26) )
  {
    if ( *(int *)(a1 + 16) < 7 )
      *(_BYTE *)(a1 + 12) |= 0x40u;
    *(_WORD *)(a1 + 128) = 0;
  }
  return v1;
}
// 5FCF0: using guessed type int __cdecl _wcpp_1_unwind_leave__100(_DWORD, _DWORD);
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00060AB0) --------------------------------------------------------
int __cdecl sub_60AB0(int a1)
{
  unsigned int v1; // eax
  _WORD *v2; // esi
  char v3; // dl
  int v4; // esi
  signed int v5; // edi
  signed int v6; // eax
  unsigned int v7; // edi
  int v8; // esi
  int v9; // ecx
  __int16 *v10; // eax
  __int16 v11; // ax
  __int16 v12; // ax
  int v14; // [esp-Ch] [ebp-10h]
  int v15; // [esp-8h] [ebp-Ch]
  __int16 v16; // [esp-4h] [ebp-8h]
  int v17; // [esp+0h] [ebp-4h]

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v17 = v1;
  if ( v1 > dword_EA3E4[0] )
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v2 = (_WORD *)(v1 + 76);
    *(_WORD *)(a1 + 28) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(v1 + 76));
    v3 = *(_BYTE *)(v17 + 63);
    if ( v3 == 10 )
    {
      if ( *(unsigned __int16 *)(v17 + 148) != *(__int16 *)(a1 + 26) )
        goto LABEL_20;
      if ( byte_D41B6 )
        v4 = 2048;
      else
        v4 = 1024;
      v5 = sub_58490(&word_EB398, (_WORD *)(v17 + 76));
      if ( v5 > v4 )
      {
        *(_BYTE *)(v17 + 12) &= ~0x40u;
      }
      else
      {
        *(_BYTE *)(v17 + 12) |= 0x40u;
        *(_WORD *)(v17 + 150) = (a1 - (dword_D41A0 + 28302)) / 168;
        if ( sub_106C0(v17, a1) )
        {
          *(_DWORD *)(a1 + 144) += *(_DWORD *)(v17 + 144);
          *(_WORD *)(a1 + 148) = *(_WORD *)(v17 + 148);
          *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
          *(_WORD *)(a1 + 150) = 0;
          sub_57F10(v17);
        }
      }
      v6 = *(__int16 *)(a1 + 130);
      if ( v5 <= v6 )
      {
        word_EB398 = *(_WORD *)(v17 + 76);
        word_EB39A = *(_WORD *)(v17 + 78);
        goto LABEL_20;
      }
    }
    else
    {
      if ( v3 == 3 )
      {
        v7 = *(__int16 *)(a1 + 130) * *(_DWORD *)(v17 + 16);
        if ( sub_58490(&word_EB398, v2) <= v7 )
        {
          v8 = *(__int16 *)(*(_DWORD *)(a1 + 160) + 12);
          if ( word_EB39C <= v8 + (__int16)sub_10C40(&word_EB398) && *(int *)(v17 + 16) > 0 )
          {
            word_EB398 = *(_WORD *)(v17 + 76);
            v9 = *(_DWORD *)(v17 + 144);
            word_EB39A = *(_WORD *)(v17 + 78);
            *(_DWORD *)(v17 + 144) = *(_DWORD *)(a1 + 144) + v9;
            *(_DWORD *)(a1 + 144) = 0;
            *(_WORD *)(a1 + 148) = *(_WORD *)(a1 + 26);
            *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
          }
          goto LABEL_20;
        }
      }
      LOWORD(v6) = *(_WORD *)(a1 + 130);
    }
    sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), v6);
LABEL_20:
    if ( byte_D41B6 )
    {
      sub_60D50(&word_EB398, a1);
    }
    else
    {
      v10 = *(__int16 **)(a1 + 160);
      v16 = v10[7];
      v15 = v10[5];
      v14 = v10[6];
      v11 = sub_10C40(&word_EB398);
      v12 = sub_580E0((int)&word_EB398, v11, v14, v15, v16);
      sub_57CF0(v12, a1, (int)&word_EB398);
    }
  }
  return sub_60EA0(a1);
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00060D50) --------------------------------------------------------
int __cdecl sub_60D50(__int16 *a1, int a2)
{
  int v2; // edx
  char v3; // ch
  __int16 *v4; // edx
  __int16 v5; // ax
  int v6; // eax
  int v7; // edi
  int v8; // edx
  int v9; // edx
  int v11; // [esp-Ch] [ebp-10h]
  int v12; // [esp-8h] [ebp-Ch]
  __int16 v13; // [esp-4h] [ebp-8h]
  char v14; // [esp+0h] [ebp-4h]

  v14 = 0;
  v2 = *a1 >> 8;
  BYTE1(v2) = HIBYTE(a1[1]);
  if ( (*(_BYTE *)(a2 + 12) & 1) != 0 )
  {
    if ( (byte_13B4E0[(unsigned __int16)v2] & 8) == 0 && !sub_11E70(a2, a1) )
    {
      *(_BYTE *)(a2 + 12) &= ~1u;
      v14 = 1;
    }
    *(_WORD *)(a2 + 130) = 96;
  }
  else
  {
    if ( (byte_13B4E0[(unsigned __int16)v2] & 8) != 0 || sub_11E70(a2, a1) )
    {
      v14 = 1;
      *(_BYTE *)(a2 + 12) |= 1u;
    }
    *(_WORD *)(a2 + 130) = 48;
  }
  v3 = *(_BYTE *)(a2 + 70);
  if ( v3 )
    *(_BYTE *)(a2 + 70) = v3 - 1;
  if ( v14 && !*(_BYTE *)(a2 + 70) )
  {
    sub_6E450((a2 - (dword_D41A0 + 28302)) / 168, -1, 22);
    *(_BYTE *)(a2 + 70) = 32;
  }
  v4 = *(__int16 **)(a2 + 160);
  v13 = v4[7];
  v12 = v4[5];
  v11 = v4[6];
  v5 = sub_10C40(a1);
  LOWORD(v6) = sub_580E0((int)a1, v5, v11, v12, v13);
  if ( (*(_BYTE *)(a2 + 12) & 1) == 0 )
  {
    v7 = *(__int16 *)(a2 + 88);
    v8 = (__int16)sub_10C60(a1);
    v6 = a1[2];
    v9 = v8 - v7;
    if ( v6 > v9 )
      a1[2] = v9;
  }
  return sub_57CF0(v6, a2, (int)a1);
}
// D41A0: using guessed type int dword_D41A0;

//----- (00060EA0) --------------------------------------------------------
int __cdecl sub_60EA0(int a1)
{
  int v1; // edx
  int v3; // edx

  v1 = 0;
  if ( *(int *)(a1 + 8) < 0 )
    return 2;
  if ( *(_WORD *)(a1 + 98) )
  {
    v3 = *(_DWORD *)(a1 + 164);
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 94);
    *(_BYTE *)(v3 + 407) = 4;
    if ( *(int *)(a1 + 8) < 0 )
    {
      *(_WORD *)(a1 + 36) = *(_WORD *)(a1 + 98);
      return 2;
    }
    v1 = 1;
    *(_WORD *)(a1 + 98) = 0;
  }
  return v1;
}

//----- (00060F00) --------------------------------------------------------
char sub_60F00()
{
  unsigned __int16 v0; // bx
  int v1; // eax
  int v2; // edx
  _DWORD *v3; // eax
  unsigned int v4; // ebx

  v0 = 0;
  v1 = dword_D41A0 + 11230;
  while ( v0 < *(_WORD *)(dword_D41A0 + 14) )
  {
    v2 = dword_EA3E4[*(unsigned __int16 *)(v1 + 10)];
    *(_DWORD *)(v2 + 140) = *(_DWORD *)(*(_DWORD *)(v2 + 164) + 336);
    v1 += 2124;
    ++v0;
    *(_DWORD *)(*(_DWORD *)(v2 + 164) + 316) = 0;
  }
  v3 = (_DWORD *)dword_D41A4;
  v4 = dword_EA3E8;
  *(_DWORD *)(dword_D41A4 + 246) = 1;
  *(_DWORD *)((char *)v3 + 250) = 0;
  if ( v4 < dword_EB384 )
  {
    while ( 1 )
    {
      LOBYTE(v3) = *(_BYTE *)(v4 + 63);
      if ( (unsigned __int8)v3 < 5u )
        break;
      if ( (unsigned __int8)v3 <= 5u )
        goto LABEL_22;
      if ( (_BYTE)v3 != 10 )
        goto LABEL_23;
      LOBYTE(v3) = *(_BYTE *)(v4 + 64);
      if ( (unsigned __int8)v3 < 0x2Du )
      {
        if ( (_BYTE)v3 == 39 )
          goto LABEL_22;
      }
      else
      {
        if ( (unsigned __int8)v3 <= 0x2Du )
        {
          LOWORD(v3) = sub_61000(v4);
          if ( v3 && v3[41] )
          {
            v3 = (_DWORD *)v3[41];
            v3[79] += *(_DWORD *)(v4 + 144);
          }
          goto LABEL_23;
        }
        if ( (_BYTE)v3 == 58 )
          goto LABEL_22;
      }
LABEL_23:
      v4 += 168;
      if ( v4 >= dword_EB384 )
        return (char)v3;
    }
    if ( (_BYTE)v3 != 3 )
      goto LABEL_23;
    LOBYTE(v3) = *(_BYTE *)(v4 + 64);
    if ( (unsigned __int8)v3 < 2u || (unsigned __int8)v3 >= 4u )
      goto LABEL_23;
LABEL_22:
    LOBYTE(v3) = sub_61000(v4);
    goto LABEL_23;
  }
  return (char)v3;
}
// 60FCA: variable 'v3' is possibly undefined
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// EA3E8: using guessed type int dword_EA3E8;
// EB384: using guessed type int dword_EB384;

//----- (00061000) --------------------------------------------------------
__int16 __cdecl sub_61000(int a1)
{
  int v1; // eax

  v1 = 0;
  if ( *(_WORD *)(a1 + 148) )
  {
    LOWORD(v1) = *(_WORD *)(a1 + 148);
    v1 = dword_EA3E4[v1];
    *(_DWORD *)(v1 + 140) += *(_DWORD *)(a1 + 144);
  }
  *(_DWORD *)(dword_D41A4 + 246) += *(_DWORD *)(a1 + 144);
  return v1;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00061050) --------------------------------------------------------
unsigned int __cdecl sub_61050(unsigned int a1)
{
  unsigned __int16 v1; // ax
  unsigned int v2; // edx
  char *v3; // edx
  char v4; // dl
  int v5; // eax
  unsigned int v6; // ebx
  unsigned int v7; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // edx
  int v11; // edx
  int v12; // ecx
  __int16 v13; // si
  unsigned __int16 v14; // si
  __int16 v15; // ax
  int v16; // eax
  int v17; // ebx
  __int16 v18; // ax
  __int16 v19; // si
  unsigned __int16 v20; // ax
  int v21; // esi
  int v22; // esi
  int v23; // ebx
  unsigned int result; // eax
  __int16 v25; // [esp-4h] [ebp-2Ch]
  int v26; // [esp+0h] [ebp-28h] BYREF
  __int16 v27; // [esp+4h] [ebp-24h]
  int *v28; // [esp+8h] [ebp-20h]
  unsigned int v29; // [esp+Ch] [ebp-1Ch]
  int v30; // [esp+10h] [ebp-18h]
  int v31; // [esp+14h] [ebp-14h]
  char *v32; // [esp+18h] [ebp-10h]
  int v33; // [esp+1Ch] [ebp-Ch]
  _DWORD *v34; // [esp+20h] [ebp-8h]
  char v35; // [esp+24h] [ebp-4h]

  v33 = 0;
  v35 = 0;
  v1 = *(_WORD *)(a1 + 116);
  v2 = dword_EA3E4[v1];
  v34 = (_DWORD *)v2;
  if ( v2 < dword_EA3E4[0] )
    goto LABEL_35;
  if ( *(_BYTE *)(v2 + 63) == 3 )
  {
    sub_6D8B0(v1, 0xDu, 1);
    v3 = (char *)&unk_DAC2A + 26 * *(_DWORD *)(a1 + 112);
    v28 = (int *)&unk_DAC44;
    v32 = v3;
    v4 = v3[24];
    if ( v4 )
    {
      if ( (unsigned __int8)v4 > 2u )
        goto LABEL_23;
      v6 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(a1 + 164) + 58)];
      v7 = dword_EA3E4[*(unsigned __int16 *)(v34[41] + 58)];
      v31 = v7;
      if ( v6 <= dword_EA3E4[0] || v7 <= dword_EA3E4[0] || (v8 = *(_DWORD *)(v6 + 144), v8 <= 0) )
      {
        v35 = 1;
      }
      else
      {
        v9 = v8 * *(_DWORD *)v32 / 100;
        v10 = v31;
        *(_DWORD *)(v6 + 144) = v8 - v9;
        v11 = *(__int16 *)(v10 + 84) * *(__int16 *)(v10 + 84);
        v33 = v9;
        v29 = sub_7277A(v11 + *(__int16 *)(v31 + 86) * *(__int16 *)(v31 + 86));
        while ( v33 > 0 )
        {
          if ( v33 <= 500 )
            v30 = v33;
          else
            v30 = 500;
          v12 = v33 - v30;
          v26 = *(_DWORD *)(v31 + 76);
          v27 = *(_WORD *)(v31 + 80);
          v13 = 9377 * *(_WORD *)(a1 + 20) + 9439;
          *(_WORD *)(a1 + 20) = v13;
          v14 = v13 & 0x7FF;
          v33 = v12;
          sub_57FA0(&v26, v14, 0, v29);
          v15 = sub_10C40((__int16 *)&v26);
          HIBYTE(v15) += 4;
          v27 = v15;
          v16 = sub_4A190((int)&v26, 10, 39);
          v17 = v16;
          if ( v16 )
          {
            *(_WORD *)(v16 + 20) = 9377 * *(_WORD *)(v16 + 20) + 9439;
            v18 = (v14 + *(_WORD *)(v16 + 20) % 0x71u - 56) & 0x7FF;
            v19 = *(_WORD *)(v17 + 20);
            *(_WORD *)(v17 + 28) = v18;
            *(_WORD *)(v17 + 20) = 9377 * v19 + 9439;
            *(_WORD *)(v17 + 130) = *(_WORD *)(v17 + 20) % 0x30u + 16;
            v25 = *(_WORD *)(v17 + 130);
            v20 = *(_WORD *)(v17 + 28);
            *(_WORD *)(v17 + 154) = 0;
            *(_WORD *)(v17 + 156) = 0;
            *(_WORD *)(v17 + 44) = 128;
            sub_57FA0((_WORD *)(v17 + 154), v20, 0, v25);
            *(_DWORD *)(v17 + 144) = v30;
            if ( v32[24] == 2 )
              *(_WORD *)(v17 + 148) = ((int)v34 - dword_D41A0 - 28302) / 168;
            else
              *(_WORD *)(v17 + 148) = 0;
          }
        }
      }
      if ( !v35 )
        goto LABEL_23;
      v5 = *v28;
    }
    else
    {
      v5 = *(_DWORD *)v32;
      v35 = 1;
    }
    v33 = v5;
  }
LABEL_23:
  if ( v35 )
  {
    v21 = v33;
    if ( v33 )
    {
      v34[36] += v33;
      *(_DWORD *)(a1 + 144) -= v21;
    }
  }
  if ( (int)v34[36] < 0 )
    v34[36] = 0;
  v22 = v34[35];
  if ( v34[36] > v22 )
    v34[36] = v22;
  if ( *(int *)(a1 + 144) < 0 )
    *(_DWORD *)(a1 + 144) = 0;
  v23 = *(_DWORD *)(a1 + 140);
  if ( *(_DWORD *)(a1 + 144) > v23 )
    *(_DWORD *)(a1 + 144) = v23;
  *(_BYTE *)(*(_DWORD *)(a1 + 164) + 406) = 4;
  *(_DWORD *)(*(_DWORD *)(a1 + 164) + 397) = 16;
  *(_WORD *)(*(_DWORD *)(a1 + 164) + 588) = 64;
LABEL_35:
  sub_5EF70(a1);
  result = a1;
  *(_WORD *)(a1 + 116) = 0;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000613D0) --------------------------------------------------------
__int16 __cdecl sub_613D0(int a1)
{
  int i; // eax
  int v2; // ebx
  __int16 v3; // dx
  int v4; // esi
  int v5; // edx
  int v6; // ebx
  int v7; // ebx
  int v8; // edx
  int v9; // ebx
  __int16 v10; // ax
  char *v12; // [esp+0h] [ebp-24h]
  int v13; // [esp+4h] [ebp-20h]
  int v14; // [esp+8h] [ebp-1Ch]
  int v15; // [esp+Ch] [ebp-18h]
  char v16; // [esp+10h] [ebp-14h]
  int v17; // [esp+14h] [ebp-10h]
  int v18; // [esp+18h] [ebp-Ch]
  unsigned __int8 v19; // [esp+1Ch] [ebp-8h]
  unsigned __int8 v20; // [esp+20h] [ebp-4h]

  for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v2 + 52) )
  {
    v2 = dword_EA3E4[i];
    if ( v2 == dword_EA3E4[0] )
      break;
    sub_57F20(i, dword_EA3E4[i]);
  }
  v3 = *(_WORD *)(a1 + 26);
  *(_WORD *)(a1 + 52) = 0;
  if ( v3 && *(_DWORD *)(a1 + 16) )
  {
    LOWORD(i) = v3;
    v4 = *(_DWORD *)(a1 + 16);
    v5 = dword_EA3E4[v3];
    while ( v4 > 0 )
    {
      LOWORD(i) = *(char *)(v4 + *(_DWORD *)(v5 + 164) + 599);
      v16 = *(_BYTE *)(v4 + *(_DWORD *)(v5 + 164) + 599);
      if ( v16 )
        break;
      --v4;
    }
    if ( v4 )
    {
      v6 = 6 * v4;
      i = word_180660 == 1
        ? (int)*(unsigned __int8 *)(v6 + dword_EA3BC + 4) >> 1
        : *(unsigned __int8 *)(v6 + dword_EA3BC + 4);
      v7 = 6 * v4;
      v8 = word_180660 == 1
         ? (int)*(unsigned __int8 *)(v7 + dword_EA3BC + 5) >> 1
         : *(unsigned __int8 *)(v7 + dword_EA3BC + 5);
      v20 = ((unsigned __int16)(*(_WORD *)(a1 + 76) + 128) >> 8) - (i >> 1);
      v19 = ((unsigned __int16)(*(_WORD *)(a1 + 78) + 128) >> 8) - (v8 >> 1);
      v15 = 0;
      v13 = (unsigned __int8)byte_DB038[2 * v4];
      v18 = a1;
      v12 = (char *)&unk_DB04A + 2 * (unsigned __int8)byte_DB039[2 * v4];
      LOWORD(i) = 0;
      if ( byte_DB038[2 * v4] )
      {
        do
        {
          word_EB398 = (v20 + *v12) << 8;
          word_EB39A = (v19 + v12[1]) << 8;
          i = sub_4A190((int)&word_EB398, 10, 79);
          v9 = i;
          v17 = i;
          if ( !i )
            break;
          v14 = dword_D41A0 + 28302;
          *(_WORD *)(i + 50) = (v18 - (dword_D41A0 + 28302)) / 168;
          *(_WORD *)(v18 + 52) = (i - v14) / 168;
          *(_WORD *)(i + 52) = 0;
          *(_WORD *)(i + 26) = *(_WORD *)(a1 + 26);
          *(_BYTE *)(i + 67) = v16;
          *(_WORD *)(i + 74) = v4;
          v10 = sub_10C40((__int16 *)(i + 76));
          *(_WORD *)(v9 + 80) = v10;
          *(_WORD *)(v9 + 80) = v4 <= 1 ? v10 + 384 : v10 + 224;
          v18 = v17;
          ++v15;
          v12 += 2;
          LOWORD(i) = v15;
        }
        while ( v15 < v13 );
      }
    }
  }
  return i;
}
// 615B3: variable 'v16' is possibly undefined
// D41A0: using guessed type int dword_D41A0;
// EA3BC: using guessed type int dword_EA3BC;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// 180660: using guessed type __int16 word_180660;

//----- (00061620) --------------------------------------------------------
char __cdecl sub_61620(int a1, int a2)
{
  void (__noreturn *v2)(); // edi
  unsigned int v3; // esi
  unsigned int i; // ebx
  signed int v5; // eax
  char v7; // [esp+0h] [ebp-4h]

  v2 = sub_10000;
  v3 = 0;
  v7 = 0;
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
  {
    if ( !*(_BYTE *)(i + 64) && i != a1 )
    {
      v5 = sub_61810(a1, i);
      if ( v5 )
      {
        if ( v5 < (int)v2 )
        {
          v2 = (void (__noreturn *)())v5;
          v3 = i;
        }
      }
    }
  }
  if ( v3 == a2 )
    return 1;
  return v7;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000616D0) --------------------------------------------------------
int __cdecl sub_616D0(unsigned int a1)
{
  int result; // eax

  result = 0;
  if ( a1 <= 7 )
  {
    if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
    {
      switch ( *(_BYTE *)(2124 * a1 + dword_D41A0 + 12676) )
      {
        case 0:
LABEL_4:
          result = 0;
          break;
        case 1:
LABEL_6:
          result = 4;
          break;
        case 2:
LABEL_5:
          result = 1;
          break;
        case 3:
LABEL_8:
          result = 2;
          break;
        case 4:
LABEL_9:
          result = 5;
          break;
        case 5:
        case 7:
LABEL_12:
          result = 7;
          break;
        case 6:
LABEL_7:
          result = 3;
          break;
        default:
          return result;
      }
    }
    else
    {
      switch ( a1 )
      {
        case 0u:
          goto LABEL_4;
        case 1u:
          goto LABEL_5;
        case 2u:
          goto LABEL_6;
        case 3u:
          goto LABEL_7;
        case 4u:
          goto LABEL_8;
        case 5u:
          goto LABEL_9;
        case 6u:
          goto LABEL_12;
        case 7u:
          result = 6;
          break;
        default:
          return result;
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00061790) --------------------------------------------------------
int __cdecl sub_61790(int a1)
{
  int result; // eax

  result = a1;
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
  {
    switch ( *(_BYTE *)(2124 * a1 + dword_D41A0 + 12676) )
    {
      case 0:
        result = 0;
        break;
      case 1:
        result = 2;
        break;
      case 2:
        result = 1;
        break;
      case 3:
        result = 4;
        break;
      case 4:
        result = 5;
        break;
      case 5:
        result = 6;
        break;
      case 6:
        result = 3;
        break;
      case 7:
        result = 7;
        break;
      default:
        return result;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (00061810) --------------------------------------------------------
signed int __cdecl sub_61810(int a1, int a2)
{
  int v2; // ebx
  signed int v3; // esi
  __int16 v4; // ax

  v2 = 0;
  v3 = sub_583F0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
  if ( v3 < 5376 )
  {
    v4 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
    if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v4) < 0x100u )
      return v3;
  }
  return v2;
}

//----- (00061880) --------------------------------------------------------
char *__cdecl sub_61880(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8)
{
  if ( *(_BYTE *)(dword_D41A0 + 8592) == 1 )
    return sub_627F0(a1, a2, a3, a4, a5, a6, a7, a8);
  else
    return sub_61A00(a1, a2, a3, a4, a5, a6, a7, a8);
}
// D41A0: using guessed type int dword_D41A0;

//----- (00061A00) --------------------------------------------------------
char *__cdecl sub_61A00(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8)
{
  int v8; // edx
  int v9; // esi
  int v10; // ebx
  unsigned __int8 v11; // al
  __int64 v12; // rtt
  int v13; // ebx
  int v14; // edx
  int v15; // ebx
  __int16 v16; // dx
  int v17; // ebx
  int v18; // eax
  int v19; // edx
  int v20; // esi
  int v21; // edi
  int v22; // edx
  int v23; // eax
  int v24; // edx
  int v25; // ebx
  int v26; // eax
  int v27; // ebx
  unsigned int v28; // ebx
  unsigned __int8 v29; // al
  unsigned __int8 v30; // ah
  unsigned __int16 v31; // si
  int v32; // eax
  char v33; // al
  char v34; // al
  int v35; // eax
  unsigned __int16 v36; // si
  char v37; // al
  unsigned __int8 v38; // ah
  int v39; // eax
  unsigned __int8 v40; // al
  char v41; // al
  char v42; // dl
  char v43; // al
  unsigned __int8 v44; // ah
  __int16 v45; // ax
  int v46; // edx
  int v47; // ecx
  int v48; // esi
  int v49; // edi
  char *v50; // edx
  int v51; // ecx
  char *v52; // edx
  int v53; // eax
  int v54; // ebx
  int v55; // edx
  int v56; // eax
  int v57; // esi
  int v58; // edi
  unsigned __int8 v59; // al
  int v60; // esi
  _BYTE *v61; // ebx
  char *result; // eax
  _BYTE *v63; // edx
  int v64; // ecx
  int v65; // [esp+0h] [ebp-60h]
  unsigned __int8 *v66; // [esp+4h] [ebp-5Ch]
  int v67; // [esp+8h] [ebp-58h]
  int v68; // [esp+Ch] [ebp-54h]
  signed int v69; // [esp+10h] [ebp-50h]
  int v70; // [esp+14h] [ebp-4Ch]
  _BYTE *v71; // [esp+18h] [ebp-48h]
  int v72; // [esp+1Ch] [ebp-44h]
  int v73; // [esp+20h] [ebp-40h]
  int v74; // [esp+24h] [ebp-3Ch]
  _BYTE *v75; // [esp+28h] [ebp-38h]
  int v76; // [esp+2Ch] [ebp-34h]
  int v77; // [esp+30h] [ebp-30h]
  int v78; // [esp+34h] [ebp-2Ch]
  int v79; // [esp+38h] [ebp-28h]
  int v80; // [esp+38h] [ebp-28h]
  int v81; // [esp+3Ch] [ebp-24h]
  unsigned __int16 v82; // [esp+40h] [ebp-20h]
  unsigned __int16 v83; // [esp+44h] [ebp-1Ch]
  char v84; // [esp+48h] [ebp-18h]
  char v85; // [esp+4Ch] [ebp-14h]
  char v86; // [esp+50h] [ebp-10h]
  char v87; // [esp+54h] [ebp-Ch]
  unsigned __int8 v88; // [esp+58h] [ebp-8h]
  char v89; // [esp+5Ch] [ebp-4h]

  v8 = a1;
  v9 = a2;
  v10 = a8;
  v11 = *(_BYTE *)(dword_D41A0 + 196308);
  v77 = 0;
  if ( v11 )
  {
    if ( v11 <= 1u )
    {
      v87 = byte_E98FF;
      v88 = byte_E98FF;
      v86 = -24;
      v85 = -124;
    }
    else if ( v11 == 2 )
    {
      v87 = byte_E98FF;
      v88 = byte_E98FF;
      v86 = 28;
      v85 = byte_E89F0;
    }
  }
  else
  {
    v87 = byte_E8900[0];
    v88 = byte_E8900[0];
    v86 = -24;
    v85 = 28;
  }
  if ( (word_180660 & 1) != 0 )
  {
    v8 = a1 >> 1;
    v9 = a2 >> 1;
    v10 = 2 * a8;
    a5 >>= 1;
    a6 >>= 1;
  }
  v78 = v9 * dword_18062C + dword_180628 + v8;
  LODWORD(v12) = sub_10000;
  HIDWORD(v12) = (int)sub_10000 >> 31;
  v13 = v12 / v10;
  v76 = a5 / 2;
  v14 = v13 * dword_DB750[a7 & 0x7FF];
  v70 = a6 / 2;
  v15 = (_DWORD)off_DBF50[a7 & 0x7FF] * v13;
  v81 = -v14 >> 16;
  sub_6FC50(byte_D419D);
  v67 = v15 >> 16;
  v74 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v16 = *(_WORD *)(*(_DWORD *)(v74 + 164) + 843);
  if ( v16 )
    v77 = *(__int16 *)(dword_EA3E4[v16] + 46);
  v17 = *(_DWORD *)(v74 + 164);
  if ( *(_WORD *)(v17 + 58) )
  {
    v18 = (__int16)(*(_WORD *)(v74 + 76) - a3);
    v19 = (__int16)(*(_WORD *)(v74 + 78) - a4);
    v20 = v76 + ((v18 * v67 - v19 * v81) >> 16);
    v21 = ((v67 * v19 + v81 * v18) >> 16) + v70;
    v22 = dword_EA3E4[*(unsigned __int16 *)(v17 + 58)];
    v23 = (__int16)(*(_WORD *)(v22 + 76) - a3);
    v24 = (__int16)(*(_WORD *)(v22 + 78) - a4);
    v25 = v76 + ((v23 * v67 - v24 * v81) >> 16);
    v79 = ((v67 * v24 + v81 * v23) >> 16) + v70;
    v69 = sub_7277A((v25 - v20) * (v25 - v20) + (v79 - v21) * (v79 - v21));
    v65 = (unsigned __int16)sub_72633(v25 - v20, v79 - v21);
    v26 = *(_DWORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248) & 3;
    while ( 1 )
    {
      v26 += 4;
      if ( v26 > v69 )
        break;
      v27 = v20 + ((v26 * dword_DB750[v65]) >> 16);
      v80 = v21 + ((-v26 * (int)off_DBF50[v65]) >> 16);
      if ( v27 < 0 || v27 >= a5 || v80 < 0 || v80 >= a6 || v27 < word_F4962[2 * v80] || v27 >= word_F4960[2 * v80] )
        break;
      *(_BYTE *)(v78 + v27 + dword_18062C * v80) = byte_FAEE0[256 * *(unsigned __int8 *)(v78 + v27 + dword_18062C * v80)
                                                            + (unsigned __int8)byte_E98FF];
    }
  }
  v28 = dword_D41A0 + 28470;
  while ( v28 < dword_D41A0 + 196302 )
  {
    v29 = 0;
    v84 = 0;
    v72 = 1;
    v83 = 0;
    switch ( *(_BYTE *)(v28 + 63) )
    {
      case 2:
        switch ( *(_BYTE *)(v28 + 64) )
        {
          case 0:
            if ( *(_BYTE *)(v28 + 69) != 2 )
              goto LABEL_72;
            v89 = v85;
            v29 = 0;
            break;
          case 1:
            v29 = 1;
            if ( *(_BYTE *)(dword_D41A4 + 124) )
              v89 = byte_E8988;
            else
              v84 = 1;
            v83 = 27;
            break;
          case 2:
            if ( *(_BYTE *)(dword_D41A4 + 123) )
              v37 = byte_E9188;
            else
              v37 = v85;
            v89 = v37;
            v29 = 1;
            v83 = 22;
            break;
          case 3:
            goto LABEL_117;
          default:
LABEL_72:
            v34 = v85;
            goto LABEL_115;
        }
        goto LABEL_117;
      case 3:
        v44 = *(_BYTE *)(v28 + 64);
        if ( v44 >= 2u )
        {
          if ( v44 <= 2u )
          {
            LOBYTE(v45) = *(_WORD *)(v28 + 26) != *(_WORD *)(v74 + 26);
            HIBYTE(v45) = 0;
            v83 = v45 + 24;
            v29 = sub_616D0(*(__int16 *)(*(_DWORD *)(dword_EA3E4[*(__int16 *)(v28 + 26)] + 164) + 56)) + 58;
          }
          else if ( v44 == 3 )
          {
            if ( *(_WORD *)(v28 + 26) == *(_WORD *)(v74 + 26) || v77 )
              v29 = sub_616D0(*(__int16 *)(*(_DWORD *)(dword_EA3E4[*(__int16 *)(v28 + 26)] + 164) + 56)) + 66;
            if ( *(_WORD *)(v28 + 26) == *(_WORD *)(v74 + 26) )
            {
              v83 = 23;
            }
            else if ( v77 )
            {
              v83 = 26;
            }
          }
        }
        goto LABEL_117;
      case 5:
        v38 = *(_BYTE *)(v28 + 69);
        if ( v38 >= 0xB4u && (v38 <= 0xB4u || v38 >= 0xE8u && v38 <= 0xEAu) || (*(_BYTE *)(v28 + 12) & 1) != 0 )
          goto LABEL_117;
        v39 = *(__int16 *)(v28 + 26);
        if ( v39 != (int)(v28 - (dword_D41A0 + 28302)) / 168 )
        {
          v41 = byte_E88E1[3 * sub_61790(*(__int16 *)(*(_DWORD *)(dword_EA3E4[v39] + 164) + 56))];
          goto LABEL_96;
        }
        v40 = *(_BYTE *)(v28 + 64);
        if ( v40 >= 0xCu )
        {
          if ( v40 <= 0xEu )
          {
            v41 = byte_E890F;
LABEL_96:
            v89 = v41;
            goto LABEL_116;
          }
          if ( v40 == 22 )
          {
            if ( *(unsigned __int16 *)(v28 + 148) != *(__int16 *)(v74 + 26) )
              v83 = 18;
            v41 = v87;
            goto LABEL_96;
          }
        }
        v42 = *(_BYTE *)(v28 + 73);
        v89 = v87;
        v43 = 1;
        if ( (v42 == 14 || v42 == 13) && *(unsigned __int16 *)(v28 + 40) == *(__int16 *)(v74 + 26) )
          v43 = 0;
        if ( v43 )
          v83 = 19;
        goto LABEL_116;
      case 9:
        goto LABEL_53;
      case 0xA:
        v30 = *(_BYTE *)(v28 + 64);
        if ( v30 < 0x27u )
        {
          if ( v30 >= 0x12u )
          {
            if ( v30 <= 0x12u )
              goto LABEL_117;
            if ( v30 == 34 )
              v72 = 2;
          }
          goto LABEL_53;
        }
        if ( v30 <= 0x27u )
          goto LABEL_43;
        if ( v30 < 0x39u )
        {
          if ( v30 != 45 )
            goto LABEL_53;
          v36 = *(_WORD *)(v28 + 148);
          if ( v36 )
          {
            v35 = dword_EA3E4[v36];
            if ( *(_BYTE *)(v35 + 63) == 3 )
            {
              if ( !*(_BYTE *)(dword_D41A4 + 124) )
              {
                v34 = byte_E88E1[3 * sub_61790(*(__int16 *)(*(_DWORD *)(v35 + 164) + 56))];
                goto LABEL_115;
              }
LABEL_54:
              v34 = byte_E88E0[3 * sub_61790(*(__int16 *)(*(_DWORD *)(v35 + 164) + 56))];
LABEL_115:
              v89 = v34;
              goto LABEL_116;
            }
          }
          if ( (byte_D93C2[4 * *(char *)(v28 + 70)] & 8) == 0 )
            v83 = 21;
LABEL_53:
          v35 = dword_EA3E4[*(__int16 *)(v28 + 26)];
          if ( *(_BYTE *)(v35 + 63) != 3 )
          {
            v34 = byte_E980F;
            goto LABEL_115;
          }
          goto LABEL_54;
        }
        if ( v30 <= 0x39u )
        {
LABEL_43:
          v31 = *(_WORD *)(v28 + 148);
          if ( v31 && (v32 = dword_EA3E4[v31], *(_BYTE *)(v32 + 63) == 3) )
          {
            if ( *(_BYTE *)(dword_D41A4 + 124) )
              v33 = byte_E88E0[3 * sub_61790(*(__int16 *)(*(_DWORD *)(v32 + 164) + 56))];
            else
              v33 = byte_E88E1[3 * sub_61790(*(__int16 *)(*(_DWORD *)(v32 + 164) + 56))];
            v89 = v33;
          }
          else
          {
            v89 = v86;
            v83 = 18;
          }
LABEL_116:
          v29 = 1;
        }
        else
        {
          if ( v30 < 0x4Eu )
            goto LABEL_53;
          if ( v30 <= 0x4Eu )
          {
            if ( *(_WORD *)(v28 + 50) != *(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240) )
              goto LABEL_117;
            v34 = byte_E88E0[3 * sub_61790(*(__int16 *)(*(_DWORD *)(v74 + 164) + 56))
                           + *(unsigned __int8 *)(dword_D41A4 + 124)];
            goto LABEL_115;
          }
          if ( v30 < 0x56u || v30 > 0x57u )
            goto LABEL_53;
        }
LABEL_117:
        if ( v29 )
        {
          v46 = (__int16)(*(_WORD *)(v28 + 76) - a3);
          v47 = (__int16)(*(_WORD *)(v28 + 78) - a4);
          v48 = v76 + ((v46 * v67 - v47 * v81) >> 16);
          if ( v48 >= 0 && v48 < a5 )
          {
            v49 = ((v67 * v47 + v81 * v46) >> 16) + v70;
            if ( v49 >= 0 && v49 < a6 && v48 >= word_F4962[2 * v49] && v48 < word_F4960[2 * v49] )
            {
              v50 = (char *)(v48 + v78 + v49 * dword_18062C);
              if ( !v84 )
              {
                if ( v29 <= 1u )
                {
                  *v50 = v89;
                  if ( v72 > 1 )
                  {
                    v51 = dword_18062C;
                    v50[1] = v89;
                    v52 = &v50[v51];
                    *v52 = v89;
                    v52[1] = v89;
                  }
                }
                else if ( word_180660 == 1 )
                {
                  if ( v29 < 0x42u || v29 >= 0x4Au )
                  {
                    if ( v29 < 0x3Au || v29 >= 0x42u )
                    {
                      if ( v29 == 83 || v29 == 84 )
                        sub_2BB40(
                          2 * v48 - *(unsigned __int8 *)(6 * v29 + dword_EA3DC + 4) / 2,
                          2 * v49 - ((int)*(unsigned __int8 *)(6 * v29 + dword_EA3DC + 5) >> 1),
                          6 * v29 + dword_EA3DC);
                    }
                    else
                    {
                      sub_2BB40(
                        2 * v48,
                        2 * v49 - *(unsigned __int8 *)(6 * v29 + dword_EA3DC + 5),
                        6 * v29 + dword_EA3DC);
                    }
                  }
                  else
                  {
                    sub_2BB40(
                      2 * v48 - *(unsigned __int8 *)(6 * v29 + dword_EA3DC + 4) / 2,
                      2 * v49 - *(unsigned __int8 *)(6 * v29 + dword_EA3DC + 5),
                      6 * v29 + dword_EA3DC);
                  }
                }
                else if ( v29 >= 0x3Cu )
                {
                  sub_2BB40(
                    v48 - ((int)*(unsigned __int8 *)(6 * v29 + dword_EA3DC + 4) >> 1),
                    v49 - *(unsigned __int8 *)(6 * v29 + dword_EA3DC + 5),
                    6 * v29 + dword_EA3DC);
                }
                else
                {
                  sub_2BB40(v48, v49 - *(unsigned __int8 *)(6 * v29 + dword_EA3DC + 5), 6 * v29 + dword_EA3DC);
                }
              }
              if ( v83 )
                sub_885E0(v28, v48, v49, v83);
            }
          }
        }
        v28 += 168;
        break;
      case 0xB:
        switch ( *(_BYTE *)(v28 + 64) )
        {
          case 0xC:
            v29 = 83;
            v83 = 83;
            break;
          case 0x1F:
            v29 = 84;
            v83 = 83;
            break;
          default:
            goto LABEL_117;
        }
        goto LABEL_117;
      case 0xC:
      case 0xF:
        if ( (*(_BYTE *)(v28 + 12) & 1) != 0 )
          goto LABEL_117;
        v34 = byte_E9800;
        v83 = 20;
        goto LABEL_115;
      case 0xE:
        if ( *(_BYTE *)(v28 + 64) != 5 )
          goto LABEL_117;
        if ( *(_BYTE *)(dword_D41A4 + 124) )
          v34 = byte_E9800;
        else
          v34 = byte_E98FF;
        goto LABEL_115;
      default:
        goto LABEL_117;
    }
  }
  if ( v77 )
  {
    v82 = 0;
    v68 = dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12) + 11240)];
    while ( v82 < *(_WORD *)(dword_D41A0 + 14) )
    {
      if ( v82 != *(__int16 *)(dword_D41A0 + 12) )
      {
        v73 = 2124 * v82;
        v53 = *(unsigned __int16 *)(v73 + dword_D41A0 + 11240);
        v54 = dword_EA3E4[v53];
        if ( *(int *)(v54 + 8) >= 0 )
        {
          if ( sub_63570(v68, dword_EA3E4[v53]) )
          {
            v55 = (__int16)(*(_WORD *)(v54 + 76) - a3);
            v56 = (__int16)(*(_WORD *)(v54 + 78) - a4);
            v57 = v76 + ((v55 * v67 - v56 * v81) >> 16);
            if ( v57 >= 0 && v57 < a5 )
            {
              v58 = v70 + ((v81 * v55 + v67 * v56) >> 16);
              if ( v58 >= 0 && v58 < a6 && v57 >= word_F4962[2 * v58] && v57 < word_F4960[2 * v58] )
              {
                v66 = (unsigned __int8 *)(v58 * dword_18062C + v57 + v78);
                v59 = byte_E88E0[3 * sub_61790(*(__int16 *)(*(_DWORD *)(v54 + 164) + 56))];
                *v66 = v59;
                if ( word_180660 == 1 )
                  sub_2BC10((_BYTE *)(v73 + dword_D41A0 + 11230 + 927), 2 * v57 + 4, 2 * v58, v59);
                else
                  sub_2BC10((_BYTE *)(v73 + dword_D41A0 + 11230 + 927), v57 + 4, v58, v59);
              }
            }
          }
        }
      }
      ++v82;
    }
  }
  v60 = a5 / 12;
  v61 = (_BYTE *)(dword_18062C * (a6 / 2) + a5 / 2 + v78 - 1);
  result = &byte_FAEE0[256 * v88];
  v63 = v61;
  v71 = v61;
  v75 = v61;
  for ( *v61 = result[(unsigned __int8)*v61]; v60; *v61 = result[v64] )
  {
    v75 -= dword_18062C;
    v63 += dword_18062C;
    ++v71;
    *v75 = result[(unsigned __int8)*v75];
    *v71 = result[(unsigned __int8)*v71];
    *v63 = result[(unsigned __int8)*v63];
    v64 = (unsigned __int8)*--v61;
    --v60;
  }
  return result;
}
// 61E49: variable 'v86' is possibly undefined
// 61FCF: variable 'v85' is possibly undefined
// 620A8: variable 'v87' is possibly undefined
// 62429: variable 'v89' is possibly undefined
// 62675: variable 'v88' is possibly undefined
// 10000: using guessed type void __noreturn sub_10000();
// D419D: using guessed type char byte_D419D;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// DB750: using guessed type int dword_DB750[256];
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// E890F: using guessed type char byte_E890F;
// E8988: using guessed type char byte_E8988;
// E89F0: using guessed type char byte_E89F0;
// E9188: using guessed type char byte_E9188;
// E9800: using guessed type char byte_E9800;
// E980F: using guessed type char byte_E980F;
// E98FF: using guessed type char byte_E98FF;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// F4960: using guessed type __int16 word_F4960[];
// F4962: using guessed type __int16 word_F4962[831];
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (000627F0) --------------------------------------------------------
char *__cdecl sub_627F0(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8)
{
  int v8; // edx
  int v9; // esi
  int v10; // ebx
  unsigned __int8 v11; // al
  char v12; // al
  __int64 v13; // rtt
  int v14; // ebx
  int v15; // edx
  int v16; // ebx
  __int16 v17; // dx
  int v18; // ebx
  int v19; // edx
  int v20; // eax
  int v21; // esi
  int v22; // edx
  int v23; // eax
  int v24; // edi
  int v25; // edx
  int v26; // eax
  int v27; // ebx
  int v28; // eax
  int v29; // ebx
  char *v30; // edx
  char v31; // bl
  unsigned int v32; // ebx
  unsigned __int8 v33; // al
  unsigned __int8 v34; // ah
  unsigned __int16 v35; // si
  int v36; // eax
  char v37; // al
  char v38; // al
  int v39; // eax
  unsigned __int16 v40; // si
  int v41; // eax
  unsigned __int8 v42; // ah
  int v43; // eax
  unsigned __int8 v44; // al
  char v45; // al
  char v46; // al
  char v47; // ah
  unsigned __int8 v48; // ah
  __int16 v49; // ax
  int v50; // edx
  int v51; // ecx
  int v52; // esi
  int v53; // edi
  char *v54; // ecx
  char *v55; // edx
  char *v56; // edx
  char *v57; // ecx
  int v58; // eax
  int v59; // ebx
  int v60; // edx
  int v61; // eax
  int v62; // esi
  int v63; // edi
  unsigned __int8 v64; // al
  int v65; // eax
  char *v66; // esi
  char *v67; // ebx
  char *result; // eax
  char *v69; // edx
  char v70; // cl
  char v71; // cl
  char v72; // cl
  char v73; // cl
  char *v74; // [esp+0h] [ebp-1Eh]
  char *v75; // [esp+4h] [ebp-1Ah]
  int v76; // [esp+8h] [ebp-16h]
  int v77; // [esp+Ch] [ebp-12h]
  int v78; // [esp+10h] [ebp-Eh]
  char *v79; // [esp+14h] [ebp-Ah]
  unsigned __int8 *v80; // [esp+18h] [ebp-6h]
  unsigned __int8 *v81; // [esp+1Ch] [ebp-2h]
  int v82; // [esp+20h] [ebp+2h]
  int v83; // [esp+24h] [ebp+6h]
  signed int v84; // [esp+28h] [ebp+Ah]
  int v85; // [esp+2Ch] [ebp+Eh]
  int v86; // [esp+30h] [ebp+12h]
  char *v87; // [esp+34h] [ebp+16h]
  int v88; // [esp+38h] [ebp+1Ah]
  int v89; // [esp+38h] [ebp+1Ah]
  char *v90; // [esp+3Ch] [ebp+1Eh]
  int v91; // [esp+40h] [ebp+22h]
  int v92; // [esp+44h] [ebp+26h]
  int v93; // [esp+48h] [ebp+2Ah]
  int v94; // [esp+4Ch] [ebp+2Eh]
  int v95; // [esp+50h] [ebp+32h]
  char *v96; // [esp+54h] [ebp+36h]
  int v97; // [esp+58h] [ebp+3Ah]
  unsigned __int16 i; // [esp+5Ch] [ebp+3Eh]
  unsigned __int16 v99; // [esp+60h] [ebp+42h]
  char v100; // [esp+68h] [ebp+4Ah]
  unsigned __int8 v101; // [esp+6Ch] [ebp+4Eh]
  char v102; // [esp+70h] [ebp+52h]
  char v103; // [esp+74h] [ebp+56h]
  char v104; // [esp+78h] [ebp+5Ah]
  char v105; // [esp+7Ch] [ebp+5Eh]

  v8 = a1;
  v9 = a2;
  v10 = a8;
  v11 = *(_BYTE *)(dword_D41A0 + 196308);
  v86 = 0;
  if ( v11 )
  {
    if ( v11 <= 1u )
    {
      v104 = byte_E98FF;
      v101 = byte_E98FF;
      v12 = -124;
      v102 = -24;
    }
    else
    {
      if ( v11 != 2 )
        goto LABEL_9;
      v104 = byte_E98FF;
      v101 = byte_E98FF;
      v102 = 28;
      v12 = byte_E89F0;
    }
    v103 = v12;
  }
  else
  {
    v104 = byte_E8900[0];
    v101 = byte_E8900[0];
    v103 = 28;
    v102 = -24;
  }
LABEL_9:
  if ( (word_180660 & 1) != 0 )
  {
    v8 = a1 >> 1;
    v9 = a2 >> 1;
    v10 = 2 * a8;
    a5 >>= 1;
    a6 >>= 1;
  }
  v94 = v9 * dword_18062C + dword_180628 + v8;
  v95 = v9 * dword_18062C + dword_E9C3C + v8;
  LODWORD(v13) = sub_10000;
  HIDWORD(v13) = (int)sub_10000 >> 31;
  v14 = v13 / v10;
  v93 = a5 / 2;
  v15 = v14 * dword_DB750[a7 & 0x7FF];
  v16 = (_DWORD)off_DBF50[a7 & 0x7FF] * v14;
  v76 = a6 / 2;
  v77 = -v15 >> 16;
  sub_6FC50(byte_D419D);
  v78 = v16 >> 16;
  v97 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v17 = *(_WORD *)(*(_DWORD *)(v97 + 164) + 843);
  if ( v17 )
    v86 = *(__int16 *)(dword_EA3E4[v17] + 46);
  v18 = *(_DWORD *)(v97 + 164);
  if ( *(_WORD *)(v18 + 58) )
  {
    v19 = (__int16)(*(_WORD *)(v97 + 76) - a3);
    v20 = (__int16)(*(_WORD *)(v97 + 78) - a4);
    v21 = v93 + ((v19 * v78 - v20 * v77) >> 16);
    v22 = v78 * v20 + v77 * v19;
    v23 = dword_EA3E4[*(unsigned __int16 *)(v18 + 58)];
    v24 = (v22 >> 16) + v76;
    v25 = (__int16)(*(_WORD *)(v23 + 76) - a3);
    v26 = (__int16)(*(_WORD *)(v23 + 78) - a4);
    v27 = v93 + ((v25 * v78 - v26 * v77) >> 16);
    v88 = ((v77 * v25 + v78 * v26) >> 16) + v76;
    v84 = sub_7277A((v27 - v21) * (v27 - v21) + (v88 - v24) * (v88 - v24));
    v82 = (unsigned __int16)sub_72633(v27 - v21, v88 - v24);
    v28 = *(_DWORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248) & 3;
    while ( 1 )
    {
      v28 += 4;
      if ( v28 > v84 )
        break;
      v29 = v21 + ((v28 * dword_DB750[v82]) >> 16);
      v89 = v24 + ((-v28 * (int)off_DBF50[v82]) >> 16);
      if ( v29 < 0 || v29 >= a5 || v89 < 0 || v89 >= a6 || v29 < word_F4962[2 * v89] || v29 >= word_F4960[2 * v89] )
        break;
      v30 = (char *)(dword_18062C * v89 + v29 + v94);
      v87 = (char *)(v95 + v29 + dword_18062C * v89);
      v31 = byte_FAEE0[256 * (unsigned __int8)*v30 + (unsigned __int8)byte_E98FF];
      *v87 = v31;
      *v30 = v31;
    }
  }
  v32 = dword_D41A0 + 28470;
  while ( v32 < dword_D41A0 + 196302 )
  {
    v33 = 0;
    v100 = 0;
    v85 = 1;
    v99 = 0;
    switch ( *(_BYTE *)(v32 + 63) )
    {
      case 2:
        switch ( *(_BYTE *)(v32 + 64) )
        {
          case 0:
            if ( *(_BYTE *)(v32 + 69) != 2 )
              goto LABEL_70;
            v105 = v103;
            v33 = 0;
            goto LABEL_115;
          case 1:
            v33 = 1;
            if ( *(_BYTE *)(dword_D41A4 + 123) )
              v105 = byte_E8988;
            else
              v100 = 1;
            v99 = 27;
            goto LABEL_115;
          case 2:
            v105 = v103;
            v99 = 22;
            goto LABEL_114;
          case 3:
            goto LABEL_115;
          default:
LABEL_70:
            v105 = v103;
            goto LABEL_114;
        }
      case 3:
        v48 = *(_BYTE *)(v32 + 64);
        if ( v48 >= 2u )
        {
          if ( v48 <= 2u )
          {
            LOBYTE(v49) = *(_WORD *)(v32 + 26) != *(_WORD *)(v97 + 26);
            HIBYTE(v49) = 0;
            v99 = v49 + 24;
            v33 = *(_BYTE *)(*(_DWORD *)(dword_EA3E4[*(__int16 *)(v32 + 26)] + 164) + 56) + 58;
          }
          else if ( v48 == 3 )
          {
            if ( *(_WORD *)(v32 + 26) == *(_WORD *)(v97 + 26) || v86 )
              v33 = *(_BYTE *)(*(_DWORD *)(dword_EA3E4[*(__int16 *)(v32 + 26)] + 164) + 56) + 66;
            if ( *(_WORD *)(v32 + 26) == *(_WORD *)(v97 + 26) )
            {
              v99 = 23;
            }
            else if ( v86 )
            {
              v99 = 26;
            }
          }
        }
        goto LABEL_115;
      case 5:
        v42 = *(_BYTE *)(v32 + 69);
        if ( v42 >= 0xB4u && (v42 <= 0xB4u || v42 >= 0xE8u && v42 <= 0xEAu) || (*(_BYTE *)(v32 + 12) & 1) != 0 )
          goto LABEL_115;
        v43 = *(__int16 *)(v32 + 26);
        if ( v43 != (int)(v32 - (dword_D41A0 + 28302)) / 168 )
        {
          v45 = byte_E88E1[3 * sub_61790(*(__int16 *)(*(_DWORD *)(dword_EA3E4[v43] + 164) + 56))];
          goto LABEL_94;
        }
        v44 = *(_BYTE *)(v32 + 64);
        if ( v44 >= 0xCu )
        {
          if ( v44 <= 0xEu )
          {
            v45 = byte_E890F;
LABEL_94:
            v105 = v45;
            goto LABEL_114;
          }
          if ( v44 == 22 )
          {
            if ( *(unsigned __int16 *)(v32 + 148) != *(__int16 *)(v97 + 26) )
              v99 = 18;
            v45 = v104;
            goto LABEL_94;
          }
        }
        v105 = v104;
        v46 = 1;
        v47 = *(_BYTE *)(v32 + 73);
        if ( (v47 == 14 || v47 == 13) && *(unsigned __int16 *)(v32 + 40) == *(__int16 *)(v97 + 26) )
          v46 = 0;
        if ( v46 )
          v99 = 19;
        goto LABEL_114;
      case 9:
        goto LABEL_54;
      case 0xA:
        v34 = *(_BYTE *)(v32 + 64);
        if ( v34 < 0x27u )
        {
          if ( v34 >= 0x12u )
          {
            if ( v34 <= 0x12u )
              goto LABEL_115;
            if ( v34 == 34 )
              v85 = 2;
          }
          goto LABEL_54;
        }
        if ( v34 <= 0x27u )
          goto LABEL_44;
        if ( v34 < 0x39u )
        {
          if ( v34 == 45 )
          {
            v40 = *(_WORD *)(v32 + 148);
            if ( v40 && (v41 = dword_EA3E4[v40], *(_BYTE *)(v41 + 63) == 3) )
            {
              sub_61790(*(__int16 *)(*(_DWORD *)(v41 + 164) + 56));
            }
            else
            {
              if ( (byte_D93C2[4 * *(char *)(v32 + 70)] & 8) == 0 )
                v99 = 21;
              v100 = 1;
            }
          }
LABEL_54:
          v39 = dword_EA3E4[*(__int16 *)(v32 + 26)];
          if ( *(_BYTE *)(v39 + 63) == 3 )
            v38 = byte_E88E0[3 * sub_61790(*(__int16 *)(*(_DWORD *)(v39 + 164) + 56))];
          else
            v38 = byte_E980F;
LABEL_113:
          v105 = v38;
          goto LABEL_114;
        }
        if ( v34 <= 0x39u )
        {
LABEL_44:
          v35 = *(_WORD *)(v32 + 148);
          if ( v35 && (v36 = dword_EA3E4[v35], *(_BYTE *)(v36 + 63) == 3) )
          {
            if ( *(_BYTE *)(dword_D41A4 + 124) )
              v37 = byte_E88E0[3 * sub_61790(*(__int16 *)(*(_DWORD *)(v36 + 164) + 56))];
            else
              v37 = byte_E88E1[3 * sub_61790(*(__int16 *)(*(_DWORD *)(v36 + 164) + 56))];
            v105 = v37;
          }
          else
          {
            v105 = v102;
            v99 = 18;
          }
LABEL_114:
          v33 = 1;
        }
        else
        {
          if ( v34 < 0x4Eu )
            goto LABEL_54;
          if ( v34 <= 0x4Eu )
          {
            if ( *(_WORD *)(v32 + 50) != *(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240) )
              goto LABEL_115;
            v38 = byte_E88E0[3 * sub_61790(*(__int16 *)(*(_DWORD *)(v97 + 164) + 56))
                           + *(unsigned __int8 *)(dword_D41A4 + 124)];
            goto LABEL_113;
          }
          if ( v34 < 0x56u || v34 > 0x57u )
            goto LABEL_54;
        }
LABEL_115:
        if ( v33 )
        {
          v50 = (__int16)(*(_WORD *)(v32 + 76) - a3);
          v51 = (__int16)(*(_WORD *)(v32 + 78) - a4);
          v52 = v93 + ((v50 * v78 - v51 * v77) >> 16);
          if ( v52 >= 0 && v52 < a5 )
          {
            v53 = ((v78 * v51 + v77 * v50) >> 16) + v76;
            if ( v53 >= 0 && v53 < a6 && v52 >= word_F4962[2 * v53] && v52 < word_F4960[2 * v53] )
            {
              v54 = (char *)(v53 * dword_18062C + v52 + v94);
              v55 = (char *)(v53 * dword_18062C + v52 + v95);
              if ( !v100 )
              {
                if ( v33 <= 1u )
                {
                  *v55 = v105;
                  *v54 = v105;
                  if ( v85 > 1 )
                  {
                    v55[1] = v105;
                    v54[1] = v105;
                    v56 = &v55[dword_18062C];
                    *v56 = v105;
                    v57 = &v54[dword_18062C];
                    *v57 = v105;
                    v56[1] = v105;
                    v57[1] = v105;
                  }
                }
                else if ( word_180660 == 1 )
                {
                  if ( v33 < 0x42u || v33 >= 0x4Au )
                  {
                    if ( v33 < 0x3Au || v33 >= 0x42u )
                    {
                      if ( v33 == 83 || v33 == 84 )
                        sub_2BB40(
                          2 * v52 - *(unsigned __int8 *)(6 * v33 + dword_EA3DC + 4) / 2,
                          2 * v53 - ((int)*(unsigned __int8 *)(6 * v33 + dword_EA3DC + 5) >> 1),
                          6 * v33 + dword_EA3DC);
                    }
                    else
                    {
                      sub_2BB40(
                        2 * v52,
                        2 * v53 - *(unsigned __int8 *)(dword_EA3DC + 6 * v33 + 5),
                        dword_EA3DC + 6 * v33);
                    }
                  }
                  else
                  {
                    sub_2BB40(
                      2 * v52 - *(unsigned __int8 *)(6 * v33 + dword_EA3DC + 4) / 2,
                      2 * v53 - *(unsigned __int8 *)(6 * v33 + dword_EA3DC + 5),
                      6 * v33 + dword_EA3DC);
                  }
                }
                else if ( v33 >= 0x3Cu )
                {
                  sub_2BB40(
                    v52 - ((int)*(unsigned __int8 *)(6 * v33 + dword_EA3DC + 4) >> 1),
                    v53 - *(unsigned __int8 *)(6 * v33 + dword_EA3DC + 5),
                    6 * v33 + dword_EA3DC);
                }
                else
                {
                  sub_2BB40(v52, v53 - *(unsigned __int8 *)(6 * v33 + dword_EA3DC + 5), 6 * v33 + dword_EA3DC);
                }
              }
              if ( v99 )
                sub_885E0(v32, v52, v53, v99);
            }
          }
        }
        v32 += 168;
        break;
      case 0xB:
        switch ( *(_BYTE *)(v32 + 64) )
        {
          case 0xC:
            v33 = 83;
            v99 = 83;
            break;
          case 0x1F:
            v33 = 84;
            v99 = 83;
            break;
          default:
            goto LABEL_115;
        }
        goto LABEL_115;
      case 0xC:
      case 0xF:
        if ( (*(_BYTE *)(v32 + 12) & 1) != 0 )
          goto LABEL_115;
        v38 = byte_E9800;
        v99 = 20;
        goto LABEL_113;
      case 0xE:
        if ( *(_BYTE *)(v32 + 64) != 5 )
          goto LABEL_115;
        if ( *(_BYTE *)(dword_D41A4 + 124) )
          v38 = byte_E9800;
        else
          v38 = byte_E98FF;
        goto LABEL_113;
      default:
        goto LABEL_115;
    }
  }
  if ( v86 )
  {
    v83 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
    for ( i = 0; i < *(_WORD *)(dword_D41A0 + 14); ++i )
    {
      if ( i != *(__int16 *)(dword_D41A0 + 12) )
      {
        v91 = 2124 * i;
        v58 = *(unsigned __int16 *)(v91 + dword_D41A0 + 11240);
        v59 = dword_EA3E4[v58];
        if ( *(int *)(v59 + 8) >= 0 )
        {
          if ( sub_63570(v83, dword_EA3E4[v58]) )
          {
            v60 = (__int16)(*(_WORD *)(v59 + 76) - a3);
            v61 = (__int16)(*(_WORD *)(v59 + 78) - a4);
            v62 = v93 + ((v60 * v78 - v61 * v77) >> 16);
            if ( v62 >= 0 && v62 < a5 )
            {
              v63 = ((v77 * v60 + v78 * v61) >> 16) + v76;
              if ( v63 >= 0 && v63 < a6 && v62 >= word_F4962[2 * v63] && v62 < word_F4960[2 * v63] )
              {
                v81 = (unsigned __int8 *)(v63 * dword_18062C + v62 + v94);
                v80 = (unsigned __int8 *)(v63 * dword_18062C + v62 + v95);
                v64 = byte_E88E1[3 * sub_61790(*(__int16 *)(*(_DWORD *)(v59 + 164) + 56))];
                *v80 = v64;
                *v81 = v64;
                if ( word_180660 == 1 )
                  sub_2BC10((_BYTE *)(v91 + dword_D41A0 + 11230 + 927), 2 * v62 + 4, 2 * v63, v64);
                else
                  sub_2BC10((_BYTE *)(v91 + dword_D41A0 + 11230 + 927), v62 + 4, v63, v64);
              }
            }
          }
        }
      }
    }
  }
  v92 = a5 / 12;
  v65 = dword_18062C * (a6 / 2);
  v66 = (char *)(v95 + a5 / 2 + v65 - 1);
  v67 = (char *)(v65 + a5 / 2 + v94 - 1);
  result = &byte_FAEE0[256 * v101];
  v79 = v67;
  v96 = v67;
  *v67 = result[(unsigned __int8)*v67];
  v69 = v67;
  v74 = v66;
  v75 = v66;
  v90 = v66;
  for ( *v66 = result[(unsigned __int8)*v67]; v92; --v92 )
  {
    ++v96;
    v79 += dword_18062C;
    v69 -= dword_18062C;
    v90 -= dword_18062C;
    ++v75;
    v74 += dword_18062C;
    v70 = result[(unsigned __int8)*v69];
    *v69 = v70;
    *v90 = v70;
    v71 = result[(unsigned __int8)*v96];
    *v96 = v71;
    *v75 = v71;
    v72 = result[(unsigned __int8)*v79];
    *v79 = v72;
    *v74 = v72;
    v73 = result[(unsigned __int8)*(v67 - 1)];
    *(v67 - 1) = v73;
    *(v66 - 1) = v73;
    --v67;
    --v66;
  }
  return result;
}
// 62C91: variable 'v102' is possibly undefined
// 62DDA: variable 'v103' is possibly undefined
// 62EA2: variable 'v104' is possibly undefined
// 63216: variable 'v105' is possibly undefined
// 634A2: variable 'v101' is possibly undefined
// 10000: using guessed type void __noreturn sub_10000();
// D419D: using guessed type char byte_D419D;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// DB750: using guessed type int dword_DB750[256];
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// E890F: using guessed type char byte_E890F;
// E8988: using guessed type char byte_E8988;
// E89F0: using guessed type char byte_E89F0;
// E9800: using guessed type char byte_E9800;
// E980F: using guessed type char byte_E980F;
// E98FF: using guessed type char byte_E98FF;
// E9C3C: using guessed type int dword_E9C3C;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// F4960: using guessed type __int16 word_F4960[];
// F4962: using guessed type __int16 word_F4962[831];
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (00063570) --------------------------------------------------------
char __cdecl sub_63570(int a1, int a2)
{
  unsigned int v2; // ecx
  char v3; // ah
  unsigned int v4; // ebx
  char v5; // dl
  unsigned __int8 v6; // al

  v2 = dword_EA3E4[*(__int16 *)(*(_DWORD *)(a1 + 164) + 843)];
  v3 = 1;
  v4 = dword_EA3E4[*(__int16 *)(*(_DWORD *)(a2 + 164) + 827)];
  v5 = 0;
  if ( v4 > dword_EA3E4[0] && *(_WORD *)(v4 + 46) )
    v5 = 1;
  if ( v2 > dword_EA3E4[0] )
  {
    v6 = *(_BYTE *)(v2 + 70);
    if ( v6 )
    {
      if ( v6 > 1u )
        return v3;
    }
    else if ( *(_BYTE *)(*(_DWORD *)(a2 + 164) + 447) )
    {
      return 0;
    }
    if ( v5 )
      return 0;
  }
  return v3;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00063600) --------------------------------------------------------
int __cdecl sub_63600(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10)
{
  if ( *(_BYTE *)(dword_D41A0 + 8592) == 1 )
    return sub_63670(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  else
    return sub_63C90(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}
// D41A0: using guessed type int dword_D41A0;

//----- (00063670) --------------------------------------------------------
int __cdecl sub_63670(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10)
{
  int v10; // eax
  int v11; // esi
  int v12; // edi
  int v13; // ecx
  _BOOL1 v14; // dl
  __int16 *v15; // ebx
  int i; // edx
  __int16 *v17; // esi
  int v18; // ebx
  __int16 v19; // ax
  __int16 *v20; // edx
  __int16 v21; // ax
  int v22; // edx
  int v23; // ebx
  int v24; // esi
  int v25; // eax
  int v26; // eax
  int result; // eax
  __int16 v28; // bx
  __int16 v29; // cx
  char *v30; // edi
  int v31; // esi
  int v32; // eax
  int v33; // edx
  char v34; // al
  int v35; // ecx
  __int16 v36; // bx
  _BYTE *v37; // edi
  __int16 v38; // cx
  int v39; // esi
  int v40; // eax
  int v41; // edx
  __int16 v42; // bx
  char *v43; // edi
  __int16 v44; // cx
  int v45; // esi
  int v46; // eax
  int v47; // edx
  char v48; // al
  int v49; // ecx
  int v50; // ebx
  _BYTE *v51; // edi
  int v52; // ecx
  int v53; // esi
  int v54; // eax
  int v55; // edx
  int v56; // ebx
  char *v57; // edi
  int v58; // ecx
  int v59; // esi
  int v60; // eax
  int v61; // edx
  char v62; // al
  char *v63; // edi
  __int32 v64; // [esp+0h] [ebp-60h] BYREF
  int v65; // [esp+4h] [ebp-5Ch]
  int v66; // [esp+8h] [ebp-58h]
  int v67; // [esp+Ch] [ebp-54h]
  int v68; // [esp+10h] [ebp-50h]
  int v69; // [esp+14h] [ebp-4Ch]
  int v70; // [esp+18h] [ebp-48h]
  int v71; // [esp+1Ch] [ebp-44h]
  int n; // [esp+20h] [ebp-40h]
  int v73; // [esp+24h] [ebp-3Ch]
  int j; // [esp+28h] [ebp-38h]
  int m; // [esp+2Ch] [ebp-34h]
  int ii; // [esp+30h] [ebp-30h]
  int k; // [esp+34h] [ebp-2Ch]
  int v78; // [esp+38h] [ebp-28h]
  __int16 *v79; // [esp+3Ch] [ebp-24h]
  int v80; // [esp+40h] [ebp-20h]
  int v81; // [esp+44h] [ebp-1Ch]
  int v82; // [esp+48h] [ebp-18h]
  int v83; // [esp+4Ch] [ebp-14h]
  int v84; // [esp+50h] [ebp-10h]
  int v85; // [esp+54h] [ebp-Ch]
  __int16 *v86; // [esp+58h] [ebp-8h]
  _BOOL1 v87; // [esp+5Ch] [ebp-4h]

  v10 = a1;
  v11 = a2;
  v12 = a5;
  v13 = a6;
  v14 = !*(_BYTE *)(dword_D41A0 + 8600) && *(_BYTE *)(dword_D41A0 + 196308) != 2;
  v87 = v14;
  if ( (word_180660 & 1) != 0 )
  {
    v10 = a1 >> 1;
    v11 = a2 >> 1;
    v12 = a5 >> 1;
    v13 = a6 >> 1;
    a8 *= 2;
  }
  v70 = v11 * dword_18062C + dword_180628 + v10;
  v71 = v11 * dword_18062C + dword_E9C3C + v10;
  if ( a10 )
  {
    v15 = word_F4960;
    for ( i = v13; i; --i )
    {
      v15 += 2;
      *(v15 - 1) = 0;
      *(v15 - 2) = v12;
    }
  }
  else
  {
    v78 = v13 / 2;
    v17 = &word_F4960[2 * (v13 / 2)];
    v79 = v17 - 2;
    v73 = 0;
    v68 = v13 >> 1;
    v18 = v12 >> 1;
    v69 = 0x1000000 / (v13 >> 1);
    while ( v78 )
    {
      v65 = (v18 * (unsigned __int8)byte_10B1E0[v73 >> 16]) >> 8;
      v19 = v18 + v65;
      v20 = v79;
      *v17 = v18 + v65;
      *v20 = v19;
      v21 = v18 - v65;
      v22 = (int)v79;
      v17[1] = v18 - v65;
      *(_WORD *)(v22 + 2) = v21;
      v79 = (__int16 *)(v22 - 4);
      v17 += 2;
      v73 += v69;
      --v78;
    }
  }
  v23 = a7 & 0x7FF;
  v24 = v13 * ((a8 * dword_DB750[v23]) >> 16);
  v25 = (a8 * (int)off_DBF50[v23]) >> 16;
  v80 = (a8 * dword_DB750[v23]) >> 16;
  v81 = v25;
  v67 = v24 / v12;
  v26 = v13 * v25;
  v66 = v26 / v12;
  v85 = a3 - (v12 * (v26 / v12) - v24) / 2;
  v86 = word_F4960;
  v83 = a4 - (v26 + v12 * (v24 / v12)) / 2;
  v84 = v70;
  result = v71;
  v82 = v71;
  if ( byte_D41B6 )
  {
    if ( a10 )
    {
      for ( j = v13; j; --j )
      {
        v33 = v86[1];
        v28 = v85 + v33 * v66;
        v29 = v83 + v33 * v67;
        v30 = (char *)(v33 + v84);
        v64 = v33 + v82;
        v31 = *v86 - v86[1];
        v32 = 0;
        HIWORD(v33) = 0;
        do
        {
          LOBYTE(v33) = HIBYTE(v28);
          BYTE1(v33) = HIBYTE(v29);
          v34 = 0;
          if ( (byte_13B4E0[v33] & 8) == 0 )
          {
            LOBYTE(v32) = byte_10B4E0[v33];
            BYTE1(v33) = byte_12B4E0[v33];
            LOBYTE(v33) = byte_10AEE0[v32];
            v34 = byte_F6EE0[v33];
          }
          *v30++ = v34;
          v28 += v66;
          v29 += v67;
          --v31;
        }
        while ( v31 );
        v84 += dword_18062C;
        v82 += dword_18062C;
        v86 += 2;
        v85 -= v80;
        result = j - 1;
        v83 += v81;
      }
    }
    else if ( v87 )
    {
      for ( k = v13; k; --k )
      {
        v35 = v86[1];
        v36 = v85 + v35 * v66;
        v37 = (_BYTE *)(v35 + v84);
        v64 = v35 + v82;
        v38 = v83 + v35 * v67;
        v39 = *v86 - v86[1];
        v40 = 0;
        HIWORD(v41) = 0;
        do
        {
          LOBYTE(v41) = HIBYTE(v36);
          BYTE1(v41) = HIBYTE(v38);
          if ( (byte_13B4E0[v41] & 8) == 0 )
          {
            LOBYTE(v40) = byte_10B4E0[v41];
            BYTE1(v41) = byte_12B4E0[v41];
            LOBYTE(v41) = byte_10AEE0[v40];
            LOBYTE(v41) = byte_F6EE0[v41];
            BYTE1(v41) = *v37;
            *v37 = byte_FAEE0[v41];
          }
          ++v37;
          v36 += v66;
          v38 += v67;
          --v39;
        }
        while ( v39 );
        v84 += dword_18062C;
        v82 += dword_18062C;
        v86 += 2;
        v85 -= v80;
        result = k - 1;
        v83 += v81;
      }
    }
    else
    {
      for ( m = v13; m; v83 += v81 )
      {
        v47 = v86[1];
        v42 = v85 + v47 * v66;
        v43 = (char *)(v47 + v84);
        v44 = v83 + v47 * v67;
        v64 = v47 + v82;
        v45 = *v86 - v86[1];
        v46 = 0;
        HIWORD(v47) = 0;
        do
        {
          LOBYTE(v47) = HIBYTE(v42);
          BYTE1(v47) = HIBYTE(v44);
          if ( (byte_13B4E0[v47] & 8) != 0 )
          {
            v48 = 0;
          }
          else
          {
            LOBYTE(v46) = byte_10B4E0[v47];
            BYTE1(v47) = byte_12B4E0[v47];
            LOBYTE(v47) = byte_10AEE0[v46];
            v48 = byte_F6EE0[v47];
          }
          *v43++ = v48;
          v42 += v66;
          v44 += v67;
          --v45;
        }
        while ( v45 );
        v84 += dword_18062C;
        v82 += dword_18062C;
        v86 += 2;
        result = v81;
        v85 -= v80;
        --m;
      }
    }
  }
  else if ( a10 )
  {
    for ( n = v13; n; --n )
    {
      v49 = v86[1];
      v50 = v85 + v49 * v66;
      v51 = (_BYTE *)(v49 + v84);
      v64 = v49 + v82;
      v52 = v83 + v49 * v67;
      v53 = *v86 - v86[1];
      v54 = 0;
      HIWORD(v55) = 0;
      do
      {
        LOBYTE(v55) = BYTE1(v50);
        BYTE1(v55) = BYTE1(v52);
        LOBYTE(v54) = byte_10B4E0[v55];
        BYTE1(v55) = byte_12B4E0[v55];
        LOBYTE(v55) = byte_10AEE0[v54];
        *v51++ = byte_F6EE0[v55];
        v50 += v66;
        v52 += v67;
        --v53;
      }
      while ( v53 );
      v84 += dword_18062C;
      v82 += dword_18062C;
      v86 += 2;
      v85 -= v80;
      result = n - 1;
      v83 += v81;
    }
  }
  else
  {
    for ( ii = v13; ii; v83 += v81 )
    {
      v61 = v86[1];
      v56 = v85 + v61 * v66;
      v57 = (char *)(v61 + v84);
      v58 = v83 + v61 * v67;
      v64 = v61 + v82;
      v59 = *v86 - v86[1];
      v60 = 0;
      HIWORD(v61) = 0;
      do
      {
        LOBYTE(v61) = BYTE1(v56);
        BYTE1(v61) = BYTE1(v58);
        LOBYTE(v60) = byte_10B4E0[v61];
        BYTE1(v61) = byte_12B4E0[v61];
        LOBYTE(v61) = byte_10AEE0[v60];
        LOBYTE(v61) = byte_F6EE0[v61];
        BYTE1(v61) = *v57;
        v62 = byte_FAEE0[v61];
        *v57 = v62;
        v63 = (char *)_InterlockedExchange(&v64, (__int32)(v57 + 1));
        *v63 = v62;
        v57 = (char *)_InterlockedExchange(&v64, (__int32)(v63 + 1));
        v56 += v66;
        v58 += v67;
        --v59;
      }
      while ( v59 );
      v84 += dword_18062C;
      v82 += dword_18062C;
      v86 += 2;
      result = v81;
      v85 -= v80;
      --ii;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// DB750: using guessed type int dword_DB750[256];
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// E9C3C: using guessed type int dword_E9C3C;
// F4960: using guessed type __int16 word_F4960[];
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (00063C90) --------------------------------------------------------
int __cdecl sub_63C90(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10)
{
  int v10; // ebx
  int v11; // edx
  int v12; // edi
  int v13; // ecx
  _BOOL1 v14; // al
  __int16 *v15; // ebx
  int i; // edx
  __int16 *v17; // esi
  int v18; // ebx
  int v19; // ebx
  int v20; // esi
  int result; // eax
  __int16 v22; // bx
  __int16 v23; // cx
  char *v24; // edi
  int v25; // esi
  int v26; // eax
  int v27; // edx
  char v28; // al
  __int16 v29; // bx
  __int16 v30; // cx
  _BYTE *v31; // edi
  int v32; // esi
  int v33; // eax
  int v34; // edx
  __int16 v35; // bx
  __int16 v36; // cx
  char *v37; // edi
  int v38; // esi
  int v39; // eax
  int v40; // edx
  char v41; // al
  int v42; // ebx
  int v43; // ecx
  _BYTE *v44; // edi
  int v45; // esi
  int v46; // eax
  int v47; // edx
  int v48; // ebx
  int v49; // ecx
  _BYTE *v50; // edi
  int v51; // esi
  int v52; // eax
  int v53; // edx
  int v54; // [esp+0h] [ebp-54h]
  int v55; // [esp+4h] [ebp-50h]
  int v56; // [esp+8h] [ebp-4Ch]
  int v57; // [esp+14h] [ebp-40h]
  int ii; // [esp+18h] [ebp-3Ch]
  int n; // [esp+1Ch] [ebp-38h]
  int m; // [esp+20h] [ebp-34h]
  int v61; // [esp+24h] [ebp-30h]
  int j; // [esp+28h] [ebp-2Ch]
  int k; // [esp+2Ch] [ebp-28h]
  int v64; // [esp+30h] [ebp-24h]
  __int16 *v65; // [esp+34h] [ebp-20h]
  int v66; // [esp+38h] [ebp-1Ch]
  int v67; // [esp+3Ch] [ebp-18h]
  int v68; // [esp+40h] [ebp-14h]
  int v69; // [esp+44h] [ebp-10h]
  int v70; // [esp+48h] [ebp-Ch]
  __int16 *v71; // [esp+4Ch] [ebp-8h]
  _BOOL1 v72; // [esp+50h] [ebp-4h]

  v10 = a1;
  v11 = a2;
  v12 = a5;
  v13 = a6;
  v14 = !*(_BYTE *)(dword_D41A0 + 8600) && *(_BYTE *)(dword_D41A0 + 196308) != 2;
  v72 = v14;
  if ( (word_180660 & 1) != 0 )
  {
    v10 = a1 >> 1;
    v11 = a2 >> 1;
    v12 = a5 >> 1;
    v13 = a6 >> 1;
    a8 *= 2;
  }
  v57 = dword_18062C * v11 + v10 + dword_180628;
  if ( a10 )
  {
    v15 = word_F4960;
    for ( i = v13; i; --i )
    {
      v15 += 2;
      *(v15 - 1) = 0;
      *(v15 - 2) = v12;
    }
  }
  else
  {
    v64 = v13 / 2;
    v17 = &word_F4960[2 * (v13 / 2)];
    v65 = v17 - 2;
    v61 = 0;
    v18 = v12 >> 1;
    while ( v64 )
    {
      v54 = (v18 * (unsigned __int8)byte_10B1E0[v61 >> 16]) >> 8;
      *v17 = v18 + v54;
      *v65 = v18 + v54;
      v17[1] = v18 - v54;
      v65[1] = v18 - v54;
      v65 -= 2;
      v17 += 2;
      v61 += 0x1000000 / (v13 >> 1);
      --v64;
    }
  }
  v19 = a7 & 0x7FF;
  v20 = v13 * ((a8 * dword_DB750[v19]) >> 16);
  v67 = (a8 * dword_DB750[v19]) >> 16;
  v66 = (a8 * (int)off_DBF50[v19]) >> 16;
  v56 = v20 / v12;
  v55 = v13 * v66 / v12;
  v69 = a3 - (v12 * v55 - v20) / 2;
  v71 = word_F4960;
  result = v57;
  v70 = a4 - (v13 * v66 + v12 * (v20 / v12)) / 2;
  v68 = v57;
  if ( byte_D41B6 )
  {
    if ( a10 )
    {
      for ( j = v13; j; LOWORD(v70) = v66 + v70 )
      {
        v27 = v71[1];
        v22 = v69 + v27 * v55;
        v23 = v70 + v27 * v56;
        v24 = (char *)(v27 + v68);
        v25 = *v71 - v27;
        v26 = 0;
        HIWORD(v27) = 0;
        do
        {
          LOBYTE(v27) = HIBYTE(v22);
          BYTE1(v27) = HIBYTE(v23);
          v28 = 0;
          if ( (byte_13B4E0[v27] & 8) == 0 )
          {
            LOBYTE(v26) = byte_10B4E0[v27];
            BYTE1(v27) = byte_12B4E0[v27];
            LOBYTE(v27) = byte_10AEE0[v26];
            v28 = byte_F6EE0[v27];
          }
          *v24++ = v28;
          v22 += v55;
          v23 += v56;
          --v25;
        }
        while ( v25 );
        v68 += dword_18062C;
        v71 += 2;
        result = v66;
        --j;
        LOWORD(v69) = v69 - v67;
      }
    }
    else if ( v72 )
    {
      for ( k = v13; k; LOWORD(v70) = v66 + v70 )
      {
        v34 = v71[1];
        v29 = v69 + v34 * v55;
        v30 = v70 + v34 * v56;
        v31 = (_BYTE *)(v34 + v68);
        v32 = *v71 - v34;
        v33 = 0;
        HIWORD(v34) = 0;
        do
        {
          LOBYTE(v34) = HIBYTE(v29);
          BYTE1(v34) = HIBYTE(v30);
          if ( (byte_13B4E0[v34] & 8) == 0 )
          {
            LOBYTE(v33) = byte_10B4E0[v34];
            BYTE1(v34) = byte_12B4E0[v34];
            LOBYTE(v34) = byte_10AEE0[v33];
            LOBYTE(v34) = byte_F6EE0[v34];
            BYTE1(v34) = *v31;
            *v31 = byte_FAEE0[v34];
          }
          ++v31;
          v29 += v55;
          v30 += v56;
          --v32;
        }
        while ( v32 );
        v68 += dword_18062C;
        v71 += 2;
        result = v66;
        --k;
        LOWORD(v69) = v69 - v67;
      }
    }
    else
    {
      for ( m = v13; m; LOWORD(v70) = v66 + v70 )
      {
        v40 = v71[1];
        v35 = v69 + v71[1] * v55;
        v36 = v70 + v40 * v56;
        v37 = (char *)(v40 + v68);
        v38 = *v71 - v40;
        v39 = 0;
        HIWORD(v40) = 0;
        do
        {
          LOBYTE(v40) = HIBYTE(v35);
          BYTE1(v40) = HIBYTE(v36);
          if ( (byte_13B4E0[v40] & 8) != 0 )
          {
            v41 = 0;
          }
          else
          {
            LOBYTE(v39) = byte_10B4E0[v40];
            BYTE1(v40) = byte_12B4E0[v40];
            LOBYTE(v40) = byte_10AEE0[v39];
            v41 = byte_F6EE0[v40];
          }
          *v37++ = v41;
          v35 += v55;
          v36 += v56;
          --v38;
        }
        while ( v38 );
        v68 += dword_18062C;
        v71 += 2;
        result = v66;
        --m;
        LOWORD(v69) = v69 - v67;
      }
    }
  }
  else if ( a10 )
  {
    for ( n = v13; n; v70 += v66 )
    {
      v47 = v71[1];
      v42 = v69 + v47 * v55;
      v43 = v70 + v47 * v56;
      v44 = (_BYTE *)(v47 + v68);
      v45 = *v71 - v47;
      v46 = 0;
      HIWORD(v47) = 0;
      do
      {
        LOBYTE(v47) = BYTE1(v42);
        BYTE1(v47) = BYTE1(v43);
        LOBYTE(v46) = byte_10B4E0[v47];
        BYTE1(v47) = byte_12B4E0[v47];
        LOBYTE(v47) = byte_10AEE0[v46];
        *v44++ = byte_F6EE0[v47];
        v42 += v55;
        v43 += v56;
        --v45;
      }
      while ( v45 );
      v68 += dword_18062C;
      v71 += 2;
      result = v66;
      --n;
      v69 -= v67;
    }
  }
  else
  {
    for ( ii = v13; ii; v70 += v66 )
    {
      v53 = v71[1];
      v48 = v69 + v53 * v55;
      v49 = v70 + v53 * v56;
      v50 = (_BYTE *)(v53 + v68);
      v51 = *v71 - v53;
      v52 = 0;
      HIWORD(v53) = 0;
      do
      {
        LOBYTE(v53) = BYTE1(v48);
        BYTE1(v53) = BYTE1(v49);
        LOBYTE(v52) = byte_10B4E0[v53];
        BYTE1(v53) = byte_12B4E0[v53];
        LOBYTE(v53) = byte_10AEE0[v52];
        LOBYTE(v53) = byte_F6EE0[v53];
        BYTE1(v53) = *v50;
        *v50++ = byte_FAEE0[v53];
        v48 += v55;
        v49 += v56;
        --v51;
      }
      while ( v51 );
      v68 += dword_18062C;
      v71 += 2;
      result = v66;
      --ii;
      v69 -= v67;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// DB750: using guessed type int dword_DB750[256];
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// F4960: using guessed type __int16 word_F4960[];
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (000644F0) --------------------------------------------------------
char __cdecl sub_644F0(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8)
{
  int v8; // ebx
  __int64 v9; // rtt
  int v10; // edi
  int v11; // edx
  int v12; // eax
  char v13; // dl
  unsigned int i; // eax
  _WORD *v15; // eax
  int *v16; // esi
  int v17; // edx
  signed int v18; // eax
  signed int v19; // eax
  int v20; // ebx
  int v21; // ecx
  int v22; // ebx
  int v23; // ecx
  int v24; // esi
  int v25; // edx
  int v26; // ecx
  void (__noreturn *v27)(); // ebx
  int v28; // eax
  unsigned __int8 v29; // cl
  int k; // ebx
  int v31; // eax
  int v32; // edi
  __int16 v34; // [esp-4h] [ebp-BEh]
  int *v35; // [esp-4h] [ebp-BEh]
  int v36; // [esp+0h] [ebp-BAh]
  _QWORD v37[2]; // [esp+4h] [ebp-B6h]
  int v38; // [esp+18h] [ebp-A2h]
  int v39; // [esp+1Ch] [ebp-9Eh]
  int v40; // [esp+30h] [ebp-8Ah]
  int v41; // [esp+34h] [ebp-86h]
  int v42; // [esp+48h] [ebp-72h]
  int v43; // [esp+4Ch] [ebp-6Eh]
  int v44; // [esp+60h] [ebp-5Ah]
  int v45; // [esp+64h] [ebp-56h]
  int v46; // [esp+78h] [ebp-42h]
  int v47; // [esp+7Ch] [ebp-3Eh]
  int v48; // [esp+90h] [ebp-2Ah]
  int v49; // [esp+94h] [ebp-26h]
  int v50; // [esp+A8h] [ebp-12h] BYREF
  __int16 v51; // [esp+ACh] [ebp-Eh]
  int v52; // [esp+AEh] [ebp-Ch]
  int v53; // [esp+B2h] [ebp-8h]
  int v54; // [esp+B6h] [ebp-4h]
  int v55; // [esp+BAh] [ebp+0h]
  int v56; // [esp+BEh] [ebp+4h]
  int v57; // [esp+C2h] [ebp+8h]
  int v58; // [esp+C6h] [ebp+Ch]
  int v59; // [esp+CAh] [ebp+10h]
  int v60; // [esp+CEh] [ebp+14h]
  __int16 v61; // [esp+D2h] [ebp+18h]
  __int16 v62; // [esp+D4h] [ebp+1Ah]
  char v63; // [esp+D6h] [ebp+1Ch]
  int v64; // [esp+D8h] [ebp+1Eh] BYREF
  __int16 v65; // [esp+DCh] [ebp+22h]
  int v66; // [esp+E0h] [ebp+26h] BYREF
  __int16 v67; // [esp+E4h] [ebp+2Ah]
  int v68; // [esp+E8h] [ebp+2Eh]
  int v69; // [esp+ECh] [ebp+32h]
  int v70; // [esp+F0h] [ebp+36h]
  int v71[3]; // [esp+F4h] [ebp+3Ah] BYREF
  int v72; // [esp+100h] [ebp+46h]
  int v73; // [esp+104h] [ebp+4Ah]
  int v74; // [esp+108h] [ebp+4Eh]
  int v75; // [esp+10Ch] [ebp+52h]
  int v76; // [esp+110h] [ebp+56h]
  unsigned __int8 j; // [esp+114h] [ebp+5Ah]
  char v78; // [esp+118h] [ebp+5Eh]
  int v79; // [esp+14Ch] [ebp+92h]

  v8 = 0x1000000;
  v78 = 0;
  if ( (word_180660 & 1) != 0 )
  {
    a1 >>= 1;
    a2 >>= 1;
    a5 >>= 1;
    a6 >>= 1;
    a8 *= 2;
  }
  v52 = dword_18062C * a2 + dword_180628 + a1;
  LODWORD(v9) = sub_10000;
  HIDWORD(v9) = (int)sub_10000 >> 31;
  v79 = v9 / a8;
  v55 = a3;
  v56 = a4;
  v57 = a5;
  v58 = a6;
  v59 = a5 / 2;
  v10 = a7 & 0x7FF;
  v11 = v79 * dword_DB750[v10];
  v60 = a6 / 2;
  v12 = (v79 * (int)off_DBF50[v10]) >> 16;
  v54 = -v11 >> 16;
  v53 = v12;
  v34 = *(_WORD *)(dword_D41A0 + 12);
  v72 = dword_EA3E4[*(unsigned __int16 *)(2124 * v34 + dword_D41A0 + 11240)];
  v13 = sub_595C0(v34);
  LOBYTE(i) = v13 + 3;
  switch ( v13 )
  {
    case -3:
    case -2:
    case -1:
      if ( v13 == -3 )
      {
        for ( i = *(_DWORD *)(dword_D41A4 + 38535); ; i = *(_DWORD *)v71[0] )
        {
          v71[0] = i;
          if ( i <= dword_EA3E4[0] )
            break;
          LOBYTE(i) = v71[0];
          if ( *(_BYTE *)(v71[0] + 64) == 31 )
          {
            v78 = 1;
            break;
          }
        }
      }
      else
      {
        for ( i = *(_DWORD *)(dword_D41A4 + 38535); ; i = *(_DWORD *)v71[0] )
        {
          v71[0] = i;
          if ( i <= dword_EA3E4[0] )
            break;
          LOBYTE(i) = v71[0];
          if ( *(_BYTE *)(v71[0] + 64) == 12 )
          {
            v78 = 1;
            break;
          }
        }
      }
      if ( v78 )
      {
        v35 = &v66;
        v15 = (_WORD *)(v72 + 76);
        v16 = (int *)(v71[0] + 76);
        goto LABEL_47;
      }
      break;
    case 1:
    case 2:
      LOBYTE(i) = sub_59610(v71, *(_WORD *)(dword_D41A0 + 12));
      if ( (_BYTE)i )
      {
        v63 = byte_E9800;
        v50 = *(_DWORD *)(v71[0] + 76);
        v51 = *(_WORD *)(v71[0] + 80);
        if ( sub_64CE0((int)&v50) )
          sub_885E0(v71[0], v61, v62, 0x52u);
        v35 = (int *)(v71[0] + 76);
        v16 = (int *)(v71[0] + 76);
        v15 = (_WORD *)(v72 + 76);
        v78 = 1;
        goto LABEL_47;
      }
      break;
    case 5:
      LOBYTE(i) = sub_596C0(&v64, *(_WORD *)(dword_D41A0 + 12));
      if ( (_BYTE)i )
      {
        v63 = byte_E98F0;
        v50 = v64;
        v51 = v65;
        if ( sub_64CE0((int)&v50) )
          sub_885E0(0, v61, v62, 0x51u);
        v35 = &v64;
        v16 = &v64;
        v15 = (_WORD *)(v72 + 76);
        v78 = 1;
LABEL_47:
        v66 = *v16;
        v67 = *((_WORD *)v16 + 2);
        i = sub_58490(v15, v35);
        v8 = i;
      }
      break;
    case 7:
      v17 = *(_DWORD *)(dword_D41A0
                      + 10 * (unsigned __int8)byte_3659D[11 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0]
                      + 222546);
      v63 = byte_E9800;
      for ( i = *(_DWORD *)(dword_D41A4 + 4 * v17 + 38403); ; i = *(_DWORD *)v71[0] )
      {
        v71[0] = i;
        if ( i <= dword_EA3E4[0] )
          break;
        v50 = *(_DWORD *)(v71[0] + 76);
        v51 = *(_WORD *)(v71[0] + 80);
        if ( sub_64CE0((int)&v50) )
          sub_885E0(v71[0], v61, v62, 0x52u);
        v18 = sub_58490((_WORD *)(v72 + 76), (_WORD *)(v71[0] + 76));
        if ( v18 < v8 )
        {
          v78 = 1;
          v8 = v18;
          v66 = *(_DWORD *)(v71[0] + 76);
          v67 = *(_WORD *)(v71[0] + 80);
        }
      }
      break;
    case 9:
      v63 = byte_E9800;
      v73 = *(_DWORD *)(dword_D41A0
                      + 10 * (unsigned __int8)byte_3659D[11 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0]
                      + 222546);
      for ( i = *(_DWORD *)(dword_D41A4 + 38527); ; i = *(_DWORD *)v71[0] )
      {
        v71[0] = i;
        if ( i <= dword_EA3E4[0] )
          break;
        v76 = v73;
        for ( j = 0; v76 && j < 8u; ++j )
        {
          if ( *(char *)(v71[0] + 70) == v76 )
          {
            v50 = *(_DWORD *)(v71[0] + 76);
            v51 = *(_WORD *)(v71[0] + 80);
            if ( sub_64CE0((int)&v50) )
              sub_885E0(v71[0], v61, v62, 0x52u);
            v19 = sub_58490((_WORD *)(v72 + 76), (_WORD *)(v71[0] + 76));
            if ( v19 < v8 )
            {
              v8 = v19;
              v78 = 1;
              v66 = *(_DWORD *)(v71[0] + 76);
              v67 = *(_WORD *)(v71[0] + 80);
            }
          }
          v76 = (unsigned __int8)byte_D93C3[4 * v76];
        }
      }
      break;
    default:
      break;
  }
  if ( v78 )
  {
    LOBYTE(i) = dword_D41A4;
    if ( (*(_BYTE *)(dword_D41A4 + 26) & 0x40) != 0 )
    {
      if ( *(_BYTE *)(dword_D41A4 + 127) )
      {
        v20 = v8 - 512;
        LOWORD(v75) = sub_581E0((_WORD *)(v72 + 76), &v66);
        v75 = (unsigned __int16)v75;
        if ( v20 > 15872 )
          LOWORD(v20) = 15872;
        v66 = *(_DWORD *)(v72 + 76);
        v67 = *(_WORD *)(v72 + 80);
        sub_57FA0(&v66, v75, 0, v20);
        v21 = v79 * dword_DB750[v10];
        v22 = v79 * (_DWORD)off_DBF50[v10];
        v70 = (__int16)(v66 - a3);
        v22 >>= 16;
        v23 = -v21 >> 16;
        v24 = a5 / 2 + ((v22 * v70 - v23 * (__int16)(HIWORD(v66) - a4)) >> 16);
        v39 = 13;
        v41 = 13;
        v43 = 13;
        v49 = 13;
        v38 = 9;
        v74 = a6 / 2 + ((v70 * v23 + (__int16)(HIWORD(v66) - a4) * v22) >> 16);
        v36 = 0;
        LODWORD(v37[0]) = 0;
        v40 = -9;
        v46 = -4;
        v48 = -4;
        v45 = 23;
        v47 = 23;
        v42 = 4;
        v44 = 4;
        v25 = 1;
        v75 = ((_WORD)v75 - (_WORD)v10) & 0x7FF;
        v26 = dword_DB750[v75];
        v27 = off_DBF50[v75];
        while ( v25 < 7 )
        {
          v28 = 3 * v25;
          v69 = 16 * *(&v36 + 6 * v25);
          v68 = 16 * LODWORD(v37[3 * v25]);
          *(&v36 + 2 * v28) = ((int)v27 * v69 - v26 * v68) >> 20;
          v71[1] = v26 * v69;
          v71[2] = (_DWORD)v27 * v68;
          ++v25;
          LODWORD(v37[v28]) = ((int)v27 * v68 + v26 * v69) >> 20;
        }
        if ( (word_180660 & 1) != 0 )
        {
          v24 *= 2;
          v74 *= 2;
        }
        v29 = byte_E9800;
        for ( k = 0; k < 7; ++k )
        {
          v31 = 3 * k;
          *(&v36 + 2 * v31) = v24 + a1 + *(&v36 + 6 * k);
          v32 = v37[3 * k];
          LODWORD(v37[v31]) = v74 + a2 + v32;
        }
        sub_2BD10(v36, v37[0], v38, v39, v29);
        sub_2BD10(v38, v39, v42, v43, v29);
        sub_2BD10(v42, v43, v44, v45, v29);
        sub_2BD10(v44, v45, v46, v47, v29);
        sub_2BD10(v46, v47, v48, v49, v29);
        sub_2BD10(v48, v49, v40, v41, v29);
        LOBYTE(i) = sub_2BD10(v40, v41, v36, v37[0], v29);
      }
    }
  }
  return i;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// DB750: using guessed type int dword_DB750[256];
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();
// E9800: using guessed type char byte_E9800;
// E98F0: using guessed type char byte_E98F0;
// EA3E4: using guessed type int dword_EA3E4[];
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (00064CE0) --------------------------------------------------------
char __cdecl sub_64CE0(int a1)
{
  int v1; // ecx
  int v2; // esi
  char v3; // ah
  int v4; // ebx
  char v5; // al
  int v6; // ecx
  int v7; // esi
  int v8; // ecx
  int v9; // ebx
  _BYTE *v10; // edx
  _BYTE *v11; // edx
  _BYTE *v12; // edx
  _BYTE *v13; // edx
  _BYTE *v14; // edx
  _BYTE *v15; // edx

  v1 = (__int16)(*(_WORD *)a1 - *(_WORD *)(a1 + 18));
  v2 = (__int16)(*(_WORD *)(a1 + 2) - *(_WORD *)(a1 + 22));
  v3 = 0;
  v4 = *(_DWORD *)(a1 + 34) + ((v1 * *(_DWORD *)(a1 + 10) - v2 * *(_DWORD *)(a1 + 14)) >> 16);
  v5 = *(_BYTE *)(a1 + 46);
  if ( v4 >= 0 && v4 < *(_DWORD *)(a1 + 26) )
  {
    v6 = *(_DWORD *)(a1 + 38) + ((*(_DWORD *)(a1 + 10) * v2 + *(_DWORD *)(a1 + 14) * v1) >> 16);
    if ( v6 >= 3 && v6 < *(_DWORD *)(a1 + 30) - 3 && v4 >= word_F4962[2 * v6] + 3 && v4 < word_F4960[2 * v6] - 3 )
    {
      *(_WORD *)(a1 + 42) = v4;
      *(_WORD *)(a1 + 44) = v6;
      v3 = 1;
      if ( (*(_BYTE *)(dword_D41A4 + 26) & 3) == 0 )
      {
        v7 = dword_18062C;
        v8 = dword_18062C * (v6 - 1);
        v9 = v4 - 1;
        v10 = (_BYTE *)(v8 + v9 + dword_180628);
        *v10 = v5;
        v10[1] = v5;
        v10[2] = v5;
        v11 = &v10[v7];
        *v11 = v5;
        v11[2] = v5;
        v12 = &v11[v7];
        *v12 = v5;
        v12[1] = v5;
        v12[2] = v5;
        if ( *(_BYTE *)(dword_D41A0 + 8592) == 1 )
        {
          v13 = (_BYTE *)(v8 + v9 + dword_E9C3C);
          *v13 = v5;
          v13[1] = v5;
          v13[2] = v5;
          v14 = &v13[v7];
          *v14 = v5;
          v14[2] = v5;
          v15 = &v14[v7];
          *v15 = v5;
          v15[1] = v5;
          v15[2] = v5;
        }
      }
    }
  }
  return v3;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E9C3C: using guessed type int dword_E9C3C;
// F4960: using guessed type __int16 word_F4960[];
// F4962: using guessed type __int16 word_F4962[831];
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;

//----- (00064E20) --------------------------------------------------------
int __cdecl sub_64E20(int a1)
{
  __int16 v1; // dx
  int v2; // edx
  int v3; // eax
  int v4; // ecx
  int v5; // esi
  __int64 v6; // rax
  __int16 v7; // di
  unsigned int v8; // edx
  int v9; // esi
  int result; // eax
  int v11; // eax

  v1 = *(_WORD *)(a1 + 98);
  *(_BYTE *)(a1 + 14) |= 2u;
  if ( v1 )
  {
    v2 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 94);
    *(_DWORD *)(a1 + 8) = v2;
    if ( v2 < 0 )
    {
      v3 = sub_4A190(a1 + 76, 10, 6);
      v4 = v3;
      v5 = v3;
      if ( v3 )
      {
        *(_WORD *)(v3 + 26) = *(_WORD *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 98)] + 26);
        v6 = 3 * *(__int16 *)(a1 + 88);
        v7 = *(_WORD *)(v4 + 80);
        *(_WORD *)(v4 + 44) = (int)(v6 - (__CFSHL__(HIDWORD(v6), 2) + 4 * HIDWORD(v6))) >> 2;
        if ( v7 <= 128 )
          *(_WORD *)(v4 + 80) = 0;
        else
          *(_WORD *)(v4 + 80) = v7 - 128;
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v8 = *(unsigned __int16 *)(a1 + 20) % 0x3Cu + 130;
        *(_DWORD *)(v5 + 8) = v8;
        v9 = *(_DWORD *)(a1 + 12);
        *(_DWORD *)(a1 + 8) = v8;
        *(_DWORD *)(a1 + 12) = v9 & 0xFFFDFFF7;
        LOBYTE(v8) = *(_BYTE *)(a1 + 14);
        *(_BYTE *)(a1 + 69) = 1;
        *(_BYTE *)(a1 + 14) = v8 | 2;
        sub_57D40(a1 + 76, a1, a1 + 76);
      }
    }
    *(_WORD *)(a1 + 98) = 0;
  }
  *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
  result = sub_104D0((__int16 *)(a1 + 76));
  if ( result == 1 )
  {
    v11 = sub_4A190(a1 + 76, 10, 5);
    if ( v11 )
      *(_WORD *)(v11 + 26) = *(_WORD *)(a1 + 26);
    return sub_57F10(a1);
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00064F60) --------------------------------------------------------
int __cdecl sub_64F60(int a1)
{
  int v1; // edx
  unsigned __int16 v2; // si
  int result; // eax
  int v4; // eax

  v1 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v1;
  if ( v1 < 60 )
  {
    v2 = *(_WORD *)(a1 + 90);
    *(_BYTE *)(a1 + 69) = 2;
    if ( v2 >= 0x53u )
    {
      if ( v2 <= 0x53u )
      {
        sub_49DA0((_WORD *)a1, 226);
      }
      else if ( v2 == 84 )
      {
        sub_49DA0((_WORD *)a1, 227);
      }
    }
  }
  *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
  result = sub_104D0((__int16 *)(a1 + 76));
  if ( result == 1 )
  {
    v4 = sub_4A190(a1 + 76, 10, 5);
    if ( v4 )
      *(_WORD *)(v4 + 26) = *(_WORD *)(a1 + 26);
    return sub_57F10(a1);
  }
  return result;
}

//----- (00064FF0) --------------------------------------------------------
int __cdecl sub_64FF0(_WORD *a1)
{
  int result; // eax
  int v2; // eax

  a1[40] = sub_10C40(a1 + 38);
  result = sub_104D0(a1 + 38);
  if ( result == 1 )
  {
    v2 = sub_4A190((int)(a1 + 38), 10, 5);
    if ( v2 )
      *(_WORD *)(v2 + 26) = a1[13];
    return sub_57F10((int)a1);
  }
  return result;
}

//----- (00065040) --------------------------------------------------------
int __cdecl sub_65040(int a1)
{
  int result; // eax

  *(_BYTE *)(a1 + 14) |= 2u;
  result = sub_10C40((__int16 *)(a1 + 76));
  *(_WORD *)(a1 + 80) = result;
  return result;
}

//----- (00065080) --------------------------------------------------------
int __cdecl sub_65080(int a1)
{
  unsigned __int16 v1; // di
  int v2; // esi
  int v3; // ebx
  int result; // eax

  v1 = 0;
  v2 = dword_D41A0 + 11230;
  while ( v1 < *(_WORD *)(dword_D41A0 + 14) )
  {
    v3 = dword_EA3E4[*(unsigned __int16 *)(v2 + 10)];
    if ( *(int *)(v3 + 8) >= 0 && sub_106C0(v3, a1) )
      *(_BYTE *)(v3 + 13) |= 0x10u;
    v2 += 2124;
    ++v1;
  }
  result = sub_10C40((__int16 *)(a1 + 76));
  *(_WORD *)(a1 + 80) = result;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00065110) --------------------------------------------------------
int __cdecl sub_65110(int a1)
{
  int result; // eax

  *(_BYTE *)(a1 + 14) |= 2u;
  result = sub_10C40((__int16 *)(a1 + 76));
  *(_WORD *)(a1 + 80) = result;
  return result;
}

//----- (000651B0) --------------------------------------------------------
int __cdecl sub_651B0(int a1)
{
  __int16 v1; // dx
  int v2; // edx
  __int16 v3; // ax
  char v4; // dl
  int result; // eax

  v1 = *(_WORD *)(a1 + 98);
  *(_BYTE *)(a1 + 14) |= 2u;
  if ( v1 )
  {
    v2 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 94);
    *(_DWORD *)(a1 + 8) = v2;
    if ( v2 < 0 )
    {
      v3 = *(_WORD *)(a1 + 90);
      *(_WORD *)(a1 + 98) = 0;
      v4 = *(_BYTE *)(a1 + 12);
      *(_BYTE *)(a1 + 69) = 19;
      *(_BYTE *)(a1 + 12) = v4 & 0xF7;
      sub_49DA0((_WORD *)a1, v3 + 4);
      sub_4A190(a1 + 76, 10, 13);
    }
    *(_WORD *)(a1 + 98) = 0;
  }
  *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
  result = sub_104D0((__int16 *)(a1 + 76));
  if ( result == 1 )
    return sub_57F10(a1);
  return result;
}

//----- (00065240) --------------------------------------------------------
int __cdecl sub_65240(int a1)
{
  int result; // eax

  *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
  result = sub_104D0((__int16 *)(a1 + 76));
  if ( result == 1 )
    return sub_57F10(a1);
  return result;
}

//----- (00065280) --------------------------------------------------------
void __cdecl sub_65280(int a1)
{
  sub_652C0(a1);
}

//----- (000652A0) --------------------------------------------------------
void __cdecl sub_652A0(int a1)
{
  sub_652C0(a1);
}

//----- (000652C0) --------------------------------------------------------
void __cdecl sub_652C0(int a1)
{
  char v1; // ah
  int v2; // esi
  int v3; // eax
  __int16 v4; // dx
  __int16 v5; // cx
  __int16 v6; // di
  __int16 v7; // ax
  int v8; // esi
  int v9; // ecx
  int v10; // ecx
  __int16 v11; // ax
  unsigned int v12; // edx
  __int16 v13; // di
  __int16 v14; // ax
  int v15; // eax
  int v16; // edx

  v1 = *(_BYTE *)(a1 + 13);
  if ( (v1 & 8) != 0 )
  {
    *(_BYTE *)(a1 + 13) = v1 & 0xF7;
  }
  else
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v2 = (__int16)sub_10C40((__int16 *)(a1 + 76));
    v3 = *(__int16 *)(a1 + 80);
    if ( v3 > v2 )
    {
      v4 = *(_WORD *)(a1 + 130);
      if ( v4 )
        LOWORD(v3) = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), 0, v4);
    }
    else
    {
      *(_WORD *)(a1 + 130) = 0;
      LOWORD(v3) = sub_654B0(&word_EB398, a1);
    }
    sub_57CF0(v3, a1, (int)&word_EB398);
    v5 = *(_WORD *)(a1 + 130);
    if ( v5 )
      *(_WORD *)(a1 + 130) = v5 - 1;
    v6 = *(_WORD *)(a1 + 44) + *(_WORD *)(a1 + 80);
    v7 = *(_WORD *)(a1 + 44) - 24;
    *(_WORD *)(a1 + 44) = v7;
    *(_WORD *)(a1 + 80) = v6;
    if ( v7 < -192 )
      *(_WORD *)(a1 + 44) = -192;
    if ( *(__int16 *)(a1 + 44) > 192 )
      *(_WORD *)(a1 + 44) = 192;
    v8 = (__int16)sub_10C40((__int16 *)(a1 + 76));
    if ( *(__int16 *)(a1 + 80) <= v8 )
      *(_WORD *)(a1 + 80) = v8;
    if ( *(_WORD *)(a1 + 98) )
    {
      if ( *(__int16 *)(a1 + 80) <= v8 )
      {
        v9 = *(int *)(a1 + 94) >> 2;
        if ( v9 < 2 )
          v9 = 2;
        if ( v9 > 192 )
          v9 = 192;
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v10 = *(unsigned __int16 *)(a1 + 20) % (unsigned int)v9 + v9;
        v11 = 9377 * *(_WORD *)(a1 + 20);
        *(_WORD *)(a1 + 44) = v10;
        *(_WORD *)(a1 + 20) = v11 + 9439;
        v12 = *(unsigned __int16 *)(a1 + 20) % (unsigned int)(v10 >> 1);
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v13 = *(_WORD *)(a1 + 80);
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 20) & 0x7FF;
        v14 = *(_WORD *)(a1 + 44);
        *(_WORD *)(a1 + 130) = v12 + 1;
        *(_WORD *)(a1 + 80) = v14 + v13;
      }
      v15 = *(_DWORD *)(a1 + 94);
      v16 = *(_DWORD *)(a1 + 8);
      *(_WORD *)(a1 + 98) = 0;
      *(_DWORD *)(a1 + 8) = v16 - v15;
    }
    if ( *(int *)(a1 + 8) < 0 )
    {
      sub_4A190(a1 + 76, 10, 13);
      goto LABEL_27;
    }
    if ( *(__int16 *)(a1 + 80) <= v8 && sub_104D0((__int16 *)(a1 + 76)) == 1 )
    {
      sub_4A190(a1 + 76, 10, 5);
LABEL_27:
      sub_57F10(a1);
    }
  }
}
// EB398: using guessed type __int16 word_EB398;

//----- (000654B0) --------------------------------------------------------
signed int __cdecl sub_654B0(__int16 *a1, int a2)
{
  signed int result; // eax
  void (__noreturn *v3)(); // esi
  __int16 v4; // ax
  int v5; // [esp+0h] [ebp-1Ch]
  __int16 v6; // [esp+4h] [ebp-18h]
  int v7; // [esp+8h] [ebp-14h] BYREF
  __int16 v8; // [esp+Ch] [ebp-10h]
  int v9; // [esp+10h] [ebp-Ch]
  void (__noreturn *v10)(); // [esp+14h] [ebp-8h]
  int v11; // [esp+18h] [ebp-4h]

  result = sub_1B7A0(a1);
  if ( result > 20 )
  {
    v9 = 0;
    v5 = *(_DWORD *)a1;
    v6 = a1[2];
    result = *(unsigned __int16 *)(a2 + 28);
    v10 = sub_10000;
    while ( 1 )
    {
      v11 = result;
      if ( v9 >= 8 )
        break;
      v7 = *(_DWORD *)a1;
      v8 = a1[2];
      sub_57FA0(&v7, v11, 0, 64);
      v3 = v10;
      v4 = sub_10C40((__int16 *)&v7);
      if ( v4 < (int)v3 )
      {
        v10 = (void (__noreturn *)())v4;
        v5 = v7;
        v6 = v8;
      }
      result = ((_WORD)v11 + 256) & 0x7FF;
      ++v9;
    }
    *(_DWORD *)a1 = v5;
    a1[2] = v6;
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();

//----- (00065580) --------------------------------------------------------
int __cdecl sub_65580(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_BYTE *)(a1 + 64) != 2 )
    *(_WORD *)(a1 + 80) += *(_WORD *)(a1 + 82);
  return result;
}

//----- (000655A0) --------------------------------------------------------
int __cdecl sub_655A0(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_BYTE *)(a1 + 64) != 2 )
    *(_WORD *)(a1 + 80) -= *(_WORD *)(a1 + 82);
  return result;
}

//----- (000655C0) --------------------------------------------------------
int __cdecl sub_655C0(_WORD *a1, int a2)
{
  sub_65580(a2);
  a1[16] = sub_581E0(a1 + 38, (_WORD *)(a2 + 76));
  a1[17] = sub_58210(a1 + 38, (_WORD *)(a2 + 76));
  return sub_655A0(a2);
}

//----- (00065610) --------------------------------------------------------
int __cdecl sub_65610(int a1, int a2)
{
  __int16 v3; // ax
  int v4; // esi
  __int16 v5; // ax
  int v6; // esi
  __int16 v7; // ax

  sub_65580(a2);
  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
  v3 = sub_58210((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
  v4 = *(_DWORD *)(a1 + 160);
  *(_WORD *)(a1 + 34) = v3;
  v5 = *(_WORD *)(a1 + 28)
     + sub_58350(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32), *(unsigned __int16 *)(v4 + 4), *(_WORD *)(v4 + 2));
  HIBYTE(v5) &= 7u;
  v6 = *(_DWORD *)(a1 + 160);
  *(_WORD *)(a1 + 28) = v5;
  v7 = *(_WORD *)(a1 + 30)
     + sub_58350(*(_WORD *)(a1 + 30), *(_WORD *)(a1 + 34), *(unsigned __int16 *)(v6 + 8), *(_WORD *)(v6 + 6));
  HIBYTE(v7) &= 7u;
  *(_WORD *)(a1 + 30) = v7;
  return sub_655A0(a2);
}

//----- (000656D0) --------------------------------------------------------
__int16 __cdecl sub_656D0(int a1, int a2)
{
  __int16 v3; // ax
  int v4; // esi
  __int16 v5; // ax
  int v6; // esi
  __int16 result; // ax

  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
  v3 = sub_58210((_WORD *)(a1 + 76), (_WORD *)(a2 + 76));
  v4 = *(_DWORD *)(a1 + 160);
  *(_WORD *)(a1 + 34) = v3;
  v5 = *(_WORD *)(a1 + 28)
     + sub_58350(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32), *(unsigned __int16 *)(v4 + 4), *(_WORD *)(v4 + 2));
  HIBYTE(v5) &= 7u;
  v6 = *(_DWORD *)(a1 + 160);
  *(_WORD *)(a1 + 28) = v5;
  result = *(_WORD *)(a1 + 30)
         + sub_58350(*(_WORD *)(a1 + 30), *(_WORD *)(a1 + 34), *(unsigned __int16 *)(v6 + 8), *(_WORD *)(v6 + 6));
  HIBYTE(result) &= 7u;
  *(_WORD *)(a1 + 30) = result;
  return result;
}

//----- (00065780) --------------------------------------------------------
char __cdecl sub_65780(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // eax
  int v4; // ebx

  LOBYTE(v3) = *(_BYTE *)(a1 + 64);
  if ( (unsigned __int8)v3 < 0xCu )
  {
    if ( (unsigned __int8)v3 < 3u )
    {
      if ( (unsigned __int8)v3 > 1u )
        return v3;
    }
    else if ( (unsigned __int8)v3 > 3u && ((unsigned __int8)v3 < 7u || (unsigned __int8)v3 > 9u) )
    {
      return v3;
    }
  }
  else if ( (unsigned __int8)v3 > 0xCu )
  {
    if ( (unsigned __int8)v3 < 0x19u )
    {
      if ( (_BYTE)v3 != 17 )
        return v3;
    }
    else if ( (unsigned __int8)v3 > 0x19u && (_BYTE)v3 != 28 )
    {
      return v3;
    }
  }
  v3 = dword_EA3E4[*(__int16 *)(a1 + 26)];
  if ( *(_BYTE *)(v3 + 63) == 3 && !*(_BYTE *)(v3 + 64) )
  {
    ++*(_DWORD *)(*(_DWORD *)(v3 + 164) + 357);
    if ( a2 > dword_EA3E4[0] && a3 > dword_EA3E4[0] && *(_WORD *)(a2 + 26) == *(_WORD *)(a3 + 26) )
    {
      v4 = *(_DWORD *)(v3 + 164);
      if ( v4 )
        ++*(_DWORD *)(v4 + 361);
    }
  }
  return v3;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00065820) --------------------------------------------------------
int __cdecl sub_65820(int a1)
{
  unsigned int v1; // eax
  char v2; // dl
  __int16 v3; // ax
  __int16 v4; // ax
  int v5; // eax
  unsigned int v6; // esi
  __int16 v7; // ax
  __int16 v8; // cx
  char v9; // al
  int v10; // eax
  int v11; // edi
  int v12; // edi
  unsigned int v14; // [esp+0h] [ebp-8h]
  char v15; // [esp+4h] [ebp-4h]

  v15 = 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v14 = v1;
  if ( v1 <= dword_EA3E4[0] )
  {
    v2 = *(_BYTE *)(a1 + 12);
    if ( (v2 & 2) == 0 )
    {
      *(_BYTE *)(a1 + 12) = v2 | 2;
      if ( sub_68940(a1) || sub_67CB0(a1) )
      {
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
      }
      else
      {
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 28);
        *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 30);
      }
    }
  }
  else
  {
    sub_65610(a1, v1);
  }
  v3 = *(_WORD *)(a1 + 132) - *(_WORD *)(a1 + 130);
  if ( *(__int16 *)(a1 + 132) != *(__int16 *)(a1 + 130) )
  {
    if ( *(__int16 *)(a1 + 132) - *(__int16 *)(a1 + 130) <= 0 )
      v3 = -1;
    else
      v3 = 1;
  }
  *(_WORD *)(a1 + 130) += 2 * v3;
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  v4 = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  sub_57CF0(v4, a1, (int)&word_EB398);
  v5 = sub_10780(a1);
  v6 = v5;
  if ( v5 )
  {
    if ( (*(_WORD *)(v5 + 12) & 0x8010) != 0 && sub_68740(a1, v5, 0x2Du, 22) )
      return 0;
    sub_65580(v6);
    sub_57CF0(v6 + 76, a1, v6 + 76);
    sub_655A0(v6);
    v15 = 1;
    goto LABEL_29;
  }
  v7 = sub_10C40((__int16 *)(a1 + 76));
  v8 = *(_WORD *)(a1 + 80);
  word_EB39C = v7;
  if ( v7 > v8
    || byte_D41B6
    && (word_EB39C = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88), *(__int16 *)(a1 + 80) > word_EB39C) )
  {
    *(_WORD *)(a1 + 80) = word_EB39C;
    v9 = *(_BYTE *)(a1 + 64);
    if ( v9 != 4 && v9 != 22 && v9 != 24 && v9 != 26 && sub_104D0((__int16 *)(a1 + 76)) == 1 )
    {
      v10 = sub_4A190(a1 + 76, 10, 5);
      if ( v10 )
        *(_WORD *)(v10 + 26) = *(_WORD *)(a1 + 26);
      sub_57F10(a1);
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  v11 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v11;
  if ( v11 < 0 )
LABEL_28:
    v15 = 1;
LABEL_29:
  if ( !v15 )
    return 0;
  if ( sub_68AC0(a1, v6) )
  {
    sub_57F10(a1);
    return 0;
  }
  v12 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
  if ( !v12 )
    return 0;
  sub_65780(a1, v6, v14);
  sub_686D0(a1, v6);
  if ( v6 > dword_EA3E4[0] && *(_WORD *)(a1 + 38) )
    sub_6D8B0(*(_WORD *)(a1 + 26), *(char *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 64), 1);
  if ( *(_BYTE *)(a1 + 68) == 34 )
    *(_DWORD *)(v12 + 8) = *(unsigned __int16 *)(a1 + 42);
  *(_WORD *)(v12 + 26) = *(_WORD *)(a1 + 26);
  *(_WORD *)(v12 + 28) = *(_WORD *)(a1 + 28);
  *(_WORD *)(v12 + 30) = *(_WORD *)(a1 + 30);
  if ( v6 )
    *(_WORD *)(v12 + 150) = (int)(v6 - (dword_D41A0 + 28302)) / 168;
  *(_WORD *)(v12 + 42) = *(_WORD *)(a1 + 42);
  *(_BYTE *)(v12 + 70) = *(_BYTE *)(a1 + 70);
  sub_57F10(a1);
  return v12;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00065B30) --------------------------------------------------------
int __cdecl sub_65B30(int a1)
{
  int result; // eax

  result = sub_65C20(a1);
  if ( result )
    return sub_57F10(a1);
  return result;
}

//----- (00065B50) --------------------------------------------------------
int __cdecl sub_65B50(int a1)
{
  int result; // eax
  int v2; // esi
  __int16 v3; // bx
  __int16 v4; // dx
  int v5; // eax
  unsigned int i; // ebx
  char v7; // [esp+0h] [ebp-4h]

  v7 = 0;
  result = sub_65C20(a1);
  v2 = result;
  if ( result )
  {
    v3 = *(_WORD *)(a1 + 150);
    *(_DWORD *)(result + 4) = 30;
    *(_WORD *)(result + 150) = v3;
    v4 = *(_WORD *)(result + 26);
    *(_DWORD *)(result + 8) = *(_DWORD *)(result + 4);
    if ( v4 )
    {
      v5 = dword_EA3E4[v4];
      if ( *(_BYTE *)(v5 + 63) == 3
        && !*(_BYTE *)(v5 + 64)
        && *(_WORD *)(*(_DWORD *)(v5 + 164) + 56) == *(_WORD *)(dword_D41A0 + 12) )
      {
        v7 = 1;
      }
    }
    for ( i = dword_EA3E4[*(unsigned __int16 *)(v2 + 52)];
          i > dword_EA3E4[0];
          i = dword_EA3E4[*(unsigned __int16 *)(i + 52)] )
    {
      *(_WORD *)(i + 26) = *(_WORD *)(v2 + 26);
      if ( v7 )
        sub_49C90(i, 42);
    }
    return sub_57F10(a1);
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00065C20) --------------------------------------------------------
int __cdecl sub_65C20(int a1)
{
  unsigned int v1; // eax
  char v2; // dl
  __int16 v3; // si
  __int16 v4; // dx
  __int16 v5; // ax
  __int16 v6; // si
  __int16 v7; // cx
  __int16 v8; // ax
  int v9; // eax
  unsigned int v10; // esi
  __int16 v12; // ax
  __int16 v13; // dx
  int v14; // eax
  int v15; // edi
  _WORD *v16; // edi
  int v17; // [esp+0h] [ebp-14h] BYREF
  __int16 v18; // [esp+4h] [ebp-10h]
  _WORD *v19; // [esp+8h] [ebp-Ch]
  unsigned int v20; // [esp+Ch] [ebp-8h]
  char v21; // [esp+10h] [ebp-4h]

  v21 = 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v19 = 0;
  v20 = v1;
  if ( v1 > dword_EA3E4[0] )
  {
    sub_65610(a1, v1);
    goto LABEL_18;
  }
  v2 = *(_BYTE *)(a1 + 12);
  if ( (v2 & 2) == 0 )
  {
    *(_BYTE *)(a1 + 12) = v2 | 2;
    if ( sub_68940(a1) )
    {
      v6 = sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32));
      if ( v6 < 0 )
        v6 = 0;
      if ( v6 > 34 )
        v6 = 34;
      v7 = v6 * sub_582F0(*(unsigned __int16 *)(a1 + 28), *(_WORD *)(a1 + 32)) + *(_WORD *)(a1 + 28);
      v5 = *(_WORD *)(a1 + 34);
      *(_WORD *)(a1 + 28) = v7;
    }
    else
    {
      if ( !sub_67CB0(a1) )
      {
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 28);
        *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 30);
        goto LABEL_18;
      }
      v3 = sub_582B0(*(_WORD *)(a1 + 28), *(_WORD *)(a1 + 32));
      if ( v3 < 0 )
        v3 = 0;
      if ( v3 > 34 )
        v3 = 34;
      v4 = v3 * sub_582F0(*(unsigned __int16 *)(a1 + 28), *(_WORD *)(a1 + 32)) + *(_WORD *)(a1 + 28);
      v5 = *(_WORD *)(a1 + 34);
      *(_WORD *)(a1 + 28) = v4;
    }
    *(_WORD *)(a1 + 30) = v5;
  }
LABEL_18:
  v17 = *(_DWORD *)(a1 + 76);
  v18 = *(_WORD *)(a1 + 80);
  *(_DWORD *)&word_EB398 = v17;
  *(&word_EB398 + 2) = v18;
  v8 = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  sub_57CF0(v8, a1, (int)&word_EB398);
  v9 = sub_10780(a1);
  v10 = v9;
  if ( !v9 )
  {
    v12 = sub_10C40((__int16 *)(a1 + 76));
    v13 = *(_WORD *)(a1 + 80);
    word_EB39C = v12;
    if ( v12 > v13
      || byte_D41B6
      && (word_EB39C = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88), *(__int16 *)(a1 + 80) > word_EB39C) )
    {
      v18 = word_EB39C;
      sub_57CF0((__int16)&v17, a1, (int)&v17);
      if ( *(_BYTE *)(a1 + 64) != 4 && sub_104D0((__int16 *)(a1 + 76)) == 1 )
      {
        v14 = sub_4A190(a1 + 76, 10, 5);
        if ( v14 )
          *(_WORD *)(v14 + 26) = *(_WORD *)(a1 + 26);
        sub_57F10(a1);
        goto LABEL_35;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 8) - 1;
      *(_DWORD *)(a1 + 8) = v15;
      if ( v15 >= 0 )
        goto LABEL_35;
    }
    v21 = 1;
    goto LABEL_35;
  }
  if ( (*(_WORD *)(v9 + 12) & 0x8010) != 0 )
  {
    if ( sub_68740(a1, v9, 0x5Bu, 45) )
      return 0;
  }
  else
  {
    if ( (*(_BYTE *)(*(_DWORD *)(v9 + 160) + 32) & 0x10) != 0 )
      *(_WORD *)(a1 + 42) = 1;
    sub_65580(v9);
    sub_57CF0(v10 + 76, a1, v10 + 76);
    sub_655A0(v10);
    v21 = 1;
  }
LABEL_35:
  if ( v21 )
  {
    if ( sub_68AC0(a1, v10) )
    {
      sub_57F10(a1);
    }
    else
    {
      v19 = (_WORD *)sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
      if ( v19 )
      {
        sub_65780(a1, v10, v20);
        sub_686D0(a1, v10);
        if ( v10 > dword_EA3E4[0] )
          sub_6D8B0(*(_WORD *)(a1 + 26), 0, 1);
        v16 = v19;
        v19[21] = *(_WORD *)(a1 + 42);
        v16[13] = *(_WORD *)(a1 + 26);
        v16[14] = *(_WORD *)(a1 + 28);
        v16[15] = *(_WORD *)(a1 + 30);
        if ( !v10 )
          *(_WORD *)(a1 + 150) = 0;
      }
    }
  }
  return (int)v19;
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00065F60) --------------------------------------------------------
__int16 __cdecl sub_65F60(int a1)
{
  unsigned int v1; // eax
  char v2; // dl
  __int16 v3; // ax
  int v4; // eax
  int v5; // esi
  unsigned int v6; // edi
  int v7; // eax
  __int16 v8; // dx
  int v9; // esi
  _WORD *v10; // esi
  unsigned int v12; // [esp+0h] [ebp-8h]
  char v13; // [esp+4h] [ebp-4h]

  v13 = 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v12 = v1;
  if ( v1 <= dword_EA3E4[0] )
  {
    v2 = *(_BYTE *)(a1 + 12);
    if ( (v2 & 2) == 0 )
    {
      *(_BYTE *)(a1 + 12) = v2 | 2;
      if ( sub_67CB0(a1) )
      {
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
      }
    }
  }
  else
  {
    sub_65610(a1, v1);
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  v3 = sub_10C40(&word_EB398);
  if ( v3 > word_EB39C )
    word_EB39C = v3;
  if ( byte_D41B6 )
  {
    v3 = sub_10C60(&word_EB398) - *(_WORD *)(a1 + 88);
    if ( v3 < word_EB39C )
      word_EB39C = v3;
  }
  sub_57CF0(v3, a1, (int)&word_EB398);
  v4 = sub_108B0(a1);
  v5 = v4;
  v6 = v4;
  if ( !v4 )
  {
    LOWORD(v7) = sub_10C40((__int16 *)(a1 + 76));
    v8 = *(_WORD *)(a1 + 80);
    word_EB39C = v7;
    if ( (__int16)v7 > v8
      || byte_D41B6
      && (word_EB39C = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88),
          LOWORD(v7) = *(_WORD *)(a1 + 80),
          (__int16)v7 > word_EB39C) )
    {
      LOWORD(v7) = word_EB39C;
      *(_WORD *)(a1 + 80) = word_EB39C;
    }
    else
    {
      v9 = *(_DWORD *)(a1 + 8) - 1;
      *(_DWORD *)(a1 + 8) = v9;
      if ( v9 >= 0 )
        goto LABEL_19;
    }
    v13 = 1;
    goto LABEL_19;
  }
  sub_65580(v4);
  sub_57CF0(v5 + 76, a1, v5 + 76);
  LOWORD(v7) = sub_655A0(v5);
  v13 = 1;
LABEL_19:
  if ( v13 )
  {
    v7 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
    v10 = (_WORD *)v7;
    if ( v7 )
    {
      sub_65780(a1, v6, v12);
      if ( v6 > dword_EA3E4[0] )
        sub_6D8B0(*(_WORD *)(a1 + 26), 1u, 1);
      v10[13] = *(_WORD *)(a1 + 26);
      v10[14] = *(_WORD *)(a1 + 28);
      v10[15] = *(_WORD *)(a1 + 30);
      LOWORD(v7) = sub_57F10(a1);
    }
  }
  return v7;
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00066160) --------------------------------------------------------
int __cdecl sub_66160(int a1)
{
  int result; // eax

  result = sub_65820(a1);
  if ( result )
    *(_DWORD *)(result + 8) = *(char *)(a1 + 70);
  return result;
}

//----- (00066180) --------------------------------------------------------
int __cdecl sub_66180(int a1)
{
  int v1; // esi
  int result; // eax
  __int16 v3; // dx
  __int16 v4[4]; // [esp+0h] [ebp-8h] BYREF

  result = sub_65820(a1);
  v1 = result;
  BYTE1(result) = *(_BYTE *)(a1 + 63);
  if ( BYTE1(result) )
  {
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v4[0] = *(_WORD *)(a1 + 20) % 0x81u + *(_WORD *)(a1 + 76) - 96 - 64;
    *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
    v4[1] = *(_WORD *)(a1 + 20) % 0x81u + *(_WORD *)(a1 + 78) - 96 - 64;
    v4[2] = *(_WORD *)(a1 + 80);
    result = sub_4A190((int)v4, 10, 0);
    if ( result )
    {
      *(_DWORD *)(result + 12) |= (unsigned int)sub_10080;
      *(_WORD *)(result + 26) = *(_WORD *)(a1 + 26);
      v3 = *(_WORD *)(a1 + 28);
      *(_DWORD *)(result + 8) = 4;
      *(_BYTE *)(result + 92) = 3;
      *(_WORD *)(result + 28) = v3;
    }
    if ( v1 )
    {
      result = *(char *)(a1 + 70);
      *(_DWORD *)(v1 + 4) = result;
      *(_DWORD *)(v1 + 8) = result;
    }
  }
  return result;
}

//----- (00066250) --------------------------------------------------------
int __cdecl sub_66250(int a1)
{
  int result; // eax
  int v2; // edx

  result = sub_65820(a1);
  if ( result )
  {
    v2 = *(char *)(a1 + 70);
    *(_BYTE *)(result + 70) = 0;
    *(_DWORD *)(result + 4) = v2;
  }
  return result;
}

//----- (00066280) --------------------------------------------------------
int __cdecl sub_66280(int a1)
{
  int result; // eax

  result = sub_65820(a1);
  if ( result )
    *(_DWORD *)(result + 8) = *(char *)(a1 + 70);
  return result;
}

//----- (000662A0) --------------------------------------------------------
int __cdecl sub_662A0(int a1)
{
  return sub_65820(a1);
}

//----- (000662C0) --------------------------------------------------------
char __cdecl sub_662C0(int a1)
{
  return sub_662E0(a1);
}

//----- (000662E0) --------------------------------------------------------
char __cdecl sub_662E0(int a1)
{
  unsigned int v1; // eax
  char v2; // dl
  __int16 v3; // ax
  __int16 v4; // ax
  int v5; // eax
  unsigned int v6; // esi
  int v7; // eax
  __int16 v8; // cx
  int v9; // eax
  int v10; // edi
  int v11; // edi
  unsigned int v13; // [esp+0h] [ebp-8h]
  char v14; // [esp+4h] [ebp-4h]

  v14 = 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v13 = v1;
  if ( v1 <= dword_EA3E4[0] )
  {
    v2 = *(_BYTE *)(a1 + 12);
    if ( (v2 & 2) == 0 )
    {
      *(_BYTE *)(a1 + 12) = v2 | 2;
      if ( sub_68940(a1) || sub_67CB0(a1) )
      {
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
      }
      else
      {
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 28);
        *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 30);
      }
    }
  }
  else
  {
    sub_65610(a1, v1);
  }
  v3 = *(_WORD *)(a1 + 132) - *(_WORD *)(a1 + 130);
  if ( *(__int16 *)(a1 + 132) != *(__int16 *)(a1 + 130) )
  {
    if ( *(__int16 *)(a1 + 132) - *(__int16 *)(a1 + 130) <= 0 )
      v3 = -1;
    else
      v3 = 1;
  }
  *(_WORD *)(a1 + 130) += 2 * v3;
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  v4 = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  sub_57CF0(v4, a1, (int)&word_EB398);
  v5 = sub_10780(a1);
  v6 = v5;
  if ( v5 )
  {
    if ( (*(_WORD *)(v5 + 12) & 0x8010) != 0 )
    {
      LOBYTE(v7) = sub_68740(a1, v5, 0x2Du, 22);
      if ( (_BYTE)v7 )
        return v7;
    }
    sub_65580(v6);
    sub_57CF0(v6 + 76, a1, v6 + 76);
    LOBYTE(v7) = sub_655A0(v6);
    v14 = 1;
  }
  else
  {
    LOWORD(v7) = sub_10C40((__int16 *)(a1 + 76));
    v8 = *(_WORD *)(a1 + 80);
    word_EB39C = v7;
    if ( (__int16)v7 > v8
      || byte_D41B6
      && (word_EB39C = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88),
          LOWORD(v7) = *(_WORD *)(a1 + 80),
          (__int16)v7 > word_EB39C) )
    {
      LOBYTE(v7) = word_EB39C;
      *(_WORD *)(a1 + 80) = word_EB39C;
      if ( *(_BYTE *)(a1 + 64) != 4 )
      {
        v7 = sub_104D0((__int16 *)(a1 + 76));
        if ( v7 == 1 )
        {
          v9 = sub_4A190(a1 + 76, 10, 5);
          if ( v9 )
            *(_WORD *)(v9 + 26) = *(_WORD *)(a1 + 26);
          LOBYTE(v7) = sub_57F10(a1);
          goto LABEL_26;
        }
      }
    }
    else
    {
      v10 = *(_DWORD *)(a1 + 8) - 1;
      *(_DWORD *)(a1 + 8) = v10;
      if ( v10 >= 0 )
        goto LABEL_26;
    }
    v14 = 1;
  }
LABEL_26:
  if ( v14 )
  {
    if ( sub_68AC0(a1, v6) )
    {
      LOBYTE(v7) = sub_57F10(a1);
    }
    else if ( v6 && *(_BYTE *)(v6 + 63) == 3 && *(_BYTE *)(v6 + 64) <= 1u )
    {
      v7 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
      v11 = v7;
      if ( v7 )
      {
        sub_65780(a1, v6, v13);
        sub_686D0(a1, v6);
        if ( v6 > dword_EA3E4[0] && *(_WORD *)(a1 + 38) )
          sub_6D8B0(*(_WORD *)(a1 + 26), *(char *)(dword_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 64), 1);
        if ( *(_BYTE *)(a1 + 68) == 34 )
          *(_DWORD *)(v11 + 8) = *(unsigned __int16 *)(a1 + 42);
        *(_WORD *)(v11 + 26) = *(_WORD *)(a1 + 26);
        *(_WORD *)(v11 + 28) = *(_WORD *)(a1 + 28);
        *(_WORD *)(v11 + 30) = *(_WORD *)(a1 + 30);
        *(_WORD *)(v11 + 150) = (int)(v6 - (dword_D41A0 + 28302)) / 168;
        *(_WORD *)(v11 + 42) = *(_WORD *)(a1 + 42);
        *(_BYTE *)(v11 + 70) = *(_BYTE *)(a1 + 70);
        LOBYTE(v7) = sub_57F10(a1);
      }
    }
    else
    {
      sub_65780(a1, 0, v13);
      LOBYTE(v7) = sub_57F10(a1);
    }
  }
  return v7;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00066610) --------------------------------------------------------
__int16 __cdecl sub_66610(int a1)
{
  char v1; // dl
  int v2; // eax
  __int16 v3; // dx
  int v4; // ecx
  char v6; // [esp+0h] [ebp-4h]

  v6 = 0;
  if ( dword_EA3E4[0] >= (unsigned int)dword_EA3E4[*(unsigned __int16 *)(a1 + 150)] )
  {
    v1 = *(_BYTE *)(a1 + 12);
    if ( (v1 & 2) == 0 )
    {
      *(_BYTE *)(a1 + 12) = v1 | 2;
      if ( sub_68940(a1) || sub_67CB0(a1) )
      {
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
      }
      else
      {
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 28);
        *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 30);
      }
    }
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  *(_DWORD *)(a1 + 76) = *(_DWORD *)&word_EB398;
  *(_WORD *)(a1 + 80) = *(&word_EB398 + 2);
  v2 = sub_10780(a1);
  if ( v2 )
  {
    v6 = 1;
    *(_DWORD *)(a1 + 76) = *(_DWORD *)(v2 + 76);
    *(_WORD *)(a1 + 80) = *(_WORD *)(v2 + 80);
  }
  else
  {
    LOWORD(v2) = sub_10C40((__int16 *)(a1 + 76));
    v3 = *(_WORD *)(a1 + 80);
    word_EB39C = v2;
    if ( (__int16)v2 > v3
      || byte_D41B6
      && (word_EB39C = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88),
          LOWORD(v2) = *(_WORD *)(a1 + 80),
          (__int16)v2 > word_EB39C)
      || (v4 = *(_DWORD *)(a1 + 8) - 1, *(_DWORD *)(a1 + 8) = v4, v4 < 0) )
    {
      v6 = 1;
    }
  }
  if ( v6 )
    LOWORD(v2) = sub_57F10(a1);
  return v2;
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00066750) --------------------------------------------------------
__int16 __cdecl sub_66750(unsigned int a1)
{
  __int16 v1; // ax
  __int16 v2; // di
  __int16 v3; // si
  int v4; // edx
  unsigned int v5; // eax
  int v6; // esi
  __int16 v7; // cx
  int v8; // esi
  int v9; // esi
  __int16 v10; // si
  unsigned __int16 v11; // ax
  unsigned int v12; // esi
  int v13; // eax
  _WORD *v14; // edi
  char v15; // cl
  unsigned __int16 v17; // [esp-Ch] [ebp-38h]
  __int16 v18; // [esp-8h] [ebp-34h]
  int v19; // [esp+0h] [ebp-2Ch]
  __int16 v20; // [esp+4h] [ebp-28h]
  int v21; // [esp+8h] [ebp-24h] BYREF
  __int16 v22; // [esp+Ch] [ebp-20h]
  int v23; // [esp+10h] [ebp-1Ch] BYREF
  int v24; // [esp+14h] [ebp-18h]
  unsigned int v25; // [esp+18h] [ebp-14h]
  int v26; // [esp+1Ch] [ebp-10h]
  int v27; // [esp+20h] [ebp-Ch]
  int v28; // [esp+24h] [ebp-8h]
  int v29; // [esp+28h] [ebp-4h]

  v1 = *(_WORD *)(a1 + 132);
  *(_WORD *)(a1 + 130) = v1;
  v19 = *(_DWORD *)(a1 + 76);
  v20 = *(_WORD *)(a1 + 80);
  sub_57E50(v1, a1);
  sub_66610(a1);
  v2 = *(_WORD *)(a1 + 28);
  v3 = *(_WORD *)(a1 + 30);
  v28 = 1;
  while ( (*(_BYTE *)(a1 + 13) & 4) == 0 )
  {
    sub_66610(a1);
    ++v28;
  }
  *(_WORD *)(a1 + 28) = v2;
  *(_WORD *)(a1 + 30) = v3;
  v23 = 0;
  LOWORD(v24) = 0;
  v4 = *(__int16 *)(a1 + 130);
  v28 *= 8;
  v27 = (v4 - (__CFSHL__(v4 >> 31, 3) + 8 * (v4 >> 31))) >> 3;
  v18 = *(_WORD *)(a1 + 30);
  v17 = *(_WORD *)(a1 + 28);
  v26 = 0;
  v29 = 0;
  sub_57FA0(&v23, v17, v18, v27);
  *(_DWORD *)&word_EB398 = v19;
  *(&word_EB398 + 2) = v20;
  v21 = v19;
  v22 = v20;
  while ( (v28 & 0x8000u) == 0 )
  {
    v5 = sub_4A050();
    v6 = v5;
    if ( v5 )
    {
      *(_BYTE *)(v5 + 69) = 14;
      *(_BYTE *)(v5 + 63) = 9;
      *(_BYTE *)(v5 + 64) = 9;
      *(_WORD *)(v5 + 26) = *(_WORD *)(a1 + 26);
      *(_DWORD *)(v5 + 4) = (v5 >= a1) - 1;
      sub_49CD0((_WORD *)v5, 216);
      sub_57D70(v6, (int)&v21);
      sub_49A20(v6);
    }
    v7 = (__int16)v28 / 2;
    if ( (__int16)v28 / 2 < 0 )
      v7 = 0;
    if ( v7 > 8 )
      v7 = 8;
    if ( v7 >= (__int16)v29 )
    {
      v9 = (__int16)v29;
      if ( (__int16)v29 < -v7 )
      {
        ++v29;
        goto LABEL_17;
      }
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      v8 = 2 * (*(unsigned __int16 *)(a1 + 20) % 0x9Du / 79i64) - 1 + v9;
    }
    else
    {
      v8 = v29 - 1;
    }
    v29 = v8;
LABEL_17:
    if ( v7 >= (__int16)v26 )
    {
      v10 = v26;
      if ( (__int16)v26 >= -v7 )
      {
        *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
        v26 = 2 * (*(unsigned __int16 *)(a1 + 20) % 0x9Du / 79i64) - 1 + v10;
      }
      else
      {
        ++v26;
      }
    }
    else
    {
      --v26;
    }
    word_EB398 += v23;
    word_EB39A += HIWORD(v23);
    word_EB39C += v24;
    v21 = *(_DWORD *)&word_EB398;
    v22 = v29
        * ((int)((__int16)v27
               - (__CFSHL__((unsigned __int64)(__int16)v27 >> 32, 2)
                + 4 * ((unsigned __int64)(__int16)v27 >> 32))) >> 2)
        + word_EB39C;
    v11 = *(_WORD *)(a1 + 28);
    HIBYTE(v11) = (HIBYTE(v11) + 2) & 7;
    sub_57FA0(
      &v21,
      v11,
      0,
      v29
    * ((int)((__int16)v27
           - (__CFSHL__((unsigned __int64)(__int16)v27 >> 32, 2)
            + 4 * ((unsigned __int64)(__int16)v27 >> 32))) >> 2));
    --v28;
  }
  v12 = sub_10780(a1);
  v25 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v13 = sub_4A190((int)&v21, *(char *)(a1 + 67), *(char *)(a1 + 68));
  v14 = (_WORD *)v13;
  if ( !v13 )
    return v13;
  sub_65780(a1, v12, v25);
  sub_686D0(a1, v12);
  sub_68AC0(a1, v12);
  if ( v12 > dword_EA3E4[0] )
    sub_6D8B0(*(_WORD *)(a1 + 26), 7u, 1);
  v14[13] = *(_WORD *)(a1 + 26);
  v14[14] = *(_WORD *)(a1 + 28);
  v14[15] = *(_WORD *)(a1 + 30);
  v15 = 0;
  v13 = (int)(v12 - (dword_D41A0 + 28302)) / 168;
  v14[75] = v13;
  if ( !v12 || *(_BYTE *)(v12 + 63) != 3 || (*(_WORD *)(v12 + 12) & 0x8010) == 0 )
  {
LABEL_35:
    v15 = 1;
    goto LABEL_36;
  }
  if ( *(char *)(v12 + 13) >= 0 )
  {
    v13 = (*(_DWORD *)(a1 + 144) - (__CFSHL__(*(int *)(a1 + 144) >> 31, 3) + 8 * (*(int *)(a1 + 144) >> 31))) >> 3;
    if ( v13 <= *(_DWORD *)(v12 + 144) )
    {
      v13 = *(unsigned __int16 *)(a1 + 42) / 2;
      v14[21] = v13;
      goto LABEL_36;
    }
    goto LABEL_35;
  }
  v13 = (*(_DWORD *)(a1 + 144) - (__CFSHL__(*(int *)(a1 + 144) >> 31, 2) + 4 * (*(int *)(a1 + 144) >> 31))) >> 2;
  if ( v13 > *(_DWORD *)(v12 + 144) )
    goto LABEL_35;
  v13 = (int)*(unsigned __int16 *)(a1 + 42) >> 2;
  v14[21] = v13;
LABEL_36:
  if ( v15 )
  {
    LOWORD(v13) = *(_WORD *)(a1 + 42);
    v14[21] = v13;
  }
  return v13;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39A: using guessed type __int16 word_EB39A;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00066B30) --------------------------------------------------------
char __cdecl sub_66B30(int a1)
{
  unsigned int v1; // eax
  __int16 v2; // ax
  int v3; // eax
  __int16 v4; // ax
  __int16 v5; // dx
  int v6; // edi
  int v7; // eax
  int v9; // [esp+0h] [ebp-8h]
  char v10; // [esp+4h] [ebp-4h]

  v10 = 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v9 = v1;
  if ( v1 > dword_EA3E4[0] )
  {
    sub_656D0(a1, v1);
    v3 = *(__int16 *)(a1 + 132) - *(__int16 *)(a1 + 130);
    if ( v3 )
    {
      if ( v3 <= 0 )
        LOWORD(v3) = -1;
      else
        LOWORD(v3) = 1;
    }
    *(_WORD *)(a1 + 130) += 2 * v3;
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
    v4 = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
    sub_57CF0(v4, a1, (int)&word_EB398);
    if ( sub_106C0(a1, v9) )
    {
      LOBYTE(v2) = sub_57CF0(v9 + 76, a1, v9 + 76);
      v10 = 1;
    }
    else
    {
      v2 = sub_10C40((__int16 *)(a1 + 76));
      v5 = *(_WORD *)(a1 + 80);
      word_EB39C = v2;
      if ( v2 > v5
        || byte_D41B6
        && (word_EB39C = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88), v2 = *(_WORD *)(a1 + 80),
                                                                                v2 > word_EB39C) )
      {
        LOBYTE(v2) = word_EB39C;
        v10 = 1;
        *(_WORD *)(a1 + 80) = word_EB39C;
      }
      else
      {
        v6 = *(_DWORD *)(a1 + 8) - 1;
        *(_DWORD *)(a1 + 8) = v6;
        if ( v6 < 0 )
          v10 = 1;
      }
    }
    if ( v10 )
    {
      if ( *(_BYTE *)(a1 + 67) == 3 && *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(__int16 *)(a1 + 26)] + 164) + 58) )
      {
        LOBYTE(v2) = sub_57F10(a1);
      }
      else
      {
        v7 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
        if ( v7 )
        {
          *(_WORD *)(v7 + 26) = *(_WORD *)(a1 + 26);
          LOBYTE(v2) = sub_57F10(a1);
        }
        else
        {
          LOBYTE(v2) = sub_5F890(dword_EA3E4[*(__int16 *)(a1 + 26)], 0);
        }
      }
    }
  }
  else
  {
    LOBYTE(v2) = sub_66D00(a1);
  }
  return v2;
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00066D00) --------------------------------------------------------
char __cdecl sub_66D00(int a1)
{
  char v1; // dh
  int v2; // eax
  __int16 v3; // ax
  __int16 v4; // ax
  int v5; // esi
  __int16 v6; // ax
  __int16 v7; // ax
  unsigned __int16 v8; // ax
  unsigned int v9; // esi
  __int16 v10; // ax
  __int16 v11; // di
  int v12; // ecx
  unsigned __int16 v13; // ax
  __int16 v14; // ax
  char v16; // [esp+0h] [ebp-8h]
  char v17; // [esp+4h] [ebp-4h]

  v1 = *(_BYTE *)(a1 + 12);
  v16 = 0;
  v17 = 0;
  if ( (v1 & 2) == 0 )
  {
    *(_BYTE *)(a1 + 12) = v1 | 2;
    LOBYTE(v2) = sub_11CB0((__int16 *)(a1 + 76));
    if ( !(_BYTE)v2 )
    {
      sub_5F890(a1, 0);
      sub_57F10(a1);
      LOBYTE(v2) = sub_88D00();
    }
    return v2;
  }
  *(_WORD *)(a1 + 32) = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(a1 + 154));
  *(_WORD *)(a1 + 34) = sub_58210((_WORD *)(a1 + 76), (_WORD *)(a1 + 154));
  v3 = *(_WORD *)(a1 + 28)
     + sub_58350(
         *(_WORD *)(a1 + 28),
         *(_WORD *)(a1 + 32),
         *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 4),
         *(_WORD *)(*(_DWORD *)(a1 + 160) + 2));
  HIBYTE(v3) &= 7u;
  *(_WORD *)(a1 + 28) = v3;
  v4 = *(_WORD *)(a1 + 30)
     + sub_58350(
         *(_WORD *)(a1 + 30),
         *(_WORD *)(a1 + 34),
         *(unsigned __int16 *)(*(_DWORD *)(a1 + 160) + 8),
         *(_WORD *)(*(_DWORD *)(a1 + 160) + 6));
  HIBYTE(v4) &= 7u;
  *(_WORD *)(a1 + 30) = v4;
  v5 = *(__int16 *)(a1 + 132) - *(__int16 *)(a1 + 130);
  v6 = *(_WORD *)(a1 + 132) - *(_WORD *)(a1 + 130);
  if ( v5 )
  {
    if ( v5 <= 0 )
      v6 = -1;
    else
      v6 = 1;
  }
  *(_WORD *)(a1 + 130) += 2 * v6;
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  v7 = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  sub_57CF0(v7, a1, (int)&word_EB398);
  v8 = *(_WORD *)(a1 + 150);
  v9 = dword_EA3E4[v8];
  if ( v9 > dword_EA3E4[0] && sub_106C0(a1, dword_EA3E4[v8]) )
  {
    v10 = sub_65580(v9);
    LOBYTE(v2) = sub_57CF0(v10, a1, v9 + 76);
    v16 = 1;
    goto LABEL_18;
  }
  LOWORD(v2) = sub_10C40((__int16 *)(a1 + 76));
  v11 = *(_WORD *)(a1 + 80);
  word_EB39C = v2;
  if ( (__int16)v2 > v11
    || byte_D41B6
    && (word_EB39C = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88),
        LOWORD(v2) = *(_WORD *)(a1 + 80),
        (__int16)v2 > word_EB39C) )
  {
    LOBYTE(v2) = word_EB39C;
    *(_WORD *)(a1 + 80) = word_EB39C;
LABEL_17:
    v16 = 1;
    goto LABEL_18;
  }
  v12 = *(_DWORD *)(a1 + 8) - 1;
  *(_DWORD *)(a1 + 8) = v12;
  if ( v12 < 0 )
    goto LABEL_17;
  LOBYTE(v2) = !sub_11CB0((__int16 *)(a1 + 76));
  v17 = v2;
  if ( (_BYTE)v2 )
    goto LABEL_17;
LABEL_18:
  if ( v16 )
  {
    if ( v17 )
    {
      *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
      *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
      v13 = *(_WORD *)(a1 + 28);
      HIBYTE(v13) = (HIBYTE(v13) + 4) & 7;
      v14 = (unsigned __int16)sub_57FA0(&word_EB398, v13, *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
      sub_57CF0(v14, a1, (int)&word_EB398);
    }
    v2 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
    if ( v2 )
    {
      *(_WORD *)(v2 + 26) = *(_WORD *)(a1 + 26);
      LOBYTE(v2) = sub_57F10(a1);
    }
  }
  return v2;
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00066FB0) --------------------------------------------------------
int __cdecl sub_66FB0(int a1)
{
  return sub_65820(a1);
}

//----- (00066FD0) --------------------------------------------------------
char __cdecl sub_66FD0(int a1)
{
  unsigned int v1; // eax
  char v2; // dl
  int v3; // esi
  unsigned __int16 v4; // dx
  __int16 v5; // ax
  __int16 v6; // ax
  int v7; // eax
  unsigned int v8; // edi
  int v9; // eax
  __int16 v10; // ax
  __int16 v11; // dx
  int v12; // eax
  int v13; // esi
  unsigned int v15; // [esp+0h] [ebp-8h]
  char v16; // [esp+4h] [ebp-4h]

  v16 = 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v15 = v1;
  if ( v1 <= dword_EA3E4[0] )
  {
    v2 = *(_BYTE *)(a1 + 12);
    if ( (v2 & 2) == 0 )
    {
      *(_BYTE *)(a1 + 12) = v2 | 2;
      if ( sub_68940(a1) )
      {
        v3 = *(_DWORD *)(a1 + 8) + 32;
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        *(_DWORD *)(a1 + 8) = v3;
        *(_DWORD *)(a1 + 4) = v3;
        v4 = *(_WORD *)(a1 + 52);
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
        if ( v4 )
        {
          sub_57F20(v4, dword_EA3E4[v4]);
          *(_WORD *)(a1 + 52) = 0;
        }
      }
      else if ( sub_67CB0(a1) )
      {
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
      }
      else
      {
        *(_WORD *)(a1 + 32) = *(_WORD *)(a1 + 28);
        *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 30);
      }
    }
  }
  else
  {
    sub_65610(a1, v1);
  }
  v5 = *(_WORD *)(a1 + 132) - *(_WORD *)(a1 + 130);
  if ( *(__int16 *)(a1 + 132) != *(__int16 *)(a1 + 130) )
  {
    if ( *(__int16 *)(a1 + 132) - *(__int16 *)(a1 + 130) <= 0 )
      v5 = -1;
    else
      v5 = 1;
  }
  *(_WORD *)(a1 + 130) += 2 * v5;
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  v6 = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  sub_57CF0(v6, a1, (int)&word_EB398);
  v7 = sub_10780(a1);
  v8 = v7;
  if ( v7 )
  {
    if ( (*(_WORD *)(v7 + 12) & 0x8010) != 0 )
    {
      LOBYTE(v9) = sub_68740(a1, v7, 0x2Du, 22);
      if ( (_BYTE)v9 )
        return v9;
    }
    sub_65580(v8);
    sub_57CF0(v8 + 76, a1, v8 + 76);
    LOBYTE(v9) = sub_655A0(v8);
    v16 = 1;
  }
  else
  {
    v10 = sub_10C40((__int16 *)(a1 + 76));
    v11 = *(_WORD *)(a1 + 80);
    word_EB39C = v10;
    if ( v10 > v11
      || byte_D41B6
      && (word_EB39C = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88), *(__int16 *)(a1 + 80) > word_EB39C) )
    {
      LOBYTE(v9) = word_EB39C;
      *(_WORD *)(a1 + 80) = word_EB39C;
      if ( *(_BYTE *)(a1 + 64) != 4 )
      {
        v9 = sub_104D0((__int16 *)(a1 + 76));
        if ( v9 == 1 )
        {
          v12 = sub_4A190(a1 + 76, 10, 5);
          if ( v12 )
            *(_WORD *)(v12 + 26) = *(_WORD *)(a1 + 26);
          LOBYTE(v9) = sub_57F10(a1);
          goto LABEL_28;
        }
      }
    }
    else
    {
      v9 = *(_DWORD *)(a1 + 8) - 1;
      *(_DWORD *)(a1 + 8) = v9;
      if ( v9 >= 0 )
        goto LABEL_28;
    }
    v16 = 1;
  }
LABEL_28:
  if ( v16 )
  {
    if ( sub_68AC0(a1, v8) )
    {
      LOBYTE(v9) = sub_57F10(a1);
    }
    else
    {
      v9 = sub_4A190(a1 + 76, 10, 38);
      v13 = v9;
      if ( v9 )
      {
        sub_65780(a1, v8, v15);
        if ( v8 > dword_EA3E4[0] )
          sub_6D8B0(*(_WORD *)(a1 + 26), 7u, 1);
        *(_WORD *)(v13 + 26) = *(_WORD *)(a1 + 26);
        *(_WORD *)(v13 + 28) = *(_WORD *)(a1 + 28);
        *(_WORD *)(v13 + 30) = *(_WORD *)(a1 + 30);
        *(_WORD *)(v13 + 150) = (int)(v8 - (dword_D41A0 + 28302)) / 168;
        *(_WORD *)(v13 + 42) = *(_WORD *)(a1 + 42);
        *(_BYTE *)(v13 + 67) = *(_BYTE *)(a1 + 67);
        *(_BYTE *)(v13 + 68) = *(_BYTE *)(a1 + 68);
        LOBYTE(v9) = sub_57F10(a1);
      }
    }
  }
  return v9;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (000672E0) --------------------------------------------------------
char __cdecl sub_672E0(int a1)
{
  int v1; // esi
  int v2; // eax
  int v3; // edi
  int v4; // eax
  char result; // al

  if ( (*(_BYTE *)(a1 + 12) & 2) == 0 )
  {
    v1 = dword_D41A0;
    v2 = 9377 * *(_DWORD *)(dword_D41A0 + 8) + 9439;
    *(_DWORD *)(dword_D41A0 + 8) = v2;
    sub_6E450((a1 - (v1 + 28302)) / 168, -1, (v2 & 1) + 33);
    *(_BYTE *)(a1 + 12) |= 2u;
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  v3 = sub_10780(a1);
  if ( (__int16)sub_10C40(&word_EB398) <= word_EB39C )
  {
    v4 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v4 - 1;
    if ( v4 )
    {
      if ( !v3 )
        return sub_57CF0(v4, a1, (int)&word_EB398);
    }
  }
  if ( !v3 )
  {
LABEL_10:
    sub_10C80(a1, 0, *(_WORD *)(a1 + 42));
    return sub_57F10(a1);
  }
  if ( (*(_WORD *)(v3 + 12) & 0x8010) == 0 || (result = sub_68740(a1, v3, 0x2Du, 22)) == 0 )
  {
    sub_65580(v3);
    sub_57CF0(v3 + 76, a1, v3 + 76);
    sub_655A0(v3);
    goto LABEL_10;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00067410) --------------------------------------------------------
int __cdecl sub_67410(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = result - 1;
  if ( result < 0 )
    return sub_57F10(a1);
  return result;
}

//----- (00067430) --------------------------------------------------------
int __cdecl sub_67430(int a1)
{
  return sub_65820(a1);
}

//----- (00067450) --------------------------------------------------------
int __cdecl sub_67450(int a1)
{
  return sub_65820(a1);
}

//----- (00067470) --------------------------------------------------------
int __cdecl sub_67470(int a1)
{
  int result; // eax
  char v2; // dh

  result = sub_65820(a1);
  BYTE1(result) = *(_BYTE *)(a1 + 63);
  if ( BYTE1(result) )
  {
    result = sub_4A190(a1 + 76, 10, 0);
    if ( result )
    {
      *(_BYTE *)(result + 12) |= 0x80u;
      v2 = *(_BYTE *)(result + 14) | 1;
      *(_WORD *)(result + 26) = *(_WORD *)(a1 + 26);
      *(_BYTE *)(result + 14) = v2;
    }
  }
  return result;
}

//----- (000674C0) --------------------------------------------------------
__int16 __cdecl sub_674C0(int a1)
{
  unsigned int v1; // eax
  char v2; // dl
  __int16 v3; // ax
  int v4; // eax
  int v5; // esi
  unsigned int v6; // edi
  __int16 result; // ax
  __int16 v8; // cx
  int v9; // esi
  int v10; // eax
  _WORD *v11; // esi
  int v12; // esi
  unsigned int v13; // [esp+0h] [ebp-8h]
  char v14; // [esp+4h] [ebp-4h]

  v14 = 0;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
  v13 = v1;
  if ( v1 <= dword_EA3E4[0] )
  {
    v2 = *(_BYTE *)(a1 + 12);
    if ( (v2 & 2) == 0 )
    {
      *(_BYTE *)(a1 + 12) = v2 | 2;
      if ( sub_67CB0(a1) )
      {
        *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
        *(_WORD *)(a1 + 30) = *(_WORD *)(a1 + 34);
      }
    }
  }
  else
  {
    sub_65610(a1, v1);
  }
  *(_DWORD *)&word_EB398 = *(_DWORD *)(a1 + 76);
  *(&word_EB398 + 2) = *(_WORD *)(a1 + 80);
  sub_57FA0(&word_EB398, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), *(_WORD *)(a1 + 130));
  v3 = sub_10C40(&word_EB398);
  if ( v3 > word_EB39C )
    word_EB39C = v3;
  sub_57CF0(v3, a1, (int)&word_EB398);
  v4 = sub_108B0(a1);
  v5 = v4;
  v6 = v4;
  if ( v4 )
  {
    sub_65580(v4);
    sub_57CF0(v5 + 76, a1, v5 + 76);
    result = sub_655A0(v5);
    v14 = 1;
    goto LABEL_16;
  }
  result = sub_10C40((__int16 *)(a1 + 76));
  v8 = *(_WORD *)(a1 + 80);
  word_EB39C = result;
  if ( result > v8
    || byte_D41B6
    && (word_EB39C = sub_10C60((__int16 *)(a1 + 76)) - *(_WORD *)(a1 + 88),
        result = *(_WORD *)(a1 + 80),
        result > word_EB39C) )
  {
    result = word_EB39C;
    *(_WORD *)(a1 + 80) = word_EB39C;
  }
  else
  {
    v9 = *(_DWORD *)(a1 + 8) - 1;
    *(_DWORD *)(a1 + 8) = v9;
    if ( v9 >= 0 )
      goto LABEL_16;
  }
  v14 = 1;
LABEL_16:
  if ( v14 )
  {
    if ( v6 )
    {
      if ( *(_BYTE *)(a1 + 67) == 10 && *(_BYTE *)(a1 + 68) == 69 )
        v10 = sub_4A190(a1 + 76, 10, 70);
      else
        v10 = sub_4A190(a1 + 76, 10, 12);
      v11 = (_WORD *)v10;
      if ( v10 )
      {
        sub_65780(a1, v6, v13);
        v11[13] = *(_WORD *)(a1 + 26);
        v11[14] = *(_WORD *)(a1 + 28);
        v11[15] = *(_WORD *)(a1 + 30);
      }
      v12 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
      if ( v12 )
      {
        sub_65780(a1, v6, v13);
        sub_6D8B0(*(_WORD *)(a1 + 26), 1u, 1);
        *(_WORD *)(v12 + 26) = *(_WORD *)(a1 + 26);
        *(_WORD *)(v12 + 28) = *(_WORD *)(a1 + 28);
        *(_WORD *)(v12 + 30) = *(_WORD *)(a1 + 30);
        *(_DWORD *)(v12 + 16) = *(_DWORD *)(a1 + 16);
      }
    }
    return sub_57F10(a1);
  }
  return result;
}
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (000676F0) --------------------------------------------------------
_WORD *__cdecl sub_676F0(int a1)
{
  _WORD *result; // eax

  result = (_WORD *)sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
  if ( result )
  {
    result[13] = *(_WORD *)(a1 + 26);
    result[14] = *(_WORD *)(a1 + 28);
    result[15] = *(_WORD *)(a1 + 30);
    result[21] = *(_WORD *)(a1 + 42);
    return (_WORD *)sub_57F10(a1);
  }
  return result;
}

//----- (00067740) --------------------------------------------------------
int __cdecl sub_67740(int a1)
{
  return sub_65820(a1);
}

//----- (00067760) --------------------------------------------------------
int __cdecl sub_67760(int a1)
{
  return sub_65820(a1);
}

//----- (00067780) --------------------------------------------------------
int __cdecl sub_67780(int a1)
{
  return sub_65820(a1);
}

//----- (000677A0) --------------------------------------------------------
int __cdecl sub_677A0(int a1)
{
  int result; // eax
  int v2; // edx

  result = sub_65820(a1);
  if ( result )
  {
    v2 = *(char *)(a1 + 70);
    *(_BYTE *)(result + 70) = 0;
    *(_DWORD *)(result + 8) = v2;
  }
  return result;
}

//----- (000677D0) --------------------------------------------------------
int __cdecl sub_677D0(int a1)
{
  int result; // eax
  int v2; // edx

  result = sub_65820(a1);
  if ( result )
  {
    v2 = *(char *)(a1 + 70);
    LOBYTE(v2) = v2 & 0xF0;
    *(_BYTE *)(result + 70) = 0;
    *(_DWORD *)(result + 4) = v2;
    *(_DWORD *)(result + 8) = v2;
  }
  return result;
}

//----- (00067800) --------------------------------------------------------
int __cdecl sub_67800(int a1)
{
  unsigned __int8 v1; // al
  int result; // eax

  v1 = *(_BYTE *)(a1 + 70);
  if ( v1 < 0x10u )
  {
    if ( v1 != 2 )
      goto LABEL_9;
    goto LABEL_7;
  }
  if ( v1 < 0x13u )
    goto LABEL_9;
  if ( v1 <= 0x13u )
  {
LABEL_7:
    *(_BYTE *)(dword_D41A4 + 224) = 8;
    goto LABEL_10;
  }
  if ( v1 == 25 )
  {
    *(_BYTE *)(dword_D41A4 + 224) = 4;
    goto LABEL_10;
  }
LABEL_9:
  *(_BYTE *)(dword_D41A4 + 224) = 2;
LABEL_10:
  result = sub_65820(a1);
  if ( result )
  {
    while ( result != dword_EA3E4[0] )
    {
      *(_BYTE *)(result + 70) = *(_BYTE *)(a1 + 70);
      *(_WORD *)(result + 40) = *(_WORD *)(a1 + 40);
      *(_WORD *)(result + 26) = *(_WORD *)(a1 + 26);
      result = dword_EA3E4[*(unsigned __int16 *)(result + 52)];
    }
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00067890) --------------------------------------------------------
unsigned int __cdecl sub_67890(int a1)
{
  unsigned int result; // eax

  result = sub_65820(a1);
  if ( result )
  {
    result = dword_EA3E4[*(__int16 *)(a1 + 26)];
    if ( result > dword_EA3E4[0] && *(_BYTE *)(result + 63) == 3 && *(_BYTE *)(result + 64) <= 1u )
      *(_WORD *)(result + 150) = 0;
  }
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (000678E0) --------------------------------------------------------
int __cdecl sub_678E0(int a1)
{
  int result; // eax
  int v2; // edx

  result = sub_65820(a1);
  if ( result )
  {
    v2 = 8 * *(char *)(a1 + 70);
    *(_DWORD *)(result + 4) = v2;
    *(_DWORD *)(result + 8) = v2;
  }
  return result;
}

//----- (00067910) --------------------------------------------------------
int __cdecl sub_67910(int a1)
{
  int result; // eax
  int v2; // edx

  result = sub_65820(a1);
  if ( result )
  {
    v2 = *(char *)(a1 + 70);
    *(_BYTE *)(result + 70) = 0;
    *(_DWORD *)(result + 4) = v2;
  }
  return result;
}

//----- (00067940) --------------------------------------------------------
int __cdecl sub_67940(int a1)
{
  return sub_65820(a1);
}

//----- (00067960) --------------------------------------------------------
int __usercall sub_67960@<eax>(unsigned int a1@<esi>, int a2)
{
  int v2; // eax
  unsigned int v3; // eax
  unsigned int i; // edi
  signed int v5; // eax
  int v6; // eax
  unsigned __int16 v7; // di
  __int16 v8; // ax
  __int16 v9; // ax
  __int16 v10; // dx
  int result; // eax
  __int16 v12; // dx
  signed int v13; // [esp+0h] [ebp-1Ch]
  __int16 *v14; // [esp+4h] [ebp-18h]
  void (__noreturn *v15)(); // [esp+8h] [ebp-14h]
  int v16; // [esp+Ch] [ebp-10h]
  unsigned int v17; // [esp+10h] [ebp-Ch]
  char v18; // [esp+14h] [ebp-8h]
  char v19; // [esp+18h] [ebp-4h]

  v16 = 0;
  v18 = 0;
  v19 = 0;
  v15 = sub_10000;
  if ( *(_DWORD *)(a2 + 8) == *(_DWORD *)(a2 + 4) && *(_WORD *)(a2 + 42) >= 2u )
  {
    v2 = *(__int16 *)(a2 + 26);
    *(_WORD *)(a2 + 150) = 0;
    v3 = dword_EA3E4[v2];
    v17 = v3;
    if ( v3 > dword_EA3E4[0] && *(_BYTE *)(v3 + 63) == 3 )
    {
      for ( i = *(_DWORD *)(dword_D41A4 + 38535); i > dword_EA3E4[0]; i = *(_DWORD *)i )
      {
        if ( *(_BYTE *)(i + 64) == 78
          && *(unsigned __int16 *)(i + 50) != *(__int16 *)(a2 + 26)
          && *(_WORD *)(i + 42) < 2u )
        {
          v13 = *(__int16 *)(*(_DWORD *)(v17 + 160) + 28);
          v5 = sub_583F0((_WORD *)(i + 76), (_WORD *)(a2 + 76));
          if ( v5 < v13 && v5 < (int)v15 )
          {
            v16 = i;
            v15 = (void (__noreturn *)())v5;
          }
        }
      }
      if ( v16 )
      {
        *(_DWORD *)(a2 + 4) = 32;
        *(_DWORD *)(a2 + 8) = *(_DWORD *)(a2 + 4) - 1;
        *(_WORD *)(a2 + 150) = (v16 - (dword_D41A0 + 28302)) / 168;
        sub_655C0((_WORD *)a2, v16);
      }
    }
  }
  v6 = *(__int16 *)(a2 + 132) - *(__int16 *)(a2 + 130);
  if ( v6 )
  {
    if ( v6 <= 0 )
      LOWORD(v6) = -1;
    else
      LOWORD(v6) = 1;
  }
  *(_WORD *)(a2 + 130) += 2 * v6;
  v7 = *(_WORD *)(a2 + 150);
  if ( v7 )
  {
    a1 = dword_EA3E4[v7];
    if ( a1 <= dword_EA3E4[0] || *(int *)(a1 + 8) < 0 || (*(_BYTE *)(a1 + 13) & 4) != 0 )
    {
      *(_WORD *)(a2 + 150) = 0;
    }
    else
    {
      sub_65610(a2, dword_EA3E4[v7]);
      if ( sub_106C0(a2, a1) )
        v18 = 1;
    }
  }
  v14 = (__int16 *)(a2 + 76);
  if ( v18 )
  {
    sub_65580(a1);
    sub_57CF0(a1 + 76, a2, a1 + 76);
    sub_655A0(a1);
    *(_BYTE *)(a1 + 70) = 8;
    sub_4A190((int)v14, 10, 0);
    return sub_57F10(a2);
  }
  else
  {
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a2 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a2 + 80);
    v8 = (unsigned __int16)sub_57FA0(&word_EB398, *(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 130));
    sub_57CF0(v8, a2, (int)&word_EB398);
    v9 = sub_10C40(v14);
    v10 = *(_WORD *)(a2 + 80);
    word_EB39C = v9;
    if ( v9 > v10
      || byte_D41B6 && (word_EB39C = sub_10C60(v14) - *(_WORD *)(a2 + 88), *(__int16 *)(a2 + 80) > word_EB39C) )
    {
      v19 = 1;
      *(_WORD *)(a2 + 80) = word_EB39C;
    }
    result = *(_DWORD *)(a2 + 8) - 1;
    *(_DWORD *)(a2 + 8) = result;
    if ( result < 0 )
      v19 = 1;
    if ( v19 )
    {
      result = sub_4A190(a2 + 76, *(char *)(a2 + 67), *(char *)(a2 + 68));
      if ( result )
      {
        *(_WORD *)(result + 50) = *(_WORD *)(a2 + 26);
        v12 = *(_WORD *)(a2 + 42);
        *(_BYTE *)(result + 70) = 0;
        *(_WORD *)(result + 42) = v12;
        return sub_57F10(a2);
      }
    }
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00067CB0) --------------------------------------------------------
int __cdecl sub_67CB0(int a1)
{
  unsigned int v1; // edi
  unsigned int jj; // esi
  unsigned int v3; // eax
  unsigned int mm; // esi
  unsigned int v5; // eax
  _BYTE *v7; // esi
  unsigned int i; // edi
  unsigned int v9; // edx
  unsigned int v10; // eax
  unsigned int k; // edi
  __int16 v12; // cx
  unsigned int v13; // eax
  unsigned int m; // edi
  int n; // eax
  unsigned int v16; // eax
  unsigned int v17; // edi
  unsigned int nn; // esi
  unsigned int v19; // edx
  unsigned int v20; // eax
  unsigned int i2; // esi
  __int16 v22; // cx
  unsigned int v23; // eax
  unsigned int v24; // edi
  unsigned int v25; // esi
  unsigned __int8 v26; // al
  int v27; // eax
  int v28; // edx
  unsigned int v29; // eax
  unsigned int i5; // esi
  unsigned int v31; // eax
  unsigned int i6; // esi
  int i7; // eax
  unsigned int v34; // eax
  unsigned int v35; // edi
  unsigned int ii; // esi
  unsigned int v37; // edx
  unsigned int v38; // eax
  int v39; // edi
  unsigned int i4; // esi
  unsigned int v41; // eax
  unsigned int v42; // [esp+0h] [ebp-44h]
  int v43; // [esp+4h] [ebp-40h]
  int v44; // [esp+8h] [ebp-3Ch]
  int v45; // [esp+Ch] [ebp-38h]
  int j; // [esp+10h] [ebp-34h]
  unsigned int v47; // [esp+14h] [ebp-30h]
  unsigned int v48; // [esp+18h] [ebp-2Ch]
  int kk; // [esp+1Ch] [ebp-28h]
  int i1; // [esp+20h] [ebp-24h]
  int i3; // [esp+24h] [ebp-20h]
  int v52; // [esp+28h] [ebp-1Ch]
  int v53; // [esp+2Ch] [ebp-18h]
  int v54; // [esp+30h] [ebp-14h]
  unsigned int v55; // [esp+34h] [ebp-10h]
  int v56; // [esp+38h] [ebp-Ch]
  unsigned int v57; // [esp+40h] [ebp-4h]

  switch ( *(_BYTE *)(a1 + 64) )
  {
    case 0:
    case 3:
    case 4:
    case 0x12:
    case 0x13:
    case 0x16:
    case 0x1A:
    case 0x1C:
    case 0x1E:
      v57 = -1;
      v43 = dword_EA3E4[*(__int16 *)(a1 + 26)];
      v7 = 0;
      for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
      {
        if ( *(_WORD *)(i + 26) != *(_WORD *)(a1 + 26) && (*(_BYTE *)(i + 12) & 0x20) == 0 )
        {
          v9 = *(__int16 *)(*(_DWORD *)(v43 + 160) + 28);
          if ( sub_583F0((_WORD *)(i + 76), (_WORD *)(a1 + 76)) <= v9 )
          {
            v10 = *(_BYTE *)(i + 64) == 2
                ? sub_685D0((__int16 *)a1, i, 0x71u, 0x71u)
                : sub_68490((__int16 *)a1, i, 0x71u, 0x71u);
            if ( v10 < v57 )
            {
              v7 = (_BYTE *)i;
              v57 = v10;
            }
          }
        }
      }
      for ( j = 0; j < 29; ++j )
      {
        if ( j != 22 )
        {
          for ( k = *(_DWORD *)(dword_D41A4 + 4 * j + 38403); k > dword_EA3E4[0]; k = *(_DWORD *)k )
          {
            v12 = *(_WORD *)(a1 + 26);
            if ( *(_WORD *)(k + 26) != v12
              && *(_BYTE *)(k + 57)
              && (*(_BYTE *)(k + 73) != 14 || *(unsigned __int16 *)(k + 40) != v12) )
            {
              v13 = sub_68490((__int16 *)a1, k, 0x71u, 0x71u);
              if ( v13 < v57 )
              {
                v7 = (_BYTE *)k;
                v57 = v13;
              }
            }
          }
        }
      }
      if ( !v7 )
      {
        for ( m = *(_DWORD *)(dword_D41A4 + 38491); m > dword_EA3E4[0]; m = *(_DWORD *)m )
        {
          if ( *(_BYTE *)(m + 57) )
          {
            for ( n = *(unsigned __int16 *)(m + 52); ; n = *(unsigned __int16 *)(v53 + 52) )
            {
              v53 = dword_EA3E4[n];
              if ( v53 == dword_EA3E4[0] )
                break;
              v16 = sub_68490((__int16 *)a1, v53, 0x71u, 0x71u);
              if ( v16 < v57 )
              {
                v7 = (_BYTE *)v53;
                v57 = v16;
              }
            }
          }
        }
      }
      if ( !v7 )
        return 0;
      *(_WORD *)(a1 + 150) = (int)&v7[-dword_D41A0 - 28302] / 168;
      sub_68BD0(a1, v7);
      sub_655C0((_WORD *)a1, (int)v7);
      if ( v7[63] == 3 && !v7[64] )
        sub_5EF70((unsigned int)v7);
      return 1;
    case 1:
    case 0x11:
      v24 = -1;
      v56 = 0;
      v25 = *(_DWORD *)(dword_D41A4 + 38523);
      break;
    case 7:
    case 8:
    case 0xB:
    case 0xC:
      v48 = -1;
      v35 = 0;
      v44 = dword_EA3E4[*(__int16 *)(a1 + 26)];
      for ( ii = *(_DWORD *)(dword_D41A4 + 38519); ii > dword_EA3E4[0]; ii = *(_DWORD *)ii )
      {
        if ( *(_WORD *)(ii + 26) != *(_WORD *)(a1 + 26) && (*(_BYTE *)(ii + 12) & 0x20) == 0 )
        {
          v37 = *(__int16 *)(*(_DWORD *)(v44 + 160) + 28);
          if ( sub_583F0((_WORD *)(ii + 76), (_WORD *)(a1 + 76)) <= v37 )
          {
            v38 = sub_68490((__int16 *)a1, ii, 0x71u, 0x71u);
            if ( v38 < v48 )
            {
              v35 = ii;
              v48 = v38;
            }
          }
        }
      }
      if ( !v35 )
        return 0;
      *(_WORD *)(a1 + 150) = (int)(v35 - (dword_D41A0 + 28302)) / 168;
      sub_655C0((_WORD *)a1, v35);
      if ( *(_BYTE *)(v35 + 63) == 3 && !*(_BYTE *)(v35 + 64) )
        sub_5EF70(v35);
      return 1;
    case 9:
      v1 = -1;
      v54 = 0;
      for ( jj = *(_DWORD *)(dword_D41A4 + 38519); jj > dword_EA3E4[0]; jj = *(_DWORD *)jj )
      {
        if ( *(_WORD *)(jj + 26) != *(_WORD *)(a1 + 26) && (*(_BYTE *)(jj + 12) & 0x20) == 0 )
        {
          v42 = *(__int16 *)(a1 + 132) * *(_DWORD *)(a1 + 4);
          if ( sub_583F0((_WORD *)(jj + 76), (_WORD *)(a1 + 76)) <= v42 )
          {
            v3 = *(_BYTE *)(jj + 64) == 2
               ? sub_685D0((__int16 *)a1, jj, 0x71u, 0x71u)
               : sub_68490((__int16 *)a1, jj, 0x71u, 0x71u);
            if ( v3 < v1 )
            {
              v54 = jj;
              v1 = v3;
            }
          }
        }
      }
      for ( kk = 0; kk < 29; ++kk )
      {
        for ( mm = *(_DWORD *)(dword_D41A4 + 4 * kk + 38403); mm > dword_EA3E4[0]; mm = *(_DWORD *)mm )
        {
          if ( *(_WORD *)(mm + 26) != *(_WORD *)(a1 + 26)
            && *(_BYTE *)(mm + 57)
            && (*(_BYTE *)(mm + 73) != 14 || *(unsigned __int16 *)(mm + 40) != *(__int16 *)(a1 + 26)) )
          {
            v5 = sub_68490((__int16 *)a1, mm, 0x71u, 0x200u);
            if ( v5 < v1 )
            {
              v54 = mm;
              v1 = v5;
            }
          }
        }
      }
      if ( !v54 )
        return 0;
      *(_WORD *)(a1 + 150) = (v54 - (dword_D41A0 + 28302)) / 168;
      sub_655C0((_WORD *)a1, v54);
      return 1;
    case 0x10:
      v55 = -1;
      v45 = dword_EA3E4[*(__int16 *)(a1 + 26)];
      v17 = 0;
      for ( nn = *(_DWORD *)(dword_D41A4 + 38519); nn > dword_EA3E4[0]; nn = *(_DWORD *)nn )
      {
        if ( *(_WORD *)(nn + 26) != *(_WORD *)(a1 + 26) && (*(_BYTE *)(nn + 12) & 0x20) == 0 )
        {
          v19 = *(__int16 *)(*(_DWORD *)(v45 + 160) + 28);
          if ( sub_583F0((_WORD *)(nn + 76), (_WORD *)(a1 + 76)) <= v19 )
          {
            v20 = *(_BYTE *)(nn + 64) == 2
                ? sub_685D0((__int16 *)a1, nn, 0x100u, 0x71u)
                : sub_68490((__int16 *)a1, nn, 0x100u, 0x71u);
            if ( v20 < v55 )
            {
              v17 = nn;
              v55 = v20;
            }
          }
        }
      }
      for ( i1 = 0; i1 < 29; ++i1 )
      {
        for ( i2 = *(_DWORD *)(dword_D41A4 + 4 * i1 + 38403); i2 > dword_EA3E4[0]; i2 = *(_DWORD *)i2 )
        {
          v22 = *(_WORD *)(a1 + 26);
          if ( *(_WORD *)(i2 + 26) != v22
            && *(_BYTE *)(i2 + 57)
            && (*(_BYTE *)(i2 + 73) != 14 || *(unsigned __int16 *)(i2 + 40) != v22) )
          {
            v23 = sub_68490((__int16 *)a1, i2, 0x100u, 0x71u);
            if ( v23 < v55 )
            {
              v17 = i2;
              v55 = v23;
            }
          }
        }
      }
      if ( !v17 )
        return 0;
      *(_WORD *)(a1 + 150) = (int)(v17 - (dword_D41A0 + 28302)) / 168;
      sub_655C0((_WORD *)a1, v17);
      if ( *(_BYTE *)(v17 + 63) == 3 && !*(_BYTE *)(v17 + 64) )
        sub_5EF70(v17);
      return 1;
    case 0x19:
      v39 = 0;
      v47 = -1;
      for ( i3 = 0; i3 < 29; ++i3 )
      {
        for ( i4 = *(_DWORD *)(dword_D41A4 + 4 * i3 + 38403); i4 > dword_EA3E4[0]; i4 = *(_DWORD *)i4 )
        {
          if ( *(_WORD *)(i4 + 26) != *(_WORD *)(a1 + 26) )
          {
            if ( *(_BYTE *)(i4 + 57) )
            {
              if ( sub_3A7F0((_BYTE *)i4) )
              {
                v41 = sub_68490((__int16 *)a1, i4, 0x71u, 0x71u);
                if ( v41 < v47 )
                {
                  v39 = i4;
                  v47 = v41;
                }
              }
            }
          }
        }
      }
      if ( !v39 )
        return 0;
      *(_WORD *)(a1 + 150) = (v39 - (dword_D41A0 + 28302)) / 168;
      sub_655C0((_WORD *)a1, v39);
      return 1;
    default:
      return 0;
  }
  while ( v25 > dword_EA3E4[0] )
  {
    v26 = *(_BYTE *)(v25 + 64);
    if ( v26 < 0x27u )
      goto LABEL_105;
    if ( v26 <= 0x27u )
    {
      v27 = *(__int16 *)(a1 + 26);
      v28 = *(unsigned __int16 *)(v25 + 148);
    }
    else
    {
      if ( v26 != 57 )
        goto LABEL_105;
      v27 = *(__int16 *)(a1 + 26);
      v28 = *(unsigned __int16 *)(v25 + 40);
    }
    if ( v28 != v27 )
    {
      if ( *(_BYTE *)(v25 + 57) )
      {
        v29 = sub_68490((__int16 *)a1, v25, 0x71u, 0x71u);
        if ( v29 < v24 )
        {
          v56 = v25;
          v24 = v29;
        }
      }
    }
LABEL_105:
    v25 = *(_DWORD *)v25;
  }
  for ( i5 = *(_DWORD *)(dword_D41A4 + 38527); i5 > dword_EA3E4[0]; i5 = *(_DWORD *)i5 )
  {
    if ( *(unsigned __int16 *)(i5 + 148) != *(__int16 *)(a1 + 26) )
    {
      if ( *(_BYTE *)(i5 + 57) )
      {
        if ( (byte_D93C2[4 * *(char *)(i5 + 70)] & 8) == 0 )
        {
          v31 = sub_68490((__int16 *)a1, i5, 0x71u, 0x71u);
          if ( v31 < v24 )
          {
            v56 = i5;
            v24 = v31;
          }
        }
      }
    }
  }
  for ( i6 = *(_DWORD *)(dword_D41A4 + 38491); i6 > dword_EA3E4[0]; i6 = *(_DWORD *)i6 )
  {
    if ( *(_BYTE *)(i6 + 57) )
    {
      for ( i7 = *(unsigned __int16 *)(i6 + 52); ; i7 = *(unsigned __int16 *)(v52 + 52) )
      {
        v52 = dword_EA3E4[i7];
        if ( v52 == dword_EA3E4[0] )
          break;
        v34 = sub_68490((__int16 *)a1, v52, 0x71u, 0x71u);
        if ( v34 < v24 )
        {
          v24 = v34;
          v56 = v52;
        }
      }
    }
  }
  if ( !v56 )
    return 0;
  *(_WORD *)(a1 + 150) = (v56 - (dword_D41A0 + 28302)) / 168;
  sub_655C0((_WORD *)a1, v56);
  return 1;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068490) --------------------------------------------------------
int __cdecl sub_68490(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  _WORD *v4; // edi
  __int16 v5; // ax
  __int16 v6; // ax
  signed int v8; // ebx
  int v9; // esi
  int v10; // edi
  int v11; // eax
  int v12; // edx
  unsigned __int16 v13; // [esp+0h] [ebp-8h]
  unsigned __int16 v14; // [esp+4h] [ebp-4h]

  sub_65580(a2);
  v4 = a1 + 38;
  v5 = sub_581E0(a1 + 38, (_WORD *)(a2 + 76));
  v13 = sub_582B0(a1[14], v5);
  if ( v13 <= a3 && (v6 = sub_58210(v4, (_WORD *)(a2 + 76)), v14 = sub_582B0(a1[15], v6), v14 <= a4) )
  {
    v8 = sub_58490(v4, (_WORD *)(a2 + 76));
    sub_655A0(a2);
    if ( v8 <= 5120 )
    {
      v9 = v8 * (_DWORD)off_DBF50[v13];
      v10 = v8 * dword_DB750[v13];
      v11 = v8 * (_DWORD)off_DBF50[v14];
      v12 = (__int16)((dword_DB750[v14] * v8) >> 14);
      return (v11 >> 16) * (v11 >> 16)
           + (v9 >> 16) * (v9 >> 16)
           + (__int16)(v10 >> 14) * (__int16)(v10 >> 14)
           + v12 * v12;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    sub_655A0(a2);
    return -1;
  }
}
// DB750: using guessed type int dword_DB750[256];
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();

//----- (000685D0) --------------------------------------------------------
int __cdecl sub_685D0(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  _WORD *v4; // ebx
  _WORD *v5; // esi
  __int16 v6; // ax
  __int16 v8; // ax
  unsigned __int16 v9; // di
  signed int v10; // eax
  int v11; // ebx
  int v12; // ecx
  int v13; // esi
  int v14; // eax
  unsigned __int16 v15; // [esp+0h] [ebp-4h]

  v4 = (_WORD *)(a2 + 76);
  v5 = a1 + 38;
  v6 = sub_581E0(a1 + 38, (_WORD *)(a2 + 76));
  v15 = sub_582B0(a1[14], v6);
  if ( v15 > a3 )
    return -1;
  v8 = sub_58210(v5, v4);
  v9 = sub_582B0(a1[15], v8);
  if ( v9 > a4 )
    return -1;
  v10 = sub_58490(v5, v4);
  if ( v10 > 5120 )
    return -1;
  v11 = v10 * (_DWORD)off_DBF50[v15];
  v12 = v10 * dword_DB750[v15];
  v13 = v10 * (_DWORD)off_DBF50[v9];
  v14 = (__int16)((dword_DB750[v9] * v10) >> 14);
  return (__int16)(v12 >> 14) * (__int16)(v12 >> 14) + (v11 >> 16) * (v11 >> 16) + (v13 >> 16) * (v13 >> 16) + v14 * v14;
}
// DB750: using guessed type int dword_DB750[256];
// DBF50: using guessed type void (__noreturn *off_DBF50[2])();

//----- (000686D0) --------------------------------------------------------
int __cdecl sub_686D0(int a1, unsigned int a2)
{
  int result; // eax
  unsigned int v3; // ebx

  result = a2;
  v3 = dword_EA3E4[*(__int16 *)(a1 + 26)];
  if ( v3 > dword_EA3E4[0] && *(_BYTE *)(v3 + 63) == 3 && *(_BYTE *)(v3 + 64) <= 1u && a2 && a2 > dword_EA3E4[0] )
  {
    result = (int)(a2 - (dword_D41A0 + 28302)) / 168;
    *(_WORD *)(v3 + 150) = result;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068740) --------------------------------------------------------
char __cdecl sub_68740(int a1, int a2, unsigned __int16 a3, __int16 a4)
{
  char v4; // cl
  char v5; // ch
  unsigned __int8 v6; // al
  __int16 v7; // ax
  int v8; // esi
  int v9; // eax
  __int16 v10; // dx
  int v11; // eax

  v4 = 0;
  v5 = 0;
  if ( (*(_DWORD *)(a1 + 144) - (__CFSHL__(*(int *)(a1 + 144) >> 31, 2) + 4 * (*(int *)(a1 + 144) >> 31))) >> 2 > *(_DWORD *)(a2 + 144) )
    return v4;
  if ( *(_BYTE *)(a1 + 67) != 10 )
  {
    if ( *(_BYTE *)(a1 + 64) != 13 )
      goto LABEL_23;
    goto LABEL_22;
  }
  v6 = *(_BYTE *)(a1 + 68);
  if ( v6 >= 0x11u )
  {
    if ( v6 > 0x11u )
    {
      if ( v6 < 0x43u )
      {
        if ( v6 != 22 )
          goto LABEL_23;
      }
      else if ( v6 > 0x43u && (v6 < 0x47u || v6 > 0x47u && v6 != 89) )
      {
        goto LABEL_23;
      }
    }
LABEL_22:
    v5 = 1;
    goto LABEL_23;
  }
  if ( v6 < 9u )
  {
    if ( v6 > 1u )
      goto LABEL_23;
    goto LABEL_22;
  }
  if ( v6 <= 9u || v6 >= 0xBu && (v6 <= 0xBu || v6 == 15) )
    goto LABEL_22;
LABEL_23:
  if ( v5 )
  {
    sub_6E450((a2 - (dword_D41A0 + 28302)) / 168, -1, 28);
    sub_6D8B0((a2 - (dword_D41A0 + 28302)) / 168, 8u, 1);
    *(_DWORD *)(a2 + 144) -= (*(_DWORD *)(a1 + 144)
                            - (__CFSHL__(*(int *)(a1 + 144) >> 31, 2)
                             + 4 * (*(int *)(a1 + 144) >> 31))) >> 2;
    v7 = *(_WORD *)(a1 + 28);
    HIBYTE(v7) = (HIBYTE(v7) + 4) & 7;
    *(_WORD *)(a1 + 32) = v7;
    v8 = sub_582F0(0, *(_WORD *)(a1 + 30));
    v9 = -(v8 * sub_582B0(0, *(_WORD *)(a1 + 30)));
    BYTE1(v9) &= 7u;
    *(_WORD *)(a1 + 34) = v9;
    *(_WORD *)(a1 + 30) = v9;
    if ( (*(_BYTE *)(a2 + 12) & 0x10) != 0 )
    {
      v10 = *(_WORD *)(a1 + 42);
      *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32);
      *(_WORD *)(a1 + 42) = 2 * v10;
    }
    else
    {
      *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
      *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 20) % a3 - a4;
    }
    *(_WORD *)(a1 + 150) = *(_WORD *)(a1 + 26);
    *(_WORD *)(a1 + 26) = *(_WORD *)(a2 + 26);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
    v11 = dword_EA3E4[*(unsigned __int16 *)(a1 + 150)];
    *(_BYTE *)(a1 + 65) = *(_BYTE *)(v11 + 63);
    *(_BYTE *)(a1 + 66) = *(_BYTE *)(v11 + 64);
    *(_DWORD *)&word_EB398 = *(_DWORD *)(a2 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(a2 + 80);
    LOWORD(v11) = *(_WORD *)(a2 + 88);
    word_EB39C += v11;
    sub_57CF0(v11, a1, (int)&word_EB398);
    return 1;
  }
  return v4;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;
// EB39C: using guessed type __int16 word_EB39C;

//----- (00068940) --------------------------------------------------------
char __cdecl sub_68940(int a1)
{
  unsigned __int8 v1; // al
  __int16 v2; // dx
  unsigned int i; // ebx
  signed int v4; // edi
  __int16 v5; // ax
  signed int v7; // [esp+0h] [ebp-18h]
  void (__noreturn *v8)(); // [esp+8h] [ebp-10h]
  int v9; // [esp+Ch] [ebp-Ch]
  int v10; // [esp+10h] [ebp-8h]
  char v11; // [esp+14h] [ebp-4h]

  v11 = 0;
  v10 = 0;
  v1 = *(_BYTE *)(a1 + 64);
  v8 = sub_10000;
  if ( v1 < 0xCu )
  {
    if ( v1 < 2u )
    {
      if ( v1 )
        return v11;
    }
    else if ( v1 > 5u && (v1 < 8u || v1 > 9u) )
    {
      return v11;
    }
  }
  else if ( v1 > 0xCu )
  {
    if ( v1 < 0x1Au )
    {
      if ( v1 < 0x16u || v1 > 0x17u )
        return v11;
    }
    else if ( v1 > 0x1Au && (v1 < 0x1Cu || v1 > 0x1Cu && v1 != 30) )
    {
      return v11;
    }
  }
  v2 = *(_WORD *)(a1 + 26);
  if ( v2 )
  {
    v9 = dword_EA3E4[v2];
    if ( *(_BYTE *)(v9 + 63) == 3 )
    {
      for ( i = *(_DWORD *)(dword_D41A4 + 38535); i > dword_EA3E4[0]; i = *(_DWORD *)i )
      {
        if ( *(_BYTE *)(i + 64) == 78
          && *(unsigned __int16 *)(i + 50) == *(__int16 *)(a1 + 26)
          && *(_WORD *)(i + 54) == 0xFFFF )
        {
          v7 = *(__int16 *)(*(_DWORD *)(v9 + 160) + 28);
          v4 = sub_583F0((_WORD *)(i + 76), (_WORD *)(v9 + 76));
          if ( v4 < v7 && v4 < (int)v8 )
          {
            v5 = sub_581E0((_WORD *)(a1 + 76), (_WORD *)(i + 76));
            if ( (unsigned __int16)sub_582B0(*(_WORD *)(a1 + 28), v5) < 0xAAu )
            {
              v10 = i;
              v8 = (void (__noreturn *)())v4;
            }
          }
        }
      }
      if ( v10 )
      {
        *(_WORD *)(a1 + 150) = (v10 - (dword_D41A0 + 28302)) / 168;
        v11 = 1;
        sub_655C0((_WORD *)a1, v10);
      }
    }
  }
  return v11;
}
// 10000: using guessed type void __noreturn sub_10000();
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068AC0) --------------------------------------------------------
char __cdecl sub_68AC0(int a1, int a2)
{
  unsigned __int8 v2; // al
  char v3; // dl
  unsigned __int16 v4; // di
  int v5; // edx

  v2 = *(_BYTE *)(a1 + 64);
  v3 = 0;
  if ( v2 < 0xCu )
  {
    if ( v2 < 2u )
    {
      if ( v2 )
        return v3;
    }
    else if ( v2 > 5u && (v2 < 8u || v2 > 9u) )
    {
      return v3;
    }
  }
  else if ( v2 > 0xCu )
  {
    if ( v2 < 0x1Au )
    {
      if ( v2 < 0x16u || v2 > 0x17u )
        return v3;
    }
    else if ( v2 > 0x1Au && (v2 < 0x1Cu || v2 > 0x1Cu && v2 != 30) )
    {
      return v3;
    }
  }
  if ( a2
    && *(_BYTE *)(a2 + 63) == 10
    && *(_BYTE *)(a2 + 64) == 78
    && *(unsigned __int16 *)(a2 + 50) == *(__int16 *)(a1 + 26)
    && *(_WORD *)(a2 + 54) == 0xFFFF )
  {
    sub_4A190(a1 + 76, 10, 0);
    sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 26);
    v4 = *(_WORD *)(a1 + 38);
    if ( v4 )
    {
      v5 = dword_EA3E4[v4];
      *(_WORD *)(a2 + 54) = *(char *)(v5 + 64);
      *(_WORD *)(a2 + 52) = *(char *)(v5 + 70);
      *(_WORD *)(v5 + 46) = 1;
    }
    return 1;
  }
  return v3;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068BD0) --------------------------------------------------------
char __cdecl sub_68BD0(int a1, _BYTE *a2)
{
  char result; // al

  result = a2[63];
  if ( result == 5 )
  {
    result = a2[64];
    if ( !result )
      a2[61] = 32;
  }
  return result;
}

//----- (00068BF0) --------------------------------------------------------
int sub_68BF0()
{
  __int16 i; // si
  int result; // eax
  unsigned int j; // ebx
  _DWORD *k; // ebx

  for ( i = 0; i < 29; ++i )
  {
    result = dword_D41A4;
    for ( j = *(_DWORD *)(dword_D41A4 + 4 * i + 38403); j > dword_EA3E4[0]; j = *(_DWORD *)j )
    {
      if ( *(int *)(j + 8) >= 0 )
      {
        result = sub_68C70(j);
      }
      else
      {
        *(_BYTE *)(j + 57) = -6;
        *(_BYTE *)(j + 58) = 0;
      }
    }
  }
  for ( k = *(_DWORD **)(dword_D41A4 + 38523); (unsigned int)k > dword_EA3E4[0]; k = (_DWORD *)*k )
    result = sub_68C70((int)k);
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068C70) --------------------------------------------------------
int __cdecl sub_68C70(int a1)
{
  char v1; // dh
  int v2; // eax
  unsigned int v3; // eax
  int i; // eax
  unsigned int v6; // eax

  if ( *(_BYTE *)(a1 + 57) )
  {
    for ( i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52) )
    {
      v6 = dword_EA3E4[i];
      if ( v6 <= dword_EA3E4[0] )
        break;
      *(_BYTE *)(v6 + 57) = *(_BYTE *)(a1 + 57);
    }
    --*(_BYTE *)(a1 + 57);
    return 0;
  }
  if ( (*(_BYTE *)(a1 + 12) & 1) != 0 )
    return 0;
  v1 = *(_BYTE *)(a1 + 58);
  if ( v1 )
  {
    *(_BYTE *)(a1 + 58) = v1 - 1;
    return 0;
  }
  else
  {
    if ( (unsigned int)sub_584D0(
                         (_WORD *)(a1 + 76),
                         (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12)
                                                                   + dword_D41A0
                                                                   + 11240)]
                                 + 76)) < 0x2400000 )
    {
      v2 = *(unsigned __int16 *)(a1 + 52);
      *(_BYTE *)(a1 + 57) = 16;
      while ( 1 )
      {
        v3 = dword_EA3E4[v2];
        if ( v3 <= dword_EA3E4[0] )
          break;
        *(_BYTE *)(v3 + 57) = *(_BYTE *)(a1 + 57) + 2;
        v2 = *(unsigned __int16 *)(v3 + 52);
      }
    }
    *(_BYTE *)(a1 + 58) = 0;
    return 0;
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068D50) --------------------------------------------------------
bool __cdecl sub_68D50(int a1, int *a2)
{
  int v2; // esi
  unsigned __int16 v3; // cx

  if ( a2[36] < 0 )
    return 0;
  if ( a2[2] < 0 )
    return 0;
  v2 = *(_DWORD *)(a1 + 136);
  if ( v2 )
  {
    v3 = *(_WORD *)(a2[41] + 58);
    if ( !v3 || v2 > *(_DWORD *)(dword_EA3E4[v3] + 144) )
      return 0;
  }
  if ( a2[36] >= *(_DWORD *)(a1 + 140) && *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
    return 1;
  return *(_WORD *)(a1 + 46) != *(_WORD *)(a1 + 48);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068DE0) --------------------------------------------------------
int __cdecl sub_68DE0(int a1, int a2)
{
  __int16 v2; // bx
  int v3; // ebx

  v2 = *(_WORD *)(a1 + 46);
  if ( v2 == *(_WORD *)(a1 + 48) )
  {
    v3 = *(_DWORD *)(a2 + 136);
    if ( v3 >= 0 )
      *(_DWORD *)(a2 + 136) = -*(_DWORD *)(a1 + 140);
    else
      *(_DWORD *)(a2 + 136) = v3 - *(_DWORD *)(a1 + 140);
    return 1;
  }
  else
  {
    if ( v2 && *(int *)(a2 + 136) > 0 )
      *(_DWORD *)(a2 + 136) = 0;
    return 0;
  }
}

//----- (00068E50) --------------------------------------------------------
int __cdecl sub_68E50(int a1, int a2, int a3)
{
  char v3; // cl
  unsigned __int16 v4; // cx
  unsigned __int16 v5; // ax
  __int16 v6; // ax
  int i; // eax
  int v8; // esi
  unsigned __int16 v9; // cx
  unsigned __int16 v10; // ax
  __int16 v11; // ax
  int j; // esi
  int v14; // [esp+0h] [ebp-8h] BYREF
  int v15; // [esp+4h] [ebp-4h]

  v14 = *(_DWORD *)(a2 + 76);
  LOWORD(v15) = *(_WORD *)(a2 + 80);
  v3 = *(_BYTE *)(a1 + 13);
  if ( (v3 & 1) != 0 )
  {
    if ( *(_BYTE *)(a3 + 64) == 4 && (v4 = *(_WORD *)(a3 + 150)) != 0 )
    {
      LOWORD(v15) = *(_WORD *)(dword_EA3E4[v4] + 82) + *(_WORD *)(dword_EA3E4[v4] + 80);
    }
    else
    {
      v5 = *(_WORD *)(a1 + 28) - 512;
      HIBYTE(v5) &= 7u;
      sub_57FA0(&v14, v5, 0, 256);
    }
    v6 = sub_10C40((__int16 *)&v14);
    if ( v6 > (__int16)v15 )
    {
      v14 = *(_DWORD *)(a2 + 76);
      LOWORD(v15) = *(_WORD *)(a2 + 80);
    }
    for ( i = *(unsigned __int16 *)(a2 + 52); ; i = *(unsigned __int16 *)(v8 + 52) )
    {
      v8 = dword_EA3E4[i];
      if ( v8 == dword_EA3E4[0] )
        break;
      sub_57CF0((__int16)&v14, v8, (int)&v14);
    }
  }
  else if ( (v3 & 2) != 0 )
  {
    if ( *(_BYTE *)(a3 + 64) == 4 && (v9 = *(_WORD *)(a3 + 150)) != 0 )
    {
      LOWORD(v15) = *(_WORD *)(dword_EA3E4[v9] + 82) + *(_WORD *)(dword_EA3E4[v9] + 80);
    }
    else
    {
      v10 = *(_WORD *)(a1 + 28);
      HIBYTE(v10) = (HIBYTE(v10) + 2) & 7;
      sub_57FA0(&v14, v10, 0, 256);
    }
    v11 = sub_10C40((__int16 *)&v14);
    if ( v11 > (__int16)v15 )
    {
      v14 = *(_DWORD *)(a2 + 76);
      LOWORD(v15) = *(_WORD *)(a2 + 80);
    }
    for ( j = dword_EA3E4[*(unsigned __int16 *)(a2 + 52)];
          j != dword_EA3E4[0];
          j = dword_EA3E4[*(unsigned __int16 *)(j + 52)] )
    {
      sub_57CF0((__int16)&v14, j, (int)&v14);
    }
  }
  return sub_57CF0((__int16)&v14, a2, (int)&v14);
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00068FF0) --------------------------------------------------------
int __cdecl sub_68FF0(int a1, char a2, char a3)
{
  int v3; // edx
  __int16 v4; // ax
  unsigned int i; // esi
  int v6; // eax
  int v7; // ecx
  __int16 v8; // ax
  int v9; // eax
  char v11; // [esp+0h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 8);
  v11 = 0;
  if ( v3 && (*(_DWORD *)(a1 + 8) = v3 - 1, v3 == 1) )
  {
    sub_57F10(a1);
  }
  else
  {
    v4 = sub_10C40((__int16 *)(a1 + 76));
    sub_580E0(a1 + 76, v4, 0, 0x2000, -128);
    if ( (*(_BYTE *)(a1 + 62) & 3) == 0 )
    {
      for ( i = *(_DWORD *)(dword_D41A4 + 38519); i > dword_EA3E4[0]; i = *(_DWORD *)i )
      {
        if ( !*(_BYTE *)(i + 64) && *(int *)(i + 8) >= 0 )
        {
          v6 = *(_DWORD *)(i + 164);
          if ( *(_WORD *)(v6 + 56) == *(_WORD *)(dword_D41A0 + 12)
            && (*(_BYTE *)(a1 + 12) & 1) == 0
            && *(_WORD *)(v6 + 2 * *(char *)(a1 + 64) + 819) )
          {
            *(_BYTE *)(a1 + 12) |= 1u;
          }
          if ( sub_106C0(i, a1) && !*(_WORD *)(*(_DWORD *)(i + 164) + 2 * a2 + 819) )
          {
            sub_6E450((int)(i - (dword_D41A0 + 28302)) / 168, -1, 18);
            v7 = dword_D41A0;
            *(_BYTE *)(a1 + 12) |= 1u;
            v7 += 28302;
            *(_BYTE *)(a1 + 15) &= ~2u;
            *(_WORD *)(a1 + 40) = (int)(i - v7) / 168;
            *(_BYTE *)(a1 + 69) = a3;
            *(_WORD *)(a1 + 54) = 64;
            *(_WORD *)(2 * a2 + *(_DWORD *)(i + 164) + 819) = (a1 - v7) / 168;
            *(_BYTE *)(*(_DWORD *)(i + 164) + a2 + 1027) = 1;
            v8 = *(_WORD *)(a1 + 74);
            if ( v8 )
            {
              if ( v8 == 2 )
                v11 = 1;
              *(_WORD *)(a1 + 74) = 0;
            }
            else
            {
              v9 = *(_DWORD *)(i + 164);
              if ( *(__int16 *)(v9 + 1105) == -1 || *(__int16 *)(v9 + 1107) != -1 )
                v11 = 1;
            }
            if ( v11 )
            {
              *(_WORD *)(*(_DWORD *)(i + 164) + 1105) = *(char *)(a1 + 64);
              *(_BYTE *)(*(_DWORD *)(i + 164) + 1109) = *(_BYTE *)(*(char *)(a1 + 64) + *(_DWORD *)(i + 164) + 1079);
            }
            else
            {
              *(_WORD *)(*(_DWORD *)(i + 164) + 1107) = *(char *)(a1 + 64);
              *(_BYTE *)(*(_DWORD *)(i + 164) + 1110) = *(_BYTE *)(*(char *)(a1 + 64) + *(_DWORD *)(i + 164) + 1079);
            }
            sub_6D5E0(a1, *(_BYTE *)(*(char *)(a1 + 64) + *(_DWORD *)(i + 164) + 1079));
            return 1;
          }
        }
      }
    }
  }
  return 0;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00069250) --------------------------------------------------------
int __cdecl sub_69250(int a1)
{
  int result; // eax

  result = sub_68FF0(a1, *(_BYTE *)(a1 + 64), *(_BYTE *)(a1 + 69) - 2);
  if ( result )
  {
    result = (*(int (__cdecl **)(int))((char *)&off_D781E + 14 * *(char *)(a1 + 64)))(a1 + 76);
    if ( result )
      *(_BYTE *)(result + 69) += 2;
  }
  return result;
}
// D781E: using guessed type int (__cdecl *off_D781E)(int);

//----- (000692A0) --------------------------------------------------------
int __cdecl sub_692A0(int a1)
{
  return sub_68FF0(a1, *(_BYTE *)(a1 + 64), *(_BYTE *)(a1 + 69) - 1);
}

//----- (000692C0) --------------------------------------------------------
char __cdecl sub_692C0(int a1)
{
  char result; // al
  char v2; // ah

  result = sub_59DC0((_WORD *)a1);
  if ( result )
  {
    result = 3 * *(_BYTE *)(a1 + 64) + 1;
    *(_BYTE *)(a1 + 69) = result;
    v2 = *(_BYTE *)(a1 + 15);
    *(_WORD *)(a1 + 38) = 0;
    *(_BYTE *)(a1 + 15) = v2 | 2;
  }
  return result;
}

//----- (00069300) --------------------------------------------------------
void __cdecl sub_69300(int a1, int a2)
{
  char v2; // ah
  int v3; // eax
  int v4; // edx
  int v5; // edx
  int v6; // [esp+0h] [ebp-4h]

  if ( !*(_WORD *)(a1 + 54) )
  {
    *(_WORD *)(a1 + 38) = (a2 - (dword_D41A0 + 28302)) / 168;
    v2 = *(_BYTE *)(a1 + 12);
    *(_BYTE *)(a1 + 69) = 78;
    *(_BYTE *)(a1 + 12) = v2 & 0xFE;
    v3 = *(unsigned __int16 *)(a1 + 40);
    *(_DWORD *)(a1 + 16) = 0;
    v6 = dword_EA3E4[v3];
    *(_DWORD *)&word_EB398 = *(_DWORD *)(v6 + 76);
    *(&word_EB398 + 2) = *(_WORD *)(v6 + 80);
    sub_57CF0(v6, a1, (int)&word_EB398);
    *(_WORD *)(*(_DWORD *)(v6 + 164) + 2 * *(char *)(a1 + 64) + 819) = 0;
    *(_WORD *)(a1 + 74) = 0;
    v4 = *(_DWORD *)(v6 + 164);
    if ( *(char *)(a1 + 64) == *(_WORD *)(v4 + 1107) )
    {
      *(_WORD *)(v4 + 1107) = -1;
      *(_WORD *)(a1 + 74) = 1;
    }
    v5 = *(_DWORD *)(v6 + 164);
    if ( *(char *)(a1 + 64) == *(_WORD *)(v5 + 1105) )
    {
      *(_WORD *)(v5 + 1105) = -1;
      *(_WORD *)(a1 + 74) = 2;
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];
// EB398: using guessed type __int16 word_EB398;

//----- (000693F0) --------------------------------------------------------
int __cdecl sub_693F0(int a1)
{
  unsigned int v1; // ebx
  int v2; // eax
  __int16 v3; // si
  int result; // eax
  __int16 v5; // dx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (int *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = sub_6DCA0(
                 v1,
                 v1 + 76,
                 0,
                 (__int16 *)&byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)],
                 *(_WORD *)(v1 + 130),
                 1);
          v6 = v2;
          if ( v2 )
          {
            sub_68E50(v1, v2, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 42) = *(_WORD *)(a1 + 42);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0(
              (_WORD *)(v6 + 154),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30),
              0x4000);
            if ( *(_WORD *)(*(_DWORD *)(v1 + 164) + 56) == *(_WORD *)(dword_D41A0 + 12) )
              sub_49C90(v6, 42);
          }
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00069600) --------------------------------------------------------
int __cdecl sub_69600(int a1)
{
  return sub_692A0(a1);
}

//----- (00069620) --------------------------------------------------------
int __cdecl sub_69620(int a1)
{
  return sub_69250(a1);
}

//----- (00069640) --------------------------------------------------------
void __cdecl sub_69640(int a1)
{
  int *v1; // eax
  char *v2; // edi
  char v3; // dl
  int v4; // esi
  char v5; // dl
  char v6; // ah
  char v7; // cl
  __int16 v8; // di
  __int16 v9; // dx
  int v10; // [esp+4h] [ebp-4h]

  if ( *(__int16 *)(a1 + 46) <= 0 )
    goto LABEL_28;
  v1 = (int *)dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
  v10 = (int)v1;
  if ( (unsigned int)v1 > dword_EA3E4[0] )
  {
    if ( sub_68D50(a1, v1) )
    {
      if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
      {
        v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
        v3 = v2[24];
        if ( v3 )
        {
          if ( (unsigned __int8)v3 <= 3u )
          {
            v4 = sub_4A190(v10 + 76, 9, 17);
            if ( v4 )
            {
              *(_WORD *)(v4 + 130) += *(_WORD *)(v10 + 130);
              sub_68E50(v10, v4, a1);
              *(_WORD *)(v4 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
              v5 = v2[24];
              if ( v5 )
              {
                if ( (unsigned __int8)v5 <= 1u )
                {
                  *(_BYTE *)(v4 + 68) = 54;
                }
                else if ( v5 == 2 )
                {
                  *(_BYTE *)(v4 + 68) = 69;
                }
              }
              *(_BYTE *)(v4 + 67) = 10;
              *(_WORD *)(v4 + 26) = *(_WORD *)(v10 + 26);
              *(_DWORD *)(v4 + 144) = *(_DWORD *)(a1 + 144);
              *(_WORD *)(v4 + 80) += *(_WORD *)(v10 + 88);
              *(_WORD *)(v4 + 28) = *(_WORD *)(*(_DWORD *)(v10 + 164) + 24) + *(_WORD *)(v10 + 28);
              *(_WORD *)(v4 + 30) = *(_WORD *)(*(_DWORD *)(v10 + 164) + 26) + *(_WORD *)(v10 + 30);
              *(_DWORD *)(v4 + 16) = (*(unsigned __int16 *)(a1 + 42) << 8) * (*(unsigned __int16 *)(a1 + 42) << 8);
              *(_BYTE *)(*(_DWORD *)(v10 + 164) + 340) = 0;
              *(_DWORD *)(v4 + 154) = *(_DWORD *)(v10 + 76);
              *(_WORD *)(v4 + 158) = *(_WORD *)(v10 + 80);
              sub_57FA0(
                (_WORD *)(v4 + 154),
                *(_WORD *)(*(_DWORD *)(v10 + 164) + 24) + *(_WORD *)(v10 + 28),
                *(_WORD *)(*(_DWORD *)(v10 + 164) + 26) + *(_WORD *)(v10 + 30),
                0x4000);
              sub_6E450((v4 - (dword_D41A0 + 28302)) / 168, -1, 40);
              sub_68DE0(a1, v10);
              goto LABEL_26;
            }
          }
        }
        else
        {
          sub_69900(a1, v10);
        }
      }
      else
      {
        v6 = *(_BYTE *)(a1 + 60);
        if ( v6 )
        {
          if ( *(_BYTE *)(a1 + 70) )
          {
            if ( v6 == 1 )
              sub_69900(a1, v10);
            v7 = *(_BYTE *)(a1 + 60) + 1;
            *(_BYTE *)(a1 + 60) = v7;
            if ( v7 > 3 )
            {
              *(_BYTE *)(a1 + 60) = 0;
              sub_68DE0(a1, v10);
              goto LABEL_26;
            }
          }
          else
          {
            *(_BYTE *)(a1 + 60) = 0;
          }
        }
      }
      sub_68DE0(a1, v10);
    }
    else
    {
      *(_WORD *)(a1 + 46) = 1;
    }
  }
LABEL_26:
  v8 = *(_WORD *)(a1 + 46) - 1;
  *(_WORD *)(a1 + 46) = v8;
  if ( !v8 )
    sub_6D880(a1);
LABEL_28:
  v9 = *(_WORD *)(a1 + 54);
  if ( v9 )
    *(_WORD *)(a1 + 54) = v9 - 1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00069900) --------------------------------------------------------
void __cdecl sub_69900(int a1, int a2)
{
  int v2; // ebx
  __int16 v3; // ax
  int v4; // eax

  v2 = sub_4A190(a2 + 76, 9, 1);
  if ( v2 )
  {
    *(_WORD *)(v2 + 130) += *(_WORD *)(a2 + 130);
    sub_68E50(a2, v2, a1);
    v3 = (a1 - (dword_D41A0 + 28302)) / 168;
    *(_BYTE *)(v2 + 67) = 10;
    *(_WORD *)(v2 + 38) = v3;
    *(_BYTE *)(v2 + 68) = 12;
    *(_WORD *)(v2 + 26) = *(_WORD *)(a2 + 26);
    *(_WORD *)(v2 + 80) += *(_WORD *)(a2 + 88);
    *(_DWORD *)(v2 + 144) = *(_DWORD *)(a1 + 144);
    *(_DWORD *)(v2 + 16) = 200;
    *(_BYTE *)(*(_DWORD *)(a2 + 164) + 340) = 0;
    *(_DWORD *)(v2 + 154) = *(_DWORD *)(a2 + 76);
    *(_WORD *)(v2 + 158) = *(_WORD *)(a2 + 80);
    sub_57FA0(
      (_WORD *)(v2 + 154),
      *(_WORD *)(*(_DWORD *)(a2 + 164) + 24) + *(_WORD *)(a2 + 28),
      *(_WORD *)(*(_DWORD *)(a2 + 164) + 26) + *(_WORD *)(a2 + 30),
      10240);
    *(_WORD *)(v2 + 28) = *(_WORD *)(*(_DWORD *)(a2 + 164) + 24) + *(_WORD *)(a2 + 28);
    v4 = dword_D41A0 + 28302;
    *(_WORD *)(v2 + 30) = *(_WORD *)(*(_DWORD *)(a2 + 164) + 26) + *(_WORD *)(a2 + 30);
    sub_6E450((v2 - v4) / 168, -1, 40);
  }
}
// D41A0: using guessed type int dword_D41A0;

//----- (00069A70) --------------------------------------------------------
int __cdecl sub_69A70(int a1)
{
  return sub_692A0(a1);
}

//----- (00069A90) --------------------------------------------------------
int __cdecl sub_69A90(int a1)
{
  return sub_69250(a1);
}

//----- (00069AB0) --------------------------------------------------------
int __cdecl sub_69AB0(int a1)
{
  unsigned int v1; // ebx
  unsigned __int16 v2; // si
  char *v3; // edx
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  unsigned int v7; // edx
  __int16 v8; // ax
  int result; // eax
  __int16 v10; // di
  int v11; // [esp+0h] [ebp-8h]
  int v12; // [esp+4h] [ebp-4h]

  if ( *(__int16 *)(a1 + 46) <= 0 )
  {
    sub_6D880(a1);
  }
  else
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (int *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = *(_WORD *)(*(_DWORD *)(v1 + 164) + 58);
          v3 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v4 = 1;
          if ( v2 )
            v4 = *(_DWORD *)(dword_EA3E4[v2] + 16) + 1;
          *(_BYTE *)(*(_DWORD *)(v1 + 164) + v4 + 590) = *v3;
          *(_BYTE *)(*(_DWORD *)(v1 + 164) + v4 + 599) = v3[24];
          sub_68DE0(a1, v1);
          v5 = sub_4A190(v1 + 76, 9, 10);
          v12 = v5;
          v11 = v5;
          if ( v5 )
          {
            *(_WORD *)(a1 + 46) = *(_WORD *)(a1 + 48) - 1;
            *(_WORD *)(v5 + 130) += *(_WORD *)(v1 + 130);
            sub_68E50(v1, v5, a1);
            v6 = dword_D41A0 + 28302;
            *(_WORD *)(v12 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v12 + 42) = *(_WORD *)(a1 + 42);
            *(_WORD *)(v12 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v12 + 80) += *(_WORD *)(v1 + 88);
            *(_DWORD *)(v12 + 144) = *(_DWORD *)(a1 + 144);
            v7 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(v1 + 164) + 58)];
            if ( v7 <= dword_EA3E4[0] )
            {
              *(_DWORD *)(v12 + 154) = *(_DWORD *)(v1 + 76);
              *(_WORD *)(v12 + 158) = *(_WORD *)(v1 + 80);
              sub_57FA0((_WORD *)(v12 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
              v8 = sub_10C40((__int16 *)(v12 + 154));
              *(_BYTE *)(v12 + 67) = 3;
              *(_BYTE *)(v12 + 68) = 2;
              *(_WORD *)(v12 + 158) = v8;
            }
            else
            {
              *(_BYTE *)(v12 + 67) = 10;
              *(_BYTE *)(v12 + 68) = 43;
              *(_WORD *)(v12 + 150) = (int)(v7 - v6) / 168;
            }
            *(_DWORD *)(v11 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_WORD *)(v11 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v11 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
            sub_6E450((v11 - (dword_D41A0 + 28302)) / 168, -1, 15);
          }
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 0;
      }
    }
  }
  result = a1;
  v10 = *(_WORD *)(a1 + 54);
  if ( v10 )
    *(_WORD *)(a1 + 54) = v10 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00069D70) --------------------------------------------------------
int __cdecl sub_69D70(int a1)
{
  return sub_692A0(a1);
}

//----- (00069D90) --------------------------------------------------------
int __cdecl sub_69D90(int a1)
{
  return sub_69250(a1);
}

//----- (00069DB0) --------------------------------------------------------
void __cdecl sub_69DB0(int a1)
{
  unsigned int v1; // esi
  __int16 v2; // di
  char v3; // dl
  int v4; // eax
  char v5; // cl
  int v6; // eax
  int v7; // ecx
  __int16 v8; // cx
  __int16 v9; // cx
  int v10; // [esp+0h] [ebp-8h]
  char *v11; // [esp+4h] [ebp-4h]

  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( *(_BYTE *)(v1 + 64) == 1 )
        v10 = 64;
      else
        v10 = 2;
      if ( *(__int16 *)(*(_DWORD *)(v1 + 164) + 12) >= 0 )
        v2 = 1;
      else
        v2 = -1;
      if ( !sub_68D50(a1, (int *)v1) || *(_WORD *)(*(_DWORD *)(v1 + 164) + 14) )
      {
        if ( *(_WORD *)(*(_DWORD *)(v1 + 164) + 14) )
          *(_WORD *)(a1 + 46) = 1;
      }
      else
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v3 = *(_BYTE *)(a1 + 12);
          if ( v3 >= 0 )
          {
            v4 = dword_D41A0 + 28302;
            *(_BYTE *)(a1 + 12) = v3 | 0x80;
            sub_6E450((int)(v1 - v4) / 168, -1, 19);
          }
        }
        if ( *(__int16 *)(a1 + 46) == *(__int16 *)(a1 + 48) - v10 )
        {
          v5 = *(_BYTE *)(a1 + 12);
          if ( v5 < 0 )
            *(_BYTE *)(a1 + 12) = v5 & 0x7F;
        }
        v11 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
        _wcpp_1_unwind_leave__98(v1);
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          sub_6D8B0(*(_WORD *)(a1 + 40), 3u, 1);
          *(_WORD *)(*(_DWORD *)(v1 + 164) + 12) = v2 * *(_WORD *)(v1 + 132) * (*(_WORD *)v11 + 1);
        }
        else
        {
          *(_WORD *)(*(_DWORD *)(v1 + 164) + 12) = v2 * *(_WORD *)v11 * *(_WORD *)(v1 + 132);
        }
        *(_WORD *)(v1 + 130) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 12);
        if ( (*(_BYTE *)(a1 + 62) & 3) == 0 )
        {
          v6 = sub_4A190(v1 + 76, 10, 2);
          if ( v6 )
          {
            v7 = 4 * *(_DWORD *)(v6 + 8);
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_DWORD *)(v6 + 8) = v7;
          }
        }
        sub_68DE0(a1, v1);
      }
      v8 = *(_WORD *)(a1 + 46) - 1;
      *(_WORD *)(a1 + 46) = v8;
      if ( !v8 )
      {
        *(_WORD *)(*(_DWORD *)(v1 + 164) + 12) = *(_WORD *)(v1 + 132) * v2;
        *(_WORD *)(v1 + 130) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 12);
        *(_BYTE *)(a1 + 12) &= ~0x80u;
        sub_6D880(a1);
      }
    }
  }
  v9 = *(_WORD *)(a1 + 54);
  if ( v9 )
    *(_WORD *)(a1 + 54) = v9 - 1;
}
// 5D520: using guessed type int __cdecl _wcpp_1_unwind_leave__98(_DWORD);
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (00069FF0) --------------------------------------------------------
int __cdecl sub_69FF0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006A010) --------------------------------------------------------
int __cdecl sub_6A010(int a1)
{
  return sub_69250(a1);
}

//----- (0006A030) --------------------------------------------------------
char __cdecl sub_6A030(int a1)
{
  unsigned __int16 v1; // ax
  unsigned int v2; // esi
  int v3; // edi
  int v4; // eax
  int v5; // ecx
  char v6; // al
  int v7; // eax
  unsigned int v8; // ecx
  int v9; // edx
  __int16 v10; // dx
  unsigned __int16 v11; // di
  int v12; // eax
  __int16 v13; // si
  int v15; // [esp+0h] [ebp-Ch]
  int v16; // [esp+4h] [ebp-8h]

  v1 = *(_WORD *)(a1 + 40);
  v2 = dword_EA3E4[v1];
  v3 = -1;
  if ( v2 > dword_EA3E4[0] && *(__int16 *)(a1 + 46) > 0 )
  {
    if ( sub_68D50(a1, (int *)v2) )
    {
      if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
      {
        sub_6D8B0(*(_WORD *)(a1 + 40), 4u, 1);
        v4 = sub_4A190(v2 + 76, 5, (unsigned __int8)byte_DA818[80 * *(char *)(a1 + 64) + 26 + 26 * *(char *)(a1 + 70)]);
        v5 = v4;
        if ( v4 )
        {
          v6 = 8 * *(_BYTE *)(v4 + 64);
          *(_BYTE *)(v5 + 73) = 12;
          *(_BYTE *)(v5 + 69) = v6 + 7;
          *(_WORD *)(v5 + 40) = *(_WORD *)(a1 + 40);
          *(_WORD *)(v5 + 26) = *(_WORD *)(v2 + 26);
          v15 = dword_D41A0;
          *(_WORD *)(a1 + 150) = (v5 - (dword_D41A0 + 28302)) / 168;
          *(_BYTE *)(v5 + 12) |= 1u;
          v7 = *(_DWORD *)(v2 + 164);
          *(_BYTE *)(v2 + 12) |= 0x21u;
          if ( *(_WORD *)(v7 + 56) != *(_WORD *)(v15 + 12) )
          {
            *(_BYTE *)(v5 + 12) &= ~1u;
            *(_BYTE *)(v2 + 12) |= 1u;
          }
          sub_6E450((int)(v2 - (dword_D41A0 + 28302)) / 168, -1, 60);
        }
      }
      sub_68DE0(a1, v2);
    }
    else
    {
      *(_WORD *)(a1 + 46) = 1;
    }
    v1 = *(_WORD *)(*(_DWORD *)(v2 + 164) + 56);
    if ( v1 != *(_WORD *)(dword_D41A0 + 12) )
    {
      v1 = *(_WORD *)(a1 + 150);
      v8 = dword_EA3E4[v1];
      if ( v8 > dword_EA3E4[0] )
      {
        v9 = *(__int16 *)(a1 + 48);
        v16 = *(__int16 *)(a1 + 46);
        LOBYTE(v1) = *(_WORD *)(a1 + 46);
        if ( v16 <= v9 - 7 )
        {
          v1 = *(_WORD *)(a1 + 46);
          if ( (__int16)v1 < 7 )
          {
            LOBYTE(v1) = v1 & 1;
            v3 = (unsigned __int8)v1;
          }
        }
        else
        {
          v3 = ((_BYTE)v9 - (_BYTE)v16) & 1;
        }
        if ( v3 != -1 )
        {
          if ( v3 )
          {
            if ( v3 == 1 )
            {
              *(_BYTE *)(v8 + 12) |= 1u;
              *(_BYTE *)(v2 + 12) &= ~1u;
            }
          }
          else
          {
            *(_BYTE *)(v8 + 12) &= ~1u;
            *(_BYTE *)(v2 + 12) |= 1u;
          }
        }
      }
    }
    v10 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v10;
    if ( !v10 )
    {
      v11 = *(_WORD *)(a1 + 150);
      if ( v11 )
      {
        sub_57F10(dword_EA3E4[v11]);
        *(_WORD *)(a1 + 150) = 0;
      }
      v12 = *(_DWORD *)(v2 + 164);
      *(_BYTE *)(v2 + 12) &= ~0x20u;
      if ( *(_WORD *)(v12 + 56) == *(_WORD *)(dword_D41A0 + 12) )
        sub_6E450((int)(v2 - (dword_D41A0 + 28302)) / 168, -1, 60);
      else
        *(_BYTE *)(v2 + 12) &= ~1u;
      LOBYTE(v1) = sub_6D880(a1);
    }
  }
  v13 = *(_WORD *)(a1 + 54);
  if ( v13 )
    *(_WORD *)(a1 + 54) = v13 - 1;
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006A2C0) --------------------------------------------------------
int __cdecl sub_6A2C0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006A2E0) --------------------------------------------------------
int __cdecl sub_6A2E0(int a1)
{
  return sub_69250(a1);
}

//----- (0006A300) --------------------------------------------------------
void __cdecl sub_6A300(int a1)
{
  int *v1; // esi
  int v2; // edx
  int v3; // ecx
  int v4; // edi
  __int16 v5; // ax
  __int16 v6; // cx

  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = (int *)dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( (unsigned int)v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, v1) && v1[36] >= *(_DWORD *)(a1 + 140) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
          sub_6E450(((int)v1 - dword_D41A0 - 28302) / 168, -1, 25);
        if ( v1[2] < v1[1] )
        {
          if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
            sub_6D8B0(*(_WORD *)(a1 + 40), 5u, 1);
          v2 = v1[1] * *(unsigned __int16 *)(a1 + 42) / 100 + v1[2];
          v3 = v1[1];
          v1[2] = v2;
          if ( v2 > v3 )
            v1[2] = v3;
          v4 = v1[34];
          if ( v4 >= 0 )
            v1[34] = -*(_DWORD *)(a1 + 140);
          else
            v1[34] = v4 - *(_DWORD *)(a1 + 140);
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v5 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v5;
    if ( !v5 )
      sub_6D880(a1);
  }
  v6 = *(_WORD *)(a1 + 54);
  if ( v6 )
    *(_WORD *)(a1 + 54) = v6 - 1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006A440) --------------------------------------------------------
int __cdecl sub_6A440(int a1)
{
  return sub_692A0(a1);
}

//----- (0006A460) --------------------------------------------------------
int __cdecl sub_6A460(int a1)
{
  return sub_69250(a1);
}

//----- (0006A480) --------------------------------------------------------
char __cdecl sub_6A480(int a1)
{
  int v1; // eax
  unsigned int v2; // esi
  __int16 v3; // cx

  LOWORD(v1) = *(_WORD *)(a1 + 40);
  v2 = dword_EA3E4[(unsigned __int16)v1];
  if ( v2 <= dword_EA3E4[0] || *(__int16 *)(a1 + 46) <= 0 )
    goto LABEL_15;
  LOBYTE(v1) = byte_DA818[80 * *(char *)(a1 + 64) + 26 + 26 * *(char *)(a1 + 70)];
  if ( !(_BYTE)v1 )
  {
    v1 = sub_68D50(a1, (int *)v2);
    if ( v1 )
    {
      *(_BYTE *)(v2 + 13) |= 0x40u;
      LOBYTE(v1) = sub_68DE0(a1, v2);
      --*(_WORD *)(a1 + 46);
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if ( (_BYTE)v1 == 1 )
  {
    v1 = sub_68D50(a1, (int *)v2);
    if ( v1 )
    {
      if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        *(_BYTE *)(v2 + 14) |= 0x40u;
      --*(_WORD *)(a1 + 46);
      LOBYTE(v1) = sub_68DE0(a1, v2);
      goto LABEL_13;
    }
LABEL_12:
    *(_WORD *)(a1 + 46) = 0;
  }
LABEL_13:
  if ( !*(_WORD *)(a1 + 46) )
  {
    *(_DWORD *)(v2 + 12) &= 0xFFBFBFFF;
    LOBYTE(v1) = sub_6D880(a1);
  }
LABEL_15:
  v3 = *(_WORD *)(a1 + 54);
  if ( v3 )
    *(_WORD *)(a1 + 54) = v3 - 1;
  return v1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006A580) --------------------------------------------------------
int __cdecl sub_6A580(int a1)
{
  return sub_692A0(a1);
}

//----- (0006A5A0) --------------------------------------------------------
int __cdecl sub_6A5A0(int a1)
{
  return sub_69250(a1);
}

//----- (0006A5C0) --------------------------------------------------------
int __cdecl sub_6A5C0(int a1)
{
  unsigned int v1; // ebx
  char *v2; // edx
  char v3; // al
  int v4; // eax
  __int16 v5; // ax
  int v6; // edx
  __int16 v7; // ax
  int v8; // ecx
  __int16 v9; // bx
  int result; // eax
  __int16 v11; // si
  int v12; // [esp+0h] [ebp-20h]
  int v13; // [esp+4h] [ebp-1Ch]
  char *v14; // [esp+Ch] [ebp-14h]
  int v15; // [esp+10h] [ebp-10h]
  int v16; // [esp+14h] [ebp-Ch]
  __int16 v17; // [esp+18h] [ebp-8h]
  __int16 v18; // [esp+1Ch] [ebp-4h]

  v12 = 0;
  v13 = 0;
  if ( *(__int16 *)(a1 + 46) <= 0 )
    goto LABEL_29;
  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
  if ( v1 > dword_EA3E4[0] )
  {
    if ( sub_68D50(a1, (int *)v1) )
    {
      if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
      {
        v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
        v3 = v2[24];
        v14 = v2;
        if ( v3 )
        {
          if ( (unsigned __int8)v3 <= 2u )
          {
            v18 = 0;
            v17 = (v3 != 1) + 1;
            while ( v18 < v17 )
            {
              v16 = sub_6DCA0(v1, v1 + 76, 7u, (__int16 *)v14, *(_WORD *)(v1 + 130), 1);
              if ( v16 )
              {
                sub_68E50(v1, v16, a1);
                *(_WORD *)(v16 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
                *(_WORD *)(v16 + 42) = *(_WORD *)(a1 + 42);
                *(_WORD *)(v16 + 26) = *(_WORD *)(v1 + 26);
                *(_WORD *)(v16 + 80) += *(_WORD *)(v1 + 88);
                *(_DWORD *)(v16 + 144) = *(_DWORD *)(a1 + 144);
                *(_WORD *)(v16 + 42) = *(_WORD *)v14;
                *(_DWORD *)(v16 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
                *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
                *(_DWORD *)(v16 + 154) = *(_DWORD *)(v1 + 76);
                *(_WORD *)(v16 + 158) = *(_WORD *)(v1 + 80);
                sub_57FA0(
                  (_WORD *)(v16 + 154),
                  *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28),
                  *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30),
                  0x4000);
                if ( v14[24] == 2 )
                {
                  if ( v18 )
                    v5 = *(_WORD *)(v1 + 28) - 113;
                  else
                    v5 = *(_WORD *)(v1 + 28) + 113;
                  v6 = v16;
                  v7 = (*(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + v5) & 0x7FF;
                }
                else
                {
                  v6 = v16;
                  v7 = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
                }
                *(_WORD *)(v6 + 28) = v7;
                *(_WORD *)(v16 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
                if ( v18 )
                  v13 = v16;
                else
                  v12 = v16;
              }
              ++v18;
            }
            if ( v13 )
            {
              v8 = dword_D41A0 + 28302;
              *(_WORD *)(v12 + 52) = (v13 - (dword_D41A0 + 28302)) / 168;
              *(_WORD *)(v13 + 52) = (v12 - v8) / 168;
            }
          }
        }
        else
        {
          v4 = sub_6DCA0(v1, v1 + 76, 7u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          v15 = v4;
          if ( v4 )
          {
            sub_68E50(v1, v4, a1);
            *(_WORD *)(v15 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v15 + 26) = *(_WORD *)(v1 + 26);
            *(_DWORD *)(v15 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v15 + 80) += *(_WORD *)(v1 + 88);
            *(_WORD *)(v15 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v15 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
            *(_WORD *)(v15 + 42) = *(_WORD *)v2;
            *(_DWORD *)(v15 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v15 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v15 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0(
              (_WORD *)(v15 + 154),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30),
              0x4000);
            sub_68DE0(a1, v1);
            goto LABEL_27;
          }
        }
      }
      sub_68DE0(a1, v1);
    }
    else
    {
      *(_WORD *)(a1 + 46) = 1;
    }
  }
LABEL_27:
  v9 = *(_WORD *)(a1 + 46) - 1;
  *(_WORD *)(a1 + 46) = v9;
  if ( !v9 )
    sub_6D880(a1);
LABEL_29:
  result = a1;
  v11 = *(_WORD *)(a1 + 54);
  if ( v11 )
    *(_WORD *)(a1 + 54) = v11 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006A9C0) --------------------------------------------------------
int __cdecl sub_6A9C0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006A9E0) --------------------------------------------------------
int __cdecl sub_6A9E0(int a1)
{
  return sub_69250(a1);
}

//----- (0006AA00) --------------------------------------------------------
__int16 __cdecl sub_6AA00(int a1)
{
  unsigned int v1; // esi
  char *v2; // edi
  char v3; // al
  __int16 v4; // cx
  __int16 result; // ax

  v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
  if ( v1 > dword_EA3E4[0] )
  {
    if ( *(__int16 *)(a1 + 46) <= 0 )
    {
      *(_WORD *)(v1 + 12) &= 0x7FEFu;
    }
    else
    {
      v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
      if ( sub_68D50(a1, (int *)v1) )
      {
        v3 = v2[24];
        if ( v3 )
        {
          if ( v3 == 1 )
            *(_BYTE *)(v1 + 12) |= 0x10u;
        }
        else
        {
          *(_BYTE *)(v1 + 13) |= 0x80u;
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
      v4 = *(_WORD *)(a1 + 46) - 1;
      *(_WORD *)(a1 + 46) = v4;
      if ( !v4 )
        sub_6D880(a1);
    }
  }
  result = *(_WORD *)(a1 + 54);
  if ( result )
    *(_WORD *)(a1 + 54) = result - 1;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006AAC0) --------------------------------------------------------
int __cdecl sub_6AAC0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006AAE0) --------------------------------------------------------
int __cdecl sub_6AAE0(int a1)
{
  return sub_69250(a1);
}

//----- (0006AB00) --------------------------------------------------------
int __cdecl sub_6AB00(int a1)
{
  unsigned int v1; // ebx
  char *v2; // esi
  __int16 v3; // si
  int result; // eax
  __int16 v5; // dx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (int *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v6 = sub_6DCA0(v1, v1 + 76, 9u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v6 )
          {
            sub_68E50(v1, v6, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v6 + 42) = *(_WORD *)v2;
            *(_BYTE *)(v6 + 70) = v2[24];
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0(
              (_WORD *)(v6 + 154),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30),
              10240);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
          }
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006AD00) --------------------------------------------------------
int __cdecl sub_6AD00(int a1)
{
  return sub_692A0(a1);
}

//----- (0006AD20) --------------------------------------------------------
int __cdecl sub_6AD20(int a1)
{
  return sub_69250(a1);
}

//----- (0006AD60) --------------------------------------------------------
void __cdecl sub_6AD60(int a1)
{
  int *v1; // eax
  char *v2; // esi
  char v3; // al
  int v4; // eax
  unsigned int v5; // esi
  unsigned int v6; // esi
  unsigned __int16 v7; // ax
  unsigned int v8; // edx
  int *v9; // esi
  unsigned __int16 v10; // ax
  unsigned int v11; // esi
  _BOOL1 v12; // cc
  int v13; // eax
  unsigned int v14; // eax
  unsigned int v15; // esi
  unsigned __int16 v16; // ax
  unsigned __int16 v17; // si
  int *v18; // esi
  __int16 v19; // ax
  int v20; // ecx
  __int16 v21; // cx
  __int16 v22; // di
  int v23; // [esp+0h] [ebp-14h] BYREF
  __int16 v24; // [esp+4h] [ebp-10h]
  int v25; // [esp+8h] [ebp-Ch]
  int v26; // [esp+Ch] [ebp-8h]
  int *v27; // [esp+10h] [ebp-4h]

  v26 = 1;
  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = (int *)dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    v27 = v1;
    if ( (unsigned int)v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          sub_6D8B0(*(_WORD *)(a1 + 40), 0xAu, 1);
          v3 = v2[24];
          if ( v3 )
          {
            if ( (unsigned __int8)v3 <= 1u )
            {
              v8 = dword_EA3E4[*(unsigned __int16 *)(v27[41] + 58)];
              if ( v8 <= dword_EA3E4[0] )
              {
                v26 = 0;
              }
              else if ( *(_WORD *)(a1 + 150) == 1 )
              {
                sub_57CF0(a1 + 154, (int)v27, a1 + 154);
                *(_WORD *)(a1 + 150) = 0;
              }
              else
              {
                v9 = v27 + 19;
                *(_DWORD *)(a1 + 154) = v27[19];
                *(_WORD *)(a1 + 158) = *((_WORD *)v9 + 2);
                v23 = *(_DWORD *)(v8 + 76);
                v24 = *(_WORD *)(v8 + 80);
                v10 = *((_WORD *)v27 + 14) - 204;
                HIBYTE(v10) &= 7u;
                sub_57FA0(&v23, v10, 0, -448);
                sub_57CF0((__int16)&v23, (int)v27, (int)&v23);
                *(_WORD *)(a1 + 150) = 1;
              }
            }
            else if ( v3 == 2 )
            {
              v25 = 0;
              v26 = 0;
              while ( v25 < 9 && !v26 )
              {
                switch ( *(_WORD *)(a1 + 150) )
                {
                  case 1:
                    break;
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                  case 8:
                  case 9:
                    v13 = *(unsigned __int16 *)(a1 + 150) - 2;
                    if ( v13 != *(__int16 *)(v27[41] + 56) && v13 < *(unsigned __int16 *)(dword_D41A0 + 14) )
                    {
                      v14 = dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 2124 * v13 + 11240)];
                      if ( v14 > dword_EA3E4[0] )
                      {
                        v11 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(v14 + 164) + 58)];
                        v12 = v11 <= dword_EA3E4[0];
                        goto LABEL_24;
                      }
                    }
                    break;
                  default:
                    v11 = dword_EA3E4[*(unsigned __int16 *)(v27[41] + 58)];
                    v12 = v11 <= dword_EA3E4[0];
LABEL_24:
                    if ( !v12 )
                    {
                      v15 = v11 + 76;
                      v23 = *(_DWORD *)v15;
                      v24 = *(_WORD *)(v15 + 4);
                      v16 = *((_WORD *)v27 + 14) - 204;
                      HIBYTE(v16) &= 7u;
                      sub_57FA0(&v23, v16, 0, -448);
                      sub_57CF0((__int16)v27, (int)v27, (int)&v23);
                      v26 = 1;
                    }
                    break;
                }
                v17 = *(_WORD *)(a1 + 150) + 1;
                *(_WORD *)(a1 + 150) = v17;
                if ( v17 >= 9u )
                  *(_WORD *)(a1 + 150) = 0;
                ++v25;
              }
            }
          }
          else
          {
            v4 = (int)v27;
            *(_WORD *)(a1 + 150) = 0;
            v5 = dword_EA3E4[*(unsigned __int16 *)(*(_DWORD *)(v4 + 164) + 58)];
            if ( v5 <= dword_EA3E4[0] )
            {
              v26 = 0;
            }
            else
            {
              v6 = v5 + 76;
              v23 = *(_DWORD *)v6;
              v24 = *(_WORD *)(v6 + 4);
              v7 = *((_WORD *)v27 + 14) - 204;
              HIBYTE(v7) &= 7u;
              sub_57FA0(&v23, v7, 0, -448);
              sub_57CF0((__int16)v27, (int)v27, (int)&v23);
            }
          }
          if ( !v26 )
          {
            v18 = v27 + 19;
            *(_DWORD *)(a1 + 154) = v27[19];
            *(_WORD *)(a1 + 158) = *((_WORD *)v18 + 2);
            *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
            v19 = (unsigned __int16)sub_57FA0((_WORD *)(a1 + 154), *(_WORD *)(a1 + 20) & 0x7FF, 0, 0x4000);
            sub_57CF0(v19, (int)v27, a1 + 154);
            *(_WORD *)(a1 + 150) = 0;
          }
          v20 = v26;
          *(_WORD *)(v27[41] + 12) = 0;
          if ( v20 )
            sub_6E450(((int)v27 - dword_D41A0 - 28302) / 168, -1, 22);
        }
        sub_68DE0(a1, (int)v27);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
      v21 = *(_WORD *)(a1 + 46) - 1;
      *(_WORD *)(a1 + 46) = v21;
      if ( !v21 )
      {
        *(_WORD *)(v27[41] + 12) = 0;
        sub_6D880(a1);
      }
    }
  }
  v22 = *(_WORD *)(a1 + 54);
  if ( v22 )
    *(_WORD *)(a1 + 54) = v22 - 1;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006B180) --------------------------------------------------------
int __cdecl sub_6B180(int a1)
{
  return sub_692A0(a1);
}

//----- (0006B1A0) --------------------------------------------------------
int __cdecl sub_6B1A0(int a1)
{
  return sub_69250(a1);
}

//----- (0006B1C0) --------------------------------------------------------
void __cdecl sub_6B1C0(int a1)
{
  unsigned int v1; // esi
  char *v2; // edx
  __int16 v3; // di
  int v4; // eax
  __int16 v5; // dx

  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (int *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          sub_6D8B0(*(_WORD *)(a1 + 40), 0xBu, 1);
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          *(_WORD *)(*(_DWORD *)(v1 + 164) + 345) = 0;
          *(_BYTE *)(*(_DWORD *)(v1 + 164) + 447) = v2[24];
          *(_BYTE *)(v1 + 12) |= 0x20u;
        }
        else if ( (*(_BYTE *)(v1 + 12) & 0x20) == 0 )
        {
          *(_WORD *)(a1 + 46) = 1;
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
    {
      v4 = *(_DWORD *)(v1 + 164);
      *(_BYTE *)(v1 + 12) &= ~0x20u;
      *(_BYTE *)(v4 + 447) = 0;
      sub_6D880(a1);
    }
  }
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006B2D0) --------------------------------------------------------
int __cdecl sub_6B2D0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006B2F0) --------------------------------------------------------
int __cdecl sub_6B2F0(int a1)
{
  return sub_69250(a1);
}

//----- (0006B310) --------------------------------------------------------
__int16 __cdecl sub_6B310(_WORD *a1)
{
  unsigned __int16 v1; // ax
  int *v2; // esi
  __int16 v3; // si
  __int16 result; // ax

  if ( (__int16)a1[23] > 0 )
  {
    v1 = a1[20];
    v2 = (int *)dword_EA3E4[v1];
    if ( (unsigned int)v2 > dword_EA3E4[0] )
    {
      if ( a1[23] == a1[24] )
        sub_6D8B0(v1, 0xCu, 1);
      if ( sub_68D50((int)a1, v2) )
        sub_68DE0((int)a1, (int)v2);
      else
        a1[23] = 1;
    }
    v3 = a1[23] - 1;
    a1[23] = v3;
    if ( !v3 )
      sub_6D880((int)a1);
  }
  result = a1[27];
  if ( result )
    a1[27] = result - 1;
  return result;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006B3A0) --------------------------------------------------------
int __cdecl sub_6B3A0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006B3C0) --------------------------------------------------------
int __cdecl sub_6B3C0(int a1)
{
  return sub_69250(a1);
}

//----- (0006B3E0) --------------------------------------------------------
int __cdecl sub_6B3E0(int a1)
{
  unsigned int v1; // ebx
  int v2; // eax
  __int16 v3; // dx
  int result; // eax
  __int16 v5; // cx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (int *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = sub_6DCA0(
                 v1,
                 v1 + 76,
                 0xDu,
                 (__int16 *)&byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)],
                 *(_WORD *)(v1 + 130),
                 1);
          v6 = v2;
          if ( v2 )
          {
            sub_68E50(v1, v2, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_BYTE *)(v6 + 70) = *(_BYTE *)(a1 + 70);
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0(
              (_WORD *)(v6 + 154),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28),
              *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30),
              0x4000);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
          }
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006B5D0) --------------------------------------------------------
int __cdecl sub_6B5D0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006B5F0) --------------------------------------------------------
int __cdecl sub_6B5F0(int a1)
{
  return sub_69250(a1);
}

//----- (0006B610) --------------------------------------------------------
__int16 __cdecl sub_6B610(int a1)
{
  int *v1; // eax
  int v2; // eax
  int v3; // edi
  __int16 v4; // ax
  __int16 v5; // si
  __int16 result; // ax
  _WORD *v7; // [esp+0h] [ebp-Ch]
  int v8; // [esp+4h] [ebp-8h]
  char v9; // [esp+8h] [ebp-4h]

  v9 = 0;
  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = (int *)dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    v8 = (int)v1;
    if ( (unsigned int)v1 > dword_EA3E4[0] )
    {
      if ( !sub_68D50(a1, v1) )
        goto LABEL_12;
      if ( *(__int16 *)(a1 + 46) <= *(__int16 *)(a1 + 48) - 28 && !*(_WORD *)(*(_DWORD *)(v8 + 164) + 326) )
        v9 = 1;
      if ( v9 )
      {
LABEL_12:
        *(_WORD *)(a1 + 46) = 1;
      }
      else
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = sub_4A190(v8 + 76, 9, 7);
          v7 = (_WORD *)v2;
          if ( v2 )
          {
            v3 = v2;
            sub_68E50(v8, v2, a1);
            *(_WORD *)(v3 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            v4 = *(_WORD *)(a1 + 42);
            *(_BYTE *)(v3 + 67) = 10;
            *(_WORD *)(v3 + 42) = v4;
            *(_BYTE *)(v3 + 68) = 26;
            *(_WORD *)(v3 + 26) = *(_WORD *)(v8 + 26);
            *(_WORD *)(v3 + 80) += *(_WORD *)(v8 + 88);
            *(_DWORD *)(v3 + 144) = *(_DWORD *)(a1 + 144);
            *(_BYTE *)(v3 + 70) = *(_BYTE *)(a1 + 70);
            v3 += 154;
            *(_DWORD *)v3 = *(_DWORD *)(v8 + 76);
            *(_WORD *)(v3 + 4) = *(_WORD *)(v8 + 80);
            sub_57FA0(
              v7 + 77,
              *(_WORD *)(*(_DWORD *)(v8 + 164) + 24) + *(_WORD *)(v8 + 28),
              *(_WORD *)(*(_DWORD *)(v8 + 164) + 26) + *(_WORD *)(v8 + 30),
              10240);
            v7[14] = *(_WORD *)(*(_DWORD *)(v8 + 164) + 24) + *(_WORD *)(v8 + 28);
            v7[15] = *(_WORD *)(*(_DWORD *)(v8 + 164) + 26) + *(_WORD *)(v8 + 30);
            sub_6E450(((int)v7 - dword_D41A0 - 28302) / 168, -1, 9);
          }
        }
        sub_68DE0(a1, v8);
      }
    }
    v5 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v5;
    if ( !v5 )
      sub_6D880(a1);
  }
  result = *(_WORD *)(a1 + 54);
  if ( result )
    *(_WORD *)(a1 + 54) = result - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006B830) --------------------------------------------------------
int __cdecl sub_6B830(int a1)
{
  return sub_692A0(a1);
}

//----- (0006B850) --------------------------------------------------------
int __cdecl sub_6B850(int a1)
{
  return sub_69250(a1);
}

//----- (0006B870) --------------------------------------------------------
int __cdecl sub_6B870(int a1)
{
  unsigned int v1; // ebx
  char *v2; // esi
  __int16 v3; // si
  int result; // eax
  __int16 v5; // dx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (int *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v6 = sub_6DCA0(v1, v1 + 76, 0xFu, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v6 )
          {
            sub_68E50(v1, v6, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v6 + 42) = *(_WORD *)v2;
            *(_BYTE *)(v6 + 70) = v2[24];
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0((_WORD *)(v6 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
            *(_WORD *)(v6 + 158) = sub_10C40((__int16 *)(v6 + 154));
          }
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006BA70) --------------------------------------------------------
int __cdecl sub_6BA70(int a1)
{
  return sub_692A0(a1);
}

//----- (0006BA90) --------------------------------------------------------
int __cdecl sub_6BA90(int a1)
{
  return sub_69250(a1);
}

//----- (0006BAB0) --------------------------------------------------------
int __cdecl sub_6BAB0(int a1)
{
  unsigned int v1; // ebx
  char *v2; // esi
  __int16 v3; // si
  int result; // eax
  __int16 v5; // dx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (int *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v6 = sub_6DCA0(v1, v1 + 76, 0x10u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v6 )
          {
            sub_68E50(v1, v6, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v6 + 42) = *(_WORD *)v2;
            *(_BYTE *)(v6 + 70) = v2[24];
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0((_WORD *)(v6 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
            *(_WORD *)(v6 + 158) = sub_10C40((__int16 *)(v6 + 154));
          }
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006BCB0) --------------------------------------------------------
int __cdecl sub_6BCB0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006BCD0) --------------------------------------------------------
int __cdecl sub_6BCD0(int a1)
{
  return sub_69250(a1);
}

//----- (0006BCF0) --------------------------------------------------------
int __cdecl sub_6BCF0(int a1)
{
  unsigned int v1; // ebx
  char *v2; // esi
  __int16 v3; // si
  int result; // eax
  __int16 v5; // dx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (int *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v6 = sub_6DCA0(v1, v1 + 76, 0x11u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v6 )
          {
            sub_68E50(v1, v6, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v6 + 42) = *(_WORD *)v2;
            *(_BYTE *)(v6 + 70) = v2[24];
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0((_WORD *)(v6 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
            *(_WORD *)(v6 + 158) = sub_10C40((__int16 *)(v6 + 154));
          }
          sub_68DE0(a1, v1);
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006BEF0) --------------------------------------------------------
int __cdecl sub_6BEF0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006BF10) --------------------------------------------------------
int __cdecl sub_6BF10(int a1)
{
  return sub_69250(a1);
}

//----- (0006BF30) --------------------------------------------------------
int __cdecl sub_6BF30(int a1)
{
  unsigned int v1; // ebx
  char *v2; // esi
  __int16 v3; // dx
  int result; // eax
  __int16 v5; // cx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (int *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v6 = sub_6DCA0(v1, v1 + 76, 0x12u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v6 )
          {
            sub_68E50(v1, v6, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v6 + 42) = *(_WORD *)v2;
            *(_BYTE *)(v6 + 70) = v2[24];
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0((_WORD *)(v6 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
            *(_WORD *)(v6 + 158) = sub_10C40((__int16 *)(v6 + 154));
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
          }
          sub_68DE0(a1, v1);
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006C130) --------------------------------------------------------
int __cdecl sub_6C130(int a1)
{
  return sub_692A0(a1);
}

//----- (0006C150) --------------------------------------------------------
int __cdecl sub_6C150(int a1)
{
  return sub_69250(a1);
}

//----- (0006C170) --------------------------------------------------------
__int16 __cdecl sub_6C170(int a1)
{
  int *v1; // eax
  char *v2; // esi
  __int16 v3; // ax
  __int16 v4; // si
  __int16 result; // ax
  int v6; // [esp+0h] [ebp-8h]
  int v7; // [esp+4h] [ebp-4h]

  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = (int *)dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    v7 = (int)v1;
    if ( (unsigned int)v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v6 = sub_4A190(v7 + 76, 9, 24);
          if ( v6 )
          {
            *(_WORD *)(v6 + 130) += *(_WORD *)(v7 + 130);
            sub_68E50(v7, v6, a1);
            v3 = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_BYTE *)(v6 + 67) = 10;
            *(_WORD *)(v6 + 38) = v3;
            *(_BYTE *)(v6 + 68) = 72;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v7 + 26);
            *(_WORD *)(v6 + 40) = *(_WORD *)(a1 + 40);
            *(_BYTE *)(v6 + 70) = v2[24];
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v7 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v7 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v7 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v7 + 80);
            sub_57FA0(
              (_WORD *)(v6 + 154),
              *(_WORD *)(*(_DWORD *)(v7 + 164) + 24) + *(_WORD *)(v7 + 28),
              *(_WORD *)(*(_DWORD *)(v7 + 164) + 26) + *(_WORD *)(v7 + 30),
              0x4000);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v7 + 164) + 24) + *(_WORD *)(v7 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v7 + 164) + 26) + *(_WORD *)(v7 + 30);
            sub_6E450((v6 - (dword_D41A0 + 28302)) / 168, -1, 9);
          }
        }
        sub_68DE0(a1, v7);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v4 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v4;
    if ( !v4 )
      sub_6D880(a1);
  }
  result = *(_WORD *)(a1 + 54);
  if ( result )
    *(_WORD *)(a1 + 54) = result - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006C3A0) --------------------------------------------------------
int __cdecl sub_6C3A0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006C3C0) --------------------------------------------------------
int __cdecl sub_6C3C0(int a1)
{
  return sub_69250(a1);
}

//----- (0006C3E0) --------------------------------------------------------
int __cdecl sub_6C3E0(int a1)
{
  unsigned int v1; // ebx
  char *v2; // esi
  __int16 v3; // si
  int result; // eax
  __int16 v5; // dx
  int v6; // [esp+0h] [ebp-4h]

  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (int *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v6 = sub_6DCA0(v1, v1 + 76, 0x14u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v6 )
          {
            sub_68E50(v1, v6, a1);
            *(_WORD *)(v6 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v6 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v6 + 80) += *(_WORD *)(v1 + 88);
            *(_WORD *)(v6 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v6 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
            *(_DWORD *)(v6 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v6 + 42) = *(_WORD *)v2;
            *(_BYTE *)(v6 + 70) = v2[24];
            *(_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v6 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v6 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0((_WORD *)(v6 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
            *(_WORD *)(v6 + 158) = sub_10C40((__int16 *)(v6 + 154));
          }
        }
        sub_68DE0(a1, v1);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v3 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v3;
    if ( !v3 )
      sub_6D880(a1);
  }
  result = a1;
  v5 = *(_WORD *)(a1 + 54);
  if ( v5 )
    *(_WORD *)(a1 + 54) = v5 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006C5E0) --------------------------------------------------------
int __cdecl sub_6C5E0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006C600) --------------------------------------------------------
int __cdecl sub_6C600(int a1)
{
  return sub_69250(a1);
}

//----- (0006C620) --------------------------------------------------------
int __cdecl sub_6C620(int a1)
{
  unsigned int v1; // ebx
  char *v2; // edi
  int v3; // esi
  unsigned __int8 v4; // ah
  int v5; // eax
  __int16 v6; // dx
  int result; // eax
  __int16 v8; // cx

  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (int *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v3 = sub_6DCA0(v1, v1 + 76, 0x15u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v3 )
          {
            sub_68E50(v1, v3, a1);
            *(_WORD *)(v3 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v3 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v3 + 80) += *(_WORD *)(v1 + 88);
            *(_DWORD *)(v3 + 144) = *(_DWORD *)(a1 + 144);
            v4 = v2[24];
            if ( v4 )
              v5 = *(_DWORD *)v2 / (int)v4;
            else
              LOWORD(v5) = *(_WORD *)v2;
            *(_WORD *)(v3 + 42) = v5;
            *(_BYTE *)(v3 + 70) = v2[24];
            *(_DWORD *)(v3 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v3 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v3 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0((_WORD *)(v3 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
            *(_WORD *)(v3 + 158) = sub_10C40((__int16 *)(v3 + 154));
            *(_WORD *)(v3 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v3 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
          }
          sub_68DE0(a1, v1);
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v6 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v6;
    if ( !v6 )
      sub_6D880(a1);
  }
  result = a1;
  v8 = *(_WORD *)(a1 + 54);
  if ( v8 )
    *(_WORD *)(a1 + 54) = v8 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006C830) --------------------------------------------------------
int __cdecl sub_6C830(int a1)
{
  return sub_692A0(a1);
}

//----- (0006C850) --------------------------------------------------------
int __cdecl sub_6C850(int a1)
{
  return sub_69250(a1);
}

//----- (0006C870) --------------------------------------------------------
__int16 __cdecl sub_6C870(int a1)
{
  int v1; // esi
  unsigned int v2; // edi
  int v3; // eax
  __int16 v4; // si
  __int16 result; // ax
  int v6; // [esp+0h] [ebp-8h]
  char *v7; // [esp+4h] [ebp-4h]

  v1 = 0;
  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v2 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v2 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (int *)v2) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          if ( sub_4A810() > 6 )
          {
            v6 = 0;
            v7 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
            while ( v6 < 6 )
            {
              v1 = sub_4A190(v2 + 76, 10, 57);
              if ( v1 )
              {
                v3 = 4 * *(__int16 *)(v2 + 130);
                if ( v3 < 140 )
                  v3 = 140;
                if ( v3 > 280 )
                  LOWORD(v3) = 280;
                *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
                *(_WORD *)(v1 + 130) = (*(_WORD *)(a1 + 20) & 0x7F) + v3;
                sub_68E50(v2, v1, a1);
                *(_WORD *)(v1 + 40) = *(_WORD *)(v2 + 26);
                *(_WORD *)(v1 + 42) = *(_WORD *)v7;
                *(_BYTE *)(v1 + 70) = v7[24];
                *(_WORD *)(v1 + 148) = 0;
                if ( (unsigned __int8)v7[24] >= 3u )
                {
                  *(_WORD *)(v1 + 148) = *(_WORD *)(v2 + 26);
                  sub_36920(a1, v1);
                }
                *(_WORD *)(a1 + 20) = 9377 * *(_WORD *)(a1 + 20) + 9439;
                *(_WORD *)(v1 + 28) = (*(_WORD *)(v2 + 28)
                                     - 85
                                     + *(_WORD *)(a1 + 20) % 0xAAu
                                     + *(_WORD *)(*(_DWORD *)(v2 + 164) + 24)) & 0x7FF;
                *(_WORD *)(v1 + 30) = *(_WORD *)(*(_DWORD *)(v2 + 164) + 26) + *(_WORD *)(v2 + 30);
              }
              ++v6;
            }
            if ( v1 )
              sub_6E450((v1 - (dword_D41A0 + 28302)) / 168, -1, 11);
          }
          sub_68DE0(a1, v2);
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v4 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v4;
    if ( !v4 )
      sub_6D880(a1);
  }
  result = *(_WORD *)(a1 + 54);
  if ( result )
    *(_WORD *)(a1 + 54) = result - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006CA80) --------------------------------------------------------
int __cdecl sub_6CA80(int a1)
{
  return sub_692A0(a1);
}

//----- (0006CAA0) --------------------------------------------------------
int __cdecl sub_6CAA0(int a1)
{
  return sub_69250(a1);
}

//----- (0006CAC0) --------------------------------------------------------
int __cdecl sub_6CAC0(int a1)
{
  int *v1; // eax
  int v2; // ebx
  int v3; // ett
  int v4; // eax
  __int16 v5; // di
  int result; // eax
  __int16 v7; // bx
  int v8; // [esp+0h] [ebp-4h]

  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = (int *)dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    v8 = (int)v1;
    if ( (unsigned int)v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = sub_4A190(v8 + 76, 9, 29);
          if ( v2 )
          {
            *(_WORD *)(v2 + 130) += *(_WORD *)(v8 + 130);
            sub_68E50(v8, v2, a1);
            v3 = a1 - (dword_D41A0 + 28302);
            *(_BYTE *)(v2 + 67) = 10;
            *(_BYTE *)(v2 + 68) = 78;
            *(_WORD *)(v2 + 38) = v3 / 168;
            *(_WORD *)(v2 + 26) = *(_WORD *)(v8 + 26);
            *(_WORD *)(v2 + 80) += *(_WORD *)(v8 + 88);
            *(_DWORD *)(v2 + 144) = *(_DWORD *)(a1 + 144);
            *(_WORD *)(v2 + 42) = *(char *)(a1 + 70);
            *(_DWORD *)(v2 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v8 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v8 + 164) + 340) = 0;
            *(_DWORD *)(v2 + 154) = *(_DWORD *)(v8 + 76);
            *(_WORD *)(v2 + 158) = *(_WORD *)(v8 + 80);
            sub_57FA0((_WORD *)(v2 + 154), *(_WORD *)(*(_DWORD *)(v8 + 164) + 24) + *(_WORD *)(v8 + 28), 0, 4096);
            *(_WORD *)(v2 + 158) = sub_10C40((__int16 *)(v2 + 154));
            *(_WORD *)(v2 + 28) = *(_WORD *)(*(_DWORD *)(v8 + 164) + 24) + *(_WORD *)(v8 + 28);
            v4 = dword_D41A0 + 28302;
            *(_WORD *)(v2 + 30) = *(_WORD *)(*(_DWORD *)(v8 + 164) + 26) + *(_WORD *)(v8 + 30);
            sub_6E450((v2 - v4) / 168, -1, 15);
          }
          sub_68DE0(a1, v8);
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v5 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v5;
    if ( !v5 )
      sub_6D880(a1);
  }
  result = a1;
  v7 = *(_WORD *)(a1 + 54);
  if ( v7 )
    *(_WORD *)(a1 + 54) = v7 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006CCE0) --------------------------------------------------------
int __cdecl sub_6CCE0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006CD00) --------------------------------------------------------
int __cdecl sub_6CD00(int a1)
{
  return sub_69250(a1);
}

//----- (0006CD20) --------------------------------------------------------
int __cdecl sub_6CD20(int a1)
{
  int *v1; // eax
  char *v2; // esi
  int v3; // ebx
  __int16 v4; // ax
  int v5; // eax
  __int16 v6; // di
  int result; // eax
  __int16 v8; // bx
  int v9; // [esp+0h] [ebp-4h]

  if ( *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = (int *)dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    v9 = (int)v1;
    if ( (unsigned int)v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v3 = sub_4A190(v9 + 76, 9, 25);
          if ( v3 )
          {
            *(_WORD *)(v3 + 130) += *(_WORD *)(v9 + 130);
            sub_68E50(v9, v3, a1);
            v4 = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_BYTE *)(v3 + 67) = 10;
            *(_WORD *)(v3 + 38) = v4;
            *(_BYTE *)(v3 + 68) = 74;
            *(_WORD *)(v3 + 26) = *(_WORD *)(v9 + 26);
            *(_WORD *)(v3 + 40) = *(_WORD *)(a1 + 40);
            *(_WORD *)(v3 + 42) = *(_WORD *)v2;
            *(_BYTE *)(v3 + 70) = v2[24];
            *(_DWORD *)(v3 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v9 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v9 + 164) + 340) = 0;
            *(_DWORD *)(v3 + 154) = *(_DWORD *)(v9 + 76);
            *(_WORD *)(v3 + 158) = *(_WORD *)(v9 + 80);
            sub_57FA0(
              (_WORD *)(v3 + 154),
              *(_WORD *)(*(_DWORD *)(v9 + 164) + 24) + *(_WORD *)(v9 + 28),
              *(_WORD *)(*(_DWORD *)(v9 + 164) + 26) + *(_WORD *)(v9 + 30),
              0x4000);
            *(_WORD *)(v3 + 28) = *(_WORD *)(*(_DWORD *)(v9 + 164) + 24) + *(_WORD *)(v9 + 28);
            v5 = dword_D41A0 + 28302;
            *(_WORD *)(v3 + 30) = *(_WORD *)(*(_DWORD *)(v9 + 164) + 26) + *(_WORD *)(v9 + 30);
            sub_6E450((v3 - v5) / 168, -1, 9);
          }
        }
        sub_68DE0(a1, v9);
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v6 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v6;
    if ( !v6 )
      sub_6D880(a1);
  }
  result = a1;
  v8 = *(_WORD *)(a1 + 54);
  if ( v8 )
    *(_WORD *)(a1 + 54) = v8 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006CF60) --------------------------------------------------------
int __cdecl sub_6CF60(int a1)
{
  return sub_692A0(a1);
}

//----- (0006CF80) --------------------------------------------------------
int __cdecl sub_6CF80(int a1)
{
  return sub_69250(a1);
}

//----- (0006CFA0) --------------------------------------------------------
int __cdecl sub_6CFA0(int a1)
{
  unsigned int v1; // ebx
  char *v2; // edi
  int v3; // esi
  unsigned __int8 v4; // dl
  int v5; // eax
  __int16 v6; // dx
  int result; // eax
  __int16 v8; // cx

  if ( byte_D41B6 && *(__int16 *)(a1 + 46) > 0 )
  {
    v1 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v1 > dword_EA3E4[0] )
    {
      if ( sub_68D50(a1, (int *)v1) )
      {
        if ( *(_WORD *)(a1 + 46) == *(_WORD *)(a1 + 48) )
        {
          v2 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
          v3 = sub_6DCA0(v1, v1 + 76, 0x19u, (__int16 *)v2, *(_WORD *)(v1 + 130), 1);
          if ( v3 )
          {
            sub_68E50(v1, v3, a1);
            *(_WORD *)(v3 + 38) = (a1 - (dword_D41A0 + 28302)) / 168;
            *(_WORD *)(v3 + 26) = *(_WORD *)(v1 + 26);
            *(_WORD *)(v3 + 80) += *(_WORD *)(v1 + 88);
            *(_DWORD *)(v3 + 144) = *(_DWORD *)(a1 + 144);
            v4 = v2[24];
            if ( v4 )
              v5 = *(_DWORD *)v2 / (int)v4;
            else
              LOWORD(v5) = *(_WORD *)v2;
            *(_WORD *)(v3 + 42) = v5;
            *(_BYTE *)(v3 + 70) = v2[24];
            *(_DWORD *)(v3 + 16) = *(unsigned __int8 *)(*(_DWORD *)(v1 + 164) + 340);
            *(_BYTE *)(*(_DWORD *)(v1 + 164) + 340) = 0;
            *(_DWORD *)(v3 + 154) = *(_DWORD *)(v1 + 76);
            *(_WORD *)(v3 + 158) = *(_WORD *)(v1 + 80);
            sub_57FA0((_WORD *)(v3 + 154), *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28), 0, 4096);
            *(_WORD *)(v3 + 158) = sub_10C40((__int16 *)(v3 + 154));
            *(_WORD *)(v3 + 28) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 24) + *(_WORD *)(v1 + 28);
            *(_WORD *)(v3 + 30) = *(_WORD *)(*(_DWORD *)(v1 + 164) + 26) + *(_WORD *)(v1 + 30);
          }
          sub_68DE0(a1, v1);
        }
      }
      else
      {
        *(_WORD *)(a1 + 46) = 1;
      }
    }
    v6 = *(_WORD *)(a1 + 46) - 1;
    *(_WORD *)(a1 + 46) = v6;
    if ( !v6 )
      sub_6D880(a1);
  }
  result = a1;
  v8 = *(_WORD *)(a1 + 54);
  if ( v8 )
    *(_WORD *)(a1 + 54) = v8 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41B6: using guessed type char byte_D41B6;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006D1C0) --------------------------------------------------------
int __cdecl sub_6D1C0(int a1)
{
  return sub_692A0(a1);
}

//----- (0006D1E0) --------------------------------------------------------
int __cdecl sub_6D1E0(int a1)
{
  return sub_69250(a1);
}

//----- (0006D200) --------------------------------------------------------
__int16 __cdecl sub_6D200(int a1)
{
  __int16 result; // ax
  __int16 v2; // cx
  char v3; // bl
  __int16 v4; // ax
  unsigned __int8 v5; // bl
  int v6; // ebx
  int v7; // edx
  __int16 v8; // bx
  __int16 v9; // di
  int v10; // eax
  __int16 v11; // bx
  __int16 v12; // ax
  __int16 v13; // [esp+Ch] [ebp-10h]
  __int16 v14; // [esp+14h] [ebp-8h]

  result = *(_WORD *)(a1 + 7);
  if ( result == *(_WORD *)(dword_D41A0 + 12) )
  {
    HIBYTE(result) = *(_BYTE *)(a1 + 991);
    if ( HIBYTE(result) == 5 || HIBYTE(result) == 8 )
    {
      if ( (word_180660 & 1) != 0 )
        v2 = 400;
      else
        v2 = 480;
      v3 = *(_BYTE *)(a1 + 2110);
      if ( v3 < 13 )
        v4 = v3;
      else
        v4 = v3 - 13;
      v14 = v4;
      result = dword_EA3DC;
      v5 = *(_BYTE *)(a1 + 2109);
      if ( v5 )
      {
        if ( v5 <= 2u )
        {
          v8 = (unsigned __int8)byte_D94FF[*(char *)(a1 + 2110)];
          LOBYTE(v8) = *(_BYTE *)(dword_EA3DC + 982);
          v9 = 3 * v8;
          v13 = v8;
          v10 = ((int)*(unsigned __int8 *)(dword_EA3DC + 538) >> 1)
              + *(unsigned __int8 *)(dword_EA3DC + 538) * v14
              + *(unsigned __int8 *)(dword_EA3DC + 532)
              - ((__int16)(3 * v8) >> 1);
          v11 = v2 - 2 * *(unsigned __int8 *)(dword_EA3DC + 539) - *(unsigned __int8 *)(dword_EA3DC + 983) + 18;
          if ( 640 - v9 >= (__int16)v10 )
          {
            if ( (v10 & 0x8000u) != 0 )
              LOWORD(v10) = 0;
          }
          else
          {
            LOWORD(v10) = 640 - v9;
          }
          v12 = v13 * *(char *)((unsigned __int8)byte_D94FF[*(char *)(a1 + 2110)] + a1 + 1609 + 468)
              + (v13 >> 1)
              + 8
              + v10;
          if ( word_1805C2 == 7 || word_1805C2 == 1 || word_1805C2 == 2 )
          {
            return sub_5BDC0(v12, v11);
          }
          else
          {
            dword_1805B0 = v12;
            result = v11;
            dword_1805B4 = v11;
          }
        }
      }
      else
      {
        v6 = *(unsigned __int8 *)(dword_EA3DC + 538) * v14
           + *(unsigned __int8 *)(dword_EA3DC + 532)
           + ((int)*(unsigned __int8 *)(dword_EA3DC + 538) >> 1);
        v7 = ((int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1)
           + v2
           - 2 * *(unsigned __int8 *)(dword_EA3DC + 539)
           + *(unsigned __int8 *)(dword_EA3DC + 539) * (*(_BYTE *)(a1 + 2110) >= 13);
        if ( word_1805C2 == 7 || word_1805C2 == 1 || word_1805C2 == 2 )
        {
          return sub_5BDC0(v6, v7);
        }
        else
        {
          dword_1805B0 = (__int16)v6;
          result = v7;
          dword_1805B4 = (__int16)v7;
        }
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3DC: using guessed type int dword_EA3DC;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805C2: using guessed type __int16 word_1805C2;
// 180660: using guessed type __int16 word_180660;

//----- (0006D420) --------------------------------------------------------
int __cdecl sub_6D420(__int16 a1, __int16 a2)
{
  __int16 v2; // ax
  int v3; // ebx
  int v4; // eax

  if ( (word_180660 & 1) != 0 )
    v2 = 400;
  else
    v2 = 480;
  v3 = (a2 - (__int16)(v2 - 2 * *(unsigned __int8 *)(dword_EA3DC + 539))) / *(unsigned __int8 *)(dword_EA3DC + 539);
  v4 = (a1 - *(unsigned __int8 *)(dword_EA3DC + 532)) / *(unsigned __int8 *)(dword_EA3DC + 538);
  if ( (v3 & 0x8000u) == 0 )
  {
    if ( (__int16)v3 > 1 )
      v3 = 1;
  }
  else
  {
    v3 = 0;
  }
  if ( (v4 & 0x8000u) == 0 )
  {
    if ( (__int16)v4 > 12 )
      v4 = 12;
  }
  else
  {
    v4 = 0;
  }
  return 13 * v3 + v4;
}
// EA3DC: using guessed type int dword_EA3DC;
// 180660: using guessed type __int16 word_180660;

//----- (0006D4C0) --------------------------------------------------------
char __cdecl sub_6D4C0(int a1)
{
  char result; // al

  result = *(_BYTE *)(a1 + (unsigned __int8)byte_D94FF[*(char *)(a1 + 501)] + 468);
  *(_BYTE *)(a1 + 502) = result;
  return result;
}

//----- (0006D4F0) --------------------------------------------------------
int __cdecl sub_6D4F0(int a1, __int16 a2)
{
  __int16 v2; // cx
  int v3; // esi
  __int16 v4; // ax
  int result; // eax
  int v6; // edx

  v2 = 3 * *(unsigned __int8 *)(dword_EA3DC + 982);
  v3 = ((int)*(unsigned __int8 *)(dword_EA3DC + 538) >> 1)
     + *(unsigned __int8 *)(dword_EA3DC + 532)
     + *(unsigned __int8 *)(dword_EA3DC + 538) * (*(char *)(a1 + 501) % 13)
     - v2 / 2;
  v4 = v3;
  if ( (__int16)v3 <= 640 - v2 )
  {
    if ( (v3 & 0x8000u) != 0 )
      v4 = 0;
  }
  else
  {
    v4 = 640 - v2;
  }
  result = (a2 - v4) / *(unsigned __int8 *)(dword_EA3DC + 982);
  v6 = a1 + (unsigned __int8)byte_D94FF[*(char *)(a1 + 501)];
  LOWORD(v6) = *(char *)(v6 + 442);
  if ( (__int16)result > (__int16)v6 )
    return v6;
  if ( (result & 0x8000u) != 0 )
    return 0;
  return result;
}
// EA3DC: using guessed type int dword_EA3DC;

//----- (0006D5E0) --------------------------------------------------------
char __cdecl sub_6D5E0(int a1, char a2)
{
  int v2; // eax
  char *v3; // esi
  unsigned __int8 v4; // dl
  unsigned __int16 v5; // dx
  __int16 v6; // cx
  int v7; // edi
  unsigned __int8 v9; // [esp-8h] [ebp-8h]

  LOBYTE(v2) = a2;
  if ( a2 > (unsigned __int8)byte_DA818[80 * *(char *)(a1 + 64)] - 1 )
    LOBYTE(v2) = byte_DA818[80 * *(char *)(a1 + 64)] - 1;
  if ( *(_WORD *)(a1 + 46) )
  {
    *(_WORD *)(a1 + 44) = (char)v2 + 1;
  }
  else
  {
    v3 = &byte_DA818[80 * *(char *)(a1 + 64) + 2 + 26 * (char)v2];
    *(_BYTE *)(a1 + 70) = v2;
    *(_WORD *)(a1 + 42) = *(_WORD *)v3;
    *(_WORD *)(a1 + 48) = *((_WORD *)v3 + 11);
    *(_BYTE *)(a1 + 59) = (v3[25] & 1) == 0;
    v4 = *(_BYTE *)(a1 + 64);
    *(_BYTE *)(a1 + 60) = 0;
    v9 = v4;
    v5 = *(_WORD *)(a1 + 40);
    *(_BYTE *)(a1 + 61) = 0;
    v2 = sub_6D710(dword_EA3E4[v5], v9, v2);
    v6 = *(_WORD *)(a1 + 48);
    v7 = v2;
    if ( v6 )
      v2 /= v6;
    *(_DWORD *)(a1 + 144) = v2;
    *(_DWORD *)(a1 + 140) = v7;
    *(_DWORD *)(a1 + 136) = *((_DWORD *)v3 + 2);
    if ( (*(_BYTE *)(dword_D41A4 + 24) & 0x20) != 0 )
    {
      *(_DWORD *)(a1 + 136) = 0;
      *(_DWORD *)(a1 + 144) = 1;
    }
  }
  return v2;
}
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006D710) --------------------------------------------------------
int __cdecl sub_6D710(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3)
{
  int v3; // ecx
  int result; // eax
  int v5; // edx
  unsigned int v6; // ebx
  int v7; // edx
  int v8; // eax

  v3 = 0;
  result = *(_DWORD *)&byte_DA818[80 * a2 + 6 + 26 * a3];
  if ( a2 == 2 && a1 > dword_EA3E4[0] )
  {
    v5 = *(_DWORD *)(a1 + 164);
    v6 = dword_EA3E4[*(unsigned __int16 *)(v5 + 58)];
    if ( v6 <= dword_EA3E4[0] )
      goto LABEL_23;
    switch ( *(_DWORD *)(v6 + 16) )
    {
      case 0:
        result = 1000;
        break;
      case 1:
        result = 10000;
        break;
      case 2:
        result = 20000;
        break;
      case 3:
        result = 40000;
        break;
      case 4:
        result = (int)nullsub_1;
        break;
      case 5:
        result = 160000;
        break;
      case 6:
        result = 320000;
        break;
      default:
        result = 300000000;
        break;
    }
    if ( *(int *)(v6 + 16) >= 7 )
      goto LABEL_25;
    if ( a3 )
    {
      if ( a3 <= 1u )
      {
        v7 = 320 * result;
        v8 = 320 * result;
      }
      else
      {
        if ( a3 != 2 )
          goto LABEL_21;
        v8 = 384 * result;
        v7 = v8;
      }
      result = (v8 - (__CFSHL__(v7 >> 31, 8) + (v7 >> 31 << 8))) >> 8;
    }
LABEL_21:
    if ( *(_DWORD *)(v6 + 16) )
    {
LABEL_25:
      if ( v3 )
        result += 3000;
      return result;
    }
    v5 = *(_DWORD *)(a1 + 164);
LABEL_23:
    if ( *(_BYTE *)(v5 + 446) )
      v3 = 1;
    goto LABEL_25;
  }
  return result;
}
// 13880: using guessed type int nullsub_1();
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006D830) --------------------------------------------------------
char __cdecl sub_6D830(int a1, char a2)
{
  char *v2; // eax
  unsigned int v3; // esi
  unsigned int v4; // esi

  LOBYTE(v2) = *(_BYTE *)(a1 + 64);
  if ( (_BYTE)v2 == 10 )
  {
    v2 = (char *)&unk_DAB3A + 26 * a2;
    v3 = dword_EA3E4[*(unsigned __int16 *)(a1 + 40)];
    if ( v3 > dword_EA3E4[0] && v2[24] == 1 )
    {
      v4 = v3 + 76;
      *(_DWORD *)(a1 + 154) = *(_DWORD *)v4;
      *(_WORD *)(a1 + 158) = *(_WORD *)(v4 + 4);
    }
  }
  return (char)v2;
}
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006D880) --------------------------------------------------------
char __cdecl sub_6D880(int a1)
{
  char result; // al

  if ( *(_WORD *)(a1 + 44) )
  {
    result = sub_6D5E0(a1, *(_BYTE *)(a1 + 44) - 1);
    *(_WORD *)(a1 + 44) = 0;
  }
  return result;
}

//----- (0006D8B0) --------------------------------------------------------
void __cdecl sub_6D8B0(unsigned __int16 a1, unsigned __int16 a2, __int16 a3)
{
  int v3; // eax
  int v4; // ebx
  int v5; // ecx
  int v6; // ebx

  if ( (*(_BYTE *)(dword_D41A4 + 38545) & 4) == 0 )
  {
    if ( a1 )
    {
      v3 = dword_EA3E4[a1];
      if ( *(_BYTE *)(v3 + 63) == 3 && !*(_BYTE *)(v3 + 64) )
      {
        v4 = *(_DWORD *)(v3 + 164);
        v5 = *(_DWORD *)(v4 + 4 * a2 + 715);
        v6 = v4 + 611;
        *(_DWORD *)(v6 + 4 * a2 + 104) = a3 + v5;
        if ( a2 == 2 )
          sub_6D5E0(dword_EA3E4[*(__int16 *)(v6 + 212)], *(_BYTE *)(v6 + 470));
        if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
        {
          if ( a1 == *(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240) )
            sub_6DAD0(v6, (unsigned __int8 *)&byte_DA818[80 * a2], a2);
        }
        else
        {
          sub_6D9C0(v6, (unsigned __int8 *)&byte_DA818[80 * a2], a2, 0, 1);
        }
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006D9C0) --------------------------------------------------------
int __cdecl sub_6D9C0(int a1, unsigned __int8 *a2, __int16 a3, char a4, char a5)
{
  int v5; // esi
  int v6; // eax
  int v7; // edi
  int v8; // edx
  int result; // eax
  char v10; // dh

  v5 = 0;
  if ( (*(_BYTE *)(a1 + a3 + 390) || *(_WORD *)(a1 + 2 * a3 + 208)) && (byte_D41B6 || a3 != 25) )
    v5 = 1;
  if ( *(char *)(dword_D41A4 + 23) >= 0 && *(int *)(a1 + 112) > 7 )
    *(_DWORD *)(a1 + 112) = 7;
  v6 = *a2;
  v7 = *(_DWORD *)(a1 + 4 * a3 + 104) + *(_DWORD *)(a1 + 4 * a3);
  do
    --v6;
  while ( v6 >= 0 && v7 < *(_DWORD *)&a2[26 * v6 + 14] );
  if ( v6 < 0 )
    v6 = 0;
  v8 = a1 + a3;
  if ( v6 != *(char *)(v8 + 442) )
  {
    *(_BYTE *)(v8 + 442) = v6;
    if ( v5 )
    {
      if ( a5 )
        sub_6DC40(a3);
    }
  }
  result = a1 + a3;
  v10 = *(_BYTE *)(result + 442);
  if ( *(char *)(result + 468) > v10 )
    *(_BYTE *)(result + 468) = v10;
  if ( v5 && a4 )
  {
    if ( v7 >= *(_DWORD *)(a2 + 66) )
    {
      result = *(_DWORD *)(a2 + 66);
      *(_DWORD *)(4 * a3 + a1) = result;
    }
    else
    {
      result = a3;
      *(_DWORD *)(a1 + 4 * a3) = v7;
    }
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;

//----- (0006DAD0) --------------------------------------------------------
void __cdecl sub_6DAD0(int a1, unsigned __int8 *a2, __int16 a3)
{
  int v3; // eax
  int v4; // edx

  if ( *(_WORD *)(a1 + 2 * a3 + 208) && *(char *)(a1 + a3 + 442) < *a2 - 1 )
  {
    v3 = *(_DWORD *)(a1 + 4 * a3 + 104) + *(_DWORD *)(a1 + 4 * a3);
    if ( v3 < 0 )
      v3 = 0;
    if ( v3 > *(_DWORD *)(a2 + 70) + 2 )
      v3 = *(_DWORD *)(a2 + 70) + 2;
    v4 = a1 + a3;
    if ( v3 >= *(_DWORD *)&a2[26 * *(char *)(v4 + 442) + 44] )
    {
      ++*(_BYTE *)(v4 + 442);
      sub_6DC40(a3);
    }
  }
}

//----- (0006DB50) --------------------------------------------------------
int __cdecl sub_6DB50(char a1, char a2)
{
  int result; // eax
  unsigned __int8 *v3; // esi
  int v4; // ebx
  int v5; // edi
  __int16 v6; // [esp-Ch] [ebp-Ch]

  result = dword_D41A4;
  if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) == 0 )
  {
    v3 = (unsigned __int8 *)byte_DA818;
    result = *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12) + 11240)]
                       + 164);
    v4 = 0;
    v5 = result + 611;
    while ( v4 < 26 )
    {
      v6 = v4++;
      result = sub_6D9C0(v5, v3, v6, a1, a2);
      v3 += 80;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006DBD0) --------------------------------------------------------
void sub_6DBD0()
{
  unsigned __int8 *v0; // esi
  int v1; // ebx
  int v2; // edi
  __int16 v3; // [esp-4h] [ebp-4h]

  if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
  {
    v0 = (unsigned __int8 *)byte_DA818;
    v1 = 0;
    v2 = *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)]
                   + 164)
       + 611;
    while ( v1 < 26 )
    {
      v3 = v1++;
      sub_6DAD0(v2, v0, v3);
      v0 += 80;
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006DC40) --------------------------------------------------------
void __cdecl sub_6DC40(unsigned __int8 a1)
{
  char v1[128]; // [esp+0h] [ebp-2h] BYREF

  sprintf(v1, (const char *)dword_E9EC8, dword_E9ECC[a1]);
  sub_19760(v1, 5u, 200);
  sub_6E450(*(_WORD *)(dword_D41A0 + 12), -1, 61);
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// E9EC8: using guessed type int dword_E9EC8;
// E9ECC: using guessed type int dword_E9ECC[123];

//----- (0006DCA0) --------------------------------------------------------
int __cdecl sub_6DCA0(int a1, int a2, unsigned __int16 a3, __int16 *a4, __int16 a5, char a6)
{
  __int16 v6; // di
  int v7; // ebx
  int v8; // eax
  unsigned __int8 v9; // dl
  int v10; // eax
  __int16 v11; // ax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  int v23; // eax
  __int16 v24; // dx

  v6 = 15;
  v7 = 0;
  if ( a3 < 0x10u )
  {
    if ( a3 < 9u )
    {
      if ( a3 )
      {
        if ( a3 != 7 )
          goto LABEL_60;
        v9 = *((_BYTE *)a4 + 24);
        if ( v9 )
        {
          if ( v9 > 2u )
            goto LABEL_60;
          v12 = sub_4A190(a2, 9, 12);
          v7 = v12;
          if ( !v12 )
            goto LABEL_60;
          *(_BYTE *)(v12 + 67) = 9;
          *(_BYTE *)(v12 + 68) = 9;
          v11 = *a4;
          v6 = 9;
        }
        else
        {
          v10 = sub_4A190(a2, 9, 9);
          v7 = v10;
          if ( !v10 )
            goto LABEL_60;
          *(_BYTE *)(v10 + 67) = 10;
          *(_BYTE *)(v10 + 68) = 23;
          v11 = *a4;
          v6 = 23;
        }
        *(_WORD *)(v7 + 42) = v11;
        goto LABEL_60;
      }
      if ( *((_BYTE *)a4 + 24) >= 2u )
        v8 = sub_4A190(a2, 9, 28);
      else
        v8 = sub_4A190(a2, 9, 0);
      v7 = v8;
      if ( v8 )
      {
        *(_BYTE *)(v8 + 67) = 10;
        if ( *((_BYTE *)a4 + 24) >= 2u )
          *(_BYTE *)(v8 + 68) = 76;
        else
          *(_BYTE *)(v8 + 68) = 0;
        v6 = 9;
      }
    }
    else
    {
      if ( a3 <= 9u )
      {
        v13 = sub_4A190(a2, 9, 3);
        v7 = v13;
        if ( !v13 )
          goto LABEL_60;
        *(_BYTE *)(v13 + 67) = 10;
        *(_BYTE *)(v13 + 68) = 17;
        *(_WORD *)(v13 + 42) = *a4;
        goto LABEL_59;
      }
      if ( a3 < 0xDu )
        goto LABEL_60;
      if ( a3 <= 0xDu )
      {
        v14 = sub_4A190(a2, 9, 8);
        v7 = v14;
        if ( v14 )
        {
          *(_BYTE *)(v14 + 67) = 10;
          *(_BYTE *)(v14 + 68) = 25;
        }
      }
      else if ( a3 == 15 )
      {
        v15 = sub_4A190(a2, 9, 23);
        v7 = v15;
        if ( v15 )
        {
          *(_BYTE *)(v15 + 67) = 10;
          *(_BYTE *)(v15 + 68) = 71;
          *(_WORD *)(v15 + 42) = *a4;
LABEL_59:
          *(_BYTE *)(v7 + 70) = *((_BYTE *)a4 + 24);
        }
      }
    }
  }
  else if ( a3 <= 0x10u )
  {
    v16 = sub_4A190(a2, 9, 5);
    v7 = v16;
    if ( v16 )
    {
      *(_BYTE *)(v16 + 67) = 10;
      *(_BYTE *)(v16 + 68) = 11;
      *(_WORD *)(v16 + 42) = *a4;
      *(_BYTE *)(v16 + 70) = *((_BYTE *)a4 + 24);
    }
  }
  else if ( a3 < 0x14u )
  {
    if ( a3 <= 0x11u )
    {
      v17 = sub_4A190(a2, 9, 2);
      v7 = v17;
      if ( v17 )
      {
        *(_BYTE *)(v17 + 67) = 10;
        *(_BYTE *)(v17 + 68) = 15;
        *(_WORD *)(v17 + 42) = *a4;
        *(_BYTE *)(v17 + 70) = *((_BYTE *)a4 + 24);
      }
    }
    else if ( a3 == 18 )
    {
      v18 = sub_4A190(a2, 9, 4);
      v7 = v18;
      if ( v18 )
      {
        *(_BYTE *)(v18 + 67) = 10;
        *(_BYTE *)(v18 + 68) = 9;
        *(_WORD *)(v18 + 42) = *a4;
        *(_BYTE *)(v18 + 70) = *((_BYTE *)a4 + 24);
      }
    }
  }
  else if ( a3 <= 0x14u )
  {
    v19 = sub_4A190(a2, 9, 22);
    v7 = v19;
    if ( v19 )
    {
      *(_BYTE *)(v19 + 67) = 10;
      *(_BYTE *)(v19 + 68) = 67;
      *(_WORD *)(v19 + 42) = *a4;
      *(_BYTE *)(v19 + 70) = *((_BYTE *)a4 + 24);
    }
  }
  else
  {
    if ( a3 <= 0x15u )
    {
      v20 = sub_4A190(a2, 9, 26);
      v21 = v20;
      v7 = v20;
      if ( !v20 )
        goto LABEL_60;
      *(_BYTE *)(v20 + 67) = 10;
      *(_BYTE *)(v20 + 68) = 22;
      if ( *((_BYTE *)a4 + 24) )
        v22 = *(_DWORD *)a4 / (int)*((unsigned __int8 *)a4 + 24);
      else
        LOWORD(v22) = *a4;
      goto LABEL_58;
    }
    if ( a3 == 25 )
    {
      v23 = sub_4A190(a2, 9, 30);
      v21 = v23;
      v7 = v23;
      if ( v23 )
      {
        *(_BYTE *)(v23 + 67) = 10;
        *(_BYTE *)(v23 + 68) = 89;
        if ( *((_BYTE *)a4 + 24) )
          v22 = *(_DWORD *)a4 / (int)*((unsigned __int8 *)a4 + 24);
        else
          LOWORD(v22) = *a4;
LABEL_58:
        *(_WORD *)(v21 + 42) = v22;
        goto LABEL_59;
      }
    }
  }
LABEL_60:
  if ( v7 )
  {
    v24 = a5 + *(_WORD *)(v7 + 130);
    *(_WORD *)(v7 + 130) = v24;
    if ( v24 < 384 )
      *(_WORD *)(v7 + 130) = 384;
    if ( *(__int16 *)(v7 + 130) > 0x2000 )
      *(_WORD *)(v7 + 130) = 0x2000;
    if ( a6 )
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, v6);
  }
  return v7;
}
// D41A0: using guessed type int dword_D41A0;

//----- (0006E020) --------------------------------------------------------
int __cdecl sub_6E020(unsigned __int16 a1)
{
  int result; // eax

  result = 0;
  if ( a1 < 0x11u )
  {
    if ( a1 < 0xBu )
    {
      if ( a1 == 9 )
        return 18;
    }
    else if ( a1 <= 0xBu )
    {
      return 16;
    }
    else if ( a1 == 15 )
    {
      return 17;
    }
  }
  else if ( a1 <= 0x11u )
  {
    return 9;
  }
  else if ( a1 < 0x43u )
  {
    if ( a1 == 22 )
      return 21;
  }
  else if ( a1 <= 0x43u )
  {
    return 20;
  }
  else if ( a1 == 71 )
  {
    return 15;
  }
  return result;
}

//----- (0006E090) --------------------------------------------------------
int __cdecl sub_6E090(int a1, int a2)
{
  int i; // eax
  int result; // eax

  for ( i = 0; i < 26; ++i )
  {
    if ( *(_WORD *)(a1 + 2 * i + 208) )
      *(_DWORD *)(a1 + 4 * i + 104) += a2;
  }
  result = dword_D41A4;
  if ( *(char *)(dword_D41A4 + 23) >= 0 && *(int *)(a1 + 112) > 7 )
    *(_DWORD *)(a1 + 112) = 7;
  return result;
}
// D41A4: using guessed type int dword_D41A4;

//----- (0006E0D0) --------------------------------------------------------
int sub_6E0D0()
{
  int v0; // edx
  int v1; // ecx
  int v2; // ebx

  v0 = 0;
  v1 = *(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)] + 164)
     + 611;
  while ( v0 < 26 )
  {
    *(_BYTE *)(v1 + v0 + 390) = 1;
    v2 = dword_DA85A[20 * v0++];
    *(_DWORD *)(v1 + 4 * v0 - 4) = v2 + 1;
  }
  return sub_6DB50(1, 0);
}
// D41A0: using guessed type int dword_D41A0;
// DA85A: using guessed type int dword_DA85A[69];
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006E150) --------------------------------------------------------
void sub_6E150()
{
  __int16 i; // si
  unsigned __int16 v1; // di
  int v2; // ebx
  int v3; // ebx

  if ( byte_E3799 && byte_E3798 && ((*(_BYTE *)(dword_D41A4 + 24) & 1) == 0 || *(_BYTE *)(dword_D41A4 + 38543)) )
  {
    for ( i = 0; i < 70; ++i )
    {
      switch ( word_F4FE0[6 * i] )
      {
        case 1:
          sub_75110(word_F4FE6[6 * i], i, word_F4FE4[6 * i], word_F4FE2[6 * i], word_F4FEA[6 * i]);
          word_F4FE0[6 * i] = 0;
          word_F4FE8[6 * i] = 2;
          break;
        case 2:
          sub_751B0(word_F4FE6[6 * i], i, word_F4FE4[6 * i], word_F4FE2[6 * i], word_F4FEA[6 * i]);
          word_F4FE0[6 * i] = 0;
          word_F4FE8[6 * i] = 2;
          break;
        case 3:
          sub_75160(word_F4FE6[6 * i], i, word_F4FE4[6 * i], word_F4FE2[6 * i], word_F4FEA[6 * i]);
          word_F4FE0[6 * i] = 0;
          word_F4FE8[6 * i] = 2;
          break;
        case 4:
          v1 = word_F4FE4[6 * i];
          if ( v1 == 512 )
            sub_8F420(0, i);
          else
            sub_8F100(0, i, (int)v1 >> 8, 64, 0x64u, -1, 2u);
          v2 = 3 * i;
          word_F4FE8[2 * v2] = 2;
          word_F4FE0[2 * v2] = 0;
          break;
        default:
          break;
      }
      v3 = 3 * i;
      word_F4FE4[2 * v3] = 0;
    }
  }
}
// D41A4: using guessed type int dword_D41A4;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// F4FE0: using guessed type __int16 word_F4FE0[];
// F4FE2: using guessed type __int16 word_F4FE2[];
// F4FE4: using guessed type __int16 word_F4FE4[];
// F4FE6: using guessed type __int16 word_F4FE6[];
// F4FE8: using guessed type __int16 word_F4FE8[];
// F4FEA: using guessed type __int16 word_F4FEA[419];

//----- (0006E450) --------------------------------------------------------
void __cdecl sub_6E450(__int16 a1, __int16 a2, __int16 a3)
{
  unsigned int v3; // edx
  _WORD *v4; // esi
  int v5; // eax
  int v6; // eax
  int v7; // esi
  int v8; // edx
  int v9; // edi
  unsigned int v10; // eax
  unsigned int v11; // edx
  int v12; // ebx
  __int16 v13; // [esp+0h] [ebp-24h]
  unsigned int v14; // [esp+4h] [ebp-20h]
  int v15; // [esp+Ch] [ebp-18h]
  signed int v16; // [esp+10h] [ebp-14h]
  int v17; // [esp+14h] [ebp-10h]
  unsigned __int16 v18; // [esp+18h] [ebp-Ch]
  __int16 v19; // [esp+1Ch] [ebp-8h]
  __int16 v20; // [esp+20h] [ebp-4h]

  v20 = 0;
  v13 = 0;
  v15 = *(_DWORD *)(dword_D41A0 + 8);
  if ( !byte_E3799 || !byte_E3798 )
    return;
  v3 = dword_EA3E4[a1];
  v14 = v3;
  if ( v3 <= dword_EA3E4[0] )
  {
    v7 = 0x7FFF;
    LOWORD(v9) = 0x7FFF;
  }
  else
  {
    if ( *(char *)(v3 + 12) < 0 )
      return;
    v4 = (_WORD *)(v3 + 76);
    if ( (unsigned int)sub_584D0(
                         (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12)
                                                                   + dword_D41A0
                                                                   + 11240)]
                                 + 76),
                         (_WORD *)(v3 + 76)) > 0x9000000 )
      return;
    v17 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
    v20 = *(_WORD *)(v3 + 26);
    v16 = sub_58490((_WORD *)(v17 + 76), v4);
    v19 = sub_581E0((_WORD *)(v17 + 76), v4);
    v18 = sub_582B0(*(_WORD *)(v17 + 28), v19);
    v5 = 12288 * (512 - v18 / 2 + 512);
    v6 = (v5 - (__CFSHL__(v5 >> 31, 10) + (v5 >> 31 << 10))) >> 10;
    v7 = v6 ? 0x7FFF * (v6 - v16) / v6 : 0x7FFF;
    v8 = (__int16)sub_582F0(*(unsigned __int16 *)(v17 + 28), v19);
    if ( v7 < 512 )
      return;
    if ( v7 > 0x7FFF )
      v7 = 0x7FFF;
    if ( v16 > 320 )
    {
      if ( v18 > 0x200u )
        v18 = 1024 - v18;
      v9 = (((v18 << 15) * v8 - (__CFSHL__(((v18 << 15) * v8) >> 31, 9) + (((v18 << 15) * v8) >> 31 << 9))) >> 9)
         + 0x7FFF;
      if ( v9 < 0 )
        v9 = 0;
      if ( v9 > 0xFFFF )
        LOWORD(v9) = -1;
    }
    else
    {
      LOWORD(v9) = 0x7FFF;
    }
    if ( (unsigned __int16)a3 >= 0x2Au )
    {
      v10 = 9377 * v15 + 9439;
      if ( (unsigned __int16)a3 <= 0x2Cu )
      {
        v11 = v10 % 0x1E - 15;
      }
      else
      {
        if ( a3 != 46 )
          goto LABEL_29;
        v11 = v10 % 0x14;
        if ( *(_BYTE *)(v14 + 69) == 14 )
          LOWORD(v11) = v11 + 10;
        else
          LOWORD(v11) = v11 - 10;
      }
      v13 = v11;
    }
  }
LABEL_29:
  if ( (unsigned __int16)a3 < 0x2Au )
  {
    if ( (unsigned __int16)a3 < 0x20u )
    {
      if ( a3 != 7 )
        goto LABEL_46;
      goto LABEL_45;
    }
    if ( (unsigned __int16)a3 <= 0x20u || a3 == 38 )
LABEL_45:
      v20 = 0;
  }
  else
  {
    if ( (unsigned __int16)a3 <= 0x2Cu )
      goto LABEL_45;
    if ( (unsigned __int16)a3 >= 0x31u )
    {
      if ( (unsigned __int16)a3 > 0x35u && ((unsigned __int16)a3 < 0x3Au || (unsigned __int16)a3 > 0x3Bu && a3 != 62) )
        goto LABEL_46;
      goto LABEL_45;
    }
    if ( (unsigned __int16)a3 >= 0x2Eu && (unsigned __int16)a3 <= 0x2Fu )
      goto LABEL_45;
  }
LABEL_46:
  switch ( a3 )
  {
    case 1:
    case 2:
      if ( a2 == *(_WORD *)(dword_D41A0 + 12) )
      {
        sub_8F100(0, a3, 0, 64, 0x64u, -1, 2u);
        sub_8F710(0, a3, 0x46u, 2u, 0);
      }
      break;
    case 3:
    case 4:
    case 6:
    case 9:
    case 10:
    case 11:
    case 15:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 30:
    case 38:
    case 40:
    case 41:
    case 48:
    case 50:
    case 51:
    case 52:
    case 53:
    case 60:
    case 61:
    case 63:
    case 64:
      if ( sub_6EA90(v7, (unsigned __int16)word_F4FE4[6 * a3]) )
      {
        word_F4FE4[6 * a3] = v7;
        word_F4FE2[6 * a3] = v9;
        word_F4FEA[6 * a3] = v13;
        word_F4FE0[6 * a3] = 1;
        word_F4FE6[6 * a3] = v20;
      }
      break;
    case 5:
      if ( a2 == *(_WORD *)(dword_D41A0 + 12) )
      {
        sub_8F100(0, a3, 0, 64, 0x64u, -1, 2u);
        sub_8F710(0, a3, 0x78u, 2u, 0);
      }
      break;
    case 7:
    case 8:
    case 12:
    case 13:
    case 16:
    case 17:
    case 32:
    case 33:
    case 34:
    case 37:
    case 39:
    case 42:
    case 43:
    case 44:
    case 46:
    case 58:
    case 59:
    case 62:
      if ( sub_6EA90(v7, (unsigned __int16)word_F4FE4[6 * a3]) )
      {
        word_F4FE4[6 * a3] = v7;
        word_F4FE2[6 * a3] = v9;
        word_F4FEA[6 * a3] = v13;
        word_F4FE0[6 * a3] = 3;
        word_F4FE6[6 * a3] = v20;
      }
      break;
    case 14:
    case 29:
      if ( sub_6EA90(v7, (unsigned __int16)word_F4FE4[6 * a3]) )
      {
        if ( a2 == *(_WORD *)(dword_D41A0 + 12) )
        {
          word_F4FE4[6 * a3] = v7;
          word_F4FE2[6 * a3] = v9;
          word_F4FEA[6 * a3] = v13;
          word_F4FE6[6 * a3] = 0;
          word_F4FE0[6 * a3] = 1;
        }
        else if ( a2 == -1 )
        {
          word_F4FE4[6 * a3] = v7;
          word_F4FE2[6 * a3] = v9;
          word_F4FEA[6 * a3] = v13;
          word_F4FE6[6 * a3] = v20;
          word_F4FE0[6 * a3] = 1;
        }
      }
      break;
    case 31:
      if ( a2 == *(_WORD *)(dword_D41A0 + 12) )
      {
        sub_8F100(0, a3, 0, 64, 0x64u, -1, 2u);
        sub_8F710(0, a3, 0x55u, 2u, 0);
      }
      break;
    case 47:
    case 49:
      if ( sub_6EA90(v7, (unsigned __int16)word_F4FE4[6 * a3]) )
      {
        word_F4FE4[6 * a3] = v7;
        word_F4FE2[6 * a3] = v9;
        word_F4FEA[6 * a3] = v13;
        word_F4FE6[6 * a3] = v20;
        word_F4FE0[6 * a3] = 4;
      }
      break;
    case 54:
    case 55:
    case 56:
    case 57:
      if ( sub_6EA90(v7, (unsigned __int16)word_F4FE4[6 * a3]) )
      {
        if ( a2 == *(_WORD *)(dword_D41A0 + 12) )
        {
          word_F4FE4[6 * a3] = v7;
          word_F4FE2[6 * a3] = v9;
          word_F4FEA[6 * a3] = v13;
          word_F4FE6[6 * a3] = 0;
          word_F4FE0[6 * a3] = 3;
        }
        else if ( a2 == -1 )
        {
          word_F4FE4[6 * a3] = v7;
          word_F4FE2[6 * a3] = v9;
          word_F4FEA[6 * a3] = v13;
          word_F4FE6[6 * a3] = v20;
          word_F4FE0[6 * a3] = 3;
        }
      }
      break;
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
      v12 = 3 * a3;
      word_F4FE4[2 * v12] = v7;
      word_F4FE2[2 * v12] = v9;
      word_F4FE0[2 * v12] = 3;
      word_F4FEA[2 * v12] = v13;
      word_F4FE6[2 * v12] = v20;
      break;
    default:
      return;
  }
}
// D41A0: using guessed type int dword_D41A0;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// EA3E4: using guessed type int dword_EA3E4[];
// F4FE0: using guessed type __int16 word_F4FE0[];
// F4FE2: using guessed type __int16 word_F4FE2[];
// F4FE4: using guessed type __int16 word_F4FE4[];
// F4FE6: using guessed type __int16 word_F4FE6[];
// F4FEA: using guessed type __int16 word_F4FEA[419];

//----- (0006EA90) --------------------------------------------------------
bool __cdecl sub_6EA90(int a1, int a2)
{
  return a1 - a2 >= -8;
}

//----- (0006EAB0) --------------------------------------------------------
void __cdecl sub_6EAB0(int a1, __int16 a2, __int16 a3)
{
  if ( !byte_E3799 || !byte_E3798 )
    return;
  if ( (unsigned __int16)a3 < 0x1Fu )
  {
    if ( !a3 || (unsigned __int16)a3 > 2u && a3 != 5 )
      return;
  }
  else if ( (unsigned __int16)a3 > 0x1Fu )
  {
    if ( (unsigned __int16)a3 >= 0x2Fu && ((unsigned __int16)a3 <= 0x2Fu || a3 == 49) )
      sub_8F710(0, a3, 0, 4u, 1);
    return;
  }
  if ( a2 == *(_WORD *)(dword_D41A0 + 12) )
    sub_8F710(0, a3, 0, 2u, 1);
}
// D41A0: using guessed type int dword_D41A0;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;

//----- (0006EB90) --------------------------------------------------------
unsigned int __cdecl sub_6EB90(unsigned int **a1)
{
  unsigned int **i; // ebx
  unsigned int result; // eax

  for ( i = a1; *i; i += 3 )
  {
    if ( (word_180660 & 1) != 0 )
      result = sub_98709(**i, *i[1], *i[2]);
    else
      result = (unsigned int)sub_9874D((unsigned int *)**i, *i[1], *i[2]);
  }
  return result;
}
// 180660: using guessed type __int16 word_180660;

//----- (0006EBF0) --------------------------------------------------------
unsigned int __cdecl sub_6EBF0(unsigned int **a1)
{
  unsigned int **i; // ebx
  unsigned int result; // eax

  for ( i = a1; *i; i += 3 )
  {
    if ( (word_180660 & 1) != 0 )
      result = sub_99A77(**i, *i[1], *i[2]);
    else
      result = (unsigned int)sub_99AEB((unsigned int *)**i, *i[1], *i[2]);
  }
  return result;
}
// 180660: using guessed type __int16 word_180660;

//----- (0006EDB0) --------------------------------------------------------
int sub_6EDB0()
{
  if ( word_180660 == 1 )
    return sub_6EDE0(320, 200);
  else
    return sub_6EDE0(320, 240);
}
// 180660: using guessed type __int16 word_180660;

//----- (0006EDE0) --------------------------------------------------------
int __cdecl sub_6EDE0(__int16 a1, __int16 a2)
{
  __int16 v2; // si
  __int16 v3; // bx
  int result; // eax
  __int16 v5; // ax
  __int16 v6[14]; // [esp+0h] [ebp-38h] BYREF
  char v7[28]; // [esp+1Ch] [ebp-1Ch] BYREF

  v2 = a1;
  v3 = a2;
  memset(v6, 0, sizeof(v6));
  result = memset(v7, 0, sizeof(v7));
  if ( dword_E3768 > 0 )
  {
    if ( a1 != -1 || (result = a2, a2 != -1) )
    {
      result = a1;
      if ( a1 != -1 )
      {
        v6[0] = 4;
        if ( a1 <= 0 )
        {
          if ( (word_180660 & 1) == 0 )
            v2 = 8 * a1;
        }
        else
        {
          if ( a1 > 638 )
            v2 = 638;
          word_E3760 = v2;
          if ( (word_180660 & 1) == 0 )
            v2 *= 8;
        }
        v6[4] = v2;
        if ( a2 <= 0 )
        {
          if ( (word_180660 & 1) != 0 )
            v5 = word_E3762;
          else
            v5 = 8 * word_E3762;
          v6[6] = v5;
        }
        else
        {
          if ( (word_180660 & 1) != 0 )
          {
            if ( a2 > 398 )
              v3 = 398;
            word_E3762 = v3;
            if ( (word_180660 & 1) == 0 )
              v3 *= 8;
          }
          else
          {
            if ( a2 > 478 )
              v3 = 478;
            word_E3762 = v3;
            if ( (word_180660 & 1) == 0 )
              v3 *= 8;
          }
          v6[6] = v3;
        }
        return int386(51, v6, v7);
      }
    }
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E3760: using guessed type __int16 word_E3760;
// E3762: using guessed type __int16 word_E3762;
// E3768: using guessed type int dword_E3768;
// 180660: using guessed type __int16 word_180660;

//----- (0006EF10) --------------------------------------------------------
__int16 __cdecl sub_6EF10(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  __int16 v4; // si
  __int16 v5; // bx
  __int16 result; // ax
  char v7[28]; // [esp+0h] [ebp-38h] BYREF
  __int16 v8[14]; // [esp+1Ch] [ebp-1Ch] BYREF

  v4 = a2;
  v5 = a4;
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  if ( a2 > 638 )
    v4 = 638;
  result = word_180660;
  if ( word_180660 )
  {
    if ( (unsigned __int16)word_180660 <= 1u )
    {
      v8[4] = a1;
      v8[6] = v4;
      v8[0] = 7;
      int386(51, v8, v7);
      v8[0] = 8;
      v8[4] = a3;
      if ( a4 > 398 )
        v5 = 398;
    }
    else
    {
      if ( word_180660 != 8 )
        return result;
      v8[0] = 7;
      v8[4] = 8 * a1;
      v8[6] = 8 * v4;
      int386(51, v8, v7);
      v8[0] = 8;
      if ( a4 > 478 )
        v5 = 478;
      v8[4] = 8 * a3;
      v5 *= 8;
    }
    v8[6] = v5;
    return int386(51, v8, v7);
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 180660: using guessed type __int16 word_180660;

//----- (0006F030) --------------------------------------------------------
int __cdecl sub_6F030(int a1)
{
  int result; // eax

  result = sub_6F850(a1, 1);
  if ( result )
  {
    sub_4A1E0(*(_WORD *)(a1 + 26), *(__int16 *)(a1 + 26), 1);
    return sub_57F10(a1);
  }
  return result;
}

//----- (0006F070) --------------------------------------------------------
int __cdecl sub_6F070(int a1)
{
  int result; // eax

  result = sub_6F850(a1, 0);
  if ( result )
  {
    sub_4A1E0(*(_WORD *)(a1 + 26), *(__int16 *)(a1 + 26), 1);
    return sub_57F10(a1);
  }
  return result;
}

//----- (0006F0B0) --------------------------------------------------------
unsigned int __cdecl sub_6F0B0(int a1)
{
  unsigned int result; // eax

  if ( *(_DWORD *)(a1 + 16) )
  {
    result = sub_6F8E0(a1, 1);
    if ( !result )
      --*(_DWORD *)(a1 + 16);
  }
  else
  {
    result = sub_6F850(a1, 1);
    if ( result )
    {
      result = sub_4A1E0(*(_WORD *)(a1 + 26), *(__int16 *)(a1 + 26), 0);
      *(_DWORD *)(a1 + 16) = 10;
    }
  }
  return result;
}

//----- (0006F100) --------------------------------------------------------
unsigned int __cdecl sub_6F100(int a1)
{
  unsigned int result; // eax

  if ( *(_DWORD *)(a1 + 16) )
  {
    result = sub_6F8E0(a1, 0);
    if ( !result )
      --*(_DWORD *)(a1 + 16);
  }
  else
  {
    result = sub_6F850(a1, 0);
    if ( result )
    {
      result = sub_4A1E0(*(_WORD *)(a1 + 26), *(__int16 *)(a1 + 26), 0);
      *(_DWORD *)(a1 + 16) = 10;
    }
  }
  return result;
}

//----- (0006F150) --------------------------------------------------------
unsigned int __cdecl sub_6F150(int a1)
{
  unsigned int result; // eax

  result = *(_DWORD *)(dword_D41A4 + 38519);
  if ( result > dword_EA3E4[0] )
  {
    while ( *(_BYTE *)(result + 64) || !byte_3659C[11 * *(__int16 *)(*(_DWORD *)(result + 164) + 56) + dword_D41A0] )
    {
      result = *(_DWORD *)result;
      if ( result <= dword_EA3E4[0] )
        return result;
    }
    sub_4A1E0(*(_WORD *)(a1 + 26), *(__int16 *)(a1 + 26), 1);
    return sub_57F10(a1);
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006F1C0) --------------------------------------------------------
int __cdecl sub_6F1C0(int a1)
{
  int result; // eax
  __int16 v2; // bx
  __int16 v3; // dx

  result = *(unsigned __int8 *)(dword_D41A0 + 224769);
  if ( *(char *)(a1 + 70) < result )
  {
    if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
      v2 = *(_WORD *)(dword_D41A0 + 14);
    else
      v2 = 1;
    v3 = 0;
    result = (int)&byte_3659C[dword_D41A0];
    while ( v3 < v2 )
    {
      if ( *(_BYTE *)(*(char *)(a1 + 70) + result + 3) == 2 )
      {
        *(_BYTE *)(result + 2) = 1;
        sub_4A1E0(*(_WORD *)(a1 + 26), *(__int16 *)(a1 + 26), 1);
        return sub_57F10(a1);
      }
      ++v3;
      result += 11;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (0006F2B0) --------------------------------------------------------
_BYTE *__cdecl sub_6F2B0(int a1)
{
  _BYTE *result; // eax
  unsigned __int16 v2; // dx

  result = (_BYTE *)sub_6F850(a1, 1);
  if ( result )
  {
    result[69] = 12;
    result[70] = 0;
    sub_57F10(a1);
    result = (_BYTE *)dword_D41A0;
    v2 = *(_WORD *)(dword_D41A0 + 224766);
    if ( v2 )
    {
      result = (_BYTE *)dword_EA3E4[v2];
      result[12] &= ~1u;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006F300) --------------------------------------------------------
unsigned int __cdecl sub_6F300(int a1, unsigned int a2)
{
  unsigned int result; // eax
  int v3; // esi

  result = a2;
  if ( a2 == -1 )
  {
    for ( result = 0; (int)result <= 16; ++result )
    {
      if ( (result <= 0xB || result >= 0x10 && result <= 0x1C) && *(_DWORD *)(dword_D41A4 + 4 * result + 38403) )
        return result;
    }
    v3 = *(_DWORD *)(a1 + 16);
    if ( !v3 )
    {
      *(_DWORD *)(a1 + 16) = 16;
      return result;
    }
    if ( v3 == 1 )
    {
LABEL_6:
      sub_6E450((a1 - (dword_D41A0 + 28302)) / 168, -1, 41);
      sub_4A1E0(*(_WORD *)(a1 + 26), *(__int16 *)(a1 + 26), 1);
      return sub_57F10(a1);
    }
  }
  else
  {
    if ( *(_DWORD *)(dword_D41A4 + 4 * a2 + 38403) )
      return result;
    v3 = *(_DWORD *)(a1 + 16);
    if ( !v3 )
    {
      *(_DWORD *)(a1 + 16) = 16;
      return result;
    }
    if ( v3 == 1 )
      goto LABEL_6;
  }
  result = v3 - 1;
  *(_DWORD *)(a1 + 16) = v3 - 1;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;

//----- (0006F420) --------------------------------------------------------
unsigned int __cdecl sub_6F420(int a1)
{
  return sub_6F300(a1, 0);
}

//----- (0006F440) --------------------------------------------------------
unsigned int __cdecl sub_6F440(int a1)
{
  return sub_6F300(a1, 1u);
}

//----- (0006F460) --------------------------------------------------------
unsigned int __cdecl sub_6F460(int a1)
{
  return sub_6F300(a1, 2u);
}

//----- (0006F480) --------------------------------------------------------
unsigned int __cdecl sub_6F480(int a1)
{
  return sub_6F300(a1, 3u);
}

//----- (0006F4A0) --------------------------------------------------------
unsigned int __cdecl sub_6F4A0(int a1)
{
  return sub_6F300(a1, 4u);
}

//----- (0006F4C0) --------------------------------------------------------
unsigned int __cdecl sub_6F4C0(int a1)
{
  return sub_6F300(a1, 5u);
}

//----- (0006F4E0) --------------------------------------------------------
unsigned int __cdecl sub_6F4E0(int a1)
{
  return sub_6F300(a1, 6u);
}

//----- (0006F500) --------------------------------------------------------
unsigned int __cdecl sub_6F500(int a1)
{
  return sub_6F300(a1, 7u);
}

//----- (0006F520) --------------------------------------------------------
unsigned int __cdecl sub_6F520(int a1)
{
  return sub_6F300(a1, 8u);
}

//----- (0006F540) --------------------------------------------------------
unsigned int __cdecl sub_6F540(int a1)
{
  return sub_6F300(a1, 9u);
}

//----- (0006F560) --------------------------------------------------------
unsigned int __cdecl sub_6F560(int a1)
{
  return sub_6F300(a1, 0xAu);
}

//----- (0006F580) --------------------------------------------------------
unsigned int __cdecl sub_6F580(int a1)
{
  return sub_6F300(a1, 0xBu);
}

//----- (0006F5A0) --------------------------------------------------------
unsigned int __cdecl sub_6F5A0(int a1)
{
  return sub_6F300(a1, 0xCu);
}

//----- (0006F5C0) --------------------------------------------------------
unsigned int __cdecl sub_6F5C0(int a1)
{
  return sub_6F300(a1, 0xDu);
}

//----- (0006F5E0) --------------------------------------------------------
unsigned int __cdecl sub_6F5E0(int a1)
{
  return sub_6F300(a1, 0xEu);
}

//----- (0006F600) --------------------------------------------------------
unsigned int __cdecl sub_6F600(int a1)
{
  return sub_6F300(a1, 0xFu);
}

//----- (0006F620) --------------------------------------------------------
unsigned int __cdecl sub_6F620(int a1)
{
  return sub_6F300(a1, 0x10u);
}

//----- (0006F640) --------------------------------------------------------
unsigned int __cdecl sub_6F640(int a1)
{
  return sub_6F300(a1, 0x11u);
}

//----- (0006F660) --------------------------------------------------------
unsigned int __cdecl sub_6F660(int a1)
{
  return sub_6F300(a1, 0x12u);
}

//----- (0006F680) --------------------------------------------------------
unsigned int __cdecl sub_6F680(int a1)
{
  return sub_6F300(a1, 0x13u);
}

//----- (0006F6A0) --------------------------------------------------------
unsigned int __cdecl sub_6F6A0(int a1)
{
  return sub_6F300(a1, 0x14u);
}

//----- (0006F6C0) --------------------------------------------------------
unsigned int __cdecl sub_6F6C0(int a1)
{
  return sub_6F300(a1, 0x15u);
}

//----- (0006F6E0) --------------------------------------------------------
unsigned int __cdecl sub_6F6E0(int a1)
{
  return sub_6F300(a1, 0x16u);
}

//----- (0006F700) --------------------------------------------------------
unsigned int __cdecl sub_6F700(int a1)
{
  return sub_6F300(a1, 0x17u);
}

//----- (0006F720) --------------------------------------------------------
unsigned int __cdecl sub_6F720(int a1)
{
  return sub_6F300(a1, 0x18u);
}

//----- (0006F740) --------------------------------------------------------
unsigned int __cdecl sub_6F740(int a1)
{
  return sub_6F300(a1, 0x19u);
}

//----- (0006F760) --------------------------------------------------------
unsigned int __cdecl sub_6F760(int a1)
{
  return sub_6F300(a1, 0x1Au);
}

//----- (0006F780) --------------------------------------------------------
unsigned int __cdecl sub_6F780(int a1)
{
  return sub_6F300(a1, 0x1Bu);
}

//----- (0006F7A0) --------------------------------------------------------
unsigned int __cdecl sub_6F7A0(int a1)
{
  return sub_6F300(a1, 0x1Cu);
}

//----- (0006F7C0) --------------------------------------------------------
unsigned int __cdecl sub_6F7C0(int a1)
{
  return sub_6F300(a1, 0xFFFFFFFF);
}

//----- (0006F7E0) --------------------------------------------------------
_BYTE *__cdecl sub_6F7E0(int a1)
{
  _BYTE *result; // eax
  unsigned __int16 v2; // dx

  if ( (*(_BYTE *)(dword_D41A4 + 38545) & 8) != 0 )
    return (_BYTE *)sub_57F10(a1);
  result = (_BYTE *)sub_6F850(a1, 1);
  if ( result )
  {
    result[69] = 11;
    result[70] = 0;
    sub_57F10(a1);
    result = (_BYTE *)dword_D41A0;
    v2 = *(_WORD *)((char *)&loc_36DFC + dword_D41A0);
    if ( v2 )
    {
      result = (_BYTE *)dword_EA3E4[v2];
      result[12] &= ~1u;
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006F850) --------------------------------------------------------
unsigned int __cdecl sub_6F850(int a1, int a2)
{
  unsigned int i; // ebx

  if ( (*(_BYTE *)(a1 + 62) & 7) != 0 )
    return 0;
  for ( i = *(_DWORD *)(dword_D41A4 + 38519); ; i = *(_DWORD *)i )
  {
    if ( i <= dword_EA3E4[0] )
    {
      *(_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
      return 0;
    }
    if ( !*(_BYTE *)(i + 64) && sub_10750(a1, i) == a2 )
      break;
  }
  if ( *(_BYTE *)(a1 + 64) > 3u )
    sub_6E450((int)(i - (dword_D41A0 + 28302)) / 168, -1, 41);
  return i;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006F8E0) --------------------------------------------------------
int __cdecl sub_6F8E0(int a1, int a2)
{
  unsigned __int16 v2; // bx
  int v3; // esi
  int v4; // edi

  v2 = 0;
  v3 = dword_D41A0 + 11230;
  while ( v2 < *(_WORD *)(dword_D41A0 + 14) )
  {
    v4 = dword_EA3E4[*(unsigned __int16 *)(v3 + 10)];
    if ( sub_10750(a1, v4) == a2 )
      return v4;
    v3 += 2124;
    ++v2;
  }
  return 0;
}
// D41A0: using guessed type int dword_D41A0;
// EA3E4: using guessed type int dword_EA3E4[];

//----- (0006F940) --------------------------------------------------------
int __cdecl sub_6F940(_BYTE *a1, int a2, __int16 a3, unsigned __int8 a4)
{
  int v5; // ebx
  unsigned __int16 v6; // ax
  int v7; // edi
  int v8; // eax
  int result; // eax

  v5 = a2;
  word_E36D4 = 64;
  while ( *a1 && (__int16)v5 < 640 )
  {
    v6 = (unsigned __int8)*a1;
    if ( v6 < 0xAu )
    {
      if ( !*a1 )
        goto LABEL_16;
      if ( v6 == 9 )
        goto LABEL_14;
    }
    else
    {
      if ( (unsigned __int8)*a1 <= 0xAu )
      {
        v5 = a2;
        a3 += sub_6FC30();
        goto LABEL_16;
      }
      if ( v6 >= 0xDu )
      {
        if ( v6 <= 0xDu )
          goto LABEL_16;
        if ( v6 == 32 )
        {
LABEL_14:
          LOWORD(v8) = sub_6FC10();
          goto LABEL_15;
        }
      }
    }
    if ( !*a1 )
      goto LABEL_14;
    v7 = 6 * ((unsigned __int8)*a1 + 1);
    sub_72C40(v5, a3, v7 + dword_EA3D4, a4);
    v8 = *(unsigned __int8 *)(dword_EA3D4 + v7 + 4);
LABEL_15:
    v5 += v8;
LABEL_16:
    ++a1;
  }
  result = v5;
  word_E36D4 = 0;
  return result;
}
// 6F9F0: variable 'v8' is possibly undefined
// E36D4: using guessed type __int16 word_E36D4;
// EA3D4: using guessed type int dword_EA3D4;

//----- (0006FC10) --------------------------------------------------------
__int16 sub_6FC10()
{
  return *(unsigned __int8 *)(dword_EA3D4 + 202);
}
// EA3D4: using guessed type int dword_EA3D4;

//----- (0006FC30) --------------------------------------------------------
__int16 sub_6FC30()
{
  return *(unsigned __int8 *)(dword_EA3D4 + 203);
}
// EA3D4: using guessed type int dword_EA3D4;

//----- (0006FC50) --------------------------------------------------------
int __cdecl sub_6FC50(__int16 a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  v2 = dword_E9B20[result];
  if ( !v2 )
    v2 = dword_E9B20[0];
  dword_EA3D4 = v2;
  return result * 4;
}
// E9B20: using guessed type int dword_E9B20[];
// EA3D4: using guessed type int dword_EA3D4;

//----- (0006FC80) --------------------------------------------------------
unsigned int __cdecl sub_6FC80(char *a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5)
{
  unsigned int v5; // kr04_4
  __int16 v6; // cx
  __int16 v7; // ax
  int v8; // esi
  int v9; // eax
  __int16 v11; // [esp+0h] [ebp-4h]

  v11 = a3 - a2;
  v5 = strlen(a1) + 1;
  v6 = v5 - 1;
  if ( (_WORD)v5 == 1 )
  {
    v8 = a2 + v11 / 2;
  }
  else
  {
    v7 = sub_6FC10();
    v8 = a2 + v11 / 2 - v6 * v7 / 2;
    sub_2BC10(a1, a2 + v11 / 2 - v6 * v7 / 2, a4, a5);
  }
  LOWORD(v9) = sub_6FC10();
  return v8 + v9 * strlen(a1);
}
// 6FD1C: variable 'v9' is possibly undefined

//----- (0006FD30) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn sub_6FD30(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  int v7; // [esp-4h] [ebp-4h] BYREF

  ((void (__cdecl __noreturn *)(_DWORD, _DWORD, _DWORD, _DWORD, int, int, int, int, int *, int, int, int))_GETDS)(
    (unsigned __int16)__GS__,
    (unsigned __int16)__FS__,
    (unsigned __int16)__ES__,
    (unsigned __int16)__DS__,
    a1,
    a2,
    a3,
    a4,
    &v7,
    a5,
    a6,
    a7);
}
// 6FD9C: positive sp value 4 has been found
// 6FD9C: control flows out of bounds to 6FD9D
// 99B86: using guessed type _DWORD __cdecl __far chain_intr(_DWORD);
// D41A4: using guessed type int dword_D41A4;
// 17DB54: using guessed type int dword_17DB54;

//----- (0006FDA0) --------------------------------------------------------
int sub_6FDA0()
{
  int v0; // eax
  __int64 v1; // rax
  int result; // eax

  v0 = dword_D41A4;
  *(_DWORD *)(dword_D41A4 + 2388) = 10022;
  *(_DWORD *)(v0 + 2392) = 0;
  v1 = dos_getvect(8);
  word_F5334 = WORD2(v1);
  dword_F5330 = v1;
  __outbyte(0x43u, 0x36u);
  __outbyte(0x40u, *(_DWORD *)(dword_D41A4 + 2388));
  __outbyte(0x40u, BYTE1(*(_DWORD *)(dword_D41A4 + 2388)));
  result = dos_setvect(8, sub_6FD30, (unsigned __int16)__CS__);
  BYTE1(result) = 1;
  byte_DB734 = 1;
  return result;
}
// 99BA7: using guessed type __int64 __cdecl dos_getvect(_DWORD);
// 99BDB: using guessed type _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// DB734: using guessed type char byte_DB734;
// F5330: using guessed type int dword_F5330;
// F5334: using guessed type __int16 word_F5334;

//----- (0006FE20) --------------------------------------------------------
void sub_6FE20()
{
  int v0; // eax

  if ( byte_DB734 == 1 )
  {
    __outbyte(0x43u, 0x36u);
    __outbyte(0x40u, 0);
    __outbyte(0x40u, 0);
    v0 = dos_setvect(8, dword_F5330, (unsigned __int16)word_F5334);
    _wcpp_1_unwind_leave__130(v0);
  }
  byte_DB734 = 0;
}
// 6FE80: using guessed type int __fastcall _wcpp_1_unwind_leave__130(_DWORD);
// 99BDB: using guessed type _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// DB734: using guessed type char byte_DB734;
// F5330: using guessed type int dword_F5330;
// F5334: using guessed type __int16 word_F5334;

//----- (0006FE90) --------------------------------------------------------
int __cdecl sub_6FE90(unsigned __int8 *a1, unsigned int a2)
{
  unsigned __int8 *v2; // eax
  int v3; // edx
  int v5; // ebx

  v2 = a1;
  v3 = 0;
  if ( (unsigned int)a1 >= a2 )
    return 0;
  do
  {
    v5 = *v2++;
    v3 += v5;
  }
  while ( (unsigned int)v2 < a2 );
  return v3;
}

//----- (0006FEC0) --------------------------------------------------------
int sub_6FEC0()
{
  int result; // eax
  char v1; // dl
  __int16 v2; // bx
  __int16 v3; // bx
  __int16 v4; // bx
  __int16 v5; // bx
  __int16 v6; // bx
  __int16 v7; // bx
  __int16 v8; // bx
  __int16 v9; // bx
  __int16 v10; // bx
  __int16 v11; // bx
  __int16 v12; // bx
  __int16 v13; // bx
  __int16 v14; // bx
  unsigned int v15; // eax
  __int16 v16; // bx
  __int16 v17; // bx
  __int16 v18; // bx
  __int16 v19; // bx
  __int16 v20; // bx
  __int16 v21; // bx
  __int16 v22; // bx
  int v23; // eax
  __int16 v24; // bx
  __int16 v25; // bx
  __int16 v26; // bx
  __int16 v27; // bx
  __int16 v28; // bx
  int *v29; // edi
  int v30; // ebx
  unsigned __int8 v31; // al
  int v32; // eax
  int v33; // eax
  __int16 v34; // bx
  __int16 v35; // bx
  __int16 v36; // bx
  __int16 v37; // bx
  __int16 v38; // bx
  __int16 v39; // bx
  __int16 v40; // bx
  __int16 v41; // bx
  __int16 v42; // bx
  __int16 v43; // bx
  __int16 v44; // bx
  __int16 v45; // bx
  __int16 v46; // bx
  __int16 v47; // bx
  char v48[256]; // [esp+0h] [ebp+7Eh] BYREF
  int i; // [esp+100h] [ebp+17Eh]

  result = 2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0;
  v1 = *(_BYTE *)(result + 11235);
  if ( (v1 & 8) != 0 )
  {
    sub_6FC50(1);
    sub_2BC10(aProductName, 320, 0, byte_E9800);
    v2 = sub_6FC30();
    sub_2BC10(aMagicCarpet2Ne, 320, v2, byte_E890F);
    v3 = sub_6FC30() + v2;
    sub_2BC10(aVersionNumber, 320, v3, byte_E9800);
    v4 = sub_6FC30() + v3;
    sub_2BC10(aBeta, 320, v4, byte_E890F);
    v5 = sub_6FC30() + v4;
    sub_2BC10(aVersionDate, 320, v5, byte_E9800);
    v6 = sub_6FC30() + v5;
    sprintf(v48, "%s %s", a034213, aSep061995);
    sub_2BC10(v48, 320, v6, byte_E890F);
    v7 = sub_6FC30() + v6;
    sub_2BC10(aProgrammer, 320, v7, byte_E9800);
    v8 = sub_6FC30() + v7;
    sub_2BC10(aBullfrogAlanWr, 320, v8, byte_E890F);
    v9 = sub_6FC30() + v8;
    sub_2BC10(aSuppliedTo, 320, v9, byte_E9800);
    v10 = sub_6FC30() + v9;
    sub_2BC10(aPublic, 320, v10, byte_E890F);
    v11 = sub_6FC30() + v10;
    sub_2BC10(aLevelNumber, 320, v11, byte_E9800);
    v12 = sub_6FC30() + v11;
    sprintf(v48, "%d", *(unsigned __int16 *)(dword_D41A4 + 43));
    sub_2BC10(v48, 320, v12, byte_E890F);
    v13 = sub_6FC30() + v12;
    if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 )
    {
      sub_2BC10(aTransferRate, 320, v13, byte_E9800);
      v14 = sub_6FC30() + v13;
      sprintf(v48, "%d", *(_DWORD *)(dword_D41A4 + 200));
      sub_2BC10(v48, 320, v14, byte_E890F);
      v13 = sub_6FC30() + v14;
    }
    dword_E9C14 = *(_DWORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248);
    v15 = j___clock() / 0x64u;
    dword_E9C1C = v15;
    if ( v15 != dword_E9C20 )
    {
      dword_E9C20 = v15;
      dword_E9C24 = dword_E9C14 - dword_E9C18;
      dword_E9C18 = dword_E9C14;
    }
    sub_2BC10(&aHfps[1], 320, v13, byte_E9800);
    v16 = sub_6FC30() + v13;
    sprintf(v48, "%d", dword_E9C24);
    sub_2BC10(v48, 320, v16, byte_E890F);
    v17 = sub_6FC30() + v16;
    sub_2BC10(aSoundNumber, 320, v17, byte_E9800);
    v18 = sub_6FC30() + v17;
    sprintf(v48, "%d", (unsigned __int16)word_E37B6);
    sub_2BC10(v48, 320, v18, byte_E890F);
    v19 = sub_6FC30() + v18;
    sub_2BC10(aGameTurn, 320, v19, byte_E9800);
    v20 = sub_6FC30() + v19;
    sprintf(v48, "%d %d", *(_DWORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11248), dword_17DB54);
    sub_2BC10(v48, 320, v20, byte_E890F);
    v21 = sub_6FC30() + v20;
    sub_2BC10(aThing, 320, v21, byte_E9800);
    v22 = sub_6FC30() + v21;
    v23 = sub_4A810();
    sprintf(v48, "Thing %d, Active %d", 168, 1000 - v23);
    sub_2BC10(v48, 320, v22, byte_E890F);
    v24 = sub_6FC30() + v22;
    sprintf(v48, "Carpet %d", 224791);
    sub_2BC10(v48, 320, v24, byte_E890F);
    v25 = sub_6FC30() + v24;
    sprintf(v48, "Tape %d", 38547);
    sub_2BC10(v48, 320, v25, byte_E890F);
    v26 = sub_6FC30() + v25;
    sprintf(v48, "Heap %d", *(_DWORD *)(dword_D41A4 + 230));
    sub_2BC10(v48, 320, v26, byte_E890F);
    v27 = sub_6FC30() + v26;
    sub_85350();
    sub_2BC10(aMemoryUsedFree, 320, v27, byte_E9800);
    v28 = sub_6FC30() + v27;
    sprintf(v48, "%d/%d", dword_17FEA8, dword_17FEA4);
    sub_2BC10(v48, 320, v28, byte_E890F);
    v29 = &dword_17ECA0;
    LOWORD(result) = sub_6FC30();
    v30 = 0;
    for ( i = 0; v29; v29 = (int *)v29[2] )
    {
      sprintf(v48, "s%7.7d,u%01d", v29[1], *((unsigned __int8 *)v29 + 16));
      if ( dword_17E0A4[3 * *((unsigned __int8 *)v29 + 17)] )
        v31 = byte_E8900[0];
      else
        v31 = byte_E9800;
      sub_2BC10(v48, i, v30, v31);
      LOWORD(v32) = sub_6FC30();
      v30 += v32;
      result = 400 - sub_6FC30();
      if ( (__int16)v30 > result )
      {
        LOWORD(v33) = sub_6FC10();
        result = 12 * v33;
        i += result;
        v30 = 0;
      }
    }
  }
  else if ( (v1 & 0x40) != 0 )
  {
    v34 = 6 * sub_6FC30();
    sub_2BC10(aThing_0, 10, v34, byte_E9800);
    v35 = sub_6FC30() + v34;
    sprintf(
      v48,
      "%ld / %ld",
      *(_DWORD *)(dword_D41A4 + 38396),
      (*(_DWORD *)(dword_D41A4 + 38396) - (dword_D41A0 + 28302)) / 168);
    sub_2BC10(v48, 10, v35, byte_E89FF);
    v36 = sub_6FC30() + v35;
    sub_2BC10(aClassModelStat, 10, v36, byte_E9800);
    v37 = sub_6FC30() + v36;
    sprintf(
      v48,
      "%ld / %ld / %ld",
      *(char *)(*(_DWORD *)(dword_D41A4 + 38396) + 63),
      *(char *)(*(_DWORD *)(dword_D41A4 + 38396) + 64),
      *(unsigned __int8 *)(*(_DWORD *)(dword_D41A4 + 38396) + 69));
    sub_2BC10(v48, 10, v37, byte_E89FF);
    v38 = sub_6FC30() + v37;
    sub_2BC10(aLifeMaxLife, 10, v38, byte_E9800);
    v39 = sub_6FC30() + v38;
    sprintf(
      v48,
      "%ld / %ld",
      *(_DWORD *)(*(_DWORD *)(dword_D41A4 + 38396) + 8),
      *(_DWORD *)(*(_DWORD *)(dword_D41A4 + 38396) + 4));
    sub_2BC10(v48, 10, v39, byte_E89FF);
    v40 = sub_6FC30() + v39;
    sub_2BC10(aSpeedActualMin, 10, v40, byte_E9800);
    v41 = sub_6FC30() + v40;
    sprintf(
      v48,
      "%ld / %ld / %ld",
      *(__int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 130),
      *(__int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 132),
      *(__int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 134));
    sub_2BC10(v48, 10, v41, byte_E89FF);
    v42 = sub_6FC30() + v41;
    sub_2BC10(aActualXYZ, 10, v42, byte_E9800);
    v43 = sub_6FC30() + v42;
    sprintf(
      v48,
      "%ld / %ld / %ld",
      *(__int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 76),
      *(__int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 78),
      *(__int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 80));
    sub_2BC10(v48, 10, v43, byte_E89FF);
    v44 = sub_6FC30() + v43;
    sub_2BC10(aIdWhoOwnsMe, 10, v44, byte_E9800);
    v45 = sub_6FC30() + v44;
    sprintf(
      v48,
      "%ld / %ld",
      *(__int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 26),
      *(unsigned __int16 *)(*(_DWORD *)(dword_D41A4 + 38396) + 40));
    sub_2BC10(v48, 10, v45, byte_E89FF);
    v46 = sub_6FC30() + v45;
    sub_2BC10(aManaActualMaxi, 10, v46, byte_E9800);
    v47 = sub_6FC30() + v46;
    sprintf(
      v48,
      "%ld / %ld",
      *(_DWORD *)(*(_DWORD *)(dword_D41A4 + 38396) + 144),
      *(_DWORD *)(*(_DWORD *)(dword_D41A4 + 38396) + 140));
    sub_2BC10(v48, 10, v47, byte_E89FF);
    LOWORD(result) = sub_6FC30();
  }
  if ( *(_DWORD *)(dword_D41A4 + 53) == 16273849 )
    *(_BYTE *)(dword_D41A4 + 52) |= 2u;
  return result;
}
// 704CD: variable 'v32' is possibly undefined
// 704EA: variable 'v33' is possibly undefined
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98786: using guessed type int j___clock(void);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E37B6: using guessed type __int16 word_E37B6;
// E890F: using guessed type char byte_E890F;
// E89FF: using guessed type char byte_E89FF;
// E9800: using guessed type char byte_E9800;
// E9C14: using guessed type int dword_E9C14;
// E9C18: using guessed type int dword_E9C18;
// E9C1C: using guessed type int dword_E9C1C;
// E9C20: using guessed type int dword_E9C20;
// E9C24: using guessed type int dword_E9C24;
// 17DB54: using guessed type int dword_17DB54;
// 17E0A4: using guessed type int dword_17E0A4[];
// 17ECA0: using guessed type int dword_17ECA0;
// 17FEA4: using guessed type int dword_17FEA4;
// 17FEA8: using guessed type int dword_17FEA8;

//----- (00070890) --------------------------------------------------------
int sub_70890()
{
  printf(aCopyrightC1995);
  printf(aAllRightsReser);
  return printf(aS_0);
}

//----- (00070910) --------------------------------------------------------
int sub_70910()
{
  int result; // eax

  result = dword_D41A4;
  if ( (*(_BYTE *)(dword_D41A4 + 23) & 1) != 0 )
    return printf(&off_D189C);
  return result;
}
// D189C: using guessed type void *off_D189C;
// D41A4: using guessed type int dword_D41A4;

//----- (00070940) --------------------------------------------------------
int sub_70940()
{
  _WORD *v0; // ebx
  int v1; // edi
  int result; // eax
  int v3; // esi
  int i; // eax
  char v5; // dl
  int v6; // eax
  int v7; // [esp+0h] [ebp-10h] BYREF
  int v8; // [esp+4h] [ebp-Ch] BYREF
  int v9; // [esp+8h] [ebp-8h]
  char v10; // [esp+Ch] [ebp-4h]

  v0 = (_WORD *)dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v1 = ((__int16)v0[38] + 128) >> 8;
  v9 = ((__int16)v0[39] + 128) >> 8;
  result = sub_10080(0, 128);
  v3 = result;
  if ( result )
  {
    v10 = 0;
    while ( sub_10130(v3, &v8, &v7) == 1 && !v10 )
    {
      for ( i = word_15B4E0[256 * (unsigned __int8)(v9 + v7) + (unsigned __int8)(v1 + v8)];
            ;
            i = *(unsigned __int16 *)(v6 + 22) )
      {
        v6 = dword_EA3E4[i];
        if ( v6 == dword_EA3E4[0] || v10 )
          break;
        v5 = 1;
        if ( (_WORD *)v6 == v0
          || *(_BYTE *)(v6 + 63) == 15 && *(_WORD *)(v6 + 26) == v0[13]
          || (*(_BYTE *)(v6 + 12) & 1) != 0 )
        {
          v5 = 0;
        }
        if ( v5 )
        {
          v10 = 1;
          *(_DWORD *)(dword_D41A4 + 38396) = v6;
        }
      }
    }
    return sub_10100(v3);
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// EA3E4: using guessed type int dword_EA3E4[];
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (00070A60) --------------------------------------------------------
char sub_70A60()
{
  char v1[64]; // [esp+0h] [ebp-40h] BYREF

  sprintf(v1, "%c:%s/%s/%s.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_4, aCdata_1, aTmaps00_0);
  dword_DB740 = sub_98817((int)v1, 512);
  if ( dword_DB740 == -1 )
  {
    sprintf(v1, "data/%s.dat", aTmaps00_0);
    dword_DB740 = sub_98817((int)v1, 512);
  }
  sprintf(v1, "%c:%s/%s/%s.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_4, aCdata_1, aTmaps10_0);
  dword_DB744 = sub_98817((int)v1, 512);
  if ( dword_DB744 == -1 )
  {
    sprintf(v1, "data/%s.dat", aTmaps10_0);
    dword_DB744 = sub_98817((int)v1, 512);
  }
  sprintf(v1, "%c:%s/%s/%s.dat", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_4, aCdata_1, aTmaps20_0);
  dword_DB748 = sub_98817((int)v1, 512);
  if ( dword_DB748 == -1 )
  {
    sprintf(v1, "data/%s.dat", aTmaps20_0);
    dword_DB748 = sub_98817((int)v1, 512);
  }
  dword_DB73C = dword_DB740;
  return 1;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;
// DB73C: using guessed type int dword_DB73C;
// DB740: using guessed type int dword_DB740;
// DB744: using guessed type int dword_DB744;
// DB748: using guessed type int dword_DB748;

//----- (00070BF0) --------------------------------------------------------
int sub_70BF0()
{
  int result; // eax

  if ( dword_DB740 != -1 )
  {
    result = sub_98882(dword_DB740);
    dword_DB740 = -1;
  }
  if ( dword_DB744 != -1 )
  {
    sub_98882(dword_DB744);
    result = -1;
    dword_DB744 = -1;
  }
  if ( dword_DB748 != -1 )
  {
    result = sub_98882(dword_DB748);
    dword_DB748 = -1;
  }
  dword_DB73C = -1;
  return result;
}
// DB73C: using guessed type int dword_DB73C;
// DB740: using guessed type int dword_DB740;
// DB744: using guessed type int dword_DB744;
// DB748: using guessed type int dword_DB748;

//----- (00070C60) --------------------------------------------------------
int __cdecl sub_70C60(unsigned __int16 a1, char *a2)
{
  int v2; // edi
  int v3; // ebx
  int result; // eax

  if ( dword_DB73C == -1 )
    return dword_DB73C;
  v2 = 10 * a1;
  sub_9891E(dword_DB73C, *(_DWORD *)(v2 + dword_F6ED0 + 4), 0);
  v3 = *(_DWORD *)(dword_F6ED0 + 10 * (a1 + 1) + 4) - *(_DWORD *)(dword_F6ED0 + v2 + 4);
  if ( sub_988A7(dword_DB73C, (int)a2, v3) != v3 )
    return -1;
  result = sub_9894C((int)a2, a2);
  if ( result >= 0 )
  {
    if ( !result )
      return v3;
  }
  else
  {
    printf(aErrorDecompres_1);
    return -2;
  }
  return result;
}
// DB73C: using guessed type int dword_DB73C;
// F6ED0: using guessed type int dword_F6ED0;

//----- (00070D20) --------------------------------------------------------
char __cdecl sub_70D20(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  __int16 v2; // di
  unsigned __int16 i; // bx
  _BYTE **v4; // ecx
  _DWORD *v5; // eax

  v1 = *(_WORD *)(10 * a1 + dword_F6ED0 + 8);
  if ( byte_F5340[v1] )
    return 0;
  v2 = *(_WORD *)(10 * a1 + dword_F6ED0 + 8);
  if ( !dword_F66F0[v1] )
    return 0;
  for ( i = *(_WORD *)(10 * a1 + dword_F6ED0 + 8); i < 0x1F8u && v2 == *(_WORD *)(dword_F6ED0 + 10 * i + 8); ++i )
  {
    v4 = (_BYTE **)dword_F66F0[i];
    if ( v4 )
    {
      if ( (**v4 & 1) != 0 )
      {
        v5 = (_DWORD *)sub_724F0(dword_E9C08, i);
        sub_72410(v5);
      }
      sub_71F20(dword_E9C28, dword_F5F10[i]);
      dword_F66F0[i] = 0;
      dword_F5F10[i] = 0;
      dword_F5730[i] = 0;
    }
  }
  return 1;
}
// E9C08: using guessed type int dword_E9C08;
// E9C28: using guessed type int dword_E9C28;
// F5730: using guessed type int dword_F5730[504];
// F5F10: using guessed type int dword_F5F10[504];
// F66F0: using guessed type int dword_F66F0[504];
// F6ED0: using guessed type int dword_F6ED0;

//----- (00070E10) --------------------------------------------------------
char __cdecl sub_70E10(unsigned __int16 a1)
{
  unsigned __int16 v1; // di
  unsigned __int16 i; // bx
  _BYTE **v3; // ecx
  _DWORD *v4; // eax

  v1 = *(_WORD *)(10 * a1 + dword_F6ED0 + 8);
  if ( !dword_F66F0[v1] )
    return 0;
  for ( i = *(_WORD *)(10 * a1 + dword_F6ED0 + 8); i < 0x1F8u && v1 == *(_WORD *)(dword_F6ED0 + 10 * i + 8); ++i )
  {
    v3 = (_BYTE **)dword_F66F0[i];
    if ( v3 )
    {
      if ( (**v3 & 1) != 0 )
      {
        v4 = (_DWORD *)sub_724F0(dword_E9C08, i);
        sub_72410(v4);
      }
      sub_71F20(dword_E9C28, dword_F5F10[i]);
      dword_F66F0[i] = 0;
      dword_F5F10[i] = 0;
      dword_F5730[i] = 0;
    }
  }
  return 1;
}
// E9C08: using guessed type int dword_E9C08;
// E9C28: using guessed type int dword_E9C28;
// F5730: using guessed type int dword_F5730[504];
// F5F10: using guessed type int dword_F5F10[504];
// F66F0: using guessed type int dword_F66F0[504];
// F6ED0: using guessed type int dword_F6ED0;

//----- (00070EF0) --------------------------------------------------------
int __cdecl sub_70EF0(unsigned __int16 a1)
{
  unsigned __int16 v1; // dx
  int i; // ebx
  int v3; // ecx

  v1 = *(_WORD *)(10 * a1 + dword_F6ED0 + 8);
  for ( i = 0; v1 < 0x1F8u; i += *(_DWORD *)(v3 + dword_F6ED0) + 10 )
  {
    v3 = 10 * v1;
    if ( *(_WORD *)(10 * a1 + dword_F6ED0 + 8) != *(_WORD *)(v3 + dword_F6ED0 + 8) )
      break;
    ++v1;
  }
  return i;
}
// F6ED0: using guessed type int dword_F6ED0;

//----- (00070F50) --------------------------------------------------------
int __cdecl sub_70F50(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int16 v2; // bx
  unsigned __int16 i; // si
  int v4; // edi
  int v5; // [esp+0h] [ebp-Ch]

  v5 = *(_DWORD *)(dword_D41A4 + 26);
  result = dword_F6ED0;
  v2 = *(_WORD *)(10 * a1 + dword_F6ED0 + 8);
  for ( i = v2; i < 0x1F8u; ++i )
  {
    result = 10 * i + dword_F6ED0;
    if ( v2 != *(_WORD *)(result + 8) )
      break;
    if ( !dword_F66F0[i] )
    {
      result = sub_71E70(dword_E9C28, (unsigned __int16)(4 * ((unsigned int)(*(_DWORD *)result + 13) >> 2)), i);
      v4 = result;
      if ( result )
      {
        result = sub_70C60(i, *(char **)result);
        if ( result != -1 )
        {
          dword_F5F10[i] = v4;
          dword_F66F0[i] = v4;
          dword_F5730[i] = v5;
          result = dword_F66F0[i];
          if ( (**(_BYTE **)result & 1) != 0 )
            result = sub_721C0((unsigned __int16 *)dword_E9C08, (int *)result, i);
          if ( v2 < 0x1E0u )
          {
            if ( v2 != 311 )
              continue;
LABEL_14:
            result = *(_DWORD *)dword_F66F0[i];
            *(_BYTE *)result |= 0x20u;
            continue;
          }
          if ( v2 <= 0x1E0u || v2 >= 0x1E8u && (v2 <= 0x1E8u || v2 == 496) )
            goto LABEL_14;
        }
      }
    }
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// E9C08: using guessed type int dword_E9C08;
// E9C28: using guessed type int dword_E9C28;
// F5730: using guessed type int dword_F5730[504];
// F5F10: using guessed type int dword_F5F10[504];
// F66F0: using guessed type int dword_F66F0[504];
// F6ED0: using guessed type int dword_F6ED0;

//----- (00071090) --------------------------------------------------------
unsigned int __cdecl sub_71090(unsigned int a1)
{
  int v1; // eax
  unsigned __int16 v2; // dx
  int v3; // eax
  int v4; // ebx
  int v5; // ebx
  int v6; // ecx
  unsigned int v7; // eax
  int v8; // edx
  int v9; // esi
  int v10; // esi
  int v11; // edi
  int v12; // edi
  int v13; // esi
  int v14; // esi
  int v15; // edi
  unsigned __int16 v16; // di
  unsigned int v17; // ebx
  char v18; // al
  int v20; // [esp+0h] [ebp-2Ch]
  int v21; // [esp+4h] [ebp-28h]
  int v22; // [esp+8h] [ebp-24h]
  int v23; // [esp+Ch] [ebp-20h]
  int v24; // [esp+10h] [ebp-1Ch]
  unsigned int v25; // [esp+14h] [ebp-18h]
  unsigned int v26; // [esp+18h] [ebp-14h]
  unsigned int v27; // [esp+1Ch] [ebp-10h]
  unsigned int v28; // [esp+20h] [ebp-Ch]
  unsigned int v29; // [esp+24h] [ebp-8h]
  char v30; // [esp+28h] [ebp-4h]

  v30 = 1;
  v1 = 0;
  do
  {
    v2 = v1++;
    *(&v25 + v2) = -1;
    *(&v20 + v2) = -1;
  }
  while ( (unsigned __int16)v1 < 5u );
  v3 = 0;
  do
  {
    v4 = *(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)v3 + 8);
    if ( dword_F66F0[v4] && !byte_F5340[v4] )
      v30 = 0;
    while ( (unsigned __int16)v3 < 0x1F8u
         && *(unsigned __int16 *)(10 * ((unsigned __int16)v3 + 1) + dword_F6ED0 + 8) == v4 )
      ++v3;
    ++v3;
  }
  while ( (unsigned __int16)v3 < 0x1F8u );
  v5 = 0;
  do
  {
    v6 = *(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)v5 + 8);
    if ( (!byte_F5340[v6] || v30) && dword_F66F0[v6] )
    {
      v7 = dword_F5730[v6];
      v8 = *(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)v5 + 8);
      if ( v7 < v25 )
      {
        v9 = v7 ^ v25;
        v7 = v25;
        v25 ^= v9;
        v8 = v20;
        v20 = v6;
      }
      if ( v7 < v26 )
      {
        v10 = v7 ^ v26;
        v11 = v8 ^ v21;
        v7 = v26;
        v8 = v21;
        v26 ^= v10;
        v21 ^= v11;
      }
      if ( v7 < v27 )
      {
        v12 = v7 ^ v27;
        v13 = v8 ^ v22;
        v7 = v27;
        v8 = v22;
        v27 ^= v12;
        v22 ^= v13;
      }
      if ( v7 < v28 )
      {
        v14 = v7 ^ v28;
        v15 = v8 ^ v23;
        v7 = v28;
        v8 = v23;
        v28 ^= v14;
        v23 ^= v15;
      }
      if ( v7 < v29 )
      {
        v29 = v7;
        v24 = v8;
      }
    }
    while ( (unsigned __int16)v5 < 0x1F8u
         && *(unsigned __int16 *)(10 * ((unsigned __int16)v5 + 1) + dword_F6ED0 + 8) == v6 )
      ++v5;
    ++v5;
  }
  while ( (unsigned __int16)v5 < 0x1F8u );
  v16 = 0;
  v17 = 0;
  while ( v16 < 5u && v17 < a1 && *(&v20 + v16) > -1 )
  {
    if ( v30 )
      v18 = sub_70E10(*((_WORD *)&v20 + 2 * v16));
    else
      v18 = sub_70D20(*((_WORD *)&v20 + 2 * v16));
    if ( v18 )
      v17 += sub_70EF0(*((_WORD *)&v20 + 2 * v16));
    ++v16;
  }
  return v17;
}
// F5730: using guessed type int dword_F5730[504];
// F66F0: using guessed type int dword_F66F0[504];
// F6ED0: using guessed type int dword_F6ED0;

//----- (000712F0) --------------------------------------------------------
__int16 sub_712F0()
{
  dword_E9C28 = sub_71B40(*(_DWORD *)(dword_D41A4 + 230), 0x1F8u, *(_DWORD *)(dword_D41A4 + 226));
  if ( dword_E9C28 )
    dword_E9C08 = sub_72120(0x1F8u);
  sub_70A60();
  sub_71A70(*(_BYTE *)(dword_D41A0 + 196308));
  memset(dword_F66F0, 0, sizeof(dword_F66F0));
  memset(dword_F5F10, 0, sizeof(dword_F5F10));
  memset(dword_F5730, 0, sizeof(dword_F5730));
  sub_71890();
  return sub_718F0();
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E9C08: using guessed type int dword_E9C08;
// E9C28: using guessed type int dword_E9C28;
// F5730: using guessed type int dword_F5730[504];
// F5F10: using guessed type int dword_F5F10[504];
// F66F0: using guessed type int dword_F66F0[504];

//----- (000713A0) --------------------------------------------------------
int sub_713A0()
{
  sub_720C0(&dword_E9C28);
  sub_72550(&dword_E9C08);
  sub_716A0();
  memset(dword_F66F0, 0, sizeof(dword_F66F0));
  memset(dword_F5F10, 0, sizeof(dword_F5F10));
  memset(dword_F5730, 0, sizeof(dword_F5730));
  byte_DB738 = 0;
  return sub_70BF0();
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// DB738: using guessed type char byte_DB738;
// E9C08: using guessed type int dword_E9C08;
// E9C28: using guessed type int dword_E9C28;
// F5730: using guessed type int dword_F5730[504];
// F5F10: using guessed type int dword_F5F10[504];
// F66F0: using guessed type int dword_F66F0[504];

//----- (00071410) --------------------------------------------------------
int sub_71410()
{
  unsigned __int16 *v0; // esi
  int v1; // ebx
  unsigned __int16 v2; // di

  sub_70A60();
  v0 = (unsigned __int16 *)word_D951C;
  v1 = dword_180628;
  while ( v0[3] || v0[4] )
  {
    v2 = *v0;
    memset(v1, 0, *(_DWORD *)(dword_F6ED0 + 10 * (*v0 + 1) + 4) - *(_DWORD *)(10 * *v0 + dword_F6ED0 + 4));
    if ( sub_70C60(v2, (char *)v1) == -1 )
    {
      *(_WORD *)(v1 + 2) = 255;
      *(_WORD *)(v1 + 4) = 255;
      *(_BYTE *)(v1 + 1) = 1;
    }
    if ( !*(_WORD *)(v1 + 4) || !*(_WORD *)(v1 + 2) )
    {
      *(_WORD *)(v1 + 2) = 255;
      *(_WORD *)(v1 + 4) = 255;
      *(_BYTE *)(v1 + 1) = 1;
    }
    if ( v0[3] )
    {
      if ( !v0[4] )
        v0[4] = *(unsigned __int16 *)(v1 + 4) * v0[3] / *(unsigned __int16 *)(v1 + 2);
    }
    else
    {
      v0[3] = *(unsigned __int16 *)(v1 + 2) * v0[4] / *(unsigned __int16 *)(v1 + 4);
    }
    v0 += 7;
    *((_BYTE *)v0 - 2) = *(_BYTE *)(v1 + 1);
  }
  return sub_70BF0();
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D951C: using guessed type __int16 word_D951C[];
// F6ED0: using guessed type int dword_F6ED0;
// 180628: using guessed type int dword_180628;

//----- (00071520) --------------------------------------------------------
bool __cdecl sub_71520(unsigned __int16 a1)
{
  int v1; // eax
  int v2; // esi
  signed int i; // ebx
  unsigned __int16 v4; // ax

  v1 = sub_70EF0(a1);
  v2 = 0;
  for ( i = v1 - sub_71E60(dword_E9C28) + 20; i > 0; i -= sub_71090(i) )
  {
    v4 = v2++;
    if ( v4 >= 4u )
      break;
  }
  if ( i <= 0 )
  {
    sub_70F50(a1);
    *(_BYTE *)(dword_D41A4 + 177) = 5;
  }
  return dword_F66F0[a1] != 0;
}
// D41A4: using guessed type int dword_D41A4;
// E9C28: using guessed type int dword_E9C28;
// F66F0: using guessed type int dword_F66F0[504];

//----- (000715B0) --------------------------------------------------------
int sub_715B0()
{
  unsigned __int16 i; // bx
  int result; // eax
  int *v2; // ecx
  char v3; // cl
  char v4; // cl
  int v5; // eax
  unsigned __int16 v6; // si
  unsigned __int16 j; // bx
  int *v8; // edi
  char v9; // cl
  int v10; // eax

  for ( i = 0; i < 0x1F8u; ++i )
  {
    result = 4 * i;
    v2 = *(int **)((char *)dword_F66F0 + result);
    if ( v2 )
    {
      result = *v2;
      v3 = *(_BYTE *)*v2;
      if ( (v3 & 8) != 0 )
      {
        if ( (v3 & 0x20) != 0 )
        {
          result = 5 * i;
          v6 = *(_WORD *)(dword_F6ED0 + 10 * i + 8);
          for ( j = v6; j < 0x1F8u; ++j )
          {
            result = 5 * j;
            if ( v6 != *(_WORD *)(dword_F6ED0 + 10 * j + 8) )
              break;
            result = 4 * j;
            v8 = *(int **)((char *)dword_F66F0 + result);
            if ( v8 )
            {
              result = *v8;
              v9 = *(_BYTE *)*v8 & 0xF7;
              *(_BYTE *)*v8 = v9;
              if ( (v9 & 1) != 0 )
              {
                v10 = sub_724F0(dword_E9C08, j);
                result = sub_72350(v10);
              }
            }
          }
          i = j - 1;
        }
        else
        {
          v4 = v3 & 0xF7;
          *(_BYTE *)result = v4;
          if ( (v4 & 1) != 0 )
          {
            v5 = sub_724F0(dword_E9C08, i);
            result = sub_72350(v5);
          }
        }
      }
    }
  }
  return result;
}
// E9C08: using guessed type int dword_E9C08;
// F66F0: using guessed type int dword_F66F0[504];
// F6ED0: using guessed type int dword_F6ED0;

//----- (000716A0) --------------------------------------------------------
int sub_716A0()
{
  return memset(&byte_F5538, 0, 504);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// F5538: using guessed type char byte_F5538;

//----- (000716C0) --------------------------------------------------------
__int16 *__cdecl sub_716C0(unsigned __int16 a1, unsigned __int16 a2, signed __int16 a3)
{
  __int16 *result; // eax
  unsigned __int16 *v4; // ebx
  unsigned __int16 v5; // cx

  result = (__int16 *)&unk_D7BD6;
  v4 = 0;
  while ( *result >= 0 )
  {
    if ( *result == a1 && result[1] == a2 )
      v4 = (unsigned __int16 *)(result + 2);
    result += 17;
  }
  if ( v4 )
  {
    while ( 1 )
    {
      v5 = *v4;
      if ( (*v4 & 0x8000u) != 0 )
        break;
      ++v4;
      result = (__int16 *)sub_71730(v5);
    }
  }
  else if ( a3 >= 0 )
  {
    return (__int16 *)sub_71730(a3);
  }
  return result;
}

//----- (00071730) --------------------------------------------------------
int __cdecl sub_71730(unsigned __int16 a1)
{
  __int16 *v1; // eax
  char v2; // bl
  int result; // eax

  v1 = &word_D951C[7 * a1];
  v2 = *((_BYTE *)v1 + 11);
  result = *(unsigned __int16 *)(dword_F6ED0 + 10 * (unsigned __int16)*v1 + 8);
  byte_F5538[result] = v2;
  return result;
}
// D951C: using guessed type __int16 word_D951C[];
// F6ED0: using guessed type int dword_F6ED0;

//----- (00071780) --------------------------------------------------------
char sub_71780()
{
  unsigned __int16 v0; // bx
  unsigned int v1; // eax
  char i; // bl
  unsigned __int16 j; // si
  unsigned int v4; // edx
  char v6; // [esp+4h] [ebp-4h]

  v6 = 0;
  if ( !dword_E9C28 )
    sub_712F0();
  sub_71A70(*(_BYTE *)(dword_D41A0 + 196308));
  v0 = 0;
  memset(dword_F5730, 0, sizeof(dword_F5730));
  do
  {
    LOBYTE(v1) = v0;
    if ( !byte_F5538[v0] )
      LOBYTE(v1) = sub_70D20(v0);
    ++v0;
  }
  while ( v0 < 0x1F8u );
  for ( i = -1; i && !v6; --i )
  {
    for ( j = 0; j < 0x1F8u && !v6; ++j )
    {
      if ( i == byte_F5538[j] && !dword_F66F0[j] )
      {
        v4 = sub_70EF0(j);
        if ( sub_71E60(dword_E9C28) <= v4 )
        {
          v1 = sub_71E60(dword_E9C28);
          if ( v1 < 0x400 )
            v6 = 1;
        }
        else
        {
          LOBYTE(v1) = sub_70F50(j);
        }
      }
    }
  }
  return v1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// E9C28: using guessed type int dword_E9C28;
// F5730: using guessed type int dword_F5730[504];
// F66F0: using guessed type int dword_F66F0[504];

//----- (00071890) --------------------------------------------------------
char sub_71890()
{
  __int16 *v0; // ebx
  char result; // al

  v0 = word_D951C;
  result = memset(byte_F5340, 0, sizeof(byte_F5340));
  if ( byte_DB74C )
  {
    while ( v0[3] || v0[4] )
    {
      if ( *((_BYTE *)v0 + 11) == 0xFF )
      {
        result = *((_BYTE *)v0 + 11);
        byte_F5340[(unsigned __int16)*v0] = result;
      }
      v0 += 7;
    }
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D951C: using guessed type __int16 word_D951C[];
// DB74C: using guessed type char byte_DB74C;

//----- (000718F0) --------------------------------------------------------
__int16 sub_718F0()
{
  unsigned __int16 i; // bx
  __int16 result; // ax

  for ( i = 0; i < 0x1F8u; ++i )
  {
    result = i;
    if ( byte_F5340[i] )
      result = sub_70F50(i);
  }
  return result;
}

//----- (00071930) --------------------------------------------------------
int sub_71930()
{
  int result; // eax
  int v1; // ebx

  memset(dword_D41A0 + 57, 0, 508);
  result = 0;
  do
  {
    if ( dword_F66F0[(unsigned __int16)result] )
    {
      v1 = (unsigned __int16)result + dword_D41A0;
      *(_BYTE *)(v1 + 57) = 1;
      if ( byte_F5340[(unsigned __int16)result] )
        ++*(_BYTE *)(v1 + 57);
    }
    ++result;
  }
  while ( (unsigned __int16)result < 0x1F8u );
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// F66F0: using guessed type int dword_F66F0[504];

//----- (00071990) --------------------------------------------------------
char sub_71990()
{
  unsigned __int16 i; // bx
  unsigned int v1; // eax
  char j; // bl
  unsigned __int16 k; // si
  unsigned int v4; // edx
  char v6; // [esp+4h] [ebp-4h]

  v6 = 0;
  if ( !dword_E9C28 )
    sub_712F0();
  for ( i = 0; i < 0x1F8u; ++i )
  {
    LOBYTE(v1) = i;
    if ( !*(_BYTE *)(dword_D41A0 + i + 57) )
      LOBYTE(v1) = sub_70D20(i);
  }
  for ( j = 2; j && !v6; --j )
  {
    for ( k = 0; k < 0x1F8u && !v6; ++k )
    {
      LOBYTE(v1) = dword_D41A0;
      if ( j == *(_BYTE *)(k + dword_D41A0 + 57) && !dword_F66F0[k] )
      {
        v4 = sub_70EF0(k);
        if ( sub_71E60(dword_E9C28) <= v4 )
        {
          v1 = sub_71E60(dword_E9C28);
          if ( v1 < 0x400 )
            v6 = 1;
        }
        else
        {
          LOBYTE(v1) = sub_70F50(k);
        }
      }
    }
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// E9C28: using guessed type int dword_E9C28;
// F66F0: using guessed type int dword_F66F0[504];

//----- (00071A70) --------------------------------------------------------
unsigned __int8 __cdecl sub_71A70(unsigned __int8 a1)
{
  int v1; // edx
  unsigned __int8 result; // al

  v1 = dword_DB73C;
  result = a1;
  if ( a1 )
  {
    if ( a1 <= 1u )
    {
      v1 = dword_DB744;
    }
    else if ( a1 == 2 )
    {
      v1 = dword_DB748;
    }
  }
  else
  {
    v1 = dword_DB740;
  }
  dword_DB73C = v1;
  return result;
}
// DB73C: using guessed type int dword_DB73C;
// DB740: using guessed type int dword_DB740;
// DB744: using guessed type int dword_DB744;
// DB748: using guessed type int dword_DB748;

//----- (00071AB0) --------------------------------------------------------
__int16 __cdecl sub_71AB0(__int16 a1, char a2)
{
  _BYTE *v2; // eax
  __int16 v3; // si
  __int16 i; // bx
  _DWORD *v5; // ecx
  int v6; // eax

  LOWORD(v2) = 5 * a1;
  v3 = *(_WORD *)(dword_F6ED0 + 10 * a1 + 8);
  for ( i = v3; i < 504; ++i )
  {
    LOWORD(v2) = v3;
    if ( *(unsigned __int16 *)(10 * i + dword_F6ED0 + 8) != v3 )
      break;
    v5 = (_DWORD *)dword_F66F0[i];
    if ( v5 )
    {
      v2 = (_BYTE *)*v5;
      if ( (*(_BYTE *)*v5 & 1) != 0 )
      {
        v6 = sub_724F0(dword_E9C08, i);
        LOWORD(v2) = sub_723B0(v6, a2);
      }
    }
  }
  return (__int16)v2;
}
// E9C08: using guessed type int dword_E9C08;
// F66F0: using guessed type int dword_F66F0[504];
// F6ED0: using guessed type int dword_F6ED0;

//----- (00071B40) --------------------------------------------------------
int __cdecl sub_71B40(int a1, unsigned __int16 a2, int a3)
{
  unsigned __int16 v3; // di
  int v4; // eax
  int v5; // edx
  int v6; // esi
  int v7; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // [esp+0h] [ebp-Ch]

  v3 = a2;
  if ( a3 )
  {
    v13 = 14 * a2;
    v4 = 4 * a2 + v13 + 26;
    v5 = a1 - v4;
    if ( a1 == v4 )
      return 0;
    *(_WORD *)(a3 + 20) = 0;
    *(_WORD *)(a3 + 24) = 2;
    *(_DWORD *)a3 = v5;
    *(_DWORD *)(a3 + 4) = v5;
    v6 = a3;
    *(_WORD *)(a3 + 22) = a2;
    *(_DWORD *)(a3 + 8) = a3 + 26;
    v7 = v13 + a3 + 26;
    *(_DWORD *)(a3 + 12) = v7;
    *(_DWORD *)(a3 + 16) = 4 * a2 + v7;
    while ( --v3 != 0xFFFF )
      *(_DWORD *)(*(_DWORD *)(a3 + 8) + 14 * v3 + 4) = 0;
  }
  else
  {
    v9 = sub_83CD0(26);
    v6 = v9;
    if ( !v9
      || (v10 = sub_83CD0(a1), (*(_DWORD *)(v9 + 16) = v10) == 0)
      || (v11 = sub_83CD0(14 * a2), (*(_DWORD *)(v9 + 8) = v11) == 0)
      || (v12 = sub_83CD0(4 * a2), (*(_DWORD *)(v9 + 12) = v12) == 0) )
    {
      if ( v9 )
      {
        if ( *(_DWORD *)(v9 + 16) )
        {
          if ( *(_DWORD *)(v9 + 8) )
            sub_83E80(*(_DWORD *)(v9 + 8));
          sub_83E80(*(_DWORD *)(v9 + 16));
        }
        sub_83E80(v9);
      }
      exit(1);
    }
    *(_WORD *)(v9 + 20) = 0;
    *(_WORD *)(v9 + 24) = 1;
    *(_WORD *)(v9 + 22) = a2;
    *(_DWORD *)v9 = a1;
    *(_DWORD *)(v9 + 4) = a1;
    while ( --v3 != 0xFFFF )
      *(_DWORD *)(*(_DWORD *)(v9 + 8) + 14 * v3 + 4) = 0;
  }
  return v6;
}

//----- (00071CD0) --------------------------------------------------------
int __cdecl sub_71CD0(int a1)
{
  int i; // edx

  for ( i = 0; (__int16)i < (int)*(unsigned __int16 *)(a1 + 22); ++i )
  {
    if ( !*(_DWORD *)(14 * (__int16)i + *(_DWORD *)(a1 + 8) + 4) )
      return i;
  }
  return -1;
}

//----- (00071E60) --------------------------------------------------------
int __cdecl sub_71E60(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (00071E70) --------------------------------------------------------
int __cdecl sub_71E70(int a1, unsigned int a2, __int16 a3)
{
  __int16 v3; // si
  __int16 v4; // ax
  __int16 v5; // dx
  int v6; // ecx
  int v7; // eax

  v3 = -1;
  if ( a2 < *(_DWORD *)(a1 + 4) )
  {
    v4 = sub_71CD0(a1);
    v5 = v4;
    v6 = v4;
    v3 = v4;
    if ( v4 > -1 )
    {
      v7 = 14 * v4;
      *(_WORD *)(*(_DWORD *)(a1 + 8) + v7 + 10) = v5;
      *(_DWORD *)(*(_DWORD *)(a1 + 8) + v7 + 4) = a2;
      *(_DWORD *)(*(_DWORD *)(a1 + 8) + v7) = *(_DWORD *)a1 + *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 4);
      *(_WORD *)(*(_DWORD *)(a1 + 8) + v7 + 12) = a3;
      *(_DWORD *)(a1 + 4) -= a2;
      *(_WORD *)(*(_DWORD *)(a1 + 8) + v7 + 8) = *(_WORD *)(a1 + 20);
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * (unsigned __int16)(*(_WORD *)(a1 + 20))++) = *(_DWORD *)(a1 + 8) + 14 * v6;
    }
  }
  if ( v3 <= -1 )
    return 0;
  else
    return 14 * v3 + *(_DWORD *)(a1 + 8);
}

//----- (00071F20) --------------------------------------------------------
__int16 __cdecl sub_71F20(int a1, int a2)
{
  int v2; // eax
  int v3; // ecx
  unsigned __int16 v4; // bx
  int v5; // esi
  int v6; // ecx
  unsigned __int16 v7; // cx
  int v8; // eax
  const void *v9; // esi
  int v11; // [esp+0h] [ebp-8h]
  char *i; // [esp+4h] [ebp-4h]

  LOWORD(v2) = *(_WORD *)(a2 + 10);
  if ( (unsigned __int16)v2 < *(_WORD *)(a1 + 22) )
  {
    v2 = 14 * (unsigned __int16)v2;
    v3 = v2 + *(_DWORD *)(a1 + 8);
    if ( *(_DWORD *)(v3 + 4) )
    {
      v4 = *(_WORD *)(v3 + 8);
      v5 = *(_DWORD *)(v3 + 4) + *(_DWORD *)(a1 + 4);
      v6 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 4) = v5;
      *(_DWORD *)(v6 + v2 + 4) = 0;
      v2 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + v2);
      for ( i = (char *)v2; ; i += v2 )
      {
        ++v4;
        v7 = *(_WORD *)(a1 + 20);
        if ( v4 >= v7 )
          break;
        v11 = 4 * v4;
        *(_DWORD *)(v11 + *(_DWORD *)(a1 + 12) - 4) = *(_DWORD *)(v11 + *(_DWORD *)(a1 + 12));
        v8 = *(_DWORD *)(v11 + *(_DWORD *)(a1 + 12));
        *(_WORD *)(v8 + 8) = v4 - 1;
        v9 = *(const void **)v8;
        **(_DWORD **)(v11 + *(_DWORD *)(a1 + 12)) = i;
        qmemcpy(i, v9, *(_DWORD *)(*(_DWORD *)(v11 + *(_DWORD *)(a1 + 12)) + 4));
        v2 = *(_DWORD *)(*(_DWORD *)(v11 + *(_DWORD *)(a1 + 12)) + 4);
      }
      *(_WORD *)(a1 + 20) = v7 - 1;
    }
  }
  return v2;
}

//----- (000720C0) --------------------------------------------------------
void __cdecl sub_720C0(int *a1)
{
  int v1; // edx

  v1 = *a1;
  if ( *a1 )
  {
    if ( *(_WORD *)(v1 + 24) == 1 )
    {
      sub_83E80(*(_DWORD *)(v1 + 16));
      sub_83E80(*(_DWORD *)(*a1 + 8));
      sub_83E80(*(_DWORD *)(*a1 + 12));
      sub_83E80(*a1);
    }
    *a1 = 0;
  }
}

//----- (00072120) --------------------------------------------------------
int __cdecl sub_72120(unsigned __int16 a1)
{
  unsigned __int16 v1; // di
  int v2; // esi
  int v3; // ebx
  int v4; // eax
  int v5; // eax

  v1 = a1;
  sub_83CC0(9);
  v2 = sub_83CD0(6);
  v3 = v2;
  if ( v2 && (v4 = sub_83CD0(28 * a1), (*(_DWORD *)(v2 + 2) = v4) != 0) )
  {
    *(_WORD *)v2 = a1;
    while ( --v1 != 0xFFFF )
    {
      v5 = 7 * v1;
      *(_DWORD *)(*(_DWORD *)(v2 + 2) + 4 * v5 + 4) = 0;
      *(_DWORD *)(*(_DWORD *)(v2 + 2) + 4 * v5) = 0;
    }
  }
  else if ( v2 )
  {
    sub_83E80(v2);
    v3 = 0;
  }
  sub_83CC0(10);
  return v3;
}

//----- (000721C0) --------------------------------------------------------
int __cdecl sub_721C0(unsigned __int16 *a1, int *a2, __int16 a3)
{
  __int16 v3; // cx
  __int16 v4; // si
  __int16 i; // bx
  _DWORD *v6; // edx
  int v7; // ebx
  int v8; // ecx
  int v9; // edx
  __int16 v11; // [esp+8h] [ebp-8h]
  __int16 v12; // [esp+Ch] [ebp-4h]

  v3 = -1;
  v4 = -1;
  if ( !*a1 )
    return 0;
  for ( i = 0; i < (int)*a1; ++i )
  {
    v6 = (_DWORD *)(28 * i + *(_DWORD *)(a1 + 1));
    if ( v6[1] )
    {
      if ( !*v6 )
        v4 = i;
    }
    else
    {
      v3 = i;
    }
  }
  v12 = v3 <= 0 ? v4 : v3;
  if ( v12 <= -1 )
    return 0;
  v7 = *a2;
  v8 = *(unsigned __int16 *)(*a2 + 4) * *(unsigned __int16 *)(*a2 + 2);
  v11 = *(_WORD *)(v8 + *a2 + 6);
  v9 = 28 * v12;
  *(_DWORD *)(v9 + *(_DWORD *)(a1 + 1) + 4) = a2;
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 12) = 6;
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 14) = v8 + 6;
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 16) = v11;
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 18) = *(_WORD *)(v7 + 2);
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 20) = *(_WORD *)(v7 + 4);
  *(_DWORD *)(v9 + *(_DWORD *)(a1 + 1) + 8) = v8 + 6;
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 22) = 1;
  *(_DWORD *)(v9 + *(_DWORD *)(a1 + 1)) = 1;
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 24) = v12;
  *(_WORD *)(v9 + *(_DWORD *)(a1 + 1) + 26) = a3;
  return v9 + *(_DWORD *)(a1 + 1);
}

//----- (00072350) --------------------------------------------------------
int __cdecl sub_72350(int a1)
{
  int v1; // esi
  int v2; // edi
  int v3; // eax
  __int16 v4; // cx
  int result; // eax

  if ( *(_WORD *)(a1 + 22) > *(_WORD *)(a1 + 16) )
  {
    *(_WORD *)(a1 + 22) = 1;
    *(_DWORD *)(a1 + 8) = *(unsigned __int16 *)(a1 + 14);
  }
  v1 = **(_DWORD **)(a1 + 4);
  v2 = *(_DWORD *)(a1 + 8);
  sub_765FC(*(_WORD *)(a1 + 18), 0);
  v1 += 6;
  v3 = sub_76619(v1 + v2, v1);
  v4 = *(_WORD *)(a1 + 22);
  result = v3 - v1;
  *(_DWORD *)(a1 + 8) = result;
  *(_WORD *)(a1 + 22) = v4 + 1;
  return result;
}

//----- (000723B0) --------------------------------------------------------
unsigned __int16 __cdecl sub_723B0(int a1, char a2)
{
  unsigned __int16 result; // ax

  if ( a2 )
  {
    while ( 1 )
    {
      result = *(_WORD *)(a1 + 22);
      if ( result > *(_WORD *)(a1 + 16) )
        break;
      sub_72350(a1);
    }
  }
  else
  {
    memset(**(_DWORD **)(a1 + 4) + 6, 0, *(unsigned __int16 *)(a1 + 18) * *(unsigned __int16 *)(a1 + 20));
    *(_WORD *)(a1 + 22) = 1;
    result = *(_WORD *)(a1 + 14);
    *(_DWORD *)(a1 + 8) = result;
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);

//----- (00072410) --------------------------------------------------------
_DWORD *__cdecl sub_72410(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  if ( a1 )
  {
    *a1 = 0;
    a1[1] = 0;
  }
  return result;
}

//----- (000724F0) --------------------------------------------------------
int __cdecl sub_724F0(int a1, __int16 a2)
{
  int result; // eax
  int v3; // edx

  HIWORD(v3) = HIWORD(a1);
  result = *(_DWORD *)(a1 + 2);
  LOWORD(v3) = *(_WORD *)a1;
  if ( !*(_WORD *)a1 )
    return 0;
  while ( !*(_DWORD *)(result + 4) || a2 != *(_WORD *)(result + 26) )
  {
    --v3;
    result += 28;
    if ( !(_WORD)v3 )
      return 0;
  }
  return result;
}

//----- (00072550) --------------------------------------------------------
void __cdecl sub_72550(int *a1)
{
  if ( *a1 )
  {
    sub_83E80(*(_DWORD *)(*a1 + 2));
    *(_DWORD *)(*a1 + 2) = 0;
    sub_83E80(*a1);
    *a1 = 0;
  }
}

//----- (00072633) --------------------------------------------------------
__int16 __cdecl __spoils<> sub_72633(__int16 a1, __int16 a2)
{
  int v2; // ebx
  int v4; // ebx
  int v5; // eax
  int v6; // ebx

  if ( a1 )
  {
    v2 = a2;
  }
  else
  {
    v2 = a2;
    if ( !a2 )
      return 0;
  }
  if ( a1 < 0 )
  {
    v5 = -a1;
    if ( v2 < 0 )
    {
      v6 = -v2;
      if ( v5 < v6 )
        return 2048 - word_DE350[-256 * a1 / (unsigned int)v6];
      else
        return word_DE350[(v6 << 8) / (unsigned int)v5] + 1536;
    }
    else if ( v5 < v2 )
    {
      return word_DE350[-256 * a1 / (unsigned int)v2] + 1024;
    }
    else
    {
      return 1536 - word_DE350[(v2 << 8) / (unsigned int)v5];
    }
  }
  else if ( v2 < 0 )
  {
    v4 = -v2;
    if ( a1 < v4 )
      return word_DE350[(a1 << 8) / (unsigned int)v4];
    else
      return 512 - word_DE350[(v4 << 8) / (unsigned int)a1];
  }
  else if ( a1 < v2 )
  {
    return 1024 - word_DE350[(a1 << 8) / (unsigned int)v2];
  }
  else
  {
    return word_DE350[(v2 << 8) / (unsigned int)a1] + 512;
  }
}
// DE350: using guessed type __int16 word_DE350[258];

//----- (0007277A) --------------------------------------------------------
unsigned int __cdecl sub_7277A(unsigned int a1)
{
  unsigned int v1; // eax
  unsigned int i; // ebx

  if ( !a1 )
    return 0;
  _BitScanReverse(&v1, a1);
  for ( i = (unsigned __int16)word_727B0[v1]; (int)(a1 / i) < (int)i; i = (a1 / i + i) >> 1 )
    ;
  return i;
}
// 727B0: using guessed type __int16 word_727B0[];

//----- (000727F0) --------------------------------------------------------
void __cdecl __spoils<> sub_727F0(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  __outbyte(0x3C8u, a1);
  __outbyte(0x3C9u, a2);
  __outbyte(0x3C9u, a3);
  __outbyte(0x3C9u, a4);
}

//----- (00072883) --------------------------------------------------------
int __usercall sub_72883@<eax>(int a1@<eax>, void *a2, unsigned __int16 a3, char a4)
{
  int v4; // eax
  int v6; // [esp-8h] [ebp-Ch]

  v6 = a1;
  LOBYTE(a1) = a4;
  BYTE1(a1) = a4;
  v4 = a1 << 16;
  LOBYTE(v4) = a4;
  BYTE1(v4) = a4;
  memset32(a2, v4, 80 * a3);
  return v6;
}

//----- (000728A9) --------------------------------------------------------
int __usercall sub_728A9@<eax>(int a1@<eax>, void *a2, unsigned __int16 a3, char a4)
{
  int v4; // eax
  int v6; // [esp-8h] [ebp-Ch]

  v6 = a1;
  LOBYTE(a1) = a4;
  BYTE1(a1) = a4;
  v4 = a1 << 16;
  LOBYTE(v4) = a4;
  BYTE1(v4) = a4;
  memset32(a2, v4, 160 * a3);
  return v6;
}

//----- (00072C40) --------------------------------------------------------
int __cdecl sub_72C40(__int16 a1, __int16 a2, int a3, unsigned __int8 a4)
{
  __int16 v4; // dx
  char *v5; // esi
  int v7; // [esp+4h] [ebp-4h]

  v4 = *(_WORD *)(a3 + 4);
  v5 = *(char **)a3;
  if ( (word_180660 & 1) != 0 )
  {
    sub_8F920(v4, a2, a1, v5, a4, 0);
    return v7;
  }
  else
  {
    if ( (word_180660 & 8) != 0 )
      sub_8F935(v4, a2, a1, v5, a4, 0);
    return v7;
  }
}
// 72C82: variable 'v7' is possibly undefined
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (00072CB0) --------------------------------------------------------
int __cdecl sub_72CB0(unsigned __int8 *a1, int a2)
{
  int v3; // [esp+4h] [ebp-Ch]

  v3 = 0;
  while ( a2 )
  {
    --a2;
    v3 += *a1++;
  }
  return v3;
}

//----- (00072D04) --------------------------------------------------------
void sub_72D04()
{
  int i; // [esp+0h] [ebp-8h]
  int j; // [esp+4h] [ebp-4h]

  if ( byte_E1274 )
  {
    for ( i = 0; word_E127A > i; ++i )
    {
      while ( *(_BYTE *)(dword_E12AE[i] + 49) == 0xFF )
        ;
    }
    while ( *(_BYTE *)(dword_E12AA + 49) == 0xFF )
      ;
    sub_83E80(dword_E12AA);
    for ( j = 0; j < 8; ++j )
    {
      sub_83E80(dword_E12AE[j]);
      sub_83E80(dword_E1286[j]);
    }
    sub_83E80(dword_E127E);
    sub_83E80(dword_E1282);
    byte_E1274 = 0;
  }
}
// E1274: using guessed type char byte_E1274;
// E127A: using guessed type __int16 word_E127A;
// E127E: using guessed type int dword_E127E;
// E1282: using guessed type int dword_E1282;
// E1286: using guessed type int dword_E1286[8];
// E12AA: using guessed type int dword_E12AA;
// E12AE: using guessed type int dword_E12AE[8];

//----- (00072DDE) --------------------------------------------------------
int __usercall sub_72DDE@<eax>(int a1@<edx>, __int16 *a2@<ebx>, int a3)
{
  char v4[20]; // [esp+0h] [ebp-1Ch] BYREF
  int v5; // [esp+14h] [ebp-8h]

  sprintf(v4, "%s%d", aTester, a3);
  do
  {
    v5 = sub_74767(a1, a2, (_BYTE *)dword_E12AE[a3], (int)v4);
    if ( v5 && v5 == 13 )
      sub_74A86((_BYTE *)dword_E12AE[a3], (int)v4);
  }
  while ( v5 == 13 && !word_E12A6 );
  return v5;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// E12A6: using guessed type __int16 word_E12A6;
// E12AE: using guessed type int dword_E12AE[8];

//----- (00072E70) --------------------------------------------------------
int __fastcall sub_72E70(int a1, int a2, __int16 *a3)
{
  int v3; // edx
  char v5; // [esp+0h] [ebp-30h]
  char v6[8]; // [esp+18h] [ebp-18h] BYREF
  int i; // [esp+28h] [ebp-8h]
  int v8; // [esp+2Ch] [ebp-4h]

  for ( i = 0; word_E127A > i; ++i )
  {
    if ( word_E1276 != i )
      sub_74809(i);
  }
  memset(v6, 0, sizeof(v6));
  v8 = 0;
  while ( v8 < 2 )
  {
    v3 = v6[word_E1276];
    if ( v3 == word_E127A - 1 || word_E12A6 )
      break;
    for ( i = 0; word_E127A > i; ++i )
    {
      if ( word_E1276 != i )
      {
        v5 = *(_BYTE *)(dword_E12AE[i] + 49);
        if ( v5 )
        {
          if ( v5 == -1 )
          {
            if ( v8 )
              sub_748F7(i);
          }
          else if ( !v6[i] )
          {
            ++v6[word_E1276];
            v6[i] = 1;
          }
        }
        else if ( ++v8 == 1 )
        {
          word_E12A8 = i;
        }
      }
    }
    sub_7C230(word_E127A, v3, a3);
  }
  return v8;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A6: using guessed type __int16 word_E12A6;
// E12A8: using guessed type __int16 word_E12A8;
// E12AE: using guessed type int dword_E12AE[8];
// 72E70: using guessed type char var_18[8];

//----- (00072FBB) --------------------------------------------------------
int __fastcall sub_72FBB(int a1, int a2, __int16 *a3)
{
  int i; // [esp+4h] [ebp-4h]

  sub_74809(0);
  for ( i = dword_17DB54; ; sub_7C230(dword_17DB54 - i, a2, a3) )
  {
    if ( *(_BYTE *)(dword_E12AE[0] + 49) != 0xFF )
      return 1;
    if ( (unsigned int)(dword_17DB54 - i) > 0x78 )
      break;
  }
  sub_748F7(0);
  return 0;
}
// E12AE: using guessed type int dword_E12AE[8];
// 17DB54: using guessed type int dword_17DB54;

//----- (0007302E) --------------------------------------------------------
int sub_7302E()
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; word_E127A > i && !word_E12A6; ++i )
  {
    if ( word_E1276 != i )
      sub_74B75(i);
  }
  return 1;
}
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A6: using guessed type __int16 word_E12A6;

//----- (0007308F) --------------------------------------------------------
int __usercall sub_7308F@<eax>(int a1@<edx>, __int16 *a2@<ebx>, int a3, __int16 a4)
{
  int v4; // eax
  int v6; // [esp+4h] [ebp-24h]
  char v7[20]; // [esp+8h] [ebp-20h] BYREF
  int i; // [esp+1Ch] [ebp-Ch]

  if ( !byte_E1274 || byte_E1275 )
    return -1;
  if ( a4 )
    word_E127A = a4;
  else
    word_E127A = 8;
  byte_E1275 = 0;
  word_E12A6 = 0;
  strcpy(aTester, a3);
  for ( i = 0; word_E127A > i; ++i )
    byte_E12CE[i] = 0;
  for ( i = 0; word_E127A > i; ++i )
  {
    while ( *(_BYTE *)(dword_E12AE[i] + 49) == 0xFF )
      ;
  }
  while ( *(_BYTE *)(dword_E12AA + 49) == 0xFF )
    ;
  i = 0;
  word_E1276 = -1;
  while ( word_E127A > i && word_E1276 == -1 && !word_E12A6 )
  {
    v6 = sub_72DDE(a1, a2, i);
    if ( v6 )
    {
      if ( v6 == 255 )
      {
        sub_748F7(i);
        i = word_E127A;
      }
    }
    else
    {
      word_E1276 = i;
    }
    ++i;
  }
  if ( word_E1276 == -1 )
    return -1;
  for ( i = 0; ; ++i )
  {
    v4 = word_E127A;
    if ( word_E127A <= i )
      break;
    if ( word_E1276 != i )
    {
      strcpy(dword_E12AE[i] + 26, dword_E12AE[word_E1276] + 26);
      a1 = dword_E12AE[word_E1276];
      LOBYTE(a1) = *(_BYTE *)(a1 + 3);
      *(_BYTE *)(dword_E12AE[i] + 3) = a1;
    }
  }
  LOWORD(v4) = word_E1276;
  if ( word_E1276 )
  {
    if ( !sub_72FBB(v4, a1, a2) )
      word_E12A6 = 1;
  }
  else
  {
    sub_7302E();
    word_E12A8 = word_E1276;
  }
  if ( word_E12A6 == 1 )
  {
    for ( i = 0; word_E127A > i; ++i )
    {
      if ( word_E1276 != i )
        sub_748F7(i);
    }
    sprintf(v7, "%s%d", aTester, word_E1276);
    sub_74A86((_BYTE *)dword_E12AE[word_E1276], (int)v7);
    return -1;
  }
  else
  {
    sub_74F76();
    byte_E1275 = 1;
    return word_E1276;
  }
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// E1274: using guessed type char byte_E1274;
// E1275: using guessed type char byte_E1275;
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A6: using guessed type __int16 word_E12A6;
// E12A8: using guessed type __int16 word_E12A8;
// E12AA: using guessed type int dword_E12AA;
// E12AE: using guessed type int dword_E12AE[8];

//----- (00073669) --------------------------------------------------------
int __cdecl sub_73669(__int16 a1)
{
  int result; // eax
  char v2[20]; // [esp+0h] [ebp-18h] BYREF
  int i; // [esp+14h] [ebp-4h]

  if ( word_E1276 == a1 )
  {
    for ( i = 0; (__int16)i < word_E127A; ++i )
    {
      if ( (_WORD)i != word_E1276 )
      {
        sub_748F7(i);
        sub_74B19((_BYTE *)dword_E12AE[(__int16)i]);
      }
    }
    sprintf(v2, "%s%d", aTester, word_E1276);
    result = sub_74A86((_BYTE *)dword_E12AE[a1], (int)v2);
    byte_E1275 = 0;
  }
  else
  {
    sub_748F7(a1);
    return sub_74B19((_BYTE *)dword_E12AE[a1]);
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// E1275: using guessed type char byte_E1275;
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12AE: using guessed type int dword_E12AE[8];

//----- (0007373D) --------------------------------------------------------
int __cdecl sub_7373D(__int16 a1)
{
  int result; // eax
  char v2[84]; // [esp+0h] [ebp-64h] BYREF
  char v3[8]; // [esp+54h] [ebp-10h] BYREF
  int i; // [esp+5Ch] [ebp-8h]

  if ( byte_E1274 && byte_E1275 )
  {
    if ( (unsigned __int16)word_E12A8 == a1 )
    {
      if ( word_E1276 == a1 )
      {
        for ( i = 0; word_E127A > i; ++i )
          v3[i] = byte_E12CE[i] == 1;
        for ( i = 0; word_E127A > i; ++i )
        {
          if ( v3[i] == 1 )
            sub_74006(i, (int)v3, 8u);
        }
        return sub_73669(a1);
      }
      else
      {
        sub_7404E(word_E12A8, (int)v3, 8u);
        sub_73669(a1);
        for ( i = 0; word_E127A > i; ++i )
        {
          if ( v3[i] == 1 )
          {
            word_E12A8 = i;
            v3[i] = 0;
            break;
          }
        }
        if ( (unsigned __int16)word_E12A8 == word_E1276 )
        {
          for ( i = 0; ; ++i )
          {
            result = word_E127A;
            if ( word_E127A <= i )
              break;
            if ( word_E1276 != i && v3[i] == 1 )
            {
              sub_74B75(i);
              while ( *(_BYTE *)(dword_E12AE[i] + 49) == 0xFF )
                ;
              if ( *(_BYTE *)(dword_E12AE[i] + 49) )
                sprintf(v2, "Error code (LISTEN) : %d", *(unsigned __int8 *)(dword_E12AE[i] + 49));
            }
          }
        }
        else
        {
          while ( 1 )
          {
            sub_74809(word_E12A8);
            while ( *(_BYTE *)(dword_E12AE[(unsigned __int16)word_E12A8] + 49) == 0xFF )
              ;
            result = dword_E12AE[(unsigned __int16)word_E12A8];
            if ( !*(_BYTE *)(result + 49) )
              break;
            sprintf(v2, "Error code (CALL) : %d", *(unsigned __int8 *)(dword_E12AE[(unsigned __int16)word_E12A8] + 49));
          }
        }
      }
    }
    else
    {
      return sub_73669(a1);
    }
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// E1274: using guessed type char byte_E1274;
// E1275: using guessed type char byte_E1275;
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A8: using guessed type __int16 word_E12A8;
// E12AE: using guessed type int dword_E12AE[8];
// 7373D: using guessed type char var_10[8];

//----- (000739AD) --------------------------------------------------------
__int16 __cdecl sub_739AD(__int16 a1)
{
  __int16 result; // ax
  char v2[20]; // [esp+0h] [ebp-18h] BYREF
  int i; // [esp+14h] [ebp-4h]

  if ( word_E1276 == a1 )
  {
    for ( i = 0; (__int16)i < word_E127A; ++i )
    {
      if ( (_WORD)i != word_E1276 )
      {
        sub_748F7(i);
        sub_74B19((_BYTE *)dword_E12AE[(__int16)i]);
      }
    }
    sprintf(v2, "%s%d", aTester, word_E1276);
    result = sub_74A86((_BYTE *)dword_E12AE[a1], (int)v2);
    byte_E1275 = 0;
  }
  else
  {
    sub_748F7(a1);
    sub_74B19((_BYTE *)dword_E12AE[a1]);
    result = word_E12A8;
    if ( word_E1276 == (unsigned __int16)word_E12A8 )
      return sub_74B75(a1);
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// E1275: using guessed type char byte_E1275;
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A8: using guessed type __int16 word_E12A8;
// E12AE: using guessed type int dword_E12AE[8];

//----- (00073AA1) --------------------------------------------------------
__int16 __cdecl sub_73AA1(__int16 a1)
{
  int v1; // eax
  char v3[84]; // [esp+0h] [ebp-64h] BYREF
  char v4[8]; // [esp+54h] [ebp-10h] BYREF
  int i; // [esp+5Ch] [ebp-8h]

  if ( byte_E1274 && byte_E1275 )
  {
    if ( (unsigned __int16)word_E12A8 == a1 )
    {
      if ( word_E1276 == a1 )
      {
        for ( i = 0; word_E127A > i; ++i )
          v4[i] = byte_E12CE[i] == 1;
        for ( i = 0; word_E127A > i; ++i )
        {
          if ( v4[i] == 1 )
            sub_74006(i, (int)v4, 8u);
        }
        LOWORD(v1) = sub_739AD(a1);
      }
      else
      {
        sub_7404E(word_E12A8, (int)v4, 8u);
        sub_739AD(a1);
        for ( i = 0; word_E127A > i; ++i )
        {
          if ( v4[i] == 1 )
          {
            word_E12A8 = i;
            v4[i] = 0;
            break;
          }
        }
        if ( (unsigned __int16)word_E12A8 == word_E1276 )
        {
          for ( i = 0; ; ++i )
          {
            LOWORD(v1) = word_E127A;
            if ( word_E127A <= i )
              break;
            if ( word_E1276 != i && v4[i] == 1 )
            {
              sub_74B75(i);
              while ( *(_BYTE *)(dword_E12AE[i] + 49) == 0xFF )
                ;
              if ( *(_BYTE *)(dword_E12AE[i] + 49) )
                sprintf(v3, "Error code (LISTEN) : %d", *(unsigned __int8 *)(dword_E12AE[i] + 49));
            }
          }
        }
        else
        {
          while ( 1 )
          {
            sub_74809(word_E12A8);
            while ( *(_BYTE *)(dword_E12AE[(unsigned __int16)word_E12A8] + 49) == 0xFF )
              ;
            v1 = dword_E12AE[(unsigned __int16)word_E12A8];
            if ( !*(_BYTE *)(v1 + 49) )
              break;
            sprintf(v3, "Error code (CALL) : %d", *(unsigned __int8 *)(dword_E12AE[(unsigned __int16)word_E12A8] + 49));
          }
        }
      }
    }
    else
    {
      LOWORD(v1) = sub_739AD(a1);
    }
  }
  return v1;
}
// 73D0A: variable 'v1' is possibly undefined
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// E1274: using guessed type char byte_E1274;
// E1275: using guessed type char byte_E1275;
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A8: using guessed type __int16 word_E12A8;
// E12AE: using guessed type int dword_E12AE[8];
// 73AA1: using guessed type char var_10[8];

//----- (00073D11) --------------------------------------------------------
__int16 __cdecl sub_73D11(__int16 a1)
{
  __int16 result; // ax
  char v2[20]; // [esp+0h] [ebp-18h] BYREF
  int i; // [esp+14h] [ebp-4h]

  if ( word_E1276 == a1 )
  {
    for ( i = 0; (__int16)i < word_E127A; ++i )
    {
      if ( (_WORD)i != word_E1276 )
      {
        sub_748F7(i);
        sub_74B19((_BYTE *)dword_E12AE[(__int16)i]);
      }
    }
    sprintf(v2, "%s%d", aTester, word_E1276);
    result = sub_74A86((_BYTE *)dword_E12AE[a1], (int)v2);
    byte_E1275 = 0;
  }
  else
  {
    sub_748F7(a1);
    sub_74B19((_BYTE *)dword_E12AE[a1]);
    result = word_E12A8;
    if ( word_E1276 == (unsigned __int16)word_E12A8 )
      return sub_74B75(a1);
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// E1275: using guessed type char byte_E1275;
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A8: using guessed type __int16 word_E12A8;
// E12AE: using guessed type int dword_E12AE[8];

//----- (00074006) --------------------------------------------------------
unsigned __int16 __cdecl sub_74006(unsigned __int16 a1, int a2, unsigned int a3)
{
  unsigned __int16 result; // ax

  if ( byte_E1274 )
  {
    result = a1;
    if ( byte_E12CE[a1] == 1 )
      return sub_74EF1(dword_E12AE[a1], a2, a3);
  }
  return result;
}
// E1274: using guessed type char byte_E1274;
// E12AE: using guessed type int dword_E12AE[8];

//----- (0007404E) --------------------------------------------------------
unsigned __int16 __cdecl sub_7404E(unsigned __int16 a1, int a2, unsigned int a3)
{
  unsigned __int16 result; // ax

  if ( byte_E1274 )
  {
    result = a1;
    if ( byte_E12CE[a1] == 1 )
      return sub_74D41(dword_E12AE[a1], a2, a3);
  }
  return result;
}
// E1274: using guessed type char byte_E1274;
// E12AE: using guessed type int dword_E12AE[8];

//----- (00074374) --------------------------------------------------------
__int16 sub_74374()
{
  return sub_74F76();
}

//----- (0007438A) --------------------------------------------------------
unsigned __int16 __cdecl sub_7438A(int a1, unsigned int a2)
{
  unsigned __int16 result; // ax
  signed __int16 i; // [esp+4h] [ebp-4h]
  signed __int16 j; // [esp+4h] [ebp-4h]

  if ( byte_E1274 )
  {
    if ( word_E1276 == (unsigned __int16)word_E12A8 )
    {
      for ( i = 0; i < word_E1278; ++i )
      {
        if ( i != word_E1276 )
          sub_7404E(i, a1 + a2 * i, a2);
      }
      for ( j = 0; ; ++j )
      {
        result = j;
        if ( j >= word_E1278 )
          break;
        if ( j != word_E1276 )
          sub_74006(j, a1, a2 * word_E1278);
      }
    }
    else
    {
      sub_74006(word_E12A8, a1 + a2 * word_E1276, a2);
      return sub_7404E(word_E12A8, a1, a2 * word_E1278);
    }
  }
  return result;
}
// E1274: using guessed type char byte_E1274;
// E1276: using guessed type __int16 word_E1276;
// E1278: using guessed type __int16 word_E1278;
// E12A8: using guessed type __int16 word_E12A8;

//----- (0007449C) --------------------------------------------------------
__int16 sub_7449C()
{
  __int16 result; // ax
  int i; // [esp+0h] [ebp-4h]

  if ( byte_E1274 )
  {
    result = word_E12A8;
    if ( word_E1276 == (unsigned __int16)word_E12A8 )
    {
      for ( i = 0; ; ++i )
      {
        result = word_E127A;
        if ( word_E127A <= i )
          break;
        if ( word_E1276 != i && *(_BYTE *)(dword_E12AE[i] + 49) == 0xFF )
          sub_748F7(i);
      }
    }
  }
  return result;
}
// E1274: using guessed type char byte_E1274;
// E1276: using guessed type __int16 word_E1276;
// E127A: using guessed type __int16 word_E127A;
// E12A8: using guessed type __int16 word_E12A8;
// E12AE: using guessed type int dword_E12AE[8];

//----- (00074515) --------------------------------------------------------
int sub_74515()
{
  return (unsigned __int16)word_E12A8;
}
// E12A8: using guessed type __int16 word_E12A8;

//----- (00074536) --------------------------------------------------------
int sub_74536()
{
  return word_E1276;
}
// E1276: using guessed type __int16 word_E1276;

//----- (00074556) --------------------------------------------------------
int sub_74556()
{
  int v2; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h]
  int j; // [esp+8h] [ebp-4h]

  v2 = 1;
  if ( !byte_E1274 && !dword_E12AA )
  {
    dword_E12AA = sub_83D70(66);
    if ( dword_E12AA )
    {
      if ( sub_74A11() == -1 )
        return 0;
      dword_E127E = sub_83D70(2048);
      if ( dword_E127E )
      {
        dword_E1282 = sub_83D70(2048);
        if ( dword_E1282 )
        {
          for ( i = 0; i < 8; ++i )
          {
            dword_E1286[i] = sub_83D70(2048);
            if ( !dword_E1286[i] )
            {
              v2 = 0;
              break;
            }
            dword_E12AE[i] = sub_83D70(66);
            if ( !dword_E12AE[i] )
            {
              v2 = 0;
              break;
            }
          }
          if ( i == 8 )
            byte_E1274 = 1;
        }
        else
        {
          v2 = 0;
        }
      }
      else
      {
        v2 = 0;
      }
    }
    else
    {
      v2 = 0;
    }
  }
  if ( !v2 )
  {
    byte_E1274 = 0;
    if ( dword_E12AA )
      sub_83E80(dword_E12AA);
    if ( dword_E127E )
      sub_83E80(dword_E127E);
    if ( dword_E1282 )
      sub_83E80(dword_E1282);
    for ( j = 0; j < 8; ++j )
    {
      if ( dword_E12AE[j] )
        sub_83E80(dword_E12AE[j]);
      if ( dword_E1286[j] )
        sub_83E80(dword_E1286[j]);
    }
  }
  return (unsigned __int8)byte_E1274;
}
// E1274: using guessed type char byte_E1274;
// E127E: using guessed type int dword_E127E;
// E1282: using guessed type int dword_E1282;
// E1286: using guessed type int dword_E1286[8];
// E12AA: using guessed type int dword_E12AA;
// E12AE: using guessed type int dword_E12AE[8];

//----- (00074767) --------------------------------------------------------
int __usercall sub_74767@<eax>(int a1@<edx>, __int16 *a2@<ebx>, _BYTE *a3, int a4)
{
  strcpy(a3 + 26, a4);
  while ( strlen(a3 + 26) < 0xFu )
    strcat(a3 + 26, asc_D1949);
  *a3 = -80;
  if ( sub_75044((unsigned int)a3) == -1 )
    return -99;
  while ( a3[49] == 0xFF && !word_E12A6 )
    sub_7C230((int)a3, a1, a2);
  return (unsigned __int8)a3[49];
}
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// 99D6B: using guessed type _DWORD __cdecl strlen(_DWORD);
// 99D84: using guessed type _DWORD __cdecl strcat(_DWORD, _DWORD);
// E12A6: using guessed type __int16 word_E12A6;

//----- (00074809) --------------------------------------------------------
int __cdecl sub_74809(__int16 a1)
{
  *(_BYTE *)dword_E12AE[a1] = -112;
  sprintf(dword_E12AE[a1] + 10, "%s%d", aTester, a1);
  while ( strlen(dword_E12AE[a1] + 10) < 0xFu )
    strcat(dword_E12AE[a1] + 10, asc_D1949);
  *(_BYTE *)(dword_E12AE[a1] + 42) = 0;
  *(_BYTE *)(dword_E12AE[a1] + 43) = 0;
  if ( sub_75044(dword_E12AE[a1]) == -1 )
    return -99;
  else
    return -*(unsigned __int8 *)(dword_E12AE[a1] + 49);
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 99D6B: using guessed type _DWORD __cdecl strlen(_DWORD);
// 99D84: using guessed type _DWORD __cdecl strcat(_DWORD, _DWORD);
// E12AE: using guessed type int dword_E12AE[8];

//----- (000748F7) --------------------------------------------------------
int __cdecl sub_748F7(__int16 a1)
{
  if ( *(_BYTE *)(dword_E12AE[a1] + 49) != 0xFF )
    return -*(unsigned __int8 *)(dword_E12AA + 49);
  *(_BYTE *)dword_E12AA = 53;
  *(_WORD *)(dword_E12AA + 6) = (unsigned int)dword_E12AE[a1] >> 4;
  if ( sub_75044(dword_E12AA) != -1 )
  {
    do
    {
      while ( *(_BYTE *)(dword_E12AA + 49) == 0xFF )
        ;
    }
    while ( *(_BYTE *)(dword_E12AE[a1] + 49) == 0xFF );
    return -*(unsigned __int8 *)(dword_E12AA + 49);
  }
  return -99;
}
// E12AA: using guessed type int dword_E12AA;
// E12AE: using guessed type int dword_E12AE[8];

//----- (00074A11) --------------------------------------------------------
int sub_74A11()
{
  __int64 v0; // rax

  v0 = dos_getvect(92);
  if ( !(_DWORD)v0 && !WORD2(v0) )
    return -1;
  *(_BYTE *)dword_E12AA = 127;
  if ( sub_75044(dword_E12AA) == -1 )
    return -1;
  if ( *(_BYTE *)(dword_E12AA + 1) == 3 )
    return 0;
  return -1;
}
// 99BA7: using guessed type __int64 __cdecl dos_getvect(_DWORD);
// E12AA: using guessed type int dword_E12AA;

//----- (00074A86) --------------------------------------------------------
int __cdecl sub_74A86(_BYTE *a1, int a2)
{
  strcpy(a1 + 26, a2);
  while ( strlen(a1 + 26) < 0xFu )
    strcat(a1 + 26, asc_D1949);
  *a1 = -79;
  if ( sub_75044((unsigned int)a1) == -1 )
    return -99;
  while ( a1[49] == 0xFF )
    ;
  return -(unsigned __int8)a1[49];
}
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// 99D6B: using guessed type _DWORD __cdecl strlen(_DWORD);
// 99D84: using guessed type _DWORD __cdecl strcat(_DWORD, _DWORD);

//----- (00074B19) --------------------------------------------------------
int __cdecl sub_74B19(_BYTE *a1)
{
  *a1 = -110;
  if ( sub_75044((unsigned int)a1) == -1 )
    return -99;
  while ( a1[49] == 0xFF )
    ;
  a1[2] = 0;
  return -(unsigned __int8)a1[49];
}

//----- (00074B75) --------------------------------------------------------
int __cdecl sub_74B75(__int16 a1)
{
  char v2[20]; // [esp+0h] [ebp-18h] BYREF

  if ( *(_BYTE *)(dword_E12AE[a1] + 49) == 0xFF )
    return -*(unsigned __int8 *)(dword_E12AE[a1] + 49);
  sprintf(v2, "%s%d", aTester, a1);
  *(_BYTE *)dword_E12AE[a1] = -111;
  strcpy(dword_E12AE[a1] + 10, v2);
  while ( strlen(dword_E12AE[a1] + 10) < 0xFu )
    strcat(dword_E12AE[a1] + 10, asc_D1949);
  *(_BYTE *)(dword_E12AE[a1] + 42) = 0;
  *(_BYTE *)(dword_E12AE[a1] + 43) = 0;
  if ( sub_75044(dword_E12AE[a1]) != -1 )
  {
    *(_WORD *)(dword_E12AE[a1] + 4) = 0;
    return -*(unsigned __int8 *)(dword_E12AE[a1] + 49);
  }
  return -99;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// 99D6B: using guessed type _DWORD __cdecl strlen(_DWORD);
// 99D84: using guessed type _DWORD __cdecl strcat(_DWORD, _DWORD);
// E12AE: using guessed type int dword_E12AE[8];

//----- (00074C9D) --------------------------------------------------------
int __cdecl sub_74C9D(unsigned int a1, int a2)
{
  *(_BYTE *)a1 = -107;
  *(_WORD *)(a1 + 6) = (unsigned int)dword_E1282 >> 4;
  *(_WORD *)(a1 + 8) = 2048;
  if ( sub_75044(a1) == -1 )
    return -99;
  while ( *(_BYTE *)(a1 + 49) == 0xFF )
    ;
  if ( *(_BYTE *)(a1 + 49) )
    return -*(unsigned __int8 *)(a1 + 49);
  memcpy(a2, dword_E1282, *(unsigned __int16 *)(a1 + 8));
  return *(unsigned __int16 *)(a1 + 8);
}
// 99DBD: using guessed type _DWORD __cdecl memcpy(_DWORD, _DWORD, _DWORD);
// E1282: using guessed type int dword_E1282;

//----- (00074D41) --------------------------------------------------------
int __cdecl sub_74D41(unsigned int a1, int a2, unsigned int a3)
{
  int v3; // eax
  int v6; // [esp+4h] [ebp-Ch]
  unsigned int i; // [esp+8h] [ebp-8h]

  for ( i = 0; a3 >> 11 > i; ++i )
  {
    v6 = sub_74C9D(a1, a2);
    if ( v6 != 2048 )
      return v6;
    a2 += 2048;
  }
  v3 = sub_74C9D(a1, a2);
  if ( (a3 & 0x7FF) == v3 )
    return a3;
  else
    return v3;
}

//----- (00074DD4) --------------------------------------------------------
int __cdecl sub_74DD4(unsigned int a1, int a2, unsigned __int16 a3)
{
  *(_BYTE *)a1 = -107;
  *(_WORD *)(a1 + 6) = (unsigned int)dword_E1286[a3] >> 4;
  *(_WORD *)(a1 + 8) = 2048;
  if ( sub_75044(a1) == -1 )
    return -99;
  else
    return 1;
}
// E1286: using guessed type int dword_E1286[8];

//----- (00074E6D) --------------------------------------------------------
int __cdecl sub_74E6D(unsigned int a1, int a2, int a3)
{
  memcpy(dword_E127E, a2, a3);
  *(_BYTE *)a1 = -108;
  *(_WORD *)(a1 + 6) = (unsigned int)dword_E127E >> 4;
  *(_WORD *)(a1 + 8) = a3;
  if ( sub_75044(a1) == -1 )
    return -99;
  while ( *(_BYTE *)(a1 + 49) == 0xFF )
    ;
  return -*(unsigned __int8 *)(a1 + 49);
}
// 99DBD: using guessed type _DWORD __cdecl memcpy(_DWORD, _DWORD, _DWORD);
// E127E: using guessed type int dword_E127E;

//----- (00074EF1) --------------------------------------------------------
int __cdecl sub_74EF1(unsigned int a1, int a2, unsigned int a3)
{
  unsigned int i; // [esp+4h] [ebp-Ch]
  __int16 v7; // [esp+Ch] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    if ( a3 >> 11 <= i )
      return sub_74E6D(a1, a2, a3 & 0x7FF);
    v7 = sub_74E6D(a1, a2, 2048);
    if ( v7 )
      break;
    a2 += 2048;
  }
  return v7;
}

//----- (00074F76) --------------------------------------------------------
__int16 sub_74F76()
{
  __int16 result; // ax
  __int16 i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < word_E127A; ++i )
  {
    byte_E12CE[i] = sub_74FE1(i);
    if ( byte_E12CE[i] )
      word_E1278 = i + 1;
  }
  result = word_E127A;
  word_E1278 = word_E127A;
  return result;
}
// E1278: using guessed type __int16 word_E1278;
// E127A: using guessed type __int16 word_E127A;

//----- (00074FE1) --------------------------------------------------------
int __cdecl sub_74FE1(__int16 a1)
{
  if ( a1 == word_E1276 )
    return 2;
  else
    return *(_BYTE *)(dword_E12AE[a1] + 2) && !*(_BYTE *)(dword_E12AE[a1] + 49);
}
// E1276: using guessed type __int16 word_E1276;
// E12AE: using guessed type int dword_E12AE[8];

//----- (00075044) --------------------------------------------------------
int __cdecl sub_75044(unsigned int a1)
{
  int v2[13]; // [esp+0h] [ebp-7Ch] BYREF
  int v3[7]; // [esp+34h] [ebp-48h] BYREF
  int v4[7]; // [esp+50h] [ebp-2Ch] BYREF
  char v5[12]; // [esp+6Ch] [ebp-10h] BYREF

  *(_BYTE *)(a1 + 49) = 0;
  memset(v2, 0, 50);
  LOWORD(v2[9]) = a1 >> 4;
  HIWORD(v2[8]) = v2[9];
  v2[4] = 0;
  v2[7] = 256;
  memset(v3, 0, sizeof(v3));
  memset(v4, 0, sizeof(v4));
  memset(v5, 0, sizeof(v5));
  segread(v5);
  v3[0] = 768;
  v3[1] = 92;
  v3[5] = (int)v2;
  int386x(49, v3, v4, v5);
  if ( v4[6] )
    return -1;
  else
    return 0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99DE6: using guessed type _DWORD __cdecl segread(_DWORD);
// 99E10: using guessed type _DWORD __cdecl int386x(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00075110) --------------------------------------------------------
int *__cdecl sub_75110(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5)
{
  return sub_8F100(a1, a2, a3 >> 8, 127 * a4 / 0xFFFF, a5 + 100, 0, 3u);
}

//----- (00075160) --------------------------------------------------------
int *__cdecl sub_75160(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5)
{
  return sub_8F100(a1, a2, a3 >> 8, 127 * a4 / 0xFFFF, a5 + 100, 0, 2u);
}

//----- (000751B0) --------------------------------------------------------
int *__cdecl sub_751B0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5)
{
  return sub_8F100(a1, a2, a3 >> 8, 127 * a4 / 0xFFFF, a5 + 100, 0, 1u);
}

//----- (00075200) --------------------------------------------------------
void __cdecl sub_75200(__int16 a1)
{
  char *v1; // esi
  char *v2; // esi

  if ( !byte_E3766 )
    sub_8CACD();
  sub_9951B(0);
  qmemcpy(&loc_A0000, (const void *)dword_180628, 0x10000u);
  v1 = (char *)(dword_180628 + 0x10000);
  sub_9951B(1);
  qmemcpy(&loc_A0000, v1, 0x10000u);
  v1 += 0x10000;
  sub_9951B(2);
  qmemcpy(&loc_A0000, v1, 0x10000u);
  v2 = v1 + 0x10000;
  sub_9951B(3);
  if ( a1 == 400 )
  {
    qmemcpy(&loc_A0000, v2, 0xE800u);
    sub_8CB1F();
  }
  else
  {
    qmemcpy(&loc_A0000, v2, 0x10000u);
    sub_9951B(4);
    qmemcpy(&loc_A0000, v2 + 0x10000, 0xB000u);
    if ( !byte_E3766 )
      sub_8CB1F();
  }
}
// E3766: using guessed type char byte_E3766;
// 180628: using guessed type int dword_180628;

//----- (000752C0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn sub_752C0(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  int v7; // [esp-4h] [ebp-4h] BYREF

  ((void (__cdecl __noreturn *)(_DWORD, _DWORD, _DWORD, _DWORD, int, int, int, int, int *, int, int, int))_GETDS)(
    (unsigned __int16)__GS__,
    (unsigned __int16)__FS__,
    (unsigned __int16)__ES__,
    (unsigned __int16)__DS__,
    a1,
    a2,
    a3,
    a4,
    &v7,
    a5,
    a6,
    a7);
}
// 753C1: positive sp value 4 has been found
// 753C1: control flows out of bounds to 753C2
// 99B86: using guessed type _DWORD __cdecl __far chain_intr(_DWORD);
// D4194: using guessed type char byte_D4194;
// D41A4: using guessed type int dword_D41A4;
// 17D430: using guessed type int dword_17D430;
// 17D434: using guessed type __int16 word_17D434;
// 17D436: using guessed type char byte_17D436;
// 17D437: using guessed type char byte_17D437;
// 1806E4: using guessed type char byte_1806E4;

//----- (000753D0) --------------------------------------------------------
int __fastcall sub_753D0(int a1, int a2)
{
  __int16 i; // ax
  int v3; // eax

  for ( i = 0; i < 128; ++i )
  {
    a2 = i;
    byte_180664[a2] = 0;
  }
  v3 = dos_getvect(9);
  word_17D434 = a2;
  dword_17D430 = v3;
  return dos_setvect(9, sub_752C0, (unsigned __int16)__CS__);
}
// 99BA7: using guessed type _DWORD __cdecl dos_getvect(_DWORD);
// 99BDB: using guessed type _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD);
// 17D430: using guessed type int dword_17D430;
// 17D434: using guessed type __int16 word_17D434;

//----- (00075420) --------------------------------------------------------
int sub_75420()
{
  return dos_setvect(9, dword_17D430, (unsigned __int16)word_17D434);
}
// 99BDB: using guessed type _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD);
// 17D430: using guessed type int dword_17D430;
// 17D434: using guessed type __int16 word_17D434;

//----- (00075440) --------------------------------------------------------
int sub_75440()
{
  int i; // ebx
  int v1; // esi

  for ( i = 96; i <= 112; ++i )
  {
    v1 = i << 8;
    LOWORD(v1) = ((_WORD)i << 8) | 0x7F;
    memset(&unk_17D6D4, 0, 50);
    dword_17D6F0 = v1;
    dword_17D6E4 = 0;
    dword_17D6EC = 0;
    dword_17D6E8 = 0;
    sub_75AE0((int)&unk_17D6D4);
    if ( (i | 0x7F00) == dword_17D6F0 )
      return (unsigned __int16)((_WORD)i << 8);
  }
  return 0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 17D6E4: using guessed type int dword_17D6E4;
// 17D6E8: using guessed type int dword_17D6E8;
// 17D6EC: using guessed type int dword_17D6EC;
// 17D6F0: using guessed type int dword_17D6F0;

//----- (000754C0) --------------------------------------------------------
int __cdecl sub_754C0(int a1, _DWORD *a2, int a3)
{
  int v3; // eax
  int v4; // ecx
  int i; // eax

  memset(&unk_17D6D4, 0, 50);
  v3 = a1;
  LOBYTE(v3) = a1 | 3;
  dword_17D6EC = 0;
  dword_17D6F0 = v3;
  dword_17D6E8 = 0;
  word_17D6F6 = word_17D708;
  sub_75AE0((int)&unk_17D6D4);
  v4 = dword_17D6C8;
  for ( i = 0; i < dword_17D6EC; *(_BYTE *)(a3 + i - 1) = *(_BYTE *)(v4 + i - 1) )
    ++i;
  *a2 = dword_17D6EC;
  return dword_17D6F0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 17D6C8: using guessed type int dword_17D6C8;
// 17D6E8: using guessed type int dword_17D6E8;
// 17D6EC: using guessed type int dword_17D6EC;
// 17D6F0: using guessed type int dword_17D6F0;
// 17D6F6: using guessed type __int16 word_17D6F6;
// 17D708: using guessed type __int16 word_17D708;

//----- (00075540) --------------------------------------------------------
int __cdecl sub_75540(int a1, int a2)
{
  int v2; // ecx
  int i; // eax
  int v4; // eax

  v2 = dword_17D6C8;
  for ( i = 0; i < 256; *(_BYTE *)(v2 + i - 1) = *(_BYTE *)(a2 + i - 1) )
    ++i;
  memset(&unk_17D6D4, 0, 50);
  v4 = a1;
  LOBYTE(v4) = a1 | 4;
  dword_17D6EC = 0;
  dword_17D6F0 = v4;
  dword_17D6E8 = 0;
  word_17D6F6 = word_17D708;
  sub_75AE0((int)&unk_17D6D4);
  return dword_17D6F0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 17D6C8: using guessed type int dword_17D6C8;
// 17D6E8: using guessed type int dword_17D6E8;
// 17D6EC: using guessed type int dword_17D6EC;
// 17D6F0: using guessed type int dword_17D6F0;
// 17D6F6: using guessed type __int16 word_17D6F6;
// 17D708: using guessed type __int16 word_17D708;

//----- (000755B0) --------------------------------------------------------
int __cdecl sub_755B0(int a1, _DWORD *a2, int a3)
{
  int v3; // eax
  int v4; // ecx
  int i; // eax

  memset(&unk_17D6D4, 0, 50);
  v3 = a1;
  LOBYTE(v3) = a1 | 5;
  dword_17D6EC = 0;
  dword_17D6F0 = v3;
  dword_17D6E8 = 0;
  word_17D6F6 = word_17D708;
  sub_75AE0((int)&unk_17D6D4);
  v4 = dword_17D6C8;
  for ( i = 0; i < dword_17D6EC; *(_BYTE *)(a3 + i - 1) = *(_BYTE *)(v4 + i - 1) )
    ++i;
  *a2 = dword_17D6EC;
  return dword_17D6F0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 17D6C8: using guessed type int dword_17D6C8;
// 17D6E8: using guessed type int dword_17D6E8;
// 17D6EC: using guessed type int dword_17D6EC;
// 17D6F0: using guessed type int dword_17D6F0;
// 17D6F6: using guessed type __int16 word_17D6F6;
// 17D708: using guessed type __int16 word_17D708;

//----- (00075650) --------------------------------------------------------
int sub_75650()
{
  unsigned __int8 *v1; // eax
  int v2; // eax
  char *v3; // eax
  int v4; // ebx
  int v5; // edx
  int v6; // esi
  char v7; // dh
  char v8; // bh
  int v9; // ecx
  int v10; // edx
  int v11; // ebx
  char v12; // dl
  char v13; // bl
  char v14; // dh
  unsigned __int8 *v15; // [esp+0h] [ebp-4h] BYREF

  memset(&word_17D6CC, 0, 6);
  memset(&word_17D70A, 0, 7);
  dword_17D6C8 = sub_75B80(256, &word_17D708, &word_17D706);
  if ( !dword_17D6C8 )
    return 0;
  v1 = (unsigned __int8 *)getenv(aVipport);
  if ( v1 )
  {
    dword_17D6B0 = sub_99FF0(v1, &v15, 16);
    dword_17D6A0 = dword_17D6B0 + 1;
    v2 = sub_75440();
    dword_17D640 = v2;
    if ( !v2 || sub_754C0(v2, &dword_17D648, (int)byte_17D440) )
      goto LABEL_22;
    dword_17D644 = 0;
    dword_17D6A8 = 0;
    dword_17D698 = 0;
    dword_17D6AC = (int)&unk_17D540;
    while ( dword_17D698 < dword_17D648 )
    {
      dword_17D6A4 = byte_17D440[dword_17D698];
      v3 = &byte_17D440[dword_17D698];
      switch ( byte_17D441[dword_17D698] )
      {
        case 0:
          dword_17D698 = dword_17D648;
          break;
        case 1:
          dword_17D6C0 = (int)&byte_17D440[dword_17D698];
          break;
        case 2:
          dword_17D6B8 = (int)&byte_17D440[dword_17D698];
          byte_17D711 = strcmp(v3 + 34, aVfx1Cyberpuck) == 0;
          break;
        case 6:
          if ( dword_17D6A8 < 6 )
          {
            v4 = dword_17D6A8;
            v5 = 3 * dword_17D6A8;
            v6 = dword_17D6AC;
            dword_17D6C4 = (int)&byte_17D440[dword_17D698];
            *(_WORD *)&byte_17D674[2 * v5 + 4] = __DS__;
            *(_DWORD *)&byte_17D674[2 * v5] = v6;
            dword_17D6A8 = v4 + 1;
            dword_17D6AC = v6 + 6;
            if ( byte_17D711 )
            {
              v7 = v3[14];
              v3[22] |= 0x80u;
              v8 = v3[30];
              v3[14] = v7 | 0x80;
              v3[30] = v8 | 0x80;
            }
          }
          break;
        case 7:
          if ( dword_17D644 < 6 )
          {
            v9 = dword_17D6AC;
            v10 = 3 * dword_17D644;
            dword_17D6BC = (int)&byte_17D440[dword_17D698];
            v11 = dword_17D644 + 1;
            *(_DWORD *)&byte_17D650[2 * v10] = dword_17D6AC;
            *(_WORD *)&byte_17D650[2 * v10 + 4] = __DS__;
            dword_17D6AC = v9 + 7;
            dword_17D644 = v11;
            if ( byte_17D711 )
            {
              v12 = v3[22];
              v3[14] |= 0x80u;
              v13 = v3[33];
              v3[22] = v12 | 0x80;
              v14 = v3[30];
              v3[33] = v13 | 0x80;
              v3[30] = v14 | 0x80;
            }
          }
          break;
        default:
          break;
      }
      dword_17D698 += dword_17D6A4;
    }
    if ( sub_75540(dword_17D640, (int)byte_17D440) )
    {
LABEL_22:
      sub_75AB0();
      return 0;
    }
    else
    {
      if ( dword_17D6A8 )
        byte_E12EC = 1;
      if ( dword_17D644 )
        byte_E12ED = 1;
      return 1;
    }
  }
  else
  {
    dword_17D6B0 = 768;
    sub_75AB0();
    return 0;
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99E33: using guessed type _DWORD __cdecl getenv(_DWORD);
// 9A050: using guessed type _DWORD __cdecl strcmp(_DWORD, _DWORD);
// E12EC: using guessed type char byte_E12EC;
// E12ED: using guessed type char byte_E12ED;
// 17D640: using guessed type int dword_17D640;
// 17D644: using guessed type int dword_17D644;
// 17D648: using guessed type int dword_17D648;
// 17D698: using guessed type int dword_17D698;
// 17D6A0: using guessed type int dword_17D6A0;
// 17D6A4: using guessed type int dword_17D6A4;
// 17D6A8: using guessed type int dword_17D6A8;
// 17D6AC: using guessed type int dword_17D6AC;
// 17D6B0: using guessed type int dword_17D6B0;
// 17D6B8: using guessed type int dword_17D6B8;
// 17D6BC: using guessed type int dword_17D6BC;
// 17D6C0: using guessed type int dword_17D6C0;
// 17D6C4: using guessed type int dword_17D6C4;
// 17D6C8: using guessed type int dword_17D6C8;
// 17D6CC: using guessed type __int16 word_17D6CC;
// 17D706: using guessed type __int16 word_17D706;
// 17D708: using guessed type __int16 word_17D708;
// 17D70A: using guessed type __int16 word_17D70A;
// 17D711: using guessed type char byte_17D711;

//----- (00075900) --------------------------------------------------------
int sub_75900()
{
  return sub_75AB0();
}

//----- (00075910) --------------------------------------------------------
int sub_75910()
{
  unsigned __int16 v1; // ax
  unsigned __int8 v2; // al

  if ( sub_755B0(dword_17D640, &dword_17D648, (int)&unk_17D540) )
  {
    sub_75AB0();
    return 0;
  }
  else
  {
    if ( byte_E12EC )
    {
      word_17D6CC = __readgsword(*(unsigned int *)byte_17D674);
      v1 = __readgsword(*(_DWORD *)byte_17D674 + 4);
      word_17D6CE = __readgsword(*(_DWORD *)byte_17D674 + 2);
      word_17D6D0 = v1;
    }
    if ( byte_E12ED )
    {
      word_17D70A = __readgsword(*(unsigned int *)byte_17D650);
      word_17D70C = __readgsword(*(_DWORD *)byte_17D650 + 2);
      v2 = __readgsbyte(*(_DWORD *)byte_17D650 + 6);
      word_17D70E = __readgsword(*(_DWORD *)byte_17D650 + 4);
      byte_17D710 = v2;
    }
    return 1;
  }
}
// E12EC: using guessed type char byte_E12EC;
// E12ED: using guessed type char byte_E12ED;
// 17D640: using guessed type int dword_17D640;
// 17D648: using guessed type int dword_17D648;
// 17D6CC: using guessed type __int16 word_17D6CC;
// 17D6CE: using guessed type __int16 word_17D6CE;
// 17D6D0: using guessed type __int16 word_17D6D0;
// 17D70A: using guessed type __int16 word_17D70A;
// 17D70C: using guessed type __int16 word_17D70C;
// 17D70E: using guessed type __int16 word_17D70E;
// 17D710: using guessed type char byte_17D710;

//----- (000759B0) --------------------------------------------------------
int sub_759B0()
{
  int result; // eax
  __int16 v1[14]; // [esp+0h] [ebp-1Ch] BYREF

  if ( byte_E12EC )
  {
    memset(v1, 0, sizeof(v1));
    v1[0] = 24584;
    v1[2] = *(unsigned __int8 *)(dword_17D6C4 + 3) | 0x800;
    return int386(51, v1, v1);
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E12EC: using guessed type char byte_E12EC;
// 17D6C4: using guessed type int dword_17D6C4;

//----- (00075A10) --------------------------------------------------------
unsigned __int8 __cdecl sub_75A10(int a1, unsigned __int8 *a2)
{
  unsigned __int8 v3; // al
  char v5; // dl
  unsigned __int8 v6; // al
  int v7; // ecx
  unsigned __int8 v8; // al
  unsigned __int8 *v9; // ebx
  unsigned __int8 v10; // al
  unsigned __int8 result; // al

  __outbyte(dword_17D6B0, 7u);
  __outbyte(dword_17D6A0, 0xFFu);
  __outbyte(dword_17D6B0, 6u);
  v3 = __inbyte(dword_17D6A0);
  v5 = v3 & 0xF8;
  if ( a1 )
  {
    if ( a1 == 1 )
      v6 = v5 | 1;
    else
      v6 = v3 & 0xFA | 4;
  }
  else
  {
    v6 = v5 | 3;
  }
  __outbyte(dword_17D6A0, v6);
  __outbyte(dword_17D6B0, 9u);
  __outbyte(dword_17D6A0, 0);
  v7 = 0;
  __outbyte(dword_17D6B0, 0xAu);
  do
  {
    v8 = *a2;
    v9 = a2 + 1;
    __outbyte(dword_17D6A0, v8);
    v10 = *v9++;
    __outbyte(dword_17D6A0, v10);
    ++v7;
    result = *v9;
    a2 = v9 + 1;
    __outbyte(dword_17D6A0, result);
  }
  while ( v7 < 256 );
  return result;
}
// 17D6A0: using guessed type int dword_17D6A0;
// 17D6B0: using guessed type int dword_17D6B0;

//----- (00075AB0) --------------------------------------------------------
int sub_75AB0()
{
  int result; // eax

  if ( dword_17D6C8 )
  {
    result = sub_75B50(word_17D706);
    dword_17D6C8 = 0;
  }
  return result;
}
// 17D6C8: using guessed type int dword_17D6C8;
// 17D706: using guessed type __int16 word_17D706;

//----- (00075AE0) --------------------------------------------------------
int __cdecl sub_75AE0(int a1)
{
  int v2[7]; // [esp+0h] [ebp-28h] BYREF
  __int16 v3[6]; // [esp+1Ch] [ebp-Ch] BYREF

  memset(v3, 0, sizeof(v3));
  memset(v2, 0, sizeof(v2));
  v2[2] = 0;
  v2[5] = a1;
  v2[0] = 768;
  v2[1] = 51;
  v3[0] = __DS__;
  return int386x(49, v2, v2, v3);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99E10: using guessed type _DWORD __cdecl int386x(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00075B50) --------------------------------------------------------
int __cdecl sub_75B50(__int16 a1)
{
  int v2[7]; // [esp+0h] [ebp-1Ch] BYREF

  v2[3] = a1;
  v2[0] = 257;
  return int386(49, v2, v2);
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (00075B80) --------------------------------------------------------
int __cdecl sub_75B80(int a1, __int16 *a2, _WORD *a3)
{
  int v3; // ebx
  int v5[3]; // [esp+0h] [ebp-28h] BYREF
  int v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+18h] [ebp-10h]
  char v8[12]; // [esp+1Ch] [ebp-Ch] BYREF

  *a2 = 0;
  *a3 = 0;
  segread(v8);
  v3 = 0;
  v5[1] = (unsigned int)(a1 + 15) >> 4;
  v5[0] = 256;
  int386(49, v5, v5);
  if ( !v7 )
  {
    *a2 = v5[0];
    *a3 = v6;
    return 16 * *a2;
  }
  return v3;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 99DE6: using guessed type _DWORD __cdecl segread(_DWORD);
// 75B80: using guessed type char var_C[12];

//----- (00075C50) --------------------------------------------------------
void sub_75C50()
{
  __outbyte(0x302u, 2u);
  __outbyte(0x303u, 1u);
  memset(dword_180628, 0, dword_180624 * dword_18062C);
  if ( (word_180660 & 1) != 0 )
    sub_90478();
  else
    sub_75200(480);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 180624: using guessed type int dword_180624;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;

//----- (00075CB0) --------------------------------------------------------
void sub_75CB0()
{
  if ( word_E12FE && sub_473E0() )
  {
    word_17DB5A = 1;
  }
  else if ( word_17DB5C && (byte_1806E4 || word_180746 || word_180744) )
  {
    word_17DB5A = 1;
  }
  else
  {
    while ( dword_17DB54 < (unsigned int)dword_E3844 )
    {
      if ( word_E12FE && sub_473E0() )
      {
        word_17DB5A = 1;
        return;
      }
      if ( word_17DB5C && (byte_1806E4 || word_180746 || word_180744) )
      {
        word_17DB5A = 1;
        return;
      }
    }
    dword_17DB54 = 0;
  }
}
// E12FE: using guessed type __int16 word_E12FE;
// E3844: using guessed type int dword_E3844;
// 17DB54: using guessed type int dword_17DB54;
// 17DB5A: using guessed type __int16 word_17DB5A;
// 17DB5C: using guessed type __int16 word_17DB5C;
// 1806E4: using guessed type char byte_1806E4;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;

//----- (00075D70) --------------------------------------------------------
unsigned int __cdecl sub_75D70(void *a1, unsigned int a2)
{
  unsigned int result; // eax

  if ( a1 )
  {
    result = a2;
    qmemcpy(a1, (const void *)dword_17DB50, a2);
  }
  dword_17DB50 += a2;
  return result;
}
// 17DB50: using guessed type int dword_17DB50;

//----- (00075DB0) --------------------------------------------------------
int sub_75DB0()
{
  int result; // eax

  dword_17D730 = dword_E1300;
  sub_988A7(dword_17DB38, (int)&dword_17D720, 16);
  while ( word_17D724 != -3590 )
    printf(aErrorUnknownFr);
  sub_988A7(dword_17DB38, dword_E9C38, dword_17D720 - 16);
  result = dword_17D720;
  dword_E1300 += dword_17D720;
  return result;
}
// E1300: using guessed type int dword_E1300;
// E9C38: using guessed type int dword_E9C38;
// 17D720: using guessed type int dword_17D720;
// 17D724: using guessed type __int16 word_17D724;
// 17D730: using guessed type int dword_17D730;
// 17DB38: using guessed type int dword_17DB38;

//----- (00075E70) --------------------------------------------------------
void __fastcall sub_75E70(__int16 a1)
{
  int v1; // eax
  unsigned int i; // ebx
  char *v3; // esi
  char *v4; // edi
  char v5; // al
  char v6; // al
  char *v7; // esi
  char *v8; // esi
  char *v9; // edi
  char v10; // al
  char v11; // al
  char *v12; // esi
  char *v13; // edi
  char v14; // al
  char v15; // al
  char *v16; // edi
  char v17; // al
  char v18; // al
  char v19; // al
  int v20; // [esp+0h] [ebp-10h] BYREF
  int v21; // [esp+4h] [ebp-Ch]
  int v22; // [esp+8h] [ebp-8h]
  char v23; // [esp+Ch] [ebp-4h]

  HIBYTE(a1) = 0;
  v23 = 0;
  dword_17DB50 = dword_E9C38;
  byte_17D738[0] = 0;
  if ( word_17D724 == -3840 )
  {
    sub_75D70(0, dword_17D720 - 16);
    v1 = sub_75DB0();
    a1 = sub_75E70(v1);
  }
  else if ( word_17D724 == -3590 )
  {
    for ( i = 0; ; ++i )
    {
      a1 = word_17D726;
      if ( i >= (unsigned __int16)word_17D726 )
        break;
      v22 = dword_17DB50;
      sub_75D70(&v20, 6u);
      switch ( (__int16)v21 )
      {
        case 4:
          v3 = aColour256;
          sub_76260();
          v4 = &byte_17D738[strlen(byte_17D738)];
          do
          {
            v5 = *v3;
            *v4 = *v3;
            if ( !v5 )
              break;
            v6 = v3[1];
            v3 += 2;
            v4[1] = v6;
            v4 += 2;
          }
          while ( v6 );
          v23 = 1;
          break;
        case 7:
          v7 = aSs2;
          sub_76300();
          goto LABEL_23;
        case 11:
          sub_76260();
          v8 = aColour;
          v9 = &byte_17D738[strlen(byte_17D738)];
          do
          {
            v10 = *v8;
            *v9 = *v8;
            if ( !v10 )
              break;
            v11 = v8[1];
            v8 += 2;
            v9[1] = v11;
            v9 += 2;
          }
          while ( v11 );
          v23 = 1;
          break;
        case 12:
          v7 = aLc;
          sub_76430();
          goto LABEL_23;
        case 13:
          memset(dword_E12F4, 0, (unsigned __int16)word_17DB48 * (unsigned __int16)word_17DB4A);
          v7 = aBlack;
          goto LABEL_23;
        case 15:
          v7 = aBrun;
          sub_76540();
          goto LABEL_23;
        case 16:
          sub_75D70((void *)dword_E12F4, (unsigned __int16)word_17DB4A * (unsigned __int16)word_17DB48);
          v12 = aCopy;
          v13 = &byte_17D738[strlen(byte_17D738)];
          do
          {
            v14 = *v12;
            *v13 = *v12;
            if ( !v14 )
              break;
            v15 = v12[1];
            v12 += 2;
            v13[1] = v15;
            v13 += 2;
          }
          while ( v15 );
          v20 = (unsigned __int16)word_17DB4A * (unsigned __int16)word_17DB48;
          break;
        case 18:
          sub_75D70(0, v20 - 6);
          v7 = aPstamp;
LABEL_23:
          v16 = &byte_17D738[strlen(byte_17D738)];
          do
          {
            v17 = *v7;
            *v16 = *v7;
            if ( !v17 )
              break;
            v18 = v7[1];
            v7 += 2;
            v16[1] = v18;
            v16 += 2;
          }
          while ( v18 );
          break;
        default:
          break;
      }
      dword_17DB50 = v20 + v22;
    }
  }
  if ( dword_17DB3C )
    dword_17DB3C(a1);
  sub_75CB0();
  if ( v23 )
  {
    sub_9A0FC();
    if ( word_E12FC )
    {
      sub_41A90(byte_17D838);
      v19 = sub_5BE80(byte_17D838, 0x3Fu, 0x3Fu, 0x3Fu);
      sub_2EC90(v19);
    }
  }
  if ( byte_D41C1 )
  {
    dword_180628 += 9920;
    sub_90478();
    dword_180628 -= 9920;
  }
  else
  {
    sub_90478();
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41C1: using guessed type char byte_D41C1;
// E12F4: using guessed type int dword_E12F4;
// E12FC: using guessed type __int16 word_E12FC;
// E9C38: using guessed type int dword_E9C38;
// 17D720: using guessed type int dword_17D720;
// 17D724: using guessed type __int16 word_17D724;
// 17D726: using guessed type __int16 word_17D726;
// 17D838: using guessed type unsigned __int8 byte_17D838[768];
// 17DB3C: using guessed type int (__fastcall *dword_17DB3C)(_DWORD);
// 17DB48: using guessed type __int16 word_17DB48;
// 17DB4A: using guessed type __int16 word_17DB4A;
// 17DB50: using guessed type int dword_17DB50;
// 180628: using guessed type int dword_180628;

//----- (00076160) --------------------------------------------------------
int __cdecl sub_76160(__int16 a1, __int16 a2, int a3)
{
  int result; // eax
  __int16 v4; // ax

  word_E12FC = a2;
  word_D4004 = 0;
  word_17DB58 = 0;
  word_17DB60 = 0;
  dword_E12F4 = dword_180628;
  result = sub_98817((int)&unk_E3848, 512);
  dword_17DB38 = result;
  if ( result >= 0 )
  {
    sub_988A7(result, (int)&unk_17DB40, 12);
    word_180744 = 0;
    word_180746 = 0;
    dword_E1300 += 12;
    byte_1806E4 = 0;
    word_17DB5A = 0;
    sub_473B0();
    word_17DB5C = a1;
    do
    {
      if ( word_17DB5A )
        break;
      if ( word_17DB60 >= (unsigned __int16)word_17DB46 - 1 )
        break;
      sub_1B280(a3);
      v4 = sub_75DB0();
      sub_75E70(v4);
      ++word_17DB60;
    }
    while ( byte_1806E4 != 1 );
    return sub_98882(dword_17DB38);
  }
  return result;
}
// D4004: using guessed type __int16 word_D4004;
// E12F4: using guessed type int dword_E12F4;
// E12FC: using guessed type __int16 word_E12FC;
// E1300: using guessed type int dword_E1300;
// 17DB38: using guessed type int dword_17DB38;
// 17DB46: using guessed type __int16 word_17DB46;
// 17DB58: using guessed type __int16 word_17DB58;
// 17DB5A: using guessed type __int16 word_17DB5A;
// 17DB5C: using guessed type __int16 word_17DB5C;
// 17DB60: using guessed type __int16 word_17DB60;
// 180628: using guessed type int dword_180628;
// 1806E4: using guessed type char byte_1806E4;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;

//----- (00076260) --------------------------------------------------------
unsigned int sub_76260()
{
  char *v0; // ebx
  int v1; // esi
  unsigned int result; // eax
  unsigned __int16 i; // di
  unsigned __int16 v4; // [esp+0h] [ebp-Ch] BYREF
  int v5; // [esp+4h] [ebp-8h] BYREF
  char v6[4]; // [esp+8h] [ebp-4h] BYREF

  v0 = (char *)&unk_17D838;
  v1 = 0;
  for ( result = sub_75D70(&v4, 2u); (unsigned __int16)v1 < v4; ++v1 )
  {
    sub_75D70(v6, 1u);
    v0 += 3 * (unsigned __int8)v6[0];
    v5 = 0;
    result = sub_75D70(&v5, 1u);
    if ( !(_WORD)v5 )
      v5 = 256;
    for ( i = 0; i < (unsigned __int16)v5; ++i )
    {
      result = sub_75D70(v0, 3u);
      v0 += 3;
    }
  }
  return result;
}
// 76260: using guessed type char var_4[4];

//----- (00076300) --------------------------------------------------------
__int16 sub_76300()
{
  int v0; // edi
  __int16 result; // ax
  int i; // esi
  char *v3; // ebx
  unsigned __int16 k; // cx
  unsigned __int16 v5; // [esp+0h] [ebp-1Ch] BYREF
  int v6; // [esp+4h] [ebp-18h]
  int j; // [esp+8h] [ebp-14h]
  int v8; // [esp+Ch] [ebp-10h] BYREF
  int v9; // [esp+10h] [ebp-Ch] BYREF
  char v10[4]; // [esp+14h] [ebp-8h] BYREF
  char v11[4]; // [esp+18h] [ebp-4h] BYREF

  v0 = 0;
  result = sub_75D70(&v5, 2u);
  for ( i = dword_E12F4; (unsigned __int16)v0 < v5; i += (unsigned __int16)word_17DB48 )
  {
    v3 = (char *)i;
    sub_75D70(&v9, 2u);
    if ( (v9 & 0x8000) == 0 )
    {
      v6 = v9;
      for ( j = 0; (unsigned __int16)j < (unsigned __int16)v6; ++j )
      {
        sub_75D70(v11, 1u);
        v3 += (unsigned __int8)v11[0];
        sub_75D70(v10, 1u);
        if ( v10[0] >= 0 )
        {
          if ( v10[0] > 0 )
          {
            sub_75D70(v3, 2 * v10[0]);
            v3 += 2 * v10[0];
          }
        }
        else
        {
          sub_75D70(&v8, 2u);
          for ( k = 0; abs8(v10[0]) > (int)k; ++k )
          {
            v3 += 2;
            *((_WORD *)v3 - 1) = v8;
          }
        }
      }
    }
    else if ( (v9 & 0x4000) != 0 )
    {
      --v0;
      i += (unsigned __int16)word_17DB48 * (abs16(v9) - 1);
    }
    else
    {
      *(_BYTE *)(i + (unsigned __int16)word_17DB48 - 1) = v9;
    }
    result = word_17DB48;
    ++v0;
  }
  return result;
}
// E12F4: using guessed type int dword_E12F4;
// 17DB48: using guessed type __int16 word_17DB48;
// 76300: using guessed type char var_4[4];
// 76300: using guessed type char var_8[4];

//----- (00076430) --------------------------------------------------------
int sub_76430()
{
  int v0; // edi
  int result; // eax
  char *v2; // ebx
  unsigned __int16 v3; // si
  int v4; // eax
  int v5; // [esp+0h] [ebp-18h]
  unsigned __int16 v6; // [esp+4h] [ebp-14h] BYREF
  char v7[4]; // [esp+8h] [ebp-10h] BYREF
  char v8[4]; // [esp+Ch] [ebp-Ch] BYREF
  char v9[4]; // [esp+10h] [ebp-8h] BYREF
  char v10[4]; // [esp+14h] [ebp-4h] BYREF

  sub_75D70(&v6, 2u);
  v0 = (unsigned __int16)word_17DB48 * v6 + dword_E12F4;
  sub_75D70(&v6, 2u);
  v5 = 0;
  for ( result = 0; (unsigned __int16)v5 < v6; result = v5 )
  {
    v2 = (char *)v0;
    v3 = 0;
    sub_75D70(v9, 1u);
    while ( v3 < (int)(unsigned __int8)v9[0] )
    {
      sub_75D70(v7, 1u);
      v2 += (unsigned __int8)v7[0];
      sub_75D70(v8, 1u);
      if ( v8[0] >= 0 )
      {
        if ( v8[0] <= 0 )
          goto LABEL_8;
        sub_75D70(v2, v8[0]);
        v4 = v8[0];
      }
      else
      {
        sub_75D70(v10, 1u);
        memset(v2, (unsigned __int8)v10[0], abs8(v8[0]));
        v4 = abs8(v8[0]);
      }
      v2 += v4;
LABEL_8:
      ++v3;
    }
    ++v5;
    v0 += (unsigned __int16)word_17DB48;
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// E12F4: using guessed type int dword_E12F4;
// 17DB48: using guessed type __int16 word_17DB48;
// 76430: using guessed type char var_8[4];
// 76430: using guessed type char var_10[4];
// 76430: using guessed type char var_C[4];
// 76430: using guessed type char var_4[4];

//----- (00076540) --------------------------------------------------------
int sub_76540()
{
  int v0; // esi
  char *v1; // ebx
  unsigned __int16 v2; // di
  int result; // eax
  int i; // [esp+0h] [ebp-Ch]
  char v5[4]; // [esp+4h] [ebp-8h] BYREF
  char v6[4]; // [esp+8h] [ebp-4h] BYREF

  v0 = dword_E12F4;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( (unsigned __int16)i >= (unsigned __int16)word_17DB4A )
      break;
    v1 = (char *)v0;
    v2 = 0;
    sub_75D70(0, 1u);
    while ( v2 < (unsigned __int16)word_17DB48 )
    {
      sub_75D70(v6, 1u);
      if ( v6[0] >= 0 )
      {
        if ( v6[0] > 0 )
        {
          sub_75D70(v5, 1u);
          memset(v1, (unsigned __int8)v5[0], v6[0]);
        }
      }
      else
      {
        v6[0] = abs8(v6[0]);
        sub_75D70(v1, v6[0]);
      }
      v2 += v6[0];
      v1 += v6[0];
    }
    v0 += (unsigned __int16)word_17DB48;
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// E12F4: using guessed type int dword_E12F4;
// 17DB48: using guessed type __int16 word_17DB48;
// 17DB4A: using guessed type __int16 word_17DB4A;
// 76540: using guessed type char var_4[4];
// 76540: using guessed type char var_8[4];

//----- (000765FC) --------------------------------------------------------
void __cdecl sub_765FC(__int16 a1, __int16 a2)
{
  word_E130E = a1;
  word_E1310 = a2;
}
// E130E: using guessed type __int16 word_E130E;
// E1310: using guessed type __int16 word_E1310;

//----- (00076619) --------------------------------------------------------
int __cdecl sub_76619(int a1, int a2)
{
  dword_E1308 = a1;
  dword_E1304 = a2;
  while ( 1 )
  {
    qmemcpy(&word_E1312, (const void *)dword_E1308, 4u);
    dword_E1308 += 4;
    qmemcpy(&word_E130C, (const void *)dword_E1308, sizeof(word_E130C));
    dword_E1308 += 2;
    if ( word_E130C != -20718 )
      break;
    sub_76752();
  }
  if ( word_E130C != -3590 )
    return 0;
  sub_766A4();
  return dword_E1308;
}
// E1304: using guessed type int dword_E1304;
// E1308: using guessed type int dword_E1308;
// E130C: using guessed type __int16 word_E130C;
// E1312: using guessed type __int16 word_E1312;

//----- (000766A4) --------------------------------------------------------
__int16 sub_766A4()
{
  __int16 result; // ax

  qmemcpy(&word_E1316, (const void *)dword_E1308, sizeof(word_E1316));
  dword_E1308 += 2;
  dword_E1308 += 8;
  while ( word_E1316 )
  {
    --word_E1316;
    qmemcpy(&word_E1312, (const void *)dword_E1308, 4u);
    dword_E1308 += 4;
    qmemcpy(&word_E130C, (const void *)dword_E1308, sizeof(word_E130C));
    dword_E1308 += 2;
    if ( word_E130C == 7 )
    {
      result = sub_7678D();
    }
    else if ( word_E130C == 15 )
    {
      result = sub_76840();
    }
    else
    {
      result = sub_7677C();
    }
  }
  return result;
}
// E1308: using guessed type int dword_E1308;
// E130C: using guessed type __int16 word_E130C;
// E1312: using guessed type __int16 word_E1312;
// E1316: using guessed type __int16 word_E1316;

//----- (00076752) --------------------------------------------------------
__int16 sub_76752()
{
  __int16 result; // ax

  word_E130E = *(_WORD *)(dword_E1308 + 2);
  result = *(_WORD *)(dword_E1308 + 4);
  word_E1310 = result;
  dword_E1308 += 6;
  return result;
}
// E1308: using guessed type int dword_E1308;
// E130E: using guessed type __int16 word_E130E;
// E1310: using guessed type __int16 word_E1310;

//----- (0007677C) --------------------------------------------------------
int sub_7677C()
{
  int result; // eax

  result = (unsigned __int16)word_E1312 - 6;
  dword_E1308 += result;
  return result;
}
// E1308: using guessed type int dword_E1308;
// E1312: using guessed type __int16 word_E1312;

//----- (0007678D) --------------------------------------------------------
__int16 sub_7678D()
{
  _WORD *v0; // edi
  __int16 *v1; // esi
  __int16 result; // ax
  _BYTE *v3; // edi
  _BYTE *v4; // esi
  char v5; // dl
  _WORD *v6; // [esp-4h] [ebp-14h]
  _WORD *v7; // [esp+0h] [ebp-10h]
  __int16 i; // [esp+6h] [ebp-Ah]
  __int16 v9; // [esp+8h] [ebp-8h]
  int v10; // [esp+Ch] [ebp-4h]

  v10 = (unsigned __int16)word_E130E;
  v0 = (_WORD *)dword_E1304;
  v1 = (__int16 *)(dword_E1308 + 2);
  v9 = *(_WORD *)dword_E1308;
  do
  {
    while ( 1 )
    {
      result = *v1++;
      v7 = v0;
      if ( result >= 0 )
        goto LABEL_10;
      if ( (result & 0x4000) == 0 )
        break;
      v0 = (_WORD *)((char *)v0 + v10 * -result);
    }
    v6 = v0;
    v3 = (char *)v0 + v10 - 1;
    if ( byte_E2A20 == 1 )
    {
      if ( (_BYTE)result )
        *v3 = result;
    }
    else
    {
      *v3 = result;
    }
    v0 = v6;
LABEL_10:
    for ( i = result; i; --i )
    {
      while ( 1 )
      {
        LOBYTE(result) = *(_BYTE *)v1;
        v4 = (char *)v1 + 1;
        result = (unsigned __int8)result;
        v0 = (_WORD *)((char *)v0 + (unsigned __int8)result);
        v5 = *v4;
        v1 = (__int16 *)(v4 + 1);
        if ( v5 > 0 )
          break;
        result = *v1++;
        do
        {
          *v0++ = result;
          ++v5;
        }
        while ( v5 );
        if ( !--i )
          goto LABEL_18;
      }
      do
      {
        *v0++ = *v1++;
        --v5;
      }
      while ( v5 );
    }
LABEL_18:
    v0 = (_WORD *)((char *)v7 + v10);
    --v9;
  }
  while ( v9 );
  dword_E1308 = (int)v1;
  return result;
}
// E1304: using guessed type int dword_E1304;
// E1308: using guessed type int dword_E1308;
// E130E: using guessed type __int16 word_E130E;
// E1310: using guessed type __int16 word_E1310;
// E1312: using guessed type __int16 word_E1312;
// E2A20: using guessed type char byte_E2A20;

//----- (00076840) --------------------------------------------------------
int sub_76840()
{
  _BYTE *v0; // edi
  char *v1; // esi
  __int16 v2; // bx
  __int16 v3; // cx
  char v4; // dl
  __int16 v5; // ax
  char v6; // dh
  char v7; // dh
  int result; // eax
  int v9; // [esp-8h] [ebp-Ch]
  int v10; // [esp-4h] [ebp-8h]
  __int16 v11; // [esp+2h] [ebp-2h]

  v11 = word_E130E;
  v0 = (_BYTE *)dword_E1304;
  v1 = (char *)dword_E1308;
  v10 = (unsigned __int16)word_E1312 - 6;
  v9 = dword_E1308;
  v2 = word_E1310;
  do
  {
    ++v1;
    v3 = v11;
    do
    {
      v4 = *v1++;
      if ( v4 > 0 )
      {
        v3 -= (unsigned __int8)v4;
      }
      else
      {
        HIBYTE(v5) = -1;
        LOBYTE(v5) = v4;
        v3 += v5;
      }
      if ( v4 > 0 )
      {
        v7 = *v1++;
        do
        {
          if ( byte_E2A20 == 1 )
          {
            if ( v7 )
              *v0 = v7;
          }
          else
          {
            *v0 = v7;
          }
          ++v0;
          --v4;
        }
        while ( v4 );
      }
      else
      {
        do
        {
          v6 = *v1++;
          if ( byte_E2A20 == 1 )
          {
            if ( v6 )
              *v0 = v6;
          }
          else
          {
            *v0 = v6;
          }
          ++v0;
          ++v4;
        }
        while ( v4 );
      }
    }
    while ( v3 );
    --v2;
  }
  while ( v2 );
  result = v10;
  dword_E1308 = v10 + v9;
  return result;
}
// E1304: using guessed type int dword_E1304;
// E1308: using guessed type int dword_E1308;
// E130E: using guessed type __int16 word_E130E;
// E1310: using guessed type __int16 word_E1310;
// E1312: using guessed type __int16 word_E1312;
// E2A20: using guessed type char byte_E2A20;

//----- (00076930) --------------------------------------------------------
int __fastcall sub_76930(int a1, int a2, __int16 *a3)
{
  byte_E29DE = word_180660;
  word_E29DC = 0;
  if ( byte_D41AD == 1 || word_E29D8 )
  {
    sub_82670();
    sub_7AC00();
  }
  if ( byte_D41AD == 1 )
  {
    sub_76A40();
    word_E29D8 = 4;
  }
  memset(&dword_17DE38, 0, 613);
  dword_17DEE0 = -1;
  sub_7BEC0();
  sub_6EDB0();
  sub_81DB0();
  do
  {
    switch ( word_E29D8 )
    {
      case 0:
        sub_76A40();
        break;
      case 1:
        sub_76CF0();
        break;
      case 2:
        _wcpp_1_unwind_leave__131();
        break;
      case 3:
        sub_76D10(0);
        break;
      case 4:
        sub_76FA0((unsigned __int16)word_E29D8, -1, a3);
        break;
      case 5:
        word_E29DC = 1;
        break;
      case 12:
        sub_779E0(0);
        break;
      default:
        break;
    }
  }
  while ( !word_E29DC );
  sub_7ADE0(byte_E29DE);
  if ( byte_E29E1 )
    byte_E29E1 = 0;
  return sub_81DB0();
}
// 76D00: using guessed type int _wcpp_1_unwind_leave__131(void);
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41AD: using guessed type char byte_D41AD;
// E29D8: using guessed type __int16 word_E29D8;
// E29DC: using guessed type __int16 word_E29DC;
// E29DE: using guessed type char byte_E29DE;
// E29E1: using guessed type char byte_E29E1;
// 17DE38: using guessed type int dword_17DE38;
// 17DEE0: using guessed type int dword_17DEE0;
// 180660: using guessed type __int16 word_180660;

//----- (00076A40) --------------------------------------------------------
int sub_76A40()
{
  int v0; // ebx
  int v1; // edi
  __int16 v2; // si
  int v3; // eax
  int v4; // ebx
  int v5; // edi
  int v6; // esi
  int result; // eax
  char v8[80]; // [esp+0h] [ebp-42h] BYREF
  char v9[80]; // [esp+50h] [ebp+Eh] BYREF
  char v10[32]; // [esp+A0h] [ebp+5Eh] BYREF
  int v11; // [esp+C0h] [ebp+7Eh] BYREF

  v11 = 0;
  memset(v8, 0, sizeof(v8));
  memset(&dword_17DE38, 0, 613);
  dword_17DEE0 = -1;
  memset(v10, 0, sizeof(v10));
  sprintf(v8, "%c%s", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherwConfigD);
  v0 = sub_98817((int)v8, 512);
  if ( v0 == -1 )
  {
    sub_7AC00();
    sub_779E0(0);
    sub_7ADE0(1);
  }
  else
  {
    sub_988A7(v0, (int)&v11, 4);
    if ( v11 == -9 )
    {
      sub_988A7(v0, (int)&v10[4], 28);
      v1 = dword_D41A4;
      qmemcpy((void *)dword_D41A4, v10, 0x14u);
      qmemcpy((void *)(v1 + 20), &v10[20], 2u);
      qmemcpy(&byte_EB39E, &v10[22], 8u);
      qmemcpy(&byte_EB39E + 8, &v10[30], 2u);
      sub_98882(v0);
      sub_8E470(*(__int16 *)(dword_D41A4 + 6));
      sub_8E410((_DWORD *)*(__int16 *)(dword_D41A4 + 8));
      v2 = 0;
      sprintf(
        v9,
        "%c%s/L%d.txt",
        *(unsigned __int8 *)(dword_D41A4 + 182),
        aNetherwLanguag,
        *(__int16 *)(dword_D41A4 + 4));
      while ( v2 < 2 )
      {
        *(_BYTE *)(dword_D41A4 + 179) = *(_BYTE *)(dword_D41A4 + 4);
        if ( byte_E29E0 || dword_D41BC )
          sub_83E80(dword_D41BC);
        v3 = sub_98817((int)v9, 512);
        v4 = v3;
        v5 = v3;
        if ( v3 != -1 )
        {
          v6 = filelength(v3) - 4785;
          dword_D41BC = sub_83CD0(v6);
          if ( dword_D41BC )
          {
            sub_9891E(v4, 4785, 0);
            sub_988A7(v4, dword_D41BC, v6);
          }
          sub_98882(v5);
          sub_5B870((_BYTE *)dword_D41BC, (int)dword_E9C4C, 471);
          break;
        }
        ++v2;
        sprintf(v9, "LANGUAGE/L%d.txt", *(unsigned __int8 *)(dword_D41A4 + 179));
      }
    }
    else
    {
      sub_98882(v0);
      sub_7AC00();
      sub_779E0(0);
      sub_7ADE0(1);
    }
  }
  result = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 179) != 2 || !byte_E3798 )
    byte_D41C0 = 1;
  word_E29D8 = 1;
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// D41A4: using guessed type int dword_D41A4;
// D41BC: using guessed type int dword_D41BC;
// D41C0: using guessed type char byte_D41C0;
// E29D8: using guessed type __int16 word_E29D8;
// E29E0: using guessed type char byte_E29E0;
// E3798: using guessed type char byte_E3798;
// E9C4C: using guessed type int dword_E9C4C[];
// EB39E: using guessed type char byte_EB39E;
// 17DE38: using guessed type int dword_17DE38;
// 17DEE0: using guessed type int dword_17DEE0;

//----- (00076CF0) --------------------------------------------------------
void sub_76CF0()
{
  word_E29D8 = 3;
}
// E29D8: using guessed type __int16 word_E29D8;

//----- (00076D10) --------------------------------------------------------
char __cdecl sub_76D10(char a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax

  dword_17DE48 = *(_DWORD *)(dword_D41A4 + 226);
  dword_17DE54 = dword_17DE48 + 301787;
  dword_17DEC0 = dword_17DE48 + 308527;
  dword_17DEC4 = (int)&algn_4BB85[dword_17DE48 + 10];
  sub_7AA70((int)aDataScreensHsc, (char *)(dword_17DE48 + 301787), (int)&unk_164FCD, 860);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC0, (int)&unk_165329, 548);
  sub_7AA70(0, 0, 0, 0);
  if ( (word_180660 & 1) != 0 )
    sub_98709(dword_17DEC0, dword_17DEC4, dword_17DE54);
  else
    sub_9874D((unsigned int *)dword_17DEC0, dword_17DEC4, dword_17DE54);
  sub_2EB40();
  if ( byte_E3798 && *(_BYTE *)(dword_D41A4 + 179) == 2 )
  {
    byte_D41C1 = 0;
    byte_D41C0 = 0;
  }
  else
  {
    byte_D41C0 = 1;
    byte_D41C1 = 1;
  }
  sub_8CD27(dword_EB394);
  sprintf(&unk_E3848, aIntroIntroDat);
  switch ( a1 )
  {
    case 0:
      sub_83850();
      sub_76160(1, 1, (int)&unk_E17CC);
      v1 = sub_2EB40();
      byte_D41C1 = 0;
      byte_D41C0 = 0;
      while ( sub_9A10A(v1) )
      {
        byte_1806E4 = 0;
        LOBYTE(v1) = sub_7A060();
      }
      j___delay(50);
      sprintf(&unk_E3848, aIntroIntro2Dat);
      goto LABEL_17;
    case 1:
      sub_76160(1, 1, (int)&unk_E17CC);
      break;
    case 2:
      byte_1806E4 = 0;
      byte_D41C1 = 0;
      byte_D41C0 = 0;
      sprintf(&unk_E3848, aIntroIntro2Dat);
LABEL_17:
      sub_76160(1, 1, (int)&unk_E192C);
      break;
  }
  sub_90B27(0, 0x10u, 0);
  sub_8D8F0();
  sub_8E020();
  sub_7B5D0();
  LOBYTE(v2) = 0;
  word_E29D8 = 4;
  byte_D41C0 = 0;
  byte_D41C1 = 0;
  v3 = sub_9A10A(v2);
  if ( v3 )
    LOBYTE(v3) = sub_7A060();
  byte_17DF11 = 0;
  byte_17DF10 = 0;
  if ( !a1 )
    LOBYTE(v3) = sub_7AC00();
  return v3;
}
// 76E60: variable 'v1' is possibly undefined
// 76F0B: variable 'v2' is possibly undefined
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 9A122: using guessed type _DWORD __cdecl j___delay(_DWORD);
// D41A4: using guessed type int dword_D41A4;
// D41C0: using guessed type char byte_D41C0;
// D41C1: using guessed type char byte_D41C1;
// E29D8: using guessed type __int16 word_E29D8;
// E3798: using guessed type char byte_E3798;
// EB394: using guessed type int dword_EB394;
// 17DE48: using guessed type int dword_17DE48;
// 17DE54: using guessed type int dword_17DE54;
// 17DEC0: using guessed type int dword_17DEC0;
// 17DEC4: using guessed type int dword_17DEC4;
// 17DF10: using guessed type char byte_17DF10;
// 17DF11: using guessed type char byte_17DF11;
// 180660: using guessed type __int16 word_180660;
// 1806E4: using guessed type char byte_1806E4;

//----- (00076F40) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn sub_76F40(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  int v7; // [esp-4h] [ebp-4h] BYREF

  ((void (__cdecl __noreturn *)(_DWORD, _DWORD, _DWORD, _DWORD, int, int, int, int, int *, int, int, int))_GETDS)(
    (unsigned __int16)__GS__,
    (unsigned __int16)__FS__,
    (unsigned __int16)__ES__,
    (unsigned __int16)__DS__,
    a1,
    a2,
    a3,
    a4,
    &v7,
    a5,
    a6,
    a7);
}
// 76F96: positive sp value 4 has been found
// 76F96: control flows out of bounds to 76F97
// 99B86: using guessed type _DWORD __cdecl __far chain_intr(_DWORD);
// 1806E4: using guessed type char byte_1806E4;

//----- (00076FA0) --------------------------------------------------------
int __fastcall sub_76FA0(int a1, int a2, __int16 *a3)
{
  __int64 v3; // rax
  int v4; // edx
  int v5; // eax
  int result; // eax
  unsigned __int16 v7; // di
  unsigned __int16 v8; // si
  int v9; // esi
  __int64 v10; // rax
  __int16 v11[14]; // [esp+0h] [ebp-24h] BYREF
  int v12; // [esp+1Ch] [ebp-8h]
  int v13; // [esp+20h] [ebp-4h]

  memset(v11, 0, sizeof(v11));
  v11[0] = 13057;
  v11[6] = 0;
  int386(33, v11, v11);
  sub_86860(word_1803EC);
  sub_84300(0);
  memset(&dword_17DBB8, 0, 16);
  byte_17DBC6 = 2;
  word_17DF04 = -1;
  dword_17DE44 = dword_E9C38;
  sub_6EDB0();
  sub_8E020();
  sub_8E160(4, 0x7Fu);
  sub_75420();
  v3 = dos_getvect(9);
  LOWORD(a3) = 256;
  word_17DE26 = WORD2(v3);
  dword_17DE22 = v3;
  dos_setvect(9, sub_76F40, (unsigned __int16)__CS__);
  BYTE4(v3) = byte_E29E1;
  if ( byte_E29E1 || (*(_BYTE *)(dword_D41A4 + 22) & 0x10) != 0 || (sub_77350(0), !word_E29DC) )
  {
    *(_BYTE *)(dword_D41A4 + 22) &= ~0x10u;
    sub_7A110(word_180660, 4);
    sub_7B5A0();
    sub_8CD27(dword_17DED4 + 234);
    LODWORD(v3) = dword_D41A4;
    byte_17DF13 = *(_BYTE *)(dword_D41A4 + 10);
    LOBYTE(v3) = byte_17DF13;
    dword_17DBB8 = j___clock(v3, HIDWORD(v3), 256);
    v12 = j___clock(dword_17DBB8, HIDWORD(v3), 256);
    v7 = dword_17DEE4;
    LODWORD(v3) = (unsigned __int8)byte_17DF10;
    v8 = HIWORD(dword_17DEE4);
    v13 = (unsigned __int8)byte_17DF10;
    while ( !word_E29DC )
    {
      LODWORD(v3) = j___clock(v3, HIDWORD(v3), (_WORD)a3);
      if ( __PAIR32__(v8, v7) == dword_17DEE4
        && (HIDWORD(v3) = (unsigned __int8)byte_17DF10, (unsigned __int8)byte_17DF10 == (_WORD)v13) )
      {
        HIDWORD(v3) = ((int)v3 - v12) % 0x64u;
        if ( ((int)v3 - v12) / 0x64u > 0x3C )
        {
          v9 = dword_E9C38;
          dword_E9C38 = dword_17DE44;
          sub_83250(SBYTE1(a3));
          dword_E9C38 = v9;
          BYTE1(a3) = (BYTE1(a3) == 1) + 1;
          v8 = HIWORD(dword_17DEE4);
          v7 = dword_17DEE4;
          byte_17DF10 = 0;
          v13 = 0;
          v12 = j___clock(0, HIDWORD(v3), (_WORD)a3);
          sub_8E020();
          LOBYTE(a3) = 0;
          sub_8E160(4, 0x7Fu);
        }
      }
      else
      {
        v8 = HIWORD(dword_17DEE4);
        v7 = dword_17DEE4;
        v13 = (unsigned __int8)byte_17DF10;
        v12 = j___clock((unsigned __int8)byte_17DF10, HIDWORD(v3), (_WORD)a3);
      }
      if ( byte_17DF10 == 59 )
      {
        LODWORD(v3) = dword_D41A4;
        BYTE5(v3) = *(_BYTE *)(dword_D41A4 + 10);
        BYTE4(v3) = BYTE5(v3) != 1;
        *(_BYTE *)(dword_D41A4 + 10) = BYTE5(v3) != 1;
        byte_17DF13 = BYTE5(v3) != 1;
        *(_BYTE *)(v3 + 38402) = 1;
      }
      if ( (word_180660 & 1) != 0 )
      {
        HIDWORD(v3) = dword_E9C38;
        sub_9A128((const void *)dword_E9C38, (void *)dword_180628, 0xC8u);
      }
      else
      {
        sub_9A144((const void *)dword_E9C38, (void *)dword_180628, 0x1E0u);
      }
      LOWORD(v3) = sub_7C120(185, 232, dword_17DED4 + 396);
      LODWORD(v3) = sub_7AB00(v3, SHIDWORD(v3), a3, 4u);
      if ( sub_7B250(v3, SHIDWORD(v3), (__int16)a3) )
      {
        v8 = HIWORD(dword_17DEE4);
        v7 = dword_17DEE4;
        LOBYTE(a3) = 0;
        v13 = (unsigned __int8)byte_17DF10;
        v12 = j___clock((unsigned __int8)byte_17DF10, HIDWORD(v3), (_WORD)a3);
      }
      if ( (_BYTE)a3 )
      {
        if ( (word_180660 & 1) != 0 )
          sub_90478();
        else
          sub_75200(480);
      }
      else
      {
        HIDWORD(v3) = dword_17DE38;
        LOBYTE(a3) = 1;
        sub_90B27((char *)dword_17DE38, 0x20u, 0);
      }
      LOBYTE(v3) = sub_7A060();
    }
    v10 = sub_41BC0();
    *(_BYTE *)(dword_D41A0 + 8592) = 0;
    LODWORD(v10) = dos_setvect(9, dword_17DE22, (unsigned __int16)word_17DE26);
    sub_753D0(v10, SHIDWORD(v10));
    result = dword_17DE44;
    dword_E9C38 = dword_17DE44;
  }
  else
  {
    sub_41BC0();
    *(_BYTE *)(dword_D41A0 + 8592) = 0;
    v4 = dword_17DE22;
    v5 = dos_setvect(9, dword_17DE22, (unsigned __int16)word_17DE26);
    return sub_753D0(v5, v4);
  }
  return result;
}
// 7713D: variable 'v3' is possibly undefined
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 99BA7: using guessed type __int64 __cdecl dos_getvect(_DWORD);
// 99BDB: using guessed type _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E29DC: using guessed type __int16 word_E29DC;
// E29E1: using guessed type char byte_E29E1;
// E9C38: using guessed type int dword_E9C38;
// 17DBB8: using guessed type int dword_17DBB8;
// 17DBC6: using guessed type char byte_17DBC6;
// 17DE22: using guessed type int dword_17DE22;
// 17DE26: using guessed type __int16 word_17DE26;
// 17DE38: using guessed type int dword_17DE38;
// 17DE44: using guessed type int dword_17DE44;
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DF04: using guessed type __int16 word_17DF04;
// 17DF10: using guessed type char byte_17DF10;
// 17DF13: using guessed type char byte_17DF13;
// 1803EC: using guessed type __int16 word_1803EC;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (00077350) --------------------------------------------------------
char __cdecl sub_77350(int a1)
{
  unsigned __int16 v1; // bx
  char v2; // cl
  unsigned __int8 v4; // al
  unsigned __int8 v5; // al
  int v6; // eax
  char v7; // bl

  v1 = 0;
  v2 = *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232);
  word_E29D6 = 0;
  if ( (v2 & 2) != 0 && *(_WORD *)(dword_D41A4 + 43) == 24 )
    sub_833C0();
  memset(dword_17DBA8, 0, 16);
  byte_17DBB6 = 2;
  if ( byte_D419C <= -1 )
  {
    byte_17E09D = 0;
    byte_17E083 = 16;
    word_17E06E = 480;
    word_17E080 = 13;
    byte_17E09C = 0;
    byte_17E082 = 13;
    word_17E06C = 0;
    memset(&dword_17DB70, 0, 56);
    if ( (*(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) & 2) != 0 )
      byte_17DB8F = 4;
    else
      byte_17DB8F = 1;
    sub_7A110(word_180660, 6);
    sub_8CD27(dword_EB394);
    sub_7B5A0();
    sub_90B27(0, 0x10u, 0);
    if ( (word_180660 & 1) != 0 )
    {
      v4 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, 0);
      sub_72883(v4, (void *)dword_180628, 0xC8u, v4);
    }
    else
    {
      v5 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, 0);
      sub_728A9(v5, (void *)dword_180628, 0x1E0u, v5);
    }
    if ( (word_180660 & 1) != 0 )
      sub_90478();
    else
      sub_75200(480);
    sub_41A90((unsigned __int8 *)dword_17DE38);
    sub_7DD70();
    word_17DEEC = 0;
    sub_6EDB0();
    sub_8CD27(dword_17DED4 + 1434);
    word_17DB8A = *(_WORD *)(dword_D41A4 + 43);
    while ( !v1 )
    {
      if ( byte_17DF10 == 59 )
      {
        v6 = dword_D41A4;
        v7 = *(_BYTE *)(dword_D41A4 + 10);
        *(_BYTE *)(dword_D41A4 + 10) = v7 != 1;
        byte_17DF13 = v7 != 1;
        *(_BYTE *)(v6 + 38402) = 1;
      }
      v1 = sub_7EAE0(&word_17DB76, word_17DB78, &word_17DB7E, &word_17DB80, &byte_17DB8F, word_17DB90);
      if ( (word_180660 & 1) != 0 )
        sub_90478();
      else
        sub_75200(480);
      sub_7A060();
    }
    sub_86860(word_1803EC);
    *(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) = 0;
    sub_8D8F0();
    word_E29D6 = 0;
    if ( v1 <= 1u )
    {
      word_E29DC = 1;
      if ( a1 )
        *(_DWORD *)(a1 + 4) = 0;
    }
    else if ( v1 == 2 && a1 )
    {
      *(_DWORD *)(a1 + 4) = 1;
    }
    sub_8CD27(dword_EB394);
    sub_90B27(0, 0x10u, 0);
    return 1;
  }
  else
  {
    word_E29DC = 1;
    *(_WORD *)(dword_D41A4 + 43) = byte_D419C;
    if ( a1 )
      *(_DWORD *)(a1 + 4) = 0;
    return 1;
  }
}
// 77620: conditional instruction was optimized away because bx.2!=0
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D419C: using guessed type char byte_D419C;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E29D6: using guessed type __int16 word_E29D6;
// E29DC: using guessed type __int16 word_E29DC;
// EB394: using guessed type int dword_EB394;
// 17DB70: using guessed type int dword_17DB70;
// 17DB76: using guessed type __int16 word_17DB76;
// 17DB78: using guessed type __int16 word_17DB78[3];
// 17DB7E: using guessed type __int16 word_17DB7E;
// 17DB80: using guessed type __int16 word_17DB80;
// 17DB8A: using guessed type __int16 word_17DB8A;
// 17DB8F: using guessed type char byte_17DB8F;
// 17DB90: using guessed type __int16 word_17DB90[12];
// 17DBA8: using guessed type int dword_17DBA8[3];
// 17DBB6: using guessed type char byte_17DBB6;
// 17DE38: using guessed type int dword_17DE38;
// 17DED4: using guessed type int dword_17DED4;
// 17DEEC: using guessed type __int16 word_17DEEC;
// 17DF10: using guessed type char byte_17DF10;
// 17DF13: using guessed type char byte_17DF13;
// 17E06C: using guessed type __int16 word_17E06C;
// 17E06E: using guessed type __int16 word_17E06E;
// 17E080: using guessed type __int16 word_17E080;
// 17E082: using guessed type char byte_17E082;
// 17E083: using guessed type char byte_17E083;
// 17E09C: using guessed type char byte_17E09C;
// 17E09D: using guessed type char byte_17E09D;
// 1803EC: using guessed type __int16 word_1803EC;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (00077680) --------------------------------------------------------
char __fastcall sub_77680(int a1, int a2, __int16 *a3)
{
  unsigned int v4; // edx
  int v5; // eax
  int v6; // eax
  char *v8; // esi
  char v9[80]; // [esp+0h] [ebp-4h] BYREF
  _DWORD v10[13]; // [esp+50h] [ebp+4Ch] BYREF

  word_E2094 = (unsigned __int8)byte_E2096;
  memset(v9, 0, sizeof(v9));
  memset(&v10[9], 0, 16);
  BYTE2(v10[12]) = 2;
  sprintf(v9, "NETH%d", (unsigned __int16)word_17DEFA + 20);
  LOWORD(a3) = 0;
  word_17DEFC = sub_7308F(a2, a3, (int)v9, 8);
  if ( word_17DEFC == -1 )
  {
    sub_8CD27(dword_17DED4 + 234);
    return 0;
  }
  else
  {
    sub_7A110(word_180660, 7);
    word_17DEFE = 0;
    sub_8CD27(dword_EB394);
    dword_17DEDC = 0;
    word_17DEEE = 0;
    sub_7B5A0();
    memset(byte_17DE68, 0, 88);
    memset(v9, 0, sizeof(v9));
    word_17DEF6 = 5;
    word_17DEEC = 0;
    sub_6EDB0();
    dword_17DEE4 = 15728960;
    v4 = 240;
    if ( *(_WORD *)(dword_D41A4 + 43) >= 0x32u )
    {
      v4 = 11 * word_17DEFC;
      byte_17DE72[v4] = *(_BYTE *)(dword_D41A4 + 43);
    }
    else
    {
      byte_17DE72[11 * word_17DEFC] = 50;
    }
    BYTE1(v4) = 2;
    byte_17DE71[11 * word_17DEFC] = 2;
    word_17DEEE = 0;
    while ( !BYTE1(a3) )
    {
      if ( byte_17DF10 == 59 )
      {
        v5 = dword_D41A4;
        LOBYTE(v4) = *(_BYTE *)(dword_D41A4 + 10) != 1;
        *(_BYTE *)(dword_D41A4 + 10) = v4;
        *(_BYTE *)(v5 + 38402) = 1;
      }
      BYTE1(a3) = sub_7C390();
      v6 = dword_D41A4;
      if ( *(_BYTE *)(dword_D41A4 + 10) == 1 )
      {
        LOBYTE(v6) = BYTE2(v10[12]);
        if ( BYTE2(v10[12]) == 2 )
        {
          v10[10] = j___clock(v6, v4, (_WORD)a3);
          if ( (v10[10] - v10[9]) / 0x64u > 1 )
          {
            if ( !word_E2572[9 * (__int16)++LOWORD(v10[12])] )
              LOWORD(v10[12]) = 0;
            v10[9] = v10[10];
          }
          memset(v10, 0, 36);
          v4 = SLOWORD(v10[12]);
          v8 = (char *)&unk_E2570 + 18 * SLOWORD(v10[12]);
          qmemcpy(v10, v8, 0x10u);
          qmemcpy(&v10[4], v8 + 16, 2u);
          sub_7E840((__int16 *)v10, 21, 27);
        }
        else if ( BYTE2(v10[12]) == 3 )
        {
          v10[10] = j___clock(v6, v4, (_WORD)a3);
          v4 = (v10[10] - v10[9]) % 0x64u;
          if ( (v10[10] - v10[9]) / 0x64u > 1 )
            BYTE2(v10[12]) = 2;
        }
      }
      if ( !(_BYTE)a3 )
      {
        sub_90B27((char *)dword_17DE38, 0x20u, 0);
        LOBYTE(a3) = 1;
        sub_8CD27(dword_17DED4 + 90);
      }
      if ( (word_180660 & 1) != 0 )
        sub_90478();
      else
        sub_75200(480);
      sub_7A060();
    }
    sub_7B5D0();
    sub_7AA70(0, 0, 0, 0);
    sub_7C710();
    return 1;
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98786: using guessed type __int64 __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E2094: using guessed type __int16 word_E2094;
// E2096: using guessed type char byte_E2096;
// E2572: using guessed type __int16 word_E2572[53];
// EB394: using guessed type int dword_EB394;
// 17DE38: using guessed type int dword_17DE38;
// 17DED4: using guessed type int dword_17DED4;
// 17DEDC: using guessed type int dword_17DEDC;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEC: using guessed type __int16 word_17DEEC;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DEF6: using guessed type __int16 word_17DEF6;
// 17DEFA: using guessed type __int16 word_17DEFA;
// 17DEFC: using guessed type __int16 word_17DEFC;
// 17DEFE: using guessed type __int16 word_17DEFE;
// 17DF10: using guessed type char byte_17DF10;
// 180660: using guessed type __int16 word_180660;

//----- (00077980) --------------------------------------------------------
char __usercall sub_77980@<al>(int a1@<edx>, int a2)
{
  __int16 v2; // ax
  char v3; // bl

  v2 = sub_7BF20(a1, (__int16 *)(a2 + 26));
  v3 = v2;
  if ( v2 == 1 )
  {
    word_E29DC = 1;
    *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11234) = 1;
  }
  else if ( v2 == 2 )
  {
    v3 = 1;
    sub_7C020((_WORD *)(a2 + 26));
  }
  return v3;
}
// D41A0: using guessed type int dword_D41A0;
// E29DC: using guessed type __int16 word_E29DC;

//----- (000779E0) --------------------------------------------------------
char __cdecl sub_779E0(int a1)
{
  unsigned int v1; // ebx
  int v2; // eax
  const char *v3; // eax
  int v4; // esi
  unsigned int v5; // edx
  int v6; // eax
  int v7; // eax
  char *v8; // esi
  __int16 v9; // si
  __int16 v10; // ax
  int v11; // esi
  char v12; // al
  int v13; // ebx
  int v14; // eax
  int v15; // eax
  char v17[160]; // [esp+0h] [ebp-142h] BYREF
  char v18[80]; // [esp+A0h] [ebp-A2h] BYREF
  char v19[30]; // [esp+F0h] [ebp-52h] BYREF
  char v20[14]; // [esp+10Eh] [ebp-34h] BYREF
  char v21[30]; // [esp+11Ch] [ebp-26h] BYREF
  char v22; // [esp+13Ah] [ebp-8h] BYREF
  __int16 v23[18]; // [esp+148h] [ebp+6h] BYREF
  int v24[12]; // [esp+16Ch] [ebp+2Ah] BYREF
  unsigned int v25; // [esp+19Ch] [ebp+5Ah] BYREF
  int v26; // [esp+1A0h] [ebp+5Eh] BYREF
  unsigned int *v27; // [esp+1A4h] [ebp+62h] BYREF
  unsigned int *v28; // [esp+1A8h] [ebp+66h]
  unsigned int v29; // [esp+1ACh] [ebp+6Ah]
  int v30; // [esp+1B0h] [ebp+6Eh]
  int v31; // [esp+1B4h] [ebp+72h]
  __int16 v32; // [esp+1B8h] [ebp+76h] BYREF
  int v33; // [esp+1BCh] [ebp+7Ah]

  v26 = 0;
  v33 = 0;
  v32 = 0;
  v31 = 0;
  sprintf(v18, "%c%s", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherwConfigD);
  memset(v24, 0, sizeof(v24));
  qmemcpy(v24, (const void *)dword_D41A4, 0x14u);
  qmemcpy(&v24[5], (const void *)(dword_D41A4 + 20), 2u);
  BYTE2(v24[11]) = 2;
  sub_6EDB0();
  dword_17DEE4 = 13107520;
  if ( a1 )
  {
    sub_7A110(word_180660, 12);
    v1 = dword_E9C38 + 307200;
  }
  else
  {
    v30 = dword_E9C38;
    dword_E9C38 = *(_DWORD *)(dword_D41A4 + 226);
    v1 = dword_E9C38 + 307200;
    sub_7A110(word_180660, 14);
  }
  sub_7B5A0();
  sub_8CD27(dword_EB394);
  word_17DEEC = 0;
  if ( !unknown_libname_2(aLanguageLTxt, 0, v19) )
  {
    v2 = unknown_libname_2(aLanguageDTxt, 0, v21);
    if ( a1 || v2 )
      v3 = v20;
    else
      v3 = &v22;
    *(_BYTE *)(dword_D41A4 + 179) = sub_7F7D0((unsigned int *)&v27, &v25, v1, v3);
    unknown_libname_4(v21);
    v28 = v27;
    v29 = v25;
    if ( a1 )
    {
      v4 = sub_98817((int)v18, 512);
      if ( v4 != -1 )
      {
        sub_988A7(v4, (int)&v26, 4);
        if ( v26 == -9 )
        {
          sub_988A7(v4, (int)&v32, 2);
          sprintf(v17, "L%d.TXT", v32);
          *(_BYTE *)(dword_D41A4 + 179) = sub_7F960(v28, v29, v1, v17);
        }
        sub_98882(v4);
      }
    }
    sub_7B5A0();
    v5 = 0;
    word_17DEEE = 0;
    sub_8CD27(dword_17DED4 + 222);
    while ( (_WORD)v31 != 2 )
    {
      if ( byte_17DF10 == 59 )
      {
        v6 = dword_D41A4;
        BYTE1(v5) = *(_BYTE *)(dword_D41A4 + 10);
        LOBYTE(v5) = BYTE1(v5) != 1;
        *(_BYTE *)(dword_D41A4 + 10) = BYTE1(v5) != 1;
        *(_BYTE *)(v6 + 38402) = 1;
      }
      if ( (word_180660 & 1) != 0 )
      {
        sub_9A128((const void *)dword_E9C38, (void *)dword_180628, 0xC8u);
      }
      else
      {
        v5 = dword_E9C38;
        sub_9A144((const void *)dword_E9C38, (void *)dword_180628, 0x1E0u);
      }
      v31 = sub_7E0E0();
      sub_2BB40(263, 134, (int)v28 + 6);
      v7 = dword_D41A4;
      if ( *(_BYTE *)(dword_D41A4 + 10) == 1 )
      {
        LOBYTE(v7) = BYTE2(v24[11]);
        if ( BYTE2(v24[11]) == 2 )
        {
          v24[9] = j___clock(v7, v5, v1);
          v5 = (v24[9] - v24[8]) % 0x64u;
          if ( (v24[9] - v24[8]) / 0x64u > 1 )
          {
            ++LOWORD(v24[11]);
            if ( !word_E24BE[9 * SLOWORD(v24[11])] )
              LOWORD(v24[11]) = 0;
            v24[8] = v24[9];
          }
          memset(v23, 0, sizeof(v23));
          v8 = (char *)&unk_E24BC + 18 * SLOWORD(v24[11]);
          qmemcpy(v23, v8, 0x10u);
          qmemcpy(&v23[8], v8 + 16, sizeof(__int16));
          sub_7E840(v23, 83, 100);
        }
        else if ( BYTE2(v24[11]) == 3 )
        {
          v24[9] = j___clock(v7, v5, v1);
          v5 = (v24[9] - v24[8]) % 0x64u;
          if ( (v24[9] - v24[8]) / 0x64u > 1 )
            BYTE2(v24[11]) = 2;
        }
      }
      if ( (_WORD)v33 )
      {
        if ( (word_180660 & 1) != 0 )
          sub_90478();
        else
          sub_75200(480);
      }
      else
      {
        sub_90B27((char *)dword_17DE38, 0x20u, 0);
        ++v33;
      }
      v9 = v31;
      sub_7A060();
      if ( v9 == 1 )
      {
        if ( unknown_libname_3(v19) )
        {
          unknown_libname_4(v19);
          unknown_libname_2(aLanguageLTxt, 0, v19);
        }
        v5 = (unsigned int)v28;
        v10 = sub_7F960(v28, v29, v1, v20);
        v11 = dword_D41A4;
        v32 = v10;
        if ( *(unsigned __int8 *)(dword_D41A4 + 179) == v10 )
        {
          if ( unknown_libname_3(v19) )
          {
            unknown_libname_4(v19);
            unknown_libname_2(aLanguageLTxt, 0, v19);
          }
          v12 = sub_7F960(v28, v29, v1, v20);
          v11 = dword_D41A4;
        }
        else
        {
          v12 = v32;
        }
        *(_BYTE *)(v11 + 179) = v12;
      }
    }
  }
  unknown_libname_4(v19);
  v13 = sub_98817((int)v18, 546);
  if ( v13 != -1 )
  {
    if ( *(_BYTE *)(dword_D41A4 + 38402) == 1 )
      *(_BYTE *)(dword_D41A4 + 38402) = 0;
    qmemcpy(v24, (const void *)dword_D41A4, 0x14u);
    qmemcpy(&v24[5], (const void *)(dword_D41A4 + 20), 2u);
    qmemcpy((char *)&v24[5] + 2, &byte_EB39E, 8u);
    qmemcpy((char *)&v24[7] + 2, &byte_EB39E + 8, 2u);
    v24[0] = -9;
    LOWORD(v24[1]) = *(unsigned __int8 *)(dword_D41A4 + 179);
    sub_98CAA(v13, (int)v24, 32);
    sub_98882(v13);
  }
  LOWORD(v14) = sub_90B27(0, 0x10u, 0);
  if ( (word_180660 & 1) != 0 )
    v15 = sub_72883(dword_180628, (void *)dword_180628, 0xC8u, 0);
  else
    v15 = sub_728A9(v14, (void *)dword_180628, 0x1E0u, 0);
  if ( (word_180660 & 1) != 0 )
    sub_72883(v15, (void *)dword_E9C38, 0xC8u, 0);
  else
    sub_728A9(v15, (void *)dword_E9C38, 0x1E0u, 0);
  sub_7B5A0();
  if ( (word_180660 & 1) != 0 )
    sub_90478();
  else
    sub_75200(480);
  if ( a1 )
  {
    sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, 0, 768);
    sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE40, dword_17DEDC, 168081);
    sub_41A90((unsigned __int8 *)dword_17DE38);
    sub_8CD27(dword_EB394);
    sub_8CD27(dword_17DED4 + 234);
    if ( (word_180660 & 1) != 0 )
      sub_9A128((const void *)dword_180628, (void *)dword_E9C38, 0xC8u);
    else
      sub_9A144((const void *)dword_180628, (void *)dword_E9C38, 0x1E0u);
    sub_7C120(185, 232, dword_17DED4 + 396);
  }
  else
  {
    dword_E9C38 = v30;
  }
  sub_7AA70(0, 0, 0, 0);
  return 1;
}
// 77F86: variable 'v14' is possibly undefined
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 9A166: using guessed type _DWORD __cdecl unknown_libname_2(_DWORD, _DWORD, _DWORD);
// 9A193: using guessed type _DWORD __cdecl unknown_libname_3(_DWORD);
// 9A1B3: using guessed type int __cdecl unknown_libname_4(_DWORD);
// D41A4: using guessed type int dword_D41A4;
// E24BE: using guessed type __int16 word_E24BE[26];
// E9C38: using guessed type int dword_E9C38;
// EB394: using guessed type int dword_EB394;
// EB39E: using guessed type char byte_EB39E;
// 17DE38: using guessed type int dword_17DE38;
// 17DE40: using guessed type int dword_17DE40;
// 17DED4: using guessed type int dword_17DED4;
// 17DEDC: using guessed type int dword_17DEDC;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEC: using guessed type __int16 word_17DEEC;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;
// 779E0: using guessed type __int16 var_78[18];

//----- (000780F0) --------------------------------------------------------
char __cdecl sub_780F0(int a1)
{
  int v1; // edx
  _WORD *v2; // ebx
  char *v3; // esi
  char *v4; // edi
  char v5; // al
  char v6; // al
  int v7; // eax
  int v8; // esi
  int v9; // eax
  int v10; // esi
  __int16 *v11; // edi
  __int16 v12; // ax
  _WORD *v13; // esi
  _WORD *v14; // eax
  __int16 j; // si
  char *v16; // eax
  __int16 v17; // si
  char v18; // cl
  int k; // esi
  int v20; // eax
  unsigned __int8 v21; // di
  __int16 v22; // ax
  __int16 v23; // di
  __int16 m; // si
  __int16 v25; // di
  char v26; // ch
  __int16 v27; // ax
  __int16 v29; // [esp-8h] [ebp-5Eh]
  __int16 v30; // [esp-8h] [ebp-5Eh]
  unsigned __int8 v31; // [esp-4h] [ebp-5Ah]
  unsigned __int8 v32; // [esp-4h] [ebp-5Ah]
  char v33[80]; // [esp+0h] [ebp-56h] BYREF
  _WORD v34[22]; // [esp+50h] [ebp-6h] BYREF
  char v35[12]; // [esp+7Ch] [ebp+26h] BYREF
  int v36; // [esp+88h] [ebp+32h]
  char v37[4]; // [esp+90h] [ebp+3Ah] BYREF
  int v38; // [esp+94h] [ebp+3Eh] BYREF
  int v39; // [esp+98h] [ebp+42h] BYREF
  int v40; // [esp+9Ch] [ebp+46h] BYREF
  int v41; // [esp+A0h] [ebp+4Ah]
  _BYTE *v42; // [esp+A4h] [ebp+4Eh]
  int v43; // [esp+A8h] [ebp+52h]
  int v44; // [esp+ACh] [ebp+56h]
  int v45; // [esp+B0h] [ebp+5Ah]
  _BYTE *v46; // [esp+B4h] [ebp+5Eh]
  __int16 v47; // [esp+B8h] [ebp+62h]
  int v48; // [esp+BCh] [ebp+66h]
  int v49; // [esp+C0h] [ebp+6Ah]
  int i; // [esp+C4h] [ebp+6Eh]
  __int16 v51; // [esp+C8h] [ebp+72h]
  unsigned __int8 v52; // [esp+CCh] [ebp+76h]
  unsigned __int8 v53; // [esp+D0h] [ebp+7Ah]

  v38 = 0;
  v40 = 0;
  v1 = 0;
  v51 = 0;
  v2 = (_WORD *)(a1 + 26);
  v53 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x3Fu, 0x3Fu, 0x3Fu);
  v52 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x16u, 0x10u, 9u);
  if ( word_17DF04 == -1 )
  {
    for ( i = 1; (__int16)i < 9; ++i )
    {
      v1 = (__int16)i;
      v44 = 43 * ((__int16)i - 1);
      v3 = (char *)dword_EA2C4;
      v4 = &byte_17DF14[v44];
      v42 = &byte_17DF14[v44];
      do
      {
        v5 = *v3;
        *v4 = *v3;
        if ( !v5 )
          break;
        v6 = v3[1];
        v3 += 2;
        v4[1] = v6;
        v4 += 2;
      }
      while ( v6 );
      v7 = v44;
      byte_17DF3D[v44] = 0;
      byte_17DF3E[v7] = 0;
      sprintf(v33, "%c:%s/save/save%d.gam", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_5, v1);
      v8 = sub_98817((int)v33, 512);
      if ( v8 != -1 )
      {
        sub_988A7(v8, (int)&v39, 4);
        if ( v39 == -9 )
        {
          v1 = (int)v42;
          sub_988A7(v8, (int)v42, 20);
          LOBYTE(v1) = 1;
          byte_17DF3D[v44] = 1;
        }
        sub_98882(v8);
      }
    }
    word_17DF04 = 0;
  }
  v47 = sub_7BF20(v1, (__int16 *)(a1 + 26));
  if ( (_BYTE)v47 )
  {
    sub_7C020((_WORD *)(a1 + 26));
    if ( (_BYTE)v47 == 1 && word_17DF04 > 0 )
    {
      sprintf(v33, "%c:%s/save/save%d.gam", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_5, word_17DF04);
      v9 = sub_98817((int)v33, 512);
      v10 = v9;
      if ( v9 != -1 )
      {
        sub_988A7(v9, (int)&v39, 4);
        if ( v39 == -9 )
        {
          if ( *(_BYTE *)(a1 + 25) )
            sub_7E640((int)&v39, 0);
          sub_988A7(v10, (int)&byte_17DF14[43 * word_17DF04 - 43], 20);
          sub_988A7(v10, dword_D41A4 + 57, 32);
          v11 = word_E2970;
          sub_988A7(v10, dword_D41A4 + 89, 32);
          while ( v11 < &word_E29D6 )
          {
            sub_988A7(v10, (int)v35, 17);
            v12 = v36;
            v11[6] = v36;
            if ( v12 == 1 )
              v11[7] = 305;
            else
              v11[7] = 270;
            v11 = (__int16 *)((char *)v11 + 17);
          }
          sub_988A7(v10, dword_D41A0 + 8586, 16);
          sub_988A7(v10, (int)&v38, 4);
          sub_988A7(v10, (int)&v40, 4);
          sub_988A7(v10, 2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230 + 1609, 505);
          sub_988A7(v10, (int)dword_17DBC8, 500);
          sub_988A7(v10, (int)dword_17DDBC, 100);
          sub_98882(v10);
          v13 = &unk_E1960;
          *(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) = 0;
          while ( v13[2] )
          {
            v13 += 11;
            *((_BYTE *)v13 - 4) = 2;
          }
          v14 = &unk_E1960;
          for ( j = 0; j < v38 && v14[2]; ++j )
          {
            v14 += 11;
            *((_BYTE *)v14 - 4) = 1;
          }
          v16 = (char *)&unk_E1960;
          v17 = 0;
          while ( *((_WORD *)v16 + 2) )
          {
            if ( v16[18] == 1 )
              *(_WORD *)(dword_D41A4 + 43) = v17;
            v16 += 22;
            ++v17;
          }
          byte_17DB8F = 1;
          memset(&dword_17DE28, 0, 13);
          v18 = *(_BYTE *)(a1 + 25);
          word_17DB8A = -1;
          if ( v18 )
          {
            sub_81760(a1);
          }
          else
          {
            word_17DF04 = -1;
            sub_77350(a1);
            *(_DWORD *)(a1 + 4) = 2;
          }
        }
      }
    }
    word_17DF04 = -1;
    v51 = 1;
  }
  for ( k = 1; (__int16)k < 9; ++k )
  {
    sub_6FC50(1);
    if ( *(__int16 *)(a1 + 36) > 16 * (__int16)k + 3 * sub_6FC30() )
    {
      sprintf(v37, "%d.", (__int16)k);
      v49 = 16 * k;
      v20 = 43 * ((__int16)k - 1);
      v46 = &byte_17DF14[v20];
      if ( (_WORD)k == word_17DF04 )
      {
        LOWORD(v20) = *v2;
        v48 = v20 + 20;
        v23 = v49 + *(_WORD *)(a1 + 28) + 16;
        v43 = v53;
        sub_2BC10(v37, v20 + 20, v23, v53);
        v31 = v43;
        v29 = v23;
        v22 = v48 + 3 * sub_6FC10();
      }
      else
      {
        v21 = v52;
        sub_2BC10(v37, *(_WORD *)(a1 + 26) + 20, v49 + *(_WORD *)(a1 + 28) + 16, v52);
        v31 = v21;
        v29 = v49 + *(_WORD *)(a1 + 28) + 16;
        v22 = *v2 + 20 + 3 * sub_6FC10();
      }
      sub_2BC10(v46, v22, v29, v31);
    }
  }
  if ( *(_WORD *)(a1 + 36) >= *(_WORD *)(a1 + 34) )
  {
    for ( m = 1; m < 9; ++m )
    {
      v34[5] = *v2 + 20;
      v25 = 16 * m;
      v34[6] = 16 * m + *(_WORD *)(a1 + 28) + 16;
      v34[7] = 100;
      v41 = m;
      v34[8] = 16;
      v26 = byte_17DF3D[43 * m - 43];
      v45 = 43 * (m - 1);
      if ( v26 && sub_7B200(v34, dword_17DEE4, SHIWORD(dword_17DEE4)) )
      {
        if ( (word_17DEEE & 1) != 0 )
        {
          word_17DF04 = m;
        }
        else
        {
          sprintf(v37, "%d.", v41);
          v43 = v53;
          sub_2BC10(v37, *(_WORD *)(a1 + 26) + 20, v25 + *(_WORD *)(a1 + 28) + 16, v53);
          v32 = v43;
          v30 = v25 + *(_WORD *)(a1 + 28) + 16;
          v27 = sub_6FC10();
          sub_2BC10(&byte_17DF14[v45], *v2 + 20 + 3 * v27, v30, v32);
        }
      }
    }
  }
  return v51;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E2970: using guessed type _WORD word_E2970[51];
// E29D6: using guessed type __int16 word_E29D6;
// EA2C4: using guessed type int dword_EA2C4;
// 17DB8A: using guessed type __int16 word_17DB8A;
// 17DB8F: using guessed type char byte_17DB8F;
// 17DBC8: using guessed type int dword_17DBC8[];
// 17DDBC: using guessed type int dword_17DDBC[];
// 17DE28: using guessed type int dword_17DE28;
// 17DE38: using guessed type int dword_17DE38;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF04: using guessed type __int16 word_17DF04;
// 17DF14: using guessed type _BYTE byte_17DF14[40];
// 780F0: using guessed type char var_58[12];
// 780F0: using guessed type char var_44[4];

//----- (00078730) --------------------------------------------------------
char __cdecl sub_78730(_WORD *a1)
{
  int v1; // edx
  __int16 *v2; // ebx
  char *v3; // esi
  char *v4; // edi
  char v5; // al
  char v6; // al
  int v7; // esi
  char *v8; // edi
  char *v9; // esi
  char v10; // al
  char v11; // al
  int v12; // esi
  _WORD *v13; // eax
  int j; // esi
  int v15; // eax
  char *v16; // edi
  int v17; // eax
  __int16 v18; // ax
  char *v19; // esi
  _BYTE *v20; // edi
  char v21; // al
  char v22; // al
  int v23; // eax
  int v24; // edi
  unsigned __int8 v25; // si
  __int16 v26; // ax
  int v27; // eax
  int v28; // eax
  char *v29; // eax
  int v30; // edx
  __int16 v31; // ax
  __int16 v33; // [esp-10h] [ebp-52h]
  __int16 v34; // [esp-Ch] [ebp-4Eh]
  __int16 v35; // [esp-Ch] [ebp-4Eh]
  char *v36; // [esp-Ch] [ebp-4Eh]
  __int16 v37; // [esp-8h] [ebp-4Ah]
  __int16 v38; // [esp-8h] [ebp-4Ah]
  __int16 v39; // [esp-8h] [ebp-4Ah]
  _BYTE *v40; // [esp-8h] [ebp-4Ah]
  int v41; // [esp-4h] [ebp-46h]
  unsigned __int8 v42; // [esp-4h] [ebp-46h]
  unsigned __int8 v43; // [esp-4h] [ebp-46h]
  unsigned __int8 v44; // [esp-4h] [ebp-46h]
  char v45[80]; // [esp+0h] [ebp-42h] BYREF
  _WORD v46[22]; // [esp+50h] [ebp+Eh] BYREF
  char v47[4]; // [esp+7Ch] [ebp+3Ah] BYREF
  int v48; // [esp+80h] [ebp+3Eh] BYREF
  int v49; // [esp+84h] [ebp+42h] BYREF
  int v50; // [esp+88h] [ebp+46h] BYREF
  int v51; // [esp+8Ch] [ebp+4Ah]
  int v52; // [esp+90h] [ebp+4Eh]
  int v53; // [esp+94h] [ebp+52h]
  __int16 v54; // [esp+98h] [ebp+56h]
  __int16 v55; // [esp+9Ch] [ebp+5Ah]
  int v56; // [esp+A0h] [ebp+5Eh]
  int v57; // [esp+A4h] [ebp+62h]
  int v58; // [esp+A8h] [ebp+66h]
  int v59; // [esp+ACh] [ebp+6Ah]
  int i; // [esp+B0h] [ebp+6Eh]
  int k; // [esp+B4h] [ebp+72h]
  unsigned __int8 v62; // [esp+B8h] [ebp+76h]
  unsigned __int8 v63; // [esp+BCh] [ebp+7Ah]

  v55 = 0;
  v1 = dword_17DE38;
  v63 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x3Fu, 0x3Fu, 0x3Fu);
  v62 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x16u, 0x10u, 9u);
  v2 = a1 + 13;
  if ( word_17DF04 == -1 )
  {
    for ( i = 1; (__int16)i < 9; ++i )
    {
      v1 = (__int16)i;
      v3 = (char *)dword_EA2C4;
      v4 = &byte_17DF14[43 * (__int16)i - 43];
      v41 = (int)v4;
      do
      {
        v5 = *v3;
        *v4 = *v3;
        if ( !v5 )
          break;
        v6 = v3[1];
        v3 += 2;
        v4[1] = v6;
        v4 += 2;
      }
      while ( v6 );
      v51 = v41;
      sprintf(v45, "%c:%s/save/save%d.gam", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_5, v1);
      v7 = sub_98817((int)v45, 512);
      if ( v7 != -1 )
      {
        sub_988A7(v7, (int)&v49, 4);
        if ( v49 == -9 )
          sub_988A7(v7, v51, 20);
        sub_98882(v7);
      }
    }
    word_17DF04 = 0;
  }
  v54 = sub_7BF20(v1, v2);
  if ( (_BYTE)v54 )
  {
    sub_7C020(v2);
    if ( (_BYTE)v54 == 1 && word_17DF04 > 0 )
    {
      v8 = &byte_17DF14[43 * word_17DF04 - 43];
      v9 = v8 + 20;
      do
      {
        v10 = *v9;
        *v8 = *v9;
        if ( !v10 )
          break;
        v11 = v9[1];
        v9 += 2;
        v8[1] = v11;
        v8 += 2;
      }
      while ( v11 );
      sprintf(v45, "%c:%s/save/save%d.gam", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherw_5, word_17DF04);
      v12 = sub_98817((int)v45, 546);
      if ( v12 != -1 )
      {
        v13 = &unk_E1960;
        v49 = -9;
        v50 = 0;
        while ( v13[2] && *((_BYTE *)v13 + 18) != 2 )
        {
          v13 += 11;
          ++v50;
        }
        v48 = *(__int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232);
        sub_98CAA(v12, (int)&v49, 4);
        sub_98CAA(v12, (int)&byte_17DF14[43 * word_17DF04 - 43], 20);
        sub_98CAA(v12, dword_D41A4 + 57, 32);
        sub_98CAA(v12, dword_D41A4 + 89, 32);
        sub_98CAA(v12, (int)word_E2970, 102);
        sub_98CAA(v12, dword_D41A0 + 8586, 16);
        sub_98CAA(v12, (int)&v50, 4);
        sub_98CAA(v12, (int)&v48, 4);
        sub_98CAA(v12, 2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230 + 1609, 505);
        sub_98CAA(v12, (int)dword_17DBC8, 500);
        sub_98CAA(v12, (int)dword_17DDBC, 100);
        sub_98882(v12);
      }
    }
    word_17DF04 = -1;
    v55 = 1;
  }
  for ( j = 1; (__int16)j < 9; ++j )
  {
    sub_6FC50(1);
    if ( (__int16)a1[18] > 16 * (__int16)j + 3 * sub_6FC30() )
    {
      sprintf(v47, "%d.", (__int16)j);
      v15 = 16 * j;
      v57 = 16 * j;
      v16 = &byte_17DF14[43 * (__int16)j - 43];
      if ( (_WORD)j == word_17DF04 )
      {
        LOWORD(v15) = *v2;
        v17 = v15 + 20;
        v58 = v17;
        LOWORD(v17) = a1[14];
        v52 = v63;
        v53 = (__int16)(v17 + 16 + v57);
        v56 = v17 + 16 + v57;
        sub_2BC10(v47, v58, v17 + 16 + v57, v63);
        v43 = v52;
        v38 = v53;
        v35 = v58 + 3 * sub_6FC10();
        sub_2BC10(v16 + 20, v35, v38, v43);
      }
      else
      {
        v52 = v62;
        sub_2BC10(v47, a1[13] + 20, v57 + a1[14] + 16, v62);
        v42 = v52;
        v37 = v57 + a1[14] + 16;
        v34 = *v2 + 20 + 3 * sub_6FC10();
        sub_2BC10(v16, v34, v37, v42);
      }
    }
  }
  if ( a1[18] >= a1[17] )
  {
    for ( k = 1; (__int16)k < 9; ++k )
    {
      v46[5] = *v2 + 20;
      v18 = a1[14];
      v59 = 16 * k;
      v46[8] = 16;
      v46[7] = 90;
      v46[6] = v18 + 16 + 16 * k;
      if ( sub_7B200(v46, dword_17DEE4, SHIWORD(dword_17DEE4)) )
      {
        if ( (word_17DEEE & 1) != 0 )
        {
          word_17DF04 = k;
          v19 = &byte_17DF14[43 * (__int16)k - 43];
          v20 = v19 + 20;
          do
          {
            v21 = *v19;
            *v20 = *v19;
            if ( !v21 )
              break;
            v22 = v19[1];
            v19 += 2;
            v20[1] = v22;
            v20 += 2;
          }
          while ( v22 );
          v23 = 43 * (word_17DF04 - 1);
          byte_17DF3C[v23] = 0;
          LOWORD(v23) = *v2;
          v23 += 20;
          v58 = v23;
          LOWORD(v23) = a1[14];
          v56 = v23 + 16 + v59;
          byte_17DF3E[43 * word_17DF04 - 43] = 0;
        }
        else if ( (_WORD)k != word_17DF04 )
        {
          v24 = 43 * ((__int16)k - 1);
          sprintf(v47, "%d.", (__int16)k);
          v25 = v63;
          sub_2BC10(v47, a1[13] + 20, v59 + a1[14] + 16, v63);
          v39 = v59 + a1[14] + 16;
          v26 = sub_6FC10();
          sub_2BC10(&byte_17DF14[v24], *v2 + 20 + 3 * v26, v39, v25);
        }
      }
    }
    if ( word_17DF04 )
    {
      sub_6FC50(1);
      if ( (byte_17DF10 == 1 || byte_17DF10 == 28 || byte_17DF10 == 14)
        && (v27 = 43 * (word_17DF04 - 1), !byte_17DF3E[v27]) )
      {
        byte_17DF3E[v27] = 1;
      }
      else if ( byte_17DF11 )
      {
        if ( sub_7C200(byte_17DF11) )
        {
          v28 = 43 * (word_17DF04 - 1);
          if ( !byte_17DF3E[v28] )
          {
            byte_17DF3E[v28] = 1;
            sprintf(&byte_17DF14[43 * word_17DF04 - 23], "%c", (unsigned __int8)byte_17DF11);
            byte_17DF10 = 0;
            byte_17DF11 = 0;
          }
        }
      }
      v44 = v63;
      v29 = &byte_17DF14[43 * word_17DF04 - 43];
      v30 = (int)(v29 + 40);
      v40 = v29 + 40;
      v36 = v29 + 20;
      v33 = v56;
      v31 = sub_6FC10();
      sub_7F6A0((__int16)(v58 + 3 * v31), v30, v58 + 3 * v31, v33, v36, v40, v44);
    }
  }
  return v55;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E2970: using guessed type _WORD word_E2970[51];
// EA2C4: using guessed type int dword_EA2C4;
// 17DBC8: using guessed type int dword_17DBC8[];
// 17DDBC: using guessed type int dword_17DDBC[];
// 17DE38: using guessed type int dword_17DE38;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF04: using guessed type __int16 word_17DF04;
// 17DF10: using guessed type char byte_17DF10;
// 17DF11: using guessed type char byte_17DF11;
// 17DF14: using guessed type _BYTE byte_17DF14[40];
// 78730: using guessed type char var_44[4];

//----- (00078E00) --------------------------------------------------------
char __usercall sub_78E00@<al>(int a1@<eax>, int a2@<ebx>, __int16 *a3)
{
  int v3; // edx
  int v4; // esi
  int v5; // esi
  const char *v6; // edi
  char *v7; // edx
  char v8; // al
  __int16 v9; // si
  unsigned __int8 v10; // al
  __int16 v11; // bx
  unsigned __int8 v12; // al
  char *v13; // esi
  char *v14; // edi
  char v15; // al
  char v16; // al
  char *v17; // edi
  char *v18; // esi
  char v19; // al
  char v20; // al
  char *v21; // edi
  char *v22; // esi
  char v23; // al
  char v24; // al
  int v26; // [esp+0h] [ebp-14h]
  __int16 v27; // [esp+4h] [ebp-10h]
  char v28; // [esp+8h] [ebp-Ch]
  __int16 v29; // [esp+Ch] [ebp-8h]
  char v30; // [esp+10h] [ebp-4h]

  v28 = 0;
  v26 = j___clock(a1, 0, a2);
  sub_6FC50(1);
  v29 = a3[13] + 10;
  v27 = v29 + *(unsigned __int8 *)(dword_17DED4 + 436) - 22;
  v3 = a3[14];
  v4 = v3 + a3[17] / 2;
  v5 = v4 - sub_6FC30();
  v30 = sub_7BF20(v3, a3 + 13);
  if ( a3[18] <= a3[17] / 2 )
    goto LABEL_15;
  word_17DEF0 = strlen((const char *)dword_17DE50);
  if ( (unsigned __int8)byte_17DF10 < 0xFu )
  {
    if ( byte_17DF10 != 14 )
    {
LABEL_9:
      if ( (unsigned __int16)word_17DEF0 < 0xCu && byte_17DF11 && sub_7C200(byte_17DF11) )
      {
        v7 = (char *)(dword_17DE50 + (unsigned __int16)word_17DEF0);
        v8 = byte_17DF11;
        v7[1] = 0;
        *v7 = v8;
      }
      goto LABEL_13;
    }
LABEL_7:
    if ( word_17DEF0 )
    {
      v6 = (const char *)dword_17DE50;
      *(_BYTE *)(strlen((const char *)dword_17DE50) + dword_17DE50 - 1) = 0;
      word_17DEF0 = strlen(v6);
    }
    goto LABEL_13;
  }
  if ( (unsigned __int8)byte_17DF10 > 0xFu )
  {
    if ( byte_17DF10 != 83 )
      goto LABEL_9;
    goto LABEL_7;
  }
LABEL_13:
  strupr(dword_17DE50);
  sub_6FC50(1);
  v9 = sub_6FC30() + v5;
  v10 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x16u, 0x10u, 9u);
  v11 = sub_6FC80((char *)dword_17DE50, v29, v27, v9, v10);
  if ( (v26 - dword_17DED0) / 0xCu )
  {
    v12 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x16u, 0x10u, 9u);
    sub_2BC10(&asc_D1AB3[1], v11 + 2, v9, v12);
    dword_17DED0 = v26;
  }
LABEL_15:
  if ( v30 )
  {
    if ( v30 == 1 )
    {
      v13 = (char *)dword_17DE50;
      v14 = (char *)(dword_D41A0 + 11230 + 2124 * *(__int16 *)(dword_D41A0 + 12) + 927);
      do
      {
        v15 = *v13;
        *v14 = *v13;
        if ( !v15 )
          break;
        v16 = v13[1];
        v13 += 2;
        v14[1] = v16;
        v14 += 2;
      }
      while ( v16 );
      v17 = (char *)(dword_D41A4 + 57);
      v18 = (char *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230 + 927);
      do
      {
        v19 = *v18;
        *v17 = *v18;
        if ( !v19 )
          break;
        v20 = v18[1];
        v18 += 2;
        v17[1] = v20;
        v17 += 2;
      }
      while ( v20 );
    }
    else
    {
      *(_BYTE *)(dword_D41A4 + 57) = 0;
    }
    v21 = (char *)dword_17DE50;
    v22 = (char *)(dword_D41A0 + 11230 + 2124 * *(__int16 *)(dword_D41A0 + 12) + 927);
    do
    {
      v23 = *v22;
      *v21 = *v22;
      if ( !v23 )
        break;
      v24 = v22[1];
      v22 += 2;
      v21[1] = v24;
      v21 += 2;
    }
    while ( v24 );
    sub_7C020(a3 + 13);
    return 1;
  }
  return v28;
}
// 98786: using guessed type __int64 __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 9A20A: using guessed type _DWORD __cdecl strupr(_DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 17DE38: using guessed type int dword_17DE38;
// 17DE50: using guessed type int dword_17DE50;
// 17DED0: using guessed type int dword_17DED0;
// 17DED4: using guessed type int dword_17DED4;
// 17DEF0: using guessed type __int16 word_17DEF0;
// 17DF10: using guessed type char byte_17DF10;
// 17DF11: using guessed type char byte_17DF11;

//----- (00079160) --------------------------------------------------------
char __cdecl sub_79160(int a1)
{
  __int16 *v1; // esi
  int v2; // eax
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // edx
  int v7; // ebx
  __int16 *v8; // esi
  int v9; // ebx
  __int16 *v10; // esi
  int v11; // eax
  _WORD *i; // esi
  int v13; // eax
  int v14; // esi
  unsigned int v15; // ebx
  __int16 v16; // cx
  unsigned __int8 v18; // al
  char *v19; // [esp-14h] [ebp-60h]
  _WORD v20[22]; // [esp+0h] [ebp-4Ch] BYREF
  _WORD *v21; // [esp+30h] [ebp-1Ch]
  int v22; // [esp+34h] [ebp-18h]
  __int16 v23; // [esp+38h] [ebp-14h]
  int v24; // [esp+3Ch] [ebp-10h]
  char v25; // [esp+40h] [ebp-Ch]
  unsigned __int8 v26; // [esp+44h] [ebp-8h]
  unsigned __int8 v27; // [esp+48h] [ebp-4h]

  v21 = 0;
  v23 = 0;
  v1 = (__int16 *)(a1 + 26);
  v27 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x3Fu, 0x3Fu, 0x3Fu);
  v26 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, 0);
  BYTE1(v2) = *(_BYTE *)(a1 + 25);
  if ( !BYTE1(v2) )
  {
    LOWORD(v2) = *v1;
    v22 = v2 + 10;
    HIWORD(v3) = HIWORD(dword_17DED4);
    LOWORD(v3) = *(unsigned __int8 *)(dword_17DED4 + 436);
    v4 = *(__int16 *)(a1 + 34);
    v24 = v22 + v3 - 22;
    v5 = v4 / 2;
    v6 = *(__int16 *)(a1 + 28);
    v7 = v6 + v5 - 2 * sub_6FC30();
    v25 = sub_7BF20(v6, (__int16 *)(a1 + 26));
    if ( *(_WORD *)(a1 + 36) >= *(_WORD *)(a1 + 34) )
    {
      v8 = (__int16 *)&unk_E2690;
      sub_6FC50(1);
      while ( v8[6] )
      {
        if ( v8[7] )
        {
          sub_6FC50(1);
          v19 = (char *)dword_E9C4C[v8[6]];
          v21 = v8;
          sub_6FC80(v19, v22, v24, v7, v27);
        }
        else
        {
          sub_6FC50(1);
          sub_6FC80((char *)dword_E9C4C[v8[6]], v22, v24, v7, v26);
        }
        v8 += 9;
        LOWORD(v7) = sub_6FC30() + v7;
      }
      v9 = *(__int16 *)(a1 + 28) + *(__int16 *)(a1 + 34) / 2;
      v7 = v9 - 2 * sub_6FC30();
      v20[5] = v22;
      v10 = (__int16 *)&unk_E2690;
      v20[7] = *(unsigned __int8 *)(dword_17DED4 + 436);
      v20[8] = sub_6FC30();
      while ( v10[6] )
      {
        v20[6] = v7;
        if ( sub_7B200(v20, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        {
          if ( (word_17DEEE & 1) != 0 )
          {
            if ( v21 )
              v21[7] = 0;
            v10[7] = 1;
          }
          sub_6FC50(1);
          sub_6FC80((char *)dword_E9C4C[v10[6]], v22, v24, v7, v27);
        }
        LOWORD(v11) = sub_6FC30();
        v10 += 9;
        v7 += v11;
      }
    }
    if ( v25 )
    {
      for ( i = &unk_E2690; i[6]; i += 9 )
      {
        if ( i[7] )
        {
          v21 = i;
          break;
        }
        LOWORD(v13) = sub_6FC30();
        v7 += v13;
      }
      if ( v25 != 1 )
      {
        switch ( word_1805C2 )
        {
          case 4:
          case 11:
            word_1805C2 = 7;
            break;
          case 8:
            word_1805C2 = 1;
            break;
          case 9:
            word_1805C2 = 2;
            break;
          default:
            goto LABEL_47;
        }
        goto LABEL_47;
      }
      v23 = 1;
      v14 = (unsigned __int16)word_1805C2;
      if ( !v21 )
        goto LABEL_48;
      v15 = (unsigned __int16)word_1805C2 - 1;
      v16 = v21[8];
      if ( v16 == 2 )
      {
        if ( (__int16)sub_89B60(4u) == -1 )
        {
          word_1805C2 = v14;
        }
        else if ( v15 <= 0xC )
        {
          switch ( v14 )
          {
            case 1:
            case 12:
              word_1805C2 = 8;
              break;
            case 2:
            case 13:
              word_1805C2 = 9;
              break;
            case 3:
            case 4:
            case 5:
            case 6:
            case 8:
            case 9:
            case 10:
              break;
            case 7:
            case 11:
              word_1805C2 = 4;
              break;
          }
        }
LABEL_47:
        v23 = 1;
        goto LABEL_48;
      }
      if ( v16 != 1 )
      {
LABEL_48:
        sub_7C020((_WORD *)(a1 + 26));
        return v23;
      }
      if ( (__int16)sub_89B60(0xBu) != -1 )
      {
        if ( v15 <= 8 )
        {
          switch ( v14 )
          {
            case 1:
            case 8:
              word_1805C2 = 12;
              break;
            case 2:
            case 9:
              word_1805C2 = 13;
              break;
            case 3:
            case 5:
            case 6:
              break;
            case 4:
            case 7:
              word_1805C2 = 11;
              break;
          }
        }
        *(_BYTE *)(a1 + 25) = 1;
        v23 = 0;
        goto LABEL_48;
      }
      word_1805C2 = v14;
      sub_7C020((_WORD *)(a1 + 26));
    }
    return v23;
  }
  v23 = 0;
  if ( BYTE1(v2) <= 1u )
  {
    *(_WORD *)(a1 + 38) = 439;
    *(_WORD *)(a1 + 42) = 0;
  }
  else if ( BYTE1(v2) == 2 )
  {
    *(_WORD *)(a1 + 38) = 439;
  }
  sub_7BF20(0, v1);
  if ( *(_WORD *)(a1 + 36) < *(_WORD *)(a1 + 34) )
    return v23;
  v18 = *(_BYTE *)(a1 + 25);
  if ( v18 < 2u )
  {
    if ( v18 == 1 )
    {
      *(_BYTE *)(a1 + 25) = 2;
      return v23;
    }
    return v23;
  }
  if ( v18 > 2u )
  {
    if ( v18 != 3 )
      return v23;
    *(_BYTE *)(a1 + 25) = 0;
    *(_WORD *)(a1 + 38) = 411;
    *(_WORD *)(a1 + 42) = 3;
    sub_7C020((_WORD *)(a1 + 26));
    return 1;
  }
  byte_17DF10 = 0;
  sub_8C0E0((unsigned __int8 (__fastcall *)(int))sub_7A060);
  if ( byte_17DF10 == 1 )
  {
    if ( (unsigned __int16)word_1805C2 < 0xCu )
    {
      if ( word_1805C2 == 11 )
        word_1805C2 = 7;
    }
    else if ( (unsigned __int16)word_1805C2 <= 0xCu )
    {
      word_1805C2 = 1;
    }
    else if ( word_1805C2 == 13 )
    {
      word_1805C2 = 2;
    }
  }
  ++*(_BYTE *)(a1 + 25);
  return v23;
}
// 7950A: conditional instruction was optimized away because ah.1!=0
// 791BD: variable 'v2' is possibly undefined
// 79365: variable 'v11' is possibly undefined
// 79397: variable 'v13' is possibly undefined
// E9C4C: using guessed type int dword_E9C4C[];
// 17DE38: using guessed type int dword_17DE38;
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (00079610) --------------------------------------------------------
char sub_79610()
{
  int v0; // eax
  __int16 v1; // si
  __int16 *v2; // ebx
  __int64 v3; // rax
  int v4; // edi
  _WORD *i; // eax
  _WORD *j; // ebx
  _WORD *k; // eax
  _WORD *m; // eax
  char *v9; // ebx
  __int16 *v10; // edi
  char *n; // edi
  __int16 v12; // ax
  int v13; // eax
  char *ii; // eax
  __int16 v15; // ax
  int v16; // eax
  char *jj; // eax
  unsigned int v18; // eax
  int v19; // eax
  int v20; // eax
  int v22; // [esp-18h] [ebp-2Eh]
  int v23; // [esp-10h] [ebp-26h]
  char v24[60]; // [esp+0h] [ebp-16h] BYREF
  _WORD v25[22]; // [esp+3Ch] [ebp+26h] BYREF
  int v26; // [esp+68h] [ebp+52h]
  int v27; // [esp+6Ch] [ebp+56h]
  int v28; // [esp+70h] [ebp+5Ah]
  unsigned int v29; // [esp+74h] [ebp+5Eh]
  int v30; // [esp+78h] [ebp+62h]
  int v31; // [esp+7Ch] [ebp+66h]
  int v32; // [esp+80h] [ebp+6Ah]
  int v33; // [esp+84h] [ebp+6Eh]
  int v34; // [esp+88h] [ebp+72h]
  int v35; // [esp+8Ch] [ebp+76h]
  int v36; // [esp+90h] [ebp+7Ah]
  int v37; // [esp+94h] [ebp+7Eh]

  HIWORD(v0) = HIWORD(dword_17DED4);
  v1 = 0;
  v31 = 359;
  v35 = 372;
  v34 = 410;
  v36 = 0;
  v33 = 0;
  LOBYTE(v0) = *(_BYTE *)(dword_17DED4 + 647);
  v37 = 191;
  LOWORD(v0) = (unsigned __int8)v0;
  v32 = v0;
  v3 = j___clock(v0, 191, 372);
  v30 = v3;
  v27 = v3;
  memset(v24, 0, sizeof(v24));
  v2 = (__int16 *)&unk_E28A8;
  sub_7A110(word_180660, 15);
  v4 = dword_180628;
  dword_180628 = dword_E9C38;
  while ( *v2 )
  {
    v23 = v2[1];
    v22 = *v2;
    HIDWORD(v3) = dword_E9C4C[v2[6]];
    v2 += 9;
    sub_7FCB0((int)v2, (_BYTE *)HIDWORD(v3), v22, (__int16)v31, v23, 4, 0, 0);
  }
  dword_180628 = v4;
  sub_7B5A0();
  for ( i = &unk_E28A8; *i; *(i - 2) = 0 )
    i += 9;
  word_E28B6 = 1;
  LODWORD(v3) = sub_8CD27(dword_17DED4 + 660);
  while ( (_WORD)v36 != 2 )
  {
    v3 = j___clock(v3, HIDWORD(v3), v2);
    v26 = v3;
    v28 = v3;
    if ( (word_180660 & 1) != 0 )
      sub_9A128((const void *)dword_E9C38, (void *)dword_180628, 0xC8u);
    else
      sub_9A144((const void *)dword_E9C38, (void *)dword_180628, 0x1E0u);
    if ( (word_17DEEE & 1) != 0 )
    {
      for ( j = &unk_E28A8; *j; j += 9 )
      {
        v25[5] = v37;
        v25[6] = j[1] - 4;
        v25[7] = v34;
        v25[8] = v32;
        if ( sub_7B200(v25, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        {
          for ( k = &unk_E28A8; *k; *(k - 2) = 0 )
            k += 9;
          j[7] = 1;
          v1 = 0;
          break;
        }
      }
    }
    v36 = sub_7E1F0();
    if ( (_WORD)v36 == 1 )
    {
      *(_BYTE *)(dword_D41A4 + 38402) = 1;
      sub_5BCC0();
      for ( m = &unk_E28A8; *m; *(m - 2) = 0 )
        m += 9;
      v1 = 0;
      word_E28B6 = 1;
    }
    v9 = &byte_EB39E;
    v10 = (__int16 *)&unk_E28A8;
    while ( v9 < &byte_EB3A8 )
    {
      memset(v24, 0, sizeof(v24));
      if ( !v10[7] )
      {
        sub_79E10(v24, *v9);
        sub_7FCB0((int)v9, v24, (__int16)v35, (__int16)v34, v10[1], 4, 0, 0);
      }
      ++v9;
      v10 += 9;
    }
    v2 = (__int16 *)&unk_E28A8;
    for ( n = &byte_EB39E; n < &byte_EB3A8 && !v1; ++n )
    {
      v12 = v2[7];
      if ( v12 )
      {
        HIDWORD(v3) = v26 - v30;
        v29 = v26 - v30;
        if ( (unsigned __int16)v12 <= 1u )
        {
          memset(v24, 0, sizeof(v24));
          sub_79E10(v24, *n);
          sub_7FCB0((int)v2, v24, (__int16)v35, (__int16)v34, v2[1], 4, 0, 0);
          if ( v29 > 0x32 )
          {
            v13 = v26;
            v2[7] = 2;
            v30 = v13;
          }
          sub_2BB40(v37, v2[1], dword_17DED4 + 642);
          BYTE5(v3) = byte_17DF10;
          if ( byte_17DF10 && (unsigned __int16)sub_79E10(v24, byte_17DF10) )
          {
            BYTE4(v3) = 0;
            if ( n != &byte_EB3A4 )
            {
              for ( ii = &byte_EB39E; ii < &byte_EB3A8; ++ii )
              {
                BYTE5(v3) = byte_17DF10;
                if ( byte_17DF10 == *ii )
                {
                  BYTE4(v3) = 1;
                  break;
                }
              }
            }
            if ( !BYTE4(v3) )
            {
              *(_BYTE *)(dword_D41A4 + 38402) = 1;
              v2 += 9;
              *n = byte_17DF10;
              *(v2 - 2) = 0;
              v15 = *v2;
              byte_17DF10 = 0;
              if ( v15 )
              {
                v2[7] = 1;
              }
              else
              {
                v1 = 1;
                v30 = v26;
              }
            }
          }
        }
        else if ( v12 == 2 )
        {
          if ( HIDWORD(v3) > 0x32 )
          {
            v16 = v26;
            v2[7] = 1;
            v30 = v16;
          }
          sub_2BB40(v37, v2[1], dword_17DED4 + 642);
          if ( byte_17DF10 )
          {
            if ( (unsigned __int16)sub_79E10(v24, byte_17DF10) )
            {
              BYTE4(v3) = 0;
              if ( n != &byte_EB3A4 )
              {
                for ( jj = &byte_EB39E; jj < &byte_EB3A8; ++jj )
                {
                  BYTE5(v3) = byte_17DF10;
                  if ( byte_17DF10 == *jj )
                  {
                    BYTE4(v3) = 1;
                    break;
                  }
                }
              }
              if ( !BYTE4(v3) )
              {
                *(_BYTE *)(dword_D41A4 + 38402) = 1;
                *n = byte_17DF10;
                v2[7] = 0;
                byte_17DF10 = 0;
                WORD2(v3) = v2[9];
                v2 += 9;
                if ( WORD2(v3) )
                  v2[7] = 1;
                else
                  v1 = 1;
              }
            }
          }
        }
      }
      v2 += 9;
    }
    if ( v1 )
    {
      v18 = v26 - v30;
      if ( (unsigned __int16)v1 > 1u )
      {
        if ( v18 > 0x32 )
        {
          v1 = 1;
          v30 = v26;
        }
      }
      else
      {
        if ( v18 > 0x32 )
        {
          v1 = 2;
          v30 = v26;
        }
        sub_2BB40(283, 381, dword_17DED4 + 648);
      }
    }
    if ( (word_180660 & 1) != 0 )
      sub_90478();
    else
      sub_75200(480);
    if ( !(_WORD)v33 )
    {
      sub_90B27((char *)dword_17DE38, 0x20u, 0);
      v33 = 1;
    }
    LODWORD(v3) = v28 - v27;
    if ( (unsigned int)(v28 - v27) > 0xA )
    {
      sub_7A060();
      LODWORD(v3) = v28;
      v27 = v28;
    }
    if ( byte_17DF10 == 1 )
      v36 = 2;
    if ( byte_17DF10 == 28 )
    {
      if ( v1 )
        v36 = 2;
    }
  }
  sub_81DB0();
  LOWORD(v19) = sub_90B27(0, 0x10u, 0);
  if ( (word_180660 & 1) != 0 )
    v20 = sub_72883(dword_180628, (void *)dword_180628, 0xC8u, 0);
  else
    v20 = sub_728A9(v19, (void *)dword_180628, 0x1E0u, 0);
  if ( (word_180660 & 1) != 0 )
    sub_72883(v20, (void *)dword_E9C38, 0xC8u, 0);
  else
    sub_728A9(v20, (void *)dword_E9C38, 0x1E0u, 0);
  sub_7B5A0();
  if ( (word_180660 & 1) != 0 )
    sub_90478();
  else
    sub_75200(480);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, 0, 768);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE40, dword_17DEDC, 168081);
  sub_7AA70(0, 0, 0, 0);
  sub_8CD27(dword_EB394);
  sub_41A90((unsigned __int8 *)dword_17DE38);
  sub_8CD27(dword_17DED4 + 234);
  if ( (word_180660 & 1) != 0 )
    sub_9A128((const void *)dword_180628, (void *)dword_E9C38, 0xC8u);
  else
    sub_9A144((const void *)dword_180628, (void *)dword_E9C38, 0x1E0u);
  return 1;
}
// 79AB5: conditional instruction was optimized away because si.2==2
// 79BC4: variable 'v19' is possibly undefined
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type __int64 __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E28B6: using guessed type __int16 word_E28B6;
// E9C38: using guessed type int dword_E9C38;
// E9C4C: using guessed type int dword_E9C4C[];
// EB394: using guessed type int dword_EB394;
// EB39E: using guessed type char byte_EB39E;
// EB3A4: using guessed type char byte_EB3A4;
// EB3A8: using guessed type char byte_EB3A8;
// 17DE38: using guessed type int dword_17DE38;
// 17DE40: using guessed type int dword_17DE40;
// 17DED4: using guessed type int dword_17DED4;
// 17DEDC: using guessed type int dword_17DEDC;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (00079E10) --------------------------------------------------------
int __cdecl sub_79E10(char *a1, char a2)
{
  int result; // eax

  result = 0;
  switch ( a2 )
  {
    case 12:
    case 13:
      *(_WORD *)a1 = word_D1B40;
      result = 1;
      break;
    case 16:
      *(_WORD *)a1 = word_D1B24;
      result = 1;
      break;
    case 17:
      *(_WORD *)a1 = word_D1B30;
      result = 1;
      break;
    case 18:
      *(_WORD *)a1 = word_D1B08;
      result = 1;
      break;
    case 20:
      *(_WORD *)a1 = word_D1B28;
      result = 1;
      break;
    case 21:
      *(_WORD *)a1 = word_D1B38;
      result = 1;
      break;
    case 22:
      *(_WORD *)a1 = word_D1B2C;
      result = 1;
      break;
    case 28:
      result = 1;
      strcpy(a1, "ENTER");
      break;
    case 29:
      result = 1;
      strcpy(a1, "CTRL");
      break;
    case 30:
      *(_WORD *)a1 = word_D1B00;
      result = 1;
      break;
    case 33:
      *(_WORD *)a1 = word_D1B0C;
      result = 1;
      break;
    case 34:
      *(_WORD *)a1 = word_D1B10;
      result = 1;
      break;
    case 35:
      *(_WORD *)a1 = word_D1B14;
      result = 1;
      break;
    case 36:
      *(_WORD *)a1 = word_D1B18;
      result = 1;
      break;
    case 37:
      *(_WORD *)a1 = word_D1B1C;
      result = 1;
      break;
    case 39:
      *(_WORD *)a1 = word_D1B44;
      result = 1;
      break;
    case 42:
      result = 1;
      strcpy(a1, "Left Shift");
      break;
    case 43:
      *(_WORD *)a1 = word_D1B48;
      result = 1;
      break;
    case 44:
      *(_WORD *)a1 = word_D1B3C;
      result = 1;
      break;
    case 45:
      *(_WORD *)a1 = word_D1B34;
      result = 1;
      break;
    case 48:
      *(_WORD *)a1 = word_D1B04;
      result = 1;
      break;
    case 49:
      *(_WORD *)a1 = word_D1B20;
      result = 1;
      break;
    case 51:
      *(_WORD *)a1 = word_D1B4C;
      result = 1;
      break;
    case 52:
      *(_WORD *)a1 = word_D1B50;
      result = 1;
      break;
    case 53:
      *(_WORD *)a1 = word_D1B54;
      result = 1;
      break;
    case 54:
      result = 1;
      strcpy(a1, "Right Shift");
      break;
    case 56:
      *(_DWORD *)a1 = dword_D1AE4;
      result = 1;
      break;
    case 72:
      result = 1;
      strcpy(a1, "UP");
      break;
    case 75:
      result = 1;
      strcpy(a1, "LEFT");
      break;
    case 77:
      result = 1;
      strcpy(a1, "RIGHT");
      break;
    case 80:
      result = 1;
      strcpy(a1, "DOWN");
      break;
    default:
      return result;
  }
  return result;
}
// D1AE4: using guessed type int dword_D1AE4;
// D1B00: using guessed type __int16 word_D1B00;
// D1B04: using guessed type __int16 word_D1B04;
// D1B08: using guessed type __int16 word_D1B08;
// D1B0C: using guessed type __int16 word_D1B0C;
// D1B10: using guessed type __int16 word_D1B10;
// D1B14: using guessed type __int16 word_D1B14;
// D1B18: using guessed type __int16 word_D1B18;
// D1B1C: using guessed type __int16 word_D1B1C;
// D1B20: using guessed type __int16 word_D1B20;
// D1B24: using guessed type __int16 word_D1B24;
// D1B28: using guessed type __int16 word_D1B28;
// D1B2C: using guessed type __int16 word_D1B2C;
// D1B30: using guessed type __int16 word_D1B30;
// D1B34: using guessed type __int16 word_D1B34;
// D1B38: using guessed type __int16 word_D1B38;
// D1B3C: using guessed type __int16 word_D1B3C;
// D1B40: using guessed type __int16 word_D1B40;
// D1B44: using guessed type __int16 word_D1B44;
// D1B48: using guessed type __int16 word_D1B48;
// D1B4C: using guessed type __int16 word_D1B4C;
// D1B50: using guessed type __int16 word_D1B50;
// D1B54: using guessed type __int16 word_D1B54;

//----- (0007A060) --------------------------------------------------------
char sub_7A060()
{
  char result; // al

  word_17DEEE = word_180746 != 0;
  if ( word_180744 )
    LOBYTE(word_17DEEE) = word_17DEEE | 2;
  dword_17DEE4 = dword_E3760;
  sub_7C050(SHIWORD(dword_E3760), 0);
  result = byte_17DF10;
  word_180744 = 0;
  word_180746 = 0;
  word_18074A = 0;
  word_18074C = 0;
  return result;
}
// E3760: using guessed type int dword_E3760;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;
// 18074A: using guessed type __int16 word_18074A;
// 18074C: using guessed type __int16 word_18074C;

//----- (0007A110) --------------------------------------------------------
void __cdecl sub_7A110(char a1, char a2)
{
  int v2; // eax

  dword_17DE38 = dword_EA3D8;
  word_17DEEC = 0;
  dword_17DE40 = dword_180628;
  dword_17DEE0 = -1;
  v2 = *(_DWORD *)(dword_D41A4 + 226);
  dword_17DEDC = 0;
  dword_17DE48 = v2;
  sub_7B5D0();
  if ( a1 == 8 )
  {
    switch ( a2 )
    {
      case 4:
        dword_17DED8 = (int)&loc_36F44 + dword_17DE48;
        dword_17DED4 = (int)&loc_36CAA + dword_17DE48;
        dword_17DE4C = (int)&loc_36F44 + dword_17DE48 + 2;
        dword_17DE54 = (int)&loc_36F44 + dword_17DE48 + 16386;
        dword_17DEC4 = (int)&loc_36F44 + dword_17DE48 + 24631;
        dword_17DE50 = (int)&loc_36F44 + dword_17DE48 + 24631;
        dword_17DEC0 = (int)&loc_36F44 + dword_17DE48 + 22999;
        qmemcpy(
          (char *)&loc_36F44 + dword_17DE48 + 24631,
          (const void *)(dword_D41A0 + 11230 + 2124 * *(__int16 *)(dword_D41A0 + 12) + 927),
          0x20u);
        dword_E9C38 = dword_17DE50 + 32;
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, 0, 768);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_E9C38, dword_17DEDC, 168081);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE48, dword_17DEDC, 102213);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DED4, dword_17DEDC, 411);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE54, (int)&unk_13ACCA, 1226);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC0, (int)&unk_13B194, 548);
        sub_7AA70(0, 0, 0, 0);
        if ( (word_180660 & 1) != 0 )
          sub_98709(dword_17DED4, dword_17DED8, dword_17DE48);
        else
          sub_9874D((unsigned int *)dword_17DED4, dword_17DED8, dword_17DE48);
        if ( (word_180660 & 1) != 0 )
          sub_98709(dword_17DEC0, dword_17DEC4, dword_17DE54);
        else
          sub_9874D((unsigned int *)dword_17DEC0, dword_17DEC4, dword_17DE54);
        word_17DF06 = 72;
        word_17DF08 = 68;
        word_17DF0A = 69;
        word_17DF0C = 70;
        word_17DF0E = 71;
        break;
      case 6:
        dword_17DE54 = dword_17DE48 + 301787;
        dword_17DEC4 = dword_17DE48 + 316179;
        dword_17DE58 = dword_17DE48 + 316179;
        dword_17DEC8 = dword_17DE48 + 322754;
        dword_17DECC = dword_17DE48 + 324380;
        dword_17DED4 = dword_17DE48 + 324380;
        dword_17DED8 = dword_17DE48 + 326258;
        dword_17DE60 = dword_17DE44;
        dword_17DE64 = dword_17DE48 + 326258;
        dword_17DE3C = (int)&unk_12C000 + dword_17DE48 + 326258;
        dword_17DEC0 = dword_17DE48 + 314541;
        dword_17DE5C = dword_17DE3C + 0x4000;
        sub_7AA70((int)aDataScreensHsc, (char *)(dword_17DE48 + 301787), (int)&unk_1641FC, 1214);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC0, (int)&unk_1646BA, 589);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE58, (int)&unk_164907, 1191);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC8, (int)&unk_164DAE, 543);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, (int)&unk_13A9CA, 768);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE64, (int)&loc_B2C44 + 3, (int)&loc_87D80 + 3);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE48, (int)&loc_783BD, 103577);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DED4, (int)&loc_91856, 1027);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE3C, (int)&unk_13B3B8, 6760);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE60, (int)&unk_13CE20, 20581);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE5C, (int)&unk_141E85, 13195);
        sub_7AA70(0, 0, 0, 0);
        if ( (word_180660 & 1) != 0 )
          sub_98709(dword_17DED4, dword_17DED8, dword_17DE48);
        else
          sub_9874D((unsigned int *)dword_17DED4, dword_17DED8, dword_17DE48);
        if ( (word_180660 & 1) != 0 )
          sub_98709(dword_17DEC0, dword_17DEC4, dword_17DE54);
        else
          sub_9874D((unsigned int *)dword_17DEC0, dword_17DEC4, dword_17DE54);
        if ( (word_180660 & 1) != 0 )
          sub_98709(dword_17DEC8, dword_17DECC, dword_17DE58);
        else
          sub_9874D((unsigned int *)dword_17DEC8, dword_17DECC, dword_17DE58);
        word_17DF06 = 254;
        word_17DF08 = 255;
        word_17DF0A = 256;
        word_17DF0C = 257;
        word_17DF0E = 258;
        dword_17DEC0 += 6;
        break;
      case 7:
        dword_17DE48 += 371200;
        dword_17DE54 = dword_17DE48 + 42428;
        dword_17DEC4 = dword_17DE48 + 50673;
        dword_17DED4 = dword_17DE48 + 50673;
        dword_17DED8 = dword_17DE48 + 50871;
        dword_17DE3C = dword_17DE48 + 50871;
        dword_17DE4C = dword_17DE48 + 51639;
        dword_17DEC0 = dword_17DE48 + 49041;
        dword_17DE50 = dword_17DE48 + 68023;
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, (int)&loc_42471, 768);
        sub_7AA70((int)aDataScreensHsc, *(char **)(dword_D41A4 + 226), dword_17DEDC, 82233);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE48, (int)&loc_568AA, 21216);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DED4, 375690, 148);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE54, (int)&unk_13ACCA, 1226);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC0, (int)&unk_13B194, 548);
        if ( (word_180660 & 1) != 0 )
          sub_98709(dword_17DED4, dword_17DED8, dword_17DE48);
        else
          sub_9874D((unsigned int *)dword_17DED4, dword_17DED8, dword_17DE48);
        if ( (word_180660 & 1) == 0 )
          goto LABEL_30;
        goto LABEL_14;
      case 12:
        sub_7AA70((int)aDataScreensHsc, (char *)dword_E9C38, (int)&loc_91C54 + 5, 134382);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, (int)&off_B2947, 768);
        break;
      case 14:
        dword_17DE48 += (int)&loc_4D54A;
        dword_17DE54 = (int)&loc_36CAA + dword_17DE48;
        dword_17DEC4 = dword_17DE48 + 232671;
        dword_17DED4 = dword_17DE48 + 232671;
        dword_17DED8 = dword_17DE48 + 233337;
        dword_17DE4C = dword_17DE48 + 233339;
        dword_17DE50 = dword_17DE48 + 249723;
        dword_17DEC0 = dword_17DE48 + 231039;
        qmemcpy(
          (void *)(dword_17DE48 + 249723),
          (const void *)(dword_D41A0 + 11230 + 2124 * *(__int16 *)(dword_D41A0 + 12) + 927),
          0x20u);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE54, (int)&unk_13ACCA, 1226);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC0, (int)&unk_13B194, 548);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE48, 168849, 102213);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DED4, 271062, 411);
        sub_7AA70((int)aDataScreensHsc, *(char **)(dword_D41A4 + 226), (int)&loc_91C54 + 5, 134382);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, (int)&off_B2947, 768);
        if ( (word_180660 & 1) != 0 )
          sub_98709(dword_17DED4, dword_17DED8, dword_17DE48);
        else
          sub_9874D((unsigned int *)dword_17DED4, dword_17DED8, dword_17DE48);
        if ( (word_180660 & 1) != 0 )
LABEL_14:
          sub_98709(dword_17DEC0, dword_17DEC4, dword_17DE54);
        else
LABEL_30:
          sub_9874D((unsigned int *)dword_17DEC0, dword_17DEC4, dword_17DE54);
        break;
      case 15:
        sub_7AA70((int)aDataScreensHsc, (char *)dword_E9C38, (int)&unk_145210, 126188);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, (int)&unk_163EFC, 768);
        break;
      default:
        return;
    }
  }
}
// B2947: using guessed type void *off_B2947;
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E9C38: using guessed type int dword_E9C38;
// EA3D8: using guessed type int dword_EA3D8;
// 17DE38: using guessed type int dword_17DE38;
// 17DE3C: using guessed type int dword_17DE3C;
// 17DE40: using guessed type int dword_17DE40;
// 17DE44: using guessed type int dword_17DE44;
// 17DE48: using guessed type int dword_17DE48;
// 17DE4C: using guessed type int dword_17DE4C;
// 17DE50: using guessed type int dword_17DE50;
// 17DE54: using guessed type int dword_17DE54;
// 17DE58: using guessed type int dword_17DE58;
// 17DE5C: using guessed type int dword_17DE5C;
// 17DE60: using guessed type int dword_17DE60;
// 17DE64: using guessed type int dword_17DE64;
// 17DEC0: using guessed type int dword_17DEC0;
// 17DEC4: using guessed type int dword_17DEC4;
// 17DEC8: using guessed type int dword_17DEC8;
// 17DECC: using guessed type int dword_17DECC;
// 17DED4: using guessed type int dword_17DED4;
// 17DED8: using guessed type int dword_17DED8;
// 17DEDC: using guessed type int dword_17DEDC;
// 17DEE0: using guessed type int dword_17DEE0;
// 17DEEC: using guessed type __int16 word_17DEEC;
// 17DF06: using guessed type __int16 word_17DF06;
// 17DF08: using guessed type __int16 word_17DF08;
// 17DF0A: using guessed type __int16 word_17DF0A;
// 17DF0C: using guessed type __int16 word_17DF0C;
// 17DF0E: using guessed type __int16 word_17DF0E;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0007AA70) --------------------------------------------------------
int __cdecl sub_7AA70(int a1, char *a2, int a3, int a4)
{
  int result; // eax

  if ( dword_17DEE0 != -1 || (result = sub_98817(a1, 512), dword_17DEE0 = result, result != -1) )
  {
    result = dword_17DEE0;
    if ( dword_17DEE0 != -1 )
    {
      if ( a2 )
      {
        sub_9891E(dword_17DEE0, a3, 0);
        sub_988A7(dword_17DEE0, (int)a2, a4);
        result = sub_5C3D0((int)a2, a2);
        dword_17DEDC = a4 + a3;
      }
      else
      {
        result = sub_98882(dword_17DEE0);
        dword_17DEE0 = -1;
      }
    }
  }
  return result;
}
// 17DEDC: using guessed type int dword_17DEDC;
// 17DEE0: using guessed type int dword_17DEE0;

//----- (0007AB00) --------------------------------------------------------
int (__cdecl **__usercall sub_7AB00@<eax>(__int16 a1@<ax>, int a2@<edx>, __int16 *a3@<ebx>, unsigned __int8 a4))(int)
{
  int (__cdecl **v4)(int); // esi
  __int16 v5; // ax
  int (__cdecl **i)(int); // ebx
  int v8; // [esp+0h] [ebp-4h]

  HIBYTE(a1) = a4;
  v4 = 0;
  if ( a4 >= 4u )
  {
    if ( a4 <= 4u )
    {
      a3 = (__int16 *)&unk_E1748;
    }
    else if ( a4 == 6 )
    {
      a3 = (__int16 *)&unk_E1784;
    }
  }
  while ( a3[2] )
  {
    v8 = j___clock(a1, a2, a3);
    a2 = 6 * a3[4];
    a1 = sub_2BB40(a3[2], a3[3], a2 + dword_17DED4);
    if ( (unsigned int)(v8 - *(_DWORD *)a3) >> 2 )
    {
      LOWORD(a2) = a3[4];
      ++a2;
      v5 = *((unsigned __int8 *)a3 + 11);
      a3[4] = a2;
      if ( v5 < (__int16)a2 )
        a3[4] = *((unsigned __int8 *)a3 + 10);
      a1 = v8;
      *(_DWORD *)a3 = v8;
    }
    a3 += 6;
  }
  if ( a4 == 4 )
  {
    for ( i = &off_E1BAC; *((_WORD *)i + 5); i += 11 )
    {
      if ( *((_BYTE *)i + 23) && *((_BYTE *)i + 24) )
      {
        v4 = i;
        sub_2BB40(*((_WORD *)i + 5), *((_WORD *)i + 6), dword_17DED4 + 6 * *((unsigned __int8 *)i + 21));
      }
    }
  }
  return v4;
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// E1BAC: using guessed type int (__cdecl *off_E1BAC)(int);
// 17DED4: using guessed type int dword_17DED4;

//----- (0007AC00) --------------------------------------------------------
int sub_7AC00()
{
  char v0; // al
  unsigned __int8 v1; // al
  unsigned __int8 v2; // al

  if ( (word_180660 & 8) == 0 )
  {
    if ( dword_E9C3C )
    {
      sub_83E80(dword_E9C3C);
      dword_E9C3C = 0;
    }
    sub_54600();
    sub_6EBF0((unsigned int **)&off_D918C);
    if ( word_180660 == 1 )
    {
      word_E29DA = word_180660;
      word_180660 = 8;
      dword_E9C3C = sub_83CD0(307200);
      sub_6EB90((unsigned int **)&off_D918C);
      memset(dword_EA3D8, 0, 768);
      if ( (word_180660 & 1) != 0 )
      {
        v0 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
        sub_72883(dword_180628, (void *)dword_180628, 0xC8u, v0);
      }
      else
      {
        v1 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
        sub_728A9(v1, (void *)dword_180628, 0x1E0u, v1);
      }
      memset(dword_EA3D8, 0, 768);
      sub_41A90((unsigned __int8 *)dword_EA3D8);
      if ( (word_180660 & 1) != 0 )
        sub_90D6E((unsigned __int8 *)dword_EA3D8);
      else
        sub_90E07((unsigned __int8 *)dword_EA3D8);
      sub_41A90((unsigned __int8 *)dword_EA3D8);
      v2 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
      byte_EB3A8 = v2;
      if ( (word_180660 & 1) != 0 )
        sub_72883(v2, (void *)dword_180628, 0xC8u, v2);
      else
        sub_728A9(v2, (void *)dword_180628, 0x1E0u, v2);
      sub_8CEDF();
      sub_8CD27(dword_EB394);
    }
  }
  return sub_8CD27(dword_EB394);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D918C: using guessed type int *off_D918C;
// E29DA: using guessed type __int16 word_E29DA;
// E9C3C: using guessed type int dword_E9C3C;
// EA3D8: using guessed type int dword_EA3D8;
// EB394: using guessed type int dword_EB394;
// EB3A8: using guessed type char byte_EB3A8;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0007ADE0) --------------------------------------------------------
int __cdecl sub_7ADE0(char a1)
{
  char v1; // al
  unsigned __int8 v2; // al
  unsigned __int8 v3; // al

  if ( a1 == 1 )
  {
    if ( dword_E9C3C )
    {
      sub_83E80(dword_E9C3C);
      dword_E9C3C = 0;
    }
    sub_54600();
    sub_6EBF0((unsigned int **)&off_D918C);
    word_180660 = 1;
    word_E29DA = 1;
    dword_E9C3C = sub_83CD0(64000);
    sub_6EB90((unsigned int **)&off_D918C);
    memset(dword_EA3D8, 0, 768);
    if ( (word_180660 & 1) != 0 )
    {
      v1 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
      sub_72883(dword_180628, (void *)dword_180628, 0xC8u, v1);
    }
    else
    {
      v2 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
      sub_728A9(v2, (void *)dword_180628, 0x1E0u, v2);
    }
    memset(dword_EA3D8, 0, 768);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
    if ( (word_180660 & 1) != 0 )
      sub_90D6E((unsigned __int8 *)dword_EA3D8);
    else
      sub_90E07((unsigned __int8 *)dword_EA3D8);
    sub_41A90((unsigned __int8 *)dword_EA3D8);
    v3 = sub_5BE80((unsigned __int8 *)dword_EA3D8, 0, 0, 0);
    byte_EB3A8 = v3;
    if ( (word_180660 & 1) != 0 )
      sub_72883(v3, (void *)dword_180628, 0xC8u, v3);
    else
      sub_728A9(v3, (void *)dword_180628, 0x1E0u, v3);
    sub_8CEDF();
  }
  return sub_8CD27(dword_EB394);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D918C: using guessed type int *off_D918C;
// E29DA: using guessed type __int16 word_E29DA;
// E9C3C: using guessed type int dword_E9C3C;
// EA3D8: using guessed type int dword_EA3D8;
// EB394: using guessed type int dword_EB394;
// EB3A8: using guessed type char byte_EB3A8;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0007B200) --------------------------------------------------------
bool __cdecl sub_7B200(_WORD *a1, __int16 a2, __int16 a3)
{
  __int16 v3; // dx
  __int16 v4; // bx
  bool result; // eax

  v3 = a1[5];
  result = 0;
  if ( a2 >= v3 && a2 < v3 + (__int16)a1[7] )
  {
    v4 = a1[6];
    if ( a3 >= v4 && a3 < v4 + (__int16)a1[8] )
      return 1;
  }
  return result;
}

//----- (0007B250) --------------------------------------------------------
char __fastcall sub_7B250(int a1, int a2, __int16 a3)
{
  int (__cdecl **i)(int); // esi
  int (__cdecl **j)(int); // esi
  char v6; // ah
  char *v8; // esi
  int (__cdecl **v9)(int); // edi
  _WORD *v10; // edi
  int v11; // eax
  __int16 v12[18]; // [esp+0h] [ebp-24h] BYREF

  for ( i = &off_E1BAC; *((_WORD *)i + 5); i += 11 )
  {
    if ( *((_WORD *)i + 4) && *i )
    {
      if ( (unsigned __int8)(*i)((int)i) )
      {
        *((_WORD *)i + 4) = 0;
        sub_7B5A0();
      }
      if ( i[1] )
      {
        *((_WORD *)i + 4) = 0;
        sub_6EDB0();
        sub_7A110(word_180660, 4);
        sub_7B5A0();
        sub_8CD27(dword_17DED4 + 234);
        if ( i[1] == (int (__cdecl *)(int))2 )
          i[1] = 0;
        return 1;
      }
      return 0;
    }
  }
  for ( j = &off_E1BAC; *((_WORD *)j + 5); j += 11 )
  {
    *((_WORD *)j + 4) = 0;
    v6 = byte_17DF10;
    *((_BYTE *)j + 24) = 0;
    if ( v6 == 1 && *((_BYTE *)j + 22) == 11 )
      *((_WORD *)j + 4) = 1;
  }
  if ( byte_17DF10 == 1 )
  {
    byte_17DF10 = 0;
  }
  else
  {
    j = &off_E1BAC;
    if ( *((_WORD *)&off_E1BAC + 5) )
    {
      while ( !sub_7B200(j, dword_17DEE4, SHIWORD(dword_17DEE4)) || !*((_BYTE *)j + 23) )
      {
        j += 11;
        if ( !*((_WORD *)j + 5) )
          goto LABEL_28;
      }
      if ( (word_17DEEE & 1) != 0 )
      {
        sub_8F100(0, 14, 127, 64, 0x64u, 0, 3u);
        *((_WORD *)j + 4) = 1;
        sub_7B5A0();
      }
      else
      {
        *((_BYTE *)j + 24) = 1;
        byte_17DBC6 = 1;
      }
    }
  }
LABEL_28:
  if ( *(_BYTE *)(dword_D41A4 + 10) != 1 || !byte_17DF13 || word_E29DC )
    return 0;
  LOBYTE(a3) = byte_17DBC6;
  if ( byte_17DBC6 == 2 )
  {
    dword_17DBBC = j___clock(dword_D41A4, a2, a3);
    if ( (dword_17DBBC - dword_17DBB8) / 0x64u > 1 )
    {
      if ( !word_E25DE[9 * ++word_17DBC4] )
        word_17DBC4 = 0;
      dword_17DBB8 = dword_17DBBC;
    }
    memset(v12, 0, sizeof(v12));
    v8 = (char *)&unk_E25DC + 18 * word_17DBC4;
    qmemcpy(v12, v8, 0x10u);
    qmemcpy(&v12[8], v8 + 16, sizeof(__int16));
    v9 = &off_E1BAC;
    sub_7E840(v12, 80, 89);
    if ( !*((_WORD *)&off_E1BAC + 5) )
      return 0;
    do
    {
      if ( *((_BYTE *)v9 + 22) == byte_E25ED[18 * word_17DBC4] )
      {
        *((_BYTE *)v9 + 24) = 1;
        return 0;
      }
      v9 += 11;
    }
    while ( *((_WORD *)v9 + 5) );
    return 0;
  }
  else
  {
    if ( byte_17DBC6 == 3 )
    {
      dword_17DBBC = j___clock(dword_D41A4, a2, a3);
      if ( (dword_17DBBC - dword_17DBB8) / 0x64u > 1 )
      {
        byte_17DBC6 = 2;
        return 0;
      }
      return 0;
    }
    v10 = &unk_E25DC;
    if ( *((_WORD *)&unk_E25DC + 1) )
    {
      while ( *((_BYTE *)v10 + 17) != *((_BYTE *)j + 22) )
      {
        v10 += 9;
        if ( !v10[1] )
          return 0;
      }
      memset(v12, 0, sizeof(v12));
      qmemcpy(v12, v10, 0x10u);
      qmemcpy(&v12[8], v10 + 8, sizeof(__int16));
      v11 = sub_7E840(v12, 80, 89);
      dword_17DBBC = j___clock(v11, a2, a3);
      dword_17DBB8 = dword_17DBBC;
      byte_17DBC6 = 3;
      return 0;
    }
    else
    {
      return 0;
    }
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E1BAC: using guessed type int (__cdecl *off_E1BAC)(int);
// E25DE: using guessed type __int16 word_E25DE[];
// E29DC: using guessed type __int16 word_E29DC;
// 17DBB8: using guessed type int dword_17DBB8;
// 17DBBC: using guessed type int dword_17DBBC;
// 17DBC4: using guessed type __int16 word_17DBC4;
// 17DBC6: using guessed type char byte_17DBC6;
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 17DF13: using guessed type char byte_17DF13;
// 180660: using guessed type __int16 word_180660;
// 7B250: using guessed type __int16 var_24[18];

//----- (0007B5A0) --------------------------------------------------------
void sub_7B5A0()
{
  _disable();
  word_17DEEE = 0;
  word_180744 = 0;
  word_18074A = 0;
  word_180746 = 0;
  word_18074C = 0;
  _enable();
}
// 17DEEE: using guessed type __int16 word_17DEEE;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;
// 18074A: using guessed type __int16 word_18074A;
// 18074C: using guessed type __int16 word_18074C;

//----- (0007B5D0) --------------------------------------------------------
void sub_7B5D0()
{
  int v0; // eax

  sub_90B27(0, 0x10u, 0);
  v0 = memset(dword_EA3D8, 0, 768);
  BYTE1(v0) = word_180660;
  if ( (word_180660 & 1) != 0 )
    sub_72883(v0, (void *)dword_180628, 0xC8u, 0);
  else
    sub_728A9(v0, (void *)dword_180628, 0x1E0u, 0);
  if ( (word_180660 & 1) != 0 )
    sub_90478();
  else
    sub_75200(480);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// EA3D8: using guessed type int dword_EA3D8;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0007B660) --------------------------------------------------------
int __cdecl sub_7B660(int a1, __int16 a2, __int16 a3, _WORD *a4, _BYTE *a5, char a6)
{
  int v6; // ebx
  unsigned __int8 v7; // al
  int v8; // edx
  __int16 v9; // ax
  int v10; // eax
  int v11; // edx
  __int16 v12; // si
  int v13; // eax
  int v14; // ecx
  __int16 v15; // bx
  int v16; // edx
  __int16 v17; // si
  __int16 v18; // ax
  __int16 v19; // cx
  __int16 v20; // bx
  int v21; // edx
  int v22; // eax
  int v23; // eax
  __int16 v24; // cx
  int v25; // edx
  int v26; // eax
  int v27; // ebx
  unsigned __int8 v28; // al
  _WORD v30[5]; // [esp+0h] [ebp-4Ch] BYREF
  __int16 v31; // [esp+Ah] [ebp-42h]
  __int16 v32; // [esp+Ch] [ebp-40h]
  __int16 v33; // [esp+Eh] [ebp-3Eh]
  __int16 v34; // [esp+10h] [ebp-3Ch]
  int v35; // [esp+2Ch] [ebp-20h]
  int v36; // [esp+30h] [ebp-1Ch]
  int v37; // [esp+34h] [ebp-18h]
  int v38; // [esp+38h] [ebp-14h]
  int v39; // [esp+3Ch] [ebp-10h]
  int v40; // [esp+40h] [ebp-Ch]
  unsigned __int8 v41; // [esp+44h] [ebp-8h]
  unsigned __int8 v42; // [esp+48h] [ebp-4h]
  __int16 v43; // [esp+64h] [ebp+18h]

  HIWORD(v6) = HIWORD(a4);
  v41 = 0;
  if ( !a3 )
  {
    sub_7C120(a1, a2, dword_17DED4 + 6 * word_17DF06);
    goto LABEL_31;
  }
  v42 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x25u, 0x1Fu, 0x19u);
  v35 = a2;
  v38 = (__int16)a1;
  sub_7C120(a1, a2, 6 * word_17DF06 + dword_17DED4);
  v7 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x2Au, 0x24u, 0x1Du);
  sub_7C140(
    (__int16)(a1 + 10),
    a2 + *(unsigned __int8 *)(dword_17DED4 + 6 * word_17DF06 + 5) - 2,
    (__int16)(*(unsigned __int8 *)(dword_17DED4 + 6 * word_17DF06 + 4) - 22),
    a3,
    v7);
  v36 = v42;
  v37 = (__int16)(a3 + a2);
  sub_2BD10(a1 + 10, a2, a1 + 10, a3 + a2, v42);
  v8 = 6 * word_17DF06 + dword_17DED4;
  v9 = a2 + *(unsigned __int8 *)(v8 + 5) - 2;
  sub_2BD10(a1 + *(unsigned __int8 *)(v8 + 4) - 12, v9, a1 + *(unsigned __int8 *)(v8 + 4) - 12, v9 + a3, v42);
  v10 = sub_7C120(a1, v37, dword_17DED4 + 6 * word_17DF06);
  if ( a4[5] >= a4[4] )
  {
    switch ( a6 )
    {
      case 3:
        LOWORD(v10) = *a4;
        v40 = v10 + 15;
        v11 = 6 * word_17DF0C + dword_17DED4;
        v12 = a4[4] + a4[1] - *(unsigned __int8 *)(v11 + 5);
        v32 = v12;
        v31 = v10 + 15;
        v33 = *(unsigned __int8 *)(v11 + 4);
        v34 = *(unsigned __int8 *)(v11 + 5);
        if ( sub_7B200(v30, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        {
          sub_7C120(v40, v12, dword_17DED4 + 6 * word_17DF0E);
          if ( (word_17DEEE & 1) != 0 )
            v41 = 1;
        }
        else
        {
          sub_7C120(v40, v12, dword_17DED4 + 6 * word_17DF0C);
        }
        v13 = 3 * word_17DF06;
        LOWORD(v13) = *(unsigned __int8 *)(dword_17DED4 + 6 * word_17DF06 + 4);
        LOWORD(v6) = *a4;
        v39 = v13 - 12 + v6;
        v14 = dword_17DED4 + 6 * word_17DF08;
        LOWORD(v13) = (unsigned __int8)v13 - 12 + v6 - *(unsigned __int8 *)(v14 + 4);
        v32 = v12;
        v15 = v13;
        v31 = v13;
        v33 = *(unsigned __int8 *)(v14 + 4);
        v36 = word_17DF0A;
        v34 = *(unsigned __int8 *)(6 * word_17DF0A + dword_17DED4 + 5);
        if ( sub_7B200(v30, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        {
          sub_7C120(v15, v12, dword_17DED4 + 6 * word_17DF0A);
          if ( (word_17DEEE & 1) != 0 )
            v41 = 2;
        }
        else
        {
          sub_7C120(v15, v12, dword_17DED4 + 6 * word_17DF08);
        }
        goto LABEL_23;
      case 1:
        v16 = 6 * word_17DF0C + dword_17DED4;
        v17 = *a4 + 30;
        v18 = a4[4] + a4[1];
        v19 = *(unsigned __int8 *)(v16 + 5);
        v31 = v17;
        v20 = v18 - v19;
        v32 = v18 - v19;
        v33 = *(unsigned __int8 *)(v16 + 4);
        v34 = *(unsigned __int8 *)(v16 + 5);
        if ( sub_7B200(v30, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        {
          sub_7C120(v17, v20, dword_17DED4 + 6 * word_17DF0E);
          if ( (word_17DEEE & 1) != 0 )
            v41 = 1;
          goto LABEL_23;
        }
        v21 = dword_17DED4;
        v22 = 6 * word_17DF0E;
        break;
      case 2:
        v23 = 3 * word_17DF0C;
        v17 = *a4 + 40;
        LOWORD(v23) = *(unsigned __int8 *)(dword_17DED4 + 6 * word_17DF0C + 5);
        v24 = a4[4];
        v39 = v23;
        v20 = v24 + a4[1] - (unsigned __int8)v23;
        v32 = v20;
        v36 = word_17DF08;
        v25 = 6 * word_17DF08 + dword_17DED4;
        v31 = v17;
        v33 = *(unsigned __int8 *)(v25 + 4);
        v34 = *(unsigned __int8 *)(v25 + 5);
        if ( sub_7B200(v30, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        {
          sub_7C120(v17, v20, dword_17DED4 + 6 * word_17DF0A);
          if ( (word_17DEEE & 1) != 0 )
            v41 = 1;
          goto LABEL_23;
        }
        v21 = 6 * word_17DF08;
        v22 = dword_17DED4;
        break;
      default:
        goto LABEL_23;
    }
    sub_7C120(v17, v20, v21 + v22);
LABEL_23:
    if ( !v41 )
    {
      if ( byte_17DF10 == 28 )
      {
        v41 = 1;
      }
      else if ( byte_17DF10 == 1 )
      {
        v41 = 2;
      }
    }
  }
  sub_6FC50(1);
  v26 = 6 * word_17DF06 + dword_17DED4;
  v27 = a1 + 10 + *(unsigned __int8 *)(v26 + 4) - 22;
  v43 = *(unsigned __int8 *)(v26 + 5) + 2 + a2;
  if ( a5 )
  {
    v28 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x16u, 0x10u, 9u);
    sub_7FCB0(v27, a5, (__int16)(a1 + 10), (__int16)v27, v43, 1, v28, 0);
  }
LABEL_31:
  if ( v41 )
    sub_8F100(0, 14, 127, 64, 0x64u, 0, 3u);
  return v41;
}
// 17DE38: using guessed type int dword_17DE38;
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF06: using guessed type __int16 word_17DF06;
// 17DF08: using guessed type __int16 word_17DF08;
// 17DF0A: using guessed type __int16 word_17DF0A;
// 17DF0C: using guessed type __int16 word_17DF0C;
// 17DF0E: using guessed type __int16 word_17DF0E;
// 17DF10: using guessed type char byte_17DF10;
// 7B660: using guessed type _WORD var_4C[5];

//----- (0007BEC0) --------------------------------------------------------
int (__cdecl **sub_7BEC0())(int)
{
  int (__cdecl **result)(int); // eax
  unsigned __int8 v1; // dl

  for ( result = &off_E1BAC; *((_WORD *)result + 5); result += 11 )
  {
    *((_WORD *)result + 4) = 0;
    v1 = *((_BYTE *)result + 22);
    *((_BYTE *)result + 24) = 0;
    if ( v1 >= 7u )
    {
      if ( v1 <= 7u )
      {
        *((_BYTE *)result + 23) = *(_WORD *)(dword_D41A4 + 216) != 0;
      }
      else if ( v1 == 13 )
      {
        *((_BYTE *)result + 23) = 1;
      }
    }
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// E1BAC: using guessed type int (__cdecl *off_E1BAC)(int);

//----- (0007BF20) --------------------------------------------------------
int __usercall sub_7BF20@<eax>(int a1@<edx>, __int16 *a2)
{
  _BYTE *v2; // esi
  int result; // eax
  __int16 v4; // di
  __int16 v5; // cx
  int v6; // eax
  __int16 v7; // ax

  v2 = 0;
  result = 0;
  if ( !*a2 )
    return result;
  if ( *(_BYTE *)(dword_D41A4 + 10) == 1 )
    byte_17DF13 = 0;
  sub_6FC50(1);
  if ( !a2[7] )
  {
    v4 = a2[5];
    if ( v4 )
    {
      if ( v4 <= a2[4] - 1 )
        a2[5] = v4 + 16;
      else
        a2[5] = a2[4];
    }
    else
    {
      ++a2[5];
    }
    goto LABEL_14;
  }
  v5 = a2[5] - 16;
  a2[5] = v5;
  if ( v5 >= 0 )
  {
LABEL_14:
    if ( a2[5] > sub_6FC30() + 10 )
      v2 = (_BYTE *)dword_E9C4C[a2[6]];
    v7 = sub_7B660(*a2, a2[1], a2[5], a2, v2, *((_BYTE *)a2 + 16));
    if ( v7 )
    {
      if ( !a2[7] )
        a2[7] = v7;
    }
    return 0;
  }
  a2[5] = 0;
  v6 = dword_D41A4;
  LOWORD(a1) = a2[7];
  a2[7] = 0;
  if ( *(_BYTE *)(v6 + 10) == 1 )
    byte_17DF13 = 1;
  return a1;
}
// D41A4: using guessed type int dword_D41A4;
// E9C4C: using guessed type int dword_E9C4C[];
// 17DF13: using guessed type char byte_17DF13;

//----- (0007C020) --------------------------------------------------------
_WORD *__cdecl sub_7C020(_WORD *a1)
{
  _WORD *result; // eax

  result = a1;
  if ( a1[2] )
  {
    a1[3] = 0;
    a1[2] = a1[3];
  }
  a1[5] = 0;
  return result;
}

//----- (0007C050) --------------------------------------------------------
int __fastcall sub_7C050(__int16 a1, __int16 a2)
{
  char v2; // bl
  unsigned int v3; // eax
  unsigned int v4; // esi
  _BOOL1 v5; // zf
  int result; // eax

  byte_17DF10 = 0;
  byte_17DF11 = 0;
  HIBYTE(a1) = 2;
  __asm { int     16h; KEYBOARD - GET SHIFT STATUS }
  v2 = a1;
  if ( a1 )
  {
    if ( (a1 & 1) != 0 )
    {
      byte_17DF10 = 54;
    }
    else if ( (a1 & 2) != 0 )
    {
      byte_17DF10 = 42;
    }
    else if ( (a1 & 4) != 0 )
    {
      byte_17DF10 = 29;
    }
    else if ( (a1 & 8) != 0 )
    {
      byte_17DF10 = 56;
    }
  }
  v3 = ((int (*)(void))j___clock)();
  v4 = v3;
  do
  {
    v5 = (v2 & 1) == 0;
    if ( (v2 & 1) == 0 )
    {
      v5 = (v2 & 2) == 0;
      if ( (v2 & 2) == 0 )
      {
        v5 = (v2 & 4) == 0;
        if ( (v2 & 4) == 0 )
        {
          v5 = (v2 & 8) == 0;
          if ( (v2 & 8) == 0 )
            break;
        }
      }
    }
    BYTE1(v3) = 2;
    HIBYTE(a2) = 2;
    __asm { int     16h; KEYBOARD - GET SHIFT STATUS }
    if ( v5 )
      HIBYTE(a2) = 1;
    v2 = v3;
    v3 = j___clock(v3, a2, v3) - v4;
  }
  while ( v3 <= 5 );
  while ( 1 )
  {
    result = sub_9A10A(v3);
    if ( !result )
      break;
    BYTE1(result) = 0;
    __asm { int     16h; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY }
    byte_17DF11 = result;
    v3 = (int)(unsigned __int16)result >> 8;
    byte_17DF10 = v3;
  }
  return result;
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 17DF10: using guessed type char byte_17DF10;
// 17DF11: using guessed type char byte_17DF11;

//----- (0007C120) --------------------------------------------------------
int __cdecl sub_7C120(__int16 a1, __int16 a2, int a3)
{
  return sub_2BB40(a1, a2, a3);
}

//----- (0007C140) --------------------------------------------------------
int __cdecl sub_7C140(int a1, __int16 a2, int a3, __int16 a4, unsigned __int8 a5)
{
  __int16 v5; // si
  __int16 v6; // bx
  int result; // eax
  __int16 v8; // dx
  __int16 v9; // cx

  v5 = a1;
  v6 = a2;
  result = a3;
  v8 = a4;
  if ( (__int16)a1 < 640 && a2 < 480 )
  {
    if ( a4 + a2 > 480 )
      v8 = 480 - a2;
    if ( (__int16)a1 + (__int16)a3 > 640 )
      result = 640 - a1;
    if ( (__int16)result >= 1 && v8 >= 1 )
    {
      if ( a2 < 0 )
      {
        v8 += a2;
        v6 = 0;
      }
      if ( (a1 & 0x8000u) != 0 )
      {
        LOWORD(result) = a1 + result;
        v5 = 0;
      }
      v9 = result;
      result = v5 + (__int16)result;
      if ( result >= 1 )
      {
        result = v6;
        if ( v6 + v8 >= 1 )
          return sub_2BC80(v5, v6, v9, v8, a5);
      }
    }
  }
  return result;
}

//----- (0007C200) --------------------------------------------------------
char __cdecl sub_7C200(unsigned __int8 a1)
{
  char result; // al

  result = 0;
  if ( a1 == 32 || a1 >= 0x30u && a1 <= 0x39u || a1 >= 0x41u && a1 <= 0x5Au || a1 >= 0x61u && a1 <= 0x7Au )
    return 1;
  return result;
}

//----- (0007C230) --------------------------------------------------------
int __fastcall sub_7C230(int a1, int a2, __int16 *a3)
{
  __int16 v3; // ax
  _WORD *v4; // eax
  _WORD *v5; // ebx
  int v6; // edx

  if ( (word_180660 & 1) != 0 )
  {
    a2 = dword_180628;
    a3 = (__int16 *)dword_E9C38;
    sub_9A128((const void *)dword_E9C38, (void *)dword_180628, 0xC8u);
  }
  else
  {
    sub_9A144((const void *)dword_E9C38, (void *)dword_180628, 0x1E0u);
  }
  v3 = sub_7C120(185, 232, dword_17DED4 + 396);
  sub_7AB00(v3, a2, a3, 4u);
  v4 = (_WORD *)sub_7BF20(a2, word_E1F70);
  v5 = v4;
  if ( (_WORD)v4 )
  {
    a2 = 1;
    word_E131A = 1;
    v4 = sub_7C020(word_E1F70);
  }
  v6 = j___clock(v4, a2, v5);
  if ( (unsigned int)(v6 - dword_E208C) >> 2 )
  {
    if ( (unsigned __int8)byte_E2097 >= word_E2094 )
      ++word_E2094;
    else
      word_E2094 = (unsigned __int8)byte_E2096;
    dword_E208C = v6;
  }
  sub_7C120(dword_17DEE4, SHIWORD(dword_17DEE4), 6 * word_E2094 + dword_17DED4);
  if ( (word_180660 & 1) != 0 )
    sub_90478();
  else
    sub_75200(480);
  sub_7A060();
  return (__int16)v5;
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// E131A: using guessed type __int16 word_E131A;
// E1F70: using guessed type __int16 word_E1F70[10];
// E208C: using guessed type int dword_E208C;
// E2094: using guessed type __int16 word_E2094;
// E2096: using guessed type char byte_E2096;
// E2097: using guessed type char byte_E2097;
// E9C38: using guessed type int dword_E9C38;
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0007C390) --------------------------------------------------------
int sub_7C390()
{
  int *v1; // ebx
  int (**v2)(); // ebx
  int v3; // esi
  __int16 v4; // dx
  __int16 i; // ax
  int v6; // [esp+0h] [ebp-8h]
  char *v7; // [esp+4h] [ebp-4h]

  v6 = dword_E9C38;
  dword_E9C38 = *(_DWORD *)(dword_D41A4 + 226);
  v7 = (char *)(dword_E9C38 + 307200);
  word_17DF00 = word_17DEFE;
  qmemcpy(byte_E1BA4, byte_E1B9C, sizeof(byte_E1BA4));
  if ( (unsigned __int16)sub_7CE50() )
  {
    dword_E9C38 = v6;
    return 1;
  }
  else
  {
    qmemcpy(byte_E1B9C, &byte_17DE68[11 * sub_74515() + 1], sizeof(byte_E1B9C));
    v1 = (int *)(&off_E1E98 + 6 * word_17DEF4);
    if ( (word_180660 & 1) != 0 )
      sub_9A128((const void *)dword_E9C38, (void *)dword_180628, 0xC8u);
    else
      sub_9A144((const void *)dword_E9C38, (void *)dword_180628, 0x1E0u);
    switch ( word_17DEF6 )
    {
      case 1:
        sub_7AA70((int)aDataScreensHsc, v7, *v1, v1[1]);
        sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE3C, v1[2], v1[3]);
        word_17DF02 = 0;
        word_17DEF6 = 3;
        v2 = &off_E1D64;
        v3 = sub_7CB10();
        break;
      case 2:
        word_17DF02 += 16;
        sub_7C9D0(word_17DF02);
        if ( (unsigned __int16)word_17DF02 < 0xFFu )
          goto LABEL_13;
        sub_7C7C0((unsigned __int8)word_17DEF2, dword_E9C38);
        word_17DEF6 = 1;
        v2 = &off_E1D64;
        v3 = sub_7CB10();
        break;
      case 3:
        sub_7C720(word_17DEF4, v7);
        word_17DF02 += 16;
        sub_7C800(word_17DF02);
        if ( (unsigned __int16)word_17DF02 <= 0xFEu )
          goto LABEL_13;
        word_17DEF6 = 4;
        v2 = &off_E1D64;
        v3 = sub_7CB10();
        break;
      case 5:
        sub_7C7C0((unsigned __int8)word_17DEF2, dword_E9C38);
        word_17DF02 = 255;
        sub_7C9D0(255);
        word_17DEF6 = 1;
        byte_17DE72[11 * word_17DEFC] = byte_17DE72[11 * sub_74515()];
        goto LABEL_13;
      default:
LABEL_13:
        v2 = &off_E1D64;
        v3 = sub_7CB10();
        break;
    }
    while ( *((_WORD *)v2 + 5) )
    {
      if ( *((_BYTE *)v2 + 23) && *((_BYTE *)v2 + 24) )
        sub_7C120(*((_WORD *)v2 + 5), *((_WORD *)v2 + 6), 6 * *((unsigned __int8 *)v2 + 21) + dword_17DED4);
      v2 += 11;
    }
    sub_7C140(382, 18, 16, 16, 0);
    sprintf(dword_17DE50, "%d", (unsigned __int16)word_17DEFA);
    sub_7FAE0((char *)dword_17DE50, 382, 398, 18, 0);
    sub_7D380();
    sub_7D310();
    v4 = 0;
    for ( i = 0; i < 8; ++i )
    {
      if ( byte_E1BA4[i] != byte_E1B9C[i] )
      {
        v4 = 1;
        break;
      }
    }
    if ( v4 || word_17DF00 != word_17DEFE )
      sub_41A90((unsigned __int8 *)dword_17DE38);
    dword_E9C38 = v6;
    return v3;
  }
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;
// E1D64: using guessed type int (*off_E1D64)();
// E1E98: using guessed type void *off_E1E98;
// E9C38: using guessed type int dword_E9C38;
// 17DE38: using guessed type int dword_17DE38;
// 17DE3C: using guessed type int dword_17DE3C;
// 17DE50: using guessed type int dword_17DE50;
// 17DED4: using guessed type int dword_17DED4;
// 17DEF2: using guessed type __int16 word_17DEF2;
// 17DEF4: using guessed type __int16 word_17DEF4;
// 17DEF6: using guessed type __int16 word_17DEF6;
// 17DEFA: using guessed type __int16 word_17DEFA;
// 17DEFC: using guessed type __int16 word_17DEFC;
// 17DEFE: using guessed type __int16 word_17DEFE;
// 17DF00: using guessed type __int16 word_17DF00;
// 17DF02: using guessed type __int16 word_17DF02;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (0007C710) --------------------------------------------------------
void sub_7C710()
{
  word_17DF02 = 0;
}
// 17DF02: using guessed type __int16 word_17DF02;

//----- (0007C720) --------------------------------------------------------
int __cdecl sub_7C720(unsigned __int8 a1, _BYTE *a2)
{
  void **v2; // eax
  __int16 v3; // bx
  __int16 v4; // dx
  __int16 v5; // cx
  __int16 v6; // ax

  v2 = &off_E1E98 + 6 * a1;
  v3 = *((_WORD *)v2 + 9);
  v4 = *((_WORD *)v2 + 8);
  v5 = *((_WORD *)v2 + 10);
  v6 = *((_WORD *)v2 + 11);
  if ( v3 + v6 > 480 )
    v6 = 480 - v3;
  if ( v5 + v4 > 640 )
    v4 = v5 + v4 - 640;
  return sub_85BF5(a2, dword_E9C38, v4, v3, v5, v6);
}
// E1E98: using guessed type void *off_E1E98;
// E9C38: using guessed type int dword_E9C38;

//----- (0007C7C0) --------------------------------------------------------
int __cdecl sub_7C7C0(int a1, int a2)
{
  return sub_85C42(a2, 208, 111, 200, 369, 0x9Fu);
}

//----- (0007C800) --------------------------------------------------------
unsigned __int8 __cdecl sub_7C800(__int16 a1)
{
  __int16 v1; // bx
  unsigned __int8 *v2; // edx
  unsigned __int8 *i; // eax
  unsigned __int8 v4; // ch
  unsigned __int8 v5; // ch
  unsigned __int8 v6; // ch
  unsigned __int8 *v7; // edx
  unsigned __int8 v8; // ch
  _BYTE *v9; // eax
  unsigned __int8 v10; // ch
  unsigned __int8 v11; // ch
  unsigned __int8 v12; // cl
  unsigned __int8 *v13; // edx
  unsigned __int8 v14; // ch
  _BYTE *v15; // eax
  unsigned __int8 v16; // ch
  unsigned __int8 v17; // ch
  unsigned int v19; // [esp+4h] [ebp-4h]

  v1 = a1;
  if ( (unsigned __int16)a1 > 0xFFu )
    v1 = 255;
  v2 = (unsigned __int8 *)(dword_17DE3C + 477);
  v19 = dword_17DE38 + 765;
  for ( i = (unsigned __int8 *)(dword_17DE38 + 477); (unsigned int)i < v19; i += 3 )
  {
    v4 = *v2;
    if ( *i < *v2 )
      *i = (unsigned __int16)(v4 * v1) >> 8;
    else
      *i = v4;
    v5 = v2[1];
    if ( i[1] < v5 )
      i[1] = (unsigned __int16)(v5 * v1) >> 8;
    else
      i[1] = v5;
    v6 = v2[2];
    if ( i[2] < v6 )
      i[2] = (unsigned __int16)(v6 * v1) >> 8;
    else
      i[2] = v6;
    v2 += 3;
  }
  v7 = (unsigned __int8 *)(dword_17DE38 + 444);
  v8 = *(_BYTE *)(dword_17DE3C + 444);
  v9 = (_BYTE *)(dword_17DE3C + 444);
  if ( *(_BYTE *)(dword_17DE38 + 444) < v8 )
    *v7 = (unsigned __int16)(v8 * v1) >> 8;
  else
    *v7 = v8;
  v10 = v9[1];
  if ( v7[1] < v10 )
    v7[1] = (unsigned __int16)(v10 * v1) >> 8;
  else
    v7[1] = v10;
  v11 = v9[2];
  if ( v7[2] < v11 )
    v7[2] = (unsigned __int16)(v1 * (unsigned __int8)v9[2]) >> 8;
  else
    v7[2] = v11;
  v12 = v7[3];
  v13 = v7 + 3;
  v14 = v9[3];
  v15 = v9 + 3;
  if ( v12 < v14 )
    *v13 = (unsigned __int16)(v14 * v1) >> 8;
  else
    *v13 = v14;
  v16 = v15[1];
  if ( v13[1] < v16 )
    v13[1] = (unsigned __int16)(v16 * v1) >> 8;
  else
    v13[1] = v16;
  v17 = v15[2];
  if ( v13[2] < v17 )
    v13[2] = (unsigned __int16)((unsigned __int8)v15[2] * v1) >> 8;
  else
    v13[2] = v17;
  sub_9A0FC();
  return sub_41A90((unsigned __int8 *)dword_17DE38);
}
// 17DE38: using guessed type int dword_17DE38;
// 17DE3C: using guessed type int dword_17DE3C;

//----- (0007C9D0) --------------------------------------------------------
unsigned __int8 __cdecl sub_7C9D0(__int16 a1)
{
  __int16 v1; // cx
  unsigned __int8 *i; // eax
  __int16 v3; // bx
  int v4; // eax
  int v5; // eax
  unsigned int v7; // [esp+4h] [ebp-4h]

  v1 = a1;
  if ( (unsigned __int16)a1 > 0xFFu )
    v1 = 255;
  v7 = dword_17DE38 + 765;
  for ( i = (unsigned __int8 *)(dword_17DE38 + 477);
        (unsigned int)i < v7;
        *(i - 1) = v3 - ((unsigned __int16)(v3 * v1) >> 8) )
  {
    *i -= (unsigned __int16)(v1 * *i) >> 8;
    i[1] -= (unsigned __int16)(v1 * i[1]) >> 8;
    v3 = i[2];
    i += 3;
  }
  v4 = dword_17DE38;
  *(_BYTE *)(dword_17DE38 + 447) -= (unsigned __int16)(v1 * *(unsigned __int8 *)(dword_17DE38 + 447)) >> 8;
  *(_BYTE *)(v4 + 448) -= (unsigned __int16)(v1 * *(unsigned __int8 *)(v4 + 448)) >> 8;
  *(_BYTE *)(v4 + 449) -= (unsigned __int16)(v1 * *(unsigned __int8 *)(v4 + 449)) >> 8;
  v5 = dword_17DE38;
  *(_BYTE *)(dword_17DE38 + 444) -= (unsigned __int16)(v1 * *(unsigned __int8 *)(dword_17DE38 + 444)) >> 8;
  *(_BYTE *)(v5 + 445) -= (unsigned __int16)(v1 * *(unsigned __int8 *)(v5 + 445)) >> 8;
  *(_BYTE *)(v5 + 446) -= (unsigned __int16)(*(unsigned __int8 *)(v5 + 446) * v1) >> 8;
  sub_9A0FC();
  return sub_41A90((unsigned __int8 *)dword_17DE38);
}
// 17DE38: using guessed type int dword_17DE38;

//----- (0007CB10) --------------------------------------------------------
int sub_7CB10()
{
  int (**i)(); // ebx
  int result; // eax
  int (**j)(); // ebx
  int (**v3)(); // ebx

  for ( i = &off_E1D64; *((_WORD *)i + 5); i += 11 )
  {
    if ( *((_WORD *)i + 4) && *i )
    {
      result = ((int (__cdecl *)(int (**)()))*i)(i);
      if ( (_BYTE)result )
      {
        *((_WORD *)i + 4) = 0;
        sub_7B5A0();
        return 1;
      }
      else
      {
        LOWORD(result) = 0;
        *((_WORD *)i + 4) = 0;
      }
      return result;
    }
  }
  for ( j = &off_E1D64; *((_WORD *)j + 5); *((_BYTE *)j - 20) = 0 )
  {
    j += 11;
    *((_WORD *)j - 18) = 0;
  }
  v3 = &off_E1D64;
  if ( !*((_WORD *)&off_E1D64 + 5) )
    return 0;
  while ( !sub_7B200(v3, dword_17DEE4, SHIWORD(dword_17DEE4)) || !*((_BYTE *)v3 + 23) )
  {
    v3 += 11;
    if ( !*((_WORD *)v3 + 5) )
      return 0;
  }
  if ( (word_17DEEE & 1) != 0 )
  {
    *((_WORD *)v3 + 4) = 1;
    sub_7B5A0();
    sub_8F100(0, 14, 127, 64, 0x64u, 0, 3u);
  }
  else
  {
    *((_BYTE *)v3 + 24) = 1;
  }
  return 0;
}
// E1D64: using guessed type int (*off_E1D64)();
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;

//----- (0007CBF0) --------------------------------------------------------
char sub_7CBF0()
{
  word_17DEF8 = 0;
  byte_17DE71[11 * word_17DEFC] = 3;
  word_17DF02 = 0;
  word_17DEF6 = 2;
  word_17DEF2 = word_17DEF4;
  return 0;
}
// 17DEF2: using guessed type __int16 word_17DEF2;
// 17DEF4: using guessed type __int16 word_17DEF4;
// 17DEF6: using guessed type __int16 word_17DEF6;
// 17DEF8: using guessed type __int16 word_17DEF8;
// 17DEFC: using guessed type __int16 word_17DEFC;
// 17DF02: using guessed type __int16 word_17DF02;

//----- (0007CC40) --------------------------------------------------------
char sub_7CC40()
{
  word_17DF02 = 0;
  word_17DEF8 = 1;
  byte_17DE71[11 * word_17DEFC] = 4;
  word_17DEF6 = 2;
  word_17DEF2 = word_17DEF4;
  return 0;
}
// 17DEF2: using guessed type __int16 word_17DEF2;
// 17DEF4: using guessed type __int16 word_17DEF4;
// 17DEF6: using guessed type __int16 word_17DEF6;
// 17DEF8: using guessed type __int16 word_17DEF8;
// 17DEFC: using guessed type __int16 word_17DEFC;
// 17DF02: using guessed type __int16 word_17DF02;

//----- (0007CCA0) --------------------------------------------------------
int sub_7CCA0()
{
  int v0; // ebx
  int v1; // ebx

  v0 = word_17DEFC;
  if ( v0 == sub_74515() && word_17DEFE == 1 || (v1 = word_17DEFC, v1 != sub_74515()) )
    byte_17DE71[11 * word_17DEFC] = 1;
  return 0;
}
// 17DEFC: using guessed type __int16 word_17DEFC;
// 17DEFE: using guessed type __int16 word_17DEFE;

//----- (0007CCF0) --------------------------------------------------------
int sub_7CCF0()
{
  char v0; // dl

  v0 = byte_17DE72[11 * word_17DEFC];
  if ( v0 > 50 )
  {
    byte_17DE72[11 * word_17DEFC] = v0 - 1;
    byte_17DE71[11 * word_17DEFC] = 6;
  }
  return 0;
}
// 17DEFC: using guessed type __int16 word_17DEFC;

//----- (0007CD30) --------------------------------------------------------
int sub_7CD30()
{
  char *v0; // esi
  char v2[4]; // [esp+0h] [ebp-Ch] BYREF
  char v3[8]; // [esp+4h] [ebp-8h] BYREF

  v0 = (&off_D9208)[byte_17DE72[11 * word_17DEFC]];
  qmemcpy(v2, v0, sizeof(v2));
  qmemcpy(v3, v0 + 4, 1u);
  if ( v2[0] && v2[0] != 48 )
  {
    ++byte_17DE72[11 * word_17DEFC];
    byte_17DE71[11 * word_17DEFC] = 6;
  }
  return 0;
}
// D9208: using guessed type char *off_D9208;
// 17DEFC: using guessed type __int16 word_17DEFC;
// 7CD30: using guessed type char anonymous_0[8];

//----- (0007CDA0) --------------------------------------------------------
int sub_7CDA0()
{
  byte_17DE71[11 * word_17DEFC] = 5;
  return 0;
}
// 17DEFC: using guessed type __int16 word_17DEFC;

//----- (0007CDC0) --------------------------------------------------------
int __cdecl sub_7CDC0(unsigned __int8 a1, unsigned __int8 a2)
{
  _BYTE *v2; // eax
  int v3; // edx

  v2 = (_BYTE *)(3 * (2 * a1 + 134) + dword_EA3D8);
  v3 = 3 * a2;
  *v2 = byte_E1711[v3];
  v2[1] = byte_E1712[v3];
  v2[2] = byte_E1713[v3];
  v2[3] = byte_E172C[v3];
  v2[4] = byte_E172D[v3];
  v2[5] = byte_E172E[v3];
  return 0;
}
// EA3D8: using guessed type int dword_EA3D8;

//----- (0007CE50) --------------------------------------------------------
int sub_7CE50()
{
  __int16 v0; // bx
  char *v1; // edx
  __int16 i; // bx
  __int16 j; // di
  _BYTE *v4; // esi
  int v5; // edi
  int v6; // edi
  int v7; // eax
  int v8; // edi
  int v9; // eax
  __int16 v10; // dx
  int v11; // eax
  char v12; // ch
  int v14; // [esp+0h] [ebp-Ch]
  char v15; // [esp+4h] [ebp-8h]
  char v16; // [esp+4h] [ebp-8h]

  v14 = 0;
  byte_17DE68[11 * word_17DEFC] = 1;
  sub_74374();
  v0 = 0;
  sub_7438A((int)byte_17DE68, 0xBu);
  do
  {
    v1 = &byte_17DE68[11 * v0 + 1];
    qmemcpy(v1, &byte_17DE68[11 * sub_74515() + 1], 8u);
    ++v0;
    qmemcpy(byte_E131C, v1, sizeof(byte_E131C));
  }
  while ( v0 < 8 );
  for ( i = 0; i < 8; ++i )
  {
    if ( byte_17DE68[11 * i] )
    {
      switch ( byte_17DE71[11 * i] )
      {
        case 1:
          for ( j = 0; j < 7; ++j )
          {
            v4 = (_BYTE *)(3 * (2 * j + 134) + dword_17DE38);
            *v4 = 0;
            v4 += 3;
            *(v4 - 2) = 0;
            *(v4 - 1) = 0;
            v4[1] = 0;
            v4[2] = 0;
            *v4 = 0;
            sub_41A90((unsigned __int8 *)dword_17DE38);
          }
          byte_17DE68[11 * i] = 0;
          sub_73AA1(i);
          if ( i == word_17DEFC )
            v14 = 1;
          break;
        case 2:
          v5 = sub_74515();
          if ( v5 == sub_74536() )
          {
            if ( i <= 0 )
              byte_17DE69[11 * sub_74515() + i] = i;
            else
              byte_17DE69[11 * sub_74515() + i] = i - 1;
            goto LABEL_21;
          }
          break;
        case 3:
          v8 = sub_74515();
          if ( v8 == sub_74536() && (unsigned __int16)word_17DEFE < 7u )
          {
LABEL_21:
            v9 = sub_74515();
            v16 = sub_7D230(1, byte_17DE69[11 * v9 + i], i);
            byte_17DE69[11 * sub_74515() + i] = v16;
          }
          break;
        case 4:
          v6 = sub_74515();
          if ( v6 == sub_74536() && (unsigned __int16)word_17DEFE < 7u )
          {
            v7 = sub_74515();
            v15 = sub_7D230(0, byte_17DE69[11 * v7 + i], i);
            byte_17DE69[11 * sub_74515() + i] = v15;
          }
          break;
        case 5:
          *(_WORD *)(dword_D41A0 + 12) = word_17DEFC;
          v10 = byte_17DE72[11 * sub_74515()];
          v11 = dword_D41A4;
          v12 = *(_BYTE *)(dword_D41A4 + 22);
          *(_WORD *)(dword_D41A4 + 43) = v10;
          *(_BYTE *)(v11 + 22) = v12 | 0x10;
          *(_WORD *)(dword_D41A0 + 14) = word_17DEFE;
          sub_7449C();
          word_E29DC = 1;
          v14 = 1;
          break;
        case 6:
          byte_17DE72[11 * word_17DEFC] = byte_17DE72[11 * i];
          break;
        default:
          continue;
      }
    }
  }
  byte_17DE71[11 * word_17DEFC] = 0;
  word_17DEF4 = byte_17DE69[11 * sub_74515() + word_17DEFC];
  sub_7D1F0();
  return v14;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E29DC: using guessed type __int16 word_E29DC;
// 17DE38: using guessed type int dword_17DE38;
// 17DEF4: using guessed type __int16 word_17DEF4;
// 17DEFC: using guessed type __int16 word_17DEFC;
// 17DEFE: using guessed type __int16 word_17DEFE;

//----- (0007D1F0) --------------------------------------------------------
int sub_7D1F0()
{
  int result; // eax

  result = 0;
  word_17DEFE = 0;
  do
  {
    if ( byte_17DE68[11 * (__int16)result] )
      ++word_17DEFE;
    ++result;
  }
  while ( (__int16)result < 8 );
  return result;
}
// 17DEFE: using guessed type __int16 word_17DEFE;

//----- (0007D230) --------------------------------------------------------
int __cdecl sub_7D230(char a1, unsigned __int8 a2, unsigned __int8 a3)
{
  int v3; // ebx
  __int16 v4; // si
  __int16 v5; // si
  __int16 v7; // [esp+0h] [ebp-8h]
  __int16 v8; // [esp+4h] [ebp-4h]

  v3 = a2;
  if ( a1 )
  {
    do
    {
      if ( (--v3 & 0x8000u) != 0 )
        v3 = 7;
      v5 = 0;
      v7 = 0;
      while ( v5 < 8 )
      {
        if ( v5 != a3 && byte_17DE68[11 * v5] && byte_17DE69[11 * sub_74515() + v5] == (_WORD)v3 )
        {
          v7 = 1;
          break;
        }
        ++v5;
      }
    }
    while ( v7 );
  }
  else
  {
    do
    {
      if ( (__int16)++v3 > 7 )
        v3 = 0;
      v4 = 0;
      v8 = 0;
      while ( v4 < 8 )
      {
        if ( v4 != a3 && byte_17DE68[11 * v4] && byte_17DE69[11 * sub_74515() + v4] == (_WORD)v3 )
        {
          v8 = 1;
          break;
        }
        ++v4;
      }
    }
    while ( v8 );
  }
  return v3;
}

//----- (0007D310) --------------------------------------------------------
int sub_7D310()
{
  __int16 v0; // bx
  int result; // eax
  int v2; // eax
  __int16 v3; // [esp+0h] [ebp-4h]

  v0 = 0;
  v3 = 0;
  do
  {
    result = 11 * v0;
    if ( byte_17DE68[result] )
    {
      if ( v0 != word_17DEFC )
      {
        v2 = sub_74515();
        result = sub_7CDC0(v3++, byte_17DE69[11 * v2 + v0]);
      }
    }
    ++v0;
  }
  while ( v0 < 8 );
  return result;
}
// 17DEFC: using guessed type __int16 word_17DEFC;

//----- (0007D380) --------------------------------------------------------
unsigned int sub_7D380()
{
  int v0; // eax
  char v2[40]; // [esp+0h] [ebp-28h] BYREF

  sub_85C42(dword_180628, 246, 14, 109, 14, 0x9Fu);
  sub_6FC50(1);
  v0 = byte_17DE72[11 * word_17DEFC];
  sprintf(v2, "%d. %s", v0 - 49, off_D9204[v0]);
  return sub_7FAE0(v2, 246, 355, 14, 0);
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D9204: using guessed type char *off_D9204[2];
// 17DEFC: using guessed type __int16 word_17DEFC;
// 180628: using guessed type int dword_180628;

//----- (0007D400) --------------------------------------------------------
int __usercall sub_7D400@<eax>(int a1@<eax>, __int16 a2, __int16 a3, char a4)
{
  int v4; // edx
  _WORD *v5; // ebx
  __int16 v6; // cx
  char *i; // ebx
  unsigned __int8 v8; // al
  char v9; // cl
  _WORD *j; // ebx
  unsigned __int16 v11; // ax
  int v12; // eax
  int v13; // eax
  int v14; // edi
  char *v16; // eax
  char *v17; // edx
  _WORD *v18; // eax
  __int16 v19; // bx
  __int16 *k; // eax
  __int16 v21[18]; // [esp+0h] [ebp-54h] BYREF
  int v22[6]; // [esp+24h] [ebp-30h] BYREF
  int v23; // [esp+3Ch] [ebp-18h]
  int v24; // [esp+40h] [ebp-14h]
  int v25; // [esp+44h] [ebp-10h]
  _WORD *v26; // [esp+48h] [ebp-Ch]
  char *v27; // [esp+4Ch] [ebp-8h]
  int v28; // [esp+50h] [ebp-4h]

  v28 = -1;
  v4 = 0;
  v5 = &unk_E26C8;
  v27 = 0;
  v26 = 0;
  v25 = j___clock(a1, 0, &unk_E26C8);
  while ( v5[4] )
  {
    if ( byte_E1B82 != 1 || (v6 = v5[6], v6 != 85) && v6 != 86 )
      sub_81CA0(a2, 0, a2, a3, (int)v5);
    v5 += 15;
  }
  for ( i = (char *)&unk_E1960; *((_WORD *)i + 2); i += 22 )
  {
    v8 = i[18];
    if ( v8 )
    {
      if ( v8 <= 1u )
      {
        v27 = i;
        sub_7E5A0(a2, v4, a2, a3, (int)i, 37, 43);
      }
      else if ( v8 == 2 )
      {
        LOBYTE(v4) = a4;
        if ( a4 == 3 || a4 == 5 )
        {
          v9 = i[19];
          v26 = i;
          if ( v9 )
          {
            if ( v9 == 1 )
            {
              if ( (unsigned __int16)sub_7E5A0(a2, v4, a2, a3, (int)i, 70, 83) )
              {
                *((_WORD *)i + 8) = 33;
                i[19] = 2;
              }
            }
            else
            {
              sub_7E5A0(a2, v4, a2, a3, (int)i, 33, 35);
            }
          }
          else
          {
            sub_8F100(0, 41, 127, 64, 0x64u, 0, 2u);
            i[19] = 1;
          }
        }
      }
    }
    if ( i[18] == 2 )
      break;
  }
  for ( j = word_E2970; j[6]; j = (_WORD *)((char *)j + 17) )
  {
    v11 = j[6];
    if ( !v11 )
      continue;
    if ( v11 <= 1u )
    {
      memset(v22, 0, 22);
      v22[0] = *(_DWORD *)j;
      LOWORD(v22[4]) = j[7];
      v22[3] = *((_DWORD *)j + 2);
      sub_7E5A0(a2, v4, a2, a3, (int)v22, 305, 311);
LABEL_40:
      *(_DWORD *)j = v22[0];
      j[7] = v22[4];
      continue;
    }
    if ( v11 == 2 && a4 == 3 )
    {
      LOBYTE(v4) = *((_BYTE *)j + 16);
      if ( !(_BYTE)v4 )
      {
        sub_8F100(0, 41, 127, 64, 0x64u, 0, 2u);
        *((_BYTE *)j + 16) = 1;
        continue;
      }
      if ( (_BYTE)v4 != 1 )
      {
        memset(v22, 0, 22);
        v22[0] = *(_DWORD *)j;
        LOWORD(v22[4]) = j[7];
        v22[3] = *((_DWORD *)j + 2);
        sub_7E5A0(a2, v4, a2, a3, (int)v22, 270, 272);
        goto LABEL_40;
      }
      memset(v22, 0, 22);
      v22[0] = *(_DWORD *)j;
      LOWORD(v22[4]) = j[7];
      v22[3] = *((_DWORD *)j + 2);
      if ( (unsigned __int16)sub_7E5A0(a2, v4, a2, a3, (int)v22, 70, 83) )
      {
        j[7] = 270;
        *((_BYTE *)j + 16) = 2;
      }
      else
      {
        j[7] = v22[4];
      }
      *(_DWORD *)j = v22[0];
    }
  }
  LOBYTE(j) = a4;
  if ( a4 == 3 && *(_BYTE *)(dword_D41A4 + 10) == 1 )
  {
    v24 = dword_17DEC0;
    v23 = dword_17DEC4;
    dword_17DEC0 = dword_17DEC8;
    HIWORD(v12) = HIWORD(dword_17DECC);
    dword_17DEC4 = dword_17DECC;
    if ( word_17DB74 )
    {
      if ( (unsigned __int16)word_17DB74 <= 1u )
      {
        if ( v27 )
        {
          if ( byte_17DB8F == 3 )
          {
            memset(v21, 0, sizeof(v21));
            qmemcpy(v21, &unk_E24F2, 0x10u);
            qmemcpy(&v21[8], (char *)&unk_E24F2 + 16, sizeof(__int16));
            v21[1] = *((_WORD *)v27 + 6) - 80 - a2;
            v21[2] = *((_WORD *)v27 + 7) - 60 - a3;
            v21[3] = *((_WORD *)v27 + 6) + 16 - a2;
            v21[4] = *((_WORD *)v27 + 7) - 60 - a3;
            v21[6] = *((_WORD *)v27 + 6) + 16 - a2;
            v21[7] = *((_WORD *)v27 + 7) - 4 - a3;
            v21[0] = 464;
            v14 = (int)v26;
            sub_7E840(v21, 238, 264);
            if ( v14 )
            {
              if ( (v25 - dword_17DB70) / 0x64u > 8 )
              {
                dword_17DB70 = v25;
                word_17DB74 = 2;
              }
            }
          }
        }
      }
      else if ( word_17DB74 == 2 )
      {
        if ( v26 )
        {
          if ( byte_17DB8F == 3 )
          {
            memset(v21, 0, sizeof(v21));
            v21[1] = v26[6] - 80 - a2;
            v21[2] = v26[7] - 60 - a3;
            v21[3] = v26[6] + 16 - a2;
            v21[4] = v26[7] - 60 - a3;
            v21[6] = v26[6] + 16 - a2;
            v21[7] = v26[7] - 4 - a3;
            v21[0] = 465;
            sub_7E840(v21, 238, 264);
            if ( v27 )
            {
              if ( (v25 - dword_17DB70) / 0x64u > 8 )
              {
                dword_17DB70 = v25;
                word_17DB74 = 1;
              }
            }
          }
        }
      }
    }
    else
    {
      LOBYTE(v12) = v26 != 0;
      BYTE1(v12) = 0;
      v13 = v12 + 1;
      word_17DB74 = v13;
      dword_17DB70 = j___clock(v13, v4, j);
    }
    dword_17DEC0 = v24;
    dword_17DEC4 = v23;
  }
  if ( byte_17DB8E )
    return v28;
  if ( word_17DB8A != -1 )
  {
    v16 = (char *)&unk_E1960;
    v17 = 0;
    while ( *((_WORD *)v16 + 2) )
    {
      if ( v16[18] == 1 )
        v17 = v16;
      v16 += 22;
    }
    v18 = &unk_E1960;
    v19 = 0;
    while ( v18[2] )
    {
      if ( v19 == word_17DB8A )
      {
        sub_7DA70(v18[6], v18[7], *((_WORD *)v17 + 6), *((_WORD *)v17 + 7), a2, a3);
        return v28;
      }
      v18 += 11;
      ++v19;
    }
    for ( k = word_E2970; k[6]; k = (__int16 *)((char *)k + 17) )
    {
      if ( word_17DB8A == k[3] )
      {
        sub_7DA70(k[4], k[5], word_E196C[11 * k[2]], word_E196E[11 * k[2]], a2, a3);
        return v28;
      }
    }
    return v28;
  }
  if ( v27 && v26 )
  {
    sub_7DA70(*((_WORD *)v27 + 6), *((_WORD *)v27 + 7), v26[6], v26[7], a2, a3);
    return v28;
  }
  if ( !v27 || v26 )
    return v28;
  sub_7DA70(*((_WORD *)v27 + 6), *((_WORD *)v27 + 7), word_E1B66, word_E1B68, a2, a3);
  return v28;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E196C: using guessed type __int16 word_E196C[];
// E196E: using guessed type __int16 word_E196E[];
// E1B66: using guessed type __int16 word_E1B66;
// E1B68: using guessed type __int16 word_E1B68;
// E1B82: using guessed type char byte_E1B82;
// E2970: using guessed type _WORD word_E2970[51];
// 17DB70: using guessed type int dword_17DB70;
// 17DB74: using guessed type __int16 word_17DB74;
// 17DB8A: using guessed type __int16 word_17DB8A;
// 17DB8E: using guessed type char byte_17DB8E;
// 17DB8F: using guessed type char byte_17DB8F;
// 17DEC0: using guessed type int dword_17DEC0;
// 17DEC4: using guessed type int dword_17DEC4;
// 17DEC8: using guessed type int dword_17DEC8;
// 17DECC: using guessed type int dword_17DECC;

//----- (0007DA70) --------------------------------------------------------
int __cdecl sub_7DA70(__int16 a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6)
{
  int v6; // edx
  int v7; // ebx
  __int16 v8; // ax
  int v9; // edx
  __int16 v10; // ax
  int v11; // ebx
  int v12; // edx
  __int16 v14[4]; // [esp+0h] [ebp-10h] BYREF
  __int16 v15[4]; // [esp+8h] [ebp-8h] BYREF

  word_17E074 = a3;
  v6 = *(unsigned __int8 *)(dword_17DED4 + 226);
  word_17E06C = a1;
  v7 = v6 >> 1;
  v8 = (v6 >> 1) + a3;
  v9 = *(unsigned __int8 *)(dword_17DED4 + 227);
  word_17E074 = v8;
  v9 >>= 1;
  word_17E076 = v9 + a4;
  word_17E06C = v7 + a1;
  word_17E06E = v9 + a2;
  v15[0] = v8;
  v15[1] = v9 + a4;
  v14[0] = v7 + a1;
  v14[1] = v9 + a2;
  v10 = sub_581E0(v15, v14);
  if ( v10 <= 1024 || v10 >= 1536 )
  {
    if ( v10 <= 1536 || v10 >= 2048 )
    {
      if ( v10 <= 0 || v10 >= 512 )
      {
        if ( v10 <= 512 || v10 >= 1024 )
        {
          if ( v10 != 2048 && v10 )
          {
            if ( v10 == 512 )
            {
              if ( byte_17E082 != 9 )
              {
                word_17E080 = 9;
                byte_17E083 = 12;
                byte_17E082 = 9;
              }
            }
            else if ( v10 == 1024 )
            {
              if ( byte_17E082 != 1 )
              {
                byte_17E082 = 1;
                word_17E080 = 1;
                byte_17E083 = 4;
              }
            }
            else if ( v10 == 1536 && byte_17E082 != 25 )
            {
              word_17E080 = 25;
              byte_17E082 = 25;
              byte_17E083 = 28;
            }
          }
          else if ( byte_17E082 != 17 )
          {
            byte_17E082 = 17;
            word_17E080 = 17;
            byte_17E083 = 20;
          }
        }
        else if ( byte_17E082 != 13 )
        {
          word_17E080 = 13;
          byte_17E082 = 13;
          byte_17E083 = 16;
        }
      }
      else if ( byte_17E082 != 5 )
      {
        byte_17E082 = 5;
        word_17E080 = 5;
        byte_17E083 = 8;
      }
    }
    else if ( byte_17E082 != 29 )
    {
      word_17E080 = 29;
      byte_17E083 = 32;
      byte_17E082 = 29;
    }
  }
  else if ( byte_17E082 != 21 )
  {
    word_17E080 = 21;
    byte_17E082 = 21;
    byte_17E083 = 24;
  }
  word_17E07C = word_17E06C;
  word_17E07E = word_17E06E;
  v11 = 6 * word_17E080 + dword_17DED4;
  v12 = word_17E06C - ((int)*(unsigned __int8 *)(v11 + 4) >> 1) - a5;
  return sub_81260(
           (__int16)v12,
           v12,
           (int)&unk_17E078,
           word_17E06C - ((int)*(unsigned __int8 *)(v11 + 4) >> 1) - a5,
           word_17E06E - ((int)*(unsigned __int8 *)(v11 + 5) >> 1) - a6);
}
// 17DED4: using guessed type int dword_17DED4;
// 17E06C: using guessed type __int16 word_17E06C;
// 17E06E: using guessed type __int16 word_17E06E;
// 17E074: using guessed type __int16 word_17E074;
// 17E076: using guessed type __int16 word_17E076;
// 17E07C: using guessed type __int16 word_17E07C;
// 17E07E: using guessed type __int16 word_17E07E;
// 17E080: using guessed type __int16 word_17E080;
// 17E082: using guessed type char byte_17E082;
// 17E083: using guessed type char byte_17E083;

//----- (0007DD70) --------------------------------------------------------
int sub_7DD70()
{
  int v0; // esi
  int result; // eax
  __int16 v2; // dx
  char v3; // bl

  v0 = dword_D41A4;
  result = (int)&unk_E1960;
  v2 = 0;
  while ( *(_WORD *)(result + 4) )
  {
    v3 = *(_BYTE *)(result + 18);
    *(_BYTE *)(result + 20) = 0;
    if ( v3 == 2 )
      *(_WORD *)(result + 16) = 70;
    if ( (*(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) & 2) != 0
      && *(unsigned __int16 *)(v0 + 43) == v2 )
    {
      *(_BYTE *)(result + 18) = 1;
    }
    if ( *(_BYTE *)(result + 18) == 1 )
      *(_WORD *)(result + 16) = 37;
    result += 22;
    ++v2;
    *(_BYTE *)(result - 3) = 0;
  }
  if ( *(_WORD *)(v0 + 43) > 0x18u )
  {
    for ( result = (int)&unk_E2970; *(_WORD *)(result + 12); result += 17 )
    {
      if ( *(unsigned __int16 *)(v0 + 43) == *(__int16 *)(result + 6) )
      {
        if ( (*(_BYTE *)(dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12) + 11232) & 2) != 0 )
        {
          *(_WORD *)(result + 12) = 1;
          *(_WORD *)(result + 14) = 305;
        }
        else if ( *(_WORD *)(result + 12) == 3 )
        {
          *(_WORD *)(result + 12) = 2;
          *(_WORD *)(result + 14) = 70;
        }
        byte_E1972[22 * *(__int16 *)(result + 4)] = 1;
        result = 22 * *(__int16 *)(result + 4);
        *(__int16 *)((char *)&word_E1970 + result) = 37;
        break;
      }
    }
  }
  dword_D41A4 = v0;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E1970: using guessed type __int16 word_E1970;

//----- (0007DE80) --------------------------------------------------------
char __usercall sub_7DE80@<al>(int a1@<ebx>, int a2)
{
  int v2; // edi
  int v3; // eax
  __int16 *v4; // ebx
  int v5; // edx
  int v6; // eax
  int v7; // esi
  int v8; // esi
  char v9; // al
  int v10; // edx
  _BOOL1 v11; // zf
  __int16 v12; // si
  unsigned __int8 v13; // al
  __int16 v14; // si
  unsigned __int8 v15; // al
  int v16; // edx
  int v17; // eax
  char v19[12]; // [esp+0h] [ebp-20h] BYREF
  int v20; // [esp+Ch] [ebp-14h]
  __int16 v21; // [esp+10h] [ebp-10h]
  int v22; // [esp+14h] [ebp-Ch]
  char v23; // [esp+18h] [ebp-8h]
  char v24; // [esp+1Ch] [ebp-4h]

  v21 = 0;
  memset(v19, 0, 10);
  *(_DWORD *)(a2 + 4) = 0;
  v2 = j___clock(a2, 0, a1);
  v3 = sub_6FC50(1);
  LOWORD(v3) = *(_WORD *)(a2 + 26);
  v22 = v3 + 10;
  HIWORD(v3) = HIWORD(dword_17DED4);
  v4 = (__int16 *)(a2 + 26);
  LOWORD(v3) = *(unsigned __int8 *)(dword_17DED4 + 436);
  v5 = *(__int16 *)(a2 + 34);
  v20 = v22 + v3 - 22;
  v6 = v5;
  v5 >>= 31;
  v7 = ((v6 - v5) >> 1) + *(__int16 *)(a2 + 28);
  v8 = v7 - sub_6FC30();
  v9 = sub_7BF20(v5, (__int16 *)(a2 + 26));
  v10 = *(__int16 *)(a2 + 34);
  v23 = v9;
  if ( *(__int16 *)(a2 + 36) <= v10 / 2 )
    goto LABEL_13;
  if ( (unsigned __int8)byte_17DF10 < 0xFu )
  {
    v11 = byte_17DF10 == 14;
    goto LABEL_6;
  }
  if ( (unsigned __int8)byte_17DF10 > 0xFu )
  {
    v11 = byte_17DF10 == 83;
LABEL_6:
    if ( !v11
      && (unsigned __int16)word_17DEF0 < 0xCu
      && (unsigned __int8)byte_17DF11 >= 0x30u
      && (unsigned __int8)byte_17DF11 <= 0x39u )
    {
      byte_E29DF = byte_17DF11 - 48;
    }
  }
  sprintf(v19, "%d", (unsigned __int8)byte_E29DF);
  sub_6FC50(1);
  v12 = sub_6FC30() + v8;
  v13 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, 0);
  v4 = (__int16 *)v12;
  v14 = sub_6FC80(v19, v22, v20, v12, v13);
  if ( (v2 - dword_17DED0) / 0xCu )
  {
    sub_6FC50(1);
    v15 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, 0);
    sub_2BC10(&asc_D1AB3[1], v14 - 2, (__int16)v4, v15);
    dword_17DED0 = v2;
  }
LABEL_13:
  if ( v23 )
  {
    LOBYTE(v4) = v23;
    sub_7C020((_WORD *)(a2 + 26));
    if ( (_BYTE)v4 == 1 )
    {
      word_E131A = 0;
      word_17DEFA = (unsigned __int8)byte_E29DF;
      sub_7B5A0();
      if ( *(_BYTE *)(dword_D41A4 + 10) == 1 )
        v24 = byte_17DF13;
      v16 = dword_EB394;
      v17 = sub_8CD27(dword_EB394);
      *(_DWORD *)(a2 + 4) = sub_77680(v17, v16, v4) != 0;
      if ( *(_BYTE *)(dword_D41A4 + 10) == 1 )
        byte_17DF13 = v24;
    }
    else
    {
      byte_E29DF = word_17DEFA;
    }
    return 1;
  }
  return v21;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98786: using guessed type __int64 __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E131A: using guessed type __int16 word_E131A;
// E29DF: using guessed type char byte_E29DF;
// EB394: using guessed type int dword_EB394;
// 17DE38: using guessed type int dword_17DE38;
// 17DED0: using guessed type int dword_17DED0;
// 17DED4: using guessed type int dword_17DED4;
// 17DEF0: using guessed type __int16 word_17DEF0;
// 17DEFA: using guessed type __int16 word_17DEFA;
// 17DF10: using guessed type char byte_17DF10;
// 17DF11: using guessed type char byte_17DF11;
// 17DF13: using guessed type char byte_17DF13;

//----- (0007E0E0) --------------------------------------------------------
int sub_7E0E0()
{
  int v0; // esi
  _WORD *v2; // ebx
  int v3; // edx

  v0 = 0;
  if ( byte_17DF10 == 1 )
    return 2;
  v2 = word_E1F84;
  if ( !word_E1F84[5] )
    return 0;
  do
  {
    if ( (word_17DEEE & 1) == 0 || (_WORD)v0 )
    {
      if ( *((_BYTE *)v2 + 24) && sub_7B200(v2, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        v3 = *((unsigned __int8 *)v2 + 20);
      else
        v3 = *((unsigned __int8 *)v2 + 21);
      sub_2BB40(v2[5], v2[6], dword_17DED4 + 6 * v3);
    }
    else if ( sub_7B200(v2, dword_17DEE4, SHIWORD(dword_17DEE4)) )
    {
      sub_8F100(0, 14, 127, 64, 0x64u, 0, 3u);
      sub_2BB40(v2[5], v2[6], dword_17DED4 + 6 * *((unsigned __int8 *)v2 + 20));
      LOWORD(v0) = *((unsigned __int8 *)v2 + 22);
    }
    v2 += 22;
  }
  while ( v2[5] );
  return v0;
}
// E1F84: using guessed type _WORD word_E1F84[66];
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;

//----- (0007E1F0) --------------------------------------------------------
int sub_7E1F0()
{
  _WORD *v0; // ebx
  int v1; // esi
  int v3; // ecx
  int v4; // edx

  v0 = word_E2008;
  v1 = 0;
  if ( !word_E2008[5] )
    return 0;
  do
  {
    v3 = dword_17DED4;
    v4 = *((unsigned __int8 *)v0 + 21);
    v0[7] = *(unsigned __int8 *)(dword_17DED4 + 6 * v4 + 4);
    v0[8] = *(unsigned __int8 *)(v3 + 6 * v4 + 5);
    if ( (word_17DEEE & 1) == 0 )
    {
      if ( sub_7B200(v0, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        sub_2BB40(v0[5], v0[6], 6 * *((unsigned __int8 *)v0 + 21) + dword_17DED4);
      goto LABEL_9;
    }
    if ( sub_7B200(v0, dword_17DEE4, SHIWORD(dword_17DEE4)) )
    {
      sub_8F100(0, 14, 127, 64, 0x64u, 0, 3u);
      sub_2BB40(v0[5], v0[6], dword_17DED4 + 6 * *((unsigned __int8 *)v0 + 21));
      LOWORD(v1) = *((unsigned __int8 *)v0 + 22);
      if ( *((_BYTE *)v0 + 22) )
        break;
    }
LABEL_9:
    v0 += 22;
  }
  while ( v0[5] );
  return v1;
}
// E2008: using guessed type _WORD word_E2008[66];
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;

//----- (0007E320) --------------------------------------------------------
int __usercall sub_7E320@<eax>(int a1@<edx>, int a2@<edi>)
{
  int (__cdecl **i)(int); // esi
  int (__cdecl **v3)(int); // esi
  int (__cdecl **j)(int); // esi
  unsigned __int8 v5; // al
  int (__cdecl **k)(int); // esi
  int v8; // edi
  int v9; // eax
  char *v10; // edi
  int v11; // edi
  int v12; // esi
  __int16 v13[18]; // [esp+0h] [ebp-24h] BYREF

  for ( i = &off_E23E0; *((_BYTE *)i + 25); i += 11 )
  {
    if ( *((_BYTE *)i + 23) )
    {
      a2 = *((unsigned __int8 *)i + 21);
      LOWORD(a1) = dword_17DED4;
      sub_7C120(*((_WORD *)i + 5), *((_WORD *)i + 6), dword_17DED4 + 6 * a2);
    }
  }
  if ( byte_17DB8E )
    return 0;
  v3 = &off_E23E0;
  if ( *((_BYTE *)&off_E23E0 + 25) )
  {
    do
    {
      if ( *((_WORD *)v3 + 4) && *v3 )
      {
        v5 = (*v3)((int)v3);
        LOWORD(a2) = v5;
        if ( !v5 )
          return 1;
        *((_WORD *)v3 + 4) = 0;
        sub_7B5A0();
        return a2;
      }
      v3 += 11;
    }
    while ( *((_BYTE *)v3 + 25) );
    j = &off_E23E0;
    if ( !*((_BYTE *)&off_E23E0 + 25) )
    {
      k = &off_E23E0;
      goto LABEL_34;
    }
    goto LABEL_17;
  }
  for ( j = &off_E23E0; *((_BYTE *)j + 25); *((_BYTE *)j - 20) = 0 )
  {
LABEL_17:
    if ( *((_BYTE *)j + 23) && *((_BYTE *)j + 24) )
    {
      LOWORD(a1) = dword_17DED4;
      sub_7C120(*((_WORD *)j + 5), *((_WORD *)j + 6), dword_17DED4 + 6 * *((unsigned __int8 *)j + 20));
    }
    j += 11;
    *((_WORD *)j - 18) = 0;
  }
  for ( k = &off_E23E0; ; k += 11 )
  {
LABEL_34:
    if ( !*((_BYTE *)k + 25) )
    {
      sub_82510(a1, dword_17DBA8);
      return 0;
    }
    if ( *((_BYTE *)k + 23) )
    {
      v8 = dword_17DED4;
      a1 = *((unsigned __int8 *)k + 20);
      *((_WORD *)k + 7) = *(unsigned __int8 *)(dword_17DED4 + 6 * a1 + 4);
      *((_WORD *)k + 8) = *(unsigned __int8 *)(v8 + 6 * a1 + 5);
      if ( sub_7B200(k, dword_17DEE4, SHIWORD(dword_17DEE4)) )
        break;
    }
LABEL_33:
    ;
  }
  if ( (word_17DEEE & 1) != 0 )
  {
    *((_WORD *)k + 4) = 1;
    sub_7B5A0();
    sub_8F100(0, 14, 127, 64, 0x64u, 0, 3u);
    goto LABEL_33;
  }
  v9 = dword_D41A4;
  *((_BYTE *)k + 24) = 1;
  if ( *(_BYTE *)(v9 + 10) != 1 )
    return 0;
  v10 = (char *)&unk_E2516;
  if ( !*((_WORD *)&unk_E2516 + 1) )
    return 0;
  do
  {
    if ( v10[17] == *((_BYTE *)k + 22) )
    {
      memset(v13, 0, sizeof(v13));
      qmemcpy(v13, v10, 0x10u);
      qmemcpy(&v13[8], v10 + 16, sizeof(__int16));
      v11 = dword_17DEC0;
      v12 = dword_17DEC4;
      dword_17DEC0 = dword_17DEC8;
      dword_17DEC4 = dword_17DECC;
      sub_7E840(v13, 238, 264);
      dword_17DEC0 = v11;
      dword_17DEC4 = v12;
      return 0;
    }
    v10 += 18;
  }
  while ( *((_WORD *)v10 + 1) );
  return 0;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E23E0: using guessed type int (__cdecl *off_E23E0)(int);
// 17DB8E: using guessed type char byte_17DB8E;
// 17DBA8: using guessed type int dword_17DBA8[3];
// 17DEC0: using guessed type int dword_17DEC0;
// 17DEC4: using guessed type int dword_17DEC4;
// 17DEC8: using guessed type int dword_17DEC8;
// 17DECC: using guessed type int dword_17DECC;
// 17DED4: using guessed type int dword_17DED4;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 7E320: using guessed type __int16 var_24[18];

//----- (0007E5A0) --------------------------------------------------------
int __usercall sub_7E5A0@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3, __int16 a4, int a5, __int16 a6, __int16 a7)
{
  int v7; // edx
  int v8; // esi
  __int16 v9; // ax

  v7 = j___clock(a1, a2, a5);
  v8 = 0;
  if ( (unsigned int)(v7 - *(_DWORD *)a5) >> 3 )
  {
    v9 = *(_WORD *)(a5 + 16);
    if ( v9 <= a7 )
    {
      *(_WORD *)(a5 + 16) = v9 + 1;
    }
    else
    {
      v8 = 1;
      *(_WORD *)(a5 + 16) = a6;
    }
    *(_DWORD *)a5 = v7;
  }
  sub_7C120(*(_WORD *)(a5 + 12) - a3, *(_WORD *)(a5 + 14) - a4, dword_17DED4 + 6 * *(__int16 *)(a5 + 16));
  return v8;
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 17DED4: using guessed type int dword_17DED4;

//----- (0007E620) --------------------------------------------------------
int __cdecl sub_7E620(int a1)
{
  *(_WORD *)(a1 + 8) = 0;
  return 2;
}

//----- (0007E640) --------------------------------------------------------
int __usercall sub_7E640@<eax>(int a1@<edx>, int a2)
{
  __int16 v2; // ax
  _WORD *i; // eax
  _WORD *j; // eax

  if ( a2 )
    v2 = sub_7BF20(a1, (__int16 *)(a2 + 26));
  else
    v2 = 1;
  if ( v2 == 1 )
  {
    *(_WORD *)(dword_D41A4 + 43) = 0;
    memset(dword_17DBC8, 0, 500);
    memset(dword_17DDBC, 0, 100);
    for ( i = &unk_E1960; i[2]; *(i - 3) = 70 )
    {
      i += 11;
      *((_BYTE *)i - 4) = 2;
      *((_BYTE *)i - 3) = 0;
    }
    for ( j = word_E2970; j[6]; *((_BYTE *)j - 1) = 0 )
    {
      j = (_WORD *)((char *)j + 17);
      *(_WORD *)((char *)j - 5) = 3;
      *(_WORD *)((char *)j - 3) = 70;
    }
    memset(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230 + 1609, 0, 505);
    sub_86860(word_1803EC);
    sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE64, (int)&loc_B2C44 + 3, (int)&loc_87D80 + 3);
    sub_7AA70(0, 0, 0, 0);
    byte_17E09D = 0;
    *(_WORD *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) = 0;
    memset(&dword_17DB70, 0, 56);
    word_17E080 = 13;
    word_17E06C = 0;
    byte_17E082 = 13;
    byte_17E09C = 0;
    word_17E06E = 480;
    byte_17E083 = 16;
    byte_17DB8F = 1;
    if ( a2 )
    {
      *(_WORD *)(a2 + 8) = 0;
      sub_7C020((_WORD *)(a2 + 26));
    }
    return 1;
  }
  else if ( v2 == 2 )
  {
    *(_WORD *)(a2 + 8) = 0;
    sub_7C020((_WORD *)(a2 + 26));
    return 1;
  }
  else
  {
    return 0;
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E2970: using guessed type _WORD word_E2970[51];
// 17DB70: using guessed type int dword_17DB70;
// 17DB8F: using guessed type char byte_17DB8F;
// 17DBC8: using guessed type int dword_17DBC8[];
// 17DDBC: using guessed type int dword_17DDBC[];
// 17DE64: using guessed type int dword_17DE64;
// 17E06C: using guessed type __int16 word_17E06C;
// 17E06E: using guessed type __int16 word_17E06E;
// 17E080: using guessed type __int16 word_17E080;
// 17E082: using guessed type char byte_17E082;
// 17E083: using guessed type char byte_17E083;
// 17E09C: using guessed type char byte_17E09C;
// 17E09D: using guessed type char byte_17E09D;
// 1803EC: using guessed type __int16 word_1803EC;

//----- (0007E800) --------------------------------------------------------
char __cdecl sub_7E800(_WORD *a1)
{
  char result; // al

  result = sub_78730(a1);
  if ( result )
    a1[4] = 0;
  return result;
}

//----- (0007E820) --------------------------------------------------------
char __cdecl sub_7E820(int a1)
{
  char result; // al

  result = sub_780F0(a1);
  if ( result )
    *(_WORD *)(a1 + 8) = 0;
  return result;
}

//----- (0007E840) --------------------------------------------------------
int __cdecl sub_7E840(__int16 *a1, __int16 a2, __int16 a3)
{
  __int16 *v3; // ebx
  __int16 v5; // dx

  v3 = a1;
  if ( !a1[1] )
    return 0;
  do
  {
    v5 = v3[1];
    if ( v5 )
    {
      sub_81360(v3[3], v3[4], v3[6], v3[7], a3);
      sub_7FCB0((int)v3, (_BYTE *)dword_E9C4C[*v3], v5, (__int16)(v5 + 180), v3[2], 0, 0, a2);
    }
    v3 += 9;
  }
  while ( v3[1] );
  return 0;
}
// E9C4C: using guessed type int dword_E9C4C[];

//----- (0007E8D0) --------------------------------------------------------
int __cdecl sub_7E8D0(__int16 *a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7)
{
  __int16 v7; // dx
  __int16 v8; // dx
  __int16 v9; // dx
  __int16 v10; // ax
  int result; // eax
  __int16 v12; // di
  __int16 v13; // dx

  *a1 = a2 - a4;
  a1[1] = a3 - a5;
  a1[2] = 2 * abs16(*a1);
  v7 = *a1;
  a1[3] = 2 * abs16(a1[1]);
  if ( v7 >= 0 )
  {
    if ( v7 )
      a1[4] = a6;
    else
      a1[4] = 0;
  }
  else
  {
    a1[4] = -a6;
  }
  v8 = a1[1];
  if ( v8 >= 0 )
  {
    if ( v8 )
      a1[5] = a7;
    else
      a1[5] = 0;
  }
  else
  {
    a1[5] = -a7;
  }
  a1[6] = a2;
  a1[7] = a3;
  v9 = a1[3];
  v10 = a1[2];
  if ( v10 <= v9 )
  {
    result = v10 - (v9 >> 1);
    a1[8] = result;
  }
  else
  {
    result = v10 >> 1;
    a1[8] = v9 - result;
  }
  v12 = a1[6];
  a1[9] = 0;
  if ( a4 >= v12 )
  {
    if ( a4 > v12 )
      a1[10] = 1;
  }
  else
  {
    a1[10] = 2;
  }
  v13 = a1[7];
  if ( a5 >= v13 )
  {
    if ( a5 > v13 )
      a1[11] = 1;
  }
  else
  {
    a1[11] = 2;
  }
  return result;
}

//----- (0007E9D0) --------------------------------------------------------
int __cdecl sub_7E9D0(__int16 *a1, __int16 *a2, _WORD *a3)
{
  __int16 v4; // cx
  unsigned __int16 v5; // cx
  __int16 v6; // si
  __int16 v7; // di
  unsigned __int16 v8; // dx
  __int16 v9; // cx
  __int16 v10; // si

  if ( a3[2] <= a3[3] )
  {
    if ( *a2 == a3[7] )
      return 1;
    if ( (__int16)a3[8] >= 0 )
    {
      *a1 += a3[4];
      a3[8] -= a3[3];
    }
    *a2 += a3[5];
    v4 = a3[2];
  }
  else
  {
    if ( *a1 == a3[6] )
      return 1;
    if ( (__int16)a3[8] >= 0 )
    {
      *a2 += a3[5];
      a3[8] -= a3[2];
    }
    *a1 += a3[4];
    v4 = a3[3];
  }
  a3[8] += v4;
  v5 = a3[10];
  if ( v5 )
  {
    if ( v5 <= 1u )
    {
      v6 = a3[6];
      if ( *a1 < v6 )
        *a1 = v6;
    }
    else if ( v5 == 2 )
    {
      v7 = a3[6];
      if ( *a1 > v7 )
        *a1 = v7;
    }
  }
  v8 = a3[11];
  if ( v8 )
  {
    if ( v8 <= 1u )
    {
      v9 = a3[7];
      if ( *a2 < v9 )
        *a2 = v9;
    }
    else if ( v8 == 2 )
    {
      v10 = a3[7];
      if ( *a2 > v10 )
        *a2 = v10;
    }
  }
  return 0;
}

//----- (0007EAE0) --------------------------------------------------------
int __cdecl sub_7EAE0(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, char *a5, __int16 *a6)
{
  int v6; // edx
  int v7; // eax
  int v8; // eax
  _WORD *v9; // eax
  char *v10; // eax
  int v11; // ecx
  char *v12; // eax
  int v13; // ecx
  _WORD *v14; // eax
  __int16 v15; // cx
  __int16 *i; // eax
  int v17; // ecx
  _WORD *j; // eax
  int v19; // eax
  __int16 v20; // cx
  int v21; // eax
  int v22; // eax
  __int16 v23; // cx
  int v24; // eax
  int v25; // edx
  char v26; // cl
  int v27; // eax
  int v28; // eax
  int v29; // eax
  char v30; // cl
  int v31; // ecx
  unsigned __int8 *v32; // edi
  int v33; // eax
  _WORD *v34; // eax
  _WORD *v35; // edi
  __int16 v36; // ax
  int v37; // eax
  __int16 v39; // [esp-14h] [ebp-70h]
  __int16 v40; // [esp-10h] [ebp-6Ch]
  __int16 v41; // [esp-Ch] [ebp-68h]
  __int16 v42; // [esp-Ch] [ebp-68h]
  _WORD v43[5]; // [esp+0h] [ebp-5Ch] BYREF
  __int16 v44; // [esp+Ah] [ebp-52h]
  __int16 v45; // [esp+Ch] [ebp-50h]
  __int16 v46; // [esp+Eh] [ebp-4Eh]
  __int16 v47; // [esp+10h] [ebp-4Ch]
  int v48; // [esp+2Ch] [ebp-30h]
  char *v49; // [esp+30h] [ebp-2Ch]
  _WORD *k; // [esp+34h] [ebp-28h]
  _WORD *v51; // [esp+38h] [ebp-24h]
  _WORD *v52; // [esp+3Ch] [ebp-20h]
  int v53; // [esp+40h] [ebp-1Ch]
  int v54; // [esp+44h] [ebp-18h]
  int v55; // [esp+48h] [ebp-14h]
  int v56; // [esp+4Ch] [ebp-10h]
  int v57; // [esp+50h] [ebp-Ch]
  char *v58; // [esp+54h] [ebp-8h]
  int v59; // [esp+58h] [ebp-4h]

  v6 = 0;
  LOBYTE(v7) = *a5;
  v59 = 0;
  v55 = -1;
  HIWORD(v7) = 0;
  switch ( (char)v7 )
  {
    case 1:
      v12 = (char *)&unk_E1960;
      v6 = 0;
      v13 = 0;
      v49 = 0;
      while ( *((_WORD *)v12 + 2) )
      {
        BYTE1(v6) = v12[18];
        if ( BYTE1(v6) == 1 )
        {
          *a1 = *((_WORD *)v12 + 2);
          v49 = v12;
          LOWORD(v6) = *((_WORD *)v12 + 3);
          v55 = v13;
          *a2 = v6;
        }
        v12 += 22;
        ++v13;
      }
      if ( !v49 || word_17DB8A == -1 || (_WORD)v55 == word_17DB8A )
      {
        word_17DB8A = -1;
      }
      else
      {
        v14 = &unk_E1960;
        v15 = 0;
        while ( v14[2] )
        {
          if ( v15 == word_17DB8A )
          {
            *a1 = v14[2];
            *a2 = v14[3];
            *a5 = 3;
            break;
          }
          v14 += 11;
          ++v15;
        }
        if ( *a5 != 3 )
        {
          for ( i = word_E2970; i[6]; i = (__int16 *)((char *)i + 17) )
          {
            if ( word_17DB8A == i[3] )
            {
              *a1 = word_E1964[11 * i[2]];
              *a2 = word_E1966[11 * i[2]];
              *a5 = 3;
              break;
            }
          }
        }
      }
      memset(&dword_17DE28, 0, 13);
      if ( word_17DB8A == -1 )
      {
        v17 = 0;
        for ( j = &unk_E1960; ; j += 11 )
        {
          v54 = v17;
          if ( !j[2] )
            break;
          if ( *((_BYTE *)j + 18) == 2 )
          {
            *a3 = j[2];
            v6 = (int)a4;
            *a4 = j[3];
            if ( (_WORD)v54 )
            {
              *a5 = 2;
              j = (_WORD *)sub_7E8D0(a6, *a3, *a4, *a1, *a2, 4, 4);
            }
            else
            {
              *a1 = j[2];
              LOWORD(j) = j[3];
              *a2 = (__int16)j;
              *a5 = 3;
              if ( *a2 > 480 )
                *a2 = 480;
              if ( *a1 > 640 )
                *a1 = 640;
              v6 = v54;
              *a5 = 3;
              if ( (__int16)v6 < 24 )
              {
                word_17DE30 = *a1;
                word_17DE32 = *a2;
                v19 = dword_D41A4;
                byte_17DE34 = ((*(_BYTE *)(dword_D41A4 + 24) & 0x40) != 0) + 1;
                LOBYTE(v19) = byte_17DE34;
                j = (_WORD *)j___clock(v19, v6, a2);
                dword_17DE28 = (int)j;
              }
            }
            break;
          }
          v17 = v54 + 1;
        }
        if ( *a5 != 1 || byte_17DB8E )
          goto LABEL_66;
      }
      else
      {
        memset(&dword_17DE28, 0, 13);
        j = &unk_E1960;
        v20 = 0;
        while ( j[2] )
        {
          if ( *((_BYTE *)j + 18) == 2 )
          {
            if ( v20 < 24 )
            {
              word_17DE30 = *a1;
              word_17DE32 = *a2;
              v21 = dword_D41A4;
              byte_17DE34 = ((*(_BYTE *)(dword_D41A4 + 24) & 0x40) != 0) + 1;
              LOBYTE(v21) = byte_17DE34;
              j = (_WORD *)j___clock(v21, v6, a2);
              dword_17DE28 = (int)j;
            }
            break;
          }
          j += 11;
          ++v20;
        }
      }
      *a5 = 3;
LABEL_66:
      sub_81760((int)j);
      goto LABEL_92;
    case 2:
      v6 = (int)a6;
      if ( (unsigned __int16)sub_7E9D0(a1, a2, a6) )
      {
        *a5 = 3;
        memset(&dword_17DE28, 0, 13);
        word_17DE30 = *a1;
        word_17DE32 = *a2;
        v22 = dword_D41A4;
        byte_17DE34 = ((*(_BYTE *)(dword_D41A4 + 24) & 0x40) != 0) + 1;
        LOBYTE(v22) = byte_17DE34;
        dword_17DE28 = j___clock(v22, a6, a2);
      }
      goto LABEL_92;
    case 3:
      if ( byte_17DB8E )
        goto LABEL_92;
      v23 = dword_17DEE4;
      if ( (_WORD)dword_17DEE4 )
      {
        if ( (__int16)dword_17DEE4 < 638 )
          goto LABEL_75;
        LOWORD(v7) = word_17DB82;
        LOWORD(v6) = *a1;
        v23 = 0;
        v6 += v7;
      }
      else
      {
        LOWORD(v7) = word_17DB82;
        LOWORD(v6) = *a1;
        v6 -= v7;
      }
      word_E29D6 = v23;
      *a1 = v6;
LABEL_75:
      if ( HIWORD(dword_17DEE4) )
      {
        if ( SHIWORD(dword_17DEE4) < 478 )
          goto LABEL_80;
        LOWORD(v7) = word_17DB82;
        LOWORD(v6) = *a2;
        v6 += v7;
      }
      else
      {
        LOWORD(v7) = word_17DB82;
        LOWORD(v6) = *a2;
        v6 -= v7;
      }
      word_E29D6 = 0;
      *a2 = v6;
LABEL_80:
      if ( *a1 >= 0 )
      {
        if ( *a1 >= 638 )
          *a1 = 638;
      }
      else
      {
        *a1 = 0;
      }
      if ( *a2 >= 0 )
      {
        if ( *a2 >= 478 )
          *a2 = 478;
      }
      else
      {
        *a2 = 0;
      }
      if ( word_E29D6 )
      {
        word_17DB82 = 0;
      }
      else
      {
        word_17DB82 += 4;
        if ( word_17DB82 > 24 )
          word_17DB82 = 24;
      }
      goto LABEL_92;
    case 4:
      if ( word_17DB8A > 24 )
      {
        v9 = sub_824E0(word_17DB8A);
        if ( !v9 )
          goto LABEL_10;
        *a1 = word_E1964[11 * (__int16)v9[2]];
        v8 = 11 * (__int16)v9[2];
      }
      else
      {
        v8 = 11 * word_17DB8A;
        *a1 = word_E1964[v8];
      }
      *a2 = word_E1966[v8];
LABEL_10:
      if ( byte_17DF10 || word_17DEEE )
      {
        *a5 = 1;
        word_17DEEE = 0;
        byte_17DF11 = 0;
        byte_17DF10 = 0;
      }
      v10 = (char *)&unk_E1960;
      v6 = 0;
      v52 = 0;
      v58 = 0;
      while ( *((_WORD *)v10 + 2) )
      {
        if ( v10[18] == 2 )
        {
          v52 = v10;
          break;
        }
        v6 = (int)(v58 + 1);
        v10 += 22;
        ++v58;
      }
      v11 = (int)v52;
      if ( v52 )
      {
        LOWORD(v10) = v52[2];
        *((_BYTE *)v52 - 4) = 2;
        v58 = v10;
        *(_WORD *)(v11 + 4) = 0;
      }
      sub_81760((int)v10);
      if ( v52 )
      {
        v6 = (int)v52;
        *((_BYTE *)v52 - 4) = 1;
        *(_WORD *)(v6 + 4) = (_WORD)v58;
      }
LABEL_92:
      if ( word_E29D6 )
      {
        sub_85C8B(dword_17DE64, (char *)dword_180628, *a1, *a2, 160, 480);
        sub_7D400(*a1, *a1, *a2, *a5);
        LOWORD(v28) = sub_81EE0(*a1, v6, (int)a2, (__int16)a5, *a1, *a2);
        LOBYTE(v28) = byte_17DB8E;
        if ( byte_17DB8E )
        {
          v28 = sub_80D40((__int16)a1, *a1, *a2, word_17DB84, word_17DB86, word_17DB88);
          v59 = v28;
          if ( (_WORD)v28 )
          {
            BYTE1(v28) = 0;
            byte_17DB8E = 0;
          }
        }
        v25 = dword_17DE5C;
        sub_85CC3(v28, (int)a2, (unsigned __int16 *)dword_17DE5C);
        LOBYTE(v25) = *a5;
        if ( *a5 == 4 )
        {
          v27 = word_17DB8A;
          goto LABEL_107;
        }
        if ( (_BYTE)v25 == 5 )
        {
          v27 = word_17DB8C;
          goto LABEL_107;
        }
      }
      else
      {
        sub_85C8B(dword_17DE64, (char *)dword_180628, *a1, *a2, 160, 480);
        sub_7D400(*a1, *a1, *a2, *a5);
        LOWORD(v24) = sub_81EE0(*a1, v6, (int)a2, (__int16)a5, *a1, *a2);
        if ( byte_17DB8E )
        {
          v24 = sub_80D40((__int16)a1, *a1, *a2, word_17DB84, word_17DB86, word_17DB88);
          v59 = v24;
          if ( (_WORD)v24 )
            byte_17DB8E = 0;
        }
        sub_85CC3(v24, (int)a2, (unsigned __int16 *)dword_17DE5C);
        v25 = 1;
        v26 = *a5;
        word_E29D6 = 1;
        if ( v26 == 4 )
        {
          v27 = word_17DB8A;
LABEL_107:
          sub_82C20(v27, v27);
          goto LABEL_108;
        }
        if ( v26 == 5 )
        {
          v27 = word_17DB8C;
          goto LABEL_107;
        }
      }
LABEL_108:
      v29 = sub_7E320(v25, (int)a5);
      v57 = v29;
      if ( !byte_17DB8E && !(_WORD)v59 && !(_WORD)v29 && *a5 == 3 )
      {
        LOBYTE(v25) = byte_17DF11;
        if ( byte_17DF11 == 111 || byte_17DF11 == 79 )
        {
          v30 = byte_17DE34;
          if ( byte_17DE34 == 1 )
          {
            v29 = dword_17DE2C;
            dword_17DE28 = dword_17DE2C;
            byte_17DE34 = 2;
            byte_17E09D = v30;
          }
          else if ( byte_17DE34 == 2 )
          {
            v29 = j___clock(v29, v25, a2);
            LOWORD(v25) = 1;
            dword_17DE2C = v29;
            byte_17DE34 = 1;
            dword_17DE28 = v29;
            byte_17E09D = 0;
          }
        }
        LOBYTE(v29) = byte_17DE34;
        if ( (unsigned __int8)byte_17DE34 < 2u )
        {
          if ( byte_17DE34 == 1 )
          {
            v31 = j___clock(v29, v25, a2);
            dword_17DE2C = v31;
            v48 = 100;
            if ( (v31 - dword_17DE28) / 0x64u > 0xF )
            {
              dword_17DE28 = v31;
              byte_17DE34 = 2;
            }
            if ( word_17DE32 < 478 )
              v41 = 280;
            else
              v41 = 60;
            sub_80C30(130, v41, 380);
          }
        }
        else if ( (unsigned __int8)byte_17DE34 < 4u )
        {
          sub_80C30(0, 0, 0);
        }
      }
      if ( (_WORD)v57 == 2 && !(_WORD)v59 && !byte_17DB8E )
        v59 = v57;
      if ( !(_WORD)v57 && !(_WORD)v59 )
      {
        if ( *a5 == 3 )
        {
          BYTE1(v29) = byte_17DB8E;
          if ( !byte_17DB8E )
          {
            if ( (word_17DEEE & 1) != 0 )
            {
              v32 = (unsigned __int8 *)&unk_E1960;
              v56 = 0;
              while ( *((_WORD *)v32 + 2) )
              {
                v44 = *((_WORD *)v32 + 6) - *a1;
                v45 = *((_WORD *)v32 + 7) - *a2;
                v46 = *((_WORD *)v32 + 4);
                v47 = *((_WORD *)v32 + 5);
                if ( sub_7B200(v43, dword_17DEE4, SHIWORD(dword_17DEE4)) )
                {
                  word_17DB84 = *((_WORD *)v32 + 6);
                  word_17DB86 = *((_WORD *)v32 + 7);
                  word_17DB88 = v32[18];
                  sub_80D40((__int16)a1, *a1, *a2, *((_WORD *)v32 + 6), *((_WORD *)v32 + 7), v32[18]);
                  v33 = dword_D41A4;
                  byte_17DB8E = 1;
                  *(_WORD *)(dword_D41A4 + 43) = v56;
                  if ( v32[18] == 1 )
                    *(_BYTE *)(v33 + 38545) |= 4u;
                  v34 = sub_824B0(*(_WORD *)(dword_D41A4 + 43));
                  if ( v34 && v34[6] == 2 )
                    *(_BYTE *)(dword_D41A4 + 38545) |= 0x10u;
                  if ( *(_WORD *)(dword_D41A4 + 43) == 24 )
                    *(_BYTE *)(dword_D41A4 + 38545) |= 0x20u;
                  break;
                }
                if ( v32[18] == 2 )
                  break;
                v32 += 22;
                ++v56;
              }
              if ( !(_WORD)v59 && !byte_17DB8E )
              {
                v35 = word_E2970;
                if ( word_E2970[4] )
                {
                  while ( 1 )
                  {
                    if ( v35[6] != 3 )
                    {
                      v44 = v35[4] - *a1;
                      v45 = v35[5] - *a2;
                      v46 = 40;
                      v47 = 40;
                      if ( sub_7B200(v43, dword_17DEE4, SHIWORD(dword_17DEE4)) )
                        break;
                    }
                    v35 = (_WORD *)((char *)v35 + 17);
                    if ( !v35[4] )
                      goto LABEL_175;
                  }
                  if ( v35[6] == 1 )
                    *(_BYTE *)(dword_D41A4 + 38545) |= 4u;
                  word_17DB84 = v35[4];
                  word_17DB86 = v35[5];
                  v42 = v35[4];
                  v40 = *a2;
                  v39 = *a1;
                  word_17DB88 = 1;
                  sub_80D40((__int16)a1, v39, v40, v42, word_17DB86, 1);
                  v36 = v35[3];
                  byte_17DB8E = 1;
                  *(_WORD *)(dword_D41A4 + 43) = v36;
                }
              }
            }
            else if ( (word_17DEEE & 2) != 0 )
            {
              LOBYTE(v29) = 0;
              v51 = &unk_E1960;
              v53 = v29;
              while ( v51[2] )
              {
                v44 = v51[6] - *a1;
                v45 = v51[7] - *a2;
                v46 = v51[4];
                v47 = v51[5];
                if ( sub_7B200(v43, dword_17DEE4, SHIWORD(dword_17DEE4)) )
                {
                  if ( *((_BYTE *)v51 + 18) == 1 )
                  {
                    word_17DB8C = v53;
                    *a5 = 5;
                    word_17DEEE = 0;
                  }
                  break;
                }
                v51 += 11;
                ++v53;
              }
              if ( *a5 != 5 )
              {
                for ( k = word_E2970; k[4]; k = (_WORD *)((char *)k + 17) )
                {
                  if ( k[6] != 3 )
                  {
                    v44 = k[4] - *a1;
                    v45 = k[5] - *a2;
                    v46 = 40;
                    v47 = 40;
                    if ( sub_7B200(v43, dword_17DEE4, SHIWORD(dword_17DEE4)) )
                    {
                      v37 = (int)k;
                      if ( k[6] == 1 )
                      {
                        *a5 = 5;
                        word_17DB8C = *(_WORD *)(v37 + 6);
                      }
                      break;
                    }
                  }
                }
              }
            }
          }
        }
LABEL_175:
        if ( !(_WORD)v59 && byte_17DF10 == 1 )
          return 2;
      }
      return v59;
    case 5:
      if ( byte_17DF10 || word_17DEEE )
      {
        v6 = 0;
        word_17DEEE = 0;
        *a5 = 3;
        byte_17DF11 = 0;
        byte_17DF10 = 0;
      }
      goto LABEL_92;
    default:
      goto LABEL_92;
  }
}
// 7F2F7: conditional instruction was optimized away because %var_4.2==0
// 7F093: variable 'v24' is possibly undefined
// 7F163: variable 'v28' is possibly undefined
// 7F545: variable 'v29' is possibly undefined
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E1964: using guessed type __int16 word_E1964[];
// E1966: using guessed type __int16 word_E1966[];
// E2970: using guessed type _WORD word_E2970[51];
// E29D6: using guessed type __int16 word_E29D6;
// 17DB82: using guessed type __int16 word_17DB82;
// 17DB84: using guessed type __int16 word_17DB84;
// 17DB86: using guessed type __int16 word_17DB86;
// 17DB88: using guessed type __int16 word_17DB88;
// 17DB8A: using guessed type __int16 word_17DB8A;
// 17DB8C: using guessed type __int16 word_17DB8C;
// 17DB8E: using guessed type char byte_17DB8E;
// 17DE28: using guessed type int dword_17DE28;
// 17DE2C: using guessed type int dword_17DE2C;
// 17DE30: using guessed type __int16 word_17DE30;
// 17DE32: using guessed type __int16 word_17DE32;
// 17DE34: using guessed type char byte_17DE34;
// 17DE5C: using guessed type int dword_17DE5C;
// 17DE64: using guessed type int dword_17DE64;
// 17DEE4: using guessed type int dword_17DEE4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 17DF11: using guessed type char byte_17DF11;
// 17E09D: using guessed type char byte_17E09D;
// 180628: using guessed type int dword_180628;
// 7EAE0: using guessed type _WORD var_5C[5];

//----- (0007F6A0) --------------------------------------------------------
int __usercall sub_7F6A0@<eax>(
        int a1@<eax>,
        int a2@<edx>,
        __int16 a3,
        __int16 a4,
        char *a5,
        _BYTE *a6,
        unsigned __int8 a7)
{
  char v7; // al
  __int16 v8; // si
  int v10; // [esp+0h] [ebp-4h]

  v10 = j___clock(a1, a2, a5);
  v7 = byte_17DF10;
  *a6 = strlen(a5);
  if ( (unsigned __int8)v7 < 0xFu )
  {
    if ( !v7 )
      goto LABEL_12;
    if ( (unsigned __int8)v7 <= 1u )
      goto LABEL_16;
    if ( v7 != 14 )
      goto LABEL_12;
  }
  else
  {
    if ( (unsigned __int8)v7 <= 0xFu )
      goto LABEL_16;
    if ( (unsigned __int8)v7 < 0x1Cu )
      goto LABEL_12;
    if ( (unsigned __int8)v7 <= 0x1Cu )
      goto LABEL_16;
    if ( v7 != 83 )
    {
LABEL_12:
      if ( *a6 < 0xFu && byte_17DF11 && sub_7C200(byte_17DF11) )
      {
        a5[(unsigned __int8)*a6] = byte_17DF11;
        a5[(unsigned __int8)*a6 + 1] = 0;
      }
      goto LABEL_16;
    }
  }
  if ( *a6 )
  {
    a5[strlen(a5) - 1] = 0;
    *a6 = strlen(a5);
  }
LABEL_16:
  strupr(a5);
  sub_2BC10(a5, a3, a4, a7);
  if ( (v10 - dword_17DED0) / 0xCu )
  {
    v8 = sub_6FC10();
    sub_2BC10(&asc_D1AB3[1], a3 + v8 * strlen(a5), a4, a7);
    dword_17DED0 = v10;
  }
  return 0;
}
// 98786: using guessed type __int64 __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 9A20A: using guessed type _DWORD __cdecl strupr(_DWORD);
// 17DED0: using guessed type int dword_17DED0;
// 17DF10: using guessed type char byte_17DF10;
// 17DF11: using guessed type char byte_17DF11;

//----- (0007F7D0) --------------------------------------------------------
int __cdecl sub_7F7D0(unsigned int *a1, _DWORD *a2, unsigned int a3, const char *a4)
{
  int v4; // edi
  int v5; // eax
  int v6; // ebx
  int v7; // ebx
  int v8; // eax
  unsigned __int8 v9; // bl
  char v10; // cl
  char v12[80]; // [esp+0h] [ebp-5Ch] BYREF
  int v13; // [esp+50h] [ebp-Ch]
  int v14; // [esp+54h] [ebp-8h]
  unsigned __int8 i; // [esp+58h] [ebp-4h]

  v4 = 0;
  sprintf(v12, "%c%s/%s", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherwLanguag, a4);
  for ( i = 0; i < 2u; i = v9 + 1 )
  {
    v4 = unknown_libname_1(a4 + 1);
    v5 = sub_98817((int)v12, 512);
    v6 = v5;
    v14 = v5;
    if ( v5 != -1 )
    {
      v13 = filelength(v5);
      sub_988A7(v6, a3, 4773);
      sub_988A7(v6, a3 + 4773, 12);
      if ( byte_E29E0 || dword_D41BC )
        sub_83E80(dword_D41BC);
      v7 = v13 - 4785;
      v8 = sub_83CD0(v13 - 4785);
      dword_D41BC = v8;
      if ( v8 )
      {
        byte_E29E0 = 1;
        sub_988A7(v14, v8, v7);
      }
      sub_98882(v14);
      break;
    }
    v9 = i;
    sprintf(v12, "LANGUAGE/%s", a4);
  }
  *a1 = a3 + 4773;
  v10 = word_180660;
  *a2 = a3 + 4785;
  if ( (v10 & 1) != 0 )
    sub_98709(*a1, a3 + 4785, a3);
  else
    sub_9874D((unsigned int *)*a1, a3 + 4785, a3);
  sub_5B870((_BYTE *)dword_D41BC, (int)dword_E9C4C, 471);
  return v4;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// 98F9E: using guessed type _DWORD __cdecl unknown_libname_1(_DWORD);
// D41A4: using guessed type int dword_D41A4;
// D41BC: using guessed type int dword_D41BC;
// E29E0: using guessed type char byte_E29E0;
// E9C4C: using guessed type int dword_E9C4C[];
// 180660: using guessed type __int16 word_180660;

//----- (0007F960) --------------------------------------------------------
int __cdecl sub_7F960(unsigned int *a1, unsigned int a2, unsigned int a3, const char *a4)
{
  int v4; // esi
  int v5; // eax
  int v6; // ebx
  int v7; // edi
  int v8; // ebx
  int v9; // eax
  unsigned __int8 v10; // bl
  char v12[80]; // [esp+0h] [ebp-58h] BYREF
  int v13; // [esp+50h] [ebp-8h]
  unsigned __int8 i; // [esp+54h] [ebp-4h]

  v4 = 0;
  sprintf(v12, "%c%s/%s", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherwLanguag, a4);
  for ( i = 0; i < 2u; i = v10 + 1 )
  {
    v4 = unknown_libname_1(a4 + 1);
    v5 = sub_98817((int)v12, 512);
    v6 = v5;
    v7 = v5;
    if ( v5 != -1 )
    {
      v13 = filelength(v5);
      sub_988A7(v6, a3, 4773);
      sub_988A7(v6, a3 + 4773, 12);
      if ( byte_E29E0 || dword_D41BC )
        sub_83E80(dword_D41BC);
      v8 = v13 - 4785;
      v9 = sub_83CD0(v13 - 4785);
      dword_D41BC = v9;
      if ( v9 )
      {
        byte_E29E0 = 1;
        sub_988A7(v7, v9, v8);
      }
      sub_98882(v7);
      break;
    }
    v10 = i;
    sprintf(v12, "LANGUAGE/%s", a4);
  }
  if ( (word_180660 & 1) != 0 )
    sub_98709((unsigned int)a1, a2, a3);
  else
    sub_9874D(a1, a2, a3);
  sub_5B870((_BYTE *)dword_D41BC, (int)dword_E9C4C, 471);
  return v4;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// 98F9E: using guessed type _DWORD __cdecl unknown_libname_1(_DWORD);
// D41A4: using guessed type int dword_D41A4;
// D41BC: using guessed type int dword_D41BC;
// E29E0: using guessed type char byte_E29E0;
// E9C4C: using guessed type int dword_E9C4C[];
// 180660: using guessed type __int16 word_180660;

//----- (0007FAE0) --------------------------------------------------------
unsigned int __cdecl sub_7FAE0(char *a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5)
{
  unsigned int v5; // kr04_4
  __int16 v6; // bx
  int v7; // ebx

  v5 = strlen(a1) + 1;
  v6 = a3 - a2;
  if ( (_WORD)v5 == 1 )
  {
    v7 = a2 + v6 / 2;
  }
  else
  {
    v7 = v6 / 2 + a2 - *(unsigned __int8 *)(dword_17DEC0 + 394) * (__int16)(v5 - 1) / 2;
    sub_7FB90(a1, (__int16)v7, a4, a5);
  }
  return v7 + *(unsigned __int8 *)(dword_17DEC0 + 394) * strlen(a1);
}
// 17DEC0: using guessed type int dword_17DEC0;

//----- (0007FB90) --------------------------------------------------------
int __cdecl sub_7FB90(_BYTE *a1, int a2, __int16 a3, unsigned __int8 a4)
{
  int v5; // ebx
  unsigned __int16 v7; // ax
  int v8; // eax
  int result; // eax
  int v10; // [esp+0h] [ebp-4h]

  v5 = a2;
  if ( a4 )
    word_E36D4 = 64;
  if ( (a2 & 0x8000u) != 0 )
    v5 = 0;
  v10 = v5;
  while ( *a1 && (__int16)v5 < 640 )
  {
    v7 = (unsigned __int8)*a1;
    if ( v7 < 0xAu )
    {
      if ( !*a1 )
        goto LABEL_21;
      if ( v7 == 9 )
        goto LABEL_20;
LABEL_16:
      if ( *a1 )
      {
        if ( a4 )
          sub_72C40(v5, a3, 6 * (unsigned __int8)*a1 + dword_17DEC0, a4);
        else
          sub_7C120(v5, a3, 6 * (unsigned __int8)*a1 + dword_17DEC0);
      }
      goto LABEL_20;
    }
    if ( (unsigned __int8)*a1 <= 0xAu )
    {
      v5 = v10;
      a3 += *(unsigned __int8 *)(dword_17DEC0 + 395);
      goto LABEL_21;
    }
    if ( v7 < 0xDu )
      goto LABEL_16;
    if ( v7 <= 0xDu )
      goto LABEL_21;
    if ( v7 != 32 )
      goto LABEL_16;
LABEL_20:
    HIWORD(v8) = HIWORD(dword_17DEC0);
    LOWORD(v8) = *(unsigned __int8 *)(dword_17DEC0 + 394);
    v5 += v8;
LABEL_21:
    ++a1;
  }
  result = v5;
  word_E36D4 = 0;
  return result;
}
// E36D4: using guessed type __int16 word_E36D4;
// 17DEC0: using guessed type int dword_17DEC0;

//----- (0007FCB0) --------------------------------------------------------
int __usercall sub_7FCB0@<eax>(
        int a1@<ebx>,
        _BYTE *a2,
        int a3,
        int a4,
        int a5,
        char a6,
        unsigned __int8 a7,
        __int16 a8)
{
  int v8; // esi
  __int16 k; // di
  int v10; // eax
  int v11; // ebx
  unsigned __int8 v12; // al
  int v13; // edi
  int v14; // eax
  int v15; // eax
  __int16 i; // di
  int v17; // eax
  _BYTE *v18; // ecx
  __int16 j; // di
  int v20; // eax
  char v21; // al
  char v22; // ah
  char v23; // cl
  __int16 v24; // ax
  int v25; // esi
  unsigned __int8 v26; // al
  int v27; // esi
  int v28; // eax
  _BYTE *v29; // ecx
  __int16 n; // ax
  __int16 ii; // si
  int v32; // eax
  __int16 v33; // di
  _BYTE *v34; // ecx
  __int16 jj; // si
  unsigned __int16 v36; // ax
  __int16 v37; // di
  int v38; // eax
  int v39; // eax
  int v40; // eax
  unsigned __int8 v41; // al
  int v42; // esi
  int v43; // edi
  int v44; // eax
  int v45; // ebx
  unsigned __int8 v46; // al
  int v47; // eax
  __int16 v48; // si
  __int16 v49; // si
  _BYTE *v50; // ecx
  int v51; // eax
  __int16 kk; // ax
  int v53; // edi
  int v54; // eax
  int v55; // ebx
  _BYTE *v56; // ecx
  __int16 mm; // di
  __int16 nn; // si
  int v59; // eax
  __int16 v60; // si
  int v61; // eax
  _BYTE *v62; // ecx
  __int16 i1; // si
  __int16 i2; // ax
  int v65; // esi
  int v66; // eax
  int v67; // ebx
  _BYTE *v68; // ecx
  __int16 i3; // si
  __int16 i4; // ax
  int v71; // eax
  __int16 v72; // si
  int v73; // eax
  __int16 v75; // [esp-Ch] [ebp-104h]
  int v76; // [esp-Ch] [ebp-104h]
  __int16 v77; // [esp-Ch] [ebp-104h]
  __int16 v78; // [esp-Ch] [ebp-104h]
  __int16 v79; // [esp-8h] [ebp-100h]
  __int16 v80; // [esp-8h] [ebp-100h]
  __int16 v81; // [esp-8h] [ebp-100h]
  __int16 v82; // [esp-8h] [ebp-100h]
  __int16 v83; // [esp-8h] [ebp-100h]
  __int16 v84; // [esp-8h] [ebp-100h]
  __int16 v85; // [esp-8h] [ebp-100h]
  char v86[180]; // [esp+0h] [ebp-F8h] BYREF
  int v87; // [esp+B4h] [ebp-44h]
  int v88; // [esp+B8h] [ebp-40h]
  int v89; // [esp+BCh] [ebp-3Ch]
  int v90; // [esp+C0h] [ebp-38h]
  int v91; // [esp+C4h] [ebp-34h]
  int v92; // [esp+C8h] [ebp-30h]
  int v93; // [esp+CCh] [ebp-2Ch]
  int v94; // [esp+D0h] [ebp-28h]
  int v95; // [esp+D4h] [ebp-24h]
  unsigned __int16 v96; // [esp+D8h] [ebp-20h]
  int v97; // [esp+DCh] [ebp-1Ch]
  int v98; // [esp+E0h] [ebp-18h]
  int m; // [esp+E4h] [ebp-14h]
  int v100; // [esp+E8h] [ebp-10h]
  int v101; // [esp+ECh] [ebp-Ch]
  int v102; // [esp+F0h] [ebp-8h]
  int v103; // [esp+F4h] [ebp-4h]

  v8 = a5;
  v97 = a5;
  v101 = a5;
  v94 = 0;
  v102 = 0;
  v103 = 0;
  memset(v86, 0, sizeof(v86));
  if ( a6 )
  {
    if ( a6 == 2 || a6 == 5 )
    {
      v103 = a4 - a3;
      if ( a8 )
      {
        v102 = *(unsigned __int8 *)(dword_17DED4 + 1654);
        v89 = *(unsigned __int8 *)(dword_17DED4 + 1654);
        v93 = (__int16)v103 / v89;
        if ( (__int16)v103 % v89 )
        {
          v15 = v102 * ++v93;
          v103 = v15;
          LOWORD(a4) = v15 + a3 - *(unsigned __int8 *)(dword_17DED4 + 1648);
        }
        for ( i = 0; i < (__int16)v103; i += v102 )
          sub_7C120(i + a3, a5, dword_17DED4 + 1650);
        HIWORD(v17) = HIWORD(dword_17DED4);
        LOWORD(v17) = *(unsigned __int8 *)(dword_17DED4 + 1655);
        v8 = v17 + a5;
        v92 = 0;
        v18 = (_BYTE *)(dword_180628 + (__int16)a3 + 640 * (__int16)(v17 + a5));
        while ( *(unsigned __int8 *)(dword_17DED4 + 1649) > (__int16)v92 )
        {
          for ( j = 0; ; ++j )
          {
            v89 = *(unsigned __int8 *)(dword_17DED4 + 1648);
            if ( j >= (__int16)a4 - (v89 + (__int16)a3) )
              break;
            HIBYTE(v96) = 15;
            LOBYTE(v96) = *v18++;
            *(v18 - 1) = *(_BYTE *)(dword_17DE3C + v96);
          }
          v18 += 640 - j;
          ++v92;
        }
        sub_7C120(a3, v8, dword_17DED4 + 1644);
        sub_7C120(a4 - *(unsigned __int8 *)(dword_17DED4 + 1648), v8, dword_17DED4 + 1644);
      }
      if ( a8 )
      {
        HIWORD(v20) = HIWORD(dword_17DED4);
        LOWORD(v20) = *(unsigned __int8 *)(dword_17DED4 + 1649);
        a1 = v20 + v8;
        v97 += v20;
      }
      else
      {
        v97 = v8;
      }
    }
  }
  else
  {
    v103 = a4 - a3;
    v87 = a8;
    v91 = dword_17DED4;
    v102 = *(unsigned __int8 *)(dword_17DED4 + 6 * a8 + 4);
    if ( (__int16)(a4 - a3) % (int)(unsigned __int8)v102 )
    {
      v103 = ((__int16)(a4 - a3) / (int)(unsigned __int8)v102 + 1) * v102;
      LOWORD(a4) = v103 + a3 - *(unsigned __int8 *)(v91 + 6 * (v87 - 1) + 4);
    }
    for ( k = 0; k < (__int16)v103; k += v102 )
      sub_7C120(k + a3, a5, 6 * a8 + dword_17DED4);
    HIWORD(v10) = HIWORD(dword_17DED4);
    LOWORD(v10) = *(unsigned __int8 *)(dword_17DED4 + 6 * a8 + 5);
    v11 = v10 + a5;
    v97 += v10;
    v12 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, 0);
    v13 = 6 * (a8 - 1);
    v79 = *(unsigned __int8 *)(v13 + dword_17DED4 + 5);
    v90 = (__int16)v11;
    v89 = (__int16)a3;
    sub_7C140((__int16)a3, v11, (__int16)v103, v79, v12);
    sub_7C120(v89, v90, v13 + dword_17DED4);
    sub_7C120(a4, v90, v13 + dword_17DED4);
    HIWORD(v14) = HIWORD(dword_17DED4);
    LOWORD(v14) = *(unsigned __int8 *)(v13 + dword_17DED4 + 5);
    a1 = v14 + v11;
    v97 += v14;
  }
  v98 = a3;
  if ( !a6 )
    v97 = v8 + 12;
  v95 = 0;
  v100 = 0;
  for ( m = 0; ; ++m )
  {
    v21 = 0;
    if ( a6 )
    {
      v23 = a2[(__int16)m];
      if ( v23 == 32 || !v23 )
LABEL_38:
        v21 = 1;
    }
    else
    {
      v22 = a2[(__int16)m];
      if ( v22 == 32 || !v22 || v22 == 44 || v22 == 45 || v22 == 46 )
        goto LABEL_38;
    }
    if ( v21 )
    {
      if ( (_WORD)v100 )
      {
        if ( !a6 || a6 == 4 || a6 == 5 )
        {
          v24 = *(unsigned __int8 *)(dword_17DEC0 + 394);
        }
        else
        {
          sub_6FC50(1);
          v24 = sub_6FC10();
        }
        v88 = (__int16)m;
        v25 = (__int16)v98;
        if ( (__int16)v98 + v24 * ((__int16)m - (__int16)v95) <= (__int16)a4 - 3 * v24 )
        {
          qmemcpy(&v86[strlen(v86)], &a2[(__int16)v100 + 1], v88 - (__int16)v100);
        }
        else
        {
          if ( a6 && a6 != 4 )
          {
            if ( a6 == 2 )
            {
              sub_6FC50(1);
              v29 = (_BYTE *)(dword_180628 + v25 + 640 * (__int16)a1);
              for ( n = 0; n < *(unsigned __int8 *)(dword_17DED4 + 1649); ++n )
              {
                for ( ii = 0; ii < (__int16)a4 - ((__int16)v98 - *(unsigned __int8 *)(dword_17DED4 + 1648)); ++ii )
                {
                  HIBYTE(v96) = 15;
                  LOBYTE(v96) = *v29++;
                  *(v29 - 1) = *(_BYTE *)(dword_17DE3C + v96);
                }
                v29 += 640 - ii;
              }
              sub_7C120(v98, a1, dword_17DED4 + 1644);
              sub_7C120(a4, a1, dword_17DED4 + 1644);
              HIWORD(v32) = HIWORD(dword_17DED4);
              LOWORD(v32) = *(unsigned __int8 *)(dword_17DED4 + 1649);
              a1 += v32;
              v81 = v97;
              v75 = a4 - 2 * sub_6FC10();
              sub_6FC80(v86, v98 + *(unsigned __int8 *)(dword_17DED4 + 1654), v75, v81, a7);
            }
            else if ( a6 == 5 )
            {
              if ( a8 )
              {
                v33 = 0;
                v34 = (_BYTE *)(dword_180628 + (__int16)v98 + 640 * (__int16)a1);
                while ( v33 < *(unsigned __int8 *)(dword_17DED4 + 1649) )
                {
                  for ( jj = 0; ; ++jj )
                  {
                    v89 = *(unsigned __int8 *)(dword_17DED4 + 1648);
                    if ( jj >= (__int16)a4 - (v89 + (__int16)v98) )
                      break;
                    HIBYTE(v36) = 15;
                    LOBYTE(v36) = *v34++;
                    *(v34 - 1) = *(_BYTE *)(dword_17DE3C + v36);
                  }
                  ++v33;
                  v34 += 640 - jj;
                }
                v37 = v98;
                sub_7C120(v98, a1, dword_17DED4 + 1644);
                sub_7C120(a4 - *(unsigned __int8 *)(dword_17DED4 + 1648), a1, dword_17DED4 + 1644);
                HIWORD(v38) = HIWORD(dword_17DED4);
                LOWORD(v38) = *(unsigned __int8 *)(dword_17DED4 + 1649);
                a1 += v38;
                sub_7FAE0(v86, v37, a4, v97, 0);
              }
              else
              {
                sub_7FAE0(v86, v98, a4, v97, a7);
              }
            }
            else
            {
              sub_6FC80(v86, v98, a4, v97, a7);
            }
          }
          else
          {
            if ( !a6 )
            {
              v26 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, 0);
              v27 = 6 * (a8 - 1);
              v80 = *(unsigned __int8 *)(v27 + dword_17DED4 + 5);
              v89 = (__int16)v98;
              sub_7C140((__int16)v98, a1, (__int16)v103, v80, v26);
              sub_7C120(v89, a1, v27 + dword_17DED4);
              sub_7C120(a4, a1, v27 + dword_17DED4);
              HIWORD(v28) = HIWORD(dword_17DED4);
              LOWORD(v28) = *(unsigned __int8 *)(v27 + dword_17DED4 + 5);
              a1 += v28;
            }
            sub_7FAE0(v86, v98, a4, v97, 0);
          }
          if ( !a6 || a6 == 4 || a6 == 5 )
          {
            HIWORD(v39) = HIWORD(dword_17DEC0);
            LOWORD(v39) = *(unsigned __int8 *)(dword_17DEC0 + 395);
            v97 += v39;
          }
          else
          {
            LOWORD(v40) = sub_6FC30();
            v97 += v40 + 2;
          }
          memset(v86, 0, sizeof(v86));
          qmemcpy(v86, &a2[(__int16)v100 + 1], (__int16)m - (__int16)v100);
          v95 = v100;
        }
      }
      else
      {
        qmemcpy(v86, a2, (__int16)m + 1);
      }
      v100 = m;
    }
    if ( !a2[(__int16)m] )
      break;
  }
  if ( !(_WORD)v94 )
  {
    if ( a6 && a6 != 4 )
    {
      sub_6FC50(1);
      if ( a6 == 2 )
      {
        sub_6FC50(1);
        v49 = 0;
        v50 = (_BYTE *)((__int16)v98 + 640 * (__int16)a1);
        v51 = dword_180628;
        while ( 1 )
        {
          v50 += v51;
          if ( v49 >= *(unsigned __int8 *)(dword_17DED4 + 1649) )
            break;
          for ( kk = 0; ; ++kk )
          {
            v90 = *(unsigned __int8 *)(dword_17DED4 + 1648);
            if ( kk >= (__int16)a4 - ((__int16)v98 - v90) )
              break;
            HIBYTE(v96) = 15;
            LOBYTE(v96) = *v50++;
            *(v50 - 1) = *(_BYTE *)(dword_17DE3C + v96);
          }
          v51 = 640 - kk;
          ++v49;
        }
        v53 = (__int16)v98;
        sub_7C120(v98, a1, dword_17DED4 + 1644);
        sub_7C120(a4, a1, dword_17DED4 + 1644);
        HIWORD(v54) = HIWORD(dword_17DED4);
        LOWORD(v54) = *(unsigned __int8 *)(dword_17DED4 + 1649);
        v55 = v54 + a1;
        sub_6FC50(1);
        v56 = (_BYTE *)(640 * (__int16)v55 + v53 + dword_180628);
        for ( mm = 0; mm < *(unsigned __int8 *)(dword_17DED4 + 1649); ++mm )
        {
          for ( nn = 0; ; ++nn )
          {
            v90 = *(unsigned __int8 *)(dword_17DED4 + 1648);
            if ( nn >= (__int16)a4 - ((__int16)v98 - v90) )
              break;
            HIBYTE(v96) = 15;
            LOBYTE(v96) = *v56++;
            *(v56 - 1) = *(_BYTE *)(dword_17DE3C + v96);
          }
          v56 += 640 - nn;
        }
        sub_7C120(v98, v55, dword_17DED4 + 1644);
        sub_7C120(a4, v55, dword_17DED4 + 1644);
        HIWORD(v59) = HIWORD(dword_17DED4);
        LOWORD(v59) = *(unsigned __int8 *)(dword_17DED4 + 1649);
        v60 = 0;
        a1 = v59 + v55;
        while ( v60 < (__int16)v103 )
        {
          sub_7C120(v60 + a3, a1, dword_17DED4 + 1650);
          v60 += v102;
        }
        v85 = v97;
        v77 = a4 - 2 * sub_6FC10();
        sub_6FC80(v86, v98 + *(unsigned __int8 *)(dword_17DED4 + 1654), v77, v85, a7);
      }
      else if ( a6 == 5 )
      {
        if ( a8 )
        {
          v61 = 640 * (__int16)a1 + (__int16)v98;
          v62 = (_BYTE *)dword_180628;
          for ( i1 = 0; ; ++i1 )
          {
            v62 += v61;
            if ( i1 >= *(unsigned __int8 *)(dword_17DED4 + 1649) )
              break;
            for ( i2 = 0; ; ++i2 )
            {
              v90 = *(unsigned __int8 *)(dword_17DED4 + 1648);
              if ( i2 >= (__int16)a4 - (v90 + (__int16)v98) )
                break;
              HIBYTE(v96) = 15;
              LOBYTE(v96) = *v62++;
              *(v62 - 1) = *(_BYTE *)(dword_17DE3C + v96);
            }
            v61 = 640 - i2;
          }
          v65 = (__int16)v98;
          sub_7C120(v98, a1, dword_17DED4 + 1644);
          sub_7C120(a4 - *(unsigned __int8 *)(dword_17DED4 + 1648), a1, dword_17DED4 + 1644);
          HIWORD(v66) = HIWORD(dword_17DED4);
          LOWORD(v66) = *(unsigned __int8 *)(dword_17DED4 + 1649);
          v67 = v66 + a1;
          v68 = (_BYTE *)(640 * (__int16)v67 + v65 + dword_180628);
          for ( i3 = 0; i3 < *(unsigned __int8 *)(dword_17DED4 + 1649); ++i3 )
          {
            for ( i4 = 0; ; ++i4 )
            {
              v89 = *(unsigned __int8 *)(dword_17DED4 + 1648);
              if ( i4 >= (__int16)a4 - (v89 + (__int16)v98) )
                break;
              HIBYTE(v96) = 15;
              LOBYTE(v96) = *v68++;
              *(v68 - 1) = *(_BYTE *)(dword_17DE3C + v96);
            }
            v68 += 640 - i4;
          }
          sub_7C120(v98, v67, dword_17DED4 + 1644);
          sub_7C120(a4 - *(unsigned __int8 *)(dword_17DED4 + 1648), v67, dword_17DED4 + 1644);
          HIWORD(v71) = HIWORD(dword_17DED4);
          LOWORD(v71) = *(unsigned __int8 *)(dword_17DED4 + 1649);
          v72 = 0;
          a1 = v71 + v67;
          while ( v72 < (__int16)v103 )
          {
            v78 = v72 + a3;
            v72 += v102;
            sub_7C120(v78, a1, dword_17DED4 + 1650);
          }
          sub_7FAE0(v86, v98 + *(unsigned __int8 *)(dword_17DED4 + 1654), a4, v97, 0);
        }
        else
        {
          sub_7FAE0(v86, v98, a4, v97, a7);
        }
      }
      else
      {
        sub_6FC80(v86, v98, a4, v97, a7);
      }
    }
    else
    {
      if ( !a6 )
      {
        v41 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, 0);
        v42 = 6 * (a8 - 1);
        v82 = *(unsigned __int8 *)(v42 + dword_17DED4 + 5);
        v90 = (__int16)v103;
        v43 = (__int16)v98;
        v89 = (__int16)a1;
        sub_7C140((__int16)v98, a1, (__int16)v103, v82, v41);
        sub_7C120(v43, v89, v42 + dword_17DED4);
        v83 = v89;
        v89 = (__int16)a4;
        sub_7C120(a4, v83, v42 + dword_17DED4);
        HIWORD(v44) = HIWORD(dword_17DED4);
        LOWORD(v44) = *(unsigned __int8 *)(v42 + dword_17DED4 + 5);
        v45 = v44 + a1;
        v46 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0, 0, 0);
        v84 = *(unsigned __int8 *)(v42 + dword_17DED4 + 5);
        v76 = v90;
        v90 = (__int16)v45;
        sub_7C140(v43, v45, v76, v84, v46);
        sub_7C120(v43, v90, v42 + dword_17DED4);
        sub_7C120(v89, v90, v42 + dword_17DED4);
        HIWORD(v47) = HIWORD(dword_17DED4);
        LOWORD(v47) = *(unsigned __int8 *)(v42 + dword_17DED4 + 5);
        v48 = 0;
        a1 = v47 + v45;
        while ( v48 < (__int16)v103 )
        {
          sub_7C120(v48 + v98, a1, 6 * a8 + dword_17DED4);
          v48 += v102;
        }
      }
      sub_7FAE0(v86, v98, a4, v97, 0);
    }
  }
  if ( a6 )
    return v97 - v101;
  HIWORD(v73) = HIWORD(dword_17DED4);
  LOWORD(v73) = *(unsigned __int8 *)(dword_17DED4 + 6 * (a8 + 2) + 5);
  return a1 - v101 + v73;
}
// 80421: variable 'v40' is possibly undefined
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 17DE38: using guessed type int dword_17DE38;
// 17DE3C: using guessed type int dword_17DE3C;
// 17DEC0: using guessed type int dword_17DEC0;
// 17DED4: using guessed type int dword_17DED4;
// 180628: using guessed type int dword_180628;
// 7FCB0: using guessed type char var_F8[180];

//----- (00080C30) --------------------------------------------------------
void __cdecl sub_80C30(__int16 a1, __int16 a2, __int16 a3)
{
  int v3; // ebx
  char *v4; // eax
  int v5; // edx
  _WORD *i; // eax
  __int16 v7; // ax
  int v8; // [esp-14h] [ebp-14h]
  unsigned __int8 v9; // [esp-8h] [ebp-8h]

  v3 = -1;
  v4 = (char *)&unk_E1960;
  v5 = 0;
  while ( *((_WORD *)v4 + 2) )
  {
    if ( v4[18] == 2 )
    {
      v3 = v5;
      break;
    }
    v4 += 22;
    ++v5;
  }
  if ( a2 + a1 > 0 )
  {
    for ( i = word_E2970; i[6]; i = (_WORD *)((char *)i + 17) )
    {
      if ( i[6] != 3 && (_WORD)v3 == i[2] )
      {
        byte_17DE34 = 3;
        return;
      }
    }
    sub_6FC50(1);
    v9 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x3Fu, 0x3Fu, 0x3Fu);
    v8 = (__int16)(a1 + a3 - 3 * sub_6FC10());
    v7 = sub_6FC10();
    sub_7FCB0(v3, (_BYTE *)dword_E9CA8[(__int16)v3], (__int16)(a1 + 4 * v7), v8, a2, 5, v9, 1);
  }
  if ( byte_17DE34 != 3 && (*(_BYTE *)(dword_D41A4 + 24) & 0x40) != 0 && !byte_17E09D )
  {
    byte_17E09D = 1;
    if ( (__int16)v3 != -1 )
      sub_86EB0(v3, 0, 0);
  }
}
// D41A4: using guessed type int dword_D41A4;
// E2970: using guessed type _WORD word_E2970[51];
// E9CA8: using guessed type int dword_E9CA8[136];
// 17DE34: using guessed type char byte_17DE34;
// 17DE38: using guessed type int dword_17DE38;
// 17E09D: using guessed type char byte_17E09D;

//----- (00080D40) --------------------------------------------------------
int __usercall sub_80D40@<eax>(__int16 a1@<si>, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int v6; // ebx
  char *v7; // eax
  char v8; // dl
  int v10; // edx
  int v11; // ebx
  __int16 v12; // ax
  int v13; // edx
  int v14; // edx
  __int16 i; // si
  __int16 v16; // ax
  char v17; // dh
  __int16 v18; // cx
  int v19; // ecx
  int v20; // edx
  __int16 v21[4]; // [esp+0h] [ebp-10h] BYREF
  __int16 v22[4]; // [esp+8h] [ebp-8h] BYREF

  v6 = 1;
  if ( byte_17E09C )
  {
    if ( (unsigned __int8)byte_17E09C > 2u )
      return v6;
    for ( i = 0; i < 3; ++i )
      v6 = sub_7E9D0(&word_17E06C, &word_17E06E, word_17E084);
    v22[0] = word_17E074;
    v22[1] = word_17E076;
    v21[0] = word_17E06C;
    v21[1] = word_17E06E;
    v16 = sub_581E0(v22, v21);
    if ( v16 > 1024 && v16 < 1536 )
    {
      if ( byte_17E082 != 21 )
      {
        word_17E080 = 21;
        byte_17E082 = 21;
        byte_17E083 = 24;
      }
      goto LABEL_52;
    }
    if ( v16 <= 1536 || v16 >= 2048 )
    {
      if ( v16 > 0 && v16 < 512 )
      {
        if ( byte_17E082 != 5 )
        {
          word_17E080 = 5;
          byte_17E082 = 5;
          byte_17E083 = 8;
        }
        goto LABEL_52;
      }
      if ( v16 <= 512 || v16 >= 1024 )
      {
        switch ( v16 )
        {
          case 2048:
          case 0:
            if ( byte_17E082 != 17 )
            {
              word_17E080 = 17;
              byte_17E082 = 17;
              byte_17E083 = 20;
            }
            goto LABEL_52;
          case 512:
            if ( byte_17E082 == 9 )
              goto LABEL_52;
            byte_17E082 = 9;
            v17 = 12;
            word_17E080 = 9;
            goto LABEL_51;
          case 1024:
            if ( byte_17E082 != 1 )
            {
              word_17E080 = 1;
              byte_17E082 = 1;
              byte_17E083 = 4;
            }
            goto LABEL_52;
        }
        if ( v16 != 1536 || byte_17E082 == 25 )
        {
LABEL_52:
          word_17E07C = word_17E06C;
          word_17E07E = word_17E06E;
          if ( a6 != 1
            && byte_17E09C != 2
            && !(_WORD)v6
            && ((int)abs32(word_17E06E - word_17E072) > 8 || (int)abs32(word_17E06C - word_17E070) > 8) )
          {
            if ( word_17DB8A == -1 )
              sub_812D0(word_17E07C, word_17E07E);
            word_17E070 = word_17E06C;
            word_17E072 = word_17E06E;
          }
          v19 = 6 * word_17E080 + dword_17DED4;
          v20 = word_17E06C - ((int)*(unsigned __int8 *)(v19 + 4) >> 1) - a2;
          sub_81260(
            (__int16)v20,
            v20,
            (int)&unk_17E078,
            word_17E06C - ((int)*(unsigned __int8 *)(v19 + 4) >> 1) - a2,
            word_17E06E - ((int)*(unsigned __int8 *)(v19 + 5) >> 1) - a3);
          if ( (_WORD)v6 )
            byte_17E09C = 3;
          return v6;
        }
        v18 = 25;
        byte_17E082 = 25;
        v17 = 28;
      }
      else
      {
        if ( byte_17E082 == 13 )
          goto LABEL_52;
        v18 = 13;
        byte_17E082 = 13;
        v17 = 16;
      }
      word_17E080 = v18;
    }
    else
    {
      if ( byte_17E082 == 29 )
        goto LABEL_52;
      byte_17E082 = 29;
      v17 = 32;
      word_17E080 = 29;
    }
LABEL_51:
    byte_17E083 = v17;
    goto LABEL_52;
  }
  if ( word_17DB8A == -1 )
  {
    v7 = (char *)&unk_E1960;
    a1 = 0;
    word_17E06C = 0;
    word_17E06E = 0;
    while ( *((_WORD *)v7 + 2) )
    {
      v8 = v7[18];
      if ( v8 == 1 )
      {
        word_17E06C = *((_WORD *)v7 + 6);
        word_17E06E = *((_WORD *)v7 + 7);
      }
      else if ( v8 == 2 && !a1 )
      {
        return 1;
      }
      v7 += 22;
      ++a1;
    }
  }
  word_17E074 = a4;
  v10 = *(unsigned __int8 *)(dword_17DED4 + 226);
  word_17E076 = a5;
  v11 = v10 >> 1;
  v12 = (v10 >> 1) + a4;
  v13 = *(unsigned __int8 *)(dword_17DED4 + 227);
  word_17E074 = v12;
  v14 = v13 >> 1;
  word_17E076 = v14 + a5;
  if ( word_17DB8A == -1 )
  {
    word_17E06C += v11;
    word_17E06E += v14;
  }
  sub_7E8D0(word_17E084, word_17E074, word_17E076, word_17E06C, word_17E06E, 2, 2);
  byte_17E09C = (a1 == 0) + 1;
  word_17E070 = word_17E06C;
  word_17E072 = word_17E06E;
  v6 = 0;
  if ( (int)abs32(word_17E074 - word_17E06C) > 5 && (int)abs32(word_17E076 - word_17E06E) > 6 )
  {
    sub_8F100(0, 19, (unsigned __int8)byte_E1324, 64, 0x64u, 0, 2u);
    return 0;
  }
  return v6;
}
// E1324: using guessed type char byte_E1324;
// 17DB8A: using guessed type __int16 word_17DB8A;
// 17DED4: using guessed type int dword_17DED4;
// 17E06C: using guessed type __int16 word_17E06C;
// 17E06E: using guessed type __int16 word_17E06E;
// 17E070: using guessed type __int16 word_17E070;
// 17E072: using guessed type __int16 word_17E072;
// 17E074: using guessed type __int16 word_17E074;
// 17E076: using guessed type __int16 word_17E076;
// 17E07C: using guessed type __int16 word_17E07C;
// 17E07E: using guessed type __int16 word_17E07E;
// 17E080: using guessed type __int16 word_17E080;
// 17E082: using guessed type char byte_17E082;
// 17E083: using guessed type char byte_17E083;
// 17E084: using guessed type __int16 word_17E084[12];
// 17E09C: using guessed type char byte_17E09C;

//----- (00081260) --------------------------------------------------------
int __usercall sub_81260@<eax>(int a1@<eax>, int a2@<edx>, int a3, __int16 a4, __int16 a5)
{
  int v5; // ecx

  v5 = j___clock(a1, a2, a3);
  if ( (unsigned int)(v5 - *(_DWORD *)a3) >> 4 )
  {
    if ( *(__int16 *)(a3 + 8) <= *(unsigned __int8 *)(a3 + 11) - 1 )
      ++*(_WORD *)(a3 + 8);
    else
      *(_WORD *)(a3 + 8) = *(unsigned __int8 *)(a3 + 10);
    *(_DWORD *)a3 = v5;
  }
  return sub_7C120(a4, a5, dword_17DED4 + 6 * *(__int16 *)(a3 + 8));
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 17DED4: using guessed type int dword_17DED4;

//----- (000812D0) --------------------------------------------------------
int __cdecl sub_812D0(__int16 a1, __int16 a2)
{
  int v2; // edi
  __int16 v3; // si
  __int16 v4; // bx
  int result; // eax

  _disable();
  v2 = dword_180628;
  dword_180628 = dword_17DE64;
  v3 = dword_180624;
  dword_180644 = 960;
  dword_180624 = 960;
  v4 = dword_18062C;
  dword_180648 = 1280;
  dword_18062C = 1280;
  sub_7C120(a1, a2, dword_17DED4 + 834);
  dword_18062C = v4;
  dword_180624 = v3;
  dword_180648 = v4;
  result = v3;
  dword_180628 = v2;
  dword_180644 = v3;
  _enable();
  return result;
}
// 17DE64: using guessed type int dword_17DE64;
// 17DED4: using guessed type int dword_17DED4;
// 180624: using guessed type int dword_180624;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180644: using guessed type int dword_180644;
// 180648: using guessed type int dword_180648;

//----- (00081360) --------------------------------------------------------
int __cdecl sub_81360(int a1, int a2, int a3, int a4, __int16 a5)
{
  int v5; // edi
  int v6; // esi
  __int16 v7; // bx
  __int16 v8; // ax
  int v9; // ecx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // edx
  int v17; // edx
  unsigned int v18; // eax
  __int16 v19[4]; // [esp+0h] [ebp-38h] BYREF
  __int16 v20[4]; // [esp+8h] [ebp-30h] BYREF
  int v21; // [esp+10h] [ebp-28h]
  int v22; // [esp+14h] [ebp-24h]
  int v23; // [esp+18h] [ebp-20h]
  int v24; // [esp+1Ch] [ebp-1Ch]
  int v25; // [esp+20h] [ebp-18h]
  int v26; // [esp+24h] [ebp-14h]
  int v27; // [esp+28h] [ebp-10h]
  unsigned int v28; // [esp+2Ch] [ebp-Ch]
  unsigned int v29; // [esp+30h] [ebp-8h]
  int v30; // [esp+34h] [ebp-4h]

  v5 = a1;
  v6 = a2;
  v20[0] = a1;
  v19[0] = a3;
  v20[1] = a2;
  v19[1] = a4;
  v7 = 0;
  v27 = 0;
  v26 = 0;
  v8 = sub_581E0(v19, v20);
  if ( v8 <= 1024 || v8 >= 1536 )
  {
    if ( v8 <= 1536 || v8 >= 2048 )
    {
      if ( v8 <= 0 || v8 >= 512 )
      {
        if ( v8 <= 512 || v8 >= 1024 )
        {
          if ( v8 != 2048 && v8 )
          {
            switch ( v8 )
            {
              case 512:
                v7 = a5 - 3;
                break;
              case 1024:
                v7 = a5 - 5;
                break;
              case 1536:
                v7 = a5 + 3;
                break;
            }
          }
          else
          {
            v7 = a5 - 1;
          }
        }
        else
        {
          v7 = a5 - 4;
        }
      }
      else
      {
        v7 = a5 - 2;
      }
    }
    else
    {
      v7 = a5 + 2;
    }
  }
  else
  {
    v7 = a5 + 4;
  }
  v22 = a3 - a1;
  v9 = 6 * a5;
  v23 = a4 - a2;
  v21 = *(unsigned __int8 *)(v9 + dword_17DED4 + 4);
  v29 = 2 * abs32((__int16)(a3 - a1) / v21);
  v21 = *(unsigned __int8 *)(v9 + dword_17DED4 + 5);
  v28 = 2 * abs32((__int16)(a4 - a2) / v21);
  v10 = a3 - a1;
  if ( (__int16)(a3 - a1) >= 0 )
  {
    if ( (_WORD)a3 != (_WORD)a1 )
    {
      HIWORD(v10) = HIWORD(dword_17DED4);
      LOWORD(v10) = *(unsigned __int8 *)(v9 + dword_17DED4 + 4);
    }
  }
  else
  {
    HIWORD(v11) = HIWORD(dword_17DED4);
    LOWORD(v11) = *(unsigned __int8 *)(v9 + dword_17DED4 + 4);
    v10 = -v11;
  }
  v25 = v10;
  v12 = v23;
  if ( (v23 & 0x8000u) == 0 )
  {
    if ( (_WORD)v23 )
    {
      v12 = 3 * a5;
      LOWORD(v12) = *(unsigned __int8 *)(dword_17DED4 + 6 * a5 + 5);
    }
  }
  else
  {
    v13 = 3 * a5;
    LOWORD(v13) = *(unsigned __int8 *)(dword_17DED4 + 6 * a5 + 5);
    v12 = -v13;
  }
  v24 = v12;
  if ( (__int16)a1 >= (__int16)a3 )
  {
    if ( (__int16)a1 > (__int16)a3 )
      v27 = 1;
  }
  else
  {
    v27 = 2;
  }
  if ( (__int16)a2 >= (__int16)a4 )
  {
    if ( (__int16)a2 > (__int16)a4 )
      v26 = 1;
  }
  else
  {
    v26 = 2;
  }
  if ( (__int16)v29 <= (__int16)v28 )
  {
    v14 = (__int16)v28;
    v15 = (__int16)v29;
  }
  else
  {
    v14 = (__int16)v29;
    v15 = (__int16)v28;
  }
  v30 = v15 - (v14 >> 1);
  while ( 1 )
  {
    if ( (__int16)v29 <= (__int16)v28 )
    {
      if ( (_WORD)v6 == (_WORD)a4 )
        return sub_7C120(v5, a4, dword_17DED4 + 6 * v7);
      if ( (v30 & 0x8000u) == 0 )
      {
        v5 += v25;
        v30 -= v28;
      }
      v17 = v30;
      v6 += v24;
      v18 = v29;
    }
    else
    {
      if ( (_WORD)v5 == (_WORD)a3 )
        return sub_7C120(a3, v6, dword_17DED4 + 6 * v7);
      if ( (v30 & 0x8000u) == 0 )
      {
        v6 += v24;
        v30 -= v29;
      }
      v17 = v30;
      v5 += v25;
      v18 = v28;
    }
    v30 = v18 + v17;
    if ( !(_WORD)v27 )
      goto LABEL_61;
    if ( (unsigned __int16)v27 > 1u )
      break;
    if ( (__int16)v5 < (__int16)a3 )
      return sub_7C120(a3, a4, dword_17DED4 + 6 * v7);
LABEL_61:
    if ( (_WORD)v26 )
    {
      if ( (unsigned __int16)v26 <= 1u )
      {
        if ( (__int16)v6 < (__int16)a4 )
          return sub_7C120(a3, a4, dword_17DED4 + 6 * v7);
      }
      else if ( (_WORD)v26 == 2 && (__int16)v6 > (__int16)a4 )
      {
        return sub_7C120(a3, a4, dword_17DED4 + 6 * v7);
      }
    }
    sub_7C120(v5, v6, 6 * a5 + dword_17DED4);
  }
  if ( (_WORD)v27 != 2 || (__int16)v5 <= (__int16)a3 )
    goto LABEL_61;
  return sub_7C120(a3, a4, dword_17DED4 + 6 * v7);
}
// 17DED4: using guessed type int dword_17DED4;

//----- (00081760) --------------------------------------------------------
int __fastcall sub_81760(int a1)
{
  int v1; // esi
  __int16 v2; // bx
  __int16 v3; // di
  _WORD *i; // ebx
  int v5; // edx
  int v6; // edi
  char *v7; // ebx
  __int16 v8; // cx
  char *v9; // edx
  int k; // eax
  int v11; // edi
  int v12; // ebx
  __int16 v14[12]; // [esp+0h] [ebp-44h] BYREF
  int v15; // [esp+18h] [ebp-2Ch]
  int j; // [esp+1Ch] [ebp-28h]
  int v17; // [esp+20h] [ebp-24h] BYREF
  int v18; // [esp+24h] [ebp-20h]
  int v19; // [esp+28h] [ebp-1Ch] BYREF
  int m; // [esp+2Ch] [ebp-18h]
  int v21; // [esp+30h] [ebp-14h]
  int v22; // [esp+34h] [ebp-10h]
  int v23; // [esp+38h] [ebp-Ch]
  int v24; // [esp+3Ch] [ebp-8h]
  int v25; // [esp+40h] [ebp-4h]

  v1 = 0;
  v24 = 0;
  if ( byte_E1B82 == 1 )
  {
    _disable();
    v15 = dword_180628;
    dword_180628 = dword_17DE64;
    v2 = dword_180624;
    dword_180644 = 960;
    dword_180624 = 960;
    v3 = dword_18062C;
    dword_180648 = 1280;
    dword_18062C = 1280;
    sub_7C120(518, 17, dword_17DED4 + 1710);
    sub_7C120(583, 17, dword_17DED4 + 1716);
    sub_7C120(657, 17, dword_17DED4 + 1722);
    sub_7C120(696, 17, dword_17DED4 + 1728);
    sub_7C120(518, 88, dword_17DED4 + 1734);
    sub_7C120(574, 88, dword_17DED4 + 1740);
    sub_7C120(657, 88, dword_17DED4 + 1746);
    sub_7C120(706, 88, dword_17DED4 + 1752);
    sub_7C120(518, 156, dword_17DED4 + 1758);
    sub_7C120(582, 156, dword_17DED4 + 1764);
    sub_7C120(657, 156, dword_17DED4 + 1770);
    sub_7C120(703, 156, dword_17DED4 + 1776);
    dword_18062C = v3;
    dword_180624 = v2;
    dword_180648 = v3;
    dword_180644 = v2;
    HIWORD(a1) = HIWORD(v15);
    dword_180628 = v15;
    _enable();
  }
  for ( i = &unk_E1960; i[2]; i += 11 )
  {
    if ( *((_BYTE *)i + 18) == 1 && !(_WORD)v24 )
    {
      LOWORD(a1) = i[6];
      v17 = a1;
      LOWORD(a1) = i[7];
      v19 = a1;
      v17 = ((int)*(unsigned __int8 *)(dword_17DED4 + 226) >> 1) + (__int16)v17;
      a1 = ((int)*(unsigned __int8 *)(dword_17DED4 + 227) >> 1) + (__int16)a1;
      v24 = 1;
LABEL_19:
      v19 = a1;
      continue;
    }
    if ( (_WORD)v24 && *((_BYTE *)i + 18) == 1 )
    {
      LOWORD(a1) = i[7];
      v5 = *(unsigned __int8 *)(dword_17DED4 + 226);
      v21 = a1;
      v6 = (v5 >> 1) + (__int16)i[6];
      v21 = ((int)*(unsigned __int8 *)(dword_17DED4 + 227) >> 1) + (__int16)a1;
      memset(v14, 0, sizeof(v14));
      sub_7E8D0(v14, v6, v21, v17, v19, 2, 2);
      v25 = v17;
      v22 = v19;
      while ( !(_WORD)v1 )
      {
        for ( j = v1; ; j = v1 )
        {
          while ( (__int16)j < 3 )
          {
            v1 = sub_7E9D0((__int16 *)&v17, (__int16 *)&v19, v14);
            ++j;
          }
          if ( (int)abs32((__int16)v19 - (__int16)v22) <= 8 && (int)abs32((__int16)v17 - (__int16)v25) <= 8 )
            break;
          sub_812D0(v17, v19);
          v25 = v17;
          v22 = v19;
          if ( (_WORD)v1 )
            goto LABEL_18;
        }
      }
LABEL_18:
      a1 = v21;
      v17 = v6;
      v1 = 0;
      goto LABEL_19;
    }
  }
  if ( word_17DB8A != -1 )
  {
    v7 = (char *)&unk_E1960;
    v8 = 0;
    v9 = 0;
    for ( k = 0; *((_WORD *)v7 + 2); ++k )
    {
      if ( v7[18] == 1 )
      {
        v8 = 1;
        v9 = v7;
      }
      if ( v7[18] == 2 )
        break;
      v7 += 22;
    }
    if ( (__int16)k < 24 && v8 )
    {
      LOWORD(k) = *((_WORD *)v9 + 6);
      v17 = k;
      LOWORD(k) = *((_WORD *)v9 + 7);
      v19 = k;
      v17 = ((int)*(unsigned __int8 *)(dword_17DED4 + 226) >> 1) + (__int16)v17;
      v19 = ((int)*(unsigned __int8 *)(dword_17DED4 + 227) >> 1) + (__int16)k;
      v11 = ((int)*(unsigned __int8 *)(dword_17DED4 + 226) >> 1) + *((__int16 *)v7 + 6);
      v12 = ((int)*(unsigned __int8 *)(dword_17DED4 + 227) >> 1) + *((__int16 *)v7 + 7);
      memset(v14, 0, sizeof(v14));
      sub_7E8D0(v14, v11, v12, v17, v19, 2, 2);
      v1 = 0;
      v18 = v17;
      v23 = v19;
      while ( !(_WORD)v1 )
      {
        for ( m = v1; ; m = v1 )
        {
          while ( (__int16)m < 3 )
          {
            v1 = sub_7E9D0((__int16 *)&v17, (__int16 *)&v19, v14);
            ++m;
          }
          if ( (int)abs32((__int16)v19 - (__int16)v23) <= 8 && (int)abs32((__int16)v17 - (__int16)v18) <= 8 )
            break;
          sub_812D0(v17, v19);
          v18 = v17;
          v23 = v19;
          if ( (_WORD)v1 )
            return v1;
        }
      }
    }
  }
  return v1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// E1B82: using guessed type char byte_E1B82;
// 17DB8A: using guessed type __int16 word_17DB8A;
// 17DE64: using guessed type int dword_17DE64;
// 17DED4: using guessed type int dword_17DED4;
// 180624: using guessed type int dword_180624;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180644: using guessed type int dword_180644;
// 180648: using guessed type int dword_180648;
// 81760: using guessed type __int16 var_44[12];

//----- (00081CA0) --------------------------------------------------------
unsigned int __usercall sub_81CA0@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3, __int16 a4, int a5)
{
  unsigned int result; // eax
  unsigned __int8 v6; // dl

  result = j___clock(a1, a2, a5);
  v6 = *(_BYTE *)(a5 + 20);
  if ( v6 )
  {
    if ( v6 <= 1u )
    {
      if ( (result - *(_DWORD *)(a5 + 4)) >> 3 )
      {
        if ( *(__int16 *)(a5 + 16) <= *(__int16 *)(a5 + 14) - 2 )
        {
          ++*(_WORD *)(a5 + 16);
        }
        else
        {
          if ( *(_BYTE *)(a5 + 21) == 1 )
            *(_BYTE *)(a5 + 20) = 0;
          *(_WORD *)(a5 + 16) = *(_WORD *)(a5 + 12);
        }
        *(_DWORD *)(a5 + 4) = result;
      }
      result = sub_7C120(*(_WORD *)(a5 + 8) - a3, *(_WORD *)(a5 + 10) - a4, dword_17DED4 + 6 * *(__int16 *)(a5 + 16));
      if ( (word_17DEEE & 1) != 0 )
        ++*(_WORD *)(a5 + 16);
    }
    else if ( v6 == 2 )
    {
      result = (result - *(_DWORD *)a5) / 0x64;
      if ( result > *(__int16 *)(a5 + 18) )
      {
        result = *(__int16 *)(a5 + 22);
        *(_BYTE *)(a5 + 20) = 1;
        if ( result != -1 )
          return (unsigned int)sub_8F100(
                                 0,
                                 *(_WORD *)(a5 + 24),
                                 (unsigned __int8)byte_E1324,
                                 64,
                                 0x64u,
                                 *(_BYTE *)(a5 + 28),
                                 *(_BYTE *)(a5 + 26));
      }
    }
  }
  else
  {
    *(_BYTE *)(a5 + 20) = 2;
    *(_DWORD *)a5 = result;
    *(_DWORD *)(a5 + 4) = result;
  }
  return result;
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// E1324: using guessed type char byte_E1324;
// 17DED4: using guessed type int dword_17DED4;
// 17DEEE: using guessed type __int16 word_17DEEE;

//----- (00081DB0) --------------------------------------------------------
int sub_81DB0()
{
  int result; // eax
  int v1; // ebx
  char v2[80]; // [esp+0h] [ebp-70h] BYREF
  int v3[8]; // [esp+50h] [ebp-20h] BYREF

  result = 0;
  if ( *(_BYTE *)(dword_D41A4 + 38402) == 1 )
  {
    memset(v2, 0, sizeof(v2));
    sprintf(v2, "%c%s", *(unsigned __int8 *)(dword_D41A4 + 182), aNetherwConfigD);
    memset(v3, 0, sizeof(v3));
    v1 = sub_98817((int)v2, 546);
    if ( v1 != -1 )
    {
      qmemcpy(v3, (const void *)dword_D41A4, 0x14u);
      qmemcpy(&v3[5], (const void *)(dword_D41A4 + 20), 2u);
      qmemcpy((char *)&v3[5] + 2, &byte_EB39E, 8u);
      qmemcpy((char *)&v3[7] + 2, &byte_EB39E + 8, 2u);
      v3[0] = -9;
      LOWORD(v3[1]) = *(unsigned __int8 *)(dword_D41A4 + 179);
      sub_98CAA(v1, (int)v3, 32);
      sub_98882(v1);
    }
    result = 1;
    *(_BYTE *)(dword_D41A4 + 38402) = 0;
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;
// EB39E: using guessed type char byte_EB39E;

//----- (00081EE0) --------------------------------------------------------
__int16 __usercall sub_81EE0@<ax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, __int16 a4@<di>, __int16 a5, __int16 a6)
{
  int v6; // eax
  __int16 *v7; // ebx
  int v8; // esi
  __int16 result; // ax
  unsigned __int8 v10; // al
  char v11; // cl
  char v12; // ah
  __int16 v13; // ax
  char v14; // dh
  int v15; // edx
  int v16; // eax
  _WORD *v17; // edx
  __int16 v18; // ax
  char v19; // al
  __int16 v20; // ax
  char v21; // dl
  _WORD *v22; // edx
  __int16 v23; // ax
  unsigned __int8 v24; // al
  char v25; // ch
  int v26; // edx
  __int16 v27; // [esp-18h] [ebp-34h]
  __int16 v28; // [esp-18h] [ebp-34h]
  __int16 v29; // [esp-18h] [ebp-34h]
  int v30; // [esp-14h] [ebp-30h]
  int v31; // [esp-14h] [ebp-30h]
  int v32; // [esp-14h] [ebp-30h]
  __int16 v33; // [esp-Ch] [ebp-28h]
  __int16 v34; // [esp-8h] [ebp-24h]
  unsigned __int8 v35; // [esp-4h] [ebp-20h]
  unsigned __int8 v36; // [esp-4h] [ebp-20h]
  unsigned __int8 v37; // [esp-4h] [ebp-20h]
  int v38; // [esp+0h] [ebp-1Ch]
  __int16 k; // [esp+8h] [ebp-14h]
  __int16 i; // [esp+Ch] [ebp-10h]
  __int16 v41; // [esp+10h] [ebp-Ch]
  __int16 v42; // [esp+14h] [ebp-8h]
  __int16 j; // [esp+18h] [ebp-4h]

  v6 = j___clock(a1, a2, a3);
  v7 = word_E20A4;
  v8 = v6;
  for ( result = word_E20A4[11]; result; result = v7[11] )
  {
    v10 = *((_BYTE *)v7 + 42);
    if ( v10 < 2u )
    {
      if ( v10 == 1 )
      {
        v11 = *((_BYTE *)v7 + 43);
        switch ( v11 )
        {
          case 0:
            v12 = *((_BYTE *)v7 + 43);
            *(_DWORD *)v7 = v8;
            *((_BYTE *)v7 + 43) = v12 + 1;
            break;
          case 1:
            if ( (v8 - *(_DWORD *)v7) / 0x64u > v7[20] )
              *((_BYTE *)v7 + 43) = v11 + 1;
            break;
          case 2:
            v7[9] = v7[11];
            v13 = v7[12];
            v7[10] = v13;
            sub_7E8D0((__int16 *)((char *)v7 + 45), v7[13], v7[14], v7[11], v13, 2, 2);
            v7[17] = v7[15];
            v35 = *((_BYTE *)v7 + 12);
            v30 = (unsigned __int8)byte_E1324;
            v27 = v7[5];
            ++*((_BYTE *)v7 + 43);
            sub_8F100(0, v27, v30, 64, 0x64u, 0, v35);
            break;
          case 3:
            for ( i = 0; i < 4; ++i )
              a4 = sub_7E9D0(v7 + 9, v7 + 10, (__int16 *)((char *)v7 + 45));
            if ( (unsigned int)(v8 - *(_DWORD *)v7) >> 3 )
            {
              if ( v7[17] <= v7[16] - 1 )
                ++v7[17];
              else
                v7[17] = v7[15];
              *(_DWORD *)v7 = v8;
            }
            sub_7C120(v7[9] - a5, v7[10] - a6, dword_17DED4 + 6 * v7[17]);
            if ( a4 )
            {
              v7[17] = v7[18];
              v36 = *((_BYTE *)v7 + 16);
              v31 = (unsigned __int8)byte_E1324;
              v14 = *((_BYTE *)v7 + 43);
              v28 = v7[7];
              *(_DWORD *)v7 = v8;
              *((_BYTE *)v7 + 43) = v14 + 1;
              sub_8F100(0, v28, v31, 64, 0x64u, 0, v36);
            }
            break;
          case 4:
            a4 = 0;
            if ( (unsigned int)(v8 - *(_DWORD *)v7) >> 3 )
            {
              if ( v7[17] <= v7[19] - 1 )
              {
                ++v7[17];
              }
              else
              {
                a4 = 1;
                v7[17] = v7[18];
              }
              *(_DWORD *)v7 = v8;
            }
            if ( !a4 )
            {
              v15 = dword_17DED4;
              v16 = 6 * v7[17];
              goto LABEL_83;
            }
            *((_BYTE *)v7 + 43) = 0;
            break;
          default:
            break;
        }
      }
    }
    else if ( v10 <= 2u )
    {
      if ( byte_17DB8F != 4 )
      {
        v17 = &unk_E1960;
        v18 = 0;
        while ( v17[2] && *((_BYTE *)v17 + 18) != 2 )
        {
          v17 += 11;
          ++v18;
        }
        if ( v18 == 25 )
          v18 = 24;
        if ( v18 == *((unsigned __int8 *)v7 + 44) )
        {
          switch ( *((_BYTE *)v7 + 43) )
          {
            case 0:
              v19 = *((_BYTE *)v7 + 43);
              *(_DWORD *)v7 = v8;
              *((_BYTE *)v7 + 43) = v19 + 1;
              break;
            case 1:
              goto LABEL_41;
            case 2:
              for ( j = 0; j < 4; ++j )
                a4 = sub_7E9D0(v7 + 9, v7 + 10, (__int16 *)((char *)v7 + 45));
              if ( (unsigned int)(v8 - *(_DWORD *)v7) >> 3 )
              {
                if ( v7[17] <= v7[16] - 1 )
                  ++v7[17];
                else
                  v7[17] = v7[15];
                *(_DWORD *)v7 = v8;
              }
              sub_7C120(v7[9] - a5, v7[10] - a6, dword_17DED4 + 6 * v7[17]);
              if ( a4 )
              {
                v7[17] = v7[18];
                v37 = *((_BYTE *)v7 + 16);
                v32 = (unsigned __int8)byte_E1324;
                v21 = *((_BYTE *)v7 + 43);
                v29 = v7[7];
                *(_DWORD *)v7 = v8;
                *((_BYTE *)v7 + 43) = v21 + 1;
                sub_8F100(0, v29, v32, 64, 0x64u, 0, v37);
              }
              break;
            case 3:
              a4 = 0;
              if ( (unsigned int)(v8 - *(_DWORD *)v7) >> 3 )
              {
                if ( v7[17] <= v7[19] - 1 )
                {
                  ++v7[17];
                }
                else
                {
                  a4 = 1;
                  v7[17] = v7[18];
                }
                *(_DWORD *)v7 = v8;
              }
              if ( !a4 )
                goto LABEL_82;
              ++*((_BYTE *)v7 + 43);
              break;
            default:
              break;
          }
        }
        else
        {
          *((_BYTE *)v7 + 43) = 0;
        }
      }
    }
    else if ( v10 == 3 )
    {
      v22 = &unk_E1960;
      v23 = 0;
      while ( v22[2] && *((_BYTE *)v22 + 18) != 2 )
      {
        v22 += 11;
        ++v23;
      }
      if ( v23 )
        --v23;
      if ( v23 == *((unsigned __int8 *)v7 + 44) )
      {
        v24 = *((_BYTE *)v7 + 43);
        if ( v24 )
        {
          if ( v24 <= 1u )
          {
LABEL_41:
            v7[9] = v7[11];
            v20 = v7[12];
            v7[10] = v20;
            sub_7E8D0((__int16 *)((char *)v7 + 45), v7[13], v7[14], v7[11], v20, 2, 2);
            v7[17] = v7[15];
            ++*((_BYTE *)v7 + 43);
            sub_8F100(0, v7[5], (unsigned __int8)byte_E1324, 64, 0x64u, 0, *((_BYTE *)v7 + 12));
          }
          else if ( v24 == 2 )
          {
            for ( k = 0; k < 4; ++k )
              a4 = sub_7E9D0(v7 + 9, v7 + 10, (__int16 *)((char *)v7 + 45));
            if ( (unsigned int)(v8 - *(_DWORD *)v7) >> 3 )
            {
              if ( v7[17] <= v7[16] - 1 )
                ++v7[17];
              else
                v7[17] = v7[15];
              *(_DWORD *)v7 = v8;
            }
            if ( byte_E1B82 == 1 )
            {
              _disable();
              v41 = dword_18062C;
              v42 = dword_180624;
              v38 = dword_180628;
              dword_180628 = dword_17DE64;
              v26 = v7[17];
              dword_180648 = 1280;
              dword_18062C = 1280;
              v34 = v7[10];
              v33 = v7[9];
              dword_180644 = 960;
              dword_180624 = 960;
              sub_7C120(v33, v34, 6 * v26 + dword_17DED4);
              dword_18062C = v41;
              dword_180624 = v42;
              dword_180648 = v41;
              dword_180644 = v42;
              dword_180628 = v38;
              _enable();
            }
            else
            {
LABEL_82:
              v15 = 6 * v7[17];
              v16 = dword_17DED4;
LABEL_83:
              sub_7C120(v7[9] - a5, v7[10] - a6, v15 + v16);
            }
          }
        }
        else
        {
          v25 = *((_BYTE *)v7 + 43);
          *(_DWORD *)v7 = v8;
          *((_BYTE *)v7 + 43) = v25 + 1;
        }
      }
      else
      {
        *((_BYTE *)v7 + 43) = 0;
      }
    }
    v7 = (__int16 *)((char *)v7 + 69);
  }
  return result;
}
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// E1324: using guessed type char byte_E1324;
// E1B82: using guessed type char byte_E1B82;
// E20A4: using guessed type _WORD word_E20A4[414];
// 17DB8F: using guessed type char byte_17DB8F;
// 17DE64: using guessed type int dword_17DE64;
// 17DED4: using guessed type int dword_17DED4;
// 180624: using guessed type int dword_180624;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180644: using guessed type int dword_180644;
// 180648: using guessed type int dword_180648;

//----- (000824B0) --------------------------------------------------------
_WORD *__cdecl sub_824B0(__int16 a1)
{
  _WORD *result; // eax

  result = word_E2970;
  if ( !word_E2970[6] )
    return 0;
  while ( a1 != result[2] )
  {
    result = (_WORD *)((char *)result + 17);
    if ( !result[6] )
      return 0;
  }
  return result;
}
// E2970: using guessed type _WORD word_E2970[51];

//----- (000824E0) --------------------------------------------------------
_WORD *__cdecl sub_824E0(__int16 a1)
{
  _WORD *result; // eax

  result = word_E2970;
  if ( !word_E2970[6] )
    return 0;
  while ( a1 != result[3] )
  {
    result = (_WORD *)((char *)result + 17);
    if ( !result[6] )
      return 0;
  }
  return result;
}
// E2970: using guessed type _WORD word_E2970[51];

//----- (00082510) --------------------------------------------------------
int __usercall sub_82510@<eax>(__int16 a1@<dx>, int *a2)
{
  int v2; // eax
  int v3; // edx
  __int16 v4; // dx
  char *v5; // esi
  int (__cdecl **v6)(int); // edx
  int v7; // eax
  int v8; // ecx
  int result; // eax
  __int16 v10[18]; // [esp+0h] [ebp-2Ch] BYREF
  int v11; // [esp+24h] [ebp-8h]
  int v12; // [esp+28h] [ebp-4h]

  v12 = dword_17DEC0;
  v11 = dword_17DEC4;
  dword_17DEC0 = dword_17DEC8;
  dword_17DEC4 = dword_17DECC;
  if ( *(_BYTE *)(dword_D41A4 + 10) == 1 )
  {
    HIBYTE(a1) = *((_BYTE *)a2 + 14);
    if ( HIBYTE(a1) == 2 )
    {
      v2 = j___clock(dword_D41A4, a1, a2);
      v3 = *a2;
      a2[1] = v2;
      if ( (v2 - v3) / 0x64u > 1 )
      {
        v4 = *((_WORD *)a2 + 6) + 1;
        *((_WORD *)a2 + 6) = v4;
        if ( !word_E2518[9 * v4] )
          *((_WORD *)a2 + 6) = 0;
        *a2 = a2[1];
      }
      memset(v10, 0, sizeof(v10));
      v5 = (char *)&unk_E2516 + 18 * *((__int16 *)a2 + 6);
      v6 = &off_E23E0;
      qmemcpy(v10, v5, 0x10u);
      qmemcpy(&v10[8], v5 + 16, sizeof(__int16));
      while ( *((_BYTE *)v6 + 25) )
      {
        if ( *((_BYTE *)v6 + 23) && *((_BYTE *)v6 + 22) == byte_E2527[18 * *((__int16 *)a2 + 6)] )
        {
          *((_BYTE *)v6 + 24) = 1;
          break;
        }
        v6 += 11;
      }
      sub_7E840(v10, 238, 264);
    }
    else if ( HIBYTE(a1) == 3 )
    {
      v7 = j___clock(dword_D41A4, a1, a2);
      v8 = *a2;
      a2[1] = v7;
      if ( (v7 - v8) / 0x64u > 1 )
        *((_BYTE *)a2 + 14) = 2;
    }
  }
  dword_17DEC0 = v12;
  result = v11;
  dword_17DEC4 = v11;
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E23E0: using guessed type int (__cdecl *off_E23E0)(int);
// E2518: using guessed type __int16 word_E2518[];
// 17DEC0: using guessed type int dword_17DEC0;
// 17DEC4: using guessed type int dword_17DEC4;
// 17DEC8: using guessed type int dword_17DEC8;
// 17DECC: using guessed type int dword_17DECC;
// 82510: using guessed type __int16 var_2C[18];

//----- (00082670) --------------------------------------------------------
__int16 sub_82670()
{
  __int16 v0; // si
  _WORD *v1; // eax
  int v2; // eax
  void **v3; // ebx
  __int16 v4; // cx
  _WORD *v5; // edi
  int v6; // eax
  int v7; // eax
  int v8; // eax
  char v10[80]; // [esp+0h] [ebp-54h] BYREF
  unsigned __int8 v11; // [esp+50h] [ebp-4h]

  v0 = 0;
  v11 = word_180660;
  LOWORD(v1) = (unsigned __int8)word_180660;
  byte_1806E4 = 0;
  if ( !byte_E29E1 )
  {
    LOWORD(v1) = dword_D41A4;
    if ( (*(_BYTE *)(dword_D41A4 + 22) & 0x10) == 0 )
    {
      v2 = *(_DWORD *)(dword_D41A4 + 226);
      byte_D41C1 = 0;
      dword_17DE48 = v2;
      dword_17DE54 = v2 + 301787;
      dword_17DEC0 = v2 + 308527;
      dword_17DEC4 = (int)&algn_4BB85[v2 + 10];
      sub_7AA70((int)aDataScreensHsc, (char *)(v2 + 301787), (int)&unk_164FCD, 860);
      sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC0, (int)&unk_165329, 548);
      sub_7AA70(0, 0, 0, 0);
      if ( (*(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11232) & 2) != 0
        || (LOWORD(v1) = dword_D41A4, *(_WORD *)(dword_D41A4 + 43) > 0x18u) )
      {
        v3 = &off_E16E0;
        LOWORD(v1) = 1;
        while ( *((_BYTE *)v3 + 4) )
        {
          if ( *(unsigned __int16 *)(dword_D41A4 + 43) + 1 == *((unsigned __int8 *)v3 + 4) )
          {
            if ( !*((_BYTE *)v3 + 5) )
            {
              v0 = (__int16)v1;
              *((_BYTE *)v3 + 5) = 1;
            }
            break;
          }
          v3 = (void **)((char *)v3 + 7);
          LOWORD(v1) = (_WORD)v1 + 1;
        }
        if ( !v0 )
        {
          LOWORD(v1) = dword_D41A4;
          v4 = *(_WORD *)(dword_D41A4 + 43);
          if ( (unsigned __int16)v4 > 0x18u )
          {
            v1 = sub_824E0(v4);
            v5 = v1;
            if ( v1 )
            {
              v3 = &off_E16E0;
              LOWORD(v1) = 1;
              while ( *((_BYTE *)v3 + 4) )
              {
                if ( (__int16)v5[2] + 1 == *((unsigned __int8 *)v3 + 4) )
                {
                  if ( !*((_BYTE *)v3 + 5) )
                  {
                    v0 = (__int16)v1;
                    *((_BYTE *)v3 + 5) = 1;
                  }
                  break;
                }
                v3 = (void **)((char *)v3 + 7);
                LOWORD(v1) = (_WORD)v1 + 1;
              }
            }
          }
        }
        if ( v0 )
        {
          if ( *(_BYTE *)(dword_D41A4 + 179) == 2 && byte_E3798 || v0 >= 6 )
          {
            byte_D41C1 = 0;
            byte_D41C0 = 0;
          }
          else
          {
            sub_2EB40();
            byte_D41C1 = 1;
            byte_D41C0 = 1;
          }
          sub_8CD27(dword_EB394);
          memset(dword_180628, 0, 307200);
          if ( word_180660 != 1 )
          {
            sub_54600();
            v6 = memset(dword_EA3D8, 0, 768);
            if ( (word_180660 & 1) != 0 )
              sub_72883(dword_180628, (void *)dword_180628, 0xC8u, 0);
            else
              sub_728A9(v6, (void *)dword_180628, 0x1E0u, 0);
            sub_41A90((unsigned __int8 *)dword_EA3D8);
            word_180660 = 1;
            sub_90D6E((unsigned __int8 *)dword_EA3D8);
            sub_8CEDF();
            sub_8CD27(dword_EB394);
          }
          if ( (word_180660 & 1) != 0 )
            sub_98709(dword_17DEC0, dword_17DEC4, dword_17DE54);
          else
            sub_9874D((unsigned int *)dword_17DEC0, dword_17DEC4, dword_17DE54);
          sprintf(v10, "intro\\cut%d.dat", *((unsigned __int8 *)v3 + 6));
          sprintf(&unk_E3848, v10);
          sub_76160(0, 1, (int)*v3);
          sub_90B27(0, 0x10u, 0);
          sub_8D8F0();
          sub_8E020();
          sub_7B5D0();
          if ( (word_180660 & 1) != 0 )
            sub_72883(v7, (void *)dword_180628, 0xC8u, 0);
          else
            sub_728A9(v7, (void *)dword_180628, 0x1E0u, 0);
          if ( (word_180660 & 1) != 0 )
            sub_90478();
          else
            sub_75200(480);
          LOWORD(v1) = v11;
          if ( v11 != word_180660 )
          {
            sub_54600();
            v8 = memset(dword_EA3D8, 0, 768);
            if ( (word_180660 & 1) != 0 )
              sub_72883(v8, (void *)dword_180628, 0xC8u, 0);
            else
              sub_728A9(v8, (void *)dword_180628, 0x1E0u, 0);
            sub_41A90((unsigned __int8 *)dword_EA3D8);
            word_180660 = v11;
            if ( (v11 & 1) != 0 )
              sub_90D6E((unsigned __int8 *)dword_EA3D8);
            else
              sub_90E07((unsigned __int8 *)dword_EA3D8);
            sub_8CEDF();
            LOWORD(v1) = sub_8CD27(dword_EB394);
          }
        }
      }
    }
  }
  byte_D41C1 = 0;
  return (__int16)v1;
}
// 829A1: variable 'v7' is possibly undefined
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41C0: using guessed type char byte_D41C0;
// D41C1: using guessed type char byte_D41C1;
// E16E0: using guessed type void *off_E16E0;
// E29E1: using guessed type char byte_E29E1;
// E3798: using guessed type char byte_E3798;
// EA3D8: using guessed type int dword_EA3D8;
// EB394: using guessed type int dword_EB394;
// 17DE48: using guessed type int dword_17DE48;
// 17DE54: using guessed type int dword_17DE54;
// 17DEC0: using guessed type int dword_17DEC0;
// 17DEC4: using guessed type int dword_17DEC4;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;
// 1806E4: using guessed type char byte_1806E4;

//----- (00082AB0) --------------------------------------------------------
int __cdecl sub_82AB0(unsigned __int8 a1)
{
  int v1; // eax
  int v2; // edx
  int result; // eax
  _WORD *v4; // ebx
  __int16 i; // cx
  int v6; // eax
  int v7; // edx

  if ( a1 > 0x18u )
  {
    v4 = word_E2970;
    for ( i = 0; v4[6]; ++i )
    {
      result = a1;
      if ( a1 == v4[3] )
      {
        v6 = dword_D41A0;
        v7 = 5 * i;
        dword_17DDBC[v7] = *(_DWORD *)(dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12) + 12605);
        dword_17DDC0[v7] = *(_DWORD *)(2124 * *(__int16 *)(v6 + 12) + v6 + 12609);
        dword_17DDC4[v7] = *(_DWORD *)(2124 * *(__int16 *)(v6 + 12) + v6 + 12601);
        dword_17DDC8[v7] = *(_DWORD *)(2124 * *(__int16 *)(v6 + 12) + v6 + 12613);
        result = *(_DWORD *)(2124 * *(__int16 *)(v6 + 12) + v6 + 12621);
        dword_17DDCC[v7] = result;
      }
      v4 = (_WORD *)((char *)v4 + 17);
    }
  }
  else
  {
    v1 = dword_D41A0;
    v2 = 5 * a1;
    dword_17DBC8[v2] = *(_DWORD *)(dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12) + 12605);
    dword_17DBCC[v2] = *(_DWORD *)(2124 * *(__int16 *)(v1 + 12) + v1 + 12609);
    dword_17DBD0[v2] = *(_DWORD *)(2124 * *(__int16 *)(v1 + 12) + v1 + 12601);
    dword_17DBD4[v2] = *(_DWORD *)(2124 * *(__int16 *)(v1 + 12) + v1 + 12613);
    result = *(_DWORD *)(2124 * *(__int16 *)(v1 + 12) + v1 + 12621);
    dword_17DBD8[v2] = result;
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E2970: using guessed type _WORD word_E2970[51];
// 17DBC8: using guessed type int dword_17DBC8[];
// 17DBCC: using guessed type int dword_17DBCC[];
// 17DBD0: using guessed type int dword_17DBD0[];
// 17DBD4: using guessed type int dword_17DBD4[];
// 17DBD8: using guessed type int dword_17DBD8[121];
// 17DDBC: using guessed type int dword_17DDBC[];
// 17DDC0: using guessed type int dword_17DDC0[];
// 17DDC4: using guessed type int dword_17DDC4[];
// 17DDC8: using guessed type int dword_17DDC8[];
// 17DDCC: using guessed type int dword_17DDCC[21];

//----- (00082C20) --------------------------------------------------------
int __usercall sub_82C20@<eax>(int result@<eax>, __int16 a2)
{
  _WORD *v2; // edx
  __int16 v3; // si
  int v4; // ebx
  __int16 v5; // bx
  __int16 v6; // si
  __int16 v7; // bx
  __int16 v8; // si
  int v9; // esi
  int v10; // edi
  __int16 i; // bx
  int v12; // eax
  _BYTE *v13; // ebx
  __int16 j; // ax
  unsigned __int16 v15; // dx
  __int16 k; // bx
  int v17; // eax
  __int16 v18; // di
  int v19; // ebx
  char v20[40]; // [esp+0h] [ebp-12h] BYREF
  char *v21[5]; // [esp+28h] [ebp+16h]
  _BYTE *v22; // [esp+3Ch] [ebp+2Ah]
  int v23; // [esp+40h] [ebp+2Eh]
  int v24; // [esp+44h] [ebp+32h]
  int v25; // [esp+48h] [ebp+36h]
  int v26; // [esp+4Ch] [ebp+3Ah]
  int v27; // [esp+50h] [ebp+3Eh]
  int v28; // [esp+54h] [ebp+42h]
  int v29; // [esp+58h] [ebp+46h]
  int v30; // [esp+5Ch] [ebp+4Ah]
  int v31; // [esp+60h] [ebp+4Eh]
  int v32; // [esp+64h] [ebp+52h]
  int v33; // [esp+68h] [ebp+56h]
  int v34; // [esp+6Ch] [ebp+5Ah]
  int v35; // [esp+70h] [ebp+5Eh]
  int v36; // [esp+74h] [ebp+62h]
  int v37; // [esp+78h] [ebp+66h]
  int v38; // [esp+7Ch] [ebp+6Ah]
  int v39; // [esp+80h] [ebp+6Eh]
  int v40; // [esp+84h] [ebp+72h]
  int v41; // [esp+88h] [ebp+76h]
  int v42; // [esp+8Ch] [ebp+7Ah]

  v35 = 50;
  v41 = 50;
  if ( a2 > -1 )
  {
    v21[0] = off_D9204[a2];
    v21[1] = (char *)dword_EA254;
    v21[2] = (char *)dword_EA250;
    v23 = 0;
    v21[3] = (char *)dword_EA24C;
    v24 = 0;
    v21[4] = (char *)dword_EA230;
    v30 = 0;
    v22 = (_BYTE *)dword_EA274;
    if ( a2 > 24 )
    {
      v2 = word_E2970;
      v3 = 0;
      while ( v2[6] )
      {
        if ( a2 == v2[3] )
        {
          v4 = 5 * v3;
          v25 = dword_17DDBC[v4];
          v26 = dword_17DDC0[v4];
          v27 = dword_17DDC4[v4];
          v28 = dword_17DDC8[v4];
          v29 = dword_17DDCC[v4];
        }
        v2 = (_WORD *)((char *)v2 + 17);
        ++v3;
      }
    }
    else
    {
      v25 = dword_17DBC8[5 * a2];
      v26 = dword_17DBCC[5 * a2];
      v27 = dword_17DBD0[5 * a2];
      v28 = dword_17DBD4[5 * a2];
      v29 = dword_17DBD8[5 * a2];
    }
    v5 = 1;
    v6 = strlen(v21[0]);
    while ( v5 < 6 )
    {
      if ( strlen(v21[v5]) > v6 )
        v6 = strlen(v21[v5]);
      ++v5;
    }
    v7 = 1;
    v8 = strlen(v21[0]);
    while ( v7 < 6 )
    {
      if ( strlen(v21[v7]) > v8 )
        v8 = strlen(v21[v7]);
      ++v7;
    }
    LOWORD(v9) = 2 * *(unsigned __int8 *)(dword_17DEC0 + 394) * v8;
    v10 = 320 - (__int16)v9 / 2;
    v37 = *(unsigned __int8 *)(dword_17DED4 + 1654);
    v33 = (unsigned __int8)v37;
    if ( (__int16)v9 % (int)(unsigned __int8)v37 )
      v9 = ((__int16)v9 / (int)(unsigned __int8)v37 + 1) * v37;
    for ( i = 0; i < (__int16)v9; i += v37 )
      sub_7C120(i + v10, v41, dword_17DED4 + 1650);
    HIWORD(v12) = HIWORD(dword_17DED4);
    LOWORD(v12) = *(unsigned __int8 *)(dword_17DED4 + 1655);
    v42 = 0;
    v41 += v12;
    do
    {
      v34 = (__int16)v10 + *(unsigned __int8 *)(dword_17DED4 + 1648);
      v32 = (__int16)v41;
      v33 = (__int16)v41;
      v13 = (_BYTE *)(v34 + 640 * (__int16)v41 + dword_180628);
      sub_7C120(v10, v41, dword_17DED4 + 1644);
      sub_7C120(v9 + v10 - *(unsigned __int8 *)(dword_17DED4 + 1648), v33, dword_17DED4 + 1644);
      v38 = 0;
      while ( *(unsigned __int8 *)(dword_17DED4 + 1649) > (__int16)v38 )
      {
        for ( j = 0; j < (__int16)v9 - 2 * *(unsigned __int8 *)(dword_17DED4 + 1648); ++j )
        {
          HIBYTE(v15) = 15;
          LOBYTE(v15) = *v13;
          v34 = v15;
          *v13++ = *(_BYTE *)(v15 + dword_17DE3C);
        }
        ++v38;
        v13 += 640 - j;
        ++v41;
      }
      ++v42;
    }
    while ( (__int16)v42 < 12 );
    for ( k = 0; k < (__int16)v9; k += v37 )
      sub_7C120(k + v10, v41, dword_17DED4 + 1650);
    HIWORD(v17) = HIWORD(dword_17DED4);
    LOWORD(v17) = *(unsigned __int8 *)(dword_17DED4 + 1648);
    v40 = 2 * v17 + v35;
    LOWORD(v17) = *(unsigned __int8 *)(dword_17DEC0 + 394);
    v18 = v17 + v10;
    sub_7FAE0(v21[0], v18, v9 - (unsigned __int8)v17 + v18, v40, 0);
    v19 = 1;
    v40 += 5;
    while ( 1 )
    {
      v39 = v40 + 2;
      if ( (__int16)v19 >= 5 )
      {
        sub_7FB90(
          v22,
          (__int16)(v18 + 2 * *(unsigned __int8 *)(dword_17DEC0 + 394)),
          v39 + 5 * *(unsigned __int8 *)(dword_17DEC0 + 395) + *(unsigned __int8 *)(dword_17DEC0 + 395),
          0);
        v32 = 60;
        v34 = v29 % 3600 / 60;
        v31 = v34;
        sprintf(v20, "%02d:%02d:%02d", v29 / 3600, v34, v29 % 3600 % 60);
        return sub_7FB90(
                 v20,
                 (__int16)(v18 + v9 - 14 * *(unsigned __int8 *)(dword_17DEC0 + 394)),
                 v39 + 5 * *(unsigned __int8 *)(dword_17DEC0 + 395) + *(unsigned __int8 *)(dword_17DEC0 + 395),
                 0);
      }
      if ( v21[(__int16)v19] )
        break;
LABEL_47:
      ++v19;
    }
    if ( *(_BYTE *)(dword_D41A4 + 179) != 2 )
    {
      v36 = v19 * *(unsigned __int8 *)(dword_17DEC0 + 395);
      sub_7FB90(v21[(__int16)v19], (__int16)(v18 + 2 * *(unsigned __int8 *)(dword_17DEC0 + 394)), v36 + v39, 0);
      goto LABEL_46;
    }
    if ( (unsigned __int16)v19 < 2u )
      goto LABEL_44;
    if ( (unsigned __int16)v19 <= 2u )
    {
      sub_7FB90(
        aHitAccuracy,
        (__int16)(v18 + 2 * *(unsigned __int8 *)(dword_17DEC0 + 394)),
        v39 + v19 * *(unsigned __int8 *)(dword_17DEC0 + 395),
        0);
    }
    else
    {
      if ( (_WORD)v19 != 4 )
      {
LABEL_44:
        sub_7FB90(
          v21[(__int16)v19],
          (__int16)(v18 + 2 * *(unsigned __int8 *)(dword_17DEC0 + 394)),
          *(unsigned __int8 *)(dword_17DEC0 + 395) * (_WORD)v19 + v40 + 2,
          0);
        goto LABEL_46;
      }
      sub_7FB90(
        aManaCollected,
        (__int16)(v18 + 2 * *(unsigned __int8 *)(dword_17DEC0 + 394)),
        v39 + 4 * *(unsigned __int8 *)(dword_17DEC0 + 395),
        0);
    }
LABEL_46:
    sprintf(v20, "%3d%%", *(&v24 + (__int16)v19));
    sub_7FB90(
      v20,
      (__int16)(v18 + v9 - 8 * *(unsigned __int8 *)(dword_17DEC0 + 394)),
      v40 + 2 + v19 * *(unsigned __int8 *)(dword_17DEC0 + 395),
      0);
    goto LABEL_47;
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D41A4: using guessed type int dword_D41A4;
// D9204: using guessed type char *off_D9204[2];
// E2970: using guessed type _WORD word_E2970[51];
// EA230: using guessed type int dword_EA230;
// EA24C: using guessed type int dword_EA24C;
// EA250: using guessed type int dword_EA250;
// EA254: using guessed type int dword_EA254;
// EA274: using guessed type int dword_EA274;
// 17DBC8: using guessed type int dword_17DBC8[];
// 17DBCC: using guessed type int dword_17DBCC[];
// 17DBD0: using guessed type int dword_17DBD0[];
// 17DBD4: using guessed type int dword_17DBD4[];
// 17DBD8: using guessed type int dword_17DBD8[121];
// 17DDBC: using guessed type int dword_17DDBC[];
// 17DDC0: using guessed type int dword_17DDC0[];
// 17DDC4: using guessed type int dword_17DDC4[];
// 17DDC8: using guessed type int dword_17DDC8[];
// 17DDCC: using guessed type int dword_17DDCC[21];
// 17DE3C: using guessed type int dword_17DE3C;
// 17DEC0: using guessed type int dword_17DEC0;
// 17DED4: using guessed type int dword_17DED4;
// 180628: using guessed type int dword_180628;

//----- (00083250) --------------------------------------------------------
int __cdecl sub_83250(char a1)
{
  int v1; // eax

  sub_8CD27(dword_EB394);
  memset(dword_180628, 0, 307200);
  if ( word_180660 != 1 )
  {
    sub_54600();
    memset(dword_EA3D8, 0, 768);
    word_180660 = 1;
    sub_90D6E((unsigned __int8 *)dword_EA3D8);
    sub_8CEDF();
    sub_8CD27(dword_EB394);
  }
  sub_76D10(a1);
  sub_54600();
  v1 = memset(dword_EA3D8, 0, 768);
  BYTE1(v1) = word_180660;
  if ( (word_180660 & 1) != 0 )
    sub_72883(v1, (void *)dword_180628, 0xC8u, 0);
  else
    sub_728A9(v1, (void *)dword_180628, 0x1E0u, 0);
  sub_41A90((unsigned __int8 *)dword_EA3D8);
  word_180660 = 8;
  sub_90E07((unsigned __int8 *)dword_EA3D8);
  sub_8CEDF();
  sub_8CD27(dword_EB394);
  sub_6EDB0();
  sub_7A110(word_180660, 4);
  sub_7B5A0();
  sub_8CD27(dword_17DED4 + 234);
  word_17DEEE = 0;
  byte_17DF10 = 0;
  return sub_84300(0);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// EA3D8: using guessed type int dword_EA3D8;
// EB394: using guessed type int dword_EB394;
// 17DED4: using guessed type int dword_17DED4;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;

//----- (000833C0) --------------------------------------------------------
void sub_833C0()
{
  int v0; // eax
  int v1; // eax
  int v2; // esi
  unsigned int v3; // edx
  int v4; // ebx
  int v5; // eax
  int v6; // eax
  unsigned int v7; // eax
  char *v8; // ecx
  int v9; // eax
  int v10; // eax
  unsigned __int8 v11; // al
  int v12; // eax
  int v13; // eax
  int v14; // [esp+0h] [ebp-14h]
  int v15; // [esp+8h] [ebp-Ch]
  __int16 v16; // [esp+Ch] [ebp-8h]
  int i; // [esp+10h] [ebp-4h]

  v15 = 0;
  v16 = 0;
  dword_17DE38 = dword_EA3D8;
  word_17DEEC = 0;
  dword_17DE40 = dword_180628;
  dword_17DEE0 = -1;
  v0 = *(_DWORD *)(dword_D41A4 + 226);
  dword_17DEDC = 0;
  dword_17DE48 = v0;
  sub_7B5D0();
  dword_17DE54 = dword_17DE48 + 301787;
  dword_17DEC4 = dword_17DE48 + 316179;
  dword_17DE58 = dword_17DE48 + 316179;
  dword_17DEC8 = dword_17DE48 + 322754;
  dword_17DECC = dword_17DE48 + 324380;
  dword_17DED4 = dword_17DE48 + 324380;
  dword_17DED8 = dword_17DE48 + 326258;
  dword_17DE60 = dword_17DE44;
  dword_17DE64 = dword_17DE48 + 326258;
  dword_17DE3C = (int)&unk_12C000 + dword_17DE48 + 326258;
  dword_17DEC0 = dword_17DE48 + 314541;
  dword_17DE5C = dword_17DE3C + 0x4000;
  v1 = j___clock(dword_17DE3C + 0x4000, 0, -1);
  v2 = v1;
  while ( sub_9A10A(v1) )
  {
    byte_1806E4 = 0;
    LOBYTE(v1) = sub_7A060();
  }
  sub_8CD27(dword_EB394);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE54, (int)&unk_1641FC, 1214);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC0, (int)&unk_1646BA, 589);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE58, (int)&unk_164907, 1191);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DEC8, (int)&unk_164DAE, 543);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE38, (int)&unk_178B5F, 768);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_17DE64, (int)&unk_16554D, 79378);
  sub_7AA70(0, 0, 0, 0);
  if ( (word_180660 & 1) != 0 )
    sub_98709(dword_17DEC0, dword_17DEC4, dword_17DE54);
  else
    sub_9874D((unsigned int *)dword_17DEC0, dword_17DEC4, dword_17DE54);
  if ( (word_180660 & 1) != 0 )
  {
    v3 = dword_17DE58;
    sub_98709(dword_17DEC8, dword_17DECC, dword_17DE58);
  }
  else
  {
    v3 = dword_17DEC8;
    sub_9874D((unsigned int *)dword_17DEC8, dword_17DECC, dword_17DE58);
  }
  byte_17DF10 = 0;
  v4 = dword_17DEC0 + 6;
  word_17DEEE = 0;
  dword_17DEC0 += 6;
  while ( !byte_17DF10 && !word_17DEEE )
  {
    if ( (word_180660 & 1) != 0 )
    {
      sub_9A128((const void *)dword_17DE64, (void *)dword_180628, 0xC8u);
    }
    else
    {
      v3 = dword_17DE64;
      sub_9A144((const void *)dword_17DE64, (void *)dword_180628, 0x1E0u);
    }
    v6 = j___clock(v5, v3, v4);
    v4 = v15;
    v14 = v6;
    for ( i = 0; ; i += v12 + 2 )
    {
      v7 = (v14 - v2) / 0x64u;
      v3 = (v14 - v2) % 0x64u;
      v8 = off_DB558[(__int16)v4];
      if ( !v8 )
      {
        if ( v7 > 5 )
        {
          v9 = j___clock(v7, v3, v4);
          v4 = 0;
          v2 = v9;
          v15 = 0;
        }
        goto LABEL_24;
      }
      if ( !stricmp(v8, &aE[1]) )
        break;
      v11 = sub_5BE80((unsigned __int8 *)dword_17DE38, 0x3Fu, 0x3Fu, 0x3Fu);
      sub_7FCB0(v4, off_DB558[(__int16)v4], 10, 620, (__int16)(i + 200), 5, v11, 0);
      HIWORD(v12) = HIWORD(dword_17DEC0);
      LOWORD(v12) = *(unsigned __int8 *)(dword_17DEC0 + 395);
      ++v4;
    }
    if ( (v14 - v2) / 0x64u > 2 )
    {
      v10 = j___clock(0, v3, v4++);
      v2 = v10;
      v15 = v4;
    }
LABEL_24:
    sub_7A060();
    if ( v16 )
    {
      if ( (word_180660 & 1) != 0 )
        sub_90478();
      else
        sub_75200(480);
    }
    else
    {
      v3 = dword_17DE38;
      sub_90B27((char *)dword_17DE38, 0x20u, 0);
      v16 = 1;
    }
  }
  sub_90B27(0, 0x10u, 0);
  v13 = memset(dword_EA3D8, 0, 768);
  LOBYTE(v13) = word_180660;
  if ( (word_180660 & 1) != 0 )
    sub_72883(v13, (void *)dword_180628, 0xC8u, 0);
  else
    sub_728A9(v13, (void *)dword_180628, 0x1E0u, 0);
  if ( (word_180660 & 1) != 0 )
    sub_90478();
  else
    sub_75200(480);
  while ( byte_17DF10 || word_17DEEE )
    sub_7A060();
  byte_17DF10 = 0;
}
// 83497: variable 'v1' is possibly undefined
// 8367C: variable 'v5' is possibly undefined
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// DB558: using guessed type char *off_DB558[3];
// EA3D8: using guessed type int dword_EA3D8;
// EB394: using guessed type int dword_EB394;
// 17DE38: using guessed type int dword_17DE38;
// 17DE3C: using guessed type int dword_17DE3C;
// 17DE40: using guessed type int dword_17DE40;
// 17DE44: using guessed type int dword_17DE44;
// 17DE48: using guessed type int dword_17DE48;
// 17DE54: using guessed type int dword_17DE54;
// 17DE58: using guessed type int dword_17DE58;
// 17DE5C: using guessed type int dword_17DE5C;
// 17DE60: using guessed type int dword_17DE60;
// 17DE64: using guessed type int dword_17DE64;
// 17DEC0: using guessed type int dword_17DEC0;
// 17DEC4: using guessed type int dword_17DEC4;
// 17DEC8: using guessed type int dword_17DEC8;
// 17DECC: using guessed type int dword_17DECC;
// 17DED4: using guessed type int dword_17DED4;
// 17DED8: using guessed type int dword_17DED8;
// 17DEDC: using guessed type int dword_17DEDC;
// 17DEE0: using guessed type int dword_17DEE0;
// 17DEEC: using guessed type __int16 word_17DEEC;
// 17DEEE: using guessed type __int16 word_17DEEE;
// 17DF10: using guessed type char byte_17DF10;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;
// 1806E4: using guessed type char byte_1806E4;

//----- (00083850) --------------------------------------------------------
int sub_83850()
{
  unsigned int v0; // edx
  int v1; // eax
  int v2; // ebx
  int v3; // esi
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax

  v0 = dword_E9C38;
  sub_7AA70((int)aDataScreensHsc, (char *)dword_E9C38, (int)&unk_178E5F, 12985);
  sub_7AA70((int)aDataScreensHsc, (char *)dword_EA3D8, (int)&unk_17C118, 768);
  v1 = sub_7AA70(0, 0, 0, 0);
  v2 = 0;
  v4 = j___clock(v1, v0, 0);
  v3 = v4;
  BYTE1(v4) = 0;
  byte_1806E4 = 0;
  while ( !byte_1806E4 )
  {
    if ( word_180746 )
      break;
    if ( word_180744 )
      break;
    v5 = j___clock(v4, v0, v2);
    v0 = (v5 - v3) % 0x64u;
    if ( (v5 - v3) / 0x64u > 0x14 )
      break;
    if ( (word_180660 & 1) != 0 )
    {
      sub_9A128((const void *)dword_E9C38, (void *)dword_180628, 0xC8u);
    }
    else
    {
      v0 = dword_180628;
      sub_9A144((const void *)dword_E9C38, (void *)dword_180628, 0x1E0u);
    }
    if ( (_WORD)v2 )
    {
      if ( (word_180660 & 1) != 0 )
        sub_90478();
      else
        sub_75200(480);
    }
    else
    {
      v2 = 1;
      LOWORD(v4) = sub_90B27((char *)dword_EA3D8, 0x20u, 0);
    }
  }
  LOWORD(v6) = sub_90B27(0, 0x10u, 0);
  if ( (word_180660 & 1) != 0 )
    sub_72883(dword_180628, (void *)dword_180628, 0xC8u, 0);
  else
    sub_728A9(v6, (void *)dword_180628, 0x1E0u, 0);
  if ( (word_180660 & 1) != 0 )
    sub_90478();
  else
    sub_75200(480);
  while ( sub_9A10A(v7) )
  {
    byte_1806E4 = 0;
    LOBYTE(v7) = sub_7A060();
  }
  return j___delay(50);
}
// 8395E: conditional instruction was optimized away because bx.2==0
// 838DC: variable 'v4' is possibly undefined
// 839BC: variable 'v6' is possibly undefined
// 839E6: variable 'v7' is possibly undefined
// 98786: using guessed type int __fastcall j___clock(_DWORD, _DWORD, _DWORD);
// 9A122: using guessed type _DWORD __cdecl j___delay(_DWORD);
// E9C38: using guessed type int dword_E9C38;
// EA3D8: using guessed type int dword_EA3D8;
// 180628: using guessed type int dword_180628;
// 180660: using guessed type __int16 word_180660;
// 1806E4: using guessed type char byte_1806E4;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;

//----- (00083B50) --------------------------------------------------------
int sub_83B50()
{
  int result; // eax
  int v1; // edx
  int v2; // edx

  result = dword_D41A4;
  if ( !*(_DWORD *)(dword_D41A4 + 226) )
  {
    byte_D41B5 = 32;
    byte_DB74C = 1;
    if ( (unsigned int)dword_17FEAC <= 0x800000 )
    {
      if ( (unsigned int)dword_17FEAC <= 0x700000 )
      {
        v1 = dword_17FEAC - 2398576;
        if ( (unsigned int)dword_17FEAC < 0x500001 )
        {
          if ( (unsigned int)dword_17FEAC <= 0x400000 )
          {
            if ( (unsigned int)dword_17FEAC <= 0x300000 )
            {
              *(_DWORD *)(dword_D41A4 + 230) = 0x200000;
              byte_D41B5 = 16;
            }
            else
            {
              *(_DWORD *)(dword_D41A4 + 230) = dword_17FEAC - 1398576;
            }
            sub_9A230(811);
          }
          else
          {
            *(_DWORD *)(dword_D41A4 + 230) = v1;
            sub_9A230(811);
          }
        }
        else
        {
          *(_DWORD *)(dword_D41A4 + 230) = v1;
          sub_9A230(822);
        }
        *(_BYTE *)(dword_D41A0 + 8628) = 0;
      }
      else
      {
        *(_DWORD *)(dword_D41A4 + 230) = dword_17FEAC - 3398576;
        sub_9A230(822);
      }
    }
    else
    {
      *(_DWORD *)(dword_D41A4 + 230) = 0x400000;
      sub_9A230(822);
    }
    v2 = sub_83CD0(*(_DWORD *)(dword_D41A4 + 230));
    *(_DWORD *)(dword_D41A4 + 226) = v2;
    if ( !v2 )
    {
      printf(aError1NotEnoug);
      exit(1);
    }
    sub_54630(byte_D41B5);
    return sub_5B7A0();
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B5: using guessed type char byte_D41B5;
// DB74C: using guessed type char byte_DB74C;
// 17FEAC: using guessed type int dword_17FEAC;

//----- (00083CC0) --------------------------------------------------------
char __cdecl sub_83CC0(char a1)
{
  char result; // al

  result = a1;
  byte_E29E8 = a1;
  return result;
}
// E29E8: using guessed type char byte_E29E8;

//----- (00083CD0) --------------------------------------------------------
int __cdecl sub_83CD0(int a1)
{
  int *v1; // eax
  unsigned int v2; // ecx
  int *v3; // ebx
  unsigned int v4; // esi
  unsigned int v5; // edx

  sub_85070();
  v1 = &dword_17ECA0;
  v2 = -1;
  v4 = a1 + 259;
  v3 = 0;
  LOWORD(v4) = (a1 + 259) & 0xFFFC;
  while ( v1 )
  {
    v5 = v1[1];
    if ( v4 <= v5 && v2 > v5 && !*((_BYTE *)v1 + 16) && !dword_17E0A4[3 * *((unsigned __int8 *)v1 + 17)] )
    {
      v3 = v1;
      v2 = v1[1];
    }
    v1 = (int *)v1[2];
  }
  if ( !v3 || !sub_83E00((int)v3, v4) )
    return sub_83D70(v4);
  sub_85350();
  memset(*v3, 0, v4);
  return *v3;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 17E0A4: using guessed type int dword_17E0A4[];
// 17ECA0: using guessed type int dword_17ECA0;

//----- (00083D70) --------------------------------------------------------
int __cdecl sub_83D70(int a1)
{
  int *v1; // eax
  unsigned int v2; // edi
  int *v3; // ebx
  unsigned int v4; // esi
  unsigned int v5; // edx

  sub_85070();
  v1 = &dword_17ECA0;
  v2 = -1;
  v4 = a1 + 271;
  v3 = 0;
  LOWORD(v4) = (a1 + 271) & 0xFFF0;
  while ( v1 )
  {
    v5 = v1[1];
    if ( v4 <= v5 && v2 > v5 && !*((_BYTE *)v1 + 16) && dword_17E0A4[3 * *((unsigned __int8 *)v1 + 17)] )
    {
      v3 = v1;
      v2 = v1[1];
    }
    v1 = (int *)v1[2];
  }
  if ( !v3 || !sub_83E00((int)v3, v4) )
    return 0;
  sub_85350();
  memset(*v3, 0, v4);
  return *v3;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 17E0A4: using guessed type int dword_17E0A4[];
// 17ECA0: using guessed type int dword_17ECA0;

//----- (00083E00) --------------------------------------------------------
char __cdecl sub_83E00(int a1, int a2)
{
  int *i; // eax
  char v4; // bl
  int v5; // edi

  if ( a2 == *(_DWORD *)(a1 + 4) )
  {
    *(_BYTE *)(a1 + 16) = byte_E29E8;
  }
  else
  {
    for ( i = &dword_17ECA0; i < &dword_17FEA0 && i[1]; i = (int *)((char *)i + 18) )
      ;
    if ( i == &dword_17FEA0 )
      return 0;
    i[1] = *(_DWORD *)(a1 + 4) - a2;
    *i = a2 + *(_DWORD *)a1;
    v4 = byte_E29E8;
    *(_DWORD *)(a1 + 4) = a2;
    *(_BYTE *)(a1 + 16) = v4;
    *((_BYTE *)i + 17) = *(_BYTE *)(a1 + 17);
    i[2] = *(_DWORD *)(a1 + 8);
    i[3] = a1;
    v5 = *(_DWORD *)(a1 + 8);
    if ( v5 )
      *(_DWORD *)(v5 + 12) = i;
    *(_DWORD *)(a1 + 8) = i;
  }
  return 1;
}
// E29E8: using guessed type char byte_E29E8;
// 17ECA0: using guessed type int dword_17ECA0;
// 17FEA0: using guessed type int dword_17FEA0;

//----- (00083E80) --------------------------------------------------------
void __cdecl sub_83E80(int a1)
{
  int *v1; // eax
  char v2; // bl
  int *i; // ebx

  if ( a1 )
  {
    v1 = &dword_17ECA0;
    v2 = 0;
    while ( v1 )
    {
      if ( a1 == *v1 )
      {
        v2 = 1;
        *((_BYTE *)v1 + 16) = 0;
        break;
      }
      v1 = (int *)v1[2];
    }
    if ( v2 == 1 )
    {
      for ( i = &dword_17ECA0; i; i = (int *)i[2] )
      {
        if ( !*((_BYTE *)i + 16) )
          sub_84000((int)i);
      }
    }
    sub_85350();
  }
}
// 17ECA0: using guessed type int dword_17ECA0;

//----- (00084000) --------------------------------------------------------
int __cdecl sub_84000(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // ebx

  result = a1;
  if ( *(_DWORD *)(a1 + 12) )
  {
    *(_BYTE *)(a1 + 16) = 0;
    v2 = *(_DWORD *)(a1 + 12);
    if ( *(_BYTE *)(a1 + 17) == *(_BYTE *)(v2 + 17) && !*(_BYTE *)(v2 + 16) )
    {
      v3 = *(_DWORD *)(a1 + 8);
      if ( v3 )
        *(_DWORD *)(v3 + 12) = v2;
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 8) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) += *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a1 + 4) = 0;
    }
  }
  return result;
}

//----- (00084050) --------------------------------------------------------
int __usercall sub_84050@<eax>(__int16 a1@<fpstat>)
{
  char v1; // sf
  int result; // eax
  char v3; // [esp+0h] [ebp-8h]
  char v4; // [esp+1h] [ebp-7h]
  char v5; // [esp+2h] [ebp-6h]
  char v6; // [esp+3h] [ebp-5h]
  char v7; // [esp+4h] [ebp-4h]

  sub_840B8(0, 0, v1, 0, a1);
  v3 = byte_E29EC;
  v5 = byte_E29ED;
  v6 = byte_E29EE;
  v7 = byte_E29EF;
  v4 = byte_E29F0;
  result = dword_D41A4;
  *(_BYTE *)(dword_D41A4 + 34) = byte_E29EC == 5;
  return result;
}
// 84056: variable 'v1' is possibly undefined
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A4: using guessed type int dword_D41A4;
// E29EC: using guessed type char byte_E29EC;
// E29ED: using guessed type char byte_E29ED;
// E29EE: using guessed type char byte_E29EE;
// E29EF: using guessed type char byte_E29EF;
// E29F0: using guessed type char byte_E29F0;

//----- (000840B8) --------------------------------------------------------
void __usercall sub_840B8(char a1@<cf>, _BOOL1 a2@<zf>, char a3@<sf>, char a4@<of>, __int16 a5@<fpstat>)
{
  unsigned int v5; // kr00_4

  v5 = __readeflags();
  sub_840D3(a1, a2, a3, a4);
  sub_841CE(a5);
  __writeeflags(v5);
}

//----- (000840D3) --------------------------------------------------------
int __usercall sub_840D3@<eax>(char _CF@<cf>, _BOOL1 _ZF@<zf>, char _SF@<sf>, char _OF@<of>)
{
  unsigned int v4; // kr00_4
  unsigned int v5; // kr04_4
  int result; // eax
  unsigned int v7; // kr08_4
  unsigned int v8; // kr0C_4
  int *v14; // esi
  _BYTE *v15; // edi
  int v16; // ecx

  __asm { pushfw }
  v4 = __readeflags();
  __writeeflags((unsigned int)&loc_40000 ^ v4);
  v5 = __readeflags();
  result = v4 ^ v5;
  byte_E29EC = 3;
  if ( v4 != v5 )
  {
    byte_E29EC = 4;
    v7 = __readeflags();
    __writeeflags(v7 ^ 0x200000);
    v8 = __readeflags();
    result = v7 ^ v8;
    if ( v7 != v8 )
    {
      byte_E2A06 = 1;
      _EAX = 0;
      __asm { cpuid }
      dword_E29FA = _EBX;
      dword_E29FE = _EDX;
      dword_E2A02 = _ECX;
      v14 = &dword_E29FA;
      v15 = &unk_E2A08;
      v16 = 1;
      do
      {
        if ( !v16 )
          break;
        _ZF = *(_BYTE *)v14 == *v15;
        v14 = (int *)((char *)v14 + 1);
        ++v15;
        --v16;
      }
      while ( _ZF );
      if ( !v16 )
        byte_E29ED = 1;
      _EAX = 1;
      __asm { cpuid }
      dword_E29F6 = _EAX;
      byte_E29EC = (unsigned __int16)(_EAX & 0xF00) >> 8;
      byte_E29EF = _EAX & 0xF;
      result = dword_E29F6;
      byte_E29EE = (unsigned __int8)(dword_E29F6 & 0xF0) >> 4;
    }
  }
  return result;
}
// E29EC: using guessed type char byte_E29EC;
// E29ED: using guessed type char byte_E29ED;
// E29EE: using guessed type char byte_E29EE;
// E29EF: using guessed type char byte_E29EF;
// E29F6: using guessed type int dword_E29F6;
// E29FA: using guessed type int dword_E29FA;
// E29FE: using guessed type int dword_E29FE;
// E2A02: using guessed type int dword_E2A02;
// E2A06: using guessed type char byte_E2A06;

//----- (000841CE) --------------------------------------------------------
void __usercall __spoils<st0> sub_841CE(__int16 a1@<fpstat>)
{
  __int16 v1; // fps
  double v2; // st6
  _BOOL1 v3; // c0
  char v4; // c2
  _BOOL1 v5; // c3

  __asm { fninit }
  word_E29F4 = a1;
  if ( (_BYTE)a1 )
  {
    byte_E29F0 = 0;
  }
  else if ( (word_E29F4 & 0x103F) == 63 )
  {
    byte_E29F0 = 1;
    if ( byte_E29EC == 3 )
    {
      v2 = -(1.0 / 0.0);
      v3 = v2 < 1.0 / 0.0;
      v4 = 0;
      v5 = v2 == 1.0 / 0.0;
      word_E29F4 = v1;
      byte_E29F1 = 2;
      if ( v2 != 1.0 / 0.0 )
        byte_E29F1 = 3;
    }
  }
  else
  {
    byte_E29F0 = 0;
  }
}
// E29EC: using guessed type char byte_E29EC;
// E29F0: using guessed type char byte_E29F0;
// E29F1: using guessed type char byte_E29F1;
// E29F4: using guessed type __int16 word_E29F4;

//----- (00084250) --------------------------------------------------------
__int16 __cdecl sub_84250(int a1)
{
  int v1; // ebx
  __int16 v2; // si
  int v3; // ebx
  __int16 v4; // ax
  char v6[100]; // [esp+0h] [ebp-64h] BYREF

  sub_85070();
  v1 = a1;
  v2 = 0;
  if ( *(_DWORD *)(a1 + 28) )
  {
    do
    {
      sub_9A2F5(v1);
      v1 += 44;
    }
    while ( *(_DWORD *)(v1 + 28) );
    v3 = a1;
  }
  else
  {
    v3 = a1;
  }
  while ( *(_DWORD *)(v3 + 28) )
  {
    v4 = sub_9A32D(v3);
    if ( v4 >= 0 )
    {
      if ( v4 )
        goto LABEL_10;
      sub_41A90((unsigned __int8 *)dword_EA3D8);
      printf(aErrorFileS);
    }
    else
    {
      sub_41A90((unsigned __int8 *)dword_EA3D8);
      printf(aErrorAllocatio);
    }
    printf(aPressReturnToC_0);
    ++v2;
    gets(v6);
LABEL_10:
    v3 += 44;
  }
  return v2;
}
// 9A464: using guessed type _DWORD __cdecl gets(_DWORD);
// EA3D8: using guessed type int dword_EA3D8;
// 84250: using guessed type char var_64[100];

//----- (00084300) --------------------------------------------------------
int __cdecl sub_84300(unsigned __int8 a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // edi
  int v4; // eax
  __int16 v6[6]; // [esp+0h] [ebp-14h] BYREF
  int v7; // [esp+Ch] [ebp-8h] BYREF
  int v8; // [esp+10h] [ebp-4h]

  if ( byte_E3798 && byte_E37AD != a1 )
  {
    if ( HIBYTE(word_E2A14) )
      sub_8D8F0();
    v1 = sub_98817((int)aSoundSoundDat, 512);
    v2 = v1;
    v3 = v1;
    if ( v1 != -1 )
    {
      sub_9891E(v1, 0, 2);
      v4 = tell(v2);
      sub_9891E(v2, v4 - 4, 0);
      sub_988A7(v2, (int)&v7, 4);
      sub_9891E(v2, v7, 0);
      sub_988A7(v2, (int)v6, 12);
      if ( (unsigned __int16)word_E37B6 < 0x336u )
      {
        if ( (unsigned __int16)word_E37B6 >= 0x320u )
        {
          if ( (unsigned __int16)word_E37B6 <= 0x320u )
          {
            v8 = 5;
          }
          else if ( word_E37B6 == 811 )
          {
            v8 = 4;
          }
        }
      }
      else if ( (unsigned __int16)word_E37B6 <= 0x336u )
      {
        v8 = 3;
      }
      else if ( (unsigned __int16)word_E37B6 < 0x656u )
      {
        if ( word_E37B6 == 1611 )
          v8 = 2;
      }
      else if ( (unsigned __int16)word_E37B6 <= 0x656u )
      {
        v8 = 1;
      }
      else if ( word_E37B6 == 1644 )
      {
        v8 = 0;
      }
      if ( (unsigned __int16)(a1 + 1) > (unsigned __int16)v6[v8] || (sub_9891E(v3, 96 * a1, 1), !sub_844F0(v3, v8)) )
      {
        sub_98882(v3);
        return 1;
      }
      byte_E37AD = a1;
      sub_98882(v3);
    }
  }
  return 0;
}
// 9A510: using guessed type _DWORD __cdecl tell(_DWORD);
// E2A14: using guessed type __int16 word_E2A14;
// E3798: using guessed type char byte_E3798;
// E37AD: using guessed type char byte_E37AD;
// E37B6: using guessed type __int16 word_E37B6;
// 84300: using guessed type __int16 var_14[6];

//----- (000844A0) --------------------------------------------------------
void sub_844A0()
{
  __int16 v0; // bx
  unsigned int v1; // eax
  int v2; // esi

  v0 = word_180B50;
  if ( dword_E37A0 && dword_E37A8 )
  {
    v1 = dword_E37A0 + 32;
    v0 = 0;
    while ( v1 < dword_E37A4 )
    {
      v2 = *(_DWORD *)(v1 + 18);
      v1 += 32;
      ++v0;
      *(_DWORD *)(v1 - 14) = dword_E37A8 + v2;
    }
  }
  word_180B50 = v0;
}
// E37A0: using guessed type int dword_E37A0;
// E37A4: using guessed type int dword_E37A4;
// E37A8: using guessed type int dword_E37A8;
// 180B50: using guessed type __int16 word_180B50;

//----- (000844F0) --------------------------------------------------------
char __cdecl sub_844F0(int a1, unsigned __int8 a2)
{
  int v2; // eax
  char result; // al
  int v4; // eax
  char *v5; // ebx
  char *v6; // esi
  _DWORD v7[24]; // [esp+0h] [ebp-60h] BYREF

  tell(a1);
  sub_988A7(a1, (int)v7, 96);
  if ( v7[4 * a2 + 1] == -1 )
    return 0;
  if ( !HIBYTE(word_E2A14) )
  {
    dword_E37A8 = sub_83CD0(v7[4 * a2 + 3] + 256);
    v2 = sub_83CD0(3100);
    dword_E37A0 = v2;
    LOBYTE(word_E2A14) = 1;
    if ( !dword_E37A8 || !v2 )
    {
      sub_83E80(dword_E37A8);
      sub_83E80(dword_E37A0);
      LOBYTE(word_E2A14) = 0;
      result = 0;
      byte_E37AD = -1;
      return result;
    }
    dword_E2A18 = v7[4 * a2 + 3] + 256;
    HIBYTE(word_E2A14) = 1;
    dword_E2A1C = 3100;
  }
  byte_E3798 = 0;
  if ( !dword_E37A8 || !dword_E37A0 )
    return 0;
  memset(dword_E37A8, 0, dword_E2A18);
  memset(dword_E37A0, 0, dword_E2A1C);
  v4 = 4 * a2;
  v5 = (char *)dword_E37A0;
  dword_E37A4 = dword_E37A0 + v7[v4 + 2];
  v6 = (char *)dword_E37A8;
  sub_9891E(a1, v7[v4 + 1], 0);
  sub_988A7(a1, dword_E37A8, 8);
  if ( *v6 == 82 && v6[1] == 78 && v6[2] == 67 )
  {
    sub_988A7(
      a1,
      dword_E37A8 + 8,
      (unsigned __int8)v6[7]
    + (((unsigned __int8)v6[6] + (((unsigned __int8)v6[5] + ((unsigned __int8)v6[4] << 8)) << 8)) << 8)
    - 8);
    sub_9894C((int)v6, v6);
  }
  else
  {
    sub_988A7(a1, dword_E37A8 + 8, v7[4 * a2 + 3] - 8);
  }
  sub_9891E(a1, v7[4 * a2], 0);
  sub_988A7(a1, dword_E37A0, 8);
  if ( *v5 == 82 && v5[1] == 78 && v5[2] == 67 )
  {
    sub_988A7(
      a1,
      dword_E37A0 + 8,
      (unsigned __int8)v5[7]
    + (((unsigned __int8)v5[6] + (((unsigned __int8)v5[5] + ((unsigned __int8)v5[4] << 8)) << 8)) << 8)
    - 8);
    sub_9894C((int)v5, v5);
  }
  else
  {
    sub_988A7(a1, dword_E37A0 + 8, v7[4 * a2 + 2] - 8);
  }
  sub_844A0();
  byte_E3798 = 1;
  return 1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 9A510: using guessed type _DWORD __cdecl tell(_DWORD);
// E2A14: using guessed type __int16 word_E2A14;
// E2A18: using guessed type int dword_E2A18;
// E2A1C: using guessed type int dword_E2A1C;
// E3798: using guessed type char byte_E3798;
// E37A0: using guessed type int dword_E37A0;
// E37A4: using guessed type int dword_E37A4;
// E37A8: using guessed type int dword_E37A8;
// E37AD: using guessed type char byte_E37AD;
// 844F0: using guessed type _DWORD var_60[24];

//----- (00084790) --------------------------------------------------------
int sub_84790()
{
  int result; // eax

  memset(dword_D41A0 + 222796, 0, 1950);
  result = dword_D41A0;
  *(_WORD *)(dword_D41A0 + 224762) = 0;
  *(_DWORD *)(result + 224754) = &loc_3A013;
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;

//----- (000847D0) --------------------------------------------------------
char __cdecl sub_847D0(int a1, char a2, char a3, char a4)
{
  __int16 v4; // dx
  unsigned __int8 v5; // dh
  int v6; // eax

  LOBYTE(v4) = 0;
  if ( *(_BYTE *)(dword_D41A0 + 8598) )
  {
    v5 = *(_BYTE *)(dword_D41A0 + 196308);
    if ( v5 )
    {
      if ( v5 <= 2u && *(__int16 *)(dword_D41A0 + 224762) < 50 )
      {
        v6 = dword_D41A0 + 222796;
        HIBYTE(v4) = 0;
        while ( v4 < 50 && *(_BYTE *)v6 )
        {
          ++v4;
          v6 += 39;
        }
        *(_BYTE *)v6 = 1;
        *(_BYTE *)(v6 + 1) = a4;
        *(_BYTE *)(v6 + 2) = a2;
        *(_BYTE *)(v6 + 3) = a3;
        *(_DWORD *)(v6 + 4) = *(_DWORD *)(a1 + 76);
        *(_WORD *)(v6 + 8) = *(_WORD *)(a1 + 80);
        *(_DWORD *)(v6 + 10) = a1;
        *(_BYTE *)(a1 + 14) |= 8u;
        memset(v6 + 14, 0, 25);
        LOBYTE(v4) = 1;
        ++*(_WORD *)(dword_D41A0 + 224762);
      }
    }
  }
  return v4;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;

//----- (00084880) --------------------------------------------------------
int __cdecl sub_84880(_BYTE *a1)
{
  int result; // eax

  *a1 = 0;
  result = dword_D41A0;
  --*(_WORD *)(dword_D41A0 + 224762);
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (000848A0) --------------------------------------------------------
char sub_848A0()
{
  unsigned __int16 v0; // ax
  int v1; // edx
  __int16 v2; // bx
  __int16 v3; // si
  int v4; // eax
  unsigned __int16 v5; // di
  unsigned __int16 v6; // di
  unsigned __int16 v7; // di
  unsigned __int16 v8; // di
  unsigned __int16 v9; // di
  unsigned __int16 v10; // di
  unsigned __int16 v11; // di
  unsigned __int16 v12; // di
  unsigned __int16 v13; // di
  unsigned __int16 v14; // di
  unsigned __int16 v15; // di
  unsigned __int16 v16; // di
  unsigned __int16 v17; // di
  unsigned __int16 v18; // di
  unsigned __int16 v19; // di
  unsigned __int16 v20; // di
  unsigned __int16 v21; // di
  unsigned __int16 v22; // di
  unsigned __int16 v23; // di
  unsigned __int16 v24; // di
  unsigned __int16 v25; // di
  unsigned __int16 v26; // di
  unsigned __int16 v27; // di
  char v28; // ch
  unsigned __int16 v29; // di
  __int16 v31; // [esp+4h] [ebp-4h]

  LOBYTE(v0) = *(_BYTE *)(dword_D41A0 + 196308);
  if ( (_BYTE)v0 )
  {
    if ( (unsigned __int8)v0 <= 2u )
    {
      v0 = *(_WORD *)(dword_D41A0 + 224762);
      v31 = v0;
      if ( v0 )
      {
        v1 = dword_D41A0 + 222796;
        v2 = 0;
        v3 = 0;
        while ( v2 < 50 && v3 < v31 )
        {
          if ( *(_BYTE *)v1 )
          {
            v4 = *(__int16 *)(v1 + 4) >> 8;
            BYTE1(v4) = HIBYTE(*(_WORD *)(v1 + 6)) - 2;
            LOBYTE(v4) = v4 - 2;
            v5 = v4;
            LOBYTE(v4) = v4 + 1;
            byte_12B4E0[v5] -= *(_BYTE *)(v1 + 14);
            v6 = v4;
            LOBYTE(v4) = v4 + 1;
            byte_12B4E0[v6] -= *(_BYTE *)(v1 + 15);
            v7 = v4;
            LOBYTE(v4) = v4 + 1;
            byte_12B4E0[v7] -= *(_BYTE *)(v1 + 16);
            v8 = v4;
            LOBYTE(v4) = v4 + 1;
            byte_12B4E0[v8] -= *(_BYTE *)(v1 + 17);
            v9 = v4;
            ++BYTE1(v4);
            byte_12B4E0[v9] -= *(_BYTE *)(v1 + 18);
            v10 = v4;
            LOBYTE(v4) = v4 - 1;
            byte_12B4E0[v10] -= *(_BYTE *)(v1 + 19);
            v11 = v4;
            LOBYTE(v4) = v4 - 1;
            byte_12B4E0[v11] -= *(_BYTE *)(v1 + 20);
            v12 = v4;
            LOBYTE(v4) = v4 - 1;
            byte_12B4E0[v12] -= *(_BYTE *)(v1 + 21);
            v13 = v4;
            LOBYTE(v4) = v4 - 1;
            byte_12B4E0[v13] -= *(_BYTE *)(v1 + 22);
            v14 = v4;
            ++BYTE1(v4);
            byte_12B4E0[v14] -= *(_BYTE *)(v1 + 23);
            v15 = v4;
            LOBYTE(v4) = v4 + 1;
            byte_12B4E0[v15] -= *(_BYTE *)(v1 + 24);
            v16 = v4;
            LOBYTE(v4) = v4 + 1;
            byte_12B4E0[v16] -= *(_BYTE *)(v1 + 25);
            v17 = v4;
            LOBYTE(v4) = v4 + 1;
            byte_12B4E0[v17] -= *(_BYTE *)(v1 + 26);
            v18 = v4;
            LOBYTE(v4) = v4 + 1;
            byte_12B4E0[v18] -= *(_BYTE *)(v1 + 27);
            v19 = v4;
            ++BYTE1(v4);
            byte_12B4E0[v19] -= *(_BYTE *)(v1 + 28);
            v20 = v4;
            LOBYTE(v4) = v4 - 1;
            byte_12B4E0[v20] -= *(_BYTE *)(v1 + 29);
            ++v3;
            byte_12B4E0[(unsigned __int16)v4] -= *(_BYTE *)(v1 + 30);
            LOBYTE(v4) = v4 - 1;
            v21 = v4;
            LOBYTE(v4) = v4 - 1;
            byte_12B4E0[v21] -= *(_BYTE *)(v1 + 31);
            v22 = v4;
            LOBYTE(v4) = v4 - 1;
            byte_12B4E0[v22] -= *(_BYTE *)(v1 + 32);
            v23 = v4;
            HIBYTE(v0) = BYTE1(v4) + 1;
            byte_12B4E0[v23] -= *(_BYTE *)(v1 + 33);
            v24 = v0;
            LOBYTE(v0) = v4 + 1;
            byte_12B4E0[v24] -= *(_BYTE *)(v1 + 34);
            v25 = v0;
            LOBYTE(v0) = v0 + 1;
            byte_12B4E0[v25] -= *(_BYTE *)(v1 + 35);
            v26 = v0;
            LOBYTE(v0) = v0 + 1;
            byte_12B4E0[v26] -= *(_BYTE *)(v1 + 36);
            v27 = v0;
            v28 = byte_12B4E0[v0] - *(_BYTE *)(v1 + 37);
            LOBYTE(v0) = v0 + 1;
            byte_12B4E0[v27] = v28;
            v29 = v0;
            LOBYTE(v0) = *(_BYTE *)(v1 + 38);
            byte_12B4E0[v29] -= v0;
          }
          ++v2;
          v1 += 39;
        }
      }
    }
  }
  return v0;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00084B80) --------------------------------------------------------
int sub_84B80()
{
  int result; // eax
  unsigned __int8 v1; // dl
  int v2; // esi
  int v3; // esi
  unsigned __int16 v4; // bx
  int v5; // eax
  int i; // [esp+0h] [ebp-10h]
  int v7; // [esp+4h] [ebp-Ch]
  __int16 v8; // [esp+8h] [ebp-8h]
  __int16 v9; // [esp+Ch] [ebp-4h]

  result = dword_D41A0;
  v1 = *(_BYTE *)(dword_D41A0 + 196308);
  if ( v1 )
  {
    if ( v1 <= 2u )
    {
      v9 = *(_WORD *)(dword_D41A0 + 224762);
      if ( v9 )
      {
        result = dword_D41A0 + 222796;
        v8 = 0;
        v7 = 0;
        for ( i = dword_D41A0 + 222796; v8 < 50; i += 39 )
        {
          result = v7;
          if ( (__int16)v7 >= v9 )
            break;
          result = i;
          if ( *(_BYTE *)i )
          {
            v2 = *(_DWORD *)(i + 10);
            ++v7;
            if ( *(int *)(v2 + 8) < 0 || (*(_BYTE *)(v2 + 13) & 4) != 0 )
            {
              result = sub_84880((_BYTE *)i);
            }
            else
            {
              v3 = v2 + 76;
              *(_DWORD *)(i + 4) = *(_DWORD *)v3;
              *(_WORD *)(i + 8) = *(_WORD *)(v3 + 4);
              LOBYTE(v4) = HIBYTE(*(_WORD *)(i + 4));
              HIBYTE(v4) = HIBYTE(*(_WORD *)(i + 6));
              v5 = dword_D41A0;
              *(_DWORD *)(dword_D41A0 + 224754) = 9377 * *(_DWORD *)(dword_D41A0 + 224754) + 9439;
              LOWORD(v3) = *(_DWORD *)(v5 + 224754) % (unsigned int)*(unsigned __int8 *)(i + 3)
                         - ((int)*(unsigned __int8 *)(i + 3) >> 1);
              HIBYTE(v4) -= 2;
              LOBYTE(v4) = v4 - 2;
              sub_84EA0(v4, i, 0, v3);
              LOBYTE(v4) = v4 + 1;
              sub_84EA0(v4, i, 1, v3);
              LOBYTE(v4) = v4 + 1;
              sub_84EA0(v4, i, 2, v3);
              LOBYTE(v4) = v4 + 1;
              sub_84EA0(v4, i, 3, v3);
              LOBYTE(v4) = v4 + 1;
              sub_84EA0(v4, i, 4, v3);
              ++HIBYTE(v4);
              sub_84EA0(v4, i, 5, v3);
              LOBYTE(v4) = v4 - 1;
              sub_84EA0(v4, i, 6, v3);
              LOBYTE(v4) = v4 - 1;
              sub_84EA0(v4, i, 7, v3);
              LOBYTE(v4) = v4 - 1;
              sub_84EA0(v4, i, 8, v3);
              LOBYTE(v4) = v4 - 1;
              sub_84EA0(v4, i, 9, v3);
              ++HIBYTE(v4);
              sub_84EA0(v4, i, 10, v3);
              LOBYTE(v4) = v4 + 1;
              sub_84EA0(v4, i, 11, v3);
              LOBYTE(v4) = v4 + 1;
              sub_84EA0(v4, i, 12, v3);
              LOBYTE(v4) = v4 + 1;
              sub_84EA0(v4, i, 13, v3);
              LOBYTE(v4) = v4 + 1;
              sub_84EA0(v4, i, 14, v3);
              ++HIBYTE(v4);
              sub_84EA0(v4, i, 15, v3);
              LOBYTE(v4) = v4 - 1;
              sub_84EA0(v4, i, 16, v3);
              LOBYTE(v4) = v4 - 1;
              sub_84EA0(v4, i, 17, v3);
              LOBYTE(v4) = v4 - 1;
              sub_84EA0(v4, i, 18, v3);
              LOBYTE(v4) = v4 - 1;
              sub_84EA0(v4, i, 19, v3);
              ++HIBYTE(v4);
              sub_84EA0(v4, i, 20, v3);
              LOBYTE(v4) = v4 + 1;
              sub_84EA0(v4, i, 21, v3);
              LOBYTE(v4) = v4 + 1;
              sub_84EA0(v4, i, 22, v3);
              LOBYTE(v4) = v4 + 1;
              sub_84EA0(v4, i, 23, v3);
              LOBYTE(v4) = v4 + 1;
              result = sub_84EA0(v4, i, 24, v3);
            }
          }
          ++v8;
        }
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;

//----- (00084EA0) --------------------------------------------------------
int __cdecl sub_84EA0(unsigned __int16 a1, int a2, char a3, __int16 a4)
{
  int v4; // esi
  unsigned int v5; // edi
  int v6; // ebx
  int v7; // ecx
  int v8; // edx
  int v9; // ebx
  int v10; // eax
  int result; // eax
  __int16 v12[4]; // [esp+0h] [ebp-8h] BYREF

  v4 = 31;
  v5 = (unsigned __int8)byte_12B4E0[a1];
  LOBYTE(v6) = 0;
  if ( v5 < 0x3F )
  {
    v12[0] = ((unsigned __int8)a1 << 8) + 128;
    v12[1] = (HIBYTE(a1) << 8) + 128;
    v12[2] = sub_10C40(v12);
    v7 = sub_84FB0((__int16 *)(a2 + 4), v12);
    if ( v7 < 294912 )
    {
      if ( (*(_BYTE *)(a2 + 1) & 1) != 0 )
      {
        v8 = *(_DWORD *)(a2 + 10);
        v9 = *(_DWORD *)(v8 + 8);
        if ( v9 <= 0 )
        {
          v4 = 0;
        }
        else if ( v9 < 31 )
        {
          v4 = *(_DWORD *)(v8 + 8);
        }
      }
      v10 = 31 * (294912 - v7) / 294912 * *(unsigned __int8 *)(a2 + 2);
      v6 = a4 + ((v10 - (__CFSHL__(v10 >> 31, 7) + (v10 >> 31 << 7))) >> 7);
      if ( v6 > v4 )
        v6 = v4;
      if ( (int)(v5 + v6) > 63 )
        v6 = 63 - v5;
      if ( v6 < 0 )
        LOBYTE(v6) = 0;
      byte_12B4E0[a1] += v6;
    }
  }
  result = a2 + a3;
  *(_BYTE *)(result + 14) = v6;
  return result;
}

//----- (00084FB0) --------------------------------------------------------
int __cdecl sub_84FB0(__int16 *a1, __int16 *a2)
{
  int v2; // edx
  int v3; // eax

  v2 = a1[1] - a2[1];
  v3 = *a1 - *a2;
  return v3 * v3 + v2 * v2 + (a1[2] - a2[2]) * (a1[2] - a2[2]);
}

//----- (00085060) --------------------------------------------------------
int __cdecl sub_85060(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (00085070) --------------------------------------------------------
void sub_85070()
{
  int v0; // ebx
  int i; // ebx
  signed int v2; // ebx
  int v3; // esi
  unsigned int v4; // eax
  int v5; // edi
  int v6; // edx
  int v7; // eax
  int j; // ebx
  int v9; // eax
  int k; // edi
  int m; // ebx
  int v12; // edx
  int v13; // eax
  int v14; // ebx
  int v15; // eax
  int n; // ebx
  int v17; // edx
  int v18; // eax
  int *v19; // [esp-Ch] [ebp-18h]
  char *v20; // [esp-Ch] [ebp-18h]
  int v21; // [esp+0h] [ebp-Ch]

  if ( !dword_17E0A8[0] )
  {
    v0 = 0;
    v21 = sub_85450((unsigned int)sub_10000);
    do
    {
      v19 = &dword_17E0A0[3 * v0++];
      memset(v19, 0, 12);
    }
    while ( v0 < 256 );
    for ( i = 0; i < 256; ++i )
    {
      v20 = (char *)&dword_17ECA0 + 18 * i;
      memset(v20, 0, 18);
    }
    v2 = (signed int)&loc_A0000;
    v3 = 0;
    while ( v2 >= 1024 )
    {
      v4 = sub_85450(v2);
      if ( v4 )
      {
        v5 = (unsigned __int16)v4;
        v6 = HIWORD(v4);
        v7 = 3 * v3;
        dword_17E0A8[v7] = v2;
        ++v3;
        dword_17E0A4[v7] = v6;
        v2 += 1024;
        dword_17E0A0[v7] = 16 * v5;
      }
      v2 -= 1024;
    }
    for ( j = 0x1000000; j >= 4096; j -= 4096 )
    {
      v9 = malloc(j);
      dword_17E0A0[3 * v3] = v9;
      if ( v9 )
      {
        for ( k = 4096; k > 0; k -= 16 )
        {
          if ( expand(dword_17E0A0[3 * v3], j + k) )
          {
            dword_17E0A8[3 * v3] = j + k;
            dword_17E0A4[3 * v3] = 0;
            break;
          }
        }
        j += 4096;
        ++v3;
      }
    }
    for ( m = 4096; m >= 16; m -= 16 )
    {
      v12 = malloc(m);
      v13 = 3 * v3;
      dword_17E0A0[3 * v3] = v12;
      if ( v12 )
      {
        ++v3;
        dword_17E0A8[v13] = m;
        m += 4096;
        dword_17E0A4[v13] = 0;
      }
    }
    v14 = 0;
    qsort(dword_17E0A0, v3, 12, sub_85060);
    do
    {
      v15 = 9 * v14++;
      *(int *)((char *)&dword_17ECA4 + 2 * v15) = 0;
    }
    while ( v14 < 256 );
    for ( n = 0; n < v3; ++n )
    {
      v17 = 18 * n;
      *(int *)((char *)&dword_17ECA0 + v17) = dword_17E0A0[3 * n];
      *(int *)((char *)&dword_17ECA4 + v17) = dword_17E0A8[3 * n];
      if ( n )
        *(int *)((char *)&dword_17ECAC + 18 * n) = (int)&dword_17ECA0 + 18 * n - 18;
      else
        dword_17ECAC = 0;
      v18 = 9 * n;
      *(int *)((char *)&dword_17ECA8 + 2 * v18) = (int)&dword_17ECA0 + 18 * n + 18;
      byte_17ECB0[2 * v18] = 0;
      byte_17ECB1[2 * v18] = n;
    }
    *(int *)((char *)&dword_17ECA8 + 18 * v3 - 18) = 0;
    sub_9AD16(HIWORD(v21));
  }
}
// 10000: using guessed type void __noreturn sub_10000();
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 9A522: using guessed type _DWORD __cdecl malloc(_DWORD);
// 9A61E: using guessed type _DWORD __cdecl expand(_DWORD, _DWORD);
// 9A8EE: using guessed type _DWORD __cdecl qsort(_DWORD, _DWORD, _DWORD, _DWORD);
// 17E0A0: using guessed type int dword_17E0A0[];
// 17E0A4: using guessed type int dword_17E0A4[];
// 17E0A8: using guessed type int dword_17E0A8[766];
// 17ECA0: using guessed type int dword_17ECA0;
// 17ECA4: using guessed type int dword_17ECA4;
// 17ECA8: using guessed type int dword_17ECA8;
// 17ECAC: using guessed type int dword_17ECAC;

//----- (00085350) --------------------------------------------------------
int *sub_85350()
{
  int *result; // eax
  unsigned int v1; // edx
  int v2; // edx

  result = &dword_17ECA0;
  dword_17FEA0 = 0;
  dword_17FEA4 = 0;
  dword_17FEA8 = 0;
  dword_17FEAC = 0;
  dword_17FEB0 = -1;
  while ( result )
  {
    if ( *((_BYTE *)result + 16) )
    {
      v2 = result[1];
      dword_17FEA8 += v2;
      dword_17FEA0 += v2;
    }
    else
    {
      v1 = result[1];
      dword_17FEA4 += v1;
      if ( v1 > dword_17FEAC )
        dword_17FEAC = v1;
      if ( result[1] < (unsigned int)dword_17FEB0 )
        dword_17FEB0 = result[1];
      dword_17FEA0 += result[1];
    }
    result = (int *)result[2];
  }
  LOBYTE(dword_17FEA0) = dword_17FEA0 & 0xFC;
  LOBYTE(dword_17FEA4) = dword_17FEA4 & 0xFC;
  LOBYTE(dword_17FEAC) = dword_17FEAC & 0xFC;
  LOBYTE(dword_17FEA8) = dword_17FEA8 & 0xFC;
  LOBYTE(dword_17FEB0) = dword_17FEB0 & 0xFC;
  return result;
}
// 17ECA0: using guessed type int dword_17ECA0;
// 17FEA0: using guessed type int dword_17FEA0;
// 17FEA4: using guessed type int dword_17FEA4;
// 17FEA8: using guessed type int dword_17FEA8;
// 17FEAC: using guessed type int dword_17FEAC;
// 17FEB0: using guessed type int dword_17FEB0;

//----- (00085450) --------------------------------------------------------
int __cdecl sub_85450(unsigned int a1)
{
  int v1; // ebx
  int v3[7]; // [esp+0h] [ebp-38h] BYREF
  int v4[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  v1 = 0;
  if ( a1 < (unsigned int)&loc_A0000 )
  {
    v3[1] = (a1 + 15) >> 4;
    v3[0] = 256;
    int386(49, v3, v4);
    if ( !v4[6] )
      return v4[0] | (v4[3] << 16);
  }
  return v1;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (000856D0) --------------------------------------------------------
__int16 __cdecl sub_856D0(int a1, int a2, __int16 a3, int a4)
{
  unsigned __int8 v4; // dl
  unsigned __int8 v5; // dh
  __int16 v6; // di
  __int16 v7; // si
  int v8; // eax
  int v9; // ecx
  unsigned __int8 v10; // cl
  _BYTE *v11; // edx
  __int16 v12; // si
  int v14; // edi
  _BYTE *v15; // esi
  _BYTE *v16; // eax
  char v17; // ch
  int v18; // edx
  _BOOL1 v19; // zf
  char v21; // cl
  unsigned __int8 v22; // cl
  int v23; // edi
  char *v24; // eax
  char *v25; // eax
  char v26; // ch
  unsigned __int8 v27; // ch
  _BYTE *v29; // [esp+0h] [ebp-38h]
  int v30; // [esp+8h] [ebp-30h]
  _BYTE *v31; // [esp+Ch] [ebp-2Ch]
  _BYTE *v32; // [esp+10h] [ebp-28h]
  char *v33; // [esp+14h] [ebp-24h]
  int v34; // [esp+1Ch] [ebp-1Ch]
  __int16 v35; // [esp+24h] [ebp-14h]
  unsigned __int8 v36; // [esp+28h] [ebp-10h]
  unsigned __int8 v37; // [esp+2Ch] [ebp-Ch]
  unsigned __int8 v38; // [esp+30h] [ebp-8h]

  v4 = *(_BYTE *)(a4 + 4);
  v5 = *(_BYTE *)(a4 + 5);
  v6 = dword_17FEC0 + a2;
  v7 = dword_17FEC8 + a3;
  v8 = -a2;
  if ( (-(__int16)a2 & 0x8000u) != 0 || (_WORD)a2 == 0 )
  {
    v36 = 0;
  }
  else
  {
    if ( (__int16)v8 >= v4 )
      return v8;
    v36 = -(char)a2;
  }
  v9 = v4;
  LOWORD(v8) = v4 + v6 - dword_17FEC4;
  if ( (__int16)v8 > 0 )
  {
    if ( (__int16)v8 >= v4 )
      return v8;
    v4 = dword_17FEC4 - v6;
  }
  LOWORD(v8) = -a3;
  if ( a3 >= 0 )
  {
    v10 = 0;
  }
  else
  {
    v9 = v5;
    if ( (__int16)v8 >= v5 )
      return v8;
    v10 = -(char)a3;
  }
  LOWORD(v8) = v7 + v5 - dword_17FECC;
  if ( (__int16)v8 > 0 )
  {
    if ( (__int16)v8 >= v5 )
      return v8;
    v5 = dword_17FECC - v7;
  }
  v37 = v4 - v36;
  BYTE1(v9) = v5 - v10;
  v8 = *(_DWORD *)a4;
  v35 = dword_18062C;
  v11 = (_BYTE *)(dword_18062C * (v7 + v10) + dword_180628 + v6 + v36);
  if ( v10 )
  {
    v12 = v10;
    do
    {
      while ( *(char *)v8 > 0 )
        v8 += *(char *)v8 + 1;
    }
    while ( *(_BYTE *)v8++ || --v12 );
  }
  v14 = (__int16)dword_18062C;
  v15 = &v11[(__int16)dword_18062C];
  v29 = v15;
  LOWORD(v15) = v37;
  LOWORD(v9) = BYTE1(v9);
  v34 = v9;
  if ( v36 )
  {
LABEL_56:
    if ( !v36 )
      goto LABEL_22;
    v38 = v36;
    while ( 1 )
    {
      while ( 1 )
      {
        v21 = *(_BYTE *)v8;
        if ( *(char *)v8 > 0 )
          break;
        if ( !*(_BYTE *)v8 )
        {
          v15 = 0;
          goto LABEL_22;
        }
        v14 = v21;
        v9 = -v38;
        if ( v14 < v9 )
        {
          LOBYTE(v9) = -*(_BYTE *)v8 - v38;
          if ( (unsigned __int8)v9 > v37 )
            LOBYTE(v9) = v37;
          v14 = (unsigned __int8)v9;
          ++v8;
          v11 += (unsigned __int8)v9;
          BYTE1(v9) = 0;
          v15 -= v9;
          goto LABEL_22;
        }
        v27 = *(_BYTE *)v8++ + v38;
        v38 = v27;
        if ( !v27 )
          goto LABEL_22;
      }
      v14 = v21;
      v9 = v38;
      if ( v38 < v14 )
        break;
      v38 -= *(_BYTE *)v8;
      v9 = v14 + 1;
      v8 += v14 + 1;
      if ( !v38 )
        goto LABEL_22;
    }
    v22 = *(_BYTE *)v8 - v38;
    if ( v22 > v37 )
      v22 = v37;
    v31 = &v11[v22];
    v23 = *(char *)v8;
    v24 = (char *)(v8 + 1);
    v33 = &v24[v23];
    v25 = &v24[v38];
    v15 -= v22;
    v14 = *(_WORD *)(a1 + 4) & 0xC000;
    if ( (unsigned __int16)v14 >= 0x4000u )
    {
      if ( (unsigned __int16)v14 <= 0x4000u )
      {
        do
        {
          ++v25;
          ++v11;
          --v22;
        }
        while ( v22 );
        v8 = (int)v33;
        v11 = v31;
        goto LABEL_22;
      }
      if ( (_WORD)v14 == 0x8000 )
      {
        do
        {
          ++v25;
          ++v11;
          --v22;
        }
        while ( v22 );
      }
LABEL_81:
      v8 = (int)v33;
      v11 = v31;
      goto LABEL_22;
    }
    if ( (_WORD)v14 )
      goto LABEL_81;
    while ( 1 )
    {
      if ( *v25 )
      {
        if ( (unsigned __int8)*v25 > 1u )
        {
          if ( *v25 != 2 || (*(_BYTE *)(a1 + 4) & 2) == 0 )
            goto LABEL_76;
          v26 = *(_BYTE *)(a1 + 7);
          goto LABEL_75;
        }
        if ( (*(_BYTE *)(a1 + 4) & 1) != 0 )
        {
          v26 = *(_BYTE *)(a1 + 6);
LABEL_75:
          *v11 = v26;
        }
      }
LABEL_76:
      ++v25;
      ++v11;
      if ( !--v22 )
        goto LABEL_81;
    }
  }
LABEL_22:
  while ( 2 )
  {
    while ( 2 )
    {
      if ( (__int16)v15 <= 0 )
      {
        HIWORD(v15) = HIWORD(v34);
        LOWORD(v15) = v34 - 1;
        v19 = (_WORD)v34 == 1;
        v34 = (int)v15;
        if ( v19 )
          return v8;
        do
        {
          while ( *(char *)v8 > 0 )
            v8 += *(char *)v8 + 1;
        }
        while ( *(_BYTE *)v8++ );
        v11 = v29;
        v9 = v35;
        v14 = (int)&v29[v35];
        LOWORD(v15) = v37;
        v29 = (_BYTE *)v14;
        goto LABEL_56;
      }
      LOBYTE(v9) = *(_BYTE *)v8;
      if ( *(char *)v8 > 0 )
      {
        if ( (char)v9 >= (__int16)v15 )
          v9 = (__int16)v15;
        else
          v9 = *(char *)v8;
        LOWORD(v14) = *(char *)v8;
        v15 -= v14;
        v32 = &v11[(unsigned __int8)v9];
        v30 = *(char *)v8 + v8 + 1;
        v14 = *(_WORD *)(a1 + 4) & 0xC000;
        v16 = (_BYTE *)(v8 + 1);
        if ( (unsigned __int16)v14 >= 0x4000u )
        {
          if ( (unsigned __int16)v14 <= 0x4000u )
          {
            do
            {
              ++v16;
              ++v11;
              LOBYTE(v9) = v9 - 1;
            }
            while ( (_BYTE)v9 );
            v11 = v32;
            v8 = v30;
            continue;
          }
          if ( (_WORD)v14 == 0x8000 )
          {
            do
            {
              ++v16;
              ++v11;
              LOBYTE(v9) = v9 - 1;
            }
            while ( (_BYTE)v9 );
          }
LABEL_46:
          v11 = v32;
          v8 = v30;
          continue;
        }
        if ( (_WORD)v14 )
          goto LABEL_46;
        while ( 1 )
        {
          if ( *v16 )
          {
            if ( *v16 > 1u )
            {
              if ( *v16 != 2 || (*(_BYTE *)(a1 + 4) & 2) == 0 )
                goto LABEL_41;
              v17 = *(_BYTE *)(a1 + 7);
              goto LABEL_40;
            }
            if ( (*(_BYTE *)(a1 + 4) & 1) != 0 )
            {
              v17 = *(_BYTE *)(a1 + 6);
LABEL_40:
              *v11 = v17;
            }
          }
LABEL_41:
          ++v16;
          ++v11;
          LOBYTE(v9) = v9 - 1;
          if ( !(_BYTE)v9 )
            goto LABEL_46;
        }
      }
      break;
    }
    if ( *(char *)v8 < 0 )
    {
      LOWORD(v9) = (char)v9;
      v15 += v9;
      v9 = *(char *)v8++;
      v11 -= v9;
      continue;
    }
    break;
  }
  HIWORD(v18) = HIWORD(v34);
  LOWORD(v18) = v34 - 1;
  v19 = (_WORD)v34 == 1;
  v34 = v18;
  if ( !v19 )
  {
    v11 = v29;
    v9 = v35;
    v15 = &v29[v35];
    ++v8;
    v29 = v15;
    LOWORD(v15) = v37;
    goto LABEL_56;
  }
  return v8;
}
// 17FEC0: using guessed type int dword_17FEC0;
// 17FEC4: using guessed type int dword_17FEC4;
// 17FEC8: using guessed type int dword_17FEC8;
// 17FECC: using guessed type int dword_17FECC;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;

//----- (00085AF0) --------------------------------------------------------
unsigned int *__cdecl sub_85AF0(int a1)
{
  unsigned int *result; // eax
  unsigned int v2; // ecx

  result = *(unsigned int **)a1;
  if ( *(_DWORD *)a1 < *(_DWORD *)(a1 + 4) )
  {
    do
    {
      v2 = *(_DWORD *)(a1 + 8);
      if ( *result < v2 )
        *result += v2;
      result = (unsigned int *)((char *)result + 6);
    }
    while ( (unsigned int)result < *(_DWORD *)(a1 + 4) );
  }
  return result;
}

//----- (00085B20) --------------------------------------------------------
int __cdecl sub_85B20(_BYTE *a1, _WORD *a2, unsigned __int16 a3)
{
  _BYTE *v3; // esi
  _WORD *v4; // edi
  __int16 v6; // bx
  __int16 v7; // cx
  __int16 v8; // ax
  _BYTE *v9; // esi
  _WORD *v10; // edi
  __int16 v11; // cx
  __int16 v12; // ax
  _BYTE *v13; // esi
  _WORD *v14; // edi
  int v15; // ecx
  _BYTE *v16; // [esp-14h] [ebp-1Ch]
  int v17; // [esp+4h] [ebp-4h]

  v3 = a1;
  v4 = a2;
  if ( (word_180660 & 1) != 0 )
  {
    sub_9A128(a1, a2, 0xC8u);
    return v17;
  }
  else
  {
    v6 = a3 >> 1;
    do
    {
      v16 = v3;
      v7 = 40;
      do
      {
        LOBYTE(v8) = *v3;
        v9 = v3 + 1;
        HIBYTE(v8) = v8;
        *v4 = v8;
        v10 = v4 + 1;
        LOBYTE(v8) = *v9++;
        HIBYTE(v8) = v8;
        *v10++ = v8;
        LOBYTE(v8) = *v9++;
        HIBYTE(v8) = v8;
        *v10++ = v8;
        LOBYTE(v8) = *v9++;
        HIBYTE(v8) = v8;
        *v10++ = v8;
        LOBYTE(v8) = *v9++;
        HIBYTE(v8) = v8;
        *v10++ = v8;
        LOBYTE(v8) = *v9++;
        HIBYTE(v8) = v8;
        *v10++ = v8;
        LOBYTE(v8) = *v9++;
        HIBYTE(v8) = v8;
        *v10++ = v8;
        LOBYTE(v8) = *v9;
        v3 = v9 + 1;
        HIBYTE(v8) = v8;
        *v10 = v8;
        v4 = v10 + 1;
        --v7;
      }
      while ( v7 );
      v3 = v16;
      v11 = 40;
      do
      {
        LOBYTE(v12) = *v3;
        v13 = v3 + 1;
        HIBYTE(v12) = v12;
        *v4 = v12;
        v14 = v4 + 1;
        LOBYTE(v12) = *v13++;
        HIBYTE(v12) = v12;
        *v14++ = v12;
        LOBYTE(v12) = *v13++;
        HIBYTE(v12) = v12;
        *v14++ = v12;
        LOBYTE(v12) = *v13++;
        HIBYTE(v12) = v12;
        *v14++ = v12;
        LOBYTE(v12) = *v13++;
        HIBYTE(v12) = v12;
        *v14++ = v12;
        LOBYTE(v12) = *v13++;
        HIBYTE(v12) = v12;
        *v14++ = v12;
        LOBYTE(v12) = *v13++;
        HIBYTE(v12) = v12;
        *v14++ = v12;
        LOBYTE(v12) = *v13;
        v3 = v13 + 1;
        HIBYTE(v12) = v12;
        *v14 = v12;
        v4 = v14 + 1;
        --v11;
      }
      while ( v11 );
      --v6;
    }
    while ( v6 );
    if ( a2 != (_WORD *)&loc_A0000 && a3 >= 0x190u )
    {
      v15 = 12800;
      do
      {
        *(_DWORD *)v4 = 0;
        v4 += 2;
        --v15;
      }
      while ( v15 );
    }
    return v17;
  }
}
// 85B4E: variable 'v17' is possibly undefined
// 180660: using guessed type __int16 word_180660;

//----- (00085BF5) --------------------------------------------------------
int __cdecl sub_85BF5(_BYTE *a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v7; // edi
  int v9; // ecx
  int v11; // [esp+4h] [ebp-4h]

  v7 = (_BYTE *)(a3 + 640 * a4 + a2);
  do
  {
    v9 = a5;
    do
    {
      if ( !*a1 || *a1 == 0xFF )
      {
        ++a1;
        ++v7;
      }
      else
      {
        *v7++ = *a1++;
      }
      --v9;
    }
    while ( v9 );
    v7 = &v7[-a5 + 640];
    --a6;
  }
  while ( a6 );
  return v11;
}
// 85C3F: variable 'v11' is possibly undefined

//----- (00085C42) --------------------------------------------------------
int __cdecl sub_85C42(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6)
{
  unsigned __int8 *v6; // edi
  int v8; // ecx
  int v10; // [esp+4h] [ebp-4h]

  v6 = (unsigned __int8 *)(a2 + 640 * a3 + a1);
  do
  {
    v8 = a4;
    do
    {
      if ( *v6 >= a6 )
        *v6 = 0;
      ++v6;
      --v8;
    }
    while ( v8 );
    v6 = &v6[-a4 + 640];
    --a5;
  }
  while ( a5 );
  return v10;
}
// 85C88: variable 'v10' is possibly undefined

//----- (00085C8B) --------------------------------------------------------
void __cdecl sub_85C8B(int a1, char *a2, int a3, int a4, int a5, int a6)
{
  char *v8; // esi

  v8 = (char *)(a3 + 1280 * a4 + a1);
  do
  {
    qmemcpy(a2, v8, 4 * a5);
    a2 += 4 * a5;
    v8 += 4 * a5 + 640;
    --a6;
  }
  while ( a6 );
}

//----- (00085CC3) --------------------------------------------------------
void __usercall __spoils<> sub_85CC3(unsigned int a1@<eax>, int a2@<ebx>, unsigned __int16 *a3)
{
  char *v4; // edi
  int v5; // edx
  char *v6; // esi
  char v7; // al
  char *v8; // edx
  unsigned int v9; // ecx
  _BYTE *v10; // edi
  _BYTE *v11; // ebx
  char v12; // al
  __int16 v13; // [esp-22h] [ebp-32h]
  unsigned __int16 *v14; // [esp-20h] [ebp-30h]
  int v15; // [esp-1Eh] [ebp-2Eh]
  __int16 v16; // [esp-1Ah] [ebp-2Ah]
  int v17; // [esp+0h] [ebp-10h]
  int v18; // [esp+4h] [ebp-Ch]
  _BYTE *v19; // [esp+8h] [ebp-8h]
  int v20; // [esp+Ch] [ebp-4h]

  v4 = (char *)dword_180628;
  v19 = (_BYTE *)(dword_180628 + 306560);
  v17 = dword_180628 + 640;
  v18 = dword_180628 + 307200;
  v20 = 0;
  LOWORD(a2) = 240;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v5 = *a3++;
        if ( (__int16)v5 <= 0 )
          break;
        a1 = (unsigned __int16)v5;
        qmemcpy(v4, a3, (unsigned __int16)v5);
        v8 = &v4[(unsigned __int16)v5];
        qmemcpy(v19, a3, a1);
        v19 += a1;
        v16 = a1;
        v15 = a2;
        v9 = a1;
        v10 = (_BYTE *)v17;
        v11 = (_BYTE *)v18;
        do
        {
          v12 = *(_BYTE *)a3;
          *v10 = *(_BYTE *)a3;
          *v11 = v12;
          a3 = (unsigned __int16 *)((char *)a3 + 1);
          --v10;
          --v11;
          --v9;
        }
        while ( v9 );
        v17 = (int)v10;
        v18 = (int)v11;
        v4 = v8;
        a2 = v15;
        LOWORD(a1) = v16;
      }
      if ( (v5 & 0x8000u) == 0 )
        break;
      LOWORD(v5) = -(__int16)v5;
      v4 += (unsigned __int16)v5;
      v20 += a1 + (unsigned __int16)v5;
      v19 += (unsigned __int16)v5;
      v17 -= v5;
      v18 -= v5;
    }
    if ( (__int16)a2 > 221 )
    {
      v14 = a3;
      v13 = a1;
      v6 = (char *)a3 - 3;
      v7 = *v6;
      *v4 = *v6;
      *v19 = v7;
      LOWORD(a1) = v13;
      a3 = v14;
    }
    v4 = &v4[-a1 + 640 - v20];
    v19 = &v19[-a1 - 640 - v20];
    v17 += v20 + a1 + 640;
    v18 = v20 + a1 + v18 - 640;
    v20 = 0;
    LOWORD(a2) = a2 - 1;
  }
  while ( (_WORD)a2 );
}
// 85D15: conditional instruction was optimized away because dx.2==0
// 180628: using guessed type int dword_180628;

//----- (00085E40) --------------------------------------------------------
__int16 sub_85E40()
{
  __int16 result; // ax

  if ( word_E2A24 )
    return 1;
  dword_17FF10 = 4096;
  dword_17FF0C = 256;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  word_E2A24 = dword_17FF0C;
  word_17FF5A = word_17FF18;
  LOBYTE(result) = dword_17FF24 == 0;
  HIBYTE(result) = 0;
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A24: using guessed type __int16 word_E2A24;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF18: using guessed type __int16 word_17FF18;
// 17FF24: using guessed type int dword_17FF24;
// 17FF5A: using guessed type __int16 word_17FF5A;

//----- (00085EB0) --------------------------------------------------------
__int16 __cdecl sub_85EB0(__int16 a1)
{
  LOWORD(dword_17FF10) = a1;
  LOWORD(dword_17FF0C) = 256;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  if ( dword_17FF24 )
    return 0;
  else
    return dword_17FF0C;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF24: using guessed type int dword_17FF24;

//----- (00085F00) --------------------------------------------------------
__int16 __cdecl sub_85F00(__int16 a1)
{
  __int16 result; // ax

  word_17FF18 = a1;
  LOWORD(dword_17FF0C) = 256;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  if ( dword_17FF24 )
    printf(aFdmErrorFreein);
  LOBYTE(result) = dword_17FF24 == 0;
  HIBYTE(result) = 0;
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF18: using guessed type __int16 word_17FF18;
// 17FF24: using guessed type int dword_17FF24;

//----- (00085F60) --------------------------------------------------------
int __cdecl sub_85F60(int a1)
{
  return 75 * BYTE1(a1) + 4500 * BYTE2(a1) + (unsigned __int8)a1;
}

//----- (00085FD0) --------------------------------------------------------
bool sub_85FD0()
{
  __int16 v0; // ax

  dword_E2A6C = sub_85EB0(2);
  v0 = sub_85EB0(256);
  dword_E2A70 = v0;
  return dword_E2A6C && v0;
}
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;

//----- (00086010) --------------------------------------------------------
int sub_86010()
{
  dword_17FF38 = 0;
  dword_17FF44 = 5376;
  dword_17FF0C = 768;
  dword_17FF10 = 47;
  dword_17FF14 = 0;
  dword_17FF20 = (int)&unk_17FF28;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  word_1803EA = dword_17FF38;
  word_1803EC = dword_17FF40;
  return dword_17FF38;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 1803EA: using guessed type __int16 word_1803EA;
// 1803EC: using guessed type __int16 word_1803EC;

//----- (00086180) --------------------------------------------------------
__int16 __cdecl sub_86180(unsigned __int16 a1)
{
  int v1; // ecx
  __int16 result; // ax
  char *v3; // esi
  __int16 v4; // ax

  if ( !dword_E2A6C )
    return 0;
  v1 = dword_E2A70;
  if ( !dword_E2A70 )
    return 0;
  v3 = (char *)(16 * dword_E2A6C);
  *v3 = 26;
  v3[1] = 0;
  v3[2] = 3;
  *(_WORD *)(v3 + 3) = 0;
  v3[13] = 0;
  *((_WORD *)v3 + 9) = 5;
  *((_WORD *)v3 + 10) = 0;
  *(_DWORD *)(v3 + 22) = 0;
  *(_DWORD *)(v3 + 14) = v1 << 16;
  v4 = dword_E2A6C;
  *(_BYTE *)(16 * v1) = 6;
  word_17FF4A = v4;
  dword_17FF38 = 0;
  dword_17FF10 = 47;
  dword_17FF14 = 0;
  dword_17FF40 = a1;
  dword_17FF44 = 5392;
  dword_17FF0C = 768;
  dword_17FF20 = (int)&unk_17FF28;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  qmemcpy(&unk_1803C0, v3, 0x1Au);
  result = word_1803C3;
  unk_180498 = *(_DWORD *)(16 * v1);
  *((_BYTE *)&unk_180498 + 4) = *(_BYTE *)(16 * v1 + 4);
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 17FF4A: using guessed type __int16 word_17FF4A;
// 1803C3: using guessed type __int16 word_1803C3;

//----- (00086270) --------------------------------------------------------
__int16 __cdecl sub_86270(unsigned __int16 a1)
{
  int v1; // ecx
  __int16 result; // ax
  char *v3; // esi

  if ( !dword_E2A6C )
    return 0;
  v1 = dword_E2A70;
  if ( !dword_E2A70 )
    return 0;
  v3 = (char *)(16 * dword_E2A6C);
  *v3 = 26;
  v3[1] = 0;
  v3[2] = 3;
  *(_WORD *)(v3 + 3) = 0;
  v3[13] = 0;
  *((_WORD *)v3 + 9) = 7;
  *((_WORD *)v3 + 10) = 0;
  *(_DWORD *)(v3 + 22) = 0;
  *(_DWORD *)(v3 + 14) = v1 << 16;
  *(_BYTE *)(16 * v1) = 10;
  word_17FF58 = 0;
  word_17FF56 = 0;
  word_17FF4A = dword_E2A6C;
  dword_17FF38 = 0;
  dword_17FF14 = 0;
  dword_17FF10 = 47;
  dword_17FF40 = a1;
  dword_17FF44 = 5392;
  dword_17FF0C = 768;
  dword_17FF20 = (int)&unk_17FF28;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  qmemcpy(&unk_1803C0, v3, 0x1Au);
  result = word_1803C3;
  unk_180470 = *(_DWORD *)(16 * v1);
  *((_WORD *)&unk_180470 + 2) = *(_WORD *)(16 * v1 + 4);
  *((_BYTE *)&unk_180470 + 6) = *(_BYTE *)(16 * v1 + 6);
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 17FF4A: using guessed type __int16 word_17FF4A;
// 17FF56: using guessed type __int16 word_17FF56;
// 17FF58: using guessed type __int16 word_17FF58;
// 1803C3: using guessed type __int16 word_1803C3;

//----- (00086370) --------------------------------------------------------
__int16 __cdecl sub_86370(unsigned __int16 a1, char a2)
{
  int v2; // ecx
  __int16 result; // ax
  char *v4; // esi
  _BYTE *v5; // ebx

  if ( !dword_E2A6C )
    return 0;
  v2 = dword_E2A70;
  if ( !dword_E2A70 )
    return 0;
  v4 = (char *)(16 * dword_E2A6C);
  *v4 = 26;
  v4[1] = 0;
  v4[2] = 3;
  *(_WORD *)(v4 + 3) = 0;
  v4[13] = 0;
  *((_WORD *)v4 + 9) = 7;
  *((_WORD *)v4 + 10) = 0;
  *(_DWORD *)(v4 + 22) = 0;
  v5 = (_BYTE *)(16 * v2);
  *(_DWORD *)(v4 + 14) = v2 << 16;
  *v5 = 11;
  v5[1] = a2;
  dword_17FF38 = 0;
  dword_17FF10 = 47;
  word_17FF4A = dword_E2A6C;
  dword_17FF14 = 0;
  dword_17FF40 = a1;
  dword_17FF44 = 5392;
  dword_17FF0C = 768;
  dword_17FF20 = (int)&unk_17FF28;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  qmemcpy(&unk_1803C0, v4, 0x1Au);
  result = word_1803C3;
  unk_180484 = *(_DWORD *)(16 * v2);
  *((_WORD *)&unk_180484 + 2) = *(_WORD *)(16 * v2 + 4);
  *((_BYTE *)&unk_180484 + 6) = *(_BYTE *)(16 * v2 + 6);
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 17FF4A: using guessed type __int16 word_17FF4A;
// 1803C3: using guessed type __int16 word_1803C3;

//----- (00086460) --------------------------------------------------------
__int16 __cdecl sub_86460(unsigned __int16 a1)
{
  int v1; // ecx
  __int16 result; // ax
  char *v3; // esi
  __int16 v4; // ax

  if ( !dword_E2A6C )
    return 0;
  v1 = dword_E2A70;
  if ( !dword_E2A70 )
    return 0;
  v3 = (char *)(16 * dword_E2A6C);
  *v3 = 26;
  v3[1] = 0;
  v3[2] = 3;
  *(_WORD *)(v3 + 3) = 0;
  v3[13] = 0;
  *((_WORD *)v3 + 9) = 11;
  *((_WORD *)v3 + 10) = 0;
  *(_DWORD *)(v3 + 22) = 0;
  *(_DWORD *)(v3 + 14) = v1 << 16;
  v4 = dword_E2A6C;
  *(_BYTE *)(16 * v1) = 12;
  word_17FF4A = v4;
  dword_17FF38 = 0;
  dword_17FF10 = 47;
  dword_17FF14 = 0;
  dword_17FF40 = a1;
  dword_17FF44 = 5392;
  dword_17FF0C = 768;
  dword_17FF20 = (int)&unk_17FF28;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  qmemcpy(&unk_1803C0, v3, 0x1Au);
  result = word_1803C3;
  unk_18048B = *(_DWORD *)(16 * v1);
  *((_DWORD *)&unk_18048B + 1) = *(_DWORD *)(16 * v1 + 4);
  *((_WORD *)&unk_18048B + 4) = *(_WORD *)(16 * v1 + 8);
  *((_BYTE *)&unk_18048B + 10) = *(_BYTE *)(16 * v1 + 0xA);
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 17FF4A: using guessed type __int16 word_17FF4A;
// 1803C3: using guessed type __int16 word_1803C3;

//----- (00086550) --------------------------------------------------------
int sub_86550()
{
  dword_17FF38 = 0;
  dword_17FF44 = 5388;
  dword_17FF0C = 768;
  dword_17FF10 = 47;
  dword_17FF14 = 0;
  dword_17FF20 = (int)&unk_17FF28;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  return dword_17FF38;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF44: using guessed type int dword_17FF44;

//----- (00086780) --------------------------------------------------------
char __cdecl sub_86780(unsigned __int16 a1, int a2, int a3)
{
  char *v4; // esi

  if ( !byte_E2A28 )
    return 0;
  if ( !dword_E2A6C || !dword_E2A70 )
    return 0;
  v4 = (char *)(16 * dword_E2A70);
  *v4 = 22;
  v4[1] = 0;
  v4[2] = -124;
  *(_WORD *)(v4 + 3) = 0;
  v4[13] = 0;
  *(_DWORD *)(v4 + 14) = a2;
  *(_DWORD *)(v4 + 18) = a3;
  dword_17FF38 = 0;
  dword_17FF10 = 47;
  dword_17FF14 = 0;
  word_17FF4A = dword_E2A70;
  dword_17FF20 = (int)&unk_17FF28;
  dword_17FF40 = a1;
  dword_17FF0C = 768;
  dword_17FF44 = 5392;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  qmemcpy(&unk_1803A8, v4, 0x16u);
  return word_1803AB;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A28: using guessed type char byte_E2A28;
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 17FF4A: using guessed type __int16 word_17FF4A;
// 1803AB: using guessed type __int16 word_1803AB;

//----- (00086860) --------------------------------------------------------
char __cdecl sub_86860(unsigned __int16 a1)
{
  int v2; // esi
  __int16 v3; // ax

  if ( !byte_E2A28 )
    return 0;
  if ( !dword_E2A6C || !dword_E2A70 )
    return 0;
  v2 = 16 * dword_E2A70;
  *(_BYTE *)v2 = 13;
  v3 = dword_E2A70;
  *(_BYTE *)(v2 + 1) = 0;
  *(_BYTE *)(v2 + 2) = -123;
  *(_WORD *)(v2 + 3) = 0;
  word_17FF4A = v3;
  dword_17FF38 = 0;
  dword_17FF10 = 47;
  dword_17FF14 = 0;
  dword_17FF20 = (int)&unk_17FF28;
  dword_17FF40 = a1;
  dword_17FF0C = 768;
  dword_17FF44 = 5392;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  unk_180452 = *(_DWORD *)v2;
  v2 += 4;
  *((_DWORD *)&unk_180452 + 1) = *(_DWORD *)v2;
  v2 += 4;
  *((_DWORD *)&unk_180452 + 2) = *(_DWORD *)v2;
  *((_BYTE *)&unk_180452 + 12) = *(_BYTE *)(v2 + 4);
  return word_180455;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A28: using guessed type char byte_E2A28;
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 17FF4A: using guessed type __int16 word_17FF4A;
// 180455: using guessed type __int16 word_180455;

//----- (00086930) --------------------------------------------------------
char __cdecl sub_86930(unsigned __int16 a1)
{
  int v2; // esi
  __int16 v3; // ax

  if ( !byte_E2A28 )
    return 0;
  if ( !dword_E2A6C || !dword_E2A70 )
    return 0;
  v2 = 16 * dword_E2A70;
  *(_BYTE *)v2 = 13;
  v3 = dword_E2A70;
  *(_BYTE *)(v2 + 1) = 0;
  *(_BYTE *)(v2 + 2) = -120;
  *(_WORD *)(v2 + 3) = 0;
  word_17FF4A = v3;
  dword_17FF38 = 0;
  dword_17FF10 = 47;
  dword_17FF14 = 0;
  dword_17FF20 = (int)&unk_17FF28;
  dword_17FF40 = a1;
  dword_17FF0C = 768;
  dword_17FF44 = 5392;
  int386(49, &dword_17FF0C, &dword_17FF0C);
  unk_180460 = *(_DWORD *)v2;
  v2 += 4;
  *((_DWORD *)&unk_180460 + 1) = *(_DWORD *)v2;
  v2 += 4;
  *((_DWORD *)&unk_180460 + 2) = *(_DWORD *)v2;
  *((_BYTE *)&unk_180460 + 12) = *(_BYTE *)(v2 + 4);
  return word_180463;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E2A28: using guessed type char byte_E2A28;
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;
// 17FF0C: using guessed type int dword_17FF0C;
// 17FF10: using guessed type int dword_17FF10;
// 17FF14: using guessed type int dword_17FF14;
// 17FF20: using guessed type int dword_17FF20;
// 17FF38: using guessed type int dword_17FF38;
// 17FF40: using guessed type int dword_17FF40;
// 17FF44: using guessed type int dword_17FF44;
// 17FF4A: using guessed type __int16 word_17FF4A;
// 180463: using guessed type __int16 word_180463;

//----- (00086A00) --------------------------------------------------------
char sub_86A00()
{
  __int16 v0; // ax
  int v1; // ebx
  unsigned __int16 v2; // bx
  int v3; // esi
  __int16 v4; // bx
  unsigned __int16 i; // ax
  int v6; // edi
  unsigned __int16 j; // bx
  int v8; // eax
  unsigned __int16 k; // bx
  int v10; // eax
  unsigned __int16 v11; // ax
  int v12; // edx
  int v13; // ecx
  int v15; // [esp-4h] [ebp-4h]

  sub_85E40();
  v0 = sub_85FD0();
  if ( v0 )
  {
    if ( !sub_86010() )
      goto LABEL_16;
    sub_86550();
    v1 = 0;
    while ( (((unsigned __int16)sub_86270(word_1803EC) >> 8) & 0x80u) != 0 )
    {
      j___delay(1000);
      if ( (_WORD)++v1 == 4 )
        goto LABEL_16;
    }
    byte_1804A1 = byte_180471;
    v2 = (unsigned __int8)byte_180471;
    byte_18049E = byte_180472;
    while ( v2 <= (int)(unsigned __int8)byte_180472 )
    {
      sub_86370(word_1803EC, v2);
      v3 = v2;
      v15 = dword_180486;
      byte_1803EE[v2++] = (byte_18048A & 0x40) == 0;
      dword_180084[v3] = sub_85F60(v15);
    }
    v4 = 0;
    for ( i = (unsigned __int8)byte_180471; i <= (int)(unsigned __int8)byte_180472; ++i )
    {
      if ( byte_1803EE[i] )
        v4 = 1;
    }
    if ( v4 )
    {
      v6 = dword_180088[0];
      for ( j = (unsigned __int8)byte_180471; ; ++j )
      {
        v8 = j;
        if ( j > (int)(unsigned __int8)byte_180472 )
          break;
        dword_180084[v8] -= v6;
      }
      for ( k = (unsigned __int8)byte_180471; k <= (int)(unsigned __int8)byte_180472; ++k )
      {
        if ( k == (unsigned __int8)byte_180472 )
          v10 = sub_85F60(dword_180473) - v6;
        else
          v10 = dword_180088[k];
        dword_180214[k] = v10;
        v11 = k;
        v12 = dword_180084[k];
        v13 = dword_180214[k];
        dword_180214[v11] = v13 - v12;
      }
      LOBYTE(v0) = sub_86460(word_1803EC);
      byte_E2A28 = 1;
    }
    else
    {
LABEL_16:
      LOBYTE(v0) = sub_86BD0();
    }
  }
  return v0;
}
// 9A122: using guessed type _DWORD __cdecl j___delay(_DWORD);
// E2A28: using guessed type char byte_E2A28;
// 180084: using guessed type int dword_180084[];
// 180088: using guessed type int dword_180088[99];
// 180214: using guessed type int dword_180214[101];
// 1803EC: using guessed type __int16 word_1803EC;
// 180471: using guessed type char byte_180471;
// 180472: using guessed type char byte_180472;
// 180473: using guessed type int dword_180473;
// 180486: using guessed type int dword_180486;
// 18048A: using guessed type char byte_18048A;
// 18049E: using guessed type char byte_18049E;
// 1804A1: using guessed type char byte_1804A1;

//----- (00086BD0) --------------------------------------------------------
char sub_86BD0()
{
  char result; // al

  if ( dword_E2A6C )
    result = sub_85F00(dword_E2A6C);
  if ( dword_E2A70 )
    result = sub_85F00(dword_E2A70);
  byte_E2A28 = 0;
  dword_E2A6C = 0;
  dword_E2A70 = 0;
  return result;
}
// E2A28: using guessed type char byte_E2A28;
// E2A6C: using guessed type int dword_E2A6C;
// E2A70: using guessed type int dword_E2A70;

//----- (00086EA0) --------------------------------------------------------
int sub_86EA0()
{
  sub_47760();
  return 0;
}

//----- (00086EB0) --------------------------------------------------------
void __cdecl sub_86EB0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int v3; // eax
  unsigned __int8 v4; // dl
  int v5; // eax
  __int16 v6; // bx
  __int16 v7; // ax

  v3 = 42 * a1;
  v4 = byte_DB080[v3];
  v5 = 4 * a2 + v3;
  v6 = *(__int16 *)((char *)&word_DB082 + v5);
  v7 = *(__int16 *)((char *)&word_DB084 + v5);
  if ( v4 && v7 )
  {
    if ( a3 )
      sub_86F70(v4, v6, v7);
    else
      sub_86FF0(v4, v6, v7);
  }
}
// DB082: using guessed type __int16 word_DB082;
// DB084: using guessed type __int16 word_DB084;

//----- (00086F20) --------------------------------------------------------
void __cdecl sub_86F20(char a1)
{
  int v1; // eax
  unsigned __int8 v2; // dl
  __int16 v3; // bx
  __int16 v4; // ax

  v1 = 21 * ((a1 != 0) + 25);
  v2 = byte_DB080[v1 * 2];
  v3 = word_DB082[v1];
  v4 = word_DB084[v1];
  if ( v2 )
  {
    if ( v4 )
      sub_86F70(v2, v3, v4);
  }
}
// DB082: using guessed type __int16 word_DB082[];
// DB084: using guessed type __int16 word_DB084[];

//----- (00086F70) --------------------------------------------------------
void __cdecl sub_86F70(unsigned __int8 a1, __int16 a2, __int16 a3)
{
  if ( byte_E2A28 && (byte_E37FC || byte_E3798) )
  {
    dword_180078 = sub_92600((int)sub_86EA0);
    sub_92930(dword_180078, 0x32u);
    sub_92BA0(dword_180078);
    sub_86FF0(a1, a2, a3);
    sub_92DC0(dword_180078);
  }
}
// E2A28: using guessed type char byte_E2A28;
// E3798: using guessed type char byte_E3798;
// E37FC: using guessed type char byte_E37FC;
// 180078: using guessed type int dword_180078;

//----- (00086FF0) --------------------------------------------------------
void __cdecl sub_86FF0(unsigned __int8 a1, __int16 a2, __int16 a3)
{
  if ( byte_E2A28 && (byte_E37FC || byte_E3798) )
  {
    word_1803E8 = a1;
    sub_86860(word_1803EC);
    if ( (unsigned __int16)word_1803E8 >= (int)(unsigned __int8)byte_1804A1
      && (unsigned __int16)word_1803E8 <= (int)(unsigned __int8)byte_18049E )
    {
      if ( byte_1803EE[(unsigned __int16)word_1803E8] )
        sub_86780(word_1803EC, dword_180084[(unsigned __int16)word_1803E8] + a2, a3);
    }
  }
}
// E2A28: using guessed type char byte_E2A28;
// E3798: using guessed type char byte_E3798;
// E37FC: using guessed type char byte_E37FC;
// 180084: using guessed type int dword_180084[];
// 1803E8: using guessed type __int16 word_1803E8;
// 1803EC: using guessed type __int16 word_1803EC;
// 18049E: using guessed type char byte_18049E;
// 1804A1: using guessed type char byte_1804A1;

//----- (00087090) --------------------------------------------------------
char sub_87090()
{
  int i; // edx
  char result; // al
  _DWORD *v2; // eax
  int j; // edx

  memset(&unk_1804B0, 0, 171);
  for ( i = 1; i < 120 && !dword_180516; ++i )
  {
    if ( !word_E2A74[15 * i] )
      dword_180516 = i - 1;
  }
  result = sub_871E0();
  if ( result )
  {
    byte_180552 = 1;
    word_1804C0 = 8;
    word_1804C2 = 14;
    word_1804BE = 400;
    word_1804C6 = 600;
    word_1804C8 = 80;
    word_1804CA = 260;
    word_1804C4 = 40;
    qmemcpy(&unk_1804E3, &unk_1804B0, 0x30u);
    qmemcpy((char *)&unk_1804E3 + 48, (char *)&unk_1804B0 + 48, 3u);
    v2 = &unk_E2A92;
    word_1804FD = 370;
    word_1804F7 = 30;
    word_1804F9 = 610;
    word_1804FB = 30;
    for ( j = 0; j < dword_180516; ++j )
    {
      v2[4] = v2[6];
      if ( !*((_BYTE *)v2 + 29) )
        *((_BYTE *)v2 + 29) = *((_BYTE *)v2 + 28);
      v2 = (_DWORD *)((char *)v2 + 30);
      *(_DWORD *)((char *)v2 - 18) = 0;
      *(_DWORD *)((char *)v2 - 10) = 0;
    }
    dword_180532 = *(_DWORD *)(dword_D41A0 + 8);
    return sub_88B20();
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// E2A74: using guessed type __int16 word_E2A74[];
// 1804BE: using guessed type __int16 word_1804BE;
// 1804C0: using guessed type __int16 word_1804C0;
// 1804C2: using guessed type __int16 word_1804C2;
// 1804C4: using guessed type __int16 word_1804C4;
// 1804C6: using guessed type __int16 word_1804C6;
// 1804C8: using guessed type __int16 word_1804C8;
// 1804CA: using guessed type __int16 word_1804CA;
// 1804F7: using guessed type __int16 word_1804F7;
// 1804F9: using guessed type __int16 word_1804F9;
// 1804FB: using guessed type __int16 word_1804FB;
// 1804FD: using guessed type __int16 word_1804FD;
// 180516: using guessed type int dword_180516;
// 180532: using guessed type int dword_180532;
// 180552: using guessed type char byte_180552;

//----- (000871E0) --------------------------------------------------------
char sub_871E0()
{
  return 1;
}

//----- (000871F0) --------------------------------------------------------
int sub_871F0()
{
  _DWORD *v0; // eax
  char v1; // bl
  int v2; // eax
  int v4; // eax

  v0 = (_DWORD *)sub_872A0();
  BYTE1(v0) = word_18054E;
  v1 = 1;
  if ( (word_18054E & 0x10) != 0 )
  {
    v0 = (_DWORD *)sub_87C10();
  }
  else
  {
    if ( (word_18054E & 0x2000) != 0 || (word_18054E & 0x1000) != 0 )
      v1 = 0;
    if ( (word_18054E & 2) != 0 || (word_18054E & 0x800) != 0 )
      v1 = 1;
    if ( v1 )
    {
      if ( word_180536 )
      {
        sub_87610();
        sub_87B30();
      }
      else if ( --dword_180522 <= 0 )
      {
        sub_87580();
      }
      v0 = sub_87B70();
    }
    else
    {
      if ( (word_18054E & 0x1000) != 0 )
      {
        v2 = sub_87A30();
        return _wcpp_1_unwind_leave__132(v2);
      }
      if ( (word_18054E & 0x2000) != 0 )
      {
        v4 = sub_87860();
        return _wcpp_1_unwind_leave__132(v4);
      }
    }
  }
  return _wcpp_1_unwind_leave__132(v0);
}
// 87BD0: using guessed type int __fastcall _wcpp_1_unwind_leave__132(_DWORD);
// 180522: using guessed type int dword_180522;
// 180536: using guessed type __int16 word_180536;
// 18054E: using guessed type __int16 word_18054E;

//----- (000872A0) --------------------------------------------------------
int sub_872A0()
{
  int v0; // edx
  unsigned __int8 v1; // al
  int v2; // esi
  char v3; // dh
  int v4; // ebx
  int v5; // edx
  int v6; // ebx
  int v7; // eax
  char v8; // cl
  char v9; // bh
  int result; // eax
  char v11; // ch
  __int16 v12; // cx
  int v13; // ebx

  v0 = 2124 * *(__int16 *)(dword_D41A0 + 12);
  v1 = *(_BYTE *)(v0 + dword_D41A0 + 12221);
  v2 = dword_EA3E4[*(unsigned __int16 *)(v0 + dword_D41A0 + 11240)];
  if ( v1 < 6u || v1 > 8u )
    LOBYTE(word_18054E) = word_18054E & 0xFA;
  else
    LOBYTE(word_18054E) = word_18054E | 5;
  word_18054E &= 0xC7FDu;
  v3 = *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221);
  if ( v3 == 5 || v3 == 8 )
  {
    LOBYTE(word_18054E) = word_18054E | 2;
    v4 = *(_DWORD *)(v2 + 164);
    dword_18051E = 6;
    v5 = *(char *)(v4 + 1112);
    v6 = v4 + 611;
    if ( v5 != (unsigned __int8)byte_180555 || *(char *)(v6 + 502) != (unsigned __int8)byte_180556 )
    {
      v7 = (unsigned __int8)byte_D94FF[*(char *)(v6 + 501)];
      if ( (unsigned __int8)byte_180554 > 1u || !*(_WORD *)(v6 + 2 * v7 + 208) || !byte_D41B6 && v7 == 25 )
        sub_87C10();
      byte_180554 = 0;
      sub_88D40();
      dword_180526 = 0;
    }
    byte_180555 = *(_BYTE *)(v6 + 501);
    byte_180556 = *(_BYTE *)(v6 + 502);
  }
  else
  {
    dword_18051E = 20;
    byte_180554 = 0;
    byte_180555 = -1;
  }
  if ( *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) == 7 )
  {
    HIBYTE(word_18054E) |= 8u;
  }
  else if ( word_E2A74[15 * word_180536] == 12 )
  {
    sub_87C10();
  }
  if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) != 0 )
    HIBYTE(word_18054E) |= 0x20u;
  if ( *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) == 3 )
    HIBYTE(word_18054E) |= 0x10u;
  if ( *(_WORD *)(v2 + 130) )
    dword_18053A = 0;
  else
    ++dword_18053A;
  v8 = HIBYTE(word_18054E) & 0xFB;
  HIBYTE(word_18054E) &= ~4u;
  if ( *(_BYTE *)(v2 + 69) == 3 )
    HIBYTE(word_18054E) = v8 | 4;
  LOBYTE(word_18054E) = word_18054E & 0xEF;
  if ( *(_BYTE *)(dword_D41A0 + 224772)
    || *(_BYTE *)(dword_D41A4 + 225)
    || (v9 = *(_BYTE *)(v2 + 69), v9 == 12)
    || v9 == 11
    || (result = 2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0, v11 = *(_BYTE *)(result + 12221), v11 == 13)
    || v11 == 14 )
  {
    result = dword_18051E;
    dword_180522 = dword_18051E;
    LOBYTE(word_18054E) = word_18054E | 0x10;
  }
  if ( word_180536 )
  {
    result = 30 * word_180536;
    v12 = *(__int16 *)((char *)word_E2A74 + result);
    if ( v12 == 2 || v12 == 8 )
    {
      if ( (word_18054E & 0x200) == 0
        || (result = 30 * word_180536, byte_E2A76[result] >= 0)
        && ((v13 = *(int *)((char *)&dword_E2A80 + 30 * word_180536)) == 0
         || (result = *(int *)((char *)&dword_E2A80 + 30 * word_180536), *(int *)(v13 + 8) < 0)
         || (*(_BYTE *)(v13 + 13) & 4) != 0) )
      {
        result = sub_87C10();
      }
    }
    if ( *(_BYTE *)(v2 + 69) == 2 )
      return sub_87C10();
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// D41B6: using guessed type char byte_D41B6;
// E2A74: using guessed type __int16 word_E2A74[];
// E2A80: using guessed type int dword_E2A80;
// EA3E4: using guessed type int dword_EA3E4[];
// 18051E: using guessed type int dword_18051E;
// 180522: using guessed type int dword_180522;
// 180526: using guessed type int dword_180526;
// 180536: using guessed type __int16 word_180536;
// 18053A: using guessed type int dword_18053A;
// 18054E: using guessed type __int16 word_18054E;
// 180554: using guessed type char byte_180554;
// 180555: using guessed type char byte_180555;
// 180556: using guessed type char byte_180556;

//----- (00087580) --------------------------------------------------------
void sub_87580()
{
  int v0; // edx

  sub_87BE0();
  if ( (word_18054E & 0x400) != 0 )
  {
    sub_884D0(91, 1, (int)&unk_E3522, 1, 0);
  }
  else if ( (word_18054E & 2) != 0 )
  {
    sub_88D40();
  }
  else if ( (word_18054E & 0x800) != 0 )
  {
    sub_89360();
  }
  else
  {
    sub_87CF0();
    v0 = sub_88450();
    sub_884D0(v0, 1, (int)&word_E2A74[15 * v0 + 2], ((byte_E2A76[30 * v0] & 4) == 0) + 1, 0);
  }
}
// E2A74: using guessed type __int16 word_E2A74[];
// 18054E: using guessed type __int16 word_18054E;

//----- (00087610) --------------------------------------------------------
char sub_87610()
{
  const char *v0; // edi
  __int16 *v1; // esi
  char result; // al
  __int16 v3; // ax
  int v4; // esi
  int v5; // edi
  unsigned __int8 v6; // al
  _BYTE *v7; // [esp-10h] [ebp-90h]
  char v8[128]; // [esp+0h] [ebp-80h] BYREF

  v0 = (const char *)dword_E9C4C[word_18053E[0]];
  v1 = &word_E2A74[15 * word_180536];
  if ( (*((_BYTE *)v1 + 3) & 1) != 0 )
  {
    v0 = v8;
    sub_89AC0(v8, word_180536);
  }
  *((_BYTE *)&unk_1804B0 + 48) = byte_E98FF;
  *((_BYTE *)&unk_1804B0 + 49) = byte_E8900[0];
  *((_BYTE *)&unk_1804B0 + 50) = byte_E9800;
  result = byte_180553;
  if ( (unsigned __int8)byte_180553 >= 2u )
  {
    if ( (unsigned __int8)byte_180553 <= 2u )
    {
      *((_WORD *)&unk_1804B0 + 14) = v1[4];
      v3 = v1[5];
      *((_WORD *)&unk_1804B0 + 6) = 220;
      *((_WORD *)&unk_1804B0 + 15) = v3;
      if ( (word_18054E & 8) != 0 )
      {
        sub_89830(&unk_1804B0);
        sub_89420(&unk_1804B0, v0);
        sub_89520((__int16 *)&unk_1804B0);
        sub_89980((__int16 *)&unk_1804B0);
      }
      sub_898A0(&unk_1804B0);
      sub_2E790(
        *((_WORD *)&unk_1804B0 + 18),
        *((__int16 *)&unk_1804B0 + 19),
        *((_WORD *)&unk_1804B0 + 20),
        *((_WORD *)&unk_1804B0 + 21),
        *((_BYTE *)&unk_1804B0 + 49));
      sub_895D0((int)&unk_1804B0, v0);
    }
    else
    {
      if ( byte_180553 != 3 )
        goto LABEL_22;
      *((_WORD *)&unk_1804B0 + 14) = v1[4];
      *((_WORD *)&unk_1804B0 + 15) = v1[5];
      sub_89830(&unk_1804B0);
      sub_89920(&unk_1804B0, (unsigned __int8)byte_180550, (int)word_18053E);
      sub_89520((__int16 *)&unk_1804B0);
      sub_89980((__int16 *)&unk_1804B0);
      sub_898A0(&unk_1804B0);
      v4 = 0;
      sub_2E790(
        *((_WORD *)&unk_1804B0 + 18),
        *((__int16 *)&unk_1804B0 + 19),
        *((_WORD *)&unk_1804B0 + 20),
        *((_WORD *)&unk_1804B0 + 21),
        *((_BYTE *)&unk_1804B0 + 49));
      v5 = *((__int16 *)&unk_1804B0 + 5);
      while ( v4 < (unsigned __int8)byte_180550 )
      {
        if ( v4 == (unsigned __int8)byte_180551 )
          v6 = *((_BYTE *)&unk_1804B0 + 50);
        else
          v6 = *((_BYTE *)&unk_1804B0 + 48);
        v7 = (_BYTE *)dword_E9C4C[word_18053E[v4++]];
        sub_2BC10(v7, *((_WORD *)&unk_1804B0 + 4), v5, v6);
        v5 += *((__int16 *)&unk_1804B0 + 9);
      }
    }
    sub_89A30(&unk_1804B0);
    goto LABEL_21;
  }
  if ( byte_180553 == 1 )
  {
    if ( (word_18054E & 8) != 0 )
    {
      unk_1804B0 = 320;
      *((_WORD *)&unk_1804B0 + 1) = 80;
      *((_WORD *)&unk_1804B0 + 6) = 320;
      sub_89420(&unk_1804B0, v0);
      sub_89520((__int16 *)&unk_1804B0);
      sub_89980((__int16 *)&unk_1804B0);
    }
    sub_2E790(
      *((_WORD *)&unk_1804B0 + 18),
      *((__int16 *)&unk_1804B0 + 19),
      *((_WORD *)&unk_1804B0 + 20),
      *((_WORD *)&unk_1804B0 + 21),
      *((_BYTE *)&unk_1804B0 + 49));
    sub_895D0((int)&unk_1804B0, v0);
LABEL_21:
    result = sub_89690((__int16 *)&unk_1804B0);
  }
LABEL_22:
  LOBYTE(word_18054E) = word_18054E & 0xF7;
  return result;
}
// E2A74: using guessed type __int16 word_E2A74[];
// E9800: using guessed type char byte_E9800;
// E98FF: using guessed type char byte_E98FF;
// E9C4C: using guessed type int dword_E9C4C[];
// 180536: using guessed type __int16 word_180536;
// 18053E: using guessed type __int16 word_18053E[4];
// 18054E: using guessed type __int16 word_18054E;
// 180550: using guessed type char byte_180550;
// 180551: using guessed type char byte_180551;
// 180553: using guessed type char byte_180553;

//----- (00087860) --------------------------------------------------------
int sub_87860()
{
  __int16 *v0; // eax
  const char *v1; // ebx
  __int16 v2; // dx
  int result; // eax

  if ( byte_18055A >= 0 )
  {
    sub_87970();
    v0 = &word_E2A74[15 * byte_18055A + 1290];
    v1 = (const char *)dword_E9C4C[v0[2]];
    v2 = v0[4];
    LOWORD(v0) = v0[5];
    word_1804FF = v2;
    word_180501 = (__int16)v0;
    byte_180513 = byte_E98FF;
    word_1804EF = 220;
    byte_180514 = byte_E8900[0];
    sub_89830(word_1804E3);
    sub_89420(word_1804E3, v1);
    sub_89520(word_1804E3);
    sub_89980(word_1804E3);
    sub_898A0(word_1804E3);
    sub_2E790(word_180507, word_180509, word_18050B, word_18050D, byte_180514);
    sub_895D0((int)word_1804E3, v1);
    sub_89A30(word_1804E3);
    return sub_89690(word_1804E3);
  }
  return result;
}
// E2A74: using guessed type __int16 word_E2A74[];
// E98FF: using guessed type char byte_E98FF;
// E9C4C: using guessed type int dword_E9C4C[];
// 1804E3: using guessed type __int16 word_1804E3[6];
// 1804EF: using guessed type __int16 word_1804EF;
// 1804FF: using guessed type __int16 word_1804FF;
// 180501: using guessed type __int16 word_180501;
// 180507: using guessed type __int16 word_180507;
// 180509: using guessed type __int16 word_180509;
// 18050B: using guessed type __int16 word_18050B;
// 18050D: using guessed type __int16 word_18050D;
// 180513: using guessed type char byte_180513;
// 180514: using guessed type char byte_180514;
// 18055A: using guessed type char byte_18055A;

//----- (00087970) --------------------------------------------------------
int sub_87970()
{
  int result; // eax
  int v1; // [esp+0h] [ebp-10h] BYREF
  int v2; // [esp+4h] [ebp-Ch] BYREF
  int v3; // [esp+8h] [ebp-8h] BYREF
  int v4; // [esp+Ch] [ebp-4h] BYREF

  sub_2FFE0(&v4, &v3, &v2, &v1);
  word_E3490 = v2 + v4 - 12;
  word_E3492 = v3 + 6;
  word_E34AE = v2 + v4 - 12;
  word_E34B0 = v1 + v3 + 6;
  word_E34CC = v4 + v2 / 2 - 12;
  word_E34CE = v3 + 2 * v1 + 6;
  word_E34EA = v2 + v4 - 12;
  word_E34EC = v3 + 2 * v1 + 6;
  word_E3508 = v2 + v4 - 12;
  result = v3 + 3 * v1 + 6;
  word_E350A = v3 + 3 * v1 + 6;
  return result;
}
// E3490: using guessed type __int16 word_E3490;
// E3492: using guessed type __int16 word_E3492;
// E34AE: using guessed type __int16 word_E34AE;
// E34B0: using guessed type __int16 word_E34B0;
// E34CC: using guessed type __int16 word_E34CC;
// E34CE: using guessed type __int16 word_E34CE;
// E34EA: using guessed type __int16 word_E34EA;
// E34EC: using guessed type __int16 word_E34EC;
// E3508: using guessed type __int16 word_E3508;
// E350A: using guessed type __int16 word_E350A;

//----- (00087A30) --------------------------------------------------------
int sub_87A30()
{
  int result; // eax
  __int16 *v1; // eax
  int v2; // ebx
  const char *v3; // ebx

  BYTE1(result) = byte_180559;
  if ( byte_180559 > 0 )
  {
    v1 = &word_E2A74[15 * byte_180559];
    v2 = v1[2];
    word_1804FF = v1[4];
    v3 = (const char *)dword_E9C4C[v2];
    word_180501 = v1[5];
    byte_180513 = byte_E98FF;
    word_1804EF = 220;
    byte_180514 = byte_E8900[0];
    sub_89830(word_1804E3);
    sub_89420(word_1804E3, v3);
    sub_89520(word_1804E3);
    sub_89980(word_1804E3);
    sub_898A0(word_1804E3);
    sub_2E790(word_180507, word_180509, word_18050B, word_18050D, byte_180514);
    sub_895D0((int)word_1804E3, v3);
    sub_89A30(word_1804E3);
    return sub_89690(word_1804E3);
  }
  return result;
}
// E2A74: using guessed type __int16 word_E2A74[];
// E98FF: using guessed type char byte_E98FF;
// E9C4C: using guessed type int dword_E9C4C[];
// 1804E3: using guessed type __int16 word_1804E3[6];
// 1804EF: using guessed type __int16 word_1804EF;
// 1804FF: using guessed type __int16 word_1804FF;
// 180501: using guessed type __int16 word_180501;
// 180507: using guessed type __int16 word_180507;
// 180509: using guessed type __int16 word_180509;
// 18050B: using guessed type __int16 word_18050B;
// 18050D: using guessed type __int16 word_18050D;
// 180513: using guessed type char byte_180513;
// 180514: using guessed type char byte_180514;
// 180559: using guessed type char byte_180559;

//----- (00087B30) --------------------------------------------------------
int sub_87B30()
{
  int result; // eax

  if ( ++dword_180526 >= dword_18052A )
    return sub_87C10();
  result = 15 * word_180536;
  if ( (byte_E2A76[30 * word_180536] & 1) == 0 )
    return sub_87C10();
  return result;
}
// 180526: using guessed type int dword_180526;
// 18052A: using guessed type int dword_18052A;
// 180536: using guessed type __int16 word_180536;

//----- (00087B70) --------------------------------------------------------
_DWORD *sub_87B70()
{
  _DWORD *result; // eax
  int i; // ebx
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  char v5; // dl

  result = &unk_E2A92;
  for ( i = 0; i < dword_180516; result = (_DWORD *)((char *)result + 30) )
  {
    v2 = result[4] + 1;
    v3 = result[6];
    result[4] = v2;
    v4 = v2 - v3;
    if ( v4 > 0 && v4 > 2 * v3 )
    {
      result[4] = result[6];
      v5 = *((_BYTE *)result + 29) + 1;
      *((_BYTE *)result + 29) = v5;
      if ( v5 < 0 )
        *((_BYTE *)result + 29) = 0;
      if ( *((char *)result + 29) > 5 )
        *((_BYTE *)result + 29) = 5;
    }
    ++i;
  }
  return result;
}
// 180516: using guessed type int dword_180516;

//----- (00087BE0) --------------------------------------------------------
char *sub_87BE0()
{
  char *result; // eax
  int i; // edx
  char v2; // bl

  result = (char *)&unk_E2A92;
  for ( i = 0; i < dword_180516; *(result - 28) = v2 & 0xFE )
  {
    v2 = result[2];
    result += 30;
    ++i;
  }
  return result;
}
// 180516: using guessed type int dword_180516;

//----- (00087C10) --------------------------------------------------------
int sub_87C10()
{
  int result; // eax
  int v1; // edx
  int v2; // eax

  result = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 10) )
  {
    dword_18051A = 0;
    word_18054E &= 0xFEDFu;
    v1 = word_180536;
    dword_180522 = dword_18051E;
    v2 = 15 * word_180536;
    byte_E2A76[2 * v2] &= ~2u;
    *(int *)((char *)&dword_E2A84 + 2 * v2) = 0;
    *(int *)((char *)&dword_E2A80 + 2 * v2) = 0;
    byte_E2A91[2 * v2] = byte_E2A90[2 * v2];
    result = sub_889F0(v1);
    word_180536 = 0;
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// E2A80: using guessed type int dword_E2A80;
// E2A84: using guessed type int dword_E2A84;
// 18051A: using guessed type int dword_18051A;
// 18051E: using guessed type int dword_18051E;
// 180522: using guessed type int dword_180522;
// 180536: using guessed type __int16 word_180536;
// 18054E: using guessed type __int16 word_18054E;

//----- (00087CF0) --------------------------------------------------------
int sub_87CF0()
{
  int v0; // ecx
  int *v1; // esi
  _WORD *v2; // edx
  unsigned __int16 v3; // bx
  char *v4; // edi
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // eax
  char *v9; // ebx
  char v10; // ah
  char v11; // dh
  int v12; // eax
  _BOOL1 v13; // zf
  int v14; // eax
  __int16 v15; // bx
  _BOOL1 v16; // bl
  int v17; // edx
  int v18; // edx
  char v20; // al
  int v21; // edx
  char *v22; // ebx
  int v23; // edx
  char *v24; // ebx
  char v25; // ah
  int result; // eax
  int v27; // edx
  char *v28; // ebx
  int v29; // [esp+0h] [ebp-28h]
  bool v30; // [esp+8h] [ebp-20h]
  bool v31; // [esp+Ch] [ebp-1Ch]
  bool v32; // [esp+10h] [ebp-18h]
  int v33; // [esp+14h] [ebp-14h]
  int v34; // [esp+18h] [ebp-10h]
  unsigned int v35; // [esp+1Ch] [ebp-Ch]
  int v36; // [esp+20h] [ebp-8h]
  int v37; // [esp+24h] [ebp-4h]

  v34 = 0;
  v37 = -1;
  v0 = -1;
  v1 = (int *)dword_EA3E4[*(unsigned __int16 *)(dword_D41A0 + 2124 * *(__int16 *)(dword_D41A0 + 12) + 11240)];
  v2 = (_WORD *)v1[41];
  v3 = v2[29];
  v4 = (char *)v2 + 611;
  if ( v3 )
    v5 = dword_EA3E4[v3];
  else
    v5 = 0;
  v36 = v5;
  v6 = 0;
  v29 = 0;
  while ( v6 < 26 )
  {
    v7 = *(_WORD *)&v4[2 * v6++ + 208] != 0;
    v29 += v7;
  }
  if ( v29 )
  {
    v30 = *(_WORD *)((char *)v2 + 823) != 0;
    v32 = *(_WORD *)((char *)v2 + 821) != 0;
    v31 = *(_WORD *)((char *)v2 + 819) != 0;
    v0 = *(__int16 *)((char *)v2 + 1105);
    v37 = *(__int16 *)((char *)v2 + 1107);
  }
  v8 = dword_D41A0 + 11 * *(__int16 *)(dword_D41A0 + 12);
  if ( byte_3659C[v8] )
    v33 = -1;
  else
    v33 = *(char *)(dword_D41A0 + 10 * (unsigned __int8)byte_3659D[v8] + 222540);
  v35 = 1;
  v9 = (char *)&unk_E2A92;
  while ( (int)v35 <= dword_180516 )
  {
    switch ( *(_WORD *)v9 )
    {
      case 1:
        if ( v35 && (v35 <= 2 || v35 == 92) )
          goto LABEL_32;
        break;
      case 2:
        v10 = v9[2];
        if ( (v10 & 0x18) != 0 )
          v9[2] = v10 | 1;
        break;
      case 3:
        if ( v36 )
        {
          if ( v35 != 35 )
            goto LABEL_32;
          if ( !v33 )
          {
            v12 = dword_D41A0;
            v9[2] |= 1u;
            word_E2E96 = (*(unsigned __int16 *)((char *)&loc_2FED5 + v12) << 6) / 100
                       + *(unsigned __int8 *)(dword_EA3DC + 244)
                       + 60;
            word_E2E98 = 38;
          }
        }
        break;
      case 5:
      case 7:
      case 0xC:
      case 0xD:
        break;
      case 6:
        v13 = (word_18054E & 2) == 0;
        goto LABEL_31;
      case 8:
        v11 = v9[2];
        if ( (v11 & 0x10) != 0 || (v11 & 0x40) != 0 )
          v9[2] |= 1u;
        if ( (v9[2] & 0x40) != 0 )
          ++v34;
        break;
      default:
        v13 = v35 == 85;
LABEL_31:
        if ( !v13 )
LABEL_32:
          v9[2] |= 1u;
        break;
    }
    v9 += 30;
    ++v35;
  }
  if ( (word_18054E & 4) != 0 )
  {
    word_E2AB8 = 190;
    word_E2ABA = 202;
  }
  else
  {
    word_E2AB8 = 64;
    word_E2ABA = 66;
  }
  if ( !v34 && (word_18054E & 4) == 0 )
    byte_E2AEE |= 1u;
  if ( v1[1] >> 2 >= v1[2] )
    byte_E2B0C |= 1u;
  if ( *(_BYTE *)(v1[41] + 610) )
    byte_E2AD0 |= 1u;
  byte_E2BA2 |= 4u;
  byte_E2BC0 |= 4u;
  byte_E2BDE |= 4u;
  if ( v29 )
  {
    v14 = word_18054E & 0x40;
    if ( (word_18054E & 0x80) != 0 )
    {
      if ( v31 )
      {
        byte_E2BA2 |= 1u;
        if ( v0 && v37 )
        {
          byte_E2BFC |= 1u;
        }
        else
        {
          byte_E2BA2 &= ~4u;
          if ( v0 )
            v15 = 600;
          else
            v15 = 540;
          word_E2BA8 = v15;
          word_E2BAA = 32;
        }
      }
      else
      {
        byte_E2B48 |= 1u;
      }
      LOBYTE(word_18054E) = word_18054E & 0x7F;
    }
    if ( v14 )
    {
      if ( v32 )
      {
        byte_E2BC0 |= 1u;
        if ( v0 == 1 || v37 == 1 )
        {
          byte_E2BC0 &= ~4u;
          if ( v0 == 1 )
            word_E2BC6 = 540;
          else
            word_E2BC6 = 600;
          word_E2BC8 = 32;
        }
        else
        {
          byte_E2BFC |= 1u;
        }
      }
      else
      {
        byte_E2B84 |= 1u;
      }
      LOBYTE(word_18054E) = word_18054E & 0xBF;
    }
    if ( v30 )
    {
      if ( !v36 )
      {
        byte_E2BDE |= 1u;
        if ( v0 == 2 || v37 == 2 )
        {
          byte_E2BDE &= ~4u;
          if ( v0 == 2 )
            word_E2BE4 = 540;
          else
            word_E2BE4 = 600;
          word_E2BE6 = 32;
        }
        else
        {
          byte_E2BFC |= 1u;
        }
      }
    }
    else
    {
      byte_E2B66 |= 1u;
    }
  }
  else
  {
    byte_E2B2A |= 1u;
  }
  if ( v36 )
  {
    if ( v1[36] >= *(_DWORD *)(dword_EA3E4[*((__int16 *)v4 + 106)] + 140) && *(int *)(v36 + 16) < 6 )
      byte_E2C1A |= 1u;
    if ( *(_BYTE *)(v1[41] + 405) )
      dword_E2C86 = 100;
    if ( dword_E2C86 )
      --dword_E2C86;
    if ( dword_E2C86 )
      byte_E2C74 |= 1u;
  }
  if ( v29 )
  {
    if ( v0 > -1 )
      byte_E2EEA |= 1u;
    if ( v37 > -1 )
      byte_E2F08 |= 1u;
    if ( v0 > -1 )
    {
      word_E2F2C = 540;
      byte_E2F26 |= 1u;
      word_E2F2E = 40;
      byte_E2F62 |= 1u;
      word_E2F6A = 16;
      word_E2F68 = 560;
    }
    v16 = 0;
    if ( v0 > -1 )
    {
      v17 = dword_EA3E4[*(__int16 *)&v4[2 * v0 + 208]];
      if ( v0 == 2 )
      {
        if ( v1[36] < *(_DWORD *)(v17 + 140) )
          v16 = 1;
      }
      else
      {
        v16 = !sub_68D50(v17, v1);
      }
      if ( v16 )
      {
        word_E2F4A = 540;
        word_E2F4C = 48;
        byte_E2F44 |= 1u;
      }
    }
    if ( v37 > -1 && !v16 )
    {
      v18 = dword_EA3E4[*(__int16 *)&v4[2 * v37 + 208]];
      if ( v37 == 2 ? v1[36] < *(_DWORD *)(v18 + 140) : !sub_68D50(v18, v1) )
      {
        byte_E2F44 |= 1u;
        word_E2F4C = 48;
        word_E2F4A = 600;
      }
    }
  }
  if ( v33 == -1 )
  {
    v20 = 1;
    byte_E33D6 |= 1u;
    if ( (byte_E3430 & 0x40) != 0 )
      byte_E3430 |= 1u;
  }
  else
  {
    v20 = 0;
    switch ( v33 )
    {
      case 0:
        byte_E32E6 |= 1u;
        break;
      case 1:
        byte_E3340 |= 1u;
        break;
      case 2:
        byte_E3304 |= 1u;
        break;
      case 3:
        byte_E337C |= 1u;
        break;
      case 5:
        byte_E33B8 |= 1u;
        break;
      case 7:
        byte_E335E |= 1u;
        break;
      case 8:
        byte_E339A |= 1u;
        break;
      case 9:
        byte_E3322 |= 1u;
        break;
      default:
        break;
    }
  }
  if ( dword_18053A > 100 )
  {
    byte_E2C38 |= 1u;
    byte_E2C56 |= 1u;
  }
  if ( v20 )
  {
    v21 = 1;
    v22 = (char *)&unk_E2A92;
    while ( v21 <= dword_180516 )
    {
      if ( (v22[3] & 4) != 0 )
        v22[2] &= ~1u;
      ++v21;
      v22 += 30;
    }
  }
  if ( (word_18054E & 4) != 0 )
  {
    v23 = 1;
    v24 = (char *)&unk_E2A92;
    while ( v23 <= dword_180516 )
    {
      v25 = v24[2];
      if ( (v25 & 0x20) != 0 )
        v24[2] = v25 & 0xFE;
      ++v23;
      v24 += 30;
    }
  }
  result = dword_D41A0;
  if ( !*(_BYTE *)(dword_D41A0 + 8590) )
  {
    v27 = 1;
    v28 = (char *)&unk_E2A92;
    while ( v27 <= dword_180516 )
    {
      if ( (v28[3] & 2) != 0 )
        v28[2] &= ~1u;
      ++v27;
      v28 += 30;
    }
  }
  return result;
}
// 88009: variable 'v31' is possibly undefined
// 8806B: variable 'v32' is possibly undefined
// 880D9: variable 'v30' is possibly undefined
// D41A0: using guessed type int dword_D41A0;
// E2AB8: using guessed type __int16 word_E2AB8;
// E2ABA: using guessed type __int16 word_E2ABA;
// E2AD0: using guessed type char byte_E2AD0;
// E2AEE: using guessed type char byte_E2AEE;
// E2B0C: using guessed type char byte_E2B0C;
// E2B2A: using guessed type char byte_E2B2A;
// E2B48: using guessed type char byte_E2B48;
// E2B66: using guessed type char byte_E2B66;
// E2B84: using guessed type char byte_E2B84;
// E2BA2: using guessed type char byte_E2BA2;
// E2BA8: using guessed type __int16 word_E2BA8;
// E2BAA: using guessed type __int16 word_E2BAA;
// E2BC0: using guessed type char byte_E2BC0;
// E2BC6: using guessed type __int16 word_E2BC6;
// E2BC8: using guessed type __int16 word_E2BC8;
// E2BDE: using guessed type char byte_E2BDE;
// E2BE4: using guessed type __int16 word_E2BE4;
// E2BE6: using guessed type __int16 word_E2BE6;
// E2BFC: using guessed type char byte_E2BFC;
// E2C1A: using guessed type char byte_E2C1A;
// E2C38: using guessed type char byte_E2C38;
// E2C56: using guessed type char byte_E2C56;
// E2C74: using guessed type char byte_E2C74;
// E2C86: using guessed type int dword_E2C86;
// E2E96: using guessed type __int16 word_E2E96;
// E2E98: using guessed type __int16 word_E2E98;
// E2EEA: using guessed type char byte_E2EEA;
// E2F08: using guessed type char byte_E2F08;
// E2F26: using guessed type char byte_E2F26;
// E2F2C: using guessed type __int16 word_E2F2C;
// E2F2E: using guessed type __int16 word_E2F2E;
// E2F44: using guessed type char byte_E2F44;
// E2F4A: using guessed type __int16 word_E2F4A;
// E2F4C: using guessed type __int16 word_E2F4C;
// E2F62: using guessed type char byte_E2F62;
// E2F68: using guessed type __int16 word_E2F68;
// E2F6A: using guessed type __int16 word_E2F6A;
// E32E6: using guessed type char byte_E32E6;
// E3304: using guessed type char byte_E3304;
// E3322: using guessed type char byte_E3322;
// E3340: using guessed type char byte_E3340;
// E335E: using guessed type char byte_E335E;
// E337C: using guessed type char byte_E337C;
// E339A: using guessed type char byte_E339A;
// E33B8: using guessed type char byte_E33B8;
// E33D6: using guessed type char byte_E33D6;
// E3430: using guessed type char byte_E3430;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// 180516: using guessed type int dword_180516;
// 18053A: using guessed type int dword_18053A;
// 18054E: using guessed type __int16 word_18054E;

//----- (00088450) --------------------------------------------------------
int sub_88450()
{
  int v0; // ebx
  int v1; // edx
  _DWORD *v2; // eax
  int v3; // ecx
  int v4; // edi

  if ( word_180538 )
  {
    v1 = word_180538;
    word_180538 = 0;
  }
  else
  {
    v0 = 6;
    v1 = 0;
    while ( v0 >= 0 && !v1 )
    {
      v2 = &unk_E2A92;
      v3 = 0;
      v4 = 0;
      while ( v3 < dword_180516 )
      {
        if ( (*((_BYTE *)v2 + 2) & 1) != 0 && v0 == *((char *)v2 + 29) && v2[4] - v2[6] > 0 && v2[4] - v2[6] > v4 )
        {
          v1 = v3 + 1;
          v4 = v2[4] - v2[6];
        }
        ++v3;
        v2 = (_DWORD *)((char *)v2 + 30);
      }
      --v0;
    }
  }
  return v1;
}
// 180516: using guessed type int dword_180516;
// 180538: using guessed type __int16 word_180538;

//----- (000884D0) --------------------------------------------------------
void __cdecl sub_884D0(int a1, __int16 a2, int a3, char a4, char a5)
{
  int i; // eax
  char v6; // dl

  if ( a1 )
  {
    dword_18052A = word_E2A7A[15 * a1];
    byte_180553 = a4;
    word_180536 = a1;
    LOBYTE(word_18054E) = word_18054E | 8;
    byte_180551 = a5;
    dword_180526 = 0;
    byte_180550 = a2;
    for ( i = 0; i < a2; *((_WORD *)&dword_18053A + i + 1) = *(_WORD *)(a3 + 2 * i - 2) )
      ++i;
    v6 = byte_E2A76[30 * a1] | 3;
    byte_E2A76[30 * a1] = v6;
    if ( (v6 & 8) != 0 )
    {
      LOBYTE(word_18054E) = word_18054E | 0x20;
    }
    else if ( (v6 & 0x10) != 0 )
    {
      HIBYTE(word_18054E) |= 1u;
    }
  }
}
// E2A7A: using guessed type __int16 word_E2A7A[];
// 180526: using guessed type int dword_180526;
// 18052A: using guessed type int dword_18052A;
// 180536: using guessed type __int16 word_180536;
// 18053A: using guessed type int dword_18053A;
// 18054E: using guessed type __int16 word_18054E;
// 180550: using guessed type char byte_180550;
// 180551: using guessed type char byte_180551;
// 180553: using guessed type char byte_180553;

//----- (00088580) --------------------------------------------------------
char *sub_88580()
{
  int v0; // edx
  char *result; // eax

  v0 = 1;
  for ( result = (char *)&unk_E2A92; v0 <= dword_180516; result += 30 )
  {
    if ( *(_WORD *)result >= 2u && (*(_WORD *)result <= 2u || *(_WORD *)result == 8) )
    {
      result[2] &= 0xA7u;
      if ( *((_DWORD *)result + 3) )
      {
        if ( (result[2] & 2) != 0 )
          HIBYTE(word_18054E) &= ~2u;
        else
          *((_DWORD *)result + 3) = 0;
      }
    }
    ++v0;
  }
  return result;
}
// 180516: using guessed type int dword_180516;
// 18054E: using guessed type __int16 word_18054E;

//----- (000885E0) --------------------------------------------------------
char __cdecl sub_885E0(int a1, __int16 a2, __int16 a3, unsigned __int16 a4)
{
  signed int v4; // eax
  int v5; // edx
  int v6; // ebx
  char v7; // al
  char v8; // dl
  char v9; // dh
  char v11; // [esp+0h] [ebp-4h]

  LOBYTE(v4) = dword_D41A4;
  v5 = 0;
  if ( *(_BYTE *)(dword_D41A4 + 10) )
  {
    LOBYTE(v4) = a4;
    if ( (byte_E2A76[30 * (__int16)a4] & 8) == 0 )
    {
      if ( (word_180660 & 1) != 0 )
      {
        a2 *= 2;
        a3 *= 2;
      }
      LOBYTE(v4) = a4;
      if ( (byte_E2A76[30 * (__int16)a4] & 2) != 0 )
      {
        if ( a1 == *(int *)((char *)&dword_E2A80 + 30 * (__int16)a4) && (word_18054E & 0x20) == 0 )
        {
          v8 = byte_E2A76[30 * (__int16)a4] | 0x10;
          word_E2A7C[15 * (__int16)a4] = a2;
          byte_E2A76[30 * (__int16)a4] = v8;
          LOBYTE(v4) = a3;
          v9 = HIBYTE(word_18054E) | 2;
          word_E2A7E[15 * (__int16)a4] = a3;
          HIBYTE(word_18054E) = v9;
        }
      }
      else
      {
        v11 = 0;
        if ( !a1
          || (v4 = sub_58490(
                     (_WORD *)(dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12)
                                                               + dword_D41A0
                                                               + 11240)]
                             + 76),
                     (_WORD *)(a1 + 76)),
              v5 = v4,
              !*(int *)((char *)&dword_E2A80 + 30 * (__int16)a4))
          || v4 < *(int *)((char *)&dword_E2A88 + 30 * (__int16)a4) )
        {
          v11 = 1;
        }
        if ( v11 )
        {
          v6 = 15 * (__int16)a4;
          *(int *)((char *)&dword_E2A80 + 2 * v6) = a1;
          v7 = byte_E2A76[30 * (__int16)a4];
          *(int *)((char *)&dword_E2A88 + 2 * v6) = v5;
          LOBYTE(v4) = v7 | 0x10;
          byte_E2A76[2 * v6] = v4;
        }
      }
    }
    if ( a4 >= 0x51u && a4 <= 0x53u )
    {
      LOBYTE(v4) = a4;
      byte_E2A76[30 * (__int16)a4] |= 0x40u;
    }
  }
  return v4;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E2A7C: using guessed type __int16 word_E2A7C[];
// E2A7E: using guessed type __int16 word_E2A7E[];
// E2A80: using guessed type int dword_E2A80;
// E2A88: using guessed type int dword_E2A88;
// EA3E4: using guessed type int dword_EA3E4[];
// 18054E: using guessed type __int16 word_18054E;
// 180660: using guessed type __int16 word_180660;

//----- (00088740) --------------------------------------------------------
void __cdecl sub_88740(int a1, __int16 a2, __int16 a3)
{
  int v3; // esi
  int v4; // edx
  unsigned __int8 v5; // al
  unsigned __int8 v6; // al
  unsigned __int8 v7; // al
  unsigned __int8 v8; // al
  char v9; // cl
  int v10; // eax
  unsigned __int8 v11; // al
  signed int v12; // eax
  int v13; // esi
  char v14; // dl
  char v15; // dh
  char v16; // bl
  char v17; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( (word_18054E & 1) != 0 )
    return;
  v4 = dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v5 = *(_BYTE *)(a1 + 63);
  if ( v5 < 5u )
  {
    if ( v5 >= 2u )
    {
      if ( v5 <= 2u )
      {
        v6 = *(_BYTE *)(a1 + 64);
        if ( v6 )
        {
          if ( v6 <= 1u )
          {
            v3 = 27;
          }
          else if ( v6 == 2 )
          {
            v3 = 22;
          }
        }
      }
      else if ( v5 == 3 )
      {
        v11 = *(_BYTE *)(a1 + 64);
        if ( v11 < 2u )
        {
          if ( v11 == 1 )
            v3 = 28;
        }
        else if ( v11 <= 2u )
        {
          v3 = (*(_WORD *)(a1 + 26) != *(_WORD *)(v4 + 26)) + 24;
        }
        else if ( v11 == 3 )
        {
          if ( *(_WORD *)(a1 + 26) == *(_WORD *)(v4 + 26) )
            v3 = 23;
          else
            v3 = 26;
        }
      }
    }
    goto LABEL_48;
  }
  if ( v5 > 5u )
  {
    if ( v5 >= 0xAu )
    {
      if ( v5 <= 0xAu )
      {
        if ( *(_BYTE *)(a1 + 64) == 39 && *(unsigned __int16 *)(a1 + 148) != *(__int16 *)(v4 + 26) )
          v3 = 18;
      }
      else if ( v5 == 15 && (*(_BYTE *)(a1 + 12) & 1) == 0 )
      {
        v3 = 20;
      }
    }
    goto LABEL_48;
  }
  if ( *(_WORD *)(a1 + 26) != *(_WORD *)(v4 + 26) )
  {
    v7 = *(_BYTE *)(a1 + 64);
    if ( v7 < 0xCu )
      goto LABEL_30;
    if ( v7 > 0xEu )
    {
      if ( v7 == 22 )
      {
        if ( *(_BYTE *)(a1 + 69) != 0xB4 && *(unsigned __int16 *)(a1 + 148) != *(__int16 *)(v4 + 26) )
          v3 = 18;
        goto LABEL_48;
      }
LABEL_30:
      v8 = *(_BYTE *)(a1 + 69);
      if ( v8 < 0xE8u || v8 > 0xEAu )
      {
        v9 = *(_BYTE *)(a1 + 73);
        v10 = 1;
        if ( (v9 == 14 || v9 == 13) && *(unsigned __int16 *)(a1 + 40) == *(__int16 *)(v4 + 26) )
          v10 = 0;
        if ( v10 )
          v3 = 19;
      }
    }
  }
LABEL_48:
  if ( v3 )
  {
    if ( (word_180660 & 1) != 0 )
    {
      a2 *= 2;
      a3 *= 2;
    }
    if ( (byte_E2A76[30 * v3] & 2) != 0 )
    {
      if ( a1 == *(int *)((char *)&dword_E2A80 + 30 * v3) )
      {
        v15 = HIBYTE(word_18054E);
        if ( (word_18054E & 0x100) == 0 )
        {
          v16 = byte_E2A76[30 * v3] | 8;
          word_E2A7C[15 * v3] = a2;
          byte_E2A76[30 * v3] = v16;
          word_E2A7E[15 * v3] = a3;
          HIBYTE(word_18054E) = v15 | 2;
        }
      }
    }
    else
    {
      v17 = 0;
      v12 = sub_58490((_WORD *)(v4 + 76), (_WORD *)(a1 + 76));
      if ( !*(int *)((char *)&dword_E2A80 + 30 * v3) || v12 < *(int *)((char *)&dword_E2A88 + 30 * v3) && v12 > 1024 )
        v17 = 1;
      if ( v17 )
      {
        v13 = 15 * v3;
        *(int *)((char *)&dword_E2A88 + 2 * v13) = v12;
        v14 = byte_E2A76[2 * v13];
        *(int *)((char *)&dword_E2A80 + 2 * v13) = a1;
        byte_E2A76[2 * v13] = v14 | 8;
      }
    }
  }
}
// D41A0: using guessed type int dword_D41A0;
// E2A7C: using guessed type __int16 word_E2A7C[];
// E2A7E: using guessed type __int16 word_E2A7E[];
// E2A80: using guessed type int dword_E2A80;
// E2A88: using guessed type int dword_E2A88;
// EA3E4: using guessed type int dword_EA3E4[];
// 18054E: using guessed type __int16 word_18054E;
// 180660: using guessed type __int16 word_180660;

//----- (000889F0) --------------------------------------------------------
int __cdecl sub_889F0(int a1)
{
  int result; // eax

  result = a1;
  if ( (unsigned __int16)a1 < 0x15u )
  {
    if ( (unsigned __int16)a1 < 0x12u )
    {
      if ( (_WORD)a1 == 15 )
      {
        byte_E2C71 = 6;
        return result;
      }
      goto LABEL_22;
    }
    if ( (unsigned __int16)a1 > 0x12u )
    {
      if ( (_WORD)a1 != 19 )
        goto LABEL_22;
      goto LABEL_19;
    }
LABEL_18:
    LOBYTE(word_18054E) = word_18054E | 0x40;
    return result;
  }
  if ( (unsigned __int16)a1 <= 0x15u )
    goto LABEL_18;
  if ( (unsigned __int16)a1 < 0x1Cu )
  {
    if ( (unsigned __int16)a1 < 0x19u || (unsigned __int16)a1 > 0x1Au )
      goto LABEL_22;
    goto LABEL_19;
  }
  if ( (unsigned __int16)a1 <= 0x1Cu )
    goto LABEL_19;
  if ( (unsigned __int16)a1 < 0x52u )
  {
LABEL_22:
    if ( word_E2A74[15 * (__int16)a1] == 7 )
    {
      switch ( *(_BYTE *)(dword_D41A0
                        + 10 * (unsigned __int8)byte_3659D[11 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0]
                        + 222540) )
      {
        case 0:
          LOBYTE(word_18054E) = word_18054E | 0x40;
          break;
        case 1:
        case 2:
        case 3:
        case 7:
        case 8:
        case 9:
          LOBYTE(word_18054E) = word_18054E | 0x80;
          break;
        default:
          break;
      }
    }
    if ( (_WORD)a1 == 79 )
    {
      byte_E2ACD = 6;
      byte_E340F = 6;
    }
    return result;
  }
  if ( (unsigned __int16)a1 <= 0x52u )
  {
LABEL_19:
    LOBYTE(word_18054E) = word_18054E | 0x80;
    return result;
  }
  if ( (_WORD)a1 != 93 )
    goto LABEL_22;
  if ( *(_WORD *)(*(_DWORD *)(dword_EA3E4[*(unsigned __int16 *)(dword_D41A0
                                                              + 2124 * *(__int16 *)(dword_D41A0 + 12)
                                                              + 11240)]
                            + 164)
                + 58) )
    word_180538 = 94;
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// E2A74: using guessed type __int16 word_E2A74[];
// E2ACD: using guessed type char byte_E2ACD;
// E2C71: using guessed type char byte_E2C71;
// E340F: using guessed type char byte_E340F;
// EA3E4: using guessed type int dword_EA3E4[];
// 180538: using guessed type __int16 word_180538;
// 18054E: using guessed type __int16 word_18054E;

//----- (00088B20) --------------------------------------------------------
int sub_88B20()
{
  int result; // eax
  int v1; // edx
  _WORD *v2; // ebx

  result = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 10) )
  {
    v1 = 1;
    v2 = &unk_E2A92;
    while ( v1 <= dword_180516 )
    {
      if ( *v2 == 7 )
      {
        result = 15 * v1;
        byte_E2A91[30 * v1] = 6;
      }
      ++v1;
      v2 += 15;
    }
  }
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// 180516: using guessed type int dword_180516;

//----- (00088B60) --------------------------------------------------------
int sub_88B60()
{
  int result; // eax

  result = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 10) )
    byte_E2F5F = 6;
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// E2F5F: using guessed type char byte_E2F5F;

//----- (00088BA0) --------------------------------------------------------
char sub_88BA0()
{
  char result; // al
  int v1; // ebx

  result = -1;
  if ( *(_BYTE *)(dword_D41A4 + 10) )
  {
    v1 = dword_D41A0 + 11 * *(__int16 *)(dword_D41A0 + 12);
    if ( !byte_3659C[v1] )
      result = *(_BYTE *)(dword_D41A0 + 10 * (unsigned __int8)byte_3659D[v1] + 222540);
    if ( result == -1 )
    {
      word_180538 = 80;
LABEL_15:
      dword_18051E = 8;
      return sub_87C10();
    }
    else
    {
      switch ( result )
      {
        case 0:
          word_180538 = 72;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        case 1:
          word_180538 = 75;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        case 2:
          word_180538 = 73;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        case 3:
          word_180538 = 77;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        case 5:
          word_180538 = 79;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        case 7:
          word_180538 = 76;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        case 8:
          word_180538 = 78;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        case 9:
          word_180538 = 74;
          dword_18051E = 8;
          result = sub_87C10();
          break;
        default:
          goto LABEL_15;
      }
    }
  }
  return result;
}
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// 18051E: using guessed type int dword_18051E;
// 180538: using guessed type __int16 word_180538;

//----- (00088D00) --------------------------------------------------------
int sub_88D00()
{
  int result; // eax

  result = dword_D41A4;
  if ( *(_BYTE *)(dword_D41A4 + 10) )
    word_180538 = 93;
  return result;
}
// D41A4: using guessed type int dword_D41A4;
// 180538: using guessed type __int16 word_180538;

//----- (00088D40) --------------------------------------------------------
char sub_88D40()
{
  unsigned __int16 v0; // dx
  int v1; // ebx
  int i; // eax
  int v3; // edx
  int v4; // ebx
  int v5; // ecx
  int v6; // edx
  int v7; // ebx
  int v8; // edi
  int v9; // esi
  int v10; // edi
  _BOOL1 v11; // cl
  char v12; // al
  int v16; // [esp+0h] [ebp-2h]
  __int16 v17[4]; // [esp+Ch] [ebp+Ah] BYREF
  unsigned int v18; // [esp+14h] [ebp+12h]
  int j; // [esp+18h] [ebp+16h]
  int v20; // [esp+1Ch] [ebp+1Ah]
  char *v21; // [esp+20h] [ebp+1Eh]
  int v22; // [esp+24h] [ebp+22h]
  int v23; // [esp+28h] [ebp+26h]
  int v24; // [esp+2Ch] [ebp+2Ah]
  int v25; // [esp+30h] [ebp+2Eh]
  int v26; // [esp+34h] [ebp+32h]
  int v27; // [esp+38h] [ebp+36h]
  int v28; // [esp+3Ch] [ebp+3Ah]
  char *v29; // [esp+40h] [ebp+3Eh]
  int v30; // [esp+44h] [ebp+42h]
  int v31; // [esp+48h] [ebp+46h]
  int v32; // [esp+4Ch] [ebp+4Ah]
  int v33; // [esp+50h] [ebp+4Eh]
  int *v34; // [esp+54h] [ebp+52h]
  int v35; // [esp+58h] [ebp+56h]
  int k; // [esp+5Ch] [ebp+5Ah]
  char *v37; // [esp+60h] [ebp+5Eh]
  int v38; // [esp+64h] [ebp+62h]
  int v39; // [esp+68h] [ebp+66h]
  int v40; // [esp+6Ch] [ebp+6Ah]
  int v41; // [esp+70h] [ebp+6Eh]
  int v42; // [esp+74h] [ebp+72h]
  char v43; // [esp+78h] [ebp+76h]
  char v44; // [esp+7Ch] [ebp+7Ah]
  _BOOL1 v45; // [esp+80h] [ebp+7Eh]

  v38 = 0;
  v44 = 0;
  v40 = 0;
  v32 = 0;
  v34 = (int *)dword_EA3E4[*(unsigned __int16 *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11240)];
  v0 = *(_WORD *)(v34[41] + 58);
  if ( v0 )
    v38 = dword_EA3E4[v0];
  v1 = 0;
  v28 = v34[41] + 611;
  for ( i = 0; i < 26; ++i )
  {
    v3 = *(_WORD *)(v28 + 2 * i + 208) != 0;
    v1 += v3;
  }
  if ( v1 )
  {
    if ( (word_180660 & 1) != 0 )
      v4 = 400;
    else
      v4 = 480;
    v5 = *(unsigned __int8 *)(dword_EA3DC + 539);
    v6 = *(unsigned __int8 *)(dword_EA3DC + 532);
    v30 = v4 - 2 * v5;
    v24 = v6;
    v20 = *(unsigned __int8 *)(dword_EA3DC + 538);
    v7 = v5;
    v39 = (unsigned __int8)byte_D94FF[*(char *)(v28 + 501)];
    v45 = *(_WORD *)(v28 + 2 * v39 + 208) != 0;
    if ( *(_BYTE *)(dword_D41A0 + 196308) != 2 && v39 == 25 )
      v45 = 0;
    v33 = *(char *)(v39 + v28 + 442);
    v8 = *(char *)(v28 + 501);
    v37 = &byte_DA818[80 * v39 + 2];
    v41 = 13;
    v16 = *(unsigned __int8 *)(dword_EA3DC + 982);
    v31 = v20 / 2 + v20 * (v8 % 13) + v24;
    v41 = 13;
    v9 = *(unsigned __int8 *)(dword_EA3DC + 983);
    v35 = v30 - v9;
    v27 = v5 / 2 + v5 * (v8 / 13) + v30;
    v10 = v31 - 3 * v16 / 2;
    if ( v10 <= 640 - 3 * v16 )
    {
      if ( v10 < 0 )
        v10 = 0;
    }
    else
    {
      v10 = 640 - 3 * v16;
    }
    v11 = 0;
    v23 = v10 + 3 * v16 / 2;
    for ( j = 0; j < 8 && !v11; ++j )
    {
      v43 = 2;
      v32 = 1;
      v22 = v9 / 2;
      v26 = v16 / 2;
      v25 = v9 / 2 + v35;
      switch ( byte_180554 )
      {
        case 0:
          if ( v45 )
          {
            v40 = 85;
            v43 = 3;
            v17[0] = *((_WORD *)v37 + 10);
            v17[1] = *((_WORD *)v37 + 23);
            v17[2] = *((_WORD *)v37 + 36);
            word_E3472 = v23;
            word_E3474 = v35;
            v11 = 1;
            v12 = *(_BYTE *)(v28 + 502);
            v32 = 3;
            v44 = v12;
          }
          break;
        case 1:
          if ( v45 )
          {
            v40 = 69;
            v17[0] = word_E328E;
            v11 = 1;
            word_E3292 = v10 + 33;
            if ( v33 > 0 )
              word_E3292 = v10 + 33 + v16;
            v42 = v35 + 29;
            v41 = v40;
            word_E2A7E[15 * v40] = v35 + 29;
          }
          break;
        case 2:
          if ( v45 )
          {
            for ( k = 0; k < 3 && !v11; ++k )
            {
              v29 = &v37[26 * k];
              if ( *((_DWORD *)v29 + 2) && (!v38 || *(_DWORD *)(v38 + 144) < *((_DWORD *)v29 + 2)) )
              {
                v40 = 70;
                v17[0] = word_E32AC;
                v41 = v10 + k * v16;
                word_E32B0 = v41 + v16 / 2;
                v11 = 1;
                word_E32B2 = v35 + v9 / 2;
              }
            }
          }
          break;
        case 3:
          if ( v45 && v33 )
          {
            v40 = 71;
            v17[0] = word_E32CA;
            word_E32CE = v26 + v10 + v33 * v16;
            v11 = 1;
            word_E32D0 = v25;
          }
          break;
        case 4:
          if ( v45 )
          {
            v21 = &v37[26 * *(char *)(v28 + 502)];
            if ( !*((_DWORD *)v21 + 2) || v38 && *(_DWORD *)(v38 + 144) >= *((_DWORD *)v21 + 2) )
            {
              v40 = 40;
              v17[0] = word_E2F28;
              word_E2F2C = v31;
              v11 = 1;
              word_E2F2E = v27 + ((v7 - (__CFSHL__(v7 >> 31, 2) + 4 * (v7 >> 31))) >> 2);
            }
          }
          break;
        case 5:
          if ( v45 )
          {
            v40 = 42;
            v17[0] = word_E2F64;
            v41 = *(char *)(v28 + 502);
            word_E2F68 = v26 + v10 + v41 * v16;
            v11 = 1;
            word_E2F6A = v25;
          }
          break;
        case 6:
          if ( v45 )
          {
            v18 = dword_EA3E4[*(__int16 *)(v28 + 2 * v39 + 208)];
            if ( v18 > dword_EA3E4[0] )
            {
              if ( v39 == 2 )
              {
                if ( v34[36] < *(_DWORD *)(v18 + 140) )
                  v11 = 1;
              }
              else
              {
                v11 = !sub_68D50(v18, v34);
              }
              if ( v11 )
              {
                v40 = 41;
                v17[0] = word_E2F46;
                word_E2F4A = v31;
                word_E2F4C = v27 + ((v7 - (__CFSHL__(v7 >> 31, 2) + 4 * (v7 >> 31))) >> 2);
              }
            }
          }
          break;
        default:
          break;
      }
      if ( (unsigned __int8)++byte_180554 > 7u )
        byte_180554 = 0;
    }
    if ( v40 )
      sub_884D0(v40, v32, (int)v17, v43, v44);
  }
  return v40;
}
// D41A0: using guessed type int dword_D41A0;
// E2A7E: using guessed type __int16 word_E2A7E[];
// E2F28: using guessed type __int16 word_E2F28;
// E2F2C: using guessed type __int16 word_E2F2C;
// E2F2E: using guessed type __int16 word_E2F2E;
// E2F46: using guessed type __int16 word_E2F46;
// E2F4A: using guessed type __int16 word_E2F4A;
// E2F4C: using guessed type __int16 word_E2F4C;
// E2F64: using guessed type __int16 word_E2F64;
// E2F68: using guessed type __int16 word_E2F68;
// E2F6A: using guessed type __int16 word_E2F6A;
// E328E: using guessed type __int16 word_E328E;
// E3292: using guessed type __int16 word_E3292;
// E32AC: using guessed type __int16 word_E32AC;
// E32B0: using guessed type __int16 word_E32B0;
// E32B2: using guessed type __int16 word_E32B2;
// E32CA: using guessed type __int16 word_E32CA;
// E32CE: using guessed type __int16 word_E32CE;
// E32D0: using guessed type __int16 word_E32D0;
// E3472: using guessed type __int16 word_E3472;
// E3474: using guessed type __int16 word_E3474;
// EA3DC: using guessed type int dword_EA3DC;
// EA3E4: using guessed type int dword_EA3E4[];
// 180554: using guessed type char byte_180554;
// 180660: using guessed type __int16 word_180660;

//----- (00089360) --------------------------------------------------------
char sub_89360()
{
  char v0; // al
  int v1; // ebx
  int v2; // eax
  int v4; // [esp+0h] [ebp-4h] BYREF

  v0 = 0;
  v1 = 0;
  if ( byte_180557 )
  {
    byte_180557 = 0;
    if ( byte_180558 && *(_WORD *)(dword_D41A0 + 14) > 1u )
    {
      word_E35BC = word_18054A;
      v1 = 96;
      word_E35BE = word_18054C;
    }
    else
    {
      v0 = 1;
    }
  }
  else
  {
    v0 = 1;
    byte_180557 = 1;
  }
  if ( v0 )
  {
    v1 = 95;
    word_E359E = word_180546;
    byte_180558 = 0;
    word_E35A0 = word_180548;
  }
  if ( v1 )
  {
    v2 = 15 * v1;
    LOWORD(v2) = word_E2A78[15 * v1];
    v4 = v2;
    sub_884D0(v1, 1, (int)&v4, 2, 0);
  }
  return v1;
}
// D41A0: using guessed type int dword_D41A0;
// E2A78: using guessed type __int16 word_E2A78[];
// E359E: using guessed type __int16 word_E359E;
// E35A0: using guessed type __int16 word_E35A0;
// E35BC: using guessed type __int16 word_E35BC;
// E35BE: using guessed type __int16 word_E35BE;
// 180546: using guessed type __int16 word_180546;
// 180548: using guessed type __int16 word_180548;
// 18054A: using guessed type __int16 word_18054A;
// 18054C: using guessed type __int16 word_18054C;
// 180557: using guessed type char byte_180557;
// 180558: using guessed type char byte_180558;

//----- (00089420) --------------------------------------------------------
int __cdecl sub_89420(_WORD *a1, const char *a2)
{
  int result; // eax
  unsigned int v3; // kr04_4
  signed int v4; // ecx
  int v5; // ebx
  const char *v6; // ecx
  const char *v7; // edx
  const char *i; // ecx
  __int16 v9; // [esp+4h] [ebp-4h]

  result = 0;
  v3 = strlen(a2) + 1;
  v9 = 1;
  a1[2] = 0;
  a1[3] = 0;
  if ( v3 != 1 )
  {
    HIWORD(result) = 0;
    v4 = (__int16)a1[8] * strlen(a2);
    v5 = (__int16)a1[6];
    if ( v4 <= v5 )
    {
      a1[2] = v4;
    }
    else
    {
      result = v5 / 2;
      if ( v4 % v5 < v5 / 2 )
      {
        while ( 1 )
        {
          result = v5 / 2;
          if ( v4 % v5 >= v5 / 2 || v5 <= 0 )
            break;
          v5 -= (__int16)a1[8];
        }
      }
      if ( v5 > 0 )
      {
        result = (v5 + (__int16)a1[8] - 1) / (__int16)a1[8];
        v9 = 0;
        v6 = a2;
        v7 = &a2[v3 - 1];
        while ( v6 < v7 )
        {
          for ( i = &v6[result]; *i != 32 && i < v7; --i )
            ;
          v6 = i + 1;
          ++v9;
        }
        a1[2] = v5;
      }
    }
    LOWORD(result) = a1[9];
    a1[3] = result * v9;
  }
  return result;
}

//----- (00089520) --------------------------------------------------------
int __cdecl sub_89520(__int16 *a1)
{
  int v1; // edi
  int v2; // ecx
  int v3; // esi
  int result; // eax
  int v5; // [esp+0h] [ebp-Ch]
  int v6; // [esp+4h] [ebp-8h]
  int v7; // [esp+8h] [ebp-4h]

  v5 = a1[2];
  v1 = a1[3];
  v2 = *a1 - v5 / 2;
  v3 = a1[1] - v1 / 2;
  if ( v2 < a1[10] )
    v2 = a1[10];
  if ( v3 < a1[12] )
    v3 = a1[12];
  v7 = a1[11];
  if ( v2 + v5 >= v7 )
    LOWORD(v2) = v7 - v5;
  v6 = a1[13];
  if ( v3 + v1 >= v6 )
    v3 = v6 - v1;
  *a1 = v2 + a1[2] / 2;
  a1[4] = v2;
  a1[5] = v3;
  result = v3 + v1 / 2;
  a1[1] = result;
  return result;
}

//----- (000895D0) --------------------------------------------------------
int __cdecl sub_895D0(int a1, const char *a2)
{
  unsigned int v2; // edi
  int result; // eax
  char *i; // ebx
  char *v5; // eax
  char *v6; // edx
  char v7; // cl
  int v8; // ebx
  __int16 v9; // [esp-Ch] [ebp-1Eh]
  unsigned __int8 v10; // [esp-4h] [ebp-16h]
  char v11[128]; // [esp+0h] [ebp-12h] BYREF
  int v12; // [esp+80h] [ebp+6Eh]
  int v13; // [esp+84h] [ebp+72h]
  unsigned int v14; // [esp+88h] [ebp+76h]

  v14 = (unsigned int)a2;
  v13 = *(__int16 *)(a1 + 10);
  v2 = (unsigned int)&a2[strlen(a2)];
  result = *(__int16 *)(a1 + 4) / *(__int16 *)(a1 + 16);
  v12 = result;
  if ( v2 > (unsigned int)a2 )
  {
    do
    {
      for ( i = (char *)(v12 + v14); *i != 32 && (unsigned int)i < v2; --i )
        ;
      v5 = (char *)v14;
      v6 = v11;
      while ( v5 < i )
      {
        ++v6;
        v7 = *v5++;
        *(v6 - 1) = v7;
      }
      *v6 = 0;
      v10 = *(_BYTE *)(a1 + 48);
      v9 = *(_WORD *)(a1 + 8);
      v14 = (unsigned int)(i + 1);
      v8 = v13;
      sub_2BC10(v11, v9, v13, v10);
      result = *(__int16 *)(a1 + 18);
      v13 = result + v8;
    }
    while ( v2 > v14 );
  }
  return result;
}

//----- (00089690) --------------------------------------------------------
int __cdecl sub_89690(__int16 *a1)
{
  int v1; // edi
  int v2; // esi
  __int16 v3; // bx
  int result; // eax
  int i; // ebx
  __int16 v6; // [esp+0h] [ebp-28h]
  __int16 v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  __int16 v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]
  int v12; // [esp+20h] [ebp-8h]
  __int16 v13; // [esp+24h] [ebp-4h]

  v10 = *(unsigned __int8 *)(dword_EA3DC + 1042);
  v11 = *(unsigned __int8 *)(dword_EA3DC + 1036);
  v6 = *(unsigned __int8 *)(dword_EA3DC + 1031);
  v9 = *(unsigned __int8 *)(dword_EA3DC + 1037);
  v1 = a1[18] - v11;
  v2 = a1[20] + a1[18];
  v13 = a1[19] - *(unsigned __int8 *)(dword_EA3DC + 1043);
  v7 = a1[19] + a1[21];
  v8 = a1[3] / a1[9];
  sub_2BB40(a1[18] - v11, v13, dword_EA3DC + 1026);
  sub_2BB40(v2, v13, dword_EA3DC + 1026);
  v12 = 0;
  v3 = v6 + v13;
  while ( v12 < v8 )
  {
    sub_2BB40(v1, v3, dword_EA3DC + 1032);
    sub_2BB40(v2, v3, dword_EA3DC + 1032);
    v3 += v9;
    ++v12;
  }
  sub_2BB40(v1, v3, dword_EA3DC + 1026);
  result = sub_2BB40(v2, v3, dword_EA3DC + 1026);
  for ( i = v1 + v11; i < v2; i += v10 )
  {
    sub_2BB40(i, v13, dword_EA3DC + 1038);
    result = sub_2BB40(i, v7, dword_EA3DC + 1038);
  }
  return result;
}
// EA3DC: using guessed type int dword_EA3DC;

//----- (00089830) --------------------------------------------------------
int __cdecl sub_89830(_WORD *a1)
{
  int v1; // eax
  __int16 v2; // si
  int result; // eax
  int v4; // [esp+0h] [ebp-4h]

  v1 = (__int16)a1[14];
  v2 = v1 + 25;
  v4 = (__int16)a1[15];
  if ( (__int16)a1[11] < v1 + 135 )
    v2 = v1 - 135;
  result = v4 - 94;
  if ( v4 - 94 + 28 < (__int16)a1[12] )
    result = v4 + 66;
  *a1 = v2;
  a1[1] = result;
  return result;
}

//----- (000898A0) --------------------------------------------------------
_WORD *__cdecl sub_898A0(_WORD *a1)
{
  _WORD *result; // eax
  int v2; // ebx
  int v3; // edx
  __int16 v4; // dx
  int v5; // edx
  int v6; // ebx
  __int16 v7; // dx

  result = a1;
  v2 = (__int16)a1[18];
  v3 = (__int16)a1[14];
  if ( v3 >= v2 - 30 )
  {
    if ( v3 <= (__int16)a1[20] + v2 + 30 )
      v4 = *a1;
    else
      v4 = a1[20] + a1[18];
  }
  else
  {
    v4 = a1[18] - 2;
  }
  a1[16] = v4;
  v5 = (__int16)a1[19];
  v6 = (__int16)a1[15];
  if ( v6 >= v5 - 30 )
  {
    if ( v6 > (__int16)a1[21] + v5 + 30 )
    {
      a1[17] = a1[21] + a1[19];
      return result;
    }
    v7 = a1[1];
  }
  else
  {
    v7 = a1[19] - 2;
  }
  a1[17] = v7;
  return result;
}

//----- (00089920) --------------------------------------------------------
int __cdecl sub_89920(_WORD *a1, __int16 a2, int a3)
{
  int v3; // edx
  signed int v4; // ebx
  int result; // eax
  unsigned int v6; // kr04_4
  __int16 v7; // dx

  v3 = 0;
  v4 = 0;
  while ( v3 < a2 )
  {
    result = 0;
    v6 = strlen((const char *)dword_E9C4C[*(__int16 *)(a3 + 2 * v3)]) + 1;
    if ( (int)(v6 - 1) > v4 )
      v4 = v6 - 1;
    ++v3;
  }
  v7 = a1[9];
  a1[2] = a1[8] * v4;
  a1[3] = v7 * a2;
  return result;
}
// E9C4C: using guessed type int dword_E9C4C[];

//----- (00089980) --------------------------------------------------------
int __cdecl sub_89980(__int16 *a1)
{
  __int16 v1; // di
  int v2; // ecx
  __int16 v3; // ax
  int v4; // edx
  __int16 v5; // ax
  int v6; // edx
  int result; // eax
  __int16 v8; // [esp+0h] [ebp-4h]

  v1 = *(unsigned __int8 *)(dword_EA3DC + 1043);
  v2 = *(unsigned __int8 *)(dword_EA3DC + 1037);
  v8 = *(unsigned __int8 *)(dword_EA3DC + 1031);
  v3 = *(unsigned __int8 *)(dword_EA3DC + 1042)
     * (unsigned __int16)((*(unsigned __int8 *)(dword_EA3DC + 1042) - 1 + a1[2] + 8)
                        / *(unsigned __int8 *)(dword_EA3DC + 1042));
  v4 = a1[2];
  a1[20] = v3;
  a1[18] = a1[4] - (v3 - v4) / 2;
  v5 = (v2 - 1 + a1[3]) / v2 * v2 + 2 * (v8 - v1);
  v6 = a1[3];
  a1[21] = v5;
  result = (v5 - v6) / 2;
  a1[19] = a1[5] - result;
  return result;
}
// EA3DC: using guessed type int dword_EA3DC;

//----- (00089A30) --------------------------------------------------------
__int16 __cdecl sub_89A30(_WORD *a1)
{
  __int16 v1; // si
  __int16 result; // ax

  v1 = ((word_180660 & 1) != 0) + 1;
  if ( a1[16] != *a1 || (result = a1[17], result != a1[1]) )
  {
    sub_2BD10(a1[14], a1[15], a1[16], a1[17], byte_E8900[0]);
    return sub_2BD10(a1[14] + v1, a1[15], v1 + a1[16], a1[17], byte_E9800);
  }
  return result;
}
// E9800: using guessed type char byte_E9800;
// 180660: using guessed type __int16 word_180660;

//----- (00089AC0) --------------------------------------------------------
int __cdecl sub_89AC0(_BYTE *a1, int a2)
{
  int result; // eax
  int v3; // eax

  result = a2;
  if ( (unsigned __int16)a2 < 0x5Cu )
    goto LABEL_7;
  if ( (unsigned __int16)a2 <= 0x5Cu )
    return sprintf(a1, "[F1] %s", (const char *)dword_E9C84);
  if ( (_WORD)a2 == 96 )
  {
    v3 = sub_61790((unsigned __int8)byte_180558);
    return sprintf(a1, (const char *)dword_EA1D0, (&off_D93A0)[v3]);
  }
  else
  {
LABEL_7:
    *a1 = 0;
  }
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// D93A0: using guessed type char *off_D93A0;
// E9C84: using guessed type int dword_E9C84;
// EA1D0: using guessed type int dword_EA1D0;
// 180558: using guessed type char byte_180558;

//----- (00089B60) --------------------------------------------------------
int __cdecl sub_89B60(unsigned __int8 a1)
{
  int v1; // esi
  __int16 v2; // ax
  _BOOL1 v3; // zf

  v1 = -1;
  dword_1805AC = 0;
  dword_1805A8 = 0;
  dword_1805A4 = 0;
  dword_180598 = 0;
  dword_180594 = 0;
  dword_180590 = 0;
  dword_1805A0 = 0;
  dword_18059C = 0;
  word_1805C8 = 0;
  switch ( a1 )
  {
    case 1u:
      v1 = sub_8B600((int)&dword_18058C);
      if ( (__int16)v1 != -1 )
        goto LABEL_3;
      goto LABEL_13;
    case 2u:
      if ( (unsigned __int16)sub_75650() )
      {
        v1 = 1;
        printf(aVfxInitialised);
        word_1805C8 = 1;
        v2 = a1;
        dword_1805A0 = 0;
        dword_18059C = 0;
        goto LABEL_12;
      }
      goto LABEL_13;
    case 4u:
      memset(&unk_180560, 0, 44);
      sub_8BB40((int)&unk_180560, 8);
      v3 = byte_180584 == 0;
      goto LABEL_10;
    case 6u:
      memset(&unk_180560, 0, 44);
      v1 = 1;
      v2 = a1;
      goto LABEL_12;
    case 7u:
      v2 = a1;
      v1 = 1;
      goto LABEL_12;
    case 8u:
    case 9u:
LABEL_3:
      word_1805C8 = 1;
      goto LABEL_13;
    case 0xBu:
      memset(&unk_180560, 0, 44);
      sub_8BB40((int)&unk_180560, 4);
      v3 = byte_180584 == 0;
LABEL_10:
      if ( v3 )
        goto LABEL_13;
      sub_8BBE0((int)&unk_180560);
      v1 = 1;
      v2 = a1;
LABEL_12:
      word_1805C2 = v2;
LABEL_13:
      word_1805C2 = a1;
      if ( (__int16)v1 > 0 )
        byte_E36D1 = a1;
      return v1;
    default:
      goto LABEL_13;
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// E36D1: using guessed type char byte_E36D1;
// 180584: using guessed type char byte_180584;
// 18058C: using guessed type _DWORD dword_18058C;
// 180590: using guessed type int dword_180590;
// 180594: using guessed type int dword_180594;
// 180598: using guessed type int dword_180598;
// 18059C: using guessed type int dword_18059C;
// 1805A0: using guessed type int dword_1805A0;
// 1805A4: using guessed type int dword_1805A4;
// 1805A8: using guessed type int dword_1805A8;
// 1805AC: using guessed type int dword_1805AC;
// 1805C2: using guessed type __int16 word_1805C2;
// 1805C8: using guessed type __int16 word_1805C8;

//----- (00089D10) --------------------------------------------------------
int sub_89D10()
{
  unsigned __int8 v1; // al
  int v2; // eax
  int v3; // ecx
  unsigned __int8 v4; // al
  int v5; // ebx
  int v6; // edx
  int v7; // edx
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  unsigned __int8 v17; // al
  int v18; // esi
  int v19; // ebx
  int v20; // ecx
  int v21; // eax
  __int64 v22; // rax
  __int64 v23; // rax
  __int16 v24; // si
  unsigned __int8 v25; // al
  int v26; // edx
  unsigned __int8 v27; // al
  int v28; // edx
  int v29; // edx
  int v30; // eax
  char v31; // ch
  int v32; // edx
  int v33; // edx
  int v34; // edx
  int v35; // ebx
  int v36; // eax
  int v37; // ecx
  int v38; // eax
  int v39; // ecx
  int v40; // eax
  int v41; // esi
  int v42; // eax
  unsigned __int8 v43; // al
  int v44; // esi
  int v45; // ebx
  int v46; // ecx
  char v47[52]; // [esp+0h] [ebp-48h] BYREF
  int v48; // [esp+34h] [ebp-14h] BYREF
  int v49; // [esp+38h] [ebp-10h] BYREF
  int v50; // [esp+3Ch] [ebp-Ch] BYREF
  int v51; // [esp+40h] [ebp-8h] BYREF
  int v52; // [esp+44h] [ebp-4h]

  v52 = -1;
  if ( !byte_E36D0 )
  {
    dword_1805A0 = 0;
    dword_18059C = 0;
    byte_E36D0 = 1;
  }
  if ( !byte_E36D1 )
    return v52;
  switch ( word_1805C2 )
  {
    case 1:
    case 8:
    case 12:
      word_1805C8 = 1;
      v52 = sub_8B790(&dword_18058C);
      if ( word_1805C2 != 8 && word_1805C2 != 12 )
      {
        dword_1805B0 = (__int16)dword_E3760;
        dword_1805B4 = SHIWORD(dword_E3760);
        dword_1805B8 = word_E375C;
        dword_1805BC = word_E375E;
        word_1805C0 = byte_180664[(unsigned __int8)byte_EB39E] != 0;
        if ( byte_180664[(unsigned __int8)byte_EB39F] )
          LOBYTE(word_1805C0) = word_1805C0 | 2;
        if ( byte_180664[(unsigned __int8)byte_EB3A0] )
          LOBYTE(word_1805C0) = word_1805C0 | 4;
        if ( byte_180664[(unsigned __int8)byte_EB3A1] )
          LOBYTE(word_1805C0) = word_1805C0 | 8;
        dword_18059C = word_180746 != 0;
        if ( word_180744 )
          LOBYTE(dword_18059C) = dword_18059C | 2;
        if ( word_18074C )
          LOBYTE(dword_18059C) = dword_18059C | 4;
        if ( word_18074A )
          LOBYTE(dword_18059C) = dword_18059C | 8;
        if ( byte_180664[(unsigned __int8)byte_EB3A3] )
          LOBYTE(dword_18059C) = dword_18059C | 0x10;
      }
      dword_180594 *= 4;
      dword_180590 = (dword_180590 << 11) / 360;
      if ( word_1805C2 == 8 )
        goto LABEL_45;
      if ( word_1805C2 == 12 )
        goto LABEL_201;
      return v52;
    case 2:
    case 9:
    case 13:
      word_1805C8 = 1;
      sub_75910();
      if ( word_1805C2 != 9 && word_1805C2 != 13 )
      {
        dword_1805B0 = (__int16)dword_E3760;
        dword_1805B4 = SHIWORD(dword_E3760);
        dword_1805B8 = word_E375C;
        dword_1805BC = word_E375E;
        word_1805C0 = byte_180664[(unsigned __int8)byte_EB39E] != 0;
        if ( byte_180664[(unsigned __int8)byte_EB39F] )
          LOBYTE(word_1805C0) = word_1805C0 | 2;
        if ( byte_180664[(unsigned __int8)byte_EB3A0] )
          LOBYTE(word_1805C0) = word_1805C0 | 4;
        if ( byte_180664[(unsigned __int8)byte_EB3A1] )
          LOBYTE(word_1805C0) = word_1805C0 | 8;
        dword_18059C = word_180746 != 0;
        if ( word_180744 )
          LOBYTE(dword_18059C) = dword_18059C | 2;
        if ( word_18074C )
          LOBYTE(dword_18059C) = dword_18059C | 4;
        if ( word_18074A )
          LOBYTE(dword_18059C) = dword_18059C | 8;
        if ( byte_180664[(unsigned __int8)byte_EB3A3] )
          LOBYTE(dword_18059C) = dword_18059C | 0x10;
      }
      dword_180590 = (-2048 * word_17D6CC / 0xFFFFu) & 0x7FF;
      if ( byte_1806E4 == 46 )
        sub_759B0();
      if ( word_1805C2 == 9 )
        goto LABEL_45;
      if ( word_1805C2 == 13 )
        goto LABEL_201;
      dword_180594 = 0;
      return v52;
    case 4:
LABEL_45:
      word_1805C0 = 0;
      sub_8BBE0((int)&unk_180560);
      goto LABEL_46;
    case 6:
      memset(v47, 0, 50);
      sub_8C140(*(_WORD *)dword_E36C4, (int)v47);
      dword_180590 = *(_DWORD *)(dword_E36C4 + 4);
      v24 = *(_WORD *)(dword_E36C4 + 62);
      dword_180594 = *(_DWORD *)(dword_E36C4 + 8);
      if ( !v24 )
      {
        dword_1805B0 = (__int16)dword_E3760;
        dword_1805B4 = SHIWORD(dword_E3760);
        dword_1805B8 = word_E375C;
        dword_1805BC = word_E375E;
        word_1805C0 = byte_180664[(unsigned __int8)byte_EB39E] != 0;
        if ( byte_180664[(unsigned __int8)byte_EB39F] )
          LOBYTE(word_1805C0) = word_1805C0 | 2;
        if ( byte_180664[(unsigned __int8)byte_EB3A0] )
          LOBYTE(word_1805C0) = word_1805C0 | 4;
        if ( byte_180664[(unsigned __int8)byte_EB3A1] )
          LOBYTE(word_1805C0) = word_1805C0 | 8;
        dword_18059C = word_180746 != 0;
        if ( word_180744 )
          LOBYTE(dword_18059C) = dword_18059C | 2;
        if ( word_18074C )
          LOBYTE(dword_18059C) = dword_18059C | 4;
        if ( word_18074A )
          LOBYTE(dword_18059C) = dword_18059C | 8;
        if ( byte_180664[(unsigned __int8)byte_EB3A3] )
        {
          LOBYTE(dword_18059C) = dword_18059C | 0x10;
          return v52;
        }
        return v52;
      }
      if ( v24 != 4 )
      {
        if ( v24 != 11 )
          return v52;
        byte_180586 = *(_BYTE *)(dword_E36C4 + 16);
        byte_180588 = dword_1805B0;
        byte_180589 = dword_1805B4;
LABEL_202:
        if ( (byte_180586 & 1) == 0 || (byte_180587 & 1) != 0 )
        {
          if ( (byte_180586 & 1) == 0 && (byte_180587 & 1) != 0 )
          {
            LOBYTE(dword_18059C) = dword_18059C & 0xFA;
            byte_180587 &= ~1u;
          }
        }
        else
        {
          dword_1805B8 = dword_1805B0;
          LOBYTE(dword_18059C) = dword_18059C | 5;
          dword_1805BC = dword_1805B4;
          byte_180587 |= 1u;
        }
        if ( (byte_180586 & 2) == 0 || (byte_180587 & 2) != 0 )
        {
          if ( (byte_180586 & 2) == 0 && (byte_180587 & 2) != 0 )
          {
            LOBYTE(dword_18059C) = dword_18059C & 0xF5;
            byte_180587 &= ~2u;
          }
        }
        else
        {
          dword_1805B8 = dword_1805B0;
          LOBYTE(dword_18059C) = dword_18059C | 0xA;
          dword_1805BC = dword_1805B4;
          byte_180587 |= 2u;
        }
        if ( byte_180664[(unsigned __int8)byte_EB3A3] )
        {
          byte_180587 &= ~8u;
          byte_180586 &= ~8u;
          LOBYTE(dword_18059C) = dword_18059C | 0x10;
        }
        else if ( (byte_180586 & 8) == 0 || (byte_180587 & 8) != 0 || (dword_18059C & 0x10) != 0 )
        {
          if ( (byte_180586 & 8) != 0 || (byte_180587 & 8) == 0 || (dword_18059C & 0x10) != 0 )
          {
            if ( (byte_180586 & 8) != 0 && (byte_180587 & 8) != 0 && (dword_18059C & 0x10) != 0 )
            {
              byte_180587 &= ~8u;
              byte_180586 &= ~8u;
            }
            else if ( (byte_180586 & 8) == 0 && (byte_180587 & 8) == 0 && (dword_18059C & 0x10) != 0 )
            {
              LOBYTE(dword_18059C) = dword_18059C & 0xEF;
            }
          }
          else
          {
            LOBYTE(dword_18059C) = dword_18059C | 0x10;
          }
        }
        else
        {
          byte_180587 |= 8u;
        }
        v25 = *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221);
        if ( v25 < 5u )
        {
          if ( v25 == 3 )
          {
            if ( 82 - *(unsigned __int8 *)(dword_EA3DC + 934) <= dword_1805B0 )
            {
              if ( dword_1805B0 >= 384 )
              {
                if ( (word_180660 & 1) != 0 )
                  v42 = 400;
                else
                  v42 = 480;
                v51 = v42 - 72;
                if ( v42 - 46 >= dword_1805B4 )
                  v43 = *(_BYTE *)(dword_EA3DC + 1558);
                else
                  v43 = *(_BYTE *)(dword_EA3DC + 946);
                v36 = (int)v43 >> 2;
                v7 = ((int)*(unsigned __int8 *)(dword_EA3DC + 947) >> 1) + v51 + 26;
                v44 = ((int)*(unsigned __int8 *)(dword_EA3DC + 1559) >> 1) + 4 + v51;
                v50 = 0;
                v51 = v44;
                v35 = 640;
                v37 = *(unsigned __int8 *)(dword_EA3DC + 1559);
              }
              else
              {
                if ( (word_180660 & 1) != 0 )
                  v40 = 400;
                else
                  v40 = 480;
                v51 = v40 - 72;
                v41 = ((int)*(unsigned __int8 *)(dword_EA3DC + 929) >> 1) + 32 + v40 - 72;
                v50 = 0;
                v51 = v41;
                v35 = 640;
                v7 = v41;
                v36 = (int)*(unsigned __int8 *)(dword_EA3DC + 928) >> 2;
                v37 = (int)*(unsigned __int8 *)(dword_EA3DC + 929) >> 1;
              }
            }
            else
            {
              if ( (word_180660 & 1) != 0 )
                v38 = 400;
              else
                v38 = 480;
              v51 = v38 - 72;
              v51 = ((int)*(unsigned __int8 *)(dword_EA3DC + 935) >> 1) + 28 + v38 - 72;
              v50 = ((int)*(unsigned __int8 *)(dword_EA3DC + 934) >> 1) + 4;
              v39 = *(unsigned __int8 *)(dword_EA3DC + 935);
              v7 = v51 + v39;
              v37 = v39 >> 1;
              v36 = (int)*(unsigned __int8 *)(dword_EA3DC + 934) >> 2;
              v35 = v50 + 640 - ((int)*(unsigned __int8 *)(dword_EA3DC + 934) >> 1);
            }
            goto LABEL_285;
          }
        }
        else if ( v25 <= 5u || v25 == 8 )
        {
          v26 = dword_D41A0 + 11230 + 2124 * *(__int16 *)(dword_D41A0 + 12);
          v27 = *(_BYTE *)(v26 + 2109);
          v28 = v26 + 1609;
          if ( v27 )
          {
            if ( v27 <= 2u )
            {
              v49 = 3 * *(unsigned __int8 *)(dword_EA3DC + 982);
              v31 = *(_BYTE *)(v28 + 501);
              if ( v31 < 13 )
                v32 = v31;
              else
                v32 = v31 - 13;
              v33 = *(unsigned __int8 *)(dword_EA3DC + 532)
                  + *(unsigned __int8 *)(dword_EA3DC + 538) * v32
                  + ((int)*(unsigned __int8 *)(dword_EA3DC + 538) >> 1)
                  - (v49 >> 1);
              v50 = v33;
              if ( 640 - v49 >= v33 )
              {
                if ( v33 < 0 )
                  v50 = 0;
              }
              else
              {
                v50 = 640 - v49;
              }
              v35 = v49 + v50;
              if ( (word_180660 & 1) != 0 )
                v34 = 400;
              else
                v34 = 480;
              v7 = v34
                 - 2 * *(unsigned __int8 *)(dword_EA3DC + 539)
                 - ((int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1);
              v51 = v7;
              v36 = (int)*(unsigned __int8 *)(dword_EA3DC + 982) >> 2;
              v37 = (int)*(unsigned __int8 *)(dword_EA3DC + 983) >> 1;
            }
            else
            {
              v35 = 640;
              v7 = 480;
              v36 = 12;
              v37 = 32;
              v50 = 0;
              v51 = 0;
            }
          }
          else
          {
            v35 = 640;
            v50 = 0;
            if ( (word_180660 & 1) != 0 )
              v29 = 400;
            else
              v29 = 480;
            v7 = v29 - ((int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1);
            if ( (word_180660 & 1) != 0 )
              v30 = 400;
            else
              v30 = 480;
            v51 = v30;
            v51 = v30 - 2 * *(unsigned __int8 *)(dword_EA3DC + 539);
            v51 += (int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1;
            v36 = (int)*(unsigned __int8 *)(dword_EA3DC + 538) >> 2;
            v37 = (int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1;
          }
          goto LABEL_285;
        }
        if ( *(_BYTE *)(dword_D41A4 + 38546) )
        {
          sub_30BE0(&v50, &v51);
          v50 += (int)*(unsigned __int8 *)(dword_EA3DC + 1546) >> 1;
          v51 += (int)*(unsigned __int8 *)(dword_EA3DC + 1547) >> 1;
          v36 = *(unsigned __int8 *)(dword_EA3DC + 1546);
          v7 = v51;
          v35 = v36 + v50;
          v37 = 0;
        }
        else if ( *(_BYTE *)(dword_D41A4 + 225) )
        {
          v45 = *(__int16 *)(dword_D41A4 + 186);
          v37 = 4;
          v51 = 67;
          v7 = 393;
          v35 = (v45 >> 1) + (640 - v45) / 2;
          dword_1805B0 = v35;
          v50 = v35;
          v36 = 0;
        }
        else if ( *(_BYTE *)(dword_D41A4 + 38543) )
        {
          sub_2FFE0(&v50, &v51, &v49, &v48);
          v49 -= 2;
          v35 = v49 + v50;
          v7 = 4 * v48 + 12 + v51;
          v37 = 0;
          v36 = 4;
          v51 = v7;
        }
        else if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) != 0 )
        {
          v49 = *(unsigned __int8 *)(dword_EA3DC + 1048);
          v48 = *(unsigned __int8 *)(dword_EA3DC + 1073)
              + *(unsigned __int8 *)(dword_EA3DC + 1061)
              + *(unsigned __int8 *)(dword_EA3DC + 1055)
              + *(unsigned __int8 *)(dword_EA3DC + 1049);
          v51 = ((int)*(unsigned __int8 *)(dword_EA3DC + 1049) >> 1) + (400 - v48) / 2 - 60;
          v50 = ((int)*(unsigned __int8 *)(dword_EA3DC + 1048) >> 2) + (640 - v49) / 2;
          v46 = *(unsigned __int8 *)(dword_EA3DC + 1049);
          v7 = v48 + v51 - v46;
          v37 = v46 >> 2;
          v36 = (int)*(unsigned __int8 *)(dword_EA3DC + 1048) >> 2;
          v35 = v49 + v50 - ((int)*(unsigned __int8 *)(dword_EA3DC + 1048) >> 1);
        }
        else
        {
          v35 = 640;
          v7 = 480;
          v37 = 32;
          v50 = 0;
          v51 = 0;
          v36 = 12;
        }
LABEL_285:
        if ( (dword_18059C & 0x10) == 0
          && (*(_BYTE *)(dword_D41A4 + 24) & 1) == 0
          && !*(_BYTE *)(dword_D41A4 + 38546)
          && !*(_BYTE *)(dword_D41A4 + 225)
          && *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) != 3 )
        {
          if ( (byte_180586 & 4) != 0 )
          {
            if ( byte_180589 < 0 )
              word_1805C0 |= 1u;
            if ( byte_180589 > 0 )
              LOBYTE(word_1805C0) = word_1805C0 | 2;
            if ( byte_180588 < 0 )
              LOBYTE(word_1805C0) = word_1805C0 | 4;
            if ( byte_180588 > 0 )
              LOBYTE(word_1805C0) = word_1805C0 | 8;
          }
          else
          {
            word_E36CC = byte_180588;
            word_E36CE = byte_180589;
            dword_1805B0 = 2 * byte_180588 + 320;
            dword_1805B4 = 2 * byte_180589 + 200;
            if ( byte_180664[(unsigned __int8)byte_EB39E] )
              word_1805C0 |= 1u;
            if ( byte_180664[(unsigned __int8)byte_EB39F] )
              LOBYTE(word_1805C0) = word_1805C0 | 2;
            if ( byte_180664[(unsigned __int8)byte_EB3A0] )
              LOBYTE(word_1805C0) = word_1805C0 | 4;
            if ( byte_180664[(unsigned __int8)byte_EB3A1] )
            {
              LOBYTE(word_1805C0) = word_1805C0 | 8;
              return v52;
            }
          }
          return v52;
        }
        if ( byte_180589 >= 0 )
        {
          if ( byte_180589 > 0 )
            dword_1805B4 += v37;
        }
        else
        {
          dword_1805B4 -= v37;
        }
        if ( byte_180588 >= 0 )
        {
          if ( byte_180588 > 0 )
            dword_1805B0 += v36;
        }
        else
        {
          dword_1805B0 -= v36;
        }
        if ( dword_1805B0 >= v50 )
        {
          if ( v35 < dword_1805B0 )
            dword_1805B0 = v35;
        }
        else
        {
          dword_1805B0 = v50;
        }
        v21 = dword_1805B4;
        if ( dword_1805B4 < v51 )
        {
          dword_1805B4 = v51;
          return v52;
        }
LABEL_149:
        if ( v7 >= v21 )
          return v52;
        dword_1805B4 = v7;
        return v52;
      }
      byte_180586 = *(_BYTE *)(dword_E36C4 + 16);
      byte_180588 = dword_1805B0;
      byte_180589 = dword_1805B4;
LABEL_46:
      if ( (byte_180586 & 1) == 0 || (byte_180587 & 1) != 0 )
      {
        if ( (byte_180586 & 1) == 0 && (byte_180587 & 1) != 0 )
        {
          LOBYTE(dword_18059C) = dword_18059C & 0xFA;
          byte_180587 &= ~1u;
        }
      }
      else
      {
        LOBYTE(dword_18059C) = dword_18059C | 5;
        dword_1805B8 = dword_1805B0;
        byte_180587 |= 1u;
        dword_1805BC = dword_1805B4;
      }
      if ( (byte_180586 & 2) == 0 || (byte_180587 & 2) != 0 )
      {
        if ( (byte_180586 & 2) == 0 && (byte_180587 & 2) != 0 )
        {
          LOBYTE(dword_18059C) = dword_18059C & 0xF5;
          byte_180587 &= ~2u;
        }
      }
      else
      {
        LOBYTE(dword_18059C) = dword_18059C | 0xA;
        dword_1805B8 = dword_1805B0;
        byte_180587 |= 2u;
        dword_1805BC = dword_1805B4;
      }
      if ( byte_180664[(unsigned __int8)byte_EB3A3] )
      {
        byte_180586 &= ~8u;
        LOBYTE(dword_18059C) = dword_18059C | 0x10;
        byte_180587 &= ~8u;
      }
      else if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) == 0 )
      {
        if ( (byte_180586 & 8) == 0 || (byte_180587 & 8) != 0 || (dword_18059C & 0x10) != 0 )
        {
          if ( (byte_180586 & 8) != 0 || (byte_180587 & 8) == 0 || (dword_18059C & 0x10) != 0 )
          {
            if ( (byte_180586 & 8) != 0 && (byte_180587 & 8) != 0 && (dword_18059C & 0x10) != 0 )
            {
              byte_180587 &= ~8u;
              byte_180586 &= ~8u;
            }
            else if ( (byte_180586 & 8) == 0 && (byte_180587 & 8) == 0 && (dword_18059C & 0x10) != 0 )
            {
              LOBYTE(dword_18059C) = dword_18059C & 0xEF;
            }
          }
          else
          {
            LOBYTE(dword_18059C) = dword_18059C | 0x10;
          }
        }
        else
        {
          byte_180587 |= 8u;
        }
      }
      v1 = *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221);
      if ( v1 < 5u )
      {
        if ( v1 == 3 )
        {
          if ( 82 - *(unsigned __int8 *)(dword_EA3DC + 934) <= dword_1805B0 )
          {
            if ( dword_1805B0 >= 384 )
            {
              if ( (word_180660 & 1) != 0 )
                v16 = 400;
              else
                v16 = 480;
              v51 = v16 - 72;
              if ( v16 - 46 >= dword_1805B4 )
                v17 = *(_BYTE *)(dword_EA3DC + 1558);
              else
                v17 = *(_BYTE *)(dword_EA3DC + 946);
              v9 = (int)v17 >> 2;
              v7 = v51 + 26 + ((int)*(unsigned __int8 *)(dword_EA3DC + 947) >> 1);
              v18 = ((int)*(unsigned __int8 *)(dword_EA3DC + 1559) >> 1) + 4 + v51;
              v50 = 0;
              v51 = v18;
              v5 = 640;
              v10 = *(unsigned __int8 *)(dword_EA3DC + 1559);
            }
            else
            {
              if ( (word_180660 & 1) != 0 )
                v15 = 400;
              else
                v15 = 480;
              v51 = v15 - 72;
              v7 = ((int)*(unsigned __int8 *)(dword_EA3DC + 929) >> 1) + 32 + v15 - 72;
              v50 = 0;
              v51 = v7;
              v5 = 640;
              v9 = (int)*(unsigned __int8 *)(dword_EA3DC + 928) >> 2;
              v10 = (int)*(unsigned __int8 *)(dword_EA3DC + 929) >> 1;
            }
          }
          else
          {
            if ( (word_180660 & 1) != 0 )
              v13 = 400;
            else
              v13 = 480;
            v51 = v13 - 72;
            v51 = ((int)*(unsigned __int8 *)(dword_EA3DC + 935) >> 1) + 28 + v13 - 72;
            v50 = ((int)*(unsigned __int8 *)(dword_EA3DC + 934) >> 1) + 4;
            v14 = *(unsigned __int8 *)(dword_EA3DC + 935);
            v7 = v51 + v14;
            v10 = v14 >> 1;
            v9 = (int)*(unsigned __int8 *)(dword_EA3DC + 934) >> 2;
            v5 = v50 + 640 - ((int)*(unsigned __int8 *)(dword_EA3DC + 934) >> 1);
          }
          goto LABEL_130;
        }
      }
      else if ( v1 <= 5u || v1 == 8 )
      {
        v2 = 2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11230;
        v3 = v2 + 1609;
        v4 = *(_BYTE *)(v2 + 2109);
        if ( !v4 )
        {
          v5 = 640;
          v50 = 0;
          if ( (word_180660 & 1) != 0 )
            v6 = 400;
          else
            v6 = 480;
          v7 = v6 - ((int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1);
          if ( (word_180660 & 1) != 0 )
            v8 = 400;
          else
            v8 = 480;
          v51 = v8;
          v51 = v8 - 2 * *(unsigned __int8 *)(dword_EA3DC + 539);
          v51 += (int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1;
          v9 = (int)*(unsigned __int8 *)(dword_EA3DC + 538) >> 2;
          v10 = (int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1;
          goto LABEL_130;
        }
        if ( v4 <= 2u )
        {
          v49 = 3 * *(unsigned __int8 *)(dword_EA3DC + 982);
          LOBYTE(v11) = *(_BYTE *)(v3 + 501);
          if ( (char)v11 < 13 )
            v11 = (char)v11;
          else
            v11 = (char)v11 - 13;
          v50 = *(unsigned __int8 *)(dword_EA3DC + 538) * v11
              + *(unsigned __int8 *)(dword_EA3DC + 532)
              + ((int)*(unsigned __int8 *)(dword_EA3DC + 538) >> 1)
              - (v49 >> 1);
          if ( 640 - v49 >= v50 )
          {
            if ( v50 < 0 )
              v50 = 0;
          }
          else
          {
            v50 = 640 - v49;
          }
          v5 = v49 + v50;
          if ( (word_180660 & 1) != 0 )
            v12 = 400;
          else
            v12 = 480;
          v7 = v12 - 2 * *(unsigned __int8 *)(dword_EA3DC + 539) - ((int)*(unsigned __int8 *)(dword_EA3DC + 539) >> 1);
          v51 = v7;
          v9 = (int)*(unsigned __int8 *)(dword_EA3DC + 982) >> 2;
          v10 = (int)*(unsigned __int8 *)(dword_EA3DC + 983) >> 1;
          goto LABEL_130;
        }
        goto LABEL_129;
      }
      if ( *(_BYTE *)(dword_D41A4 + 38546) )
      {
        sub_30BE0(&v50, &v51);
        v50 += (int)*(unsigned __int8 *)(dword_EA3DC + 1546) >> 1;
        v51 += (int)*(unsigned __int8 *)(dword_EA3DC + 1547) >> 1;
        v9 = *(unsigned __int8 *)(dword_EA3DC + 1546);
        v7 = v51;
        v5 = v9 + v50;
        v10 = 0;
        goto LABEL_130;
      }
      if ( *(_BYTE *)(dword_D41A4 + 225) )
      {
        v19 = *(__int16 *)(dword_D41A4 + 186);
        v10 = 4;
        v51 = 67;
        v7 = 393;
        v5 = (v19 >> 1) + (640 - v19) / 2;
        dword_1805B0 = v5;
        v50 = v5;
        v9 = 0;
        goto LABEL_130;
      }
      if ( *(_BYTE *)(dword_D41A4 + 38543) )
      {
        sub_2FFE0(&v50, &v51, &v49, &v48);
        v49 -= 2;
        v5 = v49 + v50;
        v7 = 4 * v48 + 12 + v51;
        v10 = 0;
        v9 = 4;
        v51 = v7;
        goto LABEL_130;
      }
      if ( (*(_BYTE *)(dword_D41A4 + 24) & 1) != 0 )
      {
        v49 = *(unsigned __int8 *)(dword_EA3DC + 1048);
        v48 = *(unsigned __int8 *)(dword_EA3DC + 1073)
            + *(unsigned __int8 *)(dword_EA3DC + 1061)
            + *(unsigned __int8 *)(dword_EA3DC + 1055)
            + *(unsigned __int8 *)(dword_EA3DC + 1049);
        v51 = ((int)*(unsigned __int8 *)(dword_EA3DC + 1049) >> 1) + (400 - v48) / 2 - 60;
        v50 = ((int)*(unsigned __int8 *)(dword_EA3DC + 1048) >> 2) + (640 - v49) / 2;
        v20 = *(unsigned __int8 *)(dword_EA3DC + 1049);
        v7 = v48 + v51 - v20;
        v10 = v20 >> 2;
        v9 = (int)*(unsigned __int8 *)(dword_EA3DC + 1048) >> 2;
        v5 = v49 + v50 - ((int)*(unsigned __int8 *)(dword_EA3DC + 1048) >> 1);
        goto LABEL_130;
      }
LABEL_129:
      v5 = 640;
      v7 = 480;
      v10 = 32;
      v50 = 0;
      v51 = 0;
      v9 = 12;
LABEL_130:
      if ( (dword_18059C & 0x10) != 0
        || (*(_BYTE *)(dword_D41A4 + 24) & 1) != 0
        || *(_BYTE *)(dword_D41A4 + 38546)
        || *(_BYTE *)(dword_D41A4 + 225)
        || *(_BYTE *)(2124 * *(__int16 *)(dword_D41A0 + 12) + dword_D41A0 + 12221) == 3 )
      {
        if ( byte_180589 >= 0 )
        {
          if ( byte_180589 > 0 )
            dword_1805B4 += v10;
        }
        else
        {
          dword_1805B4 -= v10;
        }
        if ( byte_180588 >= 0 )
        {
          if ( byte_180588 > 0 )
            dword_1805B0 += v9;
        }
        else
        {
          dword_1805B0 -= v9;
        }
        if ( dword_1805B0 >= v50 )
        {
          if ( v5 < dword_1805B0 )
            dword_1805B0 = v5;
        }
        else
        {
          dword_1805B0 = v50;
        }
        v21 = dword_1805B4;
        if ( dword_1805B4 < v51 )
        {
          dword_1805B4 = v51;
          return v52;
        }
        goto LABEL_149;
      }
      if ( (byte_180586 & 4) != 0 )
      {
        if ( byte_180589 < 0 )
          word_1805C0 |= 1u;
        if ( byte_180589 > 0 )
          LOBYTE(word_1805C0) = word_1805C0 | 2;
        if ( byte_180588 < 0 )
          LOBYTE(word_1805C0) = word_1805C0 | 4;
        if ( byte_180588 > 0 )
        {
          LOBYTE(word_1805C0) = word_1805C0 | 8;
          return v52;
        }
      }
      else
      {
        v22 = 28 * (__int16)(32 * byte_180588 + word_E36CC);
        word_E36CC = (int)(v22 - (__CFSHL__(HIDWORD(v22), 5) + 32 * HIDWORD(v22))) >> 5;
        v23 = 31 * (__int16)(16 * byte_180589 + word_E36CE);
        word_E36CE = (int)(v23 - (__CFSHL__(HIDWORD(v23), 5) + 32 * HIDWORD(v23))) >> 5;
        dword_1805B0 = 2 * word_E36CC + 320;
        dword_1805B4 = 2 * word_E36CE + 200;
        if ( byte_180664[(unsigned __int8)byte_EB39E] )
          word_1805C0 |= 1u;
        if ( byte_180664[(unsigned __int8)byte_EB39F] )
          LOBYTE(word_1805C0) = word_1805C0 | 2;
        if ( byte_180664[(unsigned __int8)byte_EB3A0] )
          LOBYTE(word_1805C0) = word_1805C0 | 4;
        if ( byte_180664[(unsigned __int8)byte_EB3A1] )
        {
          LOBYTE(word_1805C0) = word_1805C0 | 8;
          return v52;
        }
      }
      return v52;
    case 7:
      dword_1805B0 = (__int16)dword_E3760;
      dword_1805B4 = SHIWORD(dword_E3760);
      dword_1805B8 = word_E375C;
      dword_1805BC = word_E375E;
      word_1805C0 = byte_180664[(unsigned __int8)byte_EB39E] != 0;
      if ( byte_180664[(unsigned __int8)byte_EB39F] )
        LOBYTE(word_1805C0) = word_1805C0 | 2;
      if ( byte_180664[(unsigned __int8)byte_EB3A0] )
        LOBYTE(word_1805C0) = word_1805C0 | 4;
      if ( byte_180664[(unsigned __int8)byte_EB3A1] )
        LOBYTE(word_1805C0) = word_1805C0 | 8;
      dword_18059C = word_180746 != 0;
      if ( word_180744 )
        LOBYTE(dword_18059C) = dword_18059C | 2;
      if ( word_18074C )
        LOBYTE(dword_18059C) = dword_18059C | 4;
      if ( word_18074A )
        LOBYTE(dword_18059C) = dword_18059C | 8;
      if ( !byte_180664[(unsigned __int8)byte_EB3A3] )
        return v52;
      LOBYTE(dword_18059C) = dword_18059C | 0x10;
      return v52;
    case 11:
LABEL_201:
      word_1805C0 = 0;
      sub_8BBE0((int)&unk_180560);
      goto LABEL_202;
    default:
      return v52;
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D41A0: using guessed type int dword_D41A0;
// D41A4: using guessed type int dword_D41A4;
// E36C4: using guessed type int dword_E36C4;
// E36CC: using guessed type __int16 word_E36CC;
// E36CE: using guessed type __int16 word_E36CE;
// E36D0: using guessed type char byte_E36D0;
// E36D1: using guessed type char byte_E36D1;
// E375C: using guessed type __int16 word_E375C;
// E375E: using guessed type __int16 word_E375E;
// E3760: using guessed type int dword_E3760;
// EA3DC: using guessed type int dword_EA3DC;
// EB39E: using guessed type char byte_EB39E;
// EB39F: using guessed type char byte_EB39F;
// EB3A0: using guessed type char byte_EB3A0;
// EB3A1: using guessed type char byte_EB3A1;
// EB3A3: using guessed type char byte_EB3A3;
// 17D6CC: using guessed type __int16 word_17D6CC;
// 180586: using guessed type char byte_180586;
// 180587: using guessed type char byte_180587;
// 180588: using guessed type char byte_180588;
// 180589: using guessed type char byte_180589;
// 18058C: using guessed type _DWORD dword_18058C;
// 180590: using guessed type int dword_180590;
// 180594: using guessed type int dword_180594;
// 18059C: using guessed type int dword_18059C;
// 1805A0: using guessed type int dword_1805A0;
// 1805B0: using guessed type int dword_1805B0;
// 1805B4: using guessed type int dword_1805B4;
// 1805B8: using guessed type int dword_1805B8;
// 1805BC: using guessed type int dword_1805BC;
// 1805C0: using guessed type __int16 word_1805C0;
// 1805C2: using guessed type __int16 word_1805C2;
// 1805C8: using guessed type __int16 word_1805C8;
// 180660: using guessed type __int16 word_180660;
// 1806E4: using guessed type char byte_1806E4;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;
// 18074A: using guessed type __int16 word_18074A;
// 18074C: using guessed type __int16 word_18074C;

//----- (0008B5A0) --------------------------------------------------------
int sub_8B5A0()
{
  if ( byte_E36D1 )
  {
    switch ( word_1805C2 )
    {
      case 1:
        sub_8B770();
        break;
      case 9:
        sub_75900();
        break;
      default:
        break;
    }
    byte_E36D1 = 0;
  }
  return 0;
}
// E36D1: using guessed type char byte_E36D1;
// 1805C2: using guessed type __int16 word_1805C2;

//----- (0008B600) --------------------------------------------------------
int __cdecl sub_8B600(int a1)
{
  int v1; // edi
  char v2; // bl
  __int16 v3; // dx
  char v4; // al
  int v5; // eax
  int v6; // eax
  char v8[60]; // [esp+0h] [ebp-40h] BYREF
  char v9; // [esp+3Ch] [ebp-4h]

  v1 = sub_9AD9C(3);
  memset(v8, 0, sizeof(v8));
  memset(a1 + 66, 0, 84);
  v2 = 1;
  switch ( *(_WORD *)(a1 + 58) )
  {
    case 1:
      v2 = 0;
      break;
    case 3:
      v2 = 2;
      break;
    case 4:
      v2 = 3;
      break;
    default:
      break;
  }
  v3 = *(_WORD *)(a1 + 56);
  switch ( v3 )
  {
    case 1200:
      v4 = sub_8B880((int *)(a1 + 66), v2, 1200, v1);
      break;
    case 2400:
      v4 = sub_8B880((int *)(a1 + 66), v2, 2400, v1);
      break;
    case 4800:
      v4 = sub_8B880((int *)(a1 + 66), v2, 4800, v1);
      break;
    case 9600:
      v4 = sub_8B880((int *)(a1 + 66), v2, 9600, v1);
      break;
    case 19200:
      v4 = sub_8B880((int *)(a1 + 66), v2, 19200, v1);
      break;
    default:
      goto LABEL_16;
  }
  v9 = v4;
LABEL_16:
  sub_9B498(v9);
  printf(aS_1);
  sub_8BA10((int)v8, v3, (int *)(a1 + 66), v8, v1);
  printf(v8);
  printf(&unk_D1F0C);
  v5 = sub_9AD9C(2);
  sub_9B038((int *)(a1 + 66), (char *)&off_D1F10, v5);
  v6 = sub_9AD9C(2);
  if ( !sub_9B038((int *)(a1 + 66), aM1PB, v6) )
    return 1;
  sub_9B234((int *)(a1 + 66));
  printf(aCouldNotSendIn);
  return -1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// D1F10: using guessed type void *off_D1F10;

//----- (0008B770) --------------------------------------------------------
int sub_8B770()
{
  return sub_9B234(dword_1805CE);
}
// 1805CE: using guessed type int dword_1805CE[21];

//----- (0008B790) --------------------------------------------------------
int __cdecl sub_8B790(_DWORD *a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // eax
  double v4; // st7
  double v5; // st7
  int v6; // eax
  double v7; // st7
  int v8; // eax
  int v9; // ecx
  int v10; // edi
  int v11; // eax
  int v12; // ecx
  int v13; // eax
  int v14; // edx

  v1 = sub_9AD9C(1);
  v2 = 1;
  if ( sub_9B274((_DWORD *)((char *)a1 + 66), v1 / 2) )
    v2 = -1;
  v3 = sub_9B260((_DWORD **)((char *)a1 + 66));
  v4 = (double)*(int *)((char *)a1 + 94) * flt_D1F40;
  _CHP(v3);
  a1[1] = (int)v4;
  v5 = (double)*(int *)((char *)a1 + 90) * flt_D1F40;
  _CHP(v6);
  a1[2] = (int)v5;
  v7 = (double)*(int *)((char *)a1 + 98) * flt_D1F40;
  _CHP(v8);
  a1[3] = (int)v7;
  if ( byte_1806E4 == 46 )
  {
    dword_1805A4 = dword_180590;
    dword_1805A8 = dword_180594;
    dword_1805AC = dword_180598;
  }
  else
  {
    v9 = a1[2];
    v10 = a1[3];
    v11 = a1[7];
    a1[1] -= a1[6];
    v12 = v9 - v11;
    v13 = a1[8];
    a1[2] = v12;
    a1[3] = v10 - v13;
  }
  v14 = -a1[2];
  a1[1] = -a1[1];
  a1[2] = v14;
  return v2;
}
// 8B7EA: variable 'v6' is possibly undefined
// 8B7FB: variable 'v8' is possibly undefined
// 9B4F6: using guessed type double __fastcall _CHP(_DWORD);
// D1F40: using guessed type float flt_D1F40;
// 180590: using guessed type int dword_180590;
// 180594: using guessed type int dword_180594;
// 180598: using guessed type int dword_180598;
// 1805A4: using guessed type int dword_1805A4;
// 1805A8: using guessed type int dword_1805A8;
// 1805AC: using guessed type int dword_1805AC;
// 1806E4: using guessed type char byte_1806E4;

//----- (0008B880) --------------------------------------------------------
char __cdecl sub_8B880(int *a1, char a2, int a3, int a4)
{
  int v4; // esi
  char result; // al
  int v6; // eax
  int v7; // eax
  int v8; // edx
  int v9; // eax

  switch ( a2 )
  {
    case 0:
      v4 = 0;
      goto LABEL_7;
    case 1:
      v4 = 1;
      goto LABEL_7;
    case 2:
      v4 = 2;
      goto LABEL_7;
    case 3:
      v4 = 3;
LABEL_7:
      v6 = calloc(1, 90);
      *a1 = v6;
      if ( v6 )
      {
        v7 = sub_9BE18(v6, v4, 1, 0x400u, 0x400u);
        if ( v7 )
        {
          if ( v7 == -1 )
          {
            printf(aNoSerial);
            result = 1;
          }
          else
          {
            printf(aNoMemory);
            result = 9;
          }
        }
        else
        {
          sub_9BAC4(*a1, a3);
          sub_9CCF8(*a1, 1);
          v8 = *a1;
          sub_9CD9C(*a1, 1);
          v9 = sub_9CCB4(*a1, 0);
          result = sub_8B980(v9, v8, a1, a4);
        }
      }
      else
      {
        printf(aNoMemoryForSer);
        result = 1;
      }
      break;
    default:
      result = 1;
      break;
  }
  return result;
}
// 9B513: using guessed type _DWORD __cdecl calloc(_DWORD, _DWORD);

//----- (0008B980) --------------------------------------------------------
char __usercall sub_8B980@<al>(int a1@<eax>, int a2@<edx>, int *a3, int a4)
{
  int v4; // eax
  int v5; // edx
  int v6; // edi
  bool v7; // eax
  int v8; // esi
  int v10; // eax

  v4 = j_j___clock(a1, a2, a3);
  v5 = *a3;
  v6 = v4;
  sub_9CBBC((_DWORD *)*a3);
  do
  {
    v8 = j_j___clock(v7, v5, a3);
    sub_9AEEC((_DWORD **)a3, (char *)&off_D1F10);
    do
    {
      if ( !sub_9C9D0(*a3) && sub_9C938((_DWORD *)*a3) == 79 )
        return 0;
      v10 = sub_9ADB4(1);
    }
    while ( !sub_9AE04(v8, v10) );
    v5 = a4;
    v7 = sub_9AE04(v6, a4);
  }
  while ( !v7 );
  return 3;
}
// 8B99B: variable 'v7' is possibly undefined
// 9ADFC: using guessed type int __fastcall j_j___clock(_DWORD, _DWORD, _DWORD);
// D1F10: using guessed type void *off_D1F10;

//----- (0008BA10) --------------------------------------------------------
char __usercall sub_8BA10@<al>(int a1@<eax>, int a2@<edx>, int *a3, char *a4, int a5)
{
  int v5; // eax
  int v6; // edx
  int v7; // esi
  bool v8; // eax
  char v9; // ah
  unsigned int i; // edx
  char v11; // cl
  int v13; // eax
  int v14; // [esp+8h] [ebp-4h]

  v5 = j_j___clock(a1, a2, a4);
  v6 = *a3;
  v7 = v5;
  sub_9CBBC((_DWORD *)*a3);
  while ( 2 )
  {
    v14 = j_j___clock(v8, v6, a4);
    sub_9AEEC((_DWORD **)a3, (char *)&off_D1F78);
    do
    {
      sub_9AEEC((_DWORD **)a3, (char *)&off_D1F78);
      sub_9AE90(a3, a4, 60, a5);
      v9 = *a4;
      a4[59] = 0;
      if ( v9 == 77 )
      {
        for ( i = 0; i < strlen(a4); ++i )
        {
          v11 = a4[i];
          if ( v11 == 70 || v11 == 102 )
          {
            if ( COERCE_DOUBLE(strtod(&a4[i + 1], 0)) < dbl_D1F7C )
              dword_E36C8 = 0;
            return 0;
          }
        }
        return 0;
      }
      v13 = sub_9ADB4(1);
    }
    while ( !sub_9AE04(v14, v13) );
    v6 = a5;
    v8 = sub_9AE04(v7, a5);
    if ( !v8 )
      continue;
    break;
  }
  return 3;
}
// 8BA31: variable 'v8' is possibly undefined
// 9ADFC: using guessed type int __fastcall j_j___clock(_DWORD, _DWORD, _DWORD);
// 9CF81: using guessed type __int64 __cdecl strtod(_DWORD, _DWORD);
// D1F78: using guessed type void *off_D1F78;
// D1F7C: using guessed type double dbl_D1F7C;
// E36C8: using guessed type int dword_E36C8;

//----- (0008BB10) --------------------------------------------------------
int __cdecl sub_8BB10(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 36) = 2;
  *(_DWORD *)(a1 + 8) = 10000000;
  *(_DWORD *)(a1 + 20) = 10000000;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return result;
}

//----- (0008BB40) --------------------------------------------------------
int __cdecl sub_8BB40(int a1, char a2)
{
  int result; // eax

  *(_BYTE *)(a1 + 37) = a2;
  result = sub_8BB10(a1);
  BYTE1(result) = a2;
  if ( a2 == 8 )
  {
    *(_BYTE *)(a1 + 37) = 7;
    *(_BYTE *)(a1 + 36) = 3;
  }
  return result;
}

//----- (0008BBE0) --------------------------------------------------------
int __cdecl sub_8BBE0(int a1)
{
  char v1; // dl
  unsigned __int8 v2; // al
  char v3; // al
  int result; // eax
  int v5; // ecx
  unsigned __int8 v6; // al
  int v7; // ecx
  unsigned __int8 v8; // al
  int v9; // ecx
  unsigned __int8 v10; // al
  unsigned __int8 v11; // al
  int v12; // esi
  int v13; // esi
  int v14; // edi
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // esi
  int v19; // eax
  int v20; // eax
  int v21; // ecx
  int v22; // esi
  int v23; // eax
  int v24; // ecx
  int v25; // edi
  int v26; // eax
  int v27; // ecx
  int v28; // esi
  int v29; // eax
  int v30; // eax
  int v31; // ecx
  int v32; // esi
  int v33; // eax
  char v34; // al
  int v35; // edx
  int v36; // esi
  unsigned __int8 v37; // al
  int v38; // eax
  char v39; // dh
  int v40; // [esp+0h] [ebp-14h]
  int v41; // [esp+4h] [ebp-10h]
  int v42; // [esp+8h] [ebp-Ch]
  int v43; // [esp+Ch] [ebp-8h]
  unsigned __int8 v44; // [esp+10h] [ebp-4h]
  char v45; // [esp+10h] [ebp-4h]

  v1 = 0;
  v43 = 0;
  v42 = 0;
  v41 = 0;
  v40 = 0;
  v44 = 0;
  if ( *(_BYTE *)(a1 + 36) )
  {
    _disable();
    v2 = *(_BYTE *)(a1 + 37);
    switch ( v2 )
    {
      case 0u:
LABEL_3:
        *(_BYTE *)(a1 + 38) = 0;
        *(_BYTE *)(a1 + 43) = 0;
        v3 = *(_BYTE *)(a1 + 43);
        *(_BYTE *)(a1 + 42) = v3;
        *(_BYTE *)(a1 + 41) = v3;
        *(_BYTE *)(a1 + 40) = v3;
        return 0;
      case 1u:
      case 2u:
      case 3u:
      case 4u:
        v5 = 10000;
        _disable();
        v1 = 1;
        __outbyte(0x201u, v2);
        do
        {
          v6 = __inbyte(0x201u);
          if ( (v6 & 3) == 0 )
            break;
          if ( (v6 & 1) != 0 )
            ++v43;
          if ( (v6 & 2) != 0 )
            ++v42;
          --v5;
        }
        while ( v5 );
        _enable();
        v44 = v6;
        if ( !v5 )
          *(_BYTE *)(a1 + 36) = 0;
        goto LABEL_39;
      case 5u:
      case 6u:
        v7 = 10000;
        _disable();
        v1 = 1;
        __outbyte(0x201u, v2);
        do
        {
          v8 = __inbyte(0x201u);
          if ( (v8 & 0xB) == 0 )
            break;
          if ( (v8 & 1) != 0 )
            ++v43;
          if ( (v8 & 2) != 0 )
            ++v42;
          if ( (v8 & 8) != 0 )
            ++v40;
          --v7;
        }
        while ( v7 );
        _enable();
        v44 = v8;
        if ( !v7 )
          *(_BYTE *)(a1 + 36) = 0;
        goto LABEL_39;
      case 7u:
        v9 = 10000;
        _disable();
        v1 = 1;
        __outbyte(0x201u, v2);
        do
        {
          v10 = __inbyte(0x201u);
          if ( (v10 & 0xF) == 0 )
            break;
          if ( (v10 & 1) != 0 )
            ++v43;
          if ( (v10 & 2) != 0 )
            ++v42;
          if ( (v10 & 4) != 0 )
            ++v41;
          if ( (v10 & 8) != 0 )
            ++v40;
          --v9;
        }
        while ( v9 );
        _enable();
        v44 = v10;
        if ( !v9 )
        {
          if ( *(_BYTE *)(a1 + 36) == 3 )
          {
            v1 = 123;
            *(_BYTE *)(a1 + 37) = 2;
          }
          else
          {
            *(_BYTE *)(a1 + 36) = 1;
          }
        }
        goto LABEL_39;
      default:
LABEL_39:
        _enable();
        break;
    }
  }
  v45 = (~v44 >> 4) & 0xF;
  v11 = *(_BYTE *)(a1 + 37);
  if ( v11 < 3u )
  {
    if ( v11 != 1 )
      goto LABEL_46;
    goto LABEL_45;
  }
  if ( v11 <= 3u || v11 == 5 )
LABEL_45:
    v45 &= 3u;
LABEL_46:
  switch ( *(_BYTE *)(a1 + 36) )
  {
    case 0:
      goto LABEL_3;
    case 1:
      *(_BYTE *)(a1 + 38) = v45;
      switch ( *(_BYTE *)(a1 + 37) )
      {
        case 1:
        case 2:
          goto LABEL_52;
        case 3:
        case 4:
          goto LABEL_66;
        case 5:
        case 6:
          switch ( 8 * v40 / *(_DWORD *)(a1 + 32) )
          {
            case 0:
              *(_BYTE *)(a1 + 42) = 0;
              *(_BYTE *)(a1 + 43) = -1;
              break;
            case 1:
            case 2:
              *(_BYTE *)(a1 + 42) = 1;
              goto LABEL_65;
            case 3:
            case 4:
              *(_BYTE *)(a1 + 42) = 0;
              *(_BYTE *)(a1 + 43) = 1;
              break;
            case 5:
            case 6:
              *(_BYTE *)(a1 + 42) = -1;
              goto LABEL_65;
            default:
              *(_BYTE *)(a1 + 42) = 0;
LABEL_65:
              *(_BYTE *)(a1 + 43) = 0;
              break;
          }
LABEL_66:
          v14 = *(_DWORD *)(a1 + 16);
          v15 = v43 - v14;
          if ( v43 - v14 < 0 )
          {
            v20 = (*(_DWORD *)(a1 + 8) - v14) >> 3;
            v21 = v15 - v20;
            v22 = *(_DWORD *)(a1 + 8) - v14 - 2 * v20;
            if ( v21 <= 0 )
            {
              if ( !v22 )
                v22 = 1;
              v23 = -127 * v21 / v22;
              if ( v23 <= -127 )
                *(_BYTE *)(a1 + 40) = -127;
              else
                *(_BYTE *)(a1 + 40) = v23;
            }
            else
            {
              *(_BYTE *)(a1 + 40) = 0;
            }
          }
          else
          {
            v16 = (*(_DWORD *)(a1 + 12) - v14) >> 3;
            v17 = v15 - v16;
            v18 = *(_DWORD *)(a1 + 12) - v14 - 2 * v16;
            if ( v17 >= 0 )
            {
              if ( !v18 )
                v18 = 1;
              v19 = 127 * v17 / v18;
              if ( v19 >= 127 )
                *(_BYTE *)(a1 + 40) = 127;
              else
                *(_BYTE *)(a1 + 40) = v19;
            }
            else
            {
              *(_BYTE *)(a1 + 40) = 0;
            }
          }
          v24 = v42 - *(_DWORD *)(a1 + 28);
          if ( v24 < 0 )
          {
            v30 = (*(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 28)) >> 3;
            v31 = v24 - v30;
            v32 = *(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 28) - 2 * v30;
            if ( v31 <= 0 )
            {
              if ( !v32 )
                v32 = 1;
              v33 = -127 * v31 / v32;
              if ( v33 <= -127 )
                *(_BYTE *)(a1 + 41) = -127;
              else
                *(_BYTE *)(a1 + 41) = v33;
              result = 0;
            }
            else
            {
              *(_BYTE *)(a1 + 41) = 0;
              result = 0;
            }
          }
          else
          {
            v25 = *(_DWORD *)(a1 + 28);
            v26 = (*(_DWORD *)(a1 + 24) - v25) >> 3;
            v27 = v24 - v26;
            v28 = *(_DWORD *)(a1 + 24) - v25 - 2 * v26;
            if ( v27 >= 0 )
            {
              if ( !v28 )
                v28 = 1;
              v29 = 127 * v27 / v28;
              if ( v29 >= 127 )
                *(_BYTE *)(a1 + 41) = 127;
              else
                *(_BYTE *)(a1 + 41) = v29;
              result = 0;
            }
            else
            {
              *(_BYTE *)(a1 + 41) = 0;
              result = 0;
            }
          }
          break;
        case 7:
          if ( v41 < *(_DWORD *)(a1 + 32) )
            *(_BYTE *)(a1 + 38) |= 0x10u;
          if ( v40 < *(_DWORD *)(a1 + 32) )
            *(_BYTE *)(a1 + 38) |= 0x20u;
LABEL_52:
          v12 = *(_DWORD *)(a1 + 16);
          if ( (v12 + *(_DWORD *)(a1 + 8)) >> 1 <= v43 )
            *(_BYTE *)(a1 + 40) = (v12 + *(_DWORD *)(a1 + 12)) >> 1 < v43;
          else
            *(_BYTE *)(a1 + 40) = -1;
          v13 = *(_DWORD *)(a1 + 28);
          if ( (v13 + *(_DWORD *)(a1 + 20)) >> 1 <= v42 )
            *(_BYTE *)(a1 + 41) = (v13 + *(_DWORD *)(a1 + 24)) >> 1 < v42;
          else
            *(_BYTE *)(a1 + 41) = -1;
          *(_DWORD *)a1 = v43;
          *(_DWORD *)(a1 + 4) = v42;
          result = 0;
          break;
        default:
          goto LABEL_123;
      }
      return result;
    case 2:
      *(_BYTE *)(a1 + 38) = 0;
      *(_BYTE *)(a1 + 43) = 0;
      v34 = *(_BYTE *)(a1 + 43);
      *(_BYTE *)(a1 + 42) = v34;
      *(_BYTE *)(a1 + 41) = v34;
      *(_BYTE *)(a1 + 40) = v34;
      if ( (v45 & 1) == 0
        || (*(_DWORD *)(a1 + 16) = v43,
            *(_DWORD *)(a1 + 28) = v42,
            v35 = *(_DWORD *)(a1 + 16),
            v35 <= *(_DWORD *)(a1 + 8))
        || v35 >= *(_DWORD *)(a1 + 12)
        || (v36 = *(_DWORD *)(a1 + 28), *(_DWORD *)(a1 + 20) >= v36)
        || v36 >= *(_DWORD *)(a1 + 24) )
      {
        if ( v43 < *(_DWORD *)(a1 + 8) )
          *(_DWORD *)(a1 + 8) = v43;
        if ( v43 > *(_DWORD *)(a1 + 12) )
          *(_DWORD *)(a1 + 12) = v43;
        if ( v42 < *(_DWORD *)(a1 + 20) )
          *(_DWORD *)(a1 + 20) = v42;
        if ( v42 > *(_DWORD *)(a1 + 24) )
          *(_DWORD *)(a1 + 24) = v42;
        return 1;
      }
      v37 = *(_BYTE *)(a1 + 37);
      if ( v37 < 5u )
        goto LABEL_122;
      if ( v37 <= 6u )
      {
        v38 = v40;
      }
      else
      {
        if ( v37 != 7 )
          goto LABEL_122;
        v38 = (v40 + v41) >> 2;
      }
      *(_DWORD *)(a1 + 32) = v38;
LABEL_122:
      *(_BYTE *)(a1 + 36) = 1;
LABEL_123:
      result = 0;
      break;
    case 3:
      if ( v1 == 123 )
        goto LABEL_123;
      *(_DWORD *)(a1 + 16) = v43;
      *(_DWORD *)(a1 + 28) = v42;
      *(_DWORD *)(a1 + 12) = v43 / 2 + v43;
      *(_DWORD *)(a1 + 24) = v42 / 2 + v42;
      *(_DWORD *)(a1 + 8) = v43 / 6;
      v39 = *(_BYTE *)(a1 + 37);
      *(_DWORD *)(a1 + 20) = v42 / 6;
      if ( v39 == 7 )
        *(_DWORD *)(a1 + 32) = (v40 + v41) >> 2;
      goto LABEL_122;
    default:
      goto LABEL_123;
  }
  return result;
}

//----- (0008C0E0) --------------------------------------------------------
void __cdecl sub_8C0E0(unsigned __int8 (__fastcall *a1)(int))
{
  int v1; // eax
  int v2; // eax

  byte_180586 = 0;
  while ( (byte_180586 & 1) == 0 )
  {
    v1 = sub_8BBE0((int)&unk_180560);
    if ( a1 && a1(v1) )
      return;
  }
  while ( (byte_180586 & 1) != 0 )
  {
    v2 = sub_8BBE0((int)&unk_180560);
    if ( a1 )
    {
      if ( a1(v2) )
        break;
    }
  }
}
// 180586: using guessed type char byte_180586;

//----- (0008C140) --------------------------------------------------------
char __cdecl sub_8C140(unsigned __int16 a1, int a2)
{
  int v3[7]; // [esp+0h] [ebp-28h] BYREF
  char v4[12]; // [esp+1Ch] [ebp-Ch] BYREF

  memset(v3, 0, sizeof(v3));
  v3[1] = a1;
  v3[0] = 768;
  segread(v4);
  v3[5] = a2;
  int386x(49, v3, v3, v4);
  return *(_BYTE *)(a2 + 28);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99DE6: using guessed type _DWORD __cdecl segread(_DWORD);
// 99E10: using guessed type _DWORD __cdecl int386x(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0008C21F) --------------------------------------------------------
int sub_8C21F()
{
  char v1[28]; // [esp+0h] [ebp-38h] BYREF
  int v2[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  v2[0] = (unsigned __int16)word_180662;
  return int386(16, v2, v1);
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 180662: using guessed type __int16 word_180662;
// 8C21F: using guessed type int var_1C[7];
// 8C21F: using guessed type char var_38[28];

//----- (0008C2CD) --------------------------------------------------------
void sub_8C2CD()
{
  ;
}

//----- (0008C2DE) --------------------------------------------------------
void sub_8C2DE()
{
  ;
}

//----- (0008C329) --------------------------------------------------------
int sub_8C329()
{
  int result; // eax
  _BYTE *v1; // eax
  _BYTE *v2; // eax

  dword_1806E8 = dword_E3760;
  if ( (word_180660 & 1) != 0 )
  {
    LOWORD(dword_1806E8) = (__int16)dword_1806E8 >> 1;
    SHIWORD(dword_1806E8) >>= 1;
  }
  dword_1806F4 = ((int)unk_1806E6 >> 16) + (dword_1806E8 >> 16) * dword_18062C;
  if ( (word_180660 & 8) != 0 )
  {
    HIWORD(dword_18073A) = HIWORD(dword_1806F4);
    sub_9951B(SHIWORD(dword_1806F4));
  }
  unk_1806EC = dword_18062C - dword_1806E8;
  if ( (__int16)(dword_18062C - dword_1806E8) > word_18072C )
    unk_1806EC = word_18072C;
  word_1806EE = dword_180624 - HIWORD(dword_1806E8);
  if ( (__int16)(dword_180624 - HIWORD(dword_1806E8)) > word_18072E )
    word_1806EE = word_18072E;
  dword_180714 = dword_1806F0;
  dword_180708 = (int)&loc_A0000 + (unsigned __int16)dword_1806F4;
  dword_18070C = dword_180730;
  if ( (word_180660 & 1) != 0 )
  {
    for ( word_180738 = 0; ; ++word_180738 )
    {
      result = (int)unk_1806EC >> 16;
      if ( (unsigned __int16)word_180738 >= (int)unk_1806EC >> 16 )
        break;
      LOWORD(dword_18073A) = 0;
      while ( (unsigned __int16)dword_18073A < *(int *)((char *)&dword_1806E8 + 2) >> 16 )
      {
        v1 = (_BYTE *)dword_180714++;
        *v1 = *(_BYTE *)dword_180708;
        if ( *(_BYTE *)dword_18070C != 0xFE )
          *(_BYTE *)dword_180708 = *(_BYTE *)dword_18070C;
        ++dword_180708;
        ++dword_18070C;
        LOWORD(dword_18073A) = dword_18073A + 1;
      }
      dword_180708 += dword_18062C - (*(int *)((char *)&dword_1806E8 + 2) >> 16);
      dword_18070C += (*(int *)((char *)&dword_180730 + 2) >> 16) - (*(int *)((char *)&dword_1806E8 + 2) >> 16);
    }
  }
  else
  {
    for ( word_180738 = 0; ; ++word_180738 )
    {
      result = (int)unk_1806EC >> 16;
      if ( (unsigned __int16)word_180738 >= (int)unk_1806EC >> 16 )
        break;
      LOWORD(dword_18073A) = 0;
      while ( (unsigned __int16)dword_18073A < *(int *)((char *)&dword_1806E8 + 2) >> 16 )
      {
        v2 = (_BYTE *)dword_180714++;
        *v2 = *(_BYTE *)dword_180708;
        if ( *(_BYTE *)dword_18070C != 0xFE )
          *(_BYTE *)dword_180708 = *(_BYTE *)dword_18070C;
        if ( ++dword_180708 >= (unsigned int)&loc_AFFFE + 2 )
        {
          ++HIWORD(dword_18073A);
          sub_9951B(SHIWORD(dword_18073A));
          dword_180708 -= (int)sub_10000;
        }
        ++dword_18070C;
        LOWORD(dword_18073A) = dword_18073A + 1;
      }
      dword_180708 += dword_18062C - (*(int *)((char *)&dword_1806E8 + 2) >> 16);
      if ( dword_180708 >= (unsigned int)&loc_AFFFE + 2 )
      {
        ++HIWORD(dword_18073A);
        sub_9951B(SHIWORD(dword_18073A));
        dword_180708 -= (int)sub_10000;
      }
      dword_18070C += (*(int *)((char *)&dword_180730 + 2) >> 16) - (*(int *)((char *)&dword_1806E8 + 2) >> 16);
    }
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// E3760: using guessed type int dword_E3760;
// 180624: using guessed type int dword_180624;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;
// 1806E8: using guessed type int dword_1806E8;
// 1806EE: using guessed type __int16 word_1806EE;
// 1806F0: using guessed type int dword_1806F0;
// 1806F4: using guessed type int dword_1806F4;
// 180708: using guessed type int dword_180708;
// 18070C: using guessed type int dword_18070C;
// 180714: using guessed type int dword_180714;
// 18072C: using guessed type __int16 word_18072C;
// 18072E: using guessed type __int16 word_18072E;
// 180730: using guessed type int dword_180730;
// 180738: using guessed type __int16 word_180738;
// 18073A: using guessed type int dword_18073A;

//----- (0008C635) --------------------------------------------------------
int sub_8C635()
{
  int result; // eax
  _BYTE *v1; // eax
  _BYTE *v2; // edx

  dword_1806F8 = dword_E3760;
  dword_1806E8 = dword_E3760;
  if ( (word_180660 & 1) != 0 )
  {
    LOWORD(dword_1806F8) = (__int16)dword_1806F8 >> 1;
    SHIWORD(dword_1806F8) >>= 1;
  }
  dword_180704 = (*(int *)((char *)&dword_1806F4 + 2) >> 16) + (dword_1806F8 >> 16) * dword_18062C;
  dword_1806F4 = dword_180704;
  LOWORD(dword_1806FC) = dword_18062C - dword_1806F8;
  if ( (__int16)(dword_18062C - dword_1806F8) > word_18072C )
    LOWORD(dword_1806FC) = word_18072C;
  unk_1806EC = dword_1806FC;
  HIWORD(dword_1806FC) = dword_180624 - HIWORD(dword_1806F8);
  if ( (__int16)(dword_180624 - HIWORD(dword_1806F8)) > word_18072E )
    HIWORD(dword_1806FC) = word_18072E;
  word_1806EE = HIWORD(dword_1806FC);
  dword_180714 = dword_180700;
  dword_180718 = dword_1806F0;
  dword_180708 = dword_180704 + dword_180628;
  dword_18070C = dword_180730;
  for ( word_180738 = 0; ; ++word_180738 )
  {
    result = dword_1806FC >> 16;
    if ( (unsigned __int16)word_180738 >= dword_1806FC >> 16 )
      break;
    LOWORD(dword_18073A) = 0;
    while ( (unsigned __int16)dword_18073A < *(int *)((char *)&dword_1806F8 + 2) >> 16 )
    {
      v1 = (_BYTE *)dword_180714++;
      *v1 = *(_BYTE *)dword_180708;
      v2 = (_BYTE *)dword_180718++;
      *v2 = *(_BYTE *)dword_180708;
      if ( *(_BYTE *)dword_18070C != 0xFE )
        *(_BYTE *)dword_180708 = *(_BYTE *)dword_18070C;
      ++dword_180708;
      ++dword_18070C;
      LOWORD(dword_18073A) = dword_18073A + 1;
    }
    dword_180708 += dword_18062C - (*(int *)((char *)&dword_1806F8 + 2) >> 16);
    dword_18070C += (*(int *)((char *)&dword_180730 + 2) >> 16) - (*(int *)((char *)&dword_1806F8 + 2) >> 16);
  }
  return result;
}
// E3760: using guessed type int dword_E3760;
// 180624: using guessed type int dword_180624;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;
// 1806E8: using guessed type int;
// 1806EE: using guessed type __int16 word_1806EE;
// 1806F0: using guessed type int dword_1806F0;
// 1806F4: using guessed type int dword_1806F4;
// 1806F8: using guessed type int dword_1806F8;
// 1806FC: using guessed type int dword_1806FC;
// 180700: using guessed type int dword_180700;
// 180704: using guessed type int dword_180704;
// 180708: using guessed type int dword_180708;
// 18070C: using guessed type int dword_18070C;
// 180714: using guessed type int dword_180714;
// 180718: using guessed type int dword_180718;
// 18072C: using guessed type __int16 word_18072C;
// 18072E: using guessed type __int16 word_18072E;
// 180730: using guessed type int dword_180730;
// 180738: using guessed type __int16 word_180738;
// 18073A: using guessed type int dword_18073A;

//----- (0008C839) --------------------------------------------------------
int sub_8C839()
{
  int result; // eax
  _BYTE *v1; // eax
  _BYTE *v2; // edx
  _BYTE *v3; // eax
  _BYTE *v4; // edx

  if ( (word_180660 & 1) == 0 )
  {
    HIWORD(dword_18073A) = HIWORD(dword_1806F4);
    sub_9951B(SHIWORD(dword_1806F4));
  }
  dword_180714 = dword_1806F0;
  dword_180708 = (int)&loc_A0000 + (unsigned __int16)dword_1806F4;
  if ( (word_180660 & 1) != 0 )
  {
    for ( word_180738 = 0; ; ++word_180738 )
    {
      result = (int)unk_1806EC >> 16;
      if ( (unsigned __int16)word_180738 >= (int)unk_1806EC >> 16 )
        break;
      LOWORD(dword_18073A) = 0;
      while ( (unsigned __int16)dword_18073A < *(int *)((char *)&dword_1806E8 + 2) >> 16 )
      {
        v1 = (_BYTE *)dword_180714++;
        v2 = (_BYTE *)dword_180708++;
        *v2 = *v1;
        LOWORD(dword_18073A) = dword_18073A + 1;
      }
      dword_180708 += dword_18062C - (*(int *)((char *)&dword_1806E8 + 2) >> 16);
    }
  }
  else
  {
    for ( word_180738 = 0; ; ++word_180738 )
    {
      result = (int)unk_1806EC >> 16;
      if ( (unsigned __int16)word_180738 >= (int)unk_1806EC >> 16 )
        break;
      LOWORD(dword_18073A) = 0;
      while ( (unsigned __int16)dword_18073A < *(int *)((char *)&dword_1806E8 + 2) >> 16 )
      {
        v3 = (_BYTE *)dword_180714++;
        v4 = (_BYTE *)dword_180708++;
        *v4 = *v3;
        if ( dword_180708 >= (unsigned int)&loc_AFFFE + 2 )
        {
          ++HIWORD(dword_18073A);
          sub_9951B(SHIWORD(dword_18073A));
          dword_180708 -= (int)sub_10000;
        }
        LOWORD(dword_18073A) = dword_18073A + 1;
      }
      dword_180708 += dword_18062C - (*(int *)((char *)&dword_1806E8 + 2) >> 16);
      if ( dword_180708 >= (unsigned int)&loc_AFFFE + 2 )
      {
        ++HIWORD(dword_18073A);
        sub_9951B(SHIWORD(dword_18073A));
        dword_180708 -= (int)sub_10000;
      }
    }
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// 18062C: using guessed type int dword_18062C;
// 180660: using guessed type __int16 word_180660;
// 1806E8: using guessed type int dword_1806E8;
// 1806F0: using guessed type int dword_1806F0;
// 1806F4: using guessed type int dword_1806F4;
// 180708: using guessed type int dword_180708;
// 180714: using guessed type int dword_180714;
// 180738: using guessed type __int16 word_180738;
// 18073A: using guessed type int dword_18073A;

//----- (0008CA16) --------------------------------------------------------
int sub_8CA16()
{
  int result; // eax
  _BYTE *v1; // eax
  _BYTE *v2; // edx

  dword_180714 = dword_180700;
  dword_180708 = dword_180704 + dword_180628;
  for ( word_180738 = 0; ; ++word_180738 )
  {
    result = dword_1806FC >> 16;
    if ( (unsigned __int16)word_180738 >= dword_1806FC >> 16 )
      break;
    LOWORD(dword_18073A) = 0;
    while ( (unsigned __int16)dword_18073A < *(int *)((char *)&dword_1806F8 + 2) >> 16 )
    {
      v1 = (_BYTE *)dword_180714++;
      v2 = (_BYTE *)dword_180708++;
      *v2 = *v1;
      LOWORD(dword_18073A) = dword_18073A + 1;
    }
    dword_180708 += dword_18062C - (*(int *)((char *)&dword_1806F8 + 2) >> 16);
  }
  return result;
}
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 1806F8: using guessed type int dword_1806F8;
// 1806FC: using guessed type int dword_1806FC;
// 180700: using guessed type int dword_180700;
// 180704: using guessed type int dword_180704;
// 180708: using guessed type int dword_180708;
// 180714: using guessed type int dword_180714;
// 180738: using guessed type __int16 word_180738;
// 18073A: using guessed type int dword_18073A;

//----- (0008CACD) --------------------------------------------------------
int sub_8CACD()
{
  int result; // eax

  if ( dword_E3768 )
  {
    dword_E3758 = 1;
    return sub_8C635();
  }
  return result;
}
// E3758: using guessed type int dword_E3758;
// E3768: using guessed type int dword_E3768;

//----- (0008CB1F) --------------------------------------------------------
void sub_8CB1F()
{
  dword_E3758 = 0;
}
// E3758: using guessed type int dword_E3758;

//----- (0008CB3A) --------------------------------------------------------
void __noreturn sub_8CB3A()
{
  ((void (__cdecl __noreturn *)(_DWORD))_GETDS)((unsigned __int16)__DS__);
}
// 8CB3A: could not find valid save-restore pair for ebx
// 8CB3A: could not find valid save-restore pair for ebp
// 8CB3A: could not find valid save-restore pair for edi
// 8CB3A: could not find valid save-restore pair for esi
// E3758: using guessed type int dword_E3758;
// E375C: using guessed type __int16 word_E375C;
// E375E: using guessed type __int16 word_E375E;
// E3760: using guessed type int dword_E3760;
// E3767: using guessed type char byte_E3767;
// E3768: using guessed type int dword_E3768;
// E3BA4: using guessed type __int16 word_E3BA4;
// 180660: using guessed type __int16 word_180660;
// 180710: using guessed type int dword_180710;
// 180734: using guessed type int dword_180734;
// 180744: using guessed type __int16 word_180744;
// 180746: using guessed type __int16 word_180746;
// 18074A: using guessed type __int16 word_18074A;
// 18074C: using guessed type __int16 word_18074C;

//----- (0008CD27) --------------------------------------------------------
int __cdecl sub_8CD27(int a1)
{
  int result; // eax
  unsigned int i; // [esp+0h] [ebp-10h]
  int v3; // [esp+4h] [ebp-Ch]
  __int16 v4; // [esp+8h] [ebp-8h]
  int v5; // [esp+Ch] [ebp-4h]

  dword_E3758 = 1;
  v5 = dword_180628;
  dword_180628 = dword_180730;
  if ( a1 )
  {
    word_18072C = *(unsigned __int8 *)(a1 + 4);
    word_18072E = *(unsigned __int8 *)(a1 + 5);
  }
  else
  {
    word_18072C = 0;
    word_18072E = 0;
  }
  if ( (word_180660 & 1) != 0 )
  {
    word_18072C >>= 1;
    word_18072E >>= 1;
  }
  dword_18065C = dword_180650;
  dword_180640 = dword_180630;
  dword_180638 = dword_18063C;
  dword_18064C = dword_180634;
  dword_180658 = dword_180648;
  dword_180654 = dword_180644;
  dword_180650 = 0;
  dword_180630 = 64;
  dword_18063C = 0;
  dword_180634 = 64;
  dword_180648 = 64;
  dword_180644 = 64;
  v4 = word_E36D4;
  word_E36D4 = 0;
  v3 = dword_18062C;
  dword_18062C = 64;
  for ( i = 0; i < 0x1000; ++i )
    *(_BYTE *)(i + dword_180730) = -2;
  if ( a1 )
    sub_8F8B0(0, 0, a1);
  dword_18062C = v3;
  word_E36D4 = v4;
  dword_180650 = dword_18065C;
  dword_180630 = dword_180640;
  dword_18063C = dword_180638;
  dword_180634 = dword_18064C;
  dword_180648 = dword_180658;
  dword_180644 = dword_180654;
  result = v5;
  dword_180628 = v5;
  dword_E3758 = 0;
  return result;
}
// E36D4: using guessed type __int16 word_E36D4;
// E3758: using guessed type int dword_E3758;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180630: using guessed type int dword_180630;
// 180634: using guessed type int dword_180634;
// 180638: using guessed type int dword_180638;
// 18063C: using guessed type int dword_18063C;
// 180640: using guessed type int dword_180640;
// 180644: using guessed type int dword_180644;
// 180648: using guessed type int dword_180648;
// 18064C: using guessed type int dword_18064C;
// 180650: using guessed type int dword_180650;
// 180654: using guessed type int dword_180654;
// 180658: using guessed type int dword_180658;
// 18065C: using guessed type int dword_18065C;
// 180660: using guessed type __int16 word_180660;
// 18072C: using guessed type __int16 word_18072C;
// 18072E: using guessed type __int16 word_18072E;
// 180730: using guessed type int dword_180730;

//----- (0008CEDF) --------------------------------------------------------
int sub_8CEDF()
{
  __int16 v1[14]; // [esp+0h] [ebp-54h] BYREF
  __int16 v2[4]; // [esp+1Ch] [ebp-38h] BYREF
  __int16 v3; // [esp+24h] [ebp-30h]
  void (__noreturn *v4)(); // [esp+28h] [ebp-2Ch]
  __int16 v5[6]; // [esp+38h] [ebp-1Ch] BYREF
  void (__noreturn *v6)(); // [esp+44h] [ebp-10h]
  int v7; // [esp+48h] [ebp-Ch]
  int i; // [esp+4Ch] [ebp-8h]

  dword_E3768 = 0;
  segread(v5);
  v2[0] = 0;
  int386(51, v2, v1);
  if ( v1[0] != -1 )
    return 0;
  v2[0] = 12;
  v3 = 127;
  LOWORD(v7) = __CS__;
  v6 = sub_8CB3A;
  v4 = sub_8CB3A;
  v5[0] = __CS__;
  int386x(51, v2, v1, v5);
  sub_8D12F();
  if ( !dword_180730 )
    dword_180730 = sub_83CD0(4096);
  if ( !dword_180700 )
    dword_180700 = sub_83CD0(4096);
  if ( !dword_1806F0 )
    dword_1806F0 = sub_83CD0(4096);
  if ( !dword_180730 || !dword_180700 || !dword_1806F0 )
    return 0;
  word_18072C = 0;
  word_18072E = 0;
  LOWORD(dword_180734) = 64;
  for ( i = 0; i < 4096; ++i )
    *(_BYTE *)(i + dword_180730) = -2;
  if ( dword_180720 )
    sub_8CD27(dword_180720);
  v2[0] = 2;
  int386(51, v2, v1);
  if ( (word_180660 & 8) != 0 )
  {
    v2[0] = 15;
    v3 = 1;
    LOWORD(v4) = 1;
    int386(51, v2, v1);
  }
  dword_E3768 = 1;
  return 1;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 99DE6: using guessed type _DWORD __cdecl segread(_DWORD);
// 99E10: using guessed type _DWORD __cdecl int386x(_DWORD, _DWORD, _DWORD, _DWORD);
// E3768: using guessed type int dword_E3768;
// 180660: using guessed type __int16 word_180660;
// 1806F0: using guessed type int dword_1806F0;
// 180700: using guessed type int dword_180700;
// 180720: using guessed type int dword_180720;
// 18072C: using guessed type __int16 word_18072C;
// 18072E: using guessed type __int16 word_18072E;
// 180730: using guessed type int dword_180730;
// 180734: using guessed type int dword_180734;

//----- (0008D12F) --------------------------------------------------------
int sub_8D12F()
{
  int result; // eax
  char v1[28]; // [esp+0h] [ebp-38h] BYREF
  __int16 v2[4]; // [esp+1Ch] [ebp-1Ch] BYREF
  __int16 v3; // [esp+24h] [ebp-14h]
  __int16 v4; // [esp+28h] [ebp-10h]

  if ( word_180660 == 8 )
  {
    v2[0] = 7;
    v3 = 0;
    v4 = 5120;
    int386(51, v2, v1);
    v2[0] = 8;
    v3 = 0;
    v4 = 3840;
    result = int386(51, v2, v1);
  }
  if ( word_180660 == 2 )
  {
    v2[0] = 7;
    v3 = 0;
    v4 = 640;
    int386(51, v2, v1);
    v2[0] = 8;
    v3 = 0;
    v4 = 480;
    result = int386(51, v2, v1);
  }
  if ( word_180660 == 4 )
  {
    v2[0] = 7;
    v3 = 0;
    v4 = 640;
    int386(51, v2, v1);
    v2[0] = 8;
    v3 = 0;
    v4 = 400;
    result = int386(51, v2, v1);
  }
  if ( word_180660 == 1 )
  {
    v2[0] = 7;
    v3 = 0;
    v4 = 640;
    int386(51, v2, v1);
    v2[0] = 8;
    v3 = 0;
    v4 = 400;
    return int386(51, v2, v1);
  }
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 180660: using guessed type __int16 word_180660;

//----- (0008D290) --------------------------------------------------------
void __fastcall sub_8D290(int a1, unsigned __int16 a2, int a3, int a4)
{
  int (__cdecl *v4)(int); // eax
  int *v5; // eax
  __int16 v6; // [esp+4h] [ebp-3Ch] BYREF
  char v7; // [esp+6h] [ebp-3Ah] BYREF
  char v8; // [esp+8h] [ebp-38h] BYREF
  char v9; // [esp+Ah] [ebp-36h] BYREF
  char v10[16]; // [esp+1Ch] [ebp-24h] BYREF
  int v11; // [esp+2Ch] [ebp-14h]
  char *v12; // [esp+34h] [ebp-Ch]
  int v13; // [esp+38h] [ebp-8h]
  char v14; // [esp+3Ch] [ebp-4h]

  v14 = 0;
  if ( !byte_E3798 )
    return;
  word_E37B6 = word_E37B4;
  if ( !word_E37B4 )
  {
    if ( !byte_E37FC )
    {
      if ( byte_E37B8 )
        sub_919C0();
    }
    byte_E3798 = 0;
    byte_E3799 = 0;
    printf(aCouldNotLoadAn);
    return;
  }
  if ( !byte_E37B8 )
  {
    sub_90F60();
    sub_9D3F0(sub_83CD0);
    v4 = sub_9D420((int (__cdecl *)(int))sub_83E80);
    sub_917D0((int)v4, a2);
    byte_E37B8 = 1;
  }
  if ( (char)sub_90EE0() == -1 )
  {
    byte_E3798 = 0;
    byte_E3799 = 0;
    if ( byte_E37FC && byte_E37FE )
    {
      sub_99C90();
    }
    else
    {
      byte_E37FC = 0;
      byte_E37FD = 0;
      sub_919C0();
    }
    return;
  }
  v11 = getenv(aMdsound);
  if ( !v11 )
  {
    if ( sub_92190((int)&unk_180A30, aDigIni) )
    {
      if ( !stricmp(byte_180AB0, aNone) )
      {
        if ( !byte_E37FC )
          sub_919C0();
        goto LABEL_25;
      }
      if ( !sub_931F0(a4, a3, (int **)&dword_180B48) )
      {
        sub_93480((unsigned int *)dword_180B48);
        v14 = 1;
      }
    }
    if ( v14 )
    {
      sub_90F20();
      goto LABEL_33;
    }
    if ( !byte_E37FC )
      sub_919C0();
LABEL_25:
    sub_90F20();
    byte_E3798 = 0;
    byte_E3799 = 0;
    return;
  }
  sscanf(v11, "%s %x %d %d %d", v10, &v6, &v7, &v8, &v9);
  dword_180B48 = (int)sub_93330(a4, a3, v10, &v6);
  if ( !dword_180B48 )
  {
    if ( !byte_E37FC )
      sub_919C0();
    sub_90F20();
    byte_E3798 = 0;
    byte_E3799 = 0;
    return;
  }
  sprintf(byte_180AB0, "%s", v10);
  word_180B30 = v6;
  sub_93480((unsigned int *)dword_180B48);
  v14 = 1;
LABEL_33:
  sub_90F20();
  sub_8D800();
  if ( word_E37B6 )
  {
    if ( (unsigned __int16)word_E37B6 < 0x336u )
    {
      if ( (unsigned __int16)word_E37B6 < 0x320u )
      {
        if ( !word_E37B6 )
        {
          byte_E3798 = 0;
          byte_E3799 = 0;
          printf(aCouldNotLoadAn_1);
          return;
        }
      }
      else if ( (unsigned __int16)word_E37B6 <= 0x320u )
      {
        dword_E37BC = 11025;
        byte_E37AE = 0;
      }
      else if ( word_E37B6 == 811 )
      {
        dword_E37BC = 11025;
        byte_E37AE = 0;
      }
    }
    else if ( (unsigned __int16)word_E37B6 <= 0x336u )
    {
      dword_E37BC = 22050;
      byte_E37AE = 0;
    }
    else if ( (unsigned __int16)word_E37B6 < 0x656u )
    {
      if ( word_E37B6 == 1611 )
      {
        dword_E37BC = 11025;
        byte_E37AE = 1;
      }
    }
    else if ( (unsigned __int16)word_E37B6 <= 0x656u )
    {
      dword_E37BC = 22050;
      byte_E37AE = 1;
    }
    else if ( word_E37B6 == 1644 )
    {
      dword_E37BC = 44100;
      byte_E37AE = 1;
    }
    sub_91A80(0, 200);
    sub_91A80(1, dword_E37BC);
    sub_91A80(3, 100);
    sub_91A80(4, dword_E3794 + 1);
    sub_91A80(5, 127);
    sub_91A80(6, 655);
    if ( byte_E379C )
      sub_91A80(7, 1);
    else
      sub_91A80(7, 0);
    if ( !byte_E379B )
      sub_91A80(17, 0);
    if ( byte_E37AE )
    {
      sub_91A80(8, 1);
      sub_91A80(9, 1);
    }
    else
    {
      sub_91A80(8, 0);
      sub_91A80(9, 0);
    }
    sub_90EE0();
    dword_180B48 = (int)sub_93330(a4, a3, byte_180AB0, &unk_181D90);
    if ( dword_180B48 )
    {
      sub_90F20();
      if ( byte_E3798 )
      {
        dword_180B4C = (int)&unk_180750 + 23 * dword_E3794;
        v12 = (char *)&unk_180750;
        v13 = 0;
        while ( (unsigned int)v12 < dword_180B4C )
        {
          v5 = sub_93510(dword_180B48);
          *(_DWORD *)v12 = v5;
          v12[20] = 0;
          v12 += 23;
          ++v13;
        }
        byte_E379A = 1;
        sub_8E470(dword_E37B0);
      }
    }
    else
    {
      if ( !byte_E37FC )
        sub_919C0();
      sub_90F20();
      byte_E3798 = 0;
      byte_E3799 = 0;
      sub_83E80(dword_E37A0);
      dword_E37A4 = 0;
      sub_83E80(dword_E37A8);
    }
  }
  else
  {
    if ( !byte_E37FC )
      sub_919C0();
    byte_E3798 = 0;
    byte_E3799 = 0;
    printf(aCouldNotLoadAn_0);
  }
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// 99E33: using guessed type _DWORD __cdecl getenv(_DWORD);
// 9E187: using guessed type _DWORD sscanf(_DWORD, _DWORD, ...);
// E3794: using guessed type int dword_E3794;
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E379A: using guessed type char byte_E379A;
// E379B: using guessed type char byte_E379B;
// E379C: using guessed type char byte_E379C;
// E37A0: using guessed type int dword_E37A0;
// E37A4: using guessed type int dword_E37A4;
// E37A8: using guessed type int dword_E37A8;
// E37AE: using guessed type char byte_E37AE;
// E37B0: using guessed type int dword_E37B0;
// E37B4: using guessed type __int16 word_E37B4;
// E37B6: using guessed type __int16 word_E37B6;
// E37B8: using guessed type char byte_E37B8;
// E37BC: using guessed type int dword_E37BC;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E37FE: using guessed type char byte_E37FE;
// 180B30: using guessed type __int16 word_180B30;
// 180B48: using guessed type int dword_180B48;
// 180B4C: using guessed type int dword_180B4C;

//----- (0008D800) --------------------------------------------------------
void sub_8D800()
{
  int v0; // [esp+4h] [ebp-4h]

  v0 = 1;
  while ( v0 )
  {
    v0 = sub_84300(byte_E37AC);
    if ( v0 )
    {
      if ( (unsigned __int16)word_E37B6 < 0x336u )
      {
        if ( (unsigned __int16)word_E37B6 >= 0x320u )
        {
          if ( (unsigned __int16)word_E37B6 <= 0x320u )
          {
            word_E37B6 = 0;
            return;
          }
          if ( word_E37B6 == 811 )
            word_E37B6 = 800;
        }
      }
      else if ( (unsigned __int16)word_E37B6 <= 0x336u )
      {
        word_E37B6 = 1611;
      }
      else if ( (unsigned __int16)word_E37B6 < 0x656u )
      {
        if ( word_E37B6 == 1611 )
          word_E37B6 = 811;
      }
      else if ( (unsigned __int16)word_E37B6 <= 0x656u )
      {
        word_E37B6 = 822;
      }
      else if ( word_E37B6 == 1644 )
      {
        word_E37B6 = 1622;
      }
    }
  }
}
// E37AC: using guessed type char byte_E37AC;
// E37B6: using guessed type __int16 word_E37B6;

//----- (0008D8F0) --------------------------------------------------------
int sub_8D8F0()
{
  int *i; // [esp+0h] [ebp-4h]

  if ( byte_E3798 && byte_E3799 )
  {
    sub_8F850();
    for ( i = (int *)&unk_180750; (unsigned int)i < dword_180B4C; i = (int *)((char *)i + 23) )
    {
      sub_93D00(*i);
      *((_WORD *)i + 9) = 0;
      *(int *)((char *)i + 14) = 0;
      *((_BYTE *)i + 20) = 0;
      *((_BYTE *)i + 21) = 0;
    }
  }
  return sub_9F040();
}
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// 180B4C: using guessed type int dword_180B4C;

//----- (0008D970) --------------------------------------------------------
void __fastcall sub_8D970(int a1, unsigned __int16 a2, int a3, int a4)
{
  int (__cdecl *v4)(int); // eax
  char v5[144]; // [esp+0h] [ebp-C8h] BYREF
  char v6[24]; // [esp+90h] [ebp-38h] BYREF
  char v7[16]; // [esp+A8h] [ebp-20h] BYREF
  int v8; // [esp+B8h] [ebp-10h]
  char v9; // [esp+C0h] [ebp-8h]

  v9 = 0;
  if ( !byte_E37FC )
    return;
  if ( !byte_E37B8 )
  {
    sub_90F60();
    sub_9D3F0(sub_83CD0);
    v4 = sub_9D420((int (__cdecl *)(int))sub_83E80);
    sub_917D0((int)v4, a2);
    byte_E37B8 = 1;
  }
  sub_91A80(11, 120);
  sub_91A80(12, 1);
  sub_91A80(13, 127);
  sub_91A80(14, 1);
  sub_91A80(15, 0);
  sub_91A80(16, 12);
  if ( !byte_E379B )
    sub_91A80(17, 0);
  if ( !strcmp(byte_181B50, &aD_2[2]) )
    sprintf(v5, "%c:%sSOUND/SAMPLE", dword_181BE0 + 64, byte_181B50);
  else
    sprintf(v5, "%c:%s/SOUND/SAMPLE", dword_181BE0 + 64, byte_181B50);
  sub_96AE0(v5);
  if ( (char)sub_90EE0() == -1 )
  {
    byte_E37FC = 0;
    byte_E37FD = 0;
    if ( byte_E3798 && byte_E379A )
    {
      sub_99C10();
    }
    else
    {
      byte_E3798 = 0;
      byte_E3799 = 0;
      sub_919C0();
    }
    return;
  }
  v8 = getenv(aMdmusic);
  if ( v8 )
  {
    sscanf(v8, "%s %x %d %d %d", v7, v6, &v6[2], &v6[4], &v6[6]);
    dword_180C7C = (int)sub_95850(a4, a3, v7, v6);
    if ( !dword_180C7C )
    {
      if ( !byte_E3798 )
        sub_919C0();
LABEL_30:
      sub_90F20();
      byte_E37FC = 0;
      byte_E37FD = 0;
      return;
    }
    sprintf(&unk_180BE0, "%s", v7);
    v9 = 1;
  }
  else
  {
    if ( sub_92190((int)&unk_180B60, aMdiIni) )
    {
      if ( !stricmp(&unk_180BE0, aNone_0) )
      {
        if ( !byte_E3798 )
          sub_919C0();
        goto LABEL_30;
      }
      if ( !sub_95710(a4, a3, (int **)&dword_180C7C) )
        v9 = 1;
    }
    if ( !v9 )
    {
      if ( !byte_E3798 )
        sub_919C0();
      goto LABEL_30;
    }
    sub_90F20();
  }
  sub_90F20();
  dword_180C78 = (int)sub_95A30(dword_180C7C);
  if ( !stricmp(&unk_180BE0, aAdlibMdi)
    || !stricmp(&unk_180BE0, aAdlibgMdi)
    || !stricmp(&unk_180BE0, aOpl3Mdi)
    || !stricmp(&unk_180BE0, aPasMdi)
    || !stricmp(&unk_180BE0, aPasplusMdi)
    || !stricmp(&unk_180BE0, aSblasterMdi)
    || !stricmp(&unk_180BE0, aSbpro1Mdi)
    || !stricmp(&unk_180BE0, aSbpro2Mdi)
    || !stricmp(&unk_180BE0, aEsfmMdi) )
  {
    goto LABEL_58;
  }
  if ( !stricmp(&unk_180BE0, aSbawe32Mdi) )
  {
    sprintf(&byte_180C84, &aApew[3]);
    sub_9F740((int)aBullfrog);
    if ( !byte_E3815 )
      sprintf(&byte_180C84, &aDig[2]);
    goto LABEL_62;
  }
  if ( !stricmp(&unk_180BE0, aMpu401Mdi) || !stricmp(&unk_180BE0, aSndscapeMdi) )
    goto LABEL_55;
  if ( !stricmp(&unk_180BE0, aMt32mpuMdi) )
  {
    sprintf(&byte_180C84, &aOpr[2]);
LABEL_62:
    if ( byte_E37FC && sub_8EAD0((unsigned __int8)byte_E3814) )
    {
      if ( byte_E3815 == 1 )
      {
        sub_9FA80();
        byte_E3815 = 0;
      }
      sub_959A0((unsigned int *)dword_180C7C);
      if ( !byte_E3798 )
        sub_919C0();
      byte_E37FC = 0;
      byte_E37FD = 0;
      printf(aErrorOpeningMu);
    }
    else
    {
      byte_E37FE = 1;
      sub_8E410((_DWORD *)dword_E37F8);
    }
    return;
  }
  if ( !sub_969A0((_DWORD *)dword_180C7C) )
  {
LABEL_55:
    sprintf(&byte_180C84, &aDig[2]);
    goto LABEL_62;
  }
  if ( sub_969A0((_DWORD *)dword_180C7C) == 1 || sub_969A0((_DWORD *)dword_180C7C) == 2 )
  {
LABEL_58:
    sprintf(&byte_180C84, &aT32f[3]);
    goto LABEL_62;
  }
  sub_959A0((unsigned int *)dword_180C7C);
  if ( !byte_E3798 )
    sub_919C0();
  byte_E37FC = 0;
  byte_E37FD = 0;
  printf(aErrorDriverNot);
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// 99E33: using guessed type _DWORD __cdecl getenv(_DWORD);
// 9A050: using guessed type _DWORD __cdecl strcmp(_DWORD, _DWORD);
// 9E187: using guessed type _DWORD sscanf(_DWORD, _DWORD, ...);
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E379A: using guessed type char byte_E379A;
// E379B: using guessed type char byte_E379B;
// E37B8: using guessed type char byte_E37B8;
// E37F8: using guessed type int dword_E37F8;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E37FE: using guessed type char byte_E37FE;
// E3814: using guessed type char byte_E3814;
// E3815: using guessed type char byte_E3815;
// 180C78: using guessed type int dword_180C78;
// 180C7C: using guessed type int dword_180C7C;
// 180C84: using guessed type char byte_180C84;
// 181BE0: using guessed type int dword_181BE0;

//----- (0008E020) --------------------------------------------------------
void sub_8E020()
{
  if ( byte_E37FC && byte_E37FD && word_E3802 )
  {
    if ( byte_E3818 )
      sub_92DC0(dword_180C80);
    byte_E3819 = 0;
    byte_E3818 = 0;
    byte_E3817 = 1;
    byte_E3816 = 0;
    byte_E381A = -1;
    if ( sub_96170(dword_180C78) != 2 )
    {
      sub_95DE0((int *)dword_180C78);
      sub_95F00(dword_180C78);
    }
    word_E3802 = 0;
  }
}
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E3802: using guessed type __int16 word_E3802;
// E3816: using guessed type char byte_E3816;
// E3817: using guessed type char byte_E3817;
// E3818: using guessed type char byte_E3818;
// E3819: using guessed type char byte_E3819;
// E381A: using guessed type char byte_E381A;
// 180C78: using guessed type int dword_180C78;
// 180C80: using guessed type int dword_180C80;

//----- (0008E160) --------------------------------------------------------
void __cdecl sub_8E160(__int16 a1, unsigned __int8 a2)
{
  unsigned __int8 i; // [esp+0h] [ebp-4h]

  if ( byte_E37FC && byte_E37FD && a1 <= (int)(unsigned __int16)word_E3804 && (unsigned __int16)word_E3802 != a1 )
  {
    if ( byte_E3818 )
      sub_92DC0(dword_180C80);
    byte_E3819 = 0;
    byte_E3818 = 0;
    byte_E3817 = 1;
    byte_E3816 = 0;
    byte_E381A = -1;
    if ( word_E3802 )
    {
      if ( sub_96170(dword_180C78) != 2 )
      {
        sub_95DE0((int *)dword_180C78);
        sub_95F00(dword_180C78);
      }
      word_E3802 = 0;
    }
    sub_95C00((int *)dword_180C78, *(_DWORD *)(dword_E3808 + 32 * a1 + 18), 0);
    sub_97670(dword_180C78, (int)sub_8E0D0);
    for ( i = 0; i < 0x10u; ++i )
    {
      byte_180C90[i] = 0;
      sub_98360((_DWORD *)dword_180C7C, dword_180C78, i | 0xB0, 0, 0);
      sub_98360((_DWORD *)dword_180C7C, dword_180C78, i | 0xB0, 7u, 0);
      sub_98360((_DWORD *)dword_180C7C, dword_180C78, i | 0xE0, 0, 64);
      sub_98360((_DWORD *)dword_180C7C, dword_180C78, i | 0xB0, 0xBu, 127);
      sub_98360((_DWORD *)dword_180C7C, dword_180C78, i | 0xB0, 1u, 0);
      sub_98360((_DWORD *)dword_180C7C, dword_180C78, i | 0xB0, 0x5Bu, 0);
      sub_98360((_DWORD *)dword_180C7C, dword_180C78, i | 0xB0, 0x5Du, 0);
    }
    if ( a2 < 0x7Fu )
      sub_96030((_DWORD *)dword_180C78, a2, 0);
    sub_95D50((int *)dword_180C78);
    word_E3800 = 100;
    word_E3802 = a1;
  }
}
// 8E0D0: using guessed type int sub_8E0D0();
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E3800: using guessed type __int16 word_E3800;
// E3802: using guessed type __int16 word_E3802;
// E3804: using guessed type __int16 word_E3804;
// E3808: using guessed type int dword_E3808;
// E3816: using guessed type char byte_E3816;
// E3817: using guessed type char byte_E3817;
// E3818: using guessed type char byte_E3818;
// E3819: using guessed type char byte_E3819;
// E381A: using guessed type char byte_E381A;
// 180C78: using guessed type int dword_180C78;
// 180C7C: using guessed type int dword_180C7C;
// 180C80: using guessed type int dword_180C80;

//----- (0008E410) --------------------------------------------------------
_DWORD *__cdecl sub_8E410(_DWORD *a1)
{
  _DWORD *result; // eax

  if ( byte_E37FC )
  {
    if ( byte_E37FE )
    {
      result = a1;
      if ( a1 != (_DWORD *)dword_E37F8 && (unsigned int)a1 < 0x80 )
      {
        sub_96670((_DWORD *)dword_180C7C, a1);
        result = a1;
        dword_E37F8 = (int)a1;
      }
    }
  }
  return result;
}
// E37F8: using guessed type int dword_E37F8;
// E37FC: using guessed type char byte_E37FC;
// E37FE: using guessed type char byte_E37FE;
// 180C7C: using guessed type int dword_180C7C;

//----- (0008E470) --------------------------------------------------------
unsigned int __cdecl sub_8E470(unsigned int a1)
{
  unsigned int result; // eax

  if ( byte_E3798 )
  {
    if ( byte_E379A )
    {
      result = a1;
      if ( a1 != dword_E37B0 && a1 < 0x80 )
      {
        sub_94650((_DWORD *)dword_180B48, a1);
        result = a1;
        dword_E37B0 = a1;
      }
    }
  }
  return result;
}
// E3798: using guessed type char byte_E3798;
// E379A: using guessed type char byte_E379A;
// E37B0: using guessed type int dword_E37B0;
// 180B48: using guessed type int dword_180B48;

//----- (0008E673) --------------------------------------------------------
__int16 sub_8E673()
{
  __int16 result; // ax

  sub_8F023(dword_E3840, (int)&word_E3828, 2u);
  sub_8F023(dword_E3840, dword_E9C38, 8u);
  while ( 1 )
  {
    result = word_E3828;
    if ( !word_E3828 )
      break;
    --word_E3828;
    sub_8F023(dword_E3840, (int)&dword_E3824, 4u);
    sub_8F023(dword_E3840, (int)&word_E381C, 2u);
    switch ( word_E381C )
    {
      case 7:
        sub_8E871();
        break;
      case 12:
        sub_8E948();
        break;
      case 4:
        sub_8E7D5();
        break;
      case 15:
        sub_8E9EF();
        break;
      case 16:
        sub_8E799();
        break;
      default:
        sub_8E7B7();
        break;
    }
  }
  return result;
}
// E381C: using guessed type __int16 word_E381C;
// E3824: using guessed type int dword_E3824;
// E3828: using guessed type __int16 word_E3828;
// E3840: using guessed type int dword_E3840;
// E9C38: using guessed type int dword_E9C38;

//----- (0008E736) --------------------------------------------------------
__int16 sub_8E736()
{
  __int16 result; // ax

  sub_8F023(dword_E3840, dword_E9C38, dword_E3824 - 6);
  dword_E381E = *(_DWORD *)dword_E9C38;
  result = *(_WORD *)(dword_E9C38 + 4);
  word_E3822 = result;
  return result;
}
// E381E: using guessed type int dword_E381E;
// E3822: using guessed type __int16 word_E3822;
// E3824: using guessed type int dword_E3824;
// E3840: using guessed type int dword_E3840;
// E9C38: using guessed type int dword_E9C38;

//----- (0008E799) --------------------------------------------------------
int sub_8E799()
{
  return sub_8F023(dword_E3840, dword_180628, dword_E3824 - 6);
}
// E3824: using guessed type int dword_E3824;
// E3840: using guessed type int dword_E3840;
// 180628: using guessed type int dword_180628;

//----- (0008E7B7) --------------------------------------------------------
int sub_8E7B7()
{
  return sub_8F023(dword_E3840, dword_E9C38, dword_E3824 - 6);
}
// E3824: using guessed type int dword_E3824;
// E3840: using guessed type int dword_E3840;
// E9C38: using guessed type int dword_E9C38;

//----- (0008E7D5) --------------------------------------------------------
int sub_8E7D5()
{
  int result; // eax

  result = sub_8F023(dword_E3840, dword_EA3C8, dword_E3824 - 6);
  word_E387A = 1;
  return result;
}
// E3824: using guessed type int dword_E3824;
// E3840: using guessed type int dword_E3840;
// E387A: using guessed type __int16 word_E387A;
// EA3C8: using guessed type int dword_EA3C8;

//----- (0008E7FC) --------------------------------------------------------
void sub_8E7FC()
{
  __int16 v0; // ax
  char *v1; // edi
  _BYTE *v2; // esi
  int v3; // ecx
  char *v4; // edi
  char v5; // dl
  char v6; // al
  char *v7; // edi
  _BYTE *v8; // esi
  char v9; // al
  char v10; // al
  __int16 v11; // [esp-2h] [ebp-6h]

  word_E387A = 0;
  if ( dword_E383C == 1 )
  {
    v0 = *(_WORD *)dword_EA3C8;
    v1 = (char *)(dword_EA3C8 + 2);
    v2 = (_BYTE *)dword_EA3B8;
    do
    {
      v11 = v0;
      v3 = (unsigned __int8)*v1;
      v4 = v1 + 1;
      v2 += v3 + v3 + v3;
      v5 = *v4;
      v1 = v4 + 1;
      do
      {
        v6 = *v1;
        v7 = v1 + 1;
        *v2 = v6;
        v8 = v2 + 1;
        v9 = *v7++;
        *v8++ = v9;
        v10 = *v7;
        v1 = v7 + 1;
        *v8 = v10;
        v2 = v8 + 1;
        --v5;
      }
      while ( v5 );
      v0 = v11 - 1;
    }
    while ( v11 != 1 );
    sub_41A90((unsigned __int8 *)dword_EA3B8);
  }
}
// E383C: using guessed type int dword_E383C;
// E387A: using guessed type __int16 word_E387A;
// EA3B8: using guessed type int dword_EA3B8;
// EA3C8: using guessed type int dword_EA3C8;

//----- (0008E871) --------------------------------------------------------
__int16 sub_8E871()
{
  _WORD *v0; // esi
  __int16 *v1; // edi
  __int16 result; // ax
  unsigned __int8 v3; // bl
  _BYTE *v4; // edi
  char v5; // dl
  __int16 v6; // bx
  __int16 v7; // bx
  _WORD *v8; // [esp+0h] [ebp-10h]
  __int16 i; // [esp+6h] [ebp-Ah]
  __int16 v10; // [esp+8h] [ebp-8h]
  int v11; // [esp+Ch] [ebp-4h]

  v11 = (unsigned __int16)word_E3820;
  sub_8F023(dword_E3840, dword_E9C38, dword_E3824 - 6);
  v0 = (_WORD *)dword_180628;
  v10 = *(_WORD *)dword_E9C38;
  v1 = (__int16 *)(dword_E9C38 + 2);
  do
  {
    while ( 1 )
    {
      result = *v1++;
      v8 = v0;
      if ( result >= 0 )
        goto LABEL_6;
      if ( (result & 0x4000) == 0 )
        break;
      v0 = (_WORD *)((char *)v0 + v11 * -result);
    }
    *((_BYTE *)v0 + v11 - 1) = result;
LABEL_6:
    for ( i = result; i; --i )
    {
      while ( 1 )
      {
        v3 = *(_BYTE *)v1;
        v4 = (char *)v1 + 1;
        v0 = (_WORD *)((char *)v0 + v3);
        v5 = *v4;
        v1 = (__int16 *)(v4 + 1);
        if ( v5 > 0 )
          break;
        v6 = *v1++;
        do
        {
          *v0++ = v6;
          ++v5;
        }
        while ( v5 );
        if ( !--i )
          goto LABEL_14;
      }
      do
      {
        v7 = *v1++;
        *v0++ = v7;
        --v5;
      }
      while ( v5 );
    }
LABEL_14:
    v0 = (_WORD *)((char *)v8 + v11);
    --v10;
  }
  while ( v10 );
  return result;
}
// E3820: using guessed type __int16 word_E3820;
// E3824: using guessed type int dword_E3824;
// E3840: using guessed type int dword_E3840;
// E9C38: using guessed type int dword_E9C38;
// 180628: using guessed type int dword_180628;

//----- (0008E948) --------------------------------------------------------
int sub_8E948()
{
  int v0; // eax
  char *v1; // esi
  char *v2; // edi
  __int16 v3; // ax
  int v4; // eax
  _BYTE *v5; // esi
  char *v6; // edi
  unsigned __int8 v7; // al
  char *v8; // esi
  unsigned int v9; // ecx
  char v10; // al
  int result; // eax
  int v12; // [esp+0h] [ebp-10h]
  __int16 i; // [esp+6h] [ebp-Ah]
  __int16 v14; // [esp+8h] [ebp-8h]
  int v15; // [esp+Ch] [ebp-4h]

  v15 = (unsigned __int16)word_E3820;
  v0 = sub_8F023(dword_E3840, dword_E9C38, dword_E3824 - 6);
  LOWORD(v0) = *(_WORD *)dword_E9C38;
  v12 = v15 * v0 + dword_180628;
  v1 = (char *)(dword_E9C38 + 4);
  v14 = *(_WORD *)(dword_E9C38 + 2);
  do
  {
    v2 = (char *)v12;
    v3 = (unsigned __int8)*v1++;
    for ( i = v3; i; --i )
    {
      v4 = (unsigned __int8)*v1;
      v5 = v1 + 1;
      v6 = &v2[v4];
      v7 = *v5;
      v8 = v5 + 1;
      if ( (v7 & 0x80u) != 0 )
      {
        v9 = (unsigned __int8)-v7;
        v10 = *v8;
        v1 = v8 + 1;
        memset(v6, v10, v9);
        v2 = &v6[v9];
      }
      else
      {
        qmemcpy(v6, v8, v7);
        v1 = &v8[v7];
        v2 = &v6[v7];
      }
    }
    result = (unsigned __int16)word_E3820;
    v12 += (unsigned __int16)word_E3820;
    --v14;
  }
  while ( v14 );
  return result;
}
// E3820: using guessed type __int16 word_E3820;
// E3824: using guessed type int dword_E3824;
// E3840: using guessed type int dword_E3840;
// E9C38: using guessed type int dword_E9C38;
// 180628: using guessed type int dword_180628;

//----- (0008E9EF) --------------------------------------------------------
char sub_8E9EF()
{
  _BYTE *v0; // esi
  char *v1; // edi
  __int16 v2; // bx
  __int16 v3; // cx
  char v4; // dl
  __int16 v5; // ax
  char v6; // dh
  char v7; // dh
  __int16 v9; // [esp+0h] [ebp-4h]
  __int16 v10; // [esp+2h] [ebp-2h]

  v10 = word_E3820;
  v9 = word_E3822;
  sub_8F023(dword_E3840, dword_E9C38, dword_E3824 - 6);
  v0 = (_BYTE *)dword_180628;
  v1 = (char *)dword_E9C38;
  v2 = v9;
  do
  {
    ++v1;
    v3 = v10;
    do
    {
      v4 = *v1++;
      if ( v4 > 0 )
      {
        LOBYTE(v5) = v4;
        v3 -= (unsigned __int8)v4;
      }
      else
      {
        HIBYTE(v5) = -1;
        LOBYTE(v5) = v4;
        v3 += v5;
      }
      if ( v4 > 0 )
      {
        v7 = *v1++;
        do
        {
          *v0++ = v7;
          --v4;
        }
        while ( v4 );
      }
      else
      {
        do
        {
          v6 = *v1++;
          *v0++ = v6;
          ++v4;
        }
        while ( v4 );
      }
    }
    while ( v3 );
    --v2;
  }
  while ( v2 );
  return v5;
}
// E3820: using guessed type __int16 word_E3820;
// E3822: using guessed type __int16 word_E3822;
// E3824: using guessed type int dword_E3824;
// E3840: using guessed type int dword_E3840;
// E9C38: using guessed type int dword_E9C38;
// 180628: using guessed type int dword_180628;

//----- (0008EA7B) --------------------------------------------------------
void __fastcall sub_8EA7B(int a1, __int16 a2)
{
  __int16 v2; // cx

  if ( dword_E3844 )
  {
    do
    {
      do
      {
        __asm { int     21h; DOS - GET CURRENT TIME }
        v2 = 100 * HIBYTE(a2) + (unsigned __int8)a2;
        a2 = v2 - word_E3834;
      }
      while ( v2 == word_E3834 );
      if ( a2 <= 0 )
        a2 += 6000;
    }
    while ( (unsigned __int16)a2 < dword_E3844 );
    word_E3834 = v2;
  }
}
// E3834: using guessed type __int16 word_E3834;
// E3844: using guessed type int dword_E3844;

//----- (0008EAD0) --------------------------------------------------------
int __cdecl sub_8EAD0(__int16 a1)
{
  _WORD v2[4]; // [esp+44h] [ebp-1Ch] BYREF
  int v4; // [esp+50h] [ebp-10h]
  int v5; // [esp+54h] [ebp-Ch] BYREF
  int v6; // [esp+58h] [ebp-8h]
  int v7; // [esp+5Ch] [ebp-4h]
  unsigned __int16 v8; // [esp+74h] [ebp+14h]

  if ( !byte_E37FC )
    return 0;
  sub_8E020();
  v4 = sub_98817((int)aSoundMusicDat, 512);
  if ( !v4 )
    return 0;
  sub_9891E(v4, 0, 2);
  v7 = tell(v4);
  sub_9891E(v4, v7 - 4, 0);
  sub_988A7(v4, (int)&v5, 4);
  sub_9891E(v4, v5, 0);
  sub_988A7(v4, (int)v2, 8);
  v8 = a1 + 1;
  if ( (unsigned __int8)byte_180C84 >= 0x57u )
  {
    if ( (unsigned __int8)byte_180C84 <= 0x57u )
    {
LABEL_23:
      v6 = 3;
      goto LABEL_24;
    }
    if ( (unsigned __int8)byte_180C84 >= 0x67u )
    {
      if ( (unsigned __int8)byte_180C84 > 0x67u )
      {
        if ( (unsigned __int8)byte_180C84 < 0x72u )
          goto LABEL_24;
        if ( (unsigned __int8)byte_180C84 > 0x72u )
        {
          if ( byte_180C84 != 119 )
            goto LABEL_24;
          goto LABEL_23;
        }
        goto LABEL_21;
      }
      goto LABEL_20;
    }
    if ( byte_180C84 != 102 )
      goto LABEL_24;
LABEL_22:
    v6 = 2;
    goto LABEL_24;
  }
  if ( (unsigned __int8)byte_180C84 < 0x47u )
  {
    if ( byte_180C84 != 70 )
      goto LABEL_24;
    goto LABEL_22;
  }
  if ( (unsigned __int8)byte_180C84 > 0x47u )
  {
    if ( byte_180C84 != 82 )
      goto LABEL_24;
LABEL_21:
    v6 = 1;
    goto LABEL_24;
  }
LABEL_20:
  v6 = 0;
LABEL_24:
  if ( v8 <= v2[v6] )
  {
    sub_9891E(v4, (unsigned __int16)(v8 - 1) << 6, 1);
    if ( sub_8ED00(v4, v6) )
    {
      sub_98882(v4);
      return 0;
    }
  }
  sub_98882(v4);
  return 1;
}
// 9A510: using guessed type _DWORD __cdecl tell(_DWORD);
// E37FC: using guessed type char byte_E37FC;
// 180C84: using guessed type char byte_180C84;
// 8EAD0: using guessed type _WORD var_1C[4];

//----- (0008EC90) --------------------------------------------------------
unsigned int sub_8EC90()
{
  unsigned int result; // eax
  unsigned int v1; // [esp+0h] [ebp-4h]

  if ( dword_E3808 && dword_E3810 )
  {
    v1 = dword_E3808 + 32;
    for ( word_E3804 = 0; ; ++word_E3804 )
    {
      result = v1;
      if ( v1 >= dword_E380C )
        break;
      *(_DWORD *)(v1 + 18) += dword_E3810;
      v1 += 32;
    }
  }
  return result;
}
// E3804: using guessed type __int16 word_E3804;
// E3808: using guessed type int dword_E3808;
// E380C: using guessed type int dword_E380C;
// E3810: using guessed type int dword_E3810;

//----- (0008ED00) --------------------------------------------------------
char __cdecl sub_8ED00(int a1, unsigned __int8 a2)
{
  _DWORD v3[16]; // [esp+0h] [ebp-5Ch] BYREF
  char *v4; // [esp+40h] [ebp-1Ch]
  int v5; // [esp+44h] [ebp-18h]
  char *v6; // [esp+4Ch] [ebp-10h]
  int v7; // [esp+50h] [ebp-Ch]
  unsigned __int8 i; // [esp+58h] [ebp-4h]

  v5 = tell(a1);
  sub_988A7(a1, (int)v3, 64);
  if ( v3[4 * a2 + 1] == -1 )
    return 0;
  if ( dword_E3810 )
  {
    sub_83E80(dword_E3810);
    byte_E37FC = 0;
  }
  if ( dword_E3808 )
  {
    sub_83E80(dword_E3808);
    byte_E37FC = 0;
  }
  dword_E3810 = sub_83CD0(v3[4 * a2 + 3]);
  if ( !dword_E3810 )
    return 0;
  dword_E3808 = sub_83CD0(v3[4 * a2 + 2]);
  if ( !dword_E3808 )
  {
    sub_83E80(dword_E3810);
    return 0;
  }
  v4 = (char *)dword_E3810;
  v6 = (char *)dword_E3808;
  dword_E380C = v3[4 * a2 + 2] + dword_E3808;
  sub_9891E(a1, v3[4 * a2 + 1], 0);
  sub_988A7(a1, (int)v4, 8);
  if ( *v4 == 82 && v4[1] == 78 && v4[2] == 67 )
  {
    v7 = (unsigned __int8)v4[4];
    v7 <<= 8;
    v7 += (unsigned __int8)v4[5];
    v7 <<= 8;
    v7 += (unsigned __int8)v4[6];
    v7 <<= 8;
    v7 += (unsigned __int8)v4[7];
    sub_988A7(a1, dword_E3810 + 8, v7 - 8);
    sub_9894C((int)v4, v4);
  }
  else
  {
    sub_988A7(a1, dword_E3810 + 8, v3[4 * a2 + 3] - 8);
  }
  sub_9891E(a1, v3[4 * a2], 0);
  sub_988A7(a1, (int)v6, 8);
  if ( *v6 == 82 && v6[1] == 78 && v6[2] == 67 )
  {
    v7 = (unsigned __int8)v6[4];
    v7 <<= 8;
    v7 += (unsigned __int8)v6[5];
    v7 <<= 8;
    v7 += (unsigned __int8)v6[6];
    v7 <<= 8;
    v7 += (unsigned __int8)v6[7];
    sub_988A7(a1, dword_E3808 + 8, v7 - 8);
    sub_9894C((int)v6, v6);
  }
  else
  {
    sub_988A7(a1, dword_E3808 + 8, v3[4 * a2 + 2] - 8);
  }
  sub_8EC90();
  for ( i = 1; i <= (int)(unsigned __int16)word_E3804; ++i )
    sub_95C00((int *)dword_180C78, *(_DWORD *)(dword_E3808 + 32 * i + 18), 0);
  byte_E37FC = 1;
  return 1;
}
// 9A510: using guessed type _DWORD __cdecl tell(_DWORD);
// E37FC: using guessed type char byte_E37FC;
// E3804: using guessed type __int16 word_E3804;
// E3808: using guessed type int dword_E3808;
// E380C: using guessed type int dword_E380C;
// E3810: using guessed type int dword_E3810;
// 180C78: using guessed type int dword_180C78;
// 8ED00: using guessed type _DWORD var_5C[16];

//----- (0008F023) --------------------------------------------------------
int __cdecl sub_8F023(int a1, int a2, unsigned int a3)
{
  _BYTE *v3; // eax
  _BYTE *v4; // edx
  unsigned int i; // [esp+4h] [ebp-4h]

  if ( !dword_E387C )
    return sub_988A7(a1, a2, a3);
  for ( i = 0; i < a3 && dword_E3888 + i < dword_E3884; ++i )
  {
    v3 = (_BYTE *)dword_E3880++;
    v4 = (_BYTE *)a2++;
    *v4 = *v3;
  }
  dword_E3888 += a3;
  return i;
}
// E387C: using guessed type int dword_E387C;
// E3880: using guessed type int dword_E3880;
// E3884: using guessed type int dword_E3884;
// E3888: using guessed type int dword_E3888;

//----- (0008F0AB) --------------------------------------------------------
int __cdecl sub_8F0AB(int a1, int a2, int a3)
{
  int result; // eax

  result = read(a1, dword_E387C, a3);
  dword_E3880 = dword_E387C;
  dword_E3884 = result;
  dword_E3888 = 0;
  return result;
}
// A0863: using guessed type _DWORD __cdecl read(_DWORD, _DWORD, _DWORD);
// E387C: using guessed type int dword_E387C;
// E3880: using guessed type int dword_E3880;
// E3884: using guessed type int dword_E3884;
// E3888: using guessed type int dword_E3888;

//----- (0008F100) --------------------------------------------------------
int *__cdecl sub_8F100(int a1, __int16 a2, int a3, int a4, unsigned __int16 a5, char a6, unsigned __int8 a7)
{
  char v8; // [esp+0h] [ebp-18h]
  int *i; // [esp+8h] [ebp-10h]
  char *j; // [esp+8h] [ebp-10h]
  int *k; // [esp+8h] [ebp-10h]
  int *m; // [esp+8h] [ebp-10h]
  int *n; // [esp+8h] [ebp-10h]
  int *v14; // [esp+Ch] [ebp-Ch]
  char *v15; // [esp+10h] [ebp-8h]

  if ( !byte_E3798
    || !byte_E3799
    || a2 > (int)(unsigned __int16)word_180B50
    || !stricmp(32 * a2 + dword_E37A0, aNullWav) )
  {
    return 0;
  }
  v8 = 0;
  if ( a7 < 2u )
  {
    if ( a7 == 1 )
    {
      v14 = 0;
      for ( i = (int *)&unk_180750; (unsigned int)i < dword_180B4C; i = (int *)((char *)i + 23) )
      {
        if ( sub_94010(*i) == 2 )
        {
          v14 = i;
          v15 = 0;
          break;
        }
      }
    }
  }
  else if ( a7 <= 2u )
  {
    v15 = 0;
    for ( j = (char *)&unk_180750; (unsigned int)j < dword_180B4C; j += 23 )
    {
      if ( *(_DWORD *)(j + 14) == a1 && *((_WORD *)j + 9) == a2 && sub_94010(*(_DWORD *)j) != 2 )
      {
        v15 = j;
        break;
      }
    }
    if ( !v15 )
    {
      v14 = 0;
      for ( k = (int *)&unk_180750; (unsigned int)k < dword_180B4C; k = (int *)((char *)k + 23) )
      {
        if ( sub_94010(*k) == 2 )
        {
          v14 = k;
          break;
        }
      }
    }
  }
  else if ( a7 == 3 )
  {
    v8 = 0;
    for ( m = (int *)&unk_180750; (unsigned int)m < dword_180B4C; m = (int *)((char *)m + 23) )
    {
      if ( *(int *)((char *)m + 14) == a1 && *((_WORD *)m + 9) == a2 )
      {
        v14 = m;
        v15 = 0;
        v8 = 1;
        break;
      }
    }
    if ( !v8 )
    {
      v14 = 0;
      for ( n = (int *)&unk_180750; (unsigned int)n < dword_180B4C; n = (int *)((char *)n + 23) )
      {
        if ( sub_94010(*n) == 2 )
        {
          v14 = n;
          v15 = 0;
          break;
        }
      }
    }
  }
  if ( !v14 || v15 )
    return 0;
  if ( !v8 )
  {
    sub_93830((int *)*v14);
    sub_938C0((int *)*v14, *(_DWORD *)(dword_E37A0 + 32 * a2 + 18), 1);
  }
  sub_93E30((int *)*v14, a3);
  sub_93ED0((int *)*v14, a4);
  sub_93D90(*v14, dword_E37BC * (unsigned int)a5 / 0x64);
  sub_93F70(*v14, a6 + 1);
  sub_93B50((int *)*v14);
  *(int *)((char *)v14 + 14) = a1;
  *((_WORD *)v14 + 9) = a2;
  v14[1] = a3;
  *((_WORD *)v14 + 5) = a4;
  *((_WORD *)v14 + 4) = a5;
  *((_BYTE *)v14 + 20) = 0;
  *((_BYTE *)v14 + 21) = 0;
  return v14;
}
// 8F31B: variable 'v14' is possibly undefined
// 8F321: variable 'v15' is possibly undefined
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E37A0: using guessed type int dword_E37A0;
// E37BC: using guessed type int dword_E37BC;
// 180B4C: using guessed type int dword_180B4C;
// 180B50: using guessed type __int16 word_180B50;

//----- (0008F420) --------------------------------------------------------
void __cdecl sub_8F420(int a1, __int16 a2)
{
  int *i; // [esp+0h] [ebp-4h]

  if ( byte_E3798 && byte_E3799 )
  {
    for ( i = (int *)&unk_180750; (unsigned int)i < dword_180B4C; i = (int *)((char *)i + 23) )
    {
      if ( *(int *)((char *)i + 14) == a1 && *((_WORD *)i + 9) == a2 && sub_94010(*i) != 2 )
      {
        sub_93D00(*i);
        return;
      }
    }
  }
}
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// 180B4C: using guessed type int dword_180B4C;

//----- (0008F710) --------------------------------------------------------
void __cdecl sub_8F710(int a1, __int16 a2, unsigned __int16 a3, unsigned __int8 a4, char a5)
{
  char *i; // [esp+0h] [ebp-4h]

  if ( byte_E3798 && byte_E3799 && a2 <= (int)(unsigned __int16)word_180B50 )
  {
    for ( i = (char *)&unk_180750; (unsigned int)i < dword_180B4C; i += 23 )
    {
      if ( *(_DWORD *)(i + 14) == a1 && *((_WORD *)i + 9) == a2 && sub_94010(*(_DWORD *)i) != 2 )
      {
        if ( a3 > 0x7Fu )
          a3 = 127;
        if ( a3 != *((_DWORD *)i + 1) )
        {
          i[20] = 0;
          *((_WORD *)i + 6) = a3;
          i[21] = a5;
          if ( a3 > *((int *)i + 1) )
            i[20] = 1;
          else
            i[20] = 2;
          if ( !byte_E388D )
          {
            byte_E388D = 1;
            if ( a4 <= 4u )
            {
              dword_180CA0 = sub_92600((int)sub_8F4B0);
              sub_92930(dword_180CA0, 30 * a4);
              sub_92BA0(dword_180CA0);
            }
          }
        }
        return;
      }
    }
  }
}
// 8F4B0: using guessed type int sub_8F4B0();
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E388D: using guessed type char byte_E388D;
// 180B4C: using guessed type int dword_180B4C;
// 180B50: using guessed type __int16 word_180B50;
// 180CA0: using guessed type int dword_180CA0;

//----- (0008F850) --------------------------------------------------------
char *sub_8F850()
{
  char *result; // eax
  char *i; // [esp+0h] [ebp-4h]

  if ( byte_E388D )
  {
    sub_92DC0(dword_180CA0[0]);
    byte_E388D = 0;
    for ( i = (char *)&unk_180750; ; i += 23 )
    {
      result = i;
      if ( (unsigned int)i >= dword_180B4C )
        break;
      i[20] = 0;
      i[21] = 0;
    }
  }
  return result;
}
// E388D: using guessed type char byte_E388D;
// 180B4C: using guessed type int dword_180B4C;
// 180CA0: using guessed type int dword_180CA0[];

//----- (0008F8B0) --------------------------------------------------------
int __cdecl sub_8F8B0(__int16 a1, __int16 a2, int a3)
{
  int v4; // [esp+4h] [ebp-4h]

  sub_8F935(*(_WORD *)(a3 + 4), a2, a1, *(char **)a3, 0, 0);
  return v4;
}
// 8F8E5: variable 'v4' is possibly undefined
// 180628: using guessed type int dword_180628;

//----- (0008F8E8) --------------------------------------------------------
int __cdecl sub_8F8E8(__int16 a1, __int16 a2, int a3)
{
  int v4; // [esp+4h] [ebp-4h]

  sub_8F935(*(_WORD *)(a3 + 4), a2, a1, *(char **)a3, 0, 0);
  return v4;
}
// 8F91D: variable 'v4' is possibly undefined
// 180628: using guessed type int dword_180628;

//----- (0008F920) --------------------------------------------------------
void __usercall sub_8F920(__int16 a1@<dx>, int a2@<ecx>, int a3@<ebx>, char *a4@<esi>, unsigned __int8 a5, char a6)
{
  sub_8F935(a1, a2, a3, a4, a5, a6);
}

//----- (0008F935) --------------------------------------------------------
void __usercall sub_8F935(__int16 a1@<dx>, int a2@<ecx>, int a3@<ebx>, char *a4@<esi>, unsigned __int8 a5, char a6)
{
  int v6; // edi
  _BYTE *v7; // edi
  int v8; // ecx
  int v9; // eax
  _BYTE *v10; // ebx
  char v11; // al
  char v12; // al
  char v13; // al
  _BYTE *v14; // edi
  int v15; // ecx
  int v16; // eax
  _BYTE *v17; // ebx
  char v18; // al
  char v19; // al
  char v20; // al
  char *v21; // edi
  unsigned int v22; // ecx
  int v23; // eax
  char *v24; // ebx
  char *v25; // edi
  char v26; // al
  char *v27; // esi
  char *v28; // edi
  unsigned int v29; // ecx
  int v30; // eax
  char *v31; // ebx
  char *v32; // edi
  char v33; // al
  char *v34; // esi
  int v35; // ebp
  _BYTE *v36; // edi
  int v37; // ecx
  _BYTE *v38; // ebx
  char v39; // al
  int v40; // eax
  _BYTE *v41; // edi
  int v42; // ecx
  unsigned __int8 i; // dl
  char v44; // al
  char v45; // al
  char v46; // cc
  char v47; // dl
  char v48; // al
  char *v49; // edi
  char v50; // al
  char v51; // dl
  char v52; // al
  char v53; // dl
  unsigned int v54; // ebx
  const void *v55; // esi
  char *v56; // edi
  unsigned int v57; // ecx
  int v58; // eax
  char *v59; // ebx
  char *v60; // edi
  char *v61; // edi
  unsigned int v62; // ecx
  int v63; // eax
  char *v64; // ebx
  char *v65; // edi
  char v66; // al
  char *v67; // esi
  int v68; // edi
  int v69; // ebx
  _BYTE *v70; // edi
  _BYTE *v71; // edx
  int v72; // ecx
  char v73; // al
  char v74; // al
  char v75; // al
  char v76; // al
  int v77; // ebx
  _BYTE *v78; // edi
  int v79; // ecx
  int v80; // eax
  _BYTE *v81; // ebx
  char v82; // al
  int v83; // ebx
  _BYTE *v84; // edi
  int v85; // ecx
  int v86; // eax
  _BYTE *v87; // ebx
  char v88; // al
  _BYTE *v89; // edi
  int v90; // ecx
  int v91; // ebx
  int v92; // eax
  _BYTE *v93; // ebx
  char v94; // al
  unsigned int v95; // ebx
  _BYTE *v96; // edi
  _BYTE *v97; // edx
  int v98; // ecx
  char v99; // al
  char v100; // al
  char v101; // al
  char v102; // al
  _BYTE *v103; // edi
  int v104; // ecx
  int v105; // ebx
  _BYTE *v106; // ebx
  int v107; // eax
  char v108; // al
  _BYTE *v109; // edi
  int v110; // ecx
  int v111; // ebx
  _BYTE *v112; // ebx
  int v113; // eax
  char v114; // al
  unsigned int v115; // ebx
  _BYTE *v116; // edi
  _BYTE *v117; // edx
  int v118; // ecx
  char v119; // al
  char v120; // al
  char v121; // al
  char v122; // al
  int v123; // eax
  int v124; // edi
  int v125; // eax
  int v126; // eax
  char v127; // al
  int v128; // eax
  char *v129; // [esp-4h] [ebp-Ch]
  unsigned __int8 v130; // [esp+2h] [ebp-6h]
  unsigned __int8 v131; // [esp+2h] [ebp-6h]
  unsigned __int8 v132; // [esp+2h] [ebp-6h]
  unsigned __int8 v133; // [esp+2h] [ebp-6h]
  unsigned __int8 v134; // [esp+2h] [ebp-6h]
  unsigned __int8 v135; // [esp+2h] [ebp-6h]
  unsigned __int8 v136; // [esp+2h] [ebp-6h]
  unsigned __int8 v137; // [esp+2h] [ebp-6h]
  char v138; // [esp+3h] [ebp-5h]
  char v139; // [esp+3h] [ebp-5h]
  _BYTE *v140; // [esp+4h] [ebp-4h]
  _BYTE *v141; // [esp+4h] [ebp-4h]

  if ( !HIBYTE(a1) )
    return;
  v6 = dword_180628 + dword_18063C + dword_18062C * dword_180650;
  if ( (word_180660 & 1) != 0 )
  {
    LOBYTE(a1) = (unsigned __int8)a1 >> 1;
    HIBYTE(a1) >>= 1;
    a3 >>= 1;
    a2 >>= 1;
  }
  if ( a2 < 0 )
  {
    if ( (word_E36D4 & 2) != 0 )
    {
      v126 = a2 + HIBYTE(a1);
      v46 = (v126 + 1 < 0) ^ __OFADD__(1, v126) | (v126 == -1);
      v127 = v126 + 1;
      if ( v46 )
        return;
      a2 = -1;
      HIBYTE(a1) = v127;
    }
    else
    {
      v128 = a2 + HIBYTE(a1);
      if ( (v128 < 0) ^ __OFADD__(a2, HIBYTE(a1)) | (v128 == 0) )
        return;
      HIBYTE(a1) = v128;
      BYTE1(v128) = 0;
      do
      {
        while ( 1 )
        {
          LOBYTE(v128) = *a4++;
          if ( !(_BYTE)v128 )
            break;
          if ( (v128 & 0x80u) == 0 )
            a4 += v128;
        }
        ++a2;
      }
      while ( a2 );
    }
  }
  else if ( a2 + HIBYTE(a1) >= dword_180644 )
  {
    if ( (word_E36D4 & 2) != 0 )
    {
      if ( a2 + 1 >= dword_180644 )
        return;
      v123 = HIBYTE(a1) + a2 + 1 - dword_180644;
      HIBYTE(a1) = dword_180644 - (a2 + 1);
      v124 = v123;
      v125 = 0;
      do
      {
        while ( 1 )
        {
          LOBYTE(v125) = *a4++;
          if ( !(_BYTE)v125 )
            break;
          if ( (v125 & 0x80u) == 0 )
            a4 += v125;
        }
        --v124;
      }
      while ( v124 );
      v6 = dword_180628;
    }
    else
    {
      if ( dword_180644 <= a2 )
        return;
      HIBYTE(a1) = dword_180644 - a2;
    }
  }
  if ( a3 >= 0 )
  {
    if ( a3 + (unsigned __int8)a1 >= dword_180648 )
    {
      if ( word_E36D4 )
      {
        if ( (word_E36D4 & 1) != 0 )
        {
          if ( (word_E36D4 & 2) != 0 )
          {
            if ( dword_180634 - a3 >= 0 )
            {
              v77 = (unsigned __int8)a1 + a3;
              v78 = (_BYTE *)(dword_18062C * (HIBYTE(a1) + a2) + v77 + v6);
              v79 = 0;
              LOBYTE(a1) = dword_180634 - v77 - 2;
              v131 = a1;
              v80 = -1;
              v81 = v78;
              do
              {
                while ( 1 )
                {
                  while ( 1 )
                  {
                    LOBYTE(v80) = *a4++;
                    if ( (v80 & 0x80u) == 0 )
                      break;
                    v78 += v80;
                    LOBYTE(a1) = a1 - v80;
                  }
                  if ( !(_BYTE)v80 )
                    break;
                  LOBYTE(v79) = v80;
                  do
                  {
                    v82 = *a4++;
                    LOBYTE(a1) = a1 + 1;
                    if ( (a1 & 0x80u) == 0 )
                      *v78 = v82;
                    --v78;
                    --v79;
                  }
                  while ( v79 );
                }
                v81 -= dword_18062C;
                v78 = v81;
                a1 = __PAIR16__(HIBYTE(a1), v131) - 256;
              }
              while ( HIBYTE(a1) );
            }
          }
          else if ( dword_180634 - a3 >= 0 )
          {
            v83 = (unsigned __int8)a1 + a3;
            v84 = (_BYTE *)(dword_18062C * a2 + v83 + v6);
            v85 = 0;
            LOBYTE(a1) = dword_180634 - v83 - 2;
            v132 = a1;
            v86 = -1;
            v87 = v84;
            do
            {
              while ( 1 )
              {
                while ( 1 )
                {
                  LOBYTE(v86) = *a4++;
                  if ( (v86 & 0x80u) == 0 )
                    break;
                  v84 += v86;
                  LOBYTE(a1) = a1 - v86;
                }
                if ( !(_BYTE)v86 )
                  break;
                LOBYTE(v85) = v86;
                do
                {
                  v88 = *a4++;
                  LOBYTE(a1) = a1 + 1;
                  if ( (a1 & 0x80u) == 0 )
                    *v84 = v88;
                  --v84;
                  --v85;
                }
                while ( v85 );
              }
              v87 += dword_18062C;
              v84 = v87;
              a1 = __PAIR16__(HIBYTE(a1), v132) - 256;
            }
            while ( HIBYTE(a1) );
          }
        }
        else if ( (word_E36D4 & 2) != 0 )
        {
          v89 = (_BYTE *)(dword_18062C * (HIBYTE(a1) + a2) + a3 + v6);
          v90 = 0;
          v91 = dword_180634 - a3;
          if ( v91 >= 0 )
          {
            LOBYTE(a1) = v91;
            v133 = v91;
            v92 = -1;
            v93 = v89;
            do
            {
              while ( 1 )
              {
                while ( 1 )
                {
                  LOBYTE(v92) = *a4++;
                  if ( (v92 & 0x80u) == 0 )
                    break;
                  v89 -= v92;
                  LOBYTE(a1) = v92 + a1;
                }
                if ( !(_BYTE)v92 )
                  break;
                LOBYTE(v90) = v92;
                do
                {
                  v94 = *a4++;
                  LOBYTE(a1) = a1 - 1;
                  if ( (a1 & 0x80u) == 0 )
                    *v89++ = v94;
                  --v90;
                }
                while ( v90 );
              }
              v93 -= dword_18062C;
              v89 = v93;
              a1 = __PAIR16__(HIBYTE(a1), v133) - 256;
            }
            while ( HIBYTE(a1) );
          }
        }
      }
      else
      {
        v68 = a3 + v6;
        v69 = dword_180634 - a3;
        if ( v69 >= 0 )
        {
          v70 = (_BYTE *)(dword_18062C * a2 + v68);
          BYTE1(v69) = HIBYTE(a1);
          v130 = v69;
          v71 = v70;
          v72 = 0;
          do
          {
            while ( 1 )
            {
              while ( 1 )
              {
                v73 = *a4++;
                if ( v73 >= 0 )
                  break;
                v46 = ((char)(v73 + v69) < 0) ^ __OFADD__(v73, (_BYTE)v69) | (v73 + (_BYTE)v69 == 0);
                LOBYTE(v69) = v73 + v69;
                if ( !v46 )
                {
                  v70 -= v73;
                  v75 = *a4++;
                  LOBYTE(v72) = v75;
                  do
                  {
                    v76 = *a4++;
                    LOBYTE(v69) = v69 - 1;
                    if ( (v69 & 0x80u) == 0 )
                      *v70++ = v76;
                    --v72;
                  }
                  while ( v72 );
                }
              }
              if ( !v73 )
                break;
              LOBYTE(v72) = v73;
              do
              {
                v74 = *a4++;
                LOBYTE(v69) = v69 - 1;
                if ( (v69 & 0x80u) == 0 )
                  *v70++ = v74;
                --v72;
              }
              while ( v72 );
            }
            v71 += dword_18062C;
            v70 = v71;
            LOWORD(v69) = __PAIR16__(BYTE1(v69), v130) - 256;
          }
          while ( BYTE1(v69) );
        }
      }
    }
    else if ( (word_E36D4 & 1) != 0 )
    {
      if ( (word_E36D4 & 2) != 0 )
      {
        v7 = (_BYTE *)(dword_18062C * (HIBYTE(a1) + a2) + (unsigned __int8)a1 + a3 + v6);
        v8 = 0;
        v9 = -1;
        v10 = v7;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              LOBYTE(v9) = *a4++;
              if ( (v9 & 0x80u) == 0 )
                break;
              v7 += v9;
              v12 = *a4++;
              LOBYTE(v8) = v12;
              do
              {
                v13 = *a4++;
                *v7-- = v13;
                --v8;
              }
              while ( v8 );
            }
            if ( !(_BYTE)v9 )
              break;
            LOBYTE(v8) = v9;
            do
            {
              v11 = *a4++;
              *v7-- = v11;
              --v8;
            }
            while ( v8 );
          }
          v10 -= dword_18062C;
          v7 = v10;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
      else
      {
        v14 = (_BYTE *)(dword_18062C * a2 + (unsigned __int8)a1 + a3 + v6);
        v15 = 0;
        v16 = -1;
        v17 = v14;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              LOBYTE(v16) = *a4++;
              if ( (v16 & 0x80u) == 0 )
                break;
              v14 += v16;
              v19 = *a4++;
              LOBYTE(v15) = v19;
              do
              {
                v20 = *a4++;
                *v14-- = v20;
                --v15;
              }
              while ( v15 );
            }
            if ( !(_BYTE)v16 )
              break;
            LOBYTE(v15) = v16;
            do
            {
              v18 = *a4++;
              *v14-- = v18;
              --v15;
            }
            while ( v15 );
          }
          v17 += dword_18062C;
          v14 = v17;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
    }
    else if ( word_E36D4 )
    {
      if ( (word_E36D4 & 2) != 0 )
      {
        v28 = (char *)(dword_18062C * (HIBYTE(a1) + a2) + a3 + v6);
        v29 = 0;
        v30 = -1;
        v31 = v28;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              LOBYTE(v30) = *a4++;
              if ( (v30 & 0x80u) == 0 )
                break;
              v32 = &v28[-v30];
              v33 = *a4;
              v34 = a4 + 1;
              LOBYTE(v29) = v33;
              qmemcpy(v32, v34, v29);
              a4 = &v34[v29];
              v28 = &v32[v29];
              v29 = 0;
            }
            if ( !(_BYTE)v30 )
              break;
            LOBYTE(v29) = v30;
            qmemcpy(v28, a4, v29);
            a4 += v29;
            v28 += v29;
            v29 = 0;
          }
          v31 -= dword_18062C;
          v28 = v31;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
      else if ( (word_E36D4 & 4) != 0 )
      {
        v35 = dword_E3890;
        v36 = (_BYTE *)(dword_18062C * a2 + a3 + v6);
        v37 = 0;
        v38 = v36;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              v39 = *a4++;
              if ( v39 >= 0 )
                break;
              v36 -= v39;
            }
            if ( !v39 )
              break;
            LOBYTE(v37) = v39;
            v40 = (unsigned __int8)v39;
            do
            {
              LOBYTE(v40) = *a4++;
              BYTE1(v40) = *v36;
              *v36++ = *(_BYTE *)(v40 + v35);
              --v37;
            }
            while ( v37 );
          }
          v38 += dword_18062C;
          v36 = v38;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
      else if ( (word_E36D4 & 8) != 0 )
      {
        v41 = (_BYTE *)(dword_18062C * a2 + a3 + v6);
        v42 = 0;
        v140 = v41;
        v138 = HIBYTE(a1);
        for ( i = a5; ; i = a5 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              v44 = *a4++;
              if ( v44 >= 0 )
                break;
              v42 = (unsigned __int8)-v44;
              do
              {
                v46 = (char)i-- < 1;
                if ( v46 )
                {
                  i = a5;
                  ++v41;
                }
                --v42;
              }
              while ( v42 );
            }
            if ( !v44 )
              break;
            LOBYTE(v42) = v44;
            do
            {
              v45 = *a4++;
              v46 = (char)i-- < 1;
              if ( v46 )
              {
                i = a5;
                *v41++ = v45;
              }
              --v42;
            }
            while ( v42 );
          }
          if ( !--v138 )
            break;
          v47 = a6;
          while ( --v47 >= 0 )
          {
            while ( 1 )
            {
              do
                v48 = *a4++;
              while ( v48 < 0 );
              if ( !v48 )
                break;
              a4 += (unsigned __int8)v48;
            }
          }
          v140 += dword_18062C;
          v41 = v140;
        }
      }
      else if ( (word_E36D4 & 0x20) != 0 )
      {
        v49 = (char *)(dword_18062C * a2 + a3 + v6);
        v141 = v49;
        v139 = HIBYTE(a1);
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              v50 = *a4++;
              if ( v50 >= 0 )
                break;
              v49 += (unsigned __int16)(a5 * (unsigned __int8)-v50);
            }
            if ( !v50 )
              break;
            v51 = v50;
            do
            {
              v52 = *a4++;
              memset(v49, v52, a5);
              v49 += a5;
              v46 = v51-- <= 1;
            }
            while ( !v46 );
          }
          v53 = a6 - 1;
          if ( a6 > 1 )
          {
            v129 = a4;
            v54 = v49 - v141;
            do
            {
              v55 = v141;
              v141 += dword_18062C;
              qmemcpy(v141, v55, v54);
              v46 = v53-- <= 1;
            }
            while ( !v46 );
            a4 = v129;
          }
          v141 += dword_18062C;
          v49 = v141;
          --v139;
        }
        while ( v139 );
      }
      else if ( (word_E36D4 & 0x40) != 0 )
      {
        v56 = (char *)(dword_18062C * a2 + a3 + v6);
        v57 = 0;
        v58 = -1;
        v59 = v56;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              LOBYTE(v58) = *a4++;
              if ( (v58 & 0x80u) == 0 )
                break;
              v60 = &v56[-v58];
              LOBYTE(v57) = *a4;
              a4 += v57 + 1;
              memset(v60, a5, v57);
              v56 = &v60[v57];
              v57 = 0;
            }
            if ( !(_BYTE)v58 )
              break;
            LOBYTE(v57) = v58;
            a4 += v57;
            memset(v56, a5, v57);
            v56 += v57;
            v57 = 0;
          }
          v59 += dword_18062C;
          v56 = v59;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
      else
      {
        v61 = (char *)(dword_18062C * a2 + a3 + v6);
        v62 = 0;
        v63 = -1;
        v64 = v61;
        do
        {
          while ( 1 )
          {
            while ( 1 )
            {
              LOBYTE(v63) = *a4++;
              if ( (v63 & 0x80u) == 0 )
                break;
              v65 = &v61[-v63];
              v66 = *a4;
              v67 = a4 + 1;
              LOBYTE(v62) = v66;
              qmemcpy(v65, v67, v62);
              a4 = &v67[v62];
              v61 = &v65[v62];
              v62 = 0;
            }
            if ( !(_BYTE)v63 )
              break;
            LOBYTE(v62) = v63;
            qmemcpy(v61, a4, v62);
            a4 += v62;
            v61 += v62;
            v62 = 0;
          }
          v64 += dword_18062C;
          v61 = v64;
          --HIBYTE(a1);
        }
        while ( HIBYTE(a1) );
      }
    }
    else
    {
      v21 = (char *)(dword_18062C * a2 + a3 + v6);
      v22 = 0;
      v23 = -1;
      v24 = v21;
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            LOBYTE(v23) = *a4++;
            if ( (v23 & 0x80u) == 0 )
              break;
            v25 = &v21[-v23];
            v26 = *a4;
            v27 = a4 + 1;
            LOBYTE(v22) = v26;
            qmemcpy(v25, v27, v22);
            a4 = &v27[v22];
            v21 = &v25[v22];
            v22 = 0;
          }
          if ( !(_BYTE)v23 )
            break;
          LOBYTE(v22) = v23;
          qmemcpy(v21, a4, v22);
          a4 += v22;
          v21 += v22;
          v22 = 0;
        }
        v24 += dword_18062C;
        v21 = v24;
        --HIBYTE(a1);
      }
      while ( HIBYTE(a1) );
    }
    return;
  }
  if ( !word_E36D4 )
  {
    v95 = -a3;
    if ( (unsigned __int8)a1 <= v95 )
      return;
    v96 = (_BYTE *)(dword_18062C * a2 + v6);
    BYTE1(v95) = HIBYTE(a1);
    v97 = v96;
    v134 = v95;
    v98 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v99 = *a4++;
          if ( v99 < 0 )
            break;
          if ( v99 )
          {
            LOBYTE(v98) = v99;
            do
            {
              v100 = *a4++;
              LOBYTE(v95) = v95 - 1;
              if ( (v95 & 0x80u) != 0 )
                *v96++ = v100;
              --v98;
            }
            while ( v98 );
          }
          else
          {
            v97 += dword_18062C;
            v96 = v97;
            LOWORD(v95) = __PAIR16__(BYTE1(v95), v134) - 256;
            if ( !BYTE1(v95) )
              return;
          }
        }
        if ( (char)v95 > 0 )
          break;
LABEL_179:
        v96 -= v99;
        v101 = *a4++;
        LOBYTE(v98) = v101;
        do
        {
          v102 = *a4++;
          LOBYTE(v95) = v95 - 1;
          if ( (v95 & 0x80u) != 0 )
            *v96++ = v102;
          --v98;
        }
        while ( v98 );
      }
      LOBYTE(v95) = v99 + v95;
      if ( (v95 & 0x80u) != 0 )
      {
        v99 = v95;
        goto LABEL_179;
      }
    }
  }
  if ( (word_E36D4 & 1) == 0 )
  {
    if ( (word_E36D4 & 2) == 0 )
      return;
    v115 = -a3;
    if ( (unsigned __int8)a1 <= v115 )
      return;
    v116 = (_BYTE *)(dword_18062C * (HIBYTE(a1) + a2) + v6);
    BYTE1(v115) = HIBYTE(a1);
    v117 = v116;
    v137 = v115;
    v118 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v119 = *a4++;
          if ( v119 < 0 )
            break;
          if ( v119 )
          {
            LOBYTE(v118) = v119;
            do
            {
              v120 = *a4++;
              LOBYTE(v115) = v115 - 1;
              if ( (v115 & 0x80u) != 0 )
                *v116++ = v120;
              --v118;
            }
            while ( v118 );
          }
          else
          {
            v117 -= dword_18062C;
            v116 = v117;
            LOWORD(v115) = __PAIR16__(BYTE1(v115), v137) - 256;
            if ( !BYTE1(v115) )
              return;
          }
        }
        if ( (char)v115 > 0 )
          break;
LABEL_225:
        v116 -= v119;
        v121 = *a4++;
        LOBYTE(v118) = v121;
        do
        {
          v122 = *a4++;
          LOBYTE(v115) = v115 - 1;
          if ( (v115 & 0x80u) != 0 )
            *v116++ = v122;
          --v118;
        }
        while ( v118 );
      }
      LOBYTE(v115) = v119 + v115;
      if ( (v115 & 0x80u) != 0 )
      {
        v119 = v115;
        goto LABEL_225;
      }
    }
  }
  if ( (word_E36D4 & 2) != 0 )
  {
    v103 = (_BYTE *)(dword_18062C * (HIBYTE(a1) + a2) + (unsigned __int8)a1 + a3 + v6);
    v104 = 0;
    v105 = (unsigned __int8)a1 + a3 + 1;
    if ( v105 >= 0 )
    {
      LOBYTE(a1) = v105;
      v135 = v105;
      v106 = v103;
      v107 = -1;
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            LOBYTE(v107) = *a4++;
            if ( (v107 & 0x80u) == 0 )
              break;
            v103 += v107;
            LOBYTE(a1) = v107 + a1;
          }
          if ( !(_BYTE)v107 )
            break;
          LOBYTE(v104) = v107;
          do
          {
            v108 = *a4++;
            LOBYTE(a1) = a1 - 1;
            if ( (a1 & 0x80u) == 0 )
              *v103 = v108;
            --v103;
            --v104;
          }
          while ( v104 );
        }
        v106 -= dword_18062C;
        v103 = v106;
        a1 = __PAIR16__(HIBYTE(a1), v135) - 256;
      }
      while ( HIBYTE(a1) );
    }
  }
  else
  {
    v109 = (_BYTE *)(dword_18062C * a2 + (unsigned __int8)a1 + a3 + v6);
    v110 = 0;
    v111 = (unsigned __int8)a1 + a3 + 1;
    if ( v111 >= 0 )
    {
      LOBYTE(a1) = v111;
      v136 = v111;
      v112 = v109;
      v113 = -1;
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            LOBYTE(v113) = *a4++;
            if ( (v113 & 0x80u) == 0 )
              break;
            v109 += v113;
            LOBYTE(a1) = v113 + a1;
          }
          if ( !(_BYTE)v113 )
            break;
          LOBYTE(v110) = v113;
          do
          {
            v114 = *a4++;
            LOBYTE(a1) = a1 - 1;
            if ( (a1 & 0x80u) == 0 )
              *v109 = v114;
            --v109;
            --v110;
          }
          while ( v110 );
        }
        v112 += dword_18062C;
        v109 = v112;
        a1 = __PAIR16__(HIBYTE(a1), v136) - 256;
      }
      while ( HIBYTE(a1) );
    }
  }
}
// E36D4: using guessed type __int16 word_E36D4;
// E3890: using guessed type int dword_E3890;
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 180634: using guessed type int dword_180634;
// 18063C: using guessed type int dword_18063C;
// 180644: using guessed type int dword_180644;
// 180648: using guessed type int dword_180648;
// 180650: using guessed type int dword_180650;
// 180660: using guessed type __int16 word_180660;

//----- (00090164) --------------------------------------------------------
void __cdecl sub_90164(
        unsigned __int16 a1,
        unsigned __int16 a2,
        unsigned __int16 a3,
        unsigned __int16 a4,
        unsigned __int16 a5)
{
  _BYTE *v5; // edi
  __int16 v6; // dx
  int v7; // ebx
  int v8; // esi
  int v9; // ecx
  int v10; // [esp+0h] [ebp-4h]
  unsigned __int16 v11; // [esp+14h] [ebp+10h]

  v5 = (_BYTE *)(320 * (a2 >> 1) + dword_180628 + (a1 >> 1));
  v6 = a4 >> 1;
  v11 = a3 >> 1;
  v10 = (unsigned __int16)(320 - v11);
  if ( (word_E36D4 & 4) != 0 )
  {
    v7 = a5;
    v8 = dword_E3890;
    do
    {
      v9 = v11;
      do
      {
        BYTE1(v7) = *v5;
        *v5++ = *(_BYTE *)(v7 + v8);
        --v9;
      }
      while ( v9 );
      v5 += v10;
      --v6;
    }
    while ( v6 );
  }
  else
  {
    do
    {
      memset(v5, a5, v11);
      v5 += v10 + v11;
      --v6;
    }
    while ( v6 );
  }
}
// E36D4: using guessed type __int16 word_E36D4;
// E3890: using guessed type int dword_E3890;
// 180628: using guessed type int dword_180628;

//----- (000901E4) --------------------------------------------------------
void __cdecl sub_901E4(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, unsigned __int16 a5)
{
  _BYTE *v5; // edi
  int v7; // ebx
  int v8; // esi
  int v9; // ecx
  int v10; // [esp+0h] [ebp-4h]

  v5 = (_BYTE *)(640 * a2 + dword_180628 + a1);
  v10 = (unsigned __int16)(640 - a3);
  if ( (word_E36D4 & 4) != 0 )
  {
    v7 = a5;
    v8 = dword_E3890;
    do
    {
      v9 = a3;
      do
      {
        BYTE1(v7) = *v5;
        *v5++ = *(_BYTE *)(v7 + v8);
        --v9;
      }
      while ( v9 );
      v5 += v10;
      --a4;
    }
    while ( a4 );
  }
  else
  {
    do
    {
      memset(v5, a5, a3);
      v5 += v10 + a3;
      --a4;
    }
    while ( a4 );
  }
}
// E36D4: using guessed type __int16 word_E36D4;
// E3890: using guessed type int dword_E3890;
// 180628: using guessed type int dword_180628;

//----- (0009025C) --------------------------------------------------------
int __cdecl sub_9025C(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6)
{
  __int16 v6; // bx
  __int16 v7; // cx
  __int16 v8; // dx
  _BYTE *v10; // edi
  int v11; // eax
  unsigned int v12; // ecx
  int v13; // ecx
  int v14; // esi
  int v15; // esi
  int v16; // [esp+4h] [ebp-4h]

  v6 = 2 * dword_180634;
  v7 = 2 * dword_180650;
  v8 = 2 * dword_180630;
  if ( a1 < (__int16)(2 * dword_18063C) )
    a1 = 2 * dword_18063C;
  if ( a3 < (__int16)(2 * dword_18063C) )
    return v16;
  if ( a1 >= v6 )
    return v16;
  if ( a3 >= v6 )
    a3 = 2 * dword_180634;
  if ( a2 < v7 )
    a2 = 2 * dword_180650;
  if ( a4 < v7 )
    return v16;
  if ( a2 >= v8 )
    return v16;
  if ( a4 >= v8 )
    a4 = 2 * dword_180630;
  v10 = (_BYTE *)(320 * ((unsigned __int16)a2 >> 1) + dword_180628 + ((unsigned __int16)a1 >> 1));
  v11 = a5;
  v12 = (unsigned __int16)a3;
  if ( a3 == a1 )
  {
    v13 = (unsigned __int16)a4;
    LOWORD(v13) = (unsigned __int16)(a4 - a2) >> 1;
    if ( (a6 & 4) != 0 )
    {
      v14 = dword_E3890;
      do
      {
        BYTE1(v11) = *v10;
        *v10 = *(_BYTE *)(v11 + v14);
        v10 += 320;
        --v13;
      }
      while ( v13 );
    }
    else
    {
      do
      {
        *v10 = a5;
        v10 += 320;
        --v13;
      }
      while ( v13 );
    }
  }
  else
  {
    LOWORD(v12) = (unsigned __int16)(a3 - a1) >> 1;
    if ( (a6 & 4) != 0 )
    {
      v15 = dword_E3890;
      do
      {
        BYTE1(v11) = *v10;
        *v10++ = *(_BYTE *)(v11 + v15);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      memset(v10, a5, v12);
    }
  }
  return v16;
}
// 902A1: variable 'v16' is possibly undefined
// E3890: using guessed type int dword_E3890;
// 180628: using guessed type int dword_180628;
// 180630: using guessed type int dword_180630;
// 180634: using guessed type int dword_180634;
// 18063C: using guessed type int dword_18063C;
// 180650: using guessed type int dword_180650;

//----- (00090374) --------------------------------------------------------
int __cdecl sub_90374(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6)
{
  _BYTE *v7; // edi
  int v8; // eax
  unsigned int v9; // ecx
  int v10; // ecx
  int v11; // esi
  int v12; // esi
  int v13; // [esp+4h] [ebp-4h]

  if ( a1 < (__int16)dword_18063C )
    a1 = dword_18063C;
  if ( a3 < (__int16)dword_18063C )
    return v13;
  if ( a1 >= (__int16)dword_180634 )
    return v13;
  if ( a3 >= (__int16)dword_180634 )
    a3 = dword_180634;
  if ( a2 < (__int16)dword_180650 )
    a2 = dword_180650;
  if ( a4 < (__int16)dword_180650 )
    return v13;
  if ( a2 >= (__int16)dword_180630 )
    return v13;
  if ( a4 >= (__int16)dword_180630 )
    a4 = dword_180630;
  v7 = (_BYTE *)(640 * (unsigned __int16)a2 + dword_180628 + (unsigned __int16)a1);
  v8 = a5;
  v9 = (unsigned __int16)a3;
  LOWORD(v9) = a3 - a1;
  if ( a3 == a1 )
  {
    v10 = (unsigned __int16)a4;
    LOWORD(v10) = a4 - a2;
    if ( (a6 & 4) != 0 )
    {
      v11 = dword_E3890;
      do
      {
        BYTE1(v8) = *v7;
        *v7 = *(_BYTE *)(v8 + v11);
        v7 += 640;
        --v10;
      }
      while ( v10 );
    }
    else
    {
      do
      {
        *v7 = a5;
        v7 += 640;
        --v10;
      }
      while ( v10 );
    }
  }
  else if ( (a6 & 4) != 0 )
  {
    v12 = dword_E3890;
    do
    {
      BYTE1(v8) = *v7;
      *v7++ = *(_BYTE *)(v8 + v12);
      --v9;
    }
    while ( v9 );
  }
  else
  {
    memset(v7, a5, v9);
  }
  return v13;
}
// 903AD: variable 'v13' is possibly undefined
// E3890: using guessed type int dword_E3890;
// 180628: using guessed type int dword_180628;
// 180630: using guessed type int dword_180630;
// 180634: using guessed type int dword_180634;
// 18063C: using guessed type int dword_18063C;
// 180650: using guessed type int dword_180650;

//----- (00090478) --------------------------------------------------------
void sub_90478()
{
  if ( !byte_E3766 )
    sub_8CACD();
  qmemcpy(&loc_A0000, (const void *)dword_180628, 0xFA00u);
  if ( !byte_E3766 )
    sub_8CB1F();
}
// E3766: using guessed type char byte_E3766;
// 180628: using guessed type int dword_180628;

//----- (000904C0) --------------------------------------------------------
char __cdecl sub_904C0(float a1)
{
  double v1; // st7
  double v2; // st6
  int v3; // edx
  char result; // al
  int v5; // [esp+0h] [ebp-Ch]

  if ( a1 < dbl_D220C )
    a1 = 0.0099999998;
  v5 = 0;
  v1 = a1;
  do
  {
    v2 = IF_DPOW(v1, 1.0 / v1);
    v3 = v5;
    v1 = v1 * dbl_D2218 + dbl_D2220;
    _CHP();
    result = (int)v2;
    ++v5;
    byte_181504[v3] = result;
  }
  while ( v5 < 64 );
  return result;
}
// 9B4F6: using guessed type int _CHP(void);
// A097C: using guessed type double __usercall IF_DPOW@<st0>(double@<st0>, double@<st1>);
// D220C: using guessed type double dbl_D220C;
// D2218: using guessed type double dbl_D2218;
// D2220: using guessed type double dbl_D2220;

//----- (00090530) --------------------------------------------------------
unsigned __int8 __cdecl sub_90530(_DWORD *a1, int a2, float a3)
{
  int v3; // esi
  unsigned __int8 result; // al
  int i; // ecx
  int v7; // eax

  v3 = a2;
  sub_904C0(a3);
  if ( a2 > 256 )
    v3 = 256;
  result = 0;
  __outbyte(0x3C8u, 0);
  for ( i = 0; i < v3; ++i )
  {
    __outbyte(0x3C9u, byte_181504[*(unsigned __int8 *)a1]);
    __outbyte(0x3C9u, byte_181504[BYTE1(*a1)]);
    v7 = (unsigned __int8)BYTE2(*a1++);
    result = byte_181504[v7];
    __outbyte(0x3C9u, result);
  }
  return result;
}

//----- (000905EC) --------------------------------------------------------
int __cdecl sub_905EC(char a1)
{
  char v2[28]; // [esp+0h] [ebp-1Ch] BYREF

  word_E3908 = MEMORY[0x449];
  v2[0] = a1;
  v2[1] = 0;
  return int386(16, v2, v2);
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E3908: using guessed type __int16 word_E3908;

//----- (00090668) --------------------------------------------------------
int __cdecl sub_90668(int a1)
{
  int v1; // edx
  int result; // eax
  int v3; // edx
  int v4; // ebx
  int v5; // ebx

  v1 = a1;
  if ( a1 )
  {
    result = 0;
    v3 = 0;
    v4 = 0;
    do
    {
      ++result;
      word_1811E4[v3++] = v4;
      v4 += 160;
    }
    while ( result < 400 );
  }
  else
  {
    result = 0;
    v5 = 0;
    do
    {
      ++result;
      *(__int16 *)((char *)word_1811E4 + v1) = v5;
      v1 += 2;
      v5 += 80;
    }
    while ( result < 400 );
  }
  return result;
}
// 1811E4: using guessed type __int16 word_1811E4[];

//----- (000906B4) --------------------------------------------------------
int sub_906B4()
{
  char *v0; // edx
  int i; // ebx
  char v2; // cl
  int v3; // ebx
  int v4; // ecx
  int v5; // eax
  int result; // eax
  char v7[28]; // [esp+0h] [ebp-30h] BYREF
  int v8; // [esp+1Ch] [ebp-14h]

  v7[0] = 19;
  v7[1] = 0;
  word_E3908 = MEMORY[0x449];
  int386(16, v7, v7);
  sub_A0BB0(dword_E3894, 25);
  __outword(0x3C4u, 0x604u);
  __outword(0x3D4u, 0x14u);
  __outword(0x3D4u, 0xE317u);
  __outword(0x3CEu, 0xFF08u);
  __outword(0x3C4u, 0xF02u);
  v0 = (char *)&loc_A0000;
  do
  {
    *(_DWORD *)v0 = 0;
    v0 += 4;
  }
  while ( v0 != (char *)&loc_AFFFE + 2 );
  for ( i = 0; i < 320; byte_1810A3[i] = 1 << v2 )
    v2 = i++ & 3;
  sub_90668(0);
  v3 = 0;
  v4 = 0;
  do
  {
    v8 = 3;
    ++v4;
    v5 = (63 * (v3 & 7) / 7) | ((63 * (v3 >> 6) / 3) << 16) | ((63 * ((v3 >> 3) & 7) / 7) << 8);
    ++v3;
    dword_180CA0[v4] = v5;
  }
  while ( v3 < 256 );
  sub_90530(dword_180CA4, 256, 1.2);
  __inbyte(0x3DAu);
  __outbyte(0x3C0u, 0x11u);
  __outbyte(0x3C0u, 0);
  result = 0;
  __inbyte(0x3DAu);
  LOBYTE(result) = 32;
  __outbyte(0x3C0u, 0x20u);
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// E3894: using guessed type int dword_E3894[25];
// E3908: using guessed type __int16 word_E3908;
// 180CA0: using guessed type int dword_180CA0[];
// 180CA4: using guessed type _DWORD dword_180CA4[255];

//----- (00090810) --------------------------------------------------------
int sub_90810()
{
  int result; // eax

  if ( word_E3908 )
  {
    result = sub_905EC(word_E3908);
    word_E3908 = 0;
  }
  return result;
}
// E3908: using guessed type __int16 word_E3908;

//----- (00090B27) --------------------------------------------------------
__int16 __cdecl sub_90B27(char *a1, unsigned __int8 a2, char a3)
{
  char *v3; // eax
  int v4; // edx
  char *v5; // eax
  int v6; // edx
  unsigned __int8 v8[768]; // [esp+0h] [ebp-30Ch] BYREF
  int i; // [esp+300h] [ebp-Ch]
  unsigned __int8 *v10; // [esp+308h] [ebp-4h]

  if ( a3 )
  {
    if ( byte_E390C )
    {
      if ( a2 == ++word_181B44 )
        byte_E390C = 0;
    }
    else
    {
      word_181B44 = 0;
      byte_E390C = 1;
      sub_A0D2C((unsigned __int8 *)byte_181544);
      if ( !a1 )
        memset(&unk_181844, 0, 768);
    }
    if ( !a1 )
      a1 = (char *)&unk_181844;
    for ( i = 0; (__int16)i < 768; ++i )
    {
      v5 = &a1[(__int16)i];
      LOWORD(v5) = (unsigned __int8)*v5;
      v6 = (__int16)i;
      LOWORD(v6) = (unsigned __int8)byte_181544[(__int16)i];
      v10 = (unsigned __int8 *)&v5[-v6];
      v8[(__int16)i] = byte_181544[(__int16)i]
                     + ((int)unk_181B42 >> 16) * (__int16)((unsigned __int8)v5 - (unsigned __int8)v6) / a2;
    }
    sub_9A0FC();
    sub_41A90(v8);
  }
  else
  {
    sub_A0D2C((unsigned __int8 *)byte_181544);
    if ( !a1 )
    {
      a1 = (char *)&unk_181844;
      memset(&unk_181844, 0, 768);
    }
    for ( word_181B44 = 0; a2 >= word_181B44; ++word_181B44 )
    {
      for ( i = 0; (__int16)i < 768; ++i )
      {
        v3 = &a1[(__int16)i];
        LOWORD(v3) = (unsigned __int8)*v3;
        v4 = (__int16)i;
        LOWORD(v4) = (unsigned __int8)byte_181544[(__int16)i];
        v10 = (unsigned __int8 *)&v3[-v4];
        v8[(__int16)i] = byte_181544[(__int16)i]
                       + ((int)unk_181B42 >> 16) * (__int16)((unsigned __int8)v3 - (unsigned __int8)v4) / a2;
      }
      sub_9A0FC();
      sub_41A90(v8);
    }
    byte_E390C = 0;
  }
  return word_181B44;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// E390C: using guessed type char byte_E390C;
// 181B44: using guessed type __int16 word_181B44;
// 90B27: using guessed type unsigned __int8 var_30C[768];

//----- (00090D27) --------------------------------------------------------
void sub_90D27()
{
  byte_E390C = 0;
}
// E390C: using guessed type char byte_E390C;

//----- (00090D3F) --------------------------------------------------------
int __cdecl sub_90D3F(int a1)
{
  int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( !*(_DWORD *)(a1 + 28) )
      break;
    sub_9A2F5(a1);
    a1 += 44;
  }
  return result;
}

//----- (00090D6E) --------------------------------------------------------
int __cdecl sub_90D6E(unsigned __int8 *a1)
{
  char v2[28]; // [esp+0h] [ebp-38h] BYREF
  int v3[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  v3[0] = 3840;
  int386(16, v3, v2);
  if ( !word_180662 )
    word_180662 = (unsigned __int8)v2[0];
  v3[0] = 19;
  dword_18062C = 320;
  dword_180624 = 200;
  int386(16, v3, v2);
  sub_41A90(a1);
  sub_8D12F();
  return sub_A0D50(0, 0, 320, 200);
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 180624: using guessed type int dword_180624;
// 18062C: using guessed type int dword_18062C;
// 180662: using guessed type __int16 word_180662;

//----- (00090E07) --------------------------------------------------------
int __cdecl sub_90E07(unsigned __int8 *a1)
{
  char v2[28]; // [esp+0h] [ebp-38h] BYREF
  int v3[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  v3[0] = 3840;
  int386(16, v3, v2);
  if ( !word_180662 )
    word_180662 = (unsigned __int8)v2[0];
  dword_18062C = 640;
  dword_180624 = 480;
  sub_994BA(257);
  sub_41A90(a1);
  sub_8D12F();
  return sub_A0D50(0, 0, 640, 480);
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 180624: using guessed type int dword_180624;
// 18062C: using guessed type int dword_18062C;
// 180662: using guessed type __int16 word_180662;
// 90E07: using guessed type int var_1C[7];
// 90E07: using guessed type char var_38[28];

//----- (00090EA0) --------------------------------------------------------
int __cdecl sub_90EA0(int a1, const char *a2)
{
  int result; // eax

  dword_181BE4 = a1;
  result = sprintf(aSound_2, "%s", a2);
  byte_E39A0 = 1;
  return result;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// E39A0: using guessed type char byte_E39A0;
// 181BE4: using guessed type int dword_181BE4;

//----- (00090EE0) --------------------------------------------------------
int sub_90EE0()
{
  char v1[4]; // [esp+0h] [ebp-8h] BYREF

  dos_setdrive(dword_181BE4, v1);
  return chdir(aSound_2);
}
// 8C1CA: using guessed type _DWORD __cdecl dos_setdrive(_DWORD, _DWORD);
// A0DA5: using guessed type _DWORD __cdecl chdir(_DWORD);
// 181BE4: using guessed type int dword_181BE4;
// 90EE0: using guessed type char var_8[4];

//----- (00090F20) --------------------------------------------------------
int sub_90F20()
{
  char v1[4]; // [esp+0h] [ebp-4h] BYREF

  dos_setdrive(dword_181BE0, v1);
  return chdir(&unk_181B50);
}
// 8C1CA: using guessed type _DWORD __cdecl dos_setdrive(_DWORD, _DWORD);
// A0DA5: using guessed type _DWORD __cdecl chdir(_DWORD);
// 181BE0: using guessed type int dword_181BE0;
// 90F20: using guessed type char var_4[4];

//----- (00090F60) --------------------------------------------------------
int sub_90F60()
{
  int result; // eax
  int v1; // [esp+0h] [ebp-4h]

  v1 = getcwd(0, 0);
  sprintf(&unk_181B50, "%s", (const char *)(v1 + 2));
  free(v1);
  result = dos_getdrive(&dword_181BE0);
  if ( !byte_E39A0 )
  {
    result = dword_181BE0;
    dword_181BE4 = dword_181BE0;
  }
  return result;
}
// 8C1B2: using guessed type _DWORD __cdecl dos_getdrive(_DWORD);
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// A0DC7: using guessed type _DWORD __cdecl getcwd(_DWORD, _DWORD);
// A0E6B: using guessed type _DWORD __cdecl free(_DWORD);
// E39A0: using guessed type char byte_E39A0;
// 181BE0: using guessed type int dword_181BE0;
// 181BE4: using guessed type int dword_181BE4;

//----- (00090FD0) --------------------------------------------------------
__int16 __fastcall sub_90FD0(int a1, unsigned __int16 a2, int a3, int a4)
{
  int v4; // eax
  int v5; // eax

  sub_8D290(a1, a2, a3, a4);
  sub_8D970(v4, a2, a3, a4);
  v5 = stricmp(byte_180AB0, aSb16Dig);
  if ( !v5 )
    LOWORD(v5) = sub_91010();
  return v5;
}
// 90FE1: variable 'v4' is possibly undefined
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);

//----- (00091010) --------------------------------------------------------
__int16 sub_91010()
{
  __int16 result; // ax
  __int16 v1; // [esp+0h] [ebp-4h]

  result = word_180B30;
  v1 = word_180B30;
  if ( word_180B30 == 544 )
  {
    outp(word_180B30 + 4, 48);
    word_E39A4 = inp(v1 + 5) >> 3;
    outp(v1 + 4, 49);
    word_E39A6 = inp(v1 + 5) >> 3;
    outp(v1 + 4, 50);
    word_E39AC = inp(v1 + 5);
    outp(v1 + 5, 8 * word_E39A4 - 32);
    outp(v1 + 4, 51);
    word_E39AE = inp(v1 + 5);
    outp(v1 + 5, 8 * word_E39A6 - 32);
    outp(v1 + 4, 68);
    word_E39B0 = inp(v1 + 5);
    outp(v1 + 5, 96);
    outp(v1 + 4, 69);
    word_E39B2 = inp(v1 + 5);
    outp(v1 + 5, 96);
    outp(v1 + 4, 70);
    word_E39B4 = inp(v1 + 5);
    outp(v1 + 5, 120);
    outp(v1 + 4, 71);
    word_E39B6 = inp(v1 + 5);
    outp(v1 + 5, 120);
    if ( !stricmp(&unk_180BE0, aSbawe32Mdi_0) || !stricmp(&unk_180BE0, aMpu401Mdi_0) )
    {
      outp(v1 + 4, 52);
      word_E39A8 = inp(v1 + 5);
      outp(v1 + 5, 8 * word_E39A4 - 24);
      outp(v1 + 4, 53);
      word_E39AA = inp(v1 + 5);
      result = outp(v1 + 5, 8 * word_E39A6 - 24);
    }
    else
    {
      outp(v1 + 4, 52);
      word_E39A8 = inp(v1 + 5);
      outp(v1 + 5, 8 * word_E39A4 - 8);
      outp(v1 + 4, 53);
      word_E39AA = inp(v1 + 5);
      result = outp(v1 + 5, 8 * word_E39A6 - 8);
    }
    byte_E39B8 = 1;
  }
  return result;
}
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);
// E39A4: using guessed type __int16 word_E39A4;
// E39A6: using guessed type __int16 word_E39A6;
// E39A8: using guessed type __int16 word_E39A8;
// E39AA: using guessed type __int16 word_E39AA;
// E39AC: using guessed type __int16 word_E39AC;
// E39AE: using guessed type __int16 word_E39AE;
// E39B0: using guessed type __int16 word_E39B0;
// E39B2: using guessed type __int16 word_E39B2;
// E39B4: using guessed type __int16 word_E39B4;
// E39B6: using guessed type __int16 word_E39B6;
// E39B8: using guessed type char byte_E39B8;
// 180B30: using guessed type __int16 word_180B30;

//----- (00091420) --------------------------------------------------------
int sub_91420()
{
  __int16 v1; // [esp+0h] [ebp-4h]

  v1 = word_180B30;
  outp(word_180B30 + 4, 50);
  outp(549, word_E39AC);
  outp(v1 + 4, 51);
  outp(v1 + 5, word_E39AE);
  outp(v1 + 4, 52);
  outp(v1 + 5, word_E39A8);
  outp(v1 + 4, 53);
  outp(v1 + 5, word_E39AA);
  outp(v1 + 4, 68);
  outp(v1 + 5, word_E39B0);
  outp(v1 + 4, 69);
  outp(v1 + 5, word_E39B2);
  outp(v1 + 4, 70);
  outp(v1 + 5, word_E39B4);
  outp(v1 + 4, 71);
  return outp(v1 + 5, word_E39B6);
}
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// E39A8: using guessed type __int16 word_E39A8;
// E39AA: using guessed type __int16 word_E39AA;
// E39AC: using guessed type __int16 word_E39AC;
// E39AE: using guessed type __int16 word_E39AE;
// E39B0: using guessed type __int16 word_E39B0;
// E39B2: using guessed type __int16 word_E39B2;
// E39B4: using guessed type __int16 word_E39B4;
// E39B6: using guessed type __int16 word_E39B6;
// 180B30: using guessed type __int16 word_180B30;

//----- (000915A0) --------------------------------------------------------
bool sub_915A0()
{
  bool result; // eax

  if ( !dword_E39BC )
  {
    sub_9D590((unsigned int)sub_915A0, (unsigned int)sub_986A0);
    sub_9D710((unsigned int)&dword_181BF4, 4);
    sub_9D710((unsigned int)&dword_181BF8, 4);
    sub_9D710((unsigned int)&dword_181BF0, 4);
    sub_9D710((unsigned int)&dword_181BFC, 4);
    sub_9D710((unsigned int)&dword_181C0C, 4);
    sub_9D710((unsigned int)&dword_181C08, 4);
    sub_9D710((unsigned int)&dword_181C10, 4);
    result = sub_9D710((unsigned int)&dword_181C00, 4);
    dword_E39BC = 1;
  }
  return result;
}
// E39BC: using guessed type int dword_E39BC;
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181BFC: using guessed type int dword_181BFC;
// 181C00: using guessed type int dword_181C00;
// 181C08: using guessed type int dword_181C08;
// 181C0C: using guessed type int dword_181C0C;
// 181C10: using guessed type int dword_181C10;

//----- (000916F0) --------------------------------------------------------
int sub_916F0()
{
  unsigned int i; // [esp+4h] [ebp-14h]
  unsigned int j; // [esp+4h] [ebp-14h]
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  sub_A0EEC();
  v6 = dword_181BFC;
  v5 = dword_181C0C;
  v4 = dword_181C08;
  v3 = dword_181C10;
  sub_A0EF9();
  if ( dword_181C04 == 1 )
  {
    fprintf(dword_181BF0, "[%.02u:%.02u:%.02u.%.02u] ", v6, v5, v4, v3);
  }
  else
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
  }
  for ( j = 1; j < dword_181C04; ++j )
    fprintf(dword_181BF0, &unk_D2270);
  return 1;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BFC: using guessed type int dword_181BFC;
// 181C04: using guessed type int dword_181C04;
// 181C08: using guessed type int dword_181C08;
// 181C0C: using guessed type int dword_181C0C;
// 181C10: using guessed type int dword_181C10;

//----- (000917D0) --------------------------------------------------------
void __fastcall sub_917D0(int a1, unsigned __int16 a2)
{
  int v2; // eax
  int v3; // eax
  struct tm *timeptr; // [esp+0h] [ebp-Ch]
  time_t timer; // [esp+4h] [ebp-8h] BYREF
  int v6; // [esp+8h] [ebp-4h]

  sub_915A0();
  dword_181BF4 = 0;
  dword_181BF8 = 0;
  v6 = getenv(aAilDebug);
  if ( !v6 )
    goto LABEL_2;
  if ( getenv(aAilSysDebug) )
    dword_181BF8 = 1;
  dword_181BF0 = fopen(v6, &aHawT[2]);
  if ( dword_181BF0 )
  {
    if ( isatty(*(_DWORD *)(dword_181BF0 + 16)) )
      setbuf(dword_181BF0, 0);
    time(&timer);
    timeptr = (struct tm *)localtime(&timer);
    v2 = asctime(timeptr);
    strcpy(byte_181C14, v2);
    byte_181C2C = 0;
    fprintf(dword_181BF0, "-------------------------------------------------------------------------------\n");
    fprintf(dword_181BF0, "Audio Interface Library application usage script generated by AIL V%s\n", a303);
    fprintf(dword_181BF0, "Start time: %s\n", byte_181C14);
    v3 = fprintf(dword_181BF0, "-------------------------------------------------------------------------------\n\n");
    sub_9EC30(v3, a2);
    dword_181BFC = 0;
    dword_181C0C = 0;
    dword_181C08 = 0;
    dword_181C10 = 0;
    dword_181C00 = sub_A16AE((int)sub_91660);
    sub_A1840(dword_181C00, 0x64u);
    sub_A1768(dword_181C00);
    dword_181BF4 = 1;
    dword_181C04 = 1;
    sub_916F0();
    dword_181C04 = 0;
    fprintf(dword_181BF0, "AIL_startup()\n");
  }
  else
  {
LABEL_2:
    sub_9EC30(0, a2);
  }
}
// 91660: using guessed type int sub_91660();
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// 99E33: using guessed type _DWORD __cdecl getenv(_DWORD);
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// A1AF0: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// A1B9F: using guessed type _DWORD __cdecl isatty(_DWORD);
// A1BBB: using guessed type _DWORD __cdecl setbuf(_DWORD, _DWORD);
// A1BE8: using guessed type _DWORD __cdecl time(_DWORD);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181BFC: using guessed type int dword_181BFC;
// 181C00: using guessed type int dword_181C00;
// 181C04: using guessed type int dword_181C04;
// 181C08: using guessed type int dword_181C08;
// 181C0C: using guessed type int dword_181C0C;
// 181C10: using guessed type int dword_181C10;
// 181C2C: using guessed type char byte_181C2C;

//----- (000919C0) --------------------------------------------------------
int sub_919C0()
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_shutdown()\n");
  result = sub_9ED70();
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) )
  {
    result = sub_A16A2();
    if ( !result )
      result = fclose(dword_181BF0);
  }
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// A1E05: using guessed type _DWORD __cdecl fclose(_DWORD);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00091A80) --------------------------------------------------------
int __cdecl sub_91A80(int a1, int a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_preference(%d,%d)\n", a1, a2);
  v6 = sub_9E6E0(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = %d\n", v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00091BD0) --------------------------------------------------------
void sub_91BD0()
{
  sub_A0EEC();
}

//----- (00091BF0) --------------------------------------------------------
void sub_91BF0()
{
  sub_A0EF9();
}

//----- (00091C10) --------------------------------------------------------
int __usercall sub_91C10@<eax>(__int16 a1@<dx>, int a2@<ecx>, int a3@<ebx>, int a4)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_get_real_vect(0x%X)\n", a4);
  v8 = sub_A121D(a4, a1, a3, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = 0x%X\n", v8);
  }
  --dword_181C04;
  return v8;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00091D50) --------------------------------------------------------
int __cdecl sub_91D50(int a1, int a2)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_real_vect(0x%X,0x%X)\n", a1, a2);
  result = sub_A1249();
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00091E90) --------------------------------------------------------
int __cdecl sub_91E90(int a1)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_restore_USE16_ISR(%d)\n", a1);
  result = sub_A14DB(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00091F20) --------------------------------------------------------
unsigned int sub_91F20()
{
  return sub_A1520();
}

//----- (00091F50) --------------------------------------------------------
void __cdecl sub_91F50(unsigned int a1)
{
  sub_A1524(a1);
}

//----- (00091F70) --------------------------------------------------------
int __cdecl sub_91F70(int a1, int a2, _WORD *a3, _WORD *a4)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_call_driver(0x%X,0x%X,0x%X,0x%X)\n", a1, a2, a3, a4);
  v8 = sub_A158B(a1, a2, a3, a4);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = %d\n", v8);
  }
  --dword_181C04;
  return v8;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000920D0) --------------------------------------------------------
unsigned __int8 __cdecl sub_920D0(int a1)
{
  unsigned __int8 result; // al

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_delay(%d)\n", a1);
  result = sub_A1665(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092160) --------------------------------------------------------
int sub_92160()
{
  return sub_A16A2();
}

//----- (00092190) --------------------------------------------------------
int __cdecl sub_92190(int a1, const char *a2)
{
  unsigned int i3; // [esp+0h] [ebp-28h]
  unsigned int i4; // [esp+0h] [ebp-28h]
  unsigned int i1; // [esp+4h] [ebp-24h]
  unsigned int i2; // [esp+4h] [ebp-24h]
  unsigned int mm; // [esp+8h] [ebp-20h]
  unsigned int nn; // [esp+8h] [ebp-20h]
  unsigned int jj; // [esp+Ch] [ebp-1Ch]
  unsigned int kk; // [esp+Ch] [ebp-1Ch]
  unsigned int n; // [esp+10h] [ebp-18h]
  unsigned int ii; // [esp+10h] [ebp-18h]
  unsigned int k; // [esp+14h] [ebp-14h]
  unsigned int m; // [esp+14h] [ebp-14h]
  unsigned int i; // [esp+18h] [ebp-10h]
  unsigned int j; // [esp+18h] [ebp-10h]
  int v18; // [esp+24h] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_API_read_INI(0x%X,%s)\n", a1, a2);
  v18 = sub_9E3A0((__int16 *)a1, (int)a2);
  if ( v18 )
  {
    if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
    {
      for ( i = 0; i < 0xE; ++i )
        fprintf(dword_181BF0, " ");
      for ( j = 1; j < dword_181C04; ++j )
        fprintf(dword_181BF0, &unk_D2270);
      fprintf(dword_181BF0, "Driver = %s\n", (const char *)(a1 + 128));
      for ( k = 0; k < 0xE; ++k )
        fprintf(dword_181BF0, " ");
      for ( m = 1; m < dword_181C04; ++m )
        fprintf(dword_181BF0, &unk_D2270);
      fprintf(dword_181BF0, "Device = %s\n", (const char *)a1);
      for ( n = 0; n < 0xE; ++n )
        fprintf(dword_181BF0, " ");
      for ( ii = 1; ii < dword_181C04; ++ii )
        fprintf(dword_181BF0, &unk_D2270);
      fprintf(dword_181BF0, "IO     = %X\n", *(__int16 *)(a1 + 256));
      for ( jj = 0; jj < 0xE; ++jj )
        fprintf(dword_181BF0, " ");
      for ( kk = 1; kk < dword_181C04; ++kk )
        fprintf(dword_181BF0, &unk_D2270);
      fprintf(dword_181BF0, "IRQ    = %d\n", *(__int16 *)(a1 + 258));
      for ( mm = 0; mm < 0xE; ++mm )
        fprintf(dword_181BF0, " ");
      for ( nn = 1; nn < dword_181C04; ++nn )
        fprintf(dword_181BF0, &unk_D2270);
      fprintf(dword_181BF0, "DMA_8  = %d\n", *(__int16 *)(a1 + 260));
      for ( i1 = 0; i1 < 0xE; ++i1 )
        fprintf(dword_181BF0, " ");
      for ( i2 = 1; i2 < dword_181C04; ++i2 )
        fprintf(dword_181BF0, &unk_D2270);
      fprintf(dword_181BF0, "DMA_16 = %d\n", *(__int16 *)(a1 + 262));
    }
  }
  else if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i3 = 0; i3 < 0xE; ++i3 )
      fprintf(dword_181BF0, " ");
    for ( i4 = 1; i4 < dword_181C04; ++i4 )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = %u\n", 0);
  }
  --dword_181C04;
  return v18;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092600) --------------------------------------------------------
unsigned int __cdecl sub_92600(int a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  unsigned int v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_register_timer(0x%X)\n", a1);
  v5 = sub_A16AE(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = %u\n", v5);
  }
  --dword_181C04;
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092740) --------------------------------------------------------
__int32 __cdecl sub_92740(int a1, __int32 a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  __int32 v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_timer_user(%u,%u)\n", a1, a2);
  v6 = sub_A16F5(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = %u\n", v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092890) --------------------------------------------------------
void __cdecl sub_92890(int a1, int a2)
{
  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_timer_period(%u,%u)\n", a1, a2);
  sub_A1810(a1, a2);
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092930) --------------------------------------------------------
void __cdecl sub_92930(int a1, unsigned int a2)
{
  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_timer_frequency(%u,%u)\n", a1, a2);
  sub_A1840(a1, a2);
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092BA0) --------------------------------------------------------
void __cdecl sub_92BA0(int a1)
{
  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_start_timer(%u)\n", a1);
  sub_A1768(a1);
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092CB0) --------------------------------------------------------
void __cdecl sub_92CB0(int a1)
{
  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_stop_timer(%u)\n", a1);
  sub_A17BC(a1);
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092DC0) --------------------------------------------------------
void __cdecl sub_92DC0(int a1)
{
  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_release_timer_handle(%u)\n", a1);
  sub_A171D(a1);
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092E50) --------------------------------------------------------
void sub_92E50()
{
  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_release_all_timers()\n");
  sub_A1744();
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00092ED0) --------------------------------------------------------
void *__cdecl sub_92ED0(int a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  void *v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_get_IO_environment(0x%X)\n", a1);
  v5 = sub_9EB60(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = 0x%X\n", v5);
  }
  --dword_181C04;
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093010) --------------------------------------------------------
_DWORD *__usercall sub_93010@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  _DWORD *v8; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_install_driver(0x%X,%u)\n", a3, a4);
  v8 = sub_9E720(a1, a2, a3, a4);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = 0x%X\n", v8);
  }
  --dword_181C04;
  return v8;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093160) --------------------------------------------------------
int __cdecl sub_93160(unsigned int a1)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_uninstall_driver(0x%X)\n", a1);
  result = sub_9EA60(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000931F0) --------------------------------------------------------
int __usercall sub_931F0@<eax>(int a1@<ecx>, int a2@<ebx>, int **a3)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_install_DIG_INI(0x%X)\n", a3);
  v7 = sub_A3720(a1, a2, a3);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = %d\n", v7);
  }
  --dword_181C04;
  return v7;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093330) --------------------------------------------------------
int *__usercall sub_93330@<eax>(int a1@<ecx>, int a2@<ebx>, const char *a3, const void *a4)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int *v8; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_install_DIG_driver_file(%s,0x%X)\n", a3, a4);
  v8 = sub_A3600(a1, a2, (int)a3, a4);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = 0x%X\n", v8);
  }
  --dword_181C04;
  return v8;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093480) --------------------------------------------------------
int __cdecl sub_93480(unsigned int *a1)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_uninstall_DIG_driver(0x%X)\n", a1);
  result = sub_A37A0(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093510) --------------------------------------------------------
int *__cdecl sub_93510(int a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int *v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_allocate_sample_handle(0x%X)\n", a1);
  v5 = sub_A3820(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = 0x%X\n", v5);
  }
  --dword_181C04;
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000937A0) --------------------------------------------------------
int __cdecl sub_937A0(int a1)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_release_sample_handle(0x%X)\n", a1);
  result = sub_A38C0(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093830) --------------------------------------------------------
int __cdecl sub_93830(int *a1)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_init_sample(0x%X)\n", a1);
  result = sub_A38E0(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000938C0) --------------------------------------------------------
int __cdecl sub_938C0(int *a1, int a2, int a3)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_sample_file(0x%X,0x%X,%d)\n", a1, a2, a3);
  v7 = sub_A4B20(a1, a2, a3);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = %d\n", v7);
  }
  --dword_181C04;
  return v7;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093A10) --------------------------------------------------------
_DWORD *__cdecl sub_93A10(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_sample_address(0x%X,0x%X,%u)\n", a1, a2, a3);
  result = sub_A3A30(a1, a2, a3);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093AB0) --------------------------------------------------------
int __cdecl sub_93AB0(int *a1, int a2, int a3)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_sample_type(0x%X,%d,%u)\n", a1, a2, a3);
  result = sub_A3A70(a1, a2, a3);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093B50) --------------------------------------------------------
int __cdecl sub_93B50(int *a1)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_start_sample(0x%X)\n", a1);
  result = sub_A3CB0(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093D00) --------------------------------------------------------
int __cdecl sub_93D00(int a1)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_end_sample(0x%X)\n", a1);
  result = sub_A3DA0(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093D90) --------------------------------------------------------
int __cdecl sub_93D90(int a1, int a2)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_sample_playback_rate(0x%X,%d)\n", a1, a2);
  result = sub_A3AF0(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093E30) --------------------------------------------------------
int __cdecl sub_93E30(int *a1, int a2)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_sample_volume(0x%X,%d)\n", a1, a2);
  result = sub_A3B40(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093ED0) --------------------------------------------------------
int __cdecl sub_93ED0(int *a1, int a2)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_sample_pan(0x%X,%d)\n", a1, a2);
  result = sub_A3BB0(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00093F70) --------------------------------------------------------
int __cdecl sub_93F70(int a1, int a2)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_sample_loop_count(0x%X,%d)\n", a1, a2);
  result = sub_A3C90(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00094010) --------------------------------------------------------
int __cdecl sub_94010(int a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_sample_status(0x%X)\n", a1);
  v5 = sub_A3A00(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = %u\n", v5);
  }
  --dword_181C04;
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00094650) --------------------------------------------------------
int __cdecl sub_94650(_DWORD *a1, int a2)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_digital_master_volume(0x%X,%d)\n", a1, a2);
  result = sub_A3F70(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095140) --------------------------------------------------------
int __cdecl sub_95140(int a1, int a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_register_EOS_callback(0x%X,0x%X)\n", a1, a2);
  v6 = sub_A3EB0(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = 0x%X\n", v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000953E0) --------------------------------------------------------
int __cdecl sub_953E0(int a1, int a2, int a3)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_sample_user_data(0x%X,%u,%d)\n", a1, a2, a3);
  result = sub_A3F00(a1, a2, a3);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095480) --------------------------------------------------------
int __cdecl sub_95480(int a1, int a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_sample_user_data(0x%X,%u)\n", a1, a2);
  v6 = sub_A3F30(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = %d\n", v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095710) --------------------------------------------------------
int __usercall sub_95710@<eax>(int a1@<ecx>, int a2@<ebx>, int **a3)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_install_MDI_INI(0x%X)\n", a3);
  v7 = sub_A78F0(a1, a2, a3);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = %d\n", v7);
  }
  --dword_181C04;
  return v7;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095850) --------------------------------------------------------
int *__usercall sub_95850@<eax>(int a1@<ecx>, int a2@<ebx>, const char *a3, const void *a4)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int *v8; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_install_MDI_driver_file(%s,0x%X)\n", a3, a4);
  v8 = sub_A77D0(a1, a2, (int)a3, a4);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = 0x%X\n", v8);
  }
  --dword_181C04;
  return v8;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000959A0) --------------------------------------------------------
int __cdecl sub_959A0(unsigned int *a1)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_uninstall_MDI_driver(0x%X)\n", a1);
  result = sub_A7970(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095A30) --------------------------------------------------------
_DWORD *__cdecl sub_95A30(int a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  _DWORD *v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_allocate_sequence_handle(0x%X)\n", a1);
  v5 = sub_A7B30(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = 0x%X\n", v5);
  }
  --dword_181C04;
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095C00) --------------------------------------------------------
int __cdecl sub_95C00(int *a1, int a2, int a3)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_init_sequence(0x%X,0x%X,%d)\n", a1, a2, a3);
  v7 = sub_A7C20(a1, a2, a3);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = %d\n", v7);
  }
  --dword_181C04;
  return v7;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095D50) --------------------------------------------------------
int *__cdecl sub_95D50(int *a1)
{
  int *result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_start_sequence(0x%X)\n", a1);
  result = sub_A8010(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095DE0) --------------------------------------------------------
int __cdecl sub_95DE0(int *a1)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_stop_sequence(0x%X)\n", a1);
  result = sub_A8050(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095E70) --------------------------------------------------------
void __cdecl sub_95E70(_DWORD *a1)
{
  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_resume_sequence(0x%X)\n", a1);
  sub_A8180(a1);
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00095F00) --------------------------------------------------------
int __cdecl sub_95F00(int a1)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_end_sequence(0x%X)\n", a1);
  result = sub_A8250(a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00096030) --------------------------------------------------------
void __cdecl sub_96030(_DWORD *a1, int a2, int a3)
{
  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_sequence_volume(0x%X,%d,%d)\n", a1, a2, a3);
  sub_A8360(a1, a2, a3);
  --dword_181C04;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00096170) --------------------------------------------------------
int __cdecl sub_96170(int a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_sequence_status(0x%X)\n", a1);
  v5 = sub_A8410(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = %u\n", v5);
  }
  --dword_181C04;
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00096670) --------------------------------------------------------
_DWORD *__cdecl sub_96670(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_XMIDI_master_volume(0x%X,%d)\n", a1, a2);
  result = sub_A84D0(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000969A0) --------------------------------------------------------
int __cdecl sub_969A0(_DWORD *a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_MDI_driver_type(0x%X)\n", a1);
  v5 = sub_A7990(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = %d\n", v5);
  }
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00096AE0) --------------------------------------------------------
int __cdecl sub_96AE0(const char *a1)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_set_GTL_filename_prefix(%s)\n", a1);
  result = sub_A7AA0((int)a1);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00097330) --------------------------------------------------------
int __cdecl sub_97330(_DWORD *a1, _DWORD *a2, int *a3)
{
  int result; // eax
  unsigned int i; // [esp+0h] [ebp-8h]
  unsigned int j; // [esp+0h] [ebp-8h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_sequence_position(0x%X,0x%X,0x%X)\n", a1, a2, a3);
  result = sub_A8830(a1, a2, a3);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) )
  {
    result = sub_A16A2();
    if ( !result )
    {
      for ( i = 0; i < 0xE; ++i )
        fprintf(dword_181BF0, " ");
      for ( j = 1; j < dword_181C04; ++j )
        fprintf(dword_181BF0, &unk_D2270);
      result = fprintf(dword_181BF0, "Result = %d:%d\n", *a3 + 1, *a2 + 1);
    }
  }
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00097480) --------------------------------------------------------
_DWORD *__cdecl sub_97480(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_branch_index(0x%X,%u)\n", a1, a2);
  result = sub_A8900(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00097670) --------------------------------------------------------
int __cdecl sub_97670(int a1, int a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_register_trigger_callback(0x%X,0x%X)\n", a1, a2);
  v6 = sub_A8A20(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = 0x%X\n", v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00097A60) --------------------------------------------------------
int __cdecl sub_97A60(int a1, int a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_register_event_callback(0x%X,0x%X)\n", a1, a2);
  v6 = sub_A8AE0(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = 0x%X\n", v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00097BB0) --------------------------------------------------------
int __cdecl sub_97BB0(int a1, int a2)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_register_timbre_callback(0x%X,0x%X)\n", a1, a2);
  v6 = sub_A8B20(a1, a2);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = 0x%X\n", v6);
  }
  --dword_181C04;
  return v6;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00097F90) --------------------------------------------------------
int __cdecl sub_97F90(_DWORD *a1)
{
  unsigned int i; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+0h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-4h]

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_lock_channel(0x%X)\n", a1);
  v5 = sub_A8BF0(a1);
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() )
  {
    for ( i = 0; i < 0xE; ++i )
      fprintf(dword_181BF0, " ");
    for ( j = 1; j < dword_181C04; ++j )
      fprintf(dword_181BF0, &unk_D2270);
    fprintf(dword_181BF0, "Result = %d\n", v5);
  }
  --dword_181C04;
  return v5;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000980D0) --------------------------------------------------------
_DWORD *__cdecl sub_980D0(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_release_channel(0x%X,%d)\n", a1, a2);
  result = sub_A8EA0(a1, a2);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00098170) --------------------------------------------------------
int __cdecl sub_98170(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_map_sequence_channel(0x%X,%d,%d)\n", a1, a2, a3);
  result = sub_A9080(a1, a2, a3);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (00098360) --------------------------------------------------------
_DWORD *__cdecl sub_98360(_DWORD *a1, int a2, int a3, unsigned int a4, int a5)
{
  _DWORD *result; // eax

  ++dword_181C04;
  if ( dword_181BF4 && (dword_181C04 == 1 || dword_181BF8) && !sub_A16A2() && sub_916F0() )
    fprintf(dword_181BF0, "AIL_send_channel_voice_message(0x%X,0x%X,0x%X,0x%X,0x%X)\n", a1, a2, a3, a4, a5);
  result = sub_A9140(a1, a2, a3, a4, a5);
  --dword_181C04;
  return result;
}
// A18E3: using guessed type _DWORD fprintf(_DWORD, _DWORD, ...);
// 181BF0: using guessed type int dword_181BF0;
// 181BF4: using guessed type int dword_181BF4;
// 181BF8: using guessed type int dword_181BF8;
// 181C04: using guessed type int dword_181C04;

//----- (000986A0) --------------------------------------------------------
bool sub_986A0()
{
  bool result; // eax

  if ( dword_E39BC )
  {
    result = sub_9D650((unsigned int)sub_915A0, (unsigned int)sub_986A0);
    dword_E39BC = 0;
  }
  return result;
}
// 915A0: using guessed type int sub_915A0();
// E39BC: using guessed type int dword_E39BC;

//----- (000986E0) --------------------------------------------------------
void sub_986E0()
{
  sub_99C90();
  sub_99C10();
  if ( byte_E39B8 )
    sub_91420();
}
// E39B8: using guessed type char byte_E39B8;

//----- (00098709) --------------------------------------------------------
unsigned int __cdecl sub_98709(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( a1 >= a2 )
      break;
    if ( *(_DWORD *)a1 < a3 )
    {
      *(_BYTE *)(a1 + 4) *= 2;
      *(_BYTE *)(a1 + 5) *= 2;
      *(_DWORD *)a1 += a3;
    }
    a1 += 6;
  }
  return result;
}

//----- (0009874D) --------------------------------------------------------
unsigned int *__cdecl sub_9874D(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  unsigned int *result; // eax

  while ( 1 )
  {
    result = a1;
    if ( (unsigned int)a1 >= a2 )
      break;
    if ( *a1 < a3 )
      *a1 += a3;
    a1 = (unsigned int *)((char *)a1 + 6);
  }
  return result;
}

//----- (00098790) --------------------------------------------------------
void __cdecl sub_98790(unsigned __int16 a1, unsigned __int8 a2)
{
  if ( byte_E37FC && byte_E37FD && word_E3802 && a2 <= 0x7Fu && sub_96170(dword_180C78) != 2 )
    sub_96030((_DWORD *)dword_180C78, a2, a1);
}
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E3802: using guessed type __int16 word_E3802;
// 180C78: using guessed type int dword_180C78;

//----- (00098817) --------------------------------------------------------
int __cdecl sub_98817(int a1, int a2)
{
  int v3; // [esp+4h] [ebp-4h]

  if ( a2 == 546 )
  {
    v3 = creat(a1, 448);
    setmode(v3, 512);
    close(v3);
  }
  return sopen(a1, a2, 64);
}
// A0855: using guessed type _DWORD __cdecl close(_DWORD);
// AA6DD: using guessed type _DWORD __cdecl creat(_DWORD, _DWORD);
// AA6F4: using guessed type _DWORD __cdecl setmode(_DWORD, _DWORD);

//----- (00098882) --------------------------------------------------------
int __cdecl sub_98882(int a1)
{
  return close(a1);
}
// A0855: using guessed type _DWORD __cdecl close(_DWORD);

//----- (000988A7) --------------------------------------------------------
int __cdecl sub_988A7(int a1, int a2, int a3)
{
  return read(a1, a2, a3);
}
// A0863: using guessed type _DWORD __cdecl read(_DWORD, _DWORD, _DWORD);

//----- (0009891E) --------------------------------------------------------
int __cdecl sub_9891E(int a1, int a2, char a3)
{
  return lseek(a1, a2, a3);
}
// AA7C0: using guessed type _DWORD __cdecl lseek(_DWORD, _DWORD, char);

//----- (0009894C) --------------------------------------------------------
int __cdecl sub_9894C(int a1, char *a2)
{
  unsigned int i; // ecx
  int *v3; // esi
  int v4; // eax
  int v5; // eax
  _WORD *v6; // esi
  unsigned int v7; // edx
  char *v8; // ebx
  _DWORD *v9; // esi
  char *v10; // edi
  _DWORD *v11; // esi
  _WORD *v12; // edi
  _BYTE *v13; // esi
  _BYTE *v14; // edi
  char *v15; // edi
  int v16; // eax
  __int16 v17; // bx
  __int16 v18; // ax
  __int16 v19; // dx
  __int16 v20; // ax
  unsigned __int16 v22; // [esp-1Ah] [ebp-1Eh]

  if ( *(_WORD *)a1 != 20050 )
    return 0;
  v3 = (int *)(a1 + 4);
  if ( *(_WORD *)(a1 + 2) != 323 )
    return 0;
  LOBYTE(v4) = sub_98AE0(v3);
  dword_E3B40 = v4;
  LOBYTE(v5) = sub_98AE0(v3);
  dword_E3B44 = v5;
  byte_E3B50 = *(_BYTE *)(a1 + 9);
  v6 = (_WORD *)(a1 + 10);
  v7 = v5 + 18 + a1;
  if ( v7 > (unsigned int)a2 )
  {
    v8 = &a2[dword_E3B40 + *(unsigned __int8 *)(a1 + 16)];
    if ( (unsigned int)v8 > v7 )
    {
      v9 = (_DWORD *)(v7 - 4);
      v10 = v8 - 4;
      for ( i = (unsigned int)dword_E3B44 >> 2; i; --i )
      {
        *(_DWORD *)v10 = *v9--;
        v10 -= 4;
      }
      v11 = v9 + 1;
      v12 = v10 + 4;
      LOWORD(i) = dword_E3B44 & 3;
      if ( (dword_E3B44 & 3) != 0 )
      {
        v13 = (char *)v11 - 1;
        v14 = (char *)v12 - 1;
        while ( i )
        {
          *v14-- = *v13--;
          --i;
        }
        v12 = v14 + 1;
      }
      v6 = v12;
    }
  }
  v15 = a2;
  byte_E3B51 = 0;
  word_E3B4C = *v6;
  sub_98B2C(2u, (int)v6);
  do
  {
    sub_98BAF((int)v6);
    sub_98BAF((int)v6);
    sub_98BAF((int)v6);
    word_E3B4A = sub_98B2C(0x10u, (int)v6);
    while ( 1 )
    {
      sub_98AE9(word_E39C0, (int)v6);
      if ( (_WORD)i )
      {
        qmemcpy(v15, v6, i);
        v6 = (_WORD *)((char *)v6 + i);
        v15 += i;
        i = (unsigned __int8)byte_E3B51;
        v17 = *v6;
        v18 = __ROL2__(*v6, byte_E3B51);
        v19 = (1 << byte_E3B51) - 1;
        word_E3B4C &= v19;
        v20 = v18 & v19 | (v6[1] << byte_E3B51);
        word_E3B4C |= v17 << byte_E3B51;
        word_E3B4E = v20;
      }
      if ( !--word_E3B4A )
        break;
      sub_98AE9(word_E3A40, (int)v6);
      v22 = i;
      sub_98AE9(word_E3AC0, (int)v6);
      LOWORD(i) = i + 2;
      v16 = v22;
      LOWORD(v16) = v22 + 1;
      qmemcpy(v15, &v15[-v16], i);
      v15 += i;
      i = 0;
    }
    --byte_E3B50;
  }
  while ( byte_E3B50 );
  return dword_E3B40;
}
// 98979: variable 'v4' is possibly undefined
// 98983: variable 'v5' is possibly undefined
// 98A3B: variable 'i' is possibly undefined
// E39C0: using guessed type __int16 word_E39C0[64];
// E3A40: using guessed type __int16 word_E3A40[64];
// E3AC0: using guessed type __int16 word_E3AC0[64];
// E3B40: using guessed type int dword_E3B40;
// E3B44: using guessed type int dword_E3B44;
// E3B4A: using guessed type __int16 word_E3B4A;
// E3B4C: using guessed type __int16 word_E3B4C;
// E3B4E: using guessed type __int16 word_E3B4E;
// E3B50: using guessed type char byte_E3B50;
// E3B51: using guessed type char byte_E3B51;

//----- (00098AE0) --------------------------------------------------------
char __usercall sub_98AE0@<al>(int *a1@<esi>)
{
  int v1; // eax

  v1 = *a1;
  BYTE1(v1) = *a1;
  LOBYTE(v1) = BYTE1(*a1);
  return (unsigned __int16)__ROL4__(v1, 16) >> 8;
}

//----- (00098AE9) --------------------------------------------------------
__int16 __usercall sub_98AE9@<ax>(__int16 *a1@<edx>, int a2@<esi>)
{
  __int16 *v3; // esi
  __int16 v5; // ax
  __int16 *v6; // esi
  __int16 v7; // bx
  __int16 v8; // ax
  __int16 v9; // cx
  __int16 result; // ax

  v3 = a1;
  do
  {
    v5 = *v3;
    v6 = v3 + 1;
    v7 = word_E3B4C & v5;
    v8 = *v6;
    v3 = v6 + 1;
  }
  while ( v8 != v7 );
  v9 = v3[30];
  result = sub_98B2C(HIBYTE(v9), a2);
  if ( (unsigned __int8)v9 >= 2u )
    return (1 << (v9 - 1)) | sub_98B2C(v9 - 1, a2);
  return result;
}
// E3B4C: using guessed type __int16 word_E3B4C;

//----- (00098B2C) --------------------------------------------------------
__int16 __usercall sub_98B2C@<ax>(unsigned __int8 a1@<al>, int a2@<esi>)
{
  unsigned __int16 v3; // ax
  unsigned __int16 v4; // bx
  char v5; // ch
  __int16 v7; // [esp-4h] [ebp-4h]

  v3 = word_E3B4E;
  v4 = word_E3B4C;
  v7 = word_E3B4C & ((1 << a1) - 1);
  v5 = byte_E3B51 - a1;
  if ( (unsigned __int8)byte_E3B51 < a1 )
  {
    v4 = __ROR2__(word_E3B4E & ((1 << byte_E3B51) - 1), byte_E3B51) | ((unsigned __int16)word_E3B4C >> byte_E3B51);
    v3 = *(_WORD *)(a2 + 2);
    a1 -= byte_E3B51;
    v5 = 16 - a1;
  }
  word_E3B4E = v3 >> a1;
  word_E3B4C = __ROR2__(v3 & ((1 << a1) - 1), a1) | (v4 >> a1);
  byte_E3B51 = v5;
  return v7;
}
// E3B4C: using guessed type __int16 word_E3B4C;
// E3B4E: using guessed type __int16 word_E3B4E;
// E3B51: using guessed type char byte_E3B51;

//----- (00098BAF) --------------------------------------------------------
char __usercall sub_98BAF@<al>(int a1@<esi>)
{
  _BYTE *v1; // edi
  unsigned __int16 v2; // ax
  int v3; // ecx
  int v4; // ecx
  _BYTE *v5; // esi
  _WORD *v6; // edi
  unsigned __int16 v7; // bx
  unsigned __int16 v8; // dx
  _WORD *v9; // edi
  unsigned __int16 v10; // bx
  char v11; // cf
  __int16 v13; // t2
  __int16 v14; // ax
  __int16 v16; // [esp-24h] [ebp-28h] BYREF
  unsigned __int16 v17; // [esp-22h] [ebp-26h]
  unsigned __int16 v18; // [esp-20h] [ebp-24h]
  _BYTE *v19; // [esp-1Eh] [ebp-22h]
  __int16 v20; // [esp-1Ah] [ebp-1Eh]
  int v21; // [esp-18h] [ebp-1Ch]
  _DWORD v22[6]; // [esp-14h] [ebp-18h] BYREF

  v1 = v22;
  v2 = sub_98B2C(5u, a1);
  v3 = v2;
  if ( v2 )
  {
    v21 = v2;
    do
    {
      v2 = sub_98B2C(4u, a1);
      *v1++ = v2;
      --v3;
    }
    while ( v3 );
    v4 = v21;
    v21 = a1;
    v5 = v22;
    v6 = (_WORD *)v22[4];
    LOBYTE(v2) = 1;
    v7 = 0;
    v8 = 0x8000;
    do
    {
      v20 = v4;
      v19 = v5;
      do
      {
        if ( (_BYTE)v2 == *v5 )
        {
          v18 = v2;
          v17 = v7;
          v16 = v4;
          *v6 = (1 << v2) - 1;
          v9 = v6 + 1;
          v10 = v7 >> (16 - v2);
          LOBYTE(v4) = v2;
          _AX = 0;
          v11 = 0;
          do
          {
            v13 = v11 << 15;
            v11 = v10 & 1;
            v10 = (v10 >> 1) | v13;
            __asm { rcl     ax, 1 }
            --v4;
          }
          while ( v4 );
          *v9 = _AX;
          v6 = v9 + 1;
          LOBYTE(v14) = v5 - (_BYTE *)&v16 - 16;
          HIBYTE(v14) = *v5;
          v6[30] = v14;
          LOWORD(v4) = v16;
          v2 = v18;
          v7 = v8 + v17;
        }
        ++v5;
        --v4;
      }
      while ( v4 );
      v5 = v19;
      LOWORD(v4) = v20;
      v8 >>= 1;
      LOBYTE(v2) = v2 + 1;
    }
    while ( (_BYTE)v2 != 17 );
  }
  return v2;
}

//----- (00098C48) --------------------------------------------------------
int __cdecl sub_98C48(int a1, int a2, int a3)
{
  int v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]

  v5 = sub_98817(a1, 546);
  if ( v5 == -1 )
    return -1;
  v6 = sub_98CAA(v5, a2, a3);
  sub_98882(v5);
  return v6;
}

//----- (00098CAA) --------------------------------------------------------
int __cdecl sub_98CAA(int a1, int a2, int a3)
{
  return write(a1, a2, a3);
}
// AA80B: using guessed type _DWORD __cdecl write(_DWORD, _DWORD, _DWORD);

//----- (00098FF5) --------------------------------------------------------
int __cdecl sub_98FF5(char *a1)
{
  char v2; // cl
  int v3; // ebx
  int v4; // ebx

  while ( (IsTable[(unsigned __int8)(*a1 + 1)] & 2) != 0 )
    ++a1;
  v2 = *a1;
  if ( *a1 == 43 || v2 == 45 )
    ++a1;
  v3 = 0;
  while ( (IsTable[(unsigned __int8)(*a1 + 1)] & 0x20) != 0 )
  {
    v4 = (unsigned __int8)*a1++ + 10 * v3;
    v3 = v4 - 48;
  }
  if ( v2 == 45 )
    return -v3;
  return v3;
}

//----- (00099080) --------------------------------------------------------
void __cdecl sub_99080(char a1)
{
  byte_E379B = a1 != 0;
}
// E379B: using guessed type char byte_E379B;

//----- (0009937E) --------------------------------------------------------
int __cdecl sub_9937E(__int16 a1)
{
  int result; // eax
  int v2[13]; // [esp+0h] [ebp-78h] BYREF
  char v3[28]; // [esp+34h] [ebp-44h] BYREF
  int v4[7]; // [esp+50h] [ebp-28h] BYREF
  char v5[12]; // [esp+6Ch] [ebp-Ch] BYREF

  memset(v2, 0, 50);
  HIWORD(v2[8]) = (unsigned int)dword_181C40 >> 4;
  LOWORD(v2[9]) = HIWORD(v2[8]);
  v2[0] = 0;
  v2[7] = 20225;
  v2[6] = a1;
  memset(v4, 0, sizeof(v4));
  memset(v3, 0, sizeof(v3));
  memset(v5, 0, sizeof(v5));
  segread(v5);
  v4[0] = 768;
  v4[1] = 16;
  v4[5] = (int)v2;
  int386x(49, v4, v3, v5);
  word_181C44 = *(unsigned __int8 *)(dword_181C40 + 4) + (*(unsigned __int8 *)(dword_181C40 + 5) << 8);
  word_E3BA6 = *(unsigned __int8 *)(dword_181C40 + 16) + (*(unsigned __int8 *)(dword_181C40 + 17) << 8);
  word_E3BA8 = *(unsigned __int8 *)(dword_181C40 + 18) + (*(unsigned __int8 *)(dword_181C40 + 19) << 8);
  HIWORD(result) = HIWORD(dword_181C40);
  LOWORD(result) = *(unsigned __int8 *)(dword_181C40 + 20);
  word_E3BAA = (unsigned __int8)result + (*(unsigned __int8 *)(dword_181C40 + 21) << 8);
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99DE6: using guessed type _DWORD __cdecl segread(_DWORD);
// 99E10: using guessed type _DWORD __cdecl int386x(_DWORD, _DWORD, _DWORD, _DWORD);
// E3BA6: using guessed type __int16 word_E3BA6;
// E3BA8: using guessed type __int16 word_E3BA8;
// E3BAA: using guessed type __int16 word_E3BAA;
// 181C40: using guessed type int dword_181C40;
// 181C44: using guessed type __int16 word_181C44;

//----- (000994BA) --------------------------------------------------------
int __cdecl sub_994BA(__int16 a1)
{
  char v2[28]; // [esp+0h] [ebp-38h] BYREF
  _WORD v3[14]; // [esp+1Ch] [ebp-1Ch] BYREF

  memset(v3, 0, sizeof(v3));
  memset(v2, 0, sizeof(v2));
  v3[0] = 20226;
  v3[2] = a1;
  int386(16, v3, v2);
  return sub_9937E(a1);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009951B) --------------------------------------------------------
int __cdecl sub_9951B(__int16 a1)
{
  int result; // eax

  word_E3BA4 = a1;
  if ( (unsigned __int16)a1 >= 6u )
  {
    __outbyte(0x3C8u, 0);
    __outbyte(0x3C9u, 0x3Fu);
    __outbyte(0x3C9u, 0);
    __outbyte(0x3C9u, 0);
  }
  __asm { int     10h; - VIDEO - VESA SuperVGA BIOS -  VESA SuperVGA BIOS - CPU VIDEO MEMORY CONTROL }
  result = 20229;
  __asm { int     10h; - VIDEO - VESA SuperVGA BIOS -  VESA SuperVGA BIOS - CPU VIDEO MEMORY CONTROL }
  return result;
}
// E3BA4: using guessed type __int16 word_E3BA4;
// 181C40: using guessed type int dword_181C40;

//----- (000995B0) --------------------------------------------------------
int sub_995B0()
{
  int v1[13]; // [esp+0h] [ebp-7Ch] BYREF
  int v2[7]; // [esp+34h] [ebp-48h] BYREF
  char v3[28]; // [esp+50h] [ebp-2Ch] BYREF
  char v4[12]; // [esp+6Ch] [ebp-10h] BYREF

  memset(v1, 0, 50);
  HIWORD(v1[8]) = (unsigned int)dword_181C40 >> 4;
  LOWORD(v1[9]) = HIWORD(v1[8]);
  v1[0] = 0;
  v1[7] = 20224;
  v1[4] = 257;
  memset(v2, 0, sizeof(v2));
  memset(v3, 0, sizeof(v3));
  memset(v4, 0, sizeof(v4));
  segread(v4);
  v2[0] = 768;
  v2[1] = 16;
  v2[5] = (int)v1;
  int386x(49, v2, v3, v4);
  return strncmp(dword_181C40, aVesa, 4);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99682: using guessed type _DWORD __cdecl strncmp(_DWORD, _DWORD, _DWORD);
// 99DE6: using guessed type _DWORD __cdecl segread(_DWORD);
// 99E10: using guessed type _DWORD __cdecl int386x(_DWORD, _DWORD, _DWORD, _DWORD);
// 181C40: using guessed type int dword_181C40;

//----- (00099970) --------------------------------------------------------
void __cdecl sub_99970(char a1, unsigned __int8 a2)
{
  if ( byte_E3819 && byte_E37FC && byte_E37FD && word_E3802 && sub_96170(dword_180C78) != 2 && byte_E3817 != a1 )
  {
    if ( byte_E3818 )
      sub_92DC0(dword_180C80);
    byte_E3817 = a1;
    byte_E381A = -byte_E381A;
    byte_E3818 = 1;
    if ( a2 <= 4u && a2 )
    {
      dword_180C80 = sub_92600((int)sub_99830);
      sub_92930(dword_180C80, 30 * a2);
      sub_92BA0(dword_180C80);
    }
    else
    {
      dword_180C80 = sub_92600((int)sub_99830);
      sub_92930(dword_180C80, 0x1Eu);
      sub_92BA0(dword_180C80);
    }
  }
}
// 99830: using guessed type int sub_99830();
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E3802: using guessed type __int16 word_E3802;
// E3817: using guessed type char byte_E3817;
// E3818: using guessed type char byte_E3818;
// E3819: using guessed type char byte_E3819;
// E381A: using guessed type char byte_E381A;
// 180C78: using guessed type int dword_180C78;
// 180C80: using guessed type int dword_180C80;

//----- (00099A77) --------------------------------------------------------
unsigned int __cdecl sub_99A77(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( a1 >= a2 )
      break;
    if ( *(_DWORD *)a1 >= a3 )
    {
      *(_BYTE *)(a1 + 4) = (int)*(unsigned __int8 *)(a1 + 4) >> 1;
      *(_BYTE *)(a1 + 5) = (int)*(unsigned __int8 *)(a1 + 5) >> 1;
      *(_DWORD *)a1 -= a3;
    }
    a1 += 6;
  }
  return result;
}

//----- (00099AEB) --------------------------------------------------------
unsigned int *__cdecl sub_99AEB(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  unsigned int *result; // eax

  while ( 1 )
  {
    result = a1;
    if ( (unsigned int)a1 >= a2 )
      break;
    if ( *a1 >= a3 )
      *a1 -= a3;
    a1 = (unsigned int *)((char *)a1 + 6);
  }
  return result;
}

//----- (00099C10) --------------------------------------------------------
void sub_99C10()
{
  if ( byte_E379A )
  {
    sub_8D8F0();
    if ( !byte_E37FE )
      sub_919C0();
    if ( dword_E37A0 )
    {
      sub_83E80(dword_E37A0);
      dword_E37A4 = 0;
    }
    if ( dword_E37A8 )
      sub_83E80(dword_E37A8);
    byte_E3798 = 0;
    byte_E3799 = 0;
    byte_E379A = 0;
  }
}
// E3798: using guessed type char byte_E3798;
// E3799: using guessed type char byte_E3799;
// E379A: using guessed type char byte_E379A;
// E37A0: using guessed type int dword_E37A0;
// E37A4: using guessed type int dword_E37A4;
// E37A8: using guessed type int dword_E37A8;
// E37FE: using guessed type char byte_E37FE;

//----- (00099C90) --------------------------------------------------------
void sub_99C90()
{
  if ( byte_E37FE )
  {
    if ( word_E3802 )
    {
      sub_95DE0((int *)dword_180C78);
      sub_95F00(dword_180C78);
      word_E3802 = 0;
    }
    if ( byte_E3815 == 1 )
      sub_9FA80();
    if ( !byte_E379A )
      sub_919C0();
    if ( dword_E3808 )
    {
      sub_83E80(dword_E3808);
      dword_E380C = 0;
    }
    if ( dword_E3810 )
      sub_83E80(dword_E3810);
    byte_E37FC = 0;
    byte_E37FD = 0;
    byte_E37FE = 0;
  }
}
// E379A: using guessed type char byte_E379A;
// E37FC: using guessed type char byte_E37FC;
// E37FD: using guessed type char byte_E37FD;
// E37FE: using guessed type char byte_E37FE;
// E3802: using guessed type __int16 word_E3802;
// E3808: using guessed type int dword_E3808;
// E380C: using guessed type int dword_E380C;
// E3810: using guessed type int dword_E3810;
// E3815: using guessed type char byte_E3815;
// 180C78: using guessed type int dword_180C78;

//----- (00099E8E) --------------------------------------------------------
int __cdecl sub_99E8E(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4)
{
  int v4; // edi
  unsigned __int8 *i; // ebx
  unsigned __int8 v6; // al
  unsigned __int8 v8; // cl
  unsigned int v9; // esi
  int v10; // eax
  unsigned int v11; // edx
  unsigned __int8 *v12; // [esp+0h] [ebp-1Ch]
  char v13; // [esp+4h] [ebp-18h]
  unsigned __int8 v14; // [esp+8h] [ebp-14h]

  v4 = a3;
  if ( a2 )
    *a2 = a1;
  for ( i = a1; (IsTable[(unsigned __int8)(*i + 1)] & 2) != 0; ++i )
    ;
  v14 = *i;
  if ( *i == 43 || *i == 45 )
    ++i;
  if ( !a3 )
  {
    if ( *i == 48 && ((v6 = i[1], v6 == 120) || v6 == 88) )
    {
      v4 = 16;
    }
    else if ( *i == 48 )
    {
      v4 = 8;
    }
    else
    {
      v4 = 10;
    }
  }
  if ( v4 >= 2 && v4 <= 36 )
  {
    if ( v4 == 16 && *i == 48 )
    {
      v8 = i[1];
      if ( v8 == 120 || v8 == 88 )
        i += 2;
    }
    v12 = i;
    v9 = 0;
    v13 = 0;
    while ( 1 )
    {
      v10 = sub_99FF5(*i);
      if ( v10 >= v4 )
        break;
      v11 = v9;
      v9 = v10 + v4 * v9;
      if ( v9 < v11 )
        v13 = 1;
      ++i;
    }
    if ( i == v12 )
      i = a1;
    if ( a2 )
      *a2 = i;
    if ( a4 == 1 && v9 >= 0x80000000 && (v9 != 0x80000000 || v14 != 45) )
      v13 = 1;
    if ( v13 )
    {
      _set_errno(14);
      if ( a4 )
      {
        if ( v14 == 45 )
          return 0x80000000;
        else
          return 0x7FFFFFFF;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      if ( v14 == 45 )
        return -v9;
      return v9;
    }
  }
  else
  {
    _set_errno(13);
    return 0;
  }
}
// 9D195: using guessed type _DWORD __cdecl _set_errno(_DWORD);

//----- (00099FF0) --------------------------------------------------------
int __cdecl sub_99FF0(unsigned __int8 *a1, unsigned __int8 **a2, int a3)
{
  return sub_99E8E(a1, a2, a3, 1);
}

//----- (00099FF5) --------------------------------------------------------
int __cdecl sub_99FF5(unsigned __int8 a1)
{
  unsigned __int8 v2; // al

  if ( a1 >= 0x30u && a1 <= 0x39u )
    return a1 - 48;
  v2 = tolower(a1);
  if ( v2 >= 0x61u && v2 <= 0x69u )
    return v2 - 87;
  if ( v2 >= 0x6Au && v2 <= 0x72u || v2 >= 0x73u && v2 <= 0x7Au )
    return v2 - 87;
  return 37;
}
// AB952: using guessed type _DWORD __cdecl tolower(_DWORD);

//----- (0009A0FC) --------------------------------------------------------
unsigned __int8 sub_9A0FC()
{
  unsigned __int8 result; // al

  do
    result = __inbyte(0x3DAu);
  while ( (result & 8) == 0 );
  return result;
}

//----- (0009A10A) --------------------------------------------------------
int __fastcall sub_9A10A(int result)
{
  if ( dword_E4CA4 )
    return 1;
  __asm { int     21h; DOS - CHECK STANDARD INPUT STATUS }
  return (char)result;
}
// E4CA4: using guessed type int dword_E4CA4;

//----- (0009A128) --------------------------------------------------------
void __cdecl sub_9A128(const void *a1, void *a2, unsigned __int16 a3)
{
  qmemcpy(a2, a1, 320 * a3);
}

//----- (0009A144) --------------------------------------------------------
void __cdecl sub_9A144(const void *a1, void *a2, unsigned __int16 a3)
{
  qmemcpy(a2, a1, 640 * a3);
}

//----- (0009A230) --------------------------------------------------------
int __cdecl sub_9A230(int a1)
{
  int result; // eax

  result = a1;
  if ( (unsigned __int16)a1 < 0x336u )
  {
    if ( (unsigned __int16)a1 < 0x320u )
    {
      if ( !(_WORD)a1 )
        word_E37B4 = 0;
    }
    else if ( (unsigned __int16)a1 <= 0x320u )
    {
      word_E37B4 = 800;
    }
    else if ( (_WORD)a1 == 811 )
    {
      word_E37B4 = 811;
    }
  }
  else if ( (unsigned __int16)a1 <= 0x336u )
  {
    word_E37B4 = 822;
  }
  else if ( (unsigned __int16)a1 < 0x656u )
  {
    if ( (_WORD)a1 == 1611 )
      word_E37B4 = 1611;
  }
  else if ( (unsigned __int16)a1 <= 0x656u )
  {
    word_E37B4 = 1622;
  }
  else if ( (_WORD)a1 == 1644 )
  {
    word_E37B4 = 1644;
  }
  return result;
}
// E37B4: using guessed type __int16 word_E37B4;

//----- (0009A2F5) --------------------------------------------------------
_DWORD *__cdecl sub_9A2F5(int a1)
{
  _DWORD *result; // eax

  result = *(_DWORD **)(a1 + 28);
  if ( *result )
  {
    sub_83E80(**(_DWORD **)(a1 + 28));
    result = *(_DWORD **)(a1 + 28);
    *result = 0;
  }
  return result;
}

//----- (0009A32D) --------------------------------------------------------
int __cdecl sub_9A32D(int a1)
{
  int v1; // edx
  int *v2; // eax
  int v3; // edx
  int *v4; // eax
  int (__cdecl *v6)(int); // [esp+0h] [ebp-8h]

  sub_85070();
  if ( (*(_BYTE *)(a1 + 40) & 1) != 0 )
    v6 = sub_83D70;
  else
    v6 = sub_83CD0;
  sub_9A2F5(a1);
  if ( *(_BYTE *)a1 == 42 )
  {
    v1 = v6(*(_DWORD *)(a1 + 36));
    v2 = *(int **)(a1 + 28);
    *v2 = v1;
    if ( !*v2 )
      return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 36) = sub_AB9E1(a1);
    if ( *(int *)(a1 + 36) <= 0 )
      return 0;
    v3 = v6(*(_DWORD *)(a1 + 36));
    v4 = *(int **)(a1 + 28);
    *v4 = v3;
    if ( !*v4 )
      return -1;
    if ( sub_53E60(a1, **(char ***)(a1 + 28)) != *(_DWORD *)(a1 + 36) )
    {
      **(_DWORD **)(a1 + 28) = 0;
      **(_DWORD **)(a1 + 32) = 0;
      *(_DWORD *)(a1 + 36) = 0;
      return 0;
    }
  }
  if ( *(_DWORD *)(a1 + 32) )
    **(_DWORD **)(a1 + 32) = *(_DWORD *)(a1 + 36) + **(_DWORD **)(a1 + 28);
  return 1;
}

//----- (0009AD16) --------------------------------------------------------
int __cdecl sub_9AD16(unsigned __int16 a1)
{
  int result; // eax
  char v2[28]; // [esp+0h] [ebp-38h] BYREF
  int v3[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  if ( a1 )
  {
    v3[0] = 257;
    v3[3] = a1;
    return int386(49, v3, v2);
  }
  return result;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 9AD16: using guessed type char var_38[28];

//----- (0009AD9C) --------------------------------------------------------
int __cdecl sub_9AD9C(int a1)
{
  return 100 * a1;
}

//----- (0009ADB4) --------------------------------------------------------
int __cdecl sub_9ADB4(int a1)
{
  return 100 * a1 / 10;
}

//----- (0009AE04) --------------------------------------------------------
bool __cdecl sub_9AE04(int a1, int a2)
{
  return j___clock() - a1 >= a2;
}
// 98786: using guessed type int j___clock(void);

//----- (0009AE90) --------------------------------------------------------
char __cdecl sub_9AE90(int *a1, _BYTE *a2, int a3, int a4)
{
  int v5; // ebp
  int v6; // ebx

  v5 = j_j___clock();
  v6 = 0;
  do
  {
    if ( !sub_9C9D0(*a1) )
    {
      ++v6;
      *a2++ = sub_9C938((_DWORD *)*a1);
      if ( v6 == a3 )
        return 0;
    }
  }
  while ( !sub_9AE04(v5, a4) );
  return 3;
}
// 9ADFC: using guessed type int j_j___clock(void);

//----- (0009AEEC) --------------------------------------------------------
void __cdecl sub_9AEEC(_DWORD **a1, char *a2)
{
  char v3; // [esp-4h] [ebp-Ch]

  if ( dword_E3DE8 )
    printf(aWritingS);
  while ( *a2 )
  {
    v3 = *a2++;
    sub_9C810(*a1, v3);
  }
  JUMPOUT(0x9AEE8);
}
// 9AF10: control flows out of bounds to 9AEE8
// E3DE8: using guessed type int dword_E3DE8;

//----- (0009AFC4) --------------------------------------------------------
char __usercall sub_9AFC4@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, int *a4, int a5)
{
  int v5; // edi
  int v6; // ebx

  v5 = j_j___clock(a1, a2, a3);
  do
  {
    if ( !sub_9C9D0(*a4) )
    {
      v6 = sub_9C938((_DWORD *)*a4);
      if ( dword_E3DE8 )
        printf(aResponseC);
      if ( v6 == 79 )
        return 0;
      if ( v6 == 69 )
        return 8;
    }
  }
  while ( !sub_9AE04(v5, a5) );
  return 3;
}
// 9ADFC: using guessed type int __fastcall j_j___clock(_DWORD, _DWORD, _DWORD);
// E3DE8: using guessed type int dword_E3DE8;

//----- (0009B038) --------------------------------------------------------
char __cdecl sub_9B038(int *a1, char *a2, int a3)
{
  int v3; // eax

  sub_9AEEC((_DWORD **)a1, a2);
  return sub_9AFC4(v3, (int)a2, (int)a1, a1, a3);
}
// 9B051: variable 'v3' is possibly undefined

//----- (0009B234) --------------------------------------------------------
int __cdecl sub_9B234(int *a1)
{
  int result; // eax

  if ( *a1 )
  {
    sub_9C58C(*a1);
    result = free(*a1);
    *a1 = 0;
  }
  return result;
}
// A0E6B: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0009B260) --------------------------------------------------------
int __cdecl sub_9B260(_DWORD **a1)
{
  return sub_9C810(*a1, 83);
}

//----- (0009B274) --------------------------------------------------------
char __cdecl sub_9B274(int *a1, int a2)
{
  int v3; // ebp
  int v4; // esi
  char v5; // dl
  int v6; // edi
  int i; // eax
  char v8; // dh
  char v9; // [esp+0h] [ebp-44h] BYREF
  unsigned __int8 v10; // [esp+1h] [ebp-43h]
  unsigned __int8 v11; // [esp+2h] [ebp-42h]
  unsigned __int8 v12; // [esp+3h] [ebp-41h]
  unsigned __int8 v13; // [esp+4h] [ebp-40h]
  unsigned __int8 v14; // [esp+5h] [ebp-3Fh]
  unsigned __int8 v15; // [esp+6h] [ebp-3Eh]
  unsigned __int8 v16; // [esp+7h] [ebp-3Dh]
  unsigned __int8 v17; // [esp+8h] [ebp-3Ch]
  unsigned __int8 v18; // [esp+9h] [ebp-3Bh]
  unsigned __int8 v19; // [esp+Ah] [ebp-3Ah]
  char v20; // [esp+Bh] [ebp-39h]
  int v21; // [esp+20h] [ebp-24h] BYREF
  int v22; // [esp+24h] [ebp-20h] BYREF
  int v23; // [esp+28h] [ebp-1Ch] BYREF
  int v24; // [esp+2Ch] [ebp-18h]
  int v25; // [esp+30h] [ebp-14h]

  if ( sub_9AE90(a1, &v9, 12, a2) )
  {
    sub_9CBBC((_DWORD *)*a1);
    return 3;
  }
  else
  {
    v3 = (__int16)(v10 << 8) | v11;
    v24 = v13 | (__int16)(v12 << 8);
    v25 = v15 | (__int16)(v14 << 8);
    v4 = v17 | (__int16)(v16 << 8);
    v5 = 0;
    v6 = (__int16)(v18 << 8) | v19;
    for ( i = 0; i < 11; ++i )
    {
      v8 = *(&v9 + i);
      v5 += v8;
    }
    if ( v5 == v20 )
    {
      sub_AC250(
        (__int16)(v10 << 8) | v11,
        v24,
        v25,
        v17 | (__int16)(v16 << 8),
        (__int16)(v18 << 8) | v19,
        &v23,
        &v22,
        &v21);
      a1[1] = v3;
      a1[4] = v4;
      a1[5] = v6;
      a1[2] = v24;
      a1[3] = v25;
      a1[6] = v22;
      a1[7] = v23;
      a1[8] = v21;
      return 0;
    }
    else
    {
      sub_9CBBC((_DWORD *)*a1);
      return 4;
    }
  }
}

//----- (0009B498) --------------------------------------------------------
char *__cdecl sub_9B498(char a1)
{
  char *result; // eax

  switch ( a1 )
  {
    case 0:
      result = aTrackerInitial;
      break;
    case 1:
      result = aNoSerialPort;
      break;
    case 2:
      result = aTrackerNotPres;
      break;
    case 3:
      result = aTrackerIsNotRe;
      break;
    case 4:
      result = aTrackerDataIsI;
      break;
    case 5:
      result = aTrackerHeaderD;
      break;
    case 6:
      result = aAVerifiedWrite;
      break;
    case 7:
      result = aInvalidParamet;
      break;
    case 8:
      result = aTrackerCommand;
      break;
    case 9:
      result = aAMemoryAllocat;
      break;
    case 10:
      result = aTrackerVersion;
      break;
    default:
      result = aUndefined;
      break;
  }
  return result;
}

//----- (0009B540) --------------------------------------------------------
bool __cdecl sub_9B540(unsigned int a1, unsigned int a2)
{
  int v3[7]; // [esp+4h] [ebp-20h] BYREF

  v3[0] = 1536;
  v3[1] = HIWORD(a1);
  v3[2] = (unsigned __int16)a1;
  v3[4] = HIWORD(a2);
  v3[5] = (unsigned __int16)a2;
  int386(49, v3, v3);
  return v3[6] == 0;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009B5B4) --------------------------------------------------------
bool __cdecl sub_9B5B4(unsigned int a1, unsigned int a2)
{
  int v3[7]; // [esp+4h] [ebp-20h] BYREF

  v3[0] = 1537;
  v3[1] = HIWORD(a1);
  v3[2] = (unsigned __int16)a1;
  v3[4] = HIWORD(a2);
  v3[5] = (unsigned __int16)a2;
  int386(49, v3, v3);
  return v3[6] == 0;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009B628) --------------------------------------------------------
void sub_9B628()
{
  ;
}

//----- (0009B63C) --------------------------------------------------------
int __cdecl sub_9B63C(int a1)
{
  return inp(a1);
}
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);

//----- (0009B688) --------------------------------------------------------
_WORD *__cdecl sub_9B688(int a1)
{
  _WORD *result; // eax
  __int16 v2; // dx
  int v3; // [esp+10h] [ebp-34h]
  _WORD *v4; // [esp+30h] [ebp-14h]
  _WORD *v5; // [esp+34h] [ebp-10h]
  unsigned __int8 i; // [esp+38h] [ebp-Ch]
  char v7; // [esp+40h] [ebp-4h]

  result = (_WORD *)a1;
  if ( *(_DWORD *)(a1 + 28) )
  {
    if ( *(_DWORD *)(a1 + 20) )
    {
      v5 = *(_WORD **)(a1 + 44);
      if ( (inp(*(_DWORD *)(a1 + 28) + 6) & 0x10) == 0 )
      {
        result = v5;
        v5[2] |= 2u;
        return result;
      }
      v5[2] &= ~2u;
    }
    result = (_WORD *)inp(*(_DWORD *)(a1 + 28) + 5);
    if ( ((unsigned __int8)result & 0x20) != 0 )
    {
      if ( *(_DWORD *)(a1 + 24) )
        v3 = 16;
      else
        v3 = 1;
      v4 = *(_WORD **)a1;
      for ( i = 0; ; ++i )
      {
        result = v4;
        if ( (__int16)v4[2] <= 0 )
          break;
        result = (_WORD *)i;
        if ( i >= v3 )
          break;
        v2 = (*v4)++;
        v7 = *(_BYTE *)(v2 + *(_DWORD *)(a1 + 4));
        if ( *v4 == v4[3] )
          *v4 = 0;
        --v4[2];
        outp(*(_DWORD *)(a1 + 28), v7);
      }
    }
  }
  return result;
}
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);

//----- (0009B7E8) --------------------------------------------------------
int __cdecl sub_9B7E8(_DWORD *a1)
{
  __int16 v1; // dx
  char v3; // [esp+44h] [ebp-1Ch]
  _WORD *v4; // [esp+50h] [ebp-10h]
  char v5; // [esp+54h] [ebp-Ch]
  char v6; // [esp+58h] [ebp-8h]

  if ( a1[7] )
  {
    *(_WORD *)(a1[11] + 4) |= 0x10u;
    while ( 1 )
    {
      v3 = inp(a1[7] + 2);
      if ( (v3 & 1) != 0 )
        break;
      switch ( v3 & 7 )
      {
        case 0:
          v6 = inp(a1[7] + 6);
          if ( a1[5] )
          {
            if ( (v6 & 0x10) != 0 )
            {
              if ( (*(_WORD *)(a1[11] + 4) & 2) != 0 )
                sub_9B688((int)a1);
            }
            else
            {
              *(_WORD *)(a1[11] + 4) |= 2u;
            }
          }
          break;
        case 2:
          sub_9B688((int)a1);
          break;
        case 4:
          while ( (inp(a1[7] + 5) & 1) != 0 )
          {
            v5 = inp(a1[7]);
            v4 = *(_WORD **)((char *)a1 + 10);
            if ( v4[2] < v4[3] )
            {
              v1 = v4[1];
              v4[1] = v1 + 1;
              *(_BYTE *)(*(_DWORD *)((char *)a1 + 14) + v1) = v5;
              if ( v4[1] == v4[3] )
                v4[1] = 0;
              ++v4[2];
            }
          }
          break;
        case 6:
          inp(a1[7] + 5);
          break;
        default:
          continue;
      }
    }
  }
  return outp(32, 32);
}
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);

//----- (0009BA00) --------------------------------------------------------
void __usercall __noreturn sub_9BA00(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  ((void (__cdecl __noreturn *)(_DWORD, _DWORD, _DWORD, _DWORD, int, int, int, int, void **, int, int, int))_GETDS)(
    (unsigned __int16)__GS__,
    (unsigned __int16)__FS__,
    (unsigned __int16)__ES__,
    (unsigned __int16)__DS__,
    a1,
    a2,
    a3,
    a4,
    &retaddr,
    a5,
    a6,
    a7);
}

//----- (0009BA2C) --------------------------------------------------------
void __usercall __noreturn sub_9BA2C(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  ((void (__cdecl __noreturn *)(_DWORD, _DWORD, _DWORD, _DWORD, int, int, int, int, void **, int, int, int))_GETDS)(
    (unsigned __int16)__GS__,
    (unsigned __int16)__FS__,
    (unsigned __int16)__ES__,
    (unsigned __int16)__DS__,
    a1,
    a2,
    a3,
    a4,
    &retaddr,
    a5,
    a6,
    a7);
}

//----- (0009BA58) --------------------------------------------------------
void __usercall __noreturn sub_9BA58(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  ((void (__cdecl __noreturn *)(_DWORD, _DWORD, _DWORD, _DWORD, int, int, int, int, void **, int, int, int))_GETDS)(
    (unsigned __int16)__GS__,
    (unsigned __int16)__FS__,
    (unsigned __int16)__ES__,
    (unsigned __int16)__DS__,
    a1,
    a2,
    a3,
    a4,
    &retaddr,
    a5,
    a6,
    a7);
}

//----- (0009BA84) --------------------------------------------------------
void __usercall __noreturn sub_9BA84(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  ((void (__cdecl __noreturn *)(_DWORD, _DWORD, _DWORD, _DWORD, int, int, int, int, void **, int, int, int))_GETDS)(
    (unsigned __int16)__GS__,
    (unsigned __int16)__FS__,
    (unsigned __int16)__ES__,
    (unsigned __int16)__DS__,
    a1,
    a2,
    a3,
    a4,
    &retaddr,
    a5,
    a6,
    a7);
}

//----- (0009BAB0) --------------------------------------------------------
void sub_9BAB0()
{
  ;
}

//----- (0009BAC4) --------------------------------------------------------
int __cdecl sub_9BAC4(int a1, int a2)
{
  if ( !*(_DWORD *)(a1 + 28) )
    return 0;
  if ( a2 >= 300 )
  {
    if ( a2 > 115200 )
      a2 = 115200;
  }
  else
  {
    a2 = 300;
  }
  sub_AC449();
  outp(*(_DWORD *)(a1 + 28) + 3, 131);
  outp(*(_DWORD *)(a1 + 28) + 1, (unsigned __int16)(115200 / a2) >> 8);
  outp(*(_DWORD *)(a1 + 28), 115200 / a2);
  outp(*(_DWORD *)(a1 + 28) + 3, 3);
  sub_AC44B();
  return 115200 / (115200 / a2);
}
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);

//----- (0009BBFC) --------------------------------------------------------
int __cdecl sub_9BBFC(int a1)
{
  int v2[3]; // [esp+0h] [ebp-1Ch] BYREF
  __int16 v3; // [esp+Ch] [ebp-10h]

  if ( *(_DWORD *)(a1 + 4) )
  {
    v2[0] = 257;
    v3 = *(_WORD *)(a1 + 8);
    int386(49, v2, v2);
    sub_9B5B4(*(_DWORD *)(a1 + 4), *(int *)(*(_DWORD *)a1 + 4) >> 16);
  }
  return memset(a1, 0, 10);
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009BC68) --------------------------------------------------------
int __cdecl sub_9BC68(_WORD *a1, int a2, unsigned int a3)
{
  int v4[3]; // [esp+0h] [ebp-20h] BYREF
  int v5; // [esp+Ch] [ebp-14h]
  int v6; // [esp+18h] [ebp-8h]

  *(_DWORD *)a2 = a1;
  if ( *(_DWORD *)(a2 + 4) )
    goto LABEL_5;
  v4[0] = 256;
  v4[1] = (int)(a3 + 15) >> 4;
  int386(49, v4, v4);
  if ( !v6 )
  {
    *(_DWORD *)(a2 + 4) = 16 * LOWORD(v4[0]);
    *(_WORD *)(a2 + 8) = v5;
    a1[4] = v4[0];
    sub_9B540(*(_DWORD *)(a2 + 4), a3);
LABEL_5:
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    a1[3] = a3;
    return 1;
  }
  return 0;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009BD28) --------------------------------------------------------
int __cdecl sub_9BD28(int a1)
{
  int v2[3]; // [esp+0h] [ebp-28h] BYREF
  int v3; // [esp+Ch] [ebp-1Ch]
  int v4; // [esp+18h] [ebp-10h]
  unsigned int v6; // [esp+20h] [ebp-8h]
  unsigned int v7; // [esp+24h] [ebp-4h]

  v7 = byte_C0134 - (char *)sub_C0000;
  v2[0] = 256;
  v2[1] = (unsigned int)(byte_C0134 - (char *)sub_C0000 + 15) >> 4;
  int386(49, v2, v2);
  if ( v4 )
    return 0;
  *(_DWORD *)(a1 + 44) = 16 * LOWORD(v2[0]);
  v6 = *(_DWORD *)(a1 + 44);
  *(_WORD *)(a1 + 48) = v3;
  memcpy(v6, sub_C0000, v7);
  sub_9B540(v6, v7);
  *(_WORD *)(v6 + 2) = *(_WORD *)(a1 + 28);
  *(_WORD *)(v6 + 4) = 0;
  memset(v6 + 6, 0, 10);
  memset(v6 + 16, 0, 10);
  return 1;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 99DBD: using guessed type _DWORD __cdecl memcpy(_DWORD, _DWORD, _DWORD);
// C0000: using guessed type int __far sub_C0000();

//----- (0009BE18) --------------------------------------------------------
int __cdecl sub_9BE18(int a1, int a2, char a3, unsigned int a4, unsigned int a5)
{
  __int64 v5; // rax
  char v7; // [esp+40h] [ebp-104h]
  char v8; // [esp+F0h] [ebp-54h]
  int v9; // [esp+114h] [ebp-30h] BYREF
  int v10; // [esp+118h] [ebp-2Ch]
  int v11; // [esp+11Ch] [ebp-28h]
  int v12; // [esp+120h] [ebp-24h]
  __int64 v14; // [esp+134h] [ebp-10h]
  int v15; // [esp+13Ch] [ebp-8h]
  int v16; // [esp+140h] [ebp-4h]

  sub_9C58C(a1);
  if ( a2 && a2 != 2 )
  {
    if ( a2 == 1 || a2 == 3 )
    {
      *(_DWORD *)(a1 + 36) = 11;
      *(_DWORD *)(a1 + 40) = 8;
      *(_DWORD *)(a1 + 28) = *(unsigned __int16 *)(2 * a2 + dword_E3DF8);
    }
    else
    {
      *(_DWORD *)(a1 + 28) = 0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 36) = 12;
    *(_DWORD *)(a1 + 40) = 16;
    *(_DWORD *)(a1 + 28) = *(unsigned __int16 *)(2 * a2 + dword_E3DF8);
  }
  if ( *(_DWORD *)(a1 + 28) && !dword_E3DFC[a2] )
  {
    *(_DWORD *)(a1 + 32) = a2;
    dword_E3DFC[a2] = a1;
    if ( sub_9BD28(a1)
      && sub_9BC68((_WORD *)(*(_DWORD *)(a1 + 44) + 16), a1, a4)
      && sub_9BC68((_WORD *)(*(_DWORD *)(a1 + 44) + 6), a1 + 10, a5) )
    {
      sub_AC449();
      v15 = inp(*(_DWORD *)(a1 + 28) + 3);
      *(_DWORD *)(a1 + 66) = v15;
      v15 |= 0x80u;
      outp(*(_DWORD *)(a1 + 28) + 3, v15);
      LODWORD(v14) = inp(*(_DWORD *)(a1 + 28) + 1);
      HIDWORD(v14) = inp(*(_DWORD *)(a1 + 28));
      if ( v14 )
        *(_DWORD *)(a1 + 86) = 115200 / (((_DWORD)v14 << 8) | HIDWORD(v14));
      else
        *(_DWORD *)(a1 + 86) = 1200;
      v15 &= ~0x80u;
      outp(*(_DWORD *)(a1 + 28) + 3, v15);
      *(_DWORD *)(a1 + 70) = inp(*(_DWORD *)(a1 + 28) + 4);
      *(_DWORD *)(a1 + 74) = inp(33);
      *(_DWORD *)(a1 + 78) = inp(*(_DWORD *)(a1 + 28) + 1);
      *(_DWORD *)(a1 + 82) = inp(*(_DWORD *)(a1 + 28) + 2);
      v8 = inp(33);
      outp(33, *(_BYTE *)(a1 + 40) | v8);
      outp(*(_DWORD *)(a1 + 28) + 4, 0);
      outp(*(_DWORD *)(a1 + 28) + 1, 0);
      outp(*(_DWORD *)(a1 + 28) + 2, 0);
      v9 = 512;
      v10 = *(_DWORD *)(a1 + 36);
      int386(49, &v9, &v9);
      *(_WORD *)(a1 + 50) = v11;
      *(_WORD *)(a1 + 52) = v12;
      v5 = dos_getvect(*(_DWORD *)(a1 + 36));
      *(_WORD *)(a1 + 64) = WORD2(v5);
      *(_DWORD *)(a1 + 60) = v5;
      dos_setvect(
        *(_DWORD *)(a1 + 36),
        *(void (__noreturn **)())((char *)&off_E3E10 + 6 * a2),
        (unsigned __int16)seg_E3E14[3 * a2]);
      v9 = 513;
      v10 = *(_DWORD *)(a1 + 36);
      v11 = (unsigned __int16)(*(_DWORD *)(a1 + 44) >> 4);
      v12 = *(_DWORD *)(a1 + 44) & 0xF;
      int386(49, &v9, &v9);
      sub_9B540((unsigned int)sub_9B628, (char *)sub_9BAB0 - (char *)sub_9B628);
      if ( (a3 & 1) != 0 )
      {
        outp(*(_DWORD *)(a1 + 28) + 2, 193);
        v16 = inp(*(_DWORD *)(a1 + 28) + 2);
        if ( (v16 & 0xF8) == 192 )
        {
          *(_DWORD *)(a1 + 24) = 1;
          *(_WORD *)(*(_DWORD *)(a1 + 44) + 4) |= 8u;
          outp(*(_DWORD *)(a1 + 28) + 2, 65);
        }
        else
        {
          outp(*(_DWORD *)(a1 + 28) + 2, 0);
        }
      }
      outp(*(_DWORD *)(a1 + 28) + 1, 11);
      outp(*(_DWORD *)(a1 + 28) + 4, 11);
      v7 = inp(33);
      outp(33, ~*(_BYTE *)(a1 + 40) & v7);
      inp(*(_DWORD *)(a1 + 28) + 2);
      inp(*(_DWORD *)(a1 + 28));
      inp(*(_DWORD *)(a1 + 28) + 5);
      inp(*(_DWORD *)(a1 + 28) + 6);
      sub_AC44B();
      sub_9CD9C(a1, 1);
      sub_9CCF8(a1, 1);
      return 0;
    }
    else
    {
      sub_9C58C(a1);
      return -2;
    }
  }
  else
  {
    sub_9C58C(a1);
    return -1;
  }
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 99BA7: using guessed type __int64 __cdecl dos_getvect(_DWORD);
// 99BDB: using guessed type _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD);
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);
// E3DF8: using guessed type int dword_E3DF8;
// E3DFC: using guessed type int dword_E3DFC[];
// E3E10: using guessed type void (__noreturn *off_E3E10)();
// E3E14: using guessed type __int16 seg_E3E14[];

//----- (0009C58C) --------------------------------------------------------
int __cdecl sub_9C58C(int a1)
{
  int result; // eax
  char v2; // [esp+40h] [ebp-38h]
  int v3; // [esp+5Ch] [ebp-1Ch] BYREF
  char v4; // [esp+60h] [ebp-18h]
  int v5; // [esp+64h] [ebp-14h]
  int v6; // [esp+68h] [ebp-10h]

  result = a1;
  if ( *(_DWORD *)(a1 + 28) )
  {
    sub_AC449();
    if ( *(_DWORD *)(a1 + 60) || *(_WORD *)(a1 + 64) )
      dos_setvect(*(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 60), *(unsigned __int16 *)(a1 + 64));
    sub_9B5B4((unsigned int)sub_9B628, (char *)sub_9BAB0 - (char *)sub_9B628);
    if ( *(_DWORD *)(a1 + 44) )
    {
      v3 = 513;
      v4 = *(_BYTE *)(a1 + 36);
      v5 = *(unsigned __int16 *)(a1 + 50);
      v6 = *(unsigned __int16 *)(a1 + 52);
      int386(49, &v3, &v3);
    }
    if ( *(_WORD *)(a1 + 48) )
    {
      v3 = 257;
      LOWORD(v6) = *(_WORD *)(a1 + 48);
      int386(49, &v3, &v3);
      sub_9B5B4(*(_DWORD *)(a1 + 44), byte_C0134 - (char *)sub_C0000);
    }
    outp(*(_DWORD *)(a1 + 28) + 4, *(_DWORD *)(a1 + 70));
    if ( (*(_DWORD *)(a1 + 74) & *(_DWORD *)(a1 + 40)) != 0 )
    {
      v2 = inp(33);
      outp(33, *(_BYTE *)(a1 + 40) | v2);
    }
    outp(*(_DWORD *)(a1 + 28) + 1, *(_DWORD *)(a1 + 78));
    if ( (*(_DWORD *)(a1 + 82) & 0xF8) != 192 )
    {
      if ( *(_DWORD *)(a1 + 24) )
        outp(*(_DWORD *)(a1 + 28) + 2, 0);
    }
    sub_9BAC4(a1, *(_DWORD *)(a1 + 86));
    outp(*(_DWORD *)(a1 + 28) + 3, *(_DWORD *)(a1 + 66));
    sub_AC44B();
    sub_9BBFC(a1);
    sub_9BBFC(a1 + 10);
    dword_E3DFC[*(_DWORD *)(a1 + 32)] = 0;
    return memset(a1, 0, 90);
  }
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 99BDB: using guessed type _DWORD __cdecl dos_setvect(_DWORD, _DWORD, _DWORD);
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);
// C0000: using guessed type int __far sub_C0000();
// E3DFC: using guessed type int dword_E3DFC[];

//----- (0009C810) --------------------------------------------------------
int __cdecl sub_9C810(_DWORD *a1, char a2)
{
  __int16 v2; // dx
  _WORD *v4; // [esp+0h] [ebp-8h]

  if ( !a1[7] )
    return 1;
  v4 = (_WORD *)*a1;
  if ( *(_WORD *)(*a1 + 4) != *(_WORD *)(*a1 + 6) )
  {
    sub_AC449();
    v2 = v4[1];
    v4[1] = v2 + 1;
    *(_BYTE *)(a1[1] + v2) = a2;
    if ( v4[1] == v4[3] )
      v4[1] = 0;
    ++v4[2];
    sub_9B688((int)a1);
    sub_AC44B();
    return 1;
  }
  return 0;
}

//----- (0009C938) --------------------------------------------------------
int __cdecl sub_9C938(_DWORD *a1)
{
  __int16 v1; // dx
  _WORD *v4; // [esp+4h] [ebp-8h]
  int v5; // [esp+8h] [ebp-4h]

  if ( !a1[7] )
    return -1;
  v4 = *(_WORD **)((char *)a1 + 10);
  if ( (__int16)v4[2] <= 0 )
    return -1;
  sub_AC449();
  v1 = (*v4)++;
  v5 = *(unsigned __int8 *)(*(_DWORD *)((char *)a1 + 14) + v1);
  if ( *v4 == v4[3] )
    *v4 = 0;
  --v4[2];
  sub_AC44B();
  return v5;
}

//----- (0009C9D0) --------------------------------------------------------
bool __cdecl sub_9C9D0(int a1)
{
  return !*(_DWORD *)(a1 + 28) || *(_WORD *)(*(_DWORD *)(a1 + 10) + 4) == 0;
}

//----- (0009CBBC) --------------------------------------------------------
void __cdecl sub_9CBBC(_DWORD *a1)
{
  if ( a1[7] )
  {
    sub_AC449();
    *(_WORD *)(*a1 + 4) = 0;
    *(_WORD *)*a1 = 0;
    *(_WORD *)(*a1 + 2) = 0;
    *(_WORD *)(*(_DWORD *)((char *)a1 + 10) + 4) = 0;
    **(_WORD **)((char *)a1 + 10) = 0;
    *(_WORD *)(*(_DWORD *)((char *)a1 + 10) + 2) = 0;
    *(_WORD *)(a1[11] + 4) &= ~2u;
    inp(a1[7] + 5);
    inp(a1[7] + 6);
    inp(a1[7] + 2);
    inp(a1[7]);
    sub_AC44B();
  }
}
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);

//----- (0009CCB4) --------------------------------------------------------
int __cdecl sub_9CCB4(int a1, int a2)
{
  int result; // eax

  if ( a2 )
  {
    *(_DWORD *)(a1 + 20) = 1;
    result = *(_DWORD *)(a1 + 44);
    *(_WORD *)(result + 4) |= 1u;
  }
  else
  {
    *(_DWORD *)(a1 + 20) = 0;
    result = *(_DWORD *)(a1 + 44);
    *(_WORD *)(result + 4) &= ~1u;
  }
  return result;
}

//----- (0009CCF8) --------------------------------------------------------
int __cdecl sub_9CCF8(int a1, int a2)
{
  int result; // eax
  char v3; // al
  char v4; // al
  int v5; // [esp+0h] [ebp-20h]
  int v6; // [esp+10h] [ebp-10h]

  result = a1;
  if ( *(_DWORD *)(a1 + 28) )
  {
    if ( a2 )
    {
      v6 = *(_DWORD *)(a1 + 28) + 4;
      v3 = sub_9B63C(v6) | 1;
      return outp(v6, v3);
    }
    else
    {
      v5 = *(_DWORD *)(a1 + 28) + 4;
      v4 = sub_9B63C(v5) & 0xFE;
      return outp(v5, v4);
    }
  }
  return result;
}
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);

//----- (0009CD9C) --------------------------------------------------------
int __cdecl sub_9CD9C(int a1, int a2)
{
  int result; // eax
  char v3; // al
  char v4; // al
  int v5; // [esp+0h] [ebp-20h]
  int v6; // [esp+10h] [ebp-10h]

  result = a1;
  if ( *(_DWORD *)(a1 + 28) )
  {
    if ( a2 )
    {
      v6 = *(_DWORD *)(a1 + 28) + 4;
      v3 = sub_9B63C(v6) | 2;
      return outp(v6, v3);
    }
    else
    {
      v5 = *(_DWORD *)(a1 + 28) + 4;
      v4 = sub_9B63C(v5) & 0xFD;
      return outp(v5, v4);
    }
  }
  return result;
}
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);

//----- (0009D31C) --------------------------------------------------------
__int16 __fastcall sub_9D31C(__int16 result)
{
  _BOOL1 v1; // zf

  __asm { int     16h; KEYBOARD - GET ENHANCED SHIFT FLAGS (AT model 339,XT2,XT286,PS) }
  byte_1806E5 = (result & 3) != 0;
  if ( (result & 4) != 0 )
    byte_1806E5 |= 2u;
  v1 = (result & 8) == 0;
  if ( (result & 8) != 0 )
  {
    v1 = 0;
    byte_1806E5 |= 4u;
  }
  byte_1806E4 = 0;
  __asm { int     16h; KEYBOARD - CHECK ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS) }
  if ( !v1 )
  {
    __asm { int     16h; KEYBOARD - GET ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS) }
    byte_1806E4 = 16;
  }
  return result;
}
// 1806E4: using guessed type char byte_1806E4;
// 1806E5: using guessed type char byte_1806E5;

//----- (0009D380) --------------------------------------------------------
int __cdecl sub_9D380(int a1, int a2, char a3, int a4, int a5)
{
  if ( (a3 & 1) != 0 )
  {
    memcpy(a4, a2 + a1, a5);
  }
  else
  {
    lseek(a1, a2, 0);
    read(a1, a4, a5);
  }
  return a5 + a2;
}
// 99DBD: using guessed type _DWORD __cdecl memcpy(_DWORD, _DWORD, _DWORD);
// A0863: using guessed type _DWORD __cdecl read(_DWORD, _DWORD, _DWORD);
// AA7C0: using guessed type _DWORD __cdecl lseek(_DWORD, _DWORD, char);

//----- (0009D3F0) --------------------------------------------------------
int (__cdecl *__cdecl sub_9D3F0(int (__cdecl *a1)(int)))(int)
{
  int (__cdecl *v2)(int); // [esp+4h] [ebp-4h]

  v2 = off_E3E30[0];
  off_E3E30[0] = a1;
  return v2;
}
// E3E30: using guessed type int (__cdecl *off_E3E30[2])(int);

//----- (0009D420) --------------------------------------------------------
int (__cdecl *__cdecl sub_9D420(int (__cdecl *a1)(int)))(int)
{
  int (__cdecl *v2)(int); // [esp+4h] [ebp-4h]

  v2 = off_E3E34;
  off_E3E34 = a1;
  return v2;
}
// E3E34: using guessed type int (__cdecl *off_E3E34)(int);

//----- (0009D450) --------------------------------------------------------
unsigned int __cdecl sub_9D450(int a1)
{
  unsigned int v2; // [esp+4h] [ebp-4h]

  v2 = off_E3E30(a1);
  if ( v2 )
    sub_9D710(v2, a1);
  return v2;
}
// E3E30: invalid function type has been ignored
// E3E30: using guessed type int (__cdecl *off_E3E30)(_DWORD);

//----- (0009D490) --------------------------------------------------------
int __cdecl sub_9D490(unsigned int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    sub_9D740(a1, a2);
    return off_E3E34(a1);
  }
  return result;
}
// E3E34: using guessed type int (__cdecl *off_E3E34)(int);

//----- (0009D4D0) --------------------------------------------------------
int __cdecl sub_9D4D0(int a1, unsigned int *a2, _DWORD *a3, _DWORD *a4)
{
  unsigned int v6; // [esp+Ch] [ebp-4h]

  v6 = sub_83D70(16 * a1);
  if ( !v6 )
    return 0;
  *a3 = v6 >> 4 << 16;
  *a2 = v6;
  *a4 = 1232;
  sub_9D590(*a3 >> 12, (*a3 >> 12) + 16 * a1 - 1);
  return 1;
}

//----- (0009D560) --------------------------------------------------------
void __cdecl sub_9D560(int a1)
{
  sub_83E80(a1);
}

//----- (0009D590) --------------------------------------------------------
bool __cdecl sub_9D590(unsigned int a1, unsigned int a2)
{
  unsigned int v3; // [esp+0h] [ebp-54h]
  unsigned int v4; // [esp+4h] [ebp-50h]
  int v5[7]; // [esp+Ch] [ebp-48h] BYREF
  char v6[24]; // [esp+28h] [ebp-2Ch] BYREF
  int v7; // [esp+40h] [ebp-14h]
  unsigned int v8; // [esp+48h] [ebp-Ch]
  unsigned int v9; // [esp+4Ch] [ebp-8h]
  int v10; // [esp+50h] [ebp-4h]

  v10 = 0;
  if ( a1 >= a2 )
    v3 = a2;
  else
    v3 = a1;
  v9 = v3;
  if ( a1 < a2 )
    v4 = a2;
  else
    v4 = a1;
  v8 = v4 - v9 + 1;
  v5[0] = 1536;
  v5[1] = HIWORD(v9);
  v5[2] = (unsigned __int16)v9;
  v5[4] = HIWORD(v8);
  v5[5] = (unsigned __int16)(v4 - v9 + 1);
  int386(49, v5, v6);
  return v7 == 0;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 9D590: using guessed type char var_2C[24];

//----- (0009D650) --------------------------------------------------------
bool __cdecl sub_9D650(unsigned int a1, unsigned int a2)
{
  unsigned int v3; // [esp+0h] [ebp-54h]
  unsigned int v4; // [esp+4h] [ebp-50h]
  int v5[7]; // [esp+Ch] [ebp-48h] BYREF
  char v6[24]; // [esp+28h] [ebp-2Ch] BYREF
  int v7; // [esp+40h] [ebp-14h]
  unsigned int v8; // [esp+48h] [ebp-Ch]
  unsigned int v9; // [esp+4Ch] [ebp-8h]
  int v10; // [esp+50h] [ebp-4h]

  v10 = 0;
  if ( a1 >= a2 )
    v3 = a2;
  else
    v3 = a1;
  v9 = v3;
  if ( a1 < a2 )
    v4 = a2;
  else
    v4 = a1;
  v8 = v4 - v9 + 1;
  v5[0] = 1537;
  v5[1] = HIWORD(v9);
  v5[2] = (unsigned __int16)v9;
  v5[4] = HIWORD(v8);
  v5[5] = (unsigned __int16)(v4 - v9 + 1);
  int386(49, v5, v6);
  return v7 == 0;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);
// 9D650: using guessed type char var_2C[24];

//----- (0009D710) --------------------------------------------------------
bool __cdecl sub_9D710(unsigned int a1, int a2)
{
  return sub_9D590(a1, a2 + a1);
}

//----- (0009D740) --------------------------------------------------------
bool __cdecl sub_9D740(unsigned int a1, int a2)
{
  return sub_9D650(a1, a2 + a1);
}

//----- (0009D770) --------------------------------------------------------
int __cdecl sub_9D770(int a1, char a2)
{
  char v3[64]; // [esp+0h] [ebp-E0h] BYREF
  int v4; // [esp+40h] [ebp-A0h]
  unsigned int v5; // [esp+44h] [ebp-9Ch]
  int v6[6]; // [esp+ACh] [ebp-34h] BYREF
  int v7; // [esp+C4h] [ebp-1Ch]
  int v8; // [esp+C8h] [ebp-18h] BYREF
  unsigned int i; // [esp+CCh] [ebp-14h]
  int v10; // [esp+D0h] [ebp-10h]
  int v12; // [esp+D8h] [ebp-8h]
  int v13; // [esp+DCh] [ebp-4h] BYREF

  v13 = 8224;
  v7 = 0;
  if ( (a2 & 1) != 0 )
  {
    v10 = a1;
  }
  else
  {
    v10 = open(a1, 512);
    if ( v10 == -1 )
      return 0;
  }
  v12 = sub_9D380(v10, 60, a2, (int)&v8, 4);
  v12 = sub_9D380(v10, v8, a2, (int)&v13, 2);
  if ( !strcmp(&v13, aLx) )
  {
    sub_9D380(v10, v8, a2, (int)v3, 172);
    v12 = v4 + v8;
    for ( i = 0; i < v5; ++i )
    {
      v12 = sub_9D380(v10, v12, a2, (int)v6, 24);
      v7 += v6[0];
    }
    if ( (a2 & 1) == 0 )
      close(v10);
    v7 += 15 * v5;
    return v7;
  }
  else
  {
    close(v10);
    return 0;
  }
}
// 9A050: using guessed type _DWORD __cdecl strcmp(_DWORD, _DWORD);
// A0855: using guessed type _DWORD __cdecl close(_DWORD);
// 9D770: using guessed type char var_E0[64];
// 9D770: using guessed type int var_34[6];

//----- (0009DE20) --------------------------------------------------------
int __cdecl sub_9DE20(int a1)
{
  int v3; // [esp+4h] [ebp-8h]
  int v4; // [esp+8h] [ebp-4h]

  dword_E3E2C = 0;
  v4 = open(a1, 512);
  if ( v4 == -1 )
  {
    dword_E3E2C = 3;
    return -1;
  }
  else
  {
    v3 = filelength(v4);
    if ( v3 == -1 )
      dword_E3E2C = 5;
    close(v4);
    return v3;
  }
}
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// A0855: using guessed type _DWORD __cdecl close(_DWORD);
// E3E2C: using guessed type int dword_E3E2C;

//----- (0009DEA0) --------------------------------------------------------
int __cdecl sub_9DEA0(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-1Ch]
  int v5; // [esp+10h] [ebp-Ch]
  int v6; // [esp+14h] [ebp-8h]

  dword_E3E2C = 0;
  v5 = sub_9DE20(a1);
  if ( v5 == -1 )
  {
    dword_E3E2C = 3;
    return 0;
  }
  else
  {
    if ( a2 )
      v3 = a2;
    else
      v3 = off_E3E30(v5);
    if ( v3 )
    {
      v6 = open(a1, 512);
      if ( v6 == -1 )
      {
        off_E3E34(v3);
        dword_E3E2C = 3;
        return 0;
      }
      else if ( read(v6, v3, v5) == v5 )
      {
        close(v6);
        return v3;
      }
      else
      {
        off_E3E34(v3);
        dword_E3E2C = 5;
        return 0;
      }
    }
    else
    {
      dword_E3E2C = 2;
      return 0;
    }
  }
}
// A0855: using guessed type _DWORD __cdecl close(_DWORD);
// A0863: using guessed type _DWORD __cdecl read(_DWORD, _DWORD, _DWORD);
// E3E2C: using guessed type int dword_E3E2C;
// E3E30: using guessed type int (__cdecl *off_E3E30)(_DWORD);
// E3E34: using guessed type int (__cdecl *off_E3E34)(int);

//----- (0009E1B0) --------------------------------------------------------
bool sub_9E1B0()
{
  bool result; // eax

  if ( !dword_E3E3C )
  {
    sub_9D590((unsigned int)sub_9E1B0, (unsigned int)sub_9EDD0);
    sub_9D710((unsigned int)dword_181C50, 64);
    sub_9D710((unsigned int)dword_181DAC, 76);
    sub_9D710((unsigned int)&byte_181C90, 256);
    sub_9D710((unsigned int)&unk_181D90, 24);
    sub_9D710((unsigned int)&dword_E3E38, 4);
    result = sub_9D710((unsigned int)&dword_181DA8, 4);
    dword_E3E3C = 1;
  }
  return result;
}
// E3E38: using guessed type int dword_E3E38;
// E3E3C: using guessed type int dword_E3E3C;
// 181C50: using guessed type int dword_181C50[16];
// 181C90: using guessed type char byte_181C90;
// 181DA8: using guessed type int dword_181DA8;
// 181DAC: using guessed type int dword_181DAC[];

//----- (0009E2B0) --------------------------------------------------------
int __cdecl sub_9E2B0(int a1, int a2, _DWORD *a3)
{
  int v3; // ebx
  int v5; // [esp+4h] [ebp-10h]
  int v6; // [esp+8h] [ebp-Ch]
  int j; // [esp+Ch] [ebp-8h]
  unsigned int i; // [esp+10h] [ebp-4h]

  v6 = 0;
  v5 = 1;
  for ( i = 0; strlen(a1) > i; ++i )
  {
    if ( *(_BYTE *)(i + a1) == 45 )
    {
      v5 = -v5;
    }
    else if ( (IsTable[(unsigned __int8)(*(_BYTE *)(i + a1) + 1)] & 2) == 0 )
    {
      for ( j = 0; j < a2; ++j )
      {
        v3 = (unsigned __int8)byte_D3450[j];
        if ( toupper(*(unsigned __int8 *)(i + a1)) == v3 )
        {
          v6 = a2 * v6 + j;
          break;
        }
      }
      if ( j == a2 )
        break;
    }
  }
  if ( a3 )
    *a3 = i + a1;
  return v5 * v6;
}
// 98805: using guessed type _DWORD __cdecl toupper(_DWORD);
// 99D6B: using guessed type _DWORD __cdecl strlen(_DWORD);

//----- (0009E3A0) --------------------------------------------------------
int __cdecl sub_9E3A0(__int16 *a1, int a2)
{
  __int16 v3[140]; // [esp+0h] [ebp-180h] BYREF
  char v4[80]; // [esp+118h] [ebp-68h] BYREF
  char *v5; // [esp+168h] [ebp-18h]
  char *v6; // [esp+16Ch] [ebp-14h]
  char *v7; // [esp+170h] [ebp-10h]
  unsigned int i; // [esp+174h] [ebp-Ch]
  int v10; // [esp+17Ch] [ebp-4h]

  memset(v3, 0, sizeof(v3));
  memset(&v3[128], -1, 24);
  v10 = fopen(a2, &aRt[1]);
  if ( !v10 )
    return 0;
  while ( fgets(v4, 80, v10) && (*(_BYTE *)(v10 + 12) & 0x10) == 0 )
  {
    for ( i = strlen(v4) - 1; (i & 0x80000000) == 0 && (IsTable[(unsigned __int8)(v4[i] + 1)] & 2) != 0; --i )
      v4[i] = 0;
    for ( i = 0; strlen(v4) > i && (IsTable[(unsigned __int8)(v4[i] + 1)] & 2) != 0; ++i )
      ;
    v6 = &v4[i];
    while ( strlen(v4) > i && (IsTable[(unsigned __int8)(v4[i] + 1)] & 2) == 0 )
      ++i;
    v5 = &v4[i];
    while ( strlen(v4) > i && (IsTable[(unsigned __int8)(v4[i] + 1)] & 2) != 0 )
      ++i;
    v7 = &v4[i];
    if ( strlen(v4) > i )
    {
      *v5 = 0;
      if ( *v6 != 59 )
      {
        if ( !strnicmp(v6, aDriver, 7) )
        {
          strcpy(&v3[64], v7);
        }
        else if ( !strnicmp(v6, aDevice, 7) )
        {
          strcpy(v3, v7);
        }
        else if ( !strnicmp(v6, aIoAddr, 8) )
        {
          v3[128] = sub_9E2B0((int)v7, 16, 0);
        }
        else if ( !strnicmp(v6, aIrq, 4) )
        {
          v3[129] = sub_9E2B0((int)v7, 10, 0);
        }
        else if ( !strnicmp(v6, aDma8Bit, 10) )
        {
          v3[130] = sub_9E2B0((int)v7, 10, 0);
        }
        else if ( !strnicmp(v6, aDma16Bit, 11) )
        {
          v3[131] = sub_9E2B0((int)v7, 10, 0);
        }
      }
    }
  }
  fclose(v10);
  if ( strlen(&v3[64]) && strlen(v3) )
  {
    qmemcpy(a1, v3, 0x118u);
    return 1;
  }
  else
  {
    strcpy(&byte_181C90, "Corrupted .INI file\n");
    return 0;
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99B23: using guessed type _DWORD __cdecl strnicmp(_DWORD, _DWORD, _DWORD);
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// 99D6B: using guessed type _DWORD __cdecl strlen(_DWORD);
// A1AF0: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// A1E05: using guessed type _DWORD __cdecl fclose(_DWORD);
// AD7AA: using guessed type _DWORD __cdecl fgets(_DWORD, _DWORD, _DWORD);
// 181C90: using guessed type char byte_181C90;
// 9E3A0: using guessed type char var_68[80];

//----- (0009E6E0) --------------------------------------------------------
int __cdecl sub_9E6E0(int a1, int a2)
{
  int v3; // [esp+4h] [ebp-4h]

  v3 = dword_181DAC[a1];
  dword_181DAC[a1] = a2;
  return v3;
}
// 181DAC: using guessed type int dword_181DAC[];

//----- (0009E720) --------------------------------------------------------
_DWORD *__usercall sub_9E720@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4)
{
  int v4; // edx
  unsigned int i; // [esp+4h] [ebp-8h]
  _DWORD *v8; // [esp+8h] [ebp-4h]

  v8 = (_DWORD *)sub_9D450(44);
  if ( v8 )
  {
    v8[3] = a4;
    if ( sub_9D4D0((unsigned int)(a4 + 15) >> 4, v8 + 2, v8, v8 + 1) )
    {
      memmove(v8[2], a3, a4);
      v4 = v8[2];
      v8[4] = v4;
      if ( !strnicmp(v8[4], aAil3dig, 7) )
      {
        v8[5] = 0;
      }
      else
      {
        if ( strnicmp(v8[4], aAil3mdi, 7) )
        {
          strcpy(&byte_181C90, "Invalid driver type\n");
          sub_9D560(v8[2]);
          sub_9D490((unsigned int)v8, 44);
          return 0;
        }
        v8[5] = 1;
      }
      for ( i = 0; i < 0x10; ++i )
      {
        if ( !dword_181C50[i] )
        {
          dword_181C50[i] = (int)v8;
          v4 = v8[4];
          *(_WORD *)(v4 + 50) = i;
          break;
        }
      }
      if ( i != 16 )
      {
        *(_WORD *)(v8[4] + 48) = 0;
        v8[6] = 0;
        v8[7] = -1;
        *(_DWORD *)(v8[4] + 54) = sub_91C10(v4, a1, a2, 102);
        sub_91D50(102, *v8 + *(unsigned __int16 *)(v8[4] + 52));
        v8[9] = 0;
        v8[10] = 0;
        sub_91F70((int)v8, 768, 0, 0);
        if ( *(__int16 *)(v8[4] + 46) > 0 )
        {
          v8[8] = sub_92600((int)sub_9E250);
          if ( v8[8] == -1 )
          {
            strcpy(&byte_181C90, "Out of timer handles\n");
            sub_91D50(102, *(_DWORD *)(v8[4] + 54));
            sub_9D560(v8[2]);
            sub_9D490((unsigned int)v8, 44);
            return 0;
          }
          sub_92740(v8[8], (__int32)v8);
          sub_92930(v8[8], *(__int16 *)(v8[4] + 46));
          sub_92BA0(v8[8]);
        }
        else
        {
          v8[8] = -1;
        }
        return v8;
      }
      strcpy(&byte_181C90, "Out of driver handles\n");
      sub_9D560(v8[2]);
      sub_9D490((unsigned int)v8, 44);
      return 0;
    }
    else
    {
      strcpy(&byte_181C90, "Insufficient low memory\n");
      sub_9D490((unsigned int)v8, 44);
      return 0;
    }
  }
  else
  {
    strcpy(&byte_181C90, "Insufficient memory for driver descriptor\n");
    return 0;
  }
}
// 99B23: using guessed type _DWORD __cdecl strnicmp(_DWORD, _DWORD, _DWORD);
// 9E250: using guessed type int sub_9E250();
// AD81F: using guessed type _DWORD __cdecl memmove(_DWORD, _DWORD, _DWORD);
// 181C50: using guessed type int dword_181C50[16];
// 181C90: using guessed type char byte_181C90;

//----- (0009EA60) --------------------------------------------------------
int __cdecl sub_9EA60(unsigned int a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 36) )
    (*(void (__cdecl **)(_DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40));
  if ( *(_DWORD *)(a1 + 32) != -1 )
    sub_92DC0(*(_DWORD *)(a1 + 32));
  if ( *(_DWORD *)(a1 + 24) )
  {
    if ( *(_DWORD *)(a1 + 28) != -1 )
      sub_91E90(*(_DWORD *)(a1 + 28));
    sub_91F70(a1, 774, 0, 0);
  }
  sub_91D50(102, *(_DWORD *)(*(_DWORD *)(a1 + 16) + 54));
  sub_9D560(*(_DWORD *)(a1 + 8));
  result = sub_9D490(a1, 44);
  for ( i = 0; i < 16; ++i )
  {
    if ( dword_181C50[i] == a1 )
      dword_181C50[i] = 0;
    result = i;
  }
  return result;
}
// 181C50: using guessed type int dword_181C50[16];

//----- (0009EB60) --------------------------------------------------------
void *__cdecl sub_9EB60(int a1)
{
  int v3; // [esp+4h] [ebp-8h]
  int v4; // [esp+8h] [ebp-4h]

  v4 = (unsigned __int16)*(_DWORD *)(*(_DWORD *)(a1 + 16) + 18) + 16 * HIWORD(*(_DWORD *)(*(_DWORD *)(a1 + 16) + 18));
  if ( !v4 )
    return 0;
  v3 = getenv(v4);
  if ( !v3 )
    return 0;
  strncpy(*(_DWORD *)(a1 + 16) + 58, v3, 128);
  if ( sub_91F70(a1, 771, 0, 0) == -1 )
    return 0;
  qmemcpy(&unk_181DF8, (const void *)(*(_DWORD *)(a1 + 16) + 22), 0x18u);
  return &unk_181DF8;
}
// 99E33: using guessed type _DWORD __cdecl getenv(_DWORD);
// AD871: using guessed type _DWORD __cdecl strncpy(_DWORD, _DWORD, _DWORD);

//----- (0009EC30) --------------------------------------------------------
void __fastcall sub_9EC30(int a1, unsigned __int16 a2)
{
  int v2; // eax
  int i; // [esp+0h] [ebp-4h]

  sub_9E1B0();
  sub_91A80(0, 200);
  sub_91A80(1, 1);
  sub_91A80(2, 0x8000);
  sub_91A80(3, 100);
  sub_91A80(4, 16);
  sub_91A80(5, 100);
  sub_91A80(6, 655);
  sub_91A80(7, 0);
  sub_91A80(8, 0);
  sub_91A80(9, 1);
  sub_91A80(10, 0);
  sub_91A80(11, 120);
  sub_91A80(12, 8);
  sub_91A80(13, 127);
  sub_91A80(14, 1);
  sub_91A80(15, 0);
  sub_91A80(16, 2);
  sub_91A80(17, 1);
  v2 = sub_91A80(18, 1);
  for ( i = 0; i < 16; ++i )
  {
    dword_181C50[i] = 0;
    v2 = i;
  }
  byte_181C90 = 0;
  sub_A10F4(v2, a2);
}
// 181C50: using guessed type int dword_181C50[16];
// 181C90: using guessed type char byte_181C90;

//----- (0009ED70) --------------------------------------------------------
int sub_9ED70()
{
  int i; // [esp+0h] [ebp-8h]
  unsigned int v2; // [esp+4h] [ebp-4h]

  for ( i = 15; i >= 0; --i )
  {
    v2 = dword_181C50[i];
    if ( v2 )
      sub_93160(v2);
  }
  sub_92E50();
  return sub_A11E2();
}
// 181C50: using guessed type int dword_181C50[16];

//----- (0009EDD0) --------------------------------------------------------
bool sub_9EDD0()
{
  bool result; // eax

  if ( dword_E3E3C )
  {
    sub_9D650((unsigned int)sub_9E1B0, (unsigned int)sub_9EDD0);
    sub_9D740((unsigned int)dword_181C50, 64);
    sub_9D740((unsigned int)dword_181DAC, 76);
    sub_9D740((unsigned int)&byte_181C90, 256);
    sub_9D740((unsigned int)&unk_181D90, 24);
    sub_9D740((unsigned int)&dword_E3E38, 4);
    result = sub_9D740((unsigned int)&dword_181DA8, 4);
    dword_E3E3C = 0;
  }
  return result;
}
// 9E1B0: using guessed type int sub_9E1B0();
// E3E38: using guessed type int dword_E3E38;
// E3E3C: using guessed type int dword_E3E3C;
// 181C50: using guessed type int dword_181C50[16];
// 181C90: using guessed type char byte_181C90;
// 181DA8: using guessed type int dword_181DA8;
// 181DAC: using guessed type int dword_181DAC[];

//----- (0009EE70) --------------------------------------------------------
int sub_9EE70()
{
  int v0; // eax

  if ( !byte_E3E45 && sub_95480(dword_181E10, dword_E3E40) && (unsigned int)dword_E3E40 < 8 )
  {
    sub_93830((int *)dword_181E10);
    sub_95140(dword_181E10, (int)sub_9EE70);
    v0 = sub_95480(dword_181E10, dword_E3E40);
    sub_938C0((int *)dword_181E10, *(_DWORD *)(dword_E37A0 + 32 * v0 + 18), 1);
    ++dword_E3E40;
    sub_93B50((int *)dword_181E10);
  }
  return 0;
}
// E37A0: using guessed type int dword_E37A0;
// E3E40: using guessed type int dword_E3E40;
// E3E45: using guessed type char byte_E3E45;
// 181E10: using guessed type int dword_181E10;

//----- (0009F040) --------------------------------------------------------
int sub_9F040()
{
  int result; // eax

  if ( byte_E3E44 )
  {
    byte_E3E45 = 1;
    sub_93D00(dword_181E10);
    sub_953E0(dword_181E10, 0, 0);
    sub_953E0(dword_181E10, 1, 0);
    sub_953E0(dword_181E10, 2, 0);
    sub_953E0(dword_181E10, 3, 0);
    sub_953E0(dword_181E10, 4, 0);
    sub_953E0(dword_181E10, 5, 0);
    sub_953E0(dword_181E10, 6, 0);
    return sub_953E0(dword_181E10, 7, 0);
  }
  return result;
}
// E3E44: using guessed type char byte_E3E44;
// E3E45: using guessed type char byte_E3E45;
// 181E10: using guessed type int dword_181E10;

//----- (0009F110) --------------------------------------------------------
unsigned __int64 __cdecl sub_9F110(int a1)
{
  int v2[3]; // [esp+0h] [ebp-24h] BYREF
  int v3; // [esp+Ch] [ebp-18h]
  int v4; // [esp+18h] [ebp-Ch]
  unsigned int v5; // [esp+20h] [ebp-4h]

  v2[0] = 256;
  v2[1] = (a1 + 15) >> 4;
  int386(49, v2, v2);
  if ( v4 )
    LOWORD(v5) = 0;
  else
    LOWORD(v5) = v3;
  return __PAIR64__(v5, 0);
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009F170) --------------------------------------------------------
int __cdecl sub_9F170(int a1, unsigned __int16 a2)
{
  int v3[7]; // [esp+0h] [ebp-20h] BYREF

  v3[0] = 257;
  v3[3] = a2;
  int386(49, v3, v3);
  if ( v3[6] )
    return -1;
  else
    return 0;
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009F1D0) --------------------------------------------------------
int __cdecl sub_9F1D0(int a1)
{
  int v2[7]; // [esp+0h] [ebp-20h] BYREF

  v2[0] = 2;
  v2[1] = a1;
  int386(49, v2, v2);
  if ( v2[6] )
    return -1;
  else
    return LOWORD(v2[0]);
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009F220) --------------------------------------------------------
int __cdecl sub_9F220(int a1)
{
  int v2[2]; // [esp+0h] [ebp-20h] BYREF
  unsigned __int16 v3; // [esp+8h] [ebp-18h]
  unsigned __int16 v4; // [esp+Ch] [ebp-14h]
  int v5; // [esp+18h] [ebp-8h]

  v2[0] = 6;
  v2[1] = a1;
  int386(49, v2, v2);
  if ( v5 )
    return -1;
  else
    return ((int)v4 >> 4) + (v3 << 12);
}
// 98D52: using guessed type _DWORD __cdecl int386(_DWORD, _DWORD, _DWORD);

//----- (0009F280) --------------------------------------------------------
int __cdecl sub_9F280(int *a1)
{
  __int16 v2[4]; // [esp+0h] [ebp-10h] BYREF
  __int16 v3; // [esp+8h] [ebp-8h]

  v2[2] = 16;
  sub_91F70(*a1, 1286, v2, v2);
  if ( v2[0] )
    return -1;
  else
    return v2[3] << (v3 + 16);
}

//----- (0009F2E0) --------------------------------------------------------
int __cdecl sub_9F2E0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  unsigned __int64 v4; // rax
  __int16 v6[6]; // [esp+0h] [ebp-10h] BYREF

  if ( !*(_DWORD *)byte_E3E54 && !*(_WORD *)&byte_E3E54[4] )
  {
    v4 = sub_9F110(4);
    *(_WORD *)&byte_E3E54[4] = WORD2(v4);
    *(_DWORD *)byte_E3E54 = v4;
    if ( !(_DWORD)v4 && !*(_WORD *)&byte_E3E54[4] )
      return -1;
  }
  __writegsword(*(unsigned int *)byte_E3E54, a4);
  __writegsword(*(_DWORD *)byte_E3E54 + 2, sub_9F220(a3));
  v6[2] = 17;
  v6[3] = sub_9F220(*(unsigned __int16 *)&byte_E3E54[4]);
  v6[4] = 0;
  sub_91F70(*a1, 1286, v6, v6);
  return v6[0];
}

//----- (0009F3D0) --------------------------------------------------------
__int64 __cdecl sub_9F3D0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  unsigned __int64 v4; // rax
  int v5; // ebx
  __int16 v7[3]; // [esp+0h] [ebp-14h] BYREF
  __int16 v8; // [esp+6h] [ebp-Eh]
  __int16 v9; // [esp+8h] [ebp-Ch]
  __int64 v10; // [esp+Ch] [ebp-8h]

  if ( *(_DWORD *)byte_E3E54
    || *(_WORD *)&byte_E3E54[4]
    || (v4 = sub_9F110(4), *(_WORD *)&byte_E3E54[4] = WORD2(v4), (*(_DWORD *)byte_E3E54 = v4) != 0)
    || *(_WORD *)&byte_E3E54[4] )
  {
    __writegsword(*(unsigned int *)byte_E3E54, a4);
    __writegsword(*(_DWORD *)byte_E3E54 + 2, sub_9F220(a3));
    v7[2] = 23;
    v8 = sub_9F220(*(unsigned __int16 *)&byte_E3E54[4]);
    v9 = 0;
    sub_91F70(*a1, 1286, v7, v7);
    if ( v7[0] )
    {
      WORD2(v10) = 0;
      LODWORD(v10) = 0;
    }
    else
    {
      v5 = v9;
      WORD2(v10) = sub_9F1D0(v8);
      LODWORD(v10) = v5;
    }
  }
  else
  {
    WORD2(v10) = 0;
    LODWORD(v10) = 0;
  }
  return v10;
}

//----- (0009F4F0) --------------------------------------------------------
int __cdecl sub_9F4F0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  unsigned __int64 v4; // rax
  __int16 v6[6]; // [esp+0h] [ebp-10h] BYREF

  if ( !*(_DWORD *)byte_E3E54 && !*(_WORD *)&byte_E3E54[4] )
  {
    v4 = sub_9F110(4);
    *(_WORD *)&byte_E3E54[4] = WORD2(v4);
    *(_DWORD *)byte_E3E54 = v4;
    if ( !(_DWORD)v4 && !*(_WORD *)&byte_E3E54[4] )
      return -1;
  }
  __writegsword(*(unsigned int *)byte_E3E54, a4);
  __writegsword(*(_DWORD *)byte_E3E54 + 2, sub_9F220(a3));
  v6[2] = 24;
  v6[3] = sub_9F220(*(unsigned __int16 *)&byte_E3E54[4]);
  v6[4] = 0;
  sub_91F70(*a1, 1286, v6, v6);
  return v6[0];
}

//----- (0009F5E0) --------------------------------------------------------
int __cdecl sub_9F5E0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  unsigned __int64 v4; // rax
  __int16 v6[6]; // [esp+0h] [ebp-10h] BYREF

  if ( !*(_DWORD *)byte_E3E54 && !*(_WORD *)&byte_E3E54[4] )
  {
    v4 = sub_9F110(4);
    *(_WORD *)&byte_E3E54[4] = WORD2(v4);
    *(_DWORD *)byte_E3E54 = v4;
    if ( !(_DWORD)v4 && !*(_WORD *)&byte_E3E54[4] )
      return -1;
  }
  __writegsword(*(unsigned int *)byte_E3E54, a4);
  __writegsword(*(_DWORD *)byte_E3E54 + 2, sub_9F220(a3));
  v6[2] = 25;
  v6[3] = sub_9F220(*(unsigned __int16 *)&byte_E3E54[4]);
  v6[4] = 0;
  sub_91F70(*a1, 1286, v6, v6);
  return v6[0];
}

//----- (0009F6D0) --------------------------------------------------------
int __cdecl sub_9F6D0(int *a1, __int16 a2)
{
  __int16 v3[6]; // [esp+0h] [ebp-10h] BYREF

  sub_9F170(*(int *)byte_E3E54, *(unsigned __int16 *)&byte_E3E54[4]);
  *(_WORD *)&byte_E3E54[4] = 0;
  *(_DWORD *)byte_E3E54 = 0;
  v3[2] = 18;
  v3[3] = a2;
  sub_91F70(*a1, 1286, v3, v3);
  return v3[0];
}

//----- (0009F740) --------------------------------------------------------
void __cdecl sub_9F740(int a1)
{
  unsigned __int64 v1; // rax
  __int64 v2; // rax
  unsigned __int64 v3; // rax
  char v4[20]; // [esp+0h] [ebp-34h] BYREF
  int v5[2]; // [esp+14h] [ebp-20h]
  unsigned int v6[2]; // [esp+1Ch] [ebp-18h]
  unsigned int v7; // [esp+24h] [ebp-10h]
  char v8[4]; // [esp+28h] [ebp-Ch] BYREF
  int v9; // [esp+2Ch] [ebp-8h]
  int i; // [esp+30h] [ebp-4h]

  if ( byte_E37FC && !stricmp(&unk_180BE0, aSbawe32Mdi_1) && !stricmp(&byte_180C84, aW) )
  {
    if ( byte_E3815 == 1 )
    {
      sub_9FA80();
      byte_E3815 = 0;
    }
    strcpy(aBullfrog, a1);
    sprintf(v4, "sound//%s.sbk", aBullfrog);
    dword_181E20 = sub_98817((int)v4, 512);
    if ( dword_181E20 != -1 )
    {
      v7 = filelength(dword_181E20);
      v1 = sub_9F110(512);
      word_181E30 = WORD2(v1);
      dword_181E2C = v1;
      if ( (_DWORD)v1 || word_181E30 )
      {
        v9 = sub_9F280((int *)dword_180C7C);
        if ( v9 != -1 )
        {
          LOWORD(v5[1]) = word_181E30;
          v5[0] = dword_181E2C;
          __writegsdword(dword_181E2C, 0);
          __writegsdword(v5[0] + 4, v7);
          if ( !sub_9F2E0((int *)dword_180C7C, v5[0], v5[1], 2u)
            && !dos_read(dword_181E20, dword_181E2C, (unsigned __int16)word_181E30, 512, v8) )
          {
            v2 = sub_9F3D0((int *)dword_180C7C, dword_181E2C, word_181E30, 1u);
            LOWORD(v6[1]) = WORD2(v2);
            v6[0] = v2;
            if ( (_DWORD)v2 || LOWORD(v6[1]) )
            {
              lseek(dword_181E20, __readgsdword(v6[0] + 2), 0);
              for ( i = 0; (__int16)__readgsword(v6[0]) > i; ++i )
              {
                if ( dos_read(dword_181E20, dword_181E2C, (unsigned __int16)word_181E30, 512, v8)
                  || sub_9F4F0((int *)dword_180C7C, dword_181E2C, word_181E30, 1u) )
                {
                  return;
                }
              }
              v3 = sub_9F110(__readgsdword(v6[0] + 10));
              word_181E2A = WORD2(v3);
              dword_181E26 = v3;
              if ( (_DWORD)v3 || word_181E2A )
              {
                lseek(dword_181E20, __readgsdword(v6[0] + 6), 0);
                if ( !dos_read(dword_181E20, dword_181E26, (unsigned __int16)word_181E2A, __readgsdword(v6[0] + 10), v8)
                  && !sub_9F5E0((int *)dword_180C7C, dword_181E26, word_181E2A, 1u) )
                {
                  byte_E3815 = 1;
                  sub_98882(dword_181E20);
                }
              }
            }
          }
        }
      }
    }
  }
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// AA7C0: using guessed type _DWORD __cdecl lseek(_DWORD, _DWORD, char);
// AD8A2: using guessed type _DWORD __cdecl dos_read(_DWORD, char, _DWORD, _DWORD, _DWORD);
// E37FC: using guessed type char byte_E37FC;
// E3815: using guessed type char byte_E3815;
// 180C7C: using guessed type int dword_180C7C;
// 180C84: using guessed type char byte_180C84;
// 181E20: using guessed type int dword_181E20;
// 181E26: using guessed type int dword_181E26;
// 181E2A: using guessed type __int16 word_181E2A;
// 181E2C: using guessed type int dword_181E2C;
// 181E30: using guessed type __int16 word_181E30;
// 9F740: using guessed type char var_C[4];

//----- (0009FA80) --------------------------------------------------------
void sub_9FA80()
{
  if ( byte_E37FC && !stricmp(&unk_180BE0, aSbawe32Mdi_1) && !stricmp(&byte_180C84, aW) )
  {
    sub_9F6D0((int *)dword_180C7C, 1);
    sub_9F170(dword_181E2C, word_181E30);
    sub_9F170(dword_181E26, word_181E2A);
    byte_E3815 = 0;
  }
}
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);
// E37FC: using guessed type char byte_E37FC;
// E3815: using guessed type char byte_E3815;
// 180C7C: using guessed type int dword_180C7C;
// 180C84: using guessed type char byte_180C84;
// 181E26: using guessed type int dword_181E26;
// 181E2A: using guessed type __int16 word_181E2A;
// 181E2C: using guessed type int dword_181E2C;
// 181E30: using guessed type __int16 word_181E30;

//----- (000A0B24) --------------------------------------------------------
int __cdecl sub_A0B24(int a1)
{
  if ( (unsigned __int16)a1 < 0x3C4u && (unsigned __int16)a1 >= 0x3C0u )
  {
    if ( (unsigned __int16)a1 <= 0x3C0u )
    {
      inp(986);
      outp(960, BYTE2(a1) | 0x20);
      return outp(960, SHIBYTE(a1));
    }
    if ( (unsigned __int16)a1 >= 0x3C2u )
      return outp((unsigned __int16)a1, SHIBYTE(a1));
  }
  outp((unsigned __int16)a1, SBYTE2(a1));
  return outp((unsigned __int16)a1 + 1, SHIBYTE(a1));
}
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);

//----- (000A0BB0) --------------------------------------------------------
int __cdecl sub_A0BB0(int *a1, int a2)
{
  char v4; // di
  int result; // eax
  int v6; // [esp-4h] [ebp-10h]

  outp(980, 17);
  v4 = inp(981);
  outp(980, 17);
  for ( result = outp(981, v4 & 0x7F); --a2 != -1; result = sub_A0B24(v6) )
    v6 = *a1++;
  return result;
}
// A0ED7: using guessed type _DWORD __cdecl outp(_DWORD, char);
// A0EE1: using guessed type _DWORD __cdecl inp(_DWORD);

//----- (000A0D2C) --------------------------------------------------------
int __cdecl sub_A0D2C(unsigned __int8 *a1)
{
  int v3; // [esp+4h] [ebp-4h]

  __outbyte(0x3C7u, 0);
  __inbytestring(0x3C9u, a1, 0x300u);
  return v3;
}
// A0D4D: variable 'v3' is possibly undefined

//----- (000A0D50) --------------------------------------------------------
int __cdecl sub_A0D50(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  int result; // eax

  dword_18063C = a1;
  dword_180650 = a2;
  dword_180648 = a3;
  dword_180644 = a4;
  dword_180634 = a3 + a1;
  result = a4;
  dword_180630 = a4 + a2;
  return result;
}
// 180630: using guessed type int dword_180630;
// 180634: using guessed type int dword_180634;
// 18063C: using guessed type int dword_18063C;
// 180644: using guessed type int dword_180644;
// 180648: using guessed type int dword_180648;
// 180650: using guessed type int dword_180650;

//----- (000A0EEC) --------------------------------------------------------
void sub_A0EEC()
{
  ++dword_E3FF2;
}
// E3FF2: using guessed type int dword_E3FF2;

//----- (000A0EF9) --------------------------------------------------------
void sub_A0EF9()
{
  --dword_E3FF2;
}
// E3FF2: using guessed type int dword_E3FF2;

//----- (000A0F06) --------------------------------------------------------
int __usercall sub_A0F06@<eax>(
        __int32 a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        __int32 a6@<edi>,
        __int32 a7@<esi>)
{
  int v7; // edx
  unsigned int i; // edi
  unsigned int v9; // eax
  unsigned int j; // edi
  __int32 v11; // eax
  __int32 v12; // ecx
  __int32 v13; // eax
  _DWORD v15[10]; // [esp-30h] [ebp-30h] BYREF
  __int32 v16; // [esp-8h] [ebp-8h] BYREF
  __int32 v17; // [esp-4h] [ebp-4h] BYREF
  void *retaddr[2]; // [esp+0h] [ebp+0h] BYREF

  if ( dword_E3FEE )
  {
    v17 = a1;
    __outbyte(0x20u, 0x20u);
    __asm { iret }
  }
  v17 = a7;
  v16 = a6;
  v15[9] = a5;
  v15[8] = retaddr;
  v15[7] = a4;
  v15[6] = a3;
  v15[5] = a2;
  v15[4] = a1;
  v15[3] = (unsigned __int16)__DS__;
  v15[2] = (unsigned __int16)__ES__;
  v15[1] = (unsigned __int16)__FS__;
  v15[0] = (unsigned __int16)__GS__;
  __DS__ = word_E3FF6;
  ++dword_E3FEE;
  word_E4A04 = __SS__;
  dword_E4A08 = (int)v15;
  v7 = dword_E3FEA;
  for ( i = 0; i < 16; ++i )
  {
    if ( dword_E3E9C[i] == 2 )
    {
      v9 = v7 + dword_E3EDC[i];
      if ( v9 >= dword_E3F1C[i] )
      {
        v9 -= dword_E3F1C[i];
        ++dword_E3F5C[i];
      }
      dword_E3EDC[i] = v9;
    }
  }
  __outbyte(0x20u, 0x20u);
  _enable();
  if ( dword_E3FF2 <= 0 )
  {
    for ( j = 0; j < 15; ++j )
    {
      while ( dword_E3F5C[j] )
      {
        --dword_E3F5C[j];
        ((void (__stdcall *)(int))dword_E3E5C[j])(dword_E3F9C[j]);
      }
    }
  }
  if ( !dword_E3F98 )
  {
    --dword_E3FEE;
    __asm { iret }
  }
  --dword_E3F98;
  --dword_E3FEE;
  v11 = (unsigned __int16)word_E3FE0;
  v12 = _InterlockedExchange(&v16, dword_E3FDC);
  v13 = _InterlockedExchange(&v17, v11);
  return MK_FP(retaddr[0], retaddr[0])(v13, v17, v16, v12);
}
// A0F06: could not find valid save-restore pair for ebx
// A0F06: could not find valid save-restore pair for ebp
// A0F06: could not find valid save-restore pair for edi
// A0F06: could not find valid save-restore pair for esi
// E3E5C: using guessed type int dword_E3E5C[];
// E3E9C: using guessed type int dword_E3E9C[];
// E3EDC: using guessed type int dword_E3EDC[];
// E3F1C: using guessed type int dword_E3F1C[];
// E3F5C: using guessed type int dword_E3F5C[];
// E3F98: using guessed type int dword_E3F98;
// E3F9C: using guessed type int dword_E3F9C[];
// E3FDC: using guessed type int dword_E3FDC;
// E3FE0: using guessed type __int16 word_E3FE0;
// E3FEA: using guessed type int dword_E3FEA;
// E3FEE: using guessed type int dword_E3FEE;
// E3FF2: using guessed type int dword_E3FF2;
// E3FF6: using guessed type __int16 word_E3FF6;
// E4A04: using guessed type __int16 word_E4A04;
// E4A08: using guessed type int dword_E4A08;

//----- (000A102C) --------------------------------------------------------
char __cdecl sub_A102C(int a1)
{
  unsigned int v1; // kr00_4
  unsigned __int8 v2; // ah
  char result; // al
  _BOOL1 v4; // zf
  void *retaddr; // [esp+10h] [ebp+4h]

  v1 = __readeflags();
  _disable();
  __outbyte(0x43u, 0x36u);
  v2 = BYTE1(a1);
  dword_E3FE6 = a1;
  __outbyte(0x40u, a1);
  result = BYTE1(a1);
  __outbyte(0x40u, v2);
  v4 = (BYTE1(retaddr) & 2) == 0;
  _disable();
  if ( !v4 )
    _enable();
  __writeeflags(v1);
  return result;
}
// E3FE6: using guessed type int dword_E3FE6;

//----- (000A105C) --------------------------------------------------------
char __cdecl sub_A105C(unsigned int a1)
{
  int v1; // eax

  v1 = 0;
  if ( a1 < 0xD68D )
    v1 = 10000 * (unsigned __int64)a1 / 0x20BC;
  return sub_A102C(v1);
}

//----- (000A108F) --------------------------------------------------------
void sub_A108F()
{
  unsigned int v0; // ecx
  unsigned int i; // edi

  sub_91BD0();
  v0 = -1;
  for ( i = 0; i < 16; ++i )
  {
    if ( dword_E3E9C[i] && dword_E3F1C[i] < v0 )
      v0 = dword_E3F1C[i];
  }
  if ( v0 != dword_E3FEA )
  {
    dword_E3FEA = v0;
    sub_A105C(v0);
    memset(dword_E3EDC, 0, 0x40u);
  }
  sub_91BF0();
}
// E3E9C: using guessed type int dword_E3E9C[];
// E3EDC: using guessed type int dword_E3EDC[];
// E3F1C: using guessed type int dword_E3F1C[];
// E3FEA: using guessed type int dword_E3FEA;

//----- (000A10F4) --------------------------------------------------------
void __fastcall sub_A10F4(int a1, unsigned __int16 a2)
{
  unsigned int v2; // kr00_4
  _BOOL1 v3; // zf
  char v4; // [esp-7h] [ebp-13h]

  v2 = __readeflags();
  v4 = BYTE1(v2);
  _disable();
  word_E3FF6 = __DS__;
  sub_A18BE();
  dword_E3FEE = 0;
  dword_E3FF2 = 0;
  dword_E3FEA = -1;
  dword_E3FF8 = -1;
  memset(dword_E3E9C, 0, 0x40u);
  memset(dword_E3EDC, 0, 0x40u);
  memset(dword_E3F1C, 0, 0x40u);
  memset(dword_E3F5C, 0, 0x40u);
  __asm
  {
    int     31h; DPMI Services   ax=func xxxxh
    int     21h; DOS - 2+ - GET INTERRUPT VECTOR
  }
  dword_E3FDC = 8;
  word_E3FE0 = __DS__;
  dword_E3FE2 = a2;
  __asm { int     21h; DOS - SET INTERRUPT VECTOR }
  dword_E3ED8 = 2;
  sub_92890(60, 54925);
  v3 = (v4 & 2) == 0;
  _disable();
  if ( !v3 )
    _enable();
  __writeeflags(v2);
}
// E3E9C: using guessed type int dword_E3E9C[];
// E3ED8: using guessed type int dword_E3ED8;
// E3EDC: using guessed type int dword_E3EDC[];
// E3F1C: using guessed type int dword_E3F1C[];
// E3F5C: using guessed type int dword_E3F5C[];
// E3FDC: using guessed type int dword_E3FDC;
// E3FE0: using guessed type __int16 word_E3FE0;
// E3FE2: using guessed type int dword_E3FE2;
// E3FEA: using guessed type int dword_E3FEA;
// E3FEE: using guessed type int dword_E3FEE;
// E3FF2: using guessed type int dword_E3FF2;
// E3FF6: using guessed type __int16 word_E3FF6;
// E3FF8: using guessed type int dword_E3FF8;

//----- (000A11E2) --------------------------------------------------------
int sub_A11E2()
{
  unsigned int v0; // kr00_4
  int result; // eax
  _BOOL1 v2; // zf
  char v3; // [esp-3h] [ebp-Fh]

  v0 = __readeflags();
  v3 = BYTE1(v0);
  _disable();
  sub_A102C(0);
  result = 9480;
  __asm { int     21h; DOS - SET INTERRUPT VECTOR }
  v2 = (v3 & 2) == 0;
  _disable();
  if ( !v2 )
    _enable();
  __writeeflags(v0);
  return result;
}
// E3FDC: using guessed type int dword_E3FDC;
// E3FE0: using guessed type __int16 word_E3FE0;

//----- (000A121D) --------------------------------------------------------
int __fastcall sub_A121D(int a1, __int16 a2, int a3, int a4)
{
  int v4; // ecx

  __asm { int     31h; DPMI Services   ax=func xxxxh }
  v4 = a4 << 16;
  LOWORD(v4) = a2;
  __asm { int     21h; DOS - 2+ - GET INTERRUPT VECTOR }
  return v4;
}

//----- (000A1249) --------------------------------------------------------
int sub_A1249()
{
  int result; // eax

  result = 513;
  __asm { int     31h; DPMI Services   ax=func xxxxh }
  return result;
}

//----- (000A12C5) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __cdecl sub_A12C5(int a1, int a2, __int16 a3)
{
  int result; // eax

  if ( dword_E3FF8 == -1 )
  {
    __asm
    {
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      lar     ecx, edx
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      lar     ecx, edx
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      lar     ecx, edx
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      lar     ecx, edx
      int     31h; DPMI Services   ax=func xxxxh
    }
    dword_A128C = (int)&unk_E4004 - ((unsigned int)&unk_E4004 & 0xFFFFFFF0) + 512;
    word_A1286 = 0;
    word_A1277 = 0;
    word_A12AC = 0;
    word_A12B3 = a3;
    word_A12A2 = (unsigned __int16)&dword_A1270 - ((unsigned int)&dword_A1270 & 0xFFFFFFF0) + 74;
    dword_E3FF8 = a1;
    __asm { int     31h; DPMI Services   ax=func xxxxh }
    dword_E3FFC = 49407;
    dword_E4000 = __DS__;
    result = 517;
    __asm { int     31h; DPMI Services   ax=func xxxxh }
  }
  return result;
}
// A1462: write access to const memory at A128C has been detected
// A146A: write access to const memory at A1286 has been detected
// A1473: write access to const memory at A1277 has been detected
// A147C: write access to const memory at A12AC has been detected
// A1485: write access to const memory at A12B3 has been detected
// A1493: write access to const memory at A12A2 has been detected
// A1270: using guessed type int dword_A1270;
// A1277: using guessed type __int16 word_A1277;
// A1286: using guessed type __int16 word_A1286;
// A128C: using guessed type int dword_A128C;
// A12A2: using guessed type __int16 word_A12A2;
// A12AC: using guessed type __int16 word_A12AC;
// A12B3: using guessed type __int16 word_A12B3;
// E3FF8: using guessed type int dword_E3FF8;
// E3FFC: using guessed type int dword_E3FFC;
// E4000: using guessed type int dword_E4000;

//----- (000A14DB) --------------------------------------------------------
int __cdecl sub_A14DB(int a1)
{
  int result; // eax

  if ( a1 != -1 && a1 == dword_E3FF8 )
  {
    result = 517;
    __asm { int     31h; DPMI Services   ax=func xxxxh }
    dword_E3FF8 = -1;
  }
  return result;
}
// E3FF8: using guessed type int dword_E3FF8;
// E3FFC: using guessed type int dword_E3FFC;
// E4000: using guessed type int dword_E4000;

//----- (000A1520) --------------------------------------------------------
unsigned int sub_A1520()
{
  unsigned int v0; // kr00_4
  unsigned int result; // eax

  v0 = __getcallerseflags();
  result = v0;
  _disable();
  return result;
}

//----- (000A1524) --------------------------------------------------------
void __cdecl sub_A1524(unsigned int a1)
{
  _BOOL1 v1; // zf
  void *retaddr; // [esp+4h] [ebp+4h]

  v1 = (BYTE1(retaddr) & 2) == 0;
  _disable();
  if ( !v1 )
    _enable();
  __writeeflags(a1);
}

//----- (000A158B) --------------------------------------------------------
int __cdecl sub_A158B(int a1, __int16 a2, _WORD *a3, _WORD *a4)
{
  __int16 v8; // dx
  __int16 v9; // si
  __int16 v10; // di
  __int16 v11; // cx
  __int16 v12; // dx
  __int16 v13; // si
  __int16 v14; // di
  int v16; // [esp-Ch] [ebp-54h]
  __int16 v17[25]; // [esp+Eh] [ebp-3Ah] BYREF

  sub_91BD0();
  memset(v17, 0, sizeof(v17));
  _CF = __CFSHR__(50, 2);
  _ZF = 0;
  _SF = 0;
  v17[18] = 0;
  v17[17] = 0;
  __asm { pushfw }
  v17[16] = 0;
  v17[14] = a2;
  if ( a3 )
  {
    v8 = a3[3];
    v9 = a3[4];
    v10 = a3[5];
    v17[12] = a3[2];
    v17[10] = v8;
    v17[2] = v9;
    v17[0] = v10;
  }
  v17[8] = *(_WORD *)(*(_DWORD *)(a1 + 8) + 50);
  __asm { int     31h; DPMI Services   ax=func xxxxh }
  if ( a4 )
  {
    v11 = v17[12];
    v12 = v17[10];
    v13 = v17[2];
    v14 = v17[0];
    *a4 = v17[14];
    a4[2] = v11;
    a4[3] = v12;
    a4[4] = v13;
    a4[5] = v14;
    a4[1] = v17[8];
  }
  v16 = v17[14];
  sub_91BF0();
  return v16;
}

//----- (000A1665) --------------------------------------------------------
unsigned __int8 __cdecl sub_A1665(int a1)
{
  unsigned __int8 result; // al
  unsigned __int16 v2; // dx
  int i; // ecx
  unsigned __int8 v4; // al

  result = MEMORY[0x463];
  v2 = MEMORY[0x463] + 6;
  for ( i = a1; i; --i )
  {
    do
      v4 = __inbyte(v2);
    while ( (v4 & 8) == 0 );
    do
      result = __inbyte(v2);
    while ( (result & 8) != 0 );
  }
  return result;
}

//----- (000A16A2) --------------------------------------------------------
int sub_A16A2()
{
  return dword_E3FEE;
}
// E3FEE: using guessed type int dword_E3FEE;

//----- (000A16AE) --------------------------------------------------------
unsigned int __cdecl sub_A16AE(int a1)
{
  unsigned int v1; // eax
  unsigned int v3; // [esp-4h] [ebp-10h]

  sub_91BD0();
  v1 = 0;
  while ( *(int *)((char *)dword_E3E9C + v1) )
  {
    v1 += 4;
    if ( v1 >= 0x3C )
    {
      v1 = -1;
      goto LABEL_6;
    }
  }
  *(int *)((char *)dword_E3E9C + v1) = 1;
  *(int *)((char *)dword_E3E5C + v1) = a1;
LABEL_6:
  v3 = v1;
  sub_91BF0();
  return v3;
}
// E3E5C: using guessed type int dword_E3E5C[];
// E3E9C: using guessed type int dword_E3E9C[];

//----- (000A16F5) --------------------------------------------------------
__int32 __cdecl sub_A16F5(int a1, __int32 a2)
{
  __int32 v2; // eax
  __int32 v4; // [esp-4h] [ebp-10h]

  sub_91BD0();
  if ( a1 != -1 )
    v2 = _InterlockedExchange((int *)((char *)dword_E3F9C + a1), a2);
  v4 = v2;
  sub_91BF0();
  return v4;
}
// A1711: variable 'v2' is possibly undefined
// E3F9C: using guessed type int dword_E3F9C[];

//----- (000A171D) --------------------------------------------------------
void __cdecl sub_A171D(int a1)
{
  sub_91BD0();
  if ( a1 != -1 )
    *(int *)((char *)dword_E3E9C + a1) = 0;
  sub_91BF0();
}
// E3E9C: using guessed type int dword_E3E9C[];

//----- (000A1744) --------------------------------------------------------
void sub_A1744()
{
  int v0; // esi
  _BOOL1 v1; // sf
  _BOOL1 v2; // of

  sub_91BD0();
  v0 = 56;
  do
  {
    sub_92DC0(v0);
    v2 = __OFSUB__(v0, 4);
    v1 = v0 - 4 < 0;
    v0 -= 4;
  }
  while ( v1 == v2 );
  sub_91BF0();
}

//----- (000A1768) --------------------------------------------------------
void __cdecl sub_A1768(int a1)
{
  sub_91BD0();
  if ( a1 != -1 && *(int *)((char *)dword_E3E9C + a1) == 1 )
    *(int *)((char *)dword_E3E9C + a1) = 2;
  sub_91BF0();
}
// E3E9C: using guessed type int dword_E3E9C[];

//----- (000A1798) --------------------------------------------------------
void sub_A1798()
{
  int v0; // esi
  _BOOL1 v1; // sf
  _BOOL1 v2; // of

  sub_91BD0();
  v0 = 56;
  do
  {
    sub_92BA0(v0);
    v2 = __OFSUB__(v0, 4);
    v1 = v0 - 4 < 0;
    v0 -= 4;
  }
  while ( v1 == v2 );
  sub_91BF0();
}

//----- (000A17BC) --------------------------------------------------------
void __cdecl sub_A17BC(int a1)
{
  sub_91BD0();
  if ( a1 != -1 && *(int *)((char *)dword_E3E9C + a1) == 2 )
    *(int *)((char *)dword_E3E9C + a1) = 1;
  sub_91BF0();
}
// E3E9C: using guessed type int dword_E3E9C[];

//----- (000A17EC) --------------------------------------------------------
void sub_A17EC()
{
  int v0; // esi
  _BOOL1 v1; // sf
  _BOOL1 v2; // of

  sub_91BD0();
  v0 = 56;
  do
  {
    sub_92CB0(v0);
    v2 = __OFSUB__(v0, 4);
    v1 = v0 - 4 < 0;
    v0 -= 4;
  }
  while ( v1 == v2 );
  sub_91BF0();
}

//----- (000A1810) --------------------------------------------------------
void __cdecl sub_A1810(int a1, int a2)
{
  sub_91BD0();
  *(int *)((char *)dword_E3F1C + a1) = a2;
  *(int *)((char *)dword_E3EDC + a1) = 0;
  sub_A108F();
  sub_91BF0();
}
// E3EDC: using guessed type int dword_E3EDC[];
// E3F1C: using guessed type int dword_E3F1C[];

//----- (000A1840) --------------------------------------------------------
void __cdecl sub_A1840(int a1, unsigned int a2)
{
  sub_91BD0();
  sub_92890(a1, (unsigned int)&unk_F4240 / a2);
  sub_91BF0();
}

//----- (000A1870) --------------------------------------------------------
void __cdecl sub_A1870(int a1, unsigned int a2)
{
  int v2; // eax

  sub_91BD0();
  if ( a2 )
    v2 = 10000 * (unsigned __int64)a2 / 0x2E9C;
  else
    v2 = 54925;
  sub_92890(a1, v2);
  sub_91BF0();
}

//----- (000A18B2) --------------------------------------------------------
int sub_A18B2()
{
  return dword_E3FE6;
}
// E3FE6: using guessed type int dword_E3FE6;

//----- (000A18BE) --------------------------------------------------------
bool sub_A18BE()
{
  sub_9D590((unsigned int)dword_E3E5C, (unsigned int)byte_E4A0C);
  return sub_9D590((unsigned int)sub_A0EEC, (unsigned int)sub_A18BE);
}
// E3E5C: using guessed type int dword_E3E5C[];

//----- (000A1F90) --------------------------------------------------------
bool sub_A1F90()
{
  bool result; // eax

  if ( !dword_E4A90 )
  {
    sub_9D590((unsigned int)sub_A1F90, (unsigned int)sub_A4260);
    sub_9D710((unsigned int)byte_E4A0C, 128);
    sub_9D710((unsigned int)&dword_E4A8C, 4);
    sub_9D710((unsigned int)&dword_181E94, 4);
    sub_9D710((unsigned int)&unk_181E80, 12);
    sub_9D710((unsigned int)&dword_181E9C, 4);
    sub_9D710((unsigned int)&dword_181EA0, 4);
    sub_9D710((unsigned int)&dword_181E90, 4);
    sub_9D710((unsigned int)&dword_181E98, 4);
    sub_9D710((unsigned int)&dword_181E8C, 4);
    result = sub_B0C46();
    dword_E4A90 = 1;
  }
  return result;
}
// E4A8C: using guessed type int dword_E4A8C;
// E4A90: using guessed type int dword_E4A90;
// 181E8C: using guessed type int dword_181E8C;
// 181E90: using guessed type int dword_181E90;
// 181E94: using guessed type int dword_181E94;
// 181E98: using guessed type int dword_181E98;
// 181E9C: using guessed type int dword_181E9C;
// 181EA0: using guessed type int dword_181EA0;

//----- (000A2070) --------------------------------------------------------
int __cdecl sub_A2070(int a1)
{
  int result; // eax
  _WORD v2[6]; // [esp+0h] [ebp-Ch] BYREF

  result = a1;
  if ( !*(_DWORD *)(a1 + 84) )
  {
    v2[3] = *(_WORD *)(a1 + 24);
    v2[2] = *(_WORD *)(a1 + 20);
    sub_91F70(*(_DWORD *)a1, 1025, v2, 0);
    result = a1;
    *(_DWORD *)(a1 + 84) = 1;
  }
  return result;
}

//----- (000A20D0) --------------------------------------------------------
int *__cdecl sub_A20D0(int *a1)
{
  int *result; // eax

  result = a1;
  if ( a1[21] )
  {
    sub_91F70(*a1, 1026, 0, 0);
    result = a1;
    a1[21] = 0;
  }
  return result;
}

//----- (000A2110) --------------------------------------------------------
int __cdecl sub_A2110(int *a1)
{
  int result; // eax
  int *v2; // edx
  int *v3; // edx
  int *v4; // edx
  int *v5; // edx
  int *v6; // edx
  int *v7; // edx
  int *v8; // edx
  int *v9; // edx
  int *v10; // edx
  int *v11; // [esp+0h] [ebp-24h]
  int *v12; // [esp+4h] [ebp-20h]
  int *v13; // [esp+8h] [ebp-1Ch]
  int v14; // [esp+Ch] [ebp-18h]
  int v15; // [esp+14h] [ebp-10h]
  int v16; // [esp+18h] [ebp-Ch]
  int v17; // [esp+1Ch] [ebp-8h]
  int i; // [esp+20h] [ebp-4h]
  int j; // [esp+20h] [ebp-4h]
  int k; // [esp+20h] [ebp-4h]
  int m; // [esp+20h] [ebp-4h]
  int n; // [esp+20h] [ebp-4h]
  int ii; // [esp+20h] [ebp-4h]

  if ( a1[16] <= 127 )
  {
    if ( a1[16] < 0 )
      a1[16] = 0;
  }
  else
  {
    a1[16] = 127;
  }
  if ( a1[17] <= 127 )
  {
    if ( a1[17] < 0 )
      a1[17] = 0;
  }
  else
  {
    a1[17] = 127;
  }
  v14 = a1[17];
  v17 = *(_DWORD *)(*a1 + 104) * a1[16] / 127;
  if ( v17 < 0 )
    v17 = 0;
  if ( v17 > 127 )
    v17 = 127;
  if ( a1[13] == 1 || a1[13] == 3 )
  {
    a1[18] = v17 * (unsigned __int8)byte_E4A0C[127 - v14] / 127;
    result = v17 * (unsigned __int8)byte_E4A0C[v14] / 127;
    a1[274] = result;
  }
  else
  {
    if ( v17 )
      ++v17;
    if ( *(_DWORD *)(*a1 + 24) == 2
      || *(_DWORD *)(*a1 + 24) == 3
      || *(_DWORD *)(*a1 + 24) <= 1u && (a1[13] == 2 || a1[13] == 3) )
    {
      v13 = a1 + 18;
      v12 = a1 + 274;
      v16 = (unsigned __int8)byte_E4A0C[127 - v14];
      v15 = (unsigned __int8)byte_E4A0C[v14];
      result = (int)a1;
      if ( (a1[14] & 1) != 0 )
      {
        for ( i = 0; i < 0x8000; i += 256 )
        {
          v2 = v13++;
          *v2 = (v16 * ((v17 * i) >> 7)) >> 7;
          result = (v15 * ((v17 * i) >> 7)) >> 7;
          v3 = v12++;
          *v3 = result;
        }
        for ( j = -32768; j < 0; j += 256 )
        {
          v4 = v13++;
          *v4 = (v16 * ((v17 * j) >> 7)) >> 7;
          result = (v15 * ((v17 * j) >> 7)) >> 7;
          v5 = v12++;
          *v5 = result;
        }
      }
      else
      {
        for ( k = -32768; k < 0x8000; k += 256 )
        {
          v6 = v13++;
          *v6 = (v16 * ((v17 * k) >> 7)) >> 7;
          result = (v15 * ((v17 * k) >> 7)) >> 7;
          v7 = v12++;
          *v7 = result;
        }
      }
    }
    else
    {
      v11 = a1 + 18;
      result = (int)a1;
      if ( (a1[14] & 1) != 0 )
      {
        for ( m = 0; m < 0x8000; m += 256 )
        {
          result = (v17 * m) >> 7;
          v8 = v11++;
          *v8 = result;
        }
        for ( n = -32768; n < 0; n += 256 )
        {
          result = (v17 * n) >> 7;
          v9 = v11++;
          *v9 = result;
        }
      }
      else
      {
        for ( ii = -32768; ii < 0x8000; ii += 256 )
        {
          result = (v17 * ii) >> 7;
          v10 = v11++;
          *v10 = result;
        }
      }
    }
  }
  return result;
}

//----- (000A2650) --------------------------------------------------------
int __cdecl sub_A2650(int a1)
{
  int v1; // eax
  int v2; // eax
  int v4; // [esp+Ch] [ebp-38h]
  int v5; // [esp+10h] [ebp-34h]
  int v6; // [esp+14h] [ebp-30h]
  int v7; // [esp+18h] [ebp-2Ch]
  int v9; // [esp+20h] [ebp-24h]
  unsigned int v10; // [esp+24h] [ebp-20h]
  int v11; // [esp+28h] [ebp-1Ch]
  int v12; // [esp+2Ch] [ebp-18h]
  int j; // [esp+30h] [ebp-14h]
  int v14; // [esp+34h] [ebp-10h]
  int v15; // [esp+38h] [ebp-Ch]
  int v16; // [esp+3Ch] [ebp-8h]
  int i; // [esp+40h] [ebp-4h]

  v9 = *(_DWORD *)(a1 + 84);
  if ( v9 )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 96); ++i )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 92) + 2196 * i + 2192) = *(_DWORD *)(*(_DWORD *)(a1 + 92) + 2196 * i + 4);
      if ( *(_DWORD *)(2196 * i + *(_DWORD *)(a1 + 92) + 4) == 4 )
        *(_DWORD *)(2196 * i + *(_DWORD *)(a1 + 92) + 4) = 8;
    }
    sub_A20D0((int *)a1);
    sub_B0C1A(a1);
    sub_B0B87((_DWORD *)a1, 0);
    sub_B0B87((_DWORD *)a1, 1);
  }
  switch ( (2 * dword_181DC8) | dword_181DCC )
  {
    case 0:
      v4 = 0;
      v5 = 1;
      v6 = 2;
      v7 = 3;
      break;
    case 1:
      v4 = 1;
      v5 = 0;
      v6 = 3;
      v7 = 2;
      break;
    case 2:
      v4 = 2;
      v5 = 3;
      v6 = 0;
      v7 = 1;
      break;
    case 3:
      v4 = 3;
      v5 = 2;
      v6 = 1;
      v7 = 0;
      break;
    default:
      break;
  }
  for ( i = 0; i < 4; ++i )
  {
    if ( *(_BYTE *)(*(&v4 + i) + *(_DWORD *)(a1 + 4)) )
    {
      *(_DWORD *)(a1 + 24) = *(&v4 + i);
      break;
    }
  }
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 26);
  if ( dword_181DB0 )
  {
    if ( (unsigned int)dword_181DB0 <= 1 )
    {
      *(_DWORD *)(a1 + 20) = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 18);
    }
    else if ( dword_181DB0 == 2 )
    {
      *(_DWORD *)(a1 + 20) = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 20);
    }
    else
    {
      j = dword_181DB0;
      v4 = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 16);
      v5 = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 18);
      v6 = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 20);
      v11 = 0x7FFFFFFF;
      for ( i = 0; i < 3; ++i )
      {
        v1 = abs(j - *(&v4 + i));
        if ( v1 <= v11 )
        {
          v11 = abs(j - *(&v4 + i));
          v12 = i;
        }
      }
      *(_DWORD *)(a1 + 20) = *(&v4 + v12);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 20) = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 16);
  }
  switch ( *(_DWORD *)(a1 + 24) )
  {
    case 0:
      *(_DWORD *)(a1 + 60) = 1;
      *(_DWORD *)(a1 + 64) = 1;
      break;
    case 1:
      *(_DWORD *)(a1 + 60) = 1;
      *(_DWORD *)(a1 + 64) = 2;
      break;
    case 2:
      *(_DWORD *)(a1 + 60) = 2;
      *(_DWORD *)(a1 + 64) = 1;
      break;
    case 3:
      *(_DWORD *)(a1 + 60) = 2;
      *(_DWORD *)(a1 + 64) = 2;
      break;
    default:
      break;
  }
  v14 = dword_181DB8 * *(_DWORD *)(a1 + 20) / 1000;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 60) * *(_DWORD *)(a1 + 64) * v14;
  v16 = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 22);
  v15 = *(unsigned __int16 *)(14 * *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 4) + 24);
  if ( !dword_181DF4 )
    goto LABEL_40;
  if ( v15 > 2048 )
    v15 = 2048;
  if ( v16 > 2048 )
  {
    strcpy(&byte_181C90, "Minimum DMA buffer size too large for VDM\n");
    return 0;
  }
  else
  {
LABEL_40:
    v11 = 0x7FFFFFFF;
    for ( j = 8; dword_181DB4 / 2 >= j; j *= 2 )
    {
      v2 = abs(j - *(_DWORD *)(a1 + 16));
      if ( v2 <= v11 )
      {
        v11 = abs(j - *(_DWORD *)(a1 + 16));
        v12 = j;
      }
    }
    *(_DWORD *)(a1 + 16) = v12;
    if ( *(_DWORD *)(a1 + 16) < v16 )
      *(_DWORD *)(a1 + 16) = v16;
    if ( *(_DWORD *)(a1 + 16) > v15 )
      *(_DWORD *)(a1 + 16) = v15;
    v10 = *(_DWORD *)(a1 + 32);
    if ( dword_181DF4 )
    {
      v10 >>= 12;
      v10 += 4095;
      v10 &= (unsigned int)&unk_FF000;
      v10 <<= 12;
    }
    **(_DWORD **)(a1 + 8) = v10;
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) = *(_DWORD *)(a1 + 16) + v10;
    *(_DWORD *)(a1 + 44) = (unsigned __int16)**(_DWORD **)(a1 + 8) + 16 * HIWORD(**(_DWORD **)(a1 + 8));
    *(_DWORD *)(a1 + 48) = (unsigned __int16)*(_DWORD *)(*(_DWORD *)(a1 + 8) + 4)
                         + 16 * HIWORD(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 4));
    if ( v9 )
    {
      for ( i = 0; i < *(_DWORD *)(a1 + 96); ++i )
        *(_DWORD *)(*(_DWORD *)(a1 + 92) + 2196 * i + 4) = *(_DWORD *)(*(_DWORD *)(a1 + 92) + 2196 * i + 2192);
      sub_B0C1A(a1);
      sub_B0B87((_DWORD *)a1, 0);
      sub_B0B87((_DWORD *)a1, 1);
      sub_A2070(a1);
    }
    return 1;
  }
}
// A0D1F: using guessed type _DWORD __cdecl abs(_DWORD);
// 181C90: using guessed type char byte_181C90;
// 181DB0: using guessed type int dword_181DB0;
// 181DB4: using guessed type int dword_181DB4;
// 181DB8: using guessed type int dword_181DB8;
// 181DC8: using guessed type int dword_181DC8;
// 181DCC: using guessed type int dword_181DCC;
// 181DF4: using guessed type int dword_181DF4;

//----- (000A2C80) --------------------------------------------------------
int __cdecl sub_A2C80(int *a1, const void *a2)
{
  _DWORD v3[6]; // [esp+0h] [ebp-30h] BYREF
  __int16 v4[3]; // [esp+18h] [ebp-18h] BYREF
  __int16 v5; // [esp+1Eh] [ebp-12h]
  unsigned int i; // [esp+24h] [ebp-Ch]
  _WORD *v7; // [esp+28h] [ebp-8h]

  qmemcpy(v3, a2, sizeof(v3));
  if ( *(_WORD *)(*(_DWORD *)(*a1 + 16) + 16) )
  {
    v7 = (_WORD *)((unsigned __int16)*(_DWORD *)(*(_DWORD *)(*a1 + 16) + 12)
                 + 16 * HIWORD(*(_DWORD *)(*(_DWORD *)(*a1 + 16) + 12)));
    if ( SLOWORD(v3[0]) < 0 )
      LOWORD(v3[0]) = *v7;
    if ( v3[0] < 0 )
      HIWORD(v3[0]) = v7[1];
    if ( SLOWORD(v3[1]) < 0 )
      LOWORD(v3[1]) = v7[2];
    if ( v3[1] < 0 )
      HIWORD(v3[1]) = v7[3];
    for ( i = 0; i < 4; ++i )
    {
      if ( (int)v3[i + 2] < 0 )
        v3[i + 2] = *(_DWORD *)&v7[2 * i + 4];
    }
  }
  qmemcpy((void *)(*(_DWORD *)(*a1 + 16) + 22), v3, 0x18u);
  if ( dword_181DD0 )
    v5 = 3;
  else
    v5 = 1;
  return sub_91F70(*a1, 772, v4, 0);
}
// 181DD0: using guessed type int dword_181DD0;
// A2C80: using guessed type __int16 var_18[3];

//----- (000A2EA0) --------------------------------------------------------
int *__cdecl sub_A2EA0(int a1, const void *a2)
{
  unsigned int v2; // eax
  unsigned int v3; // eax
  char v5[24]; // [esp+0h] [ebp-50h] BYREF
  __int16 v6[6]; // [esp+18h] [ebp-38h] BYREF
  int v8; // [esp+28h] [ebp-28h] BYREF
  unsigned int v9; // [esp+2Ch] [ebp-24h] BYREF
  unsigned int v10; // [esp+30h] [ebp-20h]
  unsigned int v11; // [esp+34h] [ebp-1Ch]
  int v12; // [esp+38h] [ebp-18h]
  int *v13; // [esp+3Ch] [ebp-14h]
  unsigned int v14; // [esp+40h] [ebp-10h]
  int v15; // [esp+44h] [ebp-Ch]
  int i; // [esp+48h] [ebp-8h]
  int v17; // [esp+4Ch] [ebp-4h] BYREF
  void *v18; // [esp+64h] [ebp+14h]
  const void *v19; // [esp+64h] [ebp+14h]

  sub_A1F90();
  v13 = (int *)sub_9D450(140);
  if ( v13 )
  {
    *v13 = a1;
    if ( *(_DWORD *)(*v13 + 20) )
    {
      strcpy(&byte_181C90, ".DIG driver required\n");
      sub_9D490((unsigned int)v13, 140);
      return 0;
    }
    else
    {
      sub_91F70(*v13, 769, 0, v6);
      v13[1] = (unsigned __int16)v6[0] + 16 * (unsigned __int16)v6[3];
      v13[2] = (unsigned __int16)v6[1] + 16 * (unsigned __int16)v6[2];
      v13[13] = v13[2] + 8;
      v13[14] = -1;
      v13[21] = 0;
      v13[22] = 0;
      v13[25] = 0;
      v13[26] = 127;
      memset(&unk_181D90, -1, 24);
      v15 = 0;
      if ( a2 )
      {
        qmemcpy(&unk_181D90, a2, 0x18u);
        if ( sub_A2C80(v13, a2) )
        {
          v15 = 1;
          qmemcpy(v5, a2, sizeof(v5));
        }
      }
      if ( !v15 )
      {
        v18 = sub_92ED0(*v13);
        if ( v18 )
        {
          qmemcpy(&unk_181D90, v18, 0x18u);
          if ( sub_A2C80(v13, v18) )
          {
            v15 = 1;
            qmemcpy(v5, v18, sizeof(v5));
          }
        }
      }
      if ( !v15 && dword_181DF0 == 1 )
      {
        for ( i = 0; *(unsigned __int16 *)(*(_DWORD *)(*v13 + 16) + 16) > i; ++i )
        {
          v19 = (const void *)(24 * i
                             + (unsigned __int16)*(_DWORD *)(*(_DWORD *)(*v13 + 16) + 12)
                             + 16 * HIWORD(*(_DWORD *)(*(_DWORD *)(*v13 + 16) + 12)));
          if ( !i )
            qmemcpy(&unk_181D90, v19, 0x18u);
          if ( sub_A2C80(v13, v19) )
          {
            v15 = 1;
            qmemcpy(v5, v19, sizeof(v5));
            break;
          }
        }
      }
      if ( v15 )
      {
        qmemcpy(&unk_181D90, v5, 0x18u);
        if ( dword_181DF4 )
          v12 = 0x2000;
        else
          v12 = dword_181DB4;
        v13[10] = 0;
        do
        {
          if ( !sub_9D4D0(
                  (v12 + 15 - (__CFSHL__((v12 + 15) >> 31, 4) + 16 * ((v12 + 15) >> 31))) >> 4,
                  (unsigned int *)&v17,
                  &v9,
                  &v8) )
          {
            strcpy(&byte_181C90, "Could not allocate DMA buffers\n");
            sub_9D490((unsigned int)v13, 140);
            return 0;
          }
          if ( v13[10] )
            sub_9D560(v13[10]);
          v13[10] = v17;
          v13[8] = v9;
          v13[9] = v8;
          v14 = v9 >> 12;
          v11 = (unsigned int)&unk_F0000 & (v9 >> 12);
          v10 = (unsigned int)&unk_F0000 & (v12 + (v9 >> 12) - 1);
        }
        while ( v11 != v10 );
        if ( sub_A2650((int)v13) )
        {
          sub_91F70(*v13, 773, 0, 0);
          *(_DWORD *)(*v13 + 24) = 1;
          v13[18] = v13[4] / (v13[16] * v13[15]);
          v13[17] = v13[4] / v13[16];
          v13[19] = 4 * v13[17];
          v2 = sub_9D450(v13[19]);
          v13[20] = v2;
          if ( v13[20] )
          {
            v13[24] = dword_181DBC;
            v13[23] = sub_9D450(2196 * v13[24]);
            if ( v13[23] )
            {
              for ( i = 0; i < v13[24]; ++i )
              {
                *(_DWORD *)(2196 * i + v13[23] + 4) = 1;
                *(_DWORD *)(v13[23] + 2196 * i) = v13;
              }
              v3 = sub_92600((int)sub_A2450);
              v13[3] = v3;
              if ( v13[3] == -1 )
              {
                strcpy(&byte_181C90, "Out of timer handles\n");
                if ( *(_DWORD *)(a1 + 28) != -1 )
                  sub_91E90(*(_DWORD *)(a1 + 28));
                sub_91F70(*v13, 774, 0, 0);
                *(_DWORD *)(*v13 + 24) = 0;
                sub_9D560(v13[10]);
                sub_9D490(v13[23], 2196 * v13[24]);
                sub_9D490(v13[20], v13[19]);
                sub_9D490((unsigned int)v13, 140);
                return 0;
              }
              else
              {
                sub_92740(v13[3], (__int32)v13);
                sub_92930(v13[3], dword_181DAC[0]);
                sub_92BA0(v13[3]);
                *(_DWORD *)(*v13 + 36) = sub_A2DE0;
                *(_DWORD *)(*v13 + 40) = v13;
                sub_B0C1A((int)v13);
                sub_B0B87(v13, 0);
                sub_B0B87(v13, 1);
                return v13;
              }
            }
            else
            {
              strcpy(&byte_181C90, "Could not allocate SAMPLE structures\n");
              if ( *(_DWORD *)(a1 + 28) != -1 )
                sub_91E90(*(_DWORD *)(a1 + 28));
              sub_91F70(*v13, 774, 0, 0);
              *(_DWORD *)(*v13 + 24) = 0;
              sub_9D560(v13[10]);
              sub_9D490(v13[20], v13[19]);
              sub_9D490((unsigned int)v13, 140);
              return 0;
            }
          }
          else
          {
            strcpy(&byte_181C90, "Could not allocate build buffer\n");
            if ( *(_DWORD *)(a1 + 28) != -1 )
              sub_91E90(*(_DWORD *)(a1 + 28));
            sub_91F70(*v13, 774, 0, 0);
            *(_DWORD *)(*v13 + 24) = 0;
            sub_9D560(v13[10]);
            sub_9D490((unsigned int)v13, 140);
            return 0;
          }
        }
        else
        {
          sub_9D560(v13[10]);
          sub_9D490((unsigned int)v13, 140);
          return 0;
        }
      }
      else
      {
        strcpy(&byte_181C90, "Digital sound hardware not found\n");
        sub_9D490((unsigned int)v13, 140);
        return 0;
      }
    }
  }
  else
  {
    strcpy(&byte_181C90, "Could not allocate memory for driver\n");
    return 0;
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// A2450: using guessed type int sub_A2450();
// A2DE0: using guessed type int sub_A2DE0();
// 181C90: using guessed type char byte_181C90;
// 181DAC: using guessed type int dword_181DAC[];
// 181DB4: using guessed type int dword_181DB4;
// 181DBC: using guessed type int dword_181DBC;
// 181DF0: using guessed type int dword_181DF0;
// 181DF4: using guessed type int dword_181DF4;

//----- (000A3600) --------------------------------------------------------
int *__usercall sub_A3600@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, const void *a4)
{
  int v4; // eax
  int v7; // [esp+4h] [ebp-Ch]
  int *v8; // [esp+8h] [ebp-8h]
  _DWORD *v9; // [esp+Ch] [ebp-4h]

  v7 = sub_9DEA0(a3, 0);
  if ( v7 )
  {
    v4 = sub_9DE20(a3);
    v9 = sub_93010(a1, a2, v7, v4);
    off_E3E34(v7);
    if ( v9 )
    {
      v8 = sub_A2EA0((int)v9, a4);
      if ( !v8 )
        sub_93160((unsigned int)v9);
      return v8;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    strcpy(&byte_181C90, "Driver file not found\n");
    return 0;
  }
}
// E3E34: using guessed type int (__cdecl *off_E3E34)(int);
// 181C90: using guessed type char byte_181C90;

//----- (000A36B0) --------------------------------------------------------
int *__usercall sub_A36B0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, const void *a5)
{
  int *v7; // [esp+4h] [ebp-8h]
  _DWORD *v8; // [esp+8h] [ebp-4h]

  v8 = sub_93010(a1, a2, a3, a4);
  if ( !v8 )
    return 0;
  v7 = sub_A2EA0((int)v8, a5);
  if ( !v7 )
    sub_93160((unsigned int)v8);
  return v7;
}

//----- (000A3720) --------------------------------------------------------
int __usercall sub_A3720@<eax>(int a1@<ecx>, int a2@<ebx>, int **a3)
{
  char v4[128]; // [esp+0h] [ebp-11Ch] BYREF
  char v5[128]; // [esp+80h] [ebp-9Ch] BYREF
  char v6[24]; // [esp+100h] [ebp-1Ch] BYREF

  if ( sub_92190((int)v4, aDigIni_0) )
  {
    *a3 = sub_93330(a1, a2, v5, v6);
    if ( *a3 )
      return 0;
    else
      return 2;
  }
  else
  {
    strcpy(&byte_181C90, "Unable to open file DIG.INI\n");
    return 1;
  }
}
// 181C90: using guessed type char byte_181C90;
// A3720: using guessed type char var_11C[128];
// A3720: using guessed type char var_1C[24];
// A3720: using guessed type char var_9C[128];

//----- (000A37A0) --------------------------------------------------------
int __cdecl sub_A37A0(unsigned int *a1)
{
  return sub_93160(*a1);
}

//----- (000A37C0) --------------------------------------------------------
int __cdecl sub_A37C0(int a1)
{
  int v2; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h]

  v2 = 0;
  for ( i = 0; i < *(_DWORD *)(a1 + 96); ++i )
  {
    if ( *(_DWORD *)(2196 * i + *(_DWORD *)(a1 + 92) + 4) == 4 )
      ++v2;
  }
  return v2;
}

//----- (000A3820) --------------------------------------------------------
int *__cdecl sub_A3820(int a1)
{
  int *v3; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h]

  sub_91BD0();
  for ( i = 0; i < *(_DWORD *)(a1 + 96) && *(_DWORD *)(2196 * i + *(_DWORD *)(a1 + 92) + 4) != 1; ++i )
    ;
  if ( i == *(_DWORD *)(a1 + 96) )
  {
    strcpy(&byte_181C90, "Out of sample handles\n");
    sub_91BF0();
    return 0;
  }
  else
  {
    v3 = (int *)(2196 * i + *(_DWORD *)(a1 + 92));
    sub_93830(v3);
    sub_91BF0();
    return v3;
  }
}
// 181C90: using guessed type char byte_181C90;

//----- (000A38C0) --------------------------------------------------------
int __cdecl sub_A38C0(int a1)
{
  int result; // eax

  if ( a1 )
  {
    result = a1;
    *(_DWORD *)(a1 + 4) = 1;
  }
  return result;
}

//----- (000A38E0) --------------------------------------------------------
int __cdecl sub_A38E0(int *a1)
{
  int result; // eax

  if ( a1 )
  {
    a1[1] = 2;
    a1[2] = 0;
    a1[4] = 0;
    a1[6] = 0;
    a1[8] = 0;
    a1[3] = 0;
    a1[5] = 0;
    a1[7] = 0;
    a1[9] = 1;
    a1[10] = 0;
    a1[11] = -2;
    a1[12] = 1;
    a1[13] = 0;
    a1[14] = 0;
    a1[15] = 11025;
    a1[16] = dword_181DC0;
    if ( *(_DWORD *)(*a1 + 24) > 1u )
      a1[17] = 64;
    else
      a1[17] = 0;
    a1[530] = 0;
    a1[531] = 0;
    a1[532] = 0;
    return sub_A2110(a1);
  }
  return result;
}
// 181DC0: using guessed type int dword_181DC0;

//----- (000A3A00) --------------------------------------------------------
int __cdecl sub_A3A00(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 4);
  else
    return 0;
}

//----- (000A3A30) --------------------------------------------------------
_DWORD *__cdecl sub_A3A30(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax

  if ( a1 )
  {
    a1[2] = a2;
    a1[4] = a3;
    a1[3] = 0;
    result = a1;
    a1[5] = 0;
  }
  return result;
}

//----- (000A3A70) --------------------------------------------------------
int __cdecl sub_A3A70(int *a1, int a2, int a3)
{
  int result; // eax

  if ( a1 )
  {
    if ( a2 != a1[13] || (result = a3, a3 != a1[14]) )
    {
      a1[13] = a2;
      a1[14] = a3;
      return sub_A2110(a1);
    }
  }
  return result;
}

//----- (000A3AC0) --------------------------------------------------------
int __cdecl sub_A3AC0(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 60);
  else
    return 0;
}

//----- (000A3AF0) --------------------------------------------------------
int __cdecl sub_A3AF0(int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    result = a2;
    *(_DWORD *)(a1 + 60) = a2;
  }
  return result;
}

//----- (000A3B10) --------------------------------------------------------
int __cdecl sub_A3B10(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 64);
  else
    return 0;
}

//----- (000A3B40) --------------------------------------------------------
int __cdecl sub_A3B40(int *a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    result = a2;
    if ( a2 != a1[16] )
    {
      a1[16] = a2;
      return sub_A2110(a1);
    }
  }
  return result;
}

//----- (000A3B80) --------------------------------------------------------
int __cdecl sub_A3B80(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 68);
  else
    return 0;
}

//----- (000A3BB0) --------------------------------------------------------
int __cdecl sub_A3BB0(int *a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    result = a2;
    if ( a2 != a1[17] )
    {
      a1[17] = a2;
      return sub_A2110(a1);
    }
  }
  return result;
}

//----- (000A3BF0) --------------------------------------------------------
int __cdecl sub_A3BF0(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 40) + 24);
  else
    return 0;
}

//----- (000A3C30) --------------------------------------------------------
int __cdecl sub_A3C30(int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    result = a2;
    *(_DWORD *)(4 * *(_DWORD *)(a1 + 40) + a1 + 24) = a2;
  }
  return result;
}

//----- (000A3C60) --------------------------------------------------------
int __cdecl sub_A3C60(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 48);
  else
    return -1;
}

//----- (000A3C90) --------------------------------------------------------
int __cdecl sub_A3C90(int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    result = a2;
    *(_DWORD *)(a1 + 48) = a2;
  }
  return result;
}

//----- (000A3CB0) --------------------------------------------------------
int __cdecl sub_A3CB0(int *a1)
{
  int result; // eax

  if ( a1 )
  {
    result = (int)a1;
    if ( a1[1] != 1 )
    {
      result = (int)&a1[a1[10]];
      if ( *(_DWORD *)(result + 16) )
      {
        result = (int)&a1[a1[10]];
        if ( *(_DWORD *)(result + 8) )
        {
          a1[a1[10] + 6] = 0;
          a1[1] = 4;
          return sub_A2070(*a1);
        }
      }
    }
  }
  return result;
}

//----- (000A3D30) --------------------------------------------------------
int __cdecl sub_A3D30(int a1)
{
  int result; // eax

  if ( a1 )
  {
    result = a1;
    if ( *(_DWORD *)(a1 + 4) == 4 )
    {
      result = a1;
      *(_DWORD *)(a1 + 4) = 8;
    }
  }
  return result;
}

//----- (000A3D60) --------------------------------------------------------
int __cdecl sub_A3D60(int *a1)
{
  int result; // eax

  if ( a1 )
  {
    result = (int)a1;
    if ( a1[1] == 8 )
    {
      a1[1] = 4;
      return sub_A2070(*a1);
    }
  }
  return result;
}

//----- (000A3DA0) --------------------------------------------------------
int __cdecl sub_A3DA0(int a1)
{
  int result; // eax

  if ( a1 )
  {
    result = a1;
    if ( *(_DWORD *)(a1 + 4) != 1 )
    {
      result = a1;
      if ( *(_DWORD *)(a1 + 4) != 2 )
      {
        *(_DWORD *)(a1 + 4) = 2;
        if ( *(_DWORD *)(a1 + 2124) )
          (*(void (__cdecl **)(int))(a1 + 2124))(a1);
        result = a1;
        if ( *(_DWORD *)(a1 + 2128) )
          return (*(int (__cdecl **)(int))(a1 + 2128))(a1);
      }
    }
  }
  return result;
}

//----- (000A3E10) --------------------------------------------------------
int __cdecl sub_A3E10(int a1, int a2)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( !a1 )
    return 0;
  v4 = *(_DWORD *)(a1 + 2120);
  *(_DWORD *)(a1 + 2120) = a2;
  return v4;
}

//----- (000A3E60) --------------------------------------------------------
int __cdecl sub_A3E60(int a1, int a2)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( !a1 )
    return 0;
  v4 = *(_DWORD *)(a1 + 2124);
  *(_DWORD *)(a1 + 2124) = a2;
  return v4;
}

//----- (000A3EB0) --------------------------------------------------------
int __cdecl sub_A3EB0(int a1, int a2)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( !a1 )
    return 0;
  v4 = *(_DWORD *)(a1 + 2128);
  *(_DWORD *)(a1 + 2128) = a2;
  return v4;
}

//----- (000A3F00) --------------------------------------------------------
int __cdecl sub_A3F00(int a1, int a2, int a3)
{
  int result; // eax

  if ( a1 )
  {
    result = a3;
    *(_DWORD *)(4 * a2 + a1 + 2132) = a3;
  }
  return result;
}

//----- (000A3F30) --------------------------------------------------------
int __cdecl sub_A3F30(int a1, int a2)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 4 * a2 + 2132);
  else
    return 0;
}

//----- (000A3F70) --------------------------------------------------------
int __cdecl sub_A3F70(_DWORD *a1, int a2)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  a1[26] = a2;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a1[24] )
      break;
    if ( *(_DWORD *)(2196 * i + a1[23] + 4) != 1 )
      sub_A2110((int *)(2196 * i + a1[23]));
  }
  return result;
}

//----- (000A3FE0) --------------------------------------------------------
int __cdecl sub_A3FE0(int a1)
{
  return *(_DWORD *)(a1 + 104);
}

//----- (000A4000) --------------------------------------------------------
char sub_A4000()
{
  return 0;
}

//----- (000A4100) --------------------------------------------------------
int __cdecl sub_A4100(int *a1, int a2, int a3, int a4)
{
  int result; // eax

  if ( a1 )
  {
    a1[a2 + 8] = a4 == 0;
    a1[a2 + 2] = a3;
    a1[a2 + 4] = a4;
    result = (int)&a1[a2];
    *(_DWORD *)(result + 24) = 0;
    if ( a4 )
    {
      result = (int)a1;
      if ( a1[1] != 4 )
      {
        a1[1] = 4;
        return sub_A2070(*a1);
      }
    }
  }
  return result;
}

//----- (000A41B0) --------------------------------------------------------
int __cdecl sub_A41B0(_DWORD *a1)
{
  int v1; // eax
  unsigned int v3; // [esp+0h] [ebp-8h]

  if ( !a1 )
    return -1;
  v3 = a1[11];
  if ( v3 < 0xFFFFFFFE )
  {
    if ( a1[11] == a1[10] )
    {
      return -1;
    }
    else
    {
      a1[11] = a1[10];
      v1 = a1[10];
      LOBYTE(v1) = v1 ^ 1;
      return v1;
    }
  }
  else if ( v3 == -1 )
  {
    a1[11] = a1[10];
    return 1;
  }
  else
  {
    a1[9] = 0;
    a1[11] = -1;
    return 0;
  }
}

//----- (000A4260) --------------------------------------------------------
bool sub_A4260()
{
  bool result; // eax

  if ( dword_E4A90 )
  {
    sub_9D650((unsigned int)sub_A1F90, (unsigned int)sub_A4260);
    sub_9D740((unsigned int)byte_E4A0C, 128);
    sub_9D740((unsigned int)&dword_E4A8C, 4);
    sub_9D740((unsigned int)&dword_181E94, 4);
    sub_9D740((unsigned int)&unk_181E80, 12);
    sub_9D740((unsigned int)&dword_181E9C, 4);
    sub_9D740((unsigned int)&dword_181EA0, 4);
    sub_9D740((unsigned int)&dword_181E90, 4);
    sub_9D740((unsigned int)&dword_181E98, 4);
    result = sub_9D740((unsigned int)&dword_181E8C, 4);
    dword_E4A90 = 0;
  }
  return result;
}
// A1F90: using guessed type int sub_A1F90();
// E4A8C: using guessed type int dword_E4A8C;
// E4A90: using guessed type int dword_E4A90;
// 181E8C: using guessed type int dword_181E8C;
// 181E90: using guessed type int dword_181E90;
// 181E94: using guessed type int dword_181E94;
// 181E98: using guessed type int dword_181E98;
// 181E9C: using guessed type int dword_181E9C;
// 181EA0: using guessed type int dword_181EA0;

//----- (000A4330) --------------------------------------------------------
bool sub_A4330()
{
  bool result; // eax

  if ( !dword_E4A94 )
  {
    result = sub_9D590((unsigned int)sub_A4330, (unsigned int)sub_A4CB0);
    dword_E4A94 = 1;
  }
  return result;
}
// E4A94: using guessed type int dword_E4A94;

//----- (000A4370) --------------------------------------------------------
int __cdecl sub_A4370(_DWORD *a1)
{
  return *a1 >> 8;
}

//----- (000A4390) --------------------------------------------------------
int __cdecl sub_A4390(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 2164) )
    (*(void (__cdecl **)(int))(a1 + 2164))(a1);
  if ( *(int *)(a1 + 2188) > 0 )
    sub_937A0(a1);
  result = a1;
  *(_DWORD *)(a1 + 2188) = -1;
  return result;
}

//----- (000A43E0) --------------------------------------------------------
void __cdecl sub_A43E0(int *a1, int a2)
{
  int v2; // eax
  int v3; // edx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // [esp+4h] [ebp-8h]
  int v8; // [esp+8h] [ebp-4h]

  v8 = 0;
  while ( !v8 )
  {
    v7 = a1[542];
    switch ( *(_BYTE *)v7 )
    {
      case 0:
        sub_A4390((int)a1);
        return;
      case 1:
        if ( a1[546] )
        {
          v2 = sub_A4370((_DWORD *)v7);
          sub_93A10(a1, v7 + 6, v2 - 2);
          sub_93D90((int)a1, (unsigned int)&unk_F4240 / (256 - (unsigned int)*(unsigned __int8 *)(v7 + 4)));
          sub_93AB0(a1, 0, 0);
          if ( a2 )
            sub_93B50(a1);
          v8 = 1;
        }
        goto LABEL_44;
      case 4:
        if ( a1[545] != -1 )
          a1[546] = *(__int16 *)(v7 + 4) == a1[545];
        goto LABEL_44;
      case 6:
        a1[543] = v7;
        a1[544] = *(unsigned __int16 *)(v7 + 4);
        goto LABEL_44;
      case 7:
        if ( a1[544] != 0xFFFF )
        {
          v3 = a1[544];
          a1[544] = v3 - 1;
          if ( !v3 )
            goto LABEL_44;
        }
        v7 = a1[543];
        v4 = sub_A4370((_DWORD *)v7);
        break;
      case 8:
        if ( a1[546] )
        {
          if ( *(_BYTE *)(v7 + 7) )
          {
            sub_93AB0(a1, 2, 0);
            sub_93D90((int)a1, 0x7A12000 / ((unsigned int)sub_10000 - *(unsigned __int16 *)(v7 + 4)));
          }
          else
          {
            sub_93AB0(a1, 0, 0);
            sub_93D90((int)a1, 0xF424000 / ((unsigned int)sub_10000 - *(unsigned __int16 *)(v7 + 4)));
          }
          v7 += sub_A4370((_DWORD *)v7) + 4;
          v5 = sub_A4370((_DWORD *)v7);
          sub_93A10(a1, v7 + 6, v5 - 2);
          if ( a2 )
            sub_93B50(a1);
          v8 = 1;
        }
        goto LABEL_44;
      case 9:
        if ( a1[546] )
        {
          v6 = sub_A4370((_DWORD *)v7);
          sub_93A10(a1, v7 + 16, v6 - 12);
          sub_93D90((int)a1, *(_DWORD *)(v7 + 4));
          if ( *(_BYTE *)(v7 + 9) == 1 && !*(_WORD *)(v7 + 10) )
          {
            sub_93AB0(a1, 0, 0);
          }
          else if ( *(_BYTE *)(v7 + 9) == 2 && !*(_WORD *)(v7 + 10) )
          {
            sub_93AB0(a1, 2, 0);
          }
          else if ( *(_BYTE *)(v7 + 9) == 1 && *(_WORD *)(v7 + 10) == 4 )
          {
            sub_93AB0(a1, 1, 1);
          }
          else if ( *(_BYTE *)(v7 + 9) == 2 && *(_WORD *)(v7 + 10) == 4 )
          {
            sub_93AB0(a1, 3, 1);
          }
          if ( a2 )
            sub_93B50(a1);
          v8 = 1;
        }
        goto LABEL_44;
      default:
LABEL_44:
        v4 = sub_A4370((_DWORD *)v7);
        break;
    }
    a1[542] = v4 + v7 + 4;
  }
}
// 10000: using guessed type void __noreturn sub_10000();

//----- (000A47C0) --------------------------------------------------------
_DWORD *__cdecl sub_A47C0(int a1, int *a2)
{
  int i; // eax
  int j; // eax
  int v5; // [esp+0h] [ebp-8h]
  int v6; // [esp+4h] [ebp-4h]

  v6 = a1 + 12;
  for ( i = strnicmp(a1 + 12, aFmt, 4); i; i = strnicmp(v6, aFmt, 4) )
    v6 += (*(_DWORD *)(v6 + 4) & 1) + *(_DWORD *)(v6 + 4) + 8;
  if ( *(_WORD *)(v6 + 10) == 1 && *(_WORD *)(v6 + 22) == 8 )
  {
    sub_93AB0(a2, 0, 0);
  }
  else if ( *(_WORD *)(v6 + 10) == 2 && *(_WORD *)(v6 + 22) == 8 )
  {
    sub_93AB0(a2, 2, 0);
  }
  else if ( *(_WORD *)(v6 + 10) == 1 && *(_WORD *)(v6 + 22) == 16 )
  {
    sub_93AB0(a2, 1, 1);
  }
  else if ( *(_WORD *)(v6 + 10) == 2 && *(_WORD *)(v6 + 22) == 16 )
  {
    sub_93AB0(a2, 3, 1);
  }
  sub_93D90((int)a2, *(_DWORD *)(v6 + 12));
  v5 = a1 + 12;
  for ( j = strnicmp(a1 + 12, aData_0, 4); j; j = strnicmp(v5, aData_0, 4) )
    v5 += (*(_DWORD *)(v5 + 4) & 1) + *(_DWORD *)(v5 + 4) + 8;
  return sub_93A10(a2, v5 + 8, *(_DWORD *)(v5 + 4));
}
// 99B23: using guessed type _DWORD __cdecl strnicmp(_DWORD, _DWORD, _DWORD);

//----- (000A4970) --------------------------------------------------------
int *__cdecl sub_A4970(int a1, int a2, int a3)
{
  int v5; // [esp+8h] [ebp-8h]
  int *v6; // [esp+Ch] [ebp-4h]

  sub_A4330();
  if ( !strnicmp(a2, aCreative, 8) )
  {
    v5 = 0;
  }
  else
  {
    if ( strnicmp(a2 + 8, aWave, 4) )
    {
      strcpy(&byte_181C90, "Unrecognized digital audio file type\n");
      return 0;
    }
    v5 = 1;
  }
  v6 = sub_93510(a1);
  if ( !v6 )
    return 0;
  sub_93830(v6);
  v6[541] = 0;
  if ( v5 )
  {
    v6[547] = 1;
    sub_95140((int)v6, (int)sub_A4920);
    sub_A47C0(a2, v6);
  }
  else
  {
    v6[542] = *(unsigned __int16 *)(a2 + 20) + a2;
    v6[545] = a3;
    v6[546] = a3 == -1;
    v6[547] = 1;
    sub_95140((int)v6, (int)sub_A47A0);
    sub_A43E0(v6, 0);
  }
  if ( v6[547] != -1 )
    return v6;
  strcpy(&byte_181C90, "Invalid or missing data block\n");
  return 0;
}
// A4A28: conditional instruction was optimized away because %var_8.4==1
// 99B23: using guessed type _DWORD __cdecl strnicmp(_DWORD, _DWORD, _DWORD);
// A47A0: using guessed type int sub_A47A0();
// A4920: using guessed type int sub_A4920();
// 181C90: using guessed type char byte_181C90;

//----- (000A4B20) --------------------------------------------------------
int __cdecl sub_A4B20(int *a1, int a2, int a3)
{
  int v5; // [esp+8h] [ebp-4h]

  if ( !strnicmp(a2, aCreative, 8) )
  {
    v5 = 0;
  }
  else
  {
    if ( strnicmp(a2 + 8, aWave, 4) )
    {
      strcpy(&byte_181C90, "Unrecognized digital audio file type\n");
      return 0;
    }
    v5 = 1;
  }
  if ( v5 )
  {
    a1[547] = 0;
    sub_A47C0(a2, a1);
  }
  else
  {
    a1[542] = *(unsigned __int16 *)(a2 + 20) + a2;
    a1[545] = a3;
    a1[546] = a3 == -1;
    a1[547] = 0;
    sub_A43E0(a1, 0);
  }
  if ( a1[547] != -1 )
    return 1;
  strcpy(&byte_181C90, "Invalid or missing data block\n");
  return 0;
}
// A4B99: conditional instruction was optimized away because %var_4.4==1
// 99B23: using guessed type _DWORD __cdecl strnicmp(_DWORD, _DWORD, _DWORD);
// 181C90: using guessed type char byte_181C90;

//----- (000A4C60) --------------------------------------------------------
int __cdecl sub_A4C60(int a1, int a2)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( !a1 )
    return 0;
  v4 = *(_DWORD *)(a1 + 2164);
  *(_DWORD *)(a1 + 2164) = a2;
  return v4;
}

//----- (000A4CB0) --------------------------------------------------------
bool sub_A4CB0()
{
  bool result; // eax

  if ( dword_E4A94 )
  {
    result = sub_9D650((unsigned int)sub_A4330, (unsigned int)sub_A4CB0);
    dword_E4A94 = 0;
  }
  return result;
}
// A4330: using guessed type int sub_A4330();
// E4A94: using guessed type int dword_E4A94;

//----- (000A4CF0) --------------------------------------------------------
bool sub_A4CF0()
{
  bool result; // eax

  if ( !dword_E4B1C )
  {
    sub_9D590((unsigned int)sub_A4CF0, (unsigned int)sub_A9280);
    sub_9D710((unsigned int)aSample, 128);
    sub_9D710((unsigned int)&dword_E4B18, 4);
    sub_9D710((unsigned int)&dword_181EB8, 4);
    sub_9D710((unsigned int)&dword_181EBC, 4);
    sub_9D710((unsigned int)&dword_181EC0, 4);
    sub_9D710((unsigned int)&dword_181EC4, 4);
    sub_9D710((unsigned int)&dword_181ED4, 4);
    sub_9D710((unsigned int)&dword_181EC8, 4);
    sub_9D710((unsigned int)&dword_181ECC, 4);
    sub_9D710((unsigned int)&dword_181EB4, 4);
    sub_9D710((unsigned int)&dword_181ED0, 4);
    sub_9D710((unsigned int)&dword_181EDC, 4);
    sub_9D710((unsigned int)&dword_181ED8, 4);
    result = sub_9D710((unsigned int)&dword_181EB0, 4);
    dword_E4B1C = 1;
  }
  return result;
}
// E4B18: using guessed type int dword_E4B18;
// E4B1C: using guessed type int dword_E4B1C;
// 181EB0: using guessed type int dword_181EB0;
// 181EB4: using guessed type int dword_181EB4;
// 181EB8: using guessed type int dword_181EB8;
// 181EBC: using guessed type int dword_181EBC;
// 181EC0: using guessed type int dword_181EC0;
// 181EC4: using guessed type int dword_181EC4;
// 181EC8: using guessed type int dword_181EC8;
// 181ECC: using guessed type int dword_181ECC;
// 181ED0: using guessed type int dword_181ED0;
// 181ED4: using guessed type int dword_181ED4;
// 181ED8: using guessed type int dword_181ED8;
// 181EDC: using guessed type int dword_181EDC;

//----- (000A4E10) --------------------------------------------------------
int __cdecl sub_A4E10(char a1)
{
  unsigned int v2; // [esp+0h] [ebp-8h]

  v2 = a1 & 0xF0;
  if ( v2 < 0xB0 )
  {
    if ( v2 < 0x90 )
    {
      if ( v2 != 128 )
        return 0;
    }
    else if ( v2 > 0x90 && v2 != 160 )
    {
      return 0;
    }
    return 3;
  }
  if ( v2 > 0xB0 )
  {
    if ( v2 < 0xD0 )
    {
      if ( v2 != 192 )
        return 0;
    }
    else if ( v2 > 0xD0 )
    {
      if ( v2 != 224 )
        return 0;
      return 3;
    }
    return 2;
  }
  return 3;
}

//----- (000A4EB0) --------------------------------------------------------
int __cdecl sub_A4EB0(int a1)
{
  int result; // eax
  _WORD v2[6]; // [esp+0h] [ebp-Ch] BYREF

  result = a1;
  if ( *(int *)(a1 + 424) > 0 )
  {
    v2[2] = *(_WORD *)(a1 + 424);
    sub_91F70(*(_DWORD *)a1, 1282, v2, 0);
    *(_DWORD *)(a1 + 424) = 0;
    result = a1;
    *(_DWORD *)(a1 + 428) = 0;
  }
  return result;
}

//----- (000A4F10) --------------------------------------------------------
_DWORD *__cdecl sub_A4F10(_DWORD *a1, char a2, char a3, char a4)
{
  int v4; // ebx
  int v5; // edx
  int v6; // ebx
  int v7; // edx
  int v8; // ebx
  int v9; // edx
  _DWORD *result; // eax
  int v11; // [esp+0h] [ebp-4h]

  v11 = sub_A4E10(a2);
  if ( (unsigned int)(v11 + a1[107]) > 0x200 )
    sub_A4EB0((int)a1);
  v4 = a1[2];
  v5 = a1[107];
  a1[107] = v5 + 1;
  *(_BYTE *)(v4 + v5 + 256) = a2;
  v6 = a1[2];
  v7 = a1[107];
  a1[107] = v7 + 1;
  *(_BYTE *)(v6 + v7 + 256) = a3;
  if ( v11 == 3 )
  {
    v8 = a1[2];
    v9 = a1[107];
    a1[107] = v9 + 1;
    *(_BYTE *)(v8 + v9 + 256) = a4;
  }
  result = a1;
  ++a1[106];
  return result;
}

//----- (000A4FD0) --------------------------------------------------------
int __cdecl sub_A4FD0(int a1, int a2, unsigned int a3)
{
  sub_A4EB0(a1);
  if ( a3 <= 0x200 )
    memmove(*(_DWORD *)(a1 + 8) + 256, a2, a3);
  else
    memmove(*(_DWORD *)(a1 + 8) + 256, a2, 512);
  ++*(_DWORD *)(a1 + 424);
  return sub_A4EB0(a1);
}
// AD81F: using guessed type _DWORD __cdecl memmove(_DWORD, _DWORD, _DWORD);

//----- (000A5040) --------------------------------------------------------
int __cdecl sub_A5040(_DWORD *a1)
{
  int v2; // [esp+4h] [ebp-Ch]
  char v3; // [esp+8h] [ebp-8h]
  int v4; // [esp+Ch] [ebp-4h]

  v4 = 0;
  v2 = 4;
  do
  {
    v3 = *(_BYTE *)(*a1)++;
    v4 = v3 & 0x7F | (v4 << 7);
    if ( (v3 & 0x80) == 0 )
      break;
    --v2;
  }
  while ( v2 );
  return v4;
}

//----- (000A50A0) --------------------------------------------------------
unsigned int __cdecl sub_A50A0(int a1)
{
  return ((a1 & 0xFF000000) >> 24) + ((a1 & 0xFF0000u) >> 8) + ((a1 & 0xFF00) << 8) + ((unsigned __int8)a1 << 24);
}

//----- (000A50F0) --------------------------------------------------------
unsigned int __cdecl sub_A50F0(int a1, int a2)
{
  unsigned int v4; // [esp+4h] [ebp-8h]
  unsigned int v5; // [esp+8h] [ebp-4h]
  unsigned int i; // [esp+1Ch] [ebp+10h]

  v5 = 0;
  do
  {
    a1 += v5;
    if ( strncmp(a1, aForm, 4) && strncmp(a1, aCat, 4) )
      return 0;
    v5 = sub_A50A0(*(_DWORD *)(a1 + 4)) + 8;
  }
  while ( strncmp(a1 + 8, aXmid, 4) );
  if ( !strncmp(a1, aForm, 4) )
  {
    if ( a2 )
      return 0;
    else
      return a1;
  }
  else
  {
    v4 = v5 + a1;
    for ( i = a1 + 12; i < v4; i += sub_A50A0(*(_DWORD *)(i + 4)) + 8 )
    {
      if ( !strncmp(i + 8, aXmid, 4) && --a2 == -1 )
        return i;
    }
    return 0;
  }
}
// 99682: using guessed type _DWORD __cdecl strncmp(_DWORD, _DWORD, _DWORD);

//----- (000A5210) --------------------------------------------------------
int __cdecl sub_A5210(int a1, char a2, unsigned int a3)
{
  int v5; // [esp+4h] [ebp-8h]
  unsigned int v6; // [esp+8h] [ebp-4h]

  v6 = a2 & 0xF0;
  v5 = a2 & 0xF;
  if ( v6 < 0xC0 )
  {
    if ( v6 != 176 )
      return -1;
    if ( a3 < 0x5D )
    {
      if ( a3 < 0xA )
      {
        if ( a3 < 6 )
        {
          if ( a3 == 1 )
            return *(_DWORD *)(a1 + 4 * v5 + 640);
        }
        else
        {
          if ( a3 <= 6 )
            return *(_DWORD *)(a1 + 4 * v5 + 1088);
          if ( a3 == 7 )
            return *(_DWORD *)(a1 + 4 * v5 + 704);
        }
      }
      else
      {
        if ( a3 <= 0xA )
          return *(_DWORD *)(a1 + 4 * v5 + 768);
        if ( a3 < 0x40 )
        {
          if ( a3 == 11 )
            return *(_DWORD *)(a1 + 4 * v5 + 832);
        }
        else
        {
          if ( a3 <= 0x40 )
            return *(_DWORD *)(a1 + 4 * v5 + 896);
          if ( a3 == 91 )
            return *(_DWORD *)(a1 + 4 * v5 + 960);
        }
      }
    }
    else
    {
      if ( a3 <= 0x5D )
        return *(_DWORD *)(a1 + 4 * v5 + 1024);
      if ( a3 < 0x70 )
      {
        if ( a3 >= 0x6E )
        {
          if ( a3 <= 0x6E )
            return *(_DWORD *)(a1 + 4 * v5 + 192);
          else
            return *(_DWORD *)(a1 + 4 * v5 + 256);
        }
        if ( a3 == 107 )
          return *(_DWORD *)(a1 + 4 * v5 + 320);
      }
      else
      {
        if ( a3 <= 0x70 )
          return *(_DWORD *)(a1 + 4 * v5 + 384);
        if ( a3 < 0x73 )
        {
          if ( a3 == 114 )
            return *(_DWORD *)(a1 + 4 * v5 + 448);
        }
        else
        {
          if ( a3 <= 0x73 )
            return *(_DWORD *)(a1 + 4 * v5 + 512);
          if ( a3 == 119 )
            return *(_DWORD *)(a1 + 4 * v5 + 576);
        }
      }
    }
    return -1;
  }
  if ( v6 <= 0xC0 )
    return *(_DWORD *)(a1 + 4 * v5);
  if ( v6 != 224 )
    return -1;
  return (*(_DWORD *)(a1 + 4 * v5 + 128) << 7) | *(_DWORD *)(a1 + 4 * v5 + 64);
}

//----- (000A5530) --------------------------------------------------------
int __cdecl sub_A5530(int a1, char a2, unsigned int a3, unsigned __int8 a4)
{
  int result; // eax
  unsigned int v5; // [esp+4h] [ebp-4h]

  v5 = a2 & 0xF0;
  result = a2 & 0xF;
  if ( v5 < 0xC0 )
  {
    if ( v5 == 176 )
    {
      if ( a3 < 0x5D )
      {
        if ( a3 < 0xA )
        {
          if ( a3 < 6 )
          {
            if ( a3 == 1 )
            {
              result = a1 + 4 * result;
              *(_DWORD *)(result + 640) = a4;
            }
          }
          else if ( a3 <= 6 )
          {
            result = a1 + 4 * result;
            *(_DWORD *)(result + 1088) = a4;
          }
          else if ( a3 == 7 )
          {
            result = a1 + 4 * result;
            *(_DWORD *)(result + 704) = a4;
          }
        }
        else if ( a3 <= 0xA )
        {
          result = a1 + 4 * result;
          *(_DWORD *)(result + 768) = a4;
        }
        else if ( a3 < 0x40 )
        {
          if ( a3 == 11 )
          {
            result = a1 + 4 * result;
            *(_DWORD *)(result + 832) = a4;
          }
        }
        else if ( a3 <= 0x40 )
        {
          result = a1 + 4 * result;
          *(_DWORD *)(result + 896) = a4;
        }
        else if ( a3 == 91 )
        {
          result = a1 + 4 * result;
          *(_DWORD *)(result + 960) = a4;
        }
      }
      else if ( a3 <= 0x5D )
      {
        result = a1 + 4 * result;
        *(_DWORD *)(result + 1024) = a4;
      }
      else if ( a3 < 0x70 )
      {
        if ( a3 < 0x6E )
        {
          if ( a3 == 107 )
          {
            result = a1 + 4 * result;
            *(_DWORD *)(result + 320) = a4;
          }
        }
        else
        {
          result = a1 + 4 * result;
          if ( a3 <= 0x6E )
            *(_DWORD *)(result + 192) = a4;
          else
            *(_DWORD *)(result + 256) = a4;
        }
      }
      else if ( a3 <= 0x70 )
      {
        result = a1 + 4 * result;
        *(_DWORD *)(result + 384) = a4;
      }
      else if ( a3 < 0x73 )
      {
        if ( a3 == 114 )
        {
          result = a1 + 4 * result;
          *(_DWORD *)(result + 448) = a4;
        }
      }
      else if ( a3 <= 0x73 )
      {
        result = a1 + 4 * result;
        *(_DWORD *)(result + 512) = a4;
      }
      else if ( a3 == 119 )
      {
        result = a1 + 4 * result;
        *(_DWORD *)(result + 576) = a4;
      }
    }
  }
  else if ( v5 <= 0xC0 )
  {
    result = a1 + 4 * result;
    *(_DWORD *)result = (unsigned __int8)a3;
  }
  else if ( v5 == 224 )
  {
    *(_DWORD *)(a1 + 4 * result + 64) = (unsigned __int8)a3;
    result = a1 + 4 * result;
    *(_DWORD *)(result + 128) = a4;
  }
  return result;
}

//----- (000A5850) --------------------------------------------------------
_DWORD *__cdecl sub_A5850(int a1, char a2, unsigned int a3, int a4, int a5)
{
  _DWORD *result; // eax
  int v6; // eax
  _DWORD *v7; // [esp+0h] [ebp-14h]
  int v8; // [esp+4h] [ebp-10h]
  unsigned int v9; // [esp+8h] [ebp-Ch]
  int i; // [esp+Ch] [ebp-8h]
  int j; // [esp+Ch] [ebp-8h]
  _DWORD *v12; // [esp+Ch] [ebp-8h]
  int v13; // [esp+10h] [ebp-4h]

  v7 = *(_DWORD **)a1;
  v13 = a2 & 0xF0;
  v8 = a2 & 0xF;
  result = *(_DWORD **)(a1 + 4 * v8 + 148);
  v9 = (unsigned int)result;
  if ( v13 == 176 || v13 == 192 || v13 == 224 )
    result = (_DWORD *)sub_A5530(a1 + 212, v8 | v13, a3, a4);
  if ( v13 != 176 )
    goto LABEL_76;
  if ( a5 )
  {
    result = (_DWORD *)(a1 + 4 * v8);
    if ( result[181] != -1 )
    {
      a4 = *(_DWORD *)(a1 + 4 * v8 + 724);
      result = (_DWORD *)(a1 + 4 * v8);
      result[181] = -1;
    }
  }
  if ( a3 < 0x6F )
  {
    if ( a3 < 0x6C )
    {
      if ( a3 >= 6 )
      {
        if ( a3 <= 6 )
        {
          sub_A5850(a1, a2 & 0xF | 0xB0, 100, 0, 0);
          sub_A5850(a1, a2 & 0xF | 0xB0, 101, 0, 0);
          sub_A5850(a1, a2 & 0xF | 0xB0, 38, 0, 0);
        }
        else if ( a3 == 7 )
        {
          a4 = *(_DWORD *)(a1 + 56) * a4 * v7[108] / 16129;
          if ( a4 > 127 )
            a4 = 127;
          if ( a4 < 0 )
            a4 = 0;
        }
      }
      goto LABEL_76;
    }
    if ( a3 <= 0x6C )
    {
      if ( *(_DWORD *)(a1 + 28) )
        *(_DWORD *)(a1 + 4 * v8 + 724) = (*(int (__cdecl **)(int, int, int))(a1 + 28))(a1, v8, a4);
      goto LABEL_76;
    }
    if ( a3 <= 0x6D )
    {
      return sub_97480((_DWORD *)a1, a4);
    }
    else if ( a4 < 64 )
    {
      result = &v7[v9];
      if ( result[8] == 1 )
      {
        sub_A5F30((int *)a1, v8);
        sub_980D0(v7, v9 + 1);
        return (_DWORD *)sub_98170((_DWORD *)a1, v8 + 1, v8 + 1);
      }
    }
    else
    {
      result = &v7[v9];
      if ( result[8] != 1 )
      {
        result = (_DWORD *)sub_97F90(v7);
        v12 = result;
        if ( result )
        {
          sub_98170((_DWORD *)a1, v8 + 1, (int)result);
          result = (_DWORD *)a1;
          v7[(_DWORD)v12 + 23] = a1;
        }
      }
    }
  }
  else if ( a3 <= 0x6F )
  {
    result = &v7[v9];
    if ( result[8] != 1 )
    {
      result = &v7[v9];
      if ( a4 >= 64 )
        result[8] = 2;
      else
        result[8] = 0;
    }
  }
  else if ( a3 < 0x75 )
  {
    if ( a3 < 0x73 )
      goto LABEL_76;
    if ( a3 <= 0x73 )
    {
      *(_DWORD *)(a1 + 4 * v8 + 724) = *(unsigned __int8 *)(a4 + *(_DWORD *)(a1 + 24));
LABEL_76:
      if ( v7[v9 + 8] != 1 || (result = (_DWORD *)v7[v9 + 24], result == (_DWORD *)a1) )
      {
        if ( v13 == 144 )
        {
          ++v7[v9 + 88];
        }
        else if ( v13 == 128 )
        {
          --v7[v9 + 88];
        }
        v7[v9 + 56] = a1;
        if ( v13 != 144 || (result = (_DWORD *)(a1 + 4 * v8), (int)result[133] < 64) )
        {
          if ( !v7[104] )
            return sub_A4F10(v7, v9 | v13, a3, a4);
          result = (_DWORD *)((int (__cdecl *)(_DWORD *, int, unsigned int, unsigned int, int))v7[104])(
                               v7,
                               a1,
                               v9 | v13,
                               a3,
                               a4);
          if ( !result )
            return sub_A4F10(v7, v9 | v13, a3, a4);
        }
      }
      return result;
    }
    for ( i = 0; i < 4; ++i )
    {
      result = (_DWORD *)(a1 + 4 * i);
      if ( result[33] == -1 )
        break;
      result = (_DWORD *)i;
    }
    if ( i != 4 )
    {
      *(_DWORD *)(4 * i + a1 + 132) = a4;
      result = *(_DWORD **)(a1 + 20);
      *(_DWORD *)(4 * i + a1 + 116) = result;
    }
  }
  else if ( a3 <= 0x75 )
  {
    if ( a4 >= 64 )
    {
      for ( j = 3; j >= 0; --j )
      {
        result = (_DWORD *)(a1 + 4 * j);
        if ( result[33] != -1 )
          break;
        result = (_DWORD *)j;
      }
      if ( j != -1 )
      {
        if ( *(_DWORD *)(a1 + 4 * j + 132) )
        {
          v6 = a1 + 4 * j;
          if ( --*(_DWORD *)(v6 + 132) )
          {
            result = (_DWORD *)a1;
            *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 4 * j + 116);
          }
          else
          {
            result = (_DWORD *)(a1 + 4 * j);
            result[33] = -1;
          }
        }
        else
        {
          result = (_DWORD *)a1;
          *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 4 * j + 116);
        }
      }
    }
  }
  else if ( a3 <= 0x76 )
  {
    *(_DWORD *)(a1 + 92) = 0;
    *(_DWORD *)(a1 + 96) = 0;
    *(_DWORD *)(a1 + 108) = 0;
    *(_DWORD *)(a1 + 108) -= *(_DWORD *)(a1 + 104);
    result = (_DWORD *)a1;
    if ( *(_DWORD *)(a1 + 36) )
      return (_DWORD *)(*(int (__cdecl **)(_DWORD *, int, _DWORD, _DWORD))(a1 + 36))(v7, a1, 0, 0);
  }
  else
  {
    if ( a3 != 119 )
      goto LABEL_76;
    result = (_DWORD *)a1;
    if ( *(_DWORD *)(a1 + 32) )
      return (_DWORD *)(*(int (__cdecl **)(int, int, int))(a1 + 32))(a1, v8, a4);
  }
  return result;
}
// 980D0: using guessed type _DWORD __cdecl sub_980D0(_DWORD, _DWORD);

//----- (000A5E50) --------------------------------------------------------
char __cdecl sub_A5E50(int *a1)
{
  int v1; // eax
  int v3; // [esp+0h] [ebp-8h]
  int i; // [esp+4h] [ebp-4h]

  v3 = 0;
  for ( i = 0; i < 32; ++i )
  {
    if ( a1[i + 342] != -1 )
    {
      sub_A5850((int)a1, a1[i + 342] | 0x80, a1[i + 374], 0, 0);
      a1[i + 342] = -1;
      ++v3;
    }
  }
  a1[341] = 0;
  LOBYTE(v1) = sub_A4EB0(*a1);
  if ( v3 )
  {
    v1 = sub_92160();
    if ( !v1 )
      LOBYTE(v1) = sub_920D0(3);
  }
  return v1;
}

//----- (000A5F30) --------------------------------------------------------
int __cdecl sub_A5F30(int *a1, int a2)
{
  int v2; // eax
  int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 32; ++i )
  {
    if ( a1[i + 342] == a2 )
    {
      v2 = a1[i + 342];
      LOBYTE(v2) = v2 | 0x80;
      sub_A5850(a1, v2, a1[i + 374], 0, 0);
      a1[i + 342] = -1;
    }
  }
  return sub_A4EB0(*a1);
}
// A5850: using guessed type _DWORD __cdecl sub_A5850(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000A5FD0) --------------------------------------------------------
_DWORD *__cdecl sub_A5FD0(int a1, int a2)
{
  _DWORD *result; // eax

  if ( *(_DWORD *)(a1 + 4 * a2 + 660) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0x72u, *(_DWORD *)(a1 + 4 * a2 + 660), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 212) != -1 )
    sub_A5850(a1, a2 | 0xC0, *(_DWORD *)(a1 + 4 * a2 + 212), 0, 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 340) != -1 )
    sub_A5850(a1, a2 | 0xE0, *(_DWORD *)(a1 + 4 * a2 + 276), *(_DWORD *)(a1 + 4 * a2 + 340), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 532) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0x6Bu, *(_DWORD *)(a1 + 4 * a2 + 532), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 468) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0x6Fu, *(_DWORD *)(a1 + 4 * a2 + 468), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 596) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0x70u, *(_DWORD *)(a1 + 4 * a2 + 596), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 852) != -1 )
    sub_A5850(a1, a2 | 0xB0, 1u, *(_DWORD *)(a1 + 4 * a2 + 852), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 916) != -1 )
    sub_A5850(a1, a2 | 0xB0, 7u, *(_DWORD *)(a1 + 4 * a2 + 916), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 980) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0xAu, *(_DWORD *)(a1 + 4 * a2 + 980), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 1044) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0xBu, *(_DWORD *)(a1 + 4 * a2 + 1044), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 1108) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0x40u, *(_DWORD *)(a1 + 4 * a2 + 1108), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 1172) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0x5Bu, *(_DWORD *)(a1 + 4 * a2 + 1172), 0);
  if ( *(_DWORD *)(a1 + 4 * a2 + 1236) != -1 )
    sub_A5850(a1, a2 | 0xB0, 0x5Du, *(_DWORD *)(a1 + 4 * a2 + 1236), 0);
  result = (_DWORD *)(a1 + 4 * a2);
  if ( result[325] != -1 )
    return sub_A5850(a1, a2 | 0xB0, 6u, *(_DWORD *)(a1 + 4 * a2 + 1300), 0);
  return result;
}

//----- (000A6370) --------------------------------------------------------
_DWORD *__cdecl sub_A6370(_DWORD *a1)
{
  _DWORD *result; // eax
  int i; // [esp+0h] [ebp-4h]
  int j; // [esp+0h] [ebp-4h]
  int k; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 16; ++i )
    a1[i + 37] = i;
  memset(a1 + 53, -1, 1152);
  for ( j = 0; j < 4; ++j )
    a1[j + 33] = -1;
  for ( k = 0; k < 32; ++k )
    a1[k + 342] = -1;
  a1[341] = 0;
  a1[12] = 0;
  a1[23] = 0;
  a1[24] = -1;
  a1[27] = 0;
  a1[26] = 0;
  a1[25] = 4;
  a1[28] = 8000000;
  result = a1;
  a1[13] = 0;
  return result;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);

//----- (000A6490) --------------------------------------------------------
_DWORD *__cdecl sub_A6490(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_A6370(a1);
  result = a1;
  a1[5] = a1[4] + 8;
  return result;
}

//----- (000A64C0) --------------------------------------------------------
int __cdecl sub_A64C0(int a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 16; ++i )
  {
    if ( *(_DWORD *)(a1 + 4 * i + 916) != -1 )
      sub_A5850(a1, i | 0xB0, 7u, *(_DWORD *)(a1 + 4 * i + 916), 0);
    result = i;
  }
  return result;
}

//----- (000A6E00) --------------------------------------------------------
int __cdecl sub_A6E00(int *a1, const void *a2)
{
  _DWORD v3[6]; // [esp+0h] [ebp-24h] BYREF
  unsigned int i; // [esp+1Ch] [ebp-8h]
  _WORD *v5; // [esp+20h] [ebp-4h]

  qmemcpy(v3, a2, sizeof(v3));
  if ( *(_WORD *)(*(_DWORD *)(*a1 + 16) + 16) )
  {
    v5 = (_WORD *)((unsigned __int16)*(_DWORD *)(*(_DWORD *)(*a1 + 16) + 12)
                 + 16 * HIWORD(*(_DWORD *)(*(_DWORD *)(*a1 + 16) + 12)));
    if ( SLOWORD(v3[0]) < 1 )
      LOWORD(v3[0]) = *v5;
    if ( SHIWORD(v3[0]) < 1 )
      HIWORD(v3[0]) = v5[1];
    if ( SLOWORD(v3[1]) < 1 )
      LOWORD(v3[1]) = v5[2];
    if ( SHIWORD(v3[1]) < 1 )
      HIWORD(v3[1]) = v5[3];
    for ( i = 0; i < 4; ++i )
    {
      if ( (int)v3[i + 2] < 1 )
        v3[i + 2] = *(_DWORD *)&v5[2 * i + 4];
    }
  }
  qmemcpy((void *)(*(_DWORD *)(*a1 + 16) + 22), v3, 0x18u);
  return sub_91F70(*a1, 772, 0, 0);
}

//----- (000A6FB0) --------------------------------------------------------
int *__cdecl sub_A6FB0(int a1, const void *a2)
{
  __int64 v2; // rtt
  unsigned int v3; // eax
  char v5[24]; // [esp+0h] [ebp-3Ch] BYREF
  __int16 v6[6]; // [esp+18h] [ebp-24h] BYREF
  _BYTE *v8; // [esp+28h] [ebp-14h]
  int *v9; // [esp+2Ch] [ebp-10h]
  int v10; // [esp+30h] [ebp-Ch]
  int i; // [esp+34h] [ebp-8h]
  _BYTE *v12; // [esp+38h] [ebp-4h]
  void *v13; // [esp+50h] [ebp+14h]
  const void *v14; // [esp+50h] [ebp+14h]

  sub_A4CF0();
  v9 = (int *)sub_9D450(468);
  if ( v9 )
  {
    *v9 = a1;
    if ( *(_DWORD *)(*v9 + 20) == 1 )
    {
      sub_91F70(*v9, 769, 0, v6);
      v9[1] = (unsigned __int16)v6[0] + 16 * (unsigned __int16)v6[3];
      v9[2] = (unsigned __int16)v6[1] + 16 * (unsigned __int16)v6[2];
      v8 = (_BYTE *)((unsigned __int16)*(_DWORD *)v9[1] + 16 * HIWORD(*(_DWORD *)v9[1]));
      if ( v8 )
      {
        if ( *v8 )
        {
          v12 = (_BYTE *)getenv(v8);
          if ( v12 )
          {
            if ( *v12 )
              strncpy(v9[2], v12, 128);
          }
        }
      }
      v8 = (_BYTE *)((unsigned __int16)*(_DWORD *)(v9[1] + 4) + 16 * HIWORD(*(_DWORD *)(v9[1] + 4)));
      if ( v8 && *v8 )
      {
        strcpy(v9[2] + 128, aSample);
        strcat(v9[2] + 128, v8);
      }
      else
      {
        *(_BYTE *)(v9[2] + 128) = 0;
      }
      memset(&unk_181D90, -1, 24);
      v10 = 0;
      if ( a2 )
      {
        qmemcpy(&unk_181D90, a2, 0x18u);
        if ( sub_A6E00(v9, a2) )
        {
          v10 = 1;
          qmemcpy(v5, a2, sizeof(v5));
        }
      }
      if ( !v10 )
      {
        v13 = sub_92ED0(*v9);
        if ( v13 )
        {
          qmemcpy(&unk_181D90, v13, 0x18u);
          if ( sub_A6E00(v9, v13) )
          {
            v10 = 1;
            qmemcpy(v5, v13, sizeof(v5));
          }
        }
      }
      if ( !v10 && dword_181DF0 == 1 )
      {
        for ( i = 0; *(unsigned __int16 *)(*(_DWORD *)(*v9 + 16) + 16) > i; ++i )
        {
          v14 = (const void *)(24 * i
                             + (unsigned __int16)*(_DWORD *)(*(_DWORD *)(*v9 + 16) + 12)
                             + 16 * HIWORD(*(_DWORD *)(*(_DWORD *)(*v9 + 16) + 12)));
          if ( !i )
            qmemcpy(&unk_181D90, v14, 0x18u);
          if ( sub_A6E00(v9, v14) )
          {
            v10 = 1;
            qmemcpy(v5, v14, sizeof(v5));
            break;
          }
        }
      }
      if ( v10 )
      {
        qmemcpy(&unk_181D90, v5, 0x18u);
        sub_91F70(*v9, 773, 0, 0);
        *(_DWORD *)(*v9 + 24) = 1;
        sub_91F70(*v9, 1281, 0, v6);
        if ( v6[0] )
        {
          v9[7] = dword_181DDC;
          v9[6] = sub_9D450(1816 * v9[7]);
          if ( v9[6] )
          {
            for ( i = 0; i < v9[7]; ++i )
            {
              *(_DWORD *)(1816 * i + v9[6] + 4) = 1;
              *(_DWORD *)(v9[6] + 1816 * i) = v9;
            }
            v9[104] = 0;
            v9[105] = 0;
            v9[106] = 0;
            v9[107] = 0;
            LODWORD(v2) = &unk_F4240;
            HIDWORD(v2) = (int)&unk_F4240 >> 31;
            v9[4] = v2 / dword_181DD8;
            v9[5] = 0;
            v9[108] = 127;
            for ( i = 0; i < 16; ++i )
            {
              v9[i + 8] = 0;
              v9[i + 24] = 0;
              v9[i + 40] = 0;
              v9[i + 56] = 0;
              v9[i + 72] = 0;
              v9[i + 88] = 0;
            }
            v3 = sub_92600((int)sub_A6530);
            v9[3] = v3;
            if ( v9[3] == -1 )
            {
              strcpy(&byte_181C90, "Out of timer handles\n");
              sub_91F70(*v9, 774, 0, 0);
              *(_DWORD *)(*v9 + 24) = 0;
              sub_9D490(v9[6], 1816 * v9[7]);
              sub_9D490((unsigned int)v9, 468);
              return 0;
            }
            else
            {
              sub_92740(v9[3], (__int32)v9);
              *(_DWORD *)(*v9 + 36) = sub_A6F30;
              *(_DWORD *)(*v9 + 40) = v9;
              for ( i = 0; i < 16; ++i )
              {
                sub_A4F10(v9, i | 0xB0, 114, 0);
                sub_A4F10(v9, i | 0xC0, 0, 0);
                sub_A4F10(v9, i | 0xE0, 0, 64);
                sub_A4F10(v9, i | 0xB0, 112, 0);
                sub_A4F10(v9, i | 0xB0, 1, 0);
                sub_A4F10(v9, i | 0xB0, 7, dword_181DE0);
                sub_A4F10(v9, i | 0xB0, 10, 64);
                sub_A4F10(v9, i | 0xB0, 11, 127);
                sub_A4F10(v9, i | 0xB0, 64, 0);
                sub_A4F10(v9, i | 0xB0, 91, 40);
                sub_A4F10(v9, i | 0xB0, 93, 0);
                sub_A4F10(v9, i | 0xB0, 100, 0);
                sub_A4F10(v9, i | 0xB0, 101, 0);
                sub_A4F10(v9, i | 0xB0, 38, 0);
                sub_A4F10(v9, i | 0xB0, 6, dword_181DEC);
                sub_A4EB0((int)v9);
                if ( (i & 3) == 0 )
                  sub_920D0(3);
              }
              sub_92930(v9[3], dword_181DD8);
              sub_92BA0(v9[3]);
              return v9;
            }
          }
          else
          {
            strcpy(&byte_181C90, "Could not allocate SEQUENCE structures\n");
            sub_91F70(*v9, 774, 0, 0);
            *(_DWORD *)(*v9 + 24) = 0;
            sub_9D490((unsigned int)v9, 468);
            return 0;
          }
        }
        else
        {
          strcpy(&byte_181C90, "Could not initialize instrument manager\n");
          sub_91F70(*v9, 774, 0, 0);
          *(_DWORD *)(*v9 + 24) = 0;
          sub_9D490((unsigned int)v9, 468);
          return 0;
        }
      }
      else
      {
        strcpy(&byte_181C90, "XMIDI sound hardware not found\n");
        sub_9D490((unsigned int)v9, 468);
        return 0;
      }
    }
    else
    {
      strcpy(&byte_181C90, ".MDI driver required\n");
      sub_9D490((unsigned int)v9, 468);
      return 0;
    }
  }
  else
  {
    strcpy(&byte_181C90, "Could not allocate memory for driver\n");
    return 0;
  }
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// 99D84: using guessed type _DWORD __cdecl strcat(_DWORD, _DWORD);
// 99E33: using guessed type _DWORD __cdecl getenv(_DWORD);
// A6530: using guessed type int sub_A6530();
// A6F30: using guessed type int sub_A6F30();
// AD871: using guessed type _DWORD __cdecl strncpy(_DWORD, _DWORD, _DWORD);
// 181C90: using guessed type char byte_181C90;
// 181DD8: using guessed type int dword_181DD8;
// 181DDC: using guessed type int dword_181DDC;
// 181DE0: using guessed type int dword_181DE0;
// 181DEC: using guessed type int dword_181DEC;
// 181DF0: using guessed type int dword_181DF0;

//----- (000A77D0) --------------------------------------------------------
int *__usercall sub_A77D0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, const void *a4)
{
  int v4; // eax
  int v7; // [esp+4h] [ebp-Ch]
  int *v8; // [esp+8h] [ebp-8h]
  _DWORD *v9; // [esp+Ch] [ebp-4h]

  v7 = sub_9DEA0(a3, 0);
  if ( v7 )
  {
    v4 = sub_9DE20(a3);
    v9 = sub_93010(a1, a2, v7, v4);
    off_E3E34(v7);
    if ( v9 )
    {
      v8 = sub_A6FB0((int)v9, a4);
      if ( !v8 )
        sub_93160((unsigned int)v9);
      return v8;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    strcpy(&byte_181C90, "Driver file not found\n");
    return 0;
  }
}
// E3E34: using guessed type int (__cdecl *off_E3E34)(int);
// 181C90: using guessed type char byte_181C90;

//----- (000A7880) --------------------------------------------------------
int *__usercall sub_A7880@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, const void *a5)
{
  int *v7; // [esp+4h] [ebp-8h]
  _DWORD *v8; // [esp+8h] [ebp-4h]

  v8 = sub_93010(a1, a2, a3, a4);
  if ( !v8 )
    return 0;
  v7 = sub_A6FB0((int)v8, a5);
  if ( !v7 )
    sub_93160((unsigned int)v8);
  return v7;
}

//----- (000A78F0) --------------------------------------------------------
int __usercall sub_A78F0@<eax>(int a1@<ecx>, int a2@<ebx>, int **a3)
{
  char v4[128]; // [esp+0h] [ebp-11Ch] BYREF
  char v5[128]; // [esp+80h] [ebp-9Ch] BYREF
  char v6[24]; // [esp+100h] [ebp-1Ch] BYREF

  if ( sub_92190((int)v4, aMdiIni_0) )
  {
    *a3 = sub_95850(a1, a2, v5, v6);
    if ( *a3 )
      return 0;
    else
      return 2;
  }
  else
  {
    strcpy(&byte_181C90, "Unable to open file MDI.INI\n");
    return 1;
  }
}
// 181C90: using guessed type char byte_181C90;
// A78F0: using guessed type char var_11C[128];
// A78F0: using guessed type char var_1C[24];
// A78F0: using guessed type char var_9C[128];

//----- (000A7970) --------------------------------------------------------
int __cdecl sub_A7970(unsigned int *a1)
{
  return sub_93160(*a1);
}

//----- (000A7990) --------------------------------------------------------
int __cdecl sub_A7990(_DWORD *a1)
{
  int v3; // [esp+4h] [ebp-4h]
  _BYTE *v4; // [esp+4h] [ebp-4h]

  if ( *(_DWORD *)(*(_DWORD *)(*a1 + 16) + 8) >= 0x112u )
  {
    v3 = *(_DWORD *)(*a1 + 16) + 186;
    if ( !stricmp(v3, aTandy3VoiceMus) )
      return 3;
    if ( !stricmp(v3, aIbmInternalSpe) )
      return 3;
  }
  v4 = (_BYTE *)((unsigned __int16)*(_DWORD *)(a1[1] + 4) + 16 * HIWORD(*(_DWORD *)(a1[1] + 4)));
  if ( !v4 || !*v4 )
    return 0;
  if ( !stricmp(v4, &aMAd[1]) )
    return *(_DWORD *)(*a1 + 12) <= 0x5000u;
  if ( !stricmp(v4, aOpl) )
    return 2;
  return 0;
}
// 98F5D: using guessed type _DWORD __cdecl stricmp(_DWORD, _DWORD);

//----- (000A7AA0) --------------------------------------------------------
int __cdecl sub_A7AA0(int a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  strcpy(aSample, a1);
  result = strlen(aSample) - 1;
  for ( i = result; i; --i )
  {
    if ( aSample[i] == 92 )
    {
      result = strlen(aSample) - 1;
      if ( result == i )
      {
        result = i;
        aSample[i] = 0;
      }
      return result;
    }
    if ( aSample[i] == 46 )
    {
      result = i;
      aSample[i] = 0;
      return result;
    }
    result = i;
  }
  return result;
}
// 99D46: using guessed type _DWORD __cdecl strcpy(_DWORD, _DWORD);
// 99D6B: using guessed type _DWORD __cdecl strlen(_DWORD);

//----- (000A7B30) --------------------------------------------------------
_DWORD *__cdecl sub_A7B30(int a1)
{
  _DWORD *v3; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h]

  sub_91BD0();
  for ( i = 0; i < *(_DWORD *)(a1 + 28) && *(_DWORD *)(1816 * i + *(_DWORD *)(a1 + 24) + 4) != 1; ++i )
    ;
  if ( i == *(_DWORD *)(a1 + 28) )
  {
    strcpy(&byte_181C90, "Out of sequence handles\n");
    sub_91BF0();
    return 0;
  }
  else
  {
    v3 = (_DWORD *)(1816 * i + *(_DWORD *)(a1 + 24));
    v3[1] = 2;
    sub_A6370(v3);
    v3[10] = 0;
    sub_91BF0();
    return v3;
  }
}
// 181C90: using guessed type char byte_181C90;

//----- (000A7BF0) --------------------------------------------------------
int *__cdecl sub_A7BF0(int *a1)
{
  int *result; // eax

  if ( a1 )
  {
    sub_95DE0(a1);
    result = a1;
    a1[1] = 1;
  }
  return result;
}

//----- (000A7C20) --------------------------------------------------------
int __cdecl sub_A7C20(int *a1, int a2, int a3)
{
  __int16 v4; // [esp+0h] [ebp-30h] BYREF
  int v5; // [esp+2h] [ebp-2Eh]
  int v7; // [esp+10h] [ebp-20h]
  int v8; // [esp+14h] [ebp-1Ch]
  _WORD *v9; // [esp+18h] [ebp-18h]
  unsigned int v10; // [esp+1Ch] [ebp-14h]
  unsigned int i; // [esp+20h] [ebp-10h]
  unsigned int v12; // [esp+24h] [ebp-Ch]
  unsigned int v13; // [esp+28h] [ebp-8h]
  unsigned int v14; // [esp+2Ch] [ebp-4h]

  if ( !a1 )
    return 0;
  a1[1] = 2;
  v14 = sub_A50F0(a2, a3);
  if ( !v14 )
    goto LABEL_4;
  v10 = sub_A50A0(*(_DWORD *)(v14 + 4)) + 8;
  v13 = v10 + v14;
  v14 += 12;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  while ( v14 < v13 )
  {
    if ( !strncmp(v14, aTimb, 4) )
      a1[2] = v14;
    if ( !strncmp(v14, aRbrn, 4) )
      a1[3] = v14;
    if ( !strncmp(v14, aEvnt, 4) )
      a1[4] = v14;
    v14 += sub_A50A0(*(_DWORD *)(v14 + 4)) + 8;
  }
  if ( a1[4] )
  {
    a1[6] = 0;
    a1[7] = 0;
    a1[8] = 0;
    a1[9] = 0;
    a1[10] = 0;
    a1[11] = 1;
    sub_A6490(a1);
    a1[14] = dword_181DE0;
    a1[15] = dword_181DE0;
    a1[17] = 0;
    a1[16] = 0;
    a1[18] = 100;
    a1[19] = 100;
    a1[21] = 0;
    a1[20] = 0;
    a1[22] = 0;
    if ( a1[2] )
    {
      memmove(&unk_181EE0, a1[2], 512);
      v9 = &unk_181EE0;
      if ( *(_DWORD *)(*a1 + 420) )
      {
        v12 = 0;
        while ( (unsigned __int16)v9[4] > v12 )
        {
          v7 = (unsigned __int8)v9[v12 + 5];
          v8 = (unsigned __int16)(v9[v12 + 5] & 0xFF00) >> 8;
          if ( (*(int (__cdecl **)(int, int, int))(*a1 + 420))(*a1, v8, v7) )
          {
            for ( i = v12 + 1; (unsigned __int16)v9[4] > i; ++i )
              v9[i + 4] = v9[i + 5];
            --v9[4];
            if ( *((_BYTE *)v9 + 5) >= 2u )
            {
              *((_BYTE *)v9 + 5) -= 2;
            }
            else
            {
              *((_BYTE *)v9 + 5) -= 2;
              --*((_BYTE *)v9 + 4);
            }
          }
          else
          {
            ++v12;
          }
        }
      }
      if ( v9[4] )
      {
        if ( sub_92160() )
        {
          strcpy(&byte_181C90, "No timbres loaded\n");
          return -1;
        }
        else
        {
          ++*(_DWORD *)(*a1 + 20);
          sub_A4EB0(*a1);
          memmove(*(_DWORD *)(*a1 + 8) + 256, v9, 512);
          sub_91F70(*(_DWORD *)*a1, 1283, 0, &v4);
          --*(_DWORD *)(*a1 + 20);
          if ( v4 )
          {
            return 1;
          }
          else
          {
            sprintf(
              &byte_181C90,
              "Driver could not install timbre bank %u, patch %u\n",
              (__int16)v5 >> 8,
              (unsigned __int8)v5);
            return -1;
          }
        }
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
LABEL_4:
    strcpy(&byte_181C90, "Invalid XMIDI sequence\n");
    return 0;
  }
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 99682: using guessed type _DWORD __cdecl strncmp(_DWORD, _DWORD, _DWORD);
// AD81F: using guessed type _DWORD __cdecl memmove(_DWORD, _DWORD, _DWORD);
// 181C90: using guessed type char byte_181C90;
// 181DE0: using guessed type int dword_181DE0;

//----- (000A8010) --------------------------------------------------------
int *__cdecl sub_A8010(int *a1)
{
  int *result; // eax

  if ( a1 )
  {
    result = a1;
    if ( a1[1] != 1 )
    {
      sub_95DE0(a1);
      sub_A6490(a1);
      result = a1;
      a1[1] = 4;
    }
  }
  return result;
}

//----- (000A8050) --------------------------------------------------------
int __cdecl sub_A8050(int *a1)
{
  int result; // eax
  int v2; // [esp+0h] [ebp-Ch]
  int i; // [esp+4h] [ebp-8h]
  _DWORD *v4; // [esp+8h] [ebp-4h]

  if ( a1 )
  {
    result = (int)a1;
    if ( a1[1] == 4 )
    {
      a1[1] = 8;
      sub_A5E50(a1);
      result = *a1;
      v4 = (_DWORD *)*a1;
      for ( i = 0; i < 16; ++i )
      {
        v2 = a1[i + 37];
        if ( a1[i + 277] >= 64 )
          sub_A4F10(v4, v2 | 0xB0, 64, 0);
        if ( a1[i + 117] >= 64 )
          v4[v2 + 8] = 0;
        if ( a1[i + 149] >= 64 )
          sub_A4F10(v4, v2 | 0xB0, 112, 0);
        if ( a1[i + 101] >= 64 )
          sub_980D0(v4, v2 + 1);
        result = i;
      }
    }
  }
  return result;
}

//----- (000A8180) --------------------------------------------------------
void __cdecl sub_A8180(_DWORD *a1)
{
  int v1; // eax
  int v2; // [esp+0h] [ebp-10h]
  int i; // [esp+8h] [ebp-8h]
  int j; // [esp+8h] [ebp-8h]
  _DWORD *v5; // [esp+Ch] [ebp-4h]

  if ( a1 && a1[1] == 8 )
  {
    v5 = (_DWORD *)*a1;
    for ( i = 0; i < 16; ++i )
    {
      if ( (int)a1[i + 101] >= 64 )
      {
        v1 = sub_97F90(v5);
        if ( v1 )
          v2 = v1 - 1;
        else
          v2 = i;
        a1[i + 37] = v2;
      }
    }
    for ( j = 0; j < 16; ++j )
      sub_A5FD0((int)a1, j);
    a1[1] = 4;
  }
}

//----- (000A8250) --------------------------------------------------------
int __cdecl sub_A8250(int a1)
{
  int result; // eax

  if ( a1 )
  {
    result = a1;
    if ( *(_DWORD *)(a1 + 4) != 1 )
    {
      sub_95DE0((int *)a1);
      *(_DWORD *)(a1 + 4) = 2;
      result = a1;
      if ( *(_DWORD *)(a1 + 40) )
        return (*(int (__cdecl **)(int))(a1 + 40))(a1);
    }
  }
  return result;
}

//----- (000A82A0) --------------------------------------------------------
int __cdecl sub_A82A0(int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    result = a2;
    *(_DWORD *)(a1 + 44) = a2;
  }
  return result;
}

//----- (000A82C0) --------------------------------------------------------
void __cdecl sub_A82C0(_DWORD *a1, int a2, int a3)
{
  if ( a1 )
  {
    ++*(_DWORD *)(*a1 + 20);
    a1[19] = a2;
    if ( a1[18] == a1[19] )
    {
      --*(_DWORD *)(*a1 + 20);
    }
    else
    {
      if ( a3 )
      {
        a1[21] = 1000 * a3 / abs(a1[18] - a1[19]);
        a1[20] = 0;
      }
      else
      {
        a1[18] = a1[19];
      }
      --*(_DWORD *)(*a1 + 20);
    }
  }
}
// A0D1F: using guessed type _DWORD __cdecl abs(_DWORD);

//----- (000A8360) --------------------------------------------------------
void __cdecl sub_A8360(_DWORD *a1, int a2, int a3)
{
  if ( a1 )
  {
    ++*(_DWORD *)(*a1 + 20);
    a1[15] = a2;
    if ( a1[14] == a1[15] )
    {
      --*(_DWORD *)(*a1 + 20);
    }
    else
    {
      if ( a3 )
      {
        a1[17] = 1000 * a3 / abs(a1[14] - a1[15]);
        a1[16] = 0;
      }
      else
      {
        a1[14] = a1[15];
      }
      sub_A64C0((int)a1);
      --*(_DWORD *)(*a1 + 20);
    }
  }
}
// A0D1F: using guessed type _DWORD __cdecl abs(_DWORD);

//----- (000A8410) --------------------------------------------------------
int __cdecl sub_A8410(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 4);
  else
    return 0;
}

//----- (000A8440) --------------------------------------------------------
int __cdecl sub_A8440(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 44);
  else
    return -1;
}

//----- (000A8470) --------------------------------------------------------
int __cdecl sub_A8470(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 72);
  else
    return 0;
}

//----- (000A84A0) --------------------------------------------------------
int __cdecl sub_A84A0(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 56);
  else
    return 0;
}

//----- (000A84D0) --------------------------------------------------------
_DWORD *__cdecl sub_A84D0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  result = (_DWORD *)a1[108];
  if ( result != a2 )
  {
    a1[108] = a2;
    ++a1[5];
    v3 = a1[7];
    v4 = a1[6];
    while ( v3 )
    {
      if ( *(_DWORD *)(v4 + 4) == 4 )
        sub_A64C0(v4);
      --v3;
      v4 += 1816;
    }
    result = a1;
    --a1[5];
  }
  return result;
}

//----- (000A8550) --------------------------------------------------------
int __cdecl sub_A8550(int a1)
{
  return *(_DWORD *)(a1 + 432);
}

//----- (000A8570) --------------------------------------------------------
int __cdecl sub_A8570(int *a1, __int16 a2, __int16 a3)
{
  _WORD v4[6]; // [esp+0h] [ebp-10h] BYREF

  v4[2] = (a2 << 8) | a3;
  return sub_91F70(*a1, 1284, v4, 0);
}

//----- (000A85B0) --------------------------------------------------------
int __cdecl sub_A85B0(int *a1, int a2, int a3)
{
  __int16 v4; // [esp+0h] [ebp-10h] BYREF
  int v5; // [esp+2h] [ebp-Eh]

  if ( a1[105] && ((int (__cdecl *)(int *, int, int))a1[105])(a1, a2, a3) )
    return 1;
  byte_E4B2A = a3;
  byte_E4B2B = a2;
  ++a1[5];
  sub_A4EB0((int)a1);
  memmove(a1[2] + 256, aTimb_0, 12);
  sub_91F70(*a1, 1283, 0, &v4);
  --a1[5];
  if ( !v4 )
    sprintf(&byte_181C90, "Driver could not install timbre bank %u, patch %u\n", (__int16)v5 >> 8, (unsigned __int8)v5);
  return v4;
}
// 8E3D5: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// AD81F: using guessed type _DWORD __cdecl memmove(_DWORD, _DWORD, _DWORD);
// E4B2A: using guessed type char byte_E4B2A;
// E4B2B: using guessed type char byte_E4B2B;
// 181C90: using guessed type char byte_181C90;

//----- (000A8690) --------------------------------------------------------
int __cdecl sub_A8690(int *a1, __int16 a2, __int16 a3)
{
  _WORD v4[6]; // [esp+0h] [ebp-Ch] BYREF

  v4[2] = (a2 << 8) | a3;
  v4[3] = 1;
  return sub_91F70(*a1, 1285, v4, 0);
}

//----- (000A86D0) --------------------------------------------------------
int __cdecl sub_A86D0(int *a1, __int16 a2, __int16 a3)
{
  _WORD v4[6]; // [esp+0h] [ebp-Ch] BYREF

  v4[2] = (a2 << 8) | a3;
  v4[3] = 0;
  return sub_91F70(*a1, 1285, v4, 0);
}

//----- (000A8710) --------------------------------------------------------
int __cdecl sub_A8710(int a1)
{
  int v2; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h]

  v2 = 0;
  for ( i = 0; i < *(_DWORD *)(a1 + 28); ++i )
  {
    if ( *(_DWORD *)(1816 * i + *(_DWORD *)(a1 + 24) + 4) == 4 )
      ++v2;
  }
  return v2;
}

//----- (000A8770) --------------------------------------------------------
int __cdecl sub_A8770(int a1, char a2, unsigned int a3)
{
  if ( a1 )
    return sub_A5210(a1 + 212, (a2 - 1) | 0xB0, a3);
  else
    return -1;
}

//----- (000A87C0) --------------------------------------------------------
int __cdecl sub_A87C0(int a1, int a2)
{
  int v4; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h]

  if ( !a1 )
    return 0;
  v4 = 0;
  for ( i = 0; i < 16; ++i )
  {
    if ( a2 - 1 == *(_DWORD *)(4 * i + a1 + 1368) )
      ++v4;
  }
  return v4;
}

//----- (000A8830) --------------------------------------------------------
int __cdecl sub_A8830(_DWORD *a1, _DWORD *a2, int *a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-10h]
  int i; // [esp+4h] [ebp-Ch]
  int v6; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  if ( a1 )
  {
    ++*(_DWORD *)(*a1 + 20);
    v7 = a1[23];
    v6 = a1[24];
    v4 = a1[27];
    for ( i = 0; i < dword_181DE4; ++i )
    {
      v4 += a1[26];
      if ( v4 >= a1[28] )
      {
        v4 -= a1[28];
        if ( ++v7 >= a1[25] )
        {
          v7 = 0;
          ++v6;
        }
      }
    }
    if ( v6 < 0 )
      v6 = 0;
    if ( a3 )
      *a3 = v6;
    if ( a2 )
      *a2 = v7;
    result = *a1;
    --*(_DWORD *)(*a1 + 20);
  }
  return result;
}
// 181DE4: using guessed type int dword_181DE4;

//----- (000A8900) --------------------------------------------------------
_DWORD *__cdecl sub_A8900(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int v3; // [esp+0h] [ebp-Ch]
  int i; // [esp+4h] [ebp-8h]
  int v5; // [esp+8h] [ebp-4h]
  int j; // [esp+8h] [ebp-4h]

  if ( a1 )
  {
    result = a1;
    if ( a1[3] )
    {
      v5 = *(__int16 *)(a1[3] + 8);
      v3 = a1[3] + 10;
      for ( i = 0; i < v5 && *(unsigned __int16 *)(v3 + 6 * i) != a2; ++i )
        ;
      result = (_DWORD *)i;
      if ( i != v5 )
      {
        a1[5] = *(_DWORD *)(6 * i + v3 + 2) + a1[4] + 8;
        result = a1;
        a1[12] = 0;
        if ( !dword_181DE8 )
        {
          for ( j = 0; j < 4; ++j )
          {
            a1[j + 33] = -1;
            result = (_DWORD *)j;
          }
        }
      }
    }
  }
  return result;
}
// 181DE8: using guessed type int dword_181DE8;

//----- (000A89E0) --------------------------------------------------------
int __cdecl sub_A89E0(int a1, int a2)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( !a1 )
    return 0;
  v4 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 28) = a2;
  return v4;
}

//----- (000A8A20) --------------------------------------------------------
int __cdecl sub_A8A20(int a1, int a2)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( !a1 )
    return 0;
  v4 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 32) = a2;
  return v4;
}

//----- (000A8A60) --------------------------------------------------------
int __cdecl sub_A8A60(int a1, int a2)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( !a1 )
    return 0;
  v4 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 40) = a2;
  return v4;
}

//----- (000A8AA0) --------------------------------------------------------
int __cdecl sub_A8AA0(int a1, int a2)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( !a1 )
    return 0;
  v4 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = a2;
  return v4;
}

//----- (000A8AE0) --------------------------------------------------------
int __cdecl sub_A8AE0(int a1, int a2)
{
  int v3; // [esp+4h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 416);
  *(_DWORD *)(a1 + 416) = a2;
  return v3;
}

//----- (000A8B20) --------------------------------------------------------
int __cdecl sub_A8B20(int a1, int a2)
{
  int v3; // [esp+4h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 420);
  *(_DWORD *)(a1 + 420) = a2;
  return v3;
}

//----- (000A8B60) --------------------------------------------------------
int __cdecl sub_A8B60(int a1, int a2, int a3)
{
  int result; // eax

  if ( a1 )
  {
    result = a3;
    *(_DWORD *)(4 * a2 + a1 + 1752) = a3;
  }
  return result;
}

//----- (000A8B90) --------------------------------------------------------
int __cdecl sub_A8B90(int a1, int a2)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 4 * a2 + 1752);
  else
    return 0;
}

//----- (000A8BD0) --------------------------------------------------------
int __cdecl sub_A8BD0(int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    result = a2;
    *(_DWORD *)(a1 + 24) = a2;
  }
  return result;
}

//----- (000A8BF0) --------------------------------------------------------
int __cdecl sub_A8BF0(_DWORD *a1)
{
  int v1; // eax
  int v4; // [esp+4h] [ebp-14h]
  int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  int k; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]
  int v10; // [esp+14h] [ebp-4h]

  ++a1[5];
  v6 = -1;
  v5 = 0x7FFFFFFF;
  for ( i = 8; i >= 1; --i )
  {
    if ( i != 9 && a1[i + 8] != 1 && a1[i + 8] != 2 && a1[i + 88] < v5 )
    {
      v5 = a1[i + 88];
      v6 = i;
    }
  }
  if ( v6 == -1 )
  {
    for ( j = 8; j >= 1; --j )
    {
      if ( j != 9 && a1[j + 8] != 1 && a1[j + 88] < v5 )
      {
        v5 = a1[j + 88];
        v6 = j;
      }
    }
  }
  if ( v6 == -1 )
  {
    --a1[5];
    return 0;
  }
  else
  {
    sub_A4F10(a1, v6 | 0xB0, 64, 0);
    v10 = a1[7];
    v4 = a1[6];
    while ( v10 )
    {
      if ( *(_DWORD *)(v4 + 4) != 1 )
      {
        for ( k = 0; k < 32; ++k )
        {
          if ( *(_DWORD *)(v4 + 4 * k + 1368) != -1 && *(_DWORD *)(v4 + 4 * *(_DWORD *)(v4 + 4 * k + 1368) + 148) == v6 )
          {
            v1 = *(_DWORD *)(v4 + 4 * k + 1368);
            LOBYTE(v1) = v1 | 0x80;
            sub_A5850(v4, v1, *(_DWORD *)(v4 + 4 * k + 1496), 0, 0);
            *(_DWORD *)(v4 + 4 * k + 1368) = -1;
          }
        }
      }
      --v10;
      v4 += 1816;
    }
    a1[v6 + 72] = a1[v6 + 8];
    a1[v6 + 8] = 1;
    a1[v6 + 24] = 0;
    a1[v6 + 40] = a1[v6 + 56];
    --a1[5];
    return v6 + 1;
  }
}
// A5850: using guessed type _DWORD __cdecl sub_A5850(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000A8EA0) --------------------------------------------------------
_DWORD *__cdecl sub_A8EA0(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int v3; // [esp+0h] [ebp-10h]
  int v4; // [esp+4h] [ebp-Ch]
  int i; // [esp+8h] [ebp-8h]
  int v6; // [esp+Ch] [ebp-4h]

  v4 = a2 - 1;
  result = &a1[a2 - 1];
  if ( result[8] == 1 )
  {
    ++a1[5];
    a1[v4 + 8] = a1[v4 + 72];
    a1[v4 + 56] = a1[v4 + 40];
    sub_A4F10(a1, v4 | 0xB0, 64, 0);
    v6 = a1[7];
    v3 = a1[6];
    while ( v6 )
    {
      if ( *(_DWORD *)(v3 + 4) != 1 )
      {
        for ( i = 0; i < 32; ++i )
        {
          if ( *(_DWORD *)(v3 + 4 * i + 1368) != -1 && *(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 4 * i + 1368) + 148) == v4 )
          {
            sub_A5850(v3, *(_DWORD *)(v3 + 4 * i + 1368) | 0x80, *(_DWORD *)(v3 + 4 * i + 1496), 0, 0);
            *(_DWORD *)(v3 + 4 * i + 1368) = -1;
          }
        }
      }
      --v6;
      v3 += 1816;
    }
    if ( a1[v4 + 40] )
    {
      if ( *(_DWORD *)(a1[v4 + 40] + 4) != 1 )
        sub_A5FD0(a1[v4 + 40], v4);
    }
    result = a1;
    --a1[5];
  }
  return result;
}

//----- (000A9080) --------------------------------------------------------
int __cdecl sub_A9080(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  if ( a1 )
  {
    a1[a2 + 36] = a3 - 1;
    result = 4 * a3 + *a1;
    if ( *(_DWORD *)(result + 28) == 1 )
    {
      result = *(_DWORD *)(4 * a3 + *a1 + 92);
      if ( (_DWORD *)result != a1 )
      {
        result = (int)a1;
        *(_DWORD *)(*a1 + 4 * a3 + 92) = a1;
      }
    }
  }
  return result;
}

//----- (000A9100) --------------------------------------------------------
int __cdecl sub_A9100(int a1, int a2)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 4 * a2 + 144) + 1;
  else
    return 0;
}

//----- (000A9140) --------------------------------------------------------
_DWORD *__cdecl sub_A9140(_DWORD *a1, int a2, int a3, unsigned int a4, int a5)
{
  _DWORD *result; // eax

  ++a1[5];
  if ( a2 )
  {
    sub_A5850(a2, a3, a4, a5, 0);
  }
  else
  {
    if ( (a3 & 0xF0) == 176 && a4 == 7 )
    {
      a5 = a1[108] * a5 / 127;
      if ( a5 > 127 )
        a5 = 127;
      if ( a5 < 0 )
        a5 = 0;
    }
    if ( !a1[104] || !((int (__cdecl *)(_DWORD *, _DWORD, int, unsigned int, int))a1[104])(a1, 0, a3, a4, a5) )
      sub_A4F10(a1, a3, a4, a5);
  }
  sub_A4EB0((int)a1);
  result = a1;
  --a1[5];
  return result;
}

//----- (000A9230) --------------------------------------------------------
int __cdecl sub_A9230(int a1, int a2)
{
  int v2; // eax
  int result; // eax
  int v4; // [esp+4h] [ebp-4h] BYREF

  ++*(_DWORD *)(a1 + 20);
  v4 = a2 + 1;
  v2 = sub_A5040(&v4);
  sub_A4FD0(a1, a2, v4 - a2 + v2);
  result = a1;
  --*(_DWORD *)(a1 + 20);
  return result;
}

//----- (000A9280) --------------------------------------------------------
bool sub_A9280()
{
  bool result; // eax

  if ( dword_E4B1C )
  {
    sub_9D650((unsigned int)sub_A4CF0, (unsigned int)sub_A9280);
    sub_9D740((unsigned int)aSample, 128);
    sub_9D740((unsigned int)&dword_E4B18, 4);
    sub_9D740((unsigned int)&dword_181EB8, 4);
    sub_9D740((unsigned int)&dword_181EBC, 4);
    sub_9D740((unsigned int)&dword_181EC4, 4);
    sub_9D740((unsigned int)&dword_181ED4, 4);
    sub_9D740((unsigned int)&dword_181EC8, 4);
    sub_9D740((unsigned int)&dword_181ECC, 4);
    sub_9D740((unsigned int)&dword_181EB4, 4);
    sub_9D740((unsigned int)&dword_181ED0, 4);
    sub_9D740((unsigned int)&dword_181EDC, 4);
    sub_9D740((unsigned int)&dword_181ED8, 4);
    result = sub_9D740((unsigned int)&dword_181EB0, 4);
    dword_E4B1C = 0;
  }
  return result;
}
// A4CF0: using guessed type int sub_A4CF0();
// E4B18: using guessed type int dword_E4B18;
// E4B1C: using guessed type int dword_E4B1C;
// 181EB0: using guessed type int dword_181EB0;
// 181EB4: using guessed type int dword_181EB4;
// 181EB8: using guessed type int dword_181EB8;
// 181EBC: using guessed type int dword_181EBC;
// 181EC4: using guessed type int dword_181EC4;
// 181EC8: using guessed type int dword_181EC8;
// 181ECC: using guessed type int dword_181ECC;
// 181ED0: using guessed type int dword_181ED0;
// 181ED4: using guessed type int dword_181ED4;
// 181ED8: using guessed type int dword_181ED8;
// 181EDC: using guessed type int dword_181EDC;

//----- (000A9590) --------------------------------------------------------
bool sub_A9590()
{
  bool result; // eax

  if ( !dword_E4B2C )
  {
    result = sub_9D590((unsigned int)sub_A9590, (unsigned int)sub_AA620);
    dword_E4B2C = 1;
  }
  return result;
}
// E4B2C: using guessed type int dword_E4B2C;

//----- (000A95D0) --------------------------------------------------------
int __cdecl sub_A95D0(int a1, char a2, unsigned int a3, unsigned __int8 a4)
{
  int result; // eax
  unsigned int v5; // [esp+4h] [ebp-4h]

  v5 = a2 & 0xF0;
  result = a2 & 0xF;
  if ( v5 < 0xC0 )
  {
    if ( v5 == 176 )
    {
      if ( a3 < 0x5B )
      {
        if ( a3 < 7 )
        {
          if ( a3 )
          {
            if ( a3 <= 1 )
            {
              result = a1 + 4 * result;
              *(_DWORD *)(result + 640) = a4;
            }
            else if ( a3 == 6 )
            {
              result = a1 + 4 * result;
              *(_DWORD *)(result + 1088) = a4;
            }
          }
        }
        else if ( a3 <= 7 )
        {
          result = a1 + 4 * result;
          *(_DWORD *)(result + 704) = a4;
        }
        else if ( a3 < 0xB )
        {
          if ( a3 == 10 )
          {
            result = a1 + 4 * result;
            *(_DWORD *)(result + 768) = a4;
          }
        }
        else if ( a3 <= 0xB )
        {
          result = a1 + 4 * result;
          *(_DWORD *)(result + 832) = a4;
        }
        else if ( a3 == 64 )
        {
          result = a1 + 4 * result;
          *(_DWORD *)(result + 896) = a4;
        }
      }
      else if ( a3 <= 0x5B )
      {
        result = a1 + 4 * result;
        *(_DWORD *)(result + 960) = a4;
      }
      else if ( a3 < 0x70 )
      {
        if ( a3 < 0x6E )
        {
          if ( a3 == 93 )
          {
            result = a1 + 4 * result;
            *(_DWORD *)(result + 1024) = a4;
          }
        }
        else
        {
          result = a1 + 4 * result;
          if ( a3 <= 0x6E )
            *(_DWORD *)(result + 192) = a4;
          else
            *(_DWORD *)(result + 256) = a4;
        }
      }
      else if ( a3 <= 0x70 )
      {
        result = a1 + 4 * result;
        *(_DWORD *)(result + 384) = a4;
      }
      else if ( a3 < 0x73 )
      {
        if ( a3 == 114 )
        {
          result = a1 + 4 * result;
          *(_DWORD *)(result + 448) = a4;
        }
      }
      else if ( a3 <= 0x73 )
      {
        result = a1 + 4 * result;
        *(_DWORD *)(result + 512) = a4;
      }
      else if ( a3 == 119 )
      {
        result = a1 + 4 * result;
        *(_DWORD *)(result + 576) = a4;
      }
    }
  }
  else if ( v5 <= 0xC0 )
  {
    result = a1 + 4 * result;
    *(_DWORD *)result = (unsigned __int8)a3;
  }
  else if ( v5 == 224 )
  {
    *(_DWORD *)(a1 + 4 * result + 64) = (unsigned __int8)a3;
    result = a1 + 4 * result;
    *(_DWORD *)(result + 128) = a4;
  }
  return result;
}

//----- (000A98D0) --------------------------------------------------------
_DWORD *__cdecl sub_A98D0(_DWORD *a1, int a2, int a3)
{
  int i; // [esp+4h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    if ( i >= 512 )
      return 0;
    if ( *a1 == -1 )
      return 0;
    if ( *a1 == a2 && a1[1] == a3 )
      break;
    a1 += 8;
  }
  return a1;
}

//----- (000A9950) --------------------------------------------------------
int __cdecl sub_A9950(int a1, int a2)
{
  int v3; // [esp+4h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 4 * a2 + 1304);
  sub_93E30(
    *(int **)(a1 + 4 * a2 + 1236),
    *(_DWORD *)(a1 + 4 * a2 + 1560) * (*(_DWORD *)(a1 + 4 * v3 + 852) * *(_DWORD *)(4 * v3 + a1 + 724) / 127) / 127);
  return sub_93ED0(*(int **)(a1 + 4 * a2 + 1236), *(_DWORD *)(a1 + 4 * v3 + 788));
}

//----- (000A9A30) --------------------------------------------------------
int __cdecl sub_A9A30(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-2Ch]
  int v4; // [esp+0h] [ebp-2Ch]
  int v5; // [esp+4h] [ebp-28h]
  int v6; // [esp+14h] [ebp-18h]
  int v7; // [esp+18h] [ebp-14h]
  int v8; // [esp+1Ch] [ebp-10h]
  int v9; // [esp+20h] [ebp-Ch]
  int v10; // [esp+28h] [ebp-4h]

  v10 = *(_DWORD *)(a1 + 4 * a2 + 1304);
  v7 = *(_DWORD *)(a1 + 4 * a2 + 1496);
  v9 = *(_DWORD *)(a1 + 4 * a2 + 1368);
  v3 = (*(_DWORD *)(a1 + 4 * v10 + 148) << 7) | *(_DWORD *)(a1 + 4 * v10 + 84);
  if ( v3 <= 0x2000 )
  {
    if ( v3 >= 0x2000 )
    {
      v4 = 0;
      v5 = 0;
    }
    else
    {
      v4 = 0x2000 - v3;
      v5 = -1;
    }
  }
  else
  {
    v4 = v3 - 0x1FFF;
    v5 = 1;
  }
  v8 = v5 * *(_DWORD *)(a1 + 4 * v10 + 1108) + v9;
  if ( v8 < 0 )
    v8 = 0;
  if ( v8 > 127 )
    v8 = 127;
  v6 = dword_A9390[v9];
  if ( v10 != 9 )
    v7 = v6 * v7 / dword_A9390[*(_DWORD *)(a1 + 4 * a2 + 1432)];
  return sub_93D90(
           *(_DWORD *)(a1 + 4 * a2 + 1236),
           (((v4 * (dword_A9390[v8] - v6)
            - (__CFSHL__((v4 * (dword_A9390[v8] - v6)) >> 31, 13)
             + ((v4 * (dword_A9390[v8] - v6)) >> 31 << 13))) >> 13)
          + v6)
         * v7
         / v6);
}
// A9390: using guessed type int dword_A9390[];

//----- (000AA310) --------------------------------------------------------
_DWORD *__cdecl sub_AA310(int a1, int a2, int a3, int a4)
{
  int v5; // [esp+0h] [ebp-10h]
  int i; // [esp+8h] [ebp-8h]
  int j; // [esp+8h] [ebp-8h]
  int k; // [esp+8h] [ebp-8h]
  _DWORD *v10; // [esp+Ch] [ebp-4h]

  sub_A9590();
  v10 = (_DWORD *)sub_9D450(1692);
  if ( v10 )
  {
    v10[1] = a1;
    *v10 = a2;
    v10[2] = a3;
    v10[3] = sub_97A60(a2, (int)sub_A9C50);
    v10[4] = sub_97BB0(a2, (int)sub_A9C00);
    *(_DWORD *)(a2 + 436) = v10;
    for ( i = 0; i < 16; ++i )
    {
      v10[i + 5] = 0;
      v10[i + 21] = 0;
      v10[i + 37] = 64;
      v10[i + 117] = 0;
      v10[i + 181] = 127;
      v10[i + 197] = 64;
      v10[i + 213] = 127;
      v10[i + 277] = dword_181DEC;
    }
    for ( v10[325] = 0; ; ++v10[325] )
    {
      v5 = a4 <= 16 ? a4 : 16;
      if ( v10[325] >= v5 )
        break;
      v10[v10[325] + 309] = sub_93510(v10[1]);
      if ( !v10[v10[325] + 309] )
        break;
    }
    for ( j = 0; j < 16; ++j )
      v10[j + 293] = 0;
    for ( k = 0; k < v10[325]; ++k )
      v10[k + 326] = -1;
    v10[422] = 0;
    return v10;
  }
  else
  {
    strcpy(&byte_181C90, "Insufficient memory for HWAVE descriptor\n");
    return 0;
  }
}
// A9C00: using guessed type int sub_A9C00();
// A9C50: using guessed type int sub_A9C50();
// 181C90: using guessed type char byte_181C90;
// 181DEC: using guessed type int dword_181DEC;

//----- (000AA590) --------------------------------------------------------
int __cdecl sub_AA590(int *a1)
{
  int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < a1[325]; ++i )
    sub_937A0(a1[i + 309]);
  sub_97A60(*a1, a1[3]);
  sub_97BB0(*a1, a1[4]);
  return sub_9D490((unsigned int)a1, 1692);
}

//----- (000AA620) --------------------------------------------------------
bool sub_AA620()
{
  bool result; // eax

  if ( dword_E4B2C )
  {
    result = sub_9D650((unsigned int)sub_A9590, (unsigned int)sub_AA620);
    dword_E4B2C = 0;
  }
  return result;
}
// A9590: using guessed type int sub_A9590();
// E4B2C: using guessed type int dword_E4B2C;

//----- (000AB610) --------------------------------------------------------
int __fastcall sub_AB610(int a1, int a2)
{
  return *(_DWORD *)a2;
}

//----- (000AB9E1) --------------------------------------------------------
int __cdecl sub_AB9E1(int a1)
{
  char v2[8]; // [esp+0h] [ebp-1Ch] BYREF
  char v3[8]; // [esp+8h] [ebp-14h] BYREF
  int v5; // [esp+14h] [ebp-8h]
  int v6; // [esp+18h] [ebp-4h]

  v5 = -1;
  qmemcpy(v3, "RNC", 3);
  v3[3] = 1;
  v3[4] = 0;
  v6 = sub_98817(a1, 512);
  if ( v6 <= 0 )
    return -1;
  sub_988A7(v6, (int)v2, 8);
  if ( !strncmp(v2, v3, 4) )
  {
    v5 = (unsigned __int8)v2[4] << 8;
    v5 += (unsigned __int8)v2[5];
    v5 <<= 8;
    v5 += (unsigned __int8)v2[6];
    v5 <<= 8;
    v5 += (unsigned __int8)v2[7];
  }
  else
  {
    v5 = filelength(v6);
  }
  sub_98882(v6);
  return v5;
}
// 988DA: using guessed type _DWORD __cdecl filelength(_DWORD);
// 99682: using guessed type _DWORD __cdecl strncmp(_DWORD, _DWORD, _DWORD);

//----- (000AC24B) --------------------------------------------------------
int sub_AC24B()
{
  return 0;
}

//----- (000AC250) --------------------------------------------------------
int __cdecl sub_AC250(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, _DWORD *a7, int *a8)
{
  int result; // eax
  int v9; // ebx
  int v10; // esi
  int v11; // ebp
  int v12; // edi
  unsigned __int64 v13; // rax
  int v14; // [esp+Ch] [ebp-24h] BYREF
  int v15; // [esp+10h] [ebp-20h]
  int v16; // [esp+14h] [ebp-1Ch] BYREF
  int v17; // [esp+18h] [ebp-18h]
  int v18; // [esp+1Ch] [ebp-14h]

  if ( dword_E4CCC )
    goto LABEL_8;
  result = sub_B1138(dword_182188, 3);
  if ( result )
  {
    result = sub_B1138(dword_1821A0, 3);
    if ( result )
    {
      result = sub_B1138(dword_1821B8, 3);
      if ( result )
      {
        result = sub_B1138(dword_1821D0, 6);
        if ( result )
        {
          result = sub_B1138(dword_1821E8, 6);
          if ( result )
          {
            dword_E4CCC = 1;
LABEL_8:
            v18 = sub_B11E8(dword_182188, a1);
            v9 = sub_B11E8(dword_1821A0, a2);
            v10 = sub_B11E8(dword_1821B8, a3);
            v11 = sub_B11E8(
                    dword_1821D0,
                    ((unsigned __int64)(51471i64 * a4) >> 32 != 0) + ((unsigned __int64)(51471i64 * a4) >> 14));
            v12 = sub_B11E8(
                    dword_1821E8,
                    ((unsigned __int64)(51471i64 * a5) >> 32 != 0) + ((unsigned __int64)(51471i64 * a5) >> 14));
            sub_B14F8(&v16, v11);
            sub_B14F8(&v14, v12);
            v13 = (int)(((unsigned __int64)(v9 * (__int64)v17) >> 32 != 0)
                      + ((unsigned __int64)(v9 * (__int64)v17) >> 14)
                      - (((unsigned __int64)(v10 * (__int64)v16) >> 32 != 0)
                       + ((unsigned __int64)(v10 * (__int64)v16) >> 14)))
                * (__int64)v14;
            LODWORD(v13) = sub_B1304(
                             ((unsigned __int64)(v10 * (__int64)v17) >> 32 != 0)
                           + ((unsigned __int64)(v10 * (__int64)v17) >> 14)
                           + ((unsigned __int64)(v9 * (__int64)v16) >> 32 != 0)
                           + ((unsigned __int64)(v9 * (__int64)v16) >> 14),
                             ((unsigned __int64)(v18 * (__int64)v15) >> 32 != 0)
                           + ((unsigned __int64)(v18 * (__int64)v15) >> 14)
                           - ((HIDWORD(v13) != 0)
                            + (v13 >> 14)));
            *a6 = ((unsigned __int64)((int)&unk_E52EE * (__int64)(int)v13) >> 32 != 0)
                + ((unsigned __int64)((int)&unk_E52EE * (__int64)(int)v13) >> 14);
            *a7 = ((unsigned __int64)((int)&unk_E52EE * (__int64)v11) >> 32 != 0)
                + ((unsigned __int64)((int)&unk_E52EE * (__int64)v11) >> 14);
            result = ((unsigned __int64)((int)&unk_E52EE * (__int64)v12) >> 32 != 0)
                   + ((unsigned __int64)((int)&unk_E52EE * (__int64)v12) >> 14);
            *a8 = result;
          }
        }
      }
    }
  }
  return result;
}
// E4CCC: using guessed type int dword_E4CCC;
// 182188: using guessed type int dword_182188[6];
// 1821A0: using guessed type int dword_1821A0[6];
// 1821B8: using guessed type int dword_1821B8[6];
// 1821D0: using guessed type int dword_1821D0[6];
// 1821E8: using guessed type int dword_1821E8[6];

//----- (000AC449) --------------------------------------------------------
void sub_AC449()
{
  _disable();
}

//----- (000AC44B) --------------------------------------------------------
void sub_AC44B()
{
  _enable();
}

//----- (000AC70E) --------------------------------------------------------
__int16 __fastcall sub_AC70E(int a1, int a2, int a3, int a4)
{
  int *v4; // ebx
  int v5; // eax
  __int64 v7; // [esp+0h] [ebp-8h] BYREF

  byte_E3E28 = 3;
  byte_E4D18 = 1;
  __asm { smsw    word_E4D16 }
  word_E4D16 &= 6u;
  __sidt(&v7);
  v4 = (int *)(*(_DWORD *)((char *)&v7 + 2) + 56);
  if ( byte_E4CB4 )
  {
    sub_AC7D9();
    __ES__ = word_E3B9A;
    *MK_FP(word_E3B9A, v4) = a2;
    v4[1] = a4;
    LOWORD(v5) = sub_AC843();
  }
  else if ( byte_E4CB2 )
  {
    if ( byte_E4CB2 == 9 )
    {
      sub_AC7D9();
      *v4 = a2;
      v4[1] = a4;
      LOWORD(v5) = (*(int (__fastcall **)(int))(dword_E3B94 + 48))(3586);
    }
    else if ( byte_E4CB2 == 1 )
    {
      LOWORD(a2) = word_E3B98;
      LOWORD(v5) = _hook387(0, a2, v4);
    }
    else
    {
      LOWORD(a2) = 0;
      v5 = _hook387(0, a2, v4);
      if ( (_BYTE)v5 != 1 )
        LOWORD(v5) = sub_AC7F6(v5, a2, (int)v4);
    }
  }
  else
  {
    HIDWORD(v7) = (unsigned __int16)__DS__;
    __asm { int     21h; DOS - SET INTERRUPT VECTOR }
    LOWORD(v5) = -3324;
    __asm { int     21h; DOS - Novell Advanced NetWare 2.0+ - FILE SERVER FILE COPY }
  }
  return v5;
}
// B4A72: using guessed type int __fastcall _hook387(_DWORD, _DWORD, _DWORD);
// E3B94: using guessed type int dword_E3B94;
// E3B98: using guessed type __int16 word_E3B98;
// E3B9A: using guessed type __int16 word_E3B9A;
// E3E28: using guessed type char byte_E3E28;
// E4CB2: using guessed type char byte_E4CB2;
// E4CB4: using guessed type char byte_E4CB4;
// E4D16: using guessed type __int16 word_E4D16;
// E4D18: using guessed type char byte_E4D18;

//----- (000AC7D9) --------------------------------------------------------
void sub_AC7D9()
{
  ;
}

//----- (000AC7F6) --------------------------------------------------------
__int16 __fastcall sub_AC7F6(int a1, int a2, int a3)
{
  __int16 result; // ax
  unsigned __int32 v4; // ecx

  __asm { int     21h; DOS - SET INTERRUPT VECTOR }
  dword_E4D10 = a3;
  word_E4D14 = __ES__;
  result = 9476;
  if ( byte_E4CB2 < 3 )
  {
    __asm { int     21h; DOS - }
    v4 = __readcr0();
    __writecr0(v4 & 0xFFFFFFF9 | 4);
  }
  else
  {
    __asm { int     21h; DOS - SET INTERRUPT VECTOR }
    return sub_AC843();
  }
  return result;
}
// E4CB2: using guessed type char byte_E4CB2;
// E4D10: using guessed type int dword_E4D10;
// E4D14: using guessed type __int16 word_E4D14;

//----- (000AC843) --------------------------------------------------------
__int16 sub_AC843()
{
  __int16 result; // ax

  result = 9525;
  __asm { int     21h; DOS - SET INTERRUPT VECTOR }
  dword_E4CD0 |= 4u;
  dword_E4CD0 &= ~2u;
  __asm { int     21h; DOS - }
  return result;
}
// E4CD0: using guessed type int dword_E4CD0;

//----- (000AC8DD) --------------------------------------------------------
__int16 sub_AC8DD()
{
  __int16 result; // ax
  unsigned __int32 v1; // ecx

  result = 9476;
  __asm { int     21h; DOS - SET INTERRUPT VECTOR }
  if ( byte_E4CB2 >= 3 )
    return sub_AC918();
  v1 = __readcr0();
  v1 &= 0xFFFFFFF9;
  LOWORD(v1) = word_E4D16 | v1;
  __writecr0(v1);
  return result;
}
// E4CB2: using guessed type char byte_E4CB2;
// E4D10: using guessed type int dword_E4D10;
// E4D14: using guessed type __int16 word_E4D14;
// E4D16: using guessed type __int16 word_E4D16;

//----- (000AC918) --------------------------------------------------------
__int16 sub_AC918()
{
  __int16 result; // ax

  result = 9525;
  __asm { int     21h; DOS - SET INTERRUPT VECTOR }
  dword_E4CD0 = (unsigned __int16)word_E4D16;
  __asm { int     21h; DOS - }
  return result;
}
// E4CD0: using guessed type int dword_E4CD0;
// E4D16: using guessed type __int16 word_E4D16;

//----- (000AC9C3) --------------------------------------------------------
void *sub_AC9C3()
{
  return &unk_182204;
}

//----- (000AC9C9) --------------------------------------------------------
void *sub_AC9C9()
{
  return &unk_182200;
}

//----- (000ACB61) --------------------------------------------------------
int __cdecl sub_ACB61(int a1, unsigned __int8 *a2, int *a3)
{
  int *v3; // edi
  int v4; // ebp
  unsigned __int8 *v5; // ebx
  unsigned __int8 *v6; // ecx
  int v7; // ebx
  int v8; // eax
  unsigned __int8 *v9; // eax
  unsigned int v10; // ebx
  int v11; // eax
  int v13; // [esp-4h] [ebp-18h]
  int v14; // [esp+0h] [ebp-14h]

  v3 = a3;
  v4 = 0;
  v14 = 0;
  *(_BYTE *)(a1 + 16) &= ~2u;
  while ( 1 )
  {
    v5 = a2;
    v6 = ++a2;
    v7 = *v5;
    if ( !v7 )
      break;
    if ( (IsTable[(unsigned __int8)(v7 + 1)] & 2) != 0 )
    {
      v4 += sub_ACE56(a1);
    }
    else if ( v7 == 37 )
    {
      v9 = sub_ACD79(v6, a1);
      a2 = v9;
      v10 = *v9;
      if ( *v9 )
        a2 = v9 + 1;
      if ( v10 < 0x65 )
      {
        if ( v10 < 0x58 )
        {
          if ( v10 < 0x45 )
          {
            if ( v10 == 37 )
            {
              v8 = (*(int (__cdecl **)(int))a1)(a1);
              if ( v8 != 37 )
              {
LABEL_7:
                if ( (*(_BYTE *)(a1 + 16) & 2) == 0 )
                  (*(void (__cdecl **)(int, int))(a1 + 4))(v8, a1);
                break;
              }
            }
          }
          else if ( v10 <= 0x45 || v10 == 71 )
          {
LABEL_45:
            sub_AD1E8(a1, v3);
            goto LABEL_50;
          }
        }
        else
        {
          if ( v10 <= 0x58 )
          {
LABEL_44:
            sub_AD52B(a1, v3, 16, 1);
            goto LABEL_50;
          }
          if ( v10 >= 0x63 )
          {
            if ( v10 <= 0x63 )
            {
              v11 = sub_ACE8D((_WORD *)a1, a1, v3);
              goto LABEL_50;
            }
            v13 = 1;
LABEL_40:
            sub_AD52B(a1, v3, 10, v13);
            goto LABEL_50;
          }
          if ( v10 == 91 )
          {
            sub_AD0E2((_BYTE *)a1, a1, v3, &a2);
            goto LABEL_50;
          }
        }
      }
      else
      {
        if ( v10 <= 0x67 )
          goto LABEL_45;
        if ( v10 < 0x70 )
        {
          if ( v10 < 0x6E )
          {
            if ( v10 == 105 )
            {
              sub_AD52B(a1, v3, 0, 1);
              goto LABEL_50;
            }
          }
          else
          {
            if ( v10 > 0x6E )
            {
              sub_AD52B(a1, v3, 8, 1);
LABEL_50:
              if ( v11 <= 0 )
                break;
              v4 += v11;
              if ( (*(_BYTE *)(a1 + 16) & 1) != 0 )
                ++v14;
              goto LABEL_55;
            }
            sub_AD033(a1, v3, v4);
          }
        }
        else
        {
          if ( v10 <= 0x70 )
            goto LABEL_44;
          if ( v10 < 0x75 )
          {
            if ( v10 == 115 )
            {
              sub_ACF1A((_BYTE *)a1, a1, v3);
              goto LABEL_50;
            }
          }
          else
          {
            if ( v10 <= 0x75 )
            {
              v13 = 0;
              goto LABEL_40;
            }
            if ( v10 == 120 )
              goto LABEL_44;
          }
        }
      }
    }
    else
    {
      v8 = (*(int (__cdecl **)(int))a1)(a1);
      if ( v8 != v7 )
        goto LABEL_7;
      ++v4;
    }
LABEL_55:
    if ( (*(_BYTE *)(a1 + 16) & 2) != 0 )
    {
      if ( *a2 == 37 )
      {
        ++a2;
        a2 = sub_ACD79(a2, a1);
        if ( *a2 == 110 )
          sub_AD033(a1, v3, v4);
      }
      break;
    }
  }
  if ( v14 || (*(_BYTE *)(a1 + 16) & 2) == 0 )
    return v14;
  else
    return -1;
}
// ACCF7: variable 'v11' is possibly undefined

//----- (000ACD79) --------------------------------------------------------
unsigned __int8 *__cdecl sub_ACD79(unsigned __int8 *a1, int a2)
{
  unsigned __int8 *result; // eax
  char v3; // dl
  int v4; // edx
  unsigned __int8 v5; // cl
  int v6; // [esp+0h] [ebp-Ch]

  result = a1;
  v3 = *(_BYTE *)(a2 + 16) | 1;
  *(_DWORD *)(a2 + 12) = -1;
  *(_BYTE *)(a2 + 16) = v3;
  *(_BYTE *)(a2 + 16) = v3 & 3;
  if ( *a1 == 42 )
  {
    result = a1 + 1;
    *(_BYTE *)(a2 + 16) &= ~1u;
  }
  v6 = *result;
  if ( (IsTable[(unsigned __int8)(v6 + 1)] & 0x20) != 0 )
  {
    v4 = 0;
    do
    {
      ++result;
      v4 = v6 - 48 + 10 * v4;
      v6 = *result;
    }
    while ( (IsTable[(unsigned __int8)(v6 + 1)] & 0x20) != 0 );
    *(_DWORD *)(a2 + 12) = v4;
  }
  if ( *result == 78 )
  {
    *(_BYTE *)(a2 + 16) |= 8u;
  }
  else
  {
    if ( *result != 70 )
      goto LABEL_12;
    *(_BYTE *)(a2 + 16) |= 4u;
  }
  ++result;
LABEL_12:
  v5 = *result;
  if ( *result < 0x68u )
  {
    if ( v5 == 76 )
    {
      ++result;
      *(_BYTE *)(a2 + 16) |= 0x40u;
    }
  }
  else if ( *result <= 0x68u )
  {
    ++result;
    *(_BYTE *)(a2 + 16) |= 0x10u;
  }
  else if ( v5 >= 0x6Cu && (v5 <= 0x6Cu || v5 == 119) )
  {
    ++result;
    *(_BYTE *)(a2 + 16) |= 0x20u;
  }
  return result;
}

//----- (000ACE56) --------------------------------------------------------
int __cdecl sub_ACE56(int a1)
{
  int i; // esi
  int v2; // eax

  for ( i = 0; ; ++i )
  {
    v2 = (*(int (__cdecl **)(int))a1)(a1);
    if ( (IsTable[(unsigned __int8)(v2 + 1)] & 2) == 0 )
      break;
  }
  if ( (*(_BYTE *)(a1 + 16) & 2) == 0 )
    (*(void (__cdecl **)(int, int))(a1 + 4))(v2, a1);
  return i;
}

//----- (000ACE8D) --------------------------------------------------------
int __usercall sub_ACE8D@<eax>(_WORD *a1@<esi>, int a2, int *a3)
{
  char v3; // dl
  int v4; // esi
  int v5; // eoff
  int v6; // ecx
  int v7; // edx
  int v8; // edi
  int v9; // ebp
  __int16 v10; // ax
  char v11; // ch

  v3 = *(_BYTE *)(a2 + 16);
  if ( (v3 & 1) != 0 )
  {
    if ( (v3 & 4) != 0 )
    {
      v4 = *a3 + 8;
      *a3 = v4;
      v5 = v4 - 8;
      a1 = *(_WORD **)(v4 - 8);
      __ES__ = *(_WORD *)(v5 + 4);
    }
    else if ( (v3 & 8) != 0 )
    {
      v6 = *a3 + 4;
      *a3 = v6;
      __ES__ = __DS__;
      a1 = *(_WORD **)(v6 - 4);
    }
    else
    {
      v7 = *a3 + 4;
      *a3 = v7;
      __ES__ = __DS__;
      a1 = *(_WORD **)(v7 - 4);
    }
  }
  v8 = *(_DWORD *)(a2 + 12);
  v9 = 0;
  if ( v8 == -1 )
    v8 = 1;
  while ( v8 > 0 )
  {
    v10 = (*(int (__cdecl **)(int))a2)(a2);
    v11 = *(_BYTE *)(a2 + 16);
    if ( (v11 & 2) != 0 )
      break;
    ++v9;
    --v8;
    if ( (v11 & 1) != 0 )
    {
      if ( (v11 & 0x20) != 0 )
      {
        *a1++ = v10;
      }
      else
      {
        *(_BYTE *)a1 = v10;
        a1 = (_WORD *)((char *)a1 + 1);
      }
    }
  }
  return v9;
}

//----- (000ACF1A) --------------------------------------------------------
void __usercall sub_ACF1A(_BYTE *a1@<esi>, int a2, int *a3)
{
  char v3; // dh
  int v4; // esi
  int v5; // eoff
  int v6; // ecx
  int v7; // edx
  int i; // edi
  int v9; // eax
  int v10; // [esp+0h] [ebp-1Ch]
  unsigned __int8 v11; // [esp+4h] [ebp-18h]

  if ( (*(_BYTE *)(a2 + 16) & 0x20) != 0 )
    v11 = 2;
  else
    v11 = 1;
  v3 = *(_BYTE *)(a2 + 16);
  if ( (v3 & 1) != 0 )
  {
    if ( (v3 & 4) != 0 )
    {
      v4 = *a3 + 8;
      *a3 = v4;
      v5 = v4 - 8;
      a1 = *(_BYTE **)(v4 - 8);
      __ES__ = *(_WORD *)(v5 + 4);
    }
    else if ( (v3 & 8) != 0 )
    {
      v6 = *a3 + 4;
      *a3 = v6;
      __ES__ = __DS__;
      a1 = *(_BYTE **)(v6 - 4);
    }
    else
    {
      v7 = *a3 + 4;
      *a3 = v7;
      __ES__ = __DS__;
      a1 = *(_BYTE **)(v7 - 4);
    }
  }
  for ( i = 0; ; ++i )
  {
    v10 = (*(int (__cdecl **)(int))a2)(a2);
    if ( (IsTable[(unsigned __int8)(v10 + 1)] & 2) == 0 )
      break;
  }
  if ( (*(_BYTE *)(a2 + 16) & 2) != 0 )
  {
    i = 0;
  }
  else
  {
    v9 = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 12) = v9 - 1;
    if ( v9 )
    {
      while ( 1 )
      {
        ++i;
        if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
        {
          if ( v11 == 1 )
            *a1 = v10;
          else
            *(_WORD *)a1 = v10;
          a1 += v11;
        }
        v10 = sub_AD783(a2);
        if ( v10 == -1 )
          break;
        if ( (IsTable[(unsigned __int8)(v10 + 1)] & 2) != 0 )
          goto LABEL_23;
      }
    }
    else
    {
LABEL_23:
      (*(void (__cdecl **)(int, int))(a2 + 4))(v10, a2);
    }
  }
  if ( (*(_BYTE *)(a2 + 16) & 1) != 0 && i > 0 )
  {
    if ( v11 == 1 )
      *a1 = 0;
    else
      *(_WORD *)a1 = 0;
  }
  JUMPOUT(0xACF14);
}
// AD02E: control flows out of bounds to ACF14

//----- (000AD033) --------------------------------------------------------
int *__cdecl sub_AD033(int a1, int *a2, int a3)
{
  int *result; // eax
  char v4; // bl
  int v5; // esi
  int v6; // ecx
  int v7; // ebx

  result = a2;
  v4 = *(_BYTE *)(a1 + 16);
  if ( (v4 & 1) != 0 )
  {
    if ( (v4 & 4) != 0 )
    {
      v5 = *a2 + 8;
      *a2 = v5;
      result = *(int **)(v5 - 8);
      __ES__ = *(_WORD *)(v5 - 8 + 4);
    }
    else if ( (v4 & 8) != 0 )
    {
      v6 = *a2 + 4;
      *a2 = v6;
      __ES__ = __DS__;
      result = *(int **)(v6 - 4);
    }
    else
    {
      v7 = *a2 + 4;
      *a2 = v7;
      __ES__ = __DS__;
      result = *(int **)(v7 - 4);
    }
    if ( (*(_BYTE *)(a1 + 16) & 0x10) != 0 )
      *(_WORD *)result = a3;
    else
      *result = a3;
  }
  return result;
}

//----- (000AD09E) --------------------------------------------------------
_BYTE *__cdecl sub_AD09E(_BYTE *a1, int a2)
{
  int v2; // eax
  _BYTE *v3; // ebx

  memset(a2, 0, 32);
  v2 = (unsigned __int8)*a1;
  v3 = a1 + 1;
  if ( *a1 )
  {
    do
    {
      *(_BYTE *)((v2 >> 3) + a2) |= byte_D3EA0[v2 & 7];
      v2 = (unsigned __int8)*v3;
      if ( !*v3 )
        break;
      ++v3;
    }
    while ( v2 != 93 );
  }
  return v3;
}
// 8C250: using guessed type _DWORD __cdecl memset(_DWORD, _DWORD, _DWORD);

//----- (000AD0E2) --------------------------------------------------------
void __usercall sub_AD0E2(_BYTE *a1@<esi>, int a2, int *a3, _BYTE **a4)
{
  _BYTE *v4; // eax
  _BOOL1 v5; // zf
  char v6; // cl
  int v7; // ebp
  int v8; // esi
  int v9; // ecx
  int v10; // edi
  int i; // ebp
  int v12; // eax
  char v13; // dl
  char v14[32]; // [esp+0h] [ebp-40h] BYREF
  int v15; // [esp+20h] [ebp-20h]
  bool v16; // [esp+24h] [ebp-1Ch]
  int v17; // [esp+28h] [ebp-18h]

  v4 = *a4;
  v5 = **a4 != 94;
  v16 = **a4 == 94;
  if ( !v5 )
    *a4 = v4 + 1;
  *a4 = sub_AD09E(*a4, (int)v14);
  v6 = *(_BYTE *)(a2 + 16);
  if ( (v6 & 1) != 0 )
  {
    if ( (v6 & 4) != 0 )
    {
      v7 = *a3 + 8;
      *a3 = v7;
      a1 = *(_BYTE **)(v7 - 8);
      __ES__ = *(_WORD *)(v7 - 8 + 4);
    }
    else if ( (v6 & 8) != 0 )
    {
      v8 = *a3 + 4;
      *a3 = v8;
      __ES__ = __DS__;
      a1 = *(_BYTE **)(v8 - 4);
    }
    else
    {
      v9 = *a3 + 4;
      *a3 = v9;
      __ES__ = __DS__;
      a1 = *(_BYTE **)(v9 - 4);
    }
  }
  v10 = *(_DWORD *)(a2 + 12);
  for ( i = 0; ; ++i )
  {
    if ( !v10 )
      goto LABEL_16;
    v12 = (*(int (__cdecl **)(int))a2)(a2);
    v13 = *(_BYTE *)(a2 + 16);
    v17 = v12;
    if ( (v13 & 2) != 0 )
      goto LABEL_16;
    v15 = (unsigned __int8)v14[v12 >> 3];
    if ( ((unsigned __int8)(v15 & byte_D3EA0[v12 & 7]) == 0) != v16 )
      break;
    --v10;
    if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
      *a1++ = v17;
  }
  (*(void (__cdecl **)(int, int))(a2 + 4))(v12, a2);
LABEL_16:
  if ( (*(_BYTE *)(a2 + 16) & 1) != 0 && i > 0 )
    *a1 = 0;
  JUMPOUT(0xACF14);
}
// AD1E3: control flows out of bounds to ACF14
// AD0E2: using guessed type char var_40[32];

//----- (000AD1E8) --------------------------------------------------------
void __cdecl sub_AD1E8(int a1, int *a2)
{
  char *v2; // ebx
  int v3; // edi
  int i; // ebp
  int v5; // eax
  int v6; // ecx
  char *v7; // ecx
  char v8; // al
  int v9; // eax
  char v10; // ah
  int v11; // ecx
  int *v12; // ebx
  int v13; // ebx
  int v14; // edx
  char v15; // dh
  int v16; // eax
  char v17; // [esp+0h] [ebp-80h] BYREF
  _BYTE v18[3]; // [esp+1h] [ebp-7Fh] BYREF
  int v19[2]; // [esp+50h] [ebp-30h] BYREF
  int v20; // [esp+58h] [ebp-28h]
  unsigned int j; // [esp+5Ch] [ebp-24h]
  int v22; // [esp+60h] [ebp-20h]
  int v23; // [esp+64h] [ebp-1Ch]
  int v24; // [esp+68h] [ebp-18h]

  v2 = &v17;
  v3 = 0;
  for ( i = 0; ; ++i )
  {
    v5 = (*(int (__cdecl **)(int))a1)(a1);
    v22 = v5;
    if ( (IsTable[(unsigned __int8)(v5 + 1)] & 2) == 0 )
      break;
  }
  if ( (*(_BYTE *)(a1 + 16) & 2) != 0 )
    goto LABEL_42;
  v6 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v6 - 1;
  if ( v6 )
  {
    if ( v5 == 43 || v5 == 45 )
    {
      v17 = v22;
      v2 = v18;
      v22 = sub_AD783(a1);
      if ( v22 == -1 )
        goto LABEL_42;
    }
    if ( (IsTable[(unsigned __int8)(v22 + 1)] & 0x20) != 0 || v22 == 46 )
    {
      v20 = 0;
      v23 = 0;
      if ( (IsTable[(unsigned __int8)(v22 + 1)] & 0x20) != 0 )
      {
        v23 = 1;
        while ( 1 )
        {
          *v2++ = v22;
          if ( (*(_BYTE *)(a1 + 16) & 0x10) != 0 )
            HIWORD(v20) = v22 + 10 * HIWORD(v20) - 48;
          ++v3;
          v22 = sub_AD783(a1);
          if ( v22 == -1 )
            break;
          if ( (IsTable[(unsigned __int8)(v22 + 1)] & 0x20) == 0 )
            goto LABEL_17;
        }
LABEL_42:
        if ( v3 > 0 && (*(_BYTE *)(a1 + 16) & 1) != 0 )
        {
          *v2 = 0;
          if ( (*(_BYTE *)(a1 + 16) & 0x10) != 0 )
          {
            if ( v17 == 45 )
              v20 = -v20;
          }
          else
          {
            off_E4D20(&v17, v19);
          }
          v10 = *(_BYTE *)(a1 + 16);
          if ( (v10 & 4) != 0 )
          {
            v11 = *a2 + 8;
            *a2 = v11;
            v12 = *(int **)(v11 - 8);
            __ES__ = *(_WORD *)(v11 - 8 + 4);
          }
          else if ( (v10 & 8) != 0 )
          {
            v13 = *a2 + 4;
            *a2 = v13;
            __ES__ = __DS__;
            v12 = *(int **)(v13 - 4);
          }
          else
          {
            v14 = *a2 + 4;
            *a2 = v14;
            __ES__ = __DS__;
            v12 = *(int **)(v14 - 4);
          }
          v15 = *(_BYTE *)(a1 + 16);
          if ( (v15 & 0x10) != 0 )
          {
            v16 = v20;
          }
          else
          {
            if ( (v15 & 0x20) != 0 || (v15 & 0x40) != 0 )
            {
              *v12 = v19[0];
              v12[1] = v19[1];
              goto LABEL_60;
            }
            v16 = _FDFS();
          }
          *v12 = v16;
        }
LABEL_60:
        JUMPOUT(0xACF14);
      }
LABEL_17:
      if ( v22 == 46 )
      {
        *v2++ = 46;
        v22 = sub_AD783(a1);
        if ( v22 == -1 )
          goto LABEL_42;
        if ( !v23 && (IsTable[(unsigned __int8)(v22 + 1)] & 0x20) == 0 )
          goto LABEL_41;
        ++v3;
        do
        {
          if ( (IsTable[(unsigned __int8)(v22 + 1)] & 0x20) == 0 )
            break;
          ++v3;
          *v2++ = v22;
          v22 = sub_AD783(a1);
        }
        while ( v22 != -1 );
        if ( (*(_BYTE *)(a1 + 16) & 0x10) != 0 )
        {
          v7 = v2;
          for ( j = 0; ; j /= 0xAu )
          {
            v8 = *--v7;
            if ( *v7 == 46 )
              break;
            v24 = 10;
            BYTE2(j) = v8 - 48;
          }
          LOWORD(v20) = j;
        }
        if ( v22 == -1 )
          goto LABEL_42;
      }
      if ( (*(_BYTE *)(a1 + 16) & 0x10) == 0 && (v22 == 101 || v22 == 69) )
      {
        ++v3;
        *v2 = v22;
        v9 = sub_AD783(a1);
        ++v2;
        v22 = v9;
        if ( v9 == -1 )
          goto LABEL_42;
        if ( v9 == 43 || v9 == 45 )
        {
          ++v3;
          *v2++ = v22;
          v22 = sub_AD783(a1);
          if ( v22 == -1 )
            goto LABEL_42;
        }
        if ( (IsTable[(unsigned __int8)(v22 + 1)] & 0x20) != 0 )
        {
          while ( 1 )
          {
            ++v3;
            *v2++ = v22;
            v22 = sub_AD783(a1);
            if ( v22 == -1 )
              goto LABEL_42;
            if ( (IsTable[(unsigned __int8)(v22 + 1)] & 0x20) == 0 )
              goto LABEL_41;
          }
        }
        v3 = 0;
      }
    }
  }
LABEL_41:
  (*(void (__cdecl **)(int, int))(a1 + 4))(v22, a1);
  goto LABEL_42;
}
// AD526: control flows out of bounds to ACF14
// B4C3A: using guessed type int _FDFS(void);
// E4D20: using guessed type int (__cdecl *off_E4D20)(_DWORD, _DWORD);

//----- (000AD52B) --------------------------------------------------------
void __cdecl sub_AD52B(int a1, int *a2, int a3, int a4)
{
  int v4; // ebp
  int v5; // edi
  int v6; // esi
  int v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  char v15; // ah
  int v16; // edx
  _WORD *v17; // eax
  int v18; // ebp
  int v19; // ecx
  int v20; // [esp+0h] [ebp-20h]
  int v21; // [esp+4h] [ebp-1Ch]
  int i; // [esp+8h] [ebp-18h]

  v4 = a3;
  v5 = 0;
  v6 = 0;
  for ( i = 0; ; ++i )
  {
    v7 = (*(int (__cdecl **)(int))a1)(a1);
    v21 = v7;
    if ( (IsTable[(unsigned __int8)(v7 + 1)] & 2) == 0 )
      break;
  }
  if ( (*(_BYTE *)(a1 + 16) & 2) != 0 )
    goto LABEL_34;
  v8 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v8 - 1;
  if ( v8 )
  {
    v20 = 43;
    if ( a4 && (v7 == 43 || v7 == 45) )
    {
      v20 = v7;
      v21 = sub_AD783(a1);
      if ( v21 == -1 )
        goto LABEL_34;
    }
    if ( !a3 )
    {
      if ( v21 != 48 )
      {
        v4 = 10;
        goto LABEL_26;
      }
      v9 = sub_AD783(a1);
      v6 = 1;
      v21 = v9;
      if ( v9 != -1 )
      {
        if ( v9 != 120 && v9 != 88 )
        {
          v4 = 8;
          goto LABEL_26;
        }
        v6 = 0;
        v21 = sub_AD783(a1);
        if ( v21 != -1 )
        {
          v4 = 16;
          goto LABEL_26;
        }
      }
      goto LABEL_34;
    }
    if ( a3 != 16 || v21 != 48 )
      goto LABEL_26;
    v10 = sub_AD783(a1);
    v6 = 1;
    v21 = v10;
    if ( v10 == -1 )
    {
LABEL_34:
      if ( v20 == 45 )
        v5 = -v5;
      if ( v6 > 0 )
      {
        v15 = *(_BYTE *)(a1 + 16);
        if ( (v15 & 1) != 0 )
        {
          if ( (v15 & 4) != 0 )
          {
            v16 = *a2 + 8;
            *a2 = v16;
            v17 = *(_WORD **)(v16 - 8);
            __ES__ = *(_WORD *)(v16 - 8 + 4);
          }
          else if ( (v15 & 8) != 0 )
          {
            v18 = *a2 + 4;
            *a2 = v18;
            __ES__ = __DS__;
            v17 = *(_WORD **)(v18 - 4);
          }
          else
          {
            v19 = *a2 + 4;
            *a2 = v19;
            __ES__ = __DS__;
            v17 = *(_WORD **)(v19 - 4);
          }
          if ( (*(_BYTE *)(a1 + 16) & 0x10) != 0 )
            *v17 = v5;
          else
            *(_DWORD *)v17 = v5;
        }
      }
      JUMPOUT(0xACF14);
    }
    if ( v10 == 120 || v10 == 88 )
    {
      v11 = sub_AD783(a1);
      v6 = 0;
      goto LABEL_25;
    }
LABEL_26:
    while ( 1 )
    {
      v12 = sub_AD754(v21);
      if ( v12 >= v4 )
        break;
      v5 = v12 + v4 * v5;
      v11 = sub_AD783(a1);
      ++v6;
LABEL_25:
      v21 = v11;
      if ( v11 == -1 )
        goto LABEL_34;
    }
    if ( v21 == 58 && *(char *)(a1 + 16) < 0 )
    {
      while ( 1 )
      {
        v13 = sub_AD783(a1);
        ++v6;
        v21 = v13;
        if ( v13 == -1 )
          goto LABEL_34;
        v14 = sub_AD754(v13);
        if ( v14 >= v4 )
          break;
        v5 = v14 + v4 * v5;
      }
    }
  }
  (*(void (__cdecl **)(int, int))(a1 + 4))(v21, a1);
  goto LABEL_34;
}
// AD74F: control flows out of bounds to ACF14
// AD6E0: variable 'v20' is possibly undefined

//----- (000AD754) --------------------------------------------------------
int __cdecl sub_AD754(int a1)
{
  int v2; // eax

  if ( a1 >= 48 && a1 <= 57 )
    return a1 - 48;
  v2 = tolower(a1);
  if ( v2 < 97 || v2 > 102 )
    return 16;
  else
    return v2 - 87;
}
// AB952: using guessed type _DWORD __cdecl tolower(_DWORD);

//----- (000AD783) --------------------------------------------------------
int __cdecl sub_AD783(int a1)
{
  int v1; // eax
  int result; // eax

  v1 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v1 - 1;
  if ( !v1 )
    return -1;
  result = (*(int (__cdecl **)(int))a1)(a1);
  if ( (*(_BYTE *)(a1 + 16) & 2) != 0 )
    return -1;
  return result;
}

//----- (000ADC52) --------------------------------------------------------
int __cdecl sub_ADC52(_BYTE *a1)
{
  int v1; // edx
  int v2; // eax

  if ( a1 && *a1 )
  {
    fputs(a1, &unk_E3BE0);
    fputs(asc_D3A8C, &unk_E3BE0);
  }
  v1 = *(_DWORD *)sub_AC9C3();
  v2 = strerror(v1);
  fputs(v2, &unk_E3BE0);
  return fputc(10, &unk_E3BE0);
}
// AC9CF: using guessed type _DWORD __cdecl fputc(_DWORD, _DWORD);
// B4E49: using guessed type _DWORD __cdecl fputs(_DWORD, _DWORD);
// B4EDE: using guessed type _DWORD __cdecl strerror(_DWORD);

//----- (000AEAF5) --------------------------------------------------------
int sub_AEAF5()
{
  return dword_E4C90;
}
// E4C90: using guessed type int dword_E4C90;

//----- (000AEF40) --------------------------------------------------------
int __usercall sub_AEF40@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int result; // eax

  do
  {
    v3 = *a3++;
    result = v3 ^ 0x8000;
    *a2++ = BYTE1(result);
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AEF51) --------------------------------------------------------
int __usercall sub_AEF51@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>)
{
  int result; // eax

  do
  {
    result = *a3++;
    *a2++ = BYTE1(result);
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AEF5D) --------------------------------------------------------
int __usercall sub_AEF5D@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    result = v3 ^ 0x8000;
    BYTE1(v4) ^= 0x80u;
    LOBYTE(v4) = BYTE1(result);
    *a2++ = v4;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AEF7C) --------------------------------------------------------
int __usercall sub_AEF7C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax
  int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    LOBYTE(v4) = BYTE1(result);
    *a2++ = v4;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AEF90) --------------------------------------------------------
char __usercall sub_AEF90@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  __int16 v5; // ax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    HIBYTE(v5) = BYTE1(v3) ^ 0x80;
    LOBYTE(v5) = (unsigned __int16)(v4 ^ 0x8000) >> 8;
    *a2++ = v5;
    --a1;
  }
  while ( a1 );
  return v5;
}

//----- (000AEFAF) --------------------------------------------------------
char __usercall sub_AEFAF@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // edx
  int v4; // eax

  do
  {
    v4 = *a3;
    v3 = a3[1];
    a3 += 2;
    LOBYTE(v4) = BYTE1(v3);
    *a2++ = v4;
    --a1;
  }
  while ( a1 );
  return v4;
}

//----- (000AEFC3) --------------------------------------------------------
int __usercall sub_AEFC3@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    *a3 = BYTE1(result);
    *a2 = (unsigned __int16)(v5 ^ 0x8000) >> 8;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AEFE0) --------------------------------------------------------
int __usercall sub_AEFE0@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    *a3 = BYTE1(result);
    *a2 = BYTE1(v5);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AEFF2) --------------------------------------------------------
int __usercall sub_AEFF2@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    *a3 = (unsigned __int16)(v5 ^ 0x8000) >> 8;
    *a2 = BYTE1(result);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF00F) --------------------------------------------------------
int __usercall sub_AF00F@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    *a3 = BYTE1(v5);
    *a2 = BYTE1(result);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF021) --------------------------------------------------------
int __usercall sub_AF021@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int result; // eax

  do
  {
    v3 = *a3++;
    result = v3 ^ 0x8000;
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF035) --------------------------------------------------------
int __usercall sub_AF035@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax

  do
  {
    result = *a3++;
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF044) --------------------------------------------------------
__int16 __usercall sub_AF044@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  __int16 result; // ax
  char v5; // t0

  do
  {
    v3 = *a3++;
    LOWORD(v3) = v3 ^ 0x8000;
    v5 = v3;
    LOBYTE(result) = BYTE1(v3);
    HIBYTE(result) = v5;
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF05A) --------------------------------------------------------
__int16 __usercall sub_AF05A@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  __int16 result; // ax
  char v5; // t0

  do
  {
    v3 = *a3++;
    v5 = v3;
    LOBYTE(result) = BYTE1(v3);
    HIBYTE(result) = v5;
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF06B) --------------------------------------------------------
int __usercall sub_AF06B@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    result = v3 ^ 0x8000;
    *a2 = result;
    a2[1] = v4 ^ 0x8000;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF08C) --------------------------------------------------------
int __usercall sub_AF08C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax
  int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    *a2 = result;
    a2[1] = v4;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF0A2) --------------------------------------------------------
int __usercall sub_AF0A2@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    result = v3 ^ 0x8000;
    *a2 = v4 ^ 0x8000;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF0C3) --------------------------------------------------------
int __usercall sub_AF0C3@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax
  int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    *a2 = v4;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF0D9) --------------------------------------------------------
int __usercall sub_AF0D9@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax
  char v6; // t0
  char v7; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    result = v3 ^ 0x8000;
    LOWORD(v4) = v4 ^ 0x8000;
    v6 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v6;
    v7 = v4;
    LOBYTE(v4) = BYTE1(v4);
    BYTE1(v4) = v7;
    *a2 = result;
    a2[1] = v4;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF0FE) --------------------------------------------------------
int __usercall sub_AF0FE@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // edx
  int result; // eax
  char v5; // t0
  char v6; // t1

  do
  {
    result = *a3;
    v3 = a3[1];
    a3 += 2;
    v5 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v5;
    v6 = v3;
    LOBYTE(v3) = BYTE1(v3);
    BYTE1(v3) = v6;
    *a2 = result;
    a2[1] = v3;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF118) --------------------------------------------------------
int __usercall sub_AF118@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax
  char v6; // t0
  char v7; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    result = v3 ^ 0x8000;
    LOWORD(v4) = v4 ^ 0x8000;
    v6 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v6;
    v7 = v4;
    LOBYTE(v4) = BYTE1(v4);
    BYTE1(v4) = v7;
    *a2 = v4;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF13D) --------------------------------------------------------
int __usercall sub_AF13D@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // edx
  int result; // eax
  char v5; // t0
  char v6; // t1

  do
  {
    result = *a3;
    v3 = a3[1];
    a3 += 2;
    v5 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v5;
    v6 = v3;
    LOBYTE(v3) = BYTE1(v3);
    BYTE1(v3) = v6;
    *a2 = v3;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF157) --------------------------------------------------------
int __usercall sub_AF157@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    *a3 = result;
    *a2 = v5 ^ 0x8000;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF17A) --------------------------------------------------------
int __usercall sub_AF17A@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    *a3 = result;
    *a2 = v5;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF192) --------------------------------------------------------
int __usercall sub_AF192@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    *a3 = v5 ^ 0x8000;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF1B5) --------------------------------------------------------
int __usercall sub_AF1B5@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    *a3 = v5;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF1CD) --------------------------------------------------------
int __usercall sub_AF1CD@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax
  char v7; // t0
  char v8; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    LOWORD(v5) = v5 ^ 0x8000;
    v7 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v7;
    v8 = v5;
    LOBYTE(v5) = BYTE1(v5);
    BYTE1(v5) = v8;
    *a3 = result;
    *a2 = v5;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF1F4) --------------------------------------------------------
int __usercall sub_AF1F4@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // edx
  int result; // eax
  char v6; // t0
  char v7; // t1

  do
  {
    result = *a4;
    v4 = a4[1];
    a4 += 2;
    v6 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v6;
    v7 = v4;
    LOBYTE(v4) = BYTE1(v4);
    BYTE1(v4) = v7;
    *a3 = result;
    *a2 = v4;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF210) --------------------------------------------------------
int __usercall sub_AF210@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax
  char v7; // t0
  char v8; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    LOWORD(v5) = v5 ^ 0x8000;
    v7 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v7;
    v8 = v5;
    LOBYTE(v5) = BYTE1(v5);
    BYTE1(v5) = v8;
    *a3 = v5;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF237) --------------------------------------------------------
int __usercall sub_AF237@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // edx
  int result; // eax
  char v6; // t0
  char v7; // t1

  do
  {
    result = *a4;
    v4 = a4[1];
    a4 += 2;
    v6 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v6;
    v7 = v4;
    LOBYTE(v4) = BYTE1(v4);
    BYTE1(v4) = v7;
    *a3 = v4;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF253) --------------------------------------------------------
int __usercall sub_AF253@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int result; // eax

  do
  {
    v3 = *a3++;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      v3 = -32768;
    }
    result = v3 ^ 0x8000;
    *a2++ = BYTE1(result);
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF280) --------------------------------------------------------
int __usercall sub_AF280@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>)
{
  int result; // eax

  do
  {
    result = *a3++;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    *a2++ = BYTE1(result);
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF2A8) --------------------------------------------------------
int __usercall sub_AF2A8@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax
  __int16 v6; // dx

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      v3 = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      BYTE1(v4) = 127;
    }
    else if ( v4 < -32768 )
    {
      BYTE1(v4) = 0x80;
    }
    result = v3 ^ 0x8000;
    HIBYTE(v6) = BYTE1(v4) ^ 0x80;
    LOBYTE(v6) = BYTE1(result);
    *a2++ = v6;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF301) --------------------------------------------------------
int __usercall sub_AF301@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax
  int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      BYTE1(v4) = 127;
    }
    else if ( v4 < -32768 )
    {
      BYTE1(v4) = 0x80;
    }
    LOBYTE(v4) = BYTE1(result);
    *a2++ = v4;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF34F) --------------------------------------------------------
char __usercall sub_AF34F@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  __int16 v5; // ax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      BYTE1(v3) = 127;
    }
    else if ( v3 < -32768 )
    {
      BYTE1(v3) = 0x80;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = 0x8000;
    }
    HIBYTE(v5) = BYTE1(v3) ^ 0x80;
    LOBYTE(v5) = (unsigned __int16)(v4 ^ 0x8000) >> 8;
    *a2++ = v5;
    --a1;
  }
  while ( a1 );
  return v5;
}

//----- (000AF3A8) --------------------------------------------------------
char __usercall sub_AF3A8@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      BYTE1(v3) = 127;
    }
    else if ( v3 < -32768 )
    {
      BYTE1(v3) = 0x80;
    }
    if ( v4 > 0x7FFF )
    {
      BYTE1(v4) = 127;
    }
    else if ( v4 < -32768 )
    {
      BYTE1(v4) = 0x80;
    }
    LOBYTE(v3) = BYTE1(v4);
    *a2++ = v3;
    --a1;
  }
  while ( a1 );
  return v3;
}

//----- (000AF3F6) --------------------------------------------------------
int __usercall sub_AF3F6@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      v4 = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = 0x8000;
    }
    result = v4 ^ 0x8000;
    *a3 = BYTE1(result);
    *a2 = (unsigned __int16)(v5 ^ 0x8000) >> 8;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF44D) --------------------------------------------------------
int __usercall sub_AF44D@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      BYTE1(v5) = 127;
    }
    else if ( v5 < -32768 )
    {
      BYTE1(v5) = 0x80;
    }
    *a3 = BYTE1(result);
    *a2 = BYTE1(v5);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF499) --------------------------------------------------------
int __usercall sub_AF499@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      v4 = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = 0x8000;
    }
    result = v4 ^ 0x8000;
    *a3 = (unsigned __int16)(v5 ^ 0x8000) >> 8;
    *a2 = BYTE1(result);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF4F0) --------------------------------------------------------
int __usercall sub_AF4F0@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      BYTE1(v5) = 127;
    }
    else if ( v5 < -32768 )
    {
      BYTE1(v5) = 0x80;
    }
    *a3 = BYTE1(v5);
    *a2 = BYTE1(result);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF53C) --------------------------------------------------------
int __usercall sub_AF53C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int result; // eax

  do
  {
    v3 = *a3++;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      v3 = -32768;
    }
    result = v3 ^ 0x8000;
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF56C) --------------------------------------------------------
int __usercall sub_AF56C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax

  do
  {
    result = *a3++;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF597) --------------------------------------------------------
__int16 __usercall sub_AF597@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  __int16 v4; // ax
  __int16 result; // ax
  char v6; // t0

  do
  {
    v3 = *a3++;
    if ( v3 > 0x7FFF )
    {
      LOWORD(v3) = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      LOWORD(v3) = 0x8000;
    }
    v4 = v3 ^ 0x8000;
    v6 = v4;
    LOBYTE(result) = HIBYTE(v4);
    HIBYTE(result) = v6;
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF5C9) --------------------------------------------------------
__int16 __usercall sub_AF5C9@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  __int16 result; // ax
  char v5; // t0

  do
  {
    v3 = *a3++;
    if ( v3 > 0x7FFF )
    {
      LOWORD(v3) = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      LOWORD(v3) = 0x8000;
    }
    v5 = v3;
    LOBYTE(result) = BYTE1(v3);
    HIBYTE(result) = v5;
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF5F6) --------------------------------------------------------
int __usercall sub_AF5F6@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      v3 = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = 0x8000;
    }
    result = v3 ^ 0x8000;
    *a2 = result;
    a2[1] = v4 ^ 0x8000;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF651) --------------------------------------------------------
int __usercall sub_AF651@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax
  int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = 0x8000;
    }
    *a2 = result;
    a2[1] = v4;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF6A1) --------------------------------------------------------
int __usercall sub_AF6A1@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      v3 = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = 0x8000;
    }
    result = v3 ^ 0x8000;
    *a2 = v4 ^ 0x8000;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF6FC) --------------------------------------------------------
int __usercall sub_AF6FC@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax
  int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = 0x8000;
    }
    *a2 = v4;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF74C) --------------------------------------------------------
int __usercall sub_AF74C@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  __int16 v5; // dx
  int result; // eax
  char v7; // t0
  char v8; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      v3 = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = 0x8000;
    }
    result = v3 ^ 0x8000;
    v5 = v4 ^ 0x8000;
    v7 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v7;
    v8 = v5;
    LOBYTE(v5) = HIBYTE(v5);
    HIBYTE(v5) = v8;
    *a2 = result;
    a2[1] = v5;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF7AB) --------------------------------------------------------
__int16 __usercall sub_AF7AB@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  __int16 result; // ax
  char v6; // t0
  __int16 v7; // dx
  char v8; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      LOWORD(v3) = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      LOWORD(v3) = 0x8000;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = 0x8000;
    }
    v6 = v3;
    LOBYTE(result) = BYTE1(v3);
    HIBYTE(result) = v6;
    v8 = v4;
    LOBYTE(v7) = BYTE1(v4);
    HIBYTE(v7) = v8;
    *a2 = result;
    a2[1] = v7;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF7FF) --------------------------------------------------------
int __usercall sub_AF7FF@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  __int16 v5; // dx
  int result; // eax
  char v7; // t0
  char v8; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      v3 = -32768;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = 0x8000;
    }
    result = v3 ^ 0x8000;
    v5 = v4 ^ 0x8000;
    v7 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v7;
    v8 = v5;
    LOBYTE(v5) = HIBYTE(v5);
    HIBYTE(v5) = v8;
    *a2 = v5;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF85E) --------------------------------------------------------
__int16 __usercall sub_AF85E@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  __int16 result; // ax
  char v6; // t0
  __int16 v7; // dx
  char v8; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      LOWORD(v3) = 0x7FFF;
    }
    else if ( v3 < -32768 )
    {
      LOWORD(v3) = 0x8000;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = 0x8000;
    }
    v6 = v3;
    LOBYTE(result) = BYTE1(v3);
    HIBYTE(result) = v6;
    v8 = v4;
    LOBYTE(v7) = BYTE1(v4);
    HIBYTE(v7) = v8;
    *a2 = v7;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF8B2) --------------------------------------------------------
int __usercall sub_AF8B2@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      v4 = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = 0x8000;
    }
    result = v4 ^ 0x8000;
    *a3 = result;
    *a2 = v5 ^ 0x8000;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF90F) --------------------------------------------------------
int __usercall sub_AF90F@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = 0x8000;
    }
    *a3 = result;
    *a2 = v5;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF961) --------------------------------------------------------
int __usercall sub_AF961@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      v4 = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = 0x8000;
    }
    result = v4 ^ 0x8000;
    *a3 = v5 ^ 0x8000;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AF9BE) --------------------------------------------------------
int __usercall sub_AF9BE@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < -32768 )
    {
      result = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = 0x8000;
    }
    *a3 = v5;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AFA10) --------------------------------------------------------
int __usercall sub_AFA10@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  __int16 v6; // dx
  int result; // eax
  char v8; // t0
  char v9; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      v4 = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = 0x8000;
    }
    result = v4 ^ 0x8000;
    v6 = v5 ^ 0x8000;
    v8 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v8;
    v9 = v6;
    LOBYTE(v6) = HIBYTE(v6);
    HIBYTE(v6) = v9;
    *a3 = result;
    *a2 = v6;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AFA71) --------------------------------------------------------
__int16 __usercall sub_AFA71@<ax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  __int16 result; // ax
  char v7; // t0
  __int16 v8; // dx
  char v9; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = 0x8000;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = 0x8000;
    }
    v7 = v4;
    LOBYTE(result) = BYTE1(v4);
    HIBYTE(result) = v7;
    v9 = v5;
    LOBYTE(v8) = BYTE1(v5);
    HIBYTE(v8) = v9;
    *a3 = result;
    *a2 = v8;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AFAC7) --------------------------------------------------------
int __usercall sub_AFAC7@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  __int16 v6; // dx
  int result; // eax
  char v8; // t0
  char v9; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      v4 = -32768;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = 0x8000;
    }
    result = v4 ^ 0x8000;
    v6 = v5 ^ 0x8000;
    v8 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v8;
    v9 = v6;
    LOBYTE(v6) = HIBYTE(v6);
    HIBYTE(v6) = v9;
    *a3 = v6;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AFB28) --------------------------------------------------------
__int16 __usercall sub_AFB28@<ax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  __int16 result; // ax
  char v7; // t0
  __int16 v8; // dx
  char v9; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < -32768 )
    {
      LOWORD(v4) = 0x8000;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < -32768 )
    {
      LOWORD(v5) = 0x8000;
    }
    v7 = v4;
    LOBYTE(result) = BYTE1(v4);
    HIBYTE(result) = v7;
    v9 = v5;
    LOBYTE(v8) = BYTE1(v5);
    HIBYTE(v8) = v9;
    *a3 = v8;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000AFB7E) --------------------------------------------------------
int __usercall sub_AFB7E@<eax>(int result@<eax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>)
{
  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    BYTE1(result) = *a3;
    result ^= 0x8000u;
    ++a3;
    *a2++ += (__int16)result;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFB9F) --------------------------------------------------------
int __usercall sub_AFB9F@<eax>(int result@<eax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>)
{
  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    BYTE1(result) = *a3;
    result ^= 0x8000u;
    ++a3;
    *a2 += (__int16)result;
    a2[1] += (__int16)result;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFBC3) --------------------------------------------------------
int __usercall sub_AFBC3@<eax>(int result@<eax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    BYTE1(result) = *a4;
    HIBYTE(a2) = a4[1];
    result ^= 0x8000u;
    a2 ^= 0x8000u;
    a4 += 2;
    *a3 += (__int16)result;
    a3[1] += a2;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFBF5) --------------------------------------------------------
int __usercall sub_AFBF5@<eax>(int result@<eax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    HIBYTE(a2) = *a4;
    BYTE1(result) = a4[1];
    result ^= 0x8000u;
    a2 ^= 0x8000u;
    a4 += 2;
    *a3 += (__int16)result;
    a3[1] += a2;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFC27) --------------------------------------------------------
__int16 __usercall sub_AFC27@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    result = *a2++ ^ 0x8000;
    *a1++ += result;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFC4B) --------------------------------------------------------
__int16 __usercall sub_AFC4B@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    result = *a2++ ^ 0x8000;
    *a1 += result;
    a1[1] += result;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFC72) --------------------------------------------------------
__int16 __usercall sub_AFC72@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>)
{
  __int16 result; // ax
  __int16 v3; // bx

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    result = *a2 ^ 0x8000;
    v3 = a2[1] ^ 0x8000;
    a2 += 2;
    *a1 += result;
    a1[1] += v3;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFCA6) --------------------------------------------------------
__int16 __usercall sub_AFCA6@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>)
{
  __int16 result; // ax
  __int16 v3; // bx

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    result = a2[1] ^ 0x8000;
    v3 = *a2 ^ 0x8000;
    a2 += 2;
    *a1 += result;
    a1[1] += v3;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFCDA) --------------------------------------------------------
__int16 __usercall sub_AFCDA@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>)
{
  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    HIBYTE(result) = *a3++;
    *a2++ += result;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFCF6) --------------------------------------------------------
__int16 __usercall sub_AFCF6@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>)
{
  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    HIBYTE(result) = *a3++;
    *a2 += result;
    a2[1] += result;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFD15) --------------------------------------------------------
__int16 __usercall sub_AFD15@<ax>(__int16 result@<ax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    HIBYTE(result) = *a4;
    HIBYTE(a2) = a4[1];
    a4 += 2;
    *a3 += result;
    a3[1] += a2;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFD3C) --------------------------------------------------------
__int16 __usercall sub_AFD3C@<ax>(__int16 result@<ax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    HIBYTE(a2) = *a4;
    HIBYTE(result) = a4[1];
    a4 += 2;
    *a3 += result;
    a3[1] += a2;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFD63) --------------------------------------------------------
__int16 __usercall sub_AFD63@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    result = *a2++;
    *a1++ += result;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFD82) --------------------------------------------------------
__int16 __usercall sub_AFD82@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    result = *a2++;
    *a1 += result;
    a1[1] += result;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFDA4) --------------------------------------------------------
__int16 __usercall sub_AFDA4@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>)
{
  __int16 result; // ax
  __int16 v3; // bx

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    result = *a2;
    v3 = a2[1];
    a2 += 2;
    *a1 += result;
    a1[1] += v3;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFDCD) --------------------------------------------------------
__int16 __usercall sub_AFDCD@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>)
{
  __int16 v2; // bx
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_E4E24 )
      break;
    v2 = *a2;
    result = a2[1];
    a2 += 2;
    *a1 += result;
    a1[1] += v2;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000AFDF6) --------------------------------------------------------
int __usercall sub_AFDF6@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    BYTE1(result) = *a4;
    result ^= 0x8000u;
    a4 = (_BYTE *)((qword_E4E30 + __PAIR64__((unsigned int)a4, a2)) >> 32);
    a2 += qword_E4E30;
    *a3++ += (__int16)result;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFE22) --------------------------------------------------------
int __usercall sub_AFE22@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    BYTE1(result) = *a4;
    result ^= 0x8000u;
    a4 = (_BYTE *)((qword_E4E30 + __PAIR64__((unsigned int)a4, a2)) >> 32);
    a2 += qword_E4E30;
    *a3 += (__int16)result;
    a3[1] += (__int16)result;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFE51) --------------------------------------------------------
int __usercall sub_AFE51@<eax>(
        int result@<eax>,
        unsigned int a2@<ecx>,
        __int16 a3@<bx>,
        _DWORD *a4@<edi>,
        _BYTE *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    BYTE1(result) = *a5;
    HIBYTE(a3) = a5[1];
    result ^= 0x8000u;
    a3 ^= 0x8000u;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a5 += *((_DWORD *)&qword_E4E30 + v5 + 1);
    *a4 += (__int16)result;
    a4[1] += a3;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFE91) --------------------------------------------------------
int __usercall sub_AFE91@<eax>(
        int result@<eax>,
        unsigned int a2@<ecx>,
        __int16 a3@<bx>,
        _DWORD *a4@<edi>,
        _BYTE *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    HIBYTE(a3) = *a5;
    BYTE1(result) = a5[1];
    result ^= 0x8000u;
    a3 ^= 0x8000u;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a5 += *((_DWORD *)&qword_E4E30 + v5 + 1);
    *a4 += (__int16)result;
    a4[1] += a3;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFED1) --------------------------------------------------------
__int16 __usercall sub_AFED1@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3 ^ 0x8000;
    v4 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (_WORD *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v4 + 1));
    *a2++ += result;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFF03) --------------------------------------------------------
__int16 __usercall sub_AFF03@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3 ^ 0x8000;
    v4 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (_WORD *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v4 + 1));
    *a2 += result;
    a2[1] += result;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFF38) --------------------------------------------------------
__int16 __usercall sub_AFF38@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>)
{
  __int16 result; // ax
  __int16 v4; // bx
  int v5; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3 ^ 0x8000;
    v4 = a3[1] ^ 0x8000;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (_WORD *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a2 += result;
    a2[1] += v4;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFF7A) --------------------------------------------------------
__int16 __usercall sub_AFF7A@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>)
{
  __int16 result; // ax
  __int16 v4; // bx
  int v5; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = a3[1] ^ 0x8000;
    v4 = *a3 ^ 0x8000;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (_WORD *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a2 += result;
    a2[1] += v4;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFFBC) --------------------------------------------------------
__int16 __usercall sub_AFFBC@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    HIBYTE(result) = *a4;
    a4 = (_BYTE *)((qword_E4E30 + __PAIR64__((unsigned int)a4, a2)) >> 32);
    a2 += qword_E4E30;
    *a3++ += result;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000AFFE3) --------------------------------------------------------
__int16 __usercall sub_AFFE3@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    HIBYTE(result) = *a4;
    a4 = (_BYTE *)((qword_E4E30 + __PAIR64__((unsigned int)a4, a2)) >> 32);
    a2 += qword_E4E30;
    *a3 += result;
    a3[1] += result;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B000D) --------------------------------------------------------
__int16 __usercall sub_B000D@<ax>(
        __int16 result@<ax>,
        unsigned int a2@<ecx>,
        __int16 a3@<bx>,
        _DWORD *a4@<edi>,
        _BYTE *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    HIBYTE(result) = *a5;
    HIBYTE(a3) = a5[1];
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a5 += *((_DWORD *)&qword_E4E30 + v5 + 1);
    *a4 += result;
    a4[1] += a3;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0042) --------------------------------------------------------
__int16 __usercall sub_B0042@<ax>(
        __int16 result@<ax>,
        unsigned int a2@<ecx>,
        __int16 a3@<bx>,
        _DWORD *a4@<edi>,
        _BYTE *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    HIBYTE(a3) = *a5;
    HIBYTE(result) = a5[1];
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a5 += *((_DWORD *)&qword_E4E30 + v5 + 1);
    *a4 += result;
    a4[1] += a3;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0077) --------------------------------------------------------
__int16 __usercall sub_B0077@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3;
    v4 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (__int16 *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v4 + 1));
    *a2++ += result;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B00A4) --------------------------------------------------------
__int16 __usercall sub_B00A4@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3;
    v4 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (__int16 *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v4 + 1));
    *a2 += result;
    a2[1] += result;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B00D4) --------------------------------------------------------
__int16 __usercall sub_B00D4@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax
  __int16 v4; // bx
  int v5; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3;
    v4 = a3[1];
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (__int16 *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a2 += result;
    a2[1] += v4;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B010B) --------------------------------------------------------
__int16 __usercall sub_B010B@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 v3; // bx
  __int16 result; // ax
  int v5; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    v3 = *a3;
    result = a3[1];
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a1) >> 32;
    a1 += qword_E4E30;
    a3 = (__int16 *)((char *)a3 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a2 += result;
    a2[1] += v3;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0142) --------------------------------------------------------
char __usercall sub_B0142@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a4++;
    *a3++ += *(_DWORD *)(a2 + 4 * a1);
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B015E) --------------------------------------------------------
char __usercall sub_B015E@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a4++;
    *a3 += *(_DWORD *)(a2 + 4 * a1);
    a3[1] += *(_DWORD *)(a2 + 4 * a1 + 1024);
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B0184) --------------------------------------------------------
char __usercall sub_B0184@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a5;
    LOBYTE(a3) = a5[1];
    a5 += 2;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    *a4++ += *(_DWORD *)(a2 + 4 * a3 + 1024);
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B01AE) --------------------------------------------------------
char __usercall sub_B01AE@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a5;
    LOBYTE(a3) = a5[1];
    a5 += 2;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    a4[1] += *(_DWORD *)(a2 + 4 * a3 + 1024);
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B01D9) --------------------------------------------------------
char __usercall sub_B01D9@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOBYTE(a3) = *a5;
    LOBYTE(a1) = a5[1];
    a5 += 2;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    *a4++ += *(_DWORD *)(a2 + 4 * a3 + 1024);
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B0203) --------------------------------------------------------
char __usercall sub_B0203@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOBYTE(a3) = *a5;
    LOBYTE(a1) = a5[1];
    a5 += 2;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    a4[1] += *(_DWORD *)(a2 + 4 * a3 + 1024);
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B022E) --------------------------------------------------------
int __usercall sub_B022E@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOWORD(result) = *a4;
    result ^= 0x8000u;
    ++a4;
    *a3++ += (*a2 * (__int16)result) >> 7;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B0258) --------------------------------------------------------
int __usercall sub_B0258@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOWORD(result) = *a4;
    result ^= 0x8000u;
    ++a4;
    *a3 += (*a2 * (__int16)result) >> 7;
    a3[1] += (a2[256] * (__int16)result) >> 7;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B0292) --------------------------------------------------------
int __usercall sub_B0292@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>)
{
  __int16 v4; // bx

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOWORD(result) = *a4;
    result ^= 0x8000u;
    v4 = a4[1] ^ 0x8000;
    a4 += 2;
    *a3 += (*a2 * (__int16)result) >> 7;
    *a3++ += (a2[256] * v4) >> 7;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B02D5) --------------------------------------------------------
int __usercall sub_B02D5@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>)
{
  __int16 v4; // bx

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOWORD(result) = *a4;
    result ^= 0x8000u;
    v4 = a4[1] ^ 0x8000;
    a4 += 2;
    *a3 += (*a2 * (__int16)result) >> 7;
    a3[1] += (a2[256] * v4) >> 7;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B0319) --------------------------------------------------------
int __usercall sub_B0319@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>)
{
  __int16 v4; // bx

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOWORD(result) = a4[1];
    result ^= 0x8000u;
    v4 = *a4 ^ 0x8000;
    a4 += 2;
    *a3 += (*a2 * (__int16)result) >> 7;
    *a3++ += (a2[256] * v4) >> 7;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B035C) --------------------------------------------------------
int __usercall sub_B035C@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<edi>, _WORD *a4@<esi>)
{
  __int16 v4; // bx

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    LOWORD(result) = a4[1];
    result ^= 0x8000u;
    v4 = *a4 ^ 0x8000;
    a4 += 2;
    *a3 += (*a2 * (__int16)result) >> 7;
    a3[1] += (a2[256] * v4) >> 7;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B03A0) --------------------------------------------------------
__int16 __usercall sub_B03A0@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3++;
    *a2++ += (*a1 * result) >> 7;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B03C5) --------------------------------------------------------
__int16 __usercall sub_B03C5@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3++;
    *a2 += (*a1 * result) >> 7;
    a2[1] += (a1[256] * result) >> 7;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B03FA) --------------------------------------------------------
__int16 __usercall sub_B03FA@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax
  __int16 v4; // bx

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    *a2 += (*a1 * result) >> 7;
    *a2++ += (a1[256] * v4) >> 7;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B0432) --------------------------------------------------------
__int16 __usercall sub_B0432@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax
  __int16 v4; // bx

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    *a2 += (*a1 * result) >> 7;
    a2[1] += (a1[256] * v4) >> 7;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B046B) --------------------------------------------------------
__int16 __usercall sub_B046B@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 v3; // bx
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    v3 = *a3;
    result = a3[1];
    a3 += 2;
    *a2 += (*a1 * result) >> 7;
    *a2++ += (a1[256] * v3) >> 7;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B04A3) --------------------------------------------------------
__int16 __usercall sub_B04A3@<ax>(_DWORD *a1@<edx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 v3; // bx
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a3 >= dword_E4E24 )
      break;
    v3 = *a3;
    result = a3[1];
    a3 += 2;
    *a2 += (*a1 * result) >> 7;
    a2[1] += (a1[256] * v3) >> 7;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;

//----- (000B04DC) --------------------------------------------------------
char __usercall sub_B04DC@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a5;
    a5 = (_BYTE *)((qword_E4E30 + __PAIR64__((unsigned int)a5, a3)) >> 32);
    a3 += qword_E4E30;
    *a4++ += *(_DWORD *)(a2 + 4 * a1);
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0503) --------------------------------------------------------
char __usercall sub_B0503@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a5;
    a5 = (_BYTE *)((qword_E4E30 + __PAIR64__((unsigned int)a5, a3)) >> 32);
    a3 += qword_E4E30;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    a4[1] += *(_DWORD *)(a2 + 4 * a1 + 1024);
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0534) --------------------------------------------------------
char __usercall sub_B0534@<al>(
        int a1@<eax>,
        int a2@<edx>,
        unsigned int a3@<ecx>,
        int a4@<ebx>,
        _DWORD *a5@<edi>,
        _BYTE *a6@<esi>)
{
  int v6; // ebp

  do
  {
    if ( (unsigned int)a6 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a6;
    LOBYTE(a4) = a6[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a6 += *((_DWORD *)&qword_E4E30 + v6 + 1);
    *a5 += *(_DWORD *)(a2 + 4 * a1);
    *a5++ += *(_DWORD *)(a2 + 4 * a4 + 1024);
  }
  while ( (unsigned int)a5 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B056C) --------------------------------------------------------
char __usercall sub_B056C@<al>(
        int a1@<eax>,
        int a2@<edx>,
        unsigned int a3@<ecx>,
        int a4@<ebx>,
        _DWORD *a5@<edi>,
        _BYTE *a6@<esi>)
{
  int v6; // ebp

  do
  {
    if ( (unsigned int)a6 >= dword_E4E24 )
      break;
    LOBYTE(a1) = *a6;
    LOBYTE(a4) = a6[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a6 += *((_DWORD *)&qword_E4E30 + v6 + 1);
    *a5 += *(_DWORD *)(a2 + 4 * a1);
    a5[1] += *(_DWORD *)(a2 + 4 * a4 + 1024);
    a5 += 2;
  }
  while ( (unsigned int)a5 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B05A5) --------------------------------------------------------
char __usercall sub_B05A5@<al>(
        int a1@<eax>,
        int a2@<edx>,
        unsigned int a3@<ecx>,
        int a4@<ebx>,
        _DWORD *a5@<edi>,
        _BYTE *a6@<esi>)
{
  int v6; // ebp

  do
  {
    if ( (unsigned int)a6 >= dword_E4E24 )
      break;
    LOBYTE(a4) = *a6;
    LOBYTE(a1) = a6[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a6 += *((_DWORD *)&qword_E4E30 + v6 + 1);
    *a5 += *(_DWORD *)(a2 + 4 * a1);
    *a5++ += *(_DWORD *)(a2 + 4 * a4 + 1024);
  }
  while ( (unsigned int)a5 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B05DD) --------------------------------------------------------
char __usercall sub_B05DD@<al>(
        int a1@<eax>,
        int a2@<edx>,
        unsigned int a3@<ecx>,
        int a4@<ebx>,
        _DWORD *a5@<edi>,
        _BYTE *a6@<esi>)
{
  int v6; // ebp

  do
  {
    if ( (unsigned int)a6 >= dword_E4E24 )
      break;
    LOBYTE(a4) = *a6;
    LOBYTE(a1) = a6[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a6 += *((_DWORD *)&qword_E4E30 + v6 + 1);
    *a5 += *(_DWORD *)(a2 + 4 * a1);
    a5[1] += *(_DWORD *)(a2 + 4 * a4 + 1024);
    a5 += 2;
  }
  while ( (unsigned int)a5 < dword_E4E2C );
  return a1;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0616) --------------------------------------------------------
int __usercall sub_B0616@<eax>(
        int result@<eax>,
        _DWORD *a2@<edx>,
        unsigned int a3@<ecx>,
        _DWORD *a4@<edi>,
        _WORD *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOWORD(result) = *a5;
    result ^= 0x8000u;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a5 = (_WORD *)((char *)a5 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a4++ += (*a2 * (__int16)result) >> 7;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B064E) --------------------------------------------------------
int __usercall sub_B064E@<eax>(
        int result@<eax>,
        _DWORD *a2@<edx>,
        unsigned int a3@<ecx>,
        _DWORD *a4@<edi>,
        _WORD *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOWORD(result) = *a5;
    result ^= 0x8000u;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a5 = (_WORD *)((char *)a5 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a4 += (*a2 * (__int16)result) >> 7;
    a4[1] += (a2[256] * (__int16)result) >> 7;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0696) --------------------------------------------------------
int __usercall sub_B0696@<eax>(
        int result@<eax>,
        _DWORD *a2@<edx>,
        unsigned int a3@<ecx>,
        _DWORD *a4@<edi>,
        _WORD *a5@<esi>)
{
  __int16 v5; // bx
  int v6; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOWORD(result) = *a5;
    result ^= 0x8000u;
    v5 = a5[1] ^ 0x8000;
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a5 = (_WORD *)((char *)a5 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a4 += (*a2 * (__int16)result) >> 7;
    *a4++ += (a2[256] * v5) >> 7;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B06E7) --------------------------------------------------------
int __usercall sub_B06E7@<eax>(
        int result@<eax>,
        _DWORD *a2@<edx>,
        unsigned int a3@<ecx>,
        _DWORD *a4@<edi>,
        _WORD *a5@<esi>)
{
  __int16 v5; // bx
  int v6; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOWORD(result) = *a5;
    result ^= 0x8000u;
    v5 = a5[1] ^ 0x8000;
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a5 = (_WORD *)((char *)a5 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a4 += (*a2 * (__int16)result) >> 7;
    a4[1] += (a2[256] * v5) >> 7;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0739) --------------------------------------------------------
int __usercall sub_B0739@<eax>(
        int result@<eax>,
        _DWORD *a2@<edx>,
        unsigned int a3@<ecx>,
        _DWORD *a4@<edi>,
        _WORD *a5@<esi>)
{
  __int16 v5; // bx
  int v6; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOWORD(result) = a5[1];
    result ^= 0x8000u;
    v5 = *a5 ^ 0x8000;
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a5 = (_WORD *)((char *)a5 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a4 += (*a2 * (__int16)result) >> 7;
    *a4++ += (a2[256] * v5) >> 7;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B078A) --------------------------------------------------------
int __usercall sub_B078A@<eax>(
        int result@<eax>,
        _DWORD *a2@<edx>,
        unsigned int a3@<ecx>,
        _DWORD *a4@<edi>,
        _WORD *a5@<esi>)
{
  __int16 v5; // bx
  int v6; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_E4E24 )
      break;
    LOWORD(result) = a5[1];
    result ^= 0x8000u;
    v5 = *a5 ^ 0x8000;
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a3) >> 32;
    a3 += qword_E4E30;
    a5 = (_WORD *)((char *)a5 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a4 += (*a2 * (__int16)result) >> 7;
    a4[1] += (a2[256] * v5) >> 7;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B07DC) --------------------------------------------------------
__int16 __usercall sub_B07DC@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>)
{
  __int16 result; // ax
  int v5; // ebp

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    result = *a4;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a4 = (__int16 *)((char *)a4 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a3++ += (*a1 * result) >> 7;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B080F) --------------------------------------------------------
__int16 __usercall sub_B080F@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>)
{
  __int16 result; // ax
  int v5; // ebp

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    result = *a4;
    v5 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a4 = (__int16 *)((char *)a4 + *((_DWORD *)&qword_E4E30 + v5 + 1));
    *a3 += (*a1 * result) >> 7;
    a3[1] += (a1[256] * result) >> 7;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0852) --------------------------------------------------------
__int16 __usercall sub_B0852@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>)
{
  __int16 result; // ax
  __int16 v5; // bx
  int v6; // ebp

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    result = *a4;
    v5 = a4[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a4 = (__int16 *)((char *)a4 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a3 += (*a1 * result) >> 7;
    *a3++ += (a1[256] * v5) >> 7;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0898) --------------------------------------------------------
__int16 __usercall sub_B0898@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>)
{
  __int16 result; // ax
  __int16 v5; // bx
  int v6; // ebp

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    result = *a4;
    v5 = a4[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a4 = (__int16 *)((char *)a4 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a3 += (*a1 * result) >> 7;
    a3[1] += (a1[256] * v5) >> 7;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B08DF) --------------------------------------------------------
__int16 __usercall sub_B08DF@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>)
{
  __int16 v4; // bx
  __int16 result; // ax
  int v6; // ebp

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    v4 = *a4;
    result = a4[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a4 = (__int16 *)((char *)a4 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a3 += (*a1 * result) >> 7;
    *a3++ += (a1[256] * v4) >> 7;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B0925) --------------------------------------------------------
__int16 __usercall sub_B0925@<ax>(_DWORD *a1@<edx>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, __int16 *a4@<esi>)
{
  __int16 v4; // bx
  __int16 result; // ax
  int v6; // ebp

  do
  {
    if ( (unsigned int)a4 >= dword_E4E24 )
      break;
    v4 = *a4;
    result = a4[1];
    v6 = ((unsigned int)qword_E4E30 + (unsigned __int64)a2) >> 32;
    a2 += qword_E4E30;
    a4 = (__int16 *)((char *)a4 + *((_DWORD *)&qword_E4E30 + v6 + 1));
    *a3 += (*a1 * result) >> 7;
    a3[1] += (a1[256] * v4) >> 7;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_E4E2C );
  return result;
}
// E4E24: using guessed type int dword_E4E24;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;

//----- (000B096C) --------------------------------------------------------
int __cdecl sub_B096C(int a1)
{
  int v1; // ecx
  _DWORD *v2; // edi
  int v3; // eax
  unsigned __int64 v4; // rax
  int v5; // eax
  char *v6; // edx
  unsigned int v7; // eax
  int v8; // ebx
  _DWORD *v9; // edi
  int v10; // ebx
  unsigned int v11; // esi
  int v12; // edx
  int v13; // ebx
  int result; // eax
  int v15; // ebx

  v1 = a1;
  v2 = *(_DWORD **)a1;
  v3 = 0;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 24) == 2 || v2[6] == 3 )
    v3 = 1;
  if ( *(_DWORD *)(a1 + 52) == 2 || *(_DWORD *)(a1 + 52) == 3 )
  {
    v3 |= 2u;
    if ( (*(_DWORD *)(a1 + 56) & 2) != 0 )
      v3 |= 4u;
  }
  if ( *(_DWORD *)(a1 + 52) == 1 || *(_DWORD *)(a1 + 52) == 3 )
    v3 |= 8u;
  if ( ((v3 & 2) == 0 || (v3 & 1) != 0) && *(_DWORD *)(a1 + 64) == 127 && v2[26] == 127 && *(_DWORD *)(a1 + 68) == 64
    || (v3 |= 0x40u, (v3 & 8) != 0) )
  {
    if ( (*(_DWORD *)(a1 + 56) & 1) != 0 )
      v3 |= 0x10u;
  }
  dword_E4E1C = v3;
  LODWORD(v4) = 0;
  HIDWORD(v4) = *(_DWORD *)(a1 + 60);
  if ( SHIDWORD(v4) <= 0 )
    HIDWORD(v4) = 1;
  v5 = v4 / (unsigned int)(v2[5] << 16);
  v6 = (char *)(v5 - (_DWORD)sub_10000);
  if ( v5 <= (int)sub_10000 )
    v6 = (char *)sub_10000 - v5;
  if ( (unsigned int)v6 > dword_181DC4 )
  {
    LODWORD(qword_E4E30) = v5 << 16;
    v7 = HIWORD(v5);
    v8 = v7 + 1;
    if ( (dword_E4E1C & 2) != 0 )
    {
      v7 *= 2;
      v8 *= 2;
    }
    if ( (dword_E4E1C & 8) != 0 )
    {
      v7 *= 2;
      v8 *= 2;
    }
    HIDWORD(qword_E4E30) = v7;
    dword_E4E38 = v8;
    dword_E4E1C |= 0x20u;
  }
  dword_E4E28 = v2[20];
  dword_E4E2C = v2[19] + dword_E4E28;
  v9 = (_DWORD *)dword_E4E28;
  do
  {
    v10 = *(_DWORD *)(v1 + 40);
    dword_E4E20 = *(_DWORD *)(v1 + 4 * v10 + 24) + *(_DWORD *)(v1 + 4 * v10 + 8);
    dword_E4E24 = *(_DWORD *)(v1 + 4 * v10 + 16) + *(_DWORD *)(v1 + 4 * v10 + 8);
    if ( *(_DWORD *)(v1 + 2120) )
      (*(void (__stdcall **)(int))(v1 + 2120))(v1);
    v11 = dword_E4E20;
    v12 = v1 + 72;
    ((void (__usercall *)(int@<eax>, _DWORD *@<edi>, _BYTE *@<esi>))funcs_B0AC1[dword_E4E1C])(
      0,
      v9,
      (_BYTE *)dword_E4E20);
    v1 = a1;
    v13 = *(_DWORD *)(a1 + 40);
    result = v11 - *(_DWORD *)(a1 + 4 * v13 + 8);
    *(_DWORD *)(a1 + 4 * v13 + 24) = result;
    if ( v11 < dword_E4E24 )
      break;
    if ( *(_DWORD *)(a1 + 2124) )
      result = (*(int (__fastcall **)(int, int, int))(a1 + 2124))(a1, v12, v13);
    if ( *(_DWORD *)(a1 + 48) )
    {
      if ( *(_DWORD *)(a1 + 48) == 1 )
      {
        v15 = *(_DWORD *)(a1 + 40) ^ 1;
        if ( *(_DWORD *)(a1 + 4 * v15 + 32) )
        {
          *(_DWORD *)(a1 + 4) = 2;
          if ( *(_DWORD *)(a1 + 2128) )
            return (*(int (__fastcall **)(int, int, int))(a1 + 2128))(a1, v12, v15);
          return result;
        }
        if ( !*(_DWORD *)(a1 + 4 * v15 + 16) || *(_DWORD *)(a1 + 4 * v15 + 24) )
          return result;
        *(_DWORD *)(a1 + 40) = v15;
      }
      else
      {
        --*(_DWORD *)(a1 + 48);
      }
    }
    *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 40) + 24) = 0;
  }
  while ( (unsigned int)v9 < dword_E4E2C );
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// AED40: using guessed type int (*funcs_B0AC1[2])();
// E4E1C: using guessed type int dword_E4E1C;
// E4E20: using guessed type int dword_E4E20;
// E4E24: using guessed type int dword_E4E24;
// E4E28: using guessed type int dword_E4E28;
// E4E2C: using guessed type int dword_E4E2C;
// E4E30: using guessed type __int64 qword_E4E30;
// E4E38: using guessed type int dword_E4E38;
// 181DC4: using guessed type int dword_181DC4;

//----- (000B0B87) --------------------------------------------------------
int __cdecl sub_B0B87(_DWORD *a1, int a2)
{
  int v2; // eax
  int *v3; // esi
  int v4; // ecx
  _BYTE *v5; // edi

  v2 = a1[7] & 0xF;
  if ( a1[6] == 2 || a1[6] == 3 )
    v2 |= 0x10u;
  if ( a1[6] == 1 || a1[6] == 3 )
    v2 |= 0x20u;
  if ( a1[25] > 1u )
    v2 |= 0x40u;
  dword_E4E1C = v2;
  v3 = (int *)a1[20];
  v4 = a1[18];
  if ( (a1[7] & 0x20) != 0 )
  {
    dword_E4E1C |= 8u;
    v5 = (_BYTE *)(a2 * (a1[4] >> 1) + a1[11]);
  }
  else
  {
    v5 = (_BYTE *)a1[a2 + 11];
  }
  return ((int (__usercall *)@<eax>(int@<ecx>, _BYTE *@<edi>, int *@<esi>))funcs_B0C0B[dword_E4E1C])(v4, v5, v3);
}
// AEB40: using guessed type int (*funcs_B0C0B[2])();
// E4E1C: using guessed type int dword_E4E1C;

//----- (000B0C1A) --------------------------------------------------------
int __cdecl sub_B0C1A(int a1)
{
  char *v1; // edi
  int result; // eax
  unsigned int v3; // [esp-Ch] [ebp-18h]

  v1 = *(char **)(a1 + 80);
  result = 0;
  v3 = *(_DWORD *)(a1 + 76);
  memset(v1, 0, v3 & 3);
  memset(&v1[v3 & 3], 0, 4 * (v3 >> 2));
  return result;
}

//----- (000B0C46) --------------------------------------------------------
bool sub_B0C46()
{
  sub_9D590((unsigned int)&dword_E4E1C, (unsigned int)&word_E4E3C);
  return sub_9D590((unsigned int)funcs_B0C0B, (unsigned int)sub_B0C46);
}
// AEB40: using guessed type int (*funcs_B0C0B[2])();
// E4E1C: using guessed type int dword_E4E1C;
// E4E3C: using guessed type __int16 word_E4E3C;

//----- (000B0CC8) --------------------------------------------------------
char *sub_B0CC8()
{
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  return (char *)&retaddr - dword_E4C94;
}
// B0CCA: returning address of temporary local variable '%" r"'
// E4C94: using guessed type int dword_E4C94;

//----- (000B0CD2) --------------------------------------------------------
void sub_B0CD2()
{
  word_E4E3C = __SS__;
}
// E4E3C: using guessed type __int16 word_E4E3C;

//----- (000B0D52) --------------------------------------------------------
void sub_B0D52()
{
  if ( (char *)off_E3B90 != (char *)sub_B4FA3 )
  {
    off_E4CBD = (int (__fastcall *)(_DWORD))_sigfpe_handler;
    sub_B4F46();
    off_E3B90 = (int (*)())sub_B4FA3;
  }
  sub_B5000();
}
// 98D8B: using guessed type int _sigfpe_handler();
// E3B90: using guessed type int (*off_E3B90)();
// E4CBD: using guessed type int (__fastcall *off_E4CBD)(_DWORD);

//----- (000B0D80) --------------------------------------------------------
void sub_B0D80()
{
  dword_E731C = 0x8000;
}
// E731C: using guessed type int dword_E731C;

//----- (000B1138) --------------------------------------------------------
int __cdecl sub_B1138(int *a1, int a2)
{
  int result; // eax
  int v3; // eax
  int v4; // edx
  int v5; // eax

  result = calloc(a2, 4);
  *a1 = result;
  if ( result )
  {
    result = calloc(a2, 4);
    a1[1] = result;
    if ( result )
    {
      a1[2] = a2;
      v3 = 0;
      if ( a1[2] > 0 )
      {
        v4 = 0;
        do
        {
          *(_DWORD *)(*a1 + v4) = 0x4000;
          ++v3;
          v4 += 4;
        }
        while ( v3 < a1[2] );
      }
      a1[3] = *a1;
      v5 = *a1;
      a1[4] = 4 * (a1[2] - 1) + *a1;
      a1[5] = v5 - 4;
      return 1;
    }
  }
  return result;
}
// 9B513: using guessed type _DWORD __cdecl calloc(_DWORD, _DWORD);

//----- (000B11E8) --------------------------------------------------------
int __cdecl sub_B11E8(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  int v4; // edx
  _DWORD *v5; // ecx

  v2 = (_DWORD *)a1[3];
  v3 = v2;
  a1[3] = v2 + 1;
  *v2 = a2;
  if ( *a1 + 4 * a1[2] == a1[3] )
    a1[3] = *a1;
  v4 = 0;
  do
  {
    v5 = v2--;
    v4 += *v5;
    if ( v2 == (_DWORD *)a1[5] )
      v2 = (_DWORD *)a1[4];
  }
  while ( v2 != v3 );
  return v4 / a1[2];
}

//----- (000B12A4) --------------------------------------------------------
int __cdecl sub_B12A4(int a1)
{
  int v1; // edx
  int v2; // eax
  int v3; // eax
  int v4; // ecx
  unsigned __int64 v5; // rax
  int result; // eax

  if ( a1 >= 0 )
    v1 = a1;
  else
    v1 = -a1;
  v2 = v1 >> 6;
  if ( v1 >> 6 < 256 )
  {
    v4 = dword_E7724[v2];
    v5 = (v1 & 0x3F) * ((__int64)*(&off_E7728 + v2) - v4);
    v3 = v4 + (HIDWORD(v5) != 0) + (v5 >> 6);
  }
  else
  {
    v3 = dword_E7B24;
  }
  result = v3 >> 14;
  if ( a1 < 0 )
    return -result;
  return result;
}
// E7724: using guessed type int dword_E7724[];
// E7728: using guessed type void *off_E7728;
// E7B24: using guessed type int dword_E7B24;

//----- (000B1304) --------------------------------------------------------
int __cdecl sub_B1304(int a1, int a2)
{
  int result; // eax
  unsigned int v3; // edx
  int v4; // ecx
  int v5; // esi

  result = a1;
  if ( a1 || a2 )
  {
    if ( a1 >= 0 )
    {
      v4 = a1;
      v3 = 0;
    }
    else
    {
      v3 = 1;
      v4 = -a1;
    }
    if ( a2 >= 0 )
    {
      v5 = a2;
    }
    else
    {
      LOBYTE(v3) = v3 | 2;
      v5 = -a2;
    }
    if ( v4 >= v5 )
    {
      switch ( v3 )
      {
        case 0u:
        case 2u:
          result = 25735 - sub_B12A4(((__int64)a2 << 14) / a1);
          break;
        case 1u:
        case 3u:
          result = -25735 - sub_B12A4(((__int64)a2 << 14) / a1);
          break;
        default:
          result = 0;
          break;
      }
    }
    else if ( v3 < 2 )
    {
      return sub_B12A4(((__int64)a1 << 14) / a2);
    }
    else if ( v3 <= 2 )
    {
      return sub_B12A4(((__int64)a1 << 14) / a2) + 51471;
    }
    else if ( v3 == 3 )
    {
      return sub_B12A4(((__int64)a1 << 14) / a2) - 51471;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (000B1414) --------------------------------------------------------
int __cdecl sub_B1414(int a1)
{
  int v1; // edx
  int v2; // eax
  int v3; // eax
  int v4; // ecx
  unsigned __int64 v5; // rax
  int result; // eax

  if ( a1 >= 0 )
    v1 = ((__int64)a1 << 14) / 25735;
  else
    v1 = ((__int64)a1 << 14) / -25735;
  v2 = v1 >> 6;
  if ( v1 >> 6 < 256 )
  {
    v4 = dword_E7320[v2];
    v5 = (v1 & 0x3F) * (__int64)(dword_E7324[v2] - v4);
    v3 = v4 + (HIDWORD(v5) != 0) + (v5 >> 6);
  }
  else
  {
    v3 = dword_E7720;
  }
  result = v3 >> 14;
  if ( a1 < 0 )
    return -result;
  return result;
}
// E7320: using guessed type int dword_E7320[];
// E7324: using guessed type int dword_E7324[255];
// E7720: using guessed type int dword_E7720;

//----- (000B148C) --------------------------------------------------------
int __cdecl sub_B148C(int a1)
{
  int v1; // edx
  int v3; // eax

  v1 = a1 % 102943 + (a1 % 102943 < 0 ? 0x1921F : 0);
  if ( v1 <= 25735 )
    return sub_B1414(v1);
  if ( v1 <= 51471 )
    return sub_B1414(51471 - v1);
  if ( v1 > 77207 )
    v3 = sub_B1414(102943 - v1);
  else
    v3 = sub_B1414(v1 - 51471);
  return -v3;
}

//----- (000B14F8) --------------------------------------------------------
int __cdecl sub_B14F8(int *a1, int a2)
{
  int result; // eax

  *a1 = sub_B148C(a2);
  result = sub_B148C(a2 + 25735);
  a1[1] = result;
  return result;
}

//----- (000B1C58) --------------------------------------------------------
char __cdecl sub_B1C58(
        int a1,
        __int16 a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        __int16 a15)
{
  int v15; // esi
  __int16 v16; // dx
  char result; // al
  _BOOL1 i; // zf
  unsigned __int8 v19; // ah
  __int16 v20; // bx
  int v21; // ebx
  int v22; // eax

  v15 = a14;
  v16 = HIWORD(a1);
  result = *MK_FP(a15, a14);
  for ( i = *MK_FP(a15, a14) == 0x9B; *MK_FP(a15, v15) <= 0x9Bu; i = *MK_FP(a15, v15) == 0x9B )
  {
    if ( !i )
    {
      switch ( result )
      {
        case '&':
          v16 = a2;
          ++v15;
          goto LABEL_5;
        case '.':
          v16 = a15;
          ++v15;
          goto LABEL_5;
        case '6':
          v16 = HIWORD(a1);
          ++v15;
          goto LABEL_5;
        case '>':
          v16 = a1;
          ++v15;
          goto LABEL_5;
        case 'd':
          v16 = __FS__;
          ++v15;
          goto LABEL_5;
        case 'e':
          v16 = __GS__;
          ++v15;
          goto LABEL_5;
      }
      if ( result != 102 && result != 103 )
        break;
    }
    ++v15;
LABEL_5:
    result = *MK_FP(a15, v15);
  }
  if ( (result & 0xF8) == 0xD8 )
  {
    v19 = *MK_FP(a15, v15 + 1);
    if ( v19 < 0xC0u )
    {
      LOBYTE(v20) = *MK_FP(a15, v15 + 1);
      HIBYTE(v20) = v19 >> 3;
      v21 = v20 & 0x1807;
      LOWORD(v21) = (unsigned __int8)(BYTE1(v21) | v21);
      funcs_B1CA2[v21]();
      ((void (__fastcall __noreturn *)(int, __int16, int))_GETDS)(v22, v16, (unsigned __int8)v22 | BYTE1(v22) & 0x38);
    }
    ((void (__noreturn *)(void))_GETDS)();
  }
  return result;
}
// B1CB9: variable 'v22' is possibly undefined
// B1904: using guessed type int (*funcs_B1CA2[24])();

//----- (000B1D8C) --------------------------------------------------------
int __usercall sub_B1D8C@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        char a29)
{
  _DWORD *v29; // ebx
  int v30; // edx
  int v31; // eax
  _BOOL1 v32; // cf
  int v33; // eax

  v29 = (_DWORD *)(a2 + a1 + 28);
  v30 = -256;
  v31 = *(_DWORD *)(a2 + a1 + 32);
  v32 = __CFSHL__(v31, 25);
  v33 = v31 << 25;
  if ( v32 )
  {
    if ( !v33 && !*v29 )
      v30 = -512;
    v32 = __CFADD__(*(_DWORD *)(a2 + a1 + 32), 256);
    *(_DWORD *)(a2 + a1 + 32) += 256;
    if ( v32 )
    {
      *(_DWORD *)(a2 + a1 + 32) = 0x80000000;
      ++*(_WORD *)(a2 + a1 + 36);
    }
  }
  *(_DWORD *)(a2 + a1 + 32) &= v30;
  *v29 = 0;
  return sub_B1C58(
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29);
}
// B1DC3: cannot handle tail call to vararg
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B1DC8) --------------------------------------------------------
int __usercall sub_B1DC8@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        char a29)
{
  _QWORD *v29; // ebx
  int v30; // edx
  _BOOL1 v31; // cf

  v29 = (_QWORD *)(a2 + a1 + 28);
  v30 = -2048;
  if ( __CFSHL__(*(_DWORD *)v29, 22) )
  {
    if ( !(*(_DWORD *)v29 << 22) )
      v30 = -4096;
    v31 = __CFADD__(*v29, 2048i64);
    *v29 += 2048i64;
    if ( v31 )
    {
      *(_DWORD *)(a2 + a1 + 32) = 0x80000000;
      ++*(_WORD *)(a2 + a1 + 36);
    }
  }
  *(_DWORD *)v29 &= v30;
  return sub_B1C58(
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29);
}
// B1DF5: cannot handle tail call to vararg
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B1E68) --------------------------------------------------------
int __usercall sub_B1E68@<eax>(int result@<eax>, int a2@<ecx>, _BYTE *a3@<ebp>)
{
  _BYTE v3[108]; // [esp-80h] [ebp-80h] BYREF
  int v4; // [esp-14h] [ebp-14h]
  int v5; // [esp-10h] [ebp-10h]
  int v6; // [esp-Ch] [ebp-Ch]

  a3[4] |= result;
  if ( ((unsigned __int8)result & *a3) == 0 )
  {
    v6 = a2;
    v5 = (unsigned __int16)__ES__;
    v4 = (unsigned __int16)__DS__;
    qmemcpy(v3, a3, sizeof(v3));
    result = off_E4CBD(BYTE1(result));
    qmemcpy(a3, v3, 0x6Cu);
  }
  return result;
}
// E4CBD: using guessed type int (__fastcall *off_E4CBD)(_DWORD);

//----- (000B1EB6) --------------------------------------------------------
void sub_B1EB6()
{
  ;
}

//----- (000B1EBC) --------------------------------------------------------
void sub_B1EBC()
{
  ;
}

//----- (000B1EC2) --------------------------------------------------------
void sub_B1EC2()
{
  ;
}

//----- (000B1EC8) --------------------------------------------------------
void sub_B1EC8()
{
  ;
}

//----- (000B1ECE) --------------------------------------------------------
void sub_B1ECE()
{
  ;
}

//----- (000B1ED6) --------------------------------------------------------
void sub_B1ED6()
{
  ;
}

//----- (000B1EDC) --------------------------------------------------------
void sub_B1EDC()
{
  ;
}

//----- (000B1EE2) --------------------------------------------------------
void sub_B1EE2()
{
  ;
}

//----- (000B1EE8) --------------------------------------------------------
void sub_B1EE8()
{
  ;
}

//----- (000B1EF0) --------------------------------------------------------
void sub_B1EF0()
{
  ;
}

//----- (000B1EF8) --------------------------------------------------------
void sub_B1EF8()
{
  ;
}

//----- (000B1F00) --------------------------------------------------------
void sub_B1F00()
{
  ;
}

//----- (000B1F08) --------------------------------------------------------
void sub_B1F08()
{
  ;
}

//----- (000B1F12) --------------------------------------------------------
void sub_B1F12()
{
  ;
}

//----- (000B1F1C) --------------------------------------------------------
void sub_B1F1C()
{
  ;
}

//----- (000B1F24) --------------------------------------------------------
void sub_B1F24()
{
  ;
}

//----- (000B1F2C) --------------------------------------------------------
void sub_B1F2C()
{
  ;
}

//----- (000B1F35) --------------------------------------------------------
void sub_B1F35()
{
  ;
}

//----- (000B1F3E) --------------------------------------------------------
void sub_B1F3E()
{
  ;
}

//----- (000B1F47) --------------------------------------------------------
void sub_B1F47()
{
  ;
}

//----- (000B1F50) --------------------------------------------------------
void sub_B1F50()
{
  ;
}

//----- (000B1F5B) --------------------------------------------------------
void sub_B1F5B()
{
  ;
}

//----- (000B1F66) --------------------------------------------------------
void sub_B1F66()
{
  ;
}

//----- (000B1F6F) --------------------------------------------------------
void sub_B1F6F()
{
  ;
}

//----- (000B1F78) --------------------------------------------------------
char __usercall sub_B1F78@<al>(unsigned __int8 a1@<ah>, int a2@<ebx>, _BYTE *a3@<esi>)
{
  char result; // al

  LOWORD(a2) = (a1 >> 3) & 0x18 | *a3 & 7;
  funcs_B1F8B[a2]();
  return result;
}
// B1964: using guessed type int (*funcs_B1F8B[24])();

//----- (000B1FB5) --------------------------------------------------------
int __usercall sub_B1FB5@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>)
{
  int v3; // eax

  sub_B3BA6(*a3, a1 + 108);
  v3 = sub_B337C(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B1FD4) --------------------------------------------------------
int __usercall sub_B1FD4@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>)
{
  int v3; // eax

  sub_B3BA6(*a3, a1 + 108);
  v3 = sub_B37B0(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B1FF3) --------------------------------------------------------
int __usercall sub_B1FF3@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        signed int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  __int16 v30; // dx
  int v32; // eax

  sub_B3BA6(*a3, a1 + 108);
  v32 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v30 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v30) |= *((_BYTE *)&dword_B1860[37] + v32 + 3);
  *(_WORD *)(a1 + 4) = v30;
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B1E63: cannot handle tail call to vararg
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B200F) --------------------------------------------------------
int __usercall sub_B200F@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        signed int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  __int16 v30; // dx
  __int16 v31; // bx
  int v33; // eax

  sub_B3BA6(*a3, a1 + 108);
  v33 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v30 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v30) |= *((_BYTE *)&dword_B1860[37] + v33 + 3);
  *(_WORD *)(a1 + 4) = v30;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v31 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v31;
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B1E47: cannot handle tail call to vararg
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B202B) --------------------------------------------------------
int __usercall sub_B202B@<eax>(int a1@<ebp>, signed int *a2@<esi>)
{
  sub_B3BA6(*a2, a1 + 108);
  sub_B336E();
  return (*(int (**)(void))(a1 + 118))();
}

//----- (000B204A) --------------------------------------------------------
int __usercall sub_B204A@<eax>(int a1@<ebp>, signed int *a2@<esi>)
{
  sub_B3BA6(*a2, a1 + 108);
  sub_B336E();
  return (*(int (**)(void))(a1 + 118))();
}

//----- (000B2069) --------------------------------------------------------
int __usercall sub_B2069@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>)
{
  int v3; // eax

  sub_B3BA6(*a3, a1 + 108);
  v3 = sub_B35DB(a2 + a1 + 28, a1 + 108, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B2088) --------------------------------------------------------
int __usercall sub_B2088@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>)
{
  int v3; // eax

  sub_B3BA6(*a3, a1 + 108);
  v3 = sub_B35DB(a1 + 108, a2 + a1 + 28, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B20A7) --------------------------------------------------------
int __usercall sub_B20A7@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        signed int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  int v30; // edi
  __int16 v31; // bx

  v30 = *(unsigned __int16 *)((char *)dword_B1858 + a2);
  v31 = *(_WORD *)((char *)dword_B1858 + v30 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v31;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v30 + 2);
  sub_B3BA6(*a3, v30 + a1 + 28);
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B20DC: cannot handle tail call to vararg
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B20E1) --------------------------------------------------------
int __usercall sub_B20E1@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  *a3 = sub_B3A60(a2 + a1 + 28);
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B20ED: cannot handle tail call to vararg
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B20F2) --------------------------------------------------------
void __usercall sub_B20F2(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  *a3 = sub_B3A60(a2 + a1 + 28);
  JUMPOUT(0xB1E11);
}
// B20FE: control flows out of bounds to B1E11

//----- (000B2103) --------------------------------------------------------
int __usercall sub_B2103@<eax>(
        void *a1@<ebp>,
        const void *a2@<esi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        char a29)
{
  qmemcpy(a1, a2, 0x1Cu);
  return sub_B1C58(
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29);
}
// B211C: cannot handle tail call to vararg
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2121) --------------------------------------------------------
int __usercall sub_B2121@<eax>(
        int a1@<ebp>,
        __int16 *a2@<esi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        char a29)
{
  __int16 v29; // ax
  __int16 v30; // ax

  v29 = *a2;
  *(_WORD *)a1 = *a2;
  v30 = v29 & 0x300;
  if ( v30 == 768 )
  {
    *(_DWORD *)(a1 + 118) = sub_B1C58;
  }
  else if ( v30 == 512 )
  {
    *(_DWORD *)(a1 + 118) = sub_B1DC8;
  }
  else
  {
    *(_DWORD *)(a1 + 118) = sub_B1D8C;
  }
  return sub_B1C58(
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29);
}
// B215C: cannot handle tail call to vararg
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2161) --------------------------------------------------------
int __usercall sub_B2161@<eax>(
        const void *a1@<ebp>,
        void *a2@<esi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        char a29)
{
  qmemcpy(a2, a1, 0x1Cu);
  return sub_B1C58(
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29);
}
// B2170: cannot handle tail call to vararg
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2175) --------------------------------------------------------
int __usercall sub_B2175@<eax>(
        _WORD *a1@<ebp>,
        _WORD *a2@<esi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        char a29)
{
  *a2 = *a1;
  return sub_B1C58(
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29);
}
// B217E: cannot handle tail call to vararg
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2183) --------------------------------------------------------
int __usercall sub_B2183@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  int v3; // eax

  sub_B399A(*a3);
  v3 = sub_B337C(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B21A2) --------------------------------------------------------
int __usercall sub_B21A2@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  int v3; // eax

  sub_B399A(*a3);
  v3 = sub_B37B0(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B21C1) --------------------------------------------------------
int __usercall sub_B21C1@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  __int16 v30; // dx
  int v32; // eax

  sub_B399A(*a3);
  v32 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v30 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v30) |= *((_BYTE *)&dword_B1860[37] + v32 + 3);
  *(_WORD *)(a1 + 4) = v30;
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B1E63: cannot handle tail call to vararg
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B21DD) --------------------------------------------------------
int __usercall sub_B21DD@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  __int16 v30; // dx
  __int16 v31; // bx
  int v33; // eax

  sub_B399A(*a3);
  v33 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v30 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v30) |= *((_BYTE *)&dword_B1860[37] + v33 + 3);
  *(_WORD *)(a1 + 4) = v30;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v31 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v31;
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B1E47: cannot handle tail call to vararg
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B21F9) --------------------------------------------------------
int __usercall sub_B21F9@<eax>(int a1@<ebp>, int *a2@<esi>)
{
  sub_B399A(*a2);
  sub_B336E();
  return (*(int (**)(void))(a1 + 118))();
}

//----- (000B2218) --------------------------------------------------------
int __usercall sub_B2218@<eax>(int a1@<ebp>, int *a2@<esi>)
{
  sub_B399A(*a2);
  sub_B336E();
  return (*(int (**)(void))(a1 + 118))();
}

//----- (000B2237) --------------------------------------------------------
int __usercall sub_B2237@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  int v3; // eax

  sub_B399A(*a3);
  v3 = sub_B35DB(a2 + a1 + 28, a1 + 108, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B2256) --------------------------------------------------------
int __usercall sub_B2256@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  int v3; // eax

  sub_B399A(*a3);
  v3 = sub_B35DB(a1 + 108, a2 + a1 + 28, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B2275) --------------------------------------------------------
int __usercall sub_B2275@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  int v30; // edi
  __int16 v31; // bx

  v30 = *(unsigned __int16 *)((char *)dword_B1858 + a2);
  v31 = *(_WORD *)((char *)dword_B1858 + v30 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v31;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v30 + 2);
  sub_B399A(*a3);
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B22AA: cannot handle tail call to vararg
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B22AF) --------------------------------------------------------
int __usercall sub_B22AF@<eax>(
        _WORD *a1@<ebp>,
        int a2@<edi>,
        _DWORD *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  int v30; // eax
  _DWORD *v31; // ebx
  int v33; // [esp-Ch] [ebp-Ch]
  int v34; // [esp-8h] [ebp-8h]
  int v35; // [esp-4h] [ebp-4h]

  v35 = *(_DWORD *)((char *)a1 + a2 + 28);
  v34 = *(_DWORD *)((char *)a1 + a2 + 32);
  v33 = *(_DWORD *)((char *)a1 + a2 + 34);
  sub_B3C6B((unsigned int)a1 + a2 + 28, *a1 & 0xC00);
  sub_B392B();
  *a3 = v30;
  v31 = (_DWORD *)((char *)a1 + a2 + 28);
  *(_DWORD *)((char *)v31 + 6) = v33;
  v31[1] = v34;
  *v31 = v35;
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B22E6: cannot handle tail call to vararg
// B22D7: variable 'v30' is possibly undefined
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B22EB) --------------------------------------------------------
void __usercall sub_B22EB(_WORD *a1@<ebp>, int a2@<edi>, _DWORD *a3@<esi>)
{
  int v3; // eax

  sub_B3C6B((unsigned int)a1 + a2 + 28, *a1 & 0xC00);
  sub_B392B();
  *a3 = v3;
  JUMPOUT(0xB1E11);
}
// B230A: control flows out of bounds to B1E11
// B2307: variable 'v3' is possibly undefined

//----- (000B230F) --------------------------------------------------------
int __usercall sub_B230F@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>)
{
  int v3; // eax

  sub_B39E0(*a3, a1 + 108, (_BYTE *)a1);
  v3 = sub_B337C(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B2332) --------------------------------------------------------
int __usercall sub_B2332@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>)
{
  int v3; // eax

  sub_B39E0(*a3, a1 + 108, (_BYTE *)a1);
  v3 = sub_B37B0(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B2355) --------------------------------------------------------
int __usercall sub_B2355@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        __int64 *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  __int16 v30; // dx
  int v32; // eax

  sub_B39E0(*a3, a1 + 108, (_BYTE *)a1);
  v32 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v30 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v30) |= *((_BYTE *)&dword_B1860[37] + v32 + 3);
  *(_WORD *)(a1 + 4) = v30;
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B1E63: cannot handle tail call to vararg
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2375) --------------------------------------------------------
int __usercall sub_B2375@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        __int64 *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  __int16 v30; // dx
  __int16 v31; // bx
  int v33; // eax

  sub_B39E0(*a3, a1 + 108, (_BYTE *)a1);
  v33 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v30 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v30) |= *((_BYTE *)&dword_B1860[37] + v33 + 3);
  *(_WORD *)(a1 + 4) = v30;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v31 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v31;
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B1E47: cannot handle tail call to vararg
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2395) --------------------------------------------------------
int __usercall sub_B2395@<eax>(int a1@<ebp>, __int64 *a2@<esi>)
{
  sub_B39E0(*a2, a1 + 108, (_BYTE *)a1);
  sub_B336E();
  return (*(int (**)(void))(a1 + 118))();
}

//----- (000B23B8) --------------------------------------------------------
int __usercall sub_B23B8@<eax>(int a1@<ebp>, __int64 *a2@<esi>)
{
  sub_B39E0(*a2, a1 + 108, (_BYTE *)a1);
  sub_B336E();
  return (*(int (**)(void))(a1 + 118))();
}

//----- (000B23DB) --------------------------------------------------------
int __usercall sub_B23DB@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>)
{
  int v3; // eax

  sub_B39E0(*a3, a1 + 108, (_BYTE *)a1);
  v3 = sub_B35DB(a2 + a1 + 28, a1 + 108, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B23FE) --------------------------------------------------------
int __usercall sub_B23FE@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>)
{
  int v3; // eax

  sub_B39E0(*a3, a1 + 108, (_BYTE *)a1);
  v3 = sub_B35DB(a1 + 108, a2 + a1 + 28, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B2421) --------------------------------------------------------
int __usercall sub_B2421@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  int v30; // edi
  __int16 v31; // bx

  v30 = *(unsigned __int16 *)((char *)dword_B1858 + a2);
  v31 = *(_WORD *)((char *)dword_B1858 + v30 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v31;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v30 + 2);
  *(_DWORD *)(v30 + a1 + 28) = *(_DWORD *)a3;
  *(_DWORD *)(v30 + a1 + 32) = *(_DWORD *)(a3 + 4);
  *(_WORD *)(v30 + a1 + 36) = *(_WORD *)(a3 + 8);
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B2463: cannot handle tail call to vararg
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2468) --------------------------------------------------------
int __usercall sub_B2468@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        __int64 *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  int v30; // edi
  __int16 v31; // bx

  v30 = *(unsigned __int16 *)((char *)dword_B1858 + a2);
  v31 = *(_WORD *)((char *)dword_B1858 + v30 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v31;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v30 + 2);
  sub_B39E0(*a3, v30 + a1 + 28, (_BYTE *)a1);
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B24A1: cannot handle tail call to vararg
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B24A6) --------------------------------------------------------
int __usercall sub_B24A6@<eax>(
        int a1@<edx>,
        _BYTE *a2@<ebp>,
        int a3@<edi>,
        int *a4@<esi>,
        int a5,
        __int16 a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        __int16 a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        char a31)
{
  *a4 = sub_B3ADF((__int64 *)&a2[a3 + 28], a2);
  a4[1] = a1;
  return sub_B1C58(
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31);
}
// B24B6: cannot handle tail call to vararg
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B24BB) --------------------------------------------------------
void __usercall sub_B24BB(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  *(_DWORD *)a3 = *(_DWORD *)(a2 + a1 + 28);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a2 + a1 + 32);
  *(_WORD *)(a3 + 8) = *(_WORD *)(a2 + a1 + 36);
  JUMPOUT(0xB1E11);
}
// B24D4: control flows out of bounds to B1E11

//----- (000B24D9) --------------------------------------------------------
void __usercall sub_B24D9(int a1@<edx>, _BYTE *a2@<ebp>, int a3@<edi>, int *a4@<esi>)
{
  *a4 = sub_B3ADF((__int64 *)&a2[a3 + 28], a2);
  a4[1] = a1;
  JUMPOUT(0xB1E11);
}
// B24E9: control flows out of bounds to B1E11

//----- (000B24EE) --------------------------------------------------------
int __usercall sub_B24EE@<eax>(
        _DWORD *a1@<ebp>,
        _DWORD *a2@<esi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        char a29)
{
  _DWORD *v29; // esi
  unsigned int v30; // ebx
  int v31; // ecx
  _DWORD *v32; // esi

  qmemcpy(a1, a2, 0x1Cu);
  v29 = a2 + 7;
  v30 = 10 * ((a1[1] & 0x3800u) >> 11);
  v31 = 8;
  do
  {
    *(_DWORD *)((char *)a1 + v30 + 28) = *v29;
    v32 = v29 + 1;
    *(_DWORD *)((char *)a1 + v30 + 32) = *v32++;
    *(_WORD *)((char *)a1 + v30 + 36) = *(_WORD *)v32;
    v29 = (_DWORD *)((char *)v32 + 2);
    v30 = *(unsigned __int16 *)((char *)&off_B1854 + v30 + 2);
    --v31;
  }
  while ( v31 );
  return sub_B1C58(
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29);
}
// B2530: cannot handle tail call to vararg
// B1854: using guessed type void *off_B1854;
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2535) --------------------------------------------------------
void __usercall sub_B2535(char *a1@<ebp>, int a2@<edi>, _DWORD *a3@<esi>)
{
  _DWORD *v4; // edi
  int v5; // ecx
  _DWORD *v6; // edi

  qmemcpy(a3, a1, 0x1Cu);
  v4 = a3 + 7;
  v5 = 8;
  do
  {
    *v4 = *(_DWORD *)&a1[a2 + 28];
    v6 = v4 + 1;
    *v6++ = *(_DWORD *)&a1[a2 + 32];
    *(_WORD *)v6 = *(_WORD *)&a1[a2 + 36];
    v4 = (_DWORD *)((char *)v6 + 2);
    a2 = *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2);
    --v5;
  }
  while ( v5 );
  JUMPOUT(0xB2E4B);
}
// B255B: control flows out of bounds to B2E4B
// B1854: using guessed type void *off_B1854;

//----- (000B2560) --------------------------------------------------------
int __usercall sub_B2560@<eax>(
        int a1@<ebp>,
        _WORD *a2@<esi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        char a29)
{
  *a2 = *(_WORD *)(a1 + 4);
  return sub_B1C58(
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29);
}
// B2569: cannot handle tail call to vararg
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B256E) --------------------------------------------------------
int __usercall sub_B256E@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>)
{
  int v3; // eax

  sub_B399A(*a3);
  v3 = sub_B337C(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B258F) --------------------------------------------------------
int __usercall sub_B258F@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>)
{
  int v3; // eax

  sub_B399A(*a3);
  v3 = sub_B37B0(a2 + a1 + 28, a1 + 108, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B25B0) --------------------------------------------------------
int __usercall sub_B25B0@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        __int16 *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  __int16 v30; // dx
  int v32; // eax

  sub_B399A(*a3);
  v32 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v30 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v30) |= *((_BYTE *)&dword_B1860[37] + v32 + 3);
  *(_WORD *)(a1 + 4) = v30;
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B1E63: cannot handle tail call to vararg
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B25CE) --------------------------------------------------------
int __usercall sub_B25CE@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        __int16 *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  __int16 v30; // dx
  __int16 v31; // bx
  int v33; // eax

  sub_B399A(*a3);
  v33 = sub_B3542(a2 + a1 + 28, a1 + 108);
  v30 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v30) |= *((_BYTE *)&dword_B1860[37] + v33 + 3);
  *(_WORD *)(a1 + 4) = v30;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v31 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v31;
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B1E47: cannot handle tail call to vararg
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B25EC) --------------------------------------------------------
int __usercall sub_B25EC@<eax>(int a1@<ebp>, __int16 *a2@<esi>)
{
  sub_B399A(*a2);
  sub_B336E();
  return (*(int (**)(void))(a1 + 118))();
}

//----- (000B260D) --------------------------------------------------------
int __usercall sub_B260D@<eax>(int a1@<ebp>, __int16 *a2@<esi>)
{
  sub_B399A(*a2);
  sub_B336E();
  return (*(int (**)(void))(a1 + 118))();
}

//----- (000B262E) --------------------------------------------------------
int __usercall sub_B262E@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>)
{
  int v3; // eax

  sub_B399A(*a3);
  v3 = sub_B35DB(a2 + a1 + 28, a1 + 108, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B264F) --------------------------------------------------------
int __usercall sub_B264F@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>)
{
  int v3; // eax

  sub_B399A(*a3);
  v3 = sub_B35DB(a1 + 108, a2 + a1 + 28, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B2670) --------------------------------------------------------
int __usercall sub_B2670@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        __int16 *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  int v30; // edi
  __int16 v31; // bx

  v30 = *(unsigned __int16 *)((char *)dword_B1858 + a2);
  v31 = *(_WORD *)((char *)dword_B1858 + v30 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v31;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v30 + 2);
  sub_B399A(*a3);
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B26A7: cannot handle tail call to vararg
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B26AC) --------------------------------------------------------
int __usercall sub_B26AC@<eax>(
        _WORD *a1@<ebp>,
        int a2@<edi>,
        _WORD *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  int v30; // eax
  _DWORD *v31; // ebx
  int v33; // [esp-Ch] [ebp-Ch]
  int v34; // [esp-8h] [ebp-8h]
  int v35; // [esp-4h] [ebp-4h]

  v35 = *(_DWORD *)((char *)a1 + a2 + 28);
  v34 = *(_DWORD *)((char *)a1 + a2 + 32);
  v33 = *(_DWORD *)((char *)a1 + a2 + 34);
  sub_B3C6B((unsigned int)a1 + a2 + 28, *a1 & 0xC00);
  sub_B392B();
  if ( (__int16)v30 != v30 )
    LOWORD(v30) = 0x8000;
  *a3 = v30;
  v31 = (_DWORD *)((char *)a1 + a2 + 28);
  *(_DWORD *)((char *)v31 + 6) = v33;
  v31[1] = v34;
  *v31 = v35;
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B26EF: cannot handle tail call to vararg
// B26D6: variable 'v30' is possibly undefined
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B26F4) --------------------------------------------------------
void __usercall sub_B26F4(_WORD *a1@<ebp>, int a2@<edi>, _WORD *a3@<esi>)
{
  int v3; // eax

  sub_B3C6B((unsigned int)a1 + a2 + 28, *a1 & 0xC00);
  sub_B392B();
  if ( (__int16)v3 != v3 )
    LOWORD(v3) = 0x8000;
  *a3 = v3;
  JUMPOUT(0xB1E11);
}
// B271F: control flows out of bounds to B1E11
// B2712: variable 'v3' is possibly undefined

//----- (000B2729) --------------------------------------------------------
int __usercall sub_B2729@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        unsigned int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  int v30; // edi
  __int16 v31; // bx

  v30 = *(unsigned __int16 *)((char *)dword_B1858 + a2);
  v31 = *(_WORD *)((char *)dword_B1858 + v30 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v31;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v30 + 2);
  sub_B39AB(*a3, v30 + a1 + 28);
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B275E: cannot handle tail call to vararg
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2768) --------------------------------------------------------
void __usercall sub_B2768(_WORD *a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  sub_B3C6B((unsigned int)a1 + a2 + 28, *a1 & 0xC00);
  *a3 = sub_B3930((int *)((char *)a1 + a2 + 28));
  JUMPOUT(0xB1E11);
}
// B2787: control flows out of bounds to B1E11

//----- (000B2791) --------------------------------------------------------
int __usercall sub_B2791@<eax>(
        int a1@<ebx>,
        int a2,
        __int16 a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        __int16 a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        char a28)
{
  switch ( a1 )
  {
    case 0:
      return sub_B1C58(
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15,
               a16,
               a17,
               a18,
               a19,
               a20,
               a21,
               a22,
               a23,
               a24,
               a25,
               a26,
               a27,
               a28);
  }
}
// B27B9: cannot handle tail call to vararg
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B27BE) --------------------------------------------------------
int __usercall sub_B27BE@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_B337C(a2 + a1 + 28, a3 + a1 + 28, a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B27D3) --------------------------------------------------------
int __usercall sub_B27D3@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_B37B0(a2 + a1 + 28, a3 + a1 + 28, a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B27E8) --------------------------------------------------------
int __usercall sub_B27E8@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  __int16 v30; // dx
  int v32; // eax

  v32 = sub_B3542(a2 + a1 + 28, a3 + a1 + 28);
  v30 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v30) |= *((_BYTE *)&dword_B1860[37] + v32 + 3);
  *(_WORD *)(a1 + 4) = v30;
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B1E63: cannot handle tail call to vararg
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B27FA) --------------------------------------------------------
int __usercall sub_B27FA@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  __int16 v30; // dx
  __int16 v31; // bx
  int v33; // eax

  v33 = sub_B3542(a2 + a1 + 28, a3 + a1 + 28);
  v30 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v30) |= *((_BYTE *)&dword_B1860[37] + v33 + 3);
  *(_WORD *)(a1 + 4) = v30;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v31 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v31;
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B1E47: cannot handle tail call to vararg
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B280C) --------------------------------------------------------
int __usercall sub_B280C@<eax>(int a1@<ebp>)
{
  sub_B336E();
  return (*(int (**)(void))(a1 + 118))();
}

//----- (000B2821) --------------------------------------------------------
int __usercall sub_B2821@<eax>(int a1@<ebp>)
{
  sub_B336E();
  return (*(int (**)(void))(a1 + 118))();
}

//----- (000B2836) --------------------------------------------------------
int __usercall sub_B2836@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_B35DB(a2 + a1 + 28, a3 + a1 + 28, (_BYTE *)a1, a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B284B) --------------------------------------------------------
int __usercall sub_B284B@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_B35DB(a3 + a1 + 28, a2 + a1 + 28, (_BYTE *)a1, a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B2860) --------------------------------------------------------
int __usercall sub_B2860@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  int v30; // edi
  __int16 v31; // bx

  v30 = *(unsigned __int16 *)((char *)dword_B1858 + a2);
  v31 = *(_WORD *)((char *)dword_B1858 + v30 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v31;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v30 + 2);
  *(_DWORD *)(v30 + a1 + 28) = *(_DWORD *)(a3 + a1 + 28);
  *(_DWORD *)(v30 + a1 + 32) = *(_DWORD *)(a3 + a1 + 32);
  *(_WORD *)(v30 + a1 + 36) = *(_WORD *)(a3 + a1 + 36);
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B28A3: cannot handle tail call to vararg
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B28A8) --------------------------------------------------------
int __usercall sub_B28A8@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  int v30; // ebx
  int v31; // esi
  __int16 v32; // ax

  v30 = a2 + a1 + 28;
  v31 = a3 + a1 + 28;
  *(_DWORD *)v31 = _InterlockedExchange((volatile __int32 *)v30, *(_DWORD *)v31);
  *(_DWORD *)(v31 + 4) = _InterlockedExchange((volatile __int32 *)(a2 + a1 + 32), *(_DWORD *)(v31 + 4));
  v32 = *(_WORD *)(a2 + a1 + 36);
  *(_WORD *)(v30 + 8) = *(_WORD *)(v31 + 8);
  *(_WORD *)(v31 + 8) = v32;
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B28CB: cannot handle tail call to vararg
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2951) --------------------------------------------------------
int __usercall sub_B2951@<eax>(
        int a1@<ebx>,
        int a2@<ebp>,
        int a3@<edi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  int v30; // edi
  __int16 v31; // bx
  int v32; // esi
  int result; // eax
  int v34; // edi
  __int16 v35; // bx
  int v36; // esi
  int v37; // edi
  __int16 v38; // bx
  int v39; // esi
  int v40; // edi
  __int16 v41; // bx
  int v42; // esi
  int v43; // edi
  __int16 v44; // bx
  int v45; // esi
  int v46; // edi
  __int16 v47; // bx
  int v48; // esi
  int v49; // edi
  __int16 v50; // bx
  int v51; // esi

  switch ( a1 )
  {
    case 0:
      v30 = *(unsigned __int16 *)((char *)dword_B1858 + a3);
      v31 = *(_WORD *)((char *)dword_B1858 + v30 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v31;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v30 + 2);
      v32 = v30 + a2 + 28;
      *(_DWORD *)v32 = 0;
      *(_DWORD *)(v32 + 4) = 0x80000000;
      *(_WORD *)(v32 + 8) = 0x3FFF;
      result = sub_B1C58(
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10,
                 a11,
                 a12,
                 a13,
                 a14,
                 a15,
                 a16,
                 a17,
                 a18,
                 a19,
                 a20,
                 a21,
                 a22,
                 a23,
                 a24,
                 a25,
                 a26,
                 a27,
                 a28,
                 a29,
                 a30);
      break;
    case 1:
      v34 = *(unsigned __int16 *)((char *)dword_B1858 + a3);
      v35 = *(_WORD *)((char *)dword_B1858 + v34 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v35;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v34 + 2);
      v36 = v34 + a2 + 28;
      *(_DWORD *)v36 = -853832962;
      *(_DWORD *)(v36 + 4) = -728074165;
      *(_WORD *)(v36 + 8) = 0x4000;
      result = sub_B1C58(
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10,
                 a11,
                 a12,
                 a13,
                 a14,
                 a15,
                 a16,
                 a17,
                 a18,
                 a19,
                 a20,
                 a21,
                 a22,
                 a23,
                 a24,
                 a25,
                 a26,
                 a27,
                 a28,
                 a29,
                 a30);
      break;
    case 2:
      v37 = *(unsigned __int16 *)((char *)dword_B1858 + a3);
      v38 = *(_WORD *)((char *)dword_B1858 + v37 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v38;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v37 + 2);
      v39 = v37 + a2 + 28;
      *(_DWORD *)v39 = 1545072828;
      *(_DWORD *)(v39 + 4) = -1196803287;
      *(_WORD *)(v39 + 8) = 0x3FFF;
      result = sub_B1C58(
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10,
                 a11,
                 a12,
                 a13,
                 a14,
                 a15,
                 a16,
                 a17,
                 a18,
                 a19,
                 a20,
                 a21,
                 a22,
                 a23,
                 a24,
                 a25,
                 a26,
                 a27,
                 a28,
                 a29,
                 a30);
      break;
    case 3:
      v40 = *(unsigned __int16 *)((char *)dword_B1858 + a3);
      v41 = *(_WORD *)((char *)dword_B1858 + v40 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v41;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v40 + 2);
      v42 = v40 + a2 + 28;
      *(_DWORD *)v42 = 560513589;
      *(_DWORD *)(v42 + 4) = -922690910;
      *(_WORD *)(v42 + 8) = 0x4000;
      result = sub_B1C58(
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10,
                 a11,
                 a12,
                 a13,
                 a14,
                 a15,
                 a16,
                 a17,
                 a18,
                 a19,
                 a20,
                 a21,
                 a22,
                 a23,
                 a24,
                 a25,
                 a26,
                 a27,
                 a28,
                 a29,
                 a30);
      break;
    case 4:
      v43 = *(unsigned __int16 *)((char *)dword_B1858 + a3);
      v44 = *(_WORD *)((char *)dword_B1858 + v43 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v44;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v43 + 2);
      v45 = v43 + a2 + 28;
      *(_DWORD *)v45 = -70256743;
      *(_DWORD *)(v45 + 4) = -1709139324;
      *(_WORD *)(v45 + 8) = 16381;
      result = sub_B1C58(
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10,
                 a11,
                 a12,
                 a13,
                 a14,
                 a15,
                 a16,
                 a17,
                 a18,
                 a19,
                 a20,
                 a21,
                 a22,
                 a23,
                 a24,
                 a25,
                 a26,
                 a27,
                 a28,
                 a29,
                 a30);
      break;
    case 5:
      v46 = *(unsigned __int16 *)((char *)dword_B1858 + a3);
      v47 = *(_WORD *)((char *)dword_B1858 + v46 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v47;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v46 + 2);
      v48 = v46 + a2 + 28;
      *(_DWORD *)v48 = -774932052;
      *(_DWORD *)(v48 + 4) = -1317922825;
      *(_WORD *)(v48 + 8) = 16382;
      result = sub_B1C58(
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10,
                 a11,
                 a12,
                 a13,
                 a14,
                 a15,
                 a16,
                 a17,
                 a18,
                 a19,
                 a20,
                 a21,
                 a22,
                 a23,
                 a24,
                 a25,
                 a26,
                 a27,
                 a28,
                 a29,
                 a30);
      break;
    case 6:
      v49 = *(unsigned __int16 *)((char *)dword_B1858 + a3);
      v50 = *(_WORD *)((char *)dword_B1858 + v49 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v50;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v49 + 2);
      v51 = v49 + a2 + 28;
      *(_DWORD *)v51 = 0;
      *(_DWORD *)(v51 + 4) = 0;
      *(_WORD *)(v51 + 8) = 0;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v49 + 2);
      *(_WORD *)(a2 + 8) |= *(_WORD *)((char *)&dword_B1860[18] + v49);
      result = sub_B1C58(
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10,
                 a11,
                 a12,
                 a13,
                 a14,
                 a15,
                 a16,
                 a17,
                 a18,
                 a19,
                 a20,
                 a21,
                 a22,
                 a23,
                 a24,
                 a25,
                 a26,
                 a27,
                 a28,
                 a29,
                 a30);
      break;
    case 7:
      JUMPOUT(0xB278C);
  }
  return result;
}
// B2951: control flows out of bounds to B278C
// B29B7: cannot handle tail call to vararg
// B29FC: cannot handle tail call to vararg
// B2A41: cannot handle tail call to vararg
// B2A86: cannot handle tail call to vararg
// B2ACB: cannot handle tail call to vararg
// B2B10: cannot handle tail call to vararg
// B2B67: cannot handle tail call to vararg
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2B6C) --------------------------------------------------------
int __usercall sub_B2B6C@<eax>(
        int a1@<edx>,
        int a2@<ecx>,
        int a3@<ebx>,
        int a4@<ebp>,
        int a5@<edi>,
        int a6@<esi>,
        int a7,
        __int16 a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        __int16 a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        int a31,
        int a32,
        char a33)
{
  int v33; // eax
  int result; // eax
  int v35; // eax
  int v36; // edi
  __int16 v37; // bx
  int v38; // eax
  int v39; // edi
  __int16 v40; // bx
  int v41; // esi
  __int16 v42; // bx
  __int16 v43; // bx

  switch ( a3 )
  {
    case 0:
      v33 = sub_B4718(a5 + a4 + 28, a1, a3, a2);
      result = (*(int (__fastcall **)(int))(a4 + 118))(v33);
      break;
    case 1:
      v35 = a5 + a4 + 28;
      *(_WORD *)(a4 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a5 + 2);
      *(_WORD *)(a4 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a5 + 2);
      v36 = *(unsigned __int16 *)((char *)&off_B1854 + a5 + 2);
      v37 = *(_WORD *)((char *)dword_B1858 + v36 + 2);
      *(_WORD *)(a4 + 4) &= 0xC7FFu;
      *(_WORD *)(a4 + 4) |= v37;
      v38 = sub_B41F9(v35, v36 + a4 + 28, (_BYTE *)a4, a6);
      result = (*(int (__fastcall **)(int))(a4 + 118))(v38);
      break;
    case 2:
      sub_B46E2(a5 + a4 + 28);
      v39 = *(unsigned __int16 *)((char *)dword_B1858 + a5);
      v40 = *(_WORD *)((char *)dword_B1858 + v39 + 2);
      *(_WORD *)(a4 + 4) &= 0xC7FFu;
      *(_WORD *)(a4 + 4) |= v40;
      *(_WORD *)(a4 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + v39 + 2);
      v41 = v39 + a4 + 28;
      *(_DWORD *)v41 = 0;
      *(_DWORD *)(v41 + 4) = 0x80000000;
      *(_WORD *)(v41 + 8) = 0x3FFF;
      result = sub_B1C58(
                 a7,
                 a8,
                 a9,
                 a10,
                 a11,
                 a12,
                 a13,
                 a14,
                 a15,
                 a16,
                 a17,
                 a18,
                 a19,
                 a20,
                 a21,
                 a22,
                 a23,
                 a24,
                 a25,
                 a26,
                 a27,
                 a28,
                 a29,
                 a30,
                 a31,
                 a32,
                 a33);
      break;
    case 3:
      JUMPOUT(0xB31FD);
    case 4:
      JUMPOUT(0xB3246);
    case 5:
      JUMPOUT(0xB32AB);
    case 6:
      v42 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)dword_B1858 + a5) + 2);
      *(_WORD *)(a4 + 4) &= 0xC7FFu;
      *(_WORD *)(a4 + 4) |= v42;
      result = sub_B1C58(
                 a7,
                 a8,
                 a9,
                 a10,
                 a11,
                 a12,
                 a13,
                 a14,
                 a15,
                 a16,
                 a17,
                 a18,
                 a19,
                 a20,
                 a21,
                 a22,
                 a23,
                 a24,
                 a25,
                 a26,
                 a27,
                 a28,
                 a29,
                 a30,
                 a31,
                 a32,
                 a33);
      break;
    case 7:
      v43 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a5 + 2) + 2);
      *(_WORD *)(a4 + 4) &= 0xC7FFu;
      *(_WORD *)(a4 + 4) |= v43;
      result = sub_B1C58(
                 a7,
                 a8,
                 a9,
                 a10,
                 a11,
                 a12,
                 a13,
                 a14,
                 a15,
                 a16,
                 a17,
                 a18,
                 a19,
                 a20,
                 a21,
                 a22,
                 a23,
                 a24,
                 a25,
                 a26,
                 a27,
                 a28,
                 a29,
                 a30,
                 a31,
                 a32,
                 a33);
      break;
  }
  return result;
}
// B2B6C: control flows out of bounds to B31FD
// B2B6C: control flows out of bounds to B3246
// B2B6C: control flows out of bounds to B32AB
// B2C2F: cannot handle tail call to vararg
// B2C50: cannot handle tail call to vararg
// B2C71: cannot handle tail call to vararg
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2C76) --------------------------------------------------------
#error "B2D13: call analysis failed (funcsize=50)"

//----- (000B2D8E) --------------------------------------------------------
int __usercall sub_B2D8E@<eax>(
        int a1@<ebx>,
        int a2,
        __int16 a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        __int16 a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        char a28)
{
  return funcs_B2D8E[a1](
           a2,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28);
}
// B2D8E: cannot handle tail call to vararg
// B278C: using guessed type _DWORD __cdecl sub_B278C(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);
// B2D96: using guessed type int (__cdecl *funcs_B2D8E[8])(int, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16, int, int, int, int, int, int, int, int, int, int, int, char);

//----- (000B2E17) --------------------------------------------------------
int __usercall sub_B2E17@<eax>(
        int a1@<ebx>,
        int a2@<ebp>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        char a29)
{
  int result; // eax

  switch ( a1 )
  {
    case 0:
    case 1:
    case 4:
    case 5:
    case 6:
    case 7:
      JUMPOUT(0xB278C);
    case 2:
      *(_WORD *)(a2 + 4) &= 0x7F00u;
      result = sub_B1C58(
                 a3,
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10,
                 a11,
                 a12,
                 a13,
                 a14,
                 a15,
                 a16,
                 a17,
                 a18,
                 a19,
                 a20,
                 a21,
                 a22,
                 a23,
                 a24,
                 a25,
                 a26,
                 a27,
                 a28,
                 a29);
      break;
    case 3:
      *(_WORD *)a2 = 831;
      *(_WORD *)(a2 + 4) = 0;
      *(_WORD *)(a2 + 8) = -1;
      *(_DWORD *)(a2 + 118) = sub_B1C58;
      result = sub_B1C58(
                 a3,
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10,
                 a11,
                 a12,
                 a13,
                 a14,
                 a15,
                 a16,
                 a17,
                 a18,
                 a19,
                 a20,
                 a21,
                 a22,
                 a23,
                 a24,
                 a25,
                 a26,
                 a27,
                 a28,
                 a29);
      break;
  }
  return result;
}
// B2E17: control flows out of bounds to B278C
// B2E46: cannot handle tail call to vararg
// B2E6C: cannot handle tail call to vararg
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2E71) --------------------------------------------------------
int __usercall sub_B2E71@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_B337C(a3 + a1 + 28, a2 + a1 + 28, a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B2E86) --------------------------------------------------------
int __usercall sub_B2E86@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_B37B0(a3 + a1 + 28, a2 + a1 + 28, a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B2E9B) --------------------------------------------------------
int __usercall sub_B2E9B@<eax>(int a1@<ebp>)
{
  sub_B336E();
  return (*(int (**)(void))(a1 + 118))();
}

//----- (000B2EB0) --------------------------------------------------------
int __usercall sub_B2EB0@<eax>(int a1@<ebp>)
{
  sub_B336E();
  return (*(int (**)(void))(a1 + 118))();
}

//----- (000B2EC5) --------------------------------------------------------
int __usercall sub_B2EC5@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_B35DB(a2 + a1 + 28, a3 + a1 + 28, (_BYTE *)a1, a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B2EDA) --------------------------------------------------------
int __usercall sub_B2EDA@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_B35DB(a3 + a1 + 28, a2 + a1 + 28, (_BYTE *)a1, a3);
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}

//----- (000B2EEF) --------------------------------------------------------
int __usercall sub_B2EEF@<eax>(
        int a1@<ebp>,
        int a2@<esi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        char a29)
{
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  return sub_B1C58(
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29);
}
// B2F09: cannot handle tail call to vararg
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2F0E) --------------------------------------------------------
int __usercall sub_B2F0E@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  *(_DWORD *)(a3 + a1 + 28) = *(_DWORD *)(a2 + a1 + 28);
  *(_DWORD *)(a3 + a1 + 32) = *(_DWORD *)(a2 + a1 + 32);
  *(_WORD *)(a3 + a1 + 36) = *(_WORD *)(a2 + a1 + 36);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a3 + 2);
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B2F35: cannot handle tail call to vararg
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2F3A) --------------------------------------------------------
int __usercall sub_B2F3A@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  __int16 v30; // dx
  int v32; // eax

  v32 = sub_B3542(a2 + a1 + 28, a3 + a1 + 28);
  v30 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v30) |= *((_BYTE *)&dword_B1860[37] + v32 + 3);
  *(_WORD *)(a1 + 4) = v30;
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B1E63: cannot handle tail call to vararg
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2F4C) --------------------------------------------------------
int __usercall sub_B2F4C@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        char a30)
{
  __int16 v30; // dx
  __int16 v31; // bx
  int v33; // eax

  v33 = sub_B3542(a2 + a1 + 28, a3 + a1 + 28);
  v30 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v30) |= *((_BYTE *)&dword_B1860[37] + v33 + 3);
  *(_WORD *)(a1 + 4) = v30;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v31 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v31;
  return sub_B1C58(
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30);
}
// B1E47: cannot handle tail call to vararg
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B2F5E) --------------------------------------------------------
void __usercall sub_B2F5E(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  *(_DWORD *)(a3 + a1 + 28) = *(_DWORD *)(a2 + a1 + 28);
  *(_DWORD *)(a3 + a1 + 32) = *(_DWORD *)(a2 + a1 + 32);
  *(_WORD *)(a3 + a1 + 36) = *(_WORD *)(a2 + a1 + 36);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a3 + 2);
  JUMPOUT(0xB1E11);
}
// B2F85: control flows out of bounds to B1E11
// B1860: using guessed type int dword_B1860[41];

//----- (000B2F8A) --------------------------------------------------------
int __usercall sub_B2F8A@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  __int16 v4; // bx

  v3 = sub_B337C(a3 + a1 + 28, a2 + a1 + 28, a3);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v4 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v4;
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B2FD5) --------------------------------------------------------
int __usercall sub_B2FD5@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  __int16 v4; // bx

  v3 = sub_B37B0(a3 + a1 + 28, a2 + a1 + 28, a3);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v4 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v4;
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B3020) --------------------------------------------------------
int __usercall sub_B3020@<eax>(
        int a1@<ebx>,
        int a2,
        __int16 a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        __int16 a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        char a28)
{
  return funcs_B3020[a1](
           a2,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28);
}
// B3020: cannot handle tail call to vararg
// B278C: using guessed type _DWORD __cdecl sub_B278C(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);
// B3028: using guessed type int (__cdecl *funcs_B3020[8])(int, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16, int, int, int, int, int, int, int, int, int, int, int, char);

//----- (000B30A9) --------------------------------------------------------
int __usercall sub_B30A9@<eax>(int a1@<ebp>, int a2@<edi>)
{
  __int16 v2; // bx

  sub_B336E();
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v2 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v2;
  return (*(int (**)(void))(a1 + 118))();
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B30F4) --------------------------------------------------------
int __usercall sub_B30F4@<eax>(int a1@<ebp>, int a2@<edi>)
{
  __int16 v2; // bx

  sub_B336E();
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v2 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v2;
  return (*(int (**)(void))(a1 + 118))();
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B313F) --------------------------------------------------------
int __usercall sub_B313F@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  __int16 v4; // bx

  v3 = sub_B35DB(a2 + a1 + 28, a3 + a1 + 28, (_BYTE *)a1, a3);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v4 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v4;
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B318A) --------------------------------------------------------
int __usercall sub_B318A@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  __int16 v4; // bx

  v3 = sub_B35DB(a3 + a1 + 28, a2 + a1 + 28, (_BYTE *)a1, a3);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_B1860[17] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_B1860[19] + a2 + 2);
  v4 = *(_WORD *)((char *)dword_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v4;
  return (*(int (__fastcall **)(int))(a1 + 118))(v3);
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int dword_B1858[2];
// B1860: using guessed type int dword_B1860[41];

//----- (000B31D5) --------------------------------------------------------
int __usercall sub_B31D5@<eax>(
        int a1@<ebx>,
        int a2@<ebp>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        char a29)
{
  switch ( a1 )
  {
    case 0:
      LOWORD(a12) = *(_WORD *)(a2 + 4);
      return sub_B1C58(
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15,
               a16,
               a17,
               a18,
               a19,
               a20,
               a21,
               a22,
               a23,
               a24,
               a25,
               a26,
               a27,
               a28,
               a29);
  }
}
// B3369: cannot handle tail call to vararg
// B1C58: using guessed type _DWORD __cdecl sub_B1C58(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (000B336E) --------------------------------------------------------
void sub_B336E()
{
  JUMPOUT(0xB3383);
}
// B337A: control flows out of bounds to B3383

//----- (000B337C) --------------------------------------------------------
int __usercall sub_B337C@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>)
{
  int v3; // ecx
  int v4; // ebx
  int v5; // esi
  __int64 v6; // rax

  LOWORD(a3) = *(_WORD *)(a2 + 8);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)a2;
  v5 = a3 << 16;
  LOWORD(v5) = *(_WORD *)(a1 + 8);
  v6 = *(_QWORD *)a1;
  LODWORD(v6) = sub_B33D6(v6, v3, v4, v5);
  *(_QWORD *)v4 = v6;
  *(_WORD *)(v4 + 8) = v5;
  return v6;
}

//----- (000B33A6) --------------------------------------------------------
int __userpurge sub_B33A6@<eax>(int a1@<eax>, int a2@<esi>, int a3, int a4, __int16 a5)
{
  int v5; // esi
  __int64 v6; // rax

  LOWORD(a2) = a5;
  v5 = a2 << 16;
  LOWORD(v5) = *(_WORD *)(a1 + 8);
  v6 = *(_QWORD *)a1;
  LODWORD(v6) = sub_B33D6(v6, a4, a3, v5);
  *(_QWORD *)a3 = v6;
  *(_WORD *)(a3 + 8) = v5;
  return v6;
}

//----- (000B33D6) --------------------------------------------------------
int __usercall sub_B33D6@<eax>(__int64 a1@<edx:eax>, int a2@<ecx>, int a3@<ebx>, int a4@<esi>)
{
  _BOOL1 v4; // cf
  unsigned __int16 v5; // si
  int v6; // ecx
  int v7; // esi
  unsigned int v9; // ebp
  int v10; // edi
  int v11; // ecx
  unsigned __int16 v12; // di
  _BOOL1 v13; // cf
  int v14; // ecx
  int v15; // et1
  int v16; // et2
  int v17; // edi
  int v18; // ebx
  char v19; // ch
  int v20; // ebx
  int v21; // edi
  char v22; // cf
  char v23; // tt
  int v24; // ett
  int v25; // ett
  __int16 v26; // bp
  int v27; // et2
  _BOOL1 v28; // cf
  int v29; // eax
  _BOOL1 v30; // tt
  bool v31; // ett
  int v32; // ett
  int v34; // [esp-Ch] [ebp-Ch]

  if ( !a1 )
  {
    v4 = __CFADD__((_WORD)a4, (_WORD)a4);
    v5 = 2 * a4;
    if ( !v5 )
    {
      LODWORD(a1) = a3;
      return a1;
    }
    LOWORD(a4) = (v5 >> 1) | (v4 << 15);
  }
  if ( a2 || a3 || (a4 & 0x7FFF0000) != 0 )
  {
    v6 = a4;
    v7 = a2;
    v9 = (v6 >> 16) & 0x80007FFF;
    v10 = __ROL4__(((int)__ROL4__(v6, 16) >> 16) & 0x80007FFF, 16);
    v11 = __ROL4__(v9, 16);
    LOWORD(v11) = v10 + v11;
    v12 = __ROL4__(v10, 16);
    v14 = __ROL4__(v11, 16);
    v13 = (unsigned __int16)v14 < v12;
    LOWORD(v14) = v14 - v12;
    if ( !(_WORD)v14 )
      goto LABEL_13;
    if ( v13 )
    {
      LOWORD(v9) = v12;
      LOWORD(v14) = -(__int16)v14;
      v15 = a1;
      LODWORD(a1) = a3;
      a3 = v15;
      v16 = HIDWORD(a1);
      HIDWORD(a1) = v7;
      v7 = v16;
    }
    if ( (unsigned __int16)v14 > 0x40u )
    {
      LODWORD(a1) = a3;
    }
    else
    {
LABEL_13:
      BYTE1(v14) = 0;
      if ( v14 < 0 )
      {
        BYTE1(v14) = -1;
        a3 = -a3;
        v7 = -v7 - (a3 != 0);
      }
      v17 = 0;
      if ( (_BYTE)v14 )
      {
        v34 = a3;
        v18 = 0;
        if ( (unsigned __int8)v14 >= 0x20u )
        {
          LOBYTE(v18) = (_DWORD)a1 != 0;
          v17 = v18;
          if ( (_BYTE)v14 == 64 )
          {
            v17 = HIDWORD(a1) | v18;
            HIDWORD(a1) = 0;
          }
          a1 = HIDWORD(a1);
        }
        v17 |= __PAIR64__(a1, 0) >> v14;
        LODWORD(a1) = (unsigned __int64)a1 >> v14;
        HIDWORD(a1) = (unsigned __int64)HIDWORD(a1) >> v14;
        a3 = v34;
      }
      v4 = __CFADD__(__PAIR64__(v7, a3), a1);
      a1 += __PAIR64__(v7, a3);
      v19 = v4 + BYTE1(v14);
      if ( v19 < 0 )
      {
        if ( (_BYTE)v14 == 64 )
          a1 += (v17 & 0x7FFFFFFF) != 0;
        a1 = -a1;
        v19 = 0;
      }
      v20 = a1;
      LOBYTE(v20) = v19 | a1;
      if ( HIDWORD(a1) | v20 && (_WORD)v9 )
      {
        if ( v19 )
        {
LABEL_31:
          v26 = v9 + 1;
          if ( v26 == 0x7FFF )
            goto LABEL_39;
          v4 = BYTE4(a1) & 1;
          HIDWORD(a1) = (HIDWORD(a1) >> 1) | 0x80000000;
          v27 = v4 << 31;
          v4 = a1 & 1;
          LODWORD(a1) = ((unsigned int)a1 >> 1) | v27;
          if ( v4 )
          {
            v28 = __CFADD__(v17, v17);
            if ( !(2 * v17) )
            {
              v29 = __ROR4__(a1, 1);
              v30 = __CFSHL__(v29, 1);
              LODWORD(a1) = __ROL4__(v29, 1);
              v28 = v30;
            }
            v31 = v28;
            v4 = __CFADD__(v28, (_DWORD)a1);
            LODWORD(a1) = v31 + a1;
            v32 = v4;
            v4 = __CFADD__(v4, HIDWORD(a1));
            HIDWORD(a1) += v32;
            if ( v4 )
            {
              LODWORD(a1) = a1 >> 1;
              if ( v26 == 32766 )
LABEL_39:
                LODWORD(a1) = 0;
            }
          }
        }
        else
        {
          v21 = __ROL4__(v17, 1);
          v23 = v21 & 1;
          v17 = __ROR4__(v21, 1);
          v22 = v23;
          while ( 1 )
          {
            LOWORD(v9) = v9 - 1;
            if ( !(_WORD)v9 )
              break;
            v24 = v22 + (_DWORD)a1;
            v4 = __CFADD__(v22, (_DWORD)a1) | __CFADD__((_DWORD)a1, v24);
            LODWORD(a1) = a1 + v24;
            v25 = v4 + HIDWORD(a1);
            v22 = __CFADD__(v4, HIDWORD(a1)) | __CFADD__(HIDWORD(a1), v25);
            HIDWORD(a1) += v25;
            if ( v22 )
              goto LABEL_31;
          }
        }
      }
    }
  }
  return a1;
}

//----- (000B3542) --------------------------------------------------------
int __fastcall sub_B3542(unsigned int a1, int a2)
{
  int v2; // esi
  _BOOL1 v3; // cf
  _BOOL1 v4; // zf
  int v5; // edi
  int result; // eax
  int v7; // edi
  int v8; // eax

  if ( (*(_WORD *)(a1 + 8) | 0x8000) == 0xFFFF && *(_DWORD *)a1 | (2 * *(_DWORD *)(a1 + 4))
    || (*(_WORD *)(a2 + 8) | 0x8000) == 0xFFFF && *(_DWORD *)a2 | (2 * *(_DWORD *)(a2 + 4)) )
  {
    return 2;
  }
  v2 = *(_DWORD *)(a1 + 6);
  if ( (v2 ^ *(_DWORD *)(a2 + 6)) >= 0 )
  {
    LOWORD(v2) = *(_WORD *)(a1 + 8);
    v3 = (unsigned __int16)v2 < *(_WORD *)(a2 + 8);
    v4 = (_WORD)v2 == *(_WORD *)(a2 + 8);
    if ( (_WORD)v2 == *(_WORD *)(a2 + 8) )
    {
      v3 = *(_QWORD *)a1 < *(_QWORD *)a2;
      v4 = *(_QWORD *)a1 == *(_QWORD *)a2;
    }
    v5 = 0;
    if ( v4 )
      return v5;
    v2 ^= (a1 >> 1) | (v3 << 31);
    return -2 * __CFADD__(v2, v2) + 1;
  }
  v7 = *(_DWORD *)(a2 + 4) | *(_DWORD *)(a1 + 4) | *(_DWORD *)a2 | *(_DWORD *)a1;
  LOWORD(a1) = *(_WORD *)(a1 + 8);
  v8 = a1 << 16;
  LOWORD(v8) = *(_WORD *)(a2 + 8);
  result = v7 | v8 & 0x7FFF7FFF;
  if ( result )
    return -2 * __CFADD__(v2, v2) + 1;
  return result;
}

//----- (000B35DB) --------------------------------------------------------
int __usercall sub_B35DB@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebp>, int a4@<esi>)
{
  int v4; // ecx
  unsigned int v5; // ebx
  int v6; // esi
  unsigned __int64 v7; // rax

  LOWORD(a4) = *(_WORD *)(a2 + 8);
  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)a2;
  v6 = a4 << 16;
  LOWORD(v6) = *(_WORD *)(a1 + 8);
  v7 = *(_QWORD *)a1;
  LODWORD(v7) = sub_B3605(v7, v4, v5, a3, v6);
  *(_QWORD *)v5 = v7;
  *(_WORD *)(v5 + 8) = v6;
  return v7;
}

//----- (000B3605) --------------------------------------------------------
int __usercall sub_B3605@<eax>(
        unsigned __int64 a1@<edx:eax>,
        int a2@<ecx>,
        unsigned int a3@<ebx>,
        _BYTE *a4@<ebp>,
        int a5@<esi>)
{
  _BOOL1 v5; // cf
  unsigned __int16 v6; // si
  int v7; // ecx
  int v8; // esi
  int v10; // edi
  int v11; // ecx
  __int16 v12; // di
  __int16 v13; // cx
  __int16 v14; // di
  unsigned int v15; // ecx
  unsigned int v16; // edi
  unsigned int v17; // esi
  unsigned __int64 v18; // rax
  int v19; // ecx
  int v20; // edi
  unsigned int i; // esi
  unsigned int v22; // edi
  int v23; // esi
  unsigned int v24; // eax
  unsigned __int64 v25; // kr18_8
  unsigned __int64 v26; // rax
  int v27; // ecx
  int v28; // edi
  unsigned int j; // esi
  __int16 v30; // di
  char v31; // cl
  _BYTE v33[12]; // [esp-20h] [ebp-20h]
  unsigned __int64 v34; // [esp-14h] [ebp-14h]
  __int16 v35; // [esp-Ch] [ebp-Ch]

  if ( a2 || a3 || (a5 & 0x7FFF0000) != 0 )
  {
    if ( !a1 )
    {
      v5 = __CFADD__((_WORD)a5, (_WORD)a5);
      v6 = 2 * a5;
      if ( !v6 )
        return a1;
      LOWORD(a5) = (v6 >> 1) | (v5 << 15);
    }
    v7 = a5;
    v8 = a2;
    v10 = __ROL4__(((int)__ROL4__(v7, 16) >> 16) & 0x80007FFF, 16);
    v11 = __ROL4__((v7 >> 16) & 0x80007FFF, 16);
    LOWORD(v10) = v11 + v10;
    v12 = __ROL4__(v10, 16);
    v13 = __ROL4__(v11, 16);
    if ( !v12 )
    {
      do
      {
        a1 *= 2i64;
        --v12;
      }
      while ( (a1 & 0x8000000000000000i64) == 0i64 );
    }
    if ( !v13 )
    {
      do
      {
        v8 = __PAIR64__(v8, a3) >> 31;
        a3 *= 2;
        --v13;
      }
      while ( v8 >= 0 );
    }
    v14 = v12 - v13 + 0x3FFF;
    if ( v14 == 0x7FFF )
    {
      LODWORD(a1) = 0;
    }
    else if ( v14 >= -64 )
    {
      v35 = v14;
      v34 = __PAIR64__(v8, a3);
      v15 = v8;
      v16 = HIDWORD(a1);
      v17 = a1;
      LODWORD(a1) = 0;
      if ( v15 <= HIDWORD(a1) )
      {
        HIDWORD(a1) -= v15;
        LODWORD(a1) = 1;
      }
      *(_DWORD *)&v33[8] = a1;
      *(_DWORD *)&v33[4] = __PAIR64__(HIDWORD(a1), v17) / v15;
      v18 = ((*(unsigned int *)&v33[4] * (unsigned __int64)a3) >> 32) + *(unsigned int *)&v33[4] * (unsigned __int64)v15;
      if ( (v33[8] & 1) != 0 )
        v18 += v34;
      v19 = -(*(_DWORD *)&v33[4] * a3);
      v20 = (__PAIR64__(v16, v17) - __PAIR64__(HIDWORD(v18), (*(_DWORD *)&v33[4] * a3 != 0) + (unsigned int)v18)) >> 32;
      for ( i = v17 - ((*(_DWORD *)&v33[4] * a3 != 0) + v18); v20; v20 += v5 )
      {
        --*(_QWORD *)&v33[4];
        v5 = __CFADD__(v34, __PAIR64__(i, v19));
        i = (v34 + __PAIR64__(i, v19)) >> 32;
        v19 += v34;
      }
      v22 = i;
      v23 = v19;
      if ( HIDWORD(v34) <= v22 )
      {
        v22 -= HIDWORD(v34);
        ++*(_QWORD *)&v33[4];
      }
      v24 = __PAIR64__(v22, v19) / HIDWORD(v34);
      *(_DWORD *)v33 = v24;
      if ( v24 )
      {
        v25 = v24 * (unsigned __int64)a3;
        v26 = HIDWORD(v25) + v24 * (unsigned __int64)HIDWORD(v34);
        v27 = -(int)v25;
        v28 = (__PAIR64__(v22, v23) - __PAIR64__(HIDWORD(v26), ((_DWORD)v25 != 0) + (unsigned int)v26)) >> 32;
        for ( j = v23 - (((_DWORD)v25 != 0) + v26); v28; v28 += v5 )
        {
          v5 = (*(_QWORD *)v33)-- == 0i64;
          *(_DWORD *)&v33[8] -= v5;
          v5 = __CFADD__(v34, __PAIR64__(j, v27));
          j = (v34 + __PAIR64__(j, v27)) >> 32;
          v27 += v34;
        }
      }
      a1 = *(_QWORD *)v33;
      v30 = v35 - 1;
      if ( v33[8] & 1 )
      {
        HIDWORD(a1) = *(__int64 *)&v33[4] >> 1;
        LODWORD(a1) = *(__int64 *)v33 >> 1;
        v30 = v35;
      }
      if ( v30 <= 0 )
      {
        if ( v30 )
          v31 = -(char)v30;
        else
          v31 = 1;
        LODWORD(a1) = a1 >> v31;
      }
    }
    else
    {
      LODWORD(a1) = 0;
    }
  }
  else if ( a1 || (WORD1(a1) = HIWORD(a5), 2 * (_WORD)a5) )
  {
    LOWORD(a1) = -31996;
    sub_B1E68(a1, 0, a4);
    LODWORD(a1) = 0;
  }
  else
  {
    LOWORD(a1) = -32511;
    sub_B1E68(a1, 0, a4);
    LODWORD(a1) = 0;
  }
  return a1;
}

//----- (000B37B0) --------------------------------------------------------
int __usercall sub_B37B0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>)
{
  unsigned int v3; // ecx
  unsigned int v4; // ebx
  int v5; // esi
  unsigned __int64 v6; // rax

  LOWORD(a3) = *(_WORD *)(a2 + 8);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)a2;
  v5 = a3 << 16;
  LOWORD(v5) = *(_WORD *)(a1 + 8);
  v6 = *(_QWORD *)a1;
  LODWORD(v6) = sub_B37DA(v6, v3, v4, v5);
  *(_QWORD *)v4 = v6;
  *(_WORD *)(v4 + 8) = v5;
  return v6;
}

//----- (000B37DA) --------------------------------------------------------
int __usercall sub_B37DA@<eax>(
        unsigned __int64 a1@<edx:eax>,
        unsigned int a2@<ecx>,
        unsigned int a3@<ebx>,
        int a4@<esi>)
{
  _BOOL1 v4; // cf
  unsigned __int16 v5; // si
  int v6; // ecx
  unsigned int v7; // esi
  unsigned int v9; // ecx
  __int16 v10; // cx
  unsigned __int64 v11; // rax
  int v12; // esi
  int v13; // et1
  unsigned int v14; // ecx
  unsigned __int64 v15; // rax
  unsigned int v16; // ecx
  unsigned int v17; // edi
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // kr08_8
  int v20; // ebx
  __int16 v21; // cx
  _BOOL1 v22; // cf
  bool v23; // ett
  _BOOL1 v24; // cf
  int v25; // ett
  int v26; // et2
  __int16 v27; // cx
  unsigned __int64 v29; // [esp-18h] [ebp-18h]
  unsigned int v30; // [esp-10h] [ebp-10h]
  __int16 v31; // [esp-Ch] [ebp-Ch]

  if ( !a1 )
  {
    v4 = __CFADD__((_WORD)a4, (_WORD)a4);
    v5 = 2 * a4;
    if ( !v5 )
      return a1;
    LOWORD(a4) = (v5 >> 1) | (v4 << 15);
  }
  if ( a2 || a3 || (a4 & 0x7FFF0000) != 0 )
  {
    v6 = a4;
    v7 = a2;
    v9 = (((int)__ROL4__(v6, 16) >> 16) & 0x80007FFF) + ((v6 >> 16) & 0x80007FFF);
    v4 = (unsigned __int16)v9 < 0x3FFEu;
    v10 = v9 - 16382;
    if ( !v4 && (unsigned __int16)v10 >= 0x7FFFu )
      goto LABEL_26;
    if ( v10 < -64 )
    {
      LODWORD(a1) = 0;
      return a1;
    }
    v31 = v10;
    v30 = v7;
    v29 = a1;
    v11 = a3 * (unsigned __int64)(unsigned int)a1;
    v13 = v11;
    LODWORD(v11) = v7;
    v12 = v13;
    v14 = HIDWORD(v11);
    v15 = (unsigned int)v29 * (unsigned __int64)(unsigned int)v11;
    v4 = __CFADD__((unsigned int)v15, __PAIR64__(HIDWORD(v15), v14));
    v17 = (v15 + v14) >> 32;
    v16 = v15 + v14;
    v18 = HIDWORD(v29) * (unsigned __int64)a3;
    v19 = v18 + __PAIR64__(v17, v16);
    a1 = __PAIR64__(__CFADD__(v18, __PAIR64__(v17, v16)) + (unsigned int)v4, (v18 + __PAIR64__(v17, v16)) >> 32)
       + v30 * (unsigned __int64)HIDWORD(v29);
    v20 = v19;
    v21 = v31;
    if ( (a1 & 0x8000000000000000i64) == 0i64 )
    {
      v4 = __CFADD__(__PAIR64__(a1, v19), __PAIR64__(a1, v19));
      LODWORD(a1) = __PAIR64__(a1, v19) >> 31;
      v20 = 2 * v19;
      HIDWORD(a1) += v4 + HIDWORD(a1);
      v21 = v31 - 1;
    }
    v22 = __CFADD__(v20, v20);
    if ( __CFADD__(v20, v20) )
    {
      if ( !(2 * v20) )
      {
        v22 = v12 != 0;
        if ( !v12 )
          v22 = a1 & 1;
      }
      v23 = v22;
      v4 = __CFADD__(v22, (_DWORD)a1);
      LODWORD(a1) = v23 + a1;
      v25 = v4;
      v24 = __CFADD__(v4, HIDWORD(a1));
      HIDWORD(a1) += v25;
      if ( v24 )
      {
        v26 = v24 << 31;
        v4 = BYTE4(a1) & 1;
        HIDWORD(a1) = (HIDWORD(a1) >> 1) | v26;
        LODWORD(a1) = ((unsigned int)a1 >> 1) | (v4 << 31);
        if ( ++v21 == 0x7FFF )
        {
LABEL_26:
          LODWORD(a1) = 0;
          return a1;
        }
      }
    }
    if ( v21 <= 0 )
    {
      if ( v21 )
        v27 = -v21;
      else
        LOBYTE(v27) = 1;
      LODWORD(a1) = a1 >> v27;
    }
  }
  else
  {
    LODWORD(a1) = 0;
  }
  return a1;
}

//----- (000B392B) --------------------------------------------------------
void sub_B392B()
{
  JUMPOUT(0xB3933);
}
// B392E: control flows out of bounds to B3933

//----- (000B3930) --------------------------------------------------------
int __fastcall sub_B3930(int *a1)
{
  __int16 v1; // cx
  int v2; // ebx
  unsigned int v3; // eax
  _BOOL1 v4; // cf
  char v5; // ch
  char v6; // ch
  int result; // eax

  v1 = (a1[2] & 0x7FFF) - 16382;
  if ( (a1[2] & 0x7FFFu) < 0x3FFE )
    return 0;
  if ( v1 > 32 || (char)(*((_BYTE *)a1 + 8) + 2) > 32 )
    return 0x80000000;
  HIBYTE(v1) = (*((_BYTE *)a1 + 9) >> 1) | 0x20;
  v2 = *a1;
  v3 = a1[1];
  HIBYTE(v1) = (HIBYTE(v1) >> 1) | (__CFADD__(v2, v2) << 7);
  if ( (_BYTE)v1 == 32 )
  {
    v4 = __CFADD__(HIBYTE(v1), HIBYTE(v1));
    v5 = 2 * HIBYTE(v1);
  }
  else
  {
    v5 = 2 * HIBYTE(v1);
    v4 = __CFADD__(v3 << v1, v3 << v1);
    v3 = (unsigned __int64)v3 << v1 >> 32;
  }
  v6 = ((v4 << 7) | 0x7F) & v5;
  result = __CFADD__(v6, v6) + v3;
  if ( __CFADD__(2 * v6, 2 * v6) )
    return -result;
  return result;
}

//----- (000B399A) --------------------------------------------------------
int __fastcall sub_B399A(int a1)
{
  if ( a1 < 0 )
    JUMPOUT(0xB39B3);
  return sub_B39AB();
}
// B39A8: control flows out of bounds to B39B3
// B39AB: using guessed type int sub_B39AB(void);

//----- (000B39AB) --------------------------------------------------------
int __fastcall sub_B39AB(unsigned int a1, int a2)
{
  unsigned int v3; // ecx
  unsigned int v4; // eax
  __int16 v5; // cx
  unsigned int v6; // edx
  int result; // eax

  if ( a1 )
  {
    _BitScanReverse(&v3, a1);
    v4 = a1 << (31 - v3);
    v5 = (unsigned __int8)v3 + 0x3FFF;
    v6 = v4;
  }
  else
  {
    v6 = 0;
    v5 = 0;
  }
  result = 0;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = v6;
  *(_WORD *)(a2 + 8) = v5;
  return result;
}

//----- (000B39E0) --------------------------------------------------------
int __usercall sub_B39E0@<eax>(__int64 a1@<edx:eax>, int a2@<ebx>, _BYTE *a3@<ebp>)
{
  int v3; // ecx
  signed __int64 v4; // rax
  int v5; // ecx
  _BOOL1 v6; // zf
  int v7; // et0
  unsigned int v9; // [esp-8h] [ebp-8h]

  v3 = HIDWORD(a1);
  v4 = a1 << 11;
  v5 = v3 >> 20;
  LOWORD(v5) = v5 & 0x7FF;
  if ( (_WORD)v5 )
  {
    if ( (_WORD)v5 == 2047 )
    {
      LOWORD(v5) = 0x7FFF;
      v6 = (v4 & 0x7FFFFFFF00000000i64) == 0;
      if ( (v4 & 0x7FFFFFFF00000000i64) == 0 )
        v6 = (_DWORD)v4 == 0;
      if ( !v6 )
      {
        v9 = v4;
        LOWORD(v4) = -32511;
        sub_B1E68(v4, v5, a3);
        v4 = __PAIR64__(HIDWORD(v4), v9) | 0x4000000000000000i64;
      }
    }
    else
    {
      LOWORD(v5) = v5 + 15360;
    }
    HIDWORD(v4) |= 0x80000000;
  }
  else if ( v4 )
  {
    LOWORD(v5) = 15361;
    if ( !HIDWORD(v4) )
    {
      v7 = v4;
      LODWORD(v4) = 0;
      HIDWORD(v4) = v7;
      LOWORD(v5) = 15329;
    }
    while ( v4 >= 0 )
    {
      v4 *= 2i64;
      LOWORD(v5) = v5 - 1;
    }
  }
  else
  {
    v5 = 0;
  }
  *(_QWORD *)a2 = v4;
  *(_WORD *)(a2 + 8) = ((unsigned __int16)(2 * v5) >> 1) | (__CFADD__(v5, v5) << 15);
  return v4;
}

//----- (000B3A60) --------------------------------------------------------
int __fastcall sub_B3A60(int a1)
{
  int v2; // edx
  unsigned int v3; // eax
  unsigned int v4; // ecx
  _BOOL1 v5; // cf
  int result; // eax
  __int16 v7; // bx
  __int16 v8; // cx
  unsigned __int64 v9; // rt0

  v2 = -256;
  v3 = *(_DWORD *)(a1 + 4);
  v4 = v3 << 25;
  LOWORD(v4) = *(_WORD *)(a1 + 8);
  if ( __CFSHL__(v3, 25) )
  {
    if ( !(v3 << 25) && !*(_DWORD *)a1 )
      v2 = -512;
    v5 = __CFADD__(v3, 256);
    v3 += 256;
    if ( v5 )
    {
      v3 = 0x80000000;
      LOWORD(v4) = v4 + 1;
    }
  }
  result = v2 & v3;
  v7 = v4;
  v8 = v4 & 0x7FFF;
  if ( v8 )
  {
    if ( v8 == 0x7FFF )
    {
      return ((((unsigned int)(2 * result) >> 8) | 0xFF000000) >> 1) | (__CFADD__(v7, v7) << 31);
    }
    else
    {
      LOWORD(v4) = v8 - 16256;
      if ( (v4 & 0x8000u) == 0 )
      {
        if ( (__int16)v4 < 255 )
        {
          LODWORD(v9) = 2 * result;
          HIDWORD(v9) = v4;
          return ((unsigned int)(v9 >> 8) >> 1) | (__CFADD__(v7, v7) << 31);
        }
        else
        {
          return (__CFADD__(v7, v7) << 31) | 0x7F800000;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

//----- (000B3ADF) --------------------------------------------------------
int __usercall sub_B3ADF@<eax>(__int64 *a1@<eax>, _BYTE *a2@<ebp>)
{
  __int16 v2; // cx
  unsigned __int64 v3; // rax
  int v4; // esi
  _BOOL1 v5; // cf
  __int16 v6; // cx
  int result; // eax
  unsigned __int8 v8; // cl
  int v9; // [esp-4h] [ebp-10h]

  v2 = *((_WORD *)a1 + 4);
  v3 = *a1;
  v4 = -2048;
  if ( __CFSHL__(v3, 22) )
  {
    if ( !((_DWORD)v3 << 22) )
      v4 = -4096;
    v5 = __CFADD__(v3, 2048i64);
    v3 += 2048i64;
    if ( v5 )
    {
      HIDWORD(v3) = 0x80000000;
      ++v2;
    }
  }
  LODWORD(v3) = v4 & v3;
  v6 = (v2 & 0x7FFF) - 15360;
  if ( (unsigned __int16)v6 >= 0x7FFu )
  {
    if ( (unsigned __int16)v6 < 0xC400u )
    {
      result = v3 >> 11;
      if ( v6 != 17407 )
      {
        v9 = result;
        LOWORD(result) = -31736;
        sub_B1E68(result, v6, a2);
        return v9;
      }
    }
    else if ( v6 < -52 )
    {
      return 0;
    }
    else
    {
      v8 = 12 - v6;
      if ( v8 >= 0x20u )
      {
        v8 -= 32;
        v4 = v3;
        v3 = HIDWORD(v3);
      }
      return ((unsigned int)(__PAIR64__(v3, v4) >> v8) + __PAIR64__(v3 >> (v8 & 0x1F), __PAIR64__(v3, v4) >> v8)) >> 32;
    }
  }
  else if ( v6 )
  {
    return v3 >> 11;
  }
  else
  {
    return v3 >> 12;
  }
  return result;
}

//----- (000B3BA6) --------------------------------------------------------
signed int __fastcall sub_B3BA6(signed int result, int a2)
{
  int v2; // ecx
  signed int v3; // eax

  v2 = result >> 23;
  LOWORD(v2) = (unsigned __int8)(result >> 23);
  if ( (unsigned __int8)(result >> 23) )
  {
    v3 = result << 8;
    if ( (_BYTE)v2 == 0xFF )
    {
      LOWORD(v2) = -1;
      v3 &= ~0x80000000;
      if ( v3 )
        v3 |= 0x40000000u;
    }
    else
    {
      LOWORD(v2) = v2 + 16256;
    }
    LOWORD(v2) = ((unsigned __int16)(2 * v2) >> 1) | (__CFADD__(v2, v2) << 15);
    result = v3 | 0x80000000;
  }
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = result;
  *(_WORD *)(a2 + 8) = v2;
  return result;
}

//----- (000B3C6B) --------------------------------------------------------
unsigned int __fastcall sub_B3C6B(unsigned int result, __int16 a2)
{
  int v3; // ebx
  _BOOL1 v4; // zf
  __int16 v5; // bx
  char v6; // cc
  __int16 v7; // bx
  int v8; // ecx
  int v9; // eax
  unsigned int v10; // ecx
  _BOOL1 v11; // tt
  _BOOL1 v12; // zf
  _BOOL1 v13; // cf
  int v14; // esi
  int v15; // eax
  unsigned int v16; // esi
  _BOOL1 v17; // tt
  _BOOL1 v18; // zf

  _EDI = result;
  v3 = *(unsigned __int16 *)(result + 8);
  v4 = a2 == 1024;
  if ( a2 != 1024 )
    v4 = a2 == 2048;
  if ( v4 && (v3 & 0x8000) != 0 )
    a2 ^= 0xC00u;
  if ( a2 == 3072 )
    a2 = 1024;
  v5 = v3 & 0x7FFF;
  v6 = v5 < 16447;
  v7 = v5 - 16447;
  if ( v6 )
  {
    v8 = *(_DWORD *)result;
    v6 = ((__int16)(v7 + 32) < 0) ^ __OFADD__(32, v7);
    LOWORD(v3) = v7 + 32;
    if ( !v6 )
    {
      v9 = dword_B3BEB[v3];
      v10 = v9 & v8;
      *(_DWORD *)_EDI ^= v10;
      result = v9 + 1;
      if ( a2 == 1024 )
        return result;
      if ( !a2 )
      {
        v10 *= 2;
        if ( result > v10 )
          return result;
        if ( result == v10 )
        {
          v11 = __CFSHL__(result, 1);
          result = __ROL4__(result, 1);
          if ( v11 )
            v12 = (result & *(_DWORD *)(_EDI + 4)) == 0;
          else
            v12 = (result & *(_DWORD *)_EDI) == 0;
          if ( v12 )
            return result;
          result = __ROR4__(result, 1);
        }
      }
      if ( v10 )
      {
        v13 = __CFADD__(result, *(_QWORD *)_EDI);
        *(_QWORD *)_EDI += result;
        if ( v13 )
        {
          __asm { rcr     dword ptr [edi+4], 1 }
          ++*(_WORD *)(_EDI + 8);
        }
      }
      return result;
    }
    *(_DWORD *)result = 0;
    v14 = *(_DWORD *)(result + 4);
    v6 = ((__int16)(v3 + 32) < 0) ^ __OFADD__(32, (_WORD)v3);
    LOWORD(v3) = v3 + 32;
    if ( v6 )
    {
      if ( a2 != 1024 && (a2 || (_WORD)v3 == 0xFFFF && (v14 != 0x80000000 || v8)) )
      {
        *(_DWORD *)(result + 4) = 0x80000000;
        *(_WORD *)(result + 8) |= 0x3FFFu;
      }
      else
      {
        result = 0;
        *(_DWORD *)(_EDI + 4) = 0;
        *(_WORD *)(_EDI + 8) = 0;
      }
      return result;
    }
    v15 = dword_B3BEB[v3];
    v16 = v15 & v14;
    *(_DWORD *)(_EDI + 4) ^= v16;
    result = v15 + 1;
    if ( a2 == 1024 )
      return result;
    if ( !a2 )
    {
      v17 = __CFSHL__(v8, 1);
      v8 = __ROL4__(v8, 1);
      v16 += v17 + v16;
      if ( result > v16 )
        return result;
      if ( result == v16 )
      {
        if ( v8 )
        {
LABEL_35:
          v13 = __CFADD__(result, *(_DWORD *)(_EDI + 4));
          *(_DWORD *)(_EDI + 4) += result;
          if ( v13 )
          {
            __asm { rcr     dword ptr [edi+4], 1 }
            ++*(_WORD *)(_EDI + 8);
          }
          return result;
        }
        v13 = __CFADD__(result, result);
        v18 = 2 * result == 0;
        result *= 2;
        if ( !v13 )
          v18 = (result & *(_DWORD *)(_EDI + 4)) == 0;
        if ( v18 )
          return result;
        result >>= 1;
      }
    }
    if ( !(v16 | v8) )
      return result;
    goto LABEL_35;
  }
  return result;
}
// B3BEB: using guessed type int dword_B3BEB[];

//----- (000B3DF8) --------------------------------------------------------
__int16 __usercall sub_B3DF8@<ax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _BYTE *a4@<ebp>, int a5@<esi>)
{
  char v5; // ch
  char v6; // dl

  if ( 2 * *(_WORD *)(a1 + 8) )
  {
    if ( 2 * *(_WORD *)(a2 + 8) )
    {
      v5 = *(_BYTE *)(a1 + 9);
      sub_B35DB(a1, a2, a4, a5);
      LOWORD(a1) = sub_B3EAE(a3, a4, a5);
      v6 = *(_BYTE *)(a3 + 9);
      if ( v5 < 0 )
      {
        if ( v6 > 0 )
          LOWORD(a1) = sub_B33A6(a3, a5, 560513589, -921707870, 49152);
      }
      else if ( v6 < 0 )
      {
        LOWORD(a1) = sub_B33A6(a3, a5, 560513589, -921707870, 0x4000);
      }
    }
    else
    {
      LOWORD(a1) = *(_WORD *)(a1 + 8) & 0x8000 | 0x3FFF;
      *(_WORD *)(a3 + 8) = a1;
      *(_DWORD *)(a3 + 4) = -921707870;
      *(_DWORD *)a3 = 560513589;
    }
  }
  else if ( *(char *)(a2 + 9) >= 0 )
  {
    *(_WORD *)(a3 + 8) = 0;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)a3 = 0;
  }
  else
  {
    *(_WORD *)(a3 + 8) = 0x4000;
    *(_DWORD *)(a3 + 4) = -921707870;
    *(_DWORD *)a3 = 560513589;
  }
  return a1;
}

//----- (000B3EAE) --------------------------------------------------------
__int16 __usercall __spoils<> sub_B3EAE@<ax>(int a1@<eax>, _BYTE *a2@<ebp>, int a3@<esi>)
{
  unsigned __int8 v4; // ch
  char v5; // cl
  __int16 result; // ax
  unsigned __int16 v7; // ax
  _BOOL1 v8; // cc
  int v9; // esi
  __int64 v10; // rax
  unsigned __int64 v11; // rax
  int v12; // esi
  int v13; // esi
  int v14; // ebx
  char v15; // cf
  char v16; // ch
  int v17; // [esp-1Ch] [ebp-24h]
  int v18; // [esp-18h] [ebp-20h]
  int v19; // [esp-14h] [ebp-1Ch]

  v4 = 0;
  v5 = *(_BYTE *)(a1 + 9);
  *(_BYTE *)(a1 + 9) = v5 & 0x7F;
  if ( *(_WORD *)(a1 + 8) == 0x3FFF && *(_DWORD *)(a1 + 4) == 0x80000000 && !*(_DWORD *)a1 )
  {
    *(_DWORD *)a1 = 560513589;
    *(_DWORD *)(a1 + 4) = -921707870;
    LOBYTE(result) = -2;
    HIBYTE(result) = v5 & 0x80 | 0x3F;
    *(_WORD *)(a1 + 8) = result;
  }
  else
  {
    if ( *(__int16 *)(a1 + 8) >= 0x3FFF )
    {
      LOWORD(a3) = *(_WORD *)(a1 + 8);
      a3 <<= 16;
      LOWORD(a3) = 0x3FFF;
      *(_DWORD *)a1 = sub_B3605(0x8000000000000000i64, *(_DWORD *)(a1 + 4), *(_DWORD *)a1, a2, a3);
      *(_DWORD *)(a1 + 4) = 0x80000000;
      *(_WORD *)(a1 + 8) = 0x3FFF;
      v4 = 2;
    }
    v7 = *(_WORD *)(a1 + 8);
    v8 = v7 <= 0x3FFDu;
    if ( v7 == 16381 )
      v8 = *(_QWORD *)a1 <= 0x8930A2F4F66AB09Bi64;
    if ( !v8 )
    {
      HIWORD(v9) = 0x3FFF;
      v10 = *(_QWORD *)a1;
      LOWORD(v9) = *(_WORD *)(a1 + 8);
      v19 = sub_B33D6(*(_QWORD *)a1, -575416510, -1033546850, v9);
      v18 = HIDWORD(v10);
      v17 = v9;
      HIWORD(v9) = 0x3FFF;
      v11 = *(_QWORD *)a1;
      LOWORD(v9) = *(_WORD *)(a1 + 8);
      LODWORD(v11) = sub_B37DA(*(_QWORD *)a1, 0xDDB3D742, 0xC265539E, v9);
      v12 = __ROL4__(v9, 16);
      LOWORD(v12) = -16385;
      v13 = __ROL4__(v12, 16);
      LODWORD(v11) = sub_B33D6(v11, 0x80000000, 0, v13);
      v14 = v17 << 16;
      LOWORD(v14) = v13;
      a3 = v14;
      *(_DWORD *)a1 = sub_B3605(v11, v18, v19, a2, v14);
      *(_DWORD *)(a1 + 4) = HIDWORD(v11);
      *(_WORD *)(a1 + 8) = v14;
      v4 |= 1u;
    }
    result = sub_B4A2A(a1, (int)&word_B3D9E, a3);
    v15 = v4 & 1;
    v16 = v4 >> 1;
    if ( v15 )
      result = sub_B33A6(a1, a3, 1805331491, -2046127679, 16382);
    if ( v16 & 1 )
    {
      result = sub_B33A6(a1, a3, 560513589, -921707870, 49151);
      *(_BYTE *)(a1 + 9) ^= 0x80u;
    }
    if ( v5 < 0 )
      *(_BYTE *)(a1 + 9) ^= 0x80u;
  }
  return result;
}
// B3D9E: using guessed type __int16 word_B3D9E;

//----- (000B4011) --------------------------------------------------------
int __usercall sub_B4011@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>)
{
  __int16 v4; // si
  unsigned int v5; // ecx
  unsigned int v6; // ebx
  __int64 v7; // rax

  if ( !*(_WORD *)(a1 + 8) && !*(_DWORD *)(a1 + 4) && !*(_DWORD *)a1 )
    return 0;
  if ( *(_WORD *)(a2 + 8) || *(_DWORD *)(a2 + 4) || *(_DWORD *)a2 )
  {
    v4 = *(_WORD *)(a1 + 8);
    LOWORD(a3) = *(_WORD *)(a2 + 8);
    v5 = *(_DWORD *)(a2 + 4);
    v6 = *(_DWORD *)a2;
    v7 = *(_QWORD *)a1;
    *(_DWORD *)a1 = sub_B4077(v7, v5, v6, a3, v4);
    *(_DWORD *)(a1 + 4) = HIDWORD(v7);
    *(_WORD *)(a1 + 8) = v4;
    return a3;
  }
  else
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_WORD *)(a1 + 8) = 0;
    return 0;
  }
}

//----- (000B4077) --------------------------------------------------------
int __usercall sub_B4077@<eax>(
        __int64 a1@<edx:eax>,
        unsigned int a2@<ecx>,
        unsigned int a3@<ebx>,
        __int16 a4@<di>,
        __int16 a5@<si>)
{
  int v5; // esi
  int v6; // edi
  _BOOL1 v7; // cc
  int v8; // esi
  int v9; // edi
  _BOOL1 v10; // cf
  int v11; // esi
  int v12; // ett

  v5 = a5 & 0x7FFF;
  v6 = a4 & 0x7FFF;
  v7 = v5 < v6;
  v8 = v5 - v6;
  if ( !v7 )
  {
    v9 = 0;
LABEL_3:
    v10 = a2 < HIDWORD(a1);
    if ( a2 == HIDWORD(a1) && (v10 = a3 < (unsigned int)a1, a3 == (_DWORD)a1) || v10 )
    {
LABEL_6:
      a1 -= __PAIR64__(a2, a3);
      v10 = 1;
    }
    while ( 1 )
    {
      v9 += v10 + v9;
      v7 = v8-- < 1;
      if ( v7 )
        break;
      v10 = __CFADD__(a1, a1);
      a1 *= 2i64;
      if ( v10 )
        goto LABEL_6;
      v10 = 0;
      if ( a1 < 0 )
        goto LABEL_3;
    }
    v11 = 0;
    if ( a1 )
    {
      while ( a1 >= 0 )
      {
        v12 = (a1 + (unsigned __int64)(unsigned int)a1) >> 32;
        LODWORD(a1) = 2 * a1;
        HIDWORD(a1) += v12;
        --v11;
      }
    }
  }
  return a1;
}

//----- (000B41E0) --------------------------------------------------------
int __usercall sub_B41E0@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebp>, int a4@<esi>)
{
  sub_B33A6(a1, a4, 0, 0x80000000, 0x3FFF);
  return sub_B41F9(a1, a2, a3, a4);
}

//----- (000B41F9) --------------------------------------------------------
int __usercall sub_B41F9@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebp>, int a4@<esi>)
{
  int v4; // esi
  int result; // eax

  sub_B423C(a1, a3);
  sub_B37B0(a1, a2, a4);
  LOWORD(a4) = *(_WORD *)(a2 + 8);
  v4 = a4 << 16;
  LOWORD(v4) = 0x3FFF;
  result = sub_B37DA(0xB8AA3B295C17F0BDi64, *(_DWORD *)(a2 + 4), *(_DWORD *)a2, v4);
  *(_DWORD *)a2 = result;
  *(_DWORD *)(a2 + 4) = -1196803287;
  *(_WORD *)(a2 + 8) = 0x3FFF;
  return result;
}

//----- (000B423C) --------------------------------------------------------
int __usercall sub_B423C@<eax>(int a1@<eax>, _BYTE *a2@<ebp>)
{
  __int64 v3; // rax
  _BOOL1 v4; // cc
  __int64 v5; // rax
  int v6; // esi
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // kr00_8
  int v9; // esi
  int v10; // esi
  int v11; // esi
  int v12; // esi
  int v13; // esi
  int v14; // esi
  int v15; // esi
  int v16; // esi
  __int64 v17; // rax
  __int64 v18; // kr08_8
  __int64 v19; // rax
  int v20; // esi
  int v21; // esi
  int v22; // esi
  int v23; // esi
  int v24; // esi
  unsigned int v26; // [esp+4h] [ebp-20h]
  __int16 v27; // [esp+4h] [ebp-20h]
  __int16 v28; // [esp+4h] [ebp-20h]
  unsigned int v29; // [esp+8h] [ebp-1Ch]
  unsigned int v30; // [esp+8h] [ebp-1Ch]
  int v31; // [esp+8h] [ebp-1Ch]
  int v32; // [esp+Ch] [ebp-18h]
  int v33; // [esp+Ch] [ebp-18h]

  v32 = *(unsigned __int16 *)(a1 + 8) - 16382;
  *(_WORD *)(a1 + 8) = 16382;
  v3 = *(_QWORD *)a1;
  LODWORD(v3) = sub_B33D6(v3, 0x80000000, 0, -1073856514);
  v4 = *(_WORD *)(a1 + 8) <= 0x3FFEu;
  if ( *(_WORD *)(a1 + 8) == 16382 )
    v4 = *(_QWORD *)a1 <= 0xB504F333F9DE6484i64;
  if ( v4 )
  {
    *(_QWORD *)a1 = v3;
    *(_WORD *)(a1 + 8) = 16382;
    --v32;
  }
  else
  {
    LODWORD(v3) = sub_B33D6(v3, 0x80000000, 0, -1073856514);
  }
  v26 = HIDWORD(v3);
  v29 = v3;
  v5 = *(_QWORD *)a1;
  v6 = (unsigned __int16)(*(_WORD *)(a1 + 8) - 1) | 0x3FFE0000;
  LODWORD(v5) = sub_B33D6(*(_QWORD *)a1, 0x80000000, 0, v6);
  v6 <<= 16;
  LOWORD(v6) = 16382;
  v7 = __PAIR64__(v26, sub_B3605(__PAIR64__(v26, v29), SHIDWORD(v5), v5, a2, v6));
  v30 = v7;
  v6 <<= 16;
  LOWORD(v6) = 16382;
  *(_DWORD *)a1 = sub_B37DA(v7, HIDWORD(v7), v7, v6);
  *(_DWORD *)(a1 + 4) = HIDWORD(v7);
  *(_WORD *)(a1 + 8) = 16382;
  sub_B49D8((int)&dword_B41B8, v6);
  v8 = v7;
  HIDWORD(v17) = *(_DWORD *)(a1 + 4);
  LOWORD(v6) = *(_WORD *)(a1 + 8);
  sub_B49D8((int)&word_B419A, v6);
  v9 = __ROL4__(v6, 16);
  LOWORD(v9) = 16382;
  v10 = __ROL4__(v9, 16);
  LODWORD(v17) = sub_B3605(v17, SHIDWORD(v8), v8, a2, v10);
  v11 = __ROL4__(v10, 16);
  LOWORD(v11) = *(_WORD *)(a1 + 8);
  v12 = __ROL4__(v11, 16);
  LODWORD(v17) = sub_B37DA(v17, *(_DWORD *)(a1 + 4), *(_DWORD *)a1, v12);
  v13 = __ROL4__(v12, 16);
  LOWORD(v13) = 16382;
  v14 = __ROL4__(v13, 16);
  LODWORD(v17) = sub_B37DA(v17, v26, v30, v14);
  v15 = __ROL4__(v14, 16);
  LOWORD(v15) = 16382;
  v16 = __ROL4__(v15, 16);
  LODWORD(v17) = sub_B33D6(v17, v26, v30, v16);
  if ( v32 )
  {
    v18 = v17;
    v27 = v16;
    sub_B399A(v32);
    v19 = *(_QWORD *)a1;
    v20 = *(unsigned __int16 *)(a1 + 8) | 0xBFF20000;
    LODWORD(v19) = sub_B37DA(*(_QWORD *)a1, 0xDE8082E3, 0x865435Cu, v20);
    v21 = __ROL4__(v20, 16);
    LOWORD(v21) = v27;
    v22 = __ROL4__(v21, 16);
    v33 = sub_B33D6(v19, SHIDWORD(v18), v18, v22);
    v31 = HIDWORD(v19);
    v28 = v22;
    v17 = *(_QWORD *)a1;
    v23 = *(unsigned __int16 *)(a1 + 8) | 0x3FFE0000;
    LODWORD(v17) = sub_B37DA(*(_QWORD *)a1, 0xB1800000, 0, v23);
    v24 = __ROL4__(v23, 16);
    LOWORD(v24) = v28;
    v16 = __ROL4__(v24, 16);
    LODWORD(v17) = sub_B33D6(v17, v31, v33, v16);
  }
  *(_QWORD *)a1 = v17;
  *(_WORD *)(a1 + 8) = v16;
  return v17;
}
// B431B: variable 'v7' is possibly undefined
// B4342: variable 'v17' is possibly undefined
// B419A: using guessed type __int16 word_B419A;
// B41B8: using guessed type int dword_B41B8;

//----- (000B44D4) --------------------------------------------------------
int __usercall sub_B44D4@<eax>(int a1@<eax>, int a2@<esi>)
{
  __int16 v2; // si
  __int64 v3; // rax
  char v4; // al
  int v5; // edi
  int v6; // esi
  __int16 v7; // ax
  int v8; // ecx
  __int16 v9; // ax
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rax
  int v12; // esi
  int v13; // ecx
  unsigned int v14; // ebx
  __int16 v16; // [esp-4h] [ebp-1Ch]
  __int16 v19; // [esp+4h] [ebp-14h]
  unsigned __int64 v20; // [esp+Ch] [ebp-Ch]
  __int16 v21; // [esp+14h] [ebp-4h]
  _BYTE savedregs[20]; // [esp+18h] [ebp+0h] BYREF

  v2 = *(_WORD *)(a1 + 8);
  v3 = *(_QWORD *)a1;
  *(_DWORD *)a1 = sub_B4077(v3, 0xC90FDAA2, 0x2168C235u, 16382, v2);
  *(_DWORD *)(a1 + 4) = HIDWORD(v3);
  *(_WORD *)(a1 + 8) = v2;
  v4 = -2;
  v5 = a1;
  v6 = a2;
  if ( *(char *)(a1 + 9) < 0 )
  {
    sub_B33A6(a1, a2, 560513589, -921707870, 16382);
    v4 = -3;
  }
  HIBYTE(v7) = a2;
  LOBYTE(v7) = ((a2 & 2) + v4) & 7;
  v19 = v7;
  if ( (v7 & 1) != 0 )
  {
    sub_B33A6(v5, v6, 560513589, -921707870, 49150);
    *(_BYTE *)(v5 + 9) ^= 0x80u;
  }
  v8 = (unsigned __int16)(*(_WORD *)(v5 + 8) - 16382);
  if ( (__int16)v8 >= -32 )
  {
    if ( (v8 & 0x8000u) == 0 )
      LOWORD(v8) = 0;
    LOWORD(v8) = -(__int16)v8;
    if ( (__int16)v8 > 8 )
      LOWORD(v8) = 8;
    LOWORD(v8) = word_B44C2[v8];
    HIBYTE(v9) = HIBYTE(v19);
    LOBYTE(v9) = (v19 + 1) & 2;
    if ( (_BYTE)v9 || HIBYTE(v19) == 1 )
    {
      v16 = v9;
      v10 = *(_QWORD *)v5;
      LOWORD(v6) = *(_WORD *)(v5 + 8);
      v6 <<= 16;
      LOWORD(v6) = *(_WORD *)(v5 + 8);
      sub_B37DA(*(_QWORD *)v5, *(_DWORD *)(v5 + 4), *(_DWORD *)v5, v6);
      sub_B49D8((int)dword_B4468 + 10 * v8, v6);
      v20 = v10;
      v21 = v6;
      v9 = v16;
    }
    if ( !(_BYTE)v9 || HIBYTE(v9) == 1 )
      sub_B4A2A(v5, (int)&word_B440E[5 * v8], v6);
  }
  else
  {
    v20 = 0x8000000000000000i64;
    v21 = 0x3FFF;
  }
  if ( (((_BYTE)v19 + 1) & 2) != 0 )
  {
    v11 = v20;
    LOWORD(v6) = v21;
  }
  else
  {
    v11 = *(_QWORD *)v5;
    LOWORD(v6) = *(_WORD *)(v5 + 8);
  }
  if ( (v19 & 4) != 0 )
    LOWORD(v6) = v6 ^ 0x8000;
  if ( HIBYTE(v19) == 1 )
  {
    v12 = __ROL4__(v6, 16);
    if ( (((_BYTE)v19 + 3) & 2) != 0 )
    {
      v13 = HIDWORD(v20);
      v14 = v20;
      LOWORD(v12) = v21;
    }
    else
    {
      v14 = *(_DWORD *)v5;
      v13 = *(_DWORD *)(v5 + 4);
      LOWORD(v12) = *(_WORD *)(v5 + 8);
    }
    if ( (((_BYTE)v19 + 2) & 4) != 0 )
      v12 ^= 0x8000u;
    v6 = __ROL4__(v12, 16);
    if ( v14 || v13 || (v6 & 0x7FFF0000) != 0 )
    {
      LODWORD(v11) = sub_B3605(v11, v13, v14, savedregs, v6);
    }
    else
    {
      v11 = 0x8000000000000000i64;
      LOWORD(v6) = v6 | 0x7FFF;
    }
  }
  *(_QWORD *)v5 = v11;
  *(_WORD *)(v5 + 8) = v6;
  return v11;
}
// B45FE: variable 'v10' is possibly undefined
// B463B: variable 'v20' is possibly undefined
// B4641: variable 'v21' is possibly undefined
// B440E: using guessed type __int16 word_B440E[];
// B4468: using guessed type int dword_B4468[19];
// B44C2: using guessed type __int16 word_B44C2[];

//----- (000B46CB) --------------------------------------------------------
int __fastcall sub_B46CB(int a1)
{
  return sub_B44D4(a1, 0);
}

//----- (000B46D5) --------------------------------------------------------
int __fastcall sub_B46D5(int a1)
{
  return sub_B44D4(a1, 2);
}

//----- (000B46E2) --------------------------------------------------------
int __fastcall sub_B46E2(int a1)
{
  return sub_B44D4(a1, 1);
}

//----- (000B4718) --------------------------------------------------------
int __fastcall sub_B4718(int a1, int a2, int a3, int a4)
{
  int v5; // esi
  __int16 v6; // cx
  _BOOL1 v7; // zf
  unsigned __int16 v8; // bx
  int v9; // ecx
  signed __int64 v10; // rax
  _BOOL1 v11; // cf
  __int16 v12; // bx
  unsigned __int64 v13; // rax
  int v14; // esi
  int v15; // esi
  int v16; // esi
  int v17; // esi
  int v18; // esi
  int v19; // esi
  int v20; // esi
  int v21; // esi
  int v22; // esi
  int v23; // esi
  int v24; // esi
  int v25; // esi
  unsigned __int64 v26; // rax
  unsigned int v27; // ecx
  int (*v28)(); // esi
  int v29; // eax
  int v30; // et0
  int v31; // esi
  __int32 v33; // [esp-2Ch] [ebp-38h] BYREF
  __int32 v34; // [esp-28h] [ebp-34h] BYREF
  unsigned int v35; // [esp-24h] [ebp-30h] BYREF
  __int32 v36; // [esp-20h] [ebp-2Ch] BYREF
  __int32 v37; // [esp-1Ch] [ebp-28h] BYREF
  int (*v38)(); // [esp-18h] [ebp-24h] BYREF
  int v39; // [esp-14h] [ebp-20h]
  int v40; // [esp-10h] [ebp-1Ch]
  int v41; // [esp-8h] [ebp-14h]

  v41 = a4;
  v5 = 0;
  v6 = *(_WORD *)(a1 + 8);
  *(_BYTE *)(a1 + 9) &= ~0x80u;
  v7 = *(_WORD *)(a1 + 8) == 0;
  if ( !*(_WORD *)(a1 + 8) )
    v7 = *(_QWORD *)a1 == 0i64;
  if ( v7 )
  {
    v9 = 0;
  }
  else
  {
    if ( v6 < 0 )
    {
      v5 = -1;
      sub_B33A6(a1, -1, 0, 0x80000000, 49151);
      *(_BYTE *)(a1 + 9) ^= 0x80u;
    }
    v8 = *(_WORD *)(a1 + 8) + 4;
    v9 = 0;
    v10 = *(_QWORD *)a1;
    while ( v8 >= 0x3FFFu )
    {
      v11 = __CFADD__(v10, v10);
      v10 *= 2i64;
      v9 += v11 + v9;
      --v8;
    }
    if ( v10 )
    {
      while ( v10 >= 0 )
      {
        v10 *= 2i64;
        --v8;
      }
      v12 = v8 - 4;
    }
    else
    {
      v12 = 0;
    }
    *(_QWORD *)a1 = v10;
    *(_WORD *)(a1 + 8) = v12;
  }
  v40 = v5;
  v39 = v9;
  v13 = *(_QWORD *)a1;
  LOWORD(v5) = *(_WORD *)(a1 + 8);
  v14 = v5 << 16;
  LOWORD(v14) = *(_WORD *)(a1 + 8);
  LODWORD(v13) = sub_B37DA(*(_QWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)a1, v14);
  v37 = HIDWORD(v13);
  v38 = (int (*)())v13;
  v36 = v14;
  v15 = (unsigned __int16)v14 | 0x40030000;
  LODWORD(v13) = _InterlockedExchange((volatile __int32 *)&v38, sub_B33D6(v13, -1501390215, 468852620, v15));
  HIDWORD(v13) = _InterlockedExchange(&v37, SHIDWORD(v13));
  v16 = (unsigned __int16)_InterlockedExchange(&v36, v15) | 0x3FFA0000;
  LODWORD(v13) = sub_B37DA(v13, 0xEC96F0D6, 0x9D7BFDBu, v16);
  v17 = (unsigned __int16)v16 | 0x40010000;
  LODWORD(v13) = sub_B33D6(v13, -422247142, -449388153, v17);
  v18 = __ROL4__(v17, 16);
  LOWORD(v18) = *(_WORD *)(a1 + 8);
  v19 = __ROL4__(v18, 16);
  LODWORD(v13) = sub_B37DA(v13, *(_DWORD *)(a1 + 4), *(_DWORD *)a1, v19);
  v34 = HIDWORD(v13);
  v35 = v13;
  v33 = v19;
  v20 = __ROL4__(v19 ^ 0x8000, 16);
  LOWORD(v20) = v36;
  v21 = __ROL4__(v20, 16);
  LODWORD(v13) = _InterlockedExchange((volatile __int32 *)&v35, sub_B33D6(v13, v37, (int)v38, v21));
  HIDWORD(v26) = _InterlockedExchange(&v34, SHIDWORD(v13));
  v22 = __ROL4__(_InterlockedExchange(&v33, v21), 16);
  LOWORD(v22) = v36;
  v23 = __ROL4__(v22, 16);
  LODWORD(v26) = sub_B33D6(v26, v37, (int)v38, v23);
  v24 = __ROL4__(v23, 16);
  LOWORD(v24) = v33;
  v25 = __ROL4__(v24, 16);
  LODWORD(v26) = sub_B3605(v26, v34, v35, &v36, v25);
  *(_QWORD *)a1 = v26;
  *(_WORD *)(a1 + 8) = v25;
  v27 = v39;
  v28 = sub_B46F0;
  while ( v27 )
  {
    v11 = v27 & 1;
    v27 >>= 1;
    if ( v11 )
    {
      v39 = v27;
      v38 = v28;
      LOWORD(v26) = *(_WORD *)(a1 + 8);
      v29 = (_DWORD)v26 << 16;
      LOWORD(v29) = *((_WORD *)v28 + 4);
      v30 = v29;
      v26 = *(_QWORD *)v28;
      LODWORD(v26) = sub_B37DA(*(_QWORD *)v28, *(_DWORD *)(a1 + 4), *(_DWORD *)a1, v30);
      *(_QWORD *)a1 = v26;
      *(_WORD *)(a1 + 8) = v30;
      v28 = v38;
      v27 = v39;
    }
    v28 = (int (*)())((char *)v28 + 10);
  }
  v31 = v40;
  *(_WORD *)(a1 + 8) += v40;
  return sub_B33A6(a1, v31, 0, 0x80000000, 49151);
}
// B46F0: using guessed type int sub_B46F0();

//----- (000B48EC) --------------------------------------------------------
int __fastcall sub_B48EC(unsigned __int64 a1)
{
  __int16 v1; // cx
  unsigned int v2; // ebx
  unsigned __int16 v3; // cx
  __int16 v4; // cx
  int v5; // edi
  __int16 v6; // cx
  __int16 v7; // cx
  int v8; // et2
  unsigned int v9; // ecx
  unsigned int v10; // esi
  unsigned int v11; // eax
  unsigned int v12; // edx
  unsigned __int64 v13; // rt2
  unsigned int v14; // esi
  unsigned int v15; // esi
  unsigned int v16; // ecx
  unsigned int v17; // eax
  _BOOL1 v18; // cf
  int v19; // eax
  int v20; // et2
  bool v21; // ett
  _DWORD *v23; // [esp-10h] [ebp-18h]

  v1 = *(_WORD *)(a1 + 8);
  v2 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
    goto LABEL_7;
  if ( *(_DWORD *)(a1 + 4) )
  {
    if ( v1 == 0x7FFF )
      return a1;
LABEL_7:
    if ( (v1 & 0x7FFF) == 0x7FFF )
      goto LABEL_5;
    v18 = __CFADD__(v1, v1);
    v3 = 2 * v1;
    if ( v18 )
      goto LABEL_5;
    v4 = v3 >> 1;
    if ( v4 && !__CFADD__(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 4)) )
    {
LABEL_4:
      *(_WORD *)(a1 + 8) = -1;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = 0;
LABEL_5:
      *(_BYTE *)(a1 + 7) |= 0xC0u;
      return a1;
    }
    HIDWORD(a1) = *(_DWORD *)(a1 + 4);
    v5 = 0;
    v23 = (_DWORD *)a1;
    v6 = v4 - 0x3FFF;
    v18 = v6 & 1;
    v7 = v6 >> 1;
    if ( !v18 )
    {
      v18 = BYTE4(a1) & 1;
      HIDWORD(a1) >>= 1;
      v8 = v18 << 31;
      v18 = v2 & 1;
      v2 = (v2 >> 1) | v8;
      v5 = v18 << 31;
    }
    *(_WORD *)(a1 + 8) = v7 + 0x3FFF;
    v9 = HIDWORD(a1);
    LODWORD(a1) = v2;
    v10 = (HIDWORD(a1)++ >> 1) | 0x80000000;
    if ( HIDWORD(a1) )
    {
      --HIDWORD(a1);
      while ( 1 )
      {
        v13 = a1 % v10;
        v11 = a1 / v10;
        v12 = v13;
        v14 = v10 - 1;
        if ( v14 <= v11 )
          break;
        v10 = ((v11 + v14 + 1) >> 1) | (__CFADD__(v11, v14 + 1) << 31);
        a1 = __PAIR64__(v9, v2);
      }
      v15 = v14 + 1;
      v16 = v11;
      v17 = __PAIR64__(v12, v5) / v15;
      v10 = v16 + v15;
    }
    else
    {
      v18 = v2 < v10;
      if ( v2 == v10 )
      {
LABEL_21:
        *v23 = a1;
        v23[1] = v10 + v18;
        return a1;
      }
      v17 = __PAIR64__(v2, v5) / v10;
    }
    v18 = v10 & 1;
    v10 = (v10 >> 1) | 0x80000000;
    v20 = v18 << 31;
    v18 = v17 & 1;
    v19 = (v17 >> 1) | v20;
    v21 = v18;
    v18 = __CFADD__(v18, v19);
    LODWORD(a1) = v21 + v19;
    goto LABEL_21;
  }
  if ( 2 * v1 )
    goto LABEL_4;
  return a1;
}

//----- (000B49D8) --------------------------------------------------------
void __usercall sub_B49D8(int a1@<ecx>, int a2@<esi>)
{
  int v2; // edi
  unsigned __int64 v3; // rax
  int v4; // esi
  int v5; // esi
  int v6; // esi
  unsigned int vars0; // [esp+0h] [ebp+0h]
  unsigned int vars4; // [esp+4h] [ebp+4h]
  __int16 vars8; // [esp+8h] [ebp+8h]
  int varsC; // [esp+Ch] [ebp+Ch]

  v2 = a1;
  v3 = *(_QWORD *)a1;
  LOWORD(a2) = *(_WORD *)(a1 + 8);
  do
  {
    v4 = __ROL4__(a2, 16);
    LOWORD(v4) = vars8;
    v5 = __ROL4__(v4, 16);
    LODWORD(v3) = sub_B37DA(v3, vars4, vars0, v5);
    v2 += 10;
    v6 = __ROL4__(v5, 16);
    LOWORD(v6) = *(_WORD *)(v2 + 8);
    a2 = __ROL4__(v6, 16);
    LODWORD(v3) = sub_B33D6(v3, *(_DWORD *)(v2 + 4), *(_DWORD *)v2, a2);
    --varsC;
  }
  while ( varsC );
}
// B49F2: variable 'vars8' is possibly undefined
// B49FF: variable 'vars4' is possibly undefined
// B49FF: variable 'vars0' is possibly undefined
// B4A1E: variable 'varsC' is possibly undefined

//----- (000B4A2A) --------------------------------------------------------
int __usercall sub_B4A2A@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>)
{
  int v4; // esi
  int v5; // esi
  int v6; // esi
  unsigned __int64 v7; // rax

  v7 = *(_QWORD *)a1;
  LOWORD(a3) = *(_WORD *)(a1 + 8);
  v4 = a3 << 16;
  LOWORD(v4) = *(_WORD *)(a1 + 8);
  sub_B37DA(v7, *(_DWORD *)(a1 + 4), v7, v4);
  sub_B49D8(a2, v4);
  v5 = __ROL4__(v4, 16);
  LOWORD(v5) = *(_WORD *)(a1 + 8);
  v6 = __ROL4__(v5, 16);
  LODWORD(v7) = sub_B37DA(v7, *(_DWORD *)(a1 + 4), *(_DWORD *)a1, v6);
  *(_QWORD *)a1 = v7;
  *(_WORD *)(a1 + 8) = v6;
  return v7;
}
// B4A60: variable 'v7' is possibly undefined

//----- (000B4F46) --------------------------------------------------------
void __spoils<edx> sub_B4F46()
{
  if ( !word_E7C58 && byte_E3E28 )
  {
    if ( byte_E4CB2 )
    {
      if ( byte_E4CB2 == 1 )
      {
        _DOS4G_hook_init();
      }
      else if ( byte_E4CB2 == 9 )
      {
        _Intel_hook_init();
      }
      else
      {
        _Phar_hook_init();
      }
    }
    else
    {
      _Ergo_hook_init();
    }
    sub_B5000();
  }
}
// B56EA: using guessed type int _Phar_hook_init(void);
// B57DA: using guessed type int _DOS4G_hook_init(void);
// B5820: using guessed type int _Ergo_hook_init(void);
// B5878: using guessed type int _Intel_hook_init(void);
// E3E28: using guessed type char byte_E3E28;
// E4CB2: using guessed type char byte_E4CB2;
// E7C58: using guessed type __int16 word_E7C58;

//----- (000B4FA3) --------------------------------------------------------
void __spoils<edx> sub_B4FA3()
{
  if ( word_E7C58 )
  {
    if ( byte_E4CB2 )
    {
      if ( byte_E4CB2 == 1 )
      {
        _DOS4G_hook_fini();
      }
      else if ( byte_E4CB2 == 9 )
      {
        _Intel_hook_fini();
      }
      else
      {
        _Phar_hook_fini();
      }
    }
    else
    {
      _Ergo_hook_fini();
    }
  }
}
// B57AD: using guessed type int _Phar_hook_fini(void);
// B5807: using guessed type int _DOS4G_hook_fini(void);
// B585E: using guessed type int _Ergo_hook_fini(void);
// B58D0: using guessed type int _Intel_hook_fini(void);
// E4CB2: using guessed type char byte_E4CB2;
// E7C58: using guessed type __int16 word_E7C58;

//----- (000B5000) --------------------------------------------------------
void sub_B5000()
{
  ;
}

//----- (000B5015) --------------------------------------------------------
void __noreturn sub_B5015()
{
  __outbyte(0x20u, 0x20u);
  __outbyte(0xA0u, 0x20u);
  __outbyte(0xF0u, 0);
  sub_B5022();
}
// B5022: using guessed type void __noreturn sub_B5022(void);

//----- (000B5022) --------------------------------------------------------
void __noreturn sub_B5022()
{
  _DWORD v1[16]; // [esp-24h] [ebp-40h] BYREF

  v1[8] = (unsigned __int16)__DS__;
  v1[7] = (unsigned __int16)__ES__;
  _EBP = v1;
  __asm
  {
    fnstenv byte ptr [ebp+0]
    fclex
    fdisi
  }
  _enable();
  ((void (__noreturn *)(void))_GETDS)();
}

//----- (000B5128) --------------------------------------------------------
void __usercall sub_B5128(__int16 a1@<bx>, double *a2@<edi>, double a3@<st0>)
{
  _BOOL1 v3; // zf

  if ( a1 != -9734 && a1 != -9743 )
  {
    v3 = a1 == -9736;
    if ( a1 != -9736 )
      v3 = a1 == -9739;
    if ( !v3 && (a1 & 0x310) != 784 && (a1 & 0x110) == 272 )
    {
      __asm
      {
        fstp    st
        fldz
      }
      if ( (a1 & 0xC0) != 0xC0 )
        sub_B5250(a1, a2, a3);
      if ( (a1 & 8) != 0 )
        __asm { fstp    st }
    }
  }
}
// B516D: inconsistent fpu stack

//----- (000B51B3) --------------------------------------------------------
void __usercall sub_B51B3(__int16 a1@<bx>, int a2@<ebp>, double *a3@<edi>, __int16 a4@<fpstat>, double a5@<st0>)
{
  double v5; // st7

  if ( a1 != -9731 )
  {
    if ( (a1 & 0x110) == 272 )
    {
      v5 = sub_B5205(SHIBYTE(a1), a2, a4, a5);
      if ( (a1 & 0xC0) != 0xC0 )
        sub_B5250(a1, a3, v5);
      if ( (a1 & 8) != 0 )
        __asm { fstp    st }
    }
    else if ( (a1 & 0xC0) == 0xC0 )
    {
      sub_B522B(a1 & 0x1C0, a1, (int)&unk_E7C64);
    }
    else
    {
      sub_B5205(SHIBYTE(a1), a2, a4, a5);
    }
  }
}
// B51CB: inconsistent fpu stack

//----- (000B5205) --------------------------------------------------------
double __usercall sub_B5205@<st0>(char a1@<bh>, int a2@<ebp>, __int16 a3@<fpstat>, double a4@<st0>)
{
  _BOOL1 v4; // c0
  char v5; // c2
  _BOOL1 v6; // c3
  double result; // st7

  v4 = a4 < 0.0;
  v5 = 0;
  v6 = a4 == 0.0;
  *(_WORD *)(a2 + 20) = a3;
  if ( (a1 & 4) != 0 )
    result = dbl_E7C6E;
  else
    result = flt_E7C76;
  if ( (*(_WORD *)(a2 + 20) & 0x100) != 0 )
    return -result;
  return result;
}
// E7C6E: using guessed type double dbl_E7C6E;
// E7C76: using guessed type float flt_E7C76;

//----- (000B522B) --------------------------------------------------------
__int64 __usercall sub_B522B@<edx:eax>(int a1@<edx>, __int16 a2@<bx>, int _ESI@<esi>)
{
  _BOOL1 v3; // cc
  __int64 result; // rax
  int v5; // [esp-4h] [ebp-4h]

  if ( (a2 & 0x400) != 0 )
    LOBYTE(a1) = a2 & 7;
  else
    LOBYTE(a1) = 0;
  v5 = a1;
  while ( 1 )
  {
    v3 = (char)a1 < 1;
    LOBYTE(a1) = a1 - 1;
    if ( v3 )
      break;
    __asm { fincstp }
  }
  __asm
  {
    fstp    st
    fld     tbyte ptr [esi]
  }
  HIDWORD(result) = v5;
  while ( 1 )
  {
    v3 = BYTE4(result)-- < 1;
    if ( v3 )
      break;
    __asm { fdecstp }
  }
  return result;
}
// B523E: inconsistent fpu stack

//----- (000B5250) --------------------------------------------------------
double __usercall sub_B5250@<st0>(char a1@<bl>, double *a2@<edi>, double result@<st0>)
{
  if ( (a1 & 4) != 0 )
    *a2 = result;
  else
    *(float *)a2 = result;
  return result;
}

//----- (000B5C5B) --------------------------------------------------------
int sub_B5C5B()
{
  return 0;
}

//----- (000B5C60) --------------------------------------------------------
int __cdecl sub_B5C60(__int16 a1, __int16 a2)
{
  int v2; // ebx
  int v3; // edx
  int v4; // eax
  int v5; // esi
  int v6; // esi
  int v8; // esi
  int v9; // eax
  int v10; // esi
  int v11; // esi
  int v12; // edi

  v2 = HIBYTE(a1);
  BYTE1(v2) = HIBYTE(a2);
  v3 = (unsigned __int8)a2;
  if ( ((HIBYTE(a1) + HIBYTE(a2)) & 1) != 0 )
  {
    if ( __CFADD__((_BYTE)a2, (_BYTE)a1) )
    {
      BYTE1(v2) = HIBYTE(a2) + 1;
      v4 = (unsigned __int8)byte_11B4E0[v2];
      LOBYTE(v2) = v2 + 1;
      v8 = (unsigned __int8)byte_11B4E0[v2];
      LOBYTE(v3) = ~(_BYTE)a2;
      BYTE1(v2) = HIBYTE(a2);
      v6 = v3 * ((unsigned __int8)byte_11B4E0[v2] - v8) + (unsigned __int8)a1 * (v8 - v4);
    }
    else
    {
      v4 = (unsigned __int8)byte_11B4E0[v2];
      LOBYTE(v2) = v2 + 1;
      v5 = (unsigned __int8)a1 * ((unsigned __int8)byte_11B4E0[v2] - v4);
      LOBYTE(v2) = v2 - 1;
      BYTE1(v2) = HIBYTE(a2) + 1;
      v6 = (unsigned __int8)a2 * ((unsigned __int8)byte_11B4E0[v2] - v4) + v5;
    }
    return (v6 >> 3) + 32 * v4;
  }
  else
  {
    v9 = (unsigned __int8)byte_11B4E0[v2];
    if ( (unsigned __int8)a1 <= (unsigned __int8)a2 )
    {
      BYTE1(v2) = HIBYTE(a2) + 1;
      v12 = (unsigned __int8)byte_11B4E0[v2];
      LOBYTE(v2) = v2 + 1;
      v11 = (unsigned __int8)a2 * (v12 - v9) + (unsigned __int8)a1 * ((unsigned __int8)byte_11B4E0[v2] - v12);
    }
    else
    {
      LOBYTE(v2) = v2 + 1;
      v10 = (unsigned __int8)byte_11B4E0[v2];
      BYTE1(v2) = HIBYTE(a2) + 1;
      v11 = (unsigned __int8)a2 * ((unsigned __int8)byte_11B4E0[v2] - v10) + (unsigned __int8)a1 * (v10 - v9);
    }
    return (v11 >> 3) + 32 * v9;
  }
}

//----- (000B5D68) --------------------------------------------------------
int __cdecl sub_B5D68(__int16 a1, __int16 a2)
{
  int v2; // ebx
  int v3; // edx
  int v4; // eax
  int v5; // esi
  int v6; // esi
  int v8; // esi
  int v9; // eax
  int v10; // esi
  int v11; // esi
  int v12; // edi

  v2 = HIBYTE(a1);
  BYTE1(v2) = HIBYTE(a2);
  v3 = (unsigned __int8)a2;
  if ( ((HIBYTE(a1) + HIBYTE(a2)) & 1) != 0 )
  {
    if ( __CFADD__((_BYTE)a2, (_BYTE)a1) )
    {
      BYTE1(v2) = HIBYTE(a2) + 1;
      v4 = (unsigned __int8)byte_14B4E0[v2];
      LOBYTE(v2) = v2 + 1;
      v8 = (unsigned __int8)byte_14B4E0[v2];
      LOBYTE(v3) = ~(_BYTE)a2;
      BYTE1(v2) = HIBYTE(a2);
      v6 = v3 * ((unsigned __int8)byte_14B4E0[v2] - v8) + (unsigned __int8)a1 * (v8 - v4);
    }
    else
    {
      v4 = (unsigned __int8)byte_14B4E0[v2];
      LOBYTE(v2) = v2 + 1;
      v5 = (unsigned __int8)a1 * ((unsigned __int8)byte_14B4E0[v2] - v4);
      LOBYTE(v2) = v2 - 1;
      BYTE1(v2) = HIBYTE(a2) + 1;
      v6 = (unsigned __int8)a2 * ((unsigned __int8)byte_14B4E0[v2] - v4) + v5;
    }
    return (v6 >> 3) + 32 * v4;
  }
  else
  {
    v9 = (unsigned __int8)byte_14B4E0[v2];
    if ( (unsigned __int8)a1 <= (unsigned __int8)a2 )
    {
      BYTE1(v2) = HIBYTE(a2) + 1;
      v12 = (unsigned __int8)byte_14B4E0[v2];
      LOBYTE(v2) = v2 + 1;
      v11 = (unsigned __int8)a2 * (v12 - v9) + (unsigned __int8)a1 * ((unsigned __int8)byte_14B4E0[v2] - v12);
    }
    else
    {
      LOBYTE(v2) = v2 + 1;
      v10 = (unsigned __int8)byte_14B4E0[v2];
      BYTE1(v2) = HIBYTE(a2) + 1;
      v11 = (unsigned __int8)a2 * ((unsigned __int8)byte_14B4E0[v2] - v10) + (unsigned __int8)a1 * (v10 - v9);
    }
    return (v11 >> 3) + 32 * v9;
  }
}

//----- (000B5E70) --------------------------------------------------------
void __cdecl __spoils<> sub_B5E70(__int16 a1, unsigned __int16 a2, __int16 a3)
{
  int v3; // ebx
  __int16 v4; // cx
  char v6; // [esp+1h] [ebp-3h]
  char v7; // [esp+1h] [ebp-3h]
  char v8; // [esp+2h] [ebp-2h]
  char v9; // [esp+2h] [ebp-2h]
  char v10; // [esp+3h] [ebp-1h]
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  word_15B4E0[a2] = a3;
  v10 = 7;
  do
  {
    v3 = a2;
    v4 = (unsigned __int8)(1 << v10);
    v6 = 1 << (7 - v10);
    do
    {
      v8 = 1 << (7 - v10);
      do
      {
        sub_B5EFA(v4, v3, (int)&savedregs, a1);
        --v8;
      }
      while ( v8 );
      BYTE1(v3) += v4 + v4;
      --v6;
    }
    while ( v6 );
    v7 = 1 << (7 - v10);
    do
    {
      v9 = 1 << (7 - v10);
      do
      {
        sub_B5F8F(v4, v3, (int)&savedregs, a1);
        --v9;
      }
      while ( v9 );
      BYTE1(v3) += v4 + v4;
      --v7;
    }
    while ( v7 );
  }
  while ( v10-- >= 1 );
}
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (000B5EFA) --------------------------------------------------------
__int16 __usercall sub_B5EFA@<ax>(__int16 a1@<cx>, int a2@<ebx>, int a3@<ebp>, __int16 a4@<si>)
{
  __int16 v4; // di
  __int16 v5; // di
  __int16 v6; // di
  __int16 v7; // di
  __int16 v8; // di
  __int16 result; // ax

  v4 = word_15B4E0[a2];
  LOBYTE(a2) = a1 + a1 + a2;
  v5 = word_15B4E0[a2] + v4;
  BYTE1(a2) += a1 + a1;
  v6 = word_15B4E0[a2] + v5;
  LOBYTE(a2) = a2 - a1 - a1;
  v7 = word_15B4E0[a2] + v6;
  LOBYTE(a2) = a1 + a2;
  BYTE1(a2) -= a1;
  v8 = (unsigned __int16)(9377 * a4 + 9439) % (unsigned __int16)(2 * *(_WORD *)(a3 + 20) + 1)
     + (unsigned __int16)(9377 * a4 + 9439) % (unsigned __int16)((a1 << 6) + 1)
     + (v7 >> 2)
     - 32 * a1
     - *(_WORD *)(a3 + 20);
  result = v8;
  if ( !word_15B4E0[a2] )
    word_15B4E0[a2] = v8;
  return result;
}
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (000B5F8F) --------------------------------------------------------
__int16 __usercall sub_B5F8F@<ax>(__int16 a1@<cx>, int a2@<ebx>, int a3@<ebp>, __int16 a4@<si>)
{
  __int16 v4; // di
  __int16 v5; // di
  unsigned __int16 v6; // si
  __int16 v7; // ax
  __int16 v8; // di
  __int16 v9; // di
  __int16 v10; // di
  __int16 v11; // di
  __int16 result; // ax
  __int16 v13; // [esp-2h] [ebp-2h]

  v13 = word_15B4E0[a2];
  LOBYTE(a2) = a1 + a2;
  BYTE1(a2) -= a1;
  v4 = word_15B4E0[a2] + v13;
  LOBYTE(a2) = a1 + a2;
  BYTE1(a2) += a1;
  v5 = word_15B4E0[a2] + v4;
  LOBYTE(a2) = a2 - a1;
  BYTE1(a2) += a1;
  v6 = 9377 * a4 + 9439;
  v7 = v6 % (unsigned __int16)(2 * *(_WORD *)(a3 + 20) + 1)
     + v6 % (unsigned __int16)((a1 << 6) + 1)
     + ((__int16)(word_15B4E0[a2] + v5) >> 2)
     - 32 * a1
     - *(_WORD *)(a3 + 20);
  v8 = word_15B4E0[a2];
  BYTE1(a2) -= a1;
  if ( !word_15B4E0[a2] )
    word_15B4E0[a2] = v7;
  LOBYTE(a2) = a2 - a1 - a1;
  BYTE1(a2) += a1;
  v9 = word_15B4E0[a2] + v13 + v8;
  LOBYTE(a2) = a1 + a2;
  BYTE1(a2) += a1;
  v10 = word_15B4E0[a2] + v9;
  BYTE1(a2) -= a1;
  v11 = (unsigned __int16)(9377 * v6 + 9439) % (unsigned __int16)(2 * *(_WORD *)(a3 + 20) + 1)
      + (unsigned __int16)(9377 * v6 + 9439) % (unsigned __int16)((a1 << 6) + 1)
      + (v10 >> 2)
      - 32 * a1
      - *(_WORD *)(a3 + 20);
  result = v11;
  if ( !word_15B4E0[a2] )
    word_15B4E0[a2] = v11;
  return result;
}
// 15B4E0: using guessed type __int16 word_15B4E0[9616];

//----- (000B6253) --------------------------------------------------------
void __cdecl __spoils<> sub_B6253(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // esi
  _DWORD *v4; // edi
  _DWORD *v5; // ecx
  int v6; // eax
  int v7; // ebx
  int v8; // edx
  int v9; // eax
  int v10; // ebx
  int v11; // ebx
  int v12; // ebx
  int v13; // eax
  int v14; // ebx
  _BOOL1 v15; // zf
  char v16; // cc
  int v17; // ebx
  int v18; // ebx
  int v19; // eax
  int v20; // ebx
  int v21; // ecx
  int v22; // edx
  int v23; // esi
  int v24; // ebx
  _DWORD *v25; // edi
  int v26; // edi
  _BOOL1 v27; // of
  int v28; // edi
  unsigned int v29; // eax
  int v30; // eax
  int v31; // ebx
  _BOOL1 v32; // zf
  int v33; // ebx
  int v34; // ebx
  int v35; // eax
  int v36; // ebx
  int v37; // ecx
  int v38; // edx
  int v39; // ebx
  _DWORD *v40; // edi
  int v41; // edi
  int v42; // edi
  int v43; // eax
  int v44; // ebx
  _BOOL1 v45; // zf
  int v46; // ebx
  int v47; // eax
  int v48; // ebx
  int v49; // esi
  int v50; // ebx
  _DWORD *v51; // edi
  int v52; // edi
  int v53; // edi
  int v54; // eax
  int v55; // ebx
  int v56; // ebx
  _DWORD *v57; // edi
  int v58; // edi
  int v59; // edi
  int v60; // eax
  int v61; // ebx
  int v62; // ebx
  int v63; // ebx
  int v64; // eax
  int v65; // ebx
  _BOOL1 v66; // zf
  int v67; // ebx
  int v68; // ebx
  int v69; // eax
  int v70; // ebx
  int v71; // ecx
  int v72; // edx
  int v73; // esi
  int v74; // eax
  _DWORD *v75; // edi
  int v76; // edi
  int v77; // edi
  int v78; // eax
  int v79; // ebx
  _BOOL1 v80; // zf
  int v81; // ebx
  int v82; // ebx
  int v83; // eax
  int v84; // ebx
  int v85; // ecx
  int v86; // edx
  int v87; // eax
  _DWORD *v88; // edi
  int v89; // edi
  int v90; // edi
  int v91; // eax
  int v92; // ebx
  _BOOL1 v93; // zf
  int v94; // ebx
  int v95; // eax
  int v96; // ebx
  int v97; // esi
  int v98; // eax
  _DWORD *v99; // edi
  int v100; // edi
  int v101; // edi
  int v102; // eax
  int v103; // ebx
  int v104; // eax
  _DWORD *v105; // edi
  int v106; // edi
  int v107; // edi
  int v108; // eax
  int v109; // ebx
  int v110; // ebx
  int v111; // eax
  int v112; // ebx
  int v113; // ecx
  int v114; // edx
  int v115; // esi
  int v116; // edi
  _DWORD *v117; // edi
  int v118; // ebx
  int v119; // eax
  int v120; // ebx
  int v121; // ecx
  int v122; // edx
  int v123; // edi
  _DWORD *v124; // edi
  int v125; // eax
  int v126; // ebx
  int v127; // esi
  int v128; // edi
  _DWORD *v129; // edi
  int v130; // eax
  int v131; // ebx
  int v132; // edi
  _DWORD *v133; // edi
  int v134; // eax
  int v135; // ebx
  int v136; // ebx
  int v137; // eax
  int v138; // ebx
  int v139; // ecx
  int v140; // edx
  int v141; // esi
  int v142; // edi
  _DWORD *v143; // edi
  int v144; // ebx
  int v145; // eax
  int v146; // ebx
  int v147; // ecx
  int v148; // edx
  int v149; // edi
  _DWORD *v150; // edi
  int v151; // eax
  int v152; // ebx
  int v153; // esi
  int v154; // edi
  _DWORD *v155; // edi
  int v156; // eax
  int v157; // ebx
  int v158; // edi
  _DWORD *v159; // edi
  unsigned __int16 *v160; // esi
  char *v161; // edx
  char v162; // al
  int v163; // ebx
  signed int v164; // ecx
  char *v165; // edi
  _WORD *i; // esi
  int v167; // ecx
  _BYTE *v168; // edi
  unsigned int v169; // eax
  __int16 v170; // bx
  _BOOL1 v171; // cf
  __int16 v172; // bx
  __int16 v173; // bx
  char v174; // ah
  __int16 v175; // cx
  __int16 v176; // bx
  char v177; // ah
  __int16 v178; // cx
  __int16 v179; // bx
  char v180; // ah
  __int16 v181; // cx
  __int16 v182; // bx
  char v183; // ah
  __int16 v184; // cx
  __int16 v185; // bx
  char v186; // ah
  __int16 v187; // cx
  __int16 v188; // bx
  char v189; // ah
  __int16 v190; // cx
  __int16 v191; // bx
  char v192; // ah
  __int16 v193; // cx
  __int16 v194; // bx
  char v195; // ah
  __int16 v196; // cx
  __int16 v197; // bx
  char v198; // ah
  __int16 v199; // cx
  __int16 v200; // bx
  char v201; // ah
  __int16 v202; // cx
  __int16 v203; // bx
  char v204; // ah
  __int16 v205; // cx
  __int16 v206; // bx
  char v207; // ah
  __int16 v208; // cx
  __int16 v209; // bx
  char v210; // ah
  __int16 v211; // cx
  __int16 v212; // bx
  char v213; // ah
  __int16 v214; // cx
  __int16 v215; // bx
  char v216; // ah
  __int16 v217; // cx
  unsigned __int16 *v218; // esi
  int v219; // eax
  int v220; // ebx
  int v221; // ecx
  _BYTE *v222; // edi
  int v223; // eax
  unsigned int v224; // eax
  int v225; // edx
  unsigned int v226; // eax
  int v227; // esi
  char v228; // al
  int v229; // edx
  __int16 v230; // cx
  char v231; // al
  int v232; // edx
  __int16 v233; // cx
  char v234; // al
  int v235; // edx
  __int16 v236; // cx
  char v237; // al
  int v238; // edx
  __int16 v239; // cx
  char v240; // al
  int v241; // edx
  __int16 v242; // cx
  char v243; // al
  int v244; // edx
  __int16 v245; // cx
  char v246; // al
  int v247; // edx
  __int16 v248; // cx
  char v249; // al
  int v250; // edx
  __int16 v251; // cx
  char v252; // al
  int v253; // edx
  __int16 v254; // cx
  char v255; // al
  int v256; // edx
  __int16 v257; // cx
  char v258; // al
  int v259; // edx
  __int16 v260; // cx
  char v261; // al
  int v262; // edx
  __int16 v263; // cx
  char v264; // al
  int v265; // edx
  __int16 v266; // cx
  char v267; // al
  int v268; // edx
  __int16 v269; // cx
  char v270; // al
  int v271; // edx
  __int16 v272; // cx
  char v273; // al
  unsigned __int16 *v274; // esi
  int v275; // eax
  int v276; // ebx
  int v277; // ecx
  _BYTE *v278; // edi
  int v279; // eax
  unsigned int v280; // eax
  int v281; // edx
  unsigned int v282; // eax
  int v283; // esi
  char v284; // al
  int v285; // edx
  __int16 v286; // cx
  char v287; // al
  int v288; // edx
  __int16 v289; // cx
  char v290; // al
  int v291; // edx
  __int16 v292; // cx
  char v293; // al
  int v294; // edx
  __int16 v295; // cx
  char v296; // al
  int v297; // edx
  __int16 v298; // cx
  char v299; // al
  int v300; // edx
  __int16 v301; // cx
  char v302; // al
  int v303; // edx
  __int16 v304; // cx
  char v305; // al
  int v306; // edx
  __int16 v307; // cx
  char v308; // al
  int v309; // edx
  __int16 v310; // cx
  char v311; // al
  int v312; // edx
  __int16 v313; // cx
  char v314; // al
  int v315; // edx
  __int16 v316; // cx
  char v317; // al
  int v318; // edx
  __int16 v319; // cx
  char v320; // al
  int v321; // edx
  __int16 v322; // cx
  char v323; // al
  int v324; // edx
  __int16 v325; // cx
  char v326; // al
  int v327; // edx
  __int16 v328; // cx
  char v329; // al
  _WORD *j; // esi
  int v331; // ecx
  _BYTE *v332; // edi
  unsigned int v333; // eax
  __int16 v334; // bx
  __int16 v335; // bx
  __int16 v336; // bx
  __int16 v337; // cx
  __int16 v338; // bx
  __int16 v339; // cx
  __int16 v340; // bx
  __int16 v341; // cx
  __int16 v342; // bx
  __int16 v343; // cx
  __int16 v344; // bx
  __int16 v345; // cx
  __int16 v346; // bx
  __int16 v347; // cx
  __int16 v348; // bx
  __int16 v349; // cx
  __int16 v350; // bx
  __int16 v351; // cx
  __int16 v352; // bx
  __int16 v353; // cx
  __int16 v354; // bx
  __int16 v355; // cx
  __int16 v356; // bx
  __int16 v357; // cx
  __int16 v358; // bx
  __int16 v359; // cx
  __int16 v360; // bx
  __int16 v361; // cx
  __int16 v362; // bx
  __int16 v363; // cx
  __int16 v364; // bx
  __int16 v365; // cx
  unsigned int v366; // eax
  int v367; // ebx
  char *v368; // esi
  int v369; // ecx
  int v370; // edi
  int v371; // ecx
  int v372; // edx
  int v373; // ecx
  __int16 v374; // cx
  __int16 v375; // bp
  _BYTE *v376; // edi
  int v377; // ebp
  unsigned int v378; // eax
  int v379; // ebx
  char *v380; // esi
  int v381; // ecx
  int v382; // edi
  int v383; // ecx
  int v384; // edx
  int v385; // ecx
  __int16 v386; // cx
  __int16 v387; // bp
  _BYTE *v388; // edi
  int v389; // ebp
  unsigned __int16 *v390; // esi
  int v391; // eax
  int v392; // ebx
  int v393; // ecx
  _BYTE *v394; // edi
  int v395; // eax
  unsigned int v396; // eax
  int v397; // edx
  unsigned int v398; // eax
  int v399; // esi
  int v400; // edx
  __int16 v401; // cx
  int v402; // edx
  __int16 v403; // cx
  int v404; // edx
  __int16 v405; // cx
  int v406; // edx
  __int16 v407; // cx
  int v408; // edx
  __int16 v409; // cx
  int v410; // edx
  __int16 v411; // cx
  int v412; // edx
  __int16 v413; // cx
  int v414; // edx
  __int16 v415; // cx
  int v416; // edx
  __int16 v417; // cx
  int v418; // edx
  __int16 v419; // cx
  int v420; // edx
  __int16 v421; // cx
  int v422; // edx
  __int16 v423; // cx
  int v424; // edx
  __int16 v425; // cx
  int v426; // edx
  __int16 v427; // cx
  int v428; // edx
  __int16 v429; // cx
  unsigned __int16 *v430; // esi
  int v431; // eax
  int v432; // ebx
  int v433; // ecx
  _BYTE *v434; // edi
  int v435; // eax
  unsigned int v436; // eax
  int v437; // edx
  unsigned int v438; // eax
  int v439; // esi
  int v440; // edx
  __int16 v441; // cx
  int v442; // edx
  __int16 v443; // cx
  int v444; // edx
  __int16 v445; // cx
  int v446; // edx
  __int16 v447; // cx
  int v448; // edx
  __int16 v449; // cx
  int v450; // edx
  __int16 v451; // cx
  int v452; // edx
  __int16 v453; // cx
  int v454; // edx
  __int16 v455; // cx
  int v456; // edx
  __int16 v457; // cx
  int v458; // edx
  __int16 v459; // cx
  int v460; // edx
  __int16 v461; // cx
  int v462; // edx
  __int16 v463; // cx
  int v464; // edx
  __int16 v465; // cx
  int v466; // edx
  __int16 v467; // cx
  int v468; // edx
  __int16 v469; // cx
  unsigned __int16 *v470; // esi
  int v471; // eax
  int v472; // ebx
  int v473; // ecx
  _BYTE *v474; // edi
  int v475; // eax
  unsigned int v476; // eax
  int v477; // edx
  unsigned int v478; // eax
  int v479; // esi
  int v480; // edx
  __int16 v481; // cx
  int v482; // edx
  __int16 v483; // cx
  int v484; // edx
  __int16 v485; // cx
  int v486; // edx
  __int16 v487; // cx
  int v488; // edx
  __int16 v489; // cx
  int v490; // edx
  __int16 v491; // cx
  int v492; // edx
  __int16 v493; // cx
  int v494; // edx
  __int16 v495; // cx
  int v496; // edx
  __int16 v497; // cx
  int v498; // edx
  __int16 v499; // cx
  int v500; // edx
  __int16 v501; // cx
  int v502; // edx
  __int16 v503; // cx
  int v504; // edx
  __int16 v505; // cx
  int v506; // edx
  __int16 v507; // cx
  int v508; // edx
  __int16 v509; // cx
  unsigned __int16 *v510; // esi
  int v511; // eax
  int v512; // ebx
  int v513; // ecx
  _BYTE *v514; // edi
  int v515; // eax
  unsigned int v516; // eax
  int v517; // edx
  unsigned int v518; // eax
  int v519; // esi
  int v520; // edx
  __int16 v521; // cx
  int v522; // edx
  __int16 v523; // cx
  int v524; // edx
  __int16 v525; // cx
  int v526; // edx
  __int16 v527; // cx
  int v528; // edx
  __int16 v529; // cx
  int v530; // edx
  __int16 v531; // cx
  int v532; // edx
  __int16 v533; // cx
  int v534; // edx
  __int16 v535; // cx
  int v536; // edx
  __int16 v537; // cx
  int v538; // edx
  __int16 v539; // cx
  int v540; // edx
  __int16 v541; // cx
  int v542; // edx
  __int16 v543; // cx
  int v544; // edx
  __int16 v545; // cx
  int v546; // edx
  __int16 v547; // cx
  int v548; // edx
  __int16 v549; // cx
  unsigned __int16 *v550; // esi
  int v551; // eax
  int v552; // ebx
  int v553; // ecx
  _BYTE *v554; // edi
  int v555; // eax
  unsigned int v556; // eax
  int v557; // edx
  unsigned int v558; // eax
  int v559; // esi
  int v560; // edx
  __int16 v561; // cx
  int v562; // edx
  __int16 v563; // cx
  int v564; // edx
  __int16 v565; // cx
  int v566; // edx
  __int16 v567; // cx
  int v568; // edx
  __int16 v569; // cx
  int v570; // edx
  __int16 v571; // cx
  int v572; // edx
  __int16 v573; // cx
  int v574; // edx
  __int16 v575; // cx
  int v576; // edx
  __int16 v577; // cx
  int v578; // edx
  __int16 v579; // cx
  int v580; // edx
  __int16 v581; // cx
  int v582; // edx
  __int16 v583; // cx
  int v584; // edx
  __int16 v585; // cx
  int v586; // edx
  __int16 v587; // cx
  int v588; // edx
  __int16 v589; // cx
  unsigned __int16 *v590; // esi
  _BYTE *v591; // edx
  int v592; // eax
  int v593; // ebx
  int v594; // ecx
  _BYTE *k; // edi
  __int16 v596; // cx
  __int16 v597; // cx
  __int16 v598; // cx
  __int16 v599; // cx
  __int16 v600; // cx
  __int16 v601; // cx
  __int16 v602; // cx
  __int16 v603; // cx
  __int16 v604; // cx
  __int16 v605; // cx
  __int16 v606; // cx
  __int16 v607; // cx
  __int16 v608; // cx
  __int16 v609; // cx
  __int16 v610; // cx
  unsigned __int16 *v611; // esi
  _BYTE *v612; // edx
  int v613; // eax
  int v614; // ebx
  int v615; // ecx
  _BYTE *m; // edi
  __int16 v617; // cx
  __int16 v618; // cx
  __int16 v619; // cx
  __int16 v620; // cx
  __int16 v621; // cx
  __int16 v622; // cx
  __int16 v623; // cx
  __int16 v624; // cx
  __int16 v625; // cx
  __int16 v626; // cx
  __int16 v627; // cx
  __int16 v628; // cx
  __int16 v629; // cx
  __int16 v630; // cx
  __int16 v631; // cx
  unsigned __int16 *v632; // esi
  int v633; // edx
  int v634; // ecx
  _BYTE *v635; // edi
  unsigned int v636; // eax
  __int16 v637; // bx
  unsigned __int16 v638; // bx
  __int16 v639; // bx
  __int16 v640; // cx
  __int16 v641; // bx
  __int16 v642; // cx
  __int16 v643; // bx
  __int16 v644; // cx
  __int16 v645; // bx
  __int16 v646; // cx
  __int16 v647; // bx
  __int16 v648; // cx
  __int16 v649; // bx
  __int16 v650; // cx
  __int16 v651; // bx
  __int16 v652; // cx
  __int16 v653; // bx
  __int16 v654; // cx
  __int16 v655; // bx
  __int16 v656; // cx
  __int16 v657; // bx
  __int16 v658; // cx
  __int16 v659; // bx
  __int16 v660; // cx
  __int16 v661; // bx
  __int16 v662; // cx
  __int16 v663; // bx
  __int16 v664; // cx
  __int16 v665; // bx
  __int16 v666; // cx
  __int16 v667; // bx
  __int16 v668; // cx
  unsigned __int16 *v669; // esi
  int v670; // edx
  int v671; // ecx
  _BYTE *v672; // edi
  unsigned int v673; // eax
  __int16 v674; // bx
  unsigned __int16 v675; // bx
  __int16 v676; // bx
  __int16 v677; // cx
  __int16 v678; // bx
  __int16 v679; // cx
  __int16 v680; // bx
  __int16 v681; // cx
  __int16 v682; // bx
  __int16 v683; // cx
  __int16 v684; // bx
  __int16 v685; // cx
  __int16 v686; // bx
  __int16 v687; // cx
  __int16 v688; // bx
  __int16 v689; // cx
  __int16 v690; // bx
  __int16 v691; // cx
  __int16 v692; // bx
  __int16 v693; // cx
  __int16 v694; // bx
  __int16 v695; // cx
  __int16 v696; // bx
  __int16 v697; // cx
  __int16 v698; // bx
  __int16 v699; // cx
  __int16 v700; // bx
  __int16 v701; // cx
  __int16 v702; // bx
  __int16 v703; // cx
  __int16 v704; // bx
  __int16 v705; // cx
  unsigned __int16 *v706; // esi
  int v707; // eax
  int v708; // ebx
  int v709; // ecx
  _BYTE *v710; // edi
  int v711; // eax
  unsigned int v712; // eax
  int v713; // edx
  unsigned int v714; // eax
  int v715; // esi
  int v716; // edx
  __int16 v717; // cx
  int v718; // edx
  __int16 v719; // cx
  int v720; // edx
  __int16 v721; // cx
  int v722; // edx
  __int16 v723; // cx
  int v724; // edx
  __int16 v725; // cx
  int v726; // edx
  __int16 v727; // cx
  int v728; // edx
  __int16 v729; // cx
  int v730; // edx
  __int16 v731; // cx
  int v732; // edx
  __int16 v733; // cx
  int v734; // edx
  __int16 v735; // cx
  int v736; // edx
  __int16 v737; // cx
  int v738; // edx
  __int16 v739; // cx
  int v740; // edx
  __int16 v741; // cx
  int v742; // edx
  __int16 v743; // cx
  int v744; // edx
  __int16 v745; // cx
  unsigned __int16 *v746; // esi
  int v747; // eax
  int v748; // ebx
  int v749; // ecx
  _BYTE *v750; // edi
  int v751; // eax
  unsigned int v752; // eax
  int v753; // edx
  unsigned int v754; // eax
  int v755; // esi
  int v756; // edx
  __int16 v757; // cx
  int v758; // edx
  __int16 v759; // cx
  int v760; // edx
  __int16 v761; // cx
  int v762; // edx
  __int16 v763; // cx
  int v764; // edx
  __int16 v765; // cx
  int v766; // edx
  __int16 v767; // cx
  int v768; // edx
  __int16 v769; // cx
  int v770; // edx
  __int16 v771; // cx
  int v772; // edx
  __int16 v773; // cx
  int v774; // edx
  __int16 v775; // cx
  int v776; // edx
  __int16 v777; // cx
  int v778; // edx
  __int16 v779; // cx
  int v780; // edx
  __int16 v781; // cx
  int v782; // edx
  __int16 v783; // cx
  int v784; // edx
  __int16 v785; // cx
  unsigned __int16 *v786; // esi
  unsigned int v787; // eax
  int v788; // ebx
  int v789; // ecx
  _BYTE *v790; // edi
  int v791; // ecx
  int v792; // edx
  int v793; // ecx
  int v794; // esi
  int v795; // edx
  int v796; // ecx
  int v797; // edx
  int v798; // ecx
  int v799; // edx
  int v800; // ecx
  int v801; // edx
  int v802; // ecx
  int v803; // edx
  int v804; // ecx
  int v805; // edx
  int v806; // ecx
  int v807; // edx
  int v808; // ecx
  int v809; // edx
  int v810; // ecx
  int v811; // edx
  int v812; // ecx
  int v813; // edx
  int v814; // ecx
  int v815; // edx
  int v816; // ecx
  int v817; // edx
  int v818; // ecx
  int v819; // edx
  int v820; // ecx
  int v821; // edx
  int v822; // ecx
  int v823; // edx
  int v824; // ecx
  unsigned __int16 *v825; // esi
  unsigned int v826; // eax
  int v827; // ebx
  int v828; // ecx
  _BYTE *v829; // edi
  int v830; // ecx
  int v831; // edx
  int v832; // ecx
  int v833; // esi
  int v834; // edx
  int v835; // ecx
  int v836; // edx
  int v837; // ecx
  int v838; // edx
  int v839; // ecx
  int v840; // edx
  int v841; // ecx
  int v842; // edx
  int v843; // ecx
  int v844; // edx
  int v845; // ecx
  int v846; // edx
  int v847; // ecx
  int v848; // edx
  int v849; // ecx
  int v850; // edx
  int v851; // ecx
  int v852; // edx
  int v853; // ecx
  int v854; // edx
  int v855; // ecx
  int v856; // edx
  int v857; // ecx
  int v858; // edx
  int v859; // ecx
  int v860; // edx
  int v861; // ecx
  int v862; // edx
  int v863; // ecx
  unsigned __int16 *v864; // esi
  int v865; // eax
  int v866; // ebx
  int v867; // ecx
  _BYTE *v868; // edi
  int v869; // eax
  unsigned int v870; // eax
  int v871; // edx
  unsigned int v872; // eax
  int v873; // esi
  int v874; // edx
  __int16 v875; // cx
  int v876; // edx
  __int16 v877; // cx
  int v878; // edx
  __int16 v879; // cx
  int v880; // edx
  __int16 v881; // cx
  int v882; // edx
  __int16 v883; // cx
  int v884; // edx
  __int16 v885; // cx
  int v886; // edx
  __int16 v887; // cx
  int v888; // edx
  __int16 v889; // cx
  int v890; // edx
  __int16 v891; // cx
  int v892; // edx
  __int16 v893; // cx
  int v894; // edx
  __int16 v895; // cx
  int v896; // edx
  __int16 v897; // cx
  int v898; // edx
  __int16 v899; // cx
  int v900; // edx
  __int16 v901; // cx
  int v902; // edx
  __int16 v903; // cx
  unsigned __int16 *v904; // esi
  int v905; // eax
  int v906; // ebx
  int v907; // ecx
  _BYTE *v908; // edi
  int v909; // eax
  unsigned int v910; // eax
  int v911; // edx
  unsigned int v912; // eax
  int v913; // esi
  int v914; // edx
  __int16 v915; // cx
  int v916; // edx
  __int16 v917; // cx
  int v918; // edx
  __int16 v919; // cx
  int v920; // edx
  __int16 v921; // cx
  int v922; // edx
  __int16 v923; // cx
  int v924; // edx
  __int16 v925; // cx
  int v926; // edx
  __int16 v927; // cx
  int v928; // edx
  __int16 v929; // cx
  int v930; // edx
  __int16 v931; // cx
  int v932; // edx
  __int16 v933; // cx
  int v934; // edx
  __int16 v935; // cx
  int v936; // edx
  __int16 v937; // cx
  int v938; // edx
  __int16 v939; // cx
  int v940; // edx
  __int16 v941; // cx
  int v942; // edx
  __int16 v943; // cx
  unsigned __int16 *v944; // esi
  unsigned int v945; // eax
  int v946; // ebx
  int v947; // ecx
  _BYTE *v948; // edi
  int v949; // ecx
  int v950; // edx
  int v951; // ecx
  int v952; // esi
  int v953; // edx
  int v954; // ecx
  int v955; // edx
  int v956; // ecx
  int v957; // edx
  int v958; // ecx
  int v959; // edx
  int v960; // ecx
  int v961; // edx
  int v962; // ecx
  int v963; // edx
  int v964; // ecx
  int v965; // edx
  int v966; // ecx
  int v967; // edx
  int v968; // ecx
  int v969; // edx
  int v970; // ecx
  int v971; // edx
  int v972; // ecx
  int v973; // edx
  int v974; // ecx
  int v975; // edx
  int v976; // ecx
  int v977; // edx
  int v978; // ecx
  int v979; // edx
  int v980; // ecx
  int v981; // edx
  int v982; // ecx
  unsigned __int16 *v983; // esi
  unsigned int v984; // eax
  int v985; // ebx
  int v986; // ecx
  _BYTE *v987; // edi
  int v988; // ecx
  int v989; // edx
  int v990; // ecx
  int v991; // esi
  int v992; // edx
  int v993; // ecx
  int v994; // edx
  int v995; // ecx
  int v996; // edx
  int v997; // ecx
  int v998; // edx
  int v999; // ecx
  int v1000; // edx
  int v1001; // ecx
  int v1002; // edx
  int v1003; // ecx
  int v1004; // edx
  int v1005; // ecx
  int v1006; // edx
  int v1007; // ecx
  int v1008; // edx
  int v1009; // ecx
  int v1010; // edx
  int v1011; // ecx
  int v1012; // edx
  int v1013; // ecx
  int v1014; // edx
  int v1015; // ecx
  int v1016; // edx
  int v1017; // ecx
  int v1018; // edx
  int v1019; // ecx
  int v1020; // edx
  int v1021; // ecx
  unsigned __int16 *v1022; // esi
  unsigned int v1023; // eax
  int v1024; // ebx
  int v1025; // ecx
  char *v1026; // edi
  int v1027; // ecx
  int v1028; // edx
  int v1029; // ecx
  int v1030; // esi
  char v1031; // al
  int v1032; // edx
  int v1033; // ecx
  char v1034; // al
  int v1035; // edx
  int v1036; // ecx
  char v1037; // al
  int v1038; // edx
  int v1039; // ecx
  char v1040; // al
  int v1041; // edx
  int v1042; // ecx
  char v1043; // al
  int v1044; // edx
  int v1045; // ecx
  char v1046; // al
  int v1047; // edx
  int v1048; // ecx
  char v1049; // al
  int v1050; // edx
  int v1051; // ecx
  char v1052; // al
  int v1053; // edx
  int v1054; // ecx
  char v1055; // al
  int v1056; // edx
  int v1057; // ecx
  char v1058; // al
  int v1059; // edx
  int v1060; // ecx
  char v1061; // al
  int v1062; // edx
  int v1063; // ecx
  char v1064; // al
  int v1065; // edx
  int v1066; // ecx
  char v1067; // al
  int v1068; // edx
  int v1069; // ecx
  char v1070; // al
  int v1071; // edx
  int v1072; // ecx
  char v1073; // al
  int v1074; // edx
  int v1075; // ecx
  char v1076; // al
  int v1077; // [esp+0h] [ebp-88h]
  int v1078; // [esp+4h] [ebp-84h]
  int v1079; // [esp+4h] [ebp-84h]
  int v1080; // [esp+4h] [ebp-84h]
  int v1081; // [esp+4h] [ebp-84h]
  int v1082; // [esp+8h] [ebp-80h]
  int v1083; // [esp+8h] [ebp-80h]
  int v1084; // [esp+8h] [ebp-80h]
  int v1085; // [esp+8h] [ebp-80h]
  int v1086; // [esp+Ch] [ebp-7Ch]
  int v1087; // [esp+Ch] [ebp-7Ch]
  int v1088; // [esp+10h] [ebp-78h]
  int v1089; // [esp+10h] [ebp-78h]
  int v1090; // [esp+10h] [ebp-78h]
  int v1091; // [esp+10h] [ebp-78h]
  int v1092; // [esp+14h] [ebp-74h]
  int v1093; // [esp+14h] [ebp-74h]
  int v1094; // [esp+18h] [ebp-70h]
  int v1095; // [esp+18h] [ebp-70h]
  int v1096; // [esp+1Ch] [ebp-6Ch]
  int v1097; // [esp+1Ch] [ebp-6Ch]
  int v1098; // [esp+20h] [ebp-68h]
  int v1099; // [esp+24h] [ebp-64h]
  int v1100; // [esp+28h] [ebp-60h]
  int v1101; // [esp+28h] [ebp-60h]
  int v1102; // [esp+28h] [ebp-60h]
  int v1103; // [esp+28h] [ebp-60h]
  int v1104; // [esp+28h] [ebp-60h]
  int v1105; // [esp+28h] [ebp-60h]
  int v1106; // [esp+28h] [ebp-60h]
  int v1107; // [esp+28h] [ebp-60h]
  int v1108; // [esp+2Ch] [ebp-5Ch]
  int v1109; // [esp+2Ch] [ebp-5Ch]
  int v1110; // [esp+30h] [ebp-58h]
  int v1111; // [esp+34h] [ebp-54h]
  int v1112; // [esp+34h] [ebp-54h]
  int v1113; // [esp+34h] [ebp-54h]
  int v1114; // [esp+34h] [ebp-54h]
  int v1115; // [esp+34h] [ebp-54h]
  int v1116; // [esp+34h] [ebp-54h]
  int v1117; // [esp+34h] [ebp-54h]
  int v1118; // [esp+34h] [ebp-54h]
  int v1119; // [esp+38h] [ebp-50h]
  int v1120; // [esp+38h] [ebp-50h]
  int v1121; // [esp+3Ch] [ebp-4Ch]
  int v1122; // [esp+40h] [ebp-48h]
  int v1123; // [esp+40h] [ebp-48h]
  int v1124; // [esp+40h] [ebp-48h]
  int v1125; // [esp+40h] [ebp-48h]
  int v1126; // [esp+40h] [ebp-48h]
  int v1127; // [esp+40h] [ebp-48h]
  int v1128; // [esp+40h] [ebp-48h]
  int v1129; // [esp+40h] [ebp-48h]
  int v1130; // [esp+44h] [ebp-44h]
  int v1131; // [esp+44h] [ebp-44h]
  int v1132; // [esp+48h] [ebp-40h]
  int v1133; // [esp+48h] [ebp-40h]
  int v1134; // [esp+48h] [ebp-40h]
  int v1135; // [esp+48h] [ebp-40h]
  int v1136; // [esp+48h] [ebp-40h]
  int v1137; // [esp+48h] [ebp-40h]
  int v1138; // [esp+48h] [ebp-40h]
  int v1139; // [esp+48h] [ebp-40h]
  int v1140; // [esp+48h] [ebp-40h]
  int v1141; // [esp+48h] [ebp-40h]
  int v1142; // [esp+48h] [ebp-40h]
  int v1143; // [esp+48h] [ebp-40h]
  int v1144; // [esp+48h] [ebp-40h]
  int v1145; // [esp+48h] [ebp-40h]
  int v1146; // [esp+48h] [ebp-40h]
  int v1147; // [esp+48h] [ebp-40h]
  int v1148; // [esp+4Ch] [ebp-3Ch]
  int v1149; // [esp+4Ch] [ebp-3Ch]
  int v1150; // [esp+4Ch] [ebp-3Ch]
  int v1151; // [esp+4Ch] [ebp-3Ch]
  int v1152; // [esp+4Ch] [ebp-3Ch]
  int v1153; // [esp+4Ch] [ebp-3Ch]
  int v1154; // [esp+4Ch] [ebp-3Ch]
  int v1155; // [esp+4Ch] [ebp-3Ch]
  int v1156; // [esp+4Ch] [ebp-3Ch]
  int v1157; // [esp+4Ch] [ebp-3Ch]
  int v1158; // [esp+4Ch] [ebp-3Ch]
  int v1159; // [esp+4Ch] [ebp-3Ch]
  int v1160; // [esp+4Ch] [ebp-3Ch]
  int v1161; // [esp+4Ch] [ebp-3Ch]
  int v1162; // [esp+4Ch] [ebp-3Ch]
  int v1163; // [esp+4Ch] [ebp-3Ch]
  int v1164; // [esp+4Ch] [ebp-3Ch]
  int v1165; // [esp+4Ch] [ebp-3Ch]
  int v1166; // [esp+50h] [ebp-38h]
  int v1167; // [esp+50h] [ebp-38h]
  int v1168; // [esp+50h] [ebp-38h]
  int v1169; // [esp+50h] [ebp-38h]
  int v1170; // [esp+50h] [ebp-38h]
  int v1171; // [esp+50h] [ebp-38h]
  int v1172; // [esp+50h] [ebp-38h]
  int v1173; // [esp+54h] [ebp-34h]
  int v1174; // [esp+54h] [ebp-34h]
  int v1175; // [esp+54h] [ebp-34h]
  int v1176; // [esp+54h] [ebp-34h]
  int v1177; // [esp+58h] [ebp-30h]
  int v1178; // [esp+58h] [ebp-30h]
  int v1179; // [esp+58h] [ebp-30h]
  int v1180; // [esp+58h] [ebp-30h]
  int v1181; // [esp+58h] [ebp-30h]
  int v1182; // [esp+58h] [ebp-30h]
  int v1183; // [esp+58h] [ebp-30h]
  int v1184; // [esp+58h] [ebp-30h]
  int v1185; // [esp+58h] [ebp-30h]
  int v1186; // [esp+58h] [ebp-30h]
  int v1187; // [esp+58h] [ebp-30h]
  int v1188; // [esp+58h] [ebp-30h]
  int v1189; // [esp+58h] [ebp-30h]
  int v1190; // [esp+58h] [ebp-30h]
  int v1191; // [esp+58h] [ebp-30h]
  int v1192; // [esp+58h] [ebp-30h]
  int v1193; // [esp+58h] [ebp-30h]
  int v1194; // [esp+58h] [ebp-30h]
  int v1195; // [esp+58h] [ebp-30h]
  int v1196; // [esp+58h] [ebp-30h]
  int v1197; // [esp+58h] [ebp-30h]
  int v1198; // [esp+58h] [ebp-30h]
  int v1199; // [esp+58h] [ebp-30h]
  int v1200; // [esp+58h] [ebp-30h]
  int v1201; // [esp+58h] [ebp-30h]
  int v1202; // [esp+58h] [ebp-30h]
  int v1203; // [esp+58h] [ebp-30h]
  int v1204; // [esp+58h] [ebp-30h]
  int v1205; // [esp+58h] [ebp-30h]
  int v1206; // [esp+58h] [ebp-30h]
  int v1207; // [esp+58h] [ebp-30h]
  int v1208; // [esp+58h] [ebp-30h]
  int v1209; // [esp+58h] [ebp-30h]
  int v1210; // [esp+58h] [ebp-30h]
  int v1211; // [esp+58h] [ebp-30h]
  int v1212; // [esp+58h] [ebp-30h]
  int v1213; // [esp+58h] [ebp-30h]
  int v1214; // [esp+58h] [ebp-30h]
  int v1215; // [esp+58h] [ebp-30h]
  int v1216; // [esp+58h] [ebp-30h]
  int v1217; // [esp+58h] [ebp-30h]
  int v1218; // [esp+58h] [ebp-30h]
  int v1219; // [esp+58h] [ebp-30h]
  int v1220; // [esp+58h] [ebp-30h]
  int v1221; // [esp+58h] [ebp-30h]
  int v1222; // [esp+58h] [ebp-30h]
  int v1223; // [esp+58h] [ebp-30h]
  int v1224; // [esp+58h] [ebp-30h]
  int v1225; // [esp+58h] [ebp-30h]
  int v1226; // [esp+58h] [ebp-30h]
  int v1227; // [esp+58h] [ebp-30h]
  int v1228; // [esp+58h] [ebp-30h]
  int v1229; // [esp+58h] [ebp-30h]
  int v1230; // [esp+58h] [ebp-30h]
  int v1231; // [esp+58h] [ebp-30h]
  int v1232; // [esp+58h] [ebp-30h]
  int v1233; // [esp+58h] [ebp-30h]
  int v1234; // [esp+58h] [ebp-30h]
  int v1235; // [esp+58h] [ebp-30h]
  int v1236; // [esp+58h] [ebp-30h]
  int v1237; // [esp+58h] [ebp-30h]
  int v1238; // [esp+58h] [ebp-30h]
  int v1239; // [esp+58h] [ebp-30h]
  int v1240; // [esp+58h] [ebp-30h]
  int v1241; // [esp+58h] [ebp-30h]
  int v1242; // [esp+58h] [ebp-30h]
  int v1243; // [esp+58h] [ebp-30h]
  int v1244; // [esp+58h] [ebp-30h]
  int v1245; // [esp+58h] [ebp-30h]
  int v1246; // [esp+58h] [ebp-30h]
  int v1247; // [esp+58h] [ebp-30h]
  int v1248; // [esp+58h] [ebp-30h]
  int v1249; // [esp+58h] [ebp-30h]
  int v1250; // [esp+58h] [ebp-30h]
  int v1251; // [esp+58h] [ebp-30h]
  int v1252; // [esp+58h] [ebp-30h]
  int v1253; // [esp+58h] [ebp-30h]
  int v1254; // [esp+58h] [ebp-30h]
  int v1255; // [esp+58h] [ebp-30h]
  int v1256; // [esp+58h] [ebp-30h]
  unsigned __int16 *v1257; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1258; // [esp+5Ch] [ebp-2Ch]
  char *v1259; // [esp+5Ch] [ebp-2Ch]
  char *v1260; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1261; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1262; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1263; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1264; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1265; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1266; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1267; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1268; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1269; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1270; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1271; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1272; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1273; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 *v1274; // [esp+5Ch] [ebp-2Ch]
  char v1275; // [esp+62h] [ebp-26h]
  char v1276; // [esp+62h] [ebp-26h]
  char v1277; // [esp+62h] [ebp-26h]
  char v1278; // [esp+62h] [ebp-26h]
  char v1279; // [esp+63h] [ebp-25h]
  char v1280; // [esp+63h] [ebp-25h]
  _BOOL1 v1281; // [esp+63h] [ebp-25h]
  _BOOL1 v1282; // [esp+63h] [ebp-25h]
  _BOOL1 v1283; // [esp+64h] [ebp-24h]
  _BOOL1 v1284; // [esp+64h] [ebp-24h]

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = a1[1];
  v7 = a2[1];
  v8 = a3[1];
  if ( v6 == v7 )
  {
    if ( v6 == v8 )
      return;
    if ( v6 >= v8 )
    {
      if ( *a1 <= *a2 )
        return;
      v3 = a3;
      v4 = a1;
      v5 = a2;
      goto LABEL_225;
    }
    if ( *a2 <= *a1 )
      return;
    goto LABEL_268;
  }
  if ( v6 <= v7 )
  {
    if ( v6 != v8 )
    {
      if ( v6 >= v8 )
      {
        v3 = a3;
        v4 = a1;
        v5 = a2;
LABEL_24:
        v9 = v3[1];
        v1173 = v9;
        if ( v9 >= 0 )
        {
          if ( v9 >= dword_DE568 )
            return;
          v1077 = dword_DE554 + dword_DE560 * v9;
          v1275 = 0;
        }
        else
        {
          v1077 = dword_DE554;
          v1275 = 1;
        }
        v10 = v5[1];
        v1283 = v10 > dword_DE568;
        v1088 = v10 - v9;
        v1098 = v10 - v9;
        v11 = v4[1];
        v1279 = v11 > dword_DE568;
        v12 = v11 - v9;
        v1092 = v12;
        v1078 = ((*v5 - *v3) << 16) / v1088;
        if ( ((*v4 - *v3) << 16) / v12 > v1078 )
        {
          v1082 = ((*v4 - *v3) << 16) / v12;
          v1086 = ((*v5 - *v4) << 16) / (v5[1] - v4[1]);
          v1094 = v5[1] - v4[1];
          v1096 = *v4 << 16;
          switch ( byte_E126D )
          {
            case 0:
            case 14:
            case 15:
              v54 = *v3 << 16;
              v55 = v54;
              if ( !v1275 )
              {
                if ( v1283 )
                {
                  v58 = dword_DE568 - v1173;
                  v1098 = dword_DE568 - v1173;
                  if ( v1279 )
                  {
                    v1092 = dword_DE568 - v1173;
                  }
                  else
                  {
                    v27 = __OFSUB__(v58, v1092);
                    v59 = v58 - v1092;
                    v1279 = (v59 < 0) ^ v27 | (v59 == 0);
                    v1094 = v59;
                  }
                }
                goto LABEL_116;
              }
              v16 = v1098 <= -v1173;
              v1098 += v1173;
              if ( !v16 )
              {
                v1138 = -v1173;
                if ( -v1173 - v1092 >= 0 )
                {
                  v1094 -= v1138 - v1092;
                  v1139 = v1138 - v1092;
                  v54 += v1078 * v1139 + v1092 * v1078;
                  v56 = v1086 * v1139 + v1096;
                  if ( v1283 )
                  {
                    v1094 = dword_DE568;
                    v1098 = dword_DE568;
                  }
                  v57 = &unk_DE56C;
LABEL_119:
                  if ( v1279 )
                  {
                    v29 = (unsigned __int8)byte_E126D;
                    switch ( byte_E126D )
                    {
                      case 0:
                        goto LABEL_309;
                      case 1:
                        goto LABEL_322;
                      case 2:
                        goto LABEL_351;
                      case 3:
                        goto LABEL_382;
                      case 4:
                        goto LABEL_445;
                      case 5:
                        goto LABEL_474;
                      case 6:
                        goto LABEL_503;
                      case 7:
                      case 11:
                        goto LABEL_564;
                      case 8:
                        goto LABEL_595;
                      case 9:
                      case 10:
                        goto LABEL_658;
                      case 12:
                        goto LABEL_721;
                      case 13:
                        goto LABEL_752;
                      case 14:
                        goto LABEL_783;
                      case 15:
                        goto LABEL_812;
                      case 16:
                        goto LABEL_841;
                      case 17:
                        goto LABEL_870;
                      case 18:
                        goto LABEL_899;
                      case 19:
                        goto LABEL_930;
                      case 20:
                        goto LABEL_961;
                      case 21:
                        goto LABEL_992;
                      case 22:
                        goto LABEL_1023;
                      case 23:
                        goto LABEL_1086;
                      case 24:
                        goto LABEL_1149;
                      case 25:
                        goto LABEL_1212;
                      case 26:
                        goto LABEL_1275;
                    }
                  }
                  do
                  {
                    *v57 = v54;
                    v54 += v1078;
                    v57[1] = v56;
                    v56 += v1086;
                    v57 += 5;
                    --v1094;
                  }
                  while ( v1094 );
                  v29 = (unsigned __int8)byte_E126D;
                  switch ( byte_E126D )
                  {
                    case 0:
                      goto LABEL_309;
                    case 1:
                      goto LABEL_322;
                    case 2:
                      goto LABEL_351;
                    case 3:
                      goto LABEL_382;
                    case 4:
                      goto LABEL_445;
                    case 5:
                      goto LABEL_474;
                    case 6:
                      goto LABEL_503;
                    case 7:
                    case 11:
                      goto LABEL_564;
                    case 8:
                      goto LABEL_595;
                    case 9:
                    case 10:
                      goto LABEL_658;
                    case 12:
                      goto LABEL_721;
                    case 13:
                      goto LABEL_752;
                    case 14:
                      goto LABEL_783;
                    case 15:
                      goto LABEL_812;
                    case 16:
                      goto LABEL_841;
                    case 17:
                      goto LABEL_870;
                    case 18:
                      goto LABEL_899;
                    case 19:
                      goto LABEL_930;
                    case 20:
                      goto LABEL_961;
                    case 21:
                      goto LABEL_992;
                    case 22:
                      goto LABEL_1023;
                    case 23:
                      goto LABEL_1086;
                    case 24:
                      goto LABEL_1149;
                    case 25:
                      goto LABEL_1212;
                    case 26:
                      goto LABEL_1275;
                  }
                }
                v1092 += v1173;
                v54 += v1078 * v1138;
                v55 += v1138 * v1082;
                if ( v1283 )
                {
                  v1098 = dword_DE568;
                  if ( v1279 )
                  {
                    v1092 = dword_DE568;
                  }
                  else
                  {
                    v1279 = dword_DE568 <= v1092;
                    v1094 = dword_DE568 - v1092;
                  }
                }
LABEL_116:
                v57 = &unk_DE56C;
                do
                {
                  *v57 = v54;
                  v54 += v1078;
                  v57[1] = v55;
                  v55 += v1082;
                  v57 += 5;
                  --v1092;
                }
                while ( v1092 );
                v56 = v1096;
                goto LABEL_119;
              }
              return;
            case 1:
            case 4:
            case 16:
            case 17:
              v43 = v12 * (__int64)(*v3 - *v5) / v1088;
              v44 = *v4 - *v3;
              v45 = v43 + v44 == 0;
              v16 = (v43 + v44 < 0) ^ __OFADD__(v43, v44);
              v46 = v43 + v44;
              if ( v16 )
                return;
              if ( !v45 )
                v1121 = (int)(v4[4] + v1092 * (__int64)(v3[4] - v5[4]) / v1088 - v3[4]) / (v46 + 1);
              v1123 = (v5[4] - v3[4]) / v1088;
              v47 = *v3 << 16;
              v48 = v47;
              v49 = v3[4];
              if ( !v1275 )
              {
                if ( v1283 )
                {
                  v52 = dword_DE568 - v1173;
                  v1098 = dword_DE568 - v1173;
                  if ( v1279 )
                  {
                    v1092 = dword_DE568 - v1173;
                  }
                  else
                  {
                    v27 = __OFSUB__(v52, v1092);
                    v53 = v52 - v1092;
                    v1279 = (v53 < 0) ^ v27 | (v53 == 0);
                    v1094 = v53;
                  }
                }
                goto LABEL_95;
              }
              v16 = v1098 <= -v1173;
              v1098 += v1173;
              if ( !v16 )
              {
                v1136 = -v1173;
                if ( -v1173 - v1092 >= 0 )
                {
                  v1094 -= v1136 - v1092;
                  v1137 = v1136 - v1092;
                  v47 += v1078 * v1137 + v1092 * v1078;
                  v50 = v1086 * v1137 + v1096;
                  v49 += v1137 * v1123 + v1092 * v1123;
                  if ( v1283 )
                  {
                    v1094 = dword_DE568;
                    v1098 = dword_DE568;
                  }
                  v51 = &unk_DE56C;
LABEL_98:
                  if ( v1279 )
                  {
                    v29 = (unsigned __int8)byte_E126D;
                    switch ( byte_E126D )
                    {
                      case 0:
                        goto LABEL_309;
                      case 1:
                        goto LABEL_322;
                      case 2:
                        goto LABEL_351;
                      case 3:
                        goto LABEL_382;
                      case 4:
                        goto LABEL_445;
                      case 5:
                        goto LABEL_474;
                      case 6:
                        goto LABEL_503;
                      case 7:
                      case 11:
                        goto LABEL_564;
                      case 8:
                        goto LABEL_595;
                      case 9:
                      case 10:
                        goto LABEL_658;
                      case 12:
                        goto LABEL_721;
                      case 13:
                        goto LABEL_752;
                      case 14:
                        goto LABEL_783;
                      case 15:
                        goto LABEL_812;
                      case 16:
                        goto LABEL_841;
                      case 17:
                        goto LABEL_870;
                      case 18:
                        goto LABEL_899;
                      case 19:
                        goto LABEL_930;
                      case 20:
                        goto LABEL_961;
                      case 21:
                        goto LABEL_992;
                      case 22:
                        goto LABEL_1023;
                      case 23:
                        goto LABEL_1086;
                      case 24:
                        goto LABEL_1149;
                      case 25:
                        goto LABEL_1212;
                      case 26:
                        goto LABEL_1275;
                    }
                  }
                  do
                  {
                    *v51 = v47;
                    v47 += v1078;
                    v51[1] = v50;
                    v50 += v1086;
                    v51[4] = v49;
                    v49 += v1123;
                    v51 += 5;
                    --v1094;
                  }
                  while ( v1094 );
                  v29 = (unsigned __int8)byte_E126D;
                  switch ( byte_E126D )
                  {
                    case 0:
                      goto LABEL_309;
                    case 1:
                      goto LABEL_322;
                    case 2:
                      goto LABEL_351;
                    case 3:
                      goto LABEL_382;
                    case 4:
                      goto LABEL_445;
                    case 5:
                      goto LABEL_474;
                    case 6:
                      goto LABEL_503;
                    case 7:
                    case 11:
                      goto LABEL_564;
                    case 8:
                      goto LABEL_595;
                    case 9:
                    case 10:
                      goto LABEL_658;
                    case 12:
                      goto LABEL_721;
                    case 13:
                      goto LABEL_752;
                    case 14:
                      goto LABEL_783;
                    case 15:
                      goto LABEL_812;
                    case 16:
                      goto LABEL_841;
                    case 17:
                      goto LABEL_870;
                    case 18:
                      goto LABEL_899;
                    case 19:
                      goto LABEL_930;
                    case 20:
                      goto LABEL_961;
                    case 21:
                      goto LABEL_992;
                    case 22:
                      goto LABEL_1023;
                    case 23:
                      goto LABEL_1086;
                    case 24:
                      goto LABEL_1149;
                    case 25:
                      goto LABEL_1212;
                    case 26:
                      goto LABEL_1275;
                  }
                }
                v1092 += v1173;
                v47 += v1078 * v1136;
                v48 += v1136 * v1082;
                v49 += v1136 * v1123;
                if ( v1283 )
                {
                  v1098 = dword_DE568;
                  if ( v1279 )
                  {
                    v1092 = dword_DE568;
                  }
                  else
                  {
                    v1279 = dword_DE568 <= v1092;
                    v1094 = dword_DE568 - v1092;
                  }
                }
LABEL_95:
                v51 = &unk_DE56C;
                do
                {
                  *v51 = v47;
                  v47 += v1078;
                  v51[1] = v48;
                  v48 += v1082;
                  v51[4] = v49;
                  v49 += v1123;
                  v51 += 5;
                  --v1092;
                }
                while ( v1092 );
                v50 = v1096;
                goto LABEL_98;
              }
              return;
            case 2:
            case 3:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 18:
            case 19:
            case 22:
            case 23:
              v30 = v12 * (__int64)(*v3 - *v5) / v1088;
              v31 = *v4 - *v3;
              v32 = v30 + v31 == 0;
              v16 = (v30 + v31 < 0) ^ __OFADD__(v30, v31);
              v33 = v30 + v31;
              if ( v16 )
                return;
              if ( !v32 )
              {
                v34 = v33 + 1;
                v1099 = (int)(v4[2] + v1092 * (__int64)(v3[2] - v5[2]) / v1088 - v3[2]) / v34;
                v1110 = (int)(v4[3] + v1092 * (__int64)(v3[3] - v5[3]) / v1088 - v3[3]) / v34;
              }
              v1101 = (v5[2] - v3[2]) / v1088;
              v1112 = (v5[3] - v3[3]) / v1088;
              v35 = *v3 << 16;
              v36 = v35;
              v37 = v3[2];
              v38 = v3[3];
              if ( !v1275 )
              {
                if ( v1283 )
                {
                  v41 = dword_DE568 - v1173;
                  v1098 = dword_DE568 - v1173;
                  if ( v1279 )
                  {
                    v1092 = dword_DE568 - v1173;
                  }
                  else
                  {
                    v27 = __OFSUB__(v41, v1092);
                    v42 = v41 - v1092;
                    v1279 = (v42 < 0) ^ v27 | (v42 == 0);
                    v1094 = v42;
                  }
                }
                goto LABEL_71;
              }
              v16 = v1098 <= -v1173;
              v1098 += v1173;
              if ( !v16 )
              {
                v1134 = -v1173;
                if ( -v1173 - v1092 >= 0 )
                {
                  v1094 -= v1134 - v1092;
                  v1135 = v1134 - v1092;
                  v35 += v1078 * v1135 + v1092 * v1078;
                  v39 = v1086 * v1135 + v1096;
                  v37 += v1135 * v1101 + v1092 * v1101;
                  v38 += v1135 * v1112 + v1092 * v1112;
                  if ( v1283 )
                  {
                    v1094 = dword_DE568;
                    v1098 = dword_DE568;
                  }
                  v40 = &unk_DE56C;
LABEL_74:
                  if ( v1279 )
                  {
                    v29 = (unsigned __int8)byte_E126D;
                    switch ( byte_E126D )
                    {
                      case 0:
                        goto LABEL_309;
                      case 1:
                        goto LABEL_322;
                      case 2:
                        goto LABEL_351;
                      case 3:
                        goto LABEL_382;
                      case 4:
                        goto LABEL_445;
                      case 5:
                        goto LABEL_474;
                      case 6:
                        goto LABEL_503;
                      case 7:
                      case 11:
                        goto LABEL_564;
                      case 8:
                        goto LABEL_595;
                      case 9:
                      case 10:
                        goto LABEL_658;
                      case 12:
                        goto LABEL_721;
                      case 13:
                        goto LABEL_752;
                      case 14:
                        goto LABEL_783;
                      case 15:
                        goto LABEL_812;
                      case 16:
                        goto LABEL_841;
                      case 17:
                        goto LABEL_870;
                      case 18:
                        goto LABEL_899;
                      case 19:
                        goto LABEL_930;
                      case 20:
                        goto LABEL_961;
                      case 21:
                        goto LABEL_992;
                      case 22:
                        goto LABEL_1023;
                      case 23:
                        goto LABEL_1086;
                      case 24:
                        goto LABEL_1149;
                      case 25:
                        goto LABEL_1212;
                      case 26:
                        goto LABEL_1275;
                    }
                  }
                  do
                  {
                    *v40 = v35;
                    v35 += v1078;
                    v40[1] = v39;
                    v39 += v1086;
                    v40[2] = v37;
                    v37 += v1101;
                    v40[3] = v38;
                    v38 += v1112;
                    v40 += 5;
                    --v1094;
                  }
                  while ( v1094 );
                  v29 = (unsigned __int8)byte_E126D;
                  switch ( byte_E126D )
                  {
                    case 0:
                      goto LABEL_309;
                    case 1:
                      goto LABEL_322;
                    case 2:
                      goto LABEL_351;
                    case 3:
                      goto LABEL_382;
                    case 4:
                      goto LABEL_445;
                    case 5:
                      goto LABEL_474;
                    case 6:
                      goto LABEL_503;
                    case 7:
                    case 11:
                      goto LABEL_564;
                    case 8:
                      goto LABEL_595;
                    case 9:
                    case 10:
                      goto LABEL_658;
                    case 12:
                      goto LABEL_721;
                    case 13:
                      goto LABEL_752;
                    case 14:
                      goto LABEL_783;
                    case 15:
                      goto LABEL_812;
                    case 16:
                      goto LABEL_841;
                    case 17:
                      goto LABEL_870;
                    case 18:
                      goto LABEL_899;
                    case 19:
                      goto LABEL_930;
                    case 20:
                      goto LABEL_961;
                    case 21:
                      goto LABEL_992;
                    case 22:
                      goto LABEL_1023;
                    case 23:
                      goto LABEL_1086;
                    case 24:
                      goto LABEL_1149;
                    case 25:
                      goto LABEL_1212;
                    case 26:
                      goto LABEL_1275;
                  }
                }
                v1092 += v1173;
                v35 += v1078 * v1134;
                v36 += v1134 * v1082;
                v37 += v1134 * v1101;
                v38 += v1134 * v1112;
                if ( v1283 )
                {
                  v1098 = dword_DE568;
                  if ( v1279 )
                  {
                    v1092 = dword_DE568;
                  }
                  else
                  {
                    v1279 = dword_DE568 <= v1092;
                    v1094 = dword_DE568 - v1092;
                  }
                }
LABEL_71:
                v40 = &unk_DE56C;
                do
                {
                  *v40 = v35;
                  v35 += v1078;
                  v40[1] = v36;
                  v36 += v1082;
                  v40[2] = v37;
                  v37 += v1101;
                  v40[3] = v38;
                  v38 += v1112;
                  v40 += 5;
                  --v1092;
                }
                while ( v1092 );
                v39 = v1096;
                goto LABEL_74;
              }
              return;
            case 5:
            case 6:
            case 20:
            case 21:
            case 24:
            case 25:
            case 26:
              v13 = v12 * (__int64)(*v3 - *v5) / v1088;
              v14 = *v4 - *v3;
              v15 = v13 + v14 == 0;
              v16 = (v13 + v14 < 0) ^ __OFADD__(v13, v14);
              v17 = v13 + v14;
              if ( v16 )
                return;
              if ( !v15 )
              {
                v18 = v17 + 1;
                v1099 = (int)(v4[2] + v1092 * (__int64)(v3[2] - v5[2]) / v1088 - v3[2]) / v18;
                v1110 = (int)(v4[3] + v1092 * (__int64)(v3[3] - v5[3]) / v1088 - v3[3]) / v18;
                v1121 = (int)(v4[4] + v1092 * (__int64)(v3[4] - v5[4]) / v1088 - v3[4]) / v18;
              }
              v1100 = (v5[2] - v3[2]) / v1088;
              v1111 = (v5[3] - v3[3]) / v1088;
              v1122 = (v5[4] - v3[4]) / v1088;
              v19 = *v3 << 16;
              v20 = v19;
              v21 = v3[2];
              v22 = v3[3];
              v23 = v3[4];
              if ( !v1275 )
              {
                if ( v1283 )
                {
                  v26 = dword_DE568 - v1173;
                  v1098 = dword_DE568 - v1173;
                  if ( v1279 )
                  {
                    v1092 = dword_DE568 - v1173;
                  }
                  else
                  {
                    v27 = __OFSUB__(v26, v1092);
                    v28 = v26 - v1092;
                    v1279 = (v28 < 0) ^ v27 | (v28 == 0);
                    v1094 = v28;
                  }
                }
                goto LABEL_47;
              }
              v16 = v1098 <= -v1173;
              v1098 += v1173;
              if ( !v16 )
              {
                v1132 = -v1173;
                if ( -v1173 - v1092 >= 0 )
                {
                  v1094 -= v1132 - v1092;
                  v1133 = v1132 - v1092;
                  v19 += v1078 * v1133 + v1092 * v1078;
                  v24 = v1086 * v1133 + v1096;
                  v21 += v1133 * v1100 + v1092 * v1100;
                  v22 += v1133 * v1111 + v1092 * v1111;
                  v23 += v1133 * v1122 + v1092 * v1122;
                  if ( v1283 )
                  {
                    v1094 = dword_DE568;
                    v1098 = dword_DE568;
                  }
                  v25 = &unk_DE56C;
LABEL_50:
                  if ( v1279 )
                  {
                    v29 = (unsigned __int8)byte_E126D;
                    switch ( byte_E126D )
                    {
                      case 0:
                        goto LABEL_309;
                      case 1:
                        goto LABEL_322;
                      case 2:
                        goto LABEL_351;
                      case 3:
                        goto LABEL_382;
                      case 4:
                        goto LABEL_445;
                      case 5:
                        goto LABEL_474;
                      case 6:
                        goto LABEL_503;
                      case 7:
                      case 11:
                        goto LABEL_564;
                      case 8:
                        goto LABEL_595;
                      case 9:
                      case 10:
                        goto LABEL_658;
                      case 12:
                        goto LABEL_721;
                      case 13:
                        goto LABEL_752;
                      case 14:
                        goto LABEL_783;
                      case 15:
                        goto LABEL_812;
                      case 16:
                        goto LABEL_841;
                      case 17:
                        goto LABEL_870;
                      case 18:
                        goto LABEL_899;
                      case 19:
                        goto LABEL_930;
                      case 20:
                        goto LABEL_961;
                      case 21:
                        goto LABEL_992;
                      case 22:
                        goto LABEL_1023;
                      case 23:
                        goto LABEL_1086;
                      case 24:
                        goto LABEL_1149;
                      case 25:
                        goto LABEL_1212;
                      case 26:
                        goto LABEL_1275;
                    }
                  }
                  do
                  {
                    *v25 = v19;
                    v19 += v1078;
                    v25[1] = v24;
                    v24 += v1086;
                    v25[2] = v21;
                    v21 += v1100;
                    v25[3] = v22;
                    v22 += v1111;
                    v25[4] = v23;
                    v23 += v1122;
                    v25 += 5;
                    --v1094;
                  }
                  while ( v1094 );
                  v29 = (unsigned __int8)byte_E126D;
                  switch ( byte_E126D )
                  {
                    case 0:
                      goto LABEL_309;
                    case 1:
                      goto LABEL_322;
                    case 2:
                      goto LABEL_351;
                    case 3:
                      goto LABEL_382;
                    case 4:
                      goto LABEL_445;
                    case 5:
                      goto LABEL_474;
                    case 6:
                      goto LABEL_503;
                    case 7:
                    case 11:
                      goto LABEL_564;
                    case 8:
                      goto LABEL_595;
                    case 9:
                    case 10:
                      goto LABEL_658;
                    case 12:
                      goto LABEL_721;
                    case 13:
                      goto LABEL_752;
                    case 14:
                      goto LABEL_783;
                    case 15:
                      goto LABEL_812;
                    case 16:
                      goto LABEL_841;
                    case 17:
                      goto LABEL_870;
                    case 18:
                      goto LABEL_899;
                    case 19:
                      goto LABEL_930;
                    case 20:
                      goto LABEL_961;
                    case 21:
                      goto LABEL_992;
                    case 22:
                      goto LABEL_1023;
                    case 23:
                      goto LABEL_1086;
                    case 24:
                      goto LABEL_1149;
                    case 25:
                      goto LABEL_1212;
                    case 26:
                      goto LABEL_1275;
                  }
                }
                v1092 += v1173;
                v19 += v1078 * v1132;
                v20 += v1132 * v1082;
                v21 += v1132 * v1100;
                v22 += v1132 * v1111;
                v23 += v1132 * v1122;
                if ( v1283 )
                {
                  v1098 = dword_DE568;
                  if ( v1279 )
                  {
                    v1092 = dword_DE568;
                  }
                  else
                  {
                    v1279 = dword_DE568 <= v1092;
                    v1094 = dword_DE568 - v1092;
                  }
                }
LABEL_47:
                v25 = &unk_DE56C;
                do
                {
                  *v25 = v19;
                  v19 += v1078;
                  v25[1] = v20;
                  v20 += v1082;
                  v25[2] = v21;
                  v21 += v1100;
                  v25[3] = v22;
                  v22 += v1111;
                  v25[4] = v23;
                  v23 += v1122;
                  v25 += 5;
                  --v1092;
                }
                while ( v1092 );
                v24 = v1096;
                goto LABEL_50;
              }
              break;
          }
        }
        return;
      }
      if ( v7 != v8 )
      {
        if ( v7 <= v8 )
          goto LABEL_24;
        goto LABEL_124;
      }
      if ( *a2 <= *a3 )
        return;
LABEL_225:
      v108 = v3[1];
      v1175 = v108;
      if ( v108 >= 0 )
      {
        if ( v108 >= dword_DE568 )
          return;
        v1077 = dword_DE554 + dword_DE560 * v108;
        v1277 = 0;
      }
      else
      {
        v1077 = dword_DE554;
        v1277 = 1;
      }
      v109 = v5[1];
      v1281 = v109 > dword_DE568;
      v1090 = v109 - v108;
      v1098 = v109 - v108;
      v1080 = ((*v5 - *v3) << 16) / (v109 - v108);
      v1084 = ((*v4 - *v3) << 16) / (v109 - v108);
      switch ( byte_E126D )
      {
        case 0:
        case 14:
        case 15:
          v130 = *v3 << 16;
          v131 = v130;
          if ( v1277 )
          {
            v132 = -v1175;
            v1090 += v1175;
            v16 = v1098 <= -v1175;
            v1098 += v1175;
            if ( v16 )
              return;
            v130 += v1080 * v132;
            v131 += v132 * v1084;
            if ( v1281 )
            {
              v1098 = dword_DE568;
              v1090 = dword_DE568;
            }
          }
          else if ( v1281 )
          {
            v1098 = dword_DE568 - v1175;
            v1090 = dword_DE568 - v1175;
          }
          v133 = &unk_DE56C;
          do
          {
            *v133 = v130;
            v130 += v1080;
            v133[1] = v131;
            v131 += v1084;
            v133 += 5;
            --v1090;
          }
          while ( v1090 );
          v29 = (unsigned __int8)byte_E126D;
          switch ( byte_E126D )
          {
            case 0:
              goto LABEL_309;
            case 1:
              goto LABEL_322;
            case 2:
              goto LABEL_351;
            case 3:
              goto LABEL_382;
            case 4:
              goto LABEL_445;
            case 5:
              goto LABEL_474;
            case 6:
              goto LABEL_503;
            case 7:
            case 11:
              goto LABEL_564;
            case 8:
              goto LABEL_595;
            case 9:
            case 10:
              goto LABEL_658;
            case 12:
              goto LABEL_721;
            case 13:
              goto LABEL_752;
            case 14:
              goto LABEL_783;
            case 15:
              goto LABEL_812;
            case 16:
              goto LABEL_841;
            case 17:
              goto LABEL_870;
            case 18:
              goto LABEL_899;
            case 19:
              goto LABEL_930;
            case 20:
              goto LABEL_961;
            case 21:
              goto LABEL_992;
            case 22:
              goto LABEL_1023;
            case 23:
              goto LABEL_1086;
            case 24:
              goto LABEL_1149;
            case 25:
              goto LABEL_1212;
            case 26:
              goto LABEL_1275;
          }
        case 1:
        case 4:
        case 16:
        case 17:
          v1121 = (v4[4] - v5[4]) / (*v4 - *v5);
          v1127 = (v5[4] - v3[4]) / v1098;
          v125 = *v3 << 16;
          v126 = v125;
          v127 = v3[4];
          if ( v1277 )
          {
            v128 = -v1175;
            v1090 += v1175;
            v16 = v1098 <= -v1175;
            v1098 += v1175;
            if ( v16 )
              return;
            v125 += v1080 * v128;
            v126 += v128 * v1084;
            v127 += v128 * v1127;
            if ( v1281 )
            {
              v1098 = dword_DE568;
              v1090 = dword_DE568;
            }
          }
          else if ( v1281 )
          {
            v1098 = dword_DE568 - v1175;
            v1090 = dword_DE568 - v1175;
          }
          v129 = &unk_DE56C;
          do
          {
            *v129 = v125;
            v125 += v1080;
            v129[1] = v126;
            v126 += v1084;
            v129[4] = v127;
            v127 += v1127;
            v129 += 5;
            --v1090;
          }
          while ( v1090 );
          v29 = (unsigned __int8)byte_E126D;
          switch ( byte_E126D )
          {
            case 0:
              goto LABEL_309;
            case 1:
              goto LABEL_322;
            case 2:
              goto LABEL_351;
            case 3:
              goto LABEL_382;
            case 4:
              goto LABEL_445;
            case 5:
              goto LABEL_474;
            case 6:
              goto LABEL_503;
            case 7:
            case 11:
              goto LABEL_564;
            case 8:
              goto LABEL_595;
            case 9:
            case 10:
              goto LABEL_658;
            case 12:
              goto LABEL_721;
            case 13:
              goto LABEL_752;
            case 14:
              goto LABEL_783;
            case 15:
              goto LABEL_812;
            case 16:
              goto LABEL_841;
            case 17:
              goto LABEL_870;
            case 18:
              goto LABEL_899;
            case 19:
              goto LABEL_930;
            case 20:
              goto LABEL_961;
            case 21:
              goto LABEL_992;
            case 22:
              goto LABEL_1023;
            case 23:
              goto LABEL_1086;
            case 24:
              goto LABEL_1149;
            case 25:
              goto LABEL_1212;
            case 26:
              goto LABEL_1275;
          }
        case 2:
        case 3:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 18:
        case 19:
        case 22:
        case 23:
          v118 = *v4 - *v5;
          v1099 = (v4[2] - v5[2]) / v118;
          v1110 = (v4[3] - v5[3]) / v118;
          v1105 = (v5[2] - v3[2]) / v1098;
          v1116 = (v5[3] - v3[3]) / v1098;
          v119 = *v3 << 16;
          v120 = v119;
          v121 = v3[2];
          v122 = v3[3];
          if ( v1277 )
          {
            v123 = -v1175;
            v1090 += v1175;
            v16 = v1098 <= -v1175;
            v1098 += v1175;
            if ( v16 )
              return;
            v119 += v1080 * v123;
            v120 += v123 * v1084;
            v121 += v123 * v1105;
            v122 += v123 * v1116;
            if ( v1281 )
            {
              v1098 = dword_DE568;
              v1090 = dword_DE568;
            }
          }
          else if ( v1281 )
          {
            v1098 = dword_DE568 - v1175;
            v1090 = dword_DE568 - v1175;
          }
          v124 = &unk_DE56C;
          do
          {
            *v124 = v119;
            v119 += v1080;
            v124[1] = v120;
            v120 += v1084;
            v124[2] = v121;
            v121 += v1105;
            v124[3] = v122;
            v122 += v1116;
            v124 += 5;
            --v1090;
          }
          while ( v1090 );
          v29 = (unsigned __int8)byte_E126D;
          switch ( byte_E126D )
          {
            case 0:
              goto LABEL_309;
            case 1:
              goto LABEL_322;
            case 2:
              goto LABEL_351;
            case 3:
              goto LABEL_382;
            case 4:
              goto LABEL_445;
            case 5:
              goto LABEL_474;
            case 6:
              goto LABEL_503;
            case 7:
            case 11:
              goto LABEL_564;
            case 8:
              goto LABEL_595;
            case 9:
            case 10:
              goto LABEL_658;
            case 12:
              goto LABEL_721;
            case 13:
              goto LABEL_752;
            case 14:
              goto LABEL_783;
            case 15:
              goto LABEL_812;
            case 16:
              goto LABEL_841;
            case 17:
              goto LABEL_870;
            case 18:
              goto LABEL_899;
            case 19:
              goto LABEL_930;
            case 20:
              goto LABEL_961;
            case 21:
              goto LABEL_992;
            case 22:
              goto LABEL_1023;
            case 23:
              goto LABEL_1086;
            case 24:
              goto LABEL_1149;
            case 25:
              goto LABEL_1212;
            case 26:
              goto LABEL_1275;
          }
        case 5:
        case 6:
        case 20:
        case 21:
        case 24:
        case 25:
        case 26:
          v110 = *v4 - *v5;
          v1099 = (v4[2] - v5[2]) / v110;
          v1110 = (v4[3] - v5[3]) / v110;
          v1121 = (v4[4] - v5[4]) / v110;
          v1104 = (v5[2] - v3[2]) / v1098;
          v1115 = (v5[3] - v3[3]) / v1098;
          v1126 = (v5[4] - v3[4]) / v1098;
          v111 = *v3 << 16;
          v112 = v111;
          v113 = v3[2];
          v114 = v3[3];
          v115 = v3[4];
          if ( v1277 )
          {
            v116 = -v1175;
            v1090 += v1175;
            v16 = v1098 <= -v1175;
            v1098 += v1175;
            if ( v16 )
              return;
            v111 += v1080 * v116;
            v112 += v116 * v1084;
            v113 += v116 * v1104;
            v114 += v116 * v1115;
            v115 += v116 * v1126;
            if ( v1281 )
            {
              v1098 = dword_DE568;
              v1090 = dword_DE568;
            }
          }
          else if ( v1281 )
          {
            v1098 = dword_DE568 - v1175;
            v1090 = dword_DE568 - v1175;
          }
          v117 = &unk_DE56C;
          do
          {
            *v117 = v111;
            v111 += v1080;
            v117[1] = v112;
            v112 += v1084;
            v117[2] = v113;
            v113 += v1104;
            v117[3] = v114;
            v114 += v1115;
            v117[4] = v115;
            v115 += v1126;
            v117 += 5;
            --v1090;
          }
          while ( v1090 );
          v29 = (unsigned __int8)byte_E126D;
          switch ( byte_E126D )
          {
            case 0:
              goto LABEL_309;
            case 1:
              goto LABEL_322;
            case 2:
              goto LABEL_351;
            case 3:
              goto LABEL_382;
            case 4:
              goto LABEL_445;
            case 5:
              goto LABEL_474;
            case 6:
              goto LABEL_503;
            case 7:
            case 11:
              goto LABEL_564;
            case 8:
              goto LABEL_595;
            case 9:
            case 10:
              goto LABEL_658;
            case 12:
              goto LABEL_721;
            case 13:
              goto LABEL_752;
            case 14:
              goto LABEL_783;
            case 15:
              goto LABEL_812;
            case 16:
              goto LABEL_841;
            case 17:
              goto LABEL_870;
            case 18:
              goto LABEL_899;
            case 19:
              goto LABEL_930;
            case 20:
              goto LABEL_961;
            case 21:
              goto LABEL_992;
            case 22:
              goto LABEL_1023;
            case 23:
              goto LABEL_1086;
            case 24:
              goto LABEL_1149;
            case 25:
              goto LABEL_1212;
            case 26:
              goto LABEL_1275;
          }
      }
    }
    if ( *a1 <= *a3 )
      return;
    v3 = a3;
    v4 = a1;
    v5 = a2;
LABEL_268:
    v134 = v3[1];
    v1176 = v134;
    if ( v134 >= 0 )
    {
      if ( v134 >= dword_DE568 )
        return;
      v1077 = dword_DE554 + dword_DE560 * v134;
      v1278 = 0;
    }
    else
    {
      v1077 = dword_DE554;
      v1278 = 1;
    }
    v135 = v5[1];
    v1282 = v135 > dword_DE568;
    v1091 = v135 - v134;
    v1098 = v135 - v134;
    v1081 = ((*v5 - *v3) << 16) / (v135 - v134);
    v1085 = ((*v5 - *v4) << 16) / (v135 - v134);
    switch ( byte_E126D )
    {
      case 0:
      case 14:
      case 15:
        v156 = *v3 << 16;
        v157 = *v4 << 16;
        if ( v1278 )
        {
          v158 = -v1176;
          v1091 += v1176;
          v16 = v1098 <= -v1176;
          v1098 += v1176;
          if ( v16 )
            return;
          v156 += v1081 * v158;
          v157 += v158 * v1085;
          if ( v1282 )
          {
            v1098 = dword_DE568;
            v1091 = dword_DE568;
          }
        }
        else if ( v1282 )
        {
          v1098 = dword_DE568 - v1176;
          v1091 = dword_DE568 - v1176;
        }
        v159 = &unk_DE56C;
        do
        {
          *v159 = v156;
          v156 += v1081;
          v159[1] = v157;
          v157 += v1085;
          v159 += 5;
          --v1091;
        }
        while ( v1091 );
        v29 = (unsigned __int8)byte_E126D;
        switch ( byte_E126D )
        {
          case 0:
            goto LABEL_309;
          case 1:
            goto LABEL_322;
          case 2:
            goto LABEL_351;
          case 3:
            goto LABEL_382;
          case 4:
            goto LABEL_445;
          case 5:
            goto LABEL_474;
          case 6:
            goto LABEL_503;
          case 7:
          case 11:
            goto LABEL_564;
          case 8:
            goto LABEL_595;
          case 9:
          case 10:
            goto LABEL_658;
          case 12:
            goto LABEL_721;
          case 13:
            goto LABEL_752;
          case 14:
            goto LABEL_783;
          case 15:
            goto LABEL_812;
          case 16:
            goto LABEL_841;
          case 17:
            goto LABEL_870;
          case 18:
            goto LABEL_899;
          case 19:
            goto LABEL_930;
          case 20:
            goto LABEL_961;
          case 21:
            goto LABEL_992;
          case 22:
            goto LABEL_1023;
          case 23:
            goto LABEL_1086;
          case 24:
            goto LABEL_1149;
          case 25:
            goto LABEL_1212;
          case 26:
            goto LABEL_1275;
        }
      case 1:
      case 4:
      case 16:
      case 17:
        v1121 = (v4[4] - v3[4]) / (*v4 - *v3);
        v1129 = (v5[4] - v3[4]) / v1098;
        v151 = *v3 << 16;
        v152 = *v4 << 16;
        v153 = v3[4];
        if ( v1278 )
        {
          v154 = -v1176;
          v1091 += v1176;
          v16 = v1098 <= -v1176;
          v1098 += v1176;
          if ( v16 )
            return;
          v151 += v1081 * v154;
          v152 += v154 * v1085;
          v153 += v154 * v1129;
          if ( v1282 )
          {
            v1098 = dword_DE568;
            v1091 = dword_DE568;
          }
        }
        else if ( v1282 )
        {
          v1098 = dword_DE568 - v1176;
          v1091 = dword_DE568 - v1176;
        }
        v155 = &unk_DE56C;
        do
        {
          *v155 = v151;
          v151 += v1081;
          v155[1] = v152;
          v152 += v1085;
          v155[4] = v153;
          v153 += v1129;
          v155 += 5;
          --v1091;
        }
        while ( v1091 );
        v29 = (unsigned __int8)byte_E126D;
        switch ( byte_E126D )
        {
          case 0:
            goto LABEL_309;
          case 1:
            goto LABEL_322;
          case 2:
            goto LABEL_351;
          case 3:
            goto LABEL_382;
          case 4:
            goto LABEL_445;
          case 5:
            goto LABEL_474;
          case 6:
            goto LABEL_503;
          case 7:
          case 11:
            goto LABEL_564;
          case 8:
            goto LABEL_595;
          case 9:
          case 10:
            goto LABEL_658;
          case 12:
            goto LABEL_721;
          case 13:
            goto LABEL_752;
          case 14:
            goto LABEL_783;
          case 15:
            goto LABEL_812;
          case 16:
            goto LABEL_841;
          case 17:
            goto LABEL_870;
          case 18:
            goto LABEL_899;
          case 19:
            goto LABEL_930;
          case 20:
            goto LABEL_961;
          case 21:
            goto LABEL_992;
          case 22:
            goto LABEL_1023;
          case 23:
            goto LABEL_1086;
          case 24:
            goto LABEL_1149;
          case 25:
            goto LABEL_1212;
          case 26:
            goto LABEL_1275;
        }
      case 2:
      case 3:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 18:
      case 19:
      case 22:
      case 23:
        v144 = *v4 - *v3;
        v1099 = (v4[2] - v3[2]) / v144;
        v1110 = (v4[3] - v3[3]) / v144;
        v1107 = (v5[2] - v3[2]) / v1098;
        v1118 = (v5[3] - v3[3]) / v1098;
        v145 = *v3 << 16;
        v146 = *v4 << 16;
        v147 = v3[2];
        v148 = v3[3];
        if ( v1278 )
        {
          v149 = -v1176;
          v1091 += v1176;
          v16 = v1098 <= -v1176;
          v1098 += v1176;
          if ( v16 )
            return;
          v145 += v1081 * v149;
          v146 += v149 * v1085;
          v147 += v149 * v1107;
          v148 += v149 * v1118;
          if ( v1282 )
          {
            v1098 = dword_DE568;
            v1091 = dword_DE568;
          }
        }
        else if ( v1282 )
        {
          v1098 = dword_DE568 - v1176;
          v1091 = dword_DE568 - v1176;
        }
        v150 = &unk_DE56C;
        do
        {
          *v150 = v145;
          v145 += v1081;
          v150[1] = v146;
          v146 += v1085;
          v150[2] = v147;
          v147 += v1107;
          v150[3] = v148;
          v148 += v1118;
          v150 += 5;
          --v1091;
        }
        while ( v1091 );
        v29 = (unsigned __int8)byte_E126D;
        switch ( byte_E126D )
        {
          case 0:
            goto LABEL_309;
          case 1:
            goto LABEL_322;
          case 2:
            goto LABEL_351;
          case 3:
            goto LABEL_382;
          case 4:
            goto LABEL_445;
          case 5:
            goto LABEL_474;
          case 6:
            goto LABEL_503;
          case 7:
          case 11:
            goto LABEL_564;
          case 8:
            goto LABEL_595;
          case 9:
          case 10:
            goto LABEL_658;
          case 12:
            goto LABEL_721;
          case 13:
            goto LABEL_752;
          case 14:
            goto LABEL_783;
          case 15:
            goto LABEL_812;
          case 16:
            goto LABEL_841;
          case 17:
            goto LABEL_870;
          case 18:
            goto LABEL_899;
          case 19:
            goto LABEL_930;
          case 20:
            goto LABEL_961;
          case 21:
            goto LABEL_992;
          case 22:
            goto LABEL_1023;
          case 23:
            goto LABEL_1086;
          case 24:
            goto LABEL_1149;
          case 25:
            goto LABEL_1212;
          case 26:
            goto LABEL_1275;
        }
      case 5:
      case 6:
      case 20:
      case 21:
      case 24:
      case 25:
      case 26:
        v136 = *v4 - *v3;
        v1099 = (v4[2] - v3[2]) / v136;
        v1110 = (v4[3] - v3[3]) / v136;
        v1121 = (v4[4] - v3[4]) / v136;
        v1106 = (v5[2] - v3[2]) / v1098;
        v1117 = (v5[3] - v3[3]) / v1098;
        v1128 = (v5[4] - v3[4]) / v1098;
        v137 = *v3 << 16;
        v138 = *v4 << 16;
        v139 = v3[2];
        v140 = v3[3];
        v141 = v3[4];
        if ( v1278 )
        {
          v142 = -v1176;
          v1091 += v1176;
          v16 = v1098 <= -v1176;
          v1098 += v1176;
          if ( v16 )
            return;
          v137 += v1081 * v142;
          v138 += v142 * v1085;
          v139 += v142 * v1106;
          v140 += v142 * v1117;
          v141 += v142 * v1128;
          if ( v1282 )
          {
            v1098 = dword_DE568;
            v1091 = dword_DE568;
          }
        }
        else if ( v1282 )
        {
          v1098 = dword_DE568 - v1176;
          v1091 = dword_DE568 - v1176;
        }
        v143 = &unk_DE56C;
        do
        {
          *v143 = v137;
          v137 += v1081;
          v143[1] = v138;
          v138 += v1085;
          v143[2] = v139;
          v139 += v1106;
          v143[3] = v140;
          v140 += v1117;
          v143[4] = v141;
          v141 += v1128;
          v143 += 5;
          --v1091;
        }
        while ( v1091 );
        break;
    }
    v29 = (unsigned __int8)byte_E126D;
    switch ( byte_E126D )
    {
      case 0:
LABEL_309:
        v160 = (unsigned __int16 *)&unk_DE56C;
        v161 = (char *)v1077;
        v162 = byte_E126C;
        HIWORD(v163) = 0;
        while ( 1 )
        {
          LOWORD(v163) = v160[1];
          v164 = v160[3];
          v161 += dword_DE560;
          if ( (v163 & 0x8000u) == 0 )
            break;
          if ( (__int16)v164 > 0 )
          {
            if ( v164 > dword_DE564 )
              v164 = dword_DE564;
            v165 = v161;
LABEL_319:
            memset(v165, v162, v164);
          }
LABEL_320:
          v160 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v164 > dword_DE564 )
          v164 = dword_DE564;
        v16 = (__int16)v164 <= (__int16)v163;
        LOWORD(v164) = v164 - v163;
        if ( v16 )
          goto LABEL_320;
        v165 = &v161[v163];
        goto LABEL_319;
      case 1:
LABEL_322:
        for ( i = &unk_DE56C; ; i += 10 )
        {
          LOWORD(v29) = i[1];
          v167 = (unsigned __int16)i[3];
          v168 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v29 & 0x8000u) == 0 )
            break;
          if ( (__int16)v167 > 0 )
          {
            v169 = v1121 * (unsigned __int16)-(__int16)v29;
            v170 = v169;
            v29 = v169 >> 8;
            v171 = __CFADD__(i[8], v170);
            v172 = i[8] + v170;
            BYTE1(v29) += *((_BYTE *)i + 18) + v171;
            if ( v167 > dword_DE564 )
              LOWORD(v167) = dword_DE564;
            v29 = (unsigned __int16)v29;
LABEL_332:
            while ( 1 )
            {
              *v168 = BYTE1(v29);
              v171 = __CFADD__((_WORD)v1121, v172);
              v173 = v1121 + v172;
              v174 = BYTE2(v1121) + v171 + BYTE1(v29);
              v175 = v167 - 1;
              if ( !v175 )
                break;
              v168[1] = v174;
              v171 = __CFADD__((_WORD)v1121, v173);
              v176 = v1121 + v173;
              v177 = BYTE2(v1121) + v171 + v174;
              v178 = v175 - 1;
              if ( !v178 )
                break;
              v168[2] = v177;
              v171 = __CFADD__((_WORD)v1121, v176);
              v179 = v1121 + v176;
              v180 = BYTE2(v1121) + v171 + v177;
              v181 = v178 - 1;
              if ( !v181 )
                break;
              v168[3] = v180;
              v171 = __CFADD__((_WORD)v1121, v179);
              v182 = v1121 + v179;
              v183 = BYTE2(v1121) + v171 + v180;
              v184 = v181 - 1;
              if ( !v184 )
                break;
              v168[4] = v183;
              v171 = __CFADD__((_WORD)v1121, v182);
              v185 = v1121 + v182;
              v186 = BYTE2(v1121) + v171 + v183;
              v187 = v184 - 1;
              if ( !v187 )
                break;
              v168[5] = v186;
              v171 = __CFADD__((_WORD)v1121, v185);
              v188 = v1121 + v185;
              v189 = BYTE2(v1121) + v171 + v186;
              v190 = v187 - 1;
              if ( !v190 )
                break;
              v168[6] = v189;
              v171 = __CFADD__((_WORD)v1121, v188);
              v191 = v1121 + v188;
              v192 = BYTE2(v1121) + v171 + v189;
              v193 = v190 - 1;
              if ( !v193 )
                break;
              v168[7] = v192;
              v171 = __CFADD__((_WORD)v1121, v191);
              v194 = v1121 + v191;
              v195 = BYTE2(v1121) + v171 + v192;
              v196 = v193 - 1;
              if ( !v196 )
                break;
              v168[8] = v195;
              v171 = __CFADD__((_WORD)v1121, v194);
              v197 = v1121 + v194;
              v198 = BYTE2(v1121) + v171 + v195;
              v199 = v196 - 1;
              if ( !v199 )
                break;
              v168[9] = v198;
              v171 = __CFADD__((_WORD)v1121, v197);
              v200 = v1121 + v197;
              v201 = BYTE2(v1121) + v171 + v198;
              v202 = v199 - 1;
              if ( !v202 )
                break;
              v168[10] = v201;
              v171 = __CFADD__((_WORD)v1121, v200);
              v203 = v1121 + v200;
              v204 = BYTE2(v1121) + v171 + v201;
              v205 = v202 - 1;
              if ( !v205 )
                break;
              v168[11] = v204;
              v171 = __CFADD__((_WORD)v1121, v203);
              v206 = v1121 + v203;
              v207 = BYTE2(v1121) + v171 + v204;
              v208 = v205 - 1;
              if ( !v208 )
                break;
              v168[12] = v207;
              v171 = __CFADD__((_WORD)v1121, v206);
              v209 = v1121 + v206;
              v210 = BYTE2(v1121) + v171 + v207;
              v211 = v208 - 1;
              if ( !v211 )
                break;
              v168[13] = v210;
              v171 = __CFADD__((_WORD)v1121, v209);
              v212 = v1121 + v209;
              v213 = BYTE2(v1121) + v171 + v210;
              v214 = v211 - 1;
              if ( !v214 )
                break;
              v168[14] = v213;
              v171 = __CFADD__((_WORD)v1121, v212);
              v215 = v1121 + v212;
              v216 = BYTE2(v1121) + v171 + v213;
              v217 = v214 - 1;
              if ( !v217 )
                break;
              v168[15] = v216;
              v171 = __CFADD__((_WORD)v1121, v215);
              v172 = v1121 + v215;
              BYTE1(v29) = BYTE2(v1121) + v171 + v216;
              LOWORD(v167) = v217 - 1;
              if ( !(_WORD)v167 )
                break;
              v168 += 16;
            }
          }
LABEL_349:
          if ( !--v1098 )
            return;
        }
        if ( v167 > dword_DE564 )
          LOWORD(v167) = dword_DE564;
        v16 = (__int16)v167 <= (__int16)v29;
        LOWORD(v167) = v167 - v29;
        if ( v16 )
          goto LABEL_349;
        v168 += v29;
        v29 = (unsigned __int8)byte_E126C;
        v172 = i[8];
        BYTE1(v29) = *((_BYTE *)i + 18);
        goto LABEL_332;
      case 2:
LABEL_351:
        v218 = (unsigned __int16 *)&unk_DE56C;
        v1148 = v1110 << 16;
        HIWORD(v219) = 0;
        HIWORD(v220) = 0;
        while ( 1 )
        {
          LOWORD(v219) = v218[1];
          v221 = v218[3];
          v222 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v219 & 0x8000u) == 0 )
            break;
          if ( (__int16)v221 > 0 )
          {
            v223 = (unsigned __int16)-(__int16)v219;
            v225 = __ROL4__(*((_DWORD *)v218 + 3) + v1110 * v223, 16);
            BYTE1(v220) = v225;
            v224 = *((_DWORD *)v218 + 2) + v1099 * v223;
            LOWORD(v225) = v224;
            v226 = v224 >> 8;
            LOBYTE(v220) = BYTE1(v226);
            if ( v221 > dword_DE564 )
              LOWORD(v221) = dword_DE564;
            v219 = (unsigned __int16)v226;
LABEL_361:
            v1257 = v218;
            v227 = dword_DE55C;
            while ( 1 )
            {
              v228 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v225);
              LOWORD(v225) = v1099 + v225;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              *v222 = v228;
              v171 = __CFADD__(v1148, v225);
              v229 = v1148 + v225;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v230 = v221 - 1;
              if ( !v230 )
                break;
              v231 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v229);
              LOWORD(v229) = v1099 + v229;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[1] = v231;
              v171 = __CFADD__(v1148, v229);
              v232 = v1148 + v229;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v233 = v230 - 1;
              if ( !v233 )
                break;
              v234 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v232);
              LOWORD(v232) = v1099 + v232;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[2] = v234;
              v171 = __CFADD__(v1148, v232);
              v235 = v1148 + v232;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v236 = v233 - 1;
              if ( !v236 )
                break;
              v237 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v235);
              LOWORD(v235) = v1099 + v235;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[3] = v237;
              v171 = __CFADD__(v1148, v235);
              v238 = v1148 + v235;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v239 = v236 - 1;
              if ( !v239 )
                break;
              v240 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v238);
              LOWORD(v238) = v1099 + v238;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[4] = v240;
              v171 = __CFADD__(v1148, v238);
              v241 = v1148 + v238;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v242 = v239 - 1;
              if ( !v242 )
                break;
              v243 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v241);
              LOWORD(v241) = v1099 + v241;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[5] = v243;
              v171 = __CFADD__(v1148, v241);
              v244 = v1148 + v241;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v245 = v242 - 1;
              if ( !v245 )
                break;
              v246 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v244);
              LOWORD(v244) = v1099 + v244;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[6] = v246;
              v171 = __CFADD__(v1148, v244);
              v247 = v1148 + v244;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v248 = v245 - 1;
              if ( !v248 )
                break;
              v249 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v247);
              LOWORD(v247) = v1099 + v247;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[7] = v249;
              v171 = __CFADD__(v1148, v247);
              v250 = v1148 + v247;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v251 = v248 - 1;
              if ( !v251 )
                break;
              v252 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v250);
              LOWORD(v250) = v1099 + v250;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[8] = v252;
              v171 = __CFADD__(v1148, v250);
              v253 = v1148 + v250;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v254 = v251 - 1;
              if ( !v254 )
                break;
              v255 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v253);
              LOWORD(v253) = v1099 + v253;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[9] = v255;
              v171 = __CFADD__(v1148, v253);
              v256 = v1148 + v253;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v257 = v254 - 1;
              if ( !v257 )
                break;
              v258 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v256);
              LOWORD(v256) = v1099 + v256;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[10] = v258;
              v171 = __CFADD__(v1148, v256);
              v259 = v1148 + v256;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v260 = v257 - 1;
              if ( !v260 )
                break;
              v261 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v259);
              LOWORD(v259) = v1099 + v259;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[11] = v261;
              v171 = __CFADD__(v1148, v259);
              v262 = v1148 + v259;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v263 = v260 - 1;
              if ( !v263 )
                break;
              v264 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v262);
              LOWORD(v262) = v1099 + v262;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[12] = v264;
              v171 = __CFADD__(v1148, v262);
              v265 = v1148 + v262;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v266 = v263 - 1;
              if ( !v266 )
                break;
              v267 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v265);
              LOWORD(v265) = v1099 + v265;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[13] = v267;
              v171 = __CFADD__(v1148, v265);
              v268 = v1148 + v265;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v269 = v266 - 1;
              if ( !v269 )
                break;
              v270 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v268);
              LOWORD(v268) = v1099 + v268;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[14] = v270;
              v171 = __CFADD__(v1148, v268);
              v271 = v1148 + v268;
              BYTE1(v220) += BYTE2(v1110) + v171;
              v272 = v269 - 1;
              if ( !v272 )
                break;
              v273 = *(_BYTE *)(v220 + v227);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v271);
              LOWORD(v271) = v1099 + v271;
              LOBYTE(v220) = BYTE2(v1099) + v171 + v220;
              v222[15] = v273;
              v171 = __CFADD__(v1148, v271);
              v225 = v1148 + v271;
              BYTE1(v220) += BYTE2(v1110) + v171;
              LOWORD(v221) = v272 - 1;
              if ( !(_WORD)v221 )
                break;
              v222 += 16;
            }
            v218 = v1257;
          }
LABEL_380:
          v218 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v221 > dword_DE564 )
          LOWORD(v221) = dword_DE564;
        v16 = (__int16)v221 <= (__int16)v219;
        LOWORD(v221) = v221 - v219;
        if ( v16 )
          goto LABEL_380;
        v222 += v219;
        v225 = __ROL4__(*((_DWORD *)v218 + 3), 16);
        BYTE1(v220) = v225;
        LOWORD(v225) = v218[4];
        LOBYTE(v220) = *((_BYTE *)v218 + 10);
        goto LABEL_361;
      case 3:
LABEL_382:
        v274 = (unsigned __int16 *)&unk_DE56C;
        v1149 = v1110 << 16;
        HIWORD(v275) = 0;
        HIWORD(v276) = 0;
        while ( 1 )
        {
          LOWORD(v275) = v274[1];
          v277 = v274[3];
          v278 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v275 & 0x8000u) == 0 )
            break;
          if ( (__int16)v277 > 0 )
          {
            v279 = (unsigned __int16)-(__int16)v275;
            v281 = __ROL4__(*((_DWORD *)v274 + 3) + v1110 * v279, 16);
            BYTE1(v276) = v281;
            v280 = *((_DWORD *)v274 + 2) + v1099 * v279;
            LOWORD(v281) = v280;
            v282 = v280 >> 8;
            LOBYTE(v276) = BYTE1(v282);
            if ( v277 > dword_DE564 )
              LOWORD(v277) = dword_DE564;
            v275 = (unsigned __int16)v282;
LABEL_392:
            v1258 = v274;
            v283 = dword_DE55C;
            while ( 1 )
            {
              v284 = *(_BYTE *)(v276 + v283);
              if ( v284 )
                *v278 = v284;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v281);
              LOWORD(v281) = v1099 + v281;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v281);
              v285 = v1149 + v281;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v286 = v277 - 1;
              if ( !v286 )
                break;
              v287 = *(_BYTE *)(v276 + v283);
              if ( v287 )
                v278[1] = v287;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v285);
              LOWORD(v285) = v1099 + v285;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v285);
              v288 = v1149 + v285;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v289 = v286 - 1;
              if ( !v289 )
                break;
              v290 = *(_BYTE *)(v276 + v283);
              if ( v290 )
                v278[2] = v290;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v288);
              LOWORD(v288) = v1099 + v288;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v288);
              v291 = v1149 + v288;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v292 = v289 - 1;
              if ( !v292 )
                break;
              v293 = *(_BYTE *)(v276 + v283);
              if ( v293 )
                v278[3] = v293;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v291);
              LOWORD(v291) = v1099 + v291;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v291);
              v294 = v1149 + v291;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v295 = v292 - 1;
              if ( !v295 )
                break;
              v296 = *(_BYTE *)(v276 + v283);
              if ( v296 )
                v278[4] = v296;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v294);
              LOWORD(v294) = v1099 + v294;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v294);
              v297 = v1149 + v294;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v298 = v295 - 1;
              if ( !v298 )
                break;
              v299 = *(_BYTE *)(v276 + v283);
              if ( v299 )
                v278[5] = v299;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v297);
              LOWORD(v297) = v1099 + v297;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v297);
              v300 = v1149 + v297;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v301 = v298 - 1;
              if ( !v301 )
                break;
              v302 = *(_BYTE *)(v276 + v283);
              if ( v302 )
                v278[6] = v302;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v300);
              LOWORD(v300) = v1099 + v300;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v300);
              v303 = v1149 + v300;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v304 = v301 - 1;
              if ( !v304 )
                break;
              v305 = *(_BYTE *)(v276 + v283);
              if ( v305 )
                v278[7] = v305;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v303);
              LOWORD(v303) = v1099 + v303;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v303);
              v306 = v1149 + v303;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v307 = v304 - 1;
              if ( !v307 )
                break;
              v308 = *(_BYTE *)(v276 + v283);
              if ( v308 )
                v278[8] = v308;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v306);
              LOWORD(v306) = v1099 + v306;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v306);
              v309 = v1149 + v306;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v310 = v307 - 1;
              if ( !v310 )
                break;
              v311 = *(_BYTE *)(v276 + v283);
              if ( v311 )
                v278[9] = v311;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v309);
              LOWORD(v309) = v1099 + v309;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v309);
              v312 = v1149 + v309;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v313 = v310 - 1;
              if ( !v313 )
                break;
              v314 = *(_BYTE *)(v276 + v283);
              if ( v314 )
                v278[10] = v314;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v312);
              LOWORD(v312) = v1099 + v312;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v312);
              v315 = v1149 + v312;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v316 = v313 - 1;
              if ( !v316 )
                break;
              v317 = *(_BYTE *)(v276 + v283);
              if ( v317 )
                v278[11] = v317;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v315);
              LOWORD(v315) = v1099 + v315;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v315);
              v318 = v1149 + v315;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v319 = v316 - 1;
              if ( !v319 )
                break;
              v320 = *(_BYTE *)(v276 + v283);
              if ( v320 )
                v278[12] = v320;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v318);
              LOWORD(v318) = v1099 + v318;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v318);
              v321 = v1149 + v318;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v322 = v319 - 1;
              if ( !v322 )
                break;
              v323 = *(_BYTE *)(v276 + v283);
              if ( v323 )
                v278[13] = v323;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v321);
              LOWORD(v321) = v1099 + v321;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v321);
              v324 = v1149 + v321;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v325 = v322 - 1;
              if ( !v325 )
                break;
              v326 = *(_BYTE *)(v276 + v283);
              if ( v326 )
                v278[14] = v326;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v324);
              LOWORD(v324) = v1099 + v324;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v324);
              v327 = v1149 + v324;
              BYTE1(v276) += BYTE2(v1110) + v171;
              v328 = v325 - 1;
              if ( !v328 )
                break;
              v329 = *(_BYTE *)(v276 + v283);
              if ( v329 )
                v278[15] = v329;
              v171 = __CFADD__((_WORD)v1099, (_WORD)v327);
              LOWORD(v327) = v1099 + v327;
              LOBYTE(v276) = BYTE2(v1099) + v171 + v276;
              v171 = __CFADD__(v1149, v327);
              v281 = v1149 + v327;
              BYTE1(v276) += BYTE2(v1110) + v171;
              LOWORD(v277) = v328 - 1;
              if ( !(_WORD)v277 )
                break;
              v278 += 16;
            }
            v274 = v1258;
          }
LABEL_443:
          v274 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v277 > dword_DE564 )
          LOWORD(v277) = dword_DE564;
        v16 = (__int16)v277 <= (__int16)v275;
        LOWORD(v277) = v277 - v275;
        if ( v16 )
          goto LABEL_443;
        v278 += v275;
        v281 = __ROL4__(*((_DWORD *)v274 + 3), 16);
        BYTE1(v276) = v281;
        LOWORD(v281) = v274[4];
        LOBYTE(v276) = *((_BYTE *)v274 + 10);
        goto LABEL_392;
      case 4:
LABEL_445:
        for ( j = &unk_DE56C; ; j += 10 )
        {
          LOWORD(v29) = j[1];
          v331 = (unsigned __int16)j[3];
          v332 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v29 & 0x8000u) == 0 )
            break;
          if ( (__int16)v331 > 0 )
          {
            v333 = v1121 * (unsigned __int16)-(__int16)v29;
            v334 = v333;
            v29 = v333 >> 8;
            v171 = __CFADD__(j[8], v334);
            v335 = j[8] + v334;
            BYTE1(v29) += *((_BYTE *)j + 18) + v171;
            if ( v331 > dword_DE564 )
              LOWORD(v331) = dword_DE564;
            v29 = (unsigned __int16)v29;
            LOBYTE(v29) = byte_E126C;
LABEL_455:
            while ( 1 )
            {
              *v332 = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v335);
              v336 = v1121 + v335;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v337 = v331 - 1;
              if ( !v337 )
                break;
              v332[1] = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v336);
              v338 = v1121 + v336;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v339 = v337 - 1;
              if ( !v339 )
                break;
              v332[2] = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v338);
              v340 = v1121 + v338;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v341 = v339 - 1;
              if ( !v341 )
                break;
              v332[3] = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v340);
              v342 = v1121 + v340;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v343 = v341 - 1;
              if ( !v343 )
                break;
              v332[4] = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v342);
              v344 = v1121 + v342;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v345 = v343 - 1;
              if ( !v345 )
                break;
              v332[5] = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v344);
              v346 = v1121 + v344;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v347 = v345 - 1;
              if ( !v347 )
                break;
              v332[6] = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v346);
              v348 = v1121 + v346;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v349 = v347 - 1;
              if ( !v349 )
                break;
              v332[7] = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v348);
              v350 = v1121 + v348;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v351 = v349 - 1;
              if ( !v351 )
                break;
              v332[8] = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v350);
              v352 = v1121 + v350;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v353 = v351 - 1;
              if ( !v353 )
                break;
              v332[9] = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v352);
              v354 = v1121 + v352;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v355 = v353 - 1;
              if ( !v355 )
                break;
              v332[10] = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v354);
              v356 = v1121 + v354;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v357 = v355 - 1;
              if ( !v357 )
                break;
              v332[11] = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v356);
              v358 = v1121 + v356;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v359 = v357 - 1;
              if ( !v359 )
                break;
              v332[12] = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v358);
              v360 = v1121 + v358;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v361 = v359 - 1;
              if ( !v361 )
                break;
              v332[13] = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v360);
              v362 = v1121 + v360;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v363 = v361 - 1;
              if ( !v363 )
                break;
              v332[14] = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v362);
              v364 = v1121 + v362;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v365 = v363 - 1;
              if ( !v365 )
                break;
              v332[15] = byte_F6EE0[v29];
              v171 = __CFADD__((_WORD)v1121, v364);
              v335 = v1121 + v364;
              BYTE1(v29) += BYTE2(v1121) + v171;
              LOWORD(v331) = v365 - 1;
              if ( !(_WORD)v331 )
                break;
              v332 += 16;
            }
          }
LABEL_472:
          if ( !--v1098 )
            return;
        }
        if ( v331 > dword_DE564 )
          LOWORD(v331) = dword_DE564;
        v16 = (__int16)v331 <= (__int16)v29;
        LOWORD(v331) = v331 - v29;
        if ( v16 )
          goto LABEL_472;
        v332 += v29;
        v29 = (unsigned __int8)byte_E126C;
        v335 = j[8];
        BYTE1(v29) = *((_BYTE *)j + 18);
        goto LABEL_455;
      case 5:
LABEL_474:
        v1259 = (char *)&unk_DE56C;
        v1150 = v1110 << 16;
        v1166 = v1121 << 16;
        HIWORD(v366) = 0;
        HIWORD(v367) = 0;
        while ( 1 )
        {
          v368 = v1259;
          v1259 += 20;
          LOWORD(v366) = *((_WORD *)v368 + 1);
          v369 = *((unsigned __int16 *)v368 + 3);
          v370 = dword_DE560 + v1077;
          v1077 += dword_DE560;
          if ( (v366 & 0x8000u) == 0 )
            break;
          if ( (__int16)v369 > 0 )
          {
            v371 = (unsigned __int16)-(__int16)v366;
            v372 = __ROL4__(*((_DWORD *)v368 + 3) + v1110 * v371, 16);
            BYTE1(v367) = v372;
            LOWORD(v372) = *((_WORD *)v368 + 4) + v1099 * v371;
            v366 = (unsigned int)(*((_DWORD *)v368 + 2) + v1099 * v371) >> 8;
            LOBYTE(v367) = (unsigned int)(*((_DWORD *)v368 + 2) + v1099 * v371) >> 16;
            v373 = __ROL4__(*((_DWORD *)v368 + 4) + v1121 * v371, 16);
            BYTE1(v366) = v373;
            LOWORD(v373) = *((_WORD *)v368 + 3);
            v366 = (unsigned __int16)v366;
            if ( (__int16)v373 > (__int16)dword_DE564 )
              LOWORD(v373) = dword_DE564;
LABEL_484:
            v376 = (_BYTE *)(dword_B8845[v373 & 0xF] + v370);
            v377 = dword_DE55C;
            switch ( v373 & 0xF )
            {
              case 0:
                goto LABEL_485;
              case 1:
                goto LABEL_500;
              case 2:
                goto LABEL_499;
              case 3:
                goto LABEL_498;
              case 4:
                goto LABEL_497;
              case 5:
                goto LABEL_496;
              case 6:
                goto LABEL_495;
              case 7:
                goto LABEL_494;
              case 8:
                goto LABEL_493;
              case 9:
                goto LABEL_492;
              case 0xA:
                goto LABEL_491;
              case 0xB:
                goto LABEL_490;
              case 0xC:
                goto LABEL_489;
              case 0xD:
                goto LABEL_488;
              case 0xE:
                goto LABEL_487;
              case 0xF:
                while ( 1 )
                {
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[1] = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_487:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[2] = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_488:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[3] = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_489:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[4] = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_490:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[5] = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_491:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[6] = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_492:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[7] = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_493:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[8] = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_494:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[9] = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_495:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[10] = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_496:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[11] = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_497:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[12] = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_498:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[13] = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_499:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[14] = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
LABEL_500:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  v376[15] = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
                  v376 += 16;
                  v16 = (__int16)v373 <= 16;
                  LOWORD(v373) = v373 - 16;
                  if ( v16 )
                    break;
LABEL_485:
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v372);
                  LOWORD(v372) = v1099 + v372;
                  LOBYTE(v366) = *(_BYTE *)(v367 + v377);
                  LOBYTE(v367) = BYTE2(v1099) + v171 + v367;
                  v171 = __CFADD__(v1150, v372);
                  v372 += v1150;
                  BYTE1(v367) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1166, v373);
                  v373 += v1166;
                  *v376 = byte_F6EE0[v366];
                  BYTE1(v366) += BYTE2(v1121) + v171;
                }
                break;
            }
          }
LABEL_501:
          if ( !--v1098 )
            return;
        }
        if ( v369 > dword_DE564 )
          LOWORD(v369) = dword_DE564;
        v16 = (__int16)v369 <= (__int16)v366;
        v374 = v369 - v366;
        if ( v16 )
          goto LABEL_501;
        v370 += v366;
        LOBYTE(v367) = v368[10];
        v372 = __ROL4__(*((_DWORD *)v368 + 3), 16);
        v375 = v374;
        BYTE1(v367) = v372;
        LOWORD(v372) = *((_WORD *)v368 + 4);
        v373 = __ROL4__(*((_DWORD *)v368 + 4), 16);
        BYTE1(v366) = v373;
        LOWORD(v373) = v375;
        goto LABEL_484;
      case 6:
LABEL_503:
        v1260 = (char *)&unk_DE56C;
        v1151 = v1110 << 16;
        v1167 = v1121 << 16;
        HIWORD(v378) = 0;
        HIWORD(v379) = 0;
        while ( 1 )
        {
          v380 = v1260;
          v1260 += 20;
          LOWORD(v378) = *((_WORD *)v380 + 1);
          v381 = *((unsigned __int16 *)v380 + 3);
          v382 = dword_DE560 + v1077;
          v1077 += dword_DE560;
          if ( (v378 & 0x8000u) == 0 )
            break;
          if ( (__int16)v381 > 0 )
          {
            v383 = (unsigned __int16)-(__int16)v378;
            v384 = __ROL4__(*((_DWORD *)v380 + 3) + v1110 * v383, 16);
            BYTE1(v379) = v384;
            LOWORD(v384) = *((_WORD *)v380 + 4) + v1099 * v383;
            v378 = (unsigned int)(*((_DWORD *)v380 + 2) + v1099 * v383) >> 8;
            LOBYTE(v379) = (unsigned int)(*((_DWORD *)v380 + 2) + v1099 * v383) >> 16;
            v385 = __ROL4__(*((_DWORD *)v380 + 4) + v1121 * v383, 16);
            BYTE1(v378) = v385;
            LOWORD(v385) = *((_WORD *)v380 + 3);
            v378 = (unsigned __int16)v378;
            if ( (__int16)v385 > (__int16)dword_DE564 )
              LOWORD(v385) = dword_DE564;
LABEL_513:
            v388 = (_BYTE *)(dword_B8845[v385 & 0xF] + v382);
            v389 = dword_DE55C;
            switch ( v385 & 0xF )
            {
              case 0:
                goto LABEL_514;
              case 1:
                goto LABEL_559;
              case 2:
                goto LABEL_556;
              case 3:
                goto LABEL_553;
              case 4:
                goto LABEL_550;
              case 5:
                goto LABEL_547;
              case 6:
                goto LABEL_544;
              case 7:
                goto LABEL_541;
              case 8:
                goto LABEL_538;
              case 9:
                goto LABEL_535;
              case 0xA:
                goto LABEL_532;
              case 0xB:
                goto LABEL_529;
              case 0xC:
                goto LABEL_526;
              case 0xD:
                goto LABEL_523;
              case 0xE:
                goto LABEL_520;
              case 0xF:
                while ( 1 )
                {
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[1] = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_520:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[2] = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_523:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[3] = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_526:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[4] = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_529:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[5] = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_532:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[6] = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_535:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[7] = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_538:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[8] = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_541:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[9] = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_544:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[10] = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_547:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[11] = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_550:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[12] = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_553:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[13] = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_556:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[14] = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
LABEL_559:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    v388[15] = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
                  v388 += 16;
                  v16 = (__int16)v385 <= 16;
                  LOWORD(v385) = v385 - 16;
                  if ( v16 )
                    break;
LABEL_514:
                  LOBYTE(v378) = *(_BYTE *)(v379 + v389);
                  if ( (_BYTE)v378 )
                    *v388 = byte_F6EE0[v378];
                  v171 = __CFADD__((_WORD)v1099, (_WORD)v384);
                  LOWORD(v384) = v1099 + v384;
                  LOBYTE(v379) = BYTE2(v1099) + v171 + v379;
                  v171 = __CFADD__(v1151, v384);
                  v384 += v1151;
                  BYTE1(v379) += BYTE2(v1110) + v171;
                  v171 = __CFADD__(v1167, v385);
                  v385 += v1167;
                  BYTE1(v378) += BYTE2(v1121) + v171;
                }
                break;
            }
          }
LABEL_562:
          if ( !--v1098 )
            return;
        }
        if ( v381 > dword_DE564 )
          LOWORD(v381) = dword_DE564;
        v16 = (__int16)v381 <= (__int16)v378;
        v386 = v381 - v378;
        if ( v16 )
          goto LABEL_562;
        v382 += v378;
        LOBYTE(v379) = v380[10];
        v384 = __ROL4__(*((_DWORD *)v380 + 3), 16);
        v387 = v386;
        BYTE1(v379) = v384;
        LOWORD(v384) = *((_WORD *)v380 + 4);
        v385 = __ROL4__(*((_DWORD *)v380 + 4), 16);
        BYTE1(v378) = v385;
        LOWORD(v385) = v387;
        goto LABEL_513;
      case 7:
      case 11:
LABEL_564:
        v390 = (unsigned __int16 *)&unk_DE56C;
        v1152 = v1110 << 16;
        HIWORD(v391) = 0;
        HIWORD(v392) = 0;
        while ( 1 )
        {
          LOWORD(v391) = v390[1];
          v393 = v390[3];
          v394 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v391 & 0x8000u) == 0 )
            break;
          if ( (__int16)v393 > 0 )
          {
            v395 = (unsigned __int16)-(__int16)v391;
            v397 = __ROL4__(*((_DWORD *)v390 + 3) + v1110 * v395, 16);
            BYTE1(v392) = v397;
            v396 = *((_DWORD *)v390 + 2) + v1099 * v395;
            LOWORD(v397) = v396;
            v398 = v396 >> 8;
            LOBYTE(v392) = BYTE1(v398);
            if ( v393 > dword_DE564 )
              LOWORD(v393) = dword_DE564;
            v391 = (unsigned __int16)v398;
LABEL_574:
            v1261 = v390;
            v399 = dword_DE55C;
            BYTE1(v391) = byte_E126C;
            while ( 1 )
            {
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v397);
              LOWORD(v397) = v1099 + v397;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v397);
              v400 = v1152 + v397;
              *v394 = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v401 = v393 - 1;
              if ( !v401 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v400);
              LOWORD(v400) = v1099 + v400;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v400);
              v402 = v1152 + v400;
              v394[1] = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v403 = v401 - 1;
              if ( !v403 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v402);
              LOWORD(v402) = v1099 + v402;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v402);
              v404 = v1152 + v402;
              v394[2] = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v405 = v403 - 1;
              if ( !v405 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v404);
              LOWORD(v404) = v1099 + v404;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v404);
              v406 = v1152 + v404;
              v394[3] = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v407 = v405 - 1;
              if ( !v407 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v406);
              LOWORD(v406) = v1099 + v406;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v406);
              v408 = v1152 + v406;
              v394[4] = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v409 = v407 - 1;
              if ( !v409 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v408);
              LOWORD(v408) = v1099 + v408;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v408);
              v410 = v1152 + v408;
              v394[5] = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v411 = v409 - 1;
              if ( !v411 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v410);
              LOWORD(v410) = v1099 + v410;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v410);
              v412 = v1152 + v410;
              v394[6] = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v413 = v411 - 1;
              if ( !v413 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v412);
              LOWORD(v412) = v1099 + v412;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v412);
              v414 = v1152 + v412;
              v394[7] = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v415 = v413 - 1;
              if ( !v415 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v414);
              LOWORD(v414) = v1099 + v414;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v414);
              v416 = v1152 + v414;
              v394[8] = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v417 = v415 - 1;
              if ( !v417 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v416);
              LOWORD(v416) = v1099 + v416;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v416);
              v418 = v1152 + v416;
              v394[9] = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v419 = v417 - 1;
              if ( !v419 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v418);
              LOWORD(v418) = v1099 + v418;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v418);
              v420 = v1152 + v418;
              v394[10] = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v421 = v419 - 1;
              if ( !v421 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v420);
              LOWORD(v420) = v1099 + v420;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v420);
              v422 = v1152 + v420;
              v394[11] = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v423 = v421 - 1;
              if ( !v423 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v422);
              LOWORD(v422) = v1099 + v422;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v422);
              v424 = v1152 + v422;
              v394[12] = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v425 = v423 - 1;
              if ( !v425 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v424);
              LOWORD(v424) = v1099 + v424;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v424);
              v426 = v1152 + v424;
              v394[13] = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v427 = v425 - 1;
              if ( !v427 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v426);
              LOWORD(v426) = v1099 + v426;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v426);
              v428 = v1152 + v426;
              v394[14] = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              v429 = v427 - 1;
              if ( !v429 )
                break;
              LOBYTE(v391) = *(_BYTE *)(v392 + v399);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v428);
              LOWORD(v428) = v1099 + v428;
              LOBYTE(v392) = BYTE2(v1099) + v171 + v392;
              v171 = __CFADD__(v1152, v428);
              v397 = v1152 + v428;
              v394[15] = byte_F6EE0[v391];
              BYTE1(v392) += BYTE2(v1110) + v171;
              LOWORD(v393) = v429 - 1;
              if ( !(_WORD)v393 )
                break;
              v394 += 16;
            }
            v390 = v1261;
          }
LABEL_593:
          v390 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v393 > dword_DE564 )
          LOWORD(v393) = dword_DE564;
        v16 = (__int16)v393 <= (__int16)v391;
        LOWORD(v393) = v393 - v391;
        if ( v16 )
          goto LABEL_593;
        v394 += v391;
        v397 = __ROL4__(*((_DWORD *)v390 + 3), 16);
        BYTE1(v392) = v397;
        LOWORD(v397) = v390[4];
        LOBYTE(v392) = *((_BYTE *)v390 + 10);
        goto LABEL_574;
      case 8:
LABEL_595:
        v430 = (unsigned __int16 *)&unk_DE56C;
        v1153 = v1110 << 16;
        HIWORD(v431) = 0;
        HIWORD(v432) = 0;
        while ( 1 )
        {
          LOWORD(v431) = v430[1];
          v433 = v430[3];
          v434 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v431 & 0x8000u) == 0 )
            break;
          if ( (__int16)v433 > 0 )
          {
            v435 = (unsigned __int16)-(__int16)v431;
            v437 = __ROL4__(*((_DWORD *)v430 + 3) + v1110 * v435, 16);
            BYTE1(v432) = v437;
            v436 = *((_DWORD *)v430 + 2) + v1099 * v435;
            LOWORD(v437) = v436;
            v438 = v436 >> 8;
            LOBYTE(v432) = BYTE1(v438);
            if ( v433 > dword_DE564 )
              LOWORD(v433) = dword_DE564;
            v431 = (unsigned __int16)v438;
LABEL_605:
            v1262 = v430;
            v439 = dword_DE55C;
            BYTE1(v431) = byte_E126C;
            while ( 1 )
            {
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v437);
              LOWORD(v437) = v1099 + v437;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                *v434 = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v437);
              v440 = v1153 + v437;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v441 = v433 - 1;
              if ( !v441 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v440);
              LOWORD(v440) = v1099 + v440;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[1] = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v440);
              v442 = v1153 + v440;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v443 = v441 - 1;
              if ( !v443 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v442);
              LOWORD(v442) = v1099 + v442;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[2] = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v442);
              v444 = v1153 + v442;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v445 = v443 - 1;
              if ( !v445 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v444);
              LOWORD(v444) = v1099 + v444;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[3] = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v444);
              v446 = v1153 + v444;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v447 = v445 - 1;
              if ( !v447 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v446);
              LOWORD(v446) = v1099 + v446;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[4] = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v446);
              v448 = v1153 + v446;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v449 = v447 - 1;
              if ( !v449 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v448);
              LOWORD(v448) = v1099 + v448;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[5] = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v448);
              v450 = v1153 + v448;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v451 = v449 - 1;
              if ( !v451 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v450);
              LOWORD(v450) = v1099 + v450;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[6] = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v450);
              v452 = v1153 + v450;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v453 = v451 - 1;
              if ( !v453 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v452);
              LOWORD(v452) = v1099 + v452;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[7] = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v452);
              v454 = v1153 + v452;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v455 = v453 - 1;
              if ( !v455 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v454);
              LOWORD(v454) = v1099 + v454;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[8] = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v454);
              v456 = v1153 + v454;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v457 = v455 - 1;
              if ( !v457 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v456);
              LOWORD(v456) = v1099 + v456;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[9] = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v456);
              v458 = v1153 + v456;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v459 = v457 - 1;
              if ( !v459 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v458);
              LOWORD(v458) = v1099 + v458;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[10] = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v458);
              v460 = v1153 + v458;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v461 = v459 - 1;
              if ( !v461 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v460);
              LOWORD(v460) = v1099 + v460;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[11] = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v460);
              v462 = v1153 + v460;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v463 = v461 - 1;
              if ( !v463 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v462);
              LOWORD(v462) = v1099 + v462;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[12] = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v462);
              v464 = v1153 + v462;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v465 = v463 - 1;
              if ( !v465 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v464);
              LOWORD(v464) = v1099 + v464;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[13] = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v464);
              v466 = v1153 + v464;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v467 = v465 - 1;
              if ( !v467 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v466);
              LOWORD(v466) = v1099 + v466;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[14] = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v466);
              v468 = v1153 + v466;
              BYTE1(v432) += BYTE2(v1110) + v171;
              v469 = v467 - 1;
              if ( !v469 )
                break;
              LOBYTE(v431) = *(_BYTE *)(v432 + v439);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v468);
              LOWORD(v468) = v1099 + v468;
              LOBYTE(v432) = BYTE2(v1099) + v171 + v432;
              if ( (_BYTE)v431 )
                v434[15] = byte_F6EE0[v431];
              v171 = __CFADD__(v1153, v468);
              v437 = v1153 + v468;
              BYTE1(v432) += BYTE2(v1110) + v171;
              LOWORD(v433) = v469 - 1;
              if ( !(_WORD)v433 )
                break;
              v434 += 16;
            }
            v430 = v1262;
          }
LABEL_656:
          v430 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v433 > dword_DE564 )
          LOWORD(v433) = dword_DE564;
        v16 = (__int16)v433 <= (__int16)v431;
        LOWORD(v433) = v433 - v431;
        if ( v16 )
          goto LABEL_656;
        v434 += v431;
        v437 = __ROL4__(*((_DWORD *)v430 + 3), 16);
        BYTE1(v432) = v437;
        LOWORD(v437) = v430[4];
        LOBYTE(v432) = *((_BYTE *)v430 + 10);
        goto LABEL_605;
      case 9:
      case 10:
LABEL_658:
        v470 = (unsigned __int16 *)&unk_DE56C;
        v1154 = v1110 << 16;
        HIWORD(v471) = 0;
        HIWORD(v472) = 0;
        while ( 1 )
        {
          LOWORD(v471) = v470[1];
          v473 = v470[3];
          v474 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v471 & 0x8000u) == 0 )
            break;
          if ( (__int16)v473 > 0 )
          {
            v475 = (unsigned __int16)-(__int16)v471;
            v477 = __ROL4__(*((_DWORD *)v470 + 3) + v1110 * v475, 16);
            BYTE1(v472) = v477;
            v476 = *((_DWORD *)v470 + 2) + v1099 * v475;
            LOWORD(v477) = v476;
            v478 = v476 >> 8;
            LOBYTE(v472) = BYTE1(v478);
            if ( v473 > dword_DE564 )
              LOWORD(v473) = dword_DE564;
            v471 = (unsigned __int16)v478;
LABEL_668:
            v1263 = v470;
            v479 = dword_DE55C;
            while ( 1 )
            {
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v477);
              LOWORD(v477) = v1099 + v477;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = *v474;
                *v474 = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v477);
              v480 = v1154 + v477;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v481 = v473 - 1;
              if ( !v481 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v480);
              LOWORD(v480) = v1099 + v480;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[1];
                v474[1] = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v480);
              v482 = v1154 + v480;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v483 = v481 - 1;
              if ( !v483 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v482);
              LOWORD(v482) = v1099 + v482;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[2];
                v474[2] = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v482);
              v484 = v1154 + v482;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v485 = v483 - 1;
              if ( !v485 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v484);
              LOWORD(v484) = v1099 + v484;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[3];
                v474[3] = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v484);
              v486 = v1154 + v484;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v487 = v485 - 1;
              if ( !v487 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v486);
              LOWORD(v486) = v1099 + v486;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[4];
                v474[4] = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v486);
              v488 = v1154 + v486;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v489 = v487 - 1;
              if ( !v489 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v488);
              LOWORD(v488) = v1099 + v488;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[5];
                v474[5] = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v488);
              v490 = v1154 + v488;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v491 = v489 - 1;
              if ( !v491 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v490);
              LOWORD(v490) = v1099 + v490;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[6];
                v474[6] = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v490);
              v492 = v1154 + v490;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v493 = v491 - 1;
              if ( !v493 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v492);
              LOWORD(v492) = v1099 + v492;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[7];
                v474[7] = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v492);
              v494 = v1154 + v492;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v495 = v493 - 1;
              if ( !v495 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v494);
              LOWORD(v494) = v1099 + v494;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[8];
                v474[8] = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v494);
              v496 = v1154 + v494;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v497 = v495 - 1;
              if ( !v497 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v496);
              LOWORD(v496) = v1099 + v496;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[9];
                v474[9] = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v496);
              v498 = v1154 + v496;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v499 = v497 - 1;
              if ( !v499 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v498);
              LOWORD(v498) = v1099 + v498;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[10];
                v474[10] = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v498);
              v500 = v1154 + v498;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v501 = v499 - 1;
              if ( !v501 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v500);
              LOWORD(v500) = v1099 + v500;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[11];
                v474[11] = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v500);
              v502 = v1154 + v500;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v503 = v501 - 1;
              if ( !v503 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v502);
              LOWORD(v502) = v1099 + v502;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[12];
                v474[12] = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v502);
              v504 = v1154 + v502;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v505 = v503 - 1;
              if ( !v505 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v504);
              LOWORD(v504) = v1099 + v504;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[13];
                v474[13] = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v504);
              v506 = v1154 + v504;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v507 = v505 - 1;
              if ( !v507 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v506);
              LOWORD(v506) = v1099 + v506;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[14];
                v474[14] = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v506);
              v508 = v1154 + v506;
              BYTE1(v472) += BYTE2(v1110) + v171;
              v509 = v507 - 1;
              if ( !v509 )
                break;
              BYTE1(v471) = *(_BYTE *)(v472 + v479);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v508);
              LOWORD(v508) = v1099 + v508;
              LOBYTE(v472) = BYTE2(v1099) + v171 + v472;
              if ( BYTE1(v471) )
              {
                LOBYTE(v471) = v474[15];
                v474[15] = byte_F6EE0[v471];
              }
              v171 = __CFADD__(v1154, v508);
              v477 = v1154 + v508;
              BYTE1(v472) += BYTE2(v1110) + v171;
              LOWORD(v473) = v509 - 1;
              if ( !(_WORD)v473 )
                break;
              v474 += 16;
            }
            v470 = v1263;
          }
LABEL_719:
          v470 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v473 > dword_DE564 )
          LOWORD(v473) = dword_DE564;
        v16 = (__int16)v473 <= (__int16)v471;
        LOWORD(v473) = v473 - v471;
        if ( v16 )
          goto LABEL_719;
        v474 += v471;
        v477 = __ROL4__(*((_DWORD *)v470 + 3), 16);
        BYTE1(v472) = v477;
        LOWORD(v477) = v470[4];
        LOBYTE(v472) = *((_BYTE *)v470 + 10);
        goto LABEL_668;
      case 12:
LABEL_721:
        v510 = (unsigned __int16 *)&unk_DE56C;
        v1155 = v1110 << 16;
        HIWORD(v511) = 0;
        HIWORD(v512) = 0;
        while ( 1 )
        {
          LOWORD(v511) = v510[1];
          v513 = v510[3];
          v514 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v511 & 0x8000u) == 0 )
            break;
          if ( (__int16)v513 > 0 )
          {
            v515 = (unsigned __int16)-(__int16)v511;
            v517 = __ROL4__(*((_DWORD *)v510 + 3) + v1110 * v515, 16);
            BYTE1(v512) = v517;
            v516 = *((_DWORD *)v510 + 2) + v1099 * v515;
            LOWORD(v517) = v516;
            v518 = v516 >> 8;
            LOBYTE(v512) = BYTE1(v518);
            if ( v513 > dword_DE564 )
              LOWORD(v513) = dword_DE564;
            v511 = (unsigned __int16)v518;
LABEL_731:
            v1264 = v510;
            v519 = dword_DE55C;
            LOBYTE(v511) = byte_E126C;
            while ( 1 )
            {
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v517);
              LOWORD(v517) = v1099 + v517;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v517);
              v520 = v1155 + v517;
              *v514 = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v521 = v513 - 1;
              if ( !v521 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v520);
              LOWORD(v520) = v1099 + v520;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v520);
              v522 = v1155 + v520;
              v514[1] = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v523 = v521 - 1;
              if ( !v523 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v522);
              LOWORD(v522) = v1099 + v522;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v522);
              v524 = v1155 + v522;
              v514[2] = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v525 = v523 - 1;
              if ( !v525 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v524);
              LOWORD(v524) = v1099 + v524;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v524);
              v526 = v1155 + v524;
              v514[3] = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v527 = v525 - 1;
              if ( !v527 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v526);
              LOWORD(v526) = v1099 + v526;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v526);
              v528 = v1155 + v526;
              v514[4] = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v529 = v527 - 1;
              if ( !v529 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v528);
              LOWORD(v528) = v1099 + v528;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v528);
              v530 = v1155 + v528;
              v514[5] = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v531 = v529 - 1;
              if ( !v531 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v530);
              LOWORD(v530) = v1099 + v530;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v530);
              v532 = v1155 + v530;
              v514[6] = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v533 = v531 - 1;
              if ( !v533 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v532);
              LOWORD(v532) = v1099 + v532;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v532);
              v534 = v1155 + v532;
              v514[7] = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v535 = v533 - 1;
              if ( !v535 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v534);
              LOWORD(v534) = v1099 + v534;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v534);
              v536 = v1155 + v534;
              v514[8] = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v537 = v535 - 1;
              if ( !v537 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v536);
              LOWORD(v536) = v1099 + v536;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v536);
              v538 = v1155 + v536;
              v514[9] = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v539 = v537 - 1;
              if ( !v539 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v538);
              LOWORD(v538) = v1099 + v538;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v538);
              v540 = v1155 + v538;
              v514[10] = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v541 = v539 - 1;
              if ( !v541 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v540);
              LOWORD(v540) = v1099 + v540;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v540);
              v542 = v1155 + v540;
              v514[11] = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v543 = v541 - 1;
              if ( !v543 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v542);
              LOWORD(v542) = v1099 + v542;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v542);
              v544 = v1155 + v542;
              v514[12] = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v545 = v543 - 1;
              if ( !v545 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v544);
              LOWORD(v544) = v1099 + v544;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v544);
              v546 = v1155 + v544;
              v514[13] = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v547 = v545 - 1;
              if ( !v547 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v546);
              LOWORD(v546) = v1099 + v546;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v546);
              v548 = v1155 + v546;
              v514[14] = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              v549 = v547 - 1;
              if ( !v549 )
                break;
              BYTE1(v511) = *(_BYTE *)(v512 + v519);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v548);
              LOWORD(v548) = v1099 + v548;
              LOBYTE(v512) = BYTE2(v1099) + v171 + v512;
              v171 = __CFADD__(v1155, v548);
              v517 = v1155 + v548;
              v514[15] = byte_FAEE0[v511];
              BYTE1(v512) += BYTE2(v1110) + v171;
              LOWORD(v513) = v549 - 1;
              if ( !(_WORD)v513 )
                break;
              v514 += 16;
            }
            v510 = v1264;
          }
LABEL_750:
          v510 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v513 > dword_DE564 )
          LOWORD(v513) = dword_DE564;
        v16 = (__int16)v513 <= (__int16)v511;
        LOWORD(v513) = v513 - v511;
        if ( v16 )
          goto LABEL_750;
        v514 += v511;
        v517 = __ROL4__(*((_DWORD *)v510 + 3), 16);
        BYTE1(v512) = v517;
        LOWORD(v517) = v510[4];
        LOBYTE(v512) = *((_BYTE *)v510 + 10);
        goto LABEL_731;
      case 13:
LABEL_752:
        v550 = (unsigned __int16 *)&unk_DE56C;
        v1156 = v1110 << 16;
        HIWORD(v551) = 0;
        HIWORD(v552) = 0;
        while ( 1 )
        {
          LOWORD(v551) = v550[1];
          v553 = v550[3];
          v554 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v551 & 0x8000u) == 0 )
            break;
          if ( (__int16)v553 > 0 )
          {
            v555 = (unsigned __int16)-(__int16)v551;
            v557 = __ROL4__(*((_DWORD *)v550 + 3) + v1110 * v555, 16);
            BYTE1(v552) = v557;
            v556 = *((_DWORD *)v550 + 2) + v1099 * v555;
            LOWORD(v557) = v556;
            v558 = v556 >> 8;
            LOBYTE(v552) = BYTE1(v558);
            if ( v553 > dword_DE564 )
              LOWORD(v553) = dword_DE564;
            v551 = (unsigned __int16)v558;
LABEL_762:
            v1265 = v550;
            v559 = dword_DE55C;
            BYTE1(v551) = byte_E126C;
            while ( 1 )
            {
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v557);
              LOWORD(v557) = v1099 + v557;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v557);
              v560 = v1156 + v557;
              *v554 = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v561 = v553 - 1;
              if ( !v561 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v560);
              LOWORD(v560) = v1099 + v560;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v560);
              v562 = v1156 + v560;
              v554[1] = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v563 = v561 - 1;
              if ( !v563 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v562);
              LOWORD(v562) = v1099 + v562;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v562);
              v564 = v1156 + v562;
              v554[2] = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v565 = v563 - 1;
              if ( !v565 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v564);
              LOWORD(v564) = v1099 + v564;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v564);
              v566 = v1156 + v564;
              v554[3] = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v567 = v565 - 1;
              if ( !v567 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v566);
              LOWORD(v566) = v1099 + v566;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v566);
              v568 = v1156 + v566;
              v554[4] = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v569 = v567 - 1;
              if ( !v569 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v568);
              LOWORD(v568) = v1099 + v568;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v568);
              v570 = v1156 + v568;
              v554[5] = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v571 = v569 - 1;
              if ( !v571 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v570);
              LOWORD(v570) = v1099 + v570;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v570);
              v572 = v1156 + v570;
              v554[6] = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v573 = v571 - 1;
              if ( !v573 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v572);
              LOWORD(v572) = v1099 + v572;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v572);
              v574 = v1156 + v572;
              v554[7] = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v575 = v573 - 1;
              if ( !v575 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v574);
              LOWORD(v574) = v1099 + v574;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v574);
              v576 = v1156 + v574;
              v554[8] = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v577 = v575 - 1;
              if ( !v577 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v576);
              LOWORD(v576) = v1099 + v576;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v576);
              v578 = v1156 + v576;
              v554[9] = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v579 = v577 - 1;
              if ( !v579 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v578);
              LOWORD(v578) = v1099 + v578;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v578);
              v580 = v1156 + v578;
              v554[10] = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v581 = v579 - 1;
              if ( !v581 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v580);
              LOWORD(v580) = v1099 + v580;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v580);
              v582 = v1156 + v580;
              v554[11] = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v583 = v581 - 1;
              if ( !v583 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v582);
              LOWORD(v582) = v1099 + v582;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v582);
              v584 = v1156 + v582;
              v554[12] = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v585 = v583 - 1;
              if ( !v585 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v584);
              LOWORD(v584) = v1099 + v584;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v584);
              v586 = v1156 + v584;
              v554[13] = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v587 = v585 - 1;
              if ( !v587 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v586);
              LOWORD(v586) = v1099 + v586;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v586);
              v588 = v1156 + v586;
              v554[14] = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              v589 = v587 - 1;
              if ( !v589 )
                break;
              LOBYTE(v551) = *(_BYTE *)(v552 + v559);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v588);
              LOWORD(v588) = v1099 + v588;
              LOBYTE(v552) = BYTE2(v1099) + v171 + v552;
              v171 = __CFADD__(v1156, v588);
              v557 = v1156 + v588;
              v554[15] = byte_FAEE0[v551];
              BYTE1(v552) += BYTE2(v1110) + v171;
              LOWORD(v553) = v589 - 1;
              if ( !(_WORD)v553 )
                break;
              v554 += 16;
            }
            v550 = v1265;
          }
LABEL_781:
          v550 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v553 > dword_DE564 )
          LOWORD(v553) = dword_DE564;
        v16 = (__int16)v553 <= (__int16)v551;
        LOWORD(v553) = v553 - v551;
        if ( v16 )
          goto LABEL_781;
        v554 += v551;
        v557 = __ROL4__(*((_DWORD *)v550 + 3), 16);
        BYTE1(v552) = v557;
        LOWORD(v557) = v550[4];
        LOBYTE(v552) = *((_BYTE *)v550 + 10);
        goto LABEL_762;
      case 14:
LABEL_783:
        v590 = (unsigned __int16 *)&unk_DE56C;
        v591 = (_BYTE *)v1077;
        HIWORD(v592) = 0;
        BYTE1(v592) = byte_E126C;
        HIWORD(v593) = 0;
        while ( 1 )
        {
          LOWORD(v593) = v590[1];
          v594 = v590[3];
          v591 += dword_DE560;
          if ( (v593 & 0x8000u) == 0 )
            break;
          if ( (__int16)v594 > 0 )
          {
            if ( v594 > dword_DE564 )
              LOWORD(v594) = dword_DE564;
LABEL_793:
            for ( k = v591; ; k += 16 )
            {
              LOBYTE(v592) = *k;
              *k = byte_FAEE0[v592];
              v596 = v594 - 1;
              if ( !v596 )
                break;
              LOBYTE(v592) = k[1];
              k[1] = byte_FAEE0[v592];
              v597 = v596 - 1;
              if ( !v597 )
                break;
              LOBYTE(v592) = k[2];
              k[2] = byte_FAEE0[v592];
              v598 = v597 - 1;
              if ( !v598 )
                break;
              LOBYTE(v592) = k[3];
              k[3] = byte_FAEE0[v592];
              v599 = v598 - 1;
              if ( !v599 )
                break;
              LOBYTE(v592) = k[4];
              k[4] = byte_FAEE0[v592];
              v600 = v599 - 1;
              if ( !v600 )
                break;
              LOBYTE(v592) = k[5];
              k[5] = byte_FAEE0[v592];
              v601 = v600 - 1;
              if ( !v601 )
                break;
              LOBYTE(v592) = k[6];
              k[6] = byte_FAEE0[v592];
              v602 = v601 - 1;
              if ( !v602 )
                break;
              LOBYTE(v592) = k[7];
              k[7] = byte_FAEE0[v592];
              v603 = v602 - 1;
              if ( !v603 )
                break;
              LOBYTE(v592) = k[8];
              k[8] = byte_FAEE0[v592];
              v604 = v603 - 1;
              if ( !v604 )
                break;
              LOBYTE(v592) = k[9];
              k[9] = byte_FAEE0[v592];
              v605 = v604 - 1;
              if ( !v605 )
                break;
              LOBYTE(v592) = k[10];
              k[10] = byte_FAEE0[v592];
              v606 = v605 - 1;
              if ( !v606 )
                break;
              LOBYTE(v592) = k[11];
              k[11] = byte_FAEE0[v592];
              v607 = v606 - 1;
              if ( !v607 )
                break;
              LOBYTE(v592) = k[12];
              k[12] = byte_FAEE0[v592];
              v608 = v607 - 1;
              if ( !v608 )
                break;
              LOBYTE(v592) = k[13];
              k[13] = byte_FAEE0[v592];
              v609 = v608 - 1;
              if ( !v609 )
                break;
              LOBYTE(v592) = k[14];
              k[14] = byte_FAEE0[v592];
              v610 = v609 - 1;
              if ( !v610 )
                break;
              LOBYTE(v592) = k[15];
              k[15] = byte_FAEE0[v592];
              LOWORD(v594) = v610 - 1;
              if ( !(_WORD)v594 )
                break;
            }
          }
LABEL_810:
          v590 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v594 > dword_DE564 )
          LOWORD(v594) = dword_DE564;
        v16 = (__int16)v594 <= (__int16)v593;
        LOWORD(v594) = v594 - v593;
        if ( v16 )
          goto LABEL_810;
        k = &v591[v593];
        goto LABEL_793;
      case 15:
LABEL_812:
        v611 = (unsigned __int16 *)&unk_DE56C;
        v612 = (_BYTE *)v1077;
        v613 = (unsigned __int8)byte_E126C;
        HIWORD(v614) = 0;
        while ( 1 )
        {
          LOWORD(v614) = v611[1];
          v615 = v611[3];
          v612 += dword_DE560;
          if ( (v614 & 0x8000u) == 0 )
            break;
          if ( (__int16)v615 > 0 )
          {
            if ( v615 > dword_DE564 )
              LOWORD(v615) = dword_DE564;
LABEL_822:
            for ( m = v612; ; m += 16 )
            {
              BYTE1(v613) = *m;
              *m = byte_FAEE0[v613];
              v617 = v615 - 1;
              if ( !v617 )
                break;
              BYTE1(v613) = m[1];
              m[1] = byte_FAEE0[v613];
              v618 = v617 - 1;
              if ( !v618 )
                break;
              BYTE1(v613) = m[2];
              m[2] = byte_FAEE0[v613];
              v619 = v618 - 1;
              if ( !v619 )
                break;
              BYTE1(v613) = m[3];
              m[3] = byte_FAEE0[v613];
              v620 = v619 - 1;
              if ( !v620 )
                break;
              BYTE1(v613) = m[4];
              m[4] = byte_FAEE0[v613];
              v621 = v620 - 1;
              if ( !v621 )
                break;
              BYTE1(v613) = m[5];
              m[5] = byte_FAEE0[v613];
              v622 = v621 - 1;
              if ( !v622 )
                break;
              BYTE1(v613) = m[6];
              m[6] = byte_FAEE0[v613];
              v623 = v622 - 1;
              if ( !v623 )
                break;
              BYTE1(v613) = m[7];
              m[7] = byte_FAEE0[v613];
              v624 = v623 - 1;
              if ( !v624 )
                break;
              BYTE1(v613) = m[8];
              m[8] = byte_FAEE0[v613];
              v625 = v624 - 1;
              if ( !v625 )
                break;
              BYTE1(v613) = m[9];
              m[9] = byte_FAEE0[v613];
              v626 = v625 - 1;
              if ( !v626 )
                break;
              BYTE1(v613) = m[10];
              m[10] = byte_FAEE0[v613];
              v627 = v626 - 1;
              if ( !v627 )
                break;
              BYTE1(v613) = m[11];
              m[11] = byte_FAEE0[v613];
              v628 = v627 - 1;
              if ( !v628 )
                break;
              BYTE1(v613) = m[12];
              m[12] = byte_FAEE0[v613];
              v629 = v628 - 1;
              if ( !v629 )
                break;
              BYTE1(v613) = m[13];
              m[13] = byte_FAEE0[v613];
              v630 = v629 - 1;
              if ( !v630 )
                break;
              BYTE1(v613) = m[14];
              m[14] = byte_FAEE0[v613];
              v631 = v630 - 1;
              if ( !v631 )
                break;
              BYTE1(v613) = m[15];
              m[15] = byte_FAEE0[v613];
              LOWORD(v615) = v631 - 1;
              if ( !(_WORD)v615 )
                break;
            }
          }
LABEL_839:
          v611 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v615 > dword_DE564 )
          LOWORD(v615) = dword_DE564;
        v16 = (__int16)v615 <= (__int16)v614;
        LOWORD(v615) = v615 - v614;
        if ( v16 )
          goto LABEL_839;
        m = &v612[v614];
        goto LABEL_822;
      case 16:
LABEL_841:
        v632 = (unsigned __int16 *)&unk_DE56C;
        HIWORD(v633) = 0;
        while ( 1 )
        {
          LOWORD(v29) = v632[1];
          v634 = v632[3];
          v635 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v29 & 0x8000u) == 0 )
            break;
          if ( (__int16)v634 > 0 )
          {
            v636 = v1121 * (unsigned __int16)-(__int16)v29;
            v637 = v636;
            v29 = v636 >> 8;
            v171 = __CFADD__(v632[8], v637);
            v638 = v632[8] + v637;
            BYTE1(v29) += *((_BYTE *)v632 + 18) + v171;
            if ( v634 > dword_DE564 )
              LOWORD(v634) = dword_DE564;
            v29 = (unsigned __int16)v29;
            LOBYTE(v29) = byte_E126C;
LABEL_851:
            while ( 1 )
            {
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = *v635;
              *v635 = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v638);
              v639 = v1121 + v638;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v640 = v634 - 1;
              if ( !v640 )
                break;
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = v635[1];
              v635[1] = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v639);
              v641 = v1121 + v639;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v642 = v640 - 1;
              if ( !v642 )
                break;
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = v635[2];
              v635[2] = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v641);
              v643 = v1121 + v641;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v644 = v642 - 1;
              if ( !v644 )
                break;
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = v635[3];
              v635[3] = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v643);
              v645 = v1121 + v643;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v646 = v644 - 1;
              if ( !v646 )
                break;
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = v635[4];
              v635[4] = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v645);
              v647 = v1121 + v645;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v648 = v646 - 1;
              if ( !v648 )
                break;
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = v635[5];
              v635[5] = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v647);
              v649 = v1121 + v647;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v650 = v648 - 1;
              if ( !v650 )
                break;
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = v635[6];
              v635[6] = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v649);
              v651 = v1121 + v649;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v652 = v650 - 1;
              if ( !v652 )
                break;
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = v635[7];
              v635[7] = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v651);
              v653 = v1121 + v651;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v654 = v652 - 1;
              if ( !v654 )
                break;
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = v635[8];
              v635[8] = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v653);
              v655 = v1121 + v653;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v656 = v654 - 1;
              if ( !v656 )
                break;
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = v635[9];
              v635[9] = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v655);
              v657 = v1121 + v655;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v658 = v656 - 1;
              if ( !v658 )
                break;
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = v635[10];
              v635[10] = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v657);
              v659 = v1121 + v657;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v660 = v658 - 1;
              if ( !v660 )
                break;
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = v635[11];
              v635[11] = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v659);
              v661 = v1121 + v659;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v662 = v660 - 1;
              if ( !v662 )
                break;
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = v635[12];
              v635[12] = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v661);
              v663 = v1121 + v661;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v664 = v662 - 1;
              if ( !v664 )
                break;
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = v635[13];
              v635[13] = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v663);
              v665 = v1121 + v663;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v666 = v664 - 1;
              if ( !v666 )
                break;
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = v635[14];
              v635[14] = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v665);
              v667 = v1121 + v665;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v668 = v666 - 1;
              if ( !v668 )
                break;
              BYTE1(v633) = byte_F6EE0[v29];
              LOBYTE(v633) = v635[15];
              v635[15] = byte_FAEE0[v633];
              v171 = __CFADD__((_WORD)v1121, v667);
              v638 = v1121 + v667;
              BYTE1(v29) += BYTE2(v1121) + v171;
              LOWORD(v634) = v668 - 1;
              if ( !(_WORD)v634 )
                break;
              v635 += 16;
            }
          }
LABEL_868:
          v632 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v634 > dword_DE564 )
          LOWORD(v634) = dword_DE564;
        v16 = (__int16)v634 <= (__int16)v29;
        LOWORD(v634) = v634 - v29;
        if ( v16 )
          goto LABEL_868;
        v635 += v29;
        v29 = (unsigned __int8)byte_E126C;
        v638 = v632[8];
        BYTE1(v29) = *((_BYTE *)v632 + 18);
        goto LABEL_851;
      case 17:
LABEL_870:
        v669 = (unsigned __int16 *)&unk_DE56C;
        HIWORD(v670) = 0;
        while ( 1 )
        {
          LOWORD(v29) = v669[1];
          v671 = v669[3];
          v672 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v29 & 0x8000u) == 0 )
            break;
          if ( (__int16)v671 > 0 )
          {
            v673 = v1121 * (unsigned __int16)-(__int16)v29;
            v674 = v673;
            v29 = v673 >> 8;
            v171 = __CFADD__(v669[8], v674);
            v675 = v669[8] + v674;
            BYTE1(v29) += *((_BYTE *)v669 + 18) + v171;
            if ( v671 > dword_DE564 )
              LOWORD(v671) = dword_DE564;
            v29 = (unsigned __int16)v29;
            LOBYTE(v29) = byte_E126C;
LABEL_880:
            while ( 1 )
            {
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = *v672;
              *v672 = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v675);
              v676 = v1121 + v675;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v677 = v671 - 1;
              if ( !v677 )
                break;
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = v672[1];
              v672[1] = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v676);
              v678 = v1121 + v676;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v679 = v677 - 1;
              if ( !v679 )
                break;
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = v672[2];
              v672[2] = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v678);
              v680 = v1121 + v678;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v681 = v679 - 1;
              if ( !v681 )
                break;
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = v672[3];
              v672[3] = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v680);
              v682 = v1121 + v680;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v683 = v681 - 1;
              if ( !v683 )
                break;
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = v672[4];
              v672[4] = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v682);
              v684 = v1121 + v682;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v685 = v683 - 1;
              if ( !v685 )
                break;
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = v672[5];
              v672[5] = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v684);
              v686 = v1121 + v684;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v687 = v685 - 1;
              if ( !v687 )
                break;
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = v672[6];
              v672[6] = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v686);
              v688 = v1121 + v686;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v689 = v687 - 1;
              if ( !v689 )
                break;
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = v672[7];
              v672[7] = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v688);
              v690 = v1121 + v688;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v691 = v689 - 1;
              if ( !v691 )
                break;
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = v672[8];
              v672[8] = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v690);
              v692 = v1121 + v690;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v693 = v691 - 1;
              if ( !v693 )
                break;
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = v672[9];
              v672[9] = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v692);
              v694 = v1121 + v692;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v695 = v693 - 1;
              if ( !v695 )
                break;
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = v672[10];
              v672[10] = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v694);
              v696 = v1121 + v694;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v697 = v695 - 1;
              if ( !v697 )
                break;
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = v672[11];
              v672[11] = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v696);
              v698 = v1121 + v696;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v699 = v697 - 1;
              if ( !v699 )
                break;
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = v672[12];
              v672[12] = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v698);
              v700 = v1121 + v698;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v701 = v699 - 1;
              if ( !v701 )
                break;
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = v672[13];
              v672[13] = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v700);
              v702 = v1121 + v700;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v703 = v701 - 1;
              if ( !v703 )
                break;
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = v672[14];
              v672[14] = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v702);
              v704 = v1121 + v702;
              BYTE1(v29) += BYTE2(v1121) + v171;
              v705 = v703 - 1;
              if ( !v705 )
                break;
              LOBYTE(v670) = byte_F6EE0[v29];
              BYTE1(v670) = v672[15];
              v672[15] = byte_FAEE0[v670];
              v171 = __CFADD__((_WORD)v1121, v704);
              v675 = v1121 + v704;
              BYTE1(v29) += BYTE2(v1121) + v171;
              LOWORD(v671) = v705 - 1;
              if ( !(_WORD)v671 )
                break;
              v672 += 16;
            }
          }
LABEL_897:
          v669 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v671 > dword_DE564 )
          LOWORD(v671) = dword_DE564;
        v16 = (__int16)v671 <= (__int16)v29;
        LOWORD(v671) = v671 - v29;
        if ( v16 )
          goto LABEL_897;
        v672 += v29;
        v29 = (unsigned __int8)byte_E126C;
        v675 = v669[8];
        BYTE1(v29) = *((_BYTE *)v669 + 18);
        goto LABEL_880;
      case 18:
LABEL_899:
        v706 = (unsigned __int16 *)&unk_DE56C;
        v1157 = v1110 << 16;
        HIWORD(v707) = 0;
        HIWORD(v708) = 0;
        while ( 1 )
        {
          LOWORD(v707) = v706[1];
          v709 = v706[3];
          v710 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v707 & 0x8000u) == 0 )
            break;
          if ( (__int16)v709 > 0 )
          {
            v711 = (unsigned __int16)-(__int16)v707;
            v713 = __ROL4__(*((_DWORD *)v706 + 3) + v1110 * v711, 16);
            BYTE1(v708) = v713;
            v712 = *((_DWORD *)v706 + 2) + v1099 * v711;
            LOWORD(v713) = v712;
            v714 = v712 >> 8;
            LOBYTE(v708) = BYTE1(v714);
            if ( v709 > dword_DE564 )
              LOWORD(v709) = dword_DE564;
            v707 = (unsigned __int16)v714;
LABEL_909:
            v1266 = v706;
            v715 = dword_DE55C;
            while ( 1 )
            {
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v713);
              LOWORD(v713) = v1099 + v713;
              LOBYTE(v707) = *v710;
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v713);
              v716 = v1157 + v713;
              *v710 = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v717 = v709 - 1;
              if ( !v717 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v716);
              LOWORD(v716) = v1099 + v716;
              LOBYTE(v707) = v710[1];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v716);
              v718 = v1157 + v716;
              v710[1] = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v719 = v717 - 1;
              if ( !v719 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v718);
              LOWORD(v718) = v1099 + v718;
              LOBYTE(v707) = v710[2];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v718);
              v720 = v1157 + v718;
              v710[2] = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v721 = v719 - 1;
              if ( !v721 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v720);
              LOWORD(v720) = v1099 + v720;
              LOBYTE(v707) = v710[3];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v720);
              v722 = v1157 + v720;
              v710[3] = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v723 = v721 - 1;
              if ( !v723 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v722);
              LOWORD(v722) = v1099 + v722;
              LOBYTE(v707) = v710[4];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v722);
              v724 = v1157 + v722;
              v710[4] = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v725 = v723 - 1;
              if ( !v725 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v724);
              LOWORD(v724) = v1099 + v724;
              LOBYTE(v707) = v710[5];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v724);
              v726 = v1157 + v724;
              v710[5] = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v727 = v725 - 1;
              if ( !v727 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v726);
              LOWORD(v726) = v1099 + v726;
              LOBYTE(v707) = v710[6];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v726);
              v728 = v1157 + v726;
              v710[6] = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v729 = v727 - 1;
              if ( !v729 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v728);
              LOWORD(v728) = v1099 + v728;
              LOBYTE(v707) = v710[7];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v728);
              v730 = v1157 + v728;
              v710[7] = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v731 = v729 - 1;
              if ( !v731 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v730);
              LOWORD(v730) = v1099 + v730;
              LOBYTE(v707) = v710[8];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v730);
              v732 = v1157 + v730;
              v710[8] = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v733 = v731 - 1;
              if ( !v733 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v732);
              LOWORD(v732) = v1099 + v732;
              LOBYTE(v707) = v710[9];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v732);
              v734 = v1157 + v732;
              v710[9] = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v735 = v733 - 1;
              if ( !v735 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v734);
              LOWORD(v734) = v1099 + v734;
              LOBYTE(v707) = v710[10];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v734);
              v736 = v1157 + v734;
              v710[10] = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v737 = v735 - 1;
              if ( !v737 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v736);
              LOWORD(v736) = v1099 + v736;
              LOBYTE(v707) = v710[11];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v736);
              v738 = v1157 + v736;
              v710[11] = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v739 = v737 - 1;
              if ( !v739 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v738);
              LOWORD(v738) = v1099 + v738;
              LOBYTE(v707) = v710[12];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v738);
              v740 = v1157 + v738;
              v710[12] = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v741 = v739 - 1;
              if ( !v741 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v740);
              LOWORD(v740) = v1099 + v740;
              LOBYTE(v707) = v710[13];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v740);
              v742 = v1157 + v740;
              v710[13] = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v743 = v741 - 1;
              if ( !v743 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v742);
              LOWORD(v742) = v1099 + v742;
              LOBYTE(v707) = v710[14];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v742);
              v744 = v1157 + v742;
              v710[14] = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              v745 = v743 - 1;
              if ( !v745 )
                break;
              BYTE1(v707) = *(_BYTE *)(v708 + v715);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v744);
              LOWORD(v744) = v1099 + v744;
              LOBYTE(v707) = v710[15];
              LOBYTE(v708) = BYTE2(v1099) + v171 + v708;
              v171 = __CFADD__(v1157, v744);
              v713 = v1157 + v744;
              v710[15] = byte_FAEE0[v707];
              BYTE1(v708) += BYTE2(v1110) + v171;
              LOWORD(v709) = v745 - 1;
              if ( !(_WORD)v709 )
                break;
              v710 += 16;
            }
            v706 = v1266;
          }
LABEL_928:
          v706 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v709 > dword_DE564 )
          LOWORD(v709) = dword_DE564;
        v16 = (__int16)v709 <= (__int16)v707;
        LOWORD(v709) = v709 - v707;
        if ( v16 )
          goto LABEL_928;
        v710 += v707;
        v713 = __ROL4__(*((_DWORD *)v706 + 3), 16);
        BYTE1(v708) = v713;
        LOWORD(v713) = v706[4];
        LOBYTE(v708) = *((_BYTE *)v706 + 10);
        goto LABEL_909;
      case 19:
LABEL_930:
        v746 = (unsigned __int16 *)&unk_DE56C;
        v1158 = v1110 << 16;
        HIWORD(v747) = 0;
        HIWORD(v748) = 0;
        while ( 1 )
        {
          LOWORD(v747) = v746[1];
          v749 = v746[3];
          v750 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v747 & 0x8000u) == 0 )
            break;
          if ( (__int16)v749 > 0 )
          {
            v751 = (unsigned __int16)-(__int16)v747;
            v753 = __ROL4__(*((_DWORD *)v746 + 3) + v1110 * v751, 16);
            BYTE1(v748) = v753;
            v752 = *((_DWORD *)v746 + 2) + v1099 * v751;
            LOWORD(v753) = v752;
            v754 = v752 >> 8;
            LOBYTE(v748) = BYTE1(v754);
            if ( v749 > dword_DE564 )
              LOWORD(v749) = dword_DE564;
            v747 = (unsigned __int16)v754;
LABEL_940:
            v1267 = v746;
            v755 = dword_DE55C;
            while ( 1 )
            {
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v753);
              LOWORD(v753) = v1099 + v753;
              BYTE1(v747) = *v750;
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v753);
              v756 = v1158 + v753;
              *v750 = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v757 = v749 - 1;
              if ( !v757 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v756);
              LOWORD(v756) = v1099 + v756;
              BYTE1(v747) = v750[1];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v756);
              v758 = v1158 + v756;
              v750[1] = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v759 = v757 - 1;
              if ( !v759 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v758);
              LOWORD(v758) = v1099 + v758;
              BYTE1(v747) = v750[2];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v758);
              v760 = v1158 + v758;
              v750[2] = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v761 = v759 - 1;
              if ( !v761 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v760);
              LOWORD(v760) = v1099 + v760;
              BYTE1(v747) = v750[3];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v760);
              v762 = v1158 + v760;
              v750[3] = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v763 = v761 - 1;
              if ( !v763 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v762);
              LOWORD(v762) = v1099 + v762;
              BYTE1(v747) = v750[4];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v762);
              v764 = v1158 + v762;
              v750[4] = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v765 = v763 - 1;
              if ( !v765 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v764);
              LOWORD(v764) = v1099 + v764;
              BYTE1(v747) = v750[5];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v764);
              v766 = v1158 + v764;
              v750[5] = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v767 = v765 - 1;
              if ( !v767 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v766);
              LOWORD(v766) = v1099 + v766;
              BYTE1(v747) = v750[6];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v766);
              v768 = v1158 + v766;
              v750[6] = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v769 = v767 - 1;
              if ( !v769 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v768);
              LOWORD(v768) = v1099 + v768;
              BYTE1(v747) = v750[7];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v768);
              v770 = v1158 + v768;
              v750[7] = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v771 = v769 - 1;
              if ( !v771 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v770);
              LOWORD(v770) = v1099 + v770;
              BYTE1(v747) = v750[8];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v770);
              v772 = v1158 + v770;
              v750[8] = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v773 = v771 - 1;
              if ( !v773 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v772);
              LOWORD(v772) = v1099 + v772;
              BYTE1(v747) = v750[9];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v772);
              v774 = v1158 + v772;
              v750[9] = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v775 = v773 - 1;
              if ( !v775 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v774);
              LOWORD(v774) = v1099 + v774;
              BYTE1(v747) = v750[10];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v774);
              v776 = v1158 + v774;
              v750[10] = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v777 = v775 - 1;
              if ( !v777 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v776);
              LOWORD(v776) = v1099 + v776;
              BYTE1(v747) = v750[11];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v776);
              v778 = v1158 + v776;
              v750[11] = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v779 = v777 - 1;
              if ( !v779 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v778);
              LOWORD(v778) = v1099 + v778;
              BYTE1(v747) = v750[12];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v778);
              v780 = v1158 + v778;
              v750[12] = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v781 = v779 - 1;
              if ( !v781 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v780);
              LOWORD(v780) = v1099 + v780;
              BYTE1(v747) = v750[13];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v780);
              v782 = v1158 + v780;
              v750[13] = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v783 = v781 - 1;
              if ( !v783 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v782);
              LOWORD(v782) = v1099 + v782;
              BYTE1(v747) = v750[14];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v782);
              v784 = v1158 + v782;
              v750[14] = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              v785 = v783 - 1;
              if ( !v785 )
                break;
              LOBYTE(v747) = *(_BYTE *)(v748 + v755);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v784);
              LOWORD(v784) = v1099 + v784;
              BYTE1(v747) = v750[15];
              LOBYTE(v748) = BYTE2(v1099) + v171 + v748;
              v171 = __CFADD__(v1158, v784);
              v753 = v1158 + v784;
              v750[15] = byte_FAEE0[v747];
              BYTE1(v748) += BYTE2(v1110) + v171;
              LOWORD(v749) = v785 - 1;
              if ( !(_WORD)v749 )
                break;
              v750 += 16;
            }
            v746 = v1267;
          }
LABEL_959:
          v746 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v749 > dword_DE564 )
          LOWORD(v749) = dword_DE564;
        v16 = (__int16)v749 <= (__int16)v747;
        LOWORD(v749) = v749 - v747;
        if ( v16 )
          goto LABEL_959;
        v750 += v747;
        v753 = __ROL4__(*((_DWORD *)v746 + 3), 16);
        BYTE1(v748) = v753;
        LOWORD(v753) = v746[4];
        LOBYTE(v748) = *((_BYTE *)v746 + 10);
        goto LABEL_940;
      case 20:
LABEL_961:
        v786 = (unsigned __int16 *)&unk_DE56C;
        v1159 = v1110 << 16;
        v1168 = v1121 << 16;
        HIWORD(v787) = 0;
        HIWORD(v788) = 0;
        while ( 1 )
        {
          LOWORD(v787) = v786[1];
          v789 = v786[3];
          v790 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v787 & 0x8000u) == 0 )
            break;
          if ( (__int16)v789 > 0 )
          {
            if ( v789 > dword_DE564 )
              v789 = dword_DE564;
            v1177 = v789;
            v791 = (unsigned __int16)-(__int16)v787;
            v792 = __ROL4__(*((_DWORD *)v786 + 3) + v1110 * v791, 16);
            BYTE1(v788) = v792;
            LOWORD(v792) = v786[4] + v1099 * v791;
            v787 = (unsigned int)(*((_DWORD *)v786 + 2) + v1099 * v791) >> 8;
            LOBYTE(v788) = (unsigned int)(*((_DWORD *)v786 + 2) + v1099 * v791) >> 16;
            v793 = __ROL4__(*((_DWORD *)v786 + 4) + v1121 * v791, 16);
            v787 = (unsigned __int16)v787;
LABEL_971:
            v1268 = v786;
            v794 = dword_DE55C;
            while ( 1 )
            {
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v792);
              LOWORD(v792) = v1099 + v792;
              BYTE1(v787) = v793;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v792);
              v795 = v1159 + v792;
              LOBYTE(v787) = *v790;
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v793);
              v796 = v1168 + v793;
              *v790 = byte_FAEE0[v787];
              LOBYTE(v796) = BYTE2(v1121) + v171 + v796;
              v1178 = v1177 - 1;
              if ( !v1178 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v795);
              LOWORD(v795) = v1099 + v795;
              BYTE1(v787) = v796;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v795);
              v797 = v1159 + v795;
              LOBYTE(v787) = v790[1];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v796);
              v798 = v1168 + v796;
              v790[1] = byte_FAEE0[v787];
              LOBYTE(v798) = BYTE2(v1121) + v171 + v798;
              v1179 = v1178 - 1;
              if ( !v1179 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v797);
              LOWORD(v797) = v1099 + v797;
              BYTE1(v787) = v798;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v797);
              v799 = v1159 + v797;
              LOBYTE(v787) = v790[2];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v798);
              v800 = v1168 + v798;
              v790[2] = byte_FAEE0[v787];
              LOBYTE(v800) = BYTE2(v1121) + v171 + v800;
              v1180 = v1179 - 1;
              if ( !v1180 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v799);
              LOWORD(v799) = v1099 + v799;
              BYTE1(v787) = v800;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v799);
              v801 = v1159 + v799;
              LOBYTE(v787) = v790[3];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v800);
              v802 = v1168 + v800;
              v790[3] = byte_FAEE0[v787];
              LOBYTE(v802) = BYTE2(v1121) + v171 + v802;
              v1181 = v1180 - 1;
              if ( !v1181 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v801);
              LOWORD(v801) = v1099 + v801;
              BYTE1(v787) = v802;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v801);
              v803 = v1159 + v801;
              LOBYTE(v787) = v790[4];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v802);
              v804 = v1168 + v802;
              v790[4] = byte_FAEE0[v787];
              LOBYTE(v804) = BYTE2(v1121) + v171 + v804;
              v1182 = v1181 - 1;
              if ( !v1182 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v803);
              LOWORD(v803) = v1099 + v803;
              BYTE1(v787) = v804;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v803);
              v805 = v1159 + v803;
              LOBYTE(v787) = v790[5];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v804);
              v806 = v1168 + v804;
              v790[5] = byte_FAEE0[v787];
              LOBYTE(v806) = BYTE2(v1121) + v171 + v806;
              v1183 = v1182 - 1;
              if ( !v1183 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v805);
              LOWORD(v805) = v1099 + v805;
              BYTE1(v787) = v806;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v805);
              v807 = v1159 + v805;
              LOBYTE(v787) = v790[6];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v806);
              v808 = v1168 + v806;
              v790[6] = byte_FAEE0[v787];
              LOBYTE(v808) = BYTE2(v1121) + v171 + v808;
              v1184 = v1183 - 1;
              if ( !v1184 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v807);
              LOWORD(v807) = v1099 + v807;
              BYTE1(v787) = v808;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v807);
              v809 = v1159 + v807;
              LOBYTE(v787) = v790[7];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v808);
              v810 = v1168 + v808;
              v790[7] = byte_FAEE0[v787];
              LOBYTE(v810) = BYTE2(v1121) + v171 + v810;
              v1185 = v1184 - 1;
              if ( !v1185 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v809);
              LOWORD(v809) = v1099 + v809;
              BYTE1(v787) = v810;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v809);
              v811 = v1159 + v809;
              LOBYTE(v787) = v790[8];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v810);
              v812 = v1168 + v810;
              v790[8] = byte_FAEE0[v787];
              LOBYTE(v812) = BYTE2(v1121) + v171 + v812;
              v1186 = v1185 - 1;
              if ( !v1186 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v811);
              LOWORD(v811) = v1099 + v811;
              BYTE1(v787) = v812;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v811);
              v813 = v1159 + v811;
              LOBYTE(v787) = v790[9];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v812);
              v814 = v1168 + v812;
              v790[9] = byte_FAEE0[v787];
              LOBYTE(v814) = BYTE2(v1121) + v171 + v814;
              v1187 = v1186 - 1;
              if ( !v1187 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v813);
              LOWORD(v813) = v1099 + v813;
              BYTE1(v787) = v814;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v813);
              v815 = v1159 + v813;
              LOBYTE(v787) = v790[10];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v814);
              v816 = v1168 + v814;
              v790[10] = byte_FAEE0[v787];
              LOBYTE(v816) = BYTE2(v1121) + v171 + v816;
              v1188 = v1187 - 1;
              if ( !v1188 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v815);
              LOWORD(v815) = v1099 + v815;
              BYTE1(v787) = v816;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v815);
              v817 = v1159 + v815;
              LOBYTE(v787) = v790[11];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v816);
              v818 = v1168 + v816;
              v790[11] = byte_FAEE0[v787];
              LOBYTE(v818) = BYTE2(v1121) + v171 + v818;
              v1189 = v1188 - 1;
              if ( !v1189 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v817);
              LOWORD(v817) = v1099 + v817;
              BYTE1(v787) = v818;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v817);
              v819 = v1159 + v817;
              LOBYTE(v787) = v790[12];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v818);
              v820 = v1168 + v818;
              v790[12] = byte_FAEE0[v787];
              LOBYTE(v820) = BYTE2(v1121) + v171 + v820;
              v1190 = v1189 - 1;
              if ( !v1190 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v819);
              LOWORD(v819) = v1099 + v819;
              BYTE1(v787) = v820;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v819);
              v821 = v1159 + v819;
              LOBYTE(v787) = v790[13];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v820);
              v822 = v1168 + v820;
              v790[13] = byte_FAEE0[v787];
              LOBYTE(v822) = BYTE2(v1121) + v171 + v822;
              v1191 = v1190 - 1;
              if ( !v1191 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v821);
              LOWORD(v821) = v1099 + v821;
              BYTE1(v787) = v822;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v821);
              v823 = v1159 + v821;
              LOBYTE(v787) = v790[14];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v822);
              v824 = v1168 + v822;
              v790[14] = byte_FAEE0[v787];
              LOBYTE(v824) = BYTE2(v1121) + v171 + v824;
              v1192 = v1191 - 1;
              if ( !v1192 )
                break;
              LOBYTE(v787) = *(_BYTE *)(v788 + v794);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v823);
              LOWORD(v823) = v1099 + v823;
              BYTE1(v787) = v824;
              LOBYTE(v788) = BYTE2(v1099) + v171 + v788;
              BYTE1(v787) = byte_F6EE0[v787];
              v171 = __CFADD__(v1159, v823);
              v792 = v1159 + v823;
              LOBYTE(v787) = v790[15];
              BYTE1(v788) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1168, v824);
              v793 = v1168 + v824;
              v790[15] = byte_FAEE0[v787];
              LOBYTE(v793) = BYTE2(v1121) + v171 + v793;
              v1177 = v1192 - 1;
              if ( !v1177 )
                break;
              v790 += 16;
            }
            v786 = v1268;
          }
LABEL_990:
          v786 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v789 > dword_DE564 )
          v789 = dword_DE564;
        v16 = (__int16)v789 <= (__int16)v787;
        LOWORD(v789) = v789 - v787;
        if ( v16 )
          goto LABEL_990;
        v790 += v787;
        v792 = __ROL4__(*((_DWORD *)v786 + 3), 16);
        BYTE1(v788) = v792;
        LOWORD(v792) = v786[4];
        LOBYTE(v788) = *((_BYTE *)v786 + 10);
        v1177 = v789;
        v793 = __ROL4__(*((_DWORD *)v786 + 4), 16);
        goto LABEL_971;
      case 21:
LABEL_992:
        v825 = (unsigned __int16 *)&unk_DE56C;
        v1160 = v1110 << 16;
        v1169 = v1121 << 16;
        HIWORD(v826) = 0;
        HIWORD(v827) = 0;
        while ( 1 )
        {
          LOWORD(v826) = v825[1];
          v828 = v825[3];
          v829 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v826 & 0x8000u) == 0 )
            break;
          if ( (__int16)v828 > 0 )
          {
            if ( v828 > dword_DE564 )
              v828 = dword_DE564;
            v1193 = v828;
            v830 = (unsigned __int16)-(__int16)v826;
            v831 = __ROL4__(*((_DWORD *)v825 + 3) + v1110 * v830, 16);
            BYTE1(v827) = v831;
            LOWORD(v831) = v825[4] + v1099 * v830;
            v826 = (unsigned int)(*((_DWORD *)v825 + 2) + v1099 * v830) >> 8;
            LOBYTE(v827) = (unsigned int)(*((_DWORD *)v825 + 2) + v1099 * v830) >> 16;
            v832 = __ROL4__(*((_DWORD *)v825 + 4) + v1121 * v830, 16);
            v826 = (unsigned __int16)v826;
LABEL_1002:
            v1269 = v825;
            v833 = dword_DE55C;
            while ( 1 )
            {
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v831);
              LOWORD(v831) = v1099 + v831;
              BYTE1(v826) = v832;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v831);
              v834 = v1160 + v831;
              BYTE1(v826) = *v829;
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v832);
              v835 = v1169 + v832;
              *v829 = byte_FAEE0[v826];
              LOBYTE(v835) = BYTE2(v1121) + v171 + v835;
              v1194 = v1193 - 1;
              if ( !v1194 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v834);
              LOWORD(v834) = v1099 + v834;
              BYTE1(v826) = v835;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v834);
              v836 = v1160 + v834;
              BYTE1(v826) = v829[1];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v835);
              v837 = v1169 + v835;
              v829[1] = byte_FAEE0[v826];
              LOBYTE(v837) = BYTE2(v1121) + v171 + v837;
              v1195 = v1194 - 1;
              if ( !v1195 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v836);
              LOWORD(v836) = v1099 + v836;
              BYTE1(v826) = v837;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v836);
              v838 = v1160 + v836;
              BYTE1(v826) = v829[2];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v837);
              v839 = v1169 + v837;
              v829[2] = byte_FAEE0[v826];
              LOBYTE(v839) = BYTE2(v1121) + v171 + v839;
              v1196 = v1195 - 1;
              if ( !v1196 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v838);
              LOWORD(v838) = v1099 + v838;
              BYTE1(v826) = v839;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v838);
              v840 = v1160 + v838;
              BYTE1(v826) = v829[3];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v839);
              v841 = v1169 + v839;
              v829[3] = byte_FAEE0[v826];
              LOBYTE(v841) = BYTE2(v1121) + v171 + v841;
              v1197 = v1196 - 1;
              if ( !v1197 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v840);
              LOWORD(v840) = v1099 + v840;
              BYTE1(v826) = v841;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v840);
              v842 = v1160 + v840;
              BYTE1(v826) = v829[4];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v841);
              v843 = v1169 + v841;
              v829[4] = byte_FAEE0[v826];
              LOBYTE(v843) = BYTE2(v1121) + v171 + v843;
              v1198 = v1197 - 1;
              if ( !v1198 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v842);
              LOWORD(v842) = v1099 + v842;
              BYTE1(v826) = v843;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v842);
              v844 = v1160 + v842;
              BYTE1(v826) = v829[5];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v843);
              v845 = v1169 + v843;
              v829[5] = byte_FAEE0[v826];
              LOBYTE(v845) = BYTE2(v1121) + v171 + v845;
              v1199 = v1198 - 1;
              if ( !v1199 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v844);
              LOWORD(v844) = v1099 + v844;
              BYTE1(v826) = v845;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v844);
              v846 = v1160 + v844;
              BYTE1(v826) = v829[6];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v845);
              v847 = v1169 + v845;
              v829[6] = byte_FAEE0[v826];
              LOBYTE(v847) = BYTE2(v1121) + v171 + v847;
              v1200 = v1199 - 1;
              if ( !v1200 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v846);
              LOWORD(v846) = v1099 + v846;
              BYTE1(v826) = v847;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v846);
              v848 = v1160 + v846;
              BYTE1(v826) = v829[7];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v847);
              v849 = v1169 + v847;
              v829[7] = byte_FAEE0[v826];
              LOBYTE(v849) = BYTE2(v1121) + v171 + v849;
              v1201 = v1200 - 1;
              if ( !v1201 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v848);
              LOWORD(v848) = v1099 + v848;
              BYTE1(v826) = v849;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v848);
              v850 = v1160 + v848;
              BYTE1(v826) = v829[8];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v849);
              v851 = v1169 + v849;
              v829[8] = byte_FAEE0[v826];
              LOBYTE(v851) = BYTE2(v1121) + v171 + v851;
              v1202 = v1201 - 1;
              if ( !v1202 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v850);
              LOWORD(v850) = v1099 + v850;
              BYTE1(v826) = v851;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v850);
              v852 = v1160 + v850;
              BYTE1(v826) = v829[9];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v851);
              v853 = v1169 + v851;
              v829[9] = byte_FAEE0[v826];
              LOBYTE(v853) = BYTE2(v1121) + v171 + v853;
              v1203 = v1202 - 1;
              if ( !v1203 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v852);
              LOWORD(v852) = v1099 + v852;
              BYTE1(v826) = v853;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v852);
              v854 = v1160 + v852;
              BYTE1(v826) = v829[10];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v853);
              v855 = v1169 + v853;
              v829[10] = byte_FAEE0[v826];
              LOBYTE(v855) = BYTE2(v1121) + v171 + v855;
              v1204 = v1203 - 1;
              if ( !v1204 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v854);
              LOWORD(v854) = v1099 + v854;
              BYTE1(v826) = v855;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v854);
              v856 = v1160 + v854;
              BYTE1(v826) = v829[11];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v855);
              v857 = v1169 + v855;
              v829[11] = byte_FAEE0[v826];
              LOBYTE(v857) = BYTE2(v1121) + v171 + v857;
              v1205 = v1204 - 1;
              if ( !v1205 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v856);
              LOWORD(v856) = v1099 + v856;
              BYTE1(v826) = v857;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v856);
              v858 = v1160 + v856;
              BYTE1(v826) = v829[12];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v857);
              v859 = v1169 + v857;
              v829[12] = byte_FAEE0[v826];
              LOBYTE(v859) = BYTE2(v1121) + v171 + v859;
              v1206 = v1205 - 1;
              if ( !v1206 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v858);
              LOWORD(v858) = v1099 + v858;
              BYTE1(v826) = v859;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v858);
              v860 = v1160 + v858;
              BYTE1(v826) = v829[13];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v859);
              v861 = v1169 + v859;
              v829[13] = byte_FAEE0[v826];
              LOBYTE(v861) = BYTE2(v1121) + v171 + v861;
              v1207 = v1206 - 1;
              if ( !v1207 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v860);
              LOWORD(v860) = v1099 + v860;
              BYTE1(v826) = v861;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v860);
              v862 = v1160 + v860;
              BYTE1(v826) = v829[14];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v861);
              v863 = v1169 + v861;
              v829[14] = byte_FAEE0[v826];
              LOBYTE(v863) = BYTE2(v1121) + v171 + v863;
              v1208 = v1207 - 1;
              if ( !v1208 )
                break;
              LOBYTE(v826) = *(_BYTE *)(v827 + v833);
              v171 = __CFADD__((_WORD)v1099, (_WORD)v862);
              LOWORD(v862) = v1099 + v862;
              BYTE1(v826) = v863;
              LOBYTE(v827) = BYTE2(v1099) + v171 + v827;
              LOBYTE(v826) = byte_F6EE0[v826];
              v171 = __CFADD__(v1160, v862);
              v831 = v1160 + v862;
              BYTE1(v826) = v829[15];
              BYTE1(v827) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1169, v863);
              v832 = v1169 + v863;
              v829[15] = byte_FAEE0[v826];
              LOBYTE(v832) = BYTE2(v1121) + v171 + v832;
              v1193 = v1208 - 1;
              if ( !v1193 )
                break;
              v829 += 16;
            }
            v825 = v1269;
          }
LABEL_1021:
          v825 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v828 > dword_DE564 )
          v828 = dword_DE564;
        v16 = (__int16)v828 <= (__int16)v826;
        LOWORD(v828) = v828 - v826;
        if ( v16 )
          goto LABEL_1021;
        v829 += v826;
        v831 = __ROL4__(*((_DWORD *)v825 + 3), 16);
        BYTE1(v827) = v831;
        LOWORD(v831) = v825[4];
        LOBYTE(v827) = *((_BYTE *)v825 + 10);
        v1193 = v828;
        v832 = __ROL4__(*((_DWORD *)v825 + 4), 16);
        goto LABEL_1002;
      case 22:
LABEL_1023:
        v864 = (unsigned __int16 *)&unk_DE56C;
        v1161 = v1110 << 16;
        HIWORD(v865) = 0;
        HIWORD(v866) = 0;
        while ( 1 )
        {
          LOWORD(v865) = v864[1];
          v867 = v864[3];
          v868 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v865 & 0x8000u) == 0 )
            break;
          if ( (__int16)v867 > 0 )
          {
            v869 = (unsigned __int16)-(__int16)v865;
            v871 = __ROL4__(*((_DWORD *)v864 + 3) + v1110 * v869, 16);
            BYTE1(v866) = v871;
            v870 = *((_DWORD *)v864 + 2) + v1099 * v869;
            LOWORD(v871) = v870;
            v872 = v870 >> 8;
            LOBYTE(v866) = BYTE1(v872);
            if ( v867 > dword_DE564 )
              LOWORD(v867) = dword_DE564;
            v865 = (unsigned __int16)v872;
LABEL_1033:
            v1270 = v864;
            v873 = dword_DE55C;
            while ( 1 )
            {
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = *v868;
                *v868 = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v871);
              LOWORD(v871) = v1099 + v871;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v871);
              v874 = v1161 + v871;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v875 = v867 - 1;
              if ( !v875 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[1];
                v868[1] = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v874);
              LOWORD(v874) = v1099 + v874;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v874);
              v876 = v1161 + v874;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v877 = v875 - 1;
              if ( !v877 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[2];
                v868[2] = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v876);
              LOWORD(v876) = v1099 + v876;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v876);
              v878 = v1161 + v876;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v879 = v877 - 1;
              if ( !v879 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[3];
                v868[3] = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v878);
              LOWORD(v878) = v1099 + v878;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v878);
              v880 = v1161 + v878;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v881 = v879 - 1;
              if ( !v881 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[4];
                v868[4] = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v880);
              LOWORD(v880) = v1099 + v880;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v880);
              v882 = v1161 + v880;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v883 = v881 - 1;
              if ( !v883 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[5];
                v868[5] = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v882);
              LOWORD(v882) = v1099 + v882;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v882);
              v884 = v1161 + v882;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v885 = v883 - 1;
              if ( !v885 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[6];
                v868[6] = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v884);
              LOWORD(v884) = v1099 + v884;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v884);
              v886 = v1161 + v884;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v887 = v885 - 1;
              if ( !v887 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[7];
                v868[7] = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v886);
              LOWORD(v886) = v1099 + v886;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v886);
              v888 = v1161 + v886;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v889 = v887 - 1;
              if ( !v889 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[8];
                v868[8] = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v888);
              LOWORD(v888) = v1099 + v888;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v888);
              v890 = v1161 + v888;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v891 = v889 - 1;
              if ( !v891 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[9];
                v868[9] = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v890);
              LOWORD(v890) = v1099 + v890;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v890);
              v892 = v1161 + v890;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v893 = v891 - 1;
              if ( !v893 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[10];
                v868[10] = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v892);
              LOWORD(v892) = v1099 + v892;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v892);
              v894 = v1161 + v892;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v895 = v893 - 1;
              if ( !v895 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[11];
                v868[11] = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v894);
              LOWORD(v894) = v1099 + v894;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v894);
              v896 = v1161 + v894;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v897 = v895 - 1;
              if ( !v897 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[12];
                v868[12] = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v896);
              LOWORD(v896) = v1099 + v896;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v896);
              v898 = v1161 + v896;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v899 = v897 - 1;
              if ( !v899 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[13];
                v868[13] = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v898);
              LOWORD(v898) = v1099 + v898;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v898);
              v900 = v1161 + v898;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v901 = v899 - 1;
              if ( !v901 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[14];
                v868[14] = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v900);
              LOWORD(v900) = v1099 + v900;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v900);
              v902 = v1161 + v900;
              BYTE1(v866) += BYTE2(v1110) + v171;
              v903 = v901 - 1;
              if ( !v903 )
                break;
              BYTE1(v865) = *(_BYTE *)(v866 + v873);
              if ( BYTE1(v865) )
              {
                LOBYTE(v865) = v868[15];
                v868[15] = byte_FAEE0[v865];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v902);
              LOWORD(v902) = v1099 + v902;
              LOBYTE(v866) = BYTE2(v1099) + v171 + v866;
              v171 = __CFADD__(v1161, v902);
              v871 = v1161 + v902;
              BYTE1(v866) += BYTE2(v1110) + v171;
              LOWORD(v867) = v903 - 1;
              if ( !(_WORD)v867 )
                break;
              v868 += 16;
            }
            v864 = v1270;
          }
LABEL_1084:
          v864 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v867 > dword_DE564 )
          LOWORD(v867) = dword_DE564;
        v16 = (__int16)v867 <= (__int16)v865;
        LOWORD(v867) = v867 - v865;
        if ( v16 )
          goto LABEL_1084;
        v868 += v865;
        v871 = __ROL4__(*((_DWORD *)v864 + 3), 16);
        BYTE1(v866) = v871;
        LOWORD(v871) = v864[4];
        LOBYTE(v866) = *((_BYTE *)v864 + 10);
        goto LABEL_1033;
      case 23:
LABEL_1086:
        v904 = (unsigned __int16 *)&unk_DE56C;
        v1162 = v1110 << 16;
        HIWORD(v905) = 0;
        HIWORD(v906) = 0;
        while ( 1 )
        {
          LOWORD(v905) = v904[1];
          v907 = v904[3];
          v908 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v905 & 0x8000u) == 0 )
            break;
          if ( (__int16)v907 > 0 )
          {
            v909 = (unsigned __int16)-(__int16)v905;
            v911 = __ROL4__(*((_DWORD *)v904 + 3) + v1110 * v909, 16);
            BYTE1(v906) = v911;
            v910 = *((_DWORD *)v904 + 2) + v1099 * v909;
            LOWORD(v911) = v910;
            v912 = v910 >> 8;
            LOBYTE(v906) = BYTE1(v912);
            if ( v907 > dword_DE564 )
              LOWORD(v907) = dword_DE564;
            v905 = (unsigned __int16)v912;
LABEL_1096:
            v1271 = v904;
            v913 = dword_DE55C;
            while ( 1 )
            {
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = *v908;
                *v908 = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v911);
              LOWORD(v911) = v1099 + v911;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v911);
              v914 = v1162 + v911;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v915 = v907 - 1;
              if ( !v915 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[1];
                v908[1] = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v914);
              LOWORD(v914) = v1099 + v914;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v914);
              v916 = v1162 + v914;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v917 = v915 - 1;
              if ( !v917 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[2];
                v908[2] = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v916);
              LOWORD(v916) = v1099 + v916;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v916);
              v918 = v1162 + v916;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v919 = v917 - 1;
              if ( !v919 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[3];
                v908[3] = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v918);
              LOWORD(v918) = v1099 + v918;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v918);
              v920 = v1162 + v918;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v921 = v919 - 1;
              if ( !v921 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[4];
                v908[4] = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v920);
              LOWORD(v920) = v1099 + v920;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v920);
              v922 = v1162 + v920;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v923 = v921 - 1;
              if ( !v923 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[5];
                v908[5] = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v922);
              LOWORD(v922) = v1099 + v922;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v922);
              v924 = v1162 + v922;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v925 = v923 - 1;
              if ( !v925 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[6];
                v908[6] = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v924);
              LOWORD(v924) = v1099 + v924;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v924);
              v926 = v1162 + v924;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v927 = v925 - 1;
              if ( !v927 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[7];
                v908[7] = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v926);
              LOWORD(v926) = v1099 + v926;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v926);
              v928 = v1162 + v926;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v929 = v927 - 1;
              if ( !v929 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[8];
                v908[8] = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v928);
              LOWORD(v928) = v1099 + v928;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v928);
              v930 = v1162 + v928;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v931 = v929 - 1;
              if ( !v931 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[9];
                v908[9] = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v930);
              LOWORD(v930) = v1099 + v930;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v930);
              v932 = v1162 + v930;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v933 = v931 - 1;
              if ( !v933 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[10];
                v908[10] = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v932);
              LOWORD(v932) = v1099 + v932;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v932);
              v934 = v1162 + v932;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v935 = v933 - 1;
              if ( !v935 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[11];
                v908[11] = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v934);
              LOWORD(v934) = v1099 + v934;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v934);
              v936 = v1162 + v934;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v937 = v935 - 1;
              if ( !v937 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[12];
                v908[12] = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v936);
              LOWORD(v936) = v1099 + v936;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v936);
              v938 = v1162 + v936;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v939 = v937 - 1;
              if ( !v939 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[13];
                v908[13] = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v938);
              LOWORD(v938) = v1099 + v938;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v938);
              v940 = v1162 + v938;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v941 = v939 - 1;
              if ( !v941 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[14];
                v908[14] = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v940);
              LOWORD(v940) = v1099 + v940;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v940);
              v942 = v1162 + v940;
              BYTE1(v906) += BYTE2(v1110) + v171;
              v943 = v941 - 1;
              if ( !v943 )
                break;
              LOBYTE(v905) = *(_BYTE *)(v906 + v913);
              if ( (_BYTE)v905 )
              {
                BYTE1(v905) = v908[15];
                v908[15] = byte_FAEE0[v905];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v942);
              LOWORD(v942) = v1099 + v942;
              LOBYTE(v906) = BYTE2(v1099) + v171 + v906;
              v171 = __CFADD__(v1162, v942);
              v911 = v1162 + v942;
              BYTE1(v906) += BYTE2(v1110) + v171;
              LOWORD(v907) = v943 - 1;
              if ( !(_WORD)v907 )
                break;
              v908 += 16;
            }
            v904 = v1271;
          }
LABEL_1147:
          v904 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v907 > dword_DE564 )
          LOWORD(v907) = dword_DE564;
        v16 = (__int16)v907 <= (__int16)v905;
        LOWORD(v907) = v907 - v905;
        if ( v16 )
          goto LABEL_1147;
        v908 += v905;
        v911 = __ROL4__(*((_DWORD *)v904 + 3), 16);
        BYTE1(v906) = v911;
        LOWORD(v911) = v904[4];
        LOBYTE(v906) = *((_BYTE *)v904 + 10);
        goto LABEL_1096;
      case 24:
LABEL_1149:
        v944 = (unsigned __int16 *)&unk_DE56C;
        v1163 = v1110 << 16;
        v1170 = v1121 << 16;
        HIWORD(v945) = 0;
        HIWORD(v946) = 0;
        while ( 1 )
        {
          LOWORD(v945) = v944[1];
          v947 = v944[3];
          v948 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v945 & 0x8000u) == 0 )
            break;
          if ( (__int16)v947 > 0 )
          {
            if ( v947 > dword_DE564 )
              v947 = dword_DE564;
            v1209 = v947;
            v949 = (unsigned __int16)-(__int16)v945;
            v950 = __ROL4__(*((_DWORD *)v944 + 3) + v1110 * v949, 16);
            BYTE1(v946) = v950;
            LOWORD(v950) = v944[4] + v1099 * v949;
            v945 = (unsigned int)(*((_DWORD *)v944 + 2) + v1099 * v949) >> 8;
            LOBYTE(v946) = (unsigned int)(*((_DWORD *)v944 + 2) + v1099 * v949) >> 16;
            v951 = __ROL4__(*((_DWORD *)v944 + 4) + v1121 * v949, 16);
            v945 = (unsigned __int16)v945;
LABEL_1159:
            v1272 = v944;
            v952 = dword_DE55C;
            while ( 1 )
            {
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v951;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = *v948;
                *v948 = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v950);
              LOWORD(v950) = v1099 + v950;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v950);
              v953 = v1163 + v950;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v951);
              v954 = v1170 + v951;
              LOBYTE(v954) = BYTE2(v1121) + v171 + v954;
              v1210 = v1209 - 1;
              if ( !v1210 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v954;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = v948[1];
                v948[1] = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v953);
              LOWORD(v953) = v1099 + v953;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v953);
              v955 = v1163 + v953;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v954);
              v956 = v1170 + v954;
              LOBYTE(v956) = BYTE2(v1121) + v171 + v956;
              v1211 = v1210 - 1;
              if ( !v1211 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v956;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = v948[2];
                v948[2] = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v955);
              LOWORD(v955) = v1099 + v955;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v955);
              v957 = v1163 + v955;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v956);
              v958 = v1170 + v956;
              LOBYTE(v958) = BYTE2(v1121) + v171 + v958;
              v1212 = v1211 - 1;
              if ( !v1212 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v958;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = v948[3];
                v948[3] = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v957);
              LOWORD(v957) = v1099 + v957;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v957);
              v959 = v1163 + v957;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v958);
              v960 = v1170 + v958;
              LOBYTE(v960) = BYTE2(v1121) + v171 + v960;
              v1213 = v1212 - 1;
              if ( !v1213 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v960;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = v948[4];
                v948[4] = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v959);
              LOWORD(v959) = v1099 + v959;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v959);
              v961 = v1163 + v959;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v960);
              v962 = v1170 + v960;
              LOBYTE(v962) = BYTE2(v1121) + v171 + v962;
              v1214 = v1213 - 1;
              if ( !v1214 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v962;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = v948[5];
                v948[5] = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v961);
              LOWORD(v961) = v1099 + v961;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v961);
              v963 = v1163 + v961;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v962);
              v964 = v1170 + v962;
              LOBYTE(v964) = BYTE2(v1121) + v171 + v964;
              v1215 = v1214 - 1;
              if ( !v1215 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v964;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = v948[6];
                v948[6] = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v963);
              LOWORD(v963) = v1099 + v963;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v963);
              v965 = v1163 + v963;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v964);
              v966 = v1170 + v964;
              LOBYTE(v966) = BYTE2(v1121) + v171 + v966;
              v1216 = v1215 - 1;
              if ( !v1216 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v966;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = v948[7];
                v948[7] = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v965);
              LOWORD(v965) = v1099 + v965;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v965);
              v967 = v1163 + v965;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v966);
              v968 = v1170 + v966;
              LOBYTE(v968) = BYTE2(v1121) + v171 + v968;
              v1217 = v1216 - 1;
              if ( !v1217 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v968;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = v948[8];
                v948[8] = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v967);
              LOWORD(v967) = v1099 + v967;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v967);
              v969 = v1163 + v967;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v968);
              v970 = v1170 + v968;
              LOBYTE(v970) = BYTE2(v1121) + v171 + v970;
              v1218 = v1217 - 1;
              if ( !v1218 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v970;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = v948[9];
                v948[9] = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v969);
              LOWORD(v969) = v1099 + v969;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v969);
              v971 = v1163 + v969;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v970);
              v972 = v1170 + v970;
              LOBYTE(v972) = BYTE2(v1121) + v171 + v972;
              v1219 = v1218 - 1;
              if ( !v1219 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v972;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = v948[10];
                v948[10] = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v971);
              LOWORD(v971) = v1099 + v971;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v971);
              v973 = v1163 + v971;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v972);
              v974 = v1170 + v972;
              LOBYTE(v974) = BYTE2(v1121) + v171 + v974;
              v1220 = v1219 - 1;
              if ( !v1220 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v974;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = v948[11];
                v948[11] = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v973);
              LOWORD(v973) = v1099 + v973;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v973);
              v975 = v1163 + v973;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v974);
              v976 = v1170 + v974;
              LOBYTE(v976) = BYTE2(v1121) + v171 + v976;
              v1221 = v1220 - 1;
              if ( !v1221 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v976;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = v948[12];
                v948[12] = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v975);
              LOWORD(v975) = v1099 + v975;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v975);
              v977 = v1163 + v975;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v976);
              v978 = v1170 + v976;
              LOBYTE(v978) = BYTE2(v1121) + v171 + v978;
              v1222 = v1221 - 1;
              if ( !v1222 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v978;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = v948[13];
                v948[13] = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v977);
              LOWORD(v977) = v1099 + v977;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v977);
              v979 = v1163 + v977;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v978);
              v980 = v1170 + v978;
              LOBYTE(v980) = BYTE2(v1121) + v171 + v980;
              v1223 = v1222 - 1;
              if ( !v1223 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v980;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = v948[14];
                v948[14] = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v979);
              LOWORD(v979) = v1099 + v979;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v979);
              v981 = v1163 + v979;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v980);
              v982 = v1170 + v980;
              LOBYTE(v982) = BYTE2(v1121) + v171 + v982;
              v1224 = v1223 - 1;
              if ( !v1224 )
                break;
              LOBYTE(v945) = *(_BYTE *)(v946 + v952);
              if ( (_BYTE)v945 )
              {
                BYTE1(v945) = v982;
                BYTE1(v945) = byte_F6EE0[v945];
                LOBYTE(v945) = v948[15];
                v948[15] = byte_FAEE0[v945];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v981);
              LOWORD(v981) = v1099 + v981;
              LOBYTE(v946) = BYTE2(v1099) + v171 + v946;
              v171 = __CFADD__(v1163, v981);
              v950 = v1163 + v981;
              BYTE1(v946) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1170, v982);
              v951 = v1170 + v982;
              LOBYTE(v951) = BYTE2(v1121) + v171 + v951;
              v1209 = v1224 - 1;
              if ( !v1209 )
                break;
              v948 += 16;
            }
            v944 = v1272;
          }
LABEL_1210:
          v944 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v947 > dword_DE564 )
          v947 = dword_DE564;
        v16 = (__int16)v947 <= (__int16)v945;
        LOWORD(v947) = v947 - v945;
        if ( v16 )
          goto LABEL_1210;
        v948 += v945;
        v950 = __ROL4__(*((_DWORD *)v944 + 3), 16);
        BYTE1(v946) = v950;
        LOWORD(v950) = v944[4];
        LOBYTE(v946) = *((_BYTE *)v944 + 10);
        v1209 = v947;
        v951 = __ROL4__(*((_DWORD *)v944 + 4), 16);
        goto LABEL_1159;
      case 25:
LABEL_1212:
        v983 = (unsigned __int16 *)&unk_DE56C;
        v1164 = v1110 << 16;
        v1171 = v1121 << 16;
        HIWORD(v984) = 0;
        HIWORD(v985) = 0;
        while ( 1 )
        {
          LOWORD(v984) = v983[1];
          v986 = v983[3];
          v987 = (_BYTE *)(dword_DE560 + v1077);
          v1077 += dword_DE560;
          if ( (v984 & 0x8000u) == 0 )
            break;
          if ( (__int16)v986 > 0 )
          {
            if ( v986 > dword_DE564 )
              v986 = dword_DE564;
            v1225 = v986;
            v988 = (unsigned __int16)-(__int16)v984;
            v989 = __ROL4__(*((_DWORD *)v983 + 3) + v1110 * v988, 16);
            BYTE1(v985) = v989;
            LOWORD(v989) = v983[4] + v1099 * v988;
            v984 = (unsigned int)(*((_DWORD *)v983 + 2) + v1099 * v988) >> 8;
            LOBYTE(v985) = (unsigned int)(*((_DWORD *)v983 + 2) + v1099 * v988) >> 16;
            v990 = __ROL4__(*((_DWORD *)v983 + 4) + v1121 * v988, 16);
            v984 = (unsigned __int16)v984;
LABEL_1222:
            v1273 = v983;
            v991 = dword_DE55C;
            while ( 1 )
            {
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v990;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = *v987;
                *v987 = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v989);
              LOWORD(v989) = v1099 + v989;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v989);
              v992 = v1164 + v989;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v990);
              v993 = v1171 + v990;
              LOBYTE(v993) = BYTE2(v1121) + v171 + v993;
              v1226 = v1225 - 1;
              if ( !v1226 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v993;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = v987[1];
                v987[1] = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v992);
              LOWORD(v992) = v1099 + v992;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v992);
              v994 = v1164 + v992;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v993);
              v995 = v1171 + v993;
              LOBYTE(v995) = BYTE2(v1121) + v171 + v995;
              v1227 = v1226 - 1;
              if ( !v1227 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v995;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = v987[2];
                v987[2] = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v994);
              LOWORD(v994) = v1099 + v994;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v994);
              v996 = v1164 + v994;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v995);
              v997 = v1171 + v995;
              LOBYTE(v997) = BYTE2(v1121) + v171 + v997;
              v1228 = v1227 - 1;
              if ( !v1228 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v997;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = v987[3];
                v987[3] = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v996);
              LOWORD(v996) = v1099 + v996;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v996);
              v998 = v1164 + v996;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v997);
              v999 = v1171 + v997;
              LOBYTE(v999) = BYTE2(v1121) + v171 + v999;
              v1229 = v1228 - 1;
              if ( !v1229 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v999;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = v987[4];
                v987[4] = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v998);
              LOWORD(v998) = v1099 + v998;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v998);
              v1000 = v1164 + v998;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v999);
              v1001 = v1171 + v999;
              LOBYTE(v1001) = BYTE2(v1121) + v171 + v1001;
              v1230 = v1229 - 1;
              if ( !v1230 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1001;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = v987[5];
                v987[5] = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1000);
              LOWORD(v1000) = v1099 + v1000;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1000);
              v1002 = v1164 + v1000;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1001);
              v1003 = v1171 + v1001;
              LOBYTE(v1003) = BYTE2(v1121) + v171 + v1003;
              v1231 = v1230 - 1;
              if ( !v1231 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1003;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = v987[6];
                v987[6] = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1002);
              LOWORD(v1002) = v1099 + v1002;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1002);
              v1004 = v1164 + v1002;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1003);
              v1005 = v1171 + v1003;
              LOBYTE(v1005) = BYTE2(v1121) + v171 + v1005;
              v1232 = v1231 - 1;
              if ( !v1232 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1005;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = v987[7];
                v987[7] = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1004);
              LOWORD(v1004) = v1099 + v1004;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1004);
              v1006 = v1164 + v1004;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1005);
              v1007 = v1171 + v1005;
              LOBYTE(v1007) = BYTE2(v1121) + v171 + v1007;
              v1233 = v1232 - 1;
              if ( !v1233 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1007;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = v987[8];
                v987[8] = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1006);
              LOWORD(v1006) = v1099 + v1006;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1006);
              v1008 = v1164 + v1006;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1007);
              v1009 = v1171 + v1007;
              LOBYTE(v1009) = BYTE2(v1121) + v171 + v1009;
              v1234 = v1233 - 1;
              if ( !v1234 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1009;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = v987[9];
                v987[9] = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1008);
              LOWORD(v1008) = v1099 + v1008;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1008);
              v1010 = v1164 + v1008;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1009);
              v1011 = v1171 + v1009;
              LOBYTE(v1011) = BYTE2(v1121) + v171 + v1011;
              v1235 = v1234 - 1;
              if ( !v1235 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1011;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = v987[10];
                v987[10] = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1010);
              LOWORD(v1010) = v1099 + v1010;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1010);
              v1012 = v1164 + v1010;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1011);
              v1013 = v1171 + v1011;
              LOBYTE(v1013) = BYTE2(v1121) + v171 + v1013;
              v1236 = v1235 - 1;
              if ( !v1236 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1013;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = v987[11];
                v987[11] = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1012);
              LOWORD(v1012) = v1099 + v1012;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1012);
              v1014 = v1164 + v1012;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1013);
              v1015 = v1171 + v1013;
              LOBYTE(v1015) = BYTE2(v1121) + v171 + v1015;
              v1237 = v1236 - 1;
              if ( !v1237 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1015;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = v987[12];
                v987[12] = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1014);
              LOWORD(v1014) = v1099 + v1014;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1014);
              v1016 = v1164 + v1014;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1015);
              v1017 = v1171 + v1015;
              LOBYTE(v1017) = BYTE2(v1121) + v171 + v1017;
              v1238 = v1237 - 1;
              if ( !v1238 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1017;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = v987[13];
                v987[13] = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1016);
              LOWORD(v1016) = v1099 + v1016;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1016);
              v1018 = v1164 + v1016;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1017);
              v1019 = v1171 + v1017;
              LOBYTE(v1019) = BYTE2(v1121) + v171 + v1019;
              v1239 = v1238 - 1;
              if ( !v1239 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1019;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = v987[14];
                v987[14] = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1018);
              LOWORD(v1018) = v1099 + v1018;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1018);
              v1020 = v1164 + v1018;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1019);
              v1021 = v1171 + v1019;
              LOBYTE(v1021) = BYTE2(v1121) + v171 + v1021;
              v1240 = v1239 - 1;
              if ( !v1240 )
                break;
              LOBYTE(v984) = *(_BYTE *)(v985 + v991);
              if ( (_BYTE)v984 )
              {
                BYTE1(v984) = v1021;
                LOBYTE(v984) = byte_F6EE0[v984];
                BYTE1(v984) = v987[15];
                v987[15] = byte_FAEE0[v984];
              }
              v171 = __CFADD__((_WORD)v1099, (_WORD)v1020);
              LOWORD(v1020) = v1099 + v1020;
              LOBYTE(v985) = BYTE2(v1099) + v171 + v985;
              v171 = __CFADD__(v1164, v1020);
              v989 = v1164 + v1020;
              BYTE1(v985) += BYTE2(v1110) + v171;
              v171 = __CFADD__(v1171, v1021);
              v990 = v1171 + v1021;
              LOBYTE(v990) = BYTE2(v1121) + v171 + v990;
              v1225 = v1240 - 1;
              if ( !v1225 )
                break;
              v987 += 16;
            }
            v983 = v1273;
          }
LABEL_1273:
          v983 += 10;
          if ( !--v1098 )
            return;
        }
        if ( v986 > dword_DE564 )
          v986 = dword_DE564;
        v16 = (__int16)v986 <= (__int16)v984;
        LOWORD(v986) = v986 - v984;
        if ( v16 )
          goto LABEL_1273;
        v987 += v984;
        v989 = __ROL4__(*((_DWORD *)v983 + 3), 16);
        BYTE1(v985) = v989;
        LOWORD(v989) = v983[4];
        LOBYTE(v985) = *((_BYTE *)v983 + 10);
        v1225 = v986;
        v990 = __ROL4__(*((_DWORD *)v983 + 4), 16);
        goto LABEL_1222;
      case 26:
LABEL_1275:
        v1022 = (unsigned __int16 *)&unk_DE56C;
        v1165 = v1110 << 16;
        v1172 = v1121 << 16;
        HIWORD(v1023) = 0;
        HIWORD(v1024) = 0;
        break;
    }
    while ( 1 )
    {
      LOWORD(v1023) = v1022[1];
      v1025 = v1022[3];
      v1026 = (char *)(dword_DE560 + v1077);
      v1077 += dword_DE560;
      if ( (v1023 & 0x8000u) == 0 )
        break;
      if ( (__int16)v1025 > 0 )
      {
        if ( v1025 > dword_DE564 )
          v1025 = dword_DE564;
        v1241 = v1025;
        v1027 = (unsigned __int16)-(__int16)v1023;
        v1028 = __ROL4__(*((_DWORD *)v1022 + 3) + v1110 * v1027, 16);
        BYTE1(v1024) = v1028;
        LOWORD(v1028) = v1022[4] + v1099 * v1027;
        v1023 = (unsigned int)(*((_DWORD *)v1022 + 2) + v1099 * v1027) >> 8;
        LOBYTE(v1024) = (unsigned int)(*((_DWORD *)v1022 + 2) + v1099 * v1027) >> 16;
        v1029 = __ROL4__(*((_DWORD *)v1022 + 4) + v1121 * v1027, 16);
        v1023 = (unsigned __int16)v1023;
LABEL_1285:
        v1274 = v1022;
        v1030 = dword_DE55C;
        while ( 1 )
        {
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1028);
          LOWORD(v1028) = v1099 + v1028;
          BYTE1(v1023) = v1029;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1031 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = *v1026;
            v1031 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1028);
          v1032 = v1165 + v1028;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1029);
          v1033 = v1172 + v1029;
          *v1026 = v1031;
          LOBYTE(v1033) = BYTE2(v1121) + v171 + v1033;
          v1242 = v1241 - 1;
          if ( !v1242 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1032);
          LOWORD(v1032) = v1099 + v1032;
          BYTE1(v1023) = v1033;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1034 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = v1026[1];
            v1034 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1032);
          v1035 = v1165 + v1032;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1033);
          v1036 = v1172 + v1033;
          v1026[1] = v1034;
          LOBYTE(v1036) = BYTE2(v1121) + v171 + v1036;
          v1243 = v1242 - 1;
          if ( !v1243 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1035);
          LOWORD(v1035) = v1099 + v1035;
          BYTE1(v1023) = v1036;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1037 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = v1026[2];
            v1037 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1035);
          v1038 = v1165 + v1035;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1036);
          v1039 = v1172 + v1036;
          v1026[2] = v1037;
          LOBYTE(v1039) = BYTE2(v1121) + v171 + v1039;
          v1244 = v1243 - 1;
          if ( !v1244 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1038);
          LOWORD(v1038) = v1099 + v1038;
          BYTE1(v1023) = v1039;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1040 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = v1026[3];
            v1040 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1038);
          v1041 = v1165 + v1038;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1039);
          v1042 = v1172 + v1039;
          v1026[3] = v1040;
          LOBYTE(v1042) = BYTE2(v1121) + v171 + v1042;
          v1245 = v1244 - 1;
          if ( !v1245 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1041);
          LOWORD(v1041) = v1099 + v1041;
          BYTE1(v1023) = v1042;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1043 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = v1026[4];
            v1043 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1041);
          v1044 = v1165 + v1041;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1042);
          v1045 = v1172 + v1042;
          v1026[4] = v1043;
          LOBYTE(v1045) = BYTE2(v1121) + v171 + v1045;
          v1246 = v1245 - 1;
          if ( !v1246 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1044);
          LOWORD(v1044) = v1099 + v1044;
          BYTE1(v1023) = v1045;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1046 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = v1026[5];
            v1046 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1044);
          v1047 = v1165 + v1044;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1045);
          v1048 = v1172 + v1045;
          v1026[5] = v1046;
          LOBYTE(v1048) = BYTE2(v1121) + v171 + v1048;
          v1247 = v1246 - 1;
          if ( !v1247 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1047);
          LOWORD(v1047) = v1099 + v1047;
          BYTE1(v1023) = v1048;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1049 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = v1026[6];
            v1049 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1047);
          v1050 = v1165 + v1047;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1048);
          v1051 = v1172 + v1048;
          v1026[6] = v1049;
          LOBYTE(v1051) = BYTE2(v1121) + v171 + v1051;
          v1248 = v1247 - 1;
          if ( !v1248 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1050);
          LOWORD(v1050) = v1099 + v1050;
          BYTE1(v1023) = v1051;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1052 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = v1026[7];
            v1052 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1050);
          v1053 = v1165 + v1050;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1051);
          v1054 = v1172 + v1051;
          v1026[7] = v1052;
          LOBYTE(v1054) = BYTE2(v1121) + v171 + v1054;
          v1249 = v1248 - 1;
          if ( !v1249 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1053);
          LOWORD(v1053) = v1099 + v1053;
          BYTE1(v1023) = v1054;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1055 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = v1026[8];
            v1055 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1053);
          v1056 = v1165 + v1053;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1054);
          v1057 = v1172 + v1054;
          v1026[8] = v1055;
          LOBYTE(v1057) = BYTE2(v1121) + v171 + v1057;
          v1250 = v1249 - 1;
          if ( !v1250 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1056);
          LOWORD(v1056) = v1099 + v1056;
          BYTE1(v1023) = v1057;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1058 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = v1026[9];
            v1058 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1056);
          v1059 = v1165 + v1056;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1057);
          v1060 = v1172 + v1057;
          v1026[9] = v1058;
          LOBYTE(v1060) = BYTE2(v1121) + v171 + v1060;
          v1251 = v1250 - 1;
          if ( !v1251 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1059);
          LOWORD(v1059) = v1099 + v1059;
          BYTE1(v1023) = v1060;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1061 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = v1026[10];
            v1061 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1059);
          v1062 = v1165 + v1059;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1060);
          v1063 = v1172 + v1060;
          v1026[10] = v1061;
          LOBYTE(v1063) = BYTE2(v1121) + v171 + v1063;
          v1252 = v1251 - 1;
          if ( !v1252 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1062);
          LOWORD(v1062) = v1099 + v1062;
          BYTE1(v1023) = v1063;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1064 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = v1026[11];
            v1064 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1062);
          v1065 = v1165 + v1062;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1063);
          v1066 = v1172 + v1063;
          v1026[11] = v1064;
          LOBYTE(v1066) = BYTE2(v1121) + v171 + v1066;
          v1253 = v1252 - 1;
          if ( !v1253 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1065);
          LOWORD(v1065) = v1099 + v1065;
          BYTE1(v1023) = v1066;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1067 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = v1026[12];
            v1067 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1065);
          v1068 = v1165 + v1065;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1066);
          v1069 = v1172 + v1066;
          v1026[12] = v1067;
          LOBYTE(v1069) = BYTE2(v1121) + v171 + v1069;
          v1254 = v1253 - 1;
          if ( !v1254 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1068);
          LOWORD(v1068) = v1099 + v1068;
          BYTE1(v1023) = v1069;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1070 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = v1026[13];
            v1070 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1068);
          v1071 = v1165 + v1068;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1069);
          v1072 = v1172 + v1069;
          v1026[13] = v1070;
          LOBYTE(v1072) = BYTE2(v1121) + v171 + v1072;
          v1255 = v1254 - 1;
          if ( !v1255 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1071);
          LOWORD(v1071) = v1099 + v1071;
          BYTE1(v1023) = v1072;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1073 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = v1026[14];
            v1073 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1071);
          v1074 = v1165 + v1071;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1072);
          v1075 = v1172 + v1072;
          v1026[14] = v1073;
          LOBYTE(v1075) = BYTE2(v1121) + v171 + v1075;
          v1256 = v1255 - 1;
          if ( !v1256 )
            break;
          LOBYTE(v1023) = *(_BYTE *)(v1024 + v1030);
          v171 = __CFADD__((_WORD)v1099, (_WORD)v1074);
          LOWORD(v1074) = v1099 + v1074;
          BYTE1(v1023) = v1075;
          LOBYTE(v1024) = BYTE2(v1099) + v171 + v1024;
          if ( (unsigned __int8)v1023 >= 0xCu )
          {
            v1076 = byte_F6EE0[v1023];
          }
          else
          {
            LOBYTE(v1023) = byte_F6EE0[v1023];
            BYTE1(v1023) = v1026[15];
            v1076 = byte_FAEE0[v1023];
          }
          v171 = __CFADD__(v1165, v1074);
          v1028 = v1165 + v1074;
          BYTE1(v1024) += BYTE2(v1110) + v171;
          v171 = __CFADD__(v1172, v1075);
          v1029 = v1172 + v1075;
          v1026[15] = v1076;
          LOBYTE(v1029) = BYTE2(v1121) + v171 + v1029;
          v1241 = v1256 - 1;
          if ( !v1241 )
            break;
          v1026 += 16;
        }
        v1022 = v1274;
      }
LABEL_1352:
      v1022 += 10;
      if ( !--v1098 )
        return;
    }
    if ( v1025 > dword_DE564 )
      v1025 = dword_DE564;
    v16 = (__int16)v1025 <= (__int16)v1023;
    LOWORD(v1025) = v1025 - v1023;
    if ( v16 )
      goto LABEL_1352;
    v1026 += v1023;
    v1028 = __ROL4__(*((_DWORD *)v1022 + 3), 16);
    BYTE1(v1024) = v1028;
    LOWORD(v1028) = v1022[4];
    LOBYTE(v1024) = *((_BYTE *)v1022 + 10);
    v1241 = v1025;
    v1029 = __ROL4__(*((_DWORD *)v1022 + 4), 16);
    goto LABEL_1285;
  }
  if ( v6 == v8 )
  {
    if ( *a3 <= *a1 )
      return;
    v3 = a2;
    v4 = a3;
    v5 = a1;
    goto LABEL_225;
  }
  if ( v6 < v8 )
  {
    v3 = a2;
    v4 = a3;
    v5 = a1;
    goto LABEL_124;
  }
  if ( v7 == v8 )
  {
    if ( *a3 <= *a2 )
      return;
    v3 = a2;
    v4 = a3;
    v5 = a1;
    goto LABEL_268;
  }
  if ( v7 < v8 )
  {
    v3 = a2;
    v4 = a3;
    v5 = a1;
    goto LABEL_24;
  }
  v3 = a3;
  v4 = a1;
  v5 = a2;
LABEL_124:
  v60 = v3[1];
  v1174 = v60;
  if ( v60 >= 0 )
  {
    if ( v60 >= dword_DE568 )
      return;
    v1077 = dword_DE554 + dword_DE560 * v60;
    v1276 = 0;
  }
  else
  {
    v1077 = dword_DE554;
    v1276 = 1;
  }
  v61 = v5[1];
  v1280 = v61 > dword_DE568;
  v1089 = v61 - v60;
  v62 = v4[1];
  v1284 = v62 > dword_DE568;
  v63 = v62 - v60;
  v1093 = v63;
  v1098 = v63;
  v1079 = ((*v5 - *v3) << 16) / v1089;
  if ( ((*v4 - *v3) << 16) / v63 > v1079 )
  {
    v1083 = ((*v4 - *v3) << 16) / v63;
    v1087 = ((*v4 - *v5) << 16) / (v4[1] - v5[1]);
    v1095 = v4[1] - v5[1];
    v1097 = *v5 << 16;
    switch ( byte_E126D )
    {
      case 0:
      case 14:
      case 15:
        v102 = *v3 << 16;
        v103 = v102;
        if ( v1276 )
        {
          v16 = v1098 <= -v1174;
          v1098 += v1174;
          if ( v16 )
            return;
          v1146 = -v1174;
          if ( -v1174 - v1089 >= 0 )
          {
            v1147 = v1146 - v1089;
            v1095 -= v1147;
            v104 = v1087 * v1147 + v1097;
            v103 += v1147 * v1083 + v1089 * v1083;
            if ( v1284 )
            {
              v1095 = dword_DE568;
              v1098 = dword_DE568;
            }
            v105 = &unk_DE56C;
LABEL_219:
            if ( v1280 )
            {
              v29 = (unsigned __int8)byte_E126D;
              switch ( byte_E126D )
              {
                case 0:
                  goto LABEL_309;
                case 1:
                  goto LABEL_322;
                case 2:
                  goto LABEL_351;
                case 3:
                  goto LABEL_382;
                case 4:
                  goto LABEL_445;
                case 5:
                  goto LABEL_474;
                case 6:
                  goto LABEL_503;
                case 7:
                case 11:
                  goto LABEL_564;
                case 8:
                  goto LABEL_595;
                case 9:
                case 10:
                  goto LABEL_658;
                case 12:
                  goto LABEL_721;
                case 13:
                  goto LABEL_752;
                case 14:
                  goto LABEL_783;
                case 15:
                  goto LABEL_812;
                case 16:
                  goto LABEL_841;
                case 17:
                  goto LABEL_870;
                case 18:
                  goto LABEL_899;
                case 19:
                  goto LABEL_930;
                case 20:
                  goto LABEL_961;
                case 21:
                  goto LABEL_992;
                case 22:
                  goto LABEL_1023;
                case 23:
                  goto LABEL_1086;
                case 24:
                  goto LABEL_1149;
                case 25:
                  goto LABEL_1212;
                case 26:
                  goto LABEL_1275;
              }
            }
            do
            {
              *v105 = v104;
              v104 += v1087;
              v105[1] = v103;
              v103 += v1083;
              v105 += 5;
              --v1095;
            }
            while ( v1095 );
            v29 = (unsigned __int8)byte_E126D;
            switch ( byte_E126D )
            {
              case 0:
                goto LABEL_309;
              case 1:
                goto LABEL_322;
              case 2:
                goto LABEL_351;
              case 3:
                goto LABEL_382;
              case 4:
                goto LABEL_445;
              case 5:
                goto LABEL_474;
              case 6:
                goto LABEL_503;
              case 7:
              case 11:
                goto LABEL_564;
              case 8:
                goto LABEL_595;
              case 9:
              case 10:
                goto LABEL_658;
              case 12:
                goto LABEL_721;
              case 13:
                goto LABEL_752;
              case 14:
                goto LABEL_783;
              case 15:
                goto LABEL_812;
              case 16:
                goto LABEL_841;
              case 17:
                goto LABEL_870;
              case 18:
                goto LABEL_899;
              case 19:
                goto LABEL_930;
              case 20:
                goto LABEL_961;
              case 21:
                goto LABEL_992;
              case 22:
                goto LABEL_1023;
              case 23:
                goto LABEL_1086;
              case 24:
                goto LABEL_1149;
              case 25:
                goto LABEL_1212;
              case 26:
                goto LABEL_1275;
            }
          }
          v1089 += v1174;
          v102 += v1079 * v1146;
          v103 += v1146 * v1083;
          if ( v1284 )
          {
            v1098 = dword_DE568;
            if ( v1280 )
            {
              v1089 = dword_DE568;
            }
            else
            {
              v1280 = dword_DE568 <= v1089;
              v1095 = dword_DE568 - v1089;
            }
          }
        }
        else if ( v1284 )
        {
          v106 = dword_DE568 - v1174;
          v1098 = dword_DE568 - v1174;
          if ( v1280 )
          {
            v1089 = dword_DE568 - v1174;
          }
          else
          {
            v27 = __OFSUB__(v106, v1089);
            v107 = v106 - v1089;
            v1280 = (v107 < 0) ^ v27 | (v107 == 0);
            v1095 = v107;
          }
        }
        v105 = &unk_DE56C;
        do
        {
          *v105 = v102;
          v102 += v1079;
          v105[1] = v103;
          v103 += v1083;
          v105 += 5;
          --v1089;
        }
        while ( v1089 );
        v104 = v1097;
        goto LABEL_219;
      case 1:
      case 4:
      case 16:
      case 17:
        v91 = v1089 * (__int64)(*v4 - *v3) / v63;
        v92 = *v3 - *v5;
        v93 = v91 + v92 == 0;
        v16 = (v91 + v92 < 0) ^ __OFADD__(v91, v92);
        v94 = v91 + v92;
        if ( v16 )
          return;
        if ( !v93 )
          v1121 = (int)(v3[4] + v1089 * (__int64)(v4[4] - v3[4]) / v1093 - v5[4]) / (v94 + 1);
        v1125 = (v5[4] - v3[4]) / v1089;
        v1131 = (v4[4] - v5[4]) / v1095;
        v95 = *v3 << 16;
        v96 = v95;
        v97 = v3[4];
        if ( v1276 )
        {
          v16 = v1098 <= -v1174;
          v1098 += v1174;
          if ( v16 )
            return;
          v1144 = -v1174;
          if ( -v1174 - v1089 >= 0 )
          {
            v1145 = v1144 - v1089;
            v1095 -= v1145;
            v98 = v1087 * v1145 + v1097;
            v96 += v1145 * v1083 + v1089 * v1083;
            v97 += v1145 * v1131 + v1089 * v1125;
            if ( v1284 )
            {
              v1095 = dword_DE568;
              v1098 = dword_DE568;
            }
            v99 = &unk_DE56C;
LABEL_198:
            if ( v1280 )
            {
              v29 = (unsigned __int8)byte_E126D;
              switch ( byte_E126D )
              {
                case 0:
                  goto LABEL_309;
                case 1:
                  goto LABEL_322;
                case 2:
                  goto LABEL_351;
                case 3:
                  goto LABEL_382;
                case 4:
                  goto LABEL_445;
                case 5:
                  goto LABEL_474;
                case 6:
                  goto LABEL_503;
                case 7:
                case 11:
                  goto LABEL_564;
                case 8:
                  goto LABEL_595;
                case 9:
                case 10:
                  goto LABEL_658;
                case 12:
                  goto LABEL_721;
                case 13:
                  goto LABEL_752;
                case 14:
                  goto LABEL_783;
                case 15:
                  goto LABEL_812;
                case 16:
                  goto LABEL_841;
                case 17:
                  goto LABEL_870;
                case 18:
                  goto LABEL_899;
                case 19:
                  goto LABEL_930;
                case 20:
                  goto LABEL_961;
                case 21:
                  goto LABEL_992;
                case 22:
                  goto LABEL_1023;
                case 23:
                  goto LABEL_1086;
                case 24:
                  goto LABEL_1149;
                case 25:
                  goto LABEL_1212;
                case 26:
                  goto LABEL_1275;
              }
            }
            do
            {
              *v99 = v98;
              v98 += v1087;
              v99[1] = v96;
              v96 += v1083;
              v99[4] = v97;
              v97 += v1131;
              v99 += 5;
              --v1095;
            }
            while ( v1095 );
            v29 = (unsigned __int8)byte_E126D;
            switch ( byte_E126D )
            {
              case 0:
                goto LABEL_309;
              case 1:
                goto LABEL_322;
              case 2:
                goto LABEL_351;
              case 3:
                goto LABEL_382;
              case 4:
                goto LABEL_445;
              case 5:
                goto LABEL_474;
              case 6:
                goto LABEL_503;
              case 7:
              case 11:
                goto LABEL_564;
              case 8:
                goto LABEL_595;
              case 9:
              case 10:
                goto LABEL_658;
              case 12:
                goto LABEL_721;
              case 13:
                goto LABEL_752;
              case 14:
                goto LABEL_783;
              case 15:
                goto LABEL_812;
              case 16:
                goto LABEL_841;
              case 17:
                goto LABEL_870;
              case 18:
                goto LABEL_899;
              case 19:
                goto LABEL_930;
              case 20:
                goto LABEL_961;
              case 21:
                goto LABEL_992;
              case 22:
                goto LABEL_1023;
              case 23:
                goto LABEL_1086;
              case 24:
                goto LABEL_1149;
              case 25:
                goto LABEL_1212;
              case 26:
                goto LABEL_1275;
            }
          }
          v1089 += v1174;
          v95 += v1079 * v1144;
          v96 += v1144 * v1083;
          v97 += v1144 * v1125;
          if ( v1284 )
          {
            v1098 = dword_DE568;
            if ( v1280 )
            {
              v1089 = dword_DE568;
            }
            else
            {
              v1280 = dword_DE568 <= v1089;
              v1095 = dword_DE568 - v1089;
            }
          }
        }
        else if ( v1284 )
        {
          v100 = dword_DE568 - v1174;
          v1098 = dword_DE568 - v1174;
          if ( v1280 )
          {
            v1089 = dword_DE568 - v1174;
          }
          else
          {
            v27 = __OFSUB__(v100, v1089);
            v101 = v100 - v1089;
            v1280 = (v101 < 0) ^ v27 | (v101 == 0);
            v1095 = v101;
          }
        }
        v99 = &unk_DE56C;
        do
        {
          *v99 = v95;
          v95 += v1079;
          v99[1] = v96;
          v96 += v1083;
          v99[4] = v97;
          v97 += v1125;
          v99 += 5;
          --v1089;
        }
        while ( v1089 );
        v98 = v1097;
        goto LABEL_198;
      case 2:
      case 3:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 18:
      case 19:
      case 22:
      case 23:
        v78 = v1089 * (__int64)(*v4 - *v3) / v63;
        v79 = *v3 - *v5;
        v80 = v78 + v79 == 0;
        v16 = (v78 + v79 < 0) ^ __OFADD__(v78, v79);
        v81 = v78 + v79;
        if ( v16 )
          return;
        if ( !v80 )
        {
          v82 = v81 + 1;
          v1099 = (int)(v3[2] + v1089 * (__int64)(v4[2] - v3[2]) / v1093 - v5[2]) / v82;
          v1110 = (int)(v3[3] + v1089 * (__int64)(v4[3] - v3[3]) / v1093 - v5[3]) / v82;
        }
        v1103 = (v5[2] - v3[2]) / v1089;
        v1114 = (v5[3] - v3[3]) / v1089;
        v1109 = (v4[2] - v5[2]) / v1095;
        v1120 = (v4[3] - v5[3]) / v1095;
        v83 = *v3 << 16;
        v84 = v83;
        v85 = v3[2];
        v86 = v3[3];
        if ( v1276 )
        {
          v16 = v1098 <= -v1174;
          v1098 += v1174;
          if ( v16 )
            return;
          v1142 = -v1174;
          if ( -v1174 - v1089 >= 0 )
          {
            v1143 = v1142 - v1089;
            v1095 -= v1143;
            v87 = v1087 * v1143 + v1097;
            v84 += v1143 * v1083 + v1089 * v1083;
            v85 += v1143 * v1109 + v1089 * v1103;
            v86 += v1143 * v1120 + v1089 * v1114;
            if ( v1284 )
            {
              v1095 = dword_DE568;
              v1098 = dword_DE568;
            }
            v88 = &unk_DE56C;
LABEL_174:
            if ( v1280 )
            {
              v29 = (unsigned __int8)byte_E126D;
              switch ( byte_E126D )
              {
                case 0:
                  goto LABEL_309;
                case 1:
                  goto LABEL_322;
                case 2:
                  goto LABEL_351;
                case 3:
                  goto LABEL_382;
                case 4:
                  goto LABEL_445;
                case 5:
                  goto LABEL_474;
                case 6:
                  goto LABEL_503;
                case 7:
                case 11:
                  goto LABEL_564;
                case 8:
                  goto LABEL_595;
                case 9:
                case 10:
                  goto LABEL_658;
                case 12:
                  goto LABEL_721;
                case 13:
                  goto LABEL_752;
                case 14:
                  goto LABEL_783;
                case 15:
                  goto LABEL_812;
                case 16:
                  goto LABEL_841;
                case 17:
                  goto LABEL_870;
                case 18:
                  goto LABEL_899;
                case 19:
                  goto LABEL_930;
                case 20:
                  goto LABEL_961;
                case 21:
                  goto LABEL_992;
                case 22:
                  goto LABEL_1023;
                case 23:
                  goto LABEL_1086;
                case 24:
                  goto LABEL_1149;
                case 25:
                  goto LABEL_1212;
                case 26:
                  goto LABEL_1275;
              }
            }
            do
            {
              *v88 = v87;
              v87 += v1087;
              v88[1] = v84;
              v84 += v1083;
              v88[2] = v85;
              v85 += v1109;
              v88[3] = v86;
              v86 += v1120;
              v88 += 5;
              --v1095;
            }
            while ( v1095 );
            v29 = (unsigned __int8)byte_E126D;
            switch ( byte_E126D )
            {
              case 0:
                goto LABEL_309;
              case 1:
                goto LABEL_322;
              case 2:
                goto LABEL_351;
              case 3:
                goto LABEL_382;
              case 4:
                goto LABEL_445;
              case 5:
                goto LABEL_474;
              case 6:
                goto LABEL_503;
              case 7:
              case 11:
                goto LABEL_564;
              case 8:
                goto LABEL_595;
              case 9:
              case 10:
                goto LABEL_658;
              case 12:
                goto LABEL_721;
              case 13:
                goto LABEL_752;
              case 14:
                goto LABEL_783;
              case 15:
                goto LABEL_812;
              case 16:
                goto LABEL_841;
              case 17:
                goto LABEL_870;
              case 18:
                goto LABEL_899;
              case 19:
                goto LABEL_930;
              case 20:
                goto LABEL_961;
              case 21:
                goto LABEL_992;
              case 22:
                goto LABEL_1023;
              case 23:
                goto LABEL_1086;
              case 24:
                goto LABEL_1149;
              case 25:
                goto LABEL_1212;
              case 26:
                goto LABEL_1275;
            }
          }
          v1089 += v1174;
          v83 += v1079 * v1142;
          v84 += v1142 * v1083;
          v85 += v1142 * v1103;
          v86 += v1142 * v1114;
          if ( v1284 )
          {
            v1098 = dword_DE568;
            if ( v1280 )
            {
              v1089 = dword_DE568;
            }
            else
            {
              v1280 = dword_DE568 <= v1089;
              v1095 = dword_DE568 - v1089;
            }
          }
        }
        else if ( v1284 )
        {
          v89 = dword_DE568 - v1174;
          v1098 = dword_DE568 - v1174;
          if ( v1280 )
          {
            v1089 = dword_DE568 - v1174;
          }
          else
          {
            v27 = __OFSUB__(v89, v1089);
            v90 = v89 - v1089;
            v1280 = (v90 < 0) ^ v27 | (v90 == 0);
            v1095 = v90;
          }
        }
        v88 = &unk_DE56C;
        do
        {
          *v88 = v83;
          v83 += v1079;
          v88[1] = v84;
          v84 += v1083;
          v88[2] = v85;
          v85 += v1103;
          v88[3] = v86;
          v86 += v1114;
          v88 += 5;
          --v1089;
        }
        while ( v1089 );
        v87 = v1097;
        goto LABEL_174;
      case 5:
      case 6:
      case 20:
      case 21:
      case 24:
      case 25:
      case 26:
        v64 = v1089 * (__int64)(*v4 - *v3) / v63;
        v65 = *v3 - *v5;
        v66 = v64 + v65 == 0;
        v16 = (v64 + v65 < 0) ^ __OFADD__(v64, v65);
        v67 = v64 + v65;
        if ( v16 )
          return;
        if ( !v66 )
        {
          v68 = v67 + 1;
          v1099 = (int)(v3[2] + v1089 * (__int64)(v4[2] - v3[2]) / v1093 - v5[2]) / v68;
          v1110 = (int)(v3[3] + v1089 * (__int64)(v4[3] - v3[3]) / v1093 - v5[3]) / v68;
          v64 = (int)(v3[4] + v1089 * (__int64)(v4[4] - v3[4]) / v1093 - v5[4]) / v68;
        }
        v1121 = v64;
        v1102 = (v5[2] - v3[2]) / v1089;
        v1113 = (v5[3] - v3[3]) / v1089;
        v1124 = (v5[4] - v3[4]) / v1089;
        v1108 = (v4[2] - v5[2]) / v1095;
        v1119 = (v4[3] - v5[3]) / v1095;
        v1130 = (v4[4] - v5[4]) / v1095;
        v69 = *v3 << 16;
        v70 = v69;
        v71 = v3[2];
        v72 = v3[3];
        v73 = v3[4];
        if ( v1276 )
        {
          v16 = v1098 <= -v1174;
          v1098 += v1174;
          if ( v16 )
            return;
          v1140 = -v1174;
          if ( -v1174 - v1089 >= 0 )
          {
            v1141 = v1140 - v1089;
            v1095 -= v1141;
            v74 = v1087 * v1141 + v1097;
            v70 += v1141 * v1083 + v1089 * v1083;
            v71 += v1141 * v1108 + v1089 * v1102;
            v72 += v1141 * v1119 + v1089 * v1113;
            v73 += v1141 * v1130 + v1089 * v1124;
            if ( v1284 )
            {
              v1095 = dword_DE568;
              v1098 = dword_DE568;
            }
            v75 = &unk_DE56C;
LABEL_150:
            if ( v1280 )
            {
              v29 = (unsigned __int8)byte_E126D;
              switch ( byte_E126D )
              {
                case 0:
                  goto LABEL_309;
                case 1:
                  goto LABEL_322;
                case 2:
                  goto LABEL_351;
                case 3:
                  goto LABEL_382;
                case 4:
                  goto LABEL_445;
                case 5:
                  goto LABEL_474;
                case 6:
                  goto LABEL_503;
                case 7:
                case 11:
                  goto LABEL_564;
                case 8:
                  goto LABEL_595;
                case 9:
                case 10:
                  goto LABEL_658;
                case 12:
                  goto LABEL_721;
                case 13:
                  goto LABEL_752;
                case 14:
                  goto LABEL_783;
                case 15:
                  goto LABEL_812;
                case 16:
                  goto LABEL_841;
                case 17:
                  goto LABEL_870;
                case 18:
                  goto LABEL_899;
                case 19:
                  goto LABEL_930;
                case 20:
                  goto LABEL_961;
                case 21:
                  goto LABEL_992;
                case 22:
                  goto LABEL_1023;
                case 23:
                  goto LABEL_1086;
                case 24:
                  goto LABEL_1149;
                case 25:
                  goto LABEL_1212;
                case 26:
                  goto LABEL_1275;
              }
            }
            do
            {
              *v75 = v74;
              v74 += v1087;
              v75[1] = v70;
              v70 += v1083;
              v75[2] = v71;
              v71 += v1108;
              v75[3] = v72;
              v72 += v1119;
              v75[4] = v73;
              v73 += v1130;
              v75 += 5;
              --v1095;
            }
            while ( v1095 );
            v29 = (unsigned __int8)byte_E126D;
            switch ( byte_E126D )
            {
              case 0:
                goto LABEL_309;
              case 1:
                goto LABEL_322;
              case 2:
                goto LABEL_351;
              case 3:
                goto LABEL_382;
              case 4:
                goto LABEL_445;
              case 5:
                goto LABEL_474;
              case 6:
                goto LABEL_503;
              case 7:
              case 11:
                goto LABEL_564;
              case 8:
                goto LABEL_595;
              case 9:
              case 10:
                goto LABEL_658;
              case 12:
                goto LABEL_721;
              case 13:
                goto LABEL_752;
              case 14:
                goto LABEL_783;
              case 15:
                goto LABEL_812;
              case 16:
                goto LABEL_841;
              case 17:
                goto LABEL_870;
              case 18:
                goto LABEL_899;
              case 19:
                goto LABEL_930;
              case 20:
                goto LABEL_961;
              case 21:
                goto LABEL_992;
              case 22:
                goto LABEL_1023;
              case 23:
                goto LABEL_1086;
              case 24:
                goto LABEL_1149;
              case 25:
                goto LABEL_1212;
              case 26:
                goto LABEL_1275;
            }
          }
          v1089 += v1174;
          v69 += v1079 * v1140;
          v70 += v1140 * v1083;
          v71 += v1140 * v1102;
          v72 += v1140 * v1113;
          v73 += v1140 * v1124;
          if ( v1284 )
          {
            v1098 = dword_DE568;
            if ( v1280 )
            {
              v1089 = dword_DE568;
            }
            else
            {
              v1280 = dword_DE568 <= v1089;
              v1095 = dword_DE568 - v1089;
            }
          }
        }
        else if ( v1284 )
        {
          v76 = dword_DE568 - v1174;
          v1098 = dword_DE568 - v1174;
          if ( v1280 )
          {
            v1089 = dword_DE568 - v1174;
          }
          else
          {
            v27 = __OFSUB__(v76, v1089);
            v77 = v76 - v1089;
            v1280 = (v77 < 0) ^ v27 | (v77 == 0);
            v1095 = v77;
          }
        }
        v75 = &unk_DE56C;
        do
        {
          *v75 = v69;
          v69 += v1079;
          v75[1] = v70;
          v70 += v1083;
          v75[2] = v71;
          v71 += v1102;
          v75[3] = v72;
          v72 += v1113;
          v75[4] = v73;
          v73 += v1124;
          v75 += 5;
          --v1089;
        }
        while ( v1089 );
        v74 = v1097;
        goto LABEL_150;
    }
  }
}
// B7F1B: variable 'v1121' is possibly undefined
// B80B2: variable 'v1110' is possibly undefined
// B80F3: variable 'v1099' is possibly undefined
// B8845: using guessed type int dword_B8845[];
// DE554: using guessed type int dword_DE554;
// DE55C: using guessed type int dword_DE55C;
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;
// E126C: using guessed type char byte_E126C;
// E126D: using guessed type char byte_E126D;

//----- (000BCD45) --------------------------------------------------------
void __cdecl __spoils<> sub_BCD45(int a1, int a2, int a3, int a4, int a5)
{
  if ( a3 )
    dword_DE560 = a3;
  if ( a1 )
  {
    dword_DE558 = a1;
    dword_DE554 = a1 - dword_DE560;
  }
  if ( a2 )
    dword_DE55C = a2;
  if ( a5 )
    dword_DE568 = a5;
  if ( a4 )
    dword_DE564 = a4;
}
// DE554: using guessed type int dword_DE554;
// DE558: using guessed type int dword_DE558;
// DE55C: using guessed type int dword_DE55C;
// DE560: using guessed type int dword_DE560;
// DE564: using guessed type int dword_DE564;
// DE568: using guessed type int dword_DE568;

//----- (000BD1B6) --------------------------------------------------------
void __cdecl __spoils<> sub_BD1B6(int a1)
{
  _BYTE *v1; // ecx
  _BYTE *v2; // edx
  int v3; // [esp-30h] [ebp-3Ch]
  int v4; // [esp-30h] [ebp-3Ch]
  int v5; // [esp-30h] [ebp-3Ch]
  int v6; // [esp-30h] [ebp-3Ch]
  int v7; // [esp-30h] [ebp-3Ch]
  int v8; // [esp-30h] [ebp-3Ch]
  int v9; // [esp-30h] [ebp-3Ch]
  int v10; // [esp-30h] [ebp-3Ch]
  int v11; // [esp-30h] [ebp-3Ch]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  sub_9951B(0);
  v1 = (_BYTE *)dword_E9C3C;
  v2 = (_BYTE *)dword_180628;
  v3 = sub_BD320(0, (_BYTE *)dword_180628, (_BYTE *)dword_E9C3C, 0, (int)&savedregs, a1);
  sub_9951B(1);
  v4 = sub_BD320(v3, v2, v1, 0, (int)&savedregs, a1);
  sub_9951B(2);
  v5 = sub_BD320(v4, v2, v1, 0, (int)&savedregs, a1);
  sub_9951B(3);
  v6 = sub_BD320(v5, v2, v1, 0, (int)&savedregs, a1);
  sub_9951B(4);
  v7 = sub_BD320(v6, v2, v1, 0, (int)&savedregs, a1);
  sub_9951B(5);
  v8 = sub_BD320(v7, v2, v1, 0, (int)&savedregs, a1);
  sub_9951B(6);
  v9 = sub_BD320(v8, v2, v1, 0, (int)&savedregs, a1);
  sub_9951B(7);
  v10 = sub_BD320(v9, v2, v1, 0, (int)&savedregs, a1);
  sub_9951B(8);
  v11 = sub_BD320(v10, v2, v1, 0, (int)&savedregs, a1);
  sub_9951B(9);
  sub_BD320(v11, v2, v1, 0, (int)&savedregs, a1);
}
// E9C3C: using guessed type int dword_E9C3C;
// 180628: using guessed type int dword_180628;

//----- (000BD2CB) --------------------------------------------------------
void __cdecl __spoils<> sub_BD2CB(int a1)
{
  _BYTE *v1; // ecx
  _BYTE *v2; // edx
  int v3; // [esp-30h] [ebp-3Ch]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  sub_9951B(0);
  v1 = (_BYTE *)dword_E9C3C;
  v2 = (_BYTE *)dword_180628;
  v3 = sub_BD320(0, (_BYTE *)dword_180628, (_BYTE *)dword_E9C3C, 0, (int)&savedregs, a1);
  sub_9951B(1);
  sub_BD320(v3, v2, v1, 0, (int)&savedregs, a1);
}
// E9C3C: using guessed type int dword_E9C3C;
// 180628: using guessed type int dword_180628;

//----- (000BD320) --------------------------------------------------------
int __usercall sub_BD320@<eax>(
        int result@<eax>,
        _BYTE *a2@<edx>,
        _BYTE *a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<esi>)
{
  int *v6; // edi
  int v7; // eax

  v6 = (int *)&loc_A0000;
  do
  {
    LOBYTE(a4) = a3[1];
    LOWORD(result) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[1];
    LOWORD(result) = *(_WORD *)(a6 + 2 * a4 + 512) + result;
    v7 = result << 16;
    LOBYTE(a4) = *a3;
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = *a2;
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    *v6 = v7;
    LOBYTE(a4) = a3[3];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[3];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    v7 <<= 16;
    LOBYTE(a4) = a3[2];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[2];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    v6[1] = v7;
    LOBYTE(a4) = a3[5];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[5];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    v7 <<= 16;
    LOBYTE(a4) = a3[4];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[4];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    v6[2] = v7;
    LOBYTE(a4) = a3[7];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[7];
    LOWORD(v7) = *(_WORD *)(a6 + 2 * a4 + 512) + v7;
    result = v7 << 16;
    LOBYTE(a4) = a3[6];
    LOWORD(result) = *(_WORD *)(a6 + 2 * a4);
    LOBYTE(a4) = a2[6];
    LOWORD(result) = *(_WORD *)(a6 + 2 * a4 + 512) + result;
    v6[3] = result;
    a3 += 8;
    a2 += 8;
    v6 += 4;
  }
  while ( (*(_DWORD *)(a5 - 4))-- != 1 );
  return result;
}

//----- (000BD3DD) --------------------------------------------------------
void sub_BD3DD()
{
  char *v0; // edi
  char *v1; // esi
  int v2; // edx
  char *v3; // esi
  char *v4; // esi
  char *v5; // edi
  int v6; // edx
  char *v7; // esi
  char *v8; // esi
  char *v9; // edi
  int v10; // edx
  char *v11; // edi
  int v12; // edx
  char *v13; // edi
  int v14; // edx

  if ( !byte_E3766 )
    sub_8CACD();
  sub_9951B(0);
  v0 = (char *)&loc_A0000 + 51200;
  v1 = (char *)dword_180628;
  v2 = 11;
  do
  {
    qmemcpy(v0, v1, 0x280u);
    v1 += 1280;
    v0 += 1280;
    --v2;
  }
  while ( v2 );
  qmemcpy(v0, v1, 0x100u);
  v3 = v1 + 256;
  sub_9951B(1);
  qmemcpy(&loc_A0000, v3, 0x180u);
  v4 = v3 + 1024;
  v5 = (char *)&loc_A0000 + 1024;
  v6 = 50;
  do
  {
    qmemcpy(v5, v4, 0x280u);
    v4 += 1280;
    v5 += 1280;
    --v6;
  }
  while ( v6 );
  qmemcpy(v5, v4, 0x200u);
  v7 = v4 + 512;
  sub_9951B(2);
  qmemcpy(&loc_A0000, v7, 0x80u);
  v8 = v7 + 768;
  v9 = (char *)&loc_A0000 + 768;
  v10 = 51;
  do
  {
    qmemcpy(v9, v8, 0x280u);
    v8 += 1280;
    v9 += 1280;
    --v10;
  }
  while ( v10 );
  sub_9951B(3);
  v11 = (char *)&loc_A0000 + 512;
  v12 = 51;
  do
  {
    qmemcpy(v11, v8, 0x280u);
    v8 += 1280;
    v11 += 1280;
    --v12;
  }
  while ( v12 );
  sub_9951B(4);
  v13 = (char *)&loc_A0000 + 256;
  v14 = 34;
  do
  {
    qmemcpy(v13, v8, 0x280u);
    v8 += 1280;
    v13 += 1280;
    --v14;
  }
  while ( v14 );
  if ( !byte_E3766 )
    sub_8CB1F();
}
// E3766: using guessed type char byte_E3766;
// 180628: using guessed type int dword_180628;

//----- (000BD524) --------------------------------------------------------
void sub_BD524()
{
  JUMPOUT(0xBD550);
}
// BD540: control flows out of bounds to BD550

//----- (000BD542) --------------------------------------------------------
void __cdecl __spoils<> sub_BD542(
        unsigned __int16 a1,
        unsigned __int16 a2,
        unsigned __int16 a3,
        unsigned __int16 a4,
        char a5)
{
  __int16 v5; // bx
  __int16 v6; // cx
  unsigned __int16 v7; // cx
  unsigned __int16 v8; // ax
  unsigned __int16 v9; // ax
  _BYTE *v10; // edi
  int v11; // esi
  unsigned __int16 v12; // ax
  unsigned __int16 v13; // cx
  unsigned __int16 v14; // si
  __int16 v15; // dx
  __int16 v16; // bx
  __int16 v17; // cx
  int v18; // edi
  unsigned int v19; // ecx
  __int16 v20; // ax
  int v21; // eax
  int v22; // ecx
  __int16 v23; // cx
  _BYTE *v24; // edi
  int v25; // [esp+0h] [ebp-Ch]
  int v26; // [esp+4h] [ebp-8h]
  int v27; // [esp+8h] [ebp-4h]

  v27 = dword_180628 + dword_18063C + dword_18062C * dword_180650;
  v5 = a2;
  if ( (a2 & 0x8000u) == 0 )
  {
    v7 = a4;
    if ( (a4 & 0x8000u) == 0 )
    {
      if ( a2 == a4 )
      {
        if ( (__int16)a2 >= (__int16)dword_180644 )
          return;
        v18 = a1;
        v19 = a3;
        if ( a3 < a1 )
        {
          LOWORD(v19) = a1;
          LOWORD(v18) = a3;
        }
        v20 = dword_180648 - 1;
        if ( (v18 & 0x8000u) == 0 )
        {
          if ( (__int16)v18 > v20 )
            return;
          if ( (unsigned __int16)v19 > (unsigned __int16)v20 )
            LOWORD(v19) = dword_180648 - 1;
        }
        else
        {
          if ( (__int16)v19 <= 0 )
            return;
          LOWORD(v18) = 0;
          if ( (unsigned __int16)v19 > (unsigned __int16)v20 )
            LOWORD(v19) = dword_180648 - 1;
        }
        LOWORD(v19) = v19 - v18;
        goto LABEL_54;
      }
      if ( (__int16)(a2 - a4) < 0 )
      {
        if ( (__int16)a2 >= (__int16)dword_180644 )
          return;
        if ( (__int16)a4 >= (__int16)dword_180644 )
          goto LABEL_5;
      }
      else
      {
        if ( (__int16)a4 >= (__int16)dword_180644 )
          return;
        a4 = a2;
        a2 = v7;
        v9 = a1;
        a1 = a3;
        a3 = v9;
        if ( v5 >= (__int16)dword_180644 )
          goto LABEL_5;
      }
      goto LABEL_15;
    }
    a4 = a2;
    v5 = v7;
    v6 = a2;
    v8 = a1;
    a1 = a3;
    a3 = v8;
  }
  else
  {
    v6 = a4;
  }
  if ( v6 < 0 )
    return;
  a1 += (__int16)-v5 * (__int16)(a3 - a1) / (__int16)(v6 - v5);
  a2 = 0;
  if ( (__int16)(a4 - dword_180644) >= 0 )
  {
LABEL_5:
    a3 = a1 + (__int16)(dword_180644 - a2) * (__int16)(a3 - a1) / (__int16)(a4 - a2);
    a4 = dword_180644 - 1;
  }
LABEL_15:
  if ( (a1 & 0x8000u) == 0 )
  {
    if ( (__int16)(a1 - dword_180648) < 0 )
    {
      if ( (a3 & 0x8000u) == 0 )
      {
        if ( (__int16)(a3 - dword_180648) < 0 )
        {
          v26 = 1;
          if ( a1 == a3 )
          {
            v21 = a2;
            v22 = a4;
            if ( a4 >= a2 )
            {
              v23 = a4 - a2;
            }
            else
            {
              LOWORD(v21) = a4;
              v23 = a2 - a4;
            }
            v24 = (_BYTE *)(v27 + dword_18062C * v21 + a1);
            LOWORD(v22) = v23 + 1;
            do
            {
              *v24 = a5;
              v24 += dword_18062C;
              --v22;
            }
            while ( v22 );
            return;
          }
          if ( (__int16)(a1 - a3) >= 0 )
            v26 = -1;
        }
        else
        {
          v26 = 1;
          a4 = a2 + (__int16)(dword_180648 - a1) * (__int16)(a4 - a2) / (__int16)(a3 - a1);
          a3 = dword_180648 - 1;
        }
      }
      else
      {
        v26 = -1;
        a4 = a2 + (__int16)a1 * (__int16)(a4 - a2) / (__int16)(a1 - a3);
        a3 = 0;
      }
    }
    else
    {
      if ( (__int16)a3 >= (__int16)dword_180648 )
        return;
      v26 = -1;
      a2 += (__int16)(a1 - dword_180648) * (__int16)(a4 - a2) / (__int16)(a1 - a3);
      a1 = dword_180648 - 1;
      if ( (a3 & 0x8000u) != 0 )
      {
        a4 -= (__int16)-a3 * (__int16)(a4 - a2) / (__int16)(a1 - a3);
        a3 = 0;
      }
    }
  }
  else
  {
    if ( (a3 & 0x8000u) != 0 )
      return;
    v26 = 1;
    a2 += (__int16)-a1 * (__int16)(a4 - a2) / (__int16)(a3 - a1);
    a1 = 0;
    if ( (__int16)(a3 - dword_180648) >= 0 )
    {
      a4 = a2 + (__int16)dword_180648 * (__int16)(a4 - a2) / (__int16)a3;
      a3 = dword_180648 - 1;
    }
  }
  v10 = (_BYTE *)(v27 + dword_18062C * a2 + a1);
  v11 = v26;
  v12 = v26 * (a3 - a1);
  v13 = a4 - a2;
  if ( a4 == a2 )
  {
    v18 = a1;
    v19 = a3;
    if ( a3 >= a1 )
    {
      LOWORD(v19) = a3 - a1;
    }
    else
    {
      LOWORD(v18) = a3;
      LOWORD(v19) = a1 - a3;
    }
LABEL_54:
    LOWORD(v19) = v19 + 1;
    memset((void *)(v27 + dword_18062C * a2 + v18), a5, v19);
    return;
  }
  if ( v13 <= v12 )
  {
    v25 = dword_18062C;
  }
  else
  {
    v12 = a4 - a2;
    v13 = v26 * (a3 - a1);
    v26 = dword_18062C;
    v25 = v11;
  }
  v14 = v12;
  v15 = 2 * v13;
  v16 = 2 * v13 - v12;
  v17 = 2 * (v13 - v12);
  *v10 = a5;
  do
  {
    while ( 1 )
    {
      v10 += v26;
      if ( v16 >= 0 )
        break;
      v16 += v15;
      *v10 = a5;
      if ( !--v14 )
        return;
    }
    v10 += v25;
    v16 += v17;
    *v10 = a5;
    --v14;
  }
  while ( v14 );
}
// 180628: using guessed type int dword_180628;
// 18062C: using guessed type int dword_18062C;
// 18063C: using guessed type int dword_18063C;
// 180644: using guessed type int dword_180644;
// 180648: using guessed type int dword_180648;
// 180650: using guessed type int dword_180650;

//----- (000BF123) --------------------------------------------------------
int sub_BF123()
{
  return dword_E4C94;
}
// E4C94: using guessed type int dword_E4C94;

//----- (000C0113) --------------------------------------------------------
#error "C0113: only 32bit functions can be decompiled (funcsize=0)"

//----- (000C0117) --------------------------------------------------------
#error "C0117: only 32bit functions can be decompiled (funcsize=0)"

// nfuncs=2915 queued=2383 decompiled=2383 lumina nreq=0 worse=0 better=0
#error "There were 3 decompilation failure(s) on 2383 function(s)"
